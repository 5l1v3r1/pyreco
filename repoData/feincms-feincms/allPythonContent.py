__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# FeinCMS documentation build configuration file, created by
# sphinx-quickstart on Mon Aug 10 17:03:33 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath('.'))
sys.path.append(os.path.abspath('..'))
os.environ['DJANGO_SETTINGS_MODULE'] = 'example.settings'

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'FeinCMS'
copyright = u'2009-2010, Feinheit GmbH and contributors'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))
import feincms

version = '.'.join(map(str, feincms.VERSION))
# The full version, including alpha/beta/rc tags.
release = feincms.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme_path = ['_theme']
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'FeinCMSdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
latex_paper_size = 'a4'

# The font size ('10pt', '11pt' or '12pt').
latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [(
    'index', 'FeinCMS.tex', u'FeinCMS Documentation',
    u'Feinheit GmbH and contributors', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from feincms.admin import tree_editor

from example.models import Category


class CategoryAdmin(tree_editor.TreeEditor):
    list_display = ('name', 'slug')
    list_filter = ('parent',)
    prepopulated_fields = {
        'slug': ('name',),
    }

admin.site.register(Category, CategoryAdmin)

########NEW FILE########
__FILENAME__ = blog_urls
from django.conf.urls import patterns, url
from django.views import generic

from feincms.module.blog.models import Entry


urlpatterns = patterns(
    '',
    url(r'^(?P<pk>\d+)/', generic.DetailView.as_view(
        queryset=Entry.objects.all(),
        ), name='blog_entry_detail'),
    url(r'^$', generic.ListView.as_view(
        queryset=Entry.objects.all(),
        ), name='blog_entry_list'),
)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

sys.path.insert(
    0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'example.settings')

from django.core.management import execute_from_command_line

execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = generate_big_tree
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import print_function

from django.core.management.base import NoArgsCommand

from feincms.module.page.models import Page


class Command(NoArgsCommand):
    help = (
        "Run this command to generate a big tree for performance testing"
        " purposes.")

    def handle_noargs(self, **options):
        parents = [None] * 5

        Page.objects.all().delete()

        for i1 in range(5):
            parents[0] = Page.objects.create(
                title='Page %s' % (i1,),
            )

            for i2 in range(5):
                parents[1] = Page.objects.create(
                    title='Page %s.%s' % (i1, i2),
                    parent=parents[0],
                )

                for i3 in range(5):
                    parents[2] = Page.objects.create(
                        title='Page %s.%s.%s' % (i1, i2, i3),
                        parent=parents[1],
                    )

                    for i4 in range(5):
                        parents[3] = Page.objects.create(
                            title='Page %s.%s.%s.%s' % (i1, i2, i3, i4),
                            parent=parents[2],
                        )

                print(parents)

########NEW FILE########
__FILENAME__ = models
from django import forms
from django.db import models
from django.utils.encoding import python_2_unicode_compatible
from django.utils.text import capfirst
from django.utils.translation import ugettext_lazy as _

from mptt.models import MPTTModel

from feincms.module.blog.models import Entry, EntryAdmin
from feincms.module.page.models import Page
from feincms.content.raw.models import RawContent
from feincms.content.image.models import ImageContent
from feincms.content.medialibrary.models import MediaFileContent
from feincms.content.application.models import ApplicationContent
from feincms.module.page.extensions.navigation import (
    NavigationExtension, PagePretender)
from feincms.content.application.models import app_reverse


Page.register_templates({
    'key': 'base',
    'title': 'Base Template',
    'path': 'base.html',
    'regions': (
        ('main', 'Main region'),
        ('sidebar', 'Sidebar', 'inherited'),
    ),
})
Page.create_content_type(RawContent)
Page.create_content_type(
    MediaFileContent,
    TYPE_CHOICES=(
        ('default', 'Default position'),
    ),
)
Page.create_content_type(
    ImageContent,
    POSITION_CHOICES=(
        ('default', 'Default position'),
    ),
)


def get_admin_fields(form, *args, **kwargs):
    return {
        'exclusive_subpages': forms.BooleanField(
            label=capfirst(_('exclusive subpages')),
            required=False,
            initial=form.instance.parameters.get('exclusive_subpages', False),
            help_text=_(
                'Exclude everything other than the application\'s'
                ' content when rendering subpages.'),
        ),
    }


Page.create_content_type(ApplicationContent, APPLICATIONS=(
    ('blog_urls', 'Blog', {
        'admin_fields': get_admin_fields,
        'urls': 'example.blog_urls',
    }),
))


Entry.register_regions(
    ('main', 'Main region'),
)
Entry.create_content_type(RawContent)
Entry.create_content_type(
    ImageContent,
    POSITION_CHOICES=(
        ('default', 'Default position'),
    )
)


class BlogEntriesNavigationExtension(NavigationExtension):
    """
    Extended navigation for blog entries.

    It would be added to 'Blog' page properties in admin.
    """
    name = _('all blog entries')

    def children(self, page, **kwargs):
        for entry in Entry.objects.all():
            yield PagePretender(
                title=entry.title,
                url=app_reverse(
                    'blog_entry_detail', 'blog_urls', kwargs={'pk': entry.id}),
                level=page.level + 1,
            )

Page.register_extensions(
    'feincms.module.page.extensions.navigation',
    'feincms.module.page.extensions.sites',
)


@python_2_unicode_compatible
class Category(MPTTModel):
    name = models.CharField(max_length=20)
    slug = models.SlugField()
    parent = models.ForeignKey(
        'self', blank=True, null=True, related_name='children')

    class Meta:
        ordering = ['tree_id', 'lft']
        verbose_name = 'category'
        verbose_name_plural = 'categories'

    def __str__(self):
        return self.name


# add m2m field to entry so it shows up in entry admin
Entry.add_to_class(
    'categories',
    models.ManyToManyField(Category, blank=True, null=True))
EntryAdmin.list_filter += ('categories',)

########NEW FILE########
__FILENAME__ = settings
# Django settings for example project.

import os

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

MANAGERS = ADMINS

DATABASE_ENGINE = 'sqlite3'
DATABASE_NAME = os.path.join(os.path.dirname(__file__), 'example.db')

DATABASES = {'default': {
    'ENGINE': 'django.db.backends.sqlite3',
    'NAME': DATABASE_NAME,
}}

TIME_ZONE = 'America/Chicago'

LANGUAGE_CODE = 'en-us'

SITE_ID = int(os.environ.get('SITE_ID', 1))

USE_I18N = True

MEDIA_ROOT = os.path.join(os.path.dirname(__file__), 'media/')
MEDIA_URL = '/media/'
STATIC_ROOT = os.path.join(os.path.dirname(__file__), 'static/')
STATIC_URL = '/static/'

SECRET_KEY = '_wn95s-apfd-442cby5m^_^ak6+5(fyn3lvnvtn7!si&o)1x^w'

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.contrib.auth.context_processors.auth',
    'django.core.context_processors.debug',
    'django.core.context_processors.i18n',
    'django.core.context_processors.media',
    'django.core.context_processors.request',
    'django.core.context_processors.static',

    'feincms.context_processors.add_page_if_missing',
)

TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'example.urls'

TEMPLATE_DIRS = (
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.admin',
    'django.contrib.staticfiles',

    'feincms',
    'feincms.module.blog',
    'feincms.module.page',
    'feincms.module.medialibrary',
    'example',

    'mptt',
)

LANGUAGES = (
    ('en', 'English'),
    ('de', 'German'),
)

FEINCMS_TREE_EDITOR_INCLUDE_ANCESTORS = True

from feincms.content.application.models import app_reverse
ABSOLUTE_URL_OVERRIDES = {
    'blog.entry': lambda entry: app_reverse(
        'blog_entry_detail', 'blog_urls',
        args=(entry.id,)),
}

########NEW FILE########
__FILENAME__ = urls
import os

from django.conf.urls import patterns, include, url
from django.contrib import admin
from django.contrib.staticfiles.urls import staticfiles_urlpatterns

admin.autodiscover()

urlpatterns = patterns(
    '',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^media/(?P<path>.*)$', 'django.views.static.serve', {
        'document_root': os.path.join(os.path.dirname(__file__), 'media/')}),
    url(r'', include('feincms.contrib.preview.urls')),
    url(r'', include('feincms.urls'))
) + staticfiles_urlpatterns()

########NEW FILE########
__FILENAME__ = filterspecs
# encoding=utf-8
# Thanks to http://www.djangosnippets.org/snippets/1051/
#
# Authors: Marinho Brandao <marinho at gmail.com>
#          Guilherme M. Gondim (semente) <semente at taurinus.org>

from __future__ import absolute_import, unicode_literals

from django.contrib.admin.filters import (
    FieldListFilter, ChoicesFieldListFilter)
from django.utils import six
from django.utils.encoding import smart_text
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext as _

from feincms.utils import shorten_string


class ParentFieldListFilter(ChoicesFieldListFilter):
    """
    Improved list_filter display for parent Pages by nicely indenting hierarchy

    In theory this would work with any mptt model which uses a "title"
    attribute.

    my_model_field.page_parent_filter = True
    """

    def __init__(self, f, request, params, model, model_admin,
                 field_path=None):
        super(ParentFieldListFilter, self).__init__(
            f, request, params, model, model_admin, field_path)

        parent_ids = model.objects.exclude(parent=None).values_list(
            "parent__id", flat=True).order_by("parent__id").distinct()
        parents = model.objects.filter(pk__in=parent_ids).values_list(
            "pk", "title", "level")
        self.lookup_choices = [(
            pk,
            "%s%s" % ("&nbsp;" * level, shorten_string(title, max_length=25)),
        ) for pk, title, level in parents]

    def choices(self, cl):
        yield {
            'selected': self.lookup_val is None,
            'query_string': cl.get_query_string({}, [self.lookup_kwarg]),
            'display': _('All')
        }

        for pk, title in self.lookup_choices:
            yield {
                'selected': pk == int(self.lookup_val or '0'),
                'query_string': cl.get_query_string({self.lookup_kwarg: pk}),
                'display': mark_safe(smart_text(title))
            }

    def title(self):
        return _('Parent')


class CategoryFieldListFilter(ChoicesFieldListFilter):
    """
    Customization of ChoicesFilterSpec which sorts in the user-expected format

    my_model_field.category_filter = True
    """

    def __init__(self, f, request, params, model, model_admin,
                 field_path=None):
        super(CategoryFieldListFilter, self).__init__(
            f, request, params, model, model_admin, field_path)

        # Restrict results to categories which are actually in use:
        self.lookup_choices = [(
            i.pk,
            six.text_type(i))
            for i in f.related.parent_model.objects.exclude(
                **{f.related.var_name: None})
        ]
        self.lookup_choices.sort(key=lambda i: i[1])

    def choices(self, cl):
        yield {
            'selected': self.lookup_val is None,
            'query_string': cl.get_query_string({}, [self.lookup_kwarg]),
            'display': _('All')
        }

        for pk, title in self.lookup_choices:
            yield {
                'selected': pk == int(self.lookup_val or '0'),
                'query_string': cl.get_query_string({self.lookup_kwarg: pk}),
                'display': mark_safe(smart_text(title))
            }

    def title(self):
        return _('Category')


FieldListFilter.register(
    lambda f: getattr(f, 'parent_filter', False),
    ParentFieldListFilter,
    take_priority=True)
FieldListFilter.register(
    lambda f: getattr(f, 'category_filter', False),
    CategoryFieldListFilter,
    take_priority=True)

########NEW FILE########
__FILENAME__ = item_editor
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

import copy
import logging
import re
import warnings

from django import forms, template
from django.contrib.admin.options import InlineModelAdmin
from django.contrib.admin.util import unquote
from django.db.models import loading
from django.forms.models import modelform_factory
from django.http import Http404
from django.shortcuts import render_to_response
from django.utils.encoding import force_text
from django.utils.functional import curry
from django.utils.translation import ugettext as _

from feincms import settings, ensure_completely_loaded
from feincms.extensions import ExtensionModelAdmin
from feincms.signals import itemeditor_post_save_related
from feincms.templatetags.feincms_admin_tags import is_popup_var


# ------------------------------------------------------------------------
FRONTEND_EDITING_MATCHER = re.compile(r'(\d+)\|(\w+)\|(\d+)')
FEINCMS_CONTENT_FIELDSET_NAME = 'FEINCMS_CONTENT'
FEINCMS_CONTENT_FIELDSET = (FEINCMS_CONTENT_FIELDSET_NAME, {'fields': ()})

logger = logging.getLogger(__name__)


# ------------------------------------------------------------------------
class ItemEditorForm(forms.ModelForm):
    """
    The item editor form contains hidden region and ordering fields and should
    be used for all content type inlines.
    """

    region = forms.CharField(widget=forms.HiddenInput())
    ordering = forms.IntegerField(widget=forms.HiddenInput())


# ------------------------------------------------------------------------
class FeinCMSInline(InlineModelAdmin):
    """
    Custom ``InlineModelAdmin`` subclass used for content types.
    """

    form = ItemEditorForm
    extra = 0
    fk_name = 'parent'
    template = 'admin/feincms/content_inline.html'


# ------------------------------------------------------------------------
class ItemEditor(ExtensionModelAdmin):
    """
    The ``ItemEditor`` is a drop-in replacement for ``ModelAdmin`` with the
    speciality of knowing how to work with :class:`feincms.models.Base`
    subclasses and associated content types.

    It does not have any public API except from everything inherited from'
    the standard ``ModelAdmin`` class.
    """

    def __init__(self, model, admin_site):
        ensure_completely_loaded()

        super(ItemEditor, self).__init__(model, admin_site)

    def get_inline_instances(self, request, *args, **kwargs):
        inline_instances = super(ItemEditor, self).get_inline_instances(
            request, *args, **kwargs)
        self.append_feincms_inlines(inline_instances, request)
        return inline_instances

    def append_feincms_inlines(self, inline_instances, request):
        """
        Append generated FeinCMS content inlines to native django inlines.
        """
        for inline_class in self.get_feincms_inlines(self.model, request):
            inline_instance = inline_class(self.model, self.admin_site)
            inline_instances.append(inline_instance)

    def can_add_content(self, request, content_type):
        perm = '.'.join((
            content_type._meta.app_label,
            content_type._meta.get_add_permission()))
        return request.user.has_perm(perm)

    def get_feincms_inlines(self, model, request):
        """ Generate genuine django inlines for registered content types. """
        model._needs_content_types()

        inlines = []
        for content_type in model._feincms_content_types:
            if not self.can_add_content(request, content_type):
                continue

            attrs = {
                '__module__': model.__module__,
                'model': content_type,
            }

            if hasattr(content_type, 'feincms_item_editor_inline'):
                inline = content_type.feincms_item_editor_inline
                attrs['form'] = inline.form

                if hasattr(content_type, 'feincms_item_editor_form'):
                    warnings.warn(
                        'feincms_item_editor_form on %s is ignored because '
                        'feincms_item_editor_inline is set too' % content_type,
                        RuntimeWarning)

            else:
                inline = FeinCMSInline
                attrs['form'] = getattr(
                    content_type, 'feincms_item_editor_form', inline.form)

            name = '%sFeinCMSInline' % content_type.__name__
            # TODO: We generate a new class every time. Is that really wanted?
            inline_class = type(str(name), (inline,), attrs)
            inlines.append(inline_class)
        return inlines

    def _frontend_editing_view(self, request, cms_id, content_type,
                               content_id):
        """
        This view is used strictly for frontend editing -- it is not used
        inside the standard administration interface.

        The code in feincms/templates/admin/feincms/fe_tools.html knows how to
        call this view correctly.
        """

        try:
            model_cls = loading.get_model(
                self.model._meta.app_label, content_type)
            obj = model_cls.objects.get(parent=cms_id, id=content_id)
        except:
            raise Http404()

        form_class_base = getattr(
            model_cls, 'feincms_item_editor_form', ItemEditorForm)

        ModelForm = modelform_factory(
            model_cls,
            exclude=('parent', 'region', 'ordering'),
            form=form_class_base,
            formfield_callback=curry(
                self.formfield_for_dbfield, request=request))

        # we do not want to edit these two fields in the frontend editing mode;
        # we are strictly editing single content blocks there.  We have to
        # remove them from the form because we explicitly redefined them in the
        # ItemEditorForm definition above. Just using exclude is not enough.
        del ModelForm.base_fields['region']
        del ModelForm.base_fields['ordering']

        if request.method == 'POST':
            # The prefix is used to replace the formset identifier from the
            # ItemEditor interface. Customization of the form is easily
            # possible through either matching the prefix (frontend editing) or
            # the formset identifier (ItemEditor) as it is done in the richtext
            # and mediafile init.html item editor includes.
            form = ModelForm(request.POST, instance=obj, prefix=content_type)

            if form.is_valid():
                obj = form.save()

                return render_to_response(
                    'admin/feincms/fe_editor_done.html', {
                        'content': obj.render(request=request),
                        'identifier': obj.fe_identifier(),
                        'FEINCMS_JQUERY_NO_CONFLICT':
                        settings.FEINCMS_JQUERY_NO_CONFLICT,
                    }, context_instance=template.RequestContext(request))
        else:
            form = ModelForm(instance=obj, prefix=content_type)

        context = self.get_extra_context(request)
        context.update({
            'frontend_editing': True,
            'title': _('Change %s') % force_text(model_cls._meta.verbose_name),
            'object': obj,
            'form': form,
            'is_popup': True,
            'media': self.media,
        })

        return render_to_response(
            'admin/feincms/fe_editor.html',
            context,
            context_instance=template.RequestContext(request))

    def get_content_type_map(self, request):
        """ Prepare mapping of content types to their prettified names. """
        content_types = []
        for content_type in self.model._feincms_content_types:
            if self.model == content_type._feincms_content_class:
                content_name = content_type._meta.verbose_name
                content_types.append(
                    (content_name, content_type.__name__.lower()))
        return content_types

    def get_extra_context(self, request):
        """ Return extra context parameters for add/change views. """

        extra_context = {
            'model': self.model,
            'available_templates': getattr(
                self.model, '_feincms_templates', ()),
            'has_parent_attribute': hasattr(self.model, 'parent'),
            'content_types': self.get_content_type_map(request),
            'FEINCMS_JQUERY_NO_CONFLICT': settings.FEINCMS_JQUERY_NO_CONFLICT,
            'FEINCMS_CONTENT_FIELDSET_NAME': FEINCMS_CONTENT_FIELDSET_NAME,

            'FEINCMS_FRONTEND_EDITING': settings.FEINCMS_FRONTEND_EDITING,
            'FEINCMS_POPUP_VAR': is_popup_var(),
        }

        for processor in self.model.feincms_item_editor_context_processors:
            extra_context.update(processor(request))

        return extra_context

    def add_view(self, request, **kwargs):
        if not self.has_add_permission(request):
            logger.warning(
                "Denied adding %s to \"%s\" (no add permission)",
                self.model,
                request.user
            )
            raise Http404

        context = {}

        # insert dummy object as 'original' so template code can grab defaults
        # for template, etc.
        context['original'] = self.model()

        # If there are errors in the form, we need to preserve the object's
        # template as it was set when the user attempted to save it, so that
        # the same regions appear on screen.
        if request.method == 'POST' and \
                hasattr(self.model, '_feincms_templates'):
            context['original'].template_key = request.POST['template_key']

        context.update(self.get_extra_context(request))
        context.update(kwargs.get('extra_context', {}))
        kwargs['extra_context'] = context
        return super(ItemEditor, self).add_view(request, **kwargs)

    def render_change_form(self, request, context, **kwargs):
        if kwargs.get('add'):
            if request.method == 'GET' and 'adminform' in context:
                if 'template_key' in context['adminform'].form.initial:
                    context['original'].template_key = (
                        context['adminform'].form.initial['template_key'])
                # ensure that initially-selected template in form is also
                # used to render the initial regions in the item editor
        return super(
            ItemEditor, self).render_change_form(request, context, **kwargs)

    def change_view(self, request, object_id, **kwargs):
        obj = self.get_object(request, unquote(object_id))
        if not self.has_change_permission(request, obj):
            logger.warning(
                "Denied editing %s to \"%s\" (no edit permission)",
                self.model,
                request.user
            )
            raise Http404

        # Recognize frontend editing requests
        # This is done here so that the developer does not need to add
        # additional entries to # urls.py or something...
        res = FRONTEND_EDITING_MATCHER.search(object_id)
        if res:
            return self._frontend_editing_view(
                request, res.group(1), res.group(2), res.group(3))

        context = {}
        context.update(self.get_extra_context(request))
        context.update(kwargs.get('extra_context', {}))
        kwargs['extra_context'] = context
        return super(ItemEditor, self).change_view(
            request, object_id, **kwargs)

    # The next two add support for sending a "saving done" signal as soon as
    # all relevant data have been saved (especially all foreign key relations)
    # This can be used to keep functionality dependend on item content happy.
    # NOTE: These two can (and probably should) be replaced by overriding
    # `save_related` as soon as we don't depend on Django<1.4 any more.
    def response_add(self, request, obj, *args, **kwargs):
        r = super(ItemEditor, self).response_add(request, obj, *args, **kwargs)
        itemeditor_post_save_related.send(
            sender=obj.__class__, instance=obj, created=True)
        return r

    def response_change(self, request, obj, *args, **kwargs):
        r = super(ItemEditor, self).response_change(
            request, obj, *args, **kwargs)
        itemeditor_post_save_related.send(
            sender=obj.__class__, instance=obj, created=False)
        return r

    @property
    def change_form_template(self):
        return self.get_template_list()

    def get_template_list(self):
        # retained for backwards-compatibility, change_form_template wraps it
        opts = self.model._meta
        return [
            'admin/feincms/%s/%s/item_editor.html' % (
                opts.app_label, opts.object_name.lower()),
            'admin/feincms/%s/item_editor.html' % opts.app_label,
            'admin/feincms/item_editor.html',
        ]

    def get_fieldsets(self, request, obj=None):
        """
        Insert FEINCMS_CONTENT_FIELDSET it not present.
        Is it reasonable to assume this should always be included?
        """

        fieldsets = copy.deepcopy(
            super(ItemEditor, self).get_fieldsets(request, obj))

        if FEINCMS_CONTENT_FIELDSET_NAME not in dict(fieldsets).keys():
            fieldsets.append(FEINCMS_CONTENT_FIELDSET)

        return fieldsets

    # These next are only used if later we use a subclass of this class
    # which also inherits from VersionAdmin.
    revision_form_template = "admin/feincms/revision_form.html"

    recover_form_template = "admin/feincms/recover_form.html"

    def render_revision_form(self, request, obj, version, context,
                             revert=False, recover=False):
        context.update(self.get_extra_context(request))
        return super(ItemEditor, self).render_revision_form(
            request, obj, version, context, revert, recover)

########NEW FILE########
__FILENAME__ = thumbnail

########NEW FILE########
__FILENAME__ = tree_editor
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

from functools import reduce
import json
import logging

from django.contrib.admin.views import main
from django.contrib.admin.actions import delete_selected
from django.contrib.staticfiles.templatetags.staticfiles import static
from django.db.models import Q
from django.http import (
    HttpResponse, HttpResponseBadRequest,
    HttpResponseForbidden, HttpResponseNotFound, HttpResponseServerError)
from django.utils.html import escape
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _, ugettext
from django.utils.encoding import force_text

from mptt.exceptions import InvalidMove
from mptt.forms import MPTTAdminForm

from feincms import settings
from feincms.extensions import ExtensionModelAdmin


logger = logging.getLogger(__name__)


# ------------------------------------------------------------------------
def django_boolean_icon(field_val, alt_text=None, title=None):
    """
    Return HTML code for a nice representation of true/false.
    """

    # Origin: contrib/admin/templatetags/admin_list.py
    BOOLEAN_MAPPING = {True: 'yes', False: 'no', None: 'unknown'}
    alt_text = alt_text or BOOLEAN_MAPPING[field_val]
    if title is not None:
        title = 'title="%s" ' % title
    else:
        title = ''
    icon_url = static('feincms/img/icon-%s.gif' % BOOLEAN_MAPPING[field_val])
    return mark_safe(
        '<img src="%s" alt="%s" %s/>' % (icon_url, alt_text, title))


def _build_tree_structure(queryset):
    """
    Build an in-memory representation of the item tree, trying to keep
    database accesses down to a minimum. The returned dictionary looks like
    this (as json dump):

        {"6": [7, 8, 10]
         "7": [12],
         "8": [],
         ...
         }
    """
    all_nodes = {}

    mptt_opts = queryset.model._mptt_meta
    items = queryset.order_by(
        mptt_opts.tree_id_attr,
        mptt_opts.left_attr)
    values_list = items.values_list(
        "pk",
        "%s_id" % mptt_opts.parent_attr)
    for p_id, parent_id in values_list:
        all_nodes[p_id] = []

        if parent_id:
            if parent_id not in all_nodes:
                # This happens very rarely, but protect against parents that
                # we have yet to iteratove over. Happens with broken MPTT
                # hierarchy.
                all_nodes[parent_id] = []
                logger.warn(
                    "Incorrect MPTT hierarchy for %s, node %d has left_attr"
                    " < than one of its parents. Try rebuilding mptt data (use"
                    " '%s._default_manager.rebuild()').",
                    queryset.model.__name__, p_id, queryset.model.__name__)

            all_nodes[parent_id].append(p_id)

    return all_nodes


# ------------------------------------------------------------------------
def ajax_editable_boolean_cell(item, attr, text='', override=None):
    """
    Generate a html snippet for showing a boolean value on the admin page.
    Item is an object, attr is the attribute name we should display. Text
    is an optional explanatory text to be included in the output.

    This function will emit code to produce a checkbox input with its state
    corresponding to the item.attr attribute if no override value is passed.
    This input is wired to run a JS ajax updater to toggle the value.

    If override is passed in, ignores the attr attribute and returns a
    static image for the override boolean with no user interaction possible
    (useful for "disabled and you can't change it" situations).
    """
    if text:
        text = '&nbsp;(%s)' % text

    if override is not None:
        a = [django_boolean_icon(override, text), text]
    else:
        value = getattr(item, attr)
        a = [
            '<input type="checkbox" data-inplace data-inplace-id="%s"'
            ' data-inplace-attribute="%s" %s>' % (
                item.pk,
                attr,
                'checked="checked"' if value else '',
            )]

    a.insert(0, '<div id="wrap_%s_%d">' % (attr, item.pk))
    a.append('</div>')
    return ''.join(a)


# ------------------------------------------------------------------------
def ajax_editable_boolean(attr, short_description):
    """
    Convenience function: Assign the return value of this method to a variable
    of your ModelAdmin class and put the variable name into list_display.

    Example::

        class MyTreeEditor(TreeEditor):
            list_display = ('__str__', 'active_toggle')

            active_toggle = ajax_editable_boolean('active', _('is active'))
    """
    def _fn(self, item):
        return ajax_editable_boolean_cell(item, attr)
    _fn.allow_tags = True
    _fn.short_description = short_description
    _fn.editable_boolean_field = attr
    return _fn


# ------------------------------------------------------------------------
class ChangeList(main.ChangeList):
    """
    Custom ``ChangeList`` class which ensures that the tree entries are always
    ordered in depth-first order (order by ``tree_id``, ``lft``).
    """

    def __init__(self, request, *args, **kwargs):
        self.user = request.user
        super(ChangeList, self).__init__(request, *args, **kwargs)

    def get_query_set(self, *args, **kwargs):
        mptt_opts = self.model._mptt_meta
        qs = super(ChangeList, self).get_query_set(*args, **kwargs).\
            order_by(mptt_opts.tree_id_attr, mptt_opts.left_attr)
        # Force has_filters, so that the expand/collapse in sidebar is visible
        self.has_filters = True
        return qs

    def get_results(self, request):
        mptt_opts = self.model._mptt_meta
        if settings.FEINCMS_TREE_EDITOR_INCLUDE_ANCESTORS:
            clauses = [
                Q(**{
                    mptt_opts.tree_id_attr: tree_id,
                    mptt_opts.left_attr + '__lte': lft,
                    mptt_opts.right_attr + '__gte': rght,
                }) for lft, rght, tree_id in self.query_set.values_list(
                    mptt_opts.left_attr,
                    mptt_opts.right_attr,
                    mptt_opts.tree_id_attr,
                )
            ]
            # We could optimise a bit here by explicitely filtering out
            # any clauses that are for parents of nodes included in the
            # queryset anyway. (ie: drop all clauses that refer to a node
            # that is a parent to another node)

            if clauses:
                # Note: Django ORM is smart enough to drop additional
                # clauses if the initial query set is unfiltered. This
                # is good.
                queryset = self.query_set | self.model._default_manager.filter(
                    reduce(lambda p, q: p | q, clauses))

                if hasattr(self, 'queryset'):
                    self.queryset = queryset
                else:
                    # Django 1.5 and older
                    self.query_set = queryset

        super(ChangeList, self).get_results(request)

        # Pre-process permissions because we still have the request here,
        # which is not passed in later stages in the tree editor
        for item in self.result_list:
            item.feincms_changeable = self.model_admin.has_change_permission(
                request, item)

            item.feincms_addable = (
                item.feincms_changeable
                and self.model_admin.has_add_permission(request, item))


# ------------------------------------------------------------------------
class TreeEditor(ExtensionModelAdmin):
    """
    The ``TreeEditor`` modifies the standard Django administration change list
    to a drag-drop enabled interface for django-mptt_-managed Django models.

    .. _django-mptt: https://github.com/django-mptt/django-mptt/
    """

    form = MPTTAdminForm

    if settings.FEINCMS_TREE_EDITOR_INCLUDE_ANCESTORS:
        # Make sure that no pagination is displayed. Slicing is disabled
        # anyway, therefore this value does not have an influence on the
        # queryset
        list_per_page = 999999999

    def __init__(self, *args, **kwargs):
        super(TreeEditor, self).__init__(*args, **kwargs)

        self.list_display = list(self.list_display)

        if 'indented_short_title' not in self.list_display:
            if self.list_display[0] == 'action_checkbox':
                self.list_display[1] = 'indented_short_title'
            else:
                self.list_display[0] = 'indented_short_title'
        self.list_display_links = ('indented_short_title',)

        opts = self.model._meta
        self.change_list_template = [
            'admin/feincms/%s/%s/tree_editor.html' % (
                opts.app_label, opts.object_name.lower()),
            'admin/feincms/%s/tree_editor.html' % opts.app_label,
            'admin/feincms/tree_editor.html',
        ]
        self.object_change_permission =\
            opts.app_label + '.' + opts.get_change_permission()
        self.object_add_permission =\
            opts.app_label + '.' + opts.get_add_permission()
        self.object_delete_permission =\
            opts.app_label + '.' + opts.get_delete_permission()

    def changeable(self, item):
        return getattr(item, 'feincms_changeable', True)

    def indented_short_title(self, item):
        """
        Generate a short title for an object, indent it depending on
        the object's depth in the hierarchy.
        """
        mptt_opts = item._mptt_meta
        r = ''
        try:
            url = item.get_absolute_url()
        except (AttributeError,):
            url = None

        if url:
            r = (
                '<input type="hidden" class="medialibrary_file_path"'
                ' value="%s" id="_refkey_%d" />') % (url, item.pk)

        changeable_class = ''
        if not self.changeable(item):
            changeable_class = ' tree-item-not-editable'

        r += (
            '<span id="page_marker-%d" class="page_marker%s"'
            ' style="width: %dpx;">&nbsp;</span>&nbsp;') % (
            item.pk,
            changeable_class,
            14 + getattr(item, mptt_opts.level_attr) * 18)

#        r += '<span tabindex="0">'
        if hasattr(item, 'short_title') and callable(item.short_title):
            r += escape(item.short_title())
        else:
            r += escape('%s' % item)
#        r += '</span>'
        return mark_safe(r)
    indented_short_title.short_description = _('title')
    indented_short_title.allow_tags = True

    def _collect_editable_booleans(self):
        """
        Collect all fields marked as editable booleans. We do not
        want the user to be able to edit arbitrary fields by crafting
        an AJAX request by hand.
        """
        if hasattr(self, '_ajax_editable_booleans'):
            return

        self._ajax_editable_booleans = {}

        for field in self.list_display:
            # The ajax_editable_boolean return value has to be assigned
            # to the ModelAdmin class
            try:
                item = getattr(self.__class__, field)
            except (AttributeError, TypeError):
                continue

            attr = getattr(item, 'editable_boolean_field', None)
            if attr:
                if hasattr(item, 'editable_boolean_result'):
                    result_func = item.editable_boolean_result
                else:
                    def _fn(attr):
                        return lambda self, instance: [
                            ajax_editable_boolean_cell(instance, attr)]
                    result_func = _fn(attr)
                self._ajax_editable_booleans[attr] = result_func

    def _refresh_changelist_caches(self):
        """
        Refresh information used to show the changelist tree structure such as
        inherited active/inactive states etc.

        XXX: This is somewhat hacky, but since it's an internal method, so be
        it.
        """

        pass

    def _toggle_boolean(self, request):
        """
        Handle an AJAX toggle_boolean request
        """
        try:
            item_id = int(request.POST.get('item_id', None))
            attr = str(request.POST.get('attr', None))
        except:
            return HttpResponseBadRequest("Malformed request")

        if not request.user.is_staff:
            logger.warning(
                "Denied AJAX request by non-staff \"%s\" to toggle boolean"
                " %s for object #%s", request.user, attr, item_id)
            return HttpResponseForbidden(
                _("You do not have permission to modify this object"))

        self._collect_editable_booleans()

        if attr not in self._ajax_editable_booleans:
            return HttpResponseBadRequest("not a valid attribute %s" % attr)

        try:
            obj = self.model._default_manager.get(pk=item_id)
        except self.model.DoesNotExist:
            return HttpResponseNotFound("Object does not exist")

        if not self.has_change_permission(request, obj=obj):
            logger.warning(
                "Denied AJAX request by \"%s\" to toggle boolean %s for"
                " object %s", request.user, attr, item_id)
            return HttpResponseForbidden(
                _("You do not have permission to modify this object"))

        new_state = not getattr(obj, attr)
        logger.info(
            "Toggle %s on #%d %s to %s by \"%s\"",
            attr, obj.pk, obj, "on" if new_state else "off", request.user)

        try:
            before_data = self._ajax_editable_booleans[attr](self, obj)

            setattr(obj, attr, new_state)
            obj.save()

            # ???: Perhaps better a post_save signal?
            self._refresh_changelist_caches()

            # Construct html snippets to send back to client for status update
            data = self._ajax_editable_booleans[attr](self, obj)

        except Exception:
            logger.exception(
                "Unhandled exception while toggling %s on %s", attr, obj)
            return HttpResponseServerError(
                "Unable to toggle %s on %s" % (attr, obj))

        # Weed out unchanged cells to keep the updates small. This assumes
        # that the order a possible get_descendents() returns does not change
        # before and after toggling this attribute. Unlikely, but still...
        return HttpResponse(
            json.dumps([b for a, b in zip(before_data, data) if a != b]),
            content_type="application/json")

    def get_changelist(self, request, **kwargs):
        return ChangeList

    def changelist_view(self, request, extra_context=None, *args, **kwargs):
        """
        Handle the changelist view, the django view for the model instances
        change list/actions page.
        """

        if 'actions_column' not in self.list_display:
            self.list_display.append('actions_column')

        # handle common AJAX requests
        if request.is_ajax():
            cmd = request.POST.get('__cmd')
            if cmd == 'toggle_boolean':
                return self._toggle_boolean(request)
            elif cmd == 'move_node':
                return self._move_node(request)

            return HttpResponseBadRequest('Oops. AJAX request not understood.')

        self._refresh_changelist_caches()

        extra_context = extra_context or {}
        queryset = self.queryset(request)
        extra_context['tree_structure'] = mark_safe(
            json.dumps(_build_tree_structure(queryset)))

        return super(TreeEditor, self).changelist_view(
            request, extra_context, *args, **kwargs)

    def has_add_permission(self, request, obj=None):
        """
        Implement a lookup for object level permissions. Basically the same as
        ModelAdmin.has_add_permission, but also passes the obj parameter in.
        """
        perm = self.object_add_permission
        if settings.FEINCMS_TREE_EDITOR_OBJECT_PERMISSIONS:
            r = request.user.has_perm(perm, obj)
        else:
            r = request.user.has_perm(perm)

        return r and super(TreeEditor, self).has_add_permission(request)

    def has_change_permission(self, request, obj=None):
        """
        Implement a lookup for object level permissions. Basically the same as
        ModelAdmin.has_change_permission, but also passes the obj parameter in.
        """
        perm = self.object_change_permission
        if settings.FEINCMS_TREE_EDITOR_OBJECT_PERMISSIONS:
            r = request.user.has_perm(perm, obj)
        else:
            r = request.user.has_perm(perm)

        return r and super(TreeEditor, self).has_change_permission(
            request, obj)

    def has_delete_permission(self, request, obj=None):
        """
        Implement a lookup for object level permissions. Basically the same as
        ModelAdmin.has_delete_permission, but also passes the obj parameter in.
        """
        perm = self.object_delete_permission
        if settings.FEINCMS_TREE_EDITOR_OBJECT_PERMISSIONS:
            r = request.user.has_perm(perm, obj)
        else:
            r = request.user.has_perm(perm)

        return r and super(TreeEditor, self).has_delete_permission(
            request, obj)

    def _move_node(self, request):
        if hasattr(self.model.objects, 'move_node'):
            tree_manager = self.model.objects
        else:
            tree_manager = self.model._tree_manager

        queryset = self.queryset(request)
        cut_item = queryset.get(pk=request.POST.get('cut_item'))
        pasted_on = queryset.get(pk=request.POST.get('pasted_on'))
        position = request.POST.get('position')

        if not self.has_change_permission(request, cut_item):
            self.message_user(request, _('No permission'))
            return HttpResponse('FAIL')

        if position in ('last-child', 'left', 'right'):
            try:
                tree_manager.move_node(cut_item, pasted_on, position)
            except InvalidMove as e:
                self.message_user(request, '%s' % e)
                return HttpResponse('FAIL')

            # Ensure that model save methods have been run (required to
            # update Page._cached_url values, might also be helpful for other
            # models inheriting MPTTModel)
            for item in queryset.filter(id__in=(cut_item.pk, pasted_on.pk)):
                item.save()

            self.message_user(
                request,
                ugettext('%s has been moved to a new position.') % cut_item)
            return HttpResponse('OK')

        self.message_user(request, _('Did not understand moving instruction.'))
        return HttpResponse('FAIL')

    def _actions_column(self, instance):
        if self.changeable(instance):
            return ['<div class="drag_handle"></div>']
        return []

    def actions_column(self, instance):
        return ' '.join(self._actions_column(instance))
    actions_column.allow_tags = True
    actions_column.short_description = _('actions')

    def delete_selected_tree(self, modeladmin, request, queryset):
        """
        Deletes multiple instances and makes sure the MPTT fields get
        recalculated properly. (Because merely doing a bulk delete doesn't
        trigger the post_delete hooks.)
        """
        # If this is True, the confirmation page has been displayed
        if request.POST.get('post'):
            n = 0
            for obj in queryset:
                if self.has_delete_permission(request, obj):
                    obj.delete()
                    n += 1
                    obj_display = force_text(obj)
                    self.log_deletion(request, obj, obj_display)
                else:
                    logger.warning(
                        "Denied delete request by \"%s\" for object #%s",
                        request.user, obj.id)
            self.message_user(
                request,
                _("Successfully deleted %(count)d items.") % {"count": n})
            # Return None to display the change list page again
            return None
        else:
            # (ab)using the built-in action to display the confirmation page
            return delete_selected(self, request, queryset)

    def get_actions(self, request):
        actions = super(TreeEditor, self).get_actions(request)
        if 'delete_selected' in actions:
            actions['delete_selected'] = (
                self.delete_selected_tree,
                'delete_selected',
                _("Delete selected %(verbose_name_plural)s"))
        return actions

########NEW FILE########
__FILENAME__ = models
"""
Third-party application inclusion support.
"""

from __future__ import absolute_import, unicode_literals

from email.utils import parsedate
from time import mktime
from random import SystemRandom
import re

from django.conf import settings
from django.core.cache import cache
from django.core.urlresolvers import (
    Resolver404, resolve, reverse, NoReverseMatch)
from django.db import models
from django.db.models import signals
from django.http import HttpResponse
from django.utils.functional import curry as partial, lazy, wraps
from django.utils.http import http_date
from django.utils.safestring import mark_safe
from django.utils.translation import get_language, ugettext_lazy as _

from feincms.admin.item_editor import ItemEditorForm
from feincms.contrib.fields import JSONField
from feincms.translations import short_language_code
from feincms.utils import get_object


def cycle_app_reverse_cache(*args, **kwargs):
    """Does not really empty the cache; instead it adds a random element to the
    cache key generation which guarantees that the cache does not yet contain
    values for all newly generated keys"""
    cache.set('app_reverse_cache_generation', str(SystemRandom().random()))


# Set the app_reverse_cache_generation value once per startup (at least).
# This protects us against offline modifications of the database.
cycle_app_reverse_cache()


def app_reverse(viewname, urlconf=None, args=None, kwargs=None, prefix=None,
                *vargs, **vkwargs):
    """
    Reverse URLs from application contents

    Works almost like Django's own reverse() method except that it resolves
    URLs from application contents. The second argument, ``urlconf``, has to
    correspond to the URLconf parameter passed in the ``APPLICATIONS`` list
    to ``Page.create_content_type``::

        app_reverse('mymodel-detail', 'myapp.urls', args=...)

        or

        app_reverse('mymodel-detail', 'myapp.urls', kwargs=...)

    The second argument may also be a request object if you want to reverse
    an URL belonging to the current application content.
    """

    # First parameter might be a request instead of an urlconf path, so
    # we'll try to be helpful and extract the current urlconf from it
    extra_context = getattr(urlconf, '_feincms_extra_context', {})
    appconfig = extra_context.get('app_config', {})
    urlconf = appconfig.get('urlconf_path', urlconf)

    cache_generation = cache.get('app_reverse_cache_generation')
    if cache_generation is None:
        # This might never happen. Still, better be safe than sorry.
        cycle_app_reverse_cache()
        cache_generation = cache.get('app_reverse_cache_generation')

    cache_key = '%s-%s-%s-%s' % (
        urlconf,
        get_language(),
        getattr(settings, 'SITE_ID', 0),
        cache_generation)

    url_prefix = cache.get(cache_key)

    if url_prefix is None:
        appcontent_class = ApplicationContent._feincms_content_models[0]
        content = appcontent_class.closest_match(urlconf)

        if content is not None:
            if urlconf in appcontent_class.ALL_APPS_CONFIG:
                # We have an overridden URLconf
                app_config = appcontent_class.ALL_APPS_CONFIG[urlconf]
                urlconf = app_config['config'].get('urls', urlconf)

            prefix = content.parent.get_absolute_url()
            prefix += '/' if prefix[-1] != '/' else ''

            url_prefix = (urlconf, prefix)
            cache.set(cache_key, url_prefix)

    if url_prefix:
        # vargs and vkwargs are used to send through additional parameters
        # which are uninteresting to us (such as current_app)
        return reverse(
            viewname,
            url_prefix[0],
            args=args,
            kwargs=kwargs,
            prefix=url_prefix[1],
            *vargs, **vkwargs)

    raise NoReverseMatch("Unable to find ApplicationContent for %r" % urlconf)


#: Lazy version of ``app_reverse``
app_reverse_lazy = lazy(app_reverse, str)


def permalink(func):
    """
    Decorator that calls app_reverse()

    Use this instead of standard django.db.models.permalink if you want to
    integrate the model through ApplicationContent. The wrapped function
    must return 4 instead of 3 arguments::

        class MyModel(models.Model):
            @appmodels.permalink
            def get_absolute_url(self):
                return ('myapp.urls', 'model_detail', (), {'slug': self.slug})
    """
    def inner(*args, **kwargs):
        return app_reverse(*func(*args, **kwargs))
    return wraps(func)(inner)


APPLICATIONCONTENT_RE = re.compile(r'^([^/]+)/([^/]+)$')


class ApplicationContent(models.Model):
    #: parameters is used to serialize instance-specific data which will be
    # provided to the view code. This allows customization (e.g. "Embed
    # MyBlogApp for blog <slug>")
    parameters = JSONField(null=True, editable=False)

    ALL_APPS_CONFIG = {}

    class Meta:
        abstract = True
        verbose_name = _('application content')
        verbose_name_plural = _('application contents')

    @classmethod
    def initialize_type(cls, APPLICATIONS):
        for i in APPLICATIONS:
            if not 2 <= len(i) <= 3:
                raise ValueError(
                    "APPLICATIONS must be provided with tuples containing at"
                    " least two parameters (urls, name) and an optional extra"
                    " config dict")

            urls, name = i[0:2]

            if len(i) == 3:
                app_conf = i[2]

                if not isinstance(app_conf, dict):
                    raise ValueError(
                        "The third parameter of an APPLICATIONS entry must be"
                        " a dict or the name of one!")
            else:
                app_conf = {}

            cls.ALL_APPS_CONFIG[urls] = {
                "urls": urls,
                "name": name,
                "config": app_conf
            }

        cls.add_to_class(
            'urlconf_path',
            models.CharField(_('application'), max_length=100, choices=[
                (c['urls'], c['name']) for c in cls.ALL_APPS_CONFIG.values()])
        )

        class ApplicationContentItemEditorForm(ItemEditorForm):
            app_config = {}
            custom_fields = {}

            def __init__(self, *args, **kwargs):
                super(ApplicationContentItemEditorForm, self).__init__(
                    *args, **kwargs)

                instance = kwargs.get("instance", None)

                if instance:
                    try:
                        # TODO use urlconf_path from POST if set
                        # urlconf_path = request.POST.get('...urlconf_path',
                        #     instance.urlconf_path)
                        self.app_config = cls.ALL_APPS_CONFIG[
                            instance.urlconf_path]['config']
                    except KeyError:
                        self.app_config = {}

                    self.custom_fields = {}
                    admin_fields = self.app_config.get('admin_fields', {})

                    if isinstance(admin_fields, dict):
                        self.custom_fields.update(admin_fields)
                    else:
                        get_fields = get_object(admin_fields)
                        self.custom_fields.update(
                            get_fields(self, *args, **kwargs))

                    for k, v in self.custom_fields.items():
                        self.fields[k] = v

            def save(self, commit=True, *args, **kwargs):
                # Django ModelForms return the model instance from save. We'll
                # call save with commit=False first to do any necessary work &
                # get the model so we can set .parameters to the values of our
                # custom fields before calling save(commit=True)

                m = super(ApplicationContentItemEditorForm, self).save(
                    commit=False, *args, **kwargs)

                m.parameters = dict(
                    (k, self.cleaned_data[k])
                    for k in self.custom_fields if k in self.cleaned_data)

                if commit:
                    m.save(**kwargs)

                return m

        # This provides hooks for us to customize the admin interface for
        # embedded instances:
        cls.feincms_item_editor_form = ApplicationContentItemEditorForm

        # Clobber the app_reverse cache when saving application contents
        # and/or pages
        page_class = cls.parent.field.rel.to
        signals.post_save.connect(cycle_app_reverse_cache, sender=cls)
        signals.post_delete.connect(cycle_app_reverse_cache, sender=cls)
        signals.post_save.connect(cycle_app_reverse_cache, sender=page_class)
        signals.post_delete.connect(cycle_app_reverse_cache, sender=page_class)

    def __init__(self, *args, **kwargs):
        super(ApplicationContent, self).__init__(*args, **kwargs)
        self.app_config = self.ALL_APPS_CONFIG.get(
            self.urlconf_path, {}).get('config', {})

    def process(self, request, **kw):
        page_url = self.parent.get_absolute_url()

        # Provide a way for appcontent items to customize URL processing by
        # altering the perceived path of the page:
        if "path_mapper" in self.app_config:
            path_mapper = get_object(self.app_config["path_mapper"])
            path, page_url = path_mapper(
                request.path,
                page_url,
                appcontent_parameters=self.parameters
            )
        else:
            path = request._feincms_extra_context['extra_path']

        # Resolve the module holding the application urls.
        urlconf_path = self.app_config.get('urls', self.urlconf_path)

        try:
            fn, args, kwargs = resolve(path, urlconf_path)
        except (ValueError, Resolver404):
            raise Resolver404(str('Not found (resolving %r in %r failed)') % (
                path, urlconf_path))

        # Variables from the ApplicationContent parameters are added to request
        # so we can expose them to our templates via the appcontent_parameters
        # context_processor
        request._feincms_extra_context.update(self.parameters)

        # Save the application configuration for reuse elsewhere
        request._feincms_extra_context.update({
            'app_config': dict(
                self.app_config,
                urlconf_path=self.urlconf_path,
            ),
        })

        view_wrapper = self.app_config.get("view_wrapper", None)
        if view_wrapper:
            fn = partial(
                get_object(view_wrapper),
                view=fn,
                appcontent_parameters=self.parameters
            )

        output = fn(request, *args, **kwargs)

        if isinstance(output, HttpResponse):
            if self.send_directly(request, output):
                return output
            elif output.status_code == 200:

                # If the response supports deferred rendering, render the
                # response right now. We do not handle template response
                # middleware.
                if hasattr(output, 'render') and callable(output.render):
                    output.render()

                self.rendered_result = mark_safe(
                    output.content.decode('utf-8'))
                self.rendered_headers = {}

                # Copy relevant headers for later perusal
                for h in ('Cache-Control', 'Last-Modified', 'Expires'):
                    if h in output:
                        self.rendered_headers.setdefault(
                            h, []).append(output[h])

        elif isinstance(output, tuple) and 'view' in kw:
            kw['view'].template_name = output[0]
            kw['view'].request._feincms_extra_context.update(output[1])
        else:
            self.rendered_result = mark_safe(output)

        return True  # successful

    def send_directly(self, request, response):
        mimetype = response.get('Content-Type', 'text/plain')
        if ';' in mimetype:
            mimetype = mimetype.split(';')[0]
        mimetype = mimetype.strip()

        return (response.status_code != 200
                or request.is_ajax()
                or getattr(response, 'standalone', False)
                or mimetype not in ('text/html', 'text/plain'))

    def render(self, **kwargs):
        return getattr(self, 'rendered_result', '')

    def finalize(self, request, response):
        headers = getattr(self, 'rendered_headers', None)
        if headers:
            self._update_response_headers(request, response, headers)

    def _update_response_headers(self, request, response, headers):
        """
        Combine all headers that were set by the different content types
        We are interested in Cache-Control, Last-Modified, Expires
        """

        # Ideally, for the Cache-Control header, we'd want to do some
        # intelligent combining, but that's hard. Let's just collect and unique
        # them and let the client worry about that.
        cc_headers = set(('must-revalidate',))
        for x in (cc.split(",") for cc in headers.get('Cache-Control', ())):
            cc_headers |= set((s.strip() for s in x))

        if len(cc_headers):
            response['Cache-Control'] = ", ".join(cc_headers)
        else:   # Default value
            response['Cache-Control'] = 'no-cache, must-revalidate'

        # Check all Last-Modified headers, choose the latest one
        lm_list = [parsedate(x) for x in headers.get('Last-Modified', ())]
        if len(lm_list) > 0:
            response['Last-Modified'] = http_date(mktime(max(lm_list)))

        # Check all Expires headers, choose the earliest one
        lm_list = [parsedate(x) for x in headers.get('Expires', ())]
        if len(lm_list) > 0:
            response['Expires'] = http_date(mktime(min(lm_list)))

    @classmethod
    def closest_match(cls, urlconf_path):
        page_class = cls.parent.field.rel.to

        contents = cls.objects.filter(
            parent__in=page_class.objects.active(),
            urlconf_path=urlconf_path,
        ).order_by('pk').select_related('parent')

        if len(contents) > 1:
            try:
                current = short_language_code(get_language())
                return [
                    content for content in contents if
                    short_language_code(content.parent.language) == current
                ][0]

            except (AttributeError, IndexError):
                pass

        try:
            return contents[0]
        except IndexError:
            pass

        return None

########NEW FILE########
__FILENAME__ = models
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------
#
#  Created by Martin J. Laubach on 08.01.10.
#  skyl wuz here (11.05.10)
#
# ------------------------------------------------------------------------

"""
Embed a comment list and comment form anywhere. Uses the standard
``django.contrib.comments`` application.
"""

from __future__ import absolute_import, unicode_literals

from django.contrib import comments
from django.contrib.comments.views.comments import post_comment
from django.db import models
from django.http import HttpResponseRedirect
from django.template import RequestContext
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy as _

from feincms.admin.item_editor import ItemEditorForm


# ------------------------------------------------------------------------
class CommentsContent(models.Model):
    comments_enabled = models.BooleanField(
        _('enabled'), default=True,
        help_text=_('New comments may be added'))

    class Meta:
        abstract = True
        verbose_name = _('comments')
        verbose_name_plural = _('comments')

    @classmethod
    def initialize_type(cls):
        class CommentContentAdminForm(ItemEditorForm):
            def __init__(self, *args, **kwargs):
                super(CommentContentAdminForm, self).__init__(*args, **kwargs)
                parent = kwargs.get('instance', None)
                if parent is not None:
                    f = self.fields['comments_enabled']
                    r = f.help_text
                    r += '<hr />'
                    comments_model = comments.get_model()
                    for c in comments_model.objects.for_model(
                            parent.parent).order_by('-submit_date'):
                        r += (
                            '<div class="form-row" style="margin-left: 60px">'
                            '# %(pk)d <a href="/admin/%(app)s/%(model)s/%(pk)'
                            'd/">%(comment)s</a> - %(is_public)s</div>') % {
                            'pk': c.id,
                            'comment': c.comment[:80],
                            'is_public': (
                                _('public') if c.is_public
                                else _('not public')),
                            'app': comments_model._meta.app_label,
                            'model': comments_model._meta.module_name,
                        }
                    f.help_text = r

        cls.feincms_item_editor_form = CommentContentAdminForm

    def process(self, request, **kwargs):
        parent_type = self.parent.__class__.__name__.lower()

        comment_page = self.parent
        if (hasattr(comment_page, 'original_translation')
                and comment_page.original_translation):
            comment_page = comment_page.original_translation

        f = None
        if self.comments_enabled and request.POST:

            # I guess the drawback is that this page can't handle any other
            # types of posts just the comments for right now, but if we just
            # post to the current path and handle it this way .. at least it
            # works for now.

            # extra = request._feincms_extra_context.get('page_extra_path', ())
            # if len(extra) > 0 and extra[0] == "post-comment":

            r = post_comment(request, next=comment_page.get_absolute_url())

            if isinstance(r, HttpResponseRedirect):
                return r

            f = comments.get_form()(comment_page, data=request.POST)

        if f is None:
            f = comments.get_form()(comment_page)

        self.rendered_output = render_to_string(
            [
                'content/comments/%s.html' % parent_type,
                'content/comments/default-site.html',
                'content/comments/default.html',
            ],
            RequestContext(request, {
                'content': self,
                'feincms_page': self.parent,
                'parent': comment_page,
                'form': f,
            }),
        )

    def render(self, **kwargs):
        return getattr(self, 'rendered_output', '')

########NEW FILE########
__FILENAME__ = models
"""
Simple contact form for FeinCMS. The default form class has name, email,
subject and content fields, content being the only one which is not required.
You can provide your own comment form by passing an additional
``form=YourClass`` argument to the ``create_content_type`` call.
"""

from __future__ import absolute_import, unicode_literals

from django import forms
from django.core.mail import send_mail
from django.db import models
from django.http import HttpResponseRedirect
from django.template import RequestContext
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy as _


class ContactForm(forms.Form):
    name = forms.CharField(label=_('name'))
    email = forms.EmailField(label=_('email'))
    subject = forms.CharField(label=_('subject'))

    content = forms.CharField(
        widget=forms.Textarea, required=False,
        label=_('content'))


class ContactFormContent(models.Model):
    form = ContactForm

    email = models.EmailField()
    subject = models.CharField(max_length=200)

    class Meta:
        abstract = True
        verbose_name = _('contact form')
        verbose_name_plural = _('contact forms')

    @classmethod
    def initialize_type(cls, form=None):
        if form:
            cls.form = form

    def process(self, request, **kwargs):
        if request.GET.get('_cf_thanks'):
            self.rendered_output = render_to_string(
                'content/contactform/thanks.html',
                context_instance=RequestContext(request))
            return

        if request.method == 'POST':
            form = self.form(request.POST)

            if form.is_valid():
                send_mail(
                    form.cleaned_data['subject'],
                    render_to_string('content/contactform/email.txt', {
                        'data': form.cleaned_data,
                    }),
                    form.cleaned_data['email'],
                    [self.email],
                    fail_silently=True,
                )

                return HttpResponseRedirect('?_cf_thanks=1')
        else:
            initial = {'subject': self.subject}
            if request.user.is_authenticated():
                initial['email'] = request.user.email
                initial['name'] = request.user.get_full_name()

            form = self.form(initial=initial)

        self.rendered_output = render_to_string(
            'content/contactform/form.html', {
                'content': self,
                'form': form,
            },
            context_instance=RequestContext(request))

    def render(self, **kwargs):
        return getattr(self, 'rendered_output', '')

########NEW FILE########
__FILENAME__ = models
"""
Simple file inclusion content: You should probably use the media library
instead.
"""

from __future__ import absolute_import, unicode_literals

import os

from django.db import models
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy as _

from feincms import settings


class FileContent(models.Model):
    # You should probably use
    # `feincms.content.medialibrary.models.MediaFileContent` instead.

    title = models.CharField(max_length=200)
    file = models.FileField(
        _('file'), max_length=255,
        upload_to=os.path.join(settings.FEINCMS_UPLOAD_PREFIX, 'filecontent'))

    class Meta:
        abstract = True
        verbose_name = _('file')
        verbose_name_plural = _('files')

    def render(self, **kwargs):
        return render_to_string(
            [
                'content/file/%s.html' % self.region,
                'content/file/default.html',
            ],
            {'content': self},
            context_instance=kwargs.get('context'),
        )

########NEW FILE########
__FILENAME__ = models
"""
Simple image inclusion content: You should probably use the media library
instead.
"""

from __future__ import absolute_import, unicode_literals

import os

from django.db import models
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy as _

from feincms import settings
from feincms.templatetags import feincms_thumbnail


class ImageContent(models.Model):
    # You should probably use
    # `feincms.content.medialibrary.models.MediaFileContent` instead.

    """
    Create an ImageContent like this::

        Cls.create_content_type(
            ImageContent,
            POSITION_CHOICES=(
                ('left', 'Float to left'),
                ('right', 'Float to right'),
                ('block', 'Block'),
            ),
            FORMAT_CHOICES=(
                ('noop', 'Do not resize'),
                ('cropscale:100x100', 'Square Thumbnail'),
                ('cropscale:200x450', 'Medium Portait'),
                ('thumbnail:1000x1000', 'Large'),
            ))

        Note that FORMAT_CHOICES is optional. The part before the colon
        corresponds to the template filters in the ``feincms_thumbnail``
        template filter library. Known values are ``cropscale`` and
        ``thumbnail``. Everything else (such as ``noop``) is ignored.
    """

    image = models.ImageField(
        _('image'), max_length=255,
        upload_to=os.path.join(settings.FEINCMS_UPLOAD_PREFIX, 'imagecontent'))
    alt_text = models.CharField(
        _('alternate text'), max_length=255, blank=True,
        help_text=_('Description of image'))
    caption = models.CharField(_('caption'), max_length=255, blank=True)

    class Meta:
        abstract = True
        verbose_name = _('image')
        verbose_name_plural = _('images')

    def render(self, **kwargs):
        templates = ['content/image/default.html']
        if hasattr(self, 'position'):
            templates.insert(0, 'content/image/%s.html' % self.position)
        return render_to_string(
            templates,
            {'content': self},
            context_instance=kwargs.get('context'),
        )

    def get_image(self):
        type, separator, size = getattr(self, 'format', '').partition(':')
        if not size:
            return self.image

        thumbnailer = {
            'cropscale': feincms_thumbnail.CropscaleThumbnailer,
        }.get(type, feincms_thumbnail.Thumbnailer)
        return thumbnailer(self.image, size)

    @classmethod
    def initialize_type(cls, POSITION_CHOICES=None, FORMAT_CHOICES=None):
        if POSITION_CHOICES:
            models.CharField(
                _('position'),
                max_length=10,
                choices=POSITION_CHOICES,
                default=POSITION_CHOICES[0][0]
            ).contribute_to_class(cls, 'position')

        if FORMAT_CHOICES:
            models.CharField(
                _('format'),
                max_length=64,
                choices=FORMAT_CHOICES,
                default=FORMAT_CHOICES[0][0]
            ).contribute_to_class(cls, 'format')

########NEW FILE########
__FILENAME__ = models
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

from django.contrib import admin
from django.core.exceptions import ImproperlyConfigured
from django.db import models
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy as _

from feincms.admin.item_editor import FeinCMSInline
from feincms.module.medialibrary.fields import ContentWithMediaFile


class MediaFileContentInline(FeinCMSInline):
    raw_id_fields = ('mediafile',)
    radio_fields = {'type': admin.VERTICAL}


class MediaFileContent(ContentWithMediaFile):
    """
    Rehashed, backwards-incompatible media file content which does not contain
    the problems from v1 anymore.

    Create a media file content as follows::

        from feincms.content.medialibrary.v2 import MediaFileContent
        Page.create_content_type(MediaFileContent, TYPE_CHOICES=(
            ('default', _('Default')),
            ('lightbox', _('Lightbox')),
            ('whatever', _('Whatever')),
            ))

    For a media file of type 'image' and type 'lightbox', the following
    templates are tried in order:

    * content/mediafile/image_lightbox.html
    * content/mediafile/image.html
    * content/mediafile/lightbox.html
    * content/mediafile/default.html

    The context contains ``content`` and ``request`` (if available).
    """

    feincms_item_editor_inline = MediaFileContentInline

    class Meta:
        abstract = True
        verbose_name = _('media file')
        verbose_name_plural = _('media files')

    @classmethod
    def initialize_type(cls, TYPE_CHOICES=None):
        if TYPE_CHOICES is None:
            raise ImproperlyConfigured(
                'You have to set TYPE_CHOICES when'
                ' creating a %s' % cls.__name__)

        cls.add_to_class(
            'type',
            models.CharField(
                _('type'),
                max_length=20,
                choices=TYPE_CHOICES,
                default=TYPE_CHOICES[0][0],
            )
        )

    def render(self, **kwargs):
        ctx = {'content': self}
        ctx.update(kwargs)
        return render_to_string([
            'content/mediafile/%s_%s.html' % (self.mediafile.type, self.type),
            'content/mediafile/%s.html' % self.mediafile.type,
            'content/mediafile/%s.html' % self.type,
            'content/mediafile/default.html',
        ], ctx, context_instance=kwargs.get('context'))

########NEW FILE########
__FILENAME__ = models
from __future__ import absolute_import, unicode_literals

from django.db import models
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _


class RawContent(models.Model):
    """
    Content type which can be used to input raw HTML code into the CMS.

    The content isn't escaped and can be used to insert CSS or JS
    snippets too.
    """

    text = models.TextField(_('content'), blank=True)

    class Meta:
        abstract = True
        verbose_name = _('raw content')
        verbose_name_plural = _('raw contents')

    def render(self, **kwargs):
        return mark_safe(self.text)

########NEW FILE########
__FILENAME__ = models
from __future__ import absolute_import, unicode_literals

from django import forms
from django.core.exceptions import ImproperlyConfigured
from django.db import models
from django.forms.util import ErrorList
from django.template.loader import render_to_string
from django.utils.html import escape
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _

from feincms import settings
from feincms.admin.item_editor import ItemEditorForm
from feincms.contrib.richtext import RichTextField
from feincms.utils import get_object


class RichTextContentAdminForm(ItemEditorForm):
    #: If FEINCMS_TIDY_ALLOW_WARNINGS_OVERRIDE allows, we'll convert this into
    # a checkbox so the user can choose whether to ignore HTML validation
    # warnings instead of fixing them:
    seen_tidy_warnings = forms.BooleanField(
        required=False,
        label=_("HTML Tidy"),
        help_text=_("Ignore the HTML validation warnings"),
        widget=forms.HiddenInput
    )

    def clean(self):
        cleaned_data = super(RichTextContentAdminForm, self).clean()

        if settings.FEINCMS_TIDY_HTML:
            text, errors, warnings = get_object(
                settings.FEINCMS_TIDY_FUNCTION)(cleaned_data['text'])

            # Ick, but we need to be able to update text and seen_tidy_warnings
            self.data = self.data.copy()

            # We always replace the HTML with the tidied version:
            cleaned_data['text'] = text
            self.data['%s-text' % self.prefix] = text

            if settings.FEINCMS_TIDY_SHOW_WARNINGS and (errors or warnings):
                if settings.FEINCMS_TIDY_ALLOW_WARNINGS_OVERRIDE:
                    # Convert the ignore input from hidden to Checkbox so the
                    # user can change it:
                    self.fields['seen_tidy_warnings'].widget =\
                        forms.CheckboxInput()

                if errors or not (
                        settings.FEINCMS_TIDY_ALLOW_WARNINGS_OVERRIDE
                        and cleaned_data['seen_tidy_warnings']):
                    self._errors["text"] = ErrorList([mark_safe(
                        _(
                            "HTML validation produced %(count)d warnings."
                            " Please review the updated content below before"
                            " continuing: %(messages)s"
                        ) % {
                            "count": len(warnings) + len(errors),
                            "messages": '<ul><li>%s</li></ul>' % (
                                "</li><li>".join(
                                    map(escape, errors + warnings))),
                        }
                    )])

                # If we're allowed to ignore warnings and we don't have any
                # errors we'll set our hidden form field to allow the user to
                # ignore warnings on the next submit:
                if (not errors
                        and settings.FEINCMS_TIDY_ALLOW_WARNINGS_OVERRIDE):
                    self.data["%s-seen_tidy_warnings" % self.prefix] = True

        return cleaned_data


class RichTextContent(models.Model):
    """
    Rich text content. Uses TinyMCE by default, but can be configured to do
    anything you want using ``FEINCMS_RICHTEXT_INIT_CONTEXT`` and
    ``FEINCMS_RICHTEXT_INIT_TEMPLATE``.

    If you are using TinyMCE 4.x then ``FEINCMS_RICHTEXT_INIT_TEMPLATE``
    needs to be set to ``admin/content/richtext/init_tinymce4.html``.

    Optionally runs the HTML code through HTML cleaners if you specify
    ``cleanse=True`` when calling ``create_content_type``.
    """

    form = RichTextContentAdminForm
    feincms_item_editor_form = RichTextContentAdminForm

    feincms_item_editor_context_processors = (
        lambda x: settings.FEINCMS_RICHTEXT_INIT_CONTEXT,
    )
    feincms_item_editor_includes = {
        'head': [settings.FEINCMS_RICHTEXT_INIT_TEMPLATE],
    }

    text = RichTextField(_('text'), blank=True)

    class Meta:
        abstract = True
        verbose_name = _('rich text')
        verbose_name_plural = _('rich texts')

    def render(self, **kwargs):
        return render_to_string(
            'content/richtext/default.html',
            {'content': self},
            context_instance=kwargs.get('context'))

    def save(self, *args, **kwargs):
        # TODO: Move this to the form?
        if getattr(self, 'cleanse', None):
            # Passes the rich text content as first argument because
            # the passed callable has been converted into a bound method
            self.text = self.cleanse(self.text)

        super(RichTextContent, self).save(*args, **kwargs)
    save.alters_data = True

    @classmethod
    def initialize_type(cls, cleanse=None):
        def to_instance_method(func):
            def func_im(self, *args, **kwargs):
                return func(*args, **kwargs)
            return func_im

        if cleanse:
            cls.cleanse = to_instance_method(cleanse)

        # TODO: Move this into somewhere more generic:
        if settings.FEINCMS_TIDY_HTML:
            # Make sure we can load the tidy function without dependency
            # failures:
            try:
                get_object(settings.FEINCMS_TIDY_FUNCTION)
            except ImportError as e:
                raise ImproperlyConfigured(
                    "FEINCMS_TIDY_HTML is enabled but the HTML tidy function"
                    " %s could not be imported: %s" % (
                        settings.FEINCMS_TIDY_FUNCTION, e))

########NEW FILE########
__FILENAME__ = models
from __future__ import absolute_import, unicode_literals

import time

from django.db import models
from django.utils import timezone
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _
from django.template.loader import render_to_string

import feedparser


class RSSContent(models.Model):
    """
    RSS feed inclusion content.

    This content requires a cronjob on the server, which runs
    ``./manage.py update_rsscontent`` every couple of hours.
    """

    title = models.CharField(
        _('title'), max_length=50,
        help_text=_(
            'The rss field is updated several times a day.'
            ' A change in the title will only be visible on the home page'
            ' after the next feed update.'))
    link = models.URLField(_('link'))
    rendered_content = models.TextField(
        _('pre-rendered content'), blank=True, editable=False)
    last_updated = models.DateTimeField(
        _('last updated'), blank=True, null=True)
    max_items = models.IntegerField(_('max. items'), default=5)

    class Meta:
        abstract = True
        verbose_name = _('RSS feed')
        verbose_name_plural = _('RSS feeds')

    def render(self, **kwargs):
        return mark_safe(self.rendered_content)

    def cache_content(self, date_format=None, save=True):
        feed = feedparser.parse(self.link)
        entries = feed['entries'][:self.max_items]
        if date_format:
            for entry in entries:
                entry.updated = time.strftime(
                    date_format, entry.updated_parsed)

        self.rendered_content = render_to_string(
            'content/rss/content.html',
            {
                'feed_title': self.title,
                'feed_link': feed['feed'].get('link'),
                'entries': entries,
            },
        )
        self.last_updated = timezone.now()

        if save:
            self.save()
    cache_content.alters_data = True

########NEW FILE########
__FILENAME__ = models
from __future__ import absolute_import, unicode_literals

from django.conf import settings as django_settings
from django.contrib import admin
from django.core.exceptions import ImproperlyConfigured
from django.db import models
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy as _

from feincms import settings
from feincms.admin.item_editor import FeinCMSInline
from feincms.contrib.richtext import RichTextField
from feincms.module.medialibrary.fields import MediaFileForeignKey
from feincms.module.medialibrary.models import MediaFile


class SectionContentInline(FeinCMSInline):
    raw_id_fields = ('mediafile',)
    radio_fields = {'type': admin.VERTICAL}


class SectionContent(models.Model):
    """
    Title, media file and rich text fields in one content block.
    """

    feincms_item_editor_inline = SectionContentInline
    feincms_item_editor_context_processors = (
        lambda x: settings.FEINCMS_RICHTEXT_INIT_CONTEXT,
    )
    feincms_item_editor_includes = {
        'head': [settings.FEINCMS_RICHTEXT_INIT_TEMPLATE],
    }

    title = models.CharField(_('title'), max_length=200, blank=True)
    richtext = RichTextField(_('text'), blank=True)
    mediafile = MediaFileForeignKey(
        MediaFile, verbose_name=_('media file'),
        related_name='+', blank=True, null=True)

    class Meta:
        abstract = True
        verbose_name = _('section')
        verbose_name_plural = _('sections')

    @classmethod
    def initialize_type(cls, TYPE_CHOICES=None, cleanse=None):
        if 'feincms.module.medialibrary' not in django_settings.INSTALLED_APPS:
            raise ImproperlyConfigured(
                'You have to add \'feincms.module.medialibrary\' to your'
                ' INSTALLED_APPS before creating a %s' % cls.__name__)

        if TYPE_CHOICES is None:
            raise ImproperlyConfigured(
                'You need to set TYPE_CHOICES when creating a'
                ' %s' % cls.__name__)

        cls.add_to_class('type', models.CharField(
            _('type'),
            max_length=10, choices=TYPE_CHOICES,
            default=TYPE_CHOICES[0][0]
        ))

        if cleanse:
            cls.cleanse = cleanse

    @classmethod
    def get_queryset(cls, filter_args):
        # Explicitly add nullable FK mediafile to minimize the DB query count
        return cls.objects.select_related('parent', 'mediafile').filter(
            filter_args)

    def render(self, **kwargs):
        if self.mediafile:
            mediafile_type = self.mediafile.type
        else:
            mediafile_type = 'nomedia'

        return render_to_string(
            [
                'content/section/%s_%s.html' % (mediafile_type, self.type),
                'content/section/%s.html' % mediafile_type,
                'content/section/%s.html' % self.type,
                'content/section/default.html',
            ],
            {'content': self},
        )

    def save(self, *args, **kwargs):
        if getattr(self, 'cleanse', None):
            try:
                # Passes the rich text content as first argument because
                # the passed callable has been converted into a bound method
                self.richtext = self.cleanse(self.richtext)
            except TypeError:
                # Call the original callable, does not pass the rich richtext
                # content instance along
                self.richtext = self.cleanse.im_func(self.richtext)

        super(SectionContent, self).save(*args, **kwargs)
    save.alters_data = True

########NEW FILE########
__FILENAME__ = models
from __future__ import absolute_import, unicode_literals

import os

from django.db import models
from django.template.loader import (
    Context, Template, TemplateDoesNotExist, find_template_loader)
from django.utils.translation import ugettext_lazy as _


DEFAULT_TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)


class TemplateChoices(object):
    def __init__(self, template_loaders):
        self.template_loaders = template_loaders

    def __iter__(self):
        seen = set()

        for loader in self.template_loaders:
            for basepath in loader.get_template_sources('.'):
                path = os.path.join(basepath, 'content', 'template')
                try:
                    templates = os.listdir(path)
                except (OSError, IOError):
                    continue

                for template in templates:
                    if template in seen:
                        continue
                    if template.endswith(('~', '.tmp')):
                        continue
                    seen.add(template)

        return ((t, t) for t in sorted(seen))


class TemplateContent(models.Model):
    """
    This content type scans all template folders for files in the
    ``content/template/`` folder and lets the website administrator select
    any template from a set of provided choices.

    The templates aren't restricted in any way.
    """

    class Meta:
        abstract = True
        verbose_name = _('template content')
        verbose_name_plural = _('template contents')

    @classmethod
    def initialize_type(cls, TEMPLATE_LOADERS=DEFAULT_TEMPLATE_LOADERS):
        cls.template_loaders = [
            find_template_loader(loader)
            for loader in TEMPLATE_LOADERS if loader]

        cls.add_to_class('filename', models.CharField(
            _('template'), max_length=100,
            choices=TemplateChoices(cls.template_loaders)))

    def render(self, **kwargs):
        context = kwargs.pop('context', None)
        name = 'content/template/%s' % self.filename

        for loader in self.template_loaders:
            try:
                template, display_name = loader.load_template(name)
            except TemplateDoesNotExist:
                continue

            if not hasattr(template, 'render'):
                template = Template(template, name=name)

            if context:
                ctx = context
                ctx.update(dict(content=self, **kwargs))
            else:
                ctx = Context(dict(content=self, **kwargs))

            result = template.render(ctx)

            if context:
                context.pop()

            return result

        return ''

########NEW FILE########
__FILENAME__ = models
from __future__ import absolute_import, unicode_literals

import re

from django.db import models
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy as _


class VideoContent(models.Model):
    """
    Copy-paste a URL to youtube or vimeo into the text box, this content type
    will automatically generate the necessary embed code.

    Other portals aren't supported currently, but would be easy to add if
    anyone would take up the baton.

    You should probably use feincms-oembed.
    """

    PORTALS = (
        ('youtube', re.compile(r'youtube'), lambda url: {
            'v': re.search(r'([?&]v=|./././)([^#&]+)', url).group(2),
        }),
        ('vimeo', re.compile(r'vimeo'), lambda url: {
            'id': re.search(r'/(\d+)', url).group(1),
        }),
        ('sf', re.compile(r'sf\.tv'), lambda url: {
            'id': re.search(r'/([a-z0-9\-]+)', url).group(1),
        }),
    )

    video = models.URLField(
        _('video link'),
        help_text=_(
            'This should be a link to a youtube or vimeo video,'
            ' i.e.: http://www.youtube.com/watch?v=zmj1rpzDRZ0'))

    class Meta:
        abstract = True
        verbose_name = _('video')
        verbose_name_plural = _('videos')

    def get_context_dict(self):
        "Extend this if you need more variables passed to template"
        return {'content': self, 'portal': 'unknown'}

    def get_templates(self, portal='unknown'):
        "Extend/override this if you want to modify the templates used"
        return [
            'content/video/%s.html' % portal,
            'content/video/unknown.html',
        ]

    def ctx_for_video(self, vurl):
        "Get a context dict for a given video URL"
        ctx = self.get_context_dict()
        for portal, match, context_fn in self.PORTALS:
            if match.search(vurl):
                try:
                    ctx.update(context_fn(vurl))
                    ctx['portal'] = portal
                    break
                except AttributeError:
                    continue
        return ctx

    def render(self, **kwargs):
        context_instance = kwargs.get('context')
        ctx = self.ctx_for_video(self.video)
        return render_to_string(
            self.get_templates(ctx['portal']),
            ctx,
            context_instance=context_instance)

########NEW FILE########
__FILENAME__ = context_processors
from feincms.module.page.models import Page


def add_page_if_missing(request):
    """
    Returns ``feincms_page`` for request.
    """

    try:
        return {
            'feincms_page': Page.objects.for_request(request, best_match=True),
        }
    except Page.DoesNotExist:
        return {}

########NEW FILE########
__FILENAME__ = fields
from __future__ import absolute_import, unicode_literals

import json
import logging

from django import forms
from django.db import models
from django.core.serializers.json import DjangoJSONEncoder
from django.utils import six


class JSONFormField(forms.fields.CharField):
    def clean(self, value, *args, **kwargs):
        # It seems that sometimes we receive dict objects here, not only
        # strings. Partial form validation maybe?
        if value:
            if isinstance(value, six.string_types):
                try:
                    value = json.loads(value)
                except ValueError:
                    raise forms.ValidationError("Invalid JSON data!")

            try:
                # Run the value through JSON so we can normalize formatting
                # and at least learn about malformed data:
                value = json.dumps(value, cls=DjangoJSONEncoder)
            except ValueError:
                raise forms.ValidationError("Invalid JSON data!")

        return super(JSONFormField, self).clean(value, *args, **kwargs)


class JSONField(six.with_metaclass(models.SubfieldBase, models.TextField)):
    """
    TextField which transparently serializes/unserializes JSON objects

    See:
    http://www.djangosnippets.org/snippets/1478/
    """

    formfield = JSONFormField

    def to_python(self, value):
        """Convert our string value to JSON after we load it from the DB"""

        if isinstance(value, dict):
            return value
        elif (isinstance(value, six.string_types)
                or isinstance(value, six.binary_type)):
            # Avoid asking the JSON decoder to handle empty values:
            if not value:
                return {}

            try:
                return json.loads(value)
            except ValueError:
                logging.getLogger("feincms.contrib.fields").exception(
                    "Unable to deserialize store JSONField data: %s", value)
                return {}
        else:
            assert value is None
            return {}

    def get_prep_value(self, value):
        """Convert our JSON object to a string before we save"""
        return self._flatten_value(value)

    def value_to_string(self, obj):
        """Extract our value from the passed object and return it in string
        form"""

        if hasattr(obj, self.attname):
            value = getattr(obj, self.attname)
        else:
            assert isinstance(obj, dict)
            value = obj.get(self.attname, "")

        return self._flatten_value(value)

    def _flatten_value(self, value):
        """Return either a string, JSON-encoding dict()s as necessary"""
        if not value:
            return ""

        if isinstance(value, dict):
            value = json.dumps(value, cls=DjangoJSONEncoder)

        assert isinstance(value, six.string_types)

        return value


try:
    from south.modelsinspector import add_introspection_rules

    JSONField_introspection_rule = ((JSONField,), [], {},)

    add_introspection_rules(
        rules=[JSONField_introspection_rule],
        patterns=["^feincms\.contrib\.fields"])
except ImportError:
    pass

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

from feincms.contrib.preview.views import PreviewHandler


urlpatterns = patterns(
    '',
    url(r'^(.*)/_preview/(\d+)/$', PreviewHandler.as_view(),
        name='feincms_preview'),
)

########NEW FILE########
__FILENAME__ = views
from __future__ import absolute_import, unicode_literals

from django.http import Http404
from django.shortcuts import get_object_or_404

from feincms.views.cbv.views import Handler


class PreviewHandler(Handler):
    """
    Preview handler

    The methods used in this handler should not be considered official API.

    *** Everything here is subject to change. ***
    """

    def get_object(self):
        """Get the page by the id in the url here instead."""

        page = get_object_or_404(self.page_model, pk=self.args[1])

        # Remove _preview/42/ from URL, the rest of the handler code should not
        # know that anything about previewing. Handler.prepare will still raise
        # a 404 if the extra_path isn't consumed by any content type
        self.request.path = page.get_absolute_url()

        return page

    def handler(self, request, *args, **kwargs):
        if not request.user.is_staff:
            raise Http404('Not found (not allowed)')
        response = super(PreviewHandler, self).handler(
            request, *args, **kwargs)
        response['Cache-Control'] =\
            'no-cache, must-revalidate, no-store, private'
        return response

########NEW FILE########
__FILENAME__ = richtext
from __future__ import absolute_import, unicode_literals

from django import forms
from django.db import models


class RichTextFormField(forms.fields.CharField):
    def __init__(self, *args, **kwargs):
        super(RichTextFormField, self).__init__(*args, **kwargs)
        css_class = self.widget.attrs.get('class', '')
        css_class += ' item-richtext'
        self.widget.attrs['class'] = css_class

    def clean(self, value):
        # TODO add cleansing here?
        return super(RichTextFormField, self).clean(value)


class RichTextField(models.TextField):
    """
    Drop-in replacement for Django's ``models.TextField`` which allows editing
    rich text instead of plain text in the item editor.
    """
    def formfield(self, form_class=RichTextFormField, **kwargs):
        return super(RichTextField, self).formfield(
            form_class=form_class, **kwargs)


try:
    from south.modelsinspector import add_introspection_rules

    RichTextField_introspection_rule = ((RichTextField,), [], {},)

    add_introspection_rules(
        rules=[RichTextField_introspection_rule],
        patterns=["^feincms\.contrib\.richtext"])
except ImportError:
    pass

########NEW FILE########
__FILENAME__ = tagging
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------
# FeinCMS django-tagging support. To add tagging to your (page) model,
# simply do a
#
#    from feincms.contrib import tagging
#    tagging.tag_model(Page)
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

from django import forms
from django.contrib.admin.widgets import FilteredSelectMultiple
from django.db.models.signals import pre_save
from django.utils import six
from django.utils.translation import ugettext_lazy as _

from tagging import AlreadyRegistered
from tagging.fields import TagField
from tagging.models import Tag
from tagging.utils import parse_tag_input


# ------------------------------------------------------------------------
def taglist_to_string(taglist):
    retval = ''
    if len(taglist) >= 1:
        taglist.sort()
        retval = ','.join(taglist)
    return retval

# ------------------------------------------------------------------------
# The following is lifted from:
# http://code.google.com/p/django-tagging/issues/detail?id=189

"""
TagSelectField

A variation of the django-tagging TagField which uses a
SelectMultiple widget instead of free text field.

class MyModel(models.Model):
    ...
    tags = TagSelectField(filter_horizontal=True, blank=False)

"""


class TagSelectFormField(forms.MultipleChoiceField):
    def clean(self, value):
        return taglist_to_string(list(value))


class TagSelectField(TagField):
    def __init__(self, filter_horizontal=False, *args, **kwargs):
        super(TagSelectField, self).__init__(*args, **kwargs)
        self.filter_horizontal = filter_horizontal

    def formfield(self, **defaults):
        if self.filter_horizontal:
            widget = FilteredSelectMultiple(
                self.verbose_name, is_stacked=False)
        else:
            widget = forms.SelectMultiple()

        def _render(name, value, attrs=None, *args, **kwargs):
            value = parse_tag_input(value)
            return type(widget).render(
                widget, name, value, attrs, *args, **kwargs)
        widget.render = _render
        defaults['widget'] = widget
        choices = [(
            six.text_type(t),
            six.text_type(t)) for t in Tag.objects.all()]
        return TagSelectFormField(
            choices=choices, required=not self.blank, **defaults)


# ------------------------------------------------------------------------
# ------------------------------------------------------------------------
def pre_save_handler(sender, instance, **kwargs):
    """
    Intercept attempts to save and sort the tag field alphabetically, so
    we won't have different permutations in the filter list.
    """
    taglist = parse_tag_input(instance.tags)
    instance.tags = taglist_to_string(taglist)


# ------------------------------------------------------------------------
def tag_model(cls, admin_cls=None, field_name='tags', sort_tags=False,
              select_field=False, auto_add_admin_field=True,
              admin_list_display=True):
    """
    tag_model accepts a number of named parameters:

    admin_cls   If set to a subclass of ModelAdmin, will insert the tag
                field into the list_display and list_filter fields.
    field_name  Defaults to "tags", can be used to name your tag field
                differently.
    sort_tags   Boolean, defaults to False. If set to True, a pre_save
                handler will be inserted to sort the tag field alphabetically.
                This is useful in case you want a canonical representation
                for a tag collection, as when yo're presenting a list of
                tag combinations (e.g. in an admin filter list).
    select_field If True, show a multi select instead of the standard
                CharField for tag entry.
    auto_add_admin_field If True, attempts to add the tag field to the admin
                class.
    """
    from tagging import register as tagging_register

    cls.add_to_class(field_name, (
        TagSelectField if select_field else TagField
    )(field_name.capitalize(), blank=True))
    # use another name for the tag descriptor
    # See http://code.google.com/p/django-tagging/issues/detail?id=95 for the
    # reason why
    try:
        tagging_register(cls, tag_descriptor_attr='tagging_' + field_name)
    except AlreadyRegistered:
        return

    if admin_cls:
        if admin_list_display:
            admin_cls.list_display.append(field_name)
        admin_cls.list_filter.append(field_name)

        if auto_add_admin_field and hasattr(
                admin_cls, 'add_extension_options'):
            admin_cls.add_extension_options(_('Tagging'), {
                'fields': (field_name,)
            })

    if sort_tags:
        pre_save.connect(pre_save_handler, sender=cls)

# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = default_settings
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------
"""
Default settings for FeinCMS

All of these can be overridden by specifying them in the standard
``settings.py`` file.
"""

from __future__ import absolute_import, unicode_literals

from os.path import join

from django.conf import settings

# ------------------------------------------------------------------------
# Settings for Generic Content

# e.g. 'uploads' if you would prefer <media root>/uploads/imagecontent/test.jpg
# to <media root>/imagecontent/test.jpg.
FEINCMS_UPLOAD_PREFIX = getattr(
    settings,
    'FEINCMS_UPLOAD_PREFIX',
    '')

# ------------------------------------------------------------------------
# Settings for MediaLibrary

#: Local path to newly uploaded media files
FEINCMS_MEDIALIBRARY_UPLOAD_TO = getattr(
    settings,
    'FEINCMS_MEDIALIBRARY_UPLOAD_TO',
    'medialibrary/%Y/%m/')

#: Thumbnail function for suitable mediafiles. Only receives the media file
#: and should return a thumbnail URL (or nothing).
FEINCMS_MEDIALIBRARY_THUMBNAIL = getattr(
    settings,
    'FEINCMS_MEDIALIBRARY_THUMBNAIL',
    'feincms.module.medialibrary.thumbnail.default_admin_thumbnail')

# ------------------------------------------------------------------------
# Settings for RichText

FEINCMS_RICHTEXT_INIT_TEMPLATE = getattr(
    settings,
    'FEINCMS_RICHTEXT_INIT_TEMPLATE',
    'admin/content/richtext/init_tinymce.html')
FEINCMS_RICHTEXT_INIT_CONTEXT = getattr(
    settings,
    'FEINCMS_RICHTEXT_INIT_CONTEXT', {
        'TINYMCE_JS_URL': join(settings.MEDIA_URL, 'js/tiny_mce/tiny_mce.js'),
        'TINYMCE_DOMAIN': None,
        'TINYMCE_CONTENT_CSS_URL': None,
        'TINYMCE_LINK_LIST_URL': None
    }
)

# ------------------------------------------------------------------------
# Admin media settings

#: avoid jQuery conflicts -- scripts should use feincms.jQuery instead of $
FEINCMS_JQUERY_NO_CONFLICT = getattr(
    settings,
    'FEINCMS_JQUERY_NO_CONFLICT',
    False)

# ------------------------------------------------------------------------
# Settings for the page module

#: Include ancestors in filtered tree editor lists
FEINCMS_TREE_EDITOR_INCLUDE_ANCESTORS = getattr(
    settings,
    'FEINCMS_TREE_EDITOR_INCLUDE_ANCESTORS',
    False)

#: Show frontend-editing button?
FEINCMS_FRONTEND_EDITING = getattr(
    settings,
    'FEINCMS_FRONTEND_EDITING',
    False)

#: Enable checking of object level permissions. Note that if this option is
#: enabled, you must plug in an authentication backend that actually does
#: implement object level permissions or no page will be editable.
FEINCMS_TREE_EDITOR_OBJECT_PERMISSIONS = getattr(
    settings,
    'FEINCMS_TREE_EDITOR_OBJECT_PERMISSIONS',
    False)

#: When enabled, the page module is automatically registered with Django's
#: default admin site (this is activated by default).
FEINCMS_USE_PAGE_ADMIN = getattr(
    settings,
    'FEINCMS_USE_PAGE_ADMIN',
    True)

#: app_label.model_name as per django.db.models.get_model.
#: defaults to page.Page
FEINCMS_DEFAULT_PAGE_MODEL = getattr(
    settings,
    'FEINCMS_DEFAULT_PAGE_MODEL',
    'page.Page')

# ------------------------------------------------------------------------
# Various settings

# ------------------------------------------------------------------------
#: Allow random gunk after a valid page?
FEINCMS_ALLOW_EXTRA_PATH = getattr(
    settings,
    'FEINCMS_ALLOW_EXTRA_PATH',
    False)

# ------------------------------------------------------------------------
#: How to switch languages.
#: * ``'STANDARD'``: The page a user navigates to sets the site's language
#:   and overwrites whatever was set before.
#: * ``'EXPLICIT'``: The language set has priority, may only be overridden
#:   by explicitely a language with ``?set_language=xx``.
FEINCMS_TRANSLATION_POLICY = getattr(
    settings,
    'FEINCMS_TRANSLATION_POLICY',
    'STANDARD')

# ------------------------------------------------------------------------
# Settings for HTML validation

#: If True, HTML will be run through a tidy function before saving:
FEINCMS_TIDY_HTML = getattr(
    settings,
    'FEINCMS_TIDY_HTML',
    False)
#: If True, displays form validation errors so the user can see how their
#: HTML has been changed:
FEINCMS_TIDY_SHOW_WARNINGS = getattr(
    settings,
    'FEINCMS_TIDY_SHOW_WARNINGS',
    True)
#: If True, users will be allowed to ignore HTML warnings (errors are always
#: blocked):
FEINCMS_TIDY_ALLOW_WARNINGS_OVERRIDE = getattr(
    settings,
    'FEINCMS_TIDY_ALLOW_WARNINGS_OVERRIDE',
    True)
#: Name of the tidy function - anything which takes ``(html)`` and returns
#: ``(html, errors, warnings)`` can be used:
FEINCMS_TIDY_FUNCTION = getattr(
    settings,
    'FEINCMS_TIDY_FUNCTION',
    'feincms.utils.html.tidy.tidy_html')

# ------------------------------------------------------------------------
#: Makes the page handling mechanism try to find a cms page with that
#: path if it encounters a page not found situation. This allows for nice
#: customised cms-styled error pages. Do not go overboard, this should
#: be as simple and as error resistant as possible, so refrain from
#: deeply nested error pages or advanced content types.
FEINCMS_CMS_404_PAGE = getattr(
    settings,
    'FEINCMS_CMS_404_PAGE',
    None)

# ------------------------------------------------------------------------
#: When uploading files to the media library, replacing an existing entry,
#: try to save the new file under the old file name in order to keep the
#: media file path (and thus the media url) constant.
#: Experimental, this might not work with all storage backends.
FEINCMS_MEDIAFILE_OVERWRITE = getattr(
    settings,
    'FEINCMS_MEDIAFILE_OVERWRITE',
    False)

# ------------------------------------------------------------------------
#: Prefix for thumbnails. Set this to something non-empty to separate thumbs
#: from uploads. The value should end with a slash, but this is not enforced.
FEINCMS_THUMBNAIL_DIR = getattr(
    settings,
    'FEINCMS_THUMBNAIL_DIR',
    '_thumbs/')

# ------------------------------------------------------------------------
#: Prevent changing template within admin for pages which have been
#: allocated a Template with singleton=True -- template field will become
#: read-only for singleton pages.
FEINCMS_SINGLETON_TEMPLATE_CHANGE_ALLOWED = getattr(
    settings,
    'FEINCMS_SINGLETON_TEMPLATE_CHANGE_ALLOWED',
    False)

#: Prevent admin page deletion for pages which have been allocated a
#: Template with singleton=True
FEINCMS_SINGLETON_TEMPLATE_DELETION_ALLOWED = getattr(
    settings,
    'FEINCMS_SINGLETON_TEMPLATE_DELETION_ALLOWED',
    False)

# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = extensions
"""
Base types for extensions refactor
"""

from __future__ import absolute_import, unicode_literals

from functools import wraps
import inspect

from django.contrib import admin
from django.core.exceptions import ImproperlyConfigured
from django.utils import six

from feincms.utils import get_object


class ExtensionsMixin(object):
    @classmethod
    def register_extensions(cls, *extensions):
        """
        Register all extensions passed as arguments.

        Extensions should be specified as a string to the python module
        containing the extension. If it is a bundled extension of FeinCMS,
        you do not need to specify the full python module path -- only
        specifying the last part (f.e. ``'seo'`` or ``'translations'``) is
        sufficient.
        """

        if not hasattr(cls, '_extensions'):
            cls._extensions = []
            cls._extensions_seen = []

        for ext in extensions:
            if ext in cls._extensions:
                continue

            extension = None

            if inspect.isclass(ext) and issubclass(ext, Extension):
                extension = ext

            elif isinstance(ext, six.string_types):
                try:
                    extension = get_object(ext)
                except (AttributeError, ImportError, ValueError):
                    if not extension:
                        raise ImproperlyConfigured(
                            '%s is not a valid extension for %s' % (
                                ext, cls.__name__))

            if hasattr(extension, 'Extension'):
                extension = extension.Extension

            elif hasattr(extension, 'register'):
                extension = extension.register

            elif hasattr(extension, '__call__'):
                pass

            else:
                raise ImproperlyConfigured(
                    '%s is not a valid extension for %s' % (
                        ext, cls.__name__))

            if extension in cls._extensions_seen:
                continue
            cls._extensions_seen.append(extension)

            if hasattr(extension, 'handle_model'):
                cls._extensions.append(extension(cls))
            else:
                raise ImproperlyConfigured(
                    '%r is an invalid extension.' % extension)


class Extension(object):
    def __init__(self, model, **kwargs):
        self.model = model
        for key, value in kwargs.items():
            if not hasattr(self, key):
                raise TypeError('%s() received an invalid keyword %r' % (
                    self.__class__.__name__, key))
            setattr(self, key, value)

        self.handle_model()

    def handle_model(self):
        raise NotImplementedError

    def handle_modeladmin(self, modeladmin):
        pass


def _ensure_list(cls, attribute):
    if cls is None:
        return
    value = getattr(cls, attribute, ()) or ()
    setattr(cls, attribute, list(value))


class ExtensionModelAdmin(admin.ModelAdmin):
    def __init__(self, *args, **kwargs):
        super(ExtensionModelAdmin, self).__init__(*args, **kwargs)
        self.initialize_extensions()

    def initialize_extensions(self):
        if not hasattr(self, '_extensions_initialized'):
            self._extensions_initialized = True
            for extension in getattr(self.model, '_extensions', []):
                extension.handle_modeladmin(self)

    def add_extension_options(self, *f):
        if self.fieldsets is None:
            return

        if isinstance(f[-1], dict):     # called with a fieldset
            self.fieldsets.insert(self.fieldset_insertion_index, f)
            f[1]['classes'] = list(f[1].get('classes', []))
            f[1]['classes'].append('collapse')
        elif f:   # assume called with "other" fields
            try:
                self.fieldsets[1][1]['fields'].extend(f)
            except IndexError:
                # Fall back to first fieldset if second does not exist
                # XXX This is really messy.
                self.fieldsets[0][1]['fields'].extend(f)

    def extend_list(self, attribute, iterable):
        extended = list(getattr(self, attribute, ()))
        extended.extend(iterable)
        setattr(self, attribute, extended)


def prefetch_modeladmin_get_queryset(modeladmin, *lookups):
    """
    Wraps default modeladmin ``get_queryset`` to prefetch related lookups.
    """
    def do_wrap(f):
        @wraps(f)
        def wrapper(request, *args, **kwargs):
            qs = f(request, *args, **kwargs)
            qs = qs.prefetch_related(*lookups)
            return qs
        return wrapper

    # queryset is renamed to get_queryset in Django 1.6
    fn = "get_queryset" if hasattr(modeladmin, "get_queryset") else "queryset"
    setattr(modeladmin, fn, do_wrap(getattr(modeladmin, fn)))

########NEW FILE########
__FILENAME__ = checker
from __future__ import absolute_import, print_function, unicode_literals

from django.core.management.color import color_style
from django.db import connection


def check_database_schema(cls, module_name):
    """
    Returns a function which inspects the database table of the passed class.
    It checks whether all fields in the model are available on the database
    too. This is especially helpful for models with an extension mechanism,
    where the extension might be activated after syncdb has been run for the
    first time.

    Please note that you have to connect the return value using strong
    references. Here's an example how to do this::

        signals.post_syncdb.connect(
            check_database_schema(Page, __name__), weak=False)

    (Yes, this is a weak attempt at a substitute for South until we find
    a way to make South work with FeinCMS' dynamic model creation.)
    """

    def _fn(sender, **kwargs):
        if sender.__name__ != module_name:
            return

        cursor = connection.cursor()

        existing_columns = [
            row[0]
            for row in connection.introspection.get_table_description(
                cursor, cls._meta.db_table)
        ]

        missing_columns = []

        for field in cls._meta.fields:
            if field.column not in existing_columns:
                missing_columns.append(field)

        if not missing_columns:
            return

        style = color_style()

        print(style.ERROR(
            'The following columns seem to be missing in the database table'
            ' %s:' % cls._meta.db_table))

        for field in missing_columns:
            print('%s:%s%s' % (
                style.SQL_KEYWORD(field.column),
                ' ' * (25 - len(field.column)),
                '%s.%s' % (
                    field.__class__.__module__, field.__class__.__name__),
            ))

        print(style.NOTICE(
            '\nPlease consult the output of `python manage.py sql %s` to'
            ' find out what the correct column types are. (Or use south,'
            ' which is what you should be doing anyway.)\n' % (
                cls._meta.app_label)))

    return _fn

########NEW FILE########
__FILENAME__ = feincms_validate
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------
"""
``feincms_validate``
--------------------

``feincms_validate`` checks your models for common pitfalls.
"""
from __future__ import absolute_import, print_function, unicode_literals

from django.core.management.base import NoArgsCommand
from django.core.management.color import color_style
from django.db.models import loading


class Command(NoArgsCommand):
    help = "Check models for common pitfalls."

    requires_model_validation = False

    def handle_noargs(self, **options):
        self.style = color_style()

        print("Running Django's own validation:")
        self.validate(display_num_errors=True)

        for model in loading.get_models():
            if hasattr(model, '_create_content_base'):
                self.validate_base_model(model)

            if hasattr(model, '_feincms_content_models'):
                self.validate_content_type(model)

    def validate_base_model(self, model):
        """
        Validate a subclass of ``feincms.models.Base`` or anything else
        created by ``feincms.models.create_base_model``
        """

        if not hasattr(model, 'template'):
            print(self.style.NOTICE(
                '%s has no template attribute; did you forget'
                ' register_templates or register_regions?' % model))

    def validate_content_type(self, model):
        """
        Validate a dynamically created concrete content type
        """

        for base in model.__bases__:
            if not base._meta.abstract:
                print(self.style.NOTICE(
                    'One of %s bases, %s, is not abstract' % (model, base)))

########NEW FILE########
__FILENAME__ = medialibrary_orphans
from __future__ import absolute_import, print_function, unicode_literals

import os

from django.core.management.base import NoArgsCommand
from django.utils.encoding import force_text

from feincms.module.medialibrary.models import MediaFile


class Command(NoArgsCommand):
    help = "Prints all orphaned files in the `media/medialibrary` folder"

    def handle_noargs(self, **options):
        mediafiles = list(MediaFile.objects.values_list('file', flat=True))

        # TODO make this smarter, and take MEDIA_ROOT into account
        for base, dirs, files in os.walk('media/medialibrary'):
            for f in files:
                full = os.path.join(base[6:], f)
                if force_text(full) not in mediafiles:
                    print(os.path.join(base, f))

########NEW FILE########
__FILENAME__ = rebuild_mptt
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------
"""
``rebuild_mptt``
---------------------

``rebuild_mptt`` rebuilds your mptt pointers. Only use in emergencies.
"""

from __future__ import absolute_import, print_function, unicode_literals

from django.core.management.base import NoArgsCommand

from feincms.module.page.models import Page


class Command(NoArgsCommand):
    help = (
        "Run this manually to rebuild your mptt pointers. Only use in"
        " emergencies.")

    def handle_noargs(self, **options):
        print("Rebuilding MPTT pointers for Page")
        Page._tree_manager.rebuild()

########NEW FILE########
__FILENAME__ = update_rsscontent
"""
``update_rsscontent``
---------------------

``update_rsscontent`` should be run as a cronjob when the ``RSSContent``
content type is used -- the content type itself does not update the
feed by itself.
"""

from __future__ import absolute_import, unicode_literals

from django.core.management.base import BaseCommand

from feincms.content.rss.models import RSSContent


class Command(BaseCommand):
    help = "Run this as a cronjob."

    def handle(self, date_format='', *args, **options):
        # find all concrete content types of RSSContent
        for cls in RSSContent._feincms_content_models:
            for content in cls.objects.all():
                if date_format:
                    content.cache_content(date_format=date_format)
                else:
                    content.cache_content()

########NEW FILE########
__FILENAME__ = models
"""
This is the core of FeinCMS

All models defined here are abstract, which means no tables are created in
the feincms\_ namespace.
"""

from __future__ import absolute_import, unicode_literals

from functools import reduce
import sys
import operator
import warnings

from django.contrib.contenttypes.models import ContentType
from django.core.exceptions import ImproperlyConfigured
from django.db import connections, models
from django.db.models import Q
from django.db.models.fields import FieldDoesNotExist
from django.db.models.loading import get_model
from django.forms.widgets import Media
from django.template.loader import render_to_string
from django.utils.datastructures import SortedDict
from django.utils.encoding import force_text, python_2_unicode_compatible
from django.utils.translation import ugettext_lazy as _

from feincms import ensure_completely_loaded
from feincms.extensions import ExtensionsMixin
from feincms.utils import copy_model_instance


@python_2_unicode_compatible
class Region(object):
    """
    This class represents a region inside a template. Example regions might be
    'main' and 'sidebar'.
    """

    def __init__(self, key, title, *args):
        self.key = key
        self.title = title
        self.inherited = args and args[0] == 'inherited' or False
        self._content_types = []

    def __str__(self):
        return force_text(self.title)

    @property
    def content_types(self):
        """
        Returns a list of content types registered for this region as a list
        of (content type key, beautified content type name) tuples
        """

        return [
            (ct.__name__.lower(), ct._meta.verbose_name)
            for ct in self._content_types
        ]


@python_2_unicode_compatible
class Template(object):
    """
    A template is a standard Django template which is used to render a
    CMS object, most commonly a page.
    """

    def __init__(self, title, path, regions, key=None, preview_image=None,
                 **kwargs):
        # The key is what will be stored in the database. If key is undefined
        # use the template path as fallback.
        if not key:
            key = path

        self.key = key
        self.title = title
        self.path = path
        self.preview_image = preview_image
        self.singleton = kwargs.get('singleton', False)
        self.child_template = kwargs.get('child_template', None)
        self.enforce_leaf = kwargs.get('enforce_leaf', False)
        self.urlconf = kwargs.get('urlconf', None)

        def _make_region(data):
            if isinstance(data, Region):
                return data
            return Region(*data)

        self.regions = [_make_region(row) for row in regions]
        self.regions_dict = dict((r.key, r) for r in self.regions)

    def __str__(self):
        return force_text(self.title)


class ContentProxy(object):
    """
    The ``ContentProxy`` is responsible for loading the content blocks for all
    regions (including content blocks in inherited regions) and assembling
    media definitions.

    The content inside a region can be fetched using attribute access with
    the region key. This is achieved through a custom ``__getattr__``
    implementation.
    """

    def __init__(self, item):
        item._needs_content_types()
        self.item = item
        self.db = item._state.db
        self._cache = {
            'cts': {},
        }

    def _inherit_from(self):
        """
        Returns a list of item primary keys to try inheriting content from if
        a certain region is empty.

        Returns an ascending list of ancestors (using MPTT) by default. This
        is good enough (tm) for pages.
        """

        return self.item.get_ancestors(ascending=True).values_list(
            'pk', flat=True)

    def _fetch_content_type_counts(self):
        """
        Returns a structure describing which content types exist for the object
        with the given primary key.

        The structure is as follows, where pk is the passed primary key and
        ct_idx are indices into the item._feincms_content_types list:

            {
                'region_key': [
                    (pk, ct_idx1),
                    (pk, ct_idx2),
                    ],
                ...
            }
        """

        if 'counts' not in self._cache:
            counts = self._fetch_content_type_count_helper(self.item.pk)

            empty_inherited_regions = set()
            for region in self.item.template.regions:
                if region.inherited and not counts.get(region.key):
                    empty_inherited_regions.add(region.key)

            if empty_inherited_regions:
                for parent in self._inherit_from():
                    parent_counts = self._fetch_content_type_count_helper(
                        parent, regions=tuple(empty_inherited_regions))

                    counts.update(parent_counts)
                    for key in parent_counts.keys():
                        empty_inherited_regions.discard(key)

                    if not empty_inherited_regions:
                        break

            self._cache['counts'] = counts
        return self._cache['counts']

    def _fetch_content_type_count_helper(self, pk, regions=None):
        tmpl = [
            'SELECT %d AS ct_idx, region, COUNT(id) FROM %s WHERE parent_id=%s'
        ]
        args = []

        if regions:
            tmpl.append(
                'AND region IN (' + ','.join(['%%s'] * len(regions)) + ')')
            args.extend(regions * len(self.item._feincms_content_types))

        tmpl.append('GROUP BY region')
        tmpl = ' '.join(tmpl)

        sql = ' UNION '.join([
            tmpl % (idx, cls._meta.db_table, pk)
            for idx, cls in enumerate(self.item._feincms_content_types)
        ])
        sql = 'SELECT * FROM ( ' + sql + ' ) AS ct ORDER BY ct_idx'

        cursor = connections[self.db].cursor()
        cursor.execute(sql, args)

        _c = {}
        for ct_idx, region, count in cursor.fetchall():
            if count:
                _c.setdefault(region, []).append((pk, ct_idx))

        return _c

    def _popuplate_content_type_caches(self, types):
        """
        Populate internal caches for all content types passed
        """

        counts_by_type = {}
        for region, counts in self._fetch_content_type_counts().items():
            for pk, ct_idx in counts:
                counts_by_type.setdefault(
                    self.item._feincms_content_types[ct_idx],
                    [],
                ).append((region, pk))

        # Resolve abstract to concrete content types
        content_types = (
            cls for cls in self.item._feincms_content_types
            if issubclass(cls, tuple(types))
        )

        for cls in content_types:
            counts = counts_by_type.get(cls)
            if cls not in self._cache['cts']:
                if counts:
                    self._cache['cts'][cls] = list(cls.get_queryset(reduce(
                        operator.or_,
                        (Q(region=r[0], parent=r[1]) for r in counts)
                    )))
                else:
                    self._cache['cts'][cls] = []

    def _fetch_regions(self):
        """
        Fetches all content types and group content types into regions
        """

        if 'regions' not in self._cache:
            self._popuplate_content_type_caches(
                self.item._feincms_content_types)
            contents = {}
            for cls, content_list in self._cache['cts'].items():
                for instance in content_list:
                    contents.setdefault(instance.region, []).append(instance)

            self._cache['regions'] = dict(
                (
                    region,
                    sorted(instances, key=lambda c: c.ordering),
                ) for region, instances in contents.items()
            )

        return self._cache['regions']

    def all_of_type(self, type_or_tuple):
        """
        Returns all content type instances belonging to the type or types
        passed.  If you want to filter for several types at the same time, type
        must be a tuple.

        The content type instances are sorted by their ``ordering`` value,
        but that isn't necessarily meaningful if the same content type exists
        in different regions.
        """

        content_list = []
        if not hasattr(type_or_tuple, '__iter__'):
            type_or_tuple = (type_or_tuple,)
        self._popuplate_content_type_caches(type_or_tuple)

        for type, contents in self._cache['cts'].items():
            if any(issubclass(type, t) for t in type_or_tuple):
                content_list.extend(contents)

        return sorted(content_list, key=lambda c: c.ordering)

    def _get_media(self):
        """
        Collect the media files of all content types of the current object
        """

        if 'media' not in self._cache:
            media = Media()

            for contents in self._fetch_regions().values():
                for content in contents:
                    if hasattr(content, 'media'):
                        media = media + content.media

            self._cache['media'] = media
        return self._cache['media']
    media = property(_get_media)

    def __getattr__(self, attr):
        """
        Get all item content instances for the specified item and region

        If no item contents could be found for the current item and the region
        has the inherited flag set, this method will go up the ancestor chain
        until either some item contents have found or no ancestors are left.
        """
        if (attr.startswith('__')):
            raise AttributeError

        # Do not trigger loading of real content type models if not necessary
        if not self._fetch_content_type_counts().get(attr):
            return []

        return self._fetch_regions().get(attr, [])


def create_base_model(inherit_from=models.Model):
    """
    This method can  be used to create a FeinCMS base model inheriting from
    your own custom subclass (f.e. extend ``MPTTModel``). The default is to
    extend :class:`django.db.models.Model`.
    """

    class Base(inherit_from, ExtensionsMixin):
        """
        This is the base class for your CMS models. It knows how to create and
        manage content types.
        """

        class Meta:
            abstract = True

        _cached_django_content_type = None

        @classmethod
        def register_regions(cls, *regions):
            """
            Register a list of regions. Only use this if you do not want to use
            multiple templates with this model (read: not use
            ``register_templates``)::

                BlogEntry.register_regions(
                    ('main', _('Main content area')),
                    )
            """

            if hasattr(cls, 'template'):
                warnings.warn(
                    'Ignoring second call to register_regions.',
                    RuntimeWarning)
                return

            # implicitly creates a dummy template object -- the item editor
            # depends on the presence of a template.
            cls.template = Template('', '', regions)
            cls._feincms_all_regions = cls.template.regions

        @classmethod
        def register_templates(cls, *templates):
            """
            Register templates and add a ``template_key`` field to the model
            for saving the selected template::

                Page.register_templates({
                    'key': 'base',
                    'title': _('Standard template'),
                    'path': 'feincms_base.html',
                    'regions': (
                        ('main', _('Main content area')),
                        ('sidebar', _('Sidebar'), 'inherited'),
                        ),
                    }, {
                    'key': '2col',
                    'title': _('Template with two columns'),
                    'path': 'feincms_2col.html',
                    'regions': (
                        ('col1', _('Column one')),
                        ('col2', _('Column two')),
                        ('sidebar', _('Sidebar'), 'inherited'),
                        ),
                    })
            """

            if not hasattr(cls, '_feincms_templates'):
                cls._feincms_templates = SortedDict()
                cls.TEMPLATES_CHOICES = []

            instances = cls._feincms_templates

            for template in templates:
                if not isinstance(template, Template):
                    template = Template(**template)

                instances[template.key] = template

            try:
                field = cls._meta.get_field_by_name('template_key')[0]
            except (FieldDoesNotExist, IndexError):
                cls.add_to_class(
                    'template_key',
                    models.CharField(_('template'), max_length=255, choices=())
                )
                field = cls._meta.get_field_by_name('template_key')[0]

                def _template(self):
                    ensure_completely_loaded()

                    try:
                        return self._feincms_templates[self.template_key]
                    except KeyError:
                        # return first template as a fallback if the template
                        # has changed in-between
                        return self._feincms_templates[
                            self._feincms_templates.keys()[0]]

                cls.template = property(_template)

            cls.TEMPLATE_CHOICES = field._choices = [
                (template_.key, template_.title,)
                for template_ in cls._feincms_templates.values()
            ]
            field.default = field.choices[0][0]

            # Build a set of all regions used anywhere
            cls._feincms_all_regions = set()
            for template in cls._feincms_templates.values():
                cls._feincms_all_regions.update(template.regions)

        #: ``ContentProxy`` class this object uses to collect content blocks
        content_proxy_class = ContentProxy

        @property
        def content(self):
            """
            Instantiate and return a ``ContentProxy``. You can use your own
            custom ``ContentProxy`` by assigning a different class to the
            ``content_proxy_class`` member variable.
            """

            if not hasattr(self, '_content_proxy'):
                self._content_proxy = self.content_proxy_class(self)

            return self._content_proxy

        @classmethod
        def _create_content_base(cls):
            """
            This is purely an internal method. Here, we create a base class for
            the concrete content types, which are built in
            ``create_content_type``.

            The three fields added to build a concrete content type class/model
            are ``parent``, ``region`` and ``ordering``.
            """

            # We need a template, because of the possibility of restricting
            # content types to a subset of all available regions. Each region
            # object carries a list of all allowed content types around.
            # Content types created before a region is initialized would not be
            # available in the respective region; we avoid this problem by
            # raising an ImproperlyConfigured exception early.
            cls._needs_templates()

            class Meta:
                abstract = True
                app_label = cls._meta.app_label
                ordering = ['ordering']

            def __str__(self):
                return (
                    '%s<pk=%s, parent=%s<pk=%s, %s>, region=%s,'
                    ' ordering=%d>') % (
                    self.__class__.__name__,
                    self.pk,
                    self.parent.__class__.__name__,
                    self.parent.pk,
                    self.parent,
                    self.region,
                    self.ordering)

            def render(self, **kwargs):
                """
                Default render implementation, tries to call a method named
                after the region key before giving up.

                You'll probably override the render method itself most of the
                time instead of adding region-specific render methods.
                """

                render_fn = getattr(self, 'render_%s' % self.region, None)

                if render_fn:
                    return render_fn(**kwargs)

                raise NotImplementedError

            def fe_render(self, **kwargs):
                """
                Frontend Editing enabled renderer
                """

                if 'request' in kwargs:
                    request = kwargs['request']

                    if (hasattr(request, 'COOKIES')
                            and request.COOKIES.get('frontend_editing')):
                        return render_to_string('admin/feincms/fe_box.html', {
                            'content': self.render(**kwargs),
                            'identifier': self.fe_identifier(),
                        })

                return self.render(**kwargs)

            def fe_identifier(self):
                """
                Returns an identifier which is understood by the frontend
                editing javascript code. (It is used to find the URL which
                should be used to load the form for every given block of
                content.)
                """

                return '%s-%s-%s-%s-%s' % (
                    cls._meta.app_label,
                    cls._meta.module_name,
                    self.__class__.__name__.lower(),
                    self.parent_id,
                    self.id,
                )

            def get_queryset(cls, filter_args):
                return cls.objects.select_related().filter(filter_args)

            attrs = {
                # The basic content type is put into
                # the same module as the CMS base type.
                # If an app_label is not given, Django
                # needs to know where a model comes
                # from, therefore we ensure that the
                # module is always known.
                '__module__': cls.__module__,
                '__str__': __str__,
                'render': render,
                'fe_render': fe_render,
                'fe_identifier': fe_identifier,
                'get_queryset': classmethod(get_queryset),
                'Meta': Meta,
                'parent': models.ForeignKey(cls, related_name='%(class)s_set'),
                'region': models.CharField(max_length=255),
                'ordering': models.IntegerField(_('ordering'), default=0),
            }

            # create content base type and save reference on CMS class

            name = '_Internal%sContentTypeBase' % cls.__name__
            if hasattr(sys.modules[cls.__module__], name):
                warnings.warn(
                    'The class %s.%s has the same name as the class that '
                    'FeinCMS auto-generates based on %s.%s. To avoid database'
                    'errors and import clashes, rename one of these classes.'
                    % (cls.__module__, name, cls.__module__, cls.__name__),
                    RuntimeWarning)

            cls._feincms_content_model = python_2_unicode_compatible(
                type(str(name), (models.Model,), attrs))

            # list of concrete content types
            cls._feincms_content_types = []

            # list of concrete content types having methods which may be called
            # before or after rendering the content:
            #
            # def process(self, request, **kwargs):
            #     May return a response early to short-circuit the
            #     request-response cycle
            #
            # def finalize(self, request, response)
            #     May modify the response or replace it entirely by returning
            #     a new one
            #
            cls._feincms_content_types_with_process = []
            cls._feincms_content_types_with_finalize = []

            # list of item editor context processors, will be extended by
            # content types
            if hasattr(cls, 'feincms_item_editor_context_processors'):
                cls.feincms_item_editor_context_processors = list(
                    cls.feincms_item_editor_context_processors)
            else:
                cls.feincms_item_editor_context_processors = []

            # list of templates which should be included in the item editor,
            # will be extended by content types
            if hasattr(cls, 'feincms_item_editor_includes'):
                cls.feincms_item_editor_includes = dict(
                    cls.feincms_item_editor_includes)
            else:
                cls.feincms_item_editor_includes = {}

        @classmethod
        def create_content_type(cls, model, regions=None, class_name=None,
                                **kwargs):
            """
            This is the method you'll use to create concrete content types.

            If the CMS base class is ``page.models.Page``, its database table
            will be ``page_page``. A concrete content type which is created
            from ``ImageContent`` will use ``page_page_imagecontent`` as its
            table.

            If you want a content type only available in a subset of regions,
            you can pass a list/tuple of region keys as ``regions``. The
            content type will only appear in the corresponding tabs in the item
            editor.

            If you use two content types with the same name in the same module,
            name clashes will happen and the content type created first will
            shadow all subsequent content types. You can work around it by
            specifying the content type class name using the ``class_name``
            argument. Please note that this will have an effect on the entries
            in ``django_content_type``, on ``related_name`` and on the table
            name used and should therefore not be changed after running
            ``syncdb`` for the first time.

            Name clashes will also happen if a content type has defined a
            relationship and you try to register that content type to more than
            one Base model (in different modules).  Django will raise an error
            when it tries to create the backward relationship. The solution to
            that problem is, as shown above, to specify the content type class
            name with the ``class_name`` argument.

            If you register a content type to more than one Base class, it is
            recommended to always specify a ``class_name`` when registering it
            a second time.

            You can pass additional keyword arguments to this factory function.
            These keyword arguments will be passed on to the concrete content
            type, provided that it has a ``initialize_type`` classmethod. This
            is used f.e. in ``MediaFileContent`` to pass a set of possible
            media positions (f.e. left, right, centered) through to the content
            type.
            """

            if not class_name:
                class_name = model.__name__

            # prevent double registration and registration of two different
            # content types with the same class name because of related_name
            # clashes
            try:
                getattr(cls, '%s_set' % class_name.lower())
                warnings.warn(
                    'Cannot create content type using %s.%s for %s.%s,'
                    ' because %s_set is already taken.' % (
                        model.__module__, class_name,
                        cls.__module__, cls.__name__,
                        class_name.lower()),
                    RuntimeWarning)
                return
            except AttributeError:
                # everything ok
                pass

            # Next name clash test. Happens when the same content type is
            # created for two Base subclasses living in the same Django
            # application (github issues #73 and #150)
            try:
                other_model = get_model(cls._meta.app_label, class_name)
                if other_model is None:
                    # Django 1.6 and earlier
                    raise LookupError
            except LookupError:
                pass
            else:
                warnings.warn(
                    'It seems that the content type %s exists twice in %s.'
                    ' Use the class_name argument to create_content_type to'
                    ' avoid this error.' % (
                        model.__name__,
                        cls._meta.app_label),
                    RuntimeWarning)

            if not model._meta.abstract:
                raise ImproperlyConfigured(
                    'Cannot create content type from'
                    ' non-abstract model (yet).')

            if not hasattr(cls, '_feincms_content_model'):
                cls._create_content_base()

            feincms_content_base = cls._feincms_content_model

            class Meta(feincms_content_base.Meta):
                db_table = '%s_%s' % (cls._meta.db_table, class_name.lower())
                verbose_name = model._meta.verbose_name
                verbose_name_plural = model._meta.verbose_name_plural
                permissions = model._meta.permissions

            attrs = {
                # put the concrete content type into the
                # same module as the CMS base type; this is
                # necessary because 1. Django needs to know
                # the module where a model lives and 2. a
                # content type may be used by several CMS
                # base models at the same time (f.e. in
                # the blog and the page module).
                '__module__': cls.__module__,
                'Meta': Meta,
            }

            new_type = type(
                str(class_name),
                (model, feincms_content_base,),
                attrs,
            )
            cls._feincms_content_types.append(new_type)
            # For consistency's sake, also install the new type in the module
            setattr(sys.modules[cls.__module__], class_name, new_type)

            if hasattr(getattr(new_type, 'process', None), '__call__'):
                cls._feincms_content_types_with_process.append(new_type)
            if hasattr(getattr(new_type, 'finalize', None), '__call__'):
                cls._feincms_content_types_with_finalize.append(new_type)

            # content types can be limited to a subset of regions
            if not regions:
                regions = set([
                    region.key for region in cls._feincms_all_regions])

            for region in cls._feincms_all_regions:
                if region.key in regions:
                    region._content_types.append(new_type)

            # Add a list of CMS base types for which a concrete content type
            # has been created to the abstract content type. This is needed
            # f.e. for the update_rsscontent management command, which needs to
            # find all concrete RSSContent types, so that the RSS feeds can be
            # fetched
            if not hasattr(model, '_feincms_content_models'):
                model._feincms_content_models = []

            model._feincms_content_models.append(new_type)

            # Add a backlink from content-type to content holder class
            new_type._feincms_content_class = cls

            # Handle optgroup argument for grouping content types in the item
            # editor
            optgroup = kwargs.pop('optgroup', None)
            if optgroup:
                new_type.optgroup = optgroup

            # customization hook.
            if hasattr(new_type, 'initialize_type'):
                new_type.initialize_type(**kwargs)
            else:
                for k, v in kwargs.items():
                    setattr(new_type, k, v)

            # collect item editor context processors from the content type
            if hasattr(model, 'feincms_item_editor_context_processors'):
                cls.feincms_item_editor_context_processors.extend(
                    model.feincms_item_editor_context_processors)

            # collect item editor includes from the content type
            if hasattr(model, 'feincms_item_editor_includes'):
                for key, incls in model.feincms_item_editor_includes.items():
                    cls.feincms_item_editor_includes.setdefault(
                        key, set()).update(incls)

            ensure_completely_loaded(force=True)
            return new_type

        @property
        def _django_content_type(self):
            if not getattr(self, '_cached_django_content_type', None):
                self.__class__._cached_django_content_type = (
                    ContentType.objects.get_for_model(self))
            return self.__class__._cached_django_content_type

        @classmethod
        def content_type_for(cls, model):
            """
            Return the concrete content type for an abstract content type::

                from feincms.content.video.models import VideoContent
                concrete_type = Page.content_type_for(VideoContent)
            """

            if (not hasattr(cls, '_feincms_content_types')
                    or not cls._feincms_content_types):
                return None

            for type in cls._feincms_content_types:
                if issubclass(type, model):
                    if type.__base__ is model:
                        return type
            return None

        @classmethod
        def _needs_templates(cls):
            ensure_completely_loaded()

            # helper which can be used to ensure that either register_regions
            # or register_templates has been executed before proceeding
            if not hasattr(cls, 'template'):
                raise ImproperlyConfigured(
                    'You need to register at least one'
                    ' template or one region on %s.' % cls.__name__)

        @classmethod
        def _needs_content_types(cls):
            ensure_completely_loaded()

            # Check whether any content types have been created for this base
            # class
            if (
                    not hasattr(cls, '_feincms_content_types')
                    or not cls._feincms_content_types):
                raise ImproperlyConfigured(
                    'You need to create at least one'
                    ' content type for the %s model.' % cls.__name__)

        def copy_content_from(self, obj):
            """
            Copy all content blocks over to another CMS base object. (Must be
            of the same type, but this is not enforced. It will crash if you
            try to copy content from another CMS base type.)
            """

            for cls in self._feincms_content_types:
                for content in cls.objects.filter(parent=obj):
                    new = copy_model_instance(
                        content, exclude=('id', 'parent'))
                    new.parent = self
                    new.save()

        def replace_content_with(self, obj):
            """
            Replace the content of the current object with content of another.

            Deletes all content blocks and calls ``copy_content_from``
            afterwards.
            """

            for cls in self._feincms_content_types:
                cls.objects.filter(parent=self).delete()
            self.copy_content_from(obj)

        @classmethod
        def register_with_reversion(cls):
            try:
                import reversion
            except ImportError:
                raise EnvironmentError("django-reversion is not installed")

            follow = []
            for content_type in cls._feincms_content_types:
                follow.append('%s_set' % content_type.__name__.lower())
                reversion.register(content_type)
            reversion.register(cls, follow=follow)

    return Base


# Legacy support
Base = create_base_model()

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from feincms.module.blog.models import Entry, EntryAdmin


admin.site.register(Entry, EntryAdmin)

########NEW FILE########
__FILENAME__ = tags
"""
Simple tagging support using ``django-tagging``.
"""

from __future__ import absolute_import, unicode_literals

from django.utils.translation import ugettext_lazy as _

from feincms import extensions

import tagging
from tagging.fields import TagField


class Extension(extensions.Extension):
    def handle_model(self):
        self.model.add_to_class('tags', TagField(_('tags')))

        # use another name for the tag descriptor See
        # http://code.google.com/p/django-tagging/issues/detail?id=95 for the
        # reason why
        tagging.register(self.model, tag_descriptor_attr='etags')

    def handle_modeladmin(self, modeladmin):
        modeladmin.add_extension_options('tags')

########NEW FILE########
__FILENAME__ = translations
"""
This extension adds a language field to every blog entry.

Blog entries in secondary languages can be said to be a translation of a
blog entry in the primary language (the first language in settings.LANGUAGES),
thereby enabling deeplinks between translated blog entries.
"""

from __future__ import absolute_import, unicode_literals

from django.conf import settings
from django.db import models
from django.utils.translation import ugettext_lazy as _

from feincms import extensions


class Extension(extensions.Extension):
    def handle_model(self):
        primary_language = settings.LANGUAGES[0][0]

        self.model.add_to_class(
            'language',
            models.CharField(
                _('language'),
                max_length=10,
                choices=settings.LANGUAGES,
            )
        )
        self.model.add_to_class(
            'translation_of',
            models.ForeignKey(
                'self',
                blank=True, null=True,
                verbose_name=_('translation of'),
                related_name='translations',
                limit_choices_to={'language': primary_language},
                help_text=_(
                    'Leave this empty for entries in the primary language.'),
            )
        )

        def available_translations(self):
            if self.language == primary_language:
                return self.translations.all()
            elif self.translation_of:
                return [self.translation_of] + list(
                    self.translation_of.translations.exclude(
                        language=self.language))
            else:
                return []

        self.model.available_translations = available_translations

        def available_translations_admin(self):
            translations = self.available_translations()

            return ', '.join(
                '<a href="%s/">%s</a>' % (
                    page.id,
                    page.language.upper()
                ) for page in translations
            )

        available_translations_admin.allow_tags = True
        available_translations_admin.short_description =\
            _('available translations')
        self.model.available_translations_admin = available_translations_admin

    def handle_modeladmin(self, modeladmin):
        modeladmin.add_extension_options('language')

        modeladmin.list_display.extend((
            'language', 'available_translations_admin'))
        modeladmin.list_filter.extend(('language',))

        modeladmin.raw_id_fields.append('translation_of')

########NEW FILE########
__FILENAME__ = models
"""
This is more a proof-of-concept for your own :class:`feincms.module.Base`
subclasses than a polished or even sufficient blog module implementation.

It does work, though.
"""

from __future__ import absolute_import, unicode_literals

from django.db import models
from django.db.models import signals
from django.utils import timezone
from django.utils.encoding import python_2_unicode_compatible
from django.utils.translation import ugettext_lazy as _

from feincms.admin import item_editor
from feincms.management.checker import check_database_schema
from feincms.models import Base


class EntryManager(models.Manager):
    def published(self):
        return self.filter(
            published=True,
            published_on__isnull=False,
            published_on__lte=timezone.now(),
        )


@python_2_unicode_compatible
class Entry(Base):
    published = models.BooleanField(_('published'), default=False)
    title = models.CharField(
        _('title'), max_length=100,
        help_text=_('This is used for the generated navigation too.'))
    slug = models.SlugField()

    published_on = models.DateTimeField(
        _('published on'), blank=True, null=True,
        help_text=_(
            'Will be set automatically once you tick the `published`'
            ' checkbox above.'))

    class Meta:
        get_latest_by = 'published_on'
        ordering = ['-published_on']
        verbose_name = _('entry')
        verbose_name_plural = _('entries')

    objects = EntryManager()

    def __str__(self):
        return self.title

    def save(self, *args, **kwargs):
        if self.published and not self.published_on:
            self.published_on = timezone.now()
        super(Entry, self).save(*args, **kwargs)
    save.alters_data = True

    @models.permalink
    def get_absolute_url(self):
        return ('blog_entry_detail', (self.id,), {})


signals.post_syncdb.connect(check_database_schema(Entry, __name__), weak=False)


class EntryAdmin(item_editor.ItemEditor):
    date_hierarchy = 'published_on'
    list_display = ['__str__', 'published', 'published_on']
    list_filter = ['published']
    search_fields = ['title', 'slug']
    prepopulated_fields = {
        'slug': ('title',),
    }

    raw_id_fields = []

########NEW FILE########
__FILENAME__ = changedate
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------
"""
Track the modification date for objects.
"""

from __future__ import absolute_import, unicode_literals

from email.utils import parsedate_tz, mktime_tz

from django.db import models
from django.db.models.signals import pre_save
from django.utils import timezone
from django.utils.translation import ugettext_lazy as _

from feincms import extensions


# ------------------------------------------------------------------------
def pre_save_handler(sender, instance, **kwargs):
    """
    Intercept attempts to save and insert the current date and time into
    creation and modification date fields.
    """
    now = timezone.now()
    if instance.id is None:
        instance.creation_date = now
    instance.modification_date = now


# ------------------------------------------------------------------------
def dt_to_utc_timestamp(dt):
    from time import mktime
    return int(mktime(dt.timetuple()))


class Extension(extensions.Extension):
    def handle_model(self):
        self.model.add_to_class('creation_date', models.DateTimeField(
            _('creation date'), null=True, editable=False))
        self.model.add_to_class('modification_date', models.DateTimeField(
            _('modification date'), null=True, editable=False))

        if hasattr(self.model, 'cache_key_components'):
            self.model.cache_key_components.append(
                lambda page: page.modification_date and str(
                    dt_to_utc_timestamp(page.modification_date)))

        self.model.last_modified = lambda p: p.modification_date

        pre_save.connect(pre_save_handler, sender=self.model)


# ------------------------------------------------------------------------
def last_modified_response_processor(page, request, response):
    from django.utils.http import http_date

    # Don't include Last-Modified if we don't want to be cached
    if "no-cache" in response.get('Cache-Control', ''):
        return

    # If we already have a Last-Modified, take the later one
    last_modified = dt_to_utc_timestamp(page.last_modified())
    if response.has_header('Last-Modified'):
        last_modified = max(
            last_modified,
            mktime_tz(parsedate_tz(response['Last-Modified'])))

    response['Last-Modified'] = http_date(last_modified)

# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = ct_tracker
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------
#
#  ct_tracker.py
#  FeinCMS
#
#  Created by Martin J. Laubach on 02.10.09.
#  Copyright (c) 2009 Martin J. Laubach. All rights reserved.
#  Updated in 2011 by Matthias Kestenholz for the 1.3 release.
#
# ------------------------------------------------------------------------

"""
Track the content types for pages. Instead of gathering the content
types present in each page at run time, save the current state at
saving time, thus saving at least one DB query on page delivery.
"""

from __future__ import absolute_import, unicode_literals

from django.contrib.contenttypes.models import ContentType
from django.db.models.signals import class_prepared, post_save, pre_save
from django.utils.translation import ugettext_lazy as _

from feincms import extensions
from feincms.contrib.fields import JSONField
from feincms.models import ContentProxy


INVENTORY_VERSION = 1
_translation_map_cache = {}


# ------------------------------------------------------------------------
class TrackerContentProxy(ContentProxy):
    def _fetch_content_type_counts(self):
        """
        If an object with an empty _ct_inventory is encountered, compute all
        the content types currently used on that object and save the list in
        the object itself. Further requests for that object can then access
        that information and find out which content types are used without
        resorting to multiple selects on different ct tables.

        It is therefore important that even an "empty" object does not have an
        empty _ct_inventory.
        """

        if 'counts' not in self._cache:
            if (self.item._ct_inventory
                    and self.item._ct_inventory.get('_version_', -1)
                    == INVENTORY_VERSION):

                try:
                    self._cache['counts'] = self._from_inventory(
                        self.item._ct_inventory)
                except KeyError:
                    # It's possible that the inventory does not fit together
                    # with the current models anymore, f.e. because a content
                    # type has been removed.
                    pass

            if 'counts' not in self._cache:
                super(TrackerContentProxy, self)._fetch_content_type_counts()

                self.item._ct_inventory = self._to_inventory(
                    self._cache['counts'])

                if hasattr(self.item, 'invalidate_cache'):
                    self.item.invalidate_cache()
                self.item.__class__.objects.filter(id=self.item.id).update(
                    _ct_inventory=self.item._ct_inventory)

                # Run post save handler by hand
                if hasattr(self.item, 'get_descendants'):
                    self.item.get_descendants(include_self=False).update(
                        _ct_inventory=None)
        return self._cache['counts']

    def _translation_map(self):
        cls = self.item.__class__
        if cls not in _translation_map_cache:
            # Prime translation map and cache it in the class. This needs to be
            # done late as opposed to at class definition time as not all
            # information is ready, especially when we are doing a "syncdb" the
            # ContentType table does not yet exist
            map = {}
            for idx, fct in enumerate(self.item._feincms_content_types):
                dct = ContentType.objects.get_for_model(fct)

                # Rely on non-negative primary keys
                map[-dct.id] = idx  # From-inventory map
                map[idx] = dct.id  # To-inventory map

            _translation_map_cache[cls] = map
        return _translation_map_cache[cls]

    def _from_inventory(self, inventory):
        """
        Transforms the inventory from Django's content types to FeinCMS's
        ContentProxy counts format.
        """

        map = self._translation_map()

        return dict((region, [
            (pk, map[-ct]) for pk, ct in items
        ]) for region, items in inventory.items() if region != '_version_')

    def _to_inventory(self, counts):
        map = self._translation_map()

        inventory = dict(
            (
                region,
                [(pk, map[ct]) for pk, ct in items],
            ) for region, items in counts.items()
        )
        inventory['_version_'] = INVENTORY_VERSION
        return inventory


# ------------------------------------------------------------------------
def class_prepared_handler(sender, **kwargs):
    # It might happen under rare circumstances that not all model classes
    # are fully loaded and initialized when the translation map is accessed.
    # This leads to (lots of) crashes on the server. Better be safe and
    # kill the translation map when any class_prepared signal is received.
    global _translation_map_cache
    _translation_map_cache = {}
class_prepared.connect(class_prepared_handler)


# ------------------------------------------------------------------------
def tree_post_save_handler(sender, instance, **kwargs):
    """
    Clobber the _ct_inventory attribute of this object and all sub-objects
    on save.
    """
    # TODO: Does not find everything it should when ContentProxy content
    # inheritance has been customized.
    instance.get_descendants(include_self=True).update(_ct_inventory=None)


# ------------------------------------------------------------------------
def single_pre_save_handler(sender, instance, **kwargs):
    """Clobber the _ct_inventory attribute of this object"""

    instance._ct_inventory = None


# ------------------------------------------------------------------------
class Extension(extensions.Extension):
    def handle_model(self):
        self.model.add_to_class('_ct_inventory', JSONField(
            _('content types'), editable=False, blank=True, null=True))
        self.model.content_proxy_class = TrackerContentProxy

        pre_save.connect(single_pre_save_handler, sender=self.model)
        if hasattr(self.model, 'get_descendants'):
            post_save.connect(tree_post_save_handler, sender=self.model)

# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = datepublisher
"""
Allows setting a date range for when the page is active. Modifies the active()
manager method so that only pages inside the given range are used in the
default views and the template tags.

Depends on the page class having a "active_filters" list that will be used by
the page's manager to determine which entries are to be considered active.
"""
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

from datetime import datetime

from django.db import models
from django.db.models import Q
from django.utils import timezone
from django.utils.cache import patch_response_headers
from django.utils.translation import ugettext_lazy as _

from feincms import extensions


# ------------------------------------------------------------------------
def format_date(d, if_none=''):
    """
    Format a date in a nice human readable way: Omit the year if it's the
    current year. Also return a default value if no date is passed in.
    """

    if d is None:
        return if_none

    now = timezone.now()
    fmt = (d.year == now.year) and '%d.%m' or '%d.%m.%Y'
    return d.strftime(fmt)


def latest_children(self):
    return self.get_children().order_by('-publication_date')


# ------------------------------------------------------------------------
def granular_now(n=None):
    """
    A datetime.now look-alike that returns times rounded to a five minute
    boundary. This helps the backend database to optimize/reuse/cache its
    queries by not creating a brand new query each time.

    Also useful if you are using johnny-cache or a similar queryset cache.
    """
    if n is None:
        n = timezone.now()
    return timezone.make_aware(
        datetime(n.year, n.month, n.day, n.hour, (n.minute // 5) * 5),
        n.tzinfo)


# ------------------------------------------------------------------------
def datepublisher_response_processor(page, request, response):
    """
    This response processor is automatically added when the datepublisher
    extension is registered. It sets the response headers to match with
    the publication end date of the page so that upstream caches and
    the django caching middleware know when to expunge the copy.
    """
    expires = page.publication_end_date
    if expires is not None:
        now = datetime.now()
        delta = expires - now

        try:
            delta = int(delta.days * 86400 + delta.seconds)
        except Exception:
            # This happens once every four years (or so)
            delta = int(delta.days * 86400 + delta.seconds - 7200)

        patch_response_headers(response, delta)


# ------------------------------------------------------------------------
class Extension(extensions.Extension):
    def handle_model(self):
        self.model.add_to_class(
            'publication_date',
            models.DateTimeField(_('publication date'), default=granular_now))
        self.model.add_to_class(
            'publication_end_date',
            models.DateTimeField(
                _('publication end date'),
                blank=True, null=True,
                help_text=_(
                    'Leave empty if the entry should stay active forever.')))
        self.model.add_to_class('latest_children', latest_children)

        # Patch in rounding the pub and pub_end dates on save
        orig_save = self.model.save

        def granular_save(obj, *args, **kwargs):
            if obj.publication_date:
                obj.publication_date = granular_now(obj.publication_date)
            if obj.publication_end_date:
                obj.publication_end_date = granular_now(
                    obj.publication_end_date)
            orig_save(obj, *args, **kwargs)
        self.model.save = granular_save

        # Append publication date active check
        if hasattr(self.model._default_manager, 'add_to_active_filters'):
            self.model._default_manager.add_to_active_filters(
                Q(publication_date__lte=granular_now) &
                 (Q(publication_end_date__isnull=True) |
                  Q(publication_end_date__gt=granular_now)),
                key='datepublisher',
            )

        # Processor to patch up response headers for expiry date
        self.model.register_response_processor(
            datepublisher_response_processor)

    def handle_modeladmin(self, modeladmin):
        def datepublisher_admin(self, obj):
            return '%s &ndash; %s' % (
                format_date(obj.publication_date),
                format_date(obj.publication_end_date, '&infin;'),
            )
        datepublisher_admin.allow_tags = True
        datepublisher_admin.short_description = _('visible from - to')

        modeladmin.__class__.datepublisher_admin = datepublisher_admin

        try:
            pos = modeladmin.list_display.index('is_visible_admin')
        except ValueError:
            pos = len(modeladmin.list_display)

        modeladmin.list_display.insert(pos + 1, 'datepublisher_admin')

        modeladmin.add_extension_options(_('Date-based publishing'), {
            'fields': ['publication_date', 'publication_end_date'],
        })

# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = featured
"""
Add a "featured" field to objects so admins can better direct top content.
"""

from __future__ import absolute_import, unicode_literals

from django.db import models
from django.utils.translation import ugettext_lazy as _

from feincms import extensions


class Extension(extensions.Extension):
    def handle_model(self):
        self.model.add_to_class('featured', models.BooleanField(_('featured')))

        if hasattr(self.model, 'cache_key_components'):
            self.model.cache_key_components.append(lambda page: page.featured)

    def handle_modeladmin(self, modeladmin):
        modeladmin.add_extension_options(_('Featured'), {
            'fields': ('featured',),
            'classes': ('collapse',),
        })

########NEW FILE########
__FILENAME__ = seo
"""
Add a keyword and a description field which are helpful for SEO optimization.
"""

from __future__ import absolute_import, unicode_literals

from django.db import models
from django.utils.translation import ugettext_lazy as _

from feincms import extensions


class Extension(extensions.Extension):
    def handle_model(self):
        self.model.add_to_class('meta_keywords', models.TextField(
            _('meta keywords'),
            blank=True,
            help_text=_('Keywords are ignored by most search engines.')))
        self.model.add_to_class('meta_description', models.TextField(
            _('meta description'),
            blank=True,
            help_text=_('This text is displayed on the search results page. '
                        'It is however not used for the SEO ranking. '
                        'Text longer than 140 characters is truncated.')))

    def handle_modeladmin(self, modeladmin):
        modeladmin.extend_list(
            'search_fields',
            ['meta_keywords', 'meta_description'],
        )

        modeladmin.add_extension_options(_('Search engine optimization'), {
            'fields': ('meta_keywords', 'meta_description'),
            'classes': ('collapse',),
        })

########NEW FILE########
__FILENAME__ = translations
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

"""
This extension adds a language field to every page. When calling the request
processors the page's language is activated.
Pages in secondary languages can be said to be a translation of a page in the
primary language (the first language in settings.LANGUAGES), thereby enabling
deeplinks between translated pages.

It is recommended to activate
:class:`django.middleware.locale.LocaleMiddleware` so that the correct language
will be activated per user or session even for non-FeinCMS managed views such
as Django's administration tool.
"""

from __future__ import absolute_import, unicode_literals

# ------------------------------------------------------------------------
import logging

from django.conf import settings as django_settings
from django.db import models
from django.http import HttpResponseRedirect
from django.utils import translation
from django.utils.translation import ugettext_lazy as _

from feincms import extensions, settings
from feincms.translations import is_primary_language
from feincms._internal import monkeypatch_method, monkeypatch_property


# ------------------------------------------------------------------------
logger = logging.getLogger(__name__)


# ------------------------------------------------------------------------
def user_has_language_set(request):
    """
    Determine whether the user has explicitely set a language earlier on.
    This is taken later on as an indication that we should not mess with the
    site's language settings, after all, the user's decision is what counts.
    """
    if (hasattr(request, 'session')
            and request.session.get('django_language') is not None):
        return True
    if django_settings.LANGUAGE_COOKIE_NAME in request.COOKIES:
        return True
    return False


# ------------------------------------------------------------------------
def translation_set_language(request, select_language):
    """
    Set and activate a language, if that language is available.
    """
    if translation.check_for_language(select_language):
        fallback = False
    else:
        # The page is in a language that Django has no messages for.
        # We display anyhow, but fall back to primary language for
        # other messages and other applications. It is *highly* recommended to
        # create a new django.po for the language instead of
        # using this behaviour.
        select_language = django_settings.LANGUAGES[0][0]
        fallback = True

    translation.activate(select_language)
    request.LANGUAGE_CODE = translation.get_language()

    if hasattr(request, 'session'):
        # User has a session, then set this language there
        if select_language != request.session.get('django_language'):
            request.session['django_language'] = select_language
    elif request.method == 'GET' and not fallback:
        # No session is active. We need to set a cookie for the language
        # so that it persists when users change their location to somewhere
        # not under the control of the CMS.
        # Only do this when request method is GET (mainly, do not abort
        # POST requests)
        response = HttpResponseRedirect(request.get_full_path())
        response.set_cookie(
            str(django_settings.LANGUAGE_COOKIE_NAME), select_language)
        return response


# ------------------------------------------------------------------------
def translations_request_processor_explicit(page, request):
    # If this page is just a redirect, don't do any language specific setup
    if page.redirect_to:
        return

    # Until further notice, the user might be wanting to switch to the
    # page's language...
    desired_language = page.language

    # ...except if the user explicitely wants to switch language
    if 'set_language' in request.GET:
        desired_language = request.GET['set_language']
    # ...or the user already has explicitely set a language, bail out and
    # don't change it for them behind their back
    elif user_has_language_set(request):
        return

    return translation_set_language(request, desired_language)


# ------------------------------------------------------------------------
def translations_request_processor_standard(page, request):
    # If this page is just a redirect, don't do any language specific setup
    if getattr(page, 'redirect_to', None):
        return

    if page.language == translation.get_language():
        return

    return translation_set_language(request, page.language)


# ------------------------------------------------------------------------
def get_current_language_code(request):
    language_code = getattr(request, 'LANGUAGE_CODE', None)
    if language_code is None:
        logger.warning(
            "Could not access request.LANGUAGE_CODE. Is 'django.middleware."
            "locale.LocaleMiddleware' in MIDDLEWARE_CLASSES?")
    return language_code


# ------------------------------------------------------------------------
class Extension(extensions.Extension):

    def handle_model(self):
        cls = self.model

        cls.add_to_class(
            'language',
            models.CharField(
                _('language'),
                max_length=10,
                choices=django_settings.LANGUAGES,
                default=django_settings.LANGUAGES[0][0]))
        cls.add_to_class(
            'translation_of',
            models.ForeignKey(
                'self',
                blank=True, null=True, verbose_name=_('translation of'),
                related_name='translations',
                limit_choices_to={'language': django_settings.LANGUAGES[0][0]},
                help_text=_(
                    'Leave this empty for entries in the primary language.'),
            )
        )

        if hasattr(cls, 'register_request_processor'):
            if settings.FEINCMS_TRANSLATION_POLICY == "EXPLICIT":
                cls.register_request_processor(
                    translations_request_processor_explicit,
                    key='translations')
            else:  # STANDARD
                cls.register_request_processor(
                    translations_request_processor_standard,
                    key='translations')

        if hasattr(cls, 'get_redirect_to_target'):
            original_get_redirect_to_target = cls.get_redirect_to_target

            @monkeypatch_method(cls)
            def get_redirect_to_target(self, request):
                """
                Find an acceptable redirect target. If this is a local link,
                then try to find the page this redirect references and
                translate it according to the user's language. This way, one
                can easily implement a localized "/"-url to welcome page
                redirection.
                """
                target = original_get_redirect_to_target(self, request)
                if target and target.find('//') == -1:
                    # Not an offsite link http://bla/blubb
                    try:
                        page = cls.objects.page_for_path(target)
                        page = page.get_translation(
                            get_current_language_code(request))
                        target = page.get_absolute_url()
                    except cls.DoesNotExist:
                        pass
                return target

        @monkeypatch_method(cls)
        def available_translations(self):
            if not self.id:  # New, unsaved pages have no translations
                return []
            if is_primary_language(self.language):
                return self.translations.all()
            elif self.translation_of:
                # reuse prefetched queryset, do not filter it
                res = [t for t in list(self.translation_of.translations.all())
                       if t.language != self.language]
                res.insert(0, self.translation_of)
                return res
            else:
                return []

        @monkeypatch_method(cls)
        def get_original_translation(self, *args, **kwargs):
            if is_primary_language(self.language):
                return self
            if self.translation_of:
                return self.translation_of
            raise self.DoesNotExist

        @monkeypatch_property(cls)
        def original_translation(self):
            return self.get_original_translation()

        @monkeypatch_method(cls)
        def get_translation(self, language):
            return self.original_translation.translations.get(
                language=language)

    def handle_modeladmin(self, modeladmin):

        extensions.prefetch_modeladmin_get_queryset(
            modeladmin, 'translation_of__translations', 'translations')

        def available_translations_admin(self, page):
            translations = dict(
                (p.language, p.id) for p in page.available_translations())

            links = []

            for key, title in django_settings.LANGUAGES:
                if key == page.language:
                    continue

                if key in translations:
                    links.append('<a href="%s/" title="%s">%s</a>' % (
                        translations[key], _('Edit translation'), key.upper()))
                else:
                    links.append(
                        '<a style="color:#baa" href="add/?translation_of='
                        '%s&amp;language=%s" title="%s">%s</a>' % (
                            page.id,
                            key,
                            _('Create translation'),
                            key.upper()
                        )
                    )

            return ' | '.join(links)

        available_translations_admin.allow_tags = True
        available_translations_admin.short_description = _('translations')
        modeladmin.__class__.available_translations_admin =\
            available_translations_admin

        if hasattr(modeladmin, 'add_extension_options'):
            modeladmin.add_extension_options('language', 'translation_of')

        modeladmin.extend_list(
            'list_display',
            ['language', 'available_translations_admin'],
        )
        modeladmin.extend_list('list_filter', ['language'])
        modeladmin.extend_list('raw_id_fields', ['translation_of'])

# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = admin
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

from django.contrib import admin

from .models import Category, MediaFile
from .modeladmins import CategoryAdmin, MediaFileAdmin

# ------------------------------------------------------------------------
admin.site.register(Category, CategoryAdmin)
admin.site.register(MediaFile, MediaFileAdmin)

# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = fields
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

from django.contrib.admin.widgets import AdminFileWidget
from django.contrib.admin.widgets import ForeignKeyRawIdWidget
from django.db import models
from django.utils import six
from django.utils.html import escape
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _

from feincms.admin.item_editor import FeinCMSInline
from feincms.utils import shorten_string
from .models import MediaFile
from .thumbnail import admin_thumbnail


__all__ = ('MediaFileForeignKey', 'ContentWithMediaFile')


# ------------------------------------------------------------------------
class MediaFileForeignKeyRawIdWidget(ForeignKeyRawIdWidget):
    def __init__(self, original):
        self.__dict__ = original.__dict__

    def label_for_value(self, value):
        key = self.rel.get_related_field().name
        try:
            obj = self.rel.to._default_manager.using(self.db).get(
                **{key: value})
            label = ['&nbsp;<strong>%s</strong>' % escape(
                shorten_string(six.text_type(obj)))]
            image = admin_thumbnail(obj)

            if image:
                label.append(
                    '<br /><img src="%s" alt="" style="margin:1em 0 0 10em"'
                    '/>' % image)

            return ''.join(label)
        except (ValueError, self.rel.to.DoesNotExist):
            return ''


class MediaFileForeignKey(models.ForeignKey):
    """
    Drop-in replacement for Django's ``models.ForeignKey`` which automatically
    adds a thumbnail of media files if the media file foreign key is shown
    using ``raw_id_fields``.
    """
    def formfield(self, **kwargs):
        if 'widget' in kwargs and isinstance(
                kwargs['widget'], ForeignKeyRawIdWidget):
            kwargs['widget'] = MediaFileForeignKeyRawIdWidget(kwargs['widget'])
        return super(MediaFileForeignKey, self).formfield(**kwargs)


class ContentWithMediaFile(models.Model):
    class feincms_item_editor_inline(FeinCMSInline):
        raw_id_fields = ('mediafile',)

    mediafile = MediaFileForeignKey(
        MediaFile, verbose_name=_('media file'), related_name='+')

    class Meta:
        abstract = True


# ------------------------------------------------------------------------
class AdminFileWithPreviewWidget(AdminFileWidget):
    """
    Simple AdminFileWidget, but detects if the file is an image and
    tries to render a small thumbnail besides the input field.
    """
    def render(self, name, value, attrs=None):
        r = super(AdminFileWithPreviewWidget, self).render(
            name, value, attrs=attrs)

        if value and getattr(value, 'instance', None):
            image = admin_thumbnail(value.instance)
            if image:
                r = mark_safe((
                    '<img src="%s" alt="" style="float: left; padding-right:'
                    '8px; border-right: 1px solid #ccc; margin-right: 8px"'
                    '>' % image) + r)

        return r

# ------------------------------------------------------------------------

try:
    from south.modelsinspector import add_introspection_rules
    add_introspection_rules(
        rules=[((MediaFileForeignKey,), [], {},)],
        patterns=["^feincms\.module\.medialibrary\.fields"])
except ImportError:
    pass

########NEW FILE########
__FILENAME__ = forms
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

import os

from django import forms
from django.utils.translation import ugettext_lazy as _

from feincms import settings

from . import logger
from .models import Category, MediaFile
from .fields import AdminFileWithPreviewWidget


# ------------------------------------------------------------------------
class MediaCategoryAdminForm(forms.ModelForm):
    class Meta:
        model = Category

    def clean_parent(self):
        data = self.cleaned_data['parent']
        if data is not None and self.instance in data.path_list():
            raise forms.ValidationError(
                _("This would create a loop in the hierarchy"))

        return data

    def __init__(self, *args, **kwargs):
        super(MediaCategoryAdminForm, self).__init__(*args, **kwargs)
        self.fields['parent'].queryset =\
            self.fields['parent'].queryset.exclude(pk=self.instance.pk)


# ------------------------------------------------------------------------
class MediaFileAdminForm(forms.ModelForm):
    class Meta:
        model = MediaFile
        widgets = {'file': AdminFileWithPreviewWidget}

    def __init__(self, *args, **kwargs):
        super(MediaFileAdminForm, self).__init__(*args, **kwargs)

        if settings.FEINCMS_MEDIAFILE_OVERWRITE and self.instance.id:
            field = self.instance.file.field
            if not hasattr(field, '_feincms_generate_filename_patched'):
                original_generate = field.generate_filename

                def _gen_fname(instance, filename):
                    if instance.id and hasattr(instance, 'original_name'):
                        logger.info("Overwriting file %s with new data" % (
                            instance.original_name))
                        instance.file.storage.delete(instance.original_name)
                        return instance.original_name

                    return original_generate(instance, filename)

                field.generate_filename = _gen_fname
                field._feincms_generate_filename_patched = True

    def clean_file(self):
        if settings.FEINCMS_MEDIAFILE_OVERWRITE and self.instance.id:
            new_base, new_ext = os.path.splitext(
                self.cleaned_data['file'].name)
            old_base, old_ext = os.path.splitext(self.instance.file.name)

            if new_ext.lower() != old_ext.lower():
                raise forms.ValidationError(_(
                    "Cannot overwrite with different file type (attempt to"
                    " overwrite a %(old_ext)s with a %(new_ext)s)"
                ) % {'old_ext': old_ext, 'new_ext': new_ext})

            self.instance.original_name = self.instance.file.name

        return self.cleaned_data['file']

# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = modeladmins
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

import os

from django import forms
from django.conf import settings as django_settings
from django.contrib import admin
from django.contrib import messages
from django.contrib.auth.decorators import permission_required
from django.contrib.sites.models import Site
from django.core.files.images import get_image_dimensions
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect
from django.shortcuts import render_to_response
from django.template.context import RequestContext
from django.template.defaultfilters import filesizeformat
from django.utils.safestring import mark_safe
from django.utils.translation import ungettext, ugettext_lazy as _
from django.views.decorators.csrf import csrf_protect

from feincms.extensions import ExtensionModelAdmin
from feincms.translations import admin_translationinline, lookup_translations
from feincms.utils import shorten_string

from .models import Category, MediaFileTranslation
from .forms import MediaCategoryAdminForm, MediaFileAdminForm
from .thumbnail import admin_thumbnail
from .zip import import_zipfile


# -----------------------------------------------------------------------
class CategoryAdmin(admin.ModelAdmin):
    form = MediaCategoryAdminForm
    list_display = ['path']
    list_filter = ['parent']
    list_per_page = 25
    search_fields = ['title']
    prepopulated_fields = {'slug': ('title',)}


# ------------------------------------------------------------------------
def assign_category(modeladmin, request, queryset):
    class AddCategoryForm(forms.Form):
        _selected_action = forms.CharField(widget=forms.MultipleHiddenInput)
        category = forms.ModelChoiceField(Category.objects.all())

    form = None
    if 'apply' in request.POST:
        form = AddCategoryForm(request.POST)
        if form.is_valid():
            category = form.cleaned_data['category']

            count = 0
            for mediafile in queryset:
                category.mediafile_set.add(mediafile)
                count += 1

            message = ungettext(
                'Successfully added %(count)d media file to %(category)s.',
                'Successfully added %(count)d media files to %(category)s.',
                count) % {'count': count, 'category': category}
            modeladmin.message_user(request, message)
            return HttpResponseRedirect(request.get_full_path())
    if 'cancel' in request.POST:
        return HttpResponseRedirect(request.get_full_path())

    if not form:
        form = AddCategoryForm(initial={
            '_selected_action': request.POST.getlist(
                admin.ACTION_CHECKBOX_NAME),
        })

    return render_to_response('admin/medialibrary/add_to_category.html', {
        'mediafiles': queryset,
        'category_form': form,
        'opts': modeladmin.model._meta,
    }, context_instance=RequestContext(request))


assign_category.short_description = _('Add selected media files to category')


# -------------------------------------------------------------------------
def save_as_zipfile(modeladmin, request, queryset):
    from .zip import export_zipfile

    site = Site.objects.get_current()
    try:
        zip_name = export_zipfile(site, queryset)
        messages.info(request, _("ZIP file exported as %s") % zip_name)
    except Exception as e:
        messages.error(request, _("ZIP file export failed: %s") % str(e))
        return

    return HttpResponseRedirect(
        os.path.join(django_settings.MEDIA_URL, zip_name))


save_as_zipfile.short_description = _(
    'Export selected media files as zip file')


# ------------------------------------------------------------------------
class MediaFileAdmin(ExtensionModelAdmin):
    form = MediaFileAdminForm

    save_on_top = True
    date_hierarchy = 'created'
    inlines = [admin_translationinline(MediaFileTranslation)]
    list_display = [
        'admin_thumbnail', '__str__', 'file_info', 'formatted_created']
    list_display_links = ['__str__']
    list_filter = ['type', 'categories']
    list_per_page = 25
    search_fields = ['copyright', 'file', 'translations__caption']
    filter_horizontal = ("categories",)
    actions = [assign_category, save_as_zipfile]

    def get_urls(self):
        from django.conf.urls import patterns, url

        urls = super(MediaFileAdmin, self).get_urls()
        my_urls = patterns(
            '',
            url(
                r'^mediafile-bulk-upload/$',
                self.admin_site.admin_view(MediaFileAdmin.bulk_upload),
                {},
                name='mediafile_bulk_upload',
            ),
        )

        return my_urls + urls

    def changelist_view(self, request, extra_context=None):
        if extra_context is None:
            extra_context = {}
        extra_context['categories'] = Category.objects.order_by('title')
        return super(MediaFileAdmin, self).changelist_view(
            request, extra_context=extra_context)

    def admin_thumbnail(self, obj):
        image = admin_thumbnail(obj)
        if image:
            return mark_safe("""
                <a href="%(url)s" target="_blank">
                    <img src="%(image)s" alt="" />
                </a>""" % {
                'url': obj.file.url,
                'image': image}
            )
        return ''
    admin_thumbnail.short_description = _('Preview')
    admin_thumbnail.allow_tags = True

    def formatted_file_size(self, obj):
        return filesizeformat(obj.file_size)
    formatted_file_size.short_description = _("file size")
    formatted_file_size.admin_order_field = 'file_size'

    def formatted_created(self, obj):
        return obj.created.strftime("%Y-%m-%d")
    formatted_created.short_description = _("created")
    formatted_created.admin_order_field = 'created'

    def file_type(self, obj):
        t = obj.filetypes_dict[obj.type]
        if obj.type == 'image':
            # get_image_dimensions is expensive / slow if the storage is not
            # local filesystem (indicated by availability the path property)
            try:
                obj.file.path
            except NotImplementedError:
                return t
            try:
                d = get_image_dimensions(obj.file.file)
                if d:
                    t += " %d&times;%d" % (d[0], d[1])
            except (IOError, ValueError) as e:
                t += " (%s)" % e
        return t
    file_type.admin_order_field = 'type'
    file_type.short_description = _('file type')
    file_type.allow_tags = True

    def file_info(self, obj):
        """
        Method for showing the file name in admin.

        Note: This also includes a hidden field that can be used to extract
        the file name later on, this can be used to access the file name from
        JS, like for example a TinyMCE connector shim.
        """
        return (
            '<input type="hidden" class="medialibrary_file_path"'
            ' name="_media_path_%d" value="%s" id="_refkey_%d" />'
            ' %s <br />%s, %s'
        ) % (
            obj.id,
            obj.file.name,
            obj.id,
            shorten_string(os.path.basename(obj.file.name), max_length=40),
            self.file_type(obj),
            self.formatted_file_size(obj),
        )
    file_info.admin_order_field = 'file'
    file_info.short_description = _('file info')
    file_info.allow_tags = True

    @staticmethod
    @csrf_protect
    @permission_required('medialibrary.add_mediafile')
    def bulk_upload(request):
        if request.method == 'POST' and 'data' in request.FILES:
            try:
                count = import_zipfile(
                    request.POST.get('category'),
                    request.POST.get('overwrite', False),
                    request.FILES['data'])
                messages.info(request, _("%d files imported") % count)
            except Exception as e:
                messages.error(request, _("ZIP import failed: %s") % e)
        else:
            messages.error(request, _("No input file given"))

        return HttpResponseRedirect(
            reverse('admin:medialibrary_mediafile_changelist'))

    def queryset(self, request):
        return super(MediaFileAdmin, self).queryset(request).transform(
            lookup_translations())

    def save_model(self, request, obj, form, change):
        obj.purge_translation_cache()
        return super(MediaFileAdmin, self).save_model(
            request, obj, form, change)

# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = models
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

import os
import re

from django.db import models
from django.db.models.signals import post_delete
from django.dispatch.dispatcher import receiver
from django.template.defaultfilters import slugify
from django.utils import timezone
from django.utils.encoding import python_2_unicode_compatible
from django.utils.translation import ugettext_lazy as _

from feincms import settings
from feincms.models import ExtensionsMixin
from feincms.translations import (
    TranslatedObjectMixin, Translation, TranslatedObjectManager)

from . import logger


# ------------------------------------------------------------------------
class CategoryManager(models.Manager):
    """
    Simple manager which exists only to supply ``.select_related("parent")``
    on querysets since we can't even __str__ efficiently without it.
    """
    def get_query_set(self):
        return super(CategoryManager, self).get_query_set().select_related(
            "parent")


# ------------------------------------------------------------------------
@python_2_unicode_compatible
class Category(models.Model):
    """
    These categories are meant primarily for organizing media files in the
    library.
    """

    title = models.CharField(_('title'), max_length=200)
    parent = models.ForeignKey(
        'self', blank=True, null=True,
        related_name='children', limit_choices_to={'parent__isnull': True},
        verbose_name=_('parent'))

    slug = models.SlugField(_('slug'), max_length=150)

    class Meta:
        ordering = ['parent__title', 'title']
        verbose_name = _('category')
        verbose_name_plural = _('categories')

    objects = CategoryManager()

    def __str__(self):
        if self.parent_id:
            return '%s - %s' % (self.parent.title, self.title)

        return self.title

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.title)

        super(Category, self).save(*args, **kwargs)
    save.alters_data = True

    def path_list(self):
        if self.parent is None:
            return [self]
        p = self.parent.path_list()
        p.append(self)
        return p

    def path(self):
        return ' - '.join((f.title for f in self.path_list()))


# ------------------------------------------------------------------------
@python_2_unicode_compatible
class MediaFileBase(models.Model, ExtensionsMixin, TranslatedObjectMixin):
    """
    Abstract media file class. Includes the
    :class:`feincms.models.ExtensionsMixin` because of the (handy) extension
    mechanism.
    """

    file = models.FileField(
        _('file'), max_length=255,
        upload_to=settings.FEINCMS_MEDIALIBRARY_UPLOAD_TO)
    type = models.CharField(
        _('file type'), max_length=12, editable=False,
        choices=())
    created = models.DateTimeField(
        _('created'), editable=False, default=timezone.now)
    copyright = models.CharField(_('copyright'), max_length=200, blank=True)
    file_size = models.IntegerField(
        _("file size"), blank=True, null=True, editable=False)

    categories = models.ManyToManyField(
        Category, verbose_name=_('categories'), blank=True, null=True)
    categories.category_filter = True

    class Meta:
        abstract = True
        ordering = ['-created']
        verbose_name = _('media file')
        verbose_name_plural = _('media files')

    objects = TranslatedObjectManager()

    filetypes = []
    filetypes_dict = {}

    @classmethod
    def reconfigure(cls, upload_to=None, storage=None):
        f = cls._meta.get_field('file')
        # Ugh. Copied relevant parts from django/db/models/fields/files.py
        # FileField.__init__ (around line 225)
        if storage:
            f.storage = storage
        if upload_to:
            f.upload_to = upload_to
            if callable(upload_to):
                f.generate_filename = upload_to

    @classmethod
    def register_filetypes(cls, *types):
        cls.filetypes[0:0] = types
        choices = [t[0:2] for t in cls.filetypes]
        cls.filetypes_dict = dict(choices)
        cls._meta.get_field('type').choices[:] = choices

    def __init__(self, *args, **kwargs):
        super(MediaFileBase, self).__init__(*args, **kwargs)
        if self.file:
            self._original_file_name = self.file.name

    def __str__(self):
        trans = None

        try:
            trans = self.translation
        except models.ObjectDoesNotExist:
            pass
        except AttributeError:
            pass

        if trans:
            trans = '%s' % trans
            if trans.strip():
                return trans
        return os.path.basename(self.file.name)

    def get_absolute_url(self):
        return self.file.url

    def determine_file_type(self, name):
        """
        >>> t = MediaFileBase()
        >>> str(t.determine_file_type('foobar.jpg'))
        'image'
        >>> str(t.determine_file_type('foobar.PDF'))
        'pdf'
        >>> str(t.determine_file_type('foobar.jpg.pdf'))
        'pdf'
        >>> str(t.determine_file_type('foobar.jgp'))
        'other'
        >>> str(t.determine_file_type('foobar-jpg'))
        'other'
        """
        for type_key, type_name, type_test in self.filetypes:
            if type_test(name):
                return type_key
        return self.filetypes[-1][0]

    def save(self, *args, **kwargs):
        if not self.id and not self.created:
            self.created = timezone.now()

        self.type = self.determine_file_type(self.file.name)
        if self.file:
            try:
                self.file_size = self.file.size
            except (OSError, IOError, ValueError) as e:
                logger.error("Unable to read file size for %s: %s" % (self, e))

        super(MediaFileBase, self).save(*args, **kwargs)

        logger.info("Saved mediafile %d (%s, type %s, %d bytes)" % (
            self.id, self.file.name, self.type, self.file_size or 0))

        # User uploaded a new file. Try to get rid of the old file in
        # storage, to avoid having orphaned files hanging around.
        if getattr(self, '_original_file_name', None):
            if self.file.name != self._original_file_name:
                self.delete_mediafile(self._original_file_name)

        self.purge_translation_cache()
    save.alters_data = True

    def delete_mediafile(self, name=None):
        if name is None:
            name = self.file.name
        try:
            self.file.storage.delete(name)
        except Exception as e:
            logger.warn("Cannot delete media file %s: %s" % (name, e))


# ------------------------------------------------------------------------
MediaFileBase.register_filetypes(
    # Should we be using imghdr.what instead of extension guessing?
    ('image', _('Image'), lambda f: re.compile(
        r'\.(bmp|jpe?g|jp2|jxr|gif|png|tiff?)$', re.IGNORECASE).search(f)),
    ('video', _('Video'), lambda f: re.compile(
        r'\.(mov|m[14]v|mp4|avi|mpe?g|qt|ogv|wmv|flv)$',
        re.IGNORECASE).search(f)),
    ('audio', _('Audio'), lambda f: re.compile(
        r'\.(au|mp3|m4a|wma|oga|ram|wav)$', re.IGNORECASE).search(f)),
    ('pdf', _('PDF document'), lambda f: f.lower().endswith('.pdf')),
    ('swf', _('Flash'), lambda f: f.lower().endswith('.swf')),
    ('txt', _('Text'), lambda f: f.lower().endswith('.txt')),
    ('rtf', _('Rich Text'), lambda f: f.lower().endswith('.rtf')),
    ('zip', _('Zip archive'), lambda f: f.lower().endswith('.zip')),
    ('doc', _('Microsoft Word'), lambda f: re.compile(
        r'\.docx?$', re.IGNORECASE).search(f)),
    ('xls', _('Microsoft Excel'), lambda f: re.compile(
        r'\.xlsx?$', re.IGNORECASE).search(f)),
    ('ppt', _('Microsoft PowerPoint'), lambda f: re.compile(
        r'\.pptx?$', re.IGNORECASE).search(f)),
    ('other', _('Binary'), lambda f: True),  # Must be last
)


# ------------------------------------------------------------------------
class MediaFile(MediaFileBase):
    pass


@receiver(post_delete, sender=MediaFile)
def _mediafile_post_delete(sender, instance, **kwargs):
    instance.delete_mediafile()
    logger.info("Deleted mediafile %d (%s)" % (
        instance.id, instance.file.name))


# ------------------------------------------------------------------------
@python_2_unicode_compatible
class MediaFileTranslation(Translation(MediaFile)):
    """
    Translated media file caption and description.
    """

    caption = models.CharField(_('caption'), max_length=200)
    description = models.TextField(_('description'), blank=True)

    class Meta:
        verbose_name = _('media file translation')
        verbose_name_plural = _('media file translations')
        unique_together = ('parent', 'language_code')

    def __str__(self):
        return self.caption

########NEW FILE########
__FILENAME__ = thumbnail
from __future__ import absolute_import, unicode_literals

from feincms import settings
from feincms.templatetags import feincms_thumbnail
from feincms.utils import get_object


def default_admin_thumbnail(mediafile, dimensions='100x100', **kwargs):
    if mediafile.type != 'image':
        return None

    return feincms_thumbnail.thumbnail(mediafile.file, dimensions)


_cached_thumbnailer = None


def admin_thumbnail(mediafile, dimensions='100x100'):
    global _cached_thumbnailer
    if not _cached_thumbnailer:
        _cached_thumbnailer = get_object(
            settings.FEINCMS_MEDIALIBRARY_THUMBNAIL)
    return _cached_thumbnailer(mediafile, dimensions=dimensions)

########NEW FILE########
__FILENAME__ = zip
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------
#
#  Created by Martin J. Laubach on 2011-12-07
#  Copyright (c) 2011 Martin J. Laubach. All rights reserved.
#
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

import json
import zipfile
import os
import time

from django.conf import settings as django_settings
from django.core.files.base import ContentFile
from django.template.defaultfilters import slugify
from django.utils import timezone

from .models import Category, MediaFile, MediaFileTranslation


# ------------------------------------------------------------------------
export_magic = 'feincms-export-01'


# ------------------------------------------------------------------------
def import_zipfile(category_id, overwrite, data):
    """
    Import a collection of media files from a zip file.

    category_id: if set, the pk of a Category that all uploaded
        files will have added (eg. cathegory "newly uploaded files")
    overwrite: attempt to overwrite existing files. This might
        not work with non-trivial storage handlers
    """
    category = None
    if category_id:
        category = Category.objects.get(pk=int(category_id))

    z = zipfile.ZipFile(data)

    # Peek into zip file to find out whether it contains meta information
    is_export_file = False
    info = {}
    try:
        info = json.loads(z.comment)
        if info['export_magic'] == export_magic:
            is_export_file = True
    except:
        pass

    # If meta information, do we need to create any categories?
    # Also build translation map for category ids.
    category_id_map = {}
    if is_export_file:
        for cat in sorted(
                info.get('categories', []),
                key=lambda k: k.get('level', 999)):
            new_cat, created = Category.objects.get_or_create(
                slug=cat['slug'],
                title=cat['title'])
            category_id_map[cat['id']] = new_cat
            if created and cat.get('parent', 0):
                parent_cat = category_id_map.get(cat.get('parent', 0), None)
                if parent_cat:
                    new_cat.parent = parent_cat
                    new_cat.save()

    count = 0
    for zi in z.infolist():
        if not zi.filename.endswith('/'):
            bname = os.path.basename(zi.filename)
            if bname and not bname.startswith(".") and "." in bname:
                fname, ext = os.path.splitext(bname)
                wanted_dir = os.path.dirname(zi.filename)
                target_fname = slugify(fname) + ext.lower()

                info = {}
                if is_export_file:
                    info = json.loads(zi.comment)

                mf = None
                if overwrite:
                    full_path = os.path.join(wanted_dir, target_fname)
                    try:
                        mf = MediaFile.objects.get(file=full_path)
                        mf.file.delete(save=False)
                    except MediaFile.DoesNotExist:
                        mf = None

                if mf is None:
                    mf = MediaFile()
                if overwrite:
                    mf.file.field.upload_to = wanted_dir
                mf.copyright = info.get('copyright', '')
                mf.file.save(
                    target_fname,
                    ContentFile(z.read(zi.filename)),
                    save=False)
                mf.save()

                found_metadata = False
                if is_export_file:
                    try:
                        for tr in info['translations']:
                            found_metadata = True
                            mt, mt_created =\
                                MediaFileTranslation.objects.get_or_create(
                                    parent=mf, language_code=tr['lang'])
                            mt.caption = tr['caption']
                            mt.description = tr.get('description', None)
                            mt.save()

                        # Add categories
                        mf.categories = (
                            category_id_map[cat_id]
                            for cat_id in info.get('categories', []))
                    except Exception:
                        pass

                if not found_metadata:
                    mt = MediaFileTranslation()
                    mt.parent = mf
                    mt.caption = fname.replace('_', ' ')
                    mt.save()

                if category:
                    mf.categories.add(category)

                count += 1

    return count


# ------------------------------------------------------------------------
def export_zipfile(site, queryset):
    now = timezone.now()
    zip_name = "export_%s_%04d%02d%02d.zip" % (
        slugify(site.domain), now.year, now.month, now.day)

    zip_data = open(os.path.join(django_settings.MEDIA_ROOT, zip_name), "w")
    zip_file = zipfile.ZipFile(zip_data, 'w', allowZip64=True)

    # Save the used categories in the zip file's global comment
    used_categories = set()
    for mf in queryset:
        for cat in mf.categories.all():
            used_categories.update(cat.path_list())

    info = {
        'export_magic': export_magic,
        'categories': [{
            'id': cat.id,
            'title': cat.title,
            'slug': cat.slug,
            'parent': cat.parent_id or 0,
            'level': len(cat.path_list()),
        } for cat in used_categories],
    }
    zip_file.comment = json.dumps(info)

    for mf in queryset:
        ctime = time.localtime(os.stat(mf.file.path).st_ctime)
        info = json.dumps({
            'copyright': mf.copyright,
            'categories': [cat.id for cat in mf.categories.all()],
            'translations': [{
                'lang': t.language_code,
                'caption': t.caption,
                'description': t.description,
            } for t in mf.translations.all()],
        })

        with open(mf.file.path, "r") as file_data:
            zip_info = zipfile.ZipInfo(
                filename=mf.file.name,
                date_time=(
                    ctime.tm_year,
                    ctime.tm_mon,
                    ctime.tm_mday,
                    ctime.tm_hour,
                    ctime.tm_min,
                    ctime.tm_sec))
            zip_info.comment = info
            zip_file.writestr(zip_info, file_data.read())

    return zip_name

# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = mixins
from __future__ import absolute_import, unicode_literals

from django.http import Http404
from django.template import Template
from django.utils.datastructures import SortedDict
from django.utils.decorators import method_decorator
from django.views import generic
from django.views.generic.base import TemplateResponseMixin

from feincms import settings
from feincms.views.decorators import standalone


class ContentModelMixin(object):
    """
    Mixin for ``feincms.models.Base`` subclasses which need need some degree of
    additional control over the request-response cycle.
    """

    #: Collection of request processors
    request_processors = None

    #: Collection of response processors
    response_processors = None

    @classmethod
    def register_request_processor(cls, fn, key=None):
        """
        Registers the passed callable as request processor. A request processor
        always receives two arguments, the current object and the request.
        """
        if cls.request_processors is None:
            cls.request_processors = SortedDict()
        cls.request_processors[fn if key is None else key] = fn

    @classmethod
    def register_response_processor(cls, fn, key=None):
        """
        Registers the passed callable as response processor. A response
        processor always receives three arguments, the current object, the
        request and the response.
        """
        if cls.response_processors is None:
            cls.response_processors = SortedDict()
        cls.response_processors[fn if key is None else key] = fn

    # TODO Implement admin_urlname templatetag protocol
    @property
    def app_label(self):
        """
        Implement the admin_urlname templatetag protocol, so one can easily
        generate an admin link using ::

            {% url page|admin_urlname:'change' page.id %}
        """
        return self._meta.app_label

    @property
    def module_name(self):
        "See app_label"
        return self.__class__.__name__.lower()


class ContentObjectMixin(TemplateResponseMixin):
    """
    Mixin for Django's class based views which knows how to handle
    ``ContentModelMixin`` detail pages.

    This is a mixture of Django's ``SingleObjectMixin`` and
    ``TemplateResponseMixin`` conceptually to support FeinCMS'
    ``ApplicationContent`` inheritance. It does not inherit
    ``SingleObjectMixin`` however, because that would set a
    precedence for the way how detail objects are determined
    (and would f.e. make the page and blog module implementation
    harder).
    """

    context_object_name = None

    def handler(self, request, *args, **kwargs):
        if not hasattr(self.request, '_feincms_extra_context'):
            self.request._feincms_extra_context = {}

        r = self.run_request_processors()
        if r:
            return r

        r = self.process_content_types()
        if r:
            return r

        response = self.render_to_response(self.get_context_data())

        r = self.finalize_content_types(response)
        if r:
            return r

        r = self.run_response_processors(response)
        if r:
            return r

        return response

    def get_template_names(self):
        # According to the documentation this method is supposed to return
        # a list. However, we can also return a Template instance...
        if isinstance(self.template_name, (Template, list, tuple)):
            return self.template_name

        if self.template_name:
            return [self.template_name]

        self.object._needs_templates()
        if self.object.template.path:
            return [self.object.template.path]

        # Hopefully someone else has a usable get_template_names()
        # implementation...
        return super(ContentObjectMixin, self).get_template_names()

    def get_context_data(self, **kwargs):
        context = self.request._feincms_extra_context
        context[self.context_object_name or 'feincms_object'] = self.object
        context.update(kwargs)
        return super(ContentObjectMixin, self).get_context_data(**context)

    @property
    def __name__(self):
        """
        Dummy property to make this handler behave like a normal function.
        This property is used by django-debug-toolbar
        """
        return self.__class__.__name__

    def run_request_processors(self):
        """
        Before rendering an object, run all registered request processors. A
        request processor may peruse and modify the page or the request. It can
        also return a ``HttpResponse`` for shortcutting the rendering and
        returning that response immediately to the client.
        """
        if not getattr(self.object, 'request_processors', None):
            return

        for fn in reversed(list(self.object.request_processors.values())):
            r = fn(self.object, self.request)
            if r:
                return r

    def run_response_processors(self, response):
        """
        After rendering an object to a response, the registered response
        processors are called to modify the response, eg. for setting cache or
        expiration headers, keeping statistics, etc.
        """
        if not getattr(self.object, 'response_processors', None):
            return

        for fn in self.object.response_processors.values():
            r = fn(self.object, self.request, response)
            if r:
                return r

    def process_content_types(self):
        """
        Run the ``process`` method of all content types sporting one
        """
        # store eventual Http404 exceptions for re-raising,
        # if no content type wants to handle the current self.request
        http404 = None
        # did any content type successfully end processing?
        successful = False

        for content in self.object.content.all_of_type(tuple(
                self.object._feincms_content_types_with_process)):

            try:
                r = content.process(self.request, view=self)
                if r in (True, False):
                    successful = r
                elif r:
                    return r
            except Http404 as e:
                http404 = e

        if not successful:
            if http404:
                # re-raise stored Http404 exception
                raise http404

            extra_context = self.request._feincms_extra_context

            if (not settings.FEINCMS_ALLOW_EXTRA_PATH
                    and extra_context.get('extra_path', '/') != '/'
                    # XXX Already inside application content.  I'm not sure
                    # whether this fix is really correct...
                    and not extra_context.get('app_config')):
                raise Http404(str('Not found (extra_path %r on %r)') % (
                    extra_context.get('extra_path', '/'),
                    self.object,
                ))

    def finalize_content_types(self, response):
        """
        Runs finalize() on content types having such a method, adds headers and
        returns the final response.
        """

        for content in self.object.content.all_of_type(tuple(
                self.object._feincms_content_types_with_finalize)):

            r = content.finalize(self.request, response)
            if r:
                return r


class ContentView(ContentObjectMixin, generic.DetailView):
    def dispatch(self, request, *args, **kwargs):
        if request.method.lower() not in self.http_method_names:
            return self.http_method_not_allowed(request, *args, **kwargs)
        self.request = request
        self.args = args
        self.kwargs = kwargs
        self.object = self.get_object()
        return self.handler(request, *args, **kwargs)


class StandaloneView(generic.View):
    @method_decorator(standalone)
    def dispatch(self, request, *args, **kwargs):
        return super(StandaloneView, self).dispatch(request, *args, **kwargs)

########NEW FILE########
__FILENAME__ = admin
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

from django.contrib import admin
from django.core.exceptions import ImproperlyConfigured
from django.db.models import FieldDoesNotExist

from feincms import ensure_completely_loaded, settings
from .models import Page
from .modeladmins import PageAdmin

# ------------------------------------------------------------------------

if settings.FEINCMS_USE_PAGE_ADMIN:
    ensure_completely_loaded()
    try:
        Page._meta.get_field('template_key')
    except FieldDoesNotExist:
        raise ImproperlyConfigured(
            "The page module requires a 'Page.register_templates()' call "
            "somewhere ('Page.register_regions()' is not sufficient). "
            "If you're not using the default Page admin, maybe try "
            "FEINCMS_USE_PAGE_ADMIN=False to avoid this warning."
        )

    admin.site.register(Page, PageAdmin)

# ------------------------------------------------------------------------
# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = excerpt
"""
Add an excerpt field to the page.
"""

from __future__ import absolute_import, unicode_literals

from django.db import models
from django.utils.translation import ugettext_lazy as _

from feincms import extensions


class Extension(extensions.Extension):
    def handle_model(self):
        self.model.add_to_class(
            'excerpt',
            models.TextField(
                _('excerpt'),
                blank=True,
                help_text=_(
                    'Add a brief excerpt summarizing the content'
                    ' of this page.')))

    def handle_modeladmin(self, modeladmin):
        modeladmin.add_extension_options(_('Excerpt'), {
            'fields': ('excerpt',),
            'classes': ('collapse',),
        })

########NEW FILE########
__FILENAME__ = navigation
"""
Extend or modify the navigation with custom entries.

This extension allows the website administrator to select an extension
which processes, modifies or adds subnavigation entries. The bundled
``feincms_nav`` template tag knows how to collect navigation entries,
be they real Page instances or extended navigation entries.
"""

from __future__ import absolute_import, unicode_literals

from django.db import models
from django.utils import six
from django.utils.translation import ugettext_lazy as _

from feincms import extensions
from feincms.utils import get_object
from feincms._internal import monkeypatch_method


class TypeRegistryMetaClass(type):
    """
    You can access the list of subclasses as <BaseClass>.types

    TODO use NavigationExtension.__subclasses__() instead?
    """

    def __init__(cls, name, bases, attrs):
        if not hasattr(cls, 'types'):
            cls.types = []
        else:
            cls.types.append(cls)


class PagePretender(object):
    """
    A PagePretender pretends to be a page, but in reality is just a shim layer
    that implements enough functionality to inject fake pages eg. into the
    navigation tree.

    For use as fake navigation page, you should at least define the following
    parameters on creation: title, url, level. If using the translation
    extension, also add language.
    """
    pk = None

    # emulate mptt properties to get the template tags working
    class _mptt_meta:
        level_attr = 'level'

    def __init__(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)

    def get_absolute_url(self):
        return self.url

    def get_navigation_url(self):
        return self.get_absolute_url()

    def get_level(self):
        return self.level

    def get_children(self):
        """ overwrite this if you want nested extensions using recursetree """
        return []

    def available_translations(self):
        return ()

    def get_original_translation(self, page):
        return page

    def short_title(self):
        from feincms.utils import shorten_string
        return shorten_string(self.title)


class NavigationExtension(six.with_metaclass(TypeRegistryMetaClass)):
    """
    Base class for all navigation extensions.

    The name attribute is shown to the website administrator.
    """

    name = _('navigation extension')

    def children(self, page, **kwargs):
        """
        This is the method which must be overridden in every navigation
        extension.

        It receives the page the extension is attached to, the depth up to
        which the navigation should be resolved, and the current request object
        if it is available.
        """

        raise NotImplementedError


def navigation_extension_choices():
    for ext in NavigationExtension.types:
        if (issubclass(ext, NavigationExtension)
                and ext is not NavigationExtension):
            yield ('%s.%s' % (ext.__module__, ext.__name__), ext.name)


class Extension(extensions.Extension):
    ident = 'navigation'  # TODO actually use this

    def handle_model(self):
        self.model.add_to_class(
            'navigation_extension',
            models.CharField(
                _('navigation extension'),
                choices=navigation_extension_choices(),
                blank=True, null=True, max_length=200,
                help_text=_(
                    'Select the module providing subpages for this page if'
                    ' you need to customize the navigation.')))

        @monkeypatch_method(self.model)
        def extended_navigation(self, **kwargs):
            if not self.navigation_extension:
                return self.children.in_navigation()

            cls = get_object(self.navigation_extension, fail_silently=True)
            if not cls or not callable(cls):
                return self.children.in_navigation()

            return cls().children(self, **kwargs)

    def handle_modeladmin(self, modeladmin):
        modeladmin.add_extension_options(_('Navigation extension'), {
            'fields': ('navigation_extension',),
            'classes': ('collapse',),
        })

########NEW FILE########
__FILENAME__ = relatedpages
"""
Add a many-to-many relationship field to relate this page to other pages.
"""

from __future__ import absolute_import, unicode_literals

from django.db import models
from django.utils.translation import ugettext_lazy as _

from feincms import extensions, settings


class Extension(extensions.Extension):
    def handle_model(self):
        self.model.add_to_class('related_pages', models.ManyToManyField(
            settings.FEINCMS_DEFAULT_PAGE_MODEL,
            blank=True,
            null=True,
            related_name='%(app_label)s_%(class)s_related',
            help_text=_(
                'Select pages that should be listed as related content.')))

    def handle_modeladmin(self, modeladmin):
        modeladmin.extend_list('filter_horizontal', ['related_pages'])

        modeladmin.add_extension_options(_('Related pages'), {
            'fields': ('related_pages',),
            'classes': ('collapse',),
        })

########NEW FILE########
__FILENAME__ = sites
from __future__ import absolute_import, unicode_literals

from django.conf import settings
from django.contrib.sites.models import Site
from django.db import models
from django.utils.translation import ugettext_lazy as _

from feincms import extensions
from feincms.module.page.models import PageManager


def current_site(queryset):
    return queryset.filter(site=Site.objects.get_current())


class Extension(extensions.Extension):
    def handle_model(self):
        self.model.add_to_class(
            'site',
            models.ForeignKey(
                Site, verbose_name=_('Site'), default=settings.SITE_ID))

        PageManager.add_to_active_filters(current_site, key='current_site')

    def handle_modeladmin(self, modeladmin):
        modeladmin.extend_list('list_display', ['site'])
        modeladmin.extend_list('list_filter', ['site'])
        modeladmin.add_extension_options('site')

########NEW FILE########
__FILENAME__ = symlinks
"""
This introduces a new page type, which has no content of its own but inherits
all content from the linked page.
"""

from __future__ import absolute_import, unicode_literals

from django.db import models
from django.utils.translation import ugettext_lazy as _

from feincms import extensions
from feincms._internal import monkeypatch_property


class Extension(extensions.Extension):
    def handle_model(self):
        self.model.add_to_class('symlinked_page', models.ForeignKey(
            'self',
            blank=True,
            null=True,
            related_name='%(app_label)s_%(class)s_symlinks',
            verbose_name=_('symlinked page'),
            help_text=_('All content is inherited from this page if given.')))

        @monkeypatch_property(self.model)
        def content(self):
            if not hasattr(self, '_content_proxy'):
                if self.symlinked_page:
                    self._content_proxy = self.content_proxy_class(
                        self.symlinked_page)
                else:
                    self._content_proxy = self.content_proxy_class(self)

            return self._content_proxy

    def handle_modeladmin(self, modeladmin):
        modeladmin.extend_list('raw_id_fields', ['symlinked_page'])
        modeladmin.add_extension_options('symlinked_page')

########NEW FILE########
__FILENAME__ = titles
"""
Sometimes, a single title is not enough, you'd like subtitles, and maybe
differing titles in the navigation and in the <title>-tag.  This extension lets
you do that.
"""

from __future__ import absolute_import, unicode_literals

from django.db import models
from django.utils.translation import ugettext_lazy as _

from feincms import extensions
from feincms._internal import monkeypatch_property


class Extension(extensions.Extension):
    def handle_model(self):
        self.model.add_to_class('_content_title', models.TextField(
            _('content title'),
            blank=True,
            help_text=_(
                'The first line is the main title, the following'
                ' lines are subtitles.')))

        self.model.add_to_class('_page_title', models.CharField(
            _('page title'),
            max_length=69,
            blank=True,
            help_text=_(
                'Page title for browser window. Same as title by'
                'default. Must not be longer than 70 characters.')))

        @monkeypatch_property(self.model)
        def page_title(self):
            """
            Use this for the browser window (<title>-tag in the <head> of the
            HTML document)
            """

            if self._page_title:
                return self._page_title
            return self.content_title

        @monkeypatch_property(self.model)
        def content_title(self):
            """
            This should be used f.e. for the <h1>-tag
            """

            if not self._content_title:
                return self.title

            return self._content_title.splitlines()[0]

        @monkeypatch_property(self.model)
        def content_subtitle(self):
            return '\n'.join(self._content_title.splitlines()[1:])

    def handle_modeladmin(self, modeladmin):
        modeladmin.add_extension_options(_('Titles'), {
            'fields': ('_content_title', '_page_title'),
            'classes': ('collapse',),
        })

########NEW FILE########
__FILENAME__ = forms
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

import re

from django.contrib.admin.widgets import ForeignKeyRawIdWidget
from django.contrib.sites.models import Site
from django.db.models.loading import get_model
from django.forms.models import model_to_dict
from django.forms.util import ErrorList
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _

from feincms import ensure_completely_loaded

from mptt.forms import MPTTAdminForm


class RedirectToWidget(ForeignKeyRawIdWidget):
    def label_for_value(self, value):
        match = re.match(
            # XXX this regex would be available as .models.REDIRECT_TO_RE
            r'^(?P<app_label>\w+).(?P<module_name>\w+):(?P<pk>\d+)$',
            value)

        if match:
            matches = match.groupdict()
            model = get_model(matches['app_label'], matches['module_name'])
            try:
                instance = model._default_manager.get(pk=int(matches['pk']))
                return '&nbsp;<strong>%s (%s)</strong>' % (
                    instance, instance.get_absolute_url())

            except model.DoesNotExist:
                pass

        return ''


# ------------------------------------------------------------------------
class PageAdminForm(MPTTAdminForm):
    never_copy_fields = (
        'title', 'slug', 'parent', 'active', 'override_url',
        'translation_of', '_content_title', '_page_title')

    @property
    def page_model(self):
        return self._meta.model

    @property
    def page_manager(self):
        return self.page_model._default_manager

    def __init__(self, *args, **kwargs):
        ensure_completely_loaded()

        if 'initial' in kwargs:
            if 'parent' in kwargs['initial']:
                # Prefill a few form values from the parent page
                try:
                    page = self.page_manager.get(
                        pk=kwargs['initial']['parent'])

                    data = model_to_dict(page)

                    for field in self.page_manager.exclude_from_copy:
                        if field in data:
                            del data[field]

                    # These are always excluded from prefilling
                    for field in self.never_copy_fields:
                        if field in data:
                            del data[field]

                    data.update(kwargs['initial'])
                    if page.template.child_template:
                        data['template_key'] = page.template.child_template
                    kwargs['initial'] = data
                except self.page_model.DoesNotExist:
                    pass

            elif 'translation_of' in kwargs['initial']:
                # Only if translation extension is active
                try:
                    page = self.page_manager.get(
                        pk=kwargs['initial']['translation_of'])
                    original = page.original_translation

                    data = {
                        'translation_of': original.id,
                        'template_key': original.template_key,
                        'active': original.active,
                        'in_navigation': original.in_navigation,
                    }

                    if original.parent:
                        try:
                            data['parent'] = original.parent.get_translation(
                                kwargs['initial']['language']
                            ).id
                        except self.page_model.DoesNotExist:
                            # ignore this -- the translation does not exist
                            pass

                    data.update(kwargs['initial'])
                    kwargs['initial'] = data
                except (AttributeError, self.page_model.DoesNotExist):
                    pass

        # Not required, only a nice-to-have for the `redirect_to` field
        modeladmin = kwargs.pop('modeladmin', None)
        super(PageAdminForm, self).__init__(*args, **kwargs)
        if modeladmin:
            # Note: Using `parent` is not strictly correct, but we can be
            # sure that `parent` always points to another page instance,
            # and that's good enough for us.
            self.fields['redirect_to'].widget = RedirectToWidget(
                self.page_model._meta.get_field('parent').rel,
                modeladmin.admin_site)

        if 'template_key' in self.fields:
            choices = []
            for key, template_name in self.page_model.TEMPLATE_CHOICES:
                template = self.page_model._feincms_templates[key]
                pages_for_template = self.page_model._default_manager.filter(
                    template_key=key)
                pk = kwargs['instance'].pk if 'instance' in kwargs else None
                other_pages_for_template = pages_for_template.exclude(pk=pk)
                if template.singleton and other_pages_for_template.exists():
                    continue  # don't allow selection of singleton if in use
                if template.preview_image:
                    choices.append((
                        template.key,
                        mark_safe('<img src="%s" alt="%s" /> %s' % (
                            template.preview_image,
                            template.key,
                            template.title,
                        ))
                    ))
                else:
                    choices.append((template.key, template.title))

            self.fields['template_key'].choices = choices

    def clean(self):
        cleaned_data = super(PageAdminForm, self).clean()

        # No need to think further, let the user correct errors first
        if self._errors:
            return cleaned_data

        current_id = None
        # See the comment below on why we do not use Page.objects.active(),
        # at least for now.
        active_pages = self.page_manager.filter(active=True)

        if self.instance:
            current_id = self.instance.id
            active_pages = active_pages.exclude(id=current_id)

        if hasattr(Site, 'page_set') and 'site' in cleaned_data:
            active_pages = active_pages.filter(site=cleaned_data['site'])

        # Convert PK in redirect_to field to something nicer for the future
        redirect_to = cleaned_data.get('redirect_to')
        if redirect_to and re.match(r'^\d+$', redirect_to):
            opts = self.page_model._meta
            cleaned_data['redirect_to'] = '%s.%s:%s' % (
                opts.app_label, opts.module_name, redirect_to)

        if not cleaned_data['active']:
            # If the current item is inactive, we do not need to conduct
            # further validation. Note that we only check for the flag, not
            # for any other active filters. This is because we do not want
            # to inspect the active filters to determine whether two pages
            # really won't be active at the same time.
            return cleaned_data

        if cleaned_data['override_url']:
            if active_pages.filter(
                    _cached_url=cleaned_data['override_url']).count():
                self._errors['override_url'] = ErrorList([
                    _('This URL is already taken by an active page.')])
                del cleaned_data['override_url']

            return cleaned_data

        if current_id:
            # We are editing an existing page
            parent = self.page_manager.get(pk=current_id).parent
        else:
            # The user tries to create a new page
            parent = cleaned_data['parent']

        if parent:
            new_url = '%s%s/' % (parent._cached_url, cleaned_data['slug'])
        else:
            new_url = '/%s/' % cleaned_data['slug']

        if active_pages.filter(_cached_url=new_url).count():
            self._errors['active'] = ErrorList([
                _('This URL is already taken by another active page.')])
            del cleaned_data['active']

        if parent and parent.template.enforce_leaf:
            self._errors['parent'] = ErrorList(
                [_('This page does not allow attachment of child pages')])
            del cleaned_data['parent']

        return cleaned_data

# ------------------------------------------------------------------------
# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = modeladmins
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

from django.conf import settings as django_settings
from django.core.exceptions import PermissionDenied
from django.contrib.contenttypes.models import ContentType
from django.contrib.staticfiles.templatetags.staticfiles import static
from django.contrib import admin
from django.contrib import messages
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect
from django.utils.functional import curry
from django.utils.translation import ugettext_lazy as _

from feincms import ensure_completely_loaded
from feincms import settings
from feincms.admin import item_editor, tree_editor

# ------------------------------------------------------------------------
from .forms import PageAdminForm


# ------------------------------------------------------------------------
class PageAdmin(item_editor.ItemEditor, tree_editor.TreeEditor):
    class Media:
        css = {}
        js = []

    form = PageAdminForm

    fieldset_insertion_index = 2
    fieldsets = [
        (None, {
            'fields': [
                ('title', 'slug'),
                ('active', 'in_navigation'),
            ],
        }),
        (_('Other options'), {
            'classes': ['collapse'],
            'fields': [
                'template_key', 'parent', 'override_url', 'redirect_to'],
        }),
        # <-- insertion point, extensions appear here, see insertion_index
        # above
        item_editor.FEINCMS_CONTENT_FIELDSET,
    ]
    readonly_fields = []
    list_display = [
        'short_title', 'is_visible_admin', 'in_navigation_toggle', 'template']
    list_filter = ['active', 'in_navigation', 'template_key', 'parent']
    search_fields = ['title', 'slug']
    prepopulated_fields = {'slug': ('title',)}

    raw_id_fields = ['parent']
    radio_fields = {'template_key': admin.HORIZONTAL}

    @classmethod
    def add_extension_options(cls, *f):
        if isinstance(f[-1], dict):     # called with a fieldset
            cls.fieldsets.insert(cls.fieldset_insertion_index, f)
            f[1]['classes'] = list(f[1].get('classes', []))
            f[1]['classes'].append('collapse')
        else:   # assume called with "other" fields
            cls.fieldsets[1][1]['fields'].extend(f)

    def __init__(self, model, admin_site):
        ensure_completely_loaded()

        if len(model._feincms_templates) > 4 and \
                'template_key' in self.radio_fields:
            del(self.radio_fields['template_key'])

        super(PageAdmin, self).__init__(model, admin_site)

    in_navigation_toggle = tree_editor.ajax_editable_boolean(
        'in_navigation', _('in navigation'))

    def get_readonly_fields(self, request, obj=None):
        readonly = super(PageAdmin, self).get_readonly_fields(request, obj=obj)
        if not settings.FEINCMS_SINGLETON_TEMPLATE_CHANGE_ALLOWED:
            if obj and obj.template and obj.template.singleton:
                return tuple(readonly) + ('template_key',)
        return readonly

    def get_form(self, *args, **kwargs):
        form = super(PageAdmin, self).get_form(*args, **kwargs)
        return curry(form, modeladmin=self)

    def _actions_column(self, page):
        addable = getattr(page, 'feincms_addable', True)

        preview_url = "../../r/%s/%s/" % (
            ContentType.objects.get_for_model(self.model).id,
            page.id)
        actions = super(PageAdmin, self)._actions_column(page)

        if addable:
            if not page.template.enforce_leaf:
                actions.insert(
                    0,
                    '<a href="add/?parent=%s" title="%s">'
                    '<img src="%s" alt="%s" />'
                    '</a>' % (
                        page.pk,
                        _('Add child page'),
                        static('feincms/img/icon_addlink.gif'),
                        _('Add child page'),
                    )
                )
        actions.insert(
            0,
            '<a href="%s" title="%s">'
            '<img src="%s" alt="%s" />'
            '</a>' % (
                preview_url,
                _('View on site'),
                static('feincms/img/selector-search.gif'),
                _('View on site'),
            )
        )
        return actions

    def add_view(self, request, **kwargs):
        kwargs['form_url'] = request.get_full_path()  # Preserve GET parameters
        if 'translation_of' in request.GET and 'language' in request.GET:
            try:
                original = self.model._tree_manager.get(
                    pk=request.GET.get('translation_of'))
            except (AttributeError, self.model.DoesNotExist):
                pass
            else:
                language_code = request.GET['language']
                language = dict(
                    django_settings.LANGUAGES).get(language_code, '')
                kwargs['extra_context'] = {
                    'adding_translation': True,
                    'title': _(
                        'Add %(language)s translation of "%(page)s"') % {
                        'language': language,
                        'page': original,
                    },
                    'language_name': language,
                    'translation_of': original,
                }
        return super(PageAdmin, self).add_view(request, **kwargs)

    def response_add(self, request, obj, *args, **kwargs):
        response = super(PageAdmin, self).response_add(
            request, obj, *args, **kwargs)
        if ('parent' in request.GET
                and '_addanother' in request.POST
                and response.status_code in (301, 302)):
            # Preserve GET parameters if we are about to add another page
            response['Location'] += '?parent=%s' % request.GET['parent']

        if ('translation_of' in request.GET
                and '_copy_content_from_original' in request.POST):
            # Copy all contents
            for content_type in obj._feincms_content_types:
                if content_type.objects.filter(parent=obj).exists():
                    # Short-circuit processing -- don't copy any contents if
                    # newly added object already has some
                    return response

            try:
                original = self.model._tree_manager.get(
                    pk=request.GET.get('translation_of'))
                original = original.original_translation
                obj.copy_content_from(original)
                obj.save()

                self.message_user(request, _(
                    'The content from the original translation has been copied'
                    ' to the newly created page.'))
            except (AttributeError, self.model.DoesNotExist):
                pass

        return response

    def _refresh_changelist_caches(self, *args, **kwargs):
        self._visible_pages = list(
            self.model.objects.active().values_list('id', flat=True))

    def change_view(self, request, object_id, **kwargs):
        try:
            return super(PageAdmin, self).change_view(
                request, object_id, **kwargs)
        except PermissionDenied:
            messages.add_message(
                request,
                messages.ERROR,
                _(
                    "You don't have the necessary permissions to edit this"
                    " object"
                )
            )
        return HttpResponseRedirect(reverse('admin:page_page_changelist'))

    def has_delete_permission(self, request, obj=None):
        if not settings.FEINCMS_SINGLETON_TEMPLATE_DELETION_ALLOWED:
            if obj and obj.template.singleton:
                return False
        return super(PageAdmin, self).has_delete_permission(request, obj=obj)

    def is_visible_admin(self, page):
        """
        Instead of just showing an on/off boolean, also indicate whether this
        page is not visible because of publishing dates or inherited status.
        """
        if not hasattr(self, "_visible_pages"):
            # Sanity check in case this is not already defined
            self._visible_pages = list()

        if page.parent_id and page.parent_id not in self._visible_pages:
            # parent page's invisibility is inherited
            if page.id in self._visible_pages:
                self._visible_pages.remove(page.id)
            return tree_editor.ajax_editable_boolean_cell(
                page, 'active', override=False, text=_('inherited'))

        if page.active and page.id not in self._visible_pages:
            # is active but should not be shown, so visibility limited by
            # extension: show a "not active"
            return tree_editor.ajax_editable_boolean_cell(
                page, 'active', override=False, text=_('extensions'))

        return tree_editor.ajax_editable_boolean_cell(page, 'active')
    is_visible_admin.allow_tags = True
    is_visible_admin.short_description = _('is active')
    is_visible_admin.editable_boolean_field = 'active'

    # active toggle needs more sophisticated result function
    def is_visible_recursive(self, page):
        retval = []
        for c in page.get_descendants(include_self=True):
            retval.append(self.is_visible_admin(c))
        return retval
    is_visible_admin.editable_boolean_result = is_visible_recursive

# ------------------------------------------------------------------------
# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = models
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

import re

from django.core.cache import cache as django_cache
from django.core.exceptions import PermissionDenied
from django.conf import settings as django_settings
from django.db import models
from django.db.models import Q, signals
from django.db.models.loading import get_model
from django.http import Http404
from django.utils.encoding import python_2_unicode_compatible
from django.utils.translation import ugettext_lazy as _

from mptt.models import MPTTModel, TreeManager

from feincms import settings
from feincms.management.checker import check_database_schema
from feincms.models import create_base_model
from feincms.module.mixins import ContentModelMixin
from feincms.module.page import processors
from feincms.utils.managers import ActiveAwareContentManagerMixin

from feincms.utils import path_to_cache_key, shorten_string


REDIRECT_TO_RE = re.compile(
    r'^(?P<app_label>\w+).(?P<module_name>\w+):(?P<pk>\d+)$')


# ------------------------------------------------------------------------
class BasePageManager(ActiveAwareContentManagerMixin, TreeManager):
    """
    The page manager. Only adds new methods, does not modify standard Django
    manager behavior in any way.
    """

    # The fields which should be excluded when creating a copy.
    exclude_from_copy = [
        'id', 'tree_id', 'lft', 'rght', 'level', 'redirect_to']

    def page_for_path(self, path, raise404=False):
        """
        Return a page for a path. Optionally raises a 404 error if requested.

        Example::

            Page.objects.page_for_path(request.path)
        """

        stripped = path.strip('/')

        try:
            page = self.active().get(
                _cached_url='/%s/' % stripped if stripped else '/')

            if not page.are_ancestors_active():
                raise self.model.DoesNotExist('Parents are inactive.')

            return page

        except self.model.DoesNotExist:
            if raise404:
                raise Http404()
            raise

    def best_match_for_path(self, path, raise404=False):
        """
        Return the best match for a path. If the path as given is unavailable,
        continues to search by chopping path components off the end.

        Tries hard to avoid unnecessary database lookups by generating all
        possible matching URL prefixes and choosing the longest match.

        Page.best_match_for_path('/photos/album/2008/09') might return the
        page with url '/photos/album/'.
        """

        paths = ['/']
        path = path.strip('/')

        # Cache path -> page resolving.
        # We flush the cache entry on page saving, so the cache should always
        # be up to date.

        ck = Page.path_to_cache_key(path)
        page = django_cache.get(ck)
        if page:
            return page

        if path:
            tokens = path.split('/')
            paths += [
                '/%s/' % '/'.join(tokens[:i])
                for i in range(1, len(tokens) + 1)]

        try:
            page = self.active().filter(_cached_url__in=paths).extra(
                select={'_url_length': 'LENGTH(_cached_url)'}
            ).order_by('-_url_length')[0]

            if not page.are_ancestors_active():
                raise IndexError('Parents are inactive.')

            django_cache.set(ck, page)
            return page

        except IndexError:
            if raise404:
                raise Http404()

        raise self.model.DoesNotExist

    def in_navigation(self):
        """
        Returns active pages which have the ``in_navigation`` flag set.
        """

        return self.active().filter(in_navigation=True)

    def toplevel_navigation(self):
        """
        Returns top-level navigation entries.
        """

        return self.in_navigation().filter(parent__isnull=True)

    def for_request(self, request, raise404=False, best_match=False,
                    path=None):
        """
        Return a page for the request

        Does not hit the database more than once for the same request.

        Examples::

            Page.objects.for_request(request, raise404=True, best_match=False)

        Defaults to raising a ``DoesNotExist`` exception if no exact match
        could be determined.
        """

        if not hasattr(request, '_feincms_page'):
            path = path or request.path_info or request.path

            if best_match:
                request._feincms_page = self.best_match_for_path(
                    path, raise404=raise404)
            else:
                request._feincms_page = self.page_for_path(
                    path, raise404=raise404)

        return request._feincms_page


# ------------------------------------------------------------------------
class PageManager(BasePageManager):
    pass
PageManager.add_to_active_filters(Q(active=True))


# ------------------------------------------------------------------------
@python_2_unicode_compatible
class BasePage(create_base_model(MPTTModel), ContentModelMixin):
    active = models.BooleanField(_('active'), default=True)

    # structure and navigation
    title = models.CharField(_('title'), max_length=200, help_text=_(
        'This title is also used for navigation menu items.'))
    slug = models.SlugField(
        _('slug'), max_length=150,
        help_text=_('This is used to build the URL for this page'))
    parent = models.ForeignKey(
        'self', verbose_name=_('Parent'), blank=True,
        null=True, related_name='children')
    # Custom list_filter - see admin/filterspecs.py
    parent.parent_filter = True
    in_navigation = models.BooleanField(_('in navigation'), default=False)
    override_url = models.CharField(
        _('override URL'), max_length=255,
        blank=True, help_text=_(
            'Override the target URL. Be sure to include slashes at the '
            'beginning and at the end if it is a local URL. This '
            'affects both the navigation and subpages\' URLs.'))
    redirect_to = models.CharField(
        _('redirect to'), max_length=255,
        blank=True,
        help_text=_(
            'Target URL for automatic redirects'
            ' or the primary key of a page.'))
    _cached_url = models.CharField(
        _('Cached URL'), max_length=255, blank=True,
        editable=False, default='', db_index=True)

    class Meta:
        ordering = ['tree_id', 'lft']
        abstract = True

    objects = PageManager()

    def __str__(self):
        return self.short_title()

    def is_active(self):
        """
        Check whether this page and all its ancestors are active
        """

        if not self.pk:
            return False

        pages = self.__class__.objects.active().filter(
            tree_id=self.tree_id,
            lft__lte=self.lft,
            rght__gte=self.rght)
        return pages.count() > self.level
    is_active.short_description = _('is active')

    def are_ancestors_active(self):
        """
        Check whether all ancestors of this page are active
        """

        if self.is_root_node():
            return True

        queryset = PageManager.apply_active_filters(self.get_ancestors())
        return queryset.count() >= self.level

    def short_title(self):
        """
        Title shortened for display.
        """
        return shorten_string(self.title)
    short_title.admin_order_field = 'title'
    short_title.short_description = _('title')

    def __init__(self, *args, **kwargs):
        super(BasePage, self).__init__(*args, **kwargs)
        # Cache a copy of the loaded _cached_url value so we can reliably
        # determine whether it has been changed in the save handler:
        self._original_cached_url = self._cached_url

    def save(self, *args, **kwargs):
        """
        Overridden save method which updates the ``_cached_url`` attribute of
        this page and all subpages. Quite expensive when called with a page
        high up in the tree.
        """

        cached_page_urls = {}

        # determine own URL
        if self.override_url:
            self._cached_url = self.override_url
        elif self.is_root_node():
            self._cached_url = '/%s/' % self.slug
        else:
            self._cached_url = '%s%s/' % (self.parent._cached_url, self.slug)

        cached_page_urls[self.id] = self._cached_url
        super(BasePage, self).save(*args, **kwargs)

        # Okay, we have changed the page -- remove the old stale entry from the
        # cache
        self.invalidate_cache()

        # If our cached URL changed we need to update all descendants to
        # reflect the changes. Since this is a very expensive operation
        # on large sites we'll check whether our _cached_url actually changed
        # or if the updates weren't navigation related:
        if self._cached_url == self._original_cached_url:
            return

        pages = self.get_descendants().order_by('lft')

        for page in pages:
            if page.override_url:
                page._cached_url = page.override_url
            else:
                # cannot be root node by definition
                page._cached_url = '%s%s/' % (
                    cached_page_urls[page.parent_id],
                    page.slug)

            cached_page_urls[page.id] = page._cached_url
            super(BasePage, page).save()  # do not recurse
    save.alters_data = True

    def delete(self, *args, **kwargs):
        if not settings.FEINCMS_SINGLETON_TEMPLATE_DELETION_ALLOWED:
            if self.template.singleton:
                raise PermissionDenied(_(
                    'This %(page_class)s uses a singleton template, and '
                    'FEINCMS_SINGLETON_TEMPLATE_DELETION_ALLOWED=False' % {
                        'page_class': self._meta.verbose_name}))
        super(BasePage, self).delete(*args, **kwargs)
        self.invalidate_cache()
    delete.alters_data = True

    # Remove the page from the url-to-page cache
    def invalidate_cache(self):
        ck = self.path_to_cache_key(self._original_cached_url)
        django_cache.delete(ck)
        ck = self.path_to_cache_key(self._cached_url)
        django_cache.delete(ck)

    @models.permalink
    def get_absolute_url(self):
        """
        Return the absolute URL of this page.
        """
        # result url never begins or ends with a slash
        url = self._cached_url.strip('/')
        if url:
            return ('feincms_handler', (url,), {})
        return ('feincms_home', (), {})

    def get_navigation_url(self):
        """
        Return either ``redirect_to`` if it is set, or the URL of this page.
        """

        # :-( maybe this could be cleaned up a bit?
        if not self.redirect_to or REDIRECT_TO_RE.match(self.redirect_to):
            return self._cached_url
        return self.redirect_to

    cache_key_components = [
        lambda p: getattr(django_settings, 'SITE_ID', 0),
        lambda p: p._django_content_type.id,
        lambda p: p.id,
    ]

    def cache_key(self):
        """
        Return a string that may be used as cache key for the current page.
        The cache_key is unique for each content type and content instance.

        This function is here purely for your convenience. FeinCMS itself
        does not use it in any way.
        """
        return '-'.join(str(fn(self)) for fn in self.cache_key_components)

    def etag(self, request):
        """
        Generate an etag for this page.
        An etag should be unique and unchanging for as long as the page
        content does not change. Since we have no means to determine whether
        rendering the page now (as opposed to a minute ago) will actually
        give the same result, this default implementation returns None, which
        means "No etag please, thanks for asking".
        """
        return None

    def last_modified(self, request):
        """
        Generate a last modified date for this page.
        Since a standard page has no way of knowing this, we always return
        "no date" -- this is overridden by the changedate extension.
        """
        return None

    def get_redirect_to_target(self, request):
        """
        This might be overriden/extended by extension modules.
        """

        if not self.redirect_to:
            return ''

        # It might be an identifier for a different object
        match = REDIRECT_TO_RE.match(self.redirect_to)

        # It's not, oh well.
        if not match:
            return self.redirect_to

        matches = match.groupdict()
        model = get_model(matches['app_label'], matches['module_name'])

        if not model:
            return self.redirect_to

        try:
            instance = model._default_manager.get(pk=int(matches['pk']))
            return instance.get_absolute_url()
        except models.ObjectDoesNotExist:
            pass

        return self.redirect_to

    @classmethod
    def path_to_cache_key(cls, path):
        prefix = "%s-FOR-URL" % cls.__name__.upper()
        return path_to_cache_key(path.strip('/'), prefix=prefix)

    @classmethod
    def register_default_processors(cls, frontend_editing=False):
        """
        Register our default request processors for the out-of-the-box
        Page experience.
        """
        cls.register_request_processor(
            processors.redirect_request_processor, key='redirect')
        cls.register_request_processor(
            processors.extra_context_request_processor, key='extra_context')

        if frontend_editing:
            cls.register_request_processor(
                processors.frontendediting_request_processor,
                key='frontend_editing')
            cls.register_response_processor(
                processors.frontendediting_response_processor,
                key='frontend_editing')


# ------------------------------------------------------------------------
class Page(BasePage):
    class Meta:
        ordering = ['tree_id', 'lft']
        verbose_name = _('page')
        verbose_name_plural = _('pages')
        # not yet # permissions = (("edit_page", _("Can edit page metadata")),)

Page.register_default_processors(
    frontend_editing=settings.FEINCMS_FRONTEND_EDITING)

signals.post_syncdb.connect(check_database_schema(Page, __name__), weak=False)

# ------------------------------------------------------------------------
# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = processors
from __future__ import absolute_import, print_function, unicode_literals

import re
import sys

from django.conf import settings as django_settings
from django.http import Http404, HttpResponseRedirect
from django.utils.cache import add_never_cache_headers


def redirect_request_processor(page, request):
    """
    Returns a ``HttpResponseRedirect`` instance if the current page says
    a redirect should happen.
    """
    target = page.get_redirect_to_target(request)
    if target:
        if request._feincms_extra_context.get('extra_path', '/') == '/':
            return HttpResponseRedirect(target)
        raise Http404()


def extra_context_request_processor(page, request):
    """
    Fills ``request._feincms_extra_context`` with a few useful variables.
    """
    request._feincms_extra_context.update({
        # XXX This variable name isn't accurate anymore.
        'in_appcontent_subpage': False,
        'extra_path': '/',
    })

    url = page.get_absolute_url()
    if request.path != url:
        request._feincms_extra_context.update({
            'in_appcontent_subpage': True,
            'extra_path': re.sub(
                '^' + re.escape(url.rstrip('/')),
                '',
                request.path,
            ),
        })


def frontendediting_request_processor(page, request):
    """
    Sets the frontend editing state in the cookie depending on the
    ``frontend_editing`` GET parameter and the user's permissions.
    """
    if 'frontend_editing' not in request.GET:
        return

    response = HttpResponseRedirect(request.path)
    if request.user.has_module_perms('page'):
        try:
            enable_fe = int(request.GET['frontend_editing']) > 0
        except ValueError:
            enable_fe = False

        if enable_fe:
            response.set_cookie(str('frontend_editing'), enable_fe)
        else:
            response.delete_cookie(str('frontend_editing'))

    # Redirect to cleanup URLs
    return response


def frontendediting_response_processor(page, request, response):
    # Add never cache headers in case frontend editing is active
    if (hasattr(request, 'COOKIES')
            and request.COOKIES.get('frontend_editing', False)):

        if hasattr(response, 'add_post_render_callback'):
            response.add_post_render_callback(add_never_cache_headers)
        else:
            add_never_cache_headers(response)


def etag_request_processor(page, request):
    """
    Short-circuits the request-response cycle if the ETag matches.
    """

    # XXX is this a performance concern? Does it create a new class
    # every time the processor is called or is this optimized to a static
    # class??
    class DummyResponse(dict):
        """
        This is a dummy class with enough behaviour of HttpResponse so we
        can use the condition decorator without too much pain.
        """
        def has_header(page, what):
            return False

    def dummy_response_handler(*args, **kwargs):
        return DummyResponse()

    def etagger(request, page, *args, **kwargs):
        etag = page.etag(request)
        return etag

    def lastmodifier(request, page, *args, **kwargs):
        lm = page.last_modified()
        return lm

    # Unavailable in Django 1.0 -- the current implementation of ETag support
    # requires Django 1.1 unfortunately.
    from django.views.decorators.http import condition

    # Now wrap the condition decorator around our dummy handler:
    # the net effect is that we will be getting a DummyResponse from
    # the handler if processing is to continue and a non-DummyResponse
    # (should be a "304 not modified") if the etag matches.
    rsp = condition(etag_func=etagger, last_modified_func=lastmodifier)(
        dummy_response_handler)(request, page)

    # If dummy then don't do anything, if a real response, return and
    # thus shortcut the request processing.
    if not isinstance(rsp, DummyResponse):
        return rsp


def etag_response_processor(page, request, response):
    """
    Response processor to set an etag header on outgoing responses.
    The Page.etag() method must return something valid as etag content
    whenever you want an etag header generated.
    """
    etag = page.etag(request)
    if etag is not None:
        response['ETag'] = '"' + etag + '"'


def debug_sql_queries_response_processor(verbose=False, file=sys.stderr):
    """
    Attaches a handler which prints the query count (and optionally all
    individual queries which have been executed) on the console. Does nothing
    if ``DEBUG = False``.

    Example::

        from feincms.module.page import models, processors
        models.Page.register_response_processor(
            processors.debug_sql_queries_response_processor(verbose=True),
            )
    """
    if not django_settings.DEBUG:
        return lambda page, request, response: None

    def processor(page, request, response):
        from django.db import connection

        print_sql = lambda x: x
        try:
            import sqlparse
            print_sql = lambda x: sqlparse.format(
                x, reindent=True, keyword_case='upper')
        except:
            pass

        if verbose:
            print("-" * 60, file=file)
        time = 0.0
        i = 0
        for q in connection.queries:
            i += 1
            if verbose:
                print("%d : [%s]\n%s\n" % (
                    i, q['time'], print_sql(q['sql'])), file=file)
            time += float(q['time'])

        print("-" * 60, file=file)
        print("Total: %d queries, %.3f ms" % (i, time), file=file)
        print("-" * 60, file=file)

    return processor

########NEW FILE########
__FILENAME__ = sitemap
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

from django.db.models import Max
from django.db.models import get_model
from django.contrib.sitemaps import Sitemap

from feincms import settings


# ------------------------------------------------------------------------
class PageSitemap(Sitemap):
    """
    The PageSitemap can be used to automatically generate sitemap.xml files
    for submission to index engines. See http://www.sitemaps.org/ for details.
    """
    def __init__(self, navigation_only=False, max_depth=0, changefreq=None,
                 queryset=None, filter=None, extended_navigation=False,
                 page_model=settings.FEINCMS_DEFAULT_PAGE_MODEL,
                 *args, **kwargs):
        """
        The PageSitemap accepts the following parameters for customisation
        of the resulting sitemap.xml output:

        * navigation_only -- if set to True, only pages that are in_navigation
        will appear in the site map.
        * max_depth -- if set to a non-negative integer, will limit the sitemap
        generated to this page hierarchy depth.
        * changefreq -- should be a string or callable specifiying the page
        update frequency, according to the sitemap protocol.
        * queryset -- pass in a query set to restrict the Pages to include
        in the site map.
        * filter -- pass in a callable that transforms a queryset to filter
        out the pages you want to include in the site map.
        * extended_navigation -- if set to True, adds pages from any navigation
        extensions. If using PagePretender, make sure to include title, url,
        level, in_navigation and optionally modification_date.
        """
        super(PageSitemap, self).__init__(*args, **kwargs)
        self.depth_cutoff = max_depth
        self.navigation_only = navigation_only
        self.changefreq = changefreq
        self.filter = filter
        self.extended_navigation = extended_navigation
        if queryset is not None:
            self.queryset = queryset
        else:
            Page = get_model(*page_model.split('.'))
            self.queryset = Page.objects.active()

    def items(self):
        """
        Consider all pages that are active and that are not a redirect
        """

        base_qs = self.queryset
        if callable(base_qs):
            base_qs = base_qs()

        self.max_depth = base_qs.aggregate(Max('level'))['level__max'] or 0
        if self.depth_cutoff > 0:
            self.max_depth = min(self.depth_cutoff, self.max_depth)

        qs = base_qs.filter(redirect_to="")
        if self.filter:
            qs = self.filter(qs)
        if self.navigation_only:
            qs = qs.filter(in_navigation=True)
        if self.depth_cutoff > 0:
            qs = qs.filter(level__lte=self.max_depth - 1)

        pages = [p for p in qs if p.is_active()]

        if self.extended_navigation:
            for idx, page in enumerate(pages):
                if self.depth_cutoff > 0 and page.level == self.max_depth:
                    continue
                if getattr(page, 'navigation_extension', None):
                    cnt = 0
                    for p in page.extended_navigation():
                        depth_too_deep = (
                            self.depth_cutoff > 0
                            and p.level > self.depth_cutoff)
                        not_in_nav = (
                            self.navigation_only
                            and not p.in_navigation)
                        if depth_too_deep or not_in_nav:
                            continue
                        cnt += 1
                        pages.insert(idx + cnt, p)
                        if p.level > self.max_depth:
                            self.max_depth = p.level

        self.per_level = 1.0 / (self.max_depth + 1.0)
        return pages

    def lastmod(self, obj):
        return getattr(obj, 'modification_date', None)

    # the priority is computed of the depth in the tree of a page
    # may we should make an extension to give control to the user for priority
    def priority(self, obj):
        """
        The priority is staggered according to the depth of the page in
        the site. Top level get highest priority, then each level is decreased
        by per_level.
        """
        if getattr(obj, 'override_url', '') == '/':
            prio = 1.0
        else:
            prio = 1.0 - (obj.level + 1) * self.per_level

        # If the page is in_navigation, then it's more important, so boost
        # its importance
        if obj.in_navigation:
            prio += 1.2 * self.per_level

        return "%0.2g" % min(1.0, prio)

# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = feincms_page_tags
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

import logging
import sys
import traceback

from django import template
from django.conf import settings
from django.db.models.loading import get_model
from django.http import HttpRequest

from feincms import settings as feincms_settings
from feincms.module.page.extensions.navigation import PagePretender
from feincms.utils.templatetags import (
    SimpleNodeWithVarAndArgs,
    do_simple_node_with_var_and_args_helper,
    SimpleAssignmentNodeWithVarAndArgs,
    do_simple_assignment_node_with_var_and_args_helper)


logger = logging.getLogger('feincms.templatetags.page')

register = template.Library()


def _get_page_model():
    return get_model(*feincms_settings.FEINCMS_DEFAULT_PAGE_MODEL.split('.'))


# ------------------------------------------------------------------------
# TODO: Belongs in some utility module
def format_exception(e):
    top = traceback.extract_tb(sys.exc_info()[2])[-1]
    return "'%s' in %s line %d" % (e, top[0], top[1])


# ------------------------------------------------------------------------
@register.assignment_tag(takes_context=True)
def feincms_nav(context, feincms_page, level=1, depth=1):
    """
    Saves a list of pages into the given context variable.
    """

    page_class = _get_page_model()

    if isinstance(feincms_page, HttpRequest):
        try:
            feincms_page = page_class.objects.for_request(
                feincms_page, best_match=True)
        except page_class.DoesNotExist:
            return []

    mptt_opts = feincms_page._mptt_meta

    # mptt starts counting at zero
    mptt_level_range = [level - 1, level + depth - 1]

    queryset = feincms_page.__class__._default_manager.in_navigation().filter(
        **{
            '%s__gte' % mptt_opts.level_attr: mptt_level_range[0],
            '%s__lt' % mptt_opts.level_attr: mptt_level_range[1],
        }
    )

    page_level = getattr(feincms_page, mptt_opts.level_attr)

    # Used for subset filtering (level>1)
    parent = None

    if level > 1:
        # A subset of the pages is requested. Determine it depending
        # upon the passed page instance

        if level - 2 == page_level:
            # The requested pages start directly below the current page
            parent = feincms_page

        elif level - 2 < page_level:
            # The requested pages start somewhere higher up in the tree
            parent = feincms_page.get_ancestors()[level - 2]

        elif level - 1 > page_level:
            # The requested pages are grandchildren of the current page
            # (or even deeper in the tree). If we would continue processing,
            # this would result in pages from different subtrees being
            # returned directly adjacent to each other.
            queryset = page_class.objects.none()

        if parent:
            if getattr(parent, 'navigation_extension', None):
                # Special case for navigation extensions
                return list(parent.extended_navigation(
                    depth=depth, request=context.get('request')))

            # Apply descendant filter
            queryset &= parent.get_descendants()

    if depth > 1:
        # Filter out children with inactive parents
        # None (no parent) is always allowed
        parents = set([None])
        if parent:
            # Subset filtering; allow children of parent as well
            parents.add(parent.id)

        def _parentactive_filter(iterable):
            for elem in iterable:
                if elem.parent_id in parents:
                    yield elem
                parents.add(elem.id)

        queryset = _parentactive_filter(queryset)

    if hasattr(feincms_page, 'navigation_extension'):
        # Filter out children of nodes which have a navigation extension
        def _navext_filter(iterable):
            current_navextension_node = None
            for elem in iterable:
                # Eliminate all subitems of last processed nav extension
                if current_navextension_node is not None and \
                   current_navextension_node.is_ancestor_of(elem):
                    continue

                yield elem
                if getattr(elem, 'navigation_extension', None):
                    current_navextension_node = elem
                    try:
                        for extended in elem.extended_navigation(
                                depth=depth, request=context.get('request')):
                            # Only return items from the extended navigation
                            # which are inside the requested level+depth
                            # values. The "-1" accounts for the differences in
                            # MPTT and navigation level counting
                            this_level = getattr(
                                extended, mptt_opts.level_attr, 0)
                            if this_level < level + depth - 1:
                                yield extended
                    except Exception as e:
                        logger.warn(
                            "feincms_nav caught exception in navigation"
                            " extension for page %d: %s",
                            current_navextension_node.id, format_exception(e))
                else:
                    current_navextension_node = None

        queryset = _navext_filter(queryset)

    # Return a list, not a generator so that it can be consumed
    # several times in a template.
    return list(queryset)


# ------------------------------------------------------------------------
class ParentLinkNode(SimpleNodeWithVarAndArgs):
    """
    {% feincms_parentlink of feincms_page level=1 %}
    """

    def what(self, page, args):
        level = int(args.get('level', 1))

        if page.level + 1 == level:
            return page.get_absolute_url()
        elif page.level + 1 < level:
            return '#'

        try:
            return page.get_ancestors()[level - 1].get_absolute_url()
        except IndexError:
            return '#'

register.tag(
    'feincms_parentlink',
    do_simple_node_with_var_and_args_helper(ParentLinkNode))


# ------------------------------------------------------------------------
class LanguageLinksNode(SimpleAssignmentNodeWithVarAndArgs):
    """
    ::

        {% feincms_languagelinks for feincms_page as links [args] %}

    This template tag needs the translations extension.

    Arguments can be any combination of:

    * all or existing: Return all languages or only those where a translation
      exists
    * excludecurrent: Excludes the item in the current language from the list
    * request=request: The current request object, only needed if you are using
      AppContents and need to append the "extra path"

    The default behavior is to return an entry for all languages including the
    current language.

    Example::

      {% feincms_languagelinks for feincms_page as links all,excludecurrent %}
      {% for key, name, link in links %}
          <a href="{% if link %}{{ link }}{% else %}/{{ key }}/{% endif %}">
            {% trans name %}</a>
      {% endfor %}
    """

    def what(self, page, args):
        only_existing = args.get('existing', False)
        exclude_current = args.get('excludecurrent', False)

        # Preserve the trailing path when switching languages if extra_path
        # exists (this is mostly the case when we are working inside an
        # ApplicationContent-managed page subtree)
        trailing_path = ''
        request = args.get('request', None)
        if request:
            # Trailing path without first slash
            trailing_path = request._feincms_extra_context.get(
                'extra_path', '')[1:]

        translations = dict(
            (t.language, t) for t in page.available_translations())
        translations[page.language] = page

        links = []
        for key, name in settings.LANGUAGES:
            if exclude_current and key == page.language:
                continue

            # hardcoded paths... bleh
            if key in translations:
                links.append((
                    key,
                    name,
                    translations[key].get_absolute_url() + trailing_path))
            elif not only_existing:
                links.append((key, name, None))

        return links

register.tag(
    'feincms_languagelinks',
    do_simple_assignment_node_with_var_and_args_helper(LanguageLinksNode))


# ------------------------------------------------------------------------
def _translate_page_into(page, language, default=None):
    """
    Return the translation for a given page
    """
    # Optimisation shortcut: No need to dive into translations if page already
    # what we want
    try:
        if page.language == language:
            return page

        if language is not None:
            translations = dict(
                (t.language, t) for t in page.available_translations())
            if language in translations:
                return translations[language]
    except AttributeError:
        pass

    if hasattr(default, '__call__'):
        return default(page=page)
    return default


# ------------------------------------------------------------------------
class TranslatedPageNode(SimpleAssignmentNodeWithVarAndArgs):
    """
    ::

        {% feincms_translatedpage for feincms_page as feincms_transpage
            language=en %}
        {% feincms_translatedpage for feincms_page as originalpage %}
        {% feincms_translatedpage for some_page as translatedpage
            language=feincms_page.language %}

    This template tag needs the translations extension.

    Returns the requested translation of the page if it exists. If the language
    argument is omitted the primary language will be returned (the first
    language specified in settings.LANGUAGES).

    Note: To distinguish between a bare language code and a variable we check
    whether settings LANGUAGES contains that code -- so naming a variable "en"
    will probably not do what is intended.
    """
    def what(self, page, args, default=None):
        language = args.get('language', None)

        if language is None:
            language = settings.LANGUAGES[0][0]
        else:
            if language not in (x[0] for x in settings.LANGUAGES):
                try:
                    language = template.Variable(language).resolve(
                        self.render_context)
                except template.VariableDoesNotExist:
                    language = settings.LANGUAGES[0][0]

        return _translate_page_into(page, language, default=default)

register.tag(
    'feincms_translatedpage',
    do_simple_assignment_node_with_var_and_args_helper(TranslatedPageNode))


# ------------------------------------------------------------------------
class TranslatedPageNodeOrBase(TranslatedPageNode):
    def what(self, page, args):
        return super(TranslatedPageNodeOrBase, self).what(
            page, args,
            default=getattr(page, 'get_original_translation', page))

register.tag(
    'feincms_translatedpage_or_base',
    do_simple_assignment_node_with_var_and_args_helper(
        TranslatedPageNodeOrBase))


# ------------------------------------------------------------------------
@register.filter
def feincms_translated_or_base(pages, language=None):
    if not hasattr(pages, '__iter__'):
        pages = [pages]
    for page in pages:
        yield _translate_page_into(
            page, language, default=page.get_original_translation)


# ------------------------------------------------------------------------
@register.inclusion_tag("breadcrumbs.html")
def feincms_breadcrumbs(page, include_self=True):
    """
    Generate a list of the page's ancestors suitable for use as breadcrumb
    navigation.

    By default, generates an unordered list with the id "breadcrumbs" -
    override breadcrumbs.html to change this.

    ::

        {% feincms_breadcrumbs feincms_page %}
    """

    ancs = page.get_ancestors()

    bc = [(anc.get_absolute_url(), anc.short_title()) for anc in ancs]

    if include_self:
        bc.append((None, page.short_title()))

    return {"trail": bc}


# ------------------------------------------------------------------------
def _is_parent_of(page1, page2):
    return (
        page1.tree_id == page2.tree_id
        and page1.lft < page2.lft
        and page1.rght > page2.rght)


@register.filter
def is_parent_of(page1, page2):
    """
    Determines whether a given page is the parent of another page

    Example::

        {% if page|is_parent_of:feincms_page %} ... {% endif %}
    """

    try:
        return _is_parent_of(page1, page2)
    except AttributeError:
        return False


# ------------------------------------------------------------------------
def _is_equal_or_parent_of(page1, page2):
    return (
        page1.tree_id == page2.tree_id
        and page1.lft <= page2.lft
        and page1.rght >= page2.rght)


@register.filter
def is_equal_or_parent_of(page1, page2):
    """
    Determines whether a given page is equal to or the parent of another page.
    This is especially handy when generating the navigation. The following
    example adds a CSS class ``current`` to the current main navigation entry::

        {% for page in navigation %}
            <a
            {% if page|is_equal_or_parent_of:feincms_page %}
                class="current"
            {% endif %}
            >{{ page.title }}</a>
        {% endfor %}
    """
    try:
        return _is_equal_or_parent_of(page1, page2)
    except AttributeError:
        return False


# ------------------------------------------------------------------------
def _is_sibling_of(page1, page2):
    return page1.parent_id == page2.parent_id


@register.filter
def is_sibling_of(page1, page2):
    """
    Determines whether a given page is a sibling of another page

    ::

        {% if page|is_sibling_of:feincms_page %} ... {% endif %}
    """

    try:
        return _is_sibling_of(page1, page2)
    except AttributeError:
        return False


# ------------------------------------------------------------------------
@register.filter
def siblings_along_path_to(page_list, page2):
    """
    Filters a list of pages so that only those remain that are either:

        * An ancestor of the current page
        * A sibling of an ancestor of the current page

    A typical use case is building a navigation menu with the active
    path to the current page expanded::

        {% feincms_nav feincms_page level=1 depth=3 as navitems %}
        {% with navitems|siblings_along_path_to:feincms_page as navtree %}
            ... whatever ...
        {% endwith %}

    """

    if page_list:
        try:
            # Try to avoid hitting the database: If the current page is
            # in_navigation, then all relevant pages are already in the
            # incoming list, no need to fetch ancestors or children.

            # NOTE: This assumes that the input list actually is complete (ie.
            # comes from feincms_nav). We'll cope with the fall-out of that
            # assumption when it happens...
            ancestors = [
                a_page for a_page in page_list
                if _is_equal_or_parent_of(a_page, page2)]
            top_level = min((a_page.level for a_page in page_list))

            if not ancestors:
                # Happens when we sit on a page outside the navigation tree so
                # fake an active root page to avoid a get_ancestors() db call
                # which would only give us a non-navigation root page anyway.
                page_class = _get_page_model()

                p = page_class(
                    title="dummy",
                    tree_id=-1,
                    parent_id=None,
                    in_navigation=False)
                ancestors = (p,)

            siblings = [
                a_page for a_page in page_list
                if a_page.parent_id == page2.id
                or a_page.level == top_level
                or any((_is_sibling_of(a_page, a) for a in ancestors))]

            return siblings
        except (AttributeError, ValueError) as e:
            logger.warn(
                "siblings_along_path_to caught exception: %s",
                format_exception(e))

    return ()


# ------------------------------------------------------------------------
@register.assignment_tag(takes_context=True)
def page_is_active(context, page, feincms_page=None, path=None):
    """
    Usage example::

        {% feincms_nav feincms_page level=1 as toplevel %}
        <ul>
        {% for page in toplevel %}
            {% page_is_active page as is_active %}
            <li {% if is_active %}class="active"{% endif %}>
                <a href="{{ page.get_navigation_url }}">{{ page.title }}</a>
            <li>
        {% endfor %}
        </ul>
    """
    if isinstance(page, PagePretender):
        if path is None:
            path = context['request'].path_info
        return page.get_absolute_url().startswith(path)

    else:
        if feincms_page is None:
            feincms_page = context['feincms_page']
        return _is_equal_or_parent_of(page, feincms_page)

########NEW FILE########
__FILENAME__ = shortcuts
from __future__ import absolute_import, unicode_literals

from django.shortcuts import render_to_response
from django.template import RequestContext

from feincms.module.page.models import Page


def render_to_response_best_match(request, template_name, dictionary=None):
    """
    ``render_to_response`` wrapper using best match for the current page.
    """

    dictionary = dictionary or {}
    dictionary['feincms_page'] = Page.objects.best_match_for_request(request)

    return render_to_response(
        template_name,
        dictionary,
        context_instance=RequestContext(request))

########NEW FILE########
__FILENAME__ = signals
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------
#
#  Created by Martin J. Laubach on 2011-08-01
#  Copyright (c) 2011 Martin J. Laubach. All rights reserved.
#
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

from django.dispatch import Signal

# ------------------------------------------------------------------------
# This signal is sent when an item editor managed object is completely
# saved, especially including all foreign or manytomany dependencies.

itemeditor_post_save_related = Signal(providing_args=["instance", "created"])

# ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = applicationcontent_tags
from __future__ import absolute_import, unicode_literals

from django import template
from django.core.urlresolvers import NoReverseMatch
from django.template import TemplateSyntaxError
from django.template.defaulttags import kwarg_re
from django.utils.encoding import smart_str

from feincms.content.application.models import (
    ApplicationContent, app_reverse as do_app_reverse)
from feincms.templatetags.feincms_tags import _render_content
# backwards compatibility import
from feincms.templatetags.fragment_tags import (
    fragment, get_fragment, has_fragment)


register = template.Library()

register.tag(fragment)
register.tag(get_fragment)
register.filter(has_fragment)


@register.simple_tag
def feincms_render_region_appcontent(page, region, request):
    """Render only the application content for the region

    This allows template authors to choose whether their page behaves
    differently when displaying embedded application subpages by doing
    something like this::

        {% if not in_appcontent_subpage %}
            {% feincms_render_region feincms_page "main" request %}
        {% else %}
            {% feincms_render_region_appcontent feincms_page "main" request %}
        {% endif %}
    """
    return ''.join(
        _render_content(content, request=request)
        for content in page.content.all_of_type(ApplicationContent)
        if content.region == region)


class AppReverseNode(template.Node):
    def __init__(self, view_name, urlconf, args, kwargs, asvar):
        self.view_name = view_name
        self.urlconf = urlconf
        self.args = args
        self.kwargs = kwargs
        self.asvar = asvar

    def render(self, context):
        args = [arg.resolve(context) for arg in self.args]
        kwargs = dict([
            (smart_str(k, 'ascii'), v.resolve(context))
            for k, v in self.kwargs.items()])
        view_name = self.view_name.resolve(context)
        urlconf = self.urlconf.resolve(context)

        try:
            url = do_app_reverse(
                view_name, urlconf, args=args, kwargs=kwargs,
                current_app=context.current_app)
        except NoReverseMatch:
            if self.asvar is None:
                raise
            url = ''

        if self.asvar:
            context[self.asvar] = url
            return ''
        else:
            return url


@register.tag
def app_reverse(parser, token):
    """
    Returns an absolute URL for applications integrated with ApplicationContent

    The tag mostly works the same way as Django's own {% url %} tag::

        {% load applicationcontent_tags %}
        {% app_reverse "mymodel_detail" "myapp.urls" arg1 arg2 %}

        or

        {% load applicationcontent_tags %}
        {% app_reverse "mymodel_detail" "myapp.urls" name1=value1 %}

    The first argument is a path to a view. The second argument is the URLconf
    under which this app is known to the ApplicationContent. The second
    argument may also be a request object if you want to reverse an URL
    belonging to the current application content.

    Other arguments are space-separated values that will be filled in place of
    positional and keyword arguments in the URL. Don't mix positional and
    keyword arguments.

    If you want to store the URL in a variable instead of showing it right away
    you can do so too::

        {% app_reverse "mymodel_detail" "myapp.urls" arg1 arg2 as url %}
    """
    bits = token.split_contents()
    if len(bits) < 3:
        raise TemplateSyntaxError(
            "'%s' takes at least two arguments"
            " (path to a view and a urlconf)" % bits[0])
    viewname = parser.compile_filter(bits[1])
    urlconf = parser.compile_filter(bits[2])
    args = []
    kwargs = {}
    asvar = None
    bits = bits[3:]
    if len(bits) >= 2 and bits[-2] == 'as':
        asvar = bits[-1]
        bits = bits[:-2]

    if len(bits):
        for bit in bits:
            match = kwarg_re.match(bit)
            if not match:
                raise TemplateSyntaxError(
                    "Malformed arguments to app_reverse tag")
            name, value = match.groups()
            if name:
                kwargs[name] = parser.compile_filter(value)
            else:
                args.append(parser.compile_filter(value))

    return AppReverseNode(viewname, urlconf, args, kwargs, asvar)

########NEW FILE########
__FILENAME__ = feincms_admin_tags
from __future__ import absolute_import, unicode_literals

import django
from django import template


register = template.Library()


@register.filter
def post_process_fieldsets(fieldset):
    """
    Removes a few fields from FeinCMS admin inlines, those being
    ``id``, ``DELETE`` and ``ORDER`` currently.

    Additionally, it ensures that dynamically added fields (i.e.
    ``ApplicationContent``'s ``admin_fields`` option) are shown.
    """
    # abort if fieldset is customized
    if fieldset.model_admin.fieldsets:
        return fieldset

    fields_to_include = set(fieldset.form.fields.keys())
    for f in ('id', 'DELETE', 'ORDER'):
        fields_to_include.discard(f)

    def _filter_recursive(fields):
        ret = []
        for f in fields:
            if isinstance(f, (list, tuple)):
                # Several fields on one line
                sub = _filter_recursive(f)
                # Only add if there's at least one field left
                if sub:
                    ret.append(sub)
            elif f in fields_to_include:
                ret.append(f)
                fields_to_include.discard(f)
        return ret

    new_fields = _filter_recursive(fieldset.fields)
    # Add all other fields (ApplicationContent's admin_fields) to
    # the end of the fieldset
    for f in fields_to_include:
        new_fields.append(f)

    fieldset.fields = new_fields
    return fieldset


@register.assignment_tag
def is_popup_var():
    """
    Django 1.6 requires _popup=1 for raw id field popups, earlier versions
    require pop=1.

    The explicit version check is a bit ugly, but works well.

    (Wrong parameters aren't simply ignored by django.contrib.admin, the
    change list actively errors out by redirecting to ?e=1)
    """
    if django.VERSION < (1, 6):
        return 'pop=1'
    return '_popup=1'

########NEW FILE########
__FILENAME__ = feincms_tags
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

import logging

from django import template
from django.conf import settings
from django.template.loader import render_to_string

from feincms.utils import get_singleton, get_singleton_url


register = template.Library()


def _render_content(content, **kwargs):
    # Track current render level and abort if we nest too deep. Avoids
    # crashing in recursive page contents (eg. a page list that contains
    # itself or similar).
    request = kwargs.get('request')
    if request is not None:
        level = getattr(request, 'feincms_render_level', 0)
        if level > 10:
            logging.getLogger('feincms').error(
                'Refusing to render %r, render level is already %s' % (
                    content, level))
            return
        setattr(request, 'feincms_render_level', level + 1)

    if (request and request.COOKIES.get('frontend_editing', False)
            and hasattr(content, 'fe_render')):
        r = content.fe_render(**kwargs)
    else:
        r = content.render(**kwargs)

    if request is not None:
        level = getattr(request, 'feincms_render_level', 1)
        setattr(request, 'feincms_render_level', max(level - 1, 0))

    return r


@register.simple_tag(takes_context=True)
def feincms_render_region(context, feincms_object, region, request=None):
    """
    {% feincms_render_region feincms_page "main" request %}
    """
    return ''.join(
        _render_content(content, request=request, context=context)
        for content in getattr(feincms_object.content, region))


@register.simple_tag(takes_context=True)
def feincms_render_content(context, content, request=None):
    """
    {% feincms_render_content content request %}
    """
    return _render_content(content, request=request, context=context)


@register.simple_tag
def feincms_frontend_editing(cms_obj, request):
    """
    {% feincms_frontend_editing feincms_page request %}
    """

    if (hasattr(request, 'COOKIES')
            and request.COOKIES.get('frontend_editing') == 'True'):
        context = template.RequestContext(request, {
            "feincms_page": cms_obj,
        })
        return render_to_string('admin/feincms/fe_tools.html', context)

    return ''


@register.inclusion_tag('admin/feincms/content_type_selection_widget.html',
                        takes_context=True)
def show_content_type_selection_widget(context, region):
    """
    {% show_content_type_selection_widget region %}
    """
    user = context['request'].user
    grouped = {}
    ungrouped = []
    for ct in region._content_types:
        # Skip cts that we shouldn't be adding anyway
        perm = ct._meta.app_label + "." + ct._meta.get_add_permission()
        if not user.has_perm(perm):
            continue

        ct_info = (ct.__name__.lower(), ct._meta.verbose_name)
        if hasattr(ct, 'optgroup'):
            if ct.optgroup in grouped:
                grouped[ct.optgroup].append(ct_info)
            else:
                grouped[ct.optgroup] = [ct_info]
        else:
            ungrouped.append(ct_info)
    return {'grouped': grouped, 'ungrouped': ungrouped}


@register.assignment_tag
def feincms_load_singleton(template_key, cls=None):
    """
    {% feincms_load_singleton template_key %} -- return a FeinCMS
    Base object which uses a Template with singleton=True.
    """
    return get_singleton(template_key, cls, raise_exception=settings.DEBUG)


@register.simple_tag
def feincms_singleton_url(template_key, cls=None):
    """
    {% feincms_singleton_url template_key %} -- return the URL of a FeinCMS
    Base object which uses a Template with singleton=True.
    """
    return get_singleton_url(template_key, cls, raise_exception=settings.DEBUG)

########NEW FILE########
__FILENAME__ = feincms_thumbnail
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

from io import BytesIO
import re

# Try to import PIL in either of the two ways it can end up installed.
try:
    from PIL import Image
except ImportError:
    try:
        import Image
    except ImportError:
        # Django seems to silently swallow the ImportError under certain
        # circumstances. Raise a generic exception explaining why we are
        # unable to proceed.
        raise Exception('FeinCMS requires PIL to be installed')

from django import template
from django.utils.encoding import force_text, python_2_unicode_compatible
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
from django.utils import six

from feincms import settings


register = template.Library()


@python_2_unicode_compatible
class Thumbnailer(object):
    THUMBNAIL_SIZE_RE = re.compile(r'^(?P<w>\d+)x(?P<h>\d+)$')
    MARKER = '_thumb_'

    def __init__(self, filename, size='200x200'):
        self.filename = filename
        self.size = size

    @property
    def url(self):
        return six.text_type(self)

    def __str__(self):
        match = self.THUMBNAIL_SIZE_RE.match(self.size)
        if not (self.filename and match):
            return ''

        matches = match.groupdict()

        # figure out storage
        if hasattr(self.filename, 'storage'):
            storage = self.filename.storage
        else:
            storage = default_storage

        # figure out name
        if hasattr(self.filename, 'name'):
            filename = self.filename.name
        else:
            filename = force_text(self.filename)

        # defining the filename and the miniature filename
        try:
            basename, format = filename.rsplit('.', 1)
        except ValueError:
            basename, format = filename, 'jpg'

        miniature = ''.join([
            settings.FEINCMS_THUMBNAIL_DIR,
            basename,
            self.MARKER,
            self.size,
            '.',
            format,
        ])

        if not storage.exists(miniature):
            generate = True
        else:
            try:
                generate = (
                    storage.modified_time(miniature)
                    < storage.modified_time(filename))
            except (NotImplementedError, AttributeError):
                # storage does NOT support modified_time
                generate = False
            except (OSError, IOError):
                # Someone might have delete the file
                return ''

        if generate:
            return self.generate(
                storage=storage,
                original=filename,
                size=matches,
                miniature=miniature)

        return storage.url(miniature)

    def generate(self, storage, original, size, miniature):
        try:
            image = Image.open(BytesIO(storage.open(original).read()))

            # defining the size
            w, h = int(size['w']), int(size['h'])

            format = image.format  # Save format for the save() call later
            image.thumbnail([w, h], Image.ANTIALIAS)
            buf = BytesIO()
            if image.mode not in ('RGBA', 'RGB', 'L'):
                image = image.convert('RGBA')
            image.save(
                buf,
                format if format.lower() in ('jpg', 'jpeg', 'png') else 'jpeg',
                quality=90)
            raw_data = buf.getvalue()
            buf.close()

            storage.delete(miniature)
            storage.save(miniature, ContentFile(raw_data))

            return storage.url(miniature)
        except:
            # PIL raises a plethora of Exceptions if reading the image
            # is not possible. Since we cannot be sure what Exception will
            # happen, catch them all so the thumbnailer will never fail.
            return storage.url(original)


class CropscaleThumbnailer(Thumbnailer):
    THUMBNAIL_SIZE_RE = re.compile(
        r'^(?P<w>\d+)x(?P<h>\d+)(-(?P<x>\d+)x(?P<y>\d+))?$')
    MARKER = '_cropscale_'

    def generate(self, storage, original, size, miniature):
        try:
            image = Image.open(BytesIO(storage.open(original).read()))
        except:
            # PIL raises a plethora of Exceptions if reading the image
            # is not possible. Since we cannot be sure what Exception will
            # happen, catch them all so the thumbnailer will never fail.
            return storage.url(original)

        storage.delete(miniature)

        w, h = int(size['w']), int(size['h'])

        if size['x'] and size['y']:
            x, y = int(size['x']), int(size['y'])
        else:
            x, y = 50, 50

        src_width, src_height = image.size
        src_ratio = float(src_width) / float(src_height)
        dst_width, dst_height = w, h
        dst_ratio = float(dst_width) / float(dst_height)

        if dst_ratio < src_ratio:
            crop_height = src_height
            crop_width = crop_height * dst_ratio
            x_offset = int(float(src_width - crop_width) * x / 100)
            y_offset = 0
        else:
            crop_width = src_width
            crop_height = crop_width / dst_ratio
            x_offset = 0
            y_offset = int(float(src_height - crop_height) * y / 100)

        format = image.format  # Save format for the save() call later
        image = image.crop((
            x_offset,
            y_offset,
            x_offset + int(crop_width),
            y_offset + int(crop_height)))
        image = image.resize((dst_width, dst_height), Image.ANTIALIAS)

        buf = BytesIO()
        if image.mode not in ('RGBA', 'RGB', 'L'):
            image = image.convert('RGBA')
        image.save(
            buf,
            format if format.lower() in ('jpg', 'jpeg', 'png') else 'jpeg',
            quality=90)
        raw_data = buf.getvalue()
        buf.close()
        storage.save(miniature, ContentFile(raw_data))

        return storage.url(miniature)


@register.filter
def thumbnail(filename, size='200x200'):
    """
    Creates a thumbnail from the image passed, returning its path::

        {{ object.image|thumbnail:"400x300" }}
    OR
        {{ object.image.name|thumbnail:"400x300" }}

    You can pass either an ``ImageField``, ``FileField`` or the ``name``
    but not the ``url`` attribute of an ``ImageField`` or ``FileField``.

    The dimensions passed are treated as a bounding box. The aspect ratio of
    the initial image is preserved. Images aren't blown up in size if they
    are already smaller.

    Both width and height must be specified. If you do not care about one
    of them, just set it to an arbitrarily large number::

        {{ object.image|thumbnail:"300x999999" }}
    """

    return Thumbnailer(filename, size)


@register.filter
def cropscale(filename, size='200x200'):
    """
    Scales the image down and crops it so that its size equals exactly the size
    passed (as long as the initial image is bigger than the specification).
    """

    return CropscaleThumbnailer(filename, size)

########NEW FILE########
__FILENAME__ = fragment_tags
from __future__ import absolute_import, unicode_literals

from django import template


register = template.Library()


class FragmentNode(template.Node):
    def __init__(self, nodelist, request, identifier, mode='append'):
        self.nodelist = nodelist
        self.request_var = template.Variable(request)
        self.identifier_var = template.Variable(identifier)
        self.mode = mode

    def render(self, context):
        request = self.request_var.resolve(context)
        identifier = self.identifier_var.resolve(context)
        rendered = self.nodelist.render(context)

        if not hasattr(request, '_feincms_fragments'):
            request._feincms_fragments = {}

        old = request._feincms_fragments.get(identifier, '')

        if self.mode == 'prepend':
            request._feincms_fragments[identifier] = rendered + old
        elif self.mode == 'replace':
            request._feincms_fragments[identifier] = rendered
        else:  # append
            request._feincms_fragments[identifier] = old + rendered

        return ''


@register.tag
def fragment(parser, token):
    """
    Appends the given content to the fragment. Different modes (replace,
    append) are available if specified.

    Either::

        {% fragment request "title" %} content ... {% endfragment %}

    or::

        {% fragment request "title" (prepend|replace|append) %}
        content ...
        {% endfragment %}
    """

    nodelist = parser.parse(('endfragment'),)
    parser.delete_first_token()

    return FragmentNode(nodelist, *token.contents.split()[1:])


class GetFragmentNode(template.Node):
    def __init__(self, request, fragment, as_var=None):
        self.request = template.Variable(request)
        self.fragment = template.Variable(fragment)
        self.as_var = as_var

    def render(self, context):
        request = self.request.resolve(context)
        fragment = self.fragment.resolve(context)

        try:
            value = request._feincms_fragments[fragment]
        except (AttributeError, KeyError):
            value = ''

        if self.as_var:
            context[self.as_var] = value
            return ''
        return value


@register.tag
def get_fragment(parser, token):
    """
    Fetches the content of a fragment.

    Either::

        {% get_fragment request "title" %}

    or::

        {% get_fragment request "title" as title %}
    """

    fragments = token.contents.split()

    if len(fragments) == 3:
        return GetFragmentNode(fragments[1], fragments[2])
    elif len(fragments) == 5 and fragments[3] == 'as':
        return GetFragmentNode(fragments[1], fragments[2], fragments[4])
    raise template.TemplateSyntaxError(
        'Invalid syntax for get_fragment: %s' % token.contents)


@register.filter
def has_fragment(request, identifier):
    """
    Returns the content of the fragment, despite its name::

        {% if request|has_fragment:"title" %} ... {% endif %}
    """
    return getattr(request, '_feincms_fragments', {}).get(identifier)

########NEW FILE########
__FILENAME__ = translations
"""
This module offers functions and abstract base classes that can be used to
store translated models. There isn't much magic going on here.

Usage example::

    class News(models.Model, TranslatedObjectMixin):
        active = models.BooleanField(default=False)
        created = models.DateTimeField(default=timezone.now)


    class NewsTranslation(Translation(News)):
        title = models.CharField(max_length=200)
        body = models.TextField()


Print the titles of all news entries either in the current language (if
available) or in any other language::

    for news in News.objects.all():
        print news.translation.title

Print all the titles of all news entries which have an english translation::

    from django.utils import translation
    translation.activate('en')
    for news in News.objects.filter(translations__language_code='en'):
        print news.translation.title
"""

from __future__ import absolute_import, unicode_literals

from django.conf import settings
from django.contrib import admin
from django.core.cache import cache
from django.core.exceptions import ObjectDoesNotExist
from django.db import models
from django.db.models import Q
from django.utils import translation
from django.utils.encoding import python_2_unicode_compatible
from django.utils.translation import ugettext_lazy as _

from feincms.utils import queryset_transform


class _NoTranslation(object):
    """Simple marker for when no translations exist for a certain object

    Only used for caching."""
    pass


def short_language_code(code=None):
    """
    Extract the short language code from its argument (or return the default
    language code).

    >>> str(short_language_code('de'))
    'de'
    >>> str(short_language_code('de-at'))
    'de'
    >>> short_language_code() == short_language_code(settings.LANGUAGE_CODE)
    True
    """
    if code is None:
        code = translation.get_language()

    pos = code.find('-')
    if pos > -1:
        return code[:pos]
    return code


def is_primary_language(language=None):
    """
    Returns true if current or passed language is the primary language for this
    site.  (The primary language is defined as the first language in
    settings.LANGUAGES.)
    """

    if not language:
        language = translation.get_language()

    return language == settings.LANGUAGES[0][0]


def lookup_translations(language_code=None):
    """
    Pass the return value of this function to .transform() to automatically
    resolve translation objects

    The current language is used if ``language_code`` isn't specified.
    """
    def _transform(qs):
        lang_ = language_code if language_code else translation.get_language()

        instance_dict = {}

        # Don't do anything for those who already have a cached translation
        # available
        for instance in qs:
            trans = cache.get(instance.get_translation_cache_key(lang_))
            if trans:
                if trans is _NoTranslation:
                    instance._cached_translation = None
                else:
                    instance._cached_translation = trans
            else:
                instance_dict[instance.pk] = instance

        # We really, really need something in here to continue
        if not instance_dict:
            return

        candidates = list(
            instance_dict.values()
        )[0].translations.model._default_manager.all()

        if instance_dict:
            _process(candidates, instance_dict, lang_, 'iexact')
        if instance_dict:
            _process(
                candidates,
                instance_dict,
                settings.LANGUAGE_CODE,
                'istartswith',
            )
        if instance_dict:
            for candidate in candidates.filter(
                    parent__pk__in=instance_dict.keys()):
                if candidate.parent_id in instance_dict:
                    _found(instance_dict, candidate)

        # No translations for the rest
        for instance in instance_dict.values():
            instance._cached_translation = None

    def _found(instance_dict, candidate):
        parent = instance_dict[candidate.parent_id]
        cache.set(parent.get_translation_cache_key(), candidate)
        parent._cached_translation = candidate
        candidate.parent = parent
        del instance_dict[candidate.parent_id]

    def _process(candidates, instance_dict, lang_, op_):
        candidates = candidates.filter(
            Q(parent__pk__in=instance_dict.keys()),
            Q(**{'language_code__' + op_: lang_})
            | Q(**{'language_code__' + op_: short_language_code(lang_)})
        ).order_by('-language_code')

        for candidate in candidates:
            # The candidate's parent might already have a translation by now
            if candidate.parent_id in instance_dict:
                _found(instance_dict, candidate)

    return _transform


class TranslatedObjectManager(queryset_transform.TransformManager):
    """
    This manager offers convenience methods.
    """

    def only_language(self, language=short_language_code):
        """
        Only return objects which have a translation into the given language.

        Uses the currently active language by default.
        """

        return self.filter(translations__language_code=language)


@python_2_unicode_compatible
class TranslatedObjectMixin(object):
    """
    Mixin with helper methods.
    """

    def _get_translation_object(self, queryset, language_code):
        try:
            return queryset.filter(
                Q(language_code__iexact=language_code)
                | Q(language_code__iexact=short_language_code(language_code))
            ).order_by('-language_code')[0]
        except IndexError:
            try:
                return queryset.filter(
                    Q(language_code__istartswith=settings.LANGUAGE_CODE)
                    | Q(language_code__istartswith=short_language_code(
                        settings.LANGUAGE_CODE))
                ).order_by('-language_code')[0]
            except IndexError:
                try:
                    return queryset.all()[0]
                except IndexError:
                    raise queryset.model.DoesNotExist

    def get_translation_cache_key(self, language_code=None):
        """Return the cache key used to cache this object's translations so we
        can purge on-demand"""
        if not language_code:
            language_code = translation.get_language()
        return (
            ('FEINCMS:%d:XLATION:' % getattr(settings, 'SITE_ID', 0))
            + '-'.join(
                ['%s' % s for s in (
                    self._meta.db_table,
                    self.id,
                    language_code,
                )]
            )
        )

    def get_translation(self, language_code=None):
        if not language_code:
            language_code = translation.get_language()

        key = self.get_translation_cache_key(language_code)

        trans = cache.get(key)

        if trans is None:
            try:
                trans = self._get_translation_object(
                    self.translations.all(), language_code)
            except ObjectDoesNotExist:
                trans = _NoTranslation
            cache.set(key, trans)

        if trans is _NoTranslation:
            return None

        # Assign self to prevent additional database queries
        trans.parent = self
        return trans

    @property
    def translation(self):
        if not hasattr(self, '_cached_translation'):
            self._cached_translation = self.get_translation()
        return self._cached_translation

    @property
    def available_translations(self):
        return self.translations.values_list('language_code', flat=True)

    def __str__(self):
        try:
            translation = self.translation
        except ObjectDoesNotExist:
            return self.__class__.__name__

        if translation:
            return '%s' % translation

        return self.__class__.__name__

    def get_absolute_url(self):
        return self.translation.get_absolute_url()

    def purge_translation_cache(self):
        cache.delete(self.get_translation_cache_key())
        for lang in self.available_translations:
            cache.delete(self.get_translation_cache_key(lang))

        try:
            del self._cached_translation
        except AttributeError:
            pass


def Translation(model):
    """
    Return a class which can be used as inheritance base for translation models
    """

    class Inner(models.Model):
        parent = models.ForeignKey(model, related_name='translations')
        language_code = models.CharField(
            _('language'), max_length=10,
            choices=settings.LANGUAGES, default=settings.LANGUAGES[0][0],
            editable=len(settings.LANGUAGES) > 1)

        class Meta:
            unique_together = ('parent', 'language_code')
            # (beware the above will not be inherited automatically if you
            #  provide a Meta class within your translation subclass)
            abstract = True

        def short_language_code(self):
            return short_language_code(self.language_code)

        def save(self, *args, **kwargs):
            super(Inner, self).save(*args, **kwargs)
            self.parent.purge_translation_cache()
        save.alters_data = True

        def delete(self, *args, **kwargs):
            super(Inner, self).delete(*args, **kwargs)
            self.parent.purge_translation_cache()
        delete.alters_data = True

    return Inner


def admin_translationinline(model, inline_class=admin.StackedInline, **kwargs):
    """
    Returns a new inline type suitable for the Django administration::

        from django.contrib import admin
        from myapp.models import News, NewsTranslation

        admin.site.register(News,
            inlines=[
                admin_translationinline(NewsTranslation),
                ],
            )
    """

    kwargs['extra'] = 1
    kwargs['max_num'] = len(settings.LANGUAGES)
    kwargs['model'] = model
    return type(
        str(model.__class__.__name__ + 'Inline'), (inline_class,), kwargs)

########NEW FILE########
__FILENAME__ = urls
# flake8: noqa
from __future__ import absolute_import

from feincms.views.cbv.urls import *

########NEW FILE########
__FILENAME__ = tidy
# encoding: utf-8

from __future__ import absolute_import, unicode_literals

import re
import tidylib

from django.utils import six


try:
    # Python 2
    unichr
except NameError:
    # Python 3
    unichr = chr


# Based on http://stackoverflow.com/questions/92438/
#
# We omit chars 9-13 (tab, newline, vertical tab, form feed, return) and 32
# (space) to avoid clogging our reports with warnings about common,
# non-problematic codes but still allow stripping things which will cause lxml
# to choke

CONTROL_CHAR_RE = re.compile('[%s]' % "".join(
    re.escape(unichr(c)) for c in range(0, 8) + range(14, 31) + range(127, 160)
))


def tidy_html(html):
    """
    Process an input string containing HTML and return a tuple (xhtml,
    errors, warnings) containing the output of tidylib and lists of
    validation errors and warnings.

    Input must be unicode.
    Output will be valid XHTML.
    """
    if not isinstance(html, six.text_type):
        raise ValueError("tidyhtml must be called with a Unicode string!")

    errors = list()
    warnings = list()

    # First, deal with embedded control codes:
    html, sub_count = CONTROL_CHAR_RE.subn(" ", html)
    if sub_count:
        warnings.append("Stripped %d control characters from body: %s" % (
            sub_count,
            set(ord(i) for i in CONTROL_CHAR_RE.findall(html))
        ))

    # tidylib.tidy_fragment will choke if given a full HTML document. This is a
    # primitive content sniff to decide whether to call tidy_document instead:
    if "<html" in html[:1024]:
        tidy_f = tidylib.tidy_document
        doc_mode = True
    else:
        tidy_f = tidylib.tidy_fragment
        doc_mode = False

    html, messages = tidy_f(html.strip(), {
        "char-encoding": "utf8",
        "clean": False,
        "drop-empty-paras": False,
        "drop-font-tags": True,
        "drop-proprietary-attributes": False,
        "fix-backslash": True,
        "indent": True,
        "output-xhtml": True,
    }
    )

    messages = filter(None, (l.strip() for l in messages.split("\n") if l))

    # postprocess warnings to avoid HTML fragments being reported as lacking
    # doctype and title:
    for msg in messages:
        if not doc_mode and "Warning: missing <!DOCTYPE> declaration" in msg:
            continue
        if (not doc_mode
                and "Warning: inserting missing 'title' element" in msg):
            continue
        if not doc_mode and "Warning: inserting implicit <body>" in msg:
            continue

        if "Error:" in msg:
            errors.append(msg)
        else:
            warnings.append(msg)

    return html, errors, warnings

########NEW FILE########
__FILENAME__ = managers
from __future__ import absolute_import, unicode_literals


# ------------------------------------------------------------------------
class ActiveAwareContentManagerMixin(object):
    """
    Implement what's necessary to add some kind of "active" state for content
    objects. The notion of active is defined by a number of filter rules that
    must all match (AND) for the object to be active.

    A Manager for a content class using the "datepublisher" extension
    should either adopt this mixin or implement a similar interface.
    """

    # A dict of filters which are used to determine whether a page is active or
    # not.  Extended for example in the datepublisher extension (date-based
    # publishing and un-publishing of pages). This will be set in
    # add_to_active_filters() below, so we won't share the same dict for
    # derived managers, do not replace with {} here!
    active_filters = None

    @classmethod
    def apply_active_filters(cls, queryset):
        """
        Apply all filters defined to the queryset passed and return the result.
        """
        if cls.active_filters is not None:
            for filt in cls.active_filters.values() or ():
                if callable(filt):
                    queryset = filt(queryset)
                else:
                    queryset = queryset.filter(filt)

        return queryset

    @classmethod
    def add_to_active_filters(cls, filter, key=None):
        """
        Add a new clause to the active filters. A filter may be either
        a Q object to be applied to the content class or a callable taking
        a queryset and spitting out a new one.

        If a filter with the given `key` already exists, the new filter
        replaces the old.
        """
        if cls.active_filters is None:
            cls.active_filters = {}
        if key is None:
            key = filter
        cls.active_filters[key] = filter

    def active(self):
        """
        Return only currently active objects.
        """
        return self.apply_active_filters(self)

########NEW FILE########
__FILENAME__ = queryset_transform
# Straight import from https://github.com/simonw/django-queryset-transform

"""
django_queryset_transform
=========================

Allows you to register a transforming map function with a Django QuerySet
that will be executed only when the QuerySet itself has been evaluated.

This allows you to build optimisations like "fetch all tags for these 10 rows"
while still benefiting from Django's lazy QuerySet evaluation.

For example::

    def lookup_tags(item_qs):
        item_pks = [item.pk for item in item_qs]
        m2mfield = Item._meta.get_field_by_name('tags')[0]
        tags_for_item = Tag.objects.filter(
            item__in = item_pks
        ).extra(select = {
            'item_id': '%s.%s' % (
                m2mfield.m2m_db_table(), m2mfield.m2m_column_name()
            )
        })
        tag_dict = {}
        for tag in tags_for_item:
            tag_dict.setdefault(tag.item_id, []).append(tag)
        for item in item_qs:
            item.fetched_tags = tag_dict.get(item.pk, [])

    qs = Item.objects.filter(name__contains = 'e').transform(lookup_tags)

    for item in qs:
        print item, item.fetched_tags

Prints::

    Winter comes to Ogglesbrook [<sledging>, <snow>, <winter>, <skating>]
    Summer now [<skating>, <sunny>]

But only executes two SQL queries - one to fetch the items, and one to fetch
ALL of the tags for those items.

Since the transformer function can transform an evaluated QuerySet, it
doesn't need to make extra database calls at all - it should work for things
like looking up additional data from a cache.multi_get() as well.

Originally inspired by http://github.com/lilspikey/django-batch-select/



LICENSE
=======

Copyright (c) 2010, Simon Willison.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

    3. Neither the name of Django nor the names of its contributors may be used
       to endorse or promote products derived from this software without
       specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

from __future__ import absolute_import, unicode_literals

from django.db import models


class TransformQuerySet(models.query.QuerySet):
    def __init__(self, *args, **kwargs):
        super(TransformQuerySet, self).__init__(*args, **kwargs)
        self._transform_fns = []

    def _clone(self, klass=None, setup=False, **kw):
        c = super(TransformQuerySet, self)._clone(klass, setup, **kw)
        c._transform_fns = self._transform_fns[:]
        return c

    def transform(self, *fn):
        c = self._clone()
        c._transform_fns.extend(fn)
        return c

    def iterator(self):
        result_iter = super(TransformQuerySet, self).iterator()
        if self._transform_fns:
            results = list(result_iter)
            for fn in self._transform_fns:
                fn(results)
            return iter(results)
        return result_iter


if hasattr(models.Manager, 'from_queryset'):
    TransformManager = models.Manager.from_queryset(TransformQuerySet)

else:
    class TransformManager(models.Manager):
        def get_queryset(self):
            return TransformQuerySet(self.model, using=self._db)

        def get_query_set(self):
            return TransformQuerySet(self.model, using=self._db)

        def transform(self, *fn):
            return self.get_query_set().transform(*fn)

########NEW FILE########
__FILENAME__ = templatetags
'''
I really hate repeating myself. These are helpers that avoid typing the
whole thing over and over when implementing additional template tags

They help implementing tags of the following forms::

    {% tag as var_name %}
    {% tag of template_var as var_name %}
    {% tag of template_var as var_name arg1,arg2,kwarg3=4 %}
'''

from __future__ import absolute_import, unicode_literals

from django import template


def _parse_args(argstr, context=None):
    try:
        args = {}
        for token in argstr.split(','):
            if '=' in token:
                k, v = token.split('=', 1)
                if context:
                    try:
                        args[k] = template.Variable(v).resolve(context)
                    except template.VariableDoesNotExist:
                        args[k] = v
                else:
                    args[k] = v
            else:
                args[token] = True

        return args

    except TypeError:
        raise template.TemplateSyntaxError('Malformed arguments')


def do_simple_node_with_var_and_args_helper(cls):
    def _func(parser, token):
        try:
            tag_name, of_, in_var_name, args = token.contents.split()
        except ValueError:
            try:
                tag_name, of_, in_var_name = token.contents.split()
                args = ''
            except ValueError:
                raise template.TemplateSyntaxError(
                    'Invalid syntax for %s node: %s' % (
                        cls.__name__, token.contents))

        return cls(tag_name, in_var_name, args)

    return _func


class SimpleNodeWithVarAndArgs(template.Node):
    def __init__(self, tag_name, in_var_name, args):
        self.tag_name = tag_name
        self.in_var = template.Variable(in_var_name)
        self.args = args

    def render(self, context):
        self.render_context = context
        try:
            instance = self.in_var.resolve(context)
        except template.VariableDoesNotExist:
            return ''

        return self.what(instance, _parse_args(self.args, context))


def do_simple_assignment_node_with_var_and_args_helper(cls):
    def _func(parser, token):
        try:
            tag_name, of_, in_var_name, as_, var_name, args =\
                token.contents.split()
        except ValueError:
            try:
                tag_name, of_, in_var_name, as_, var_name =\
                    token.contents.split()
                args = ''
            except ValueError:
                raise template.TemplateSyntaxError(
                    'Invalid syntax for %s node: %s' % (
                        cls.__name__, token.contents))

        return cls(tag_name, in_var_name, var_name, args)

    return _func


class SimpleAssignmentNodeWithVarAndArgs(template.Node):
    def __init__(self, tag_name, in_var_name, var_name, args):
        self.tag_name = tag_name
        self.in_var = template.Variable(in_var_name)
        self.var_name = var_name
        self.args = args

    def render(self, context):
        self.render_context = context
        try:
            instance = self.in_var.resolve(context)
        except template.VariableDoesNotExist:
            context[self.var_name] = []
            return ''

        context[self.var_name] = self.what(
            instance, _parse_args(self.args, context))

        return ''

########NEW FILE########
__FILENAME__ = urls
from __future__ import absolute_import

from django.conf.urls import patterns, url

from .views import Handler

handler = Handler.as_view()

urlpatterns = patterns(
    '',
    url(r'^$', handler, name='feincms_home'),
    url(r'^(.*)/$', handler, name='feincms_handler'),
)

########NEW FILE########
__FILENAME__ = views
from __future__ import absolute_import, unicode_literals

from django.db.models import get_model
from django.http import Http404

from feincms import settings
from feincms.module.mixins import ContentView


class Handler(ContentView):
    page_model_path = 'page.Page'
    context_object_name = 'feincms_page'

    @property
    def page_model(self):
        if not hasattr(self, '_page_model'):
            self._page_model = get_model(*self.page_model_path.split('.'))
            if self._page_model is None:
                raise ImportError(
                    "Can't import model \"%s\"" % self.page_model_path)
        return self._page_model

    def get_object(self):
        path = None
        if self.args:
            path = self.args[0]
        return self.page_model._default_manager.for_request(
            self.request, raise404=True, best_match=True, path=path)

    def dispatch(self, request, *args, **kwargs):
        try:
            return super(Handler, self).dispatch(request, *args, **kwargs)
        except Http404 as e:
            if settings.FEINCMS_CMS_404_PAGE:
                try:
                    request.original_path_info = request.path_info
                    request.path_info = settings.FEINCMS_CMS_404_PAGE
                    response = super(Handler, self).dispatch(
                        request, *args, **kwargs)
                    response.status_code = 404
                    return response
                except Http404:
                    raise e
            else:
                raise

########NEW FILE########
__FILENAME__ = decorators
from __future__ import absolute_import, unicode_literals

from functools import wraps

from django.http import HttpResponse


def standalone(view_func):
    """
    Marks the view method as standalone view; this means that
    ``HttpResponse`` objects returned from ``ApplicationContent``
    are returned directly, without further processing.
    """

    def inner(request, *args, **kwargs):
        response = view_func(request, *args, **kwargs)
        if isinstance(response, HttpResponse):
            response.standalone = True
        return response
    return wraps(view_func)(inner)

########NEW FILE########
__FILENAME__ = _internal
"""
These are internal helpers. Do not rely on their presence.

http://mail.python.org/pipermail/python-dev/2008-January/076194.html
"""

from __future__ import absolute_import, unicode_literals


def monkeypatch_method(cls):
    """
    A decorator to add a single method to an existing class::

        @monkeypatch_method(<someclass>)
        def <newmethod>(self, [...]):
            pass
    """

    def decorator(func):
        setattr(cls, func.__name__, func)
        return func
    return decorator


def monkeypatch_property(cls):
    """
    A decorator to add a single method as a property to an existing class::

        @monkeypatch_property(<someclass>)
        def <newmethod>(self, [...]):
            pass
    """

    def decorator(func):
        setattr(cls, func.__name__, property(func))
        return func
    return decorator


def monkeypatch_class(name, bases, namespace):
    """
    A metaclass to add a number of methods (or other attributes) to an
    existing class, using a convenient class notation::

        class <newclass>(<someclass>):
            __metaclass__ = monkeypatch_class
            def <method1>(...): ...
            def <method2>(...): ...
            ...
    """

    assert len(bases) == 1, "Exactly one base class required"
    base = bases[0]
    for name, value in namespace.iteritems():
        if name != "__metaclass__":
            setattr(base, name, value)
    return base

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "testapp.settings")

    sys.path.insert(
        0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = applicationcontent_urls
"""
This is a dummy module used to test the ApplicationContent
"""

from __future__ import absolute_import, unicode_literals

from django.conf.urls import patterns, url
from django.http import HttpResponse, HttpResponseRedirect
from django.template.loader import render_to_string

from feincms.views.decorators import standalone


def module_root(request):
    return 'module_root'


def args_test(request, kwarg1, kwarg2):
    return HttpResponse('%s-%s' % (kwarg1, kwarg2))


def full_reverse_test(request):
    return render_to_string('full_reverse_test.html', {})


def alias_reverse_test(request):
    return render_to_string('alias_reverse_test.html', {})


def fragment(request):
    return render_to_string('fragment.html', {'request': request})


def redirect(request):
    return HttpResponseRedirect('../')


def response(request):
    return HttpResponse('Anything')


def inheritance20(request):
    return 'inheritance20.html', {'from_appcontent': 42}


urlpatterns = patterns(
    '',
    url(r'^$', module_root, name='ac_module_root'),
    url(r'^args_test/([^/]+)/([^/]+)/$', args_test, name='ac_args_test'),
    url(r'^kwargs_test/(?P<kwarg2>[^/]+)/(?P<kwarg1>[^/]+)/$', args_test),
    url(r'^full_reverse_test/$', full_reverse_test),
    url(r'^alias_reverse_test/$', alias_reverse_test),
    url(r'^fragment/$', fragment),
    url(r'^redirect/$', redirect),
    url(r'^response/$', response),
    url(r'^response_decorated/$', standalone(response)),
    url(r'^inheritance20/$', inheritance20),
)

########NEW FILE########
__FILENAME__ = blog_urls
from django.conf.urls import patterns, url
from django.views import generic

from feincms.module.blog.models import Entry


urlpatterns = patterns(
    '',
    url(
        r'^(?P<pk>\d+)/',
        generic.DetailView.as_view(
            queryset=Entry.objects.all(),
        ),
        name='blog_entry_detail'
    ),
    url(
        r'^$',
        generic.ListView.as_view(
            queryset=Entry.objects.all(),
        ),
        name='blog_entry_list'
    ),
)

########NEW FILE########
__FILENAME__ = models
from __future__ import absolute_import, unicode_literals

from django import forms
from django.db import models
from django.utils.encoding import python_2_unicode_compatible
from django.utils.text import capfirst
from django.utils.translation import ugettext_lazy as _

from feincms.module.blog.models import Entry, EntryAdmin
from feincms.module.page.models import Page
from feincms.content.raw.models import RawContent
from feincms.content.image.models import ImageContent
from feincms.content.medialibrary.models import MediaFileContent
from feincms.content.application.models import ApplicationContent
from feincms.module.page.extensions.navigation import (
    NavigationExtension, PagePretender)
from feincms.content.application.models import reverse

from mptt.models import MPTTModel


Page.register_templates({
    'key': 'base',
    'title': 'Base Template',
    'path': 'base.html',
    'regions': (
        ('main', 'Main region'),
        ('sidebar', 'Sidebar', 'inherited'),
    ),
})
Page.create_content_type(RawContent)
Page.create_content_type(
    MediaFileContent,
    TYPE_CHOICES=(
        ('default', 'Default position'),
    )
)
Page.create_content_type(
    ImageContent,
    POSITION_CHOICES=(
        ('default', 'Default position'),
    )
)


def get_admin_fields(form, *args, **kwargs):
    return {
        'exclusive_subpages': forms.BooleanField(
            label=capfirst(_('exclusive subpages')),
            required=False,
            initial=form.instance.parameters.get('exclusive_subpages', False),
            help_text=_(
                'Exclude everything other than the application\'s content'
                ' when rendering subpages.'),
        ),
    }


Page.create_content_type(
    ApplicationContent,
    APPLICATIONS=(
        ('testapp.blog_urls', 'Blog', {'admin_fields': get_admin_fields}),
        ('whatever', 'Test Urls', {'urls': 'testapp.applicationcontent_urls'}),
    )
)

Entry.register_extensions(
    'feincms.module.extensions.seo',
    'feincms.module.extensions.translations',
    'feincms.module.extensions.seo',
    'feincms.module.extensions.ct_tracker',
)
Entry.register_regions(
    ('main', 'Main region'),
)
Entry.create_content_type(RawContent)
Entry.create_content_type(
    ImageContent, POSITION_CHOICES=(
        ('default', 'Default position'),
    )
)


class BlogEntriesNavigationExtension(NavigationExtension):
    """
    Extended navigation for blog entries.

    It would be added to 'Blog' page properties in admin.
    """
    name = _('all blog entries')

    def children(self, page, **kwargs):
        for entry in Entry.objects.all():
            yield PagePretender(
                title=entry.title,
                url=reverse(
                    'testapp.blog_urls/blog_entry_detail',
                    kwargs={'object_id': entry.id}
                ),
            )

Page.register_extensions(
    'feincms.module.page.extensions.navigation',
    'feincms.module.page.extensions.sites',
    'feincms.module.extensions.translations',
    'feincms.module.extensions.datepublisher',
    'feincms.module.extensions.translations',
    'feincms.module.extensions.ct_tracker',
    'feincms.module.extensions.seo',
    'feincms.module.extensions.changedate',
    'feincms.module.extensions.seo',  # duplicate
    'feincms.module.page.extensions.navigation',
    'feincms.module.page.extensions.symlinks',
    'feincms.module.page.extensions.titles',
)


@python_2_unicode_compatible
class Category(MPTTModel):
    name = models.CharField(max_length=20)
    slug = models.SlugField()
    parent = models.ForeignKey(
        'self', blank=True, null=True, related_name='children')

    class Meta:
        ordering = ['tree_id', 'lft']
        verbose_name = 'category'
        verbose_name_plural = 'categories'

    def __str__(self):
        return self.name


# add m2m field to entry so it shows up in entry admin
Entry.add_to_class(
    str('categories'),
    models.ManyToManyField(Category, blank=True, null=True))
EntryAdmin.list_filter += ('categories',)

########NEW FILE########
__FILENAME__ = navigation_extensions
from __future__ import absolute_import, unicode_literals

from feincms.module.page.extensions.navigation import (
    NavigationExtension, PagePretender)


class PassthroughExtension(NavigationExtension):
    # See PagesTestCase.test_23_navigation_extension
    name = 'passthrough extension'

    def children(self, page, **kwargs):
        for p in page.children.in_navigation():
            yield p


class PretenderExtension(NavigationExtension):
    name = 'pretender extension'

    def children(self, page, **kwargs):
        return [PagePretender(title='blabla', url='/asdsa/')]

########NEW FILE########
__FILENAME__ = settings
from __future__ import absolute_import, unicode_literals

import os

SITE_ID = 1

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': ':memory:',
    }
}

INSTALLED_APPS = [
    'django.contrib.auth',
    'django.contrib.admin',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sitemaps',
    'django.contrib.sites',
    'django.contrib.staticfiles',
    'feincms',
    'feincms.module.blog',
    'feincms.module.medialibrary',
    'feincms.module.page',
    'mptt',
    'testapp',
]

MEDIA_ROOT = '/media/'
STATIC_URL = '/static/'
BASEDIR = os.path.dirname(__file__)
MEDIA_ROOT = os.path.join(BASEDIR, 'media/')
STATIC_ROOT = os.path.join(BASEDIR, 'static/')
SECRET_KEY = 'supersikret'

ROOT_URLCONF = 'testapp.urls'
LANGUAGES = (('en', 'English'), ('de', 'German'))
TEMPLATE_CONTEXT_PROCESSORS = (
    'django.contrib.auth.context_processors.auth',
    'django.core.context_processors.debug',
    'django.core.context_processors.i18n',
    'django.core.context_processors.media',
    'django.core.context_processors.static',
    # request context processor is needed
    'django.core.context_processors.request',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.locale.LocaleMiddleware'
)

########NEW FILE########
__FILENAME__ = test_cms
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

import os

from django.core.exceptions import ImproperlyConfigured
from django.db import models
from django.test import TestCase

from feincms.content.contactform.models import ContactFormContent
from feincms.content.file.models import FileContent
from feincms.content.raw.models import RawContent
from feincms.content.richtext.models import RichTextContent
from feincms.content.video.models import VideoContent

from .test_stuff import ExampleCMSBase, Empty, ExampleCMSBase2


# ------------------------------------------------------------------------
class SubRawContent(RawContent):
    title = models.CharField('title', max_length=100, blank=True)

    class Meta:
        abstract = True


class CMSBaseTest(TestCase):
    def test_01_simple_content_type_creation(self):
        self.assertEqual(ExampleCMSBase.content_type_for(FileContent), None)

        ExampleCMSBase.create_content_type(ContactFormContent)
        ExampleCMSBase.create_content_type(FileContent, regions=('region2',))

        ExampleCMSBase.create_content_type(RawContent)
        ExampleCMSBase.create_content_type(RichTextContent)

        # test creating a cotent with arguments, but no initialize_type
        # classmethod
        ExampleCMSBase.create_content_type(
            VideoContent,
            arbitrary_arg='arbitrary_value')

        # content_type_for should return None if it does not have a subclass
        # registered
        self.assertEqual(ExampleCMSBase.content_type_for(Empty), None)

        self.assertTrue(
            'filecontent' not in dict(
                ExampleCMSBase.template.regions[0].content_types).keys())
        self.assertTrue(
            'filecontent' in dict(
                ExampleCMSBase.template.regions[1].content_types).keys())

    def test_02_rsscontent_creation(self):
        # this test resides in its own method because the required feedparser
        # module is not available everywhere

        from feincms.content.rss.models import RSSContent, feedparser

        # Monkey-patch feedparser.parse to work with a local RSS dump so that
        # the tests run faster.
        _orig_parse = feedparser.parse

        def _new_parse(link):
            return _orig_parse(open(
                os.path.join(os.path.dirname(__file__), 'yahoo.rss'), 'rb'))
        feedparser.parse = _new_parse

        type = ExampleCMSBase.create_content_type(RSSContent)
        obj = type()

        self.assertTrue('yahoo' not in obj.render())

        obj.link = 'http://rss.news.yahoo.com/rss/topstories'
        obj.cache_content(save=False)

        self.assertTrue('yahoo' in obj.render())

    # Creating a content type twice isn't forbidden anymore
    # def test_03_double_creation(self):
    #     # creating a content type twice is forbidden
    #     self.assertRaises(ImproperlyConfigured,
    #         lambda: ExampleCMSBase.create_content_type(RawContent))

    def test_04_mediafilecontent_creation(self):
        # the medialibrary needs to be enabled, otherwise this test fails

        from feincms.content.medialibrary.models import MediaFileContent

        # no TYPE_CHOICES, should raise
        self.assertRaises(
            ImproperlyConfigured,
            lambda: ExampleCMSBase.create_content_type(MediaFileContent))

    def test_05_non_abstract_content_type(self):
        # Should not be able to create a content type from a non-abstract base
        # type
        class TestContentType(models.Model):
            pass

        self.assertRaises(
            ImproperlyConfigured,
            lambda: ExampleCMSBase.create_content_type(TestContentType))

    def test_06_videocontent(self):
        type = ExampleCMSBase.content_type_for(VideoContent)
        obj = type()
        obj.video = 'http://www.youtube.com/watch?v=zmj1rpzDRZ0'

        self.assertTrue('x-shockwave-flash' in obj.render())

        self.assertEqual(getattr(type, 'arbitrary_arg'), 'arbitrary_value')

        obj.video = 'http://www.example.com/'

        self.assertTrue(obj.video in obj.render())

    def test_07_default_render_method(self):
        class SomethingElse(models.Model):
            class Meta:
                abstract = True

            def render_region(self):
                return 'hello'

        type = ExampleCMSBase.create_content_type(SomethingElse)
        obj = type()
        self.assertRaises(NotImplementedError, lambda: obj.render())

        obj.region = 'region'
        self.assertEqual(obj.render(), 'hello')

    def test_08_creating_two_content_types_in_same_application(self):
        ExampleCMSBase.create_content_type(RawContent)
        ct = ExampleCMSBase.content_type_for(RawContent)
        self.assertEqual(ct._meta.db_table, 'tests_examplecmsbase_rawcontent')

        ExampleCMSBase2.create_content_type(
            RawContent,
            class_name='RawContent2')
        ct2 = ExampleCMSBase2.content_type_for(RawContent)
        self.assertEqual(
            ct2._meta.db_table,
            'tests_examplecmsbase2_rawcontent2')

    def test_09_related_objects_cache(self):
        """
        We need to define a model with relationship to our Base *after* all
        content types have been registered; previously _fill_*_cache methods
        were called during each content type registration, so any new related
        objects added after the last content type time missed the boat. Now we
        delete the cache so hopefully _fill_*_cache* won't be called until all
        related models have been defined.

        TODO that's a dumb test, we should try being less dynamic instead of
        supporting all types of ad-hoc definitions of models etc.

        It also fails on Django 1.7 since the introduction of django.apps
        """
        class Attachment(models.Model):
            base = models.ForeignKey(
                ExampleCMSBase,
                related_name='test_related_name')

        # See issue #323 on Github.
        ExampleCMSBase._meta._fill_related_objects_cache()

        related_models = map(
            lambda x: x.model, ExampleCMSBase._meta.get_all_related_objects())

        self.assertTrue(Attachment in related_models)
        self.assertTrue(hasattr(ExampleCMSBase, 'test_related_name'))
        # self.assertFalse(hasattr(Attachment, 'anycontents'))

        class AnyContent(models.Model):
            attachment = models.ForeignKey(
                Attachment,
                related_name='anycontents')

            class Meta:
                abstract = True

        ExampleCMSBase.create_content_type(AnyContent)

        self.assertTrue(hasattr(ExampleCMSBase, 'test_related_name'))
        self.assertTrue(hasattr(Attachment, 'anycontents'))

    def test_10_content_type_subclasses(self):
        """
        See:
        https://github.com/feincms/feincms/issues/339
        """
        ExampleCMSBase.create_content_type(SubRawContent)
        ExampleCMSBase.create_content_type(RawContent)

        ct = ExampleCMSBase.content_type_for(RawContent)
        ct2 = ExampleCMSBase.content_type_for(SubRawContent)
        self.assertNotEqual(ct, ct2)

########NEW FILE########
__FILENAME__ = test_extensions
# coding: utf-8

from __future__ import absolute_import, unicode_literals

from django.contrib.sites.models import Site
from django.template.defaultfilters import slugify
from django.test import TestCase

from feincms.module.page.models import Page


class TranslationTestCase(TestCase):
    def setUp(self):
        Page.register_templates({
            'key': 'base',
            'title': 'Standard template',
            'path': 'feincms_base.html',
            'regions': (
                ('main', 'Main content area'),
                ('sidebar', 'Sidebar', 'inherited'),
            ),
        })
        self.site_1 = Site.objects.all()[0]

        # create a bunch of pages
        en = self.create_default_page_set(language='en')
        de = self.create_default_page_set(language='de', title='Testseite')
        de.translation_of = en
        de.save()
        de.parent.translation_of = en.parent
        de.parent.save()
        self.page_de = de.parent
        self.page_en = en.parent

    def create_page(self, title='Test page', parent=None, **kwargs):
        defaults = {
            'template_key': 'base',
            'site': self.site_1,
            'in_navigation': False,
            'active': False,
        }
        defaults.update(kwargs)
        return Page.objects.create(
            title=title,
            slug=kwargs.get('slug', slugify(title)),
            parent=parent,
            **defaults)

    def create_default_page_set(self, **kwargs):
        return self.create_page(
            'Test child page',
            parent=self.create_page(**kwargs),
        )

    def testPage(self):
        page = Page()
        self.assertTrue(hasattr(page, 'language'))
        self.assertTrue(hasattr(page, 'translation_of'))
        self.assertEqual(self.page_de.translation_of, self.page_en)
        self.assertEqual(self.page_de.original_translation, self.page_en)

        # TODO:  add request tests
        # with translation.override('de'):

########NEW FILE########
__FILENAME__ = test_page
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

from datetime import datetime, timedelta
import os
import re

from django import forms, template
from django.conf import settings
from django.contrib.auth.models import User, AnonymousUser
from django.contrib.contenttypes.models import ContentType
from django.core import mail
from django.db import models
from django.contrib.sites.models import Site
from django.http import Http404, HttpResponseBadRequest
from django.template import TemplateDoesNotExist
from django.template.defaultfilters import slugify
from django.test import TestCase
from django.utils import timezone
from django.utils.encoding import force_text

from mptt.exceptions import InvalidMove

from feincms import settings as feincms_settings
from feincms.content.application.models import (
    app_reverse, cycle_app_reverse_cache)
from feincms.content.image.models import ImageContent
from feincms.content.raw.models import RawContent
from feincms.content.richtext.models import RichTextContent

from feincms.context_processors import add_page_if_missing
from feincms.models import ContentProxy
from feincms.module.medialibrary.models import Category, MediaFile
from feincms.module.page import processors
from feincms.module.page.models import Page
from feincms.templatetags import feincms_tags
from feincms.translations import short_language_code

from .test_stuff import Empty


# ------------------------------------------------------------------------
class PagesTestCase(TestCase):
    def setUp(self):
        u = User(
            username='test',
            is_active=True,
            is_staff=True,
            is_superuser=True)
        u.set_password('test')
        u.save()

        self.site_1 = Site.objects.all()[0]

        Page.register_templates({
            'key': 'base',
            'title': 'Standard template',
            'path': 'feincms_base.html',
            'regions': (
                ('main', 'Main content area'),
                ('sidebar', 'Sidebar', 'inherited'),
            ),
        }, {
            'key': 'theother',
            'title': 'This actually exists',
            'path': 'base.html',
            'regions': (
                ('main', 'Main content area'),
                ('sidebar', 'Sidebar', 'inherited'),
            ),
        })

    def login(self):
        self.assertTrue(self.client.login(username='test', password='test'))

    def create_page_through_admin(self, title='Test page', parent='',
                                  **kwargs):
        dic = {
            'title': title,
            'slug': kwargs.get('slug', slugify(title)),
            'parent': parent,
            'template_key': 'base',
            'publication_date_0': '2009-01-01',
            'publication_date_1': '00:00:00',
            'initial-publication_date_0': '2009-01-01',
            'initial-publication_date_1': '00:00:00',
            'language': 'en',
            'site': self.site_1.id,

            'rawcontent_set-TOTAL_FORMS': 0,
            'rawcontent_set-INITIAL_FORMS': 0,
            'rawcontent_set-MAX_NUM_FORMS': 10,

            'mediafilecontent_set-TOTAL_FORMS': 0,
            'mediafilecontent_set-INITIAL_FORMS': 0,
            'mediafilecontent_set-MAX_NUM_FORMS': 10,

            'imagecontent_set-TOTAL_FORMS': 0,
            'imagecontent_set-INITIAL_FORMS': 0,
            'imagecontent_set-MAX_NUM_FORMS': 10,

            'contactformcontent_set-TOTAL_FORMS': 0,
            'contactformcontent_set-INITIAL_FORMS': 0,
            'contactformcontent_set-MAX_NUM_FORMS': 10,

            'filecontent_set-TOTAL_FORMS': 0,
            'filecontent_set-INITIAL_FORMS': 0,
            'filecontent_set-MAX_NUM_FORMS': 10,

            'applicationcontent_set-TOTAL_FORMS': 0,
            'applicationcontent_set-INITIAL_FORMS': 0,
            'applicationcontent_set-MAX_NUM_FORMS': 10,
        }
        dic.update(kwargs)
        return self.client.post('/admin/page/page/add/', dic)

    def create_default_page_set_through_admin(self):
        self.login()
        self.create_page_through_admin()
        return self.create_page_through_admin('Test child page', 1)

    def create_page(self, title='Test page', parent=None, **kwargs):
        defaults = {
            'template_key': 'base',
            'site': self.site_1,
            'in_navigation': False,
            'active': False,
        }
        defaults.update(kwargs)
        return Page.objects.create(
            title=title,
            slug=kwargs.get('slug', slugify(title)),
            parent=parent,
            **defaults)

    def create_default_page_set(self):
        self.create_page(
            'Test child page',
            parent=self.create_page(),
        )

    def is_published(self, url, should_be=True):
        try:
            self.client.get(url)
        except TemplateDoesNotExist as e:
            if should_be:
                if e.args != ('feincms_base.html',):
                    raise
            else:
                if e.args != ('404.html',):
                    raise

    def test_01_tree_editor(self):
        self.login()
        self.assertEqual(
            self.client.get('/admin/page/page/').status_code, 200)

        self.assertRedirects(
            self.client.get('/admin/page/page/?anything=anything'),
            '/admin/page/page/?e=1')

    def test_02_add_page(self):
        self.login()
        self.assertRedirects(
            self.create_page_through_admin(
                title='Test page ' * 10,
                slug='test-page'),
            '/admin/page/page/')
        self.assertEqual(Page.objects.count(), 1)
        self.assertContains(self.client.get('/admin/page/page/'), '…')

    def test_03_item_editor(self):
        self.login()
        self.assertRedirects(
            self.create_page_through_admin(_continue=1),
            '/admin/page/page/1/')
        self.assertEqual(
            self.client.get('/admin/page/page/1/').status_code, 200)
        self.is_published('/admin/page/page/42/', should_be=False)

    def test_03_add_another(self):
        self.login()
        self.assertRedirects(
            self.create_page_through_admin(_addanother=1),
            '/admin/page/page/add/')

    def test_04_add_child(self):
        response = self.create_default_page_set_through_admin()
        self.assertRedirects(response, '/admin/page/page/')
        self.assertEqual(Page.objects.count(), 2)

        page = Page.objects.get(pk=2)
        self.assertEqual(
            page.get_absolute_url(), '/test-page/test-child-page/')

        page.active = True
        page.in_navigation = True
        page.save()

        # page2 inherited the inactive flag from the toplevel page
        self.assertContains(self.client.get('/admin/page/page/'), 'inherited')

        page1 = Page.objects.get(pk=1)
        page1.active = True
        page1.save()

        content = self.client.get('/admin/page/page/').content.decode('utf-8')
        self.assertEqual(len(content.split('checked="checked"')), 4)

    def test_05_override_url(self):
        self.create_default_page_set()

        page = Page.objects.get(pk=1)
        page.override_url = '/something/'
        page.save()

        page2 = Page.objects.get(pk=2)
        self.assertEqual(
            page2.get_absolute_url(), '/something/test-child-page/')

        page.override_url = '/'
        page.save()
        page2 = Page.objects.get(pk=2)
        self.assertEqual(page2.get_absolute_url(), '/test-child-page/')

        self.is_published('/', False)
        page.active = True
        page.template_key = 'theother'
        page.save()
        self.is_published('/', True)

    def test_06_tree_editor_save(self):
        self.create_default_page_set()

        page1 = Page.objects.get(pk=1)
        page2 = Page.objects.get(pk=2)

        page3 = Page.objects.create(title='page3', slug='page3', parent=page2)
        page4 = Page.objects.create(title='page4', slug='page4', parent=page1)
        page5 = Page.objects.create(title='page5', slug='page5', parent=None)

        self.assertEqual(
            page3.get_absolute_url(), '/test-page/test-child-page/page3/')
        self.assertEqual(page4.get_absolute_url(), '/test-page/page4/')
        self.assertEqual(page5.get_absolute_url(), '/page5/')

        self.login()
        self.client.post('/admin/page/page/', {
            '__cmd': 'move_node',
            'position': 'last-child',
            'cut_item': '1',
            'pasted_on': '5',
        }, HTTP_X_REQUESTED_WITH='XMLHttpRequest')

        self.assertEqual(Page.objects.get(pk=1).get_absolute_url(),
                         '/page5/test-page/')
        self.assertEqual(Page.objects.get(pk=5).get_absolute_url(),
                         '/page5/')
        self.assertEqual(Page.objects.get(pk=3).get_absolute_url(),
                         '/page5/test-page/test-child-page/page3/')

    def test_07_tree_editor_toggle_boolean(self):
        self.create_default_page_set()

        self.assertEqual(Page.objects.get(pk=1).in_navigation, False)

        self.login()
        self.assertContains(
            self.client.post('/admin/page/page/', {
                '__cmd': 'toggle_boolean',
                'item_id': 1,
                'attr': 'in_navigation',
            }, HTTP_X_REQUESTED_WITH='XMLHttpRequest'),
            r'checked=\"checked\"')
        self.assertEqual(Page.objects.get(pk=1).in_navigation, True)
        self.assertNotContains(
            self.client.post('/admin/page/page/', {
                '__cmd': 'toggle_boolean',
                'item_id': 1,
                'attr': 'in_navigation',
            }, HTTP_X_REQUESTED_WITH='XMLHttpRequest'),
            'checked="checked"')
        self.assertEqual(Page.objects.get(pk=1).in_navigation, False)

        self.assertTrue(isinstance(
            self.client.post('/admin/page/page/', {
                '__cmd': 'toggle_boolean',
                'item_id': 1,
                'attr': 'notexists',
            }, HTTP_X_REQUESTED_WITH='XMLHttpRequest'),
            HttpResponseBadRequest))

    def test_07_tree_editor_invalid_ajax(self):
        self.login()
        self.assertContains(
            self.client.post('/admin/page/page/', {
                '__cmd': 'notexists',
            }, HTTP_X_REQUESTED_WITH='XMLHttpRequest'),
            'Oops. AJAX request not understood.',
            status_code=400)

    def test_08_publishing(self):
        self.create_default_page_set()

        page = Page.objects.get(pk=1)
        page2 = Page.objects.get(pk=2)
        self.is_published(page.get_absolute_url(), should_be=False)
        self.is_published(page2.get_absolute_url(), should_be=False)

        page.active = True
        page.save()
        page2.active = True
        page2.save()
        self.is_published(page.get_absolute_url(), should_be=True)
        self.is_published(page2.get_absolute_url(), should_be=True)

        old_publication = page.publication_date
        page.publication_date = timezone.now() + timedelta(days=1)
        page.save()
        self.is_published(page.get_absolute_url(), should_be=False)

        # Should be not accessible because of its parent's inactivity
        self.is_published(page2.get_absolute_url(), should_be=False)

        page.publication_date = old_publication
        page.publication_end_date = timezone.now() - timedelta(days=1)
        page.save()
        self.is_published(page.get_absolute_url(), should_be=False)

        # Should be not accessible because of its parent's inactivity
        self.is_published(page2.get_absolute_url(), should_be=False)

        page.publication_end_date = timezone.now() + timedelta(days=1)
        page.save()
        self.is_published(page.get_absolute_url(), should_be=True)
        self.is_published(page2.get_absolute_url(), should_be=True)

    def create_page_through_admincontent(self, page, **kwargs):
        data = {
            'title': page.title,
            'slug': page.slug,
            # 'parent': page.parent_id,  # this field is excluded from the form
            'template_key': page.template_key,
            'publication_date_0': '2009-01-01',
            'publication_date_1': '00:00:00',
            'initial-publication_date_0': '2009-01-01',
            'initial-publication_date_1': '00:00:00',
            'language': 'en',
            'site': self.site_1.id,

            'rawcontent_set-TOTAL_FORMS': 1,
            'rawcontent_set-INITIAL_FORMS': 0,
            'rawcontent_set-MAX_NUM_FORMS': 10,

            'rawcontent_set-0-parent': 1,
            'rawcontent_set-0-region': 'main',
            'rawcontent_set-0-ordering': 0,
            'rawcontent_set-0-text': 'This is some example content',

            'mediafilecontent_set-TOTAL_FORMS': 1,
            'mediafilecontent_set-INITIAL_FORMS': 0,
            'mediafilecontent_set-MAX_NUM_FORMS': 10,

            'mediafilecontent_set-0-parent': 1,
            'mediafilecontent_set-0-type': 'default',

            'imagecontent_set-TOTAL_FORMS': 1,
            'imagecontent_set-INITIAL_FORMS': 0,
            'imagecontent_set-MAX_NUM_FORMS': 10,

            'imagecontent_set-0-parent': 1,
            'imagecontent_set-0-position': 'default',

            'contactformcontent_set-TOTAL_FORMS': 1,
            'contactformcontent_set-INITIAL_FORMS': 0,
            'contactformcontent_set-MAX_NUM_FORMS': 10,

            'filecontent_set-TOTAL_FORMS': 1,
            'filecontent_set-INITIAL_FORMS': 0,
            'filecontent_set-MAX_NUM_FORMS': 10,

            'applicationcontent_set-TOTAL_FORMS': 1,
            'applicationcontent_set-INITIAL_FORMS': 0,
            'applicationcontent_set-MAX_NUM_FORMS': 10,
        }
        data.update(kwargs)

        return self.client.post('/admin/page/page/%s/' % page.pk, data)

    def test_09_pagecontent(self):
        self.create_default_page_set()

        page = Page.objects.get(pk=1)
        self.login()
        response = self.create_page_through_admincontent(page)
        self.assertRedirects(response, '/admin/page/page/')
        self.assertEqual(page.content.main[0].__class__.__name__, 'RawContent')

        page2 = Page.objects.get(pk=2)
        page2.symlinked_page = page

        # Test that all_of_type works correctly even before accessing
        # other content methods
        self.assertEqual(len(page2.content.all_of_type(RawContent)), 1)

        self.assertEqual(
            page2.content.main[0].__class__.__name__, 'RawContent')
        self.assertEqual(
            force_text(page2.content.main[0]),
            'RawContent<pk=1, parent=Page<pk=1, Test page>, region=main,'
            ' ordering=0>')

        self.assertEqual(len(page2.content.main), 1)
        self.assertEqual(len(page2.content.sidebar), 0)
        self.assertEqual(len(page2.content.nonexistant_region), 0)

        self.assertTrue(isinstance(page2.content.media, forms.Media))

        self.assertEqual(len(page2.content.all_of_type(RawContent)), 1)
        self.assertEqual(len(page2.content.all_of_type((ImageContent,))), 0)
        self.assertEqual(len(page2.content.all_of_type([ImageContent])), 0)

    def test_10_mediafile_and_imagecontent(self):
        self.create_default_page_set()
        self.login()

        page = Page.objects.get(pk=1)
        self.create_page_through_admincontent(page)

        category = Category.objects.create(title='Category', parent=None)
        category2 = Category.objects.create(title='Something', parent=category)

        self.assertEqual(force_text(category2), 'Category - Something')
        self.assertEqual(force_text(category), 'Category')

        mediafile = MediaFile.objects.create(file='somefile.jpg')
        mediafile.categories = [category]
        page.mediafilecontent_set.create(
            mediafile=mediafile,
            region='main',
            type='default',
            ordering=1)

        self.assertEqual(force_text(mediafile), 'somefile.jpg')

        mediafile.translations.create(
            caption='something', language_code='%s-ha' % short_language_code())
        mediafile.purge_translation_cache()

        self.assertTrue('something' in force_text(mediafile))

        mf = page.content.main[1].mediafile

        self.assertEqual(mf.translation.caption, 'something')
        self.assertEqual(
            mf.translation.short_language_code(), short_language_code())
        self.assertNotEqual(mf.get_absolute_url(), '')
        self.assertEqual(force_text(mf), 'something')
        self.assertTrue(mf.type == 'image')

        self.assertEqual(MediaFile.objects.only_language('de').count(), 0)
        self.assertEqual(MediaFile.objects.only_language('en').count(), 0)
        self.assertEqual(
            MediaFile.objects.only_language(
                '%s-ha' % short_language_code()).count(),
            1)

        self.assertTrue(
            '%s-ha' % short_language_code() in mf.available_translations)

        # this should not raise
        self.client.get('/admin/page/page/1/')

        # self.assertTrue('alt="something"' in page.content.main[1].render())
        # Since it isn't an image

        page.imagecontent_set.create(
            image='somefile.jpg', region='main', position='default',
            ordering=2)
        page.filecontent_set.create(
            file='somefile.jpg', title='thetitle', region='main', ordering=3)

        # Reload page, reset _ct_inventory
        page = Page.objects.get(pk=page.pk)
        page._ct_inventory = None

        self.assertTrue('somefile.jpg' in page.content.main[2].render())
        self.assertTrue(re.search(
            '<a .*href="somefile\.jpg">.*thetitle.*</a>',
            page.content.main[3].render(),
            re.MULTILINE + re.DOTALL) is not None)

        page.mediafilecontent_set.update(mediafile=3)
        # this should not raise
        self.client.get('/admin/page/page/1/')

        field = MediaFile._meta.get_field('file')
        old = (field.upload_to, field.storage, field.generate_filename)
        from django.core.files.storage import FileSystemStorage
        MediaFile.reconfigure(
            upload_to=lambda: 'anywhere',
            storage=FileSystemStorage(location='/wha/', base_url='/whe/'))
        mediafile = MediaFile.objects.get(pk=1)
        self.assertEqual(mediafile.file.url, '/whe/somefile.jpg')

        # restore settings
        (field.upload_to, field.storage, field.generate_filename) = old

        mediafile = MediaFile.objects.get(pk=1)
        self.assertEqual(mediafile.file.url, 'somefile.jpg')

    def test_11_translations(self):
        self.create_default_page_set()

        page1 = Page.objects.get(pk=1)
        self.assertEqual(len(page1.available_translations()), 0)

        page1 = Page.objects.get(pk=1)
        page2 = Page.objects.get(pk=2)

        page2.language = 'de'
        page2.save()

        self.assertEqual(len(page2.available_translations()), 0)

        page2.translation_of = page1
        page2.save()

        self.assertEqual(len(page2.available_translations()), 1)
        self.assertEqual(len(page1.available_translations()), 1)

        self.assertEqual(page1, page1.original_translation)
        self.assertEqual(page1, page2.original_translation)

    def test_12_titles(self):
        self.create_default_page_set()

        page = Page.objects.get(pk=1)

        self.assertEqual(page.page_title, page.title)
        self.assertEqual(page.content_title, page.title)

        page._content_title = 'Something\nawful'
        page._page_title = 'Hello world'
        page.save()

        self.assertEqual(page.page_title, 'Hello world')
        self.assertEqual(page.content_title, 'Something')
        self.assertEqual(page.content_subtitle, 'awful')

        page._content_title = 'Only one line'
        self.assertEqual(page.content_title, 'Only one line')
        self.assertEqual(page.content_subtitle, '')

        page._content_title = ''
        self.assertEqual(page.content_title, page.title)
        self.assertEqual(page.content_subtitle, '')

    def test_13_inheritance_and_ct_tracker(self):
        self.create_default_page_set()

        page = Page.objects.get(pk=1)
        page.rawcontent_set.create(
            region='sidebar',
            ordering=0,
            text='Something')
        page.rawcontent_set.create(
            region='main',
            ordering=0,
            text='Anything')

        page2 = Page.objects.get(pk=2)
        page2.rawcontent_set.create(
            region='main',
            ordering=0,
            text='Something else')
        page2.rawcontent_set.create(
            region='main',
            ordering=1,
            text='Whatever')

        # Set default, non-caching content proxy
        page2.content_proxy_class = ContentProxy

        if hasattr(self, 'assertNumQueries'):
            # 4 queries: Two to get the content types of page and page2, one to
            # fetch all ancestor PKs of page2 and one to materialize the
            # RawContent instances belonging to page's sidebar and page2's
            # main.
            self.assertNumQueries(
                4, lambda: [page2.content.main, page2.content.sidebar])
            self.assertNumQueries(
                0, lambda: page2.content.sidebar[0].render())

        self.assertEqual(
            ''.join(c.render() for c in page2.content.main),
            'Something elseWhatever')
        self.assertEqual(page2.content.sidebar[0].render(), 'Something')

        page2 = Page.objects.get(pk=2)
        self.assertEqual(page2._ct_inventory, {})

        # Prime Django content type cache
        for ct in Page._feincms_content_types:
            ContentType.objects.get_for_model(ct)

        if hasattr(self, 'assertNumQueries'):
            # 5 queries: Two to get the content types of page and page2, one to
            # fetch all ancestor PKs of page2 and one to materialize the
            # RawContent instances belonging to page's sidebar and page2's main
            # and a few queries to update the pages _ct_inventory attributes:
            # - one update to update page2
            # - one update to clobber the _ct_inventory attribute of all
            #   descendants of page2
            self.assertNumQueries(
                5, lambda: [page2.content.main, page2.content.sidebar])
            self.assertNumQueries(
                0, lambda: page2.content.sidebar[0].render())

        self.assertEqual(page2.content.sidebar[0].render(), 'Something')

        # Reload, again, to test ct_tracker extension
        page2 = Page.objects.get(pk=2)

        if hasattr(self, 'assertNumQueries'):
            self.assertNumQueries(
                1, lambda: [page2.content.main, page2.content.sidebar])

        self.assertNotEqual(page2._ct_inventory, {})

    def test_14_richtext(self):
        # only create the content type to test the item editor
        # customization hooks
        tmp = Page._feincms_content_types[:]
        type = Page.create_content_type(
            RichTextContent, regions=('notexists',))
        Page._feincms_content_types = tmp

        from django.utils.safestring import SafeData
        obj = type()
        obj.text = 'Something'
        self.assertTrue(isinstance(obj.render(), SafeData))

    def test_15_frontend_editing(self):
        self.create_default_page_set()
        page = Page.objects.get(pk=1)
        self.login()
        self.create_page_through_admincontent(page)

        # this should return a 404
        self.is_published('/admin/page/page/10|rawcontent|1/', should_be=False)
        self.is_published('/admin/page/page/1|rawcontent|10/', should_be=False)

        self.assertEqual(
            self.client.get('/admin/page/page/1|rawcontent|1/').status_code,
            200)
        self.assertEqual(self.client.post('/admin/page/page/1|rawcontent|1/', {
            'rawcontent-text': 'blablabla',
        }).status_code, 200)

        self.assertEqual(page.content.main[0].render(), 'blablabla')
        self.assertEqual(feincms_tags.feincms_frontend_editing(page, {}), '')

        request = Empty()
        request.COOKIES = {'frontend_editing': "True"}

        self.assertIn(
            'class="fe_box"', page.content.main[0].fe_render(request=request))

    def test_15_b_client_frontend_editing(self):
        self.create_default_page_set()
        page = Page.objects.get(pk=1)
        self.login()
        self.create_page_through_admincontent(page)

        page.active = True
        page.template_key = 'theother'
        page.save()

        # FEINCMS_FRONTEND_EDITING is False by default
        response = self.client.get(
            page.get_absolute_url() + '?frontend_editing=1',
            follow=True)
        self.assertNotIn('class="fe_box"', response.content.decode('utf-8'))
        self.assertNotIn('frontend_editing', self.client.cookies)

        # manually register request processor
        # override_settings(FEINCMS_FRONTEND_EDITING=True) wont work here
        Page.register_request_processor(
            processors.frontendediting_request_processor,
            key='frontend_editing')
        response = self.client.get(
            page.get_absolute_url() + '?frontend_editing=1',
            follow=True)
        self.assertRedirects(response, page.get_absolute_url())
        self.assertIn('class="fe_box"', response.content.decode('utf-8'))
        self.assertIn('frontend_editing', self.client.cookies)

        # turn off edit on site
        response = self.client.get(
            page.get_absolute_url() + '?frontend_editing=0',
            follow=True)
        self.assertRedirects(response, page.get_absolute_url())
        self.assertNotIn('class="fe_box"', response.content.decode('utf-8'))

        # anonymous user cannot front edit
        self.client.logout()
        response = self.client.get(
            page.get_absolute_url() + '?frontend_editing=1',
            follow=True)
        self.assertRedirects(response, page.get_absolute_url())
        self.assertNotIn('class="fe_box"', response.content.decode('utf-8'))

        # cleanup request processor
        del Page.request_processors['frontend_editing']

    def test_17_page_template_tags(self):
        self.create_default_page_set()

        page1 = Page.objects.get(pk=1)
        page2 = Page.objects.get(pk=2)

        page2.language = 'de'
        page2.translation_of = page1
        page2.active = True
        page2.in_navigation = True
        page2.save()

        page3 = Page.objects.create(
            parent=page2,
            title='page3',
            slug='page3',
            language='en',
            active=True,
            in_navigation=True,
            publication_date=datetime(2001, 1, 1),
        )

        # reload these two, their mptt attributes have changed
        page1 = Page.objects.get(pk=1)
        page2 = Page.objects.get(pk=2)

        context = template.Context({'feincms_page': page2, 'page3': page3})

        t = template.Template(
            '{% load feincms_page_tags %}{% feincms_parentlink of feincms_page'
            ' level=1 %}')
        self.assertEqual(t.render(context), '/test-page/')

        t = template.Template(
            '{% load feincms_page_tags %}{% feincms_languagelinks for'
            ' feincms_page as links %}{% for key, name, link in links %}'
            '{{ key }}:{{ link }}{% if not forloop.last %},{% endif %}'
            '{% endfor %}')
        self.assertEqual(
            t.render(context),
            'en:/test-page/,de:/test-page/test-child-page/')

        t = template.Template(
            '{% load feincms_page_tags %}{% feincms_languagelinks for page3'
            ' as links %}{% for key, name, link in links %}{{ key }}:'
            '{{ link }}{% if not forloop.last %},{% endif %}{% endfor %}')
        self.assertEqual(
            t.render(context),
            'en:/test-page/test-child-page/page3/,de:None')

        t = template.Template(
            '{% load feincms_page_tags %}{% feincms_languagelinks for page3'
            ' as links existing %}{% for key, name, link in links %}{{ key }}:'
            '{{ link }}{% if not forloop.last %},{% endif %}{% endfor %}')
        self.assertEqual(
            t.render(context),
            'en:/test-page/test-child-page/page3/')

        t = template.Template(
            '{% load feincms_page_tags %}{% feincms_languagelinks for'
            ' feincms_page as links excludecurrent=1 %}'
            '{% for key, name, link in links %}{{ key }}:{{ link }}'
            '{% if not forloop.last %},{% endif %}{% endfor %}')
        self.assertEqual(t.render(context), 'en:/test-page/')

        t = template.Template(
            '{% load feincms_page_tags %}'
            '{% feincms_nav feincms_page level=1 as nav %}'
            '{% for p in nav %}{{ p.get_absolute_url }}'
            '{% if not forloop.last %},{% endif %}{% endfor %}')
        self.assertEqual(t.render(context), '')

        # XXX should the other template tags not respect the in_navigation
        # setting too?
        page1.active = True
        page1.in_navigation = True
        page1.save()

        self.assertEqual(t.render(context), '/test-page/')

        t = template.Template(
            '{% load feincms_page_tags %}'
            '{% feincms_nav feincms_page level=2 as nav %}'
            '{% for p in nav %}{{ p.get_absolute_url }}'
            '{% if not forloop.last %},{% endif %}{% endfor %}')
        self.assertEqual(t.render(context), '/test-page/test-child-page/')

        t = template.Template(
            '{% load feincms_page_tags %}'
            '{% feincms_nav request level=2 as nav %}'
            '{% for p in nav %}{{ p.get_absolute_url }}'
            '{% if not forloop.last %},{% endif %}{% endfor %}')

        from django.http import HttpRequest
        request = HttpRequest()
        request.path = '/test-page/'
        self.assertEqual(
            t.render(template.Context({'request': request})),
            '/test-page/test-child-page/')

        t = template.Template(
            '{% load feincms_page_tags %}'
            '{% feincms_nav feincms_page level=99 as nav %}'
            '{% for p in nav %}{{ p.get_absolute_url }}'
            '{% if not forloop.last %},{% endif %}{% endfor %}')
        self.assertEqual(t.render(context), '')

        t = template.Template(
            '{% load feincms_page_tags %}'
            '{% feincms_breadcrumbs feincms_page %}')
        rendered = t.render(context)
        self.assertTrue("Test child page" in rendered)
        self.assertTrue(
            'href="/test-page/">Test page</a>' in rendered,
            msg="The parent page should be a breadcrumb link")
        self.assertTrue(
            'href="/test-page/test-child-page/"' not in rendered,
            msg="The current page should not be a link in the breadcrumbs")

        t = template.Template(
            '{% load feincms_page_tags %}'
            '{% feincms_nav feincms_page level=2 depth=2 as nav %}'
            '{% for p in nav %}{{ p.get_absolute_url }}'
            '{% if not forloop.last %},{% endif %}{% endfor %}')
        self.assertEqual(
            t.render(context),
            '/test-page/test-child-page/,/test-page/test-child-page/page3/')

        t = template.Template(
            '{% load feincms_page_tags %}'
            '{% feincms_nav feincms_page level=1 depth=2 as nav %}'
            '{% for p in nav %}{{ p.get_absolute_url }}'
            '{% if not forloop.last %},{% endif %}{% endfor %}')
        self.assertEqual(
            t.render(context),
            '/test-page/,/test-page/test-child-page/')

        t = template.Template(
            '{% load feincms_page_tags %}'
            '{% feincms_nav feincms_page level=1 depth=3 as nav %}'
            '{% for p in nav %}{{ p.get_absolute_url }}'
            '{% if not forloop.last %},{% endif %}{% endfor %}')
        self.assertEqual(
            t.render(context),
            '/test-page/,/test-page/test-child-page/,/test-page/test-child'
            '-page/page3/')

        t = template.Template(
            '{% load feincms_page_tags %}'
            '{% feincms_nav feincms_page level=3 depth=2 as nav %}'
            '{% for p in nav %}{{ p.get_absolute_url }}'
            '{% if not forloop.last %},{% endif %}{% endfor %}')
        self.assertEqual(
            t.render(context), '/test-page/test-child-page/page3/')

        t = template.Template(
            '{% load feincms_page_tags %}'
            '{% if feincms_page|is_parent_of:page3 %}yes{% endif %}|'
            '{% if page3|is_parent_of:feincms_page %}yes{% endif %}')
        self.assertEqual(t.render(context), 'yes|')

        t = template.Template(
            '{% load feincms_page_tags %}'
            '{% if feincms_page|is_equal_or_parent_of:page3 %}yes{% endif %}|'
            '{% if page3|is_equal_or_parent_of:feincms_page %}yes{% endif %}')
        self.assertEqual(t.render(context), 'yes|')

        t = template.Template(
            '{% load feincms_page_tags %}'
            '{% feincms_translatedpage for feincms_page as t1 language=de %}'
            '{% feincms_translatedpage for feincms_page as t2 %}'
            '{{ t1.id }}|{{ t2.id }}')
        self.assertEqual(t.render(context), '2|1')

    def test_17_feincms_nav(self):
        """
        Test feincms_nav some more
        """

        self.login()

        self.create_page_through_admin('Page 1')  # 1
        self.create_page_through_admin('Page 1.1', 1)
        self.create_page_through_admin('Page 1.2', 1)  # 3
        self.create_page_through_admin('Page 1.2.1', 3)
        self.create_page_through_admin('Page 1.2.2', 3)
        self.create_page_through_admin('Page 1.2.3', 3)
        self.create_page_through_admin('Page 1.3', 1)

        self.create_page_through_admin('Page 2')  # 8
        self.create_page_through_admin('Page 2.1', 8)
        self.create_page_through_admin('Page 2.2', 8)
        self.create_page_through_admin('Page 2.3', 8)

        self.create_page_through_admin('Page 3')  # 12
        self.create_page_through_admin('Page 3.1', 12)
        self.create_page_through_admin('Page 3.2', 12)
        self.create_page_through_admin('Page 3.3', 12)  # 15
        self.create_page_through_admin('Page 3.3.1', 15)  # 16
        self.create_page_through_admin('Page 3.3.1.1', 16)
        self.create_page_through_admin('Page 3.3.2', 15)

        self.create_page_through_admin('Page 4')  # 19
        self.create_page_through_admin('Page 4.1', 19)
        self.create_page_through_admin('Page 4.2', 19)

        """
        Creates the following structure:

            1 (1) -+- 1.1 (2)
                   +- 1.2 (3) -+- 1.2.1 (4)
                   |           +- 1.2.2 (5)
                   |           +- 1.2.3 (6)
                   +- 1.3 (7)

            2 (8) -+- 2.1 (9)
                   +- 2.2 (10)
                   +- 2.3 (11)

            3 (12) -+- 3.1 (13)
                    +- 3.2 (14)
                    +- 3.3 (15) -+- 3.3.1 (16) --- 3.3.1.1 (17)
                                 +- 3.3.2 (18)
            4 (19) -+- 4.1 (20)
                    +- 4.2 (21)
        """

        Page.objects.all().update(active=True, in_navigation=True)
        Page.objects.filter(id__in=(5, 9, 19)).update(in_navigation=False)

        tests = [
            (
                {'feincms_page': Page.objects.get(pk=1)},
                '{% load feincms_page_tags %}'
                '{% feincms_nav feincms_page level=1 depth=2 as nav %}'
                '{% for p in nav %}{{ p.get_absolute_url }}'
                '{% if not forloop.last %},{% endif %}{% endfor %}',
                '/page-1/,/page-1/page-11/,/page-1/page-12/,/page-1/page-13/'
                ',/page-2/,/page-2/page-22/,/page-2/page-23/,/page-3/,/page-'
                '3/page-31/,/page-3/page-32/,/page-3/page-33/',
            ),
            (
                {'feincms_page': Page.objects.get(pk=14)},
                '{% load feincms_page_tags %}'
                '{% feincms_nav feincms_page level=2 depth=2 as nav %}'
                '{% for p in nav %}{{ p.get_absolute_url }}'
                '{% if not forloop.last %},{% endif %}{% endfor %}',
                '/page-3/page-31/,/page-3/page-32/,/page-3/page-33/,/page-3/'
                'page-33/page-331/,/page-3/page-33/page-332/',
            ),
            (
                {'feincms_page': Page.objects.get(pk=14)},
                '{% load feincms_page_tags %}'
                '{% feincms_nav feincms_page level=2 depth=3 as nav %}'
                '{% for p in nav %}{{ p.get_absolute_url }}'
                '{% if not forloop.last %},{% endif %}{% endfor %}',
                '/page-3/page-31/,/page-3/page-32/,/page-3/page-33/,/page-3/'
                'page-33/page-331/,/page-3/page-33/page-331/page-3311/,/page'
                '-3/page-33/page-332/',
            ),
            (
                {'feincms_page': Page.objects.get(pk=19)},
                '{% load feincms_page_tags %}'
                '{% feincms_nav feincms_page level=1 depth=2 as nav %}'
                '{% for p in nav %}{{ p.get_absolute_url }}'
                '{% if not forloop.last %},{% endif %}{% endfor %}',
                '/page-1/,/page-1/page-11/,/page-1/page-12/,/page-1/page-13'
                '/,/page-2/,/page-2/page-22/,/page-2/page-23/,/page-3/,/pag'
                'e-3/page-31/,/page-3/page-32/,/page-3/page-33/',
            ),
            (
                {'feincms_page': Page.objects.get(pk=1)},
                '{% load feincms_page_tags %}'
                '{% feincms_nav feincms_page level=3 depth=1 as nav %}'
                '{% for p in nav %}{{ p.get_absolute_url }}'
                '{% if not forloop.last %},{% endif %}{% endfor %}',
                '',
            ),
        ]

        for c, t, r in tests:
            self.assertEqual(
                template.Template(t).render(template.Context(c)),
                r)

        # Test that navigation entries do not exist several times, even with
        # navigation extensions. Apply the PassthroughExtension to a page
        # which does only have direct children, because it does not collect
        # pages further down the tree.
        page = Page.objects.get(pk=8)
        page.navigation_extension =\
            'testapp.navigation_extensions.PassthroughExtension'
        page.save()

        for c, t, r in tests:
            self.assertEqual(
                template.Template(t).render(template.Context(c)),
                r)

        # Now check that disabling a page also disables it in Navigation:
        p = Page.objects.get(pk=15)
        tmpl = '''{% load feincms_page_tags %}
{% feincms_nav feincms_page level=1 depth=3 as nav %}
{% for p in nav %}{{ p.pk }}{% if not forloop.last %},{% endif %}{% endfor %}
'''

        data = template.Template(tmpl).render(
            template.Context({'feincms_page': p})
        ).strip(),
        self.assertEqual(
            data,
            ('1,2,3,4,6,7,8,10,11,12,13,14,15,16,18',),
            "Original navigation")

        p.active = False
        p.save()
        data = template.Template(tmpl).render(
            template.Context({'feincms_page': p})
        ).strip(),
        self.assertEqual(
            data,
            ('1,2,3,4,6,7,8,10,11,12,13,14',),
            "Navigation after disabling intermediate page")

        # Same test with feincms_nav
        tmpl = '''{% load feincms_page_tags %}
{% feincms_nav feincms_page level=1 depth=3 as nav %}
{% for p in nav %}{{ p.pk }}{% if not forloop.last %},{% endif %}{% endfor %}
'''

        data = template.Template(tmpl).render(
            template.Context({'feincms_page': p})
        ).strip(),
        self.assertEqual(
            data,
            ('1,2,3,4,6,7,8,10,11,12,13,14',),
            "Navigation after disabling intermediate page")

        p.active = True
        p.save()

        data = template.Template(tmpl).render(
            template.Context({'feincms_page': p})
        ).strip(),
        self.assertEqual(
            data,
            ('1,2,3,4,6,7,8,10,11,12,13,14,15,16,18',),
            "Original navigation")

    def test_18_default_render_method(self):
        """
        Test the default render() behavior of selecting render_<region> methods
        to do the (not so) heavy lifting.
        """

        class Something(models.Model):
            class Meta:
                abstract = True

            def render_main(self):
                return 'Hello'

        # do not register this model in the internal FeinCMS bookkeeping
        # structures
        tmp = Page._feincms_content_types[:]
        type = Page.create_content_type(Something, regions=('notexists',))
        Page._feincms_content_types = tmp

        s = type(region='main', ordering='1')

        self.assertEqual(s.render(), 'Hello')

    def test_19_page_manager(self):
        self.create_default_page_set()

        page = Page.objects.get(pk=2)
        page.active = True
        page.save()

        self.assertRaises(
            Page.DoesNotExist,
            lambda: Page.objects.page_for_path(page.get_absolute_url()))
        self.assertRaises(
            Page.DoesNotExist,
            lambda: Page.objects.best_match_for_path(
                page.get_absolute_url() + 'something/hello/'))

        self.assertRaises(
            Http404,
            lambda: Page.objects.best_match_for_path(
                '/blabla/blabla/', raise404=True))
        self.assertRaises(
            Http404,
            lambda: Page.objects.page_for_path('/asdf/', raise404=True))
        self.assertRaises(
            Page.DoesNotExist,
            lambda: Page.objects.best_match_for_path('/blabla/blabla/'))
        self.assertRaises(
            Page.DoesNotExist,
            lambda: Page.objects.page_for_path('/asdf/'))

        request = Empty()
        request.path = request.path_info = page.get_absolute_url()
        request.method = 'GET'
        request.get_full_path = lambda: '/xyz/'
        request.GET = {}
        request.META = {}
        request.user = AnonymousUser()

        # tadaa
        from django.utils import translation
        translation.activate(page.language)

        page.active = False
        page.save()

        self.assertRaises(
            Http404,
            lambda: Page.objects.for_request(request, raise404=True))

        page.active = True
        page.save()

        self.assertRaises(
            Http404,
            lambda: Page.objects.for_request(request, raise404=True))

        page.parent.active = True
        page.parent.save()
        self.assertEqual(page, Page.objects.for_request(request))

        self.assertEqual(
            page, Page.objects.page_for_path(page.get_absolute_url()))
        self.assertEqual(
            page,
            Page.objects.best_match_for_path(
                page.get_absolute_url() + 'something/hello/'))

        old = feincms_settings.FEINCMS_ALLOW_EXTRA_PATH
        request.path += 'hello/'

        feincms_settings.FEINCMS_ALLOW_EXTRA_PATH = False
        self.assertEqual(self.client.get(request.path).status_code, 404)

        feincms_settings.FEINCMS_ALLOW_EXTRA_PATH = True
        self.assertEqual(self.client.get(request.path).status_code, 200)
        self.assertEqual(
            page, Page.objects.for_request(request, best_match=True))

        feincms_settings.FEINCMS_ALLOW_EXTRA_PATH = old

        page_id = id(request._feincms_page)
        p = Page.objects.for_request(request)
        self.assertEqual(id(p), page_id)

    def test_20_redirects(self):
        self.create_default_page_set()
        page1 = Page.objects.get(pk=1)
        page2 = Page.objects.get(pk=2)

        page2.active = True
        page2.publication_date = timezone.now() - timedelta(days=1)
        page2.override_url = '/blablabla/'
        page2.redirect_to = page1.get_absolute_url()
        page2.save()

        # regenerate cached URLs in the whole tree
        page1.active = True
        page1.save()

        page2 = Page.objects.get(pk=2)

        # page2 has been modified too, but its URL should not have changed
        try:
            self.assertRedirects(
                self.client.get('/blablabla/'),
                page1.get_absolute_url())
        except TemplateDoesNotExist as e:
            # catch the error from rendering page1
            if e.args != ('feincms_base.html',):
                raise

    def test_21_copy_content(self):
        self.create_default_page_set()
        page = Page.objects.get(pk=1)
        self.login()
        self.create_page_through_admincontent(page)

        page2 = Page.objects.get(pk=2)
        page2.copy_content_from(page)
        self.assertEqual(len(page2.content.main), 1)

    def test_22_contactform(self):
        self.create_default_page_set()
        page = Page.objects.get(pk=1)
        page.active = True
        page.template_key = 'theother'
        page.save()

        page.contactformcontent_set.create(
            email='mail@example.com', subject='bla',
            region='main', ordering=0)

        request = Empty()
        request.method = 'GET'
        request.GET = {}
        request.META = {}
        request.user = Empty()
        request.user.is_authenticated = lambda: False
        request.user.get_and_delete_messages = lambda: ()

        page.content.main[0].process(request)
        self.assertTrue('form' in page.content.main[0].render(request=request))

        self.client.post(page.get_absolute_url(), {
            'name': 'So what\'s your name, dude?',
            'email': 'another@example.com',
            'subject': 'This is a test. Please calm down',
            'content': 'Hell on earth.',
        })

        self.assertEqual(len(mail.outbox), 1)
        self.assertEqual(
            mail.outbox[0].subject, 'This is a test. Please calm down')

    def test_23_navigation_extension(self):
        self.create_default_page_set()

        page = Page.objects.get(pk=1)

        self.assertEqual(len(page.extended_navigation()), 0)

        page.navigation_extension =\
            'testapp.navigation_extensions.PassthroughExtension'

        page2 = Page.objects.get(pk=2)
        page2.active = True
        page2.in_navigation = True
        page2.save()

        self.assertEqual(list(page.extended_navigation()), [page2])

        page.navigation_extension =\
            'testapp.navigation_extensions.ThisExtensionDoesNotExist'

        self.assertEqual(len(page.extended_navigation()), 1)

        page.navigation_extension =\
            'testapp.navigation_extensions.PretenderExtension'

        self.assertEqual(
            page.extended_navigation()[0].get_absolute_url(), '/asdsa/')

    def test_24_admin_redirects(self):
        self.create_default_page_set()
        self.login()
        page = Page.objects.get(pk=1)

        response = self.create_page_through_admincontent(page, _continue=1)
        self.assertRedirects(response, '/admin/page/page/1/')

        response = self.create_page_through_admincontent(page, _addanother=1)
        self.assertRedirects(response, '/admin/page/page/add/')

        response = self.create_page_through_admincontent(page)
        self.assertRedirects(response, '/admin/page/page/')

    def test_25_applicationcontent(self):
        self.create_default_page_set()

        page1 = Page.objects.get(pk=1)
        page1.active = True
        page1.save()

        page = Page.objects.get(pk=2)
        page.active = True
        page.template_key = 'theother'
        page.save()

        # Should not be published because the page has no application contents
        # and should therefore not catch anything below it.
        self.is_published(page1.get_absolute_url() + 'anything/', False)

        page.applicationcontent_set.create(
            region='main', ordering=0,
            urlconf_path='testapp.applicationcontent_urls')

        self.assertContains(
            self.client.get(page.get_absolute_url()),
            'module_root')
        self.assertContains(
            self.client.get(page.get_absolute_url() + 'args_test/abc/def/'),
            'abc-def')
        self.assertContains(
            self.client.get(page.get_absolute_url() + 'kwargs_test/abc/def/'),
            'def-abc')

        response = self.client.get(
            page.get_absolute_url() + 'full_reverse_test/')
        self.assertContains(response, 'home:/test-page/test-child-page/')
        self.assertContains(
            response,
            'args:/test-page/test-child-page/args_test/xy/zzy/')
        self.assertContains(response, 'base:/test/')
        self.assertContains(response, 'homeas:/test-page/test-child-page/')

        self.assertEqual(
            app_reverse('ac_module_root', 'testapp.applicationcontent_urls'),
            '/test-page/test-child-page/')

        if hasattr(self, 'assertNumQueries'):
            self.assertNumQueries(
                0,
                lambda: app_reverse(
                    'ac_module_root', 'testapp.applicationcontent_urls'))

            cycle_app_reverse_cache()

            self.assertNumQueries(
                1,
                lambda: app_reverse(
                    'ac_module_root', 'testapp.applicationcontent_urls'))
            self.assertNumQueries(
                0,
                lambda: app_reverse(
                    'ac_module_root', 'testapp.applicationcontent_urls'))

        # This should not raise
        self.assertEqual(
            self.client.get(
                page.get_absolute_url() + 'notexists/'
            ).status_code, 404)

        self.assertContains(
            self.client.get(page.get_absolute_url() + 'fragment/'),
            '<span id="something">some things</span>')

        self.assertRedirects(
            self.client.get(page.get_absolute_url() + 'redirect/'),
            page.get_absolute_url())

        self.assertEqual(
            app_reverse('ac_module_root', 'testapp.applicationcontent_urls'),
            page.get_absolute_url())

        response = self.client.get(page.get_absolute_url() + 'response/')
        self.assertContains(response, 'Anything')
        # Ensure response has been wrapped
        self.assertContains(response, '<h2>Main content</h2>')

        # Test standalone behavior
        self.assertEqual(
            self.client.get(
                page.get_absolute_url() + 'response/',
                HTTP_X_REQUESTED_WITH='XMLHttpRequest').content,
            self.client.get(
                page.get_absolute_url() + 'response_decorated/').content)

        # Test reversing of URLs (with overridden urls too)
        page.applicationcontent_set.create(
            region='main',
            ordering=1,
            urlconf_path='testapp.blog_urls')
        page1.applicationcontent_set.create(
            region='main',
            ordering=0,
            urlconf_path='whatever')

        response = self.client.get(
            page.get_absolute_url() + 'alias_reverse_test/')
        self.assertContains(response, 'home:/test-page/')
        self.assertContains(response, 'args:/test-page/args_test/xy/zzy/')
        self.assertContains(response, 'base:/test/')

        self.assertEqual(
            app_reverse('blog_entry_list', 'testapp.blog_urls'),
            '/test-page/test-child-page/')
        self.assertEqual(
            app_reverse('ac_module_root', 'testapp.applicationcontent_urls'),
            '/test-page/test-child-page/')
        self.assertEqual(
            app_reverse('ac_module_root', 'whatever'),
            '/test-page/')

        page.applicationcontent_set.get(
            urlconf_path='testapp.applicationcontent_urls').delete()

        self.assertEqual(
            app_reverse('blog_entry_list', 'testapp.blog_urls'),
            '/test-page/test-child-page/')
        self.assertEqual(
            app_reverse('ac_module_root', 'whatever'),
            '/test-page/')

        # Ensure ApplicationContent's admin_fields support works properly
        self.login()
        self.assertContains(
            self.client.get('/admin/page/page/%d/' % page.id),
            'exclusive_subpages')

    def test_26_page_form_initial(self):
        self.create_default_page_set()
        self.login()

        self.assertEqual(self.client.get(
            '/admin/page/page/add/?translation_of=1&lang=de'
        ).status_code, 200)
        self.assertEqual(self.client.get(
            '/admin/page/page/add/?parent=1'
        ).status_code, 200)
        self.assertEqual(self.client.get(
            '/admin/page/page/add/?parent=2'
        ).status_code, 200)

    def test_27_cached_url_clash(self):
        self.create_default_page_set()

        page1 = Page.objects.get(pk=1)
        page2 = Page.objects.get(pk=2)

        page1.override_url = '/'
        page1.active = True
        page1.save()

        self.login()
        self.assertContains(
            self.create_page_through_admincontent(
                page2, active=True, override_url='/'),
            'already taken by')

    def test_28_applicationcontent_reverse(self):
        self.create_default_page_set()
        page1 = Page.objects.get(pk=1)
        page1.active = True
        page1.save()

        page = Page.objects.get(pk=2)
        page.active = True
        page.template_key = 'theother'
        page.save()
        page.applicationcontent_set.create(
            region='main', ordering=0,
            urlconf_path='testapp.applicationcontent_urls')

        # test app_reverse
        self.assertEqual(
            app_reverse('ac_module_root', 'testapp.applicationcontent_urls'),
            page.get_absolute_url())

        # when specific applicationcontent exists more then once reverse should
        # return the URL of the first (ordered by primary key) page.
        self.login()
        self.create_page_through_admin(
            title='Home DE', language='de', active=True)
        page_de = Page.objects.get(title='Home DE')
        self.create_page_through_admin(
            title='Child 1 DE', language='de', parent=page_de.id, active=True)
        page_de_1 = Page.objects.get(title='Child 1 DE')
        page_de_1.applicationcontent_set.create(
            region='main', ordering=0,
            urlconf_path='testapp.applicationcontent_urls')

        page.active = False
        page.save()

        settings.TEMPLATE_DIRS = (
            os.path.join(os.path.dirname(__file__), 'templates'),
        )
        self.client.get(page_de_1.get_absolute_url())
        self.assertEqual(
            app_reverse('ac_module_root', 'testapp.applicationcontent_urls'),
            page_de_1.get_absolute_url())

        page.active = True
        page.save()

        self.client.get(page1.get_absolute_url())
        self.assertEqual(
            app_reverse('ac_module_root', 'testapp.applicationcontent_urls'),
            page.get_absolute_url())

    def test_29_medialibrary_admin(self):
        self.create_default_page_set()
        self.login()

        page = Page.objects.get(pk=1)

        mediafile = MediaFile.objects.create(file='somefile.jpg')
        page.mediafilecontent_set.create(
            mediafile=mediafile,
            region='main',
            type='default',
            ordering=1)

        self.assertContains(
            self.client.get('/admin/medialibrary/mediafile/'),
            'somefile.jpg')

        import zipfile
        zf = zipfile.ZipFile('test.zip', 'w')
        for i in range(10):
            zf.writestr('test%d.jpg' % i, 'test%d' % i)
        zf.close()

        response = self.client.post(
            '/admin/medialibrary/mediafile/mediafile-bulk-upload/', {
                'data': open('test.zip', 'rb'),
            })
        self.assertRedirects(response, '/admin/medialibrary/mediafile/')

        self.assertEqual(
            MediaFile.objects.count(),
            11,
            "Upload of media files with ZIP does not work")

        dn = os.path.dirname
        path = os.path.join(
            dn(dn(dn(dn(__file__)))), 'docs', 'images', 'tree_editor.png')

        response = self.client.post('/admin/medialibrary/mediafile/add/', {
            'file': open(path, 'rb'),
            'translations-TOTAL_FORMS': 0,
            'translations-INITIAL_FORMS': 0,
            'translations-MAX_NUM_FORMS': 10,
        })
        self.assertRedirects(response, '/admin/medialibrary/mediafile/')

        self.assertContains(
            self.client.get('/admin/medialibrary/mediafile/'),
            '100x100.png" alt="" />')

        stats = list(MediaFile.objects.values_list('type', flat=True))
        self.assertEqual(stats.count('image'), 12)
        self.assertEqual(stats.count('other'), 0)

    def test_30_context_processors(self):
        self.create_default_page_set()
        Page.objects.update(active=True, in_navigation=True)

        request = Empty()
        request.GET = {}
        request.META = {}
        request.method = 'GET'
        request.path = request.path_info = '/test-page/test-child-page/abcdef/'
        request.get_full_path = lambda: '/test-page/test-child-page/abcdef/'

        ctx = add_page_if_missing(request)
        self.assertEqual(ctx['feincms_page'], request._feincms_page)

    def test_31_sites_framework_associating_with_single_site(self):
        self.login()
        site_2 = Site.objects.create(name='site 2', domain='2.example.com')
        self.create_page_through_admin(
            'site 1 homepage', override_url='/', active=True)
        self.create_page_through_admin(
            'site 2 homepage', override_url='/', site=site_2.id, active=True)
        self.assertEqual(Page.objects.count(), 2)
        self.assertEqual(Page.objects.active().count(), 1)

    def test_32_applicationcontent_inheritance20(self):
        self.create_default_page_set()

        page1 = Page.objects.get(pk=1)
        page1.active = True
        page1.save()

        page = Page.objects.get(pk=2)
        page.active = True
        page.template_key = 'theother'
        page.save()

        # Should not be published because the page has no application contents
        # and should therefore not catch anything below it.
        self.is_published(page1.get_absolute_url() + 'anything/', False)

        page.applicationcontent_set.create(
            region='main', ordering=0,
            urlconf_path='testapp.applicationcontent_urls')
        page.rawcontent_set.create(
            region='main', ordering=1, text='some_main_region_text')
        page.rawcontent_set.create(
            region='sidebar', ordering=0, text='some_sidebar_region_text')

        self.assertContains(self.client.get(page.get_absolute_url()),
                            'module_root')

        response = self.client.get(page.get_absolute_url() + 'inheritance20/')
        self.assertContains(response, 'a content 42')
        self.assertContains(response, 'b content')
        self.assertNotContains(response, 'some_main_region_text')
        self.assertContains(response, 'some_sidebar_region_text')
        self.assertNotContains(response, 'some content outside')

    def test_33_preview(self):
        self.create_default_page_set()
        page = Page.objects.get(pk=1)
        page.template_key = 'theother'
        page.save()
        page.rawcontent_set.create(
            region='main',
            ordering=0,
            text='Example content')

        self.login()
        self.assertEqual(
            self.client.get(page.get_absolute_url()).status_code, 404)
        self.assertContains(
            self.client.get('%s_preview/%s/' % (
                page.get_absolute_url(),
                page.pk),
            ),
            'Example content')

    def test_34_access(self):
        self.create_default_page_set()

        page = Page.objects.get(pk=1)
        page.override_url = '/something/'
        page.save()

        Page.objects.update(active=True)

        self.login()
        self.create_page_through_admin(
            title='redirect page',
            override_url='/',
            redirect_to=page.get_absolute_url(),
            active=True)

        # / -> redirect to /something/
        r = self.client.get('/')
        self.assertRedirects(r, page.get_absolute_url())
        # /something/ should work
        r = self.client.get(page.override_url)
        self.assertEqual(r.status_code, 200)
        # /foo not existant -> 404
        r = self.client.get('/foo/')
        self.assertEqual(r.status_code, 404)

    def test_35_access_with_extra_path(self):
        self.login()
        self.create_page(
            title='redirect again',
            override_url='/',
            redirect_to='/somewhere/',
            active=True)
        self.create_page(title='somewhere', active=True)

        r = self.client.get('/')
        self.assertRedirects(r, '/somewhere/')
        r = self.client.get('/dingdong/')
        self.assertEqual(r.status_code, 404)

        old = feincms_settings.FEINCMS_ALLOW_EXTRA_PATH
        feincms_settings.FEINCMS_ALLOW_EXTRA_PATH = True

        r = self.client.get('/')
        self.assertRedirects(r, '/somewhere/')
        r = self.client.get('/dingdong/')
        self.assertEqual(r.status_code, 404)

        feincms_settings.FEINCMS_ALLOW_EXTRA_PATH = old

    def test_36_sitemaps(self):
        response = self.client.get('/sitemap.xml')
        self.assertContains(response, '<urlset', status_code=200)

        self.login()
        response = self.create_page()
        response = self.client.get('/sitemap.xml')
        self.assertNotContains(response, '<url>', status_code=200)

        page = Page.objects.get()
        page.active = True
        page.in_navigation = True
        page.save()
        response = self.client.get('/sitemap.xml')
        self.assertContains(response, '<url>', status_code=200)

    def test_37_invalid_parent(self):
        self.create_default_page_set()

        page1, page2 = list(Page.objects.order_by('id'))

        page1.parent = page1
        self.assertRaises(InvalidMove, page1.save)

        self.create_page('Page 3', parent=page2)
        page1, page2, page3 = list(Page.objects.order_by('id'))

        page1.parent = page3
        self.assertRaises(InvalidMove, page1.save)

########NEW FILE########
__FILENAME__ = test_stuff
# ------------------------------------------------------------------------
# coding=utf-8
# ------------------------------------------------------------------------

from __future__ import absolute_import, unicode_literals

import doctest

from django.contrib.auth.models import User
from django.test import TestCase
from django.utils.encoding import force_text

import feincms

from feincms.content.contactform.models import ContactFormContent, ContactForm
from feincms.content.file.models import FileContent

from feincms.models import Region, Template, Base
from feincms.module.blog.models import Entry
from feincms.module.page import processors
from feincms.module.page.models import Page
from feincms.utils import collect_dict_values, get_object, shorten_string


# ------------------------------------------------------------------------
class Empty(object):
    """
    Helper class to use as request substitute (or whatever)
    """

    pass


class DocTest(TestCase):
    def test_translation_short_language_code(self):
        doctest.testmod(feincms.translations)

    def test_medialibrary_doctests(self):
        doctest.testmod(feincms.module.medialibrary.models)


class ModelsTest(TestCase):
    def test_region(self):
        # Creation should not fail

        r = Region('region', 'region title')
        t = Template(
            'base template',
            'base.html',
            (
                ('region', 'region title'),
                Region('region2', 'region2 title'),
            ),
        )

        # I'm not sure whether this test tests anything at all
        self.assertEqual(r.key, t.regions[0].key)
        self.assertEqual(force_text(r), 'region title')


class UtilsTest(TestCase):
    def test_get_object(self):
        self.assertRaises(
            AttributeError, lambda: get_object('feincms.does_not_exist'))
        self.assertRaises(
            ImportError, lambda: get_object('feincms.does_not_exist.fn'))

        self.assertEqual(get_object, get_object('feincms.utils.get_object'))

    def test_collect_dict_values(self):
        self.assertEqual(
            {'a': [1, 2], 'b': [3]},
            collect_dict_values([('a', 1), ('a', 2), ('b', 3)]))

    def test_shorten_string(self):
        string = shorten_string(
            "Der Wolf und die Grossmutter assen im Wald zu mittag",
            15, ellipsis="_")
        self.assertEqual(string, 'Der Wolf und_ag')
        self.assertEqual(len(string), 15)

        string = shorten_string(
            "Haenschen-Klein, ging allein, in den tiefen Wald hinein",
            15)
        self.assertEqual(string, 'Haenschen \u2026 ein')
        self.assertEqual(len(string), 15)

        string = shorten_string(
            'Badgerbadgerbadgerbadgerbadger',
            10, ellipsis='-')
        self.assertEqual(string, 'Badger-ger')
        self.assertEqual(len(string), 10)


class ExampleCMSBase(Base):
    pass

ExampleCMSBase.register_regions(
    ('region', 'region title'),
    ('region2', 'region2 title'))


class ExampleCMSBase2(Base):
        pass

ExampleCMSBase2.register_regions(
    ('region', 'region title'),
    ('region2', 'region2 title'))

Page.create_content_type(ContactFormContent, form=ContactForm)
Page.create_content_type(FileContent)
Page.register_request_processor(processors.etag_request_processor)
Page.register_response_processor(processors.etag_response_processor)
Page.register_response_processor(
    processors.debug_sql_queries_response_processor())


class BlogTestCase(TestCase):
    def setUp(self):
        u = User(
            username='test',
            is_active=True,
            is_staff=True,
            is_superuser=True)
        u.set_password('test')
        u.save()

    def login(self):
        self.assertTrue(self.client.login(username='test', password='test'))

    def create_entry(self):
        entry = Entry.objects.create(
            published=True,
            title='Something',
            slug='something',
            language='en')

        entry.rawcontent_set.create(
            region='main',
            ordering=0,
            text='Something awful')

        return entry

    def create_entries(self):
        entry = self.create_entry()

        Entry.objects.create(
            published=True,
            title='Something 2',
            slug='something-2',
            language='de',
            translation_of=entry)

        Entry.objects.create(
            published=True,
            title='Something 3',
            slug='something-3',
            language='de')

    def test_01_smoke_test_admin(self):
        self.create_entry()

        self.login()
        self.assertEqual(
            self.client.get('/admin/blog/entry/').status_code, 200)
        self.assertEqual(
            self.client.get('/admin/blog/entry/1/').status_code, 200)

    def test_02_translations(self):
        self.create_entries()

        entries = Entry.objects.in_bulk((1, 2, 3))

        self.assertEqual(len(entries[1].available_translations()), 1)
        self.assertEqual(len(entries[2].available_translations()), 1)
        self.assertEqual(len(entries[3].available_translations()), 0)

    def test_03_admin(self):
        self.login()
        self.create_entries()
        self.assertEqual(
            self.client.get('/admin/blog/entry/').status_code, 200)
        self.assertEqual(
            self.client.get('/admin/blog/entry/1/').status_code, 200)

########NEW FILE########
__FILENAME__ = utils
# coding: utf-8

import datetime


def mock_datetime():
    class MockDatetime(datetime.datetime):
        @classmethod
        def now(cls):
            return datetime.datetime(2012, 6, 1)
    return MockDatetime


def mock_date():
    class MockDate(datetime.date):
        @classmethod
        def today(cls):
            return datetime.date(2012, 6, 1)
    return MockDate

########NEW FILE########
__FILENAME__ = urls
from __future__ import absolute_import, unicode_literals

import os

from django.conf.urls import patterns, include, url
from django.contrib import admin
from django.contrib.staticfiles.urls import staticfiles_urlpatterns

from feincms.module.page.sitemap import PageSitemap


sitemaps = {'pages': PageSitemap}

admin.autodiscover()

urlpatterns = patterns(
    '',
    url(r'^admin/', include(admin.site.urls)),

    url(
        r'^media/(?P<path>.*)$',
        'django.views.static.serve',
        {'document_root': os.path.join(os.path.dirname(__file__), 'media/')},
    ),

    url(
        r'^sitemap\.xml$',
        'django.contrib.sitemaps.views.sitemap',
        {'sitemaps': sitemaps},
    ),

    url(r'', include('feincms.contrib.preview.urls')),
    url(r'', include('feincms.views.cbv.urls')),
)

urlpatterns += staticfiles_urlpatterns()

########NEW FILE########
