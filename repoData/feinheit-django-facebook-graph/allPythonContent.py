__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-facebook-graph documentation build configuration file, created by
# sphinx-quickstart on Mon Aug  8 15:36:19 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-facebook-graph'
copyright = u'2011, FEINHEIT GmbH'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-facebook-graphdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-facebook-graph.tex', u'django-facebook-graph Documentation',
   u'FEINHEIT GmbH', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-facebook-graph', u'django-facebook-graph Documentation',
     [u'FEINHEIT GmbH'], 1)
]

########NEW FILE########
__FILENAME__ = admin
""" Use this module for imports to extend the Admin classes
"""

from django.conf import settings

if 'facebook.modules.profile.page' in settings.INSTALLED_APPS:
    from facebook.modules.profile.page.admin import PageAdmin

if 'facebook.modules.profile.user' in settings.INSTALLED_APPS:
    from facebook.modules.profile.user.admin import UserAdmin

if 'facebook.modules.profile.event' in settings.INSTALLED_APPS:
    from facebook.modules.profile.event.admin import EventAdmin

if 'facebook.modules.profile.application' in settings.INSTALLED_APPS:
    from facebook.modules.profile.application.admin import RequestAdmin

if 'facebook.modules.media' in settings.INSTALLED_APPS:
    from facebook.modules.media.admin import PhotoAdmin

if 'facebook.modules.connections.post' in settings.INSTALLED_APPS:
    from facebook.modules.connections.post.admin import PostAdmin

if 'facebook.modules.connections.game' in settings.INSTALLED_APPS:
    from facebook.modules.connections.game.admin import ScoreAdmin, AchievementAdmin



########NEW FILE########
__FILENAME__ = urls
from django.conf import settings

from django.conf.urls.defaults import *

from views import login, logout, connect

urlpatterns = patterns('',
                       url(r'^login/$', login,
                           {'template_name': 'registration/login.html'}, name='fb_login'),
                       url(r'^logout/$', logout,
                           {'template_name': 'registration/logout.html'}, name='fb_logout'),
                       url(r'^connect/$', connect, {}, name='fb_connect'),
                       )

if 'registration' in settings.INSTALLED_APPS:
    urlpatterns += patterns('',
        url(r'', include('registration.backends.default.urls')),
        )
########NEW FILE########
__FILENAME__ = views
import urlparse
import re

from django.conf import settings
from django.core.urlresolvers import reverse
from django.contrib.auth import authenticate
from django.contrib.auth import login as auth_login
from django.contrib.auth import views as auth_views
from django.contrib.auth import REDIRECT_FIELD_NAME
from django.contrib.auth.forms import AuthenticationForm
from django.shortcuts import render_to_response, redirect
from django.template.context import RequestContext
from django.views.decorators.cache import never_cache
from django.views.decorators.csrf import csrf_protect

from django.http import HttpResponseRedirect, HttpResponse

import facebook
from facebook.graph import get_graph
from facebook.modules.profile.application.utils import get_app_dict
from facebook.modules.profile.user.models import User as FacebookUser
from facebook.session import get_session


import logging

logger = logging.getLogger(__name__)


@csrf_protect
@never_cache
def login(request, template_name='registration/login.html',
          redirect_field_name=REDIRECT_FIELD_NAME,
          authentication_form=AuthenticationForm,
          app_name=None):

    fb_app = get_app_dict(app_name)

    try:
        graph = get_graph(request, app_name=app_name)
    except IOError:
        graph = None

    redirect_to = request.REQUEST.get(redirect_field_name, '')

    # Because we override the login, we should check for POST data,
    #to give priority to the django auth view
    if request.method == 'GET' and graph and graph.via not in ('application',):
        # Light security check on redirect_to (lifted from django.contrib.auth.views)
        netloc = urlparse.urlparse(redirect_to)[1]

        if not redirect_to or netloc and netloc != request.get_host():
            redirect_to = fb_app['REDIRECT-URL']

#        # TODO: Check only if the domain is in 'DOMAIN' or 'facebook.com' but without the protocol
#
#        elif '//' in redirect_to and re.match(r'[^\?]*//', redirect_to):
#                redirect_to = fb_app['REDIRECT-URL']

        new_user = authenticate(graph=graph)
        logger.debug('new user: %s' %new_user)

        # Authentication might still fail -- new_user might be an
        # instance of AnonymousUser.
        if new_user and new_user.is_authenticated():
            auth_login(request, new_user)

            if 'registration' in settings.INSTALLED_APPS:
                from registration import signals
                signals.user_registered.send(sender='facebook_login',
                                         user=new_user,
                                         request=request)

        return redirect(redirect_to)

    return auth_views.login(request, template_name,
                            redirect_field_name, authentication_form)


def logout(request, next_page=None,
           template_name='registration/logged_out.html',
           redirect_field_name=REDIRECT_FIELD_NAME):

    fb_app=get_app_dict()  # TODO: Make this multi-app capable. Add app to login-url.
    fb_session = get_session(request)

    fb_session.store_token(None)

    response = auth_views.logout(request, next_page,
                                 template_name, redirect_field_name)

    # This might lead to unexpected results with multiple apps.
    response.delete_cookie("fbsr_" + fb_app['ID'])

    return response


def connect(request, redirect_field_name=REDIRECT_FIELD_NAME, app_name=None):
    """ Connects the Facebook Account to the current logged-in user. """
    fb_app = get_app_dict(app_name)
    graph = get_graph(request, app_name=app_name)
    redirect_to = request.REQUEST.get(redirect_field_name, fb_app['REDIRECT-URL'])

    if request.user.is_authenticated():
        try:
            me = graph.get_object("me")
        except facebook.GraphAPIError as e:
            return redirect('fb_login')

        # if the user has already a facebook connection, abort and show
        # error message
        if hasattr(request.user, 'user'):
            logger.debug('The logged in user is already connected.')
            # check if the django user and FB user match:
            if graph.user_id <> request.user.user.id:
                logger.debug('User %s already connected with Facebook account %s' % (request.user.get_full_name, request.user.user._name))
                auth_views.logout(request, next_page=reverse('fb_app'))
            # Otherwise redirect
            return redirect(redirect_to)
        else:
            # The User has no Facebook account attached. Connect him.
            try:
                # if that facebook user already exists, abort and show error message
                fb_user = FacebookUser.objects.get(id=graph.user_id)
            except FacebookUser.DoesNotExist:
                fb_user = FacebookUser(id=graph.user_id)
                fb_user.get_from_facebook(graph=graph, save=True)
            else:
                if isinstance(fb_user.user, User):
                    auth_views.logout(request, next_page=reverse('fb_login'))
                else:
                    fb_user.user = request.user
                    fb_user.save()
            finally:
                return redirect(redirect_to)

    else:
        # The user is not logged in
        # -> redirect to login page
        return redirect('fb_login')

########NEW FILE########
__FILENAME__ = context_processors
from django.conf import settings
""" This context processor is depreciated.
    It only works it if you only have one Facebook App. 
    Use the fb_tags instead.
"""
def application_settings(request):
    firstapp = getattr(settings, 'FACEBOOK_APPS').values()[0]
    return { 'FACEBOOK_API_KEY' : firstapp['API-KEY'],
             'FACEBOOK_APP_ID' : firstapp['ID'],
             'FACEBOOK_CANVAS_PAGE' : firstapp['CANVAS-PAGE'],
             'FACEBOOK_CANVAS_URL' : firstapp['CANVAS-URL']}
    
def facebook_config(request):
    if 'facebook' in request.session:
        return {'facebook' : request.session['facebook']}
    else:
        return {'facebook' : False }

def session_without_cookies(request):
    """ simple helper to use sessions without cookies """
    cookie_name = settings.SESSION_COOKIE_NAME
    session_key = request.session._get_session_key()
    
    return {'session_GET' : '%s=%s' %(cookie_name, session_key),
            'session_id'  : session_key,
            'session_hidden_field' : '<div style="display:none"><input type="hidden" name="%s" value="%s" /></div>' %(cookie_name, session_key)}

def is_page_fan(request):
    """ checks if the user likes the page, the tab is in. """
    try:    
        is_fan = request.fb_session.signed_request['page']['liked']
    except (AttributeError, KeyError, TypeError):
        is_fan = False
    return {'is_fan' : is_fan, 'signed_request': request.fb_session.signed_request }
########NEW FILE########
__FILENAME__ = csrf
import logging

from django.conf import settings
import django
import re

from django.utils import crypto
from django.utils.http import same_origin
from django.utils.decorators import decorator_from_middleware
from django.middleware.csrf import CsrfViewMiddleware as DjangoCsrfViewMiddleware, \
    REASON_NO_REFERER, REASON_BAD_REFERER, REASON_NO_CSRF_COOKIE, REASON_BAD_TOKEN

logger = logging.getLogger(__name__)

CSRF_KEY_LENGTH = 32

import warnings
warnings.warn('facebook.csrf.CsrfViewMiddleware is no longer necessary. '
              'Just make sure the SignedRequestMiddleware gets called before the '
              'standard django CsrfViewMiddleware.', DeprecationWarning, stacklevel=2)

# CSRF view middleware changed significantly in Django 1.4

if django.VERSION[0]==1 and django.VERSION[1] >= 4:

    from django.middleware.csrf import _get_failure_view

    def _get_new_csrf_key():
        return crypto.get_random_string(CSRF_KEY_LENGTH)

    def _sanitize_token(token):
        # Allow only alphanum, and ensure we return a 'str' for the sake
        # of the post processing middleware.
        if len(token) > CSRF_KEY_LENGTH:
            return _get_new_csrf_key()
        token = re.sub('[^a-zA-Z0-9]+', '', str(token.decode('ascii', 'ignore')))
        if token == "":
            # In case the cookie has been truncated to nothing at some point.
            return _get_new_csrf_key()
        return token

    class CsrfViewMiddleware(DjangoCsrfViewMiddleware):
        """
        Patched Middleware that accepts POSTs from Facebook
        """
        # The _accept and _reject methods currently only exist for the sake of the
        # requires_csrf_token decorator.
        def _accept(self, request):
            request.csrf_processing_done = True
            return None

        def _reject(self, request, reason):
            return _get_failure_view()(request, reason=reason)

        def process_view(self, request, callback, callback_args, callback_kwargs):

            if getattr(request, 'csrf_processing_done', False):
                return None

            try:
                csrf_token = _sanitize_token(
                    request.COOKIES[settings.CSRF_COOKIE_NAME])
                # Use same token next time
                request.META['CSRF_COOKIE'] = csrf_token
            except KeyError:
                if 'state' in request.POST:
                    csrf_token = _sanitize_token(request.POST.get('state'))
                else:
                    csrf_token = None
                    # Generate token and store it in the request, so it's
                    # available to the view.
                    request.META["CSRF_COOKIE"] = _get_new_csrf_key()

            # Wait until request.META["CSRF_COOKIE"] has been manipulated before
            # bailing out, so that get_token still works
            if getattr(callback, 'csrf_exempt', False):
                return None

            # Assume that anything not defined as 'safe' by RC2616 needs protection
            if request.method not in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
                if getattr(request, '_dont_enforce_csrf_checks', False):
                    # Mechanism to turn off CSRF checks for test suite.
                    # It comes after the creation of CSRF cookies, so that
                    # everything else continues to work exactly the same
                    # (e.g. cookies are sent, etc.), but before any
                    # branches that call reject().
                    return self._accept(request)

                # let initial signed requests pass
                if request.method == 'POST' and 'signed_request' in request.POST:
                    post = request.POST.copy()
                    post.pop('signed_request')
                    if len(post) == 0:
                        return self._accept(request)

                if request.is_secure() and getattr(settings, 'HTTPS_REFERER_REQUIRED', True):
                    # Suppose user visits http://example.com/
                    # An active network attacker (man-in-the-middle, MITM) sends a

                    referer = request.META.get('HTTP_REFERER')
                    if referer is None:
                        logger.warning('Forbidden (%s): %s',
                                       REASON_NO_REFERER, request.path,
                            extra={
                                'status_code': 403,
                                'request': request,
                            }
                        )
                        return self._reject(request, REASON_NO_REFERER)

                    # Note that request.get_host() includes the port.
                    good_referer = 'https://%s/' % request.get_host()
                    if not same_origin(referer, good_referer):
                        reason = REASON_BAD_REFERER % (referer, good_referer)
                        logger.warning('Forbidden (%s): %s', reason, request.path,
                            extra={
                                'status_code': 403,
                                'request': request,
                            }
                        )
                        return self._reject(request, reason)

                if csrf_token is None:
                    # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
                    # and in this way we can avoid all CSRF attacks, including login
                    # CSRF.
                    logger.warning('Forbidden (%s): %s',
                                   REASON_NO_CSRF_COOKIE, request.path,
                        extra={
                            'status_code': 403,
                            'request': request,
                        }
                    )
                    return self._reject(request, REASON_NO_CSRF_COOKIE)

                # Check non-cookie token for match.
                request_csrf_token = ""
                if request.method == "POST":
                    request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')

                if request_csrf_token == "":
                    # Fall back to X-CSRFToken, to make things easier for AJAX,
                    # and possible for PUT/DELETE.
                    request_csrf_token = request.META.get('HTTP_X_CSRFTOKEN', '')

                if not crypto.constant_time_compare(request_csrf_token, csrf_token):
                    logger.warning('Forbidden (%s): %s',
                                   REASON_BAD_TOKEN, request.path,
                        extra={
                            'status_code': 403,
                            'request': request,
                        }
                    )
                    return self._reject(request, REASON_BAD_TOKEN)

            return self._accept(request)



else:
    from django.middleware.csrf import (
        _sanitize_token, _get_new_csrf_key, _make_legacy_session_token,
        REASON_NO_COOKIE, _MAX_CSRF_KEY)

    class CsrfViewMiddleware(DjangoCsrfViewMiddleware):

        def process_view(self, request, callback, callback_args, callback_kwargs):
            if getattr(request, 'csrf_processing_done', False):
                return None

            try:
                request.META["CSRF_COOKIE"] = _sanitize_token(request.COOKIES[settings.CSRF_COOKIE_NAME])
                cookie_is_new = False
            except KeyError:
                request.META["CSRF_COOKIE"] = _get_new_csrf_key()
                cookie_is_new = True

            if getattr(callback, 'csrf_exempt', False):
                return None

            if request.method == 'POST':
                if getattr(request, '_dont_enforce_csrf_checks', False):
                    return self._accept(request)
                # let initial signed requests pass
                if 'signed_request' in request.POST:
                    post = request.POST.copy()
                    post.pop('signed_request')
                    if len(post) == 0:
                        return self._accept(request)

                if request.is_secure() and getattr(settings, 'HTTPS_REFERER_REQUIRED', True):
                    referer = request.META.get('HTTP_REFERER')
                    if referer is None :
                        logger.warning('Forbidden (%s): %s' % (REASON_NO_REFERER, request.path),
                            extra={
                                'status_code': 403,
                                'request': request,
                            }
                        )
                        return self._reject(request, REASON_NO_REFERER)

                    # Note that request.get_host() includes the port
                    good_referer = 'https://%s/' % request.get_host()
                    if not same_origin(referer, good_referer):
                        reason = REASON_BAD_REFERER % (referer, good_referer)
                        logger.warning('Forbidden (%s): %s' % (reason, request.path),
                            extra={
                                'status_code': 403,
                                'request': request,
                            }
                        )
                        return self._reject(request, reason)

                if cookie_is_new:
                    try:
                        session_id = request.COOKIES[settings.SESSION_COOKIE_NAME]
                        csrf_token = _make_legacy_session_token(session_id)
                    except KeyError:
                        logger.warning('Forbidden (%s): %s' % (REASON_NO_COOKIE, request.path),
                            extra={
                                'status_code': 403,
                                'request': request,
                            }
                        )
                        return self._reject(request, REASON_NO_COOKIE)
                else:
                    csrf_token = request.META["CSRF_COOKIE"]

                # check incoming token
                request_csrf_token = request.POST.get('csrfmiddlewaretoken', None)
                if not request_csrf_token:
                    request_csrf_token = request.POST.get('state', '')
                if request_csrf_token == "":
                    # Fall back to X-CSRFToken, to make things easier for AJAX
                    request_csrf_token = request.META.get('HTTP_X_CSRFTOKEN', '')

                if not crypto.constant_time_compare(request_csrf_token, csrf_token):
                    if cookie_is_new:
                        # probably a problem setting the CSRF cookie
                        logger.warning('Forbidden (%s): %s' % (REASON_NO_CSRF_COOKIE, request.path),
                            extra={
                                'status_code': 403,
                                'request': request,
                            }
                        )
                        return self._reject(request, REASON_NO_CSRF_COOKIE)
                    else:
                        logger.warning('Forbidden (%s): %s' % (REASON_BAD_TOKEN, request.path),
                            extra={
                                'status_code': 403,
                                'request': request,
                            }
                        )
                        return self._reject(request, REASON_BAD_TOKEN)

            return self._accept(request)


csrf_protect = decorator_from_middleware(CsrfViewMiddleware)
csrf_protect.__name__ = "csrf_protect"
csrf_protect.__doc__ = """
This decorator adds CSRF protection in exactly the same way as
CsrfViewMiddleware, but it can be used on a per view basis.  Using both, or
using the decorator multiple times, is harmless and efficient.
"""


########NEW FILE########
__FILENAME__ = decorators
#coding=utf-8

import functools, logging
from django.conf import settings
from facebook.modules.profile.application.utils import get_app_dict
from django.core.urlresolvers import resolve, Resolver404
from django.shortcuts import render_to_response
from django.template.context import RequestContext
from django.template.defaultfilters import urlencode
from django.http import HttpResponseRedirect
logger = logging.getLogger(__name__)

#runserver = ('runserver' in sys.argv)


def redirect_to_page(app_name=None):
    def _redirect_to_page(view):
        """ Decorator that redirects a canvas URL to a page using the path that is in app_data.path """
        """ Decorate the views where you have links to the app page. """
        """ usage: @redirect_to_page() or @redirect_to_page('app_name'). """
    
        def wrapper(request, *args, **kwargs):
            # if this is already the callback, do not wrap.
            if getattr(request, 'avoid_redirect', False):
                logger.debug('entered calback. View: %s, kwargs: %s' %(view, kwargs))
                return view(request, *args, **kwargs)

            if 'facebook' in request.META['HTTP_USER_AGENT']:
                return view(request, *args, **kwargs)
            
            session = request.session.get('facebook', dict())
            try:
                signed_request = session['signed_request']
            except KeyError:
                logger.debug('No signed_request in current session. Returning View.')
                return view(request, *args, **kwargs)
            
            app_dict = get_app_dict(app_name)
    
            logger.debug('signed_request: %s' %signed_request)
            # This is handled by the Redirect2AppDataMiddleware
            
            if 'app_data' in signed_request:
                app_data = signed_request['app_data']
                del request.session['facebook']['signed_request']['app_data']
                request.session.modified = True
                logger.debug('found app_data url: %s' %app_data)
                return HttpResponseRedirect(app_data)
                
#                try:
#                    original_view = resolve(app_data)
#                except Resolver404:
#                    logger.debug('Did not find view for %s.' %app_data)
#                    url = u'%s?sk=app_%s' % (app_dict['REDIRECT-URL'], app_dict['ID'])
#                    return render_to_response('facebook/redirecter.html', {'destination': url }, RequestContext(request))
#    
#                logger.debug('found original view url: %s' %original_view)
#                setattr(request, 'avoid_redirect' ,  True)
#                # call the view that was originally requested:
#                return original_view.func(request, *original_view.args, **original_view.kwargs)
            else:
                #check if the app is inside the specified page.
                try:
                    page = signed_request['page']['id']
                except KeyError:
                    page = 0
    
                if int(page) not in app_dict['PAGES'] and getattr(settings, 'FB_REDIRECT', True):
                    url = u'%s?sk=app_%s&app_data=%s' % (app_dict['REDIRECT-URL'], app_dict['ID'], urlencode(request.path))
                    logger.debug('Tab is not in original Page (id: %s, should be: %s. Redirecting to: %s' %(page, app_dict['PAGES'][0], url))
                    return render_to_response('facebook/redirecter.html', {'destination': url }, RequestContext(request))

            return view(request, *args, **kwargs)
    
        return functools.wraps(view)(wrapper)
    return _redirect_to_page
########NEW FILE########
__FILENAME__ = fb
""" Use this module for imports. from facebook import fb """

from django.conf import settings

if 'facebook.modules.profile.page' in settings.INSTALLED_APPS:
    from facebook.modules.profile.page.models import Page

if 'facebook.modules.profile.user' in settings.INSTALLED_APPS:
    from facebook.modules.profile.user.models import User, TestUser

if 'facebook.modules.profile.event' in settings.INSTALLED_APPS:
    from facebook.modules.profile.event.models import Event

if 'facebook.modules.profile.application' in settings.INSTALLED_APPS:
    from facebook.modules.profile.application.models import Request

if 'facebook.modules.media' in settings.INSTALLED_APPS:
    from facebook.modules.media.models import Photo

if 'facebook.modules.connections.post' in settings.INSTALLED_APPS:
    from facebook.modules.connections.post.models import Post, PostBase

if 'facebook.modules.connections.game' in settings.INSTALLED_APPS:
    from facebook.modules.connections.game.models import Score, Achievement
    from facebook.modules.connections.game.views import (get_user_score,
            get_user_and_friends_scores, set_user_score, delete_user_score,
            delete_all_scores)


########NEW FILE########
__FILENAME__ = context_processors
from utils import get_tab_url_from_request

def facebook_tab_deeplink(request):
    tab_url = get_tab_url_from_request(request)
    return {'facebook_tab_deeplink' : '%s&app_data=%s' % (tab_url, request.path_info) }

########NEW FILE########
__FILENAME__ = extensions
from django.db import models
from django.utils.translation import ugettext_lazy as _

from facebook.modules.profile.page.models import Page
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured

""" Add those extensions to your APP_MODULE.models like so::
        
        from facebook.feincms.extensions import facebook_application
        Page.register_extension(facebook_application)
"""

def facebook_application(cls, admin_cls):
    if not getattr(settings, 'FACEBOOK_APPS'):
        raise ImproperlyConfigured, 'You need to set your FACEBOOK_APPS dict correctly.'
    APP_CHOICES = tuple((x,unicode(x)) for x in settings.FACEBOOK_APPS.keys())
    
    cls.add_to_class('facebook_application', models.CharField(max_length=25, 
                     choices = APP_CHOICES,
                     blank=True, null=True, help_text=_('Link this page to a facebook app. Used for Facebook Tabs, to determine the underlaying FB App')))
    cls.add_to_class('facebook_page', models.ForeignKey(Page, blank=True, null=True, related_name='facebook_page_set', help_text=_('Link this page to a facebook page. Used for Facebook Tabs, to determine the underlaying FB Page and prevent the Tab to be added to a random foreign page')))

    admin_cls.fieldsets.append((_('Facebook Application'),{
        'fields' : ('facebook_application', 'facebook_page',),
        'classes' : ('collapse',),
    }))


def content_type_extension(cls, admin_cls=None):
    """ Monkeypatch for content types. a patched content type will only render its content dependent of these settings
    Sample implementation (models.py):

    from facebook.feincms.extensions import content_type_extension
    content_type_extension(Page.create_content_type(RichTextContent))
    """
    RENDER_CHOICES = (
        (0, _('both')),
        (1, _('true')),
        (2, _('false')),
    )

    # save the original render method
    cls.original_render = cls.render

    cls.add_to_class('render_like', models.PositiveSmallIntegerField(_('render like'), blank=True, null=True, default=0, choices=RENDER_CHOICES, help_text=_('Render this content only, if requesting user likes the page.')))
    cls.add_to_class('app_installed', models.PositiveSmallIntegerField(_('app installed'), blank=True, null=True, default=0, choices=RENDER_CHOICES, help_text=_('Render this content only, if requesting user has installed the corresponding app.')))

    def render(instance, request, context, **kwargs):
        """ override render function. renders on dependency of the render settings. """

        try:
            # will crash, if there is no facebook and/or signed request in the session
            user_liked = request.session['facebook']['signed_request']['page']['liked']
        except:
            return instance.original_render(**kwargs)

        try:
            # if the user has not installed the app, there will be no user_id
            user_id = request.session['facebook']['signed_request']['user_id']
            app_installed = True
        except:
            app_installed = False

        render_because_of_like = True
        render_because_of_app_installed = True

        if (instance.render_like == 2 and user_liked) or \
            (instance.render_like == 1 and not user_liked):
            render_because_of_like = False

        if (instance.app_installed == 2 and app_installed) or \
            (instance.app_installed == 1 and not app_installed):
            render_because_of_app_installed = False

        if render_because_of_like and render_because_of_app_installed:
            return instance.original_render(**kwargs)
        else:
            return '<!-- content not rendered because of facebook params -->'
    cls.render = render

########NEW FILE########
__FILENAME__ = middleware
from django.shortcuts import render_to_response

from utils import get_page_from_request, get_tab_url_from_request


class PreventForeignApp(object):
    """ Checks the signed_request for the facebook page id. if it detects a foreign tab
    or an app, it redirects using a javascript redirection to the deeplink of the tab in the
    associated page """
    
    def process_request(self, request):
        if 'deauthorize' in request.path:
            return None
        
        if 'facebook' in request.session and 'signed_request' in request.session['facebook']:
            facebook_page = get_page_from_request(request)
            signed_request = request.session['facebook']['signed_request']
            
            if not facebook_page or not 'page' in signed_request:
                return None

            if signed_request['page']['id'] != str(facebook_page.id):
                destination = '%s&app_data=%s' % (get_tab_url_from_request(request), request.path_info)
                return render_to_response('facebook/redirecter.html', {'destination' : destination})

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import redirect_to_slug

urlpatterns = patterns('',
    url(r'^$', redirect_to_slug, name='redirect_to_slug'),
)
########NEW FILE########
__FILENAME__ = utils
from feincms.module.page.models import Page
from facebook.modules.profile.application.utils import get_app_dict

def get_application_from_request(request):
    try:
        page = Page.objects.for_request(request, best_match=True)
        return getattr(page, 'facebook_application', None)
    except Page.DoesNotExist:
        return None

def get_page_from_request(request):
    try:
        page = Page.objects.for_request(request, best_match=True)
        return getattr(page, 'facebook_page', None)
    except Page.DoesNotExist:
        return None

def get_tab_url_from_request(request):
    try:
        page = Page.objects.for_request(request, best_match=True)
    except Page.DoesNotExist:
        return None

    fb_app = get_app_dict(getattr(page, 'facebook_application', None))
    fb_page = getattr(page, 'facebook_page', None)

    if fb_page and fb_app:
        if '?' in fb_page.facebook_link:
            separator = '&'
        else:
            separator = '?'
        return u'%s%ssk=app_%s' % (fb_page.facebook_link, separator, fb_app['ID'])
    else:
        return None

########NEW FILE########
__FILENAME__ = views
from django.conf import settings
from django.http import HttpResponse
from django.shortcuts import redirect

from feincms.module.page.models import Page


def redirect_to_slug(request):
    """ tries to redirect the user with help of the facebook signed_request page params (admin, liked) """

    try:
        facebook_page = request.session['facebook']['signed_request']['page']
    except KeyError as e:
        return HttpResponse('<!-- could not redirect to slug via facebook page signed request params: %s -->' % e)


    page = Page.objects.for_request(request, raise404=True, best_match=True)
    if facebook_page['admin'] and facebook_page['liked']:
        try:
            return redirect(page.get_children().filter(slug='admin-liked')[0])
        except IndexError:
            pass
    if facebook_page['liked']:
        try:
            return redirect(page.get_children().filter(slug='liked')[0])
        except IndexError:
            pass
    if facebook_page['admin']:
        try:
            return redirect(page.get_children().filter(slug='admin')[0])
        except IndexError:
            pass

    try:
        return redirect(page.get_children().filter(slug='unliked')[0])
    except IndexError:
        return HttpResponse('<!-- no childpage with matching slug found. looked for slugs: admin-liked, liked, admin, unliked -->')
########NEW FILE########
__FILENAME__ = fields
import logging
logger = logging.getLogger(__name__)

from django import forms
from django.core.serializers.json import DjangoJSONEncoder
from django.db import models
from django.utils import simplejson as json
from django.conf import settings

if 'south' in settings.INSTALLED_APPS:
    from south.modelsinspector import add_introspection_rules
    add_introspection_rules([], ["^facebook\.fields\.JSONField"])


class JSONFormField(forms.fields.CharField):
    def clean(self, value, *args, **kwargs):
        if value == '{}': # let empty value pass.
            pass
        elif value:
            try:
                # Run the value through JSON so we can normalize formatting and at least learn about malformed data:
                value = json.dumps(json.loads(value), cls=DjangoJSONEncoder)
            except ValueError:
                raise forms.ValidationError("Invalid JSON data!")

        return super(JSONFormField, self).clean(value, *args, **kwargs)


class JSONField(models.TextField):
    """
    TextField which transparently serializes/unserializes JSON objects

    See:
    http://www.djangosnippets.org/snippets/1478/
    """

    # Used so to_python() is called
    __metaclass__ = models.SubfieldBase

    formfield = JSONFormField

    def to_python(self, value):
        """Convert our string value to JSON after we load it from the DB"""

        if isinstance(value, dict) or isinstance(value, list):
            return value
        elif isinstance(value, basestring):
            # Avoid asking the JSON decoder to handle empty values:
            if not value:
                return {}

            try:
                return json.loads(value)
            except ValueError:
                logging.exception("Unable to deserialize store JSONField data: %s", value)
                return {}
        else:
            assert value is None
            return {}

    def get_prep_value(self, value):
        """Convert our JSON object to a string before we save"""
        return self._flatten_value(value)

    def value_to_string(self, obj):
        """Extract our value from the passed object and return it in string form"""

        if hasattr(obj, self.attname):
            value = getattr(obj, self.attname)
        else:
            assert isinstance(obj, dict)
            value = obj.get(self.attname, "")

        return self._flatten_value(value)

    def _flatten_value(self, value):
        """Return either a string, JSON-encoding dict()s as necessary"""
        if not value:
            return ""

        if isinstance(value, dict) or isinstance(value, list):
            value = json.dumps(value, cls=DjangoJSONEncoder)

        assert isinstance(value, basestring)

        return value
########NEW FILE########
__FILENAME__ = graph
# -*- coding: utf-8 -*-

import urllib
import urllib2
import warnings
from urllib2 import HTTPError

from facebook.utils import MultipartPostHandler

import logging
from django.http import HttpResponseServerError
logger = logging.getLogger(__name__)

from datetime import datetime, timedelta

from facebook.modules.profile.application.utils import get_app_dict
from facebook.oauth2 import authenticate, parseSignedRequest
from facebook.session import get_session

# Find a JSON parser
try:
    import simplejson as json
except ImportError:
    try:
        from django.utils import simplejson as json
    except ImportError:
        import json

_parse_json = lambda s: json.loads(s)


class GraphAPIError(Exception):
    def __init__(self, type, message):
        Exception.__init__(self)
        self.type = type
        self.message = message
    
    def __str__(self):
        return '%s: %s' % (self.type, self.message)


class GraphAPI(object):
    """A client for the Facebook Graph API.

    See http://developers.facebook.com/docs/api for complete documentation
    for the API.

    The Graph API is made up of the objects in Facebook (e.g., people, pages,
    events, photos) and the connections between them (e.g., friends,
    photo tags, and event RSVPs). This client provides access to those
    primitive types in a generic way. For example, given an OAuth access
    token, this will fetch the profile of the active user and the list
    of the user's friends:

       graph = facebook.GraphAPI(access_token)
       user = graph.get_object("me")
       friends = graph.get_connections(user["id"], "friends")

    You can see a list of all of the objects and connections supported
    by the API at http://developers.facebook.com/docs/reference/api/.

    You can obtain an access token via OAuth or by using the Facebook
    JavaScript SDK. See http://developers.facebook.com/docs/authentication/
    for details.

    If you are using the JavaScript SDK, you can use the
    get_user_from_cookie() method below to get the OAuth access token
    for the active user from the cookie saved by the SDK.
    """
    def __init__(self, access_token=None):
        self.access_token = access_token

    def get_object(self, id, **args):
        """Fetchs the given object from the graph."""
        return self.request(id, args)

    def get_objects(self, ids, **args):
        """Fetchs all of the given object from the graph.

        We return a map from ID to object. If any of the IDs are invalid,
        we raise an exception.
        """
        args["ids"] = ",".join(ids)
        return self.request("", args)

    def get_connections(self, id, connection_name, **args):
        """Fetches the connections for given object."""
        return self.request(id + "/" + connection_name, args)

    def batch_request(self, batch):
        """ Combines multiple requests into one.
            Batch must be a List of Dicts in the format:
            [{"method": "GET", "relative_url": "me"},
            {"method": "GET", "relative_url": "me/friends?limit=50"}]
            It returns a list of response dicts:
            http://developers.facebook.com/docs/reference/api/batch/
        """
        return self.request('', None, {'batch': json.dumps(batch)})

    def put_object(self, parent_object, connection_name, **data):
        """Writes the given object to the graph, connected to the given parent.

        For example,

            graph.put_object("me", "feed", message="Hello, world")

        writes "Hello, world" to the active user's wall. Likewise, this
        will comment on a the first post of the active user's feed:

            feed = graph.get_connections("me", "feed")
            post = feed["data"][0]
            graph.put_object(post["id"], "comments", message="First!")

        See http://developers.facebook.com/docs/api#publishing for all of
        the supported writeable objects.

        Most write operations require extended permissions. For example,
        publishing wall posts requires the "publish_stream" permission. See
        http://developers.facebook.com/docs/authentication/ for details about
        extended permissions.
        """
        assert self.access_token, "Write operations require an access token"
        return self.request(parent_object + "/" + connection_name, post_args=data)

    def put_wall_post(self, message, attachment={}, profile_id="me"):
        """Writes a wall post to the given profile's wall.

        We default to writing to the authenticated user's wall if no
        profile_id is specified.

        attachment adds a structured attachment to the status message being
        posted to the Wall. It should be a dictionary of the form:

            {"name": "Link name"
             "link": "http://www.example.com/",
             "caption": "{*actor*} posted a new review",
             "description": "This is a longer description of the attachment",
             "picture": "http://www.example.com/thumbnail.jpg"}

        """
        return self.put_object(profile_id, "feed", message=message, **attachment)

    def put_comment(self, object_id, message):
        """Writes the given comment on the given post."""
        return self.put_object(object_id, "comments", message=message)

    def put_like(self, object_id):
        """Likes the given post."""
        return self.put_object(object_id, "likes")

    def delete_object(self, id):
        """Deletes the object with the given ID from the graph."""
        return self.request(id, post_args={"method": "delete"})

    def request(self, path, args=None, post_args=None):
        """Fetches the given path in the Graph API.

        We translate args to a valid query string. If post_args is given,
        we send a POST request to the given path with the given arguments.
        """
        if not args: args = {}
        if self.access_token:
            if post_args is not None:
                post_args["access_token"] = self.access_token
            else:
                args["access_token"] = self.access_token
        if post_args:
            for k, v in post_args.iteritems():
                if isinstance(v, basestring):
                    post_args[k] = v.encode('utf-8')
        post_data = None if post_args is None else urllib.urlencode(post_args)
        query = "https://graph.facebook.com/" + path + "?" + urllib.urlencode(args)
        logger.debug('query: %s' % query)
        try:
            file = urllib2.urlopen(query, post_data)
            raw = file.read()
        except HTTPError as e:  # attrs: filename, code, msg, hdrs, fp
            if e.fp is not None:
                r = _parse_json(e.fp.read())
                raise GraphAPIError(r['error']['type'], r['error']['message'])
            else:
                raise GraphAPIError('HTTP ERROR %s' % e.code, '%s, %s %s' % (e.msg, e.filename, e.fp.read()))
        logger.debug('facebook response raw: %s, query: %s' % (raw, query))
        try:
            response = _parse_json(raw)
            if isinstance(response, dict) and response.get("error"):
                raise GraphAPIError(response["error"]["type"],
                                    response["error"]["message"])
        except AttributeError:
            pass
        finally:
            file.close()
            
        return response
    

class Graph(GraphAPI):
    """ The Base Class for a Facebook Graph. Inherits from the Facebook SDK Class.
    Tries to get a facebook graph using different methods.
    * via access_token: that one is simple
    * via request cookie (access token)
    * via application -> create an accesstoken for an application if requested.
    Needs OAuth2ForCanvasMiddleware to deal with the signed Request and Authentication code.
    Put any graph.get_... calls in a try except structure. An Access Token might be invalid.
    In that case a GraphAPIError is raised.
    
    """
    def __init__(self, app_dict, request=None, access_token=None, 
                 request_token=True, force_refresh=False,
                 prefer_cookie=False):
        super(Graph, self).__init__(access_token)  # self.access_token = access_token
        logger.debug('app_secret: %s' %app_dict['SECRET'])
        logger.debug('app_id: %s' %app_dict['ID'])
        self.HttpRequest = request
        self._me, self._user_id = {}, None
        self.app_dict = app_dict,
        self.app_id, self.app_secret = app_dict['ID'], app_dict['SECRET']
        self.via = 'No token requested'
        self.fb_session = get_session(request)
        if request_token == False:
            return
        if access_token:
            self.via = 'access_token'
        elif request and not force_refresh and self.get_token_from_session():
            self.via = 'session'
        elif request and (self.get_token_from_cookie()) or \
                          (prefer_cookie and self.get_token_from_cookie()):
            self.via = 'cookie'        
        elif self.get_token_from_app():
            self.via = 'application'
        logger.debug('Got %s token via %s for user id: %s.' % (self.type(), self.via, self._user_id))

    def get_token_from_session(self):
        if not self.fb_session.access_token:
            return None
        self._user_id = self.fb_session.user_id
        if self.type(token=self.fb_session.access_token) <> 'user':
            return None
        self.access_token = self.fb_session.access_token
        return self.access_token

    def get_token_from_cookie(self):
        #Client-side authentification writes the signed request into the cookie.
        # Still needs verification from Facebook.
        if not self.HttpRequest.COOKIES.get('fbsr_%i' % int(self.app_id), None):
            return None
        else:
            cookie = self.get_user_from_cookie()

        if cookie and cookie.get('access_token', False):
            self.fb_session.store_token(cookie.get('access_token'))
            self.access_token = cookie.get('access_token')
            self._user_id = cookie.get('uid')
            self.fb_session.user_id = cookie.get('uid')
            return self.access_token
        
        return None        

    def get_token_from_app(self):
        try:
            response = authenticate(app_id=self.app_id, app_secret=self.app_secret, type='client_cred')
        except GraphAPIError:
        # The code is not valid. Maybe the user has uninstalled the app.
            self.HttpRequest.session.flush()
            self.fb_session.store_token(None)
            return None
        
        if 'access_token' in response:
            self.access_token = response['access_token'][0]
        if 'expires' in response:
            token_expires = datetime.now()+timedelta(seconds=int(response['expires'][0]))
        else:
            token_expires = None
            self.fb_session.store_token(self.access_token, token_expires)
        return self.access_token
    
    def get_user_from_cookie(self):
        """ Parses the cookie set by the official Facebook JavaScript SDK. Oauth2 version.
        
        cookies should be a dictionary-like object mapping cookie names to
        cookie values.
    
        If the user is logged in via Facebook, we return a dictionary with the
        keys "uid" and "access_token". The former is the user's Facebook ID,
        and the latter can be used to make authenticated requests to the Graph API.
        If the user is not logged in, we return None.
        
        The cookie contains a signed request containing only the code for authenticating.
        The app has to authenticate with facebook to get the access token.
        """
        sr = self.HttpRequest.COOKIES.get("fbsr_" + self.app_id, "")
        if not sr: return None
        parsed_request = parseSignedRequest(sr, self.app_secret)
        logger.debug('Parsed request from cookie: %s\n' % parsed_request)
        if 'user_id' in parsed_request:
            self._user_id = int(parsed_request['user_id'])
        if 'code' in parsed_request:
            try:
                response = authenticate(code=parsed_request['code'], 
                              app_id=self.app_id, app_secret=self.app_secret)
            except GraphAPIError:
                # The code is not valid. Maybe the user has uninstalled the app.
                self.HttpRequest.session.flush()
                self.fb_session.store_token(None)
                return None
            logger.debug('Authenticate returned: %s' % response)
            if 'access_token' in response:
                self.access_token = response['access_token'][0]
            if 'expires' in response:
                token_expires = datetime.now()+timedelta(seconds=int(response['expires'][0]))
            else:
                token_expires = None

        return {'uid': self._user_id, 'access_token': self.access_token, 'token_expires': token_expires }
        

    def _get_me(self, access_token=False):
        if not access_token:
            if not self.access_token or not self.type()=='user' or not self.fb_session.app_is_authenticated:
                return {}
        
        try:
            me = self.request('me')
        except GraphAPIError as e:
            logger.debug('could not use the accesstoken via %s: %s' % (self.via, e.message))
            self.fb_session.store_token(None)
        else:
            self._user_id = me['id']
            self.fb_session.me = me
            self._me = me  
        #self._me, created = User.objects.get_or_create(id=self._user_id)
        #if created:
        #    self._me.save_from_facebook(me)         
        return self._me

    @property
    def me(self):  # Is now a lazy property.
        if self._me:
            return self._me
        else:
            return self._get_me()

    @property  #DEPRECATED. Kept for compatibility reasons.
    def user(self):
        warnings.warn('The user property is depreceated. Use user_id instead.', DeprecationWarning)
        if self._user_id:
            return self._user_id
        else:
            me = self._get_me(self.access_token)
            return me.get('id', None)

    @property
    def user_id(self):
        if self._user_id:
            return int(self._user_id)
        else:
            me = self._get_me(self.access_token)
            id = me.get('id', None)
            return int(id) if id else None
        
    def type(self, token=None):
        access_token = token or self.access_token
        if not access_token:
            return None
        return 'app' if len(access_token) < 80 else 'user'

    def revoke_auth(self):
        return self.request('me/permissions', post_args={"method": "delete"})
    
    def put_photo(self, image, message='', album_id=None, **kwargs):
        """
        Shortcut for put_media to upload a photo
        """
        return self.put_media(image, message, album_id, mediatype='photos', kwargs=kwargs)

    def put_video(self, image, message='', album_id=None, **kwargs):
        """
        Shortcut for put_media to upload a video
        """
        return self.put_media(image, message, album_id, mediatype='videos', kwargs=kwargs)
    
    def put_media(self, mediafile, message='', album_id=None, mediatype=None, **kwargs):
        """ Uploads a file using multipart/form-data
            mediafile: File like object for the image
            message: Caption for your image
            album_id: On photos, None posts to /me/photos which uses or creates and uses 
                      an album for your application.
            mediatype: one of 'photos' or 'videos' depending on media type
        """
        object = album_id or "me"
        
        opener = urllib2.build_opener(MultipartPostHandler)
        try:
            source = open(mediafile.name, 'rb')
            source.seek(0)
            params = {'source' : source, 'message': message }
            upload = opener.open('https://graph.facebook.com/%s/%s?access_token=%s' % 
                              (object, mediatype, self.access_token), params)
            raw = upload.fp.read()
            upload.close()
        except IOError as e:
            return HttpResponseServerError(e)
        finally:
            source.close()

        logger.debug('facebook response raw (post image): %s' % raw)
    
        try:
            response = _parse_json(raw)
        except:
            raise GraphAPIError('GET_GRAPH', 'Facebook returned bullshit (%s), expected json' % response)
    
        """ in some cases, response is not an object """
        if response:
            if response.get("error"):
                raise GraphAPIError(response["error"]["type"],
                                    response["error"]["message"])
        return response


def get_graph(request=None, app_name=None, app_dict=None, *args, **kwargs):
    """ This is the main factory function that returns a graph class. """
    if not app_dict:
        app_dict = get_app_dict(app_name)
    return Graph(app_dict=app_dict, request=request, *args, **kwargs)

def get_static_graph(app_name=None, app_dict=None, *args, **kwargs):
    """ Explicityl avoid request and user. """
    return get_graph(app_name=app_name, app_dict=app_dict, request=None)

def get_public_graph(app_name=None, app_dict=None, *args, **kwargs):
    """ If you only access public information and don't need an access token. """
    return get_graph(app_name=app_name, app_dict=app_dict, request=None, request_token=False)


    

########NEW FILE########
__FILENAME__ = create_testuser
from django.core.management.base import BaseCommand, CommandError
from facebook.testusers import TestUsers
from facebook import get_static_graph
from optparse import make_option
from django.conf import settings

class Command(BaseCommand):
    args = '[<App Name>], [<App Name>], ...'
    help = 'Generates a new Facebook test user for your app.'
    option_list = BaseCommand.option_list + (
                            make_option('--installed', '-i',
                                action='store_true',
                                dest='installed',
                                default=False,
                                help='User has app installed.'),
                            )
    can_import_settings = True
    
    def handle(self, *args, **options):
        installed = options.get('installed')
        apps = []
        if args:
            for arg in args:
                try:
                    application = settings.FACEBOOK_APPS[arg]
                    apps.append(application)
                except KeyError:
                    raise CommandError('Application %s does not exist' %arg )
        else:
             apps.append(settings.FACEBOOK_APPS.values()[0])
        
        for app in apps:
            graph = get_static_graph(app_dict=app)
            testusers = TestUsers(graph)
            user = testusers.generate_new_test_user(installed=installed)
            self.stdout.write(u'Generated new Testuser: %s\n' % user)
########NEW FILE########
__FILENAME__ = friend
#coding=utf-8
from django.core.management.base import BaseCommand, CommandError
from facebook.testusers import TestUsers
from facebook.modules.profile.user.models import TestUser
from facebook.graph import get_static_graph


class Command(BaseCommand):
    args = '<id1>, [<id2>], [<app name>]'
    help = 'Friend Testusers. Use friend <id1> [<id2="all">]'
    can_import_settings = True
    
    def handle(self, *args, **options):
        if args:
            try:
                arg1 = int(args[0])
            except AttributeError:
                raise CommandError('Arg %s must be integer' %user1 )

            try:
                arg2 = int(args[1])
            except IndexError:
                arg2 = None
            except AttributeError:
                raise CommandError('Arg %s must be integer or empty for all users.' %user2 )  
            try:
                app = args[2]
            except IndexError:
                app = None
        else:
             raise CommandError('Need at least one user_id.')

        graph = get_static_graph(app_dict=app)
        testusers = TestUsers(graph)
        try:
            user1 = TestUser.objects.get(id=int(arg1))
        except TestUser.DoesNotExist:
            raise CommandError('User1 does not exist.')
        if arg2:
            try:
                user2 = TestUser.objects.get(id=int(arg2))
            except TestUser.DoesNotExist:
                raise CommandError('User2 does not exist.')
            response = testusers.make_friends_with(user1, user2)
            self.stdout.write(u' %s\n' % response)
        else:
            users = TestUser.objects.exclude(id=user1.id)
            for user in users:
                response = testusers.make_friends_with(user1, user)
                self.stdout.write(u' %s\n' % response)

########NEW FILE########
__FILENAME__ = testusers
from django.core.management.base import BaseCommand, CommandError
from facebook.testusers import TestUsers
from facebook.modules.profile.user.models import TestUser
from facebook.graph import get_static_graph
from optparse import make_option
from django.conf import settings

class Command(BaseCommand):
    args = '[<App Name>], [<App Name>], ...'
    help = 'Update Testusers for your apps'
    can_import_settings = True
    option_list = BaseCommand.option_list + (
                            make_option('--update', '-u',
                                action='store_true',
                                dest='update',
                                default=False,
                                help='Update Login URL.'),
                            )
    
    def handle(self, *args, **options):
        apps = []
        update = options.get('update')  # Not implemented yet. Always update.
        if args:
            for arg in args:
                try:
                    application = settings.FACEBOOK_APPS[arg]
                    apps.append(application)
                except KeyError:
                    raise CommandError('Application %s does not exist' %arg )
        else:
             apps.append(settings.FACEBOOK_APPS.values()[0])
        
        for app in apps:
            graph = get_static_graph(app_dict=app)
            testusers = TestUsers(graph)
            users = testusers.get_test_users()
            self.stdout.write(u' Testusers: %s\n' % users)
            for user in users:
                installed = '*' if getattr(user, 'access_token', False) else ''
                self.stdout.write(u'%s\t%s %s\n' % (user.id, user.login_url, installed))
########NEW FILE########
__FILENAME__ = middleware
import logging
import urlparse
from django.middleware.csrf import _get_new_csrf_key

from django.utils.datetime_safe import datetime
logger = logging.getLogger(__name__)

import urllib

from django.conf import settings
from django.http import HttpResponseRedirect, HttpResponsePermanentRedirect, HttpResponseForbidden
from django.shortcuts import redirect
from django.utils import simplejson, translation

_parse_json = lambda s: simplejson.loads(s)

from oauth2 import authenticate, parseSignedRequest
from session import get_session
from graph import get_graph
from modules.profile.application.utils import get_app_dict
from facebook.graph import GraphAPIError
from facebook.modules.profile.application.models import Request as AppRequest


class SignedRequestMiddleware(object):
    def process_request(self, request):
        """
        Writes the signed_request into the Session
        """
        fb = get_session(request)
        setattr(request, 'fb_session', fb)
        application = get_app_dict()

        logger.debug('Request Method = %s\n, AccessToken=%s' % (request.method, fb.access_token))

        if 'deauthorize' in request.path:
            logger.debug('deauthorize call, SignedRequestMiddleware returning...')
            return None
            
        if 'feincms' in settings.INSTALLED_APPS:
            # if feincms is installed, try to get the application from the page
            from facebook.feincms.utils import get_application_from_request
            page_app = get_application_from_request(request)
            if application:
                application = get_app_dict(page_app)


        # default POST request from facebook with a signed request
        if 'signed_request' in request.POST:
            try:
                parsed_request = parseSignedRequest(request.POST['signed_request'], application['SECRET'])
            except ValueError:
                return HttpResponseForbidden()
            logger.debug(u'got signed_request from facebook: %s' % parsed_request)
            # Make sure csrfViewMiddleware lets this pass:
            setattr(request, 'csrf_processing_done', True)
            # but still set a cookie for later use
            request.META["CSRF_COOKIE"] = _get_new_csrf_key()
            cookie_is_new = True

            if 'user' in parsed_request:
                language = parsed_request['user']['locale']
                logger.debug('language: %s' %language)
                request.LANGUAGE_CODE = language
                translation.activate(language)
            fb.signed_request = parsed_request
            logger.debug('stored signed_request')
            expires = None
            # rewrite important data
            if 'oauth_token' in parsed_request:
                expires = datetime.fromtimestamp(float(parsed_request['expires']))
                fb.store_token(parsed_request['oauth_token'], expires)
            elif 'access_token' in parsed_request:
                expires = datetime.fromtimestamp(float(parsed_request['expires']))
                fb.store_token(parsed_request['access_token'], expires)
            else:
                #The chance is good that there is already a valid token in the session. Remove it.
                fb.store_token(None)

            if 'user_id' in parsed_request:
                fb.user_id = parsed_request['user_id']

            else:
                logger.debug("Signed Request didn't contain public user info.")
            if expires:
                logger.debug('Signed Request issued at: %s' % datetime.fromtimestamp(float(parsed_request['issued_at'])))


        # auth via callback from facebook
        elif 'code' in request.GET and 'facebook' in request.META.get('HTTP_REFERER', u''):
            authenticate(request.REQUEST['code'], fb, application,
                         request.build_absolute_uri().split('?')[0] \
                            .replace(application['CANVAS-URL'], application['CANVAS-PAGE']))


    def process_response(self, request, response):
        """ p3p headers for allowing cookies in Internet Explorer.
        more infos: http://adamyoung.net/IE-Blocking-iFrame-Cookies
        thanks to frog32 for the hint """

        response['p3p'] = 'CP="IDC DSP COR ADM DEVi TAIi PSA PSD IVAi IVDi CONi HIS OUR IND CNT"'
        return response


class OAuth2ForCanvasMiddleware(SignedRequestMiddleware):
    #  deprecated old name
    def __init__(self, *args, **kwargs):
        import warnings
        warnings.warn('The name OAuth2ForCanvasMiddleware is deprecated. Use SignedRequestMiddleware instead',
            DeprecationWarning, stacklevel=2)
        super(OAuth2ForCanvasMiddleware, self).__init__(*args, **kwargs)


class Redirect2AppDataMiddleware(object):
    """ If app_data is specified, this middleware assumes that app_data is the deep link and redirects to that page
    example: http://www.facebook.com/PAGENAME?sk=app_APP_ID&app_data=/foo/bar/ redirects to /foo/bar/
    /
    IMPLEMENTATION: this middleware should be placed after OAuth2ForCanvasMiddleware, because it needs session['facebook']
    """

    def process_request(self, request):
        try:
            # only execute first time (Facebook will POST the tab with signed_request parameter)
            if request.method == 'POST' and request.POST.has_key('signed_request'):
                app_data = request.session['facebook']['signed_request']['app_data']

                if '//' in app_data or '..' in app_data:
                    logger.warn('Possible defacing in app_data detected: %s' % app_data)
                    return None

                target_url = '%s%s' % (request.META['SCRIPT_NAME'], app_data)
                logger.debug('got target url: %s' % target_url)
                del request.session['facebook']['signed_request']['app_data']
                request.session.modified = True
                return redirect(target_url)
            else:
                return None
        except KeyError:
            return None

class AppRequestMiddleware(object):
    """ Processes App requests. Generates a Request object for every request
        and attaches it to the session.
        The objects are only stored in the database if DEBUG is True, since
        the ids are available in every request from facebook.
        The app_requests need to be deleted manually from facebook.
    """
    def process_request(self, request):
        app_requests = []
        if request.GET.get('request_ids', None):
            fb = get_session(request)
            request_ids = urllib.unquote(request.GET.get('request_ids'))
            request_ids = request_ids.split(',')
            logger.debug('Got app request ids: %s' % request_ids)
            for id in request_ids:
                r, created = AppRequest.objects.get_or_create(id=int(id))
                if settings.DEBUG and created:
                    try:
                        graph = get_graph(request)
                        r.get_from_facebook(graph, save=True)
                    except GraphAPIError:
                        pass
                app_requests.append(r.id)
            if len(app_requests) > 0:
                fb.app_requests = app_requests


class FakeSessionCookieMiddleware(object):
    # from http://djangosnippets.org/snippets/460/
    def process_request(self, request):
        """ tries to get the session variable via HTTP GET if there is no cookie """
        if not request.COOKIES.has_key(settings.SESSION_COOKIE_NAME) \
            and request.REQUEST.has_key(settings.SESSION_COOKIE_NAME):
            request.COOKIES[settings.SESSION_COOKIE_NAME] = \
              request.REQUEST[settings.SESSION_COOKIE_NAME]
            request.COOKIES['fakesession'] = True

    def process_response(self, request, response):
        cookie_name = settings.SESSION_COOKIE_NAME

        if isinstance(response, (HttpResponseRedirect, HttpResponsePermanentRedirect)):
            location = response._headers['location'][1]

            # only append session id if the redirection stays inside (local)
            if not location.find('http') == 0 and not 'admin' in location:
                separator = '&' if '?' in location else '?'
                response._headers['location'] = ('Location' , '%s%s%s=%s' % (location,
                            separator, cookie_name,
                            request.session._get_session_key()))

                logger.debug('FakeSessionCookieMiddleware: changed redirect location from "%s" to "%s" ' % (location, response._headers['location'][1]))
        return response

########NEW FILE########
__FILENAME__ = models
"""
    Dummy model to get old references to the new structured models.
    Needed by south

    possible rewrite with dynamic imports http://www.diveintopython.net/functional_programming/dynamic_import.html
"""

from facebook.fb import *

########NEW FILE########
__FILENAME__ = base
import logging
logger = logging.getLogger(__name__)

from datetime import datetime

from django.db import models
from django.contrib import admin
from django.conf import settings
from django.core.serializers.json import DjangoJSONEncoder
from django.core.exceptions import ObjectDoesNotExist
from django.utils import simplejson as json
from django.utils.translation import ugettext_lazy as _
from django.template.defaultfilters import slugify

from facebook.graph import GraphAPIError, get_graph

from facebook.fields import JSONField


class Base(models.Model):
    # Last Lookup JSON
    _graph = JSONField(blank=True, null=True)

    slug = models.SlugField(unique=True, blank=True, null=True)

    created = models.DateTimeField(auto_now_add=True, default=datetime.now)
    updated = models.DateTimeField(auto_now=True, default=datetime.now)

    class Meta:
        abstract = True
        app_label = 'facebook'

    class Facebook:
        """ The exact function of this class is not clear yet.
            I use it for all kinds of facebook related properties."""

    class Fql:
        """ This class is for creating an adapter to fql objects. """

    @property
    def _id(self):
        """ the facebook object id for inherited functions """
        return self.id

    @property
    def graph_url(self):
        return 'https://graph.facebook.com/%s' % self._id

    @property
    def graph(self):
        return self._graph

    @property
    def cached(self):
        cached_fields = {}
        fieldnames = self._meta.get_all_field_names()
        for field in fieldnames:
            if field.find('_') == 0:
                cached_fields.update({field[1:] : getattr(self, field)})
        return cached_fields

    @property
    def refreshed_graph(self):
        """ updates the object from facebook and returns then the retrieved graph.
        bullet proof to use in templates: if the request times out or the answer is bad, the old graph is returned"""
        response = self.get_from_facebook()
        if response:
            self.save_from_facebook(response)
        return self._graph

    def get_from_facebook(self, graph=None, save=False, args=None):
        """ Updates the local fields with data from facebook. Use this function."""
        if not graph:
            graph = get_graph()
        target = str(self._id)
        if args:
            target = '%s?%s' % (target, args)
        try:
            response = graph.request(target)
        except GraphAPIError:
            logger.warning('Error in GraphAPI')
            if save:
                self.save()
            return None
        else:
            if response and save:
                self.save_from_facebook(response)
            elif save:
                self._graph = {'django-facebook-error' : 'The query returned nothing. Maybe the object is not published, accessible?',
                               'response': response,
                               'access_token': graph.access_token }
                self.save()
            else:
                return response

    def to_django(self, response, graph=None, save_related=True):
        """ update the local model with the response (JSON) from facebook
        big magic in here: it tries to convert the data from facebook in appropriate django fields inclusive foreign keys"""

        self._graph = json.dumps(response, cls=DjangoJSONEncoder)
        for prop, (val) in response.items():
            field = '_%s' % prop
            if prop == 'application':
                try:
                    self._application_id = int(val['id'])
                except (AttributeError, KeyError):
                    pass
                continue
            if prop != 'id' and hasattr(self, field):
                fieldclass = self._meta.get_field(field)
                if isinstance(fieldclass, models.DateTimeField):
                    # reading the facebook datetime string. assuming we're in MET Timezone
                    # TODO: work with real timezones
                    if '+' in val: # ignore timezone for now ...
                        val = val[:-5]
                    setattr(self, field, datetime.strptime(val, "%Y-%m-%dT%H:%M:%S")) #  - timedelta(hours=7)


                elif isinstance(self._meta.get_field(field), models.ForeignKey):
                    # trying to build the ForeignKey and if the foreign Object doesnt exists, create it.
                    # todo: check if the related model is a facebook model (not sure if there are other possible relations ...)
                    related_modelclass = fieldclass.related.parent_model
                    obj, created = related_modelclass.objects.get_or_create(id=val['id'])
                    setattr(self, field, obj)
                    if created and save_related:
                        obj.get_from_facebook(graph=graph, save=True)
                    elif created and not save_related and 'name' in val:
                        obj._name = val['name']
                    elif not created and 'name' in val:
                        # make sure name is defined:
                        obj._name = val['name']
                elif isinstance(fieldclass, models.DateField):
                    # Check for Birthday:
                    setattr(self, field, datetime.strptime(val, "%m/%d/%Y").date())
                else:
                    if val == 'true':
                        val = True
                    if val == 'false':
                        val = False
                    setattr(self, field, val)
            if prop == 'from' and hasattr(self, '_%s_id' % prop):
                setattr(self, '_%s_id' % prop, val['id'])


    def save_from_facebook(self, response, update_slug=False, save_related=True, graph=None):
        self.to_django(response, graph=graph, save_related=save_related)
        if update_slug or not self.slug:
            self.generate_slug()
        self.save()
    save_from_facebook.alters_data = True


    def save_to_facebook(self, target, graph=None):
        if not graph: graph=get_graph()

        args = {}
        cached_fields = [cached for cached in self._meta.get_all_field_names() if cached.find('_') == 0]
        for fieldname in cached_fields:
            fieldclass = self._meta.get_field(fieldname)
            field = getattr(self, fieldname)

            if field:
                if isinstance(fieldclass, models.DateField):
                    args[fieldname[1:]] = field.isoformat()
                elif isinstance(fieldclass, JSONField):
                    args[fieldname[1:]] = json.dumps(field)
                elif isinstance(fieldclass, models.FileField) or isinstance(fieldclass, models.ImageField):
                    raise NotImplementedError  # TODO: use code from image field here
                else:
                    args[fieldname[1:]] = field

        # graph.put_object("me", "feed", message="Hello, world")
        response = graph.put_object(parent_object=str(target), connection_name=self.Facebook.publish, **args)
        return response

    def get_connections(self, connection_name, graph, save=False):
        response = graph.request('%s/%s' % (self._id, connection_name))
        connections = response['data']

        if save:
            self.save_connections(connection_name, connections)
        return connections

    #@transaction.commit_manually
    def save_connections(self, connection_name, connections):
        model_connection_config = None
        connection_config = None
        if hasattr(self, 'Facebook') and hasattr(self.Facebook, 'connections'):
            model_connection_config = self.Facebook.connections

        if connection_name in self._meta.get_all_field_names():
            connecting_field_name = connection_name
        elif connection_name in model_connection_config:
            connection_config = model_connection_config[connection_name]
            connecting_field_name = connection_config['field']
        else:
            raise ObjectDoesNotExist('The Facebook Model %s has no connection configured with the name "%s"' % (self.__class__, connection_name))

        connecting_field = getattr(self, connecting_field_name)
        connected_model = self._meta.get_field(connecting_field_name).rel.to
        connected_model_ids = connected_model.objects.all().values_list('id', flat=True)

        new_connected_model_jsons = [item for item in connections if item['id'] not in connected_model_ids]
        for new_model_json in new_connected_model_jsons:
            new_connected_object = connected_model(id=new_model_json['id'])
            new_connected_object.save_from_facebook(new_model_json)

        connecting_model = connecting_field.through
        for connection_json in connections:

            kwargs = {'%s_id' % connecting_field.source_field_name : self.id,
                      '%s_id' % connecting_field.target_field_name : connection_json['id']}
            connection_object, created = connecting_model.objects.get_or_create(**kwargs)

            if connection_config:
                extra_fields = []
                if 'filter' in connection_config:
                    extra_fields.extend(connection_config['filter'].keys())
                if 'extra_fields' in connection_config:
                    extra_fields.extend(connection_config['extra_fields'])
                for extra_field in extra_fields:
                    setattr(connection_object, extra_field, connection_json[extra_field])
            connection_object.save()
        #transaction.commit()

    def generate_slug(self):
        # overridden by base profile.
        self.slug = slugify(self.id)

    def clean(self, refresh=True, *args, **kwargs):
        ''' On save, update timestamps '''
        if not self.id:
            self.created = datetime.now()
        self.updated = datetime.now()

        # try to generate a slug, but only the first time (because the slug should be more persistent)
        if not self.slug:
            self.generate_slug()

    def __unicode__(self):
        if hasattr(self, '_name') and self._name:
            return u'%s (%s)' % (self._name, self.id)
        else:
            return unicode(self.id)

    def delete(self, facebook=False, graph=None, *args, **kwargs):
        """ Deletes the local model and if facebook is true, also the facebook instance."""
        if facebook:
            if not graph: graph = get_graph()
            graph.delete_object(str(self.id))
        return super(Base, self).delete(*args, **kwargs)
    delete.alters_data = True


# it crashes my python instance on mac os x without proper error message, so may we shoudn't use that handy shortcut
# maybe its only, that the admin should'nt use these computed fields
#    def __getattr__(self, name):
#        """ the cached fields (starting with "_") should be accessible by get-method """
#        if hasattr(self, '_%s' % name):
#            return getattr(self, '_%s' % name)
#        return super(Base, self).__getattr__(name)


def delete_object(modeladmin, request, queryset):
    graph = get_graph(request)
    for obj in queryset:
        obj.delete(graph=graph, facebook=True)
delete_object.short_description = _("Delete selected objects (also on Facebook)")


class AdminBase(admin.ModelAdmin):
    search_fields = ['id']
    actions = [delete_object]
    def save_model(self, request, obj, form, change):
        graph = get_graph(request, force_refresh=True, prefer_cookie=True)
        obj.get_from_facebook(save=True, graph=graph)

    def profile_link(self, obj):
        if obj.facebook_link:
            return '<a href="%s" target="_blank"><img src="%s/picture?type=square" /></a>'\
                 % (obj.facebook_link, obj.graph_url)
        else:
            return '<img src="http://graph.facebook.com/%s/picture" />' % (obj.id)
    profile_link.allow_tags = True

    def change_view(self, request, object_id, extra_context=None):
        fb_context = {
            'facebook_apps': settings.FACEBOOK_APPS.keys(),
            'graph' : get_graph(request, force_refresh=True, prefer_cookie=True)
        }
        return super(AdminBase, self).change_view(request, object_id,
            extra_context=fb_context)
########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from facebook.modules.base import AdminBase

from .models import Score, Achievement


class ScoreAdmin(AdminBase):
    list_display = ('_user', '_score')
    readonly_fields = ('_user', '_score')
    search_fields = ('_user',)
admin.site.register(Score, ScoreAdmin)


class AchievementAdmin(AdminBase):
    list_display = ('id', '_title', 'points', '_url')
admin.site.register(Achievement, AchievementAdmin)

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as _

from facebook.fields import JSONField
from facebook.modules.base import Base
from facebook.modules.profile.user.models import User

import logging
logger = logging.getLogger(__name__)

class Score(Base):
    """ The score object stores a game score for a user. It is automatically
        posted in the user's activity feed.
        To get or set scores use the app access token.
    """
    _user = models.ForeignKey(User)
    _score = models.PositiveIntegerField(_('Score'))
    _application = JSONField(_('Application'), blank=True, null=True)
    _type = models.CharField(max_length=100, blank=True, null=True)

    class Meta(Base.Meta):
        verbose_name = _('Score')
        verbose_name_plural = _('Scores')
        ordering = ['-_score']

    class Facebook:
        access_token_type = 'app'
        type = 'score'
        publish = 'scores'

    def __unicode__(self):
        return u'%s, %s' % (self._user, self._score)

    def save(self,  graph=None, *args, **kwargs):
        """ save to facebook if graph is passed. """
        super(Score, self).save(*args, **kwargs)

        if graph:
            if self._score < 0:
                raise AttributeError, 'The score must be an integer >= 0.'
            response = graph.put_object(parent_object=str(self._user.id),
                                connection_name=self.Facebook.publish,
                                score=self._score)
            logger.debug(response)
            return response


    def delete(self, app_name=None, *args, **kwargs):
        graph = get_static_graph(app_name=app_name)
        graph.request('%s/scores' % self.user.id, post_args={'method': 'delete'})
        super(Score, self).delete(*args, **kwargs)


class Achievement(Base):
    """
    https://developers.facebook.com/docs/achievements/
    """
    id = models.BigIntegerField(primary_key=True)
    points = models.SmallIntegerField(_('Points'), blank=True, null=True)

    _type = models.CharField(max_length=50, default='games.achievement')
    _title = models.CharField(_('Title'), max_length=255, blank=True, null=True)
    _url = models.URLField(_('url'), blank=True, null=True)
    _description = models.CharField(_('Description'), max_length=255, blank=True, null=True)
    _image = JSONField(_('image'), blank=True)
    _data = JSONField(_('data'), blank=True)
    _updated_time = models.DateTimeField(_('updated_time'), auto_now=True)
    _context = JSONField(_('context'), blank=True)

    class Meta(Base.Meta):
        verbose_name = _('Achievement')
        verbose_name_plural = _('Achievements')

    class Facebook:
        type = 'games.achievement'

    def __unicode__(self):
        return unicode(self._title)

########NEW FILE########
__FILENAME__ = views
#coding=utf-8
""" Views for game-related task such as getting and settings scores and achievments. """

from facebook.modules.profile.user.models import User
from facebook.modules.profile.application.utils import get_app_dict
from .models import Score

from facebook.graph import get_static_graph

def get_user_score(user_id, graph):
    """If the user has granted your app with the user_games_activity permission then 
       this api will give you scores for all apps for that user. 
       Otherwise it will give you scores only for your app.
       The friends_games_activity permission will enable you to access scores 
       for users' friends for all apps
    """
    
    scores = graph.request('%s/scores' % user_id )
    return scores['data']


def get_user_and_friends_scores(user_id, graph, app_name=None):
    """This returns the list of scores for the user and their friends who have a uthorized the app.
       You can use this api to create leaderboard for the user and their friends.
       The graph must contain the user access_token!
    """
    application = get_app_dict(app_name)
    
    scores = graph.request('%s/scores' % application['ID'])
    
    return scores['data']  
        

def set_user_score(user_id, score, app_name=None, facebook=True):
    graph = get_static_graph(app_name=app_name)
    user_id = int(user_id)
    if int(score) < 0:
        raise AttributeError, 'Score < 0.'
    else:
        user, created = User.objects.get_or_create(id=user_id)
        if created:
            user.get_from_facebook(save=True, graph=graph)
    obj, created = Score.objects.get_or_create(_user_id=user_id, defaults={'_score':0})
    if not created and int(score) < obj._score:
        return 'score lower than current score. Not updated.'
    else:
        obj._score = int(score)
        obj._user = user
        response = obj.save(graph=graph)
        return response
    

def delete_user_score(user_id, app_name=None):
    """ This deletes the user's score for this app. """
    graph = get_static_graph(app_name=app_name)
    
    return graph.request('%s/scores' % user_id, post_args={'method': 'delete'})


def delete_all_scores(app_name=None):
    """ This deletes all scores for this app. """
    graph = get_static_graph(app_name=app_name)
    application = get_app_dict(app_name)
    
    return graph.request('%s/scores' % application['ID'], post_args={'method': 'delete'})
########NEW FILE########
__FILENAME__ = admin
# -*- coding: utf-8 -*-
from django.contrib import admin
from django.conf import settings
from django.utils.translation import ugettext_lazy as _
from models import Like

class LikeAdmin(admin.ModelAdmin):
    list_display = ('user', '_name', '_category')
    search_fields = ('user', '_name')
    ordering = ['user', '_created_time']
    
admin.site.register(Like, LikeAdmin)

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-
""" To use any of those models, add facebook.connections to your INSTALLED_APPS. """

from datetime import datetime

from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes import generic

from facebook.modules.profile.user.models import User
from facebook.modules.profile.page.models import Page

        
class Like(models.Model):
    """ The users likes. Uses a generic foreign key to Page so it doesn't need
        a Page instance but you still get all the ORM goodness.
    """
    user = models.ForeignKey(User)
    _name = models.CharField(_('Name'), max_length=255, blank=True)
    _category = models.CharField(_('Name'), max_length=255, blank=True)
    # Using the contenttype framework because of database integrity.
    # object type is usually profile or photo.
    object_type = models.ForeignKey(ContentType, blank=True, null=True)
    object_id = models.BigIntegerField(_('Liked page id'), blank=True, null=True)
    content_object = generic.GenericForeignKey('object_type', 'object_id')
    # This field exists in the facebook table. But does not seem to be serverd by the graph api.
    post_id = models.CharField(_('Post id'), max_length=255, blank=True, null=True)
    _created_time = models.DateTimeField(blank=True, null=True)
    
    class Meta:
        verbose_name = _('Profile Like')
        verbose_name_plural = _('Profile Likes')
        app_label = 'facebook'
    
    def __unicode__(self):
        return u'%s likes %s' % (self.user, self._name)
    
    @property
    def _id(self):
        return self.content_id
    
    @_id.setter
    def _id(self, value):
        self.content_type = ContentType.objects.get_for_model(Page)
        self.content_id = value
    
    @property
    def created_time(self):
        return self._created_time
    
    @created_time.setter
    def created_time(self, val):
        if '+' in val: # ignore timezone for now ...
                        val = val[:-5]
        self._created_time = datetime.strptime(val, "%Y-%m-%dT%H:%M:%S")

    
class URLLike(models.Model):
    """ This model can be used when querying the url_like table. """
    user = models.ForeignKey(User)
    url = models.URLField(_('URL'), max_length=500, verify_exists=False, blank=True, null=True)
    
    class Meta:
        verbose_name = _('URL Like')
        verbose_name_plural = _('URL Likes')
        app_label = 'facebook'
        
    def __unicode__(self):
        return unicode(self.url)
    


########NEW FILE########
__FILENAME__ = views
from django.http import Http404, HttpResponse

import facebook
from models import Like

from datetime import datetime


def get_likes(graph, fb_user):
    # TODO: Also query URL Likes.
    if graph.type == 'app':
        raise AttributeError, 'Need user graph for get_likes.'
    try:
        response = graph.request('me/likes')
    except facebook.GraphAPIError as e:
        return HttpResponse('no permission: %s' % e)
    
    likes = response['data']
    for entry in likes:
        val = entry.get('created_time', None)
        if val:
            if '+' in val: # ignore timezone for now ...
                val = val[:-5]
            created_time = datetime.strptime(val, "%Y-%m-%dT%H:%M:%S")
        else:
            created_time = datetime.now()
        like, c = Like.objects.get_or_create(user=fb_user, content_id=int(entry.get('id',0)))
        
        like._name = entry.get('name', '')
        like._category = entry.get('category', '')
        like._id = entry.get('id', None )
        like._created_time = created_time
        like.save()
    return True
########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes import generic
from facebook.modules.base import Base

class Milestone(Base):
    id = models.BigIntegerField(primary_key=True)
    # from is a Generic FK to User or Page.
    _from = generic.GenericForeignKey('__profile_type', '__profile_id')
    __profile_id = models.BigIntegerField()
    __profile_type = models.ForeignKey(ContentType)
    _created_time = models.DateTimeField(blank=True, null=True)
    _updated_time = models.DateTimeField(blank=True, null=True)
    _start_time = models.DateTimeField(blank=True, null=True)
    _end_time = models.DateTimeField(blank=True, null=True)
    _title = models.CharField(max_lenght=255, blank=True, null=True)
    _description = models.TextField()
    
    class Meta:
        ordering = ['-_start_time']
        get_latest_by = '_start_time'
        verbose_name = _('Milestone')
        verbose_name_plural = _('Milestones')
    
    def __unicode__(self):
        return self.title
########NEW FILE########
__FILENAME__ = admin
from facebook.modules.base import AdminBase

class PostAdmin(AdminBase):
    def picture_link(self, obj):
            return '<img src="%s" />' % (obj._picture)
    picture_link.allow_tags = True
    picture_link.short_description = u'picture'

    def icon_link(self, obj):
            return '<img src="%s" alt="%s" width="16" height="16"/>' % (obj._icon, obj._type)
    icon_link.allow_tags = True
    icon_link.short_description = u'icon'

    list_display = ('icon_link', 'id', '_from', '_message', '_type', 'picture_link', '_created_time', '_link')
    list_display_links = ('id',)
    readonly_fields = ('_graph', '_application', '_to', '_from', '_message', '_picture', '_story',
                       '_properties', '_actions', '_privacy', '_likes', '_comments', '_targeting')
    date_hierarchy = '_updated_time'
    list_filter = ('_type',)


########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes import generic

from facebook.fields import JSONField
from facebook.modules.base import Base
from facebook.modules.profile.user.models import User
from facebook.utils import warn_gone

class PostBase(Base):
    POST_TYPES = (('status', _('Status message')),
              ('link', _('Link')),
              ('photo', _('Photo')),
              ('video', _('Video')),
              ('note', _('Note')),
              )

    id = models.CharField(_('id'), max_length=40, primary_key=True)
    _from = models.ForeignKey(User, blank=True, null=True, verbose_name=_('from'),
                              related_name='%(app_label)s_%(class)s_posts_sent')
    # This field does not appear in the graph.
    _to = JSONField(_('to'), blank=True, null=True)  # could be M2M but nees JSON processor.
    _message = models.TextField(_('message'), blank=True)
    _message_tags = JSONField(_('message_tags'), blank=True, null=True, editable=False)
    _story = models.TextField(_('story'), blank=True,
        help_text="Text automatically generated by Facebook.")
    _picture = models.URLField(_('picture url'), max_length=255, blank=True)
    _link = models.URLField(_('link url'), max_length=255, blank=True)
    _name = models.CharField(_('link name'), max_length=255, blank=True)
    _caption = models.CharField(_('link caption'), max_length=255, blank=True)
    _description = models.TextField(_('link description'),null=True, blank=True)
    _source = models.URLField(_('movie source'), max_length=255, blank=True)
    _properties = JSONField(_('movie properties'), blank=True, null=True)
    _icon = models.URLField(_('icon'), blank=True)
    _actions = JSONField(_('actions'), blank=True, null=True)
    _privacy = JSONField(_('privacy'), blank=True, null=True)
    _type = models.CharField(_('type'), max_length=20, choices=POST_TYPES, default='status')
    _likes = JSONField(_('likes'), blank=True, null=True)
    _place = JSONField(_('place'), blank=True, null=True)
    _story_tags = JSONField(_('story tags'), blank=True, null=True, editable=False)
    _comments = JSONField(_('comments'), blank=True, null=True) #denormalized
    _object_id = models.BigIntegerField(_('object id'), blank=True, null=True)  #generic FK to image or movie
    _application = JSONField(_('application'), blank=True, null=True)
    _created_time = models.DateTimeField(_('created time'), blank=True, null=True)
    _updated_time = models.DateTimeField(_('updated time'), blank=True, null=True)
    _is_published = models.NullBooleanField(_('is published'), blank=True, null=True)

    class Meta(Base.Meta):
        abstract=True
        ordering = ['-_created_time']

    class Facebook:
        publish = 'feed'
        connections = {'likes': None, 'comments': None }  # TODO: Create models for reference
        arguments = ['message', 'picture', 'link', 'name', 'caption', 'description', 'source', 'actions']


    def __unicode__(self):
        return u'%s, %s' % (self.id, self._message[:50])

    # Deal with changes from Facebook
    @property
    def _targeting(self):
        warn_gone('Post._targeting')
        return {}

    @property
    def _subject(self):
        warn_gone('Post._subject')
        return 'This field is deprecated and needs to be removed from your code.'

    # Note has no type attribute.
    def guess_type(self):
        if self._type:
            return self._type
        if self._subject:
            self._type = 'note'
        elif self._story and self._picture:
            self._type = 'photo'
        elif not self._type:
            self._type = 'status'

    def get_from_facebook(self, graph=None, save=False, *args, **kwargs):
        super(PostBase, self).get_from_facebook(graph=graph, save=save, *args, **kwargs)
        self.guess_type()
        if save:
            self.save()

    def get_post_uid(self):
        ids = self.id.split('_')
        return ids[-1]

    @property
    def comments(self):
        return self._comments.get('data', [])

    @property
    def to(self):
        if hasattr(self._to, 'data'):
            return self._to.get('data')[0]
        else:
            return {'id': int(self.id.split('_')[0])}

    @property
    def actions(self):
        return dict((a['name'], a) for a in self._actions)

    @property
    def like_link(self):
        if self._link:
            return self._link
        elif self.actions.get('Like', False):
            return self.actions['Like']['link']
        elif self._type == 'note':
            return u'http://www.facebook.com/note.php?note_id=%s' % self.id
        else:
            try:
                return self.get_absolute_url()
            except AttributeError:
                return ''

    def status(self):
        if self._graph and 'id' in self._graph:
            return u'published'
        elif not self._graph:
            return u'not published'
        else:
            return u'error: %s' % self._graph


class Post(PostBase):

    class Meta(PostBase.Meta):
        app_label = 'facebook'
        verbose_name = _('Post')
        verbose_name_plural = _('Posts')
        abstract = False


class PagePost(models.Model):
    """ This is a generic intermediate model to attach posts to Pages or Profiles
    """
    post = models.ForeignKey(Post)
    content_type = models.ForeignKey(ContentType)
    object_id = models.BigIntegerField()
    to = generic.GenericForeignKey()
    created = models.DateTimeField(auto_now_add=True)

    class Meta:
        app_label = 'facebook'
        unique_together = (('post', 'content_type', 'object_id'),)

    def __unicode__(self):
        return u'%s to %s' % (self.post, self.to)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from facebook.modules.base import AdminBase

from .models import Photo

class PhotoAdmin(AdminBase):
    list_display = ('_id', '_name', 'like_count', '_from')
    readonly_fields = ('fb_id', '_name', '_tags', '_graph', '_from', '_like_count',
                       '_icon', '_picture', '_source', '_height', '_width', '_link', '_position')

admin.site.register(Photo, PhotoAdmin)
########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-
from django.db import models
from facebook.modules.base import Base
from facebook.modules.profile.user.models import User
from facebook.modules.connections.likes.models import Like
from facebook.graph import get_graph
from django.utils.translation import ugettext_lazy as _


class Tag(models.Model):
    to = models.ForeignKey(User)
    x = models.PositiveSmallIntegerField(_('x'), blank=True, null=True,
        help_text='x coordinate of tag, as a percentage offset from the left edge of the picture')
    y = models.PositiveSmallIntegerField(_('y'), blank=True, null=True,
        help_text='y coordinate of tag, as a percentage offset from the top edge of the picture ')
    
    class Meta:
        verbose_name = _('Tag')
        verbose_name_plural = _('Tags')
        app_label = 'facebook'
    
    def __unicode__(self):
        return u'Tag %s' % self.to


class Photo(Base):
    fb_id = models.BigIntegerField(unique=True, null=True, blank=True)
    image = models.ImageField(upload_to='uploads/')
    message = models.TextField(_('message'), blank=True)

    # Cached Facebook Graph fields for db lookup
    _name = models.CharField(max_length=100, blank=True, null=True,
                help_text='The user provided caption given to this photo - do not include advertising in this field')
    _from = models.ForeignKey(User, blank=True, null=True, related_name='photos_uploaded',
                help_text='The profile (user or page) that posted this photo')
    _icon = models.URLField(_('icon'), blank=True, null=True,
                help_text='The icon that Facebook displays when photos are published to the Feed')
    _picture = models.URLField(_('picture'), blank=True, null=True,
                        help_text='The thumbnail-sized source of the photo')
    _source = models.URLField(_('source'), blank=True, null=True,
                        help_text='The full-sized source of the photo')
    _height = models.PositiveSmallIntegerField(_('height'), blank=True, null=True,
                        help_text='The height of the photo in pixels')
    _width = models.PositiveSmallIntegerField(_('width'), blank=True, null=True,
                        help_text='The width of the photo in pixels')
    _link = models.URLField(_('link'), blank=True, null=True,
                        help_text='A link to the photo on Facebook')
    _position = models.PositiveSmallIntegerField(_('position'), blank=True, null=True,
                        help_text='The position of this photo in the album')

    # TODO: Make sure ContentType is Photo.
    #_likes = models.ManyToManyField(Like, related_name='photo_likes')
    _like_count = models.PositiveIntegerField(blank=True, null=True)
    
    _tags = models.ManyToManyField(Tag, related_name='photo_tags')

    class Meta:
        abstract = False
        app_label = 'facebook'

    @property
    def like_count(self):
        self._like_count = self._likes.all().count()
        self.save()
        return self._like_count

    @property
    def name(self):
        return self._name

    @property
    def from_object(self):
        return self._from_id

    @property
    def facebook_link(self):
        return 'http://www.facebook.com/photo.php?fbid=%s' % self.id

    def send_to_facebook(self, object='me', save=False, graph=None, message=None, app_name=None):

        if not graph:
            graph = get_graph(app_name=app_name)
        if not message:
            message = self.message

        response = post_image(graph.access_token, self.image.file, message, object=object)

        if save:
            self.fb_id = response['id']
            self.save()
        return response['id']


########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from facebook.modules.base import AdminBase
from facebook.modules.profile.application.models import Request

class RequestAdmin(AdminBase):
    list_display = ('id', '_application_id', '_to', '_from', '_data', '_message', '_created_time')
    readonly_fields = ('_graph', '_application_id', '_to', '_from', '_data', '_message', '_created_time')

admin.site.register(Request, RequestAdmin)
########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-
from django.db import models
from django.conf import settings
try:
    from django.utils import timezone
except ImportError:
    #can only be used for timezone.now()
    from datetime import datetime as timezone

from datetime import timedelta

from facebook.modules.base import Base
from facebook.modules.profile.user.models import User
from facebook.graph import get_graph, GraphAPIError


FACEBOOK_APPS_CHOICE = tuple((v['ID'], unicode(k)) for k,v in settings.FACEBOOK_APPS.items())

class RequestManager(models.Manager):
    def get_query_set(self):
        killerdate = timezone.now()-timedelta(days=14)
        return super(RequestManager, self).get_query_set().filter(created__gte=killerdate)


class Request(Base):
    """ App request model. Must be deleted manually by the app."""
    id = models.BigIntegerField(primary_key=True, unique=True)
    # Cached Facebook Graph fields for db lookup
    _application_id = models.BigIntegerField('Application', choices=FACEBOOK_APPS_CHOICE, blank=True, null=True)
    _to = models.ForeignKey(User, blank=True, null=True, related_name='request_to_set')
    _from = models.ForeignKey(User, blank=True, null=True, related_name='request_from_set')
    _data = models.TextField(blank=True, null=True)
    _message = models.TextField(blank=True, null=True)
    _created_time = models.DateTimeField(blank=True, null=True)

    objects = RequestManager()

    class Meta:
        app_label = 'facebook'
        abstract = False

    def __unicode__(self):
        try:
            return u'%s from %s: to %s: data: %s' % (self.id, self._from_id, self._to_id, self._data)
        except models.FieldDoesNotExist:
            return u'%s' % self.id

    def save(self, *args, **kwargs):
        # _to should not be stored in the database because it is ambiguous
        to = self._to
        self._to = None
        super(Request, self).save(*args, **kwargs)
        self._to = to

    def delete(self, facebook=True, graph=None, to=None, app_name=None, *args, **kwargs):
        """
        One app request can have several to users. So it has to be deleted
        individually for every user. Either by passing the current user as to
        argument or a user graph when calling the delete method.

        :param facebook: Deprecated. Deletes request on Facebook as well.
        :param graph: Graph instance. User Graph required if to is not given.
        :param to: Request to. Usually the current user.
        :param app_name:
        :param args:
        :param kwargs:
        :return: Nothing
        """
        if to or self._to:
            if not graph:
                graph = get_graph(request=None, app_name=app_name)
            return graph.delete_object(u'%s_%s' % (self.id, to.id if to else self._to_id))
        elif graph and graph.type == 'user':
            return graph.delete_object(str(self.id))
        else:
            return super(Request, self).delete(facebook=False, *args, **kwargs)


    def get_from_facebook(self, graph=None, save=settings.DEBUG, quick=False):
        """ Only saves the request to the db if DEBUG is True."""
        if quick and self._from:
            # _to is not defined.
            self._to = None
            return self
        return super(Request, self).get_from_facebook(graph=graph, save=True)

########NEW FILE########
__FILENAME__ = utils
from django.conf import settings

def get_app_dict(application=None):
    if not application:
        if getattr(settings, 'FACEBOOK_DEFAULT_APPLICATION', False):
            application = settings.FACEBOOK_APPS[settings.FACEBOOK_DEFAULT_APPLICATION]
        else:
            application = settings.FACEBOOK_APPS.values()[0]
    else:
        application = settings.FACEBOOK_APPS[application]
    return application
########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from facebook.modules.base import AdminBase

from .models import Event


class EventAdmin(AdminBase):
    list_display = ('id', 'profile_link', '_owner', '_name', '_description', '_start_time', '_end_time', '_location', '_venue', '_privacy')
    readonly_fields = ('_graph', '_owner', '_name', '_description', '_start_time', '_end_time', '_location', '_venue', '_privacy', '_updated_time')
    list_display_links = ('id',)

admin.site.register(Event, EventAdmin)
########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

from django.db import models
from facebook.modules.profile.models import Profile
from facebook.modules.profile.user.models import User as FbUser
from facebook.graph import get_graph
from facebook.fql import get_FQL
from django.db.models import Q
from datetime import datetime, timedelta, date
from django.utils.translation import ugettext_lazy as _

from facebook.fields import JSONField

class EventManager(models.Manager):
    def upcoming(self):
        """ returns all upcoming and ongoing events """
        today = date.today()
        if datetime.now().hour < 6:
            today = today-timedelta(days=1)
        
        return self.filter(Q(_start_time__gte=today) | Q(_end_time__gte=today))
    
    def past(self):
        """ returns all past events """
        today = date.today()
        if datetime.now().hour < 6:
            today = today-timedelta(days=1)
        
        return self.filter(Q(_start_time__lt=today) & Q(_end_time__lt=today))

class Event(Profile):
    # Cached Facebook Graph fields for db lookup
    _owner = JSONField(blank=True, null=True)
   
    _description = models.TextField(blank=True, null=True)
    _start_time = models.DateTimeField(blank=True, null=True)
    _end_time = models.DateTimeField(blank=True, null=True)
    _location = models.CharField(max_length=500, blank=True, null=True)
    _venue = JSONField(blank=True, null=True)
    _privacy = models.CharField(max_length=10, blank=True, null=True, choices=(('OPEN', 'OPEN'), ('CLOSED', 'CLOSED'), ('SECRET', 'SECRET')))
    _updated_time = models.DateTimeField(blank=True, null=True)
    
    invited = models.ManyToManyField(FbUser, through='EventUser')

    objects = EventManager()

    @property
    def facebook_link(self):
        return 'http://www.facebook.com/event.php?eid=%s' % self.id
    
    def get_description(self):
        return self._description
    
    def get_name(self):
        return self._name
    
    class Meta:
        ordering = ('_start_time',)
        app_label = 'facebook'
    
    class Facebook:  # TODO: refactoring here.
        connections = {'attending' : {'field' : 'invited', 'filter' : {'rsvp_status' : 'attending'}},
                       'maybe' : {'field' : 'invited', 'filter' : {'rsvp_status' : 'unsure'}},
                       'declined' : {'field' : 'invited', 'filter' : {'rsvp_status' : 'declined'}},
                       'noreply' : {'field' : 'invited', 'filter' : {'rsvp_status' : 'not_replied'}},
                       'invited' : {'field' : 'invited', 'extra_fields' : ['rsvp_status',]},}
        publish = 'events'
        arguments = ['name', 'start_time', 'end_time']
        type = 'event'
    
    def save_rsvp_status(self, user_id, status):
        user, created = FbUser.objects.get_or_create(id=user_id)
        if created:
            user.save()
        connection, created = self.invited.through.objects.get_or_create(user=user, event=self)
        connection.status = status
        connection.save()
        return connection
    
    def update_rsvp_status(self, user_id, access_token=None):
        if not access_token: access_token=get_graph().access_token
        response = get_FQL('SELECT rsvp_status FROM event_member WHERE uid=%s AND eid=%s' % (user_id, self.id),
                           access_token=access_token)
        if len(response):
            self.save_rsvp_status(user_id, response[0]['rsvp_status'])
            return response[0]['rsvp_status']
        else:
            return 'not invited'
    
    def respond(self, graph, status='attending'):
        fb_response = graph.put_object(str(self.id), status)
        self.save_rsvp_status(graph.user_id, status)
        return fb_response


class EventUser(models.Model):
    event = models.ForeignKey(Event)
    user = models.ForeignKey(FbUser)
    rsvp_status = models.CharField(max_length=10, default="attending", 
                              choices=(('attending', _('attending')),
                                       ('unsure', _('unsure')),
                                       ('declined', _('declined')),
                                       ('not_replied', _('not_replied'))))
    
    class Meta:
        unique_together = [('event', 'user'),]
        app_label = 'facebook'


########NEW FILE########
__FILENAME__ = models
from django.contrib.contenttypes import generic
from django.db import models
from django.template.defaultfilters import slugify
from django.utils.translation import ugettext_lazy as _
from django.conf import settings

from facebook.modules.base import Base, AdminBase


class Profile(Base):
    """ Base Class for user, group, page, event and application. """
    id = models.BigIntegerField(primary_key=True, unique=True, help_text=_('The ID is the facebook page ID'))
    _name = models.CharField(max_length=200, blank=True, null=True)
    _username = models.CharField(max_length=200, blank=True, unique=True, null=True)
    _link = models.URLField(max_length=255, verify_exists=False, blank=True, null=True)
    _picture = models.URLField(max_length=500, blank=True, null=True, verify_exists=False, help_text=_('Cached picture of the page'))
    _pic_square = models.URLField(max_length=500, blank=True, null=True, verify_exists=False, editable=False)
    _pic_small = models.URLField(max_length=500, blank=True, null=True, verify_exists=False, editable=False)
    _pic_large = models.URLField(max_length=500, blank=True, null=True, verify_exists=False, editable=False)
    _pic_crop = models.URLField(max_length=500, blank=True, null=True, verify_exists=False, editable=False)

    # get all posts for the selected profile
    #    posts = [p.post for p in page.post_throughs.select_related('post').all()]
    if 'facebook.modules.connections.post' in settings.INSTALLED_APPS:
        post_throughs = generic.GenericRelation('PagePost',
                            related_name="%(app_label)s_%(class)s_related")

    class Meta(Base.Meta):
        abstract = True
        app_label = 'facebook'

    def clean(self):
        super(Profile, self).clean()
        # Turn empty String into None for Uniqueness check.
        self._username = self._username or None


    def generate_slug(self):
        # username is unique on facebook, but not every object has a username (ie. user have to make themself for pages and profiles)
        if self._username:
            if len(self._username) >= 50:
                self.slug = '%s_%s' % (slugify(self._username)[:29], self.id)
            self.slug = slugify(self._username)[:50]
        elif self._name:
            self.slug = slugify('%s-%s' % (self._name[:29], self.id))
        else:
            self.slug = slugify(self.id)


class ProfileAdmin(AdminBase):

    def pic_img(self, obj):
        return '<img src="%s" height="75" />' % obj._picture if obj._picture else ''
    pic_img.allow_tags = True
    pic_img.short_description = _('Picture')

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.utils.translation import ugettext_lazy as _
from facebook.graph import get_graph, GraphAPIError

import logging, datetime
from facebook.modules.profile.application.utils import get_app_dict
from facebook.utils import do_exchange_token

logger = logging.getLogger(__name__)

from django.conf import settings
from facebook.modules.profile.models import ProfileAdmin

from .models import Page

class PageAdmin(ProfileAdmin):
    def has_access(self, obj):
        if obj.updated + datetime.timedelta(days=60) < datetime.datetime.now():
            # Token expired unless the page still has a never-expiring token.
            return False
        return not (obj._access_token == None or obj._access_token == '')
    has_access.short_description = _('Access Token')
    has_access.boolean = True

    def token_expires_in(self, obj):
        if not obj._access_token_expires:
            return ''
        expires_in = (obj._access_token_expires - datetime.datetime.now()).days
        if expires_in > 10:
            return _('%s days' % expires_in)
        elif expires_in < 0:
            return _('<span style="color:red;font-weight:bold;">expired</span>')
        else:
            return _('<span style="color:orange;font-weight:bold;">%s days</span>' % expires_in)

    token_expires_in.short_description = _('expires in')
    token_expires_in.allow_tags = True

    def insight_link(self, obj):
        if '?' in obj.facebook_link:
            return u'<a href="%s&sk=page_insights" target="_blank">%s</a>' % (obj.facebook_link, obj._name)
        else:
            return u'<a href="%s?sk=page_insights" target="_blank">%s</a>' % (obj.facebook_link, obj._name)
    insight_link.allow_tags = True
    insight_link.short_description = _('Name')


    list_display = ('id', 'profile_link', 'slug', 'insight_link', 'pic_img', '_likes', 'has_access', 'token_expires_in')
    readonly_fields = ('_name', '_picture', '_likes', '_graph', '_link', '_location', '_phone',
                       '_checkins', '_website', '_talking_about_count','_username', '_category')
    actions = ['get_page_access_token']

    def get_page_access_token(self, request, queryset):
        default_post_app = getattr(settings, 'DEFAULT_POST_APP', None)
        graph = get_graph(request, app_name=default_post_app, force_refresh=True, prefer_cookie=True)
        app_dict = get_app_dict(default_post_app)
        token_exchange = do_exchange_token(app_dict, graph.access_token)
        logger.debug('exchanged token: %s' % token_exchange)
        token_expires_in = datetime.timedelta(minutes=60)
        if 'access_token' in token_exchange:
            graph.access_token = token_exchange['access_token']
            token_expires_in = datetime.timedelta(days=60)
        try:
            response = graph.request('me/accounts/')
        except GraphAPIError as e:
            self.message_user(request, 'There was an error: %s' % e.message )
            return False
        #logger.debug(response)
        token_expires_in = datetime.datetime.now() + token_expires_in
        if response and response.get('data', False):
            data = response['data']
            message = {'count': 0, 'message': u''}
            accounts = {}
            for account in data:
                accounts[int(account['id'])] = account
            for page in queryset:
                if accounts.get(page._id, None):
                    if accounts[page._id].get('access_token', False):
                        queryset.filter(id=page._id).update(_access_token=accounts[page._id]['access_token'],
                                                            _access_token_expires=token_expires_in)
                        message['message'] = u'%sSet access token for page %s\n' % (message['message'], page._name)
                    else:
                        message['message'] = u'%sDid not get access token for page %s\n' % (message['message'], page._name)
                else:
                    message['message'] = u'%sYou are not admin for page %s\n' % (message['message'], page._name)
            self.message_user(request, '%s\n' % message['message'])
        else:
            self.message_user(request, 'There was an error: %s' % response )

    get_page_access_token.short_description = _('Get an access token for the selected page(s)')

admin.site.register(Page, PageAdmin)
########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-
import logging
logger = logging.getLogger(__name__)

from django.db import models
from django.utils.translation import ugettext_lazy as _
from facebook.fields import JSONField
from facebook.graph import get_graph, GraphAPIError

from facebook.modules.profile.models import Profile

class PageBase(Profile):
    # Cached Facebook Graph fields for db lookup
    _likes = models.IntegerField(blank=True, null=True, help_text=_('Cached fancount of the page'))
    _access_token = models.CharField(max_length=255, blank=True, null=True)
    _access_token_expires = models.DateTimeField(blank=True, null=True)
    _category = models.CharField(_('category'), max_length=255, blank=True, null=True)
    _location = JSONField(_('location'), blank=True, null=True)
    _phone = models.CharField(_('phone'), max_length=255, blank=True, null=True)
    _checkins = models.IntegerField(_('checkins'), blank=True, null=True)
    _website = models.URLField(_('website'), blank=True, null=True)
    _talking_about_count = models.PositiveIntegerField(_('talking about count'), blank=True, null=True)

    class Meta(Profile.Meta):
        abstract = True
        verbose_name = _('Page')
        verbose_name_plural = _('Pages')
        app_label = 'facebook'

    @property
    def name(self):
        return self._name

    @property
    def picture(self):
        return self._picture

    @property
    def fan_count(self):
        return self._likes

    @property
    def facebook_link(self):
        return self._link

    def __unicode__(self):
        return '%s (%s)' % (self._name, self.id)

    def get_from_facebook(self, graph=None, save=False, args=None):
        """ Updates the local fields with data from facebook. Use this function."""
        if not graph:
            graph = get_graph()
        target = str(self._id)
        if args:
            target = '%s?%s' % (target, args)
        try:
            response = graph.request(target)
        except GraphAPIError:
            logger.warning('Error in GraphAPI')
            if save:
                self.save()
            return None
        else:
            if response and save:
                if 'logo_url' in response.keys():
                    self._pic_square = response['logo_url']
                    self._picture = response['logo_url']
                self.save_from_facebook(response)

            elif save:
                self._graph = {'django-facebook-error' : 'The query returned nothing. Maybe the object is not published, accessible?',
                               'response': response,
                               'access_token': graph.access_token }
                self.save()
            else:
                return response
    
    class Facebook:
        public_fields = ['id', 'name', 'picture', 'link', 'category', 'likes', 'location', 'phone', 'checkins', 
                         'website', 'username', 'founded', 'products']
        member_fields = []
        connections = ['feed', 'posts', 'tagged', 'statuses', 'links', 'notes', 'photos', 'albums', 'events', 'videos']
        type = 'page'


class Page(PageBase):
    class Meta(PageBase.Meta):
        abstract = False
########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from facebook.modules.base import AdminBase

from .models import User

class UserAdmin(AdminBase):
    list_display = ('id', 'profile_link', '_email', 'access_token', 'user', '_name', 'created', 'updated',)
    readonly_fields = ('friends', '_name', '_locale', '_username', '_first_name', '_last_name', '_link', '_birthday', '_email', '_location', '_gender', '_graph')
    search_fields = ('id', '_name')


admin.site.register(User, UserAdmin)

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-
import warnings

from django.contrib.auth.models import User as DjangoUser
from django.db import models
from django.utils.translation import ugettext_lazy as _

from facebook.modules.profile.models import Profile
from facebook.graph import get_graph


class UserBase(Profile):
    access_token = models.CharField(max_length=250, blank=True, null=True)
    user = models.OneToOneField(DjangoUser, blank=True, null=True, related_name='facebook%(class)s')

    # Cached Facebook Graph fields for db lookup
    _first_name = models.CharField(max_length=50, blank=True, null=True)
    _last_name = models.CharField(max_length=50, blank=True, null=True)
    _birthday = models.DateField(blank=True, null=True)
    _email = models.EmailField(blank=True, null=True, max_length=100)
    _location = models.CharField(max_length=70, blank=True, null=True)
    _gender = models.CharField(max_length=10, blank=True, null=True)
    _locale = models.CharField(max_length=6, blank=True, null=True)
    _timezone = models.IntegerField(blank=True, null=True)
    _verified = models.BooleanField(blank=True)

    friends = models.ManyToManyField('self')
    
    class Meta(Profile.Meta):
        app_label = 'facebook'
        abstract=True
    
    class Facebook:
        public_fields = ['id', 'name', 'first_name', 'last_name', 'gender', 'locale', 'username']
        member_fields = ['link', 'third_party_id', 'updated_time', 'verified']
        type = 'user'

    def __unicode__(self):
        return u'%s (%s)' % (self._name, self.id)


    def get_friends(self, graph=None, save=False):
        graph = graph or get_graph(access_token=self.access_token)
        response = graph.request('%s/friends' % self.id)
        friends = response['data']

        if save:
            self.save_friends(friends)

        return friends

    def save_friends(self, friends):
        for jsonfriend in friends:
            friend, created = User.objects.get_or_create(id=jsonfriend['id'])
            if created:
                friend._name = jsonfriend['name']
                friend.save()
            all_friends = list(self.friends.all().values_list('id'));
            if not friend in all_friends:
                self.friends.add(friend)
        self.save()
        return friends

    @property
    def facebook_link(self):
        return self._link

    def save_from_facebook(self, response, update_slug=False):
        if 'access_token' in response.iterkeys():
            self.access_token = response['access_token']
        super(UserBase, self).save_from_facebook(response, update_slug)
    
    def picture_url(self, type='large'):
        if type not in ['large', 'small', 'square', 'crop']:
            raise AttributeError, 'type must be one of large, small, crop or square.'
        cached = getattr(self, '_pic_%s' % type, None)
        if cached:
            return cached
        else:
            return u'https://graph.facebook.com/%s/picture?type=%s' % (self.id, type)

    @property
    def square_picture_url(self):
        return self.picture_url(type='square')
    
    @property
    def large_picture_url(self):
        return self.picture_url(type='large')
            
    def get_absolute_url(self):
        if self._link:
            return self._link
        else:
            return 'http://www.facebook.com/profile.php?id=%s' % self.id


class User(UserBase):
    class Meta(UserBase.Meta):
        abstract = False
        app_label = 'facebook'


# This code is for backwards compability only. Will be removed with verison 1.1.
def user__facebookuser(self):
    warnings.warn('Stop using `user`, use `facebookuser` instead.',
    DeprecationWarning, stacklevel=2)
    return self.facebookuser
DjangoUser.user = property(user__facebookuser)


class TestUser(UserBase):
    login_url = models.URLField('Login URL', blank=True, max_length=160)
    password = models.CharField('Password', max_length=30, blank=True)
    belongs_to = models.BigIntegerField(_('Belongs to'), help_text=_('The app the testuser has been created with.'))
    
    def __unicode__(self):
        return 'Testuser: %s (%s)' % (self._email, self.id)
    
    def set_password(self, graph, new_password):
        if graph.request('%s' % self.id, None, {'password': new_password, 'access_token': graph.access_token }):
            self.password = new_password
            self.save()
    
    def save_from_facebook(self, response, update_slug=False, app_id=None):
        if app_id:
            self.belongs_to = int(app_id)
        if 'login_url' in response.keys():
            self.login_url = response['login_url']
        if 'password' in response.keys():
            self.password = response['password']
        if 'access_token' in response.keys():
            self.access_token = response['access_token']
        self.id = response['id']
        super(TestUser, self).save_from_facebook(response, update_slug)
        
    class Meta(UserBase.Meta):
        verbose_name = _('Test user')
        verbose_name_plural = _('Test users')

########NEW FILE########
__FILENAME__ = oauth2
# -*- coding: utf-8 -*-
import logging
logger = logging.getLogger(__name__)

import hmac
import hashlib
import urllib
import base64
import urlparse

# Find a JSON parser
try:
    import simplejson as json
except ImportError:
    try:
        from django.utils import simplejson as json
    except ImportError:
        import json

_parse_json = lambda s: json.loads(s)


def base64_url_decode(s):
    return base64.urlsafe_b64decode(s.encode("utf-8") + '=' * (4 - len(s) % 4))


def parseSignedRequest(signed_request, secret=None, application=None):
    """
    adapted from from
    http://web-phpproxy.appspot.com/687474703A2F2F7061737469652E6F72672F31303536363332
    https://github.com/facebook/python-sdk/commit/cb43c5a4a4b8c3e66264ed5508871b175f9c515f
    """

    if not secret:
        from facebook.modules.profile.application.utils import get_app_dict
        app_dict = get_app_dict(application)
        secret = app_dict['SECRET']
    
    try:
        (encoded_sig, payload) = signed_request.split(".", 2)
    except IndexError:
        raise ValueError("Signed Request is malformed")
    
    sig = base64_url_decode(encoded_sig)
    data = json.loads(base64_url_decode(payload))

    if data.get("algorithm").upper() != "HMAC-SHA256":
        raise ValueError("'signed_request' is using an unknown algorithm")
    else:
        expected_sig = hmac.new(secret, msg=payload, digestmod=hashlib.sha256).digest()

    if sig != expected_sig:
        raise ValueError("'signed_request' signature mismatch")
    
    return data


def authenticate(app_id, app_secret, code=None, redirect_uri="", type=None):
    from facebook.graph import GraphAPIError
    
    args = {'client_id': app_id,
            'client_secret': app_secret,
            'redirect_uri': redirect_uri
            }
    if code:  args['code'] =  code.replace("\"", "")
    if type:  args['type'] = 'client_cred'
    
    file = urllib.urlopen("https://graph.facebook.com/oauth/access_token?" + urllib.urlencode(args))
    raw = file.read()
    file.close()
    logger.debug('Got Graph Response: %s' % raw)
    # The raw response is a urlparsed string (access_token=xxxxxxxx&expires=6295).
    # We convert it to a dict.
    response = urlparse.parse_qs(raw)
    
    if response == {}:
        # An error occured: The response is a JSON string containing the error.
        try:
            response = _parse_json(raw)
        except ValueError:
            raise GraphAPIError('AUTHENTICATION ERROR', 'Facebook returned this: %s. Expected access token.' % raw)
        else:
            if isinstance(response, dict) and response.get("error"):
                # The Code is invalid. Maybe the user logged out of Facebook or removed the app.
                raise GraphAPIError(response["error"]["type"],
                                             response["error"]["message"])
            else:
                raise GraphAPIError('AUTHENTICATION ERROR', 'Facebook returned json (%s), expected access_token' % response)

    logger.debug('Authentication Graph Response: %s' % response)
    return response
########NEW FILE########
__FILENAME__ = session
# -*- coding: utf-8 -*-
import logging
logger = logging.getLogger(__name__)

from datetime import datetime, timedelta


class SessionBase(object):    
    def __init__(self):
        self.app_is_authenticated, self.access_token, self.signed_request = True, None, None
        self.token_expires, self.user_id, self.me = None, None, None
        self.app_requests = []  # TODO: Put this in its own class.
    
    def store_token(self, *args, **kwargs):
        raise AttributeError('Not Implemented')
    
    def modified(self):
        raise AttributeError('Not Implemented')
    
    class Meta:
        abstract=True

    
class FBSession(SessionBase):
    """ This class uses Properties and setter. Requires Python 2.6. """    
    def __init__(self, request):
        if request == None:
            raise AttributeError('Need Request to Access the Session.')
        if hasattr(request, 'fb_session'):
            raise AttributeError('Session already exists in Request.')
        self.fb_session = self.get_fb_session(request)
        self.request = request
    
    def get_fb_session(self, request):
        fb = request.session.get('facebook', None)
        logger.debug('found facebook session')
        if not fb:
            logger.debug('did not find a facebook session. Creating a new one.')
            request.session.update({'facebook': {'app_is_authenticated': True}})
            request.session.modified = True
            fb = request.session['facebook']
        return fb
    
    def modified(self, who='unknown'):
        self.request.session.modified = True
        logger.debug('Session modified by %s: %s' % (who, self.fb_session))

    
    @property
    def app_is_authenticated(self):
        """This is a cached value to store if the app is authenticated. """
        return self.fb_session['app_is_authenticated'] \
               if self.fb_session.get('app_is_authenticated', False) else True  # Assuming True.
    
    @app_is_authenticated.setter
    def app_is_authenticated(self, status):
        if status in [True, False]:
            self.fb_session['app_is_authenticated'] = status
        else:
            raise TypeError('FBSESSION', 'Authenticated takes True or False, not %s.' %status)
        
    @property
    def access_token(self):
        """ Returns the current access token or None. """
        logger.debug('token expires: %s, type: %s' % (self.token_expires, type(self.token_expires)))
        if self.token_expires and self.token_expires < datetime.now():  # TODO: Check if this is executed on every request.
            logger.debug('not returning expired access_token. %s' % self.fb_session.get('access_token'))
            return None
        else:
            return self.fb_session.get('access_token', None)
    
    @access_token.setter
    def access_token(self, token):
        self.fb_session['access_token'] = token
        self.modified('access_token.setter')
    
    @property
    def token_expires(self):
        return self.fb_session.get('access_token_expires', None)
    
    # expires can be datetime or None (i.e. an Application token has no known expiration date.
    # or a sting containing seconds to expiration.
    @token_expires.setter
    def token_expires(self, expires):
        if isinstance(expires, datetime) or isinstance(expires, type(None)):
            logger.debug('token expires: %s' % expires)
        elif isinstance(expires, basestring):
            seconds = int(expires)
            logger.debug('token expires in %s seconds.' % seconds)
            expires = datetime.now()+timedelta(seconds=seconds)
        else:
            raise TypeError('Token Expires requires a datetime instance or None. Got %s instead.' %type(expires))        
        self.fb_session['access_token_expires'] = expires
        self.modified('token_expires setter')  # Is usually used with token setter.

    def store_token(self, token=None, expires=None):
        if token == None:
            self._clear_token()
        else:
            self.access_token = token
            if not expires:
                expires=datetime.now() + timedelta(hours=1)
            # Check if there is already a longer lasting token:
            if isinstance(self.token_expires, datetime) and self.token_expires > expires:
                pass
            else:
                self.token_expires = expires

    def _clear_token(self):
        self.access_token = None
        self.user_id = None
        self.app_is_authenticated = False      

    
    @property
    def user_id(self):
        user_id = self.fb_session.get('user_id')
        return int(user_id) if user_id else None
    
    @user_id.setter
    def user_id(self, id):
        if id == None:
            self.fb_session['user_id'] = None
            self.fb_session['me'] = None
            self.app_is_authenticated = False
        else:
            self.fb_session['user_id'] = id
            self.app_is_authenticated = True
        self.modified('user_id.setter')
    
    @property
    def me(self):
        return self.fb_session.get('me', None)
    
    @me.setter
    def me(self, value):
        self.fb_session['me'] = value
        self.app_is_authenticated = True
        self.modified('me.setter')
    
    @property
    def signed_request(self):
        return self.fb_session.get('signed_request', None)
    
    @signed_request.setter
    def signed_request(self, parsed_request):
        self.fb_session['signed_request'] = parsed_request
        self.app_is_authenticated = True if getattr(parsed_request, 'user_id', False) else False
        self.modified('signed_request.setter')
    
    @property
    def user(self):
        raise AttributeError('The user attribute was confusing.\n Use signded_request["user"] instead.' )
    
    @user.setter
    def user(self, user):
        raise AttributeError('The user attribute was confusing.\n Use signded_request["user"] instead.' )

    @property
    def app_requests(self):
        ar = self.fb_session.get('app_requests', None)
        return ar.split(',') if ar else []
    
    @app_requests.setter
    def app_requests(self, item):
        from facebook.modules.profile.application.models import Request
        
        if isinstance(item, list):
            self.fb_session['app_requests'] = ','.join(str(i) for i in item)
        elif isinstance(item, Request):
            ar = self.fb_session.get('app_requests', []).split(',')
            ar.append(str(item.id))
            self.fb_session['app_requests'] = ','.join(ar)
        elif isinstance(item, (basestring, int)):
            ar = self.fb_session.get('app_requests', []).split(',')
            ar.append(str(item))
            self.fb_session['app_requests'] = ','.join(ar)
        else:
            raise AttributeError, 'App_Requests must be a list, Request, str or int, not %s' %type(item)
        self.modified('app_requests.setter')
        
class FBSessionNoOp(SessionBase):
    def __init__(self):
        super(FBSessionNoOp, self).__init__()
        logger.debug('Using Dummy Session Interface')
        self._modified = False
    
    def store_token(self, token=None, expires=None):
        self.access_token = token
        self.token_expires = expires
    
    def modified(self, who='Unknown', *args, **kwargs):
        self._modified = True
        logger.debug('%s is trying to modify a dummy session.' % who )
        return False
    

def get_session(request=None):
    if not request:
        return FBSessionNoOp()
    else:
        if hasattr(request, 'fb_session'):
            return request.fb_session
        else:
            return FBSession(request) 

########NEW FILE########
__FILENAME__ = fb_ga_tags
#coding=utf-8
from django import template
from django.utils.safestring import mark_safe
from django.template.defaultfilters import escapejs
register = template.Library()

@register.simple_tag(takes_context=True)
def user_var(context):
    """ Adds the user informations from the FB signed request to Google Analytics.
        You need to put this tag before the _trackPageview call.
    """
    request = context.get('request')
    try:
        age = request.session['facebook']['signed_request']['user']['age']
        page = request.session['facebook']['signed_request']['page']['id']
        locale = request.session['facebook']['signed_request']['user']['locale']
    except (AttributeError, KeyError):
        return mark_safe('<!-- no signed request -->')
    
    response = "_gaq.push(['_setCustomVar', 1, 'Age', '%s', 2]);\n" % escapejs(age)
    response += "_gaq.push(['_setCustomVar', 2, 'fb-page', '%s', 1]);\n " % page
    response += "_gaq.push(['_setCustomVar', 3, 'fb-locale', '%s', 1]);\n" % locale
    return mark_safe(response)
########NEW FILE########
__FILENAME__ = fb_tags
#coding=utf-8
import re
from datetime import datetime, time

from django import template
from django.conf import settings
from django.template.defaultfilters import escapejs, capfirst, stringfilter
register = template.Library()
from django.utils.safestring import mark_safe

from facebook.modules.profile.user.models import TestUser
from facebook.modules.profile.application.utils import get_app_dict
from facebook.graph import get_static_graph, get_graph
from facebook.testusers import TestUsers


@register.simple_tag
def fb_app_settings(app_id=None):
    """ Returns a link to the user's app settings page for the current app. """
    if not settings.DEBUG:
        return ''
    else:
        if not app_id:
            app = get_app_dict()
            app_id = app['ID']
        link = '<a id="fb_app_settings_link" href="http://www.facebook.com/settings/?tab=applications&app_id=%s" target="_blank">X</a>' % app_id
        return mark_safe(link)
    
@register.simple_tag
def fb_api_key(app_name=None):
    app = get_app_dict(app_name)
    return app['API-KEY']

@register.simple_tag
def fb_app_id(app_name=None):
    app = get_app_dict(app_name)
    return app['ID']

@register.simple_tag
def fb_canvas_page(app_name=None):
    app = get_app_dict(app_name)
    return app['CANVAS-PAGE']

@register.simple_tag
def fb_domain(app_name=None):
    app = get_app_dict(app_name)
    return app['DOMAIN']

@register.simple_tag
def fb_app_namespace(app_name=None):
    app = get_app_dict(app_name)
    return app['NAMESPACE']

# TODO: Check request.is_secure on server. Local always True.
@register.simple_tag
def fb_canvas_url(request, app_name=None):
    app = get_app_dict(app_name)
    if request.is_secure and False:  # FIXME: For some reason always returns true.
        return app['SECURE-CANVAS-URL']
    else:
        return app['CANVAS-URL']

@register.simple_tag
def fb_redirect_url(app_name=None):
    app = get_app_dict(app_name)
    return app['REDIRECT-URL']

@register.simple_tag
def fb_first_app():
    app = settings.FACEBOOK_APPS.keys()
    return capfirst(app[0])

@register.inclusion_tag('facebook/includes/testuser_choice.html')
def fb_testuser_menu(app_name=None):
    graph = get_static_graph(app_name)
    tu = TestUsers(graph)
    testusers = tu.get_test_users()
    return {'users': testusers}

@register.simple_tag
def messages(message, user):
    return mark_safe(message.render(user))

@register.simple_tag
def messages_escaped(message, user):
    return mark_safe(escapejs(message.render(user)))

@register.simple_tag
def access_token(request, app_name=None):
    graph = get_graph(request, app_name=app_name)
    return mark_safe(graph.access_token)
    
@register.simple_tag(takes_context=True)
def query_page_fan(context, request):
    try:    
        is_fan = request.session['facebook']['signed_request']['page']['liked']
    except (AttributeError, KeyError):
        is_fan = False
    context['is_fan'] = is_fan
    return ''

@register.filter
@stringfilter
def post_uid(value):
    ids = value.split('_')
    return ids[-1]

@register.filter
@stringfilter
def parse_date(value):
    return datetime.strptime(value, '%Y-%m-%dT%H:%M:%S+0000')  # 2011-07-13T10:24:18+0000

########NEW FILE########
__FILENAME__ = settings
from django.conf import settings
import sys, os

FACEBOOK_APPS = {
    'FB_Unittest' : {
            'ID': '218940591464663',
            'SECRET': 'd4ba1920446f44d557fc6518c475d9b7',
            'CANVAS-PAGE': 'http://apps.facebook.com/fhunittest/',
            'CANVAS-URL': 'http://fht.li/unittest/',
            'SECURE-CANVAS-URL': 'https://fht.li/unittest/',
            'REDIRECT-URL': 'http://apps.facebook.com/fhunittest/',
            'DOMAIN': 'fht.li'
    }
}

TESTUSERS = [
    {   'first_name': "Margaret",
        'gender': "female",
        'id': 100003005576619,
        'last_name': "Okelolawitz",
        'link': "http://www.facebook.com/profile.php?id=100003005576619",
        'locale': "de_DE",
        'middle_name': "Amckeegffai",
        'name': "Margaret Amckeegffai Okelolawitz",
        'updated_time': "2011-10-07T15:13:11+0000"
    },
    {   'first_name': "Nancy",
        'gender': "female",
        'id': 100002343838234,
        'last_name': "Carrieroberg",
        'link': "http://www.facebook.com/profile.php?id=100002343838234",
        'locale': "de_DE",
        'middle_name': "Ambcdchchbcd",
        'name': "Nancy Ambcdchchbcd Carrieroberg",
        'updated_time': "2011-05-06T22:12:59+0000",
    }, 
]
########NEW FILE########
__FILENAME__ = users
#coding: utf-8
""" This test checks user login and authorization. 
    It requires Selenium and Firefox.

    Get Selenium here: http://seleniumhq.org/
    sudo pip install selenium
    Read the docs: http://readthedocs.org/docs/selenium-python/en/latest/
"""

from django.test import TestCase
from facebook.utils import *
from facebook.testusers import TestUsers
from django.utils import unittest
from django.test.client import RequestFactory
from django.contrib.sessions.tests import DatabaseSessionTests

from facebook.tests import settings

from selenium import webdriver
from selenium.webdriver.common.keys import Keys

TEST_APP = 'FB_Unittest'

class UserTestCase(DatabaseSessionTests):
    
    def firefox(self, testuser):
        driver = webdriver.Firefox()
        driver.get(testuser.login_url)
        # Sometimes it needs two calls to the URL.
        if driver.title <> testuser._name:
            driver.get(testuser.login_url)
        return driver
        
    
    def setUp(self):
        super(UserTestCase, self).setUp()
        self.factory = RequestFactory()
        self.app = settings.FACEBOOK_APPS[TEST_APP]
        self.testusers = getattr(settings, 'TESTUSERS')
        
    def test_testusers_settings(self):
        """ Make sure the test user settings are valid."""
        self.assertIsInstance(self.testusers, list)
        self.assertGreaterEqual(len(self.testusers), 2 )
        self.assertIsInstance(self.testusers[0], dict)
        self.assertIsInstance(self.testusers[1], dict)
    
    def test_testusers(self):
        """ The test users are still the ones in the settings."""
        graph = get_static_graph(app_dict=self.app)
        testusers = TestUsers(graph)
        users = testusers.get_test_users()
        self.assertEqual(users[0]._name, self.testusers[0]['name'])
        self.assertEqual(int(users[0].id), self.testusers[0]['id'])
        self.assertEqual(users[1]._name, self.testusers[1]['name'])
        self.assertEqual(int(users[1].id), self.testusers[1]['id'])
        
        user1 = users[0]
        self.driver1 = self.firefox(user1)
        # Check if the Facebook login was successfull:
        self.assertEqual(self.driver1.title, user1._name)
        
        # Try a login:
        self.driver1.get('https://www.facebook.com/dialog/oauth?client_id=%s&redirect_uri=%s' % (self.app['ID'], 
                                                                        self.app['REDIRECT-URL']))
        self.assertEqual(self.driver1.title, u'Unittest auf Facebook')
        self.driver1.get('%scanvas/' % self.app['CANVAS-PAGE'])
        
        self.driver1.close()
        """
        user2 = users[1]
        driver2 = webdriver.Firefox()
        driver2.get(user2.login_url)
        if driver2.title <> user2._name:
            driver2.get(user2.login_url)
        self.assertEqual(driver.title, user1._name)
        if driver2.title <> user2._name:
            return # No point of testing further.
        """
        
    
    
        
        
########NEW FILE########
__FILENAME__ = utils
from django.test import TestCase
from facebook.utils import *
from django.utils import unittest
from django.test.client import RequestFactory
from django.contrib.sessions.tests import DatabaseSessionTests

from facebook.tests import settings

class UtilsTestCase(DatabaseSessionTests):
    
    def setUp(self):
        super(UtilsTestCase, self).setUp()
        self.factory = RequestFactory()
        self.app = settings.FACEBOOK_APPS.values()[0]

    def test_settings(self):
        fb = self.app
        self.assertEqual(fb['ID'], '218940591464663')
        self.assertEqual(fb['SECRET'], 'd4ba1920446f44d557fc6518c475d9b7')
        self.assertEqual(fb['CANVAS-PAGE'], 'http://apps.facebook.com/fhunittest/')
        self.assertEqual(fb['CANVAS-URL'], 'http://fht.li/unittest/')
        self.assertEqual(fb['SECURE-CANVAS-URL'], 'https://fht.li/unittest/')
        self.assertEqual(fb['REDIRECT-URL'], 'http://apps.facebook.com/fhunittest/')
        self.assertEqual(fb['DOMAIN'], 'fht.li')
    
    def test_get_graph(self):
        request = self.factory.get('/')
        setattr(request, 'session', self.session)
        graph = get_graph(request, app_dict=self.app)  # Have to pass app name. 
        self.assertTrue(isinstance(graph, Graph))
        self.assertTrue(isinstance(graph.fb_session, FBSession))
        self.assertTrue(isinstance(graph.access_token, basestring))
        self.assertEqual(graph.via, 'application')
        self.assertIsNone(graph.get_token_from_session())
        self.assertIsNone(graph.get_token_from_cookie())
        self.assertTrue(graph.fb_session.app_is_authenticated)
        self.assertIsNone(graph.me)
        self.assertEqual(graph.app_id, '218940591464663')
        # self.assertFalse(graph.fb_session.app_is_authenticated)  Possible Thread-Safe error
        
    def test_static_graph(self):
        graph = get_static_graph(app_dict=self.app)
        self.assertIsNone(graph.HttpRequest)
        self.assertTrue(isinstance(graph.fb_session, FBSessionNoOp))
        self.assertTrue(isinstance(graph.access_token, basestring))
        self.assertEqual(graph.via, 'application')
        self.assertIsNone(graph.me)

    def test_public_graph(self):
        graph = get_public_graph(app_dict=self.app)
        self.assertIsNone(graph.HttpRequest)
        self.assertTrue(isinstance(graph.fb_session, FBSessionNoOp))
        self.assertIsNone(graph.access_token)
        self.assertEqual(graph.via, 'No token requested')
        self.assertIsNone(graph.me)

        
        
        
        
########NEW FILE########
__FILENAME__ = testusers
#coding=utf-8
from facebook.modules.profile.user.models import TestUser
from facebook.graph import GraphAPIError
from django.utils import simplejson


class TestUsers(object):
    def __init__(self, graph):
        self.graph = graph
    
    # Friend requests need user access token
    def update_access_token(self, access_token):
        self.graph.access_token = access_token

    def generate_new_test_user(self, installed=True, permissions=[]):
        response = self.graph.request('%s/accounts/test-users' % self.graph.app_id, None, 
                                      {'installed': installed, 'permissions': ', '.join(permissions) })
        user = TestUser()
        user.save_from_facebook(response, app_id=self.graph.app_id)
        return user

    def get_test_users(self, login_url_required=False):
        """ users is a dict array with the fields access_token, login_url and id. """
        response = self.graph.request('%s/accounts/test-users' % self.graph.app_id, 
                                      {'access_token': self.graph.access_token })['data'] 
        users=[]
        for item in response:
            # Facebook sometimes does not deliver a login-url. Ignore those users.
            try:
                testuser, created = TestUser.objects.get_or_create(id=item['id'], 
                                defaults={'id': item['id'], 'login_url': item['login_url'],
                                          'belongs_to': self.graph.app_id,
                                          '_graph': simplejson.dumps(item) })
                if created:
                    testuser.save_from_facebook(item, app_id=self.graph.app_id)
                else:
                    testuser.login_url = item['login_url']
                    testuser._graph = simplejson.dumps(item)
                testuser.save()
                users.append(testuser)
            except KeyError:
                pass
                
            
        # cleanup db
        users_ids=[int(i['id']) for i in response]
        testusers = TestUser.objects.select_related(depth=1).filter(belongs_to=self.graph.app_id)
        for user in testusers:
            if user.id not in users_ids:
                user.delete()
            elif not user._name and user.access_token:
                self.graph.access_token = user.access_token
                response = user.get_from_facebook(graph=self.graph, save=True)
        return testusers
    
    def friend_request(self, user1, user2):
        graph = self.graph
        graph.access_token = user1.access_token
        return graph.request('%s/friends/%s' % (user1.id, user2.id), None, {})
    
    def make_friends_with(self, user1, user2):
        response = []
        self.update_access_token(user1.access_token)
        try:
            response.append(self.friend_request(user1, user2))
        except GraphAPIError as error:  #No access token if the user is not authorized.
            response.append(error)
        self.update_access_token(user2.access_token)
        try:
            response.append(self.friend_request(user2, user1))
        except GraphAPIError as error:
            response.append(error)
        return response
    
    def unfriend(self, user1, user2):
        pass

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import input
from django.views.generic.base import TemplateView
from django.views.decorators.csrf import csrf_exempt


""" Use this instead of direct_to_template """
go_to_template = csrf_exempt(TemplateView.as_view)


urlpatterns = patterns('',
    url(r'^deauthorize/(?:(?P<app_name>[A-Za-z0-9_-]+)/)?$', 'facebook.views.deauthorize_and_delete', name='deauthorize'),
    url(r'^fql/$', 'facebook.views.fql_console', name="fql_console"),
    url(r'^log_error/$', 'facebook.views.log_error', name="log_error"),
    url(r'^channel.html$', 'facebook.views.channel', name='channel'),
    url(r'^exchange_token/$', 'facebook.views.exchange_token', name='fb_exchange_token'),
    url(r'^redirect/$', 'facebook.views.parent_redirect', name='fb-redirect'),
    url('^internalredirect/$', 'facebook.views.internal_redirect', name='fb-internal-redirect'),
    url(r'^(?P<action>[a-z-]+)/$', input, name="input"),
)
########NEW FILE########
__FILENAME__ = utils
import logging
import sys

logger = logging.getLogger(__name__)

import urlparse

import re
import time

import urllib
import urllib2
import mimetools, mimetypes
import os, stat
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO
import warnings

from django.conf import settings
from django.contrib.sites.models import Site
from django.shortcuts import redirect


def redirect_GET_session(to, request, permanent=False):
    response = redirect(to, permanent)
    cookie_name = settings.SESSION_COOKIE_NAME

    if cookie_name in request.COOKIES:
        location = response._headers['location'][1]
        separator = '&' if '?' in location else '?'
        response._headers['location'] = ('Location', '%s%s%s=%s' % (location,
                        separator, cookie_name,
                        request.COOKIES.get(cookie_name, '')))
        return response
    else:
        return response
    

def totimestamp(instance):
    """ converts a timeinstance to a timestamp requiered by the Graph API"""
    return time.mktime(instance.timetuple())
    

def validate_redirect(url):
    """ validates the redirect url """
    
    valid = re.compile(r'^[a-zA-Z0-9_?=&.:/-]+$')
    
    if not valid.match(url):
        return False
        
    domain = urlparse.urlparse(url).netloc
    if domain.find('www.') == 0:
        domain = domain[4:]
    if Site.objects.filter(domain=domain):
        return True
    else:
        for APP in getattr(settings, 'FACEBOOK_APPS', []):
            parsed_canvas = urlparse.urlparse(settings.FACEBOOK_APPS[APP]['CANVAS-PAGE'])
            if 0 < url.find(parsed_canvas.netloc + parsed_canvas.path ) <= 8:
                logger.info(parsed_canvas)
                return True
    return False


def warn_gone(item):
    warnings.warn('%s has been removed by Facebook' %item, DeprecationWarning, stacklevel=2)

def warn_deprecated(item):
    warnings.warn('%s has been deprecated by Facebook and will be removed soon.' %item,
        DeprecationWarning, stacklevel=2)



# 02/2006 Will Holcomb <wholcomb@gmail.com>
# 7/26/07 Slightly modified by Brian Schneider  
# in order to support unicode files ( multipart_encode function )

class Callable:
    def __init__(self, anycallable):
        self.__call__ = anycallable

# Controls how sequences are uncoded. If true, elements may be given multiple values by
#  assigning a sequence.
doseq = 1

class MultipartPostHandler(urllib2.BaseHandler):
    handler_order = urllib2.HTTPHandler.handler_order - 10 # needs to run first

    def http_request(self, request):
        data = request.get_data()
        if data is not None and type(data) != str:
            v_files = []
            v_vars = []
            try:
                for(key, value) in data.items():
                    if type(value) == file:
                        v_files.append((key, value))
                    else:
                        v_vars.append((key, value))
            except TypeError:
                systype, value, traceback = sys.exc_info()
                raise TypeError, "not a valid non-string sequence or mapping object", traceback

            if len(v_files) == 0:
                data = urllib.urlencode(v_vars, doseq)
            else:
                boundary, data = self.multipart_encode(v_vars, v_files)

                contenttype = 'multipart/form-data; boundary=%s' % boundary
                #if(request.has_header('Content-Type')
                #   and request.get_header('Content-Type').find('multipart/form-data') != 0):
                #    print "Replacing %s with %s" % (request.get_header('content-type'), 'multipart/form-data')
                request.add_unredirected_header('Content-Type', contenttype)

            request.add_data(data)
        
        return request

    def multipart_encode(vars, files, boundary = None, buf = None):
        if boundary is None:
            boundary = mimetools.choose_boundary()
        if buf is None:
            buf = StringIO()
        for(key, value) in vars:
            buf.write('--%s\r\n' % boundary)
            buf.write('Content-Disposition: form-data; name="%s"' % key)
            buf.write('\r\n\r\n' + value + '\r\n')
        for(key, fd) in files:
            file_size = os.fstat(fd.fileno())[stat.ST_SIZE]
            filename = fd.name.split('/')[-1]
            contenttype = mimetypes.guess_type(filename)[0] or 'application/octet-stream'
            buf.write('--%s\r\n' % boundary)
            buf.write('Content-Disposition: form-data; name="%s"; filename="%s"\r\n' % (key, filename))
            buf.write('Content-Type: %s\r\n' % contenttype)
            # buffer += 'Content-Length: %s\r\n' % file_size
            fd.seek(0)
            buf.write('\r\n' + fd.read() + '\r\n')
        buf.write('--' + boundary + '--\r\n\r\n')
        buf = buf.getvalue()
        return boundary, buf
    multipart_encode = Callable(multipart_encode)

    https_request = http_request

def do_exchange_token(app_dict, exchange_token):
    """ Exchanges the access token for a 60 day token.
    """
    args = {'client_id' : app_dict['ID'],
                'client_secret': app_dict['SECRET'],
                'grant_type': 'fb_exchange_token',
                'fb_exchange_token': exchange_token
                }
    file = urllib.urlopen("https://graph.facebook.com/oauth/access_token",
            urllib.urlencode(args))
    raw = file.read()
    file.close()
    response = urlparse.parse_qs(raw)
    # values are returned as lists.
    response = dict((k, v[0]) for k,v in response.items())
    return response
########NEW FILE########
__FILENAME__ = views
import sys, logging, urllib2
from datetime import datetime, timedelta

from django.conf import settings
from django.contrib import admin
from django.contrib.admin.util import get_deleted_objects
from django.db import router
from django.http import HttpResponse, HttpResponseBadRequest, HttpResponseForbidden,\
    Http404
from django.views.decorators.csrf import csrf_exempt
from django.shortcuts import render_to_response, get_object_or_404, render
from django.template import loader, RequestContext
from django.views.decorators.http import require_POST
from django.contrib.admin import helpers

from facebook.utils import validate_redirect, do_exchange_token
from facebook.graph import get_graph
from facebook.oauth2 import parseSignedRequest
from facebook.session import get_session
from facebook.modules.profile.application.utils import get_app_dict
from facebook.modules.profile.user.models import User
from facebook.modules.profile.user.admin import UserAdmin
from django.utils.translation import ugettext_lazy as _


logger = logging.getLogger(__name__)

runserver = ('runserver' in sys.argv)

# Find a JSON parser
try:
    import simplejson as json
except ImportError:
    try:
        from django.utils import simplejson as json
    except ImportError:
        import json

def input(request, action):
    """ method to save a graph-object query, that is retrieved client side """

    json = request.POST.get('json', None)

    graph = get_graph(request)

    if action == 'user':
        if json:
            user, created = User.objects.get_or_create(id=json['id'])

            user.access_token = graph.access_token
            user.save_from_facebook(json)
        else:
            user, created = User.objects.get_or_create(id=graph.user_id)
            user.get_from_facebook(request)
            user.access_token = graph.access_token
            user.save()

        return HttpResponse('ok')

    elif action == 'friends':
        if json == None:
            return HttpResponseBadRequest('Facebook Graph JSON response is required as "json" attribute')

        user, created = User.objects.get_or_create(id=graph.user_id)
        user.save_friends(json)

        return HttpResponse('ok')

    elif action == 'user-friends-once':
        user, created = User.objects.get_or_create(id=graph.user_id)
        if created or not user.access_token:
            user.get_friends(save=True, request=request)
        user.access_token = graph.access_token
        user.get_from_facebook(request)
        user.save()

        return HttpResponse('ok')

    return HttpResponseBadRequest('action %s not implemented' % action)



@csrf_exempt
def channel(request):
    """ Returns the channel.html file as described in http://developers.facebook.com/docs/reference/javascript/FB.init/"""
    fb = get_session(request)
    try:
        locale = fb.signed_request['user']['locale']
    except (AttributeError, KeyError, TypeError): # TODO really catch AttributeError too?
        locale = 'en_US'  #TODO: Make this nicer.
    t=datetime.now()+timedelta(weeks=500)
    response = HttpResponse(loader.render_to_string('facebook/channel.html', {'locale': locale},
                              context_instance=RequestContext(request)))
    response['Expires'] = t.ctime()
    return response


# Deauthorize callback, signed request: {u'issued_at': 1305126336, u'user_id': u'xxxx', u'user': {u'locale': u'de_DE', u'country': u'ch'}, u'algorithm': u'HMAC-SHA256'}

@csrf_exempt
def deauthorize_and_delete(request, app_name=None):
    """ Deletes a user on a deauthorize callback. """
    if request.method == 'GET':
        if request.user.is_superuser:
            application = get_app_dict(app_name)
            # Preview callback
            if 'userid' in request.GET:
                queryset = User.objects.filter(id=int(request.GET.get('userid'), 0))
                opts = User._meta
                modeladmin = UserAdmin(User, admin.site)
                using = router.db_for_write(User)
                # Populate deletable_objects, a data structure of all related objects that
                # will also be deleted.
                deletable_objects, perms_needed, protected = get_deleted_objects(
                    queryset, opts, request.user, modeladmin.admin_site, using)

                context = {
                        "title": _("Preview deauthorization callback"),
                        "objects_name": 'User',
                        "deletable_objects": [deletable_objects],
                        'queryset': queryset,
                        "perms_lacking": perms_needed,
                        "protected": protected,
                        "opts": opts,
                        "root_path": modeladmin.admin_site.root_path,
                        "app_label": 'facebook',
                        'action_checkbox_name': helpers.ACTION_CHECKBOX_NAME,
                    }

                return render(request, [
                    "admin/facebook/delete_selected_confirmation.html",
                     "admin/delete_selected_confirmation.html"
                    ], context)
            else:
                return HttpResponse(u"""Deauthorize callback for app %s
                    with id %s called with GET. Call with userid= as
                    parameter to preview cascade.""" % (app_name, application['ID']))
        else:
            raise Http404
    if 'signed_request' in request.POST:
        application = get_app_dict(app_name)
        parsed_request = parseSignedRequest(request.POST.get('signed_request'), application['SECRET'])
        user = get_object_or_404(User, id=int(parsed_request.get('user_id')))

        if settings.DEBUG == False:
            user.delete()
            logger.info('Deleting User: %s' % user)
        else:
            logger.info('User %s asked for deauthorization. Not deleted in Debug mode.' % user)
        return HttpResponse('ok')
    raise Http404


@csrf_exempt
def parent_redirect(request):
    """ Forces a _parent redirect to the specified url. """
    
    encoded_url = request.GET.get('next','')
    unquoted_url = urllib2.unquote(encoded_url)
    
    if validate_redirect(unquoted_url):
        return render(request, 'facebook/redirecter.html', {'destination': unquoted_url })
    else:
        return HttpResponseForbidden('The next= paramater is not an allowed redirect url.')


@csrf_exempt
def internal_redirect(request):
    """ Forces a GET redirect. Use this if you do a parent redirect to your view
        if your view is csrf protected.
    """
    
    encoded_url = request.GET.get('page','')
    unquoted_url = urllib2.unquote(encoded_url)
    
    if validate_redirect(unquoted_url):
        return render(request, 'facebook/internalredirecter.html', {'destination': urllib2.unquote(unquoted_url) })
    else:
        return HttpResponseForbidden('The next= paramater is not an allowed redirect url.')


def log_error(request):
    """ Allows to register client-side errors. """
    if not request.is_ajax() or not request.method == 'POST':
        raise Http404
    logger.error(request.POST.get('message'))
    return HttpResponse('logged error.')


def fql_console(request):
    if not settings.DEBUG:
        return HttpResponseForbidden
    else:
        return render_to_response('facebook/fqlconsole.html', {},
                                  RequestContext(request))


@require_POST
def exchange_token(request):
    """ Exchanges the access token for a 60 day token.
        https://developers.facebook.com/docs/offline-access-deprecation/#extend_token
    """
    save = request.POST.get('save', False)
    app_name = request.POST.get('app_name', None)
    app_dict = get_app_dict(application=app_name)
    fb_exchange_token = request.POST.get('fb_exchange_token', None)
    if not fb_exchange_token:
        graph = get_graph(request, app_dict=app_dict)
        fb_exchange_token = graph.access_token
    response = do_exchange_token(app_dict=app_dict, exchange_token=fb_exchange_token)
    if save and response and 'access_token' in response:
        fb_session = get_session(request)
        fb_session.access_token = response['access_token']
        fb_session.token_expires = response.get('expires')
        graph = get_graph(request, app_dict=app_dict)
        if graph.user_id:
            user, created = User.objects.get_or_create(id=graph.user_id)
            user.access_token = response['access_token']
            user.get_from_facebook(graph=graph, save=True)

    return HttpResponse(json.dumps(response), mimetype="application/json")
########NEW FILE########
