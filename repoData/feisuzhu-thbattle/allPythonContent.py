__FILENAME__ = snippets
#!/bin/false

# ------------ code used to generate thb.resource.tag_sealarray -------

star = pyglet.image.load('/dev/shm/dfdf.png').get_texture(rectangle=True)
frame = pyglet.image.load('/dev/shm/frame.png').get_texture(rectangle=True)

n = 36
fbo = Framebuffer(pyglet.image.Texture.create_for_size(
    GL_TEXTURE_RECTANGLE_ARB, 25*n, 25, GL_RGBA
))

from colorsys import hsv_to_rgb as hsv
with fbo:
    glClearColor(0, 0, 0, 0)
    glClear(GL_COLOR_BUFFER_BIT)
    n1 = float(n)
    for i in range(n):
        glLoadIdentity()
        glColor3f(1, 1, 1)
        frame.blit(i*25, 0)
        glTranslatef(12.5 + i*25, 12.5, 0)
        glRotatef(-120/n1*i, 0, 0, 1)
        glTranslatef(-12.5, -12.5, 0)
        glColor3f(*hsv(i/n1, .6, 1.))
        star.blit(0, 0)

fbo.texture.save('/dev/shm/rst.png')
# ----------------------------------------------

########NEW FILE########
__FILENAME__ = base
# -*- coding: utf-8 -*-

from functools import wraps

def server_side_only(f):
    @wraps(f)
    def _wrapper(*a, **k):
        from game.autoenv import Game
        if Game.CLIENT_SIDE:
            raise Exception('Server side only method!')
        return f(*a, **k)
    return _wrapper

########NEW FILE########
__FILENAME__ = forum_integration
# -*- coding: utf-8 -*-

# -- stdlib --
from collections import defaultdict
from options import options
from contextlib import contextmanager
import logging
log = logging.getLogger('forum_integration')

# -- third party --
from gevent.queue import Queue
import gevent

# -- own --
from .base import server_side_only
from utils import log_failure


# -- globals --
_member_client = None
_cli_pool = None
_try_counter = 10032


# -- code --
@contextmanager
def member_client_pool():
    global _cli_pool

    if not _cli_pool:
        from utils.rpc import RPCClient
        host, port = options.member_service.split(':')
        port = int(port)
        _cli_pool = Queue(10)
        for i in xrange(10):
            _cli_pool.put(RPCClient((host, port), timeout=6))

    try:
        cli = _cli_pool.get()
        yield cli
    finally:
        _cli_pool.put(cli)


class Account(object):
    is_guest = False

    @classmethod
    @server_side_only
    def authenticate(cls, username, password):
        with member_client_pool() as cli:
            try:
                uid = int(username)
                uid = uid if uid < 100000 else None
            except ValueError:
                uid = None

            if uid == -1:
                acc = cls()
                acc._fill_trygame()
                return acc
            elif uid:
                member = cli.validate_by_uid(uid, password)
            else:
                member = cli.validate_by_username(username, password)

            if not member:
                return False

            acc = cls()
            acc._fill_account(member)
            return acc

    @server_side_only
    def _fill_account(self, data):
        self.username = data['username'].decode('utf-8')
        self.status = data['status']
        self.userid = data['uid']

        from urlparse import urljoin
        from settings import ACCOUNT_FORUMURL

        self.other = defaultdict(
            lambda: None,
            title=data['title'].decode('utf-8'),
            avatar=urljoin(
                ACCOUNT_FORUMURL,
                '/uc_server/avatar.php?uid=%d&size=middle' % data['uid'],
            ),
            credits=data['credits'],
            games=data['games'],
            drops=data['drops'],
        )

    @server_side_only
    def _fill_trygame(self):
        global _try_counter
        c = _try_counter
        _try_counter += 1

        self.username = u'毛玉' + str(c)
        self.status = 0
        self.userid = -c

        from urlparse import urljoin
        from settings import ACCOUNT_FORUMURL

        self.other = defaultdict(
            lambda: None,
            title=u'不愿注册的毛玉',
            avatar=urljoin(
                ACCOUNT_FORUMURL,
                '/maoyu.png'
            ),
            credits=-998,
            games=0,
            drops=0,
        )

    @server_side_only
    def available(self):
        return self.status != -1

    @server_side_only
    def add_credit(self, type, amount):
        if self.userid < 0:
            return

        @gevent.spawn
        @log_failure(log)
        def worker():
            with member_client_pool() as cli:
                rst = cli.add_credit(self.userid, type, amount)
                rst and self._fill_account(rst)

    @classmethod
    def parse(cls, data):
        acc = cls()
        mode, acc.userid, acc.username, other = data
        acc.other = defaultdict(lambda: None, other)
        assert mode == 'forum'
        return acc

    def __data__(self):
        return ['forum', self.userid, self.username, self.other]

__all__ = ['Account']

########NEW FILE########
__FILENAME__ = freeplay
# -*- coding: utf-8 -*-

from .base import server_side_only
from collections import defaultdict

class Account(object):

    @classmethod
    def authenticate(cls, username, password):
        if len(username) > 0:
            acc = cls()
            acc.username = username
            acc.userid = 1 if username == 'Proton' else id(acc)
            acc.other = defaultdict(
                lambda: None,
                title=u'野生的THB玩家',
                avatar=None,
                credits=998,
                games=1,
                drops=0,
            )
            return acc

        return False

    @server_side_only
    def available(self):
        return True

    @server_side_only
    def add_credit(self, type, amount):
        pass

    @classmethod
    def parse(cls, data):
        acc = cls()
        mode, acc.userid, acc.username = data
        acc.other = defaultdict(
            lambda: None,
            title=u'野生的THB玩家',
            avatar=None,
            credits=998,
            games=1,
        )
        assert mode == 'freeplay'
        return acc

    def __data__(self):
        return ['freeplay', self.userid, self.username]

########NEW FILE########
__FILENAME__ = autoupdate
# -*- coding: utf-8 -*-

import gevent
import random
import gevent.queue
import urllib2
from zlib import crc32
import simplejson as json
import sys
import os
from urlparse import urljoin
from StringIO import StringIO
from gzip import GzipFile

import logging
log = logging.getLogger('autoupdate')

import settings

ignores = settings.UPDATE_IGNORES
VERSION = settings.VERSION


def _clean_dir(base):
    for path, _, names in os.walk(base):
        for name in names:
            if not name.endswith('.purge'):
                continue

            fn = os.path.join(path, name)
            try:
                os.unlink(fn)
            except OSError:
                pass


def build_hash(base):
    my_hash = {}
    for path, _, names in os.walk(base):
        for name in names:
            if ignores.match(name):
                # file in exclude list
                continue
            fn = os.path.join(path, name)
            rfn = os.path.relpath(fn, base)
            with open(fn, 'rb') as f:
                h = crc32(f.read())
                my_hash[rfn.replace('\\', '/')] = h
    return my_hash


def version_string(hash):
    return str(crc32(str(sorted(hash.values()))))


def write_metadata(base):
    h = build_hash(base)
    with open('update_info.json', 'w') as f:
        f.write(json.dumps(h, encoding=sys.getfilesystemencoding(), indent='    '))

    with open('current_version', 'w') as f:
        f.write(version_string(h))


def do_update(base, update_url, cb=lambda *a, **k: False):

    try:
        remote = urllib2.build_opener()
        remote.addheaders = [('User-Agent', VERSION), ('Accept-Encoding', 'gzip')]
        cb('update_begin')

        me = gevent.getcurrent()

        def worker(url):
            try:
                resp = remote.open(url)
                rst = resp.read()
                if resp.headers.get('Content-Encoding') == 'gzip':
                    rst = GzipFile(fileobj=StringIO(rst), mode='rb').read()
                resp.close()
                return rst
            except Exception as e:
                me.kill(e)

        latest_ver = gevent.spawn(worker, urljoin(update_url, 'current_version'))

        _clean_dir(base)
        my_hash = build_hash(base)
        my_ver = version_string(my_hash)

        latest_ver = latest_ver.get().strip()

        if my_ver == latest_ver:
            log.info('game up to date')
            cb('up2date')
            return 'up2date'

        latest_hash = json.loads(worker(urljoin(update_url, 'update_info.json')))

        files_delete = set(my_hash) - set(latest_hash)
        files_update = set(latest_hash.items()) - set(my_hash.items())

        for fn in files_delete:
            ffn = os.path.join(base, fn)
            cb('delete_file', fn)
            log.info('delete file %s', fn)
            try: os.rename(ffn, ffn + '.%d.purge' % random.randint(0, 10000))
            except OSError: pass

        queue = gevent.queue.Queue(1000000)
        for fn, _ in files_update:
            suburl = fn.replace('\\', '/')
            queue.put(
                (urljoin(update_url, suburl), fn)
            )

        def retrieve_worker():
            try:
                while True:
                    url, fn = queue.get_nowait()
                    log.info('update %s' % fn)
                    cb('download_file', fn)
                    resp = remote.open(url)
                    d = resp.read()
                    if resp.headers.get('Content-Encoding') == 'gzip':
                        d = GzipFile(fileobj=StringIO(d), mode='rb').read()

                    resp.close()
                    cb('download_complete', fn)
                    ffn = os.path.join(base, fn)
                    try:
                        try:
                            os.makedirs(os.path.dirname(ffn))
                        except OSError:
                            pass

                        try: os.rename(ffn, ffn + '.%d.purge' % random.randint(0, 10000))
                        except OSError: pass

                        with open(ffn, 'wb') as f:
                            f.write(d)
                    except EnvironmentError:
                        cb('write_failed', fn)
            except gevent.queue.Empty:
                pass

            except Exception as e:
                me.kill(e)

        workers = [gevent.spawn(retrieve_worker) for i in range(4)]
        for w in workers: w.join()

        cb('update_finished')

        return 'updated'

    except urllib2.HTTPError as e:
        cb('http_error', e.getcode(), e.geturl())

    except urllib2.URLError as e:
        cb('network_error')

    except IOError as e:
        cb('io_error')

    return 'error'

########NEW FILE########
__FILENAME__ = aya
# -*- coding: utf-8 -*-

import gevent
from gevent import monkey
monkey.patch_all()

import random
import re
from gevent.pool import Pool
from gevent.coros import RLock
from gevent.queue import Queue
from cStringIO import StringIO
from deathbycaptcha import SocketClient as DBCClient
from qqbot import QQBot
import argparse
import logging
import redis
import sys
from functools import partial
from contextlib import contextmanager

from utils.interconnect import Interconnect as InterconnectBase
from utils import check, CheckFailed

# import httplib
# httplib.HTTPConnection.debuglevel = 1


parser = argparse.ArgumentParser('aya')
parser.add_argument('--qq', type=int)
parser.add_argument('--password')
parser.add_argument('--dbc-username')
parser.add_argument('--dbc-password')
parser.add_argument('--redis', default='localhost')
parser.add_argument('--redis-port', default=6379)
parser.add_argument('--member-service', default='localhost')
options = parser.parse_args()

log = logging.getLogger('Aya')
pool = Pool(5)

Interconnect = None


@contextmanager
def member_client_pool():
    global _cli_pool

    if not _cli_pool:
        from utils.rpc import RPCClient
        _cli_pool = Queue(5)
        for i in xrange(5):
            _cli_pool.put(RPCClient((options.member_service, 7000), timeout=6))

    try:
        cli = _cli_pool.get()
        yield cli
    finally:
        _cli_pool.put(cli)

_cli_pool = None


class AyaDAO(object):
    def __init__(self):
        self.redis = redis.Redis(options.redis, options.redis_port)

    def get_binding(self, qq):
        rst = self.redis.hget('aya:binding', int(qq))
        try:
            return int(rst)
        except:
            return None

    def get_all_bindings(self):
        return self.redis.hgetall('aya:binding')

    def set_binding(self, qq, uid):
        self.redis.hset('aya:binding', int(qq), int(uid))

    def is_group_on(self, group_num):
        return self.redis.sismember('aya:group_on', int(group_num))

    def get_all_groups_on(self):
        rst = self.redis.smembers('aya:group_on')
        if not rst:
            return []

        return [int(i) for i in rst]

    def set_group_on(self, group_num):
        self.redis.sadd('aya:group_on', int(group_num))

    def set_group_off(self, group_num):
        self.redis.srem('aya:group_on', int(group_num))


dao = AyaDAO()


class Aya(QQBot):
    def on_captcha(self, image):
        logging.info('Solving captcha...')
        f = StringIO()
        f.write(image)
        f.seek(0)
        dbccli = DBCClient(options.dbc_username, options.dbc_password)

        try:
            captcha = dbccli.decode(f, 60)
        except:
            log.exception('Error solving captcha')
            sys.exit(1)

        if captcha:
            self.captcha = captcha
            return captcha['text'], captcha

        sys.exit(1)

    def on_captcha_wrong(self, tag):
        log.info('Captcha wrong!')
        dbccli = DBCClient(options.dbc_username, options.dbc_password)
        dbccli.report(tag['captcha'])

    def on_sess_message(self, msg):
        text = (
            u'文文不认识你，不会理你哦。\n'
            u'加好友的时候验证信息里像这样(文文求交朋友 3456 mima)填上你的论坛uid和密码，不要带括号，文文就会跟你做朋友。'
        )

        self.send_sess_message(msg['id'], msg['from_uin'], text)

    def on_message(self, msg):
        text = (
            u'文文最近很忙，没法跟你闲聊啦……\n'
            u'有空了会告诉你哦～'
        )

        self.send_buddy_message(msg['from_uin'], text)

    def on_group_message(self, msg):
        content = self._plaintext(msg['content']).strip()
        if not content:
            return

        if content.startswith(u'呼叫文文'):
            pool.apply_async(self.send_group_message, (msg['from_uin'], u'文文在哦'))

        elif content == u'文文on':
            superusers = self.get_group_superusers_uin(msg['group_code'])
            if msg['send_uin'] in superusers or self.uin2qq(msg['send_uin']) in (84065234,):
                dao.set_group_on(self.gcode2groupnum(msg['group_code']))
                pool.apply_async(self.send_group_message, (msg['from_uin'], u'收到～文文会以最快速度播报新闻～'))

        elif content == u'文文off':
            gnum = self.gcode2groupnum(msg['group_code'])
            if dao.is_group_on(gnum):
                dao.set_group_off(gnum)
                pool.apply_async(self.send_group_message, (msg['from_uin'], u'哼，不理你们了。管理员叫我我才回来。哼。'))

        elif content[0] in (u'`', u'•'):
            pool.apply_async(self.do_speaker, (msg['send_uin'], content[1:], msg['from_uin']))

    def on_system_message(self, msg):
        if msg['type'] == 'verify_required':
            qq = self.uin2qq(msg['from_uin'])

            def fail():
                self.deny_friend_request(qq, u'好友请求填写的不对，文文不要跟你做朋友。')
                return False

            def success():
                self.allow_friend_request(qq)
                self.refresh_buddy_list()
                return True

            req = msg['msg'].split(None, 2)
            req = [i.strip() for i in req]
            try:
                check(len(req) == 3)
                check(req[0] == u'文文求交朋友')
                check(req[1].isdigit())
            except CheckFailed:
                return fail()

            uid = int(req[1])
            pwd = req[2]
            with member_client_pool() as cli:
                member = cli.validate_by_uid(uid, pwd)

            if not member:
                return fail()

            dao.set_binding(qq, uid)

            return success()

    def do_speaker(self, uin, content, group_uin=None):
        fail_text = u'文文不认识你，才不帮你发新闻呢。想跟文文做朋友么？悄悄地告诉文文吧。'
        insufficient_funds_text = u'你的节操掉了一地，才不帮你发新闻呢。'
        friend_uins = [i['uin'] for i in self.buddy_list]
        if uin not in friend_uins:
            group_uin and self.send_group_message(group_uin, fail_text)
            return

        qq = self.uin2qq(uin)
        uid = dao.get_binding(qq)
        if not uid:
            # not bound, but are friends
            # delete him.
            self.delete_friend(uin)
            self.refresh_buddy_list()
            return

        foo = str(random.randint(0x10000000, 0xffffffff))
        content = content.replace('||', foo)
        content = re.sub(r'([\r\n]|\|(c[A-Fa-f0-9]{8}|s[12][A-Fa-f0-9]{8}|[BbIiUuHrRGYW]|LB|DB|![RGOB]))', '', content)
        content = content.replace(foo, '||')

        with member_client_pool() as cli:
            member = cli.get_user_info(uid)
            if member['credits'] < 10:
                group_uin and self.send_group_message(group_uin, insufficient_funds_text)
                return

            cli.add_credit(uid, 'credits', -10)
            Interconnect.publish('speaker', [member['username'], content])


class AyaInterconnect(InterconnectBase):
    lock = None

    def on_message(self, node, topic, message):
        if topic == 'speaker':
            from settings import ServerNames
            username, content = message

            send = u'{}『文々。新闻』{}： {}'.format(
                ServerNames.get(node, node), username, content,
            )

            groups_on = [int(i) for i in dao.get_all_groups_on()]
            gids = [
                g['gid'] for g in aya.group_list
                if aya.gcode2groupnum(g['code']) in groups_on
            ]

            pool.map_async(lambda f: f(), [
                partial(aya.send_group_message, i, send)
                for i in gids
            ])

    def publish(self, topic, data):
        lock = self.lock
        if not lock:
            lock = RLock()
            self.lock = lock

        with lock:
            return InterconnectBase.publish(self, topic, data)


logging.basicConfig(level=logging.DEBUG)

from gevent.backdoor import BackdoorServer
gevent.spawn(BackdoorServer(('127.0.0.1', 11111)).serve_forever)

aya = Aya(options.qq, options.password)
# aya.wait_ready()
Interconnect = AyaInterconnect.spawn('aya', options.redis, options.redis_port)
aya.join()

########NEW FILE########
__FILENAME__ = deathbycaptcha
#!/usr/bin/env python
# -*- coding: UTF-8 -*-

"""Death by Captcha HTTP and socket API clients.

There are two types of Death by Captcha (DBC hereinafter) API: HTTP and
socket ones.  Both offer the same functionalily, with the socket API
sporting faster responses and using way less connections.

To access the socket API, use SocketClient class; for the HTTP API, use
HttpClient class.  Both are thread-safe.  SocketClient keeps a persistent
connection opened and serializes all API requests sent through it, thus
it is advised to keep a pool of them if you're script is heavily
multithreaded.

Both SocketClient and HttpClient give you the following methods:

get_user()
    Returns your DBC account details as a dict with the following keys:

    "user": your account numeric ID; if login fails, it will be the only
        item with the value of 0;
    "rate": your CAPTCHA rate, i.e. how much you will be charged for one
        solved CAPTCHA in US cents;
    "balance": your DBC account balance in US cents;
    "is_banned": flag indicating whether your account is suspended or not.

get_balance()
    Returns your DBC account balance in US cents.

get_captcha(cid)
    Returns an uploaded CAPTCHA details as a dict with the following keys:

    "captcha": the CAPTCHA numeric ID; if no such CAPTCHAs found, it will
        be the only item with the value of 0;
    "text": the CAPTCHA text, if solved, otherwise None;
    "is_correct": flag indicating whether the CAPTCHA was solved correctly
        (DBC can detect that in rare cases).

    The only argument `cid` is the CAPTCHA numeric ID.

get_text(cid)
    Returns an uploaded CAPTCHA text (None if not solved).  The only argument
    `cid` is the CAPTCHA numeric ID.

report(cid)
    Reports an incorrectly solved CAPTCHA.  The only argument `cid` is the
    CAPTCHA numeric ID.  Returns True on success, False otherwise.

upload(captcha)
    Rploads a CAPTCHA.  The only argument `captcha` can be either file-like
    object (any object with `read` method defined, actually, so StringIO
    will do), or CAPTCHA image file name.  On successul upload you'll get
    the CAPTCHA details dict (see get_captcha() method).

    NOTE: AT THIS POINT THE UPLOADED CAPTCHA IS NOT SOLVED YET!  You have
    to poll for its status periodically using get_captcha() or get_text()
    method until the CAPTCHA is solved and you get the text.

decode(captcha, timeout=DEFAULT_TIMEOUT)
    A convenient method that uploads a CAPTCHA and polls for its status
    periodically, but no longer than `timeout` (defaults to 60 seconds).
    If solved, you'll get the CAPTCHA details dict (see get_captcha()
    method for details).  See upload() method for details on `captcha`
    argument.

Visit http://www.deathbycaptcha.com/user/api for updates.

"""

import base64
import binascii
import errno
import imghdr
import random
import os
import select
import socket
import sys
import threading
import time
import urllib
import urllib2
try:
    from json import read as json_decode, write as json_encode
except ImportError:
    try:
        from json import loads as json_decode, dumps as json_encode
    except ImportError:
        from simplejson import loads as json_decode, dumps as json_encode


# API version and unique software ID
API_VERSION = 'DBC/Python v4.1.2'

# Default CAPTCHA timeout and decode() polling interval
DEFAULT_TIMEOUT = 60
POLLS_INTERVAL = 5

# Base HTTP API url
HTTP_BASE_URL = 'http://api.dbcapi.me/api'

# Preferred HTTP API server's response content type, do not change
HTTP_RESPONSE_TYPE = 'application/json'

# Socket API server's host & ports range
SOCKET_HOST = 'api.dbcapi.me'
SOCKET_PORTS = range(8123, 8131)


def _load_image(captcha):
    if hasattr(captcha, 'read'):
        img = captcha.read()
    else:
        img = ''
        try:
            captcha_file = open(captcha, 'rb')
        except Exception:
            raise
        else:
            img = captcha_file.read()
            captcha_file.close()
    if not len(img):
        raise ValueError('CAPTCHA image is empty')
    elif imghdr.what(None, img) is None:
        raise TypeError('Unknown CAPTCHA image type')
    else:
        return img


class AccessDeniedException(Exception):
    pass


class Client(object):

    """Death by Captcha API Client."""

    def __init__(self, username, password):
        self.is_verbose = False
        self.userpwd = {'username': username, 'password': password}

    def _log(self, cmd, msg=''):
        if self.is_verbose:
            print '%d %s %s' % (time.time(), cmd, msg.rstrip())
        return self

    def close(self):
        pass

    def connect(self):
        pass

    def get_user(self):
        """Fetch user details -- ID, balance, rate and banned status."""
        raise NotImplementedError()

    def get_balance(self):
        """Fetch user balance (in US cents)."""
        return self.get_user().get('balance')

    def get_captcha(self, cid):
        """Fetch a CAPTCHA details -- ID, text and correctness flag."""
        raise NotImplementedError()

    def get_text(self, cid):
        """Fetch a CAPTCHA text."""
        return self.get_captcha(cid).get('text') or None

    def report(self, cid):
        """Report a CAPTCHA as incorrectly solved."""
        raise NotImplementedError()

    def upload(self, captcha):
        """Upload a CAPTCHA.

        Accepts file names and file-like objects.  Returns CAPTCHA details
        dict on success.

        """
        raise NotImplementedError()

    def decode(self, captcha, timeout=DEFAULT_TIMEOUT):
        """Try to solve a CAPTCHA.

        See Client.upload() for arguments details.

        Uploads a CAPTCHA, polls for its status periodically with arbitrary
        timeout (in seconds), returns CAPTCHA details if (correctly) solved.

        """
        deadline = time.time() + (max(0, timeout) or DEFAULT_TIMEOUT)
        uploaded_captcha = self.upload(captcha)
        if uploaded_captcha:
            while deadline > time.time() and not uploaded_captcha.get('text'):
                time.sleep(POLLS_INTERVAL)
                uploaded_captcha = self.get_captcha(uploaded_captcha['captcha'])
            if uploaded_captcha.get('text') and uploaded_captcha.get('is_correct'):
                return uploaded_captcha


class HttpClient(Client):

    """Death by Captcha HTTP API client."""

    def __init__(self, *args):
        Client.__init__(self, *args)
        self.opener = urllib2.build_opener(urllib2.HTTPRedirectHandler())

    def _call(self, cmd, payload=None, headers=None):
        if headers is None:
            headers = {}
        headers['Accept'] = HTTP_RESPONSE_TYPE
        headers['User-Agent'] = API_VERSION
        if hasattr(payload, 'items'):
            payload = urllib.urlencode(payload)
            self._log('SEND', '%s %d %s' % (cmd, len(payload), payload))
        if payload is not None:
            headers['Content-Length'] = len(payload)
        try:
            response = self.opener.open(urllib2.Request(
                HTTP_BASE_URL + '/' + cmd.strip('/'),
                data=payload,
                headers=headers
            )).read()
        except urllib2.HTTPError, err:
            if 403 == err.code:
                raise AccessDeniedException('Access denied, please check your credentials and/or balance')
            elif 400 == err.code or 413 == err.code:
                raise ValueError("CAPTCHA was rejected by the service, check if it's a valid image")
            elif 503 == err.code:
                raise OverflowError("CAPTCHA was rejected due to service overload, try again later")
        else:
            self._log('RECV', '%d %s' % (len(response), response))
            try:
                return json_decode(response)
            except Exception:
                raise RuntimeError('Invalid API response')
        return {}

    def get_user(self):
        return self._call('user', self.userpwd.copy()) or {'user': 0}

    def get_captcha(self, cid):
        return self._call('captcha/%d' % cid) or {'captcha': 0}

    def report(self, cid):
        return not self._call('captcha/%d/report' % cid,
                              self.userpwd.copy()).get('is_correct')

    def upload(self, captcha):
        boundary = binascii.hexlify(os.urandom(16))

        body = '\r\n'.join(('\r\n'.join((
            '--%s' % boundary,
            'Content-Disposition: form-data; name="%s"' % k,
            'Content-Type: text/plain',
            'Content-Length: %d' % len(str(v)),
            '',
            str(v)
        ))) for k, v in self.userpwd.items())

        img = _load_image(captcha)
        body += '\r\n'.join((
            '',
            '--%s' % boundary,
            'Content-Disposition: form-data; name="captchafile"; filename="captcha"',
            'Content-Type: application/octet-stream',
            'Content-Length: %d' % len(img),
            '',
            img,
            '--%s--' % boundary,
            ''
        ))

        response = self._call('captcha', body, {
            'Content-Type': 'multipart/form-data; boundary="%s"' % boundary
        }) or {}
        if response.get('captcha'):
            return response


class SocketClient(Client):

    """Death by Captcha socket API client."""

    TERMINATOR = '\r\n'

    def __init__(self, *args):
        Client.__init__(self, *args)
        self.socket_lock = threading.Lock()
        self.socket = None

    def close(self):
        if self.socket:
            self._log('CLOSE')
            try:
                self.socket.shutdown(socket.SHUT_RDWR)
            except socket.error:
                pass
            finally:
                self.socket.close()
                self.socket = None

    def connect(self):
        if not self.socket:
            self._log('CONN')
            host = (socket.gethostbyname(SOCKET_HOST),
                    random.choice(SOCKET_PORTS))
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.settimeout(0)
            try:
                self.socket.connect(host)
            except socket.error, err:
                if err.args[0] not in (errno.EAGAIN, errno.EWOULDBLOCK, errno.EINPROGRESS):
                    self.close()
                    raise err
        return self.socket

    def __del__(self):
        self.close()

    def _sendrecv(self, sock, buf):
        self._log('SEND', buf)
        fds = [sock]
        buf += self.TERMINATOR
        response = ''
        while True:
            rds, wrs, exs = select.select((not buf and fds) or [],
                                          (buf and fds) or [],
                                          fds,
                                          POLLS_INTERVAL)
            if exs:
                raise IOError('select() failed')
            try:
                if wrs:
                    while buf:
                        buf = buf[wrs[0].send(buf):]
                elif rds:
                    while True:
                        s = rds[0].recv(256)
                        if not s:
                            raise IOError('recv(): connection lost')
                        else:
                            response += s
            except socket.error, err:
                if err.args[0] not in (errno.EAGAIN, errno.EWOULDBLOCK, errno.EINPROGRESS):
                    raise err
            if response.endswith(self.TERMINATOR):
                self._log('RECV', response)
                return response.rstrip(self.TERMINATOR)
        raise IOError('send/recv timed out')

    def _call(self, cmd, data=None):
        if data is None:
            data = {}
        data['cmd'] = cmd
        data['version'] = API_VERSION
        request = json_encode(data)

        response = None
        for _ in range(2):
            if not self.socket and cmd != 'login':
                self._call('login', self.userpwd.copy())
            self.socket_lock.acquire()
            try:
                sock = self.connect()
                response = self._sendrecv(sock, request)
            except IOError, err:
                sys.stderr.write(str(err) + "\n")
                self.close()
            except socket.error, err:
                sys.stderr.write(str(err) + "\n")
                self.close()
                raise IOError('Connection refused')
            else:
                break
            finally:
                self.socket_lock.release()

        if response is None:
            raise IOError('Connection lost or timed out during API request')

        try:
            response = json_decode(response)
        except Exception:
            raise RuntimeError('Invalid API response')

        if not response.get('error'):
            return response

        error = response['error']
        if error in ('not-logged-in', 'invalid-credentials'):
            raise AccessDeniedException('Access denied, check your credentials')
        elif 'banned' == error:
            raise AccessDeniedException('Access denied, account is suspended')
        elif 'insufficient-funds' == error:
            raise AccessDeniedException('CAPTCHA was rejected due to low balance')
        elif 'invalid-captcha' == error:
            raise ValueError('CAPTCHA is not a valid image')
        elif 'service-overload' == error:
            raise OverflowError('CAPTCHA was rejected due to service overload, try again later')
        else:
            self.socket_lock.acquire()
            self.close()
            self.socket_lock.release()
            raise RuntimeError('API server error occured: %s' % error)

    def get_user(self):
        return self._call('user') or {'user': 0}

    def get_captcha(self, cid):
        return self._call('captcha', {'captcha': cid}) or {'captcha': 0}

    def upload(self, captcha):
        response = self._call('upload', {
            'captcha': base64.b64encode(_load_image(captcha))
        })
        if response.get('captcha'):
            uploaded_captcha = dict(
                (k, response.get(k))
                for k in ('captcha', 'text', 'is_correct')
            )
            if not uploaded_captcha['text']:
                uploaded_captcha['text'] = None
            return uploaded_captcha

    def report(self, cid):
        return not self._call('report', {'captcha': cid}).get('is_correct')


if '__main__' == __name__:
    # Put your DBC username & password here:
    #client = HttpClient(sys.argv[1], sys.argv[2])
    client = SocketClient(sys.argv[1], sys.argv[2])
    client.is_verbose = True

    print 'Your balance is %s US cents' % client.get_balance()

    for fn in sys.argv[3:]:
        try:
            # Put your CAPTCHA image file name or file-like object, and optional
            # solving timeout (in seconds) here:
            captcha = client.decode(fn, DEFAULT_TIMEOUT)
        except Exception, e:
            sys.stderr.write('Failed uploading CAPTCHA: %s\n' % (e, ))
            captcha = None

        if captcha:
            print 'CAPTCHA %d solved: %s' % \
                  (captcha['captcha'], captcha['text'])

            # Report as incorrectly solved if needed.  Make sure the CAPTCHA was
            # in fact incorrectly solved!
            #try:
            #    client.report(captcha['captcha'])
            #except Exception, e:
            #    sys.stderr.write('Failed reporting CAPTCHA: %s\n' % (e, ))

########NEW FILE########
__FILENAME__ = qqbot
# -*- coding: utf-8 -*-

from gevent.socket import socket as gsock
from socket import socket
if gsock is not socket:
    from gevent import monkey
    monkey.patch_all()

from gevent.pool import Pool
from gevent.event import Event

from collections import defaultdict
from cStringIO import StringIO
import itertools
import json
import logging
import random
import re
import requests
import struct
import time

log = logging.getLogger('QQBot')

UA_STRING = (
    'Mozilla/5.0 (X11; Linux x86_64) '
    'AppleWebKit/537.36 (KHTML, like Gecko) '
    'Ubuntu Chromium/28.0.1500.71 '
    'Chrome/28.0.1500.71 Safari/537.36'
)


class QQBot(object):
    def __init__(self, qq, password, v=20130916001, appid=501004106):
        self.qq = str(qq)
        self.password = password
        self.logged_in = False
        self.tick = itertools.count(random.randrange(20000000, 30000000))
        self.cface_tick = itertools.count(1)
        self.clientid = random.randrange(30000000, 100000000)
        self.v = v  # nonsense, copied from smartqq
        self.appid = appid  # nonsense, copied from smartqq

        # [{"flag":167773201,"name":"圣维亚学院","gid":3672457874,"code":1705326190}, ...]
        self.group_list = []

        # [{"face":3,"flag":276841024,"nick":"Proton","uin":2462992553}, ...]
        self.buddy_list = []

        self.cache = defaultdict(dict)
        self.session = requests.session()

        self.pool = Pool(10)
        self.corepool = Pool(3)
        self.ready = Event()

        # self.corepool.spawn(self.init)
        self.init()

    def init(self):
        self.ready.clear()
        self.login()
        self.corepool.spawn(self.loop)

        p = Pool(5)
        p.map(lambda f: f(), [
            self.refresh_buddy_list,
            self.refresh_group_list,
        ])
        self.ready.set()

        p.map_async(self.gcode2groupnum, [g['code'] for g in self.group_list])
        p.map_async(self.uin2qq, [i['uin'] for i in self.buddy_list])

    def shutdown(self):
        self.ready.clear()
        self.pool.kill()
        self.corepool.kill()

    def join(self):
        self.corepool.join()

    def wait_ready(self):
        self.ready.wait()

    def _stage1_login(self):
        self.group_list[:] = []
        self.buddy_list[:] = []
        self.cache = defaultdict(dict)

        session = self.session
        log.debug('Querying for captcha...')
        check = session.get('https://ssl.ptlogin2.qq.com/check', params={
            'uin': self.qq, 'appid': self.appid,
            'u1': 'http://w.qq.com/proxy.html',
            'js_ver': 10051,
            'js_type': 0,
            'r': random.random(),
        })

        assert check.ok

        state, vc, hexuin = self._jsonp2list(check.content)

        if state == '1':
            # needs captcha
            log.debug('Captcha needed, getting captcha image...')
            captcha = session.get('https://ssl.captcha.qq.com/getimage', params={
                'uin': self.qq, 'aid': self.appid, 'r': random.random()
            })

            assert captcha.ok

            vc, vctag = self.on_captcha(captcha.content)

        hexuin = hexuin.replace('\\x', '').decode('hex')
        log.debug('Do stage1 login...')
        login = session.get('https://ssl.ptlogin2.qq.com/login', params={
            'u': self.qq, 'p': self._encode_password(hexuin, self.password, vc),
            'verifycode': vc, 'aid': self.appid,

            'webqq_type': 10, 'remember_uin': 1, 'login2qq': 1,
            'u1': 'http://w.qq.com/proxy.html?login2qq=1&webqq_type=10',
            'h': 1, 'ptredirect': 0, 'ptlang': 2052,
            'daid': 164, 'from_ui': 1, 'pttype': 1, 'dumy': '',
            'fp': 'loginerroralert', 'action': '0-28-83753',
            'mibao_css': 'm_webqq', 't': 2, 'g': 1, 'js_type': 0, 'js_ver': 10051,
        })

        state, _, url, _, msg, _ = self._jsonp2list(login.content)
        state = int(state)
        if state == 4:
            # captcha wrong
            log.error('Captcha wrong, stage1 login failed.')
            self.on_captcha_wrong(vctag)
            return False
        elif state != 0:
            raise Exception(msg)

        session.get(url)

        self.skey = session.cookies['skey']
        self.original_ptwebqq = self.ptwebqq = session.cookies['ptwebqq']

        return True

    def _stage2_login(self):

        log.debug('Do stage2 login...')

        rst = self.call_server('d:login2', {
            'status': 'online',
            'ptwebqq': self.ptwebqq,
            'clientid': self.clientid,
            'psessionid': '',
        })

        rst = rst['result']
        self.vfwebqq = rst['vfwebqq']
        self.psessionid = rst['psessionid']
        self.status = rst['status']

        # should be in separate func
        rst = self.call_server('d:get_gface_sig2', method='get',
            clientid=self.clientid,
            psessionid=self.psessionid,
        )['result']

        self.gface_key = rst['gface_key']
        self.gface_sig = rst['gface_sig']

    def login(self):
        self.logged_in = False
        while True:
            if self._stage1_login():
                break

        self._stage2_login()

        self.logged_in = True

    def loop(self):
        # poll
        log.debug('Logged in. Begin polling...')

        while True:
            self.ready.wait()

            rst = self.call_server('d:poll2', {
                'clientid': self.clientid,
                'psessionid': self.psessionid,
                'key': '',
                'ptwebqq': self.ptwebqq,
            })

            code = int(rst['retcode'])

            if code == 102:
                continue

            elif code == 116:
                log.debug('Refresh ptwebqq')
                self.ptwebqq = rst['p']

            elif code in (103, 109, 121, 100006, 100001):
                # {u'retcode': 121, u't': u'0'}
                raise Exception('Goes wrong, just fail.')
                log.debug('Need relogin')
                self.ready.clear()
                self.login()
                self.ready.set()

            # elif code == 109:
            #     log.warning('Unknown code 109: %r', rst)

            elif code == 0:
                messages = rst['result']
                for m in messages:
                    t = m['poll_type']
                    v = m['value']
                    f = getattr(self, 'on_' + t, None)
                    self.pool.spawn(f, v) if f else log.warning('Unhandled event: <%s> = %r', t, v)

            else:
                raise Exception('Goes wrong, just fail.')
                log.error('Unknown retcode: %r', rst)

    def refresh_group_list(self):
        assert self.logged_in
        log.debug('Refreshing group info...')

        rst = self.call_server('s:get_group_name_list_mask2', {'vfwebqq': self.vfwebqq})

        if int(rst['retcode']) != 0:
            log.error('Error %r', rst)
            return

        self.group_list[:] = rst['result']['gnamelist']
        return self.group_list

    def refresh_buddy_list(self):
        assert self.logged_in
        log.debug('Refreshing buddy info...')

        # should use original ptwebqq

        rst = self.call_server('s:get_user_friends2', {
            'vfwebqq': self.vfwebqq,
            'hash': self._buddylist_hash(self.qq, self.original_ptwebqq),
        })

        if int(rst['retcode']) != 0:
            log.error('Error %r', rst)
            return

        self.buddy_list[:] = rst['result']['info']

        return self.buddy_list

    def get_group_info_ext(self, gcode):
        self.ready.wait()

        cache = self.cache['group_info_ext']
        if gcode in cache:
            return cache[gcode]

        log.debug('Getting ext group info for gcode %d...', gcode)

        rst = self.call_server('s:get_group_info_ext2', method='get',
            gcode=gcode,
            vfwebqq=self.vfwebqq,
            cb='undefined',
            t=int(time.time() * 1000),
        )

        if int(rst['retcode']) != 0:
            log.error('Error %r', rst)
            return

        cache[gcode] = rst['result']
        return rst['result']

    def get_group_superusers_uin(self, gcode):
        self.ready.wait()
        ginfo = self.get_group_info_ext(gcode)
        l = [ginfo['ginfo']['owner']]
        for m in ginfo['ginfo']['members']:
            if m['mflag'] & 1:
                l.append(m['muin'])

        return l

    def _default_handler(t):
        def wrapper(self, v):
            log.info('Message <%s> received: %r', t, v)

        return wrapper

    # <message> =
    # {u'content': [[u'font',
    #    {u'color': u'000000',
    #     u'name': u'\u5b8b\u4f53',
    #     u'size': 10,
    #     u'style': [0, 0, 0]}],
    #   u'\u963f\u65af\u987f\u53d1\u751f\u5730\u65b9 '],
    #  u'from_uin': 3891407156,
    #  u'msg_id': 22041,
    #  u'msg_id2': 968626,
    #  u'msg_type': 9,
    #  u'reply_ip': 178849313,
    #  u'time': 1383456339,
    #  u'to_uin': 2290168915}

    # <message> =
    # {u'content': [[u'font',
    #    {u'color': u'000000',
    #     u'name': u'\u5b8b\u4f53',
    #     u'size': 10,
    #     u'style': [0, 0, 0]}],
    #   u'\u963f\u65af\u8482\u82ac',
    #   [u'offpic',
    #    {u'file_path': u'/d01c8248-0086-40d1-8679-f2f39bb4bf33', u'success': 1}],
    #   u'\u963f\u65af\u987f\u53d1\u70e7\r',
    #   [u'offpic',
    #    {u'file_path': u'/39b75fd0-923d-4fe3-9e73-4fe1e9ec64cc', u'success': 1}],
    #   u' '],
    #  u'from_uin': 3891407156,
    #  u'msg_id': 22042,
    #  u'msg_id2': 10890,
    #  u'msg_type': 9,
    #  u'reply_ip': 178849313,
    #  u'time': 1383456553,
    #  u'to_uin': 2290168915}
    on_message = _default_handler('message')

    # <group_message> =
    # {u'content': [[u'font',
    # {u'color': u'000000',
    #     u'name': u'\u5b8b\u4f53',
    #     u'size': 10,
    #     u'style': [0, 0, 0]}],
    # u'@\u6587\u6587  '],
    # u'from_uin': 921020219,
    # u'group_code': 952880722,
    # u'info_seq': 244369943,
    # u'msg_id': 20815,
    # u'msg_id2': 8639,
    # u'msg_type': 43,
    # u'reply_ip': 176756624,
    # u'send_uin': 3891407156,
    # u'seq': 216858,
    # u'time': 1383448210,
    # u'to_uin': 2290168915}
    on_group_message = _default_handler('group_message')

    on_discu_message = _default_handler('discu_message')

    # <sess_message> =
    # {u'content': [[u'font',
    #    {u'color': u'800080',
    #     u'name': u'\u5b8b\u4f53',
    #     u'size': 9,
    #     u'style': [1, 0, 0]}],
    #   u'123321 '],
    #  u'flags': {u'audio': 1, u'file': 1, u'pic': 1, u'text': 1, u'video': 1},
    #  u'from_uin': 1944240919,
    #  u'id': 192632011,
    #  u'msg_id': 8961,
    #  u'msg_id2': 144412,
    #  u'msg_type': 140,
    #  u'reply_ip': 178848397,
    #  u'ruin': 2534869498,
    #  u'service_type': 0,
    #  u'time': 1383480590,
    #  u'to_uin': 2986902553}
    on_sess_message = _default_handler('sess_message')

    # <shake_message> =
    # {u'from_uin': 3891407156,
    #  u'msg_id': 22040,
    #  u'msg_id2': 317425,
    #  u'msg_type': 9,
    #  u'reply_ip': 178847891,
    #  u'to_uin': 2290168915}
    on_shake_message = _default_handler('shake_message')

    # <system_message/friend_request> =
    # {u'result': [{u'poll_type': u'system_message',
    #    u'value': {u'account': 2986902553,
    #     u'allow': 1,
    #     u'client_type': 1,
    #     u'from_uin': 3379597260,
    #     u'msg': u'verify info',
    #     u'seq': 51448,
    #     u'stat': 10,
    #     u'type': u'verify_required',
    #     u'uiuin': u''}}],
    #  u'retcode': 0}
    on_system_message = _default_handler('system_message')

    # <input_notify> =
    # {u'from_uin': 3891407156,
    #  u'msg_id': 62944,
    #  u'msg_id2': 1,
    #  u'msg_type': 121,
    #  u'reply_ip': 4294967295,
    #  u'to_uin': 2290168915}
    on_input_notify = _default_handler('input_notify')

    # <buddies_status_change> = {u'status': u'online', u'client_type': 1, u'uin': 3891407156}
    on_buddies_status_change = _default_handler('buddies_status_change')

    # <kick_message> =
    # {u'reason': u'\u60a8\u7684\u8d26\u53f7\u5728\u53e6\u4e00\u5730\u70b9\u767b\u5f55\uff0c\u60a8\u5df2\u88ab\u8feb\u4e0b\u7ebf\u3002\u5982\u6709\u7591\u95ee\uff0c\u8bf7\u767b\u5f55 safe.qq.com \u4e86\u89e3\u66f4\u591a\u3002',
    #  u'show_reason': 1,
    #  u'way': u'poll'}
    def on_kick_message(self, v):
        log.error(u'kicked: %s', v['reason'])
        import sys
        sys.exit()

    def on_captcha(self, image):
        raise Exception('Override this!')

    def on_captcha_wrong(self):
        print 'Wrong captcha!'

    # ----------------

    def _format_message(self, message, font=None):
        font = font or {
            'name': u'宋体',
            'size': 10,
            'style': [0, 0, 0],
            'color': '000000',
        }
        return [message, '', ['font', font]]

    def send_buddy_message(self, uin, message, font=None):
        self.ready.wait()
        log.info('send_buddy_message(%d, %r)', uin, message)
        msg_id = self.tick.next()
        content = self._format_message(message, font)

        payload = {
            'to': uin,
            'face': 555,  # wtf is this?
            'content': json.dumps(content),
            'msg_id': msg_id,
            'clientid': self.clientid,
            'psessionid': self.psessionid,
        }

        self.call_server('d:send_buddy_msg2', payload, clientid=self.clientid, psessionid=self.psessionid)

    def send_group_message(self, group_uin, message, font=None):
        log.info('send_group_message(%d, %r)', group_uin, message)
        self.ready.wait()
        msg_id = self.tick.next()
        content = self._format_message(message, font)

        payload = {
            'group_uin': group_uin,
            'content': json.dumps(content),
            'msg_id': msg_id,
            'clientid': str(self.clientid),
            'psessionid': self.psessionid,
        }

        self.call_server('d:send_qun_msg2', payload, clientid=self.clientid, psessionid=self.psessionid)

    def send_group_picture(self, group_uin, filename, data=None, file=None):
        fileobj = file or (StringIO(data) if data else open(filename, 'rb'))
        self.ready.wait()

        payload = {
            'from': 'control',
            'f': 'EQQ.Model.ChatMsg.callbackSendPicGroup',
            'vfwebqq': self.vfwebqq,
            'fileid': self.cface_tick.next(),
        }

        resp = self.session.post(
            'http://up.web2.qq.com/cgi-bin/cface_upload',
            params={'time': int(time.time() * 1000)}, data=payload,
            files={'custom_face': (filename, fileobj)},
            headers={
                'Origin': 'http://web2.qq.com',
                'Referer': 'http://web2.qq.com/webqq.html',
                'User-Agent': UA_STRING,
            },
        )
        fileobj.close()

        cfaceid = re.findall(r'''['"]msg['"]: *['"]([^'"]+)['"] *}''', resp.content)[0]
        cfaceid = cfaceid.split()[0]

        font = {
            'name': u'宋体',
            'size': 10,
            'style': [0, 0, 0],
            'color': '000000',
        }
        msg_id = self.tick.next()
        content = [['cface', 'group', cfaceid], '\n', ['font', font]]

        payload = {
            'group_uin': group_uin,
            'content': json.dumps(content),
            'msg_id': msg_id,
            'clientid': str(self.clientid),
            'psessionid': self.psessionid,
            'key': self.gface_key,
            'sig': self.gface_sig,
        }

        self.call_server('d:send_qun_msg2', payload, clientid=self.clientid, psessionid=self.psessionid)

    def send_sess_message(self, group_id, uin, message, font=None):
        # NOTE: group_id(==group_uin), gcode, and group number is not the same thing
        log.info('send_sess_message(%d, %d, %r)', group_id, uin, message)
        self.ready.wait()
        msg_id = self.tick.next()
        content = self._format_message(message, font)

        gsig = self._get_c2cmsg_sig(group_id, uin)

        payload = {
            'clientid': self.clientid,
            'content': json.dumps(content),
            'face': 558,
            'group_sig': gsig,
            'msg_id': msg_id,
            'psessionid': self.psessionid,
            'service_type': 0,
            'to': uin,
        }

        self.call_server('d:send_sess_msg2', payload, clientid=self.clientid, psessionid=self.psessionid)

    def _get_c2cmsg_sig(self, group_id, uin):
        cache = self.cache['c2cmsg']
        if group_id in cache:
            return cache[(group_id, uin)]

        log.debug('Getting c2cmsg sig for group=%d, uin=%d', group_id, uin)
        self.ready.wait()

        rst = self.call_server('d:get_c2cmsg_sig2', method='get',
            id=group_id,
            to_uin=uin,
            service_type=0,
            clientid=self.clientid,
            psessionid=self.psessionid,
            t=int(time.time()*1000),
        )

        if rst['retcode']:
            log.error('Error in get_c2cmsg_sig: %r', rst)
            return ''

        rst = rst['result']['value']
        cache[(group_id, uin)] = rst
        return rst

    def _uin2account(self, uin, type, cache, verifysession='', code='', vctag=0):
        uin = int(uin)
        cache = self.cache[cache]
        if uin in cache:
            return cache[uin]

        rst = self.call_server('s:get_friend_uin2', method='get',
            tuin=uin,
            verifysession=verifysession,
            type=type,
            vfwebqq=self.vfwebqq,
            code=code,
            t=int(time.time() * 1000),
        )

        rcode = rst['retcode']

        if rcode == 0:
            cache[uin] = rst['result']['account']
            return rst['result']['account']
        elif rcode in (1000, 1001):
            # captcha needed
            if rcode == 1001:
                self.on_captcha_wrong(vctag)

            verifysession, vc, vctag = self._new_verify_session()
            return self._uin2account(uin, type, cache, verifysession, vc, vctag)
        else:
            assert False, 'Unexpected retcode %d' % rcode

    def _new_verify_session(self):
        privsess = requests.session()
        captcha = privsess.get('http://captcha.qq.com/getimage', params={'aid': self.appid})
        verifysession = privsess.cookies['verifysession']
        vc, vctag = self.on_captcha(captcha.content)
        return verifysession, vc, vctag

    uin2qq = lambda self, uin: self._uin2account(uin, 1, 'uin2qq')
    gcode2groupnum = lambda self, gcode: self._uin2account(gcode, 4, 'gcode2groupnum')

    def allow_friend_request(self, qq):
        log.info(u'Accepting friend request: %d', qq)
        self.ready.wait()
        self.call_server('s:allow_and_add2', {
            'account': qq,
            'gid': 0,
            'mname': '',
            'vfwebqq': self.vfwebqq,
        })

    def deny_friend_request(self, qq, reason=''):
        log.info(u'Denying friend request: %d, %s', qq, reason)
        self.ready.wait()
        self.call_server('s:deny_added_request2', {
            'account': qq,
            'msg': reason,
            'vfwebqq': self.vfwebqq,
        })

    def delete_friend(self, uin):
        log.info(u'Deleting friend: %d', self.uin2qq(uin))
        self.ready.wait()
        try:
            del self.cache['uin2qq'][uin]
        except:
            pass

        self.call_server('s:delete_friend', tuin=uin, delType=2, vfwebqq=self.vfwebqq)

    def search_and_add(self, qq, verify_msg):
        log.info(u'Search and add: %d', qq)
        self.ready.wait()
        verifysession, vc, vctag = self._new_verify_session()

        rst = self.call_server('s:search_qq_by_uin2', method='get',
            tuin=qq,
            verifysession=verifysession,
            code=vc,
            vfwebqq=self.vfwebqq,
            t=int(time.time() * 1000),
        )

        if rst['result'] in (1000, 1001, 100000):
            # Wrong captcha? perhaps.
            # Not reporting wrong captcha for safety
            time.sleep(1)
            return self.search_qq_by_uin2(qq, verify_msg)

        token = rst['result']['token']

        rst = self.call_server('s:add_need_verify2', {
            'account': qq,
            'myallow': 1,
            'groupid': 1,
            'msg': verify_msg,
            'token': token,
            'vfwebqq': self.vfwebqq,
        })

    def call_server(self, api, r=None, method='post', **payloads):
        ns, api_name = api.split(':')
        conf = {
            'd': {
                'url': 'http://d.web2.qq.com/channel/{api_name}',
                'referer': 'http://d.web2.qq.com/proxy.html?v=%s&callback=1&id=1' % self.v,
                'origin': 'http://d.web2.qq.com',
            },
            's': {
                'url': 'http://s.web2.qq.com/api/{api_name}',
                'referer': 'http://s.web2.qq.com/proxy.html?v=%s&callback=1&id=1' % self.v,
                'origin': 'http://s.web2.qq.com',
            },
        }[ns]
        req = {}
        r and req.update({'r': json.dumps(r, ensure_ascii=False)})
        req.update(payloads)

        headers = {
            'Referer': conf['referer'],
            'Origin': conf['origin'],
            'User-Agent': UA_STRING,
        }

        if method == 'post':
            resp = self.session.post(
                conf['url'].format(api_name=api_name),
                data=req, headers=headers,
            )
        elif method == 'get':
            resp = self.session.get(
                conf['url'].format(api_name=api_name),
                params=req, headers=headers,
            )

        if not resp.ok:
            raise Exception('Failed server call: %s' % resp.content)

        return json.loads(resp.content)

    # ----------------

    @staticmethod
    def _encode_password(uin, passwd, vc):
        from hashlib import md5 as _md5
        md5 = lambda x: _md5(x).digest()
        md5hex = lambda x: md5(x).encode('hex').upper()
        return md5hex(md5hex(md5(passwd) + uin) + vc.upper())

    @staticmethod
    def _jsonp2list(jsonp):
        args = jsonp[jsonp.find('(') + 1: jsonp.rfind(')')]
        return [i.strip("' ") for i in args.split(',')]

    @staticmethod
    def _plaintext(content):
        l = [i for i in content if isinstance(i, basestring)]
        return u''.join(l)

    @staticmethod
    def _buddylist_hash(qq, ptwebqq):
        a = [0] * 4
        for i, v in enumerate(ptwebqq):
            a[i % 4] ^= ord(v)

        qq = int(qq)
        d = [
            qq >> 24 & 255 ^ ord('E'),
            qq >> 16 & 255 ^ ord('C'),
            qq >> 8 & 255 ^ ord('O'),
            qq & 255 ^ ord('K'),
        ]
        j = ''.join([chr(a[s >> 1] if s % 2 == 0 else d[s >> 1]) for s in xrange(8)])
        return j.encode('hex').upper()

    @staticmethod
    def _buddylist_hash_old(qq, ptwebqq):
        L = list(struct.unpack('BBBB', struct.pack('>I', int(qq))))
        T = [ord(i) for i in ptwebqq]
        V = [(0, len(T) - 1)]

        while V:
            s, e = V.pop()
            if (s >= e or s < 0 or e >= len(T)):
                continue

            if s + 1 == e:
                if T[s] > T[e]: T[s], T[e] = T[e], T[s]
                continue

            Z = s
            U = e
            ba = T[s]
            while s < e:
                while s < e and T[e] >= ba:
                    e -= 1
                    L[0] = (L[0] + 3) & 255
                if s < e:
                    T[s] = T[e]
                    s += 1
                    L[1] = (L[1] * 13 + 43) & 255
                while s < e and T[s] <= ba:
                    s += 1
                    L[2] = (L[2] - 3) & 255
                if s < e:
                    T[e] = T[s]
                    e -= 1
                    L[3] = (L[0] ^ L[1] ^ L[2] ^ L[3] + 1) & 255

            T[s] = ba
            V.extend([(Z, s - 1), (s + 1, U)])

        V = struct.pack('BBBB', *L).encode('hex').upper()
        return V

# group admin kicks you
# <sys_g_msg> =
# {u'admin_nick': u'\u521b\u5efa\u8005',
#  u'admin_uin': 1031178679,
#  u'from_uin': 4055931059,
#  u'gcode': 1494214629,
#  u'msg_id': 29561,
#  u'msg_id2': 816530,
#  u'msg_type': 34,
#  u'old_member': 2290168915,
#  u'op_type': 3,
#  u'reply_ip': 176756757,
#  u't_admin_uin': u'',
#  u't_gcode': 244369943,
#  u't_old_member': u'',
#  u'to_uin': 2290168915,
#  u'type': u'group_leave'}

# <buddylist_change> = {u'added_friends': [], u'removed_friends': [{u'uin': 424353965}]}
# <buddylist_change> = {u'added_friends': [{u'groupid': 0, u'uin': 1499465057}], u'removed_friends': []}

########NEW FILE########
__FILENAME__ = executive
# -*- coding: utf-8 -*-
from network.client import Server
import gevent
from gevent import socket, Greenlet

from account import Account
from utils import BatchList

import logging
log = logging.getLogger('Executive')


class ForcedKill(gevent.GreenletExit): pass


class GameManager(Greenlet):
    '''
    Handles server messages, all game related operations.
    '''
    def __init__(self):
        Greenlet.__init__(self)
        self.state = 'connected'
        self.game = None
        self.last_game = None

    def _run(self):
        from gamepack import gamemodes
        handlers = {}

        def handler(_from, _to):
            def register(f):
                handlers[f.__name__] = (f, _from, _to)
            return register

        @handler(('inroom', 'ingame'), None)
        def player_change(self, data):
            self.players_data = data
            if self.state == 'ingame':
                data1 = []
                for p in data:
                    acc = Account.parse(p['account'])
                    for i, pl in enumerate(self.game.players):
                        if pl.account.userid != acc.userid: continue
                        data1.append(p)
                        self.game.players[i].dropped = (p['state'] in ('dropped', 'fleed'))

                self.event_cb('player_change', data1)
            else:
                self.event_cb('player_change', data)

        @handler(('inroom',), 'ingame')
        def game_started(self, pldata):
            Executive.server.gclear()
            if self.last_game:
                self.last_game.kill(ForcedKill)
                self.last_game.get()
                self.last_game = None

            from client.core import PeerPlayer, TheChosenOne
            pl = [PeerPlayer.parse(i) for i in pldata]
            pid = [i.account.userid for i in pl]
            me = TheChosenOne(Executive.server)
            me.account = self.account
            i = pid.index(me.account.userid)
            pl[i] = me
            g = self.game
            g.me = me
            g.players = BatchList(pl)
            #g.start()
            log.info('=======GAME STARTED: %d=======' % g.gameid)
            log.info(g)

            @g.link_exception
            def crash(*a):
                self.event_cb('game_crashed', g)

            @g.link_value
            def finish(*a):
                v = g.get()
                if not isinstance(v, ForcedKill):
                    self.event_cb('client_game_finished', g)

            self.event_cb('game_started', g)

        @handler(('inroom',), 'ingame')
        def observe_started(self, data):
            Executive.server.gclear()
            if self.last_game:
                self.last_game.kill(ForcedKill)
                self.last_game.get()
                self.last_game = None

            tgtid, pldata = data
            from client.core import PeerPlayer, TheLittleBrother
            pl = [PeerPlayer.parse(i) for i in pldata]
            pid = [i.account.userid for i in pl]
            i = pid.index(tgtid)
            g = self.game
            g.players = BatchList(pl)
            me = g.players[i]
            me.__class__ = TheLittleBrother
            me.server = Executive.server
            g.me = me
            #g.start()
            log.info('=======OBSERVE STARTED=======')
            log.info(g)

            @g.link_exception
            def crash(*a):
                self.event_cb('game_crashed', g)

            @g.link_value
            def finish(*a):
                v = g.get()
                if not isinstance(v, ForcedKill):
                    self.event_cb('client_game_finished', g)

            self.event_cb('game_started', g)

        @handler(('hang', 'inroom'), 'inroom')
        def game_joined(self, data):
            self.game = gamemodes[data['type']]()
            self.game.gameid = int(data['id'])
            self.event_cb('game_joined', self.game)

        @handler(('ingame',), 'hang')
        def fleed(self, data):
            self.game.kill(ForcedKill)
            self.game = None
            log.info('=======FLEED=======')
            Executive.server.gclear()
            self.event_cb('fleed')

        @handler(('ingame', 'inroom'), 'hang')
        def game_left(self, data):
            self.game.kill(ForcedKill)
            self.game = None
            log.info('=======GAME LEFT=======')
            Executive.server.gclear()
            self.event_cb('game_left')

        @handler(('ingame',), 'hang')
        def end_game(self, data):
            self.event_cb('end_game', self.game)
            log.info('=======GAME ENDED=======')
            self.last_game = self.game

        @handler(('connected',), None)
        def auth_result(self, status):
            if status == 'success':
                self.event_cb('auth_success')
                self.state = 'hang'
            else:
                self.event_cb('auth_failure', status)

        @handler(None, None)
        def your_account(self, accdata):
            self.account = acc = Account.parse(accdata)
            self.event_cb('your_account', acc)

        @handler(None, None)
        def thbattle_greeting(self, ver):
            from settings import VERSION
            if ver != VERSION:
                self.event_cb('version_mismatch')
                Executive.call('disconnect')
            else:
                self.event_cb('server_connected', self)

        @handler(None, None)
        def ping(self, _):
            Executive.server.write(['pong', True])

        @gevent.spawn
        def beater():
            while True:
                gevent.sleep(10)
                Executive.server.write(['heartbeat', None])

        while True:
            cmd, data = Executive.server.ctlcmds.get()
            h = handlers.get(cmd)
            if h:
                f, _from, _to = h
                if _from:
                    assert self.state in _from, 'Calling %s in %s state' % (f.__name__, self.state)
                if f: f(self, data)
                if _to: self.state = _to
            else:
                self.event_cb(cmd, data)


class Executive(Greenlet):
    '''
    Handles UI commands
    '''
    def __init__(self):
        Greenlet.__init__(self)
        # from utils import ITIEvent
        # self.event = ITIEvent()
        from gevent.event import Event
        self.event = Event()
        self.msg_queue = []
        # This callback is called when executive completed a request
        # Called with these args:
        # callback('message', *results)
        self.default_callback = lambda *a, **k: False
        self.state = 'initial'  # initial connected

    def call(self, _type, cb=None, *args):
        if not cb:
            cb = self.default_callback
        self.msg_queue.append((_type, cb, args))
        self.event.set()

    def _run(self):
        handlers = {}

        def handler(f):
            handlers[f.__name__] = f

        @handler
        def app_exit(self, cb):
            raise gevent.GreenletExit

        @handler
        def connect_server(self, cb, addr, event_cb):
            if not self.state == 'initial':
                cb('server_already_connected')
                return
            try:
                s = socket.create_connection(addr)
                svr = Server.spawn(s, 'TheChosenOne')
                self.server = svr
                self.state = 'connected'
                self.gamemgr = GameManager()
                self.gamemgr.start()
                self.gamemgr.event_cb = event_cb

                svr.link_exception(lambda *a: event_cb('server_dropped'))

                #cb('server_connected', svr)
            except:
                cb('server_connect_failed', None)

        @handler
        def disconnect(self, cb):
            if self.state != 'connected':
                cb('not_connected')
                return
            else:
                self.server.close()
                self.state = 'initial'
                self.gamemgr.kill()
                self.server = self.gamemgr = None
                cb('disconnected')

        @handler
        def update(self, cb, update_cb):
            import autoupdate as au
            from options import options
            import settings
            if not options.no_update:
                base = settings.UPDATE_BASE
                url = settings.UPDATE_URL
                gevent.spawn(lambda: cb(au.do_update(base, url, update_cb)))
            else:
                cb('update_disabled')

        @handler
        def auth(self, cb, arg):
            if not (self.state == 'connected'):
                cb('general_failure', 'Connect first!')
                return
            self.server.write(['auth', arg])

        @handler
        def fetch_resource(self, cb, url):
            def worker():
                import urllib2
                from client.ui.base import ui_schedule
                try:
                    resp = urllib2.urlopen(url)
                    data = resp.read()
                except:
                    ui_schedule(cb, False)
                    return

                ui_schedule(cb, (resp, data))
            gevent.spawn(worker)

        # @handler def register(...): ...
        def simple_gm_op(_type):
            def wrapper(self, cb, *args):
                if not (self.state == 'connected'):
                    cb('general_failure', 'Connect first!')
                    return
                self.server.write([_type, args[0]])
            wrapper.__name__ = _type
            return wrapper
        ops = [
            # FIXME: the quick start thing should be done at client
            'cancel_ready',
            'change_location',
            'chat',
            'create_game',
            'exit_game',
            'get_hallinfo',
            'get_ready',
            'join_game',
            'kick_user',
            'kick_observer',
            'observe_grant',
            'observe_user',
            'invite_user',
            'invite_grant',
            'query_gameinfo',
            'quick_start_game',
            'register',
            'speaker',
        ]
        for op in ops:
            handler(simple_gm_op(op))

        while True:
            self.event.wait()

            for _type, cb, args in self.msg_queue:
                f = handlers.get(_type)
                if f:
                    f(self, cb, *args)
                else:
                    raise Exception('Executive: No such handler: %s' % _type)

            self.msg_queue = []
            self.event.clear()

Executive = Executive.spawn()

########NEW FILE########
__FILENAME__ = game_client
# -*- coding: utf-8 -*-

# -- stdlib --
import logging
log = logging.getLogger('Game_Client')
from copy import copy
from collections import OrderedDict

# -- third party --
import gevent
from gevent import Greenlet

# -- own --
import game
from game import TimeLimitExceeded, InputTransaction, GameEnded
from utils import BatchList
from account import Account

# -- code --


def user_input(players, inputlet, timeout=25, type='single', trans=None):
    '''
    Type can be 'single', 'all' or 'any'
    '''
    assert type in ('single', 'all', 'any')
    assert not type == 'single' or len(players) == 1

    timeout = max(0, timeout)

    g = Game.getgame()
    inputlet.timeout = timeout
    players = list(players)

    if not trans:
        with InputTransaction(inputlet.tag(), players) as trans:
            return user_input(players, inputlet, timeout, type, trans)

    t = {'single': '', 'all': '&', 'any': '|'}[type]
    tag = 'I{0}:{1}:'.format(t, inputlet.tag())

    ilets = {p: copy(inputlet) for p in players}
    for p in players:
        ilets[p].actor = p

    inputproc = None

    def input_func(st):
        my = ilets[g.me]
        with TimeLimitExceeded(timeout + 1, False):
            _, my = g.emit_event('user_input', (trans, my))

        g.me.server.gwrite(tag + str(st), my.data())

    results = {p: None for p in players}

    synctags = {p: g.get_synctag() for p in players}
    synctags_r = {v: k for k, v in synctags.items()}

    try:
        for p in players:
            g.emit_event('user_input_start', (trans, ilets[p]))

        if g.me in players:  # me involved
            if not g.me.is_observer:  # Not observer or other things
                inputproc = gevent.spawn(input_func, synctags[g.me])

        orig_players = players[:]
        inputany_player = None

        while players:
            # should be [tag, <Data for Inputlet.parse>]
            # tag likes 'RI?:ChooseOption:2345'
            tag_, data = g.me.server.gexpect('R%s*' % tag)
            st = int(tag_.split(':')[2])
            if st not in synctags_r:
                log.warning('Unexpected sync tag: %d', st)
                continue

            p = synctags_r[st]

            my = ilets[p]

            try:
                rst = my.parse(data)
            except:
                log.error('user_input: exception in .process()', exc_info=1)
                # ----- FOR DEBUG -----
                if g.IS_DEBUG:
                    raise
                # ----- END FOR DEBUG -----
                rst = None

            rst = my.post_process(p, rst)

            g.emit_event('user_input_finish', (trans, my, rst))

            players.remove(p)
            results[p] = rst

            # also remove from synctags
            del synctags_r[st]
            del synctags[p]

            if type == 'any' and rst is not None:
                assert not inputany_player
                inputany_player = p

    finally:
        if inputproc:
            inputproc.kill()
            inputproc.join()

    if type == 'single':
        return results[orig_players[0]]

    elif type == 'any':
        if not inputany_player:
            return None, None

        return inputany_player, results[inputany_player]

    elif type == 'all':
        return OrderedDict([(i, results[i]) for i in orig_players])

    assert False, 'WTF?!'


class TheChosenOne(game.AbstractPlayer):
    dropped = False
    is_observer = False

    def __init__(self, server):
        self.server = server
        game.AbstractPlayer.__init__(self)

    def reveal(self, obj_list):
        # It's me, server will tell me what the hell these is.
        g = Game.getgame()
        st = g.get_synctag()
        _, raw_data = self.server.gexpect('Sync:%d' % st)
        if isinstance(obj_list, (list, tuple)):
            for o, rd in zip(obj_list, raw_data):
                o.sync(rd)
        else:
            obj_list.sync(raw_data)  # it's single obj actually

    def update(self, data):
        # It's me and I know everything about myself
        pass


class PeerPlayer(game.AbstractPlayer):
    dropped = False
    is_observer = False

    def __init__(self):
        game.AbstractPlayer.__init__(self)

    def reveal(self, obj_list):
        # Peer player, won't reveal.
        Game.getgame().get_synctag()  # must sync

    def update(self, data):
        # data comes from server.core.Player.__data__
        self.account = Account.parse(data['account'])
        self.state = data['state']

    @classmethod
    def parse(cls, data):
        pp = cls()
        pp.update(data)
        return pp

    # account = < set by update >


class TheLittleBrother(PeerPlayer):
    # Big brother is watching you!
    is_observer = True
    reveal = TheChosenOne.reveal.im_func


class Game(Greenlet, game.Game):
    '''
    The Game class, all game mode derives from this.
    Provides fundamental behaviors.

    Instance variables:
        players: list(Players)
        event_handlers: list(EventHandler)

        and all game related vars, eg. tags used by [EventHandler]s and [Action]s
    '''
    thegame = None
    CLIENT_SIDE = True
    SERVER_SIDE = False
    event_observer = None

    import random  # noqa, intentionally put here

    def __init__(self):
        Greenlet.__init__(self)
        game.Game.__init__(self)
        self.players = BatchList()

    def _run(self):
        self.synctag = 0
        Game.thegame = self
        try:
            self.game_start()
        except GameEnded:
            pass

        assert self.ended

    @classmethod
    def getgame(cls):
        return cls.thegame
        #return getcurrent()

    def get_synctag(self):
        self.synctag += 1
        return self.synctag

    def emit_event(self, evt_type, data):
        if self.event_observer:
            self.event_observer.handle(evt_type, data)

        return game.Game.emit_event(self, evt_type, data)

    def pause(self, time):
        gevent.sleep(time)

    def _get_me(self):
        me = self._me
        for i in self.players:
            if i is me:
                return i

            if getattr(i, 'player', 0) is me:
                return i

        raise AttributeError('WTF?!')

    def _set_me(self, me):
        self._me = me

    me = property(_get_me, _set_me)

########NEW FILE########
__FILENAME__ = baseclasses
# -*- coding: utf-8 -*-
import pyglet

from pyglet.gl import glBlendFunc, glClearColor, glEnable, glLoadIdentity, glMatrixMode, glOrtho
from pyglet.gl import glPolygonMode, glPopMatrix, glPushMatrix, glTranslatef, glViewport
from pyglet.gl import GL_BACK, GL_BLEND, GL_FILL, GL_FRONT, GL_LINE, GL_MODELVIEW
from pyglet.gl import GL_ONE_MINUS_SRC_ALPHA, GL_PROJECTION, GL_SRC_ALPHA

from time import time

from functools import partial

WINDOW_WIDTH = 1024
WINDOW_HEIGHT = 720

main_window = None
sched_queue = []

from utils import hook

import logging
log = logging.getLogger('UI_Baseclasses')


class Control(pyglet.event.EventDispatcher):
    def __init__(self, x=0, y=0, width=0, height=0,
                zindex=0, parent=None, can_focus=False, manual_draw=False,
                *args, **kwargs):

        self.__dict__.update({
            'parent': parent,
            'x': x, 'y': y,
            '_w': width, '_h': height,
            'zindex': zindex,
            'can_focus': can_focus,
            'manual_draw': manual_draw,
        })
        self.__dict__.update(kwargs)
        self.control_list = []
        # control under cursor now, for tracking enter/leave events
        self._control_hit = None
        if parent:
            parent.add_control(self)
        else:
            self.parent = parent
            self.overlay = False

    def _set_w(self, v):
        self._w = v
        self.dispatch_event('on_resize', self._w, self._h)

    def _get_w(self):
        return self._w

    width = property(_get_w, _set_w)

    def _set_h(self, v):
        self._h = v
        self.dispatch_event('on_resize', self._w, self._h)

    def _get_h(self):
        return self._h

    height = property(_get_h, _set_h)

    def add_control(self, c):
        self.control_list.append(c)
        c.parent = self
        c.overlay = self if isinstance(self, Overlay) else self.overlay

    def remove_control(self, c):
        self.control_list.remove(c)
        c.parent = None
        c.overlay = None

    def delete(self):
        if self.parent:
            self.parent.remove_control(self)

    def controls_frompoint(self, x, y):
        l = []
        for c in self.control_list:
            if c.x <= x <= c.x + c.width and c.y <= y <= c.y + c.height:
                if c.hit_test(x-c.x, y-c.y):
                    l.append(c)
        return l

    def control_frompoint1(self, x, y):
        l = self.controls_frompoint(x, y)
        # l.sort(key=lambda c: c.zindex, reverse=True)
        l.sort(key=lambda c: c.zindex)
        while l:
            c = l[-1]
            rst = c.hit_test(x-c.x, y-c.y)
            if rst:
                return c
            else:
                del l[-1]
                continue
        else:
            return None

    def control_frompoint1_recursive(self, x, y):
        c = self
        while True:
            c1 = c.control_frompoint1(x, y)
            if not c1: return c
            x -= c1.x; y -= c1.y; c = c1

    def hit_test(self, x, y):
        return True

    @staticmethod
    def batch_draw(l):
        glPushMatrix()
        for c in l:
            glLoadIdentity()
            x, y = c.abs_coords()
            glTranslatef(x, y, 0)
            c.draw()

        glPopMatrix()

    def draw(self):
        # default behaviors
        self.draw_subcontrols()

    @staticmethod
    def do_draw(cl):
        cl.sort(key=lambda c: (c.zindex, c.batch_draw))
        cl = [c for c in cl if not c.manual_draw]
        if not cl: return

        f = cl[0].batch_draw
        commit = []
        for c in cl:
            if c.batch_draw == f:
                commit.append(c)
            else:
                f(commit)
                commit = [c]
                f = c.batch_draw

        if commit: f(commit)

    def draw_subcontrols(self):
        self.do_draw(self.control_list)

    def set_focus(self):
        if not self.can_focus: return
        o = self.parent
        while not isinstance(o, Overlay):
            o = o.parent

        if o:
            if o.current_focus != self:
                if o.current_focus:
                    o.current_focus.dispatch_event('on_lostfocus')
                self.dispatch_event('on_focus')
                o.current_focus = self

    def set_capture(self, *evts):
        o = self.overlay
        for e in evts:
            o._capture_events.setdefault(e, []).append(self)

    def release_capture(self, *evts):
        o = self.overlay
        for e in evts:
            l = o._capture_events.get(e)
            if l:
                l.remove(self)

    def abs_coords(self):
        c, ax, ay = self, 0.0, 0.0
        while c and not isinstance(c, Overlay):
            ax += c.x
            ay += c.y
            c = c.parent
        return (ax, ay)

    def migrate_to(self, new_parent):
        if self in new_parent.control_list:
            return

        ax, ay = self.abs_coords()
        npax, npay = new_parent.abs_coords()
        self.delete()
        new_parent.add_control(self)
        self.x, self.y = ax-npax, ay-npay

    def on_message(self, *args):
        '''Do nothing'''
        pass

    xy = property(lambda self: (self.x, self.y))


class Overlay(Control):
    '''
    Represents current screen
    '''
    class DummyOverlay(object):
        def dispatch_event(*args):
            pass

    cur_overlay = DummyOverlay()

    def __init__(self, *args, **kwargs):
        Control.__init__(
            self, width=WINDOW_WIDTH, height=WINDOW_HEIGHT, parent=False
        )
        self.__dict__.update(kwargs)
        self.last_mouse_press = [  # WONTFIX: Button combinations not supported.
            None,
            (0.0, None, 0.0, 0.0),  # (time(), self._control_hit, x, y) LEFT
            (0.0, None, 0.0, 0.0),  # MIDDLE
            None,                   # Not used
            (0.0, None, 0.0, 0.0),  # RIGHT
        ]
        self.last_mouse_release = [
            None,
            (0.0, None, 0.0, 0.0),  # (time(), self._control_hit, x, y) LEFT
            (0.0, None, 0.0, 0.0),  # MIDDLE
            None,                   # Not used
            (0.0, None, 0.0, 0.0),  # RIGHT
        ]
        self.current_focus = None
        self._capture_events = {}

    def draw(self):
        main_window.clear()
        self.draw_subcontrols()

    def switch(self):
        ori = Overlay.cur_overlay
        ori.dispatch_event('on_switchout')
        Overlay.cur_overlay = self
        main_window.set_handlers(self)
        self.dispatch_event('on_switch')

        # HACK
        import gc
        gc.collect()
        # -----

        return ori

    def on_resize(self, width, height):
        glViewport(0, 0, width, height)
        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()
        glOrtho(0, width, 0, height, -1000, 1000)
        glMatrixMode(GL_MODELVIEW)
        return pyglet.event.EVENT_HANDLED

    def _position_events(self, _type, x, y, *args):
        cap_list = self._capture_events.setdefault(_type, [])[:]

        def dispatch(this, lx, ly):
            # Top most control get event
            c = this.control_frompoint1(lx, ly)
            lc = this._control_hit
            if c != lc:
                while lc:
                    lc.dispatch_event('on_mouse_leave', lx - lc.x, ly - lc.y)
                    lc._control_hit, lc = None, lc._control_hit
                if c:
                    c.dispatch_event('on_mouse_enter', lx - c.x, ly - c.y)
            this._control_hit = c

            if not c:
                # Now 'this' has no subcontrols hit, so 'this' got this event
                # TODO: if 'this' don't handle it, its parent should handle.
                if this is not self:
                    if _type == 'on_mouse_press':
                        this.set_focus()
            else:
                if dispatch(c, lx - c.x, ly - c.y):  # TODO: not recursive
                    return True
                if not c in cap_list:  # do not redispatch the same event
                    return c.dispatch_event(_type, lx - c.x, ly - c.y, *args)

        # capturing events
        for con in cap_list:
            ax, ay = con.abs_coords()
            if con.dispatch_event(_type, x-ax, y-ay, *args):
                return True
        
        return dispatch(self, x, y)

    def on_mouse_press(self, x, y, button, modifier):
        self.last_mouse_press[button] = (time(), self._control_hit, x, y)
        self._position_events('on_mouse_press', x, y, button, modifier)

    def on_mouse_release(self, x, y, button, modifier):
        lp = self.last_mouse_press[button]
        lr = self.last_mouse_release[button]
        cr = (time(), self._control_hit, x, y)
        self.last_mouse_release[button] = cr
        self._position_events('on_mouse_release', x, y, button, modifier)
        # single click
        if cr[1] == lp[1]:
            self._position_events('on_mouse_click', x, y, button, modifier)

        # double click
        if cr[0]-lr[0] < 0.2:  # time limit
            if abs(cr[2] - lr[2]) + abs(cr[3] - lr[3]) < 4:  # shift limit
                if cr[1] == lr[1]:  # Control limit
                    self._position_events('on_mouse_dblclick', x, y, button, modifier)

    on_mouse_motion = lambda self, *args: self._position_events('on_mouse_motion', *args)
    on_mouse_drag = lambda self, *args: self._position_events('on_mouse_drag', *args)
    on_mouse_scroll = lambda self, *args: self._position_events('on_mouse_scroll', *args)

    def _text_events(self, _type, *args):
        cap_list = self._capture_events.setdefault(_type, [])
        if cap_list:
            con = cap_list[-1]
            con.dispatch_event(_type, *args)
        if self.current_focus:
            self.current_focus.dispatch_event(_type, *args)

    on_key_press = lambda self, *args: self._text_events('on_key_press', *args)
    on_key_release = lambda self, *args: self._text_events('on_key_release', *args)
    on_text = lambda self, *args: self._text_events('on_text', *args)
    on_text_motion = lambda self, *args: self._text_events('on_text_motion', *args)
    on_text_motion_select = lambda self, *args: self._text_events('on_text_motion_select', *args)

    def dispatch_message(self, args):
        l = [self]
        while l:
            c = l.pop(0)
            c.dispatch_event('on_message', *args)
            l.extend(c.control_list)

    def on_message(self, _type, *args):
        if _type == 'app_exit':
            pyglet.app.exit()

Control.register_event_type('on_key_press')
Control.register_event_type('on_key_release')
Control.register_event_type('on_text')
Control.register_event_type('on_text_motion')
Control.register_event_type('on_text_motion_select')
Control.register_event_type('on_mouse_motion')
Control.register_event_type('on_mouse_press')
Control.register_event_type('on_mouse_drag')
Control.register_event_type('on_mouse_release')
Control.register_event_type('on_mouse_scroll')
Control.register_event_type('on_mouse_enter')
Control.register_event_type('on_mouse_leave')
Control.register_event_type('on_mouse_click')
Control.register_event_type('on_mouse_dblclick')
Control.register_event_type('on_focus')
Control.register_event_type('on_lostfocus')
Control.register_event_type('on_message')
Control.register_event_type('on_resize')

Overlay.register_event_type('on_switch')
Overlay.register_event_type('on_switchout')


def init_gui():
    global main_window, sched_queue, current_time, fps_limit

    config = pyglet.gl.Config(
        double_buffer=True,
        buffer_size=32,
        aux_buffers=0,
        sample_buffers=0,
        samples=0,
        red_size=8,
        green_size=8,
        blue_size=8,
        alpha_size=8,
        depth_size=0,
        stencil_size=0,
        accum_red_size=0,
        accum_green_size=0,
        accum_blue_size=0,
        accum_alpha_size=0,
    )

    main_window = pyglet.window.Window(
        width=WINDOW_WIDTH, height=WINDOW_HEIGHT, caption=u'东方符斗祭',
        config=config, visible=False
    )
    sched_queue = []

    from pyglet.gl import gl_info
    vendor = gl_info.get_vendor().lower()
    if 'amd' in vendor or 'ati' in vendor:
        pyglet.options['graphics_vbo'] = False  # AMD: Do you have QA team for your OpenGL driver ????
        from pyglet.graphics import vertexbuffer
        assert not vertexbuffer._enable_vbo

    # custom font renderer
    from .font import AncientPixFont
    pyglet.font._font_class = AncientPixFont

    # main window setup {{
    glClearColor(1, 1, 1, 1)
    glEnable(GL_BLEND)
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
    #glEnable(GL_SCISSOR_TEST)
    glPolygonMode(GL_FRONT, GL_FILL)
    glPolygonMode(GL_BACK, GL_LINE)

    def_overlay = Overlay()
    def_overlay.name = 'Overlay'
    def_overlay.switch()
    # }} main window setup

    fps = pyglet.clock.ClockDisplay()
    fps_limit = 60
    delay = 1. / fps_limit
    current_time = time()

    @main_window.event
    def on_draw():
        global current_time
        current_time = time()
        Overlay.cur_overlay.draw()
        fps.draw()

    @main_window.event
    def on_close():
        # HACK: suppress exceptions,
        # dont want to explain....
        pyglet.clock.tick = lambda a: 0.0
        pyglet.app.exit()

    @hook(main_window)
    def on_key_press(ori, symbol, modifiers):
        if symbol == pyglet.window.key.ESCAPE:
            return pyglet.event.EVENT_HANDLED
        return ori(symbol, modifiers)

    def _dispatch_msg(dt):
        global sched_queue
        import gevent

        # give logics a chance to run
        gevent.sleep(0)

        if not sched_queue: return

        for func in sched_queue:
            func()

        sched_queue = []

    pyglet.clock.schedule_interval(_dispatch_msg, delay)


def ui_schedule(func, *args, **kwargs):
    global sched_queue
    sched_queue.append(partial(func, *args, **kwargs))


def process_msg(args):
    Overlay.cur_overlay.dispatch_message(args)


def ui_message(*args):
    '''
    Send message to UI
    '''
    ui_schedule(process_msg, args)

########NEW FILE########
__FILENAME__ = font
# -*- coding: utf-8 -*-

import pyglet
from pyglet.gl import GL_ALPHA, GL_TEXTURE_2D
from pyglet.font.base import GlyphRenderer, Font
from math import ceil
from PIL import Image


class AncientPixGlyphRenderer(GlyphRenderer):
    gbk_cols = 191
    gbk_rows = 126

    def __init__(self, font):
        GlyphRenderer.__init__(self, font)
        self.font = font

    def render(self, text):
        glyph = self.render_char(text, 0)
        thin = self.render_char(text, 1)
        thick = self.render_char(text, 2)
        glyph.shadows = [None, thin, thick]
        return glyph

    def render_char(self, text, type):
        char = u'⑨' if self.font.password else text[0]
        asc = ord(char)
        font = self.font
        suffix = ('BLOAT', 'SHADOWTHIN', 'SHADOWTHICK')[type]

        if font.size == 9:
            suffix = '12' + suffix
        else:
            suffix = '16' + suffix

        if char in u'♠♡♣♢':
            # special case for suits
            i = u'♠♡♣♢'.index(char)
            if font.size == 9:
                h = 12
                grid = font.suit12
            else:
                h = 16
                grid = font.suit16

            glyph = font.create_glyph(grid[i])
            glyph.set_bearings(1, -2, h + 1)
            return glyph

        elif char == u'\u200b':
            glyph = font.create_glyph(
                pyglet.image.ImageData(1, 1, 'RGBA', '\xFF'*4)
            )
            glyph.set_bearings(0, 0, 0)
            glyph.vertices = (0, 0, 0, 0)
            return glyph

        elif asc < 128:  # ASCII
            h = int(font.size*4/3)
            w = h // 2
            w += 4
            h += 4
            datasz = int(ceil(w/8.))*h

            fontdata = self.font.fontdata['ASC%s' % suffix]
            loc = asc * datasz
            data = fontdata[loc:loc+datasz]
            i = Image.fromstring('1', (w, h), data).convert('L')
            bbox = i.getbbox()
            if bbox:
                adj = 2 - type  # normal = 0, thinshadow = 1, thickshadow = 2
                bbox = (bbox[0] - adj, 0, bbox[2] + adj, h)
                i = i.crop(bbox)
                w = bbox[2] - bbox[0]
            # else: space/return/etc..

        else:  # GBK
            w = h = int(font.size*4/3) + 4
            datasz = int(ceil(w/8.))*h
            try:
                gbk = char.encode('gbk')
            except UnicodeEncodeError:
                gbk = u'⑨'.encode('gbk')
            rol = (256 + ord(gbk[0]) - 0x81) & 0xff
            col = (256 + ord(gbk[1]) - 0x40) & 0xff
            loc = rol * self.gbk_cols + col
            loc *= datasz
            fontdata = self.font.fontdata['GBK%s' % suffix]
            data = fontdata[loc:loc+datasz]
            i = Image.fromstring('1', (w, h), data).convert('L')

        ii = i
        if self.font.bold:
            ii = Image.new('L', (w, h))
            ii.paste(i, (1, 0))
            ii.paste(i, (0, 0), i)

        img = pyglet.image.ImageData(w, h, 'A', ii.tostring())
        glyph = self.font.create_glyph(img)
        glyph.set_bearings(2, -2, w - 4 + 1)
        t = list(glyph.tex_coords)
        glyph.tex_coords = t[9:12] + t[6:9] + t[3:6] + t[:3]
        glyph.character = char
        return glyph


class AncientPixFont(Font):
    glyph_renderer_class = AncientPixGlyphRenderer
    texture_width = 1024
    texture_height = 2048
    _font_texture = []

    @property
    def textures(self):
        if not AncientPixFont._font_texture:
            AncientPixFont._font_texture = [
                self.texture_class.create_for_size(
                    GL_TEXTURE_2D, self.texture_width, self.texture_height, GL_ALPHA,
                )
            ]

        return self._font_texture

    @textures.setter
    def textures(self, val):
        pass

    @property
    def fontdata(self):
        # Lazy loading
        from ..resource import font as fontdata
        return fontdata

    @property
    def suit12(self):
        # Lazy loading
        from ..resource import resource
        return resource.suit12

    @property
    def suit16(self):
        # Lazy loading
        from ..resource import resource
        return resource.suit16

    def __init__(self, name, size, bold=False, italic=False, dpi=None):
        Font.__init__(self)
        if size != 9:
            size = 12

        self._size = size
        self.bold = bold
        self.italic = False

        self.password = (name == 'AncientPixPassword')

    @property
    def size(self):
        return self._size

    @size.setter
    def size(self, val):
        pass

    @property
    def ascent(self):
        return int(self.size*4/3) + 1

    @property
    def descent(self):
        return 0

    @staticmethod
    def have_font(name):
        return name in ('AncientPix', 'AncientPixPassword')

    @staticmethod
    def add_font_data(data):
        pass

########NEW FILE########
__FILENAME__ = interp
# -*- coding: utf-8 -*-

import baseclasses as bc

import logging
log = logging.getLogger('UI_Interp')

def getinterp(obj, name):
    desc = getattr(obj.__class__, name)
    slot = desc.slot
    return getattr(obj, slot)

class InterpDesc(object):
    def __init__(self, slot):
        self.slot = slot

    def __get__(self, obj, _type):
        if obj is None:
            # class get
            return self
        v = getattr(obj, self.slot)
        if isinstance(v, AbstractInterp):
            val = v.value
            if v.finished:
                setattr(obj, self.slot, val)
                if v.on_done:
                    v.on_done(obj, self)
            return val
        else:
            return v

    def __set__(self, obj, val):
        setattr(obj, self.slot, val)

    def __delete__(self, obj):
        setattr(obj, self.slot, None)

class AbstractInterp(object):
    pass

class FunctionInterp(AbstractInterp):
    def __init__(self, f, t, animtime, on_done=None):
        from math import pi
        self._from, self._to = f, t
        self.delta = t - f
        self.starttime = bc.current_time
        self.animtime = animtime
        self.finished = False
        self.on_done = on_done

    def _get_val(self):
        elapsed = bc.current_time - self.starttime
        if elapsed > self.animtime:
            self.finished = True
            return self._to
        else:
            return self._from + self.delta * self.func(elapsed / self.animtime)

    value = property(_get_val)

from math import sin, cos, pi
class LinearInterp(FunctionInterp):
    def func(self, percent):
        return percent

class SineInterp(FunctionInterp):
    def func(self, percent):
        return sin(percent*pi/2)

class CosineInterp(FunctionInterp):
    def func(self, percent):
        return 1 - cos(percent*pi/2)

class FixedInterp(AbstractInterp):

    def __init__(self, val, animtime, on_done=None):
        self.finished = False
        self._value = val
        self.starttime = bc.current_time
        self.animtime = animtime
        self.on_done = on_done

    def _get_val(self):
        elapsed = bc.current_time - self.starttime
        if elapsed > self.animtime:
            self.finished = True
        return self._value

    value = property(_get_val)

class ChainInterp(AbstractInterp):
    def __init__(self, *interps, **k):
        self.lastval = 0.0
        self.on_done = k.get('on_done')
        self.interps = list(interps)
        st = bc.current_time
        self.starttime = st
        self.finished = False
        cum = st
        for c in self.interps:
            c.starttime = cum
            cum += c.animtime

    def _get_val(self):
        l = self.interps
        while l:
            val = l[0].value
            self.lastval = val
            if l[0].finished:
                del l[0]
                continue
            else:
                break
        else:
            self.finished = True
            val = self.lastval
        return val

    value = property(_get_val)

########NEW FILE########
__FILENAME__ = shader
# -*- coding: utf-8 -*-

from pyglet.gl import *
import pyglet

class ShaderError(Exception): pass

def _get_infolog(oid):
    buffer = create_string_buffer(3000)
    i = GLsizei(0)
    glGetInfoLogARB(
        oid, 3000, byref(i), cast(
            byref(buffer),
            POINTER(c_char)
        )
    )
    return buffer.value

HAVE_SHADER = gl_info.have_extension('GL_ARB_shader_objects')

class _Shader(object):
    def __new__(cls, *a):
        if HAVE_SHADER:
            return object.__new__(cls, *a)
        else:
            return None

    def __init__(self, src):
        sid = False
        try:
            sid = glCreateShaderObjectARB(self.shader_type)
        except GLException:
            pass

        if not sid:
            raise ShaderError("Can't create shader object!")

        l = GLsizei(len(src))
        buf = create_string_buffer(src, len(src) + 10)
        pbuf = pointer(buf)
        glShaderSourceARB(
            sid, 1, cast(byref(pbuf), POINTER(POINTER(c_char))),
            byref(l)
        )
        glCompileShader(sid)
        v = GLint()
        glGetShaderiv(sid, GL_COMPILE_STATUS, byref(v))
        if not v:
            log = _get_infolog(sid)
            e = ShaderError("Error compiling shader!")
            e.infolog = log
            raise e

        self.sid = sid

class VertexShader(_Shader):
    shader_type = GL_VERTEX_SHADER_ARB

class FragmentShader(_Shader):
    shader_type = GL_FRAGMENT_SHADER_ARB

class _UniformAccesser(object):
    def __init__(self, prg):
        object.__setattr__(self, 'prg', prg)
        object.__setattr__(self, 'lookup', {})

    def __getattr__(self, name):
        prg = object.__getattribute__(self, 'prg')
        assert prg is ShaderProgram.shader_stack[-1]

        prg = prg.pid
        loc = self.lookup.get(name)
        if loc: return loc

        loc = glGetUniformLocationARB(prg, name)
        if loc == -1:
            raise ShaderError('No such uniform!')

        self.lookup[name] = loc
        return loc

    def __setattr__(self, name, value):
        loc = getattr(self, name)

        if not isinstance(value, (list, tuple)):
            value = (value, )

        t = type(value[0])
        t = {int:'i', float:'f'}.get(t)
        if not t:
            raise ShaderError('Unknown variable type!')

        n = len(value)
        fn = 'glUniform%d%s' % (n, t)
        from pyglet import gl
        func = getattr(gl, fn)

        func(loc, *value)

class _AttributeAccesser(object):
    def __init__(self, prg):
        object.__setattr__(self, 'prg', prg)

    def __getattr__(self, name):
        prg = object.__getattribute__(self, 'prg')
        assert prg is ShaderProgram.shader_stack[-1]
        prg = prg.pid

        loc = glGetAttribLocationARB(prg, name)
        if loc == -1:
            raise ShaderError('No such attribute!')

        return loc

class _DummyShaderProgram(object):
    def __init__(self, *a):
        from utils import DataHolder
        self.uniform = DataHolder()
        self.attrib = DataHolder()

    def use(self):
        pass

    def unuse(self):
        pass

    @classmethod
    def restore(cls):
        pass

    def __enter__(self):
        return self

    def __exit__(self, *a):
        pass

DummyShader = _DummyShaderProgram()

class ShaderProgram(object):
    shader_stack = []
    def __new__(cls, *a):
        if HAVE_SHADER:
            return object.__new__(cls, *a)
        else:
            return DummyShader

    def __init__(self, *shaders):
        pid = False
        try:
            pid = glCreateProgramObjectARB()
        except GLException:
            pass

        if not pid:
            raise ShaderError("Can't create program object!")

        for s in shaders:
            glAttachObjectARB(pid, s.sid)

        glLinkProgram(pid)

        v = GLint(0)
        glGetProgramiv(pid, GL_LINK_STATUS, byref(v))
        if not v:
            log = _get_infolog(sid)
            e = ShaderError("Error linking program!")
            e.infolog = log
            raise e

        self.pid = pid

        self.uniform = _UniformAccesser(self)
        self.attrib = _AttributeAccesser(self)

    def use(self):
        ShaderProgram.shader_stack.append(self)
        glUseProgramObjectARB(self.pid)

    def unuse(self):
        l = ShaderProgram.shader_stack
        p = l.pop()
        assert p is self
        if l:
            glUseProgramObjectARB(l[-1].pid)
        else:
            glUseProgramObjectARB(0)

    @classmethod
    def restore(cls):
        cls.shader_stack[:] = []
        glUseProgramObjectARB(0)

    def __enter__(self):
        self.use()
        return self

    def __exit__(self, exc_type, exc_value, tb):
        self.unuse()

class ShaderGroup(pyglet.graphics.Group):
    def __init__(self, shader, parent=None):
        pyglet.graphics.Group.__init__(self, parent)
        self.shader = shader

    def set_state(self):
        self.shader.use()

    def unset_state(self):
        self.shader.unuse()

    def __hash__(self):
        return hash(self.shader)

    def __eq__(self, other):
        return (
            self.__class__ is other.__class__ and
            self.shader == other.shader and
            self.parent == other.parent
        )

    def __repr__(self):
        return '%s(%d)' % (self.__class__.__name__, self.shader)

class ShaderUniformGroup(pyglet.graphics.Group):
    def __init__(self, args, parent):
        pyglet.graphics.Group.__init__(self, parent)
        self.args = args
        while parent and not isinstance(parent, ShaderGroup):
            parent = parent.parent

        if not parent:
            raise Exception('Should be child group of ShaderGroup!')

        self.shader = parent.shader

    def set_state(self):
        ua = self.shader.uniform
        for k, v in self.args:
            setattr(ua, k, v)

    def unset_state(self):
        pass

    def __hash__(self):
        return hash(self.shader)

    def __eq__(self, other):
        return (
            self.__class__ is other.__class__ and
            self.shader == other.shader and
            self.args == other.args and
            self.parent == other.parent
        )

    def __repr__(self):
        return '%s(%d)' % (self.__class__.__name__, self.shader)

########NEW FILE########
__FILENAME__ = commands
# -*- coding: utf-8 -*-

from client.ui.soundmgr import SoundManager
from client.core import Executive
import gevent
import logging

log = logging.getLogger('commands')
registered_commands = {}


def command(name, help, cmd=None):
    def decorate(f):
        f.commandname = name
        f.commandhelp = help
        registered_commands[cmd or f.__name__] = f
        return f

    return decorate


def argdesc(*desclist):
    def decorate(f):
        f.argdesc = desclist
        return f

    return decorate


def argtypes(*types):
    def decorate(f):
        f.argtypes = types
        return f

    return decorate


def _format_all_commands():
    return '\n'.join([
        u'/%s ' % cmdname + cmd.commandname
        for cmdname, cmd in registered_commands.items()
    ])


def process_command(arglist):
    while True:
        if not arglist:
            prompt = _format_all_commands()
            break

        al = list(arglist)
        cmdname = al.pop(0)
        cmd = registered_commands.get(cmdname)
        if not cmd:
            prompt = _format_all_commands()
            break

        if not al and cmdname == '?':
            prompt = u'\n'.join((cmd(None), cmd('?')))
            break

        if len(al) != len(cmd.argdesc):
            prompt = registered_commands['?'](cmdname)
            break

        try:
            al = [argtype(i) for argtype, i in zip(cmd.argtypes, al)]
        except:
            prompt = registered_commands['?'](cmdname)
            break

        prompt = cmd(*al)
        break

    return u'|R%s|R\n' % prompt

# -----------------------------------


@command(u'设置音量', u'音量可以是 on、off 和 0-100 之间的整数')
@argtypes(str)
@argdesc(u'<音量>')
def vol(val):
    if val == 'on':
        val = 100
    elif val == 'off':
        val = 0
    elif val.isdigit():
        val = min(int(val), 100)
        val = max(val, 0)
    else:
        return registered_commands['?']('vol')

    if not val:
        SoundManager.mute()
        return u'已静音。'
    else:
        SoundManager.unmute()
        SoundManager.set_volume(val / 100.0)
        return u'音量已设置为 %d' % val


@command(u'设置提醒显示级别', u'off     禁用提醒\nbasic   启用基本提醒\nat      启用@提醒\nspeaker 为文文新闻显示提醒\nsound   启用声音提醒\nnosound 禁用声音提醒')
@argtypes(str)
@argdesc(u'<off||basic||at||speaker||sound||nosound>')
def notify(val):
    from user_settings import UserSettings as us

    if val == 'sound':
        us.sound_notify = True
        return u'声音提醒已启用。'

    if val == 'nosound':
        us.sound_notify = False
        return u'声音提醒已禁用。'

    from utils.notify import NONE, BASIC, AT, SPEAKER
    try:
        level = {
            'off': NONE, 'basic': BASIC,
            'at': AT, 'speaker': SPEAKER,
        }[val]
    except KeyError:
        return registered_commands['?']('notify')

    us.notify_level = level

    return u'提醒级别已变更为%s。' % val


@command(u'帮助', u'查看命令的帮助', cmd='?')
@argtypes(str)
@argdesc(u'[<命令>]')
def help(cmdname):
    cmd = registered_commands.get(cmdname)
    if not cmd:
        return _format_all_commands()
    else:
        help = [cmd.commandname, cmd.commandhelp]
        help.append(u'/%s ' % cmdname + u' '.join(cmd.argdesc))
        return u'\n'.join(help)


@command(u'踢出观战玩家', u'uid为观战玩家[]中的数字id')
@argtypes(int)
@argdesc(u'<uid>')
def kickob(uid):
    Executive.call('kick_observer', None, uid)
    return u'指令已发出'


@command(u'报告bug', u'遇到错误时，你可以用此命令主动报告bug')
@argtypes()
@argdesc()
def bugreport():
    from __main__ import do_crashreport
    log.info('Actively filed bug report')
    gevent.spawn(do_crashreport, active=True)
    return u'已经发送了bug报告'

@command(u'开启/关闭游戏邀请', u'on      开启邀请\noff     关闭邀请')
@argtypes(str)
@argdesc(u'<on||off>')
def invite(onoff):
    from user_settings import UserSettings as us
    if onoff == 'on':
        us.no_invite = False
        return u'邀请已开启，其他玩家可以邀请你一起游戏。'
    elif onoff == 'off':
        us.no_invite = True
        return u'邀请已关闭，其他玩家邀请你时会自动拒绝，不会有提示。'
    else:
        return registered_commands['?']('invite')

@command(u'观战', u'只能在大厅内使用，uid为右侧玩家列表中[]内的数字id')
@argtypes(int)
@argdesc(u'<uid>')
def ob(uid):
    from client.ui.base import ui_message
    Executive.call('observe_user', ui_message, uid)
    return u'已经向[%d]发送了旁观请求，请等待回应……' % uid

########NEW FILE########
__FILENAME__ = controls
# -*- coding: utf-8 -*-

import pyglet
import gevent
from pyglet.window import mouse, key
from pyglet.graphics import OrderedGroup
from pyglet.sprite import Sprite
from client.ui.base import Overlay, Control
from client.ui.base import ui_message, ui_schedule
from client.ui.base.interp import InterpDesc, LinearInterp
from client.ui.resource import resource as common_res
from client.core import Executive
from utils import textsnap, flatten, rectv2f, rrectv2f, inpoly
from utils import pyperclip, instantiate

from pyglet.gl import glEnd, glBegin, glRectf, glEnable, glColor3f
from pyglet.gl import glColor4f, glDisable, glScissor, glVertex2f, glLineWidth
from pyglet.gl import glPopAttrib, glPopMatrix, glDrawArrays, glPushAttrib
from pyglet.gl import glPushMatrix, glTranslatef, glBindTexture, glLoadIdentity
from pyglet.gl import glCopyTexImage2D, glPopClientAttrib, glPushClientAttrib
from pyglet.gl import glInterleavedArrays

from pyglet.gl import GLfloat, GL_RGBA, GL_LINES, GL_QUADS, GL_T4F_V4F, GL_ENABLE_BIT
from pyglet.gl import GL_TEXTURE_2D, GL_SCISSOR_TEST, GL_CLIENT_VERTEX_ARRAY_BIT

from collections import namedtuple

KEYMOD_MASK = key.MOD_CTRL | key.MOD_ALT | key.MOD_SHIFT

import logging
log = logging.getLogger('UI_Controls')


class Colors:
    @instantiate
    class green:
        # Frame
        frame = 49, 69, 99
        heavy = 66, 138, 115
        medium = 140, 186, 140
        light = 206, 239, 156
        caption = 255, 255, 255
        caption_shadow = heavy
        close_btn = property(lambda _: common_res.buttons.close_green)
        # Button
        btn_frame = heavy
        fill_up = 173, 207, 140
        fill_medline = 173, 223, 156
        fill_down = 189, 223, 156
        fill_botline = 222, 239, 206
        text = frame

    @instantiate
    class red:
        # Frame
        frame = 171, 68, 81
        medium = 0xff, 0x9f, 0x8c
        heavy = frame
        light = 254, 221, 206
        caption = 255, 255, 255
        caption_shadow = frame
        close_btn = property(lambda _: common_res.buttons.close_red)
        # Button
        btn_frame = frame
        fill_up = 0xee, 0x89, 0x78
        fill_medline = fill_up
        fill_down = 0xf7, 0x9c, 0x8c
        fill_botline = fill_down
        text = frame

    @instantiate
    class blue:
        # Frame
        frame = 0x31, 0x55, 0x97
        medium = 0x90, 0xbc, 0xed
        heavy = 0x64, 0x8a, 0xd0
        light = 0xa3, 0xd1, 0xfa
        caption = frame
        caption_shadow = 0xe5, 0xef, 0xfb
        close_btn = property(lambda _: common_res.buttons.close_blue)
        # Button
        btn_frame = 0x54, 0x67, 0xa6
        fill_up = 0x90, 0xbf, 0xef
        fill_down = 0xa3, 0xd1, 0xfa
        fill_medline = 0x9a, 0xc8, 0xf5
        fill_botline = 0xc5, 0xf2, 0xff
        text = frame

    @instantiate
    class orange:
        # Frame
        frame = 0x88, 0x66, 0x66
        medium = 0xff, 0xcc, 0x77
        heavy = frame
        light = 0xff, 0xee, 0xaa
        caption = 255, 255, 255
        caption_shadow = frame
        close_btn = property(lambda _: common_res.buttons.close_orange)
        # Button
        btn_frame = frame
        fill_up = medium
        fill_medline = fill_up
        fill_down = 0xff, 0xdd, 0x88
        fill_botline = light
        text = frame

    @instantiate
    class gray:
        # Frame
        close_btn = property(lambda _: common_res.buttons.close_blue)
        btn_frame = 104, 104, 104
        caption = 81, 81, 81
        caption_shadow = 237, 237, 237
        fill_botline = 229, 229, 229
        fill_down = 199, 199, 199
        fill_medline = 191, 191, 191
        fill_up = 182, 182, 182
        frame = 81, 81, 81
        heavy = 134, 134, 134
        light = 199, 199, 199
        medium = 180, 180, 180
        text = 81, 81, 81

    @staticmethod
    def get4f(c):
        return c[0]/255.0, c[1]/255.0, c[2]/255.0, 1.0

    @staticmethod
    def get4i(c):
        return c + (255, )


class Button(Control):
    NORMAL = 0
    HOVER = 1
    PRESSED = 2
    DISABLED = 3

    hover_alpha = InterpDesc('_hv')

    def __init__(self, caption='Button', color=Colors.green, *args, **kwargs):
        Control.__init__(self, *args, **kwargs)
        self._batch = None
        self.caption = caption
        self._state = Button.NORMAL
        self.state = Button.NORMAL
        self.hover_alpha = 0.0

        self.need_update = True
        self.color = color

    def update(self):
        if self._batch:
            self._batch.need_update = True

    def _fill_batch(self, batch):
        ax, ay = self.abs_coords()
        w, h = self.width, self.height

        color = self.color

        up, down = Colors.get4f(color.fill_up), Colors.get4f(color.fill_down)
        heavy = Colors.get4f(self.color.heavy)
        color_array = flatten([
            down, down, up, up, [heavy]*4
        ])

        batch.add(8, GL_QUADS, None,
            ('v2f', flatten([
                rectv2f(.5, .5, w-.5, h-.5, ax, ay),
                rrectv2f(.5, .5, w-.5, h-.5, ax, ay),
            ])),
            ('c4f', color_array),
        )

        pyglet.text.Label(
            self.caption, u'AncientPix', 9,
            color=color.text + (255,),
            x=(ax + self.width // 2), y=(ay + self.height // 2),
            anchor_x='center', anchor_y='center', batch=batch
        )

        self.hilight_vl = batch.add(4, GL_QUADS, None,
            ('v2f', (ax, ay, ax + w, ay, ax + w, ay + h, ax, ay + h)),
            ('c4f/stream', [0.0] * (4 * 4)),
        )

    @staticmethod
    def batch_draw(btns):
        glPushMatrix()
        glLoadIdentity()
        batch_list = set([b._batch for b in btns])
        batch = list(batch_list)[0]
        if not (len(batch_list) == 1 and batch and not batch.need_update):
            for i in batch_list:
                if i:
                    for b in i.buttons:
                        b._batch = None

            batch = pyglet.graphics.Batch()
            batch.buttons = btns[:]
            batch.need_update = False
            for b in btns:
                b._batch = batch
                b._fill_batch(batch)

        for b in btns:
            if b.state == Button.DISABLED:
                continue

            hilight = (0., 0., 0., 0.)
            if b.state == Button.PRESSED:
                hilight = (0., 0., 0., .25)
            else:
                a = b.hover_alpha
                if a:  # HOVER, or HOVER -> NORMAL
                    hilight = (1.0, 1.0, .843, a)

            b.hilight_vl.colors[:] = hilight * 4

        batch.draw()
        glPopMatrix()

    def draw(self):
        glColor3f(1.0, 0.0, 0.0)
        glRectf(0, 0, self.width, self.height)

    def on_mouse_enter(self, x, y):
        if self.state != Button.DISABLED:
            self.state = Button.HOVER
        return pyglet.event.EVENT_HANDLED

    def on_mouse_leave(self, x, y):
        if self.state != Button.DISABLED:
            self.state = Button.NORMAL
        return pyglet.event.EVENT_HANDLED

    def on_mouse_press(self, x, y, button, modifier):
        if self.state != Button.DISABLED:
            if button == mouse.LEFT:
                self.state = Button.PRESSED
        return pyglet.event.EVENT_HANDLED

    def on_mouse_release(self, x, y, button, modifier):
        if self.state != Button.DISABLED:
            if button == mouse.LEFT:
                self.state = Button.HOVER
        return pyglet.event.EVENT_HANDLED

    def on_mouse_click(self, x, y, button, modifier):
        if self.state != Button.DISABLED:
            self.dispatch_event('on_click')
        return pyglet.event.EVENT_HANDLED

    def _get_state(self):
        return self._state

    def _set_state(self, val):
        last = self._state
        self._state = val
        if val == Button.HOVER:
            self.hover_alpha = .25
        elif last == Button.HOVER and val == Button.NORMAL:
            self.hover_alpha = LinearInterp(
                .25, 0, .17
            )
        else:
            self.update()

    state = property(_get_state, _set_state)

    def _get_color(self):
        if self._state == Button.DISABLED:
            return Colors.gray

        return self._color

    def _set_color(self, val):
        self._color = val
        self.update()

    color = property(_get_color, _set_color)


class ImageButton(Control):
    NORMAL = 0
    HOVER = 1
    PRESSED = 2
    DISABLED = 3

    hover_alpha = InterpDesc('_hv')

    def __init__(self, images, *args, **kwargs):
        Control.__init__(self, *args, **kwargs)
        self.images = images
        self._state = Button.NORMAL
        self.state = Button.NORMAL
        self.hover_alpha = 0.0
        self.width = images[0].width
        self.height = images[0].height

    @staticmethod
    def batch_draw(ibs):
        glPushMatrix()
        glLoadIdentity()
        glColor3f(1.0, 1.0, 1.0)

        glPushAttrib(GL_ENABLE_BIT)
        glEnable(GL_TEXTURE_2D)

        tex = [None]

        def blit(btn, idx):
            img = btn.images[idx]
            t = getattr(img, 'owner', img)
            if tex[0] != t:
                tex[0] = t
                glBindTexture(GL_TEXTURE_2D, t.id)
            img.blit_nobind(*btn.abs_coords())

        for btn in ibs:
            if btn.state == Button.DISABLED:
                blit(btn, 3)
            else:
                if btn.state == Button.PRESSED:
                    blit(btn, 2)
                else:
                    blit(btn, 0)
                    a = btn.hover_alpha
                    if a:  # HOVER, or HOVER -> NORMAL
                        glColor4f(1.0, 1.0, 1.0, a)
                        blit(btn, 1)
                        glColor3f(1, 1, 1)

        glPopAttrib()
        glPopMatrix()

    def on_mouse_enter(self, x, y):
        if self.state != Button.DISABLED:
            self.state = Button.HOVER

    def on_mouse_leave(self, x, y):
        if self.state != Button.DISABLED:
            self.state = Button.NORMAL

    def on_mouse_press(self, x, y, button, modifier):
        if self.state != Button.DISABLED:
            if button == mouse.LEFT:
                self.state = Button.PRESSED

    def on_mouse_release(self, x, y, button, modifier):
        if self.state == Button.PRESSED:
            if button == mouse.LEFT:
                self.state = Button.HOVER
                self.dispatch_event('on_click')

    def _get_state(self):
        return self._state

    def _set_state(self, val):
        last = self._state
        self._state = val
        if val == Button.HOVER:
            self.hover_alpha = 1.
        elif last == Button.HOVER and val == Button.NORMAL:
            self.hover_alpha = LinearInterp(
                1., 0, .3
            )
    state = property(_get_state, _set_state)

Button.register_event_type('on_click')
ImageButton.register_event_type('on_click')


def batch_drawlabel(lbls):
    s = set([l.batch for l in lbls])
    if len(s) == 1:
        batch = list(s)[0]
    else:
        batch = pyglet.graphics.Batch()
        for l in lbls:
            adj = getattr(l, '_loc_adjusted', False)
            l.begin_update()
            if not adj:
                p = l._parent
                x, y = p.abs_coords()
                l.x += x
                l.y += y
                l._loc_adjusted = True
            l._own_batch = False
            l.batch = batch
            l.end_update()
    batch.draw()


def batch_drawsprite(sprites):
    s = list(set([l.batch for l in sprites]))
    if len(s) == 1 and s[0]:
        batch = s[0]
    else:
        batch = pyglet.graphics.Batch()
        for sp in sprites:
            adj = getattr(sp, '_loc_adjusted', False)
            sp.batch = batch
            if not adj:
                p = sp._parent
                x, y = p.abs_coords()
                sp.set_position(sp.x + x, sp.y + y)
                sp._loc_adjusted = True
    batch.draw()


class Frame(Control):
    no_move = True
    zindex = 1
    bg_group = OrderedGroup(50)
    frame_group = OrderedGroup(100)
    labels_group = OrderedGroup(150)
    top_group = OrderedGroup(1000)

    def __init__(self, caption='Frame', color=Colors.green,
                 bot_reserve=10, bg=None, thin_shadow=False,
                 *args, **kwargs):
        Control.__init__(self, *args, **kwargs)
        self.caption = caption
        self._color = color
        self.bg = bg
        self._labels = []
        self.bot_reserve = bot_reserve
        self.thin_shadow = thin_shadow

        # HACK
        self._batch = pyglet.graphics.Batch()  # will be abandoned soon, acutally
        self._fill_batch(self._batch)
        self._batch.dialogs = [self]
        self._batch.need_update = False

        self.update()

    @property
    def color(self):
        return self._color

    @property
    def labels(self):
        raise AttributeError('Do not use labels! use add_label!')

    def update(self):
        self.set_caption(self.caption)

        # Frame.update_color(self)
        # Frame.update_position(self)
        # Frame.update_bg(self)

        self.update_color()
        self.update_position()
        self.update_bg()
        self._update_labels()

    def update_bg(self):
        bg = getattr(self, 'bg', None)
        r = self.bot_reserve; w = self.width; h = self.height
        _w = w - 2
        _h = h - 24 - r
        if bg:
            if bg.height > h - 24 - r or bg.width > w - 2:
                _w = min(bg.width, _w)
                _h = min(bg.height, _h)
                bg = bg.get_region(0, 0, _w, _h)
        else:
            # HACK
            bg = common_res.white.get_region(0, 0, _w, _h)
            bg.tex_coords = common_res.white.tex_coords

        self.bgsprite.image = bg

    def on_resize(self, w, h): self.update_bg()

    def _fill_batch(self, batch):
        ax, ay = self.abs_coords()
        self._batch = batch

        r = self.bot_reserve
        self.bgsprite = Sprite(common_res.white, x=ax+2, y=ax+r, batch=batch, group=self.bg_group)
        self.update_bg()

        self.framevlist = batch.add(20, GL_QUADS, self.frame_group,
            'v2f', 'c4B',
        )

        for lbl in self._labels:
            if lbl.batch is not batch:
                lbl.batch = batch

        if self.thin_shadow:
            shadow = (1, ) + self.color.caption_shadow + (255,)
        else:
            shadow = (2, ) + self.color.caption_shadow + (255,)

        self.caption_lbl = pyglet.text.Label(
            u'', u'AncientPix', 9,
            color=self.color.caption + (255,),
            shadow=shadow,
            anchor_x='left', anchor_y='bottom',
            batch=batch, group=self.labels_group,
        )

        self.set_caption(self.caption)

        self.update()

    def _get_frame_v2f(self):
        ax, ay = self.abs_coords()
        w = self.width; h = self.height; r = self.bot_reserve
        return flatten([
            rectv2f(ax+.5, ay+h-24+.5, w-.5, 24-.5),  # title bar
            rectv2f(ax+.5, ay+.5, w-.5, r-.5),  # bot reserve
            rrectv2f(ax+.5, ay+r+.5, w-.5, h-24-r-.5),  # heavy line
            rrectv2f(ax+.5, ay+.5, w-.5, h-.5),  # border
            rrectv2f(ax+1.5, ay+1.5, w-2.5, h-2.5),
        ])

    def set_color(self, color):
        self._color = color
        Frame.update_color(self)

    def update_color(self):
        c = self.color
        C = Colors.get4i
        medium = C(c.medium)
        heavy = C(c.heavy)
        frame = C(c.frame)

        self.framevlist.colors[:] = flatten([
            [medium] * 4,  # title bar
            [medium] * 4,  # bot reserve
            [heavy] * 4,  # heavy line
            [frame] * 8,  # border
        ])

        t = 1 if self.thin_shadow else 2
        self.caption_lbl.shadow = (t,) + C(c.caption_shadow)
        self.caption_lbl.color = C(c.caption)

    def set_position(self, x, y):
        self.x = x; self.y = y
        self.update_position()

    def update_position(self):
        ax, ay = self.abs_coords()
        self.framevlist.vertices[:] = self._get_frame_v2f()
        self.bgsprite.set_position(ax+2, ay+self.bot_reserve)
        self._update_labels()

        cap = self.caption_lbl

        cap.begin_update()
        cap.x = ax + 20
        cap.y = ay + self.height - 20
        cap.end_update()

    def set_caption(self, cap):
        f = pyglet.font.load('AncientPix', 9)
        cap = textsnap(cap, f, self.width - 20 - 4)

        self.caption = cap
        self.caption_lbl.text = cap

    @staticmethod
    def batch_draw(dlgs):
        glColor3f(1, 1, 1)
        glPushMatrix()
        glLoadIdentity()

        batch_list = set([d._batch for d in dlgs])
        batch = list(batch_list)[0]
        if not (len(batch_list) == 1 and batch and not batch.need_update):
            for i in batch_list:
                if i:
                    for d in i.dialogs:
                        d._batch = None

            batch = pyglet.graphics.Batch()
            batch.dialogs = dlgs[:]
            batch.need_update = False
            for d in dlgs:
                d._batch = batch
                d._fill_batch(batch)

        batch.draw()

        glPopMatrix()

        cl = []
        map(cl.extend, [d.control_list for d in dlgs])
        Control.do_draw(cl)

    def add_label(self, text, x, y, *a, **k):
        ax, ay = self.abs_coords()
        l = pyglet.text.Label(
            text, x=ax+x, y=ay+y,
            font_name='AncientPix',
            batch=self._batch, group=self.labels_group,
            *a, **k
        )
        l._parent = self
        l._ox = x
        l._oy = y
        self._labels.append(l)

        return l

    def remove_label(self, l):
        self._labels.remove(l)
        l.delete()
        shadow = getattr(l, '_shadow', None)
        if shadow:
            self._labels.remove(shadow)
            shadow.delete()

    def set_label_position(self, l, x, y):
        l._ox = x
        l._oy = y
        self._update_labels()

    def _update_labels(self):
        ax, ay = self.abs_coords()
        for l in self._labels:
            l.begin_update()
            l.x = ax + l._ox
            l.y = ay + l._oy
            l.end_update()

    def delete(self):
        Control.delete(self)
        for l in self._labels:
            l.delete()
        self.caption_lbl.delete()


class Dialog(Frame):
    no_move = False
    next_zindex = 1

    def __init__(self, *a, **k):
        Frame.__init__(self, *a, **k)
        self.zindex = Dialog.next_zindex
        Dialog.next_zindex += 1
        self.btn_close = ImageButton(
            images=self.color.close_btn,
            parent=self, font_size=12,
            x=self.width-18, y=self.height-19,
        )
        self.dragging = False

        @self.btn_close.event
        def on_click():
            self.close()

        timeout = getattr(self, 'timeout', None)
        if timeout:
            gevent.spawn_later(timeout, self.close)

    def on_resize(self, w, h):
        super(Dialog, self).on_resize(w, h)
        self.btn_close.x, self.btn_close.y = w-18, h-19

    @staticmethod
    def batch_draw(dlgs):
        for d in dlgs:
            Frame.batch_draw([d])

    def on_mouse_press(self, x, y, button, modifier):
        w, h = self.width, self.height
        self.zindex = Dialog.next_zindex
        Dialog.next_zindex += 1
        if not self.no_move and button == mouse.LEFT and h-20 <= y <= h and x <= w-20:
            self.set_capture('on_mouse_drag', 'on_mouse_release')
            self.dragging = True

    def on_mouse_release(self, x, y, button, modifier):
        if self.dragging:
            self.release_capture('on_mouse_drag', 'on_mouse_release')
            self.dragging = False

    def on_mouse_drag(self, x, y, dx, dy, button, modifier):
        if self.dragging:
            self.set_position(self.x + dx, self.y + dy)
            self.dispatch_event('on_move', self.x, self.y)

    def close(self):
        self._cancel_close = False
        self.dispatch_event('on_close')
        if not self._cancel_close:
            self.delete()
            self.dispatch_event('on_destroy')

    def cancel_close(self):
        self._cancel_close = True

Dialog.register_event_type('on_move')
Dialog.register_event_type('on_close')
Dialog.register_event_type('on_destroy')


class BalloonPromptMixin(object):
    balloon_inited = False
    balloon_panel = None
    balloon_cursorloc = (0, 0)
    balloon_width = 288
    balloon_state = 'hidden'

    def init_balloon(self, text, region=None, width=288, polygon=None):
        self.balloon_text = text
        if region:
            x, y, w, h = region
            x1, y1 = x + w, y + h
            self.balloon_polygon = ((x, y), (x1, y), (x1, y1), (x, y1))
        else:
            self.balloon_polygon = polygon

        self.balloon_width = width

        if not self.balloon_inited:
            self.balloon_inited = True
            self.push_handlers(
                on_mouse_motion=self.balloon_on_mouse_motion,
                on_mouse_drag=self.balloon_on_mouse_motion,
                on_mouse_enter=self.balloon_on_mouse_enter,
                on_mouse_leave=self.balloon_on_mouse_leave,
            )
        else:
            if self.balloon_state == 'shown':
                self.balloon_panel.delete()
                del self.balloon_panel

        self.balloon_state = 'hidden'

    def balloon_on_mouse_motion(self, x, y, dx, dy, *a):
        ax, ay = self.abs_coords()
        ax += x
        ay += y

        self.balloon_cursorloc = (ax, ay)

        poly = self.balloon_polygon
        if poly:
            if inpoly(x, y, poly):
                self.balloon_on_mouse_enter(x, y)
            else:
                self.balloon_on_mouse_leave(x, y)

        b = self.balloon_panel
        b and self.balloon_setloc()

    def balloon_setloc(self):
        b = self.balloon_panel
        o = Overlay.cur_overlay
        x, y = self.balloon_cursorloc
        ow, oh = o.width, o.height
        bw, bh = b.width, b.height

        if x*2 <= ow:
            x += 10
            if x + bw > ow:
                x = ow - bw
        else:
            x -= bw + 10
            if x < 0:
                x = 0

        if y*2 <= oh:
            y += 10
            if y + bh > oh:
                y = oh - bh
        else:
            y -= bh + 10
            if y < 0:
                y = 0

        b.x = x
        b.y = y

    def balloon_on_mouse_enter(self, x, y):
        if self.balloon_state == 'hidden':
            self.balloon_state = 'ticking'
            self.balloon_overlay = Overlay.cur_overlay
            pyglet.clock.schedule_once(self._balloon_show, 0.8)

    def balloon_on_mouse_leave(self, x, y):
        if self.balloon_state == 'ticking':
            pyglet.clock.unschedule(self._balloon_show)
        elif self.balloon_state == 'shown':
            self.balloon_panel.delete()
            del self.balloon_panel
        self.balloon_state = 'hidden'

    def _balloon_show(self, dt):
        if self.balloon_state == 'shown': return
        if Overlay.cur_overlay != self.balloon_overlay: return
        if not self.balloon_text: return

        self.balloon_state = 'shown'
        panel = self.balloon_show()
        self.balloon_panel = panel
        self.balloon_setloc()

        @panel.event
        def on_mouse_enter(x, y, panel=panel):
            panel.delete()

    def balloon_show(self):
        width = self.balloon_width
        ta = TextArea(parent=None, x=2, y=2, width=width, height=100)
        ta.append(self.balloon_text)
        h = ta.content_height
        ta.height = h

        panel = Panel(parent=Overlay.cur_overlay, x=0, y=0, width=width+4, height=h+4, zindex=999999)
        panel.add_control(ta)
        panel.fill_color = (1.0, 1.0, 0.9, 0.5)

        return panel


class TextBox(Control):
    DISABLE_NEWLINE = True

    def __init__(self, text='Yoooooo~', color=Colors.green, font_name='AncientPix', *args, **kwargs):
        Control.__init__(self, can_focus=True, *args, **kwargs)
        self.document = pyglet.text.document.UnformattedDocument(text)
        self.document.set_style(0, len(self.document.text), dict(
            color=(0, 0, 0, 255),
            font_name=font_name,
            font_size=9,
        ))

        self.color = color

        width = self.width
        f = self.document.get_font()
        font_height = f.ascent - f.descent
        if self.height == 0:
            height = font_height
            self.height = height
        else:
            height = self.height

        l = self.layout = pyglet.text.layout.IncrementalTextLayout(
            self.document, width-9, font_height, multiline=False,
        )
        l.anchor_x, l.anchor_y = 'left', 'center'
        l.x, l.y = 4, height // 2 + 1
        self.caret = pyglet.text.caret.Caret(self.layout)

        self.set_handlers(self.caret)
        self.push_handlers(self)

        from base.baseclasses import main_window
        self.window = main_window
        self.text_cursor = self.window.get_system_mouse_cursor('text')
        self.on_lostfocus()

    def _gettext(self):
        return self.document.text

    def _settext(self, text):
        self.document.text = text

    text = property(_gettext, _settext)

    def draw(self):
        #ui_utils.border(0, 0, self.width, self.height)
        w, h = self.width, self.height
        border = [i/255.0 for i in self.color.heavy]
        fill = [i/255.0 for i in self.color.light]
        glColor3f(*fill)
        glRectf(0, 0, w, h)
        glColor3f(*border)
        glRectf(0, h, w, 0)
        self.layout.draw()

    def on_focus(self):
        self.caret.visible = True
        self.caret.mark = 0
        self.caret.position = len(self.document.text)
        self.focused = True

    def on_lostfocus(self):
        self.caret.visible = False
        self.caret.mark = self.caret.position = 0
        self.focused = False

    def on_mouse_enter(self, x, y):
        self.window.set_mouse_cursor(self.text_cursor)

    def on_mouse_leave(self, x, y):
        self.window.set_mouse_cursor(None)

    def on_mouse_drag(self, x, y, dx, dy, btn, modifier):
        # If I'm not focused, don't select texts
        if btn == mouse.LEFT and self.focused:
            x = max(4, x)
            self.caret.on_mouse_drag(x, y, dx, dy, btn, modifier)
        return pyglet.event.EVENT_HANDLED

    def on_mouse_press(self, x, y, btn, modifier):
        self.set_capture('on_mouse_release', 'on_mouse_drag')

    def on_mouse_release(self, x, y, btn, modifier):
        self.release_capture('on_mouse_release', 'on_mouse_drag')
        return True

    def on_key_press(self, symbol, modifiers):
        if modifiers & KEYMOD_MASK == key.MOD_CTRL:
            if symbol == key.A:
                self.caret.position = 0
                self.caret.mark = len(self.text)
                return pyglet.event.EVENT_HANDLED

            elif symbol == key.C:
                start = self.layout.selection_start
                end = self.layout.selection_end
                if start != end:
                    pyperclip.copy(self.text[start:end])
                return pyglet.event.EVENT_HANDLED

            elif symbol == key.ENTER:
                if self.DISABLE_NEWLINE: return
                self.dispatch_event('on_text', u'\n')
                return pyglet.event.EVENT_HANDLED

            elif symbol == key.V:
                content = unicode(pyperclip.paste())
                if self.DISABLE_NEWLINE:
                    for le in (u'\r\n', u'\r', u'\n'):
                        content = content.replace(le, u' ')
                self.dispatch_event('on_text', content)
                return pyglet.event.EVENT_HANDLED

            elif symbol == key.X:
                start = self.layout.selection_start
                end = self.layout.selection_end
                if start != end:
                    pyperclip.copy(self.text[start:end])
                    self.dispatch_event('on_text', u'')
                return pyglet.event.EVENT_HANDLED

    def on_text(self, text):
        if text == '\r':
            self.dispatch_event('on_enter')
            return pyglet.event.EVENT_HANDLED

TextBox.register_event_type('on_enter')


class PasswordTextBox(TextBox):
    def __init__(self, *a, **k):
        TextBox.__init__(self, font_name='AncientPixPassword', *a, **k)


class PlayerPortrait(Frame):
    def __init__(self, player_name, color=Colors.blue, *args, **kwargs):
        self.account = None
        self.ready = False
        from base.baseclasses import main_window
        self.window = main_window
        self.hand_cursor = self.window.get_system_mouse_cursor('hand')
        self.accinfo_labels = []

        self.player_name = player_name
        Frame.__init__(
            self, caption=player_name, color=color,
            bot_reserve=50, width=128, height=245,
            thin_shadow=True,
            *args, **kwargs
        )
        sensor = SensorLayer(self)

        @sensor.event
        def on_mouse_enter(x, y):
            self.account or self.window.set_mouse_cursor(self.hand_cursor)

        @sensor.event
        def on_mouse_leave(x, y):
            self.window.set_mouse_cursor(None)

        @sensor.event
        def on_mouse_release(x, y, button, modifier):
            self._change_loc()

        self.buttons = []

        def btn(caption, command, x, y, w, h):
            btn = Button(
                caption, parent=self,
                x=x, y=y, width=w, height=h,
                manual_draw=True,
                color=self.color
            )
            self.buttons.append(btn)

            @btn.event
            def on_click(btn=btn, cmd=command):
                cmd()

        # btn(u'换位', self._change_loc, 90, 55, 32, 20)
        # btn(u'请离', self._kick, 90, 80, 32, 20)
        btn(u'请离', self._kick, 90, 55, 32, 20)

    def _change_loc(self):
        Executive.call(
            'change_location', ui_message,
            self.parent.portraits.index(self)
        )

    def _kick(self):
        if not self.userid: return
        Executive.call(
            'kick_user', ui_message, self.userid
        )

    def update(self):
        acc = self.account
        self.avatar = None
        if acc:
            name = u'<' + acc.username + u'>'
            if self.ready: name = u'(准备)' + name
            self.userid = acc.userid
        else:
            name = u'空位置'
            self.userid = 0

        for l in self.accinfo_labels:
            self.remove_label(l)

        self.accinfo_labels = []
        self.avatar = None

        self.set_caption(name)

        if acc:
            avurl = acc.other['avatar']
        else:
            avurl = None

        if avurl:
            img = self.cached_avatar.get(avurl, None)
            if img:
                sprite = pyglet.sprite.Sprite(img, x=64, y=150)
                sprite.scale = min(1.0, 64.0*2/img.width, 170.0*2/img.height)
                sprite._parent = self
                self.avatar = sprite
            else:
                def callback(rst):
                    if rst:
                        resp, data = rst

                        if data.startswith('GIF'):
                            fn = 'foo.gif'
                        elif data.startswith('\xff\xd8') and data.endswith('\xff\xd9'):
                            fn = 'foo.jpg'
                        elif data.startswith('\x89PNG'):
                            fn = 'foo.png'

                        from StringIO import StringIO
                        f = StringIO(data)

                        try:
                            if fn == 'foo.gif':
                                from utils import gif_to_animation
                                img = gif_to_animation(f)
                            else:
                                img = pyglet.image.load(fn, file=f)
                                img.anchor_x, img.anchor_y = img.width // 2, img.height // 2
                        except:
                            img = False

                        sprite = False
                        if img:
                            sprite = pyglet.sprite.Sprite(img, x=64, y=150)
                            sprite.scale = min(1.0, 64.0*2/img.width, 170.0*2/img.height)
                            sprite._parent = self

                    else:
                        img = sprite = False

                    self.cached_avatar[avurl] = img
                    self.avatar = sprite

                    if sprite:
                        ui_schedule(self.update)

                Executive.call('fetch_resource', callback, avurl)

        Frame.update(self)

        if not acc: return

        f = pyglet.font.load('AncientPix', 9)

        def L(text, loc):
            text = textsnap(text, f, self.width - 8 - 4)
            C = Colors.get4i
            ccap = C(self.color.caption)
            ccapshadow = (1,) + C(self.color.caption_shadow)

            self.accinfo_labels.append(self.add_label(
                text, x=8, y=47-15*loc,
                anchor_x='left', anchor_y='top',
                font_size=9, color=ccap,
                shadow=ccapshadow,
            ))

        L(acc.other['title'], 0)
        L(u'节操： %d' % acc.other['credits'], 1)
        g, d = acc.other['games'], acc.other['drops']
        dr = int(100*d/g) if d else 0
        L(u'游戏数：%d(%d%%)' % (g, dr), 2)

    def draw(self):
        PlayerPortrait.draw(self)
        if self.avatar:
            self.avatar.draw()

        #for b in self.buttons:
        #    b.do_draw()
        Button.batch_draw(self.buttons)

    @staticmethod
    def batch_draw(pps):
        Frame.batch_draw(pps)
        sprites = [getattr(p, 'avatar', None) for p in pps]
        sprites = [s for s in sprites if s]
        batch_drawsprite(sprites)
        btns = []
        map(btns.extend, [p.buttons for p in pps])
        Button.batch_draw(btns)


class TextArea(Control):

    def __init__(self, font=u'AncientPix', font_size=9, default_attrib={}, *args, **kwargs):
        Control.__init__(self, can_focus=True, *args, **kwargs)

        width, height = self.width, self.height

        self.document = pyglet.text.document.FormattedDocument(u'')
        self.default_attrib = dict(
            font_size=font_size,
            font_name=font,
            bold=False,
            italic=False,
            underline=None,
            color=(0, 0, 0, 255),
            shadow=(0, 0, 0, 0, 0),
        )

        self.default_attrib.update(default_attrib)

        self.layout = pyglet.text.layout.IncrementalTextLayout(
            self.document, width-8, height-8, multiline=True
        )

        self.layout.x = 4
        self.layout.y = 4

        self.pos_table = []
        self.loc_table = []

        self._text = u''

        self.caret = pyglet.text.caret.Caret(self.layout)

        self.set_handlers(self.caret)
        self.push_handlers(self)

        from base.baseclasses import main_window
        self.window = main_window
        self.text_cursor = self.window.get_system_mouse_cursor('text')
        self.on_lostfocus()

    def _gettext(self):
        return self._text

    def _settext(self, text):
        self._text = u''
        self.pos_table = []
        self.loc_table = []
        self.caret.mark = None
        l = self.layout
        l.begin_update()
        self.document.text = u''
        self.append(text)
        # l.end_update()  # self.append(text) will call it

    def append(self, text):
        attrib = dict(self.default_attrib)
        doc = self.document
        pos = len(self._text)

        def set_attrib(entry, val):
            def scanner_cb(s, tok):
                attrib[entry] = val
            return scanner_cb

        def restore(s, tok):
            attrib.update(self.default_attrib)

        def instext(s, tok):
            tok = unicode(tok)
            if s:
                self.pos_table.append(pos + s.match.start())
            else:
                self.pos_table.append(pos + len(text) - len(tok))
            self.loc_table.append(len(doc.text))
            doc.insert_text(len(doc.text), tok, attrib)

        def color(s, tok):
            c = tok[2:]
            color = (
                int(c[0:2], 16),
                int(c[2:4], 16),
                int(c[4:6], 16),
                int(c[6:8], 16),
            )
            attrib['color'] = color

        def shadow(s, tok):
            c = tok[3:]
            shadow = (
                int(tok[2]),
                int(c[0:2], 16),
                int(c[2:4], 16),
                int(c[4:6], 16),
                int(c[6:8], 16),
            )
            attrib['shadow'] = shadow

        def hidden(s, tok):
            color(s, '|c000000ff')
            shadow(s, '|s2000000ff')

        def insert_pipe(s, tok):
            instext(s, '|')

        import re
        scanner = re.Scanner([
            (r'[^|]+', instext),
            (r'\|c[A-Fa-f0-9]{8}', color),
            (r'\|s[12][A-Fa-f0-9]{8}', shadow),
            (r'\|B', set_attrib('bold', True)),
            (r'\|b', set_attrib('bold', False)),
            (r'\|I', set_attrib('italic', True)),
            (r'\|i', set_attrib('italic', False)),
            (r'\|U', set_attrib('underline', (0, 0, 0, 255))),
            (r'\|u', set_attrib('underline', None)),
            (r'\|H', hidden),
            (r'\|\|', insert_pipe),
            (r'\|r', restore),

            # shortcuts
            (r'\|R', set_attrib('color', (0xff, 0x35, 0x35, 0xff))),
            (r'\|G', set_attrib('color', (0x20, 0x80, 0x20, 0xff))),
            (r'\|Y', set_attrib('color', (0xff, 0xff, 0x30, 0xff))),
            (r'\|LB', set_attrib('color', (0x90, 0xdc, 0xe8, 0xff))),
            (r'\|DB', set_attrib('color', (0x00, 0x00, 0x60, 0xff))),
            (r'\|W', set_attrib('color', (0xff, 0xff, 0xff, 0xff))),

            # for thbviewer
            (r'\|!R', set_attrib('color', (0xff, 0x35, 0x35, 0xff))),
            (r'\|!G', set_attrib('color', (0x20, 0x80, 0x20, 0xff))),
            (r'\|!O', set_attrib('color', (0xff, 0xcc, 0x77, 0xff))),
            (r'\|!B', set_attrib('color', (0x00, 0x00, 0x60, 0xff))),
        ])

        l = self.layout

        bottom = (-l.view_y + l.height >= l.content_height)
        view_y = l.view_y

        l.begin_update()
        toks, reminder = scanner.scan(text)
        if reminder:
            instext(None, reminder)

        l.end_update()
        if bottom:
            l.view_y = -l.content_height
        else:
            l.view_y = view_y
        self._text += text

    text = property(_gettext, _settext)

    def draw(self):
        self.layout.draw()

    def on_mouse_scroll(self, x, y, dx, dy):
        f = self.document.get_font(0)
        size = f.ascent - f.descent
        self.layout.view_y += dy * size*2

    def on_focus(self):
        self.focused = True
        self.caret.visible = False

    def on_lostfocus(self):
        self.caret.visible = False
        self.caret.mark = None
        self.focused = False

    def on_mouse_enter(self, x, y):
        self.window.set_mouse_cursor(self.text_cursor)

    def on_mouse_leave(self, x, y):
        self.window.set_mouse_cursor(None)

    def on_mouse_drag(self, x, y, dx, dy, btn, modifier):
        # If I'm not focused, don't select texts
        if btn == mouse.LEFT and self.focused:
            x = max(4, x)
            self.caret.on_mouse_drag(x, y, dx, dy, btn, modifier)
        return pyglet.event.EVENT_HANDLED

    def on_mouse_press(self, x, y, btn, modifier):
        self.set_capture('on_mouse_release', 'on_mouse_drag')

    def on_mouse_release(self, x, y, btn, modifier):
        self.release_capture('on_mouse_release', 'on_mouse_drag')
        return True

    def on_key_press(self, symbol, modifiers):
        def get_pos(loc, left=True):
            import bisect
            if left:
                bisect = bisect.bisect_left
            else:
                bisect = bisect.bisect_right

            idx = bisect(self.loc_table, loc) - 1
            if idx < 0: idx = 0

            loc_diff = loc - self.loc_table[idx]

            return self.pos_table[idx] + loc_diff, idx

        if modifiers & KEYMOD_MASK == key.MOD_CTRL:
            if symbol == key.A:
                self.caret.position = 0
                self.caret.mark = len(self.text)
                return pyglet.event.EVENT_HANDLED

            elif symbol == key.C:
                start = self.layout.selection_start
                end = self.layout.selection_end
                if start != end:
                    pyperclip.copy(self.document.text[start:end])
                return pyglet.event.EVENT_HANDLED

        elif modifiers & KEYMOD_MASK == (key.MOD_CTRL | key.MOD_SHIFT):
            if symbol == key.C:
                start = get_pos(self.layout.selection_start)[0]
                end = get_pos(self.layout.selection_end)[0]
                if start != end:
                    pyperclip.copy(self.text[start:end])
                return pyglet.event.EVENT_HANDLED

        return pyglet.event.EVENT_HANDLED

    def on_text(self, text):
        return pyglet.event.EVENT_HANDLED

    def on_text_motion(self, motion):
        if motion == key.MOTION_DELETE or motion == key.MOTION_BACKSPACE:
            return pyglet.event.EVENT_HANDLED

    @property
    def content_height(self):
        return self.layout.content_height + 8

    def on_resize(self, width, height):
        l = self.layout
        l.begin_update()
        l.width, l.height = width - 8, height - 8
        l.end_update()


class ListItem(object):
    def __init__(self, p, i, color=(0, 0, 0, 255)):
        self.parent = p
        self.color = color
        n = len(p.columns)
        self.labels = [None] * n
        self._data = [''] * n
        self.idx = i
        #self.data = ['Yoo~'] * n

    def _set_data(self, val):
        val = list(val)
        p = self.parent
        n = len(p.columns)
        val = (val + n*[''])[:n]
        for i, v in enumerate(val):
            self[i] = unicode(v)
        self._update_labels()

    def _get_data(self):
        return self._data

    data = property(_get_data, _set_data)

    def _update_labels(self):
        p = self.parent
        p.need_refresh = True
        ox = 2
        for (_, w), lbl in zip(p.columns, self.labels):
            lbl.begin_update()
            lbl.x, lbl.y = ox, -2 - self.idx * self.parent.line_height
            lbl.color = self.color
            lbl.end_update()
            ox += w

    def __getitem__(self, index):
        if isinstance(index, basestring):
            index = self.parent.col_lookup[index]
        return self._data[index]

    def __setitem__(self, index, val):
        from pyglet.text import Label
        p = self.parent
        if isinstance(index, basestring):
            index = p.col_lookup[index]
        self._data[index] = val
        c = p.color.text + (255,)
        o = self.labels[index]
        if o: o.delete()
        self.labels[index] = Label(
            text=val, font_name='AncientPix', font_size=9,
            anchor_x='left', anchor_y='top', color=c,
            batch=p.batch,
        )


class ListHeader(object):
    def __init__(self, p):
        self.parent = p
        from pyglet.text import Label
        cols = p.columns
        batch = pyglet.graphics.Batch()
        _x = 2
        c = p.color.heavy + (255,)
        for name, width in cols:
            Label(
                name, anchor_x='left', anchor_y='bottom',
                x=_x, y=5, color=c, font_name='AncientPix', font_size=12,
                batch=batch
            )
            _x += width
        self.batch = batch

    def draw(self):
        p = self.parent
        c = [i/255.0 for i in p.color.light]
        glColor3f(*c)
        glRectf(0, 0, p.width, p.header_height)
        c = [i/255.0 for i in p.color.heavy]
        glColor3f(*c)
        glBegin(GL_LINES)
        glVertex2f(0, 0)
        glVertex2f(p.width, 0)
        glEnd()
        self.batch.draw()


class ListView(Control):
    li_class = ListItem
    lh_class = ListHeader
    header_height = 25
    line_height = 17

    def __init__(self, color=Colors.green, *a, **k):
        Control.__init__(self, *a, **k)
        self.color = color
        self.items = []
        self.columns = []
        self.col_lookup = {}
        self._view_y = 0
        self.batch = pyglet.graphics.Batch()
        self.cur_select = None
        self.need_refresh = True

    def set_columns(self, cols):
        # [('name1', 20), ('name2', 30)]
        self.columns = list(cols)
        self.col_lookup = {
            name: index
            for index, (name, width) in enumerate(cols)
        }
        self.header = self.lh_class(self)
        self.header.data = [n for n, w in cols]

    def append(self, val, color=(0, 0, 0, 255)):
        if isinstance(val, ListItem):
            li = val
            li.parent = self
        elif isinstance(val, (list, tuple)):
            li = self.li_class(self, len(self.items))
            li.color = color
            li.data = val
        self.items.append(li)
        return li

    def clear(self):
        self.items = []
        self.cur_select = None
        self.batch = pyglet.graphics.Batch()

    def _set_view_y(self, val):
        sum_h = len(self.items) * self.line_height
        h = self.height - self.header_height
        if val < 0: val = 0
        bot_lim = max(sum_h - h, 0)
        if val > bot_lim: val = bot_lim
        self._view_y = val

    def _get_view_y(self):
        return self._view_y

    view_y = property(_get_view_y, _set_view_y)

    def draw(self):
        glColor3f(1, 1, 1)

        hh = self.header_height
        client_height = self.height - hh
        vy = self.view_y

        #glPushMatrix()
        glTranslatef(0, client_height + vy, 0)
        glEnable(GL_SCISSOR_TEST)
        ax, ay = self.abs_coords()
        ax, ay, w, h = map(int, (ax, ay, self.width, client_height))
        glScissor(ax, ay, w, h)
        self.batch.draw()
        cs = self.cur_select
        if cs is not None:
            c = Colors.get4f(self.color.light)
            glColor4f(c[0], c[1], c[2], 0.5)
            glRectf(
                0, -16-cs*self.line_height,
                self.width, -cs*self.line_height
            )
        glDisable(GL_SCISSOR_TEST)
        glTranslatef(0, -vy, 0)
        self.header.draw()

        #glPopMatrix()

    def on_mouse_scroll(self, x, y, dx, dy):
        self.view_y -= dy * 40
        self.need_refresh = True

    def _mouse_click(self, evt_type, x, y, button, modifier):
        h = self.height - self.header_height
        lh, vy = self.line_height, self.view_y
        i = (h + vy - y) / lh
        n = len(self.items)
        if 0 <= i < n:
            # cs = self.cur_select
            # if cs is not None and 0 <= cs < n:
            #     item = self.items[cs]
            self.dispatch_event(evt_type, self.items[i])
            self.cur_select = i
            # item = self.items[i]
            self.need_refresh = True

    on_mouse_click = lambda self, *a: self._mouse_click('on_item_select', *a)
    on_mouse_dblclick = lambda self, *a: self._mouse_click('on_item_dblclick', *a)

ListView.register_event_type('on_item_select')
ListView.register_event_type('on_item_dblclick')


class ProgressBar(Control):
    value = InterpDesc('_value')

    def __init__(self, *a, **k):
        Control.__init__(self, *a, **k)
        self.value = 1.0
        self.height = self.pic_frame[0].height

    def _drawit(self, x, y, w, l, m, r):
        wl, wr = l.width, r.width
        if wl + wr < w:
            l.blit_nobind(x, y)
            r.blit_nobind(x + w - wr, y)
            m.get_region(0, 0, w - wl - wr, m.height).blit_nobind(x + wl, y)
        else:
            w /= 2
            l.get_region(0, 0, w, l.height).blit_nobind(x, y)
            _x = r.width - w
            r.get_region(_x, 0, w, r.height).blit_nobind(x + w, y)

    def draw(self):
        value = self.value
        width, height = self.width, self.height

        glColor3f(1, 1, 1)
        tex = self.pic_frame[0].owner
        with tex:
            self._drawit(0, 0, width, *self.pic_frame)
            w = (width - self.core_w_correct) * value
            if w: self._drawit(self.offs_x, self.offs_y, w, *self.pic_core)


class BigProgressBar(ProgressBar):
    offs_x, offs_y = 9, 9
    core_w_correct = 18

    @property
    def pic_frame(self):
        r = common_res.pbar
        return r.bfl, r.bfm, r.bfr

    @property
    def pic_core(self):
        r = common_res.pbar
        return r.bl, r.bm, r.br


class SmallProgressBar(ProgressBar):
    offs_x, offs_y = 8, 8
    core_w_correct = 16

    @property
    def pic_frame(self):
        r = common_res.pbar
        return r.sfl, r.sfm, r.sfr

    @property
    def pic_core(self):
        r = common_res.pbar
        return r.sl, r.sm, r.sr


class ConfirmButtons(Control):
    def __init__(self, buttons=((u'确定', True), (u'取消', False)),
                 color=Colors.green, delay=0, *a, **k):
        Control.__init__(self, *a, **k)
        self.buttons = bl = []

        wl = self._get_widths(buttons)

        loc = 0
        for p, v in buttons:
            w = wl.pop(0)
            btn = Button(
                parent=self, x=loc, y=0,
                width=w, height=24,
                caption=p, color=color,
            )
            btn.retval = v

            @btn.event
            def on_click(btn=btn):
                self.confirm(btn.retval)

            bl.append(btn)
            loc += w + 6

        if delay:
            self.disable()
            gevent.spawn_later(delay, self.enable)

        self.width, self.height = loc - 6, 24

    def confirm(self, val):
        self.value = val
        self.dispatch_event('on_confirm', val)

    def draw(self):
        self.draw_subcontrols()

    def hit_test(self, x, y):
        return self.control_frompoint1(x, y)

    def update(self):
        for b in self.buttons:
            b.update()

    def disable(self):
        for b in self.buttons:
            b.state = Button.DISABLED

    def enable(self):
        for b in self.buttons:
            b.state = Button.NORMAL

    @classmethod
    def _get_widths(cls, buttons):
        if len(buttons) > 2:
            wl = [len(b[0])*16 + 20 for b in buttons]
        else:
            wl = [max(len(b[0])*16 + 20, 80) for b in buttons]

        return wl

    @classmethod
    def calc_width(cls, buttons):
        wl = cls._get_widths(buttons)
        n = len(wl)
        return sum(wl) + (n-1)*6


ConfirmButtons.register_event_type('on_confirm')


class ConfirmBox(Dialog):
    class Presets:
        OK = ((u'确定', True), )
        OKCancel = ((u'确定', True), (u'取消', False))

    _default_value = object()

    def __init__(self, text=u'Yoo~', caption=u'信息',
                 buttons=Presets.OK, default=_default_value, *a, **k):
        Dialog.__init__(
            self, caption, width=300,
            bot_reserve=33, *a, **k
        )

        lbl = self.add_label(
            text, 0, 33 + 20, anchor_x='center', anchor_y='bottom',
            font_size=9, width=10000, multiline=True, color=(0, 0, 0, 255)
        )
        w, h = lbl.content_width + 1, lbl.content_height
        dw, dh = max(w, ConfirmButtons.calc_width(buttons))+50, h+24+33+20*2
        self.width, self.height = dw, dh
        lbl.begin_update()
        lbl.width = w
        self.set_label_position(lbl, dw//2, 33 + 20)
        lbl.end_update()

        p = self.parent
        pw, ph = p.width, p.height
        self.set_position((pw - dw)/2, (ph - dh)/2)

        self.confirm_btns = btn = ConfirmButtons(buttons, parent=self, color=self.color)
        self.value = buttons[0][1] if default is self._default_value else default

        @btn.event
        def on_confirm(val):
            self.value = val
            self.delete()
        btn.x, btn.y = (dw - btn.width)/2, 5

    def delete(self):
        self.dispatch_event('on_confirm', self.value)
        Dialog.delete(self)

    def on_move(self, x, y):
        self.confirm_btns.update()


ConfirmBox.register_event_type('on_confirm')


class Panel(Control):
    fill_color = (1.0, 1.0, 0.8, 0.0)

    def __init__(self, color=Colors.green, *a, **k):
        Control.__init__(self, *a, **k)
        self.color = color
        self.tick = 0
        self.update()

    def update(self):
        w, h = int(self.width), int(self.height)

        from shaders import HAVE_SHADER
        if HAVE_SHADER:
            blurtex = pyglet.image.Texture.create(w, h)

            self.blurtex = blurtex

            t = blurtex.tex_coords
            x1 = 0
            y1 = 0
            x2 = blurtex.width
            y2 = blurtex.height

            array = (GLfloat * 32)(
                t[0],  t[1],  t[2],  1.,
                x1,    y1,    0,     1.,
                t[3],  t[4],  t[5],  1.,
                x2,    y1,    0,     1.,
                t[6],  t[7],  t[8],  1.,
                x2,    y2,    0,     1.,
                t[9],  t[10], t[11], 1.,
                x1,    y2,    0,     1.,
            )
            self._blurtex_array = array
        else:
            self.blurtex = None

    def draw(self):
        blurtex = self.blurtex
        w, h = int(self.width), int(self.height)

        if blurtex:
            from shaders import GaussianBlurHorizontal as GBH, GaussianBlurVertical as GBV, ShaderProgram

            ax, ay = self.abs_coords()
            ax, ay = int(ax), int(ay)

            t = getattr(blurtex, 'owner', blurtex)
            _w, _h = t.width, t.height

            glColor3f(1, 1, 1)

            glEnable(blurtex.target)
            glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT)
            glInterleavedArrays(GL_T4F_V4F, 0, self._blurtex_array)
            glBindTexture(blurtex.target, blurtex.id)

            glCopyTexImage2D(blurtex.target, 0, GL_RGBA, ax, ay, _w, _h, 0)
            GBV.use()
            GBV.uniform.size = (_w, _h)
            glDrawArrays(GL_QUADS, 0, 4)

            glCopyTexImage2D(blurtex.target, 0, GL_RGBA, ax, ay, _w, _h, 0)
            GBH.use()
            GBH.uniform.size = (_w, _h)
            glDrawArrays(GL_QUADS, 0, 4)

            ShaderProgram.restore()

            glBindTexture(blurtex.target, 0)
            glPopClientAttrib()
            glDisable(blurtex.target)

        c = self.fill_color
        if c[3] != 0.0:
            glColor4f(*c)
            glRectf(0, 0, w, h)

        glLineWidth(3.0)
        glColor4f(1, 1, 1, .3)
        glRectf(1.5, 1.5, -1.5+w, -1.5+h)
        glColor3f(*[i/255.0 for i in self.color.frame])
        glRectf(-1.5+w, 1.5, 1.5, -1.5+h)
        glLineWidth(1.0)

        self.draw_subcontrols()


class ImageSelector(Control, BalloonPromptMixin):
    hover_alpha = InterpDesc('_hover_alpha')

    def __init__(self, image, group, *a, **k):
        Control.__init__(
            self, width=145, height=98,
            *a, **k
        )

        self.selected = False
        self.disabled = False
        self.hover_alpha = 0.0
        self.image = image
        self.group = group

    def on_mouse_enter(self, x, y):
        self.hover_alpha = 0.4

    def on_mouse_leave(self, x, y):
        self.hover_alpha = LinearInterp(
            0.4, 0, 0.3
        )

    def on_mouse_click(self, x, y, button, modifier):
        if self.disabled: return
        for gs in self.group:
            gs.selected = False
        self.selected = True
        self.dispatch_event('on_select')

    def on_mouse_dblclick(self, x, y, button, modifier):
        if self.disabled: return
        self.dispatch_event('on_dblclick')

    def draw(self):
        glColor3f(1, 1, 1)
        if self.disabled:
            self.image.grayed.blit(0, 0)
        else:
            self.image.blit(0, 0)

        glColor3f(0.757, 1.0, 0.384)
        glRectf(0, self.height, self.width, 0)

        if self.selected:
            common_res.imagesel_shine.blit(-11, -11)

        a = self.hover_alpha
        if a:
            glColor4f(1, 1, 0.8, a)
            glRectf(0, 0, self.width, self.height)

    def disable(self):
        self.disabled = True
        self.selected = False

    def enable(self):
        self.disabled = False

    @staticmethod
    def get_selected(group):
        for c in group:
            if c.selected:
                return c
        return None

ImageSelector.register_event_type('on_select')
ImageSelector.register_event_type('on_dblclick')


class SensorLayer(Control):
    def __init__(self, parent, *a, **k):
        Control.__init__(self,
            parent=parent,
            x=0, y=0, width=parent.width, height=parent.height,
            *a, **k
        )


class VolumeTuner(Control, BalloonPromptMixin):
    def __init__(self, *a, **k):
        Control.__init__(self, width=32, height=32, zindex=99999, *a, **k)
        self.init_balloon(
            u'|DB调节音量的图标|r\n'
            u'\n'
            u'单击切换静音和有声音\n'
            u'鼠标滚轮调整音量大小'
        )

    def draw(self):
        glColor4f(1, 1, 1, 1)
        with common_res.speaker.owner:
            glColor4f(1, 1, 1, 1)
            common_res.speaker_off.blit_nobind(0, 0)
            from client.ui.soundmgr import SoundManager
            glColor4f(1, 1, 1, SoundManager.get_volume())
            common_res.speaker.blit_nobind(0, 0)

    def on_mouse_click(self, x, y, button, modifier):
        from client.ui.soundmgr import SoundManager
        vol = SoundManager.get_volume()
        if vol > 0:
            SoundManager.mute()
        else:
            SoundManager.unmute()

    def on_mouse_scroll(self, x, y, dx, dy):
        from client.ui.soundmgr import SoundManager
        vol = SoundManager.get_volume()
        vol += 0.1 * dy
        vol = min(1.0, vol)
        vol = max(0.0, vol)

        if vol:
            SoundManager.unmute()
            SoundManager.set_volume(vol)
        else:
            SoundManager.mute()


class OptionButton(Button):
    Conf = namedtuple('OptionButtonConfiguration', 'caption color value')
    DEFAULT_CONF = (
        (u'关闭', Colors.blue, False),
        (u'打开', Colors.orange, True),
    )
    _DEFAULT = object()

    def __init__(self, conf=None, value=_DEFAULT, *a, **k):
        self.conf = conf = [self.Conf(*i) for i in conf or self.DEFAULT_CONF]
        self.confidx = confidx = {c.value: i for i, c in enumerate(conf)}
        i = confidx.get(value, conf[0].value)
        self.index = i
        c = conf[i]
        self._value = c.value
        Button.__init__(self, c.caption, c.color, *a, **k)

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, value):
        if value == self._value:
            return

        self._value = value
        self.option_update()
        self.dispatch_event('on_value_changed', value)

    def option_update(self):
        i = self.confidx[self.value]
        c = self.conf[i]
        self.caption = c.caption
        self.color = c.color
        self.index = i
        self.update()

    def on_click(self):
        i = (self.index + 1) % len(self.conf)
        self.index = i
        self.value = self.conf[i].value

OptionButton.register_event_type('on_value_changed')


class NoInviteButton(OptionButton):
    def __init__(self, *a, **k):
        from user_settings import UserSettings
        conf = (
            (u'邀请已关闭', Colors.blue, True),
            (u'邀请已开启', Colors.orange, False),
        )
        OptionButton.__init__(self, conf=conf, value=UserSettings.no_invite, *a, **k)
        UserSettings.add_observer('setting_change', self)

    def __call__(self, k, v):
        if k == 'no_invite':
            self.value = v

    def on_value_changed(self, value):
        from user_settings import UserSettings as us
        us.no_invite = value

    def delete(self):
        from user_settings import UserSettings
        UserSettings.remove_observer('setting_change', self)
        OptionButton.delete(self)


class CheckBox(Control):
    def __init__(self, value=False, *a, **k):
        conf = (
            (u'', Colors.blue, False),
            (u'', Colors.orange, True),
        )
        Control.__init__(self, width=28, height=22, *a, **k)

        self.label = label = pyglet.text.Label(
            self.caption, u'AncientPix', 9,
            color=(0, 0, 0, 255),
            x=24, y=2,
            anchor_x='left', anchor_y='bottom',
        )

        self.width = 30 + label.content_width

        self.opt = OptionButton(
            parent=self, conf=conf, x=0, y=0,
            width=16, height=16, value=value
        )
        self.image = common_res.check

        sensor = SensorLayer(self, zindex=1)
        sensor.event(self.opt.on_mouse_enter)
        sensor.event(self.opt.on_mouse_leave)
        sensor.event(self.opt.on_mouse_click)
        sensor.event(self.opt.on_mouse_release)

    @property
    def value(self):
        return self.opt.value

    def draw(self):
        self.draw_subcontrols()
        if self.opt.value:
            a = 1 - self.opt.hover_alpha
        else:
            a = 2 * self.opt.hover_alpha
        glColor4f(1, 1, 1, a)
        self.image.blit(-4, -3)
        self.label.draw()

########NEW FILE########
__FILENAME__ = entry
# -*- coding: utf-8 -*-
import threading
import sys, os

from utils import hook

import logging
log = logging.getLogger('UI_Entry')

def start_ui():
    # ATI workarounds
    import pyglet
    from pyglet import gl
    @hook(gl)
    def glDrawArrays(ori, *a, **k):
        from pyglet.gl import glBegin, glEnd, GL_QUADS
        glBegin(GL_QUADS)
        glEnd()
        return ori(*a, **k)

    # ---------------

    from client.ui.base import init_gui, ui_schedule, ui_message

    init_gui()

    # This forces all game resources to initialize,
    # else they will be imported firstly by GameManager,
    # then resources will be loaded at a different thread,
    # resulting white planes.
    # UPDATE: no more threading now, but retain notice above.
    from client.ui.resource import resource
    import gamepack
    gamepack.init_ui_resources()

    from client.ui.resloader import Resource
    Resource.load_resources()

    from client.ui.base.baseclasses import main_window
    main_window.set_icon(resource.icon)
    main_window.set_visible(True)

    # custom errcheck
    import pyglet.gl.lib as gllib
    orig_errcheck = gllib.errcheck

    import ctypes
    def my_errcheck(result, func, arguments):
        from pyglet import gl
        error = gl.glGetError()
        if error and error != 1286:
            # HACK: The 1286(INVALID_FRAMEBUFFER_OPERATION) error again!
            # This time I DIDN'T EVEN USE FBO! ATI!!
            msg = ctypes.cast(gl.gluErrorString(error), ctypes.c_char_p).value
            raise gl.GLException((error, msg))
        return result

    gllib.errcheck = my_errcheck
    # ------------------------------------

    from screens import UpdateScreen, ServerSelectScreen

    us = UpdateScreen()
    us.switch()
    from client.core import Executive
    sss = ServerSelectScreen()

    errmsgs = {
        'update_disabled': u'自动更新已被禁止',
        'error': u'更新过程出现错误，您可能无法正常进行游戏！',
    }

    def display_box(msg):
        from client.ui.controls import ConfirmBox
        b = ConfirmBox(msg, parent=us)
        @b.event
        def on_confirm(val):
            sss.switch()

    def update_callback(msg):
        # executes in logic thread
        # well, intented to be
        # ui and logic now run in the same thread.

        from options import options
        if msg == 'up2date':
            ui_schedule(sss.switch)
        elif msg == 'update_disabled' and options.fastjoin:
            import gevent
            def func():
                from client.ui.soundmgr import SoundManager
                SoundManager.mute()
                gevent.sleep(0.3)
                ui_schedule(sss.switch)
                gevent.sleep(0.3)
                Executive.call('connect_server', ui_message, ('127.0.0.1', 9999), ui_message)
                gevent.sleep(0.3)
                Executive.call('auth', ui_message, ['Proton1', 'abcde'])
                gevent.sleep(0.3)
                Executive.call('quick_start_game', ui_message, 'THBattle')
                gevent.sleep(0.3)
                Executive.call('get_ready', ui_message, [])

            gevent.spawn(func)
                
        elif msg in errmsgs:
            ui_schedule(display_box, errmsgs[msg])
        else:
            os.execv(sys.executable, [sys.executable] + sys.argv)

    Executive.call('update', update_callback, lambda *a: ui_schedule(us.update_message, *a))

    # workaround for pyglet's bug
    if sys.platform == 'win32':
        import pyglet.app.win32
        pyglet.app.win32.Win32EventLoop._next_idle_time = None

    pyglet.app.run()

########NEW FILE########
__FILENAME__ = resloader
# -*- coding: utf-8 -*-

import pyglet
from pyglet.resource import Loader
from cStringIO import StringIO
import os
import hashlib
from utils import flatten, aes_decrypt
from PIL import Image
import weakref


def get_atlas(atlas_name='__default__', atlas_size=(1024, 1024)):
    atlas = atlases.get(atlas_name)
    if not atlas:
        atlas = pyglet.image.atlas.TextureAtlas(*atlas_size)
        atlases[atlas_name] = atlas

    return atlas

atlases = {}
atlases['__default__'] = pyglet.image.atlas.TextureBin(512, 512)
define_atlas = get_atlas


class _ResourceDesc(object):
    __defaults__ = {}

    def __init__(self, *args):
        for k, v in self.__defaults__.items():
            setattr(self, k, v)

        for s, v in zip(self.__slots__, args):
            setattr(self, s, v)


class dummy(_ResourceDesc):
    __slots__ = ('name', )

    def __init__(self):
        self.name = '__dummy__'

    def load(self, loader):
        pass


class imgdata(_ResourceDesc):
    __slots__ = ('name', )

    def load(self, loader):
        fn = self.name + '.png'
        f = loader.file(fn)
        i = pyglet.image.load(fn, file=f)
        f.close()
        return i


class imgdata_grid(_ResourceDesc):
    __slots__ = ('name', 'rows', 'columns')

    def load(self, loader):
        img = imgdata(self.name).load(loader)
        img = pyglet.image.ImageGrid(img, self.rows, self.columns)
        return img


class img(_ResourceDesc):
    __slots__ = ('name', 'atlas')
    __defaults__ = {'atlas': '__default__'}

    def load(self, loader):
        i = imgdata(self.name).load(loader)
        atlas = get_atlas(self.atlas)
        return atlas.add(i)


class img_with_grayed(_ResourceDesc):
    __slots__ = ('name', 'atlas')
    __defaults__ = {'atlas': '__default__'}

    def load(self, loader):
        i = Image.open(loader.file(self.name + '.png'))
        w, h = i.size
        colored = i.convert('RGBA').tostring()
        grayed = i.convert('LA').convert('RGBA').tostring()
        colored = pyglet.image.ImageData(w, h, 'RGBA', colored, -w*4)
        grayed = pyglet.image.ImageData(w, h, 'RGBA', grayed, -w*4)
        atlas = get_atlas(self.atlas)
        tex = atlas.add(colored)
        tex.grayed = atlas.add(grayed)
        return tex


class img_grid(_ResourceDesc):
    __slots__ = ('name', 'rows', 'columns', 'atlas')
    __defaults__ = {'atlas': '__default__'}

    def load(self, loader):
        img = imgdata_grid(self.name, self.rows, self.columns).load(loader)
        atlas = get_atlas(self.atlas)
        img = [atlas.add(t) for t in img]
        return img


class anim(_ResourceDesc):
    __slots__ = ('name', 'durlist', 'loop', 'atlas')
    __defaults__ = {'atlas': '__default__', 'loop': False}
    dummy_img = pyglet.image.ImageData(1, 1, 'RGBA', '\x00'*4)

    def load(self, loader):
        img = imgdata(self.name).load(loader)
        durlist = self.durlist

        n = len(durlist)

        ig = pyglet.image.ImageGrid(img, 1, n)
        frames = []
        for i, (fi, dur) in enumerate(zip(ig, durlist)):
            f = pyglet.image.AnimationFrame(fi, dur/1000.0)
            frames.append(f)

        self.loop or frames.append(
            pyglet.image.AnimationFrame(self.dummy_img, None)
        )

        a = pyglet.image.Animation(frames)
        atlas = get_atlas(self.atlas)
        a.add_to_texture_bin(atlas)
        return a


class texture(_ResourceDesc):
    __slots__ = ('name', )

    def load(self, loader):
        return loader.texture(self.name + '.png')


class lazytexture(_ResourceDesc):
    __slots__ = ('name', )

    def load(self, loader):
        self.loader = loader
        self.reference = weakref.ref(lambda: 0)  # make a dead ref
        return self

    def get(self):
        obj = self.reference()
        if obj is not None:
            return obj

        obj = self.loader.texture(self.name + '.png')
        self.reference = weakref.ref(obj)
        return obj


class encrypted_texture(_ResourceDesc):
    __slots__ = ('name',)

    def load(self, loader):
        self.loader = loader
        self.reference = None
        self.decrypted = False
        hint = self.loader.file(self.name + '.hint').read()
        self.hint = hint
        return self

    def decrypt(self, passphrase):
        if self.reference:
            return False

        hint = self.hint.decode('base64')
        key = hashlib.sha256(passphrase).digest()
        hint2 = hashlib.sha256(key).digest()
        if hint != hint2:
            return False

        f = self.loader.file(self.name + '_encrypted.bin')
        dec = StringIO()
        data = aes_decrypt(f.read(), key)
        assert data.startswith('\x89PNG')
        dec.write(data)
        dec.seek(0)

        tex = pyglet.image.load('foo.png', file=dec)
        self.reference = tex
        self.decrypted = True
        return True

    def get(self):
        if not self.reference:
            raise Exception('Not decrypted!')

        return self.reference


class bgm(_ResourceDesc):
    __slots__ = ('name', )

    def load(self, loader):
        self.loader = loader
        return self

    def __call__(self):
        loader = self.loader
        return loader.media(loader.filename(self.name + '.ogg'))


class sound(_ResourceDesc):
    __slots__ = ('name', )

    def load(self, loader):
        snd = loader.media(
            loader.filename(self.name + '.ogg'), streaming=False
        )
        return snd


class subdir(_ResourceDesc):
    __slots__ = ('name', 'resdesc')

    def load(self, loader):
        res = _Resource(
            os.path.join(loader.path[0], self.name),
            self.resdesc,
        )
        res.load()
        return res


class _Resource(object):
    def __init__(self, path, resdesc):
        self.path = path
        self.resdesc = resdesc

    def load(self):
        loader = ResourceLoader(self.path)
        desclist = [
            i for i in flatten(self.resdesc)
            if isinstance(i, _ResourceDesc)
        ]

        for desc in desclist:
            res = desc.load(loader)
            setattr(self, desc.name, res)


class Resource(_Resource):
    loaded = False
    resources = []

    def __init__(self, *a):
        if self.__class__.loaded:
            raise Exception('Resource already loaded!')
        self.__class__.resources.append(self)
        _Resource.__init__(self, *a)

    @classmethod
    def load_resources(cls):
        cls.loaded = True
        for res in cls.resources:
            res.load()


class ResourceLoader(Loader):
    def filename(self, name):
        fn, ext = os.path.splitext(name)
        custom_name = fn + '_custom' + ext
        if os.path.exists(os.path.join(self.path[0], custom_name)):
            return custom_name
        else:
            return name

    def file(self, name, mode='rb'):
        return Loader.file(self, self.filename(name), mode)

########NEW FILE########
__FILENAME__ = resource
import pyglet
from pyglet.resource import Loader
import zipfile

from client.ui.resloader import anim, bgm, get_atlas, img, imgdata_grid, img_grid, Resource, sound, subdir, texture, imgdata, lazytexture
from client.ui.resloader import _ResourceDesc
import os

respath = os.path.join(os.path.dirname(__file__), 'res')

# special case for font
ldr = Loader(respath)
fontzip = zipfile.ZipFile(ldr.file('font.zip'))
font = {
    fn: fontzip.open(fn).read()
    for fn in fontzip.namelist()
}
fontzip.close()
del fontzip, ldr


class white(_ResourceDesc):
    __slots__ = ('name', )

    def load(self, loader):
        atlas = get_atlas()
        white = atlas.add(pyglet.image.ImageData(4, 4, 'RGBA', '\xFF'*64))
        c = white.tex_coords
        f = c[0:3]; t = c[6:9]
        white.tex_coords = ((f[0] + t[0]) / 2, (f[1] + t[1]) / 2, 0) * 4
        return white


resource = Resource(respath, [
    bgm('bgm_hall'),

    lazytexture('bg_login'),
    lazytexture('bg_gamehall'),
    lazytexture('bg_ingame'),
    lazytexture('worldmap'),
    lazytexture('worldmap_shadow'),
    lazytexture('bg_gamelist'),
    lazytexture('bg_eventsbox'),
    lazytexture('bg_chatbox'),

    img('imagesel_shine'),
    imgdata('icon'),

    img('check'),

    img('speaker'),
    img('speaker_off'),

    anim('actor_frame', [50] * 9, True),
    anim('turn_frame', [50] * 9, True),

    texture('ray'),

    subdir('pbar', [img(i) for i in [
        'bl', 'bm', 'br',
        'bfl', 'bfm', 'bfr',
        'sl', 'sm', 'sr',
        'sfl', 'sfm', 'sfr',
    ]]),

    subdir('buttons', [
        [
            img_grid('close_' + t, 1, 4)
            for t in ('blue', 'red', 'green', 'orange')
        ],
        img_grid('port_showncard', 1, 4),
        img_grid('serverbtn', 1, 4),
    ]),


    subdir('sound', [
        sound('input'),
    ]),

    imgdata_grid('suit12', 1, 4), imgdata_grid('suit16', 1, 4),

    white('white'),
])

########NEW FILE########
__FILENAME__ = screens
# -*- coding: utf-8 -*-

# -- stdlib --
import logging
log = logging.getLogger('UI_Screens')
from collections import deque
import shlex
import re

# -- third party --
import pyglet
from pyglet.gl import glClear, glClearColor, glColor3f, glColor4f, GL_COLOR_BUFFER_BIT, glRectf
from pyglet.text import Label

# -- own --
from client.ui.base import WINDOW_WIDTH, WINDOW_HEIGHT, Control, Overlay, ui_message
from client.ui.base.interp import CosineInterp, InterpDesc, LinearInterp
from client.ui.controls import BalloonPromptMixin, Button, Colors, ConfirmBox, Frame, VolumeTuner, NoInviteButton
from client.ui.controls import ImageSelector, ListView, Panel
from client.ui.controls import PasswordTextBox, PlayerPortrait
from client.ui.controls import TextArea, TextBox, SensorLayer, CheckBox
from client.ui.resource import resource as common_res
from client.ui.soundmgr import SoundManager

from client.core import Executive
from utils import rect_to_dict as r2d, textsnap, inpoly, openurl
from utils.crypto import simple_encrypt, simple_decrypt
from user_settings import UserSettings
from account import Account
from settings import ServerNames

RE_AT = re.compile(ur'@([^@ ]+)')


def handle_chat(_type, args):
    if _type in ('chat_msg', 'ob_msg'):
        uname, msg = args[0]
        uname = uname.replace('|', '||')

        if Executive.gamemgr.account.username in RE_AT.findall(msg):
            from utils.notify import notify, AT

            notify(u'东方符斗祭 - 有人@您哦', u'%s: %s' % (uname, msg), level=AT)

        style = '|cff0000ff' if _type == 'chat_msg' else '|c9f5f9fff'
        return u'%s%s|r：%s\n' % (style, uname, msg)

    elif _type == 'speaker_msg':
        node, uname, msg = args[0]
        from utils.notify import notify, SPEAKER
        notify(u'东方符斗祭 - 『文々。新闻』',
               u'%s: %s' % (uname, msg), level=SPEAKER)
        node = node and '|G%s' % ServerNames.get(node, node)
        uname = uname.replace('|', '||')
        return u'%s|ccc3299ff『文々。新闻』|cff0000ff%s|r： %s\n' % (node, uname, msg)

    elif _type == 'system_msg':
        _, msg = args[0]
        return u'|B|R%s|r\n' % msg

    else:
        return None


class ChatBoxFrame(Frame):
    history_limit = 1000
    history = deque([None] * history_limit)

    def __init__(self, **k):
        Frame.__init__(
            self,
            caption=u'系统/聊天信息',
            bot_reserve=33, **k
        )
        self.box = TextArea(
            parent=self, x=2, y=33+2, width=self.width, height=self.height-24-2-33
        )
        self.inputbox = TextBox(
            parent=self, x=6, y=6, width=self.width-12, height=22,
        )
        self.history_cursor = -1
        self.last_input = u''
        self.box.text = u'|R输入/?可以查看可用命令|r\n'

        @self.inputbox.event
        def on_text_motion(motion):
            hist = self.history
            cursor = self.history_cursor
            box = self.inputbox
            from pyglet.window import key
            if motion == key.MOTION_UP:
                cursor += 1
                if not cursor:
                    self.last_input = box.text

                text = hist[cursor]
                if text:
                    self.history_cursor = cursor
                    box.text = text
                    box.caret.position = len(text)

            if motion == key.MOTION_DOWN:
                if cursor < 0: return
                cursor -= 1

                if cursor < 0:
                    self.history_cursor = -1
                    box.text = self.last_input

                    return

                text = hist[cursor]
                if text:
                    box.text = text
                    box.caret.position = len(text)
                    self.history_cursor = cursor
                else:
                    self.history_cursor = -1

        @self.inputbox.event
        def on_enter():
            text = unicode(self.inputbox.text)
            self.inputbox.text = u''
            if not text: return

            self.add_history(text)
            if text.startswith(u'`') and len(text) > 1:
                text = text[1:]
                if not text: return
                Executive.call('speaker', ui_message, text)
            elif text.startswith(u'/'):
                from . import commands
                cmdline = shlex.split(text[1:])
                msg = commands.process_command(cmdline)
                msg and self.append(msg)
            else:
                Executive.call('chat', ui_message, text)

    def append(self, v):
        self.box.append(v)

    def add_history(self, text):
        self.history_cursor = -1
        hist = self.__class__.history
        hist.rotate(1)
        hist[0] = text
        hist[-1] = None

    def set_color(self, color):
        Frame.set_color(self, color)
        self.inputbox.color = color


class Screen(Overlay):
    def on_message(self, _type, *args):
        if _type == 'server_dropped':
            ConfirmBox(u'已经与服务器断开链接，请重新启动游戏！', parent=Screen.cur_overlay)

        elif _type == 'invite_request':
            uid, uname, gid, gtype = args[0]
            from user_settings import UserSettings as us
            if us.no_invite:
                Executive.call('invite_grant', ui_message, [gid, False])
                return

            from gamepack import gamemodes as modes

            gtype = modes.get(gtype, None)
            gtype = gtype and gtype.ui_meta.name

            invite_text = u'%s 邀请你一起玩 %s 模式' % (uname, gtype)

            from utils import notify
            notify(u'东方符斗祭 - 邀请提醒', invite_text)

            box = ConfirmBox(
                invite_text, timeout=20,
                parent=self, buttons=((u'确定', True), (u'取消', False)), default=False
            )

            @box.event
            def on_confirm(val, uid=uid):
                Executive.call('invite_grant', ui_message, [gid, val])

        else:
            Overlay.on_message(self, _type, *args)


class UpdateScreen(Screen):
    trans = dict(
        update_begin=lambda: u'|W开始更新……|r',
        up2date=lambda: u'|W已经是最新版本了|r',
        delete_file=lambda fn: u'|W删除：|LB%s|r' % fn,
        download_file=lambda fn: u'|W下载：|LB%s|r' % fn,
        download_complete=lambda fn: u'|W下载完成：|LB%s|r' % fn,
        write_failed=lambda fn: u'|R无法写入：|LB%s|r' % fn,
        update_finished=lambda: u'|W更新完成|r',
        http_error=lambda code, url: u'|RHTTP错误： %d %s|r' % (code, url),
        network_error=lambda: u'|R网络错误|r',
        io_error=lambda: u'|R系统错误|r',  # WHATEVER
    )

    def __init__(self, *args, **kwargs):
        Screen.__init__(self, *args, **kwargs)
        ta = TextArea(
            parent=self, width=600, height=450,
            x=(self.width-600)//2, y=(self.height-450)//2
        )
        self.textarea = ta

    def update_message(self, msg, *args):
        msg = self.trans[msg](*args)
        self.textarea.append(msg + '\n')

    def draw(self):
        glClearColor(0.0, 0.0, 0.0, 1.0)
        glClear(GL_COLOR_BUFFER_BIT)
        self.draw_subcontrols()


class ServerSelectScreen(Screen):

    def __init__(self, *args, **kwargs):
        Screen.__init__(self, *args, **kwargs)
        self.worldmap = common_res.worldmap.get()

        from settings import ServerList, NOTICE

        class NoticePanel(Panel):
            fill_color = (1.0, 1.0, 0.9, 0.5)

            def __init__(self, text, *a, **k):
                Panel.__init__(self, *a, **k)
                self.zindex = 100
                w, h = self.width, self.height
                ta = TextArea(
                    parent=self,
                    font_size=12,
                    x=2, y=60,
                    width=w-4, height=h-4-60
                )
                ta.append(text)
                btn = Button(
                    u'关闭',
                    parent=self,
                    x=(w-120)//2, y=20,
                    width=120, height=40,
                )

                @btn.event
                def on_click():
                    self.delete()

        screen = self

        class HighlightLayer(SensorLayer, BalloonPromptMixin):
            zindex = 0
            hl_alpha = InterpDesc('_hl_alpha')

            def __init__(self, *a, **k):
                SensorLayer.__init__(self, *a, **k)
                BalloonPromptMixin.__init__(self)
                from base.baseclasses import main_window
                self.window = main_window
                self.hand_cursor = self.window.get_system_mouse_cursor('hand')
                self.worldmap_shadow = common_res.worldmap_shadow.get()
                self.disable_click = False
                self.highlight = None
                self.hldraw = None
                self.hl_alpha = 0
                self.hlhit = False

            def on_mouse_motion(self, x, y, dx, dy):
                for s in ServerList.values():
                    if inpoly(x, y, s['polygon']):
                        self.hl_alpha = 1
                        if self.highlight is not s:
                            self.highlight = s
                            self.init_balloon(s['description'], polygon=s['polygon'])
                            x, y, w, h = s['box']
                            tex = self.worldmap_shadow.get_region(x, y, w, h)
                            self.hldraw = (x, y, tex)
                            self.window.set_mouse_cursor(self.hand_cursor)

                        break
                else:
                    if self.highlight:
                        self.highlight = None
                        self.hl_alpha = LinearInterp(1.0, 0, 0.3)
                        self.window.set_mouse_cursor(None)

                    self.init_balloon('', (0, 0, 0, 0))

            def on_mouse_release(self, x, y, button, modifiers):
                if self.highlight and not self.disable_click:
                    self.disable_click = True
                    screen.do_connect(self.highlight['address'])

            def enable_click(self):
                self.disable_click = False

            def draw(self):
                hla = self.hl_alpha
                if hla and not self.disable_click:
                    x, y, tex = self.hldraw
                    glColor4f(1, 1, 1, hla)
                    tex.blit(x, y)

        NoticePanel(
            NOTICE,
            parent=self,
            width=800, height=600,
            x=(self.width-800)//2, y=(self.height-600)//2
        )

        self.highlight_layer = HighlightLayer(parent=self)

        VolumeTuner(parent=self, x=self.width - 90, y=60)

    def do_connect(self, addr):
        Executive.call('connect_server', ui_message, addr, ui_message)

    def on_message(self, _type, *args):
        if _type == 'server_connected':
            login = LoginScreen()
            login.switch()
        elif _type == 'server_connect_failed':
            self.highlight_layer.enable_click()
            log.error('Server connect failed.')
            ConfirmBox(u'服务器连接失败！', parent=self)
        elif _type == 'version_mismatch':
            self.highlight_layer.enable_click()
            log.error('Version mismatch')
            ConfirmBox(u'您的版本与服务器版本不符，无法进行游戏！', parent=self)
        else:
            Screen.on_message(self, _type, *args)

    def draw(self):
        #glColor3f(0.9, 0.9, 0.9)
        glColor3f(1, 1, 1)
        self.worldmap.blit(0, 0)
        self.draw_subcontrols()

    def on_switch(self):
        SoundManager.switch_bgm(common_res.bgm_hall)
        from options import options

        options.testing and ConfirmBox(
            u'测试模式开启，现在可以登陆测试服务器。\n'
            u'测试模式下可能无法登陆正常服务器，\n'
            u'测试服务器也会随时重新启动。',
            parent=self, zindex=99999,
        )


class LoginScreen(Screen):
    class LoginDialog(Frame):
        def __init__(self, *a, **k):
            Frame.__init__(
                self, u'登陆', x=350, y=165,
                width=325, height=184,
                bot_reserve=50, *a, **k
            )

            def L(text, x, y, *a, **k):
                self.add_label(
                    text, x=x, y=y,
                    font_size=9, color=(0, 0, 0, 255),
                    bold=True, anchor_x='left', anchor_y='bottom',
                    *a, **k
                )

            L(u'用户名：', 368 - 350, 286 - 165)
            L(u'密码：', 368 - 350, 250 - 165)

            self.txt_username = TextBox(
                parent=self, x=438-350, y=282-165, width=220, height=20,
                text=UserSettings.last_id,
            )
            self.txt_pwd = PasswordTextBox(
                parent=self, x=438-350, y=246-165, width=220, height=20,
                text=simple_decrypt(UserSettings.saved_passwd),
            )
            self.chk_savepwd = CheckBox(
                parent=self, x=438-350, y=56, caption=u'记住密码',
                value=bool(self.txt_pwd.text),
            )
            self.btn_login = Button(
                parent=self, caption=u'进入幻想乡',
                x=50, y=10, width=100, height=30
            )
            self.btn_reg = Button(
                parent=self, caption=u'乡民登记',
                color=Colors.orange,
                x=175, y=10, width=100, height=30
            )

            @self.btn_login.event
            def on_click():
                self.do_login()

            @self.txt_pwd.event
            def on_enter():
                self.do_login()

            @self.btn_reg.event  # noqa
            def on_click():
                openurl('http://www.thbattle.net')

        def do_login(self):
            u, pwd = self.txt_username.text, self.txt_pwd.text
            Executive.call('auth', ui_message, [u, pwd])

    def __init__(self, *args, **kwargs):
        Screen.__init__(self, *args, **kwargs)
        self.bg = common_res.bg_login.get()
        self.bg_alpha = LinearInterp(0, 1.0, 1.5)
        self.dialog = LoginScreen.LoginDialog(parent=self)
        try_game = Button(
            parent=self, caption=u'试玩',
            x=750, y=50, width=100, height=30, color=Colors.orange,
        )

        @try_game.event
        def on_click():
            text = (
                u'试玩的玩家有以下限制：\n'
                u'\n'
                u'随机的id，不记录游戏数和节操\n'
                u'固定的头像、自定义签名\n'
                u'无法使用文文新闻和邀请功能\n'
                u'无法断线重连'
            )

            confirm = ConfirmBox(text, buttons=ConfirmBox.Presets.OKCancel, parent=self)

            @confirm.event
            def on_confirm(val):
                val and Executive.call('auth', ui_message, ['-1', 'guest'])

    def on_message(self, _type, *args):
        if _type == 'auth_success':
            dlg = self.dialog
            UserSettings.last_id = dlg.txt_username.text
            UserSettings.saved_passwd = simple_encrypt(
                dlg.txt_pwd.text if dlg.chk_savepwd.value else ''
            )
            GameHallScreen().switch()

        elif _type == 'auth_failure':
            log.error('Auth failure')
            status = args[0]
            tbl = dict(
                not_available=u'您的帐号目前不可用，请联系管理员询问！',
                already_logged_in=u'请不要重复登录！',
                invalid_credential=u'认证失败！',
            )
            ConfirmBox(tbl.get(status, status), parent=self)
        else:
            Screen.on_message(self, _type, *args)

    def draw(self):
        glClearColor(1.0, 1.0, 1.0, 1.0)
        glClear(GL_COLOR_BUFFER_BIT)
        glColor4f(1, 1, 1, self.bg_alpha.value)
        self.bg.blit(0, 0)
        self.draw_subcontrols()

    def on_switch(self):
        SoundManager.switch_bgm(common_res.bgm_hall)


class GameHallScreen(Screen):
    class GameList(Frame):
        class CreateGamePanel(Panel):
            def __init__(self, *a, **k):
                w, h = 550, 485
                Panel.__init__(
                    self, width=w, height=h,
                    zindex=1000,
                    *a, **k
                )
                self.x = (self.overlay.width - w) // 2
                self.y = (self.overlay.height - h) // 2

                self.btncreate = btncreate = Button(
                    u'创建游戏', parent=self, x=440, y=75, width=90, height=40
                )
                self.btncancel = btncancel = Button(
                    u'取消', parent=self, x=440, y=25, width=90, height=40
                )
                btncreate.state = Button.DISABLED

                txtbox = self.txtgamename = TextBox(
                    parent=self, x=95, y=395, width=420, height=22,
                )
                uname = Executive.gamemgr.account.username

                f = pyglet.font.load('AncientPix', 9)

                un1 = textsnap(uname, f, 140)

                if un1 != uname:
                    uname = textsnap(uname, f, 120) + u'…'
                txtbox.text = uname + u'的游戏'

                self.labels = batch = pyglet.graphics.Batch()
                Label(
                    u'创建游戏房间', font_size=12, x=275, y=431,
                    anchor_x='center', anchor_y='bottom',
                    color=Colors.green.heavy + (255, ),
                    shadow=(1, 207, 240, 156, 204),
                    batch=batch,
                ),
                Label(
                    u'房间名称：', font_size=9, x=30, y=400,
                    anchor_x='left', anchor_y='bottom',
                    color=Colors.green.heavy + (255, ),
                    shadow=(1, 207, 240, 156, 204),
                    batch=batch,
                )

                from gamepack import gamemodes as modes

                self.selectors = selectors = []

                def on_select():
                    btncreate.state = Button.NORMAL

                for i, (gname, gcls) in enumerate(modes.items()):
                    y, x = divmod(i, 3)
                    x, y = 30 + 170*x, 275 - 125*y
                    s = ImageSelector(
                        gcls.ui_meta.logo, selectors,
                        parent=self, x=x, y=y
                    )
                    intro = getattr(gcls.ui_meta, 'description', None)
                    intro and s.init_balloon(intro, width=480)
                    s.gametype = gname
                    s.event(on_select)
                    selectors.append(s)

                @btncreate.event
                def on_click():
                    gtype = ImageSelector.get_selected(selectors).gametype
                    f = pyglet.font.load('AncientPix', 9)
                    roomname = textsnap(txtbox.text, f, 200)
                    Executive.call('create_game', ui_message, [gtype, roomname])

                @btncancel.event  # noqa
                def on_click():
                    self.delete()

            def draw(self):
                Panel.draw(self)
                self.labels.draw()

        class ObserveGamePanel(Panel):
            def __init__(self, game_id, *a, **k):
                Panel.__init__(
                    self, width=550, height=340,
                    zindex=10000,
                    *a, **k
                )
                self.game_id = game_id
                self.x = (self.overlay.width - 550) // 2
                self.y = (self.overlay.height - 340) // 2

                self.btncancel = btncancel = Button(
                    u'取消', parent=self, x=440, y=25, width=90, height=40
                )

                self.labels = pyglet.graphics.Batch()

                Label(
                    u'旁观游戏', font_size=12, x=275, y=306,
                    anchor_x='center', anchor_y='bottom',
                    color=Colors.green.heavy + (255, ),
                    shadow=(2, 207, 240, 156, 204),
                    batch=self.labels,
                )

                @btncancel.event
                def on_click():
                    self.delete()

                Executive.call('query_gameinfo', ui_message, game_id)

            def draw(self):
                Panel.draw(self)
                self.labels.draw()

            def on_message(self, _type, *args):
                if _type == 'gameinfo':
                    gid, ul = args[0]
                    if gid != self.game_id: return

                    ul = [i for i in ul if i['state'] not in ('dropped', 'fleed')]

                    for i, p in enumerate(ul):
                        y, x = divmod(i, 5)
                        x, y = 30 + 100*x, 250 - 60*y
                        acc = Account.parse(p['account'])
                        s = Button(
                            acc.username,
                            color=Colors.orange,
                            parent=self, x=x, y=y,
                            width=95, height=30,
                        )
                        s.userid = acc.userid

                        @s.event
                        def on_click(uid=acc.userid, un=acc.username):
                            Executive.call('observe_user', ui_message, uid)
                            self.overlay.chat_box.append(u'|R已经向%s发送了旁观请求，请等待回应……|r\n' % un)
                            self.delete()

        def __init__(self, p):
            Frame.__init__(
                self, parent=p, caption=u'当前大厅内的游戏',
                x=35, y=220, width=700, height=420,
                bot_reserve=30, bg=common_res.bg_gamelist.get(),
            )

            gl = self.gamelist = ListView(parent=self, x=2, y=30, width=696, height=420-30-25)
            gl.set_columns([
                (u'No.', 100),
                (u'游戏名称', 200),
                (u'游戏类型', 200),
                (u'人数', 50),
                (u'当前状态', 80),
            ])

            self.btn_create = Button(parent=self, caption=u'创建游戏', x=690-270, y=6, width=70, height=20)
            self.btn_quickstart = Button(parent=self, caption=u'快速加入', x=690-180, y=6, width=70, height=20)
            self.btn_refresh = Button(parent=self, caption=u'刷新列表', x=690-90, y=6, width=70, height=20)

            @self.btn_create.event
            def on_click():
                self.CreateGamePanel(parent=self.overlay)

            @self.btn_quickstart.event  # noqa
            def on_click():
                Executive.call('quick_start_game', ui_message, 'THBattle')

            @self.btn_refresh.event  # noqa
            def on_click():
                Executive.call('get_hallinfo', ui_message, None)

            @self.gamelist.event
            def on_item_dblclick(li):
                # TODO:
                if li.started:
                    #Executive.call('observe_user', ui_message, li.game_id)
                    self.ObserveGamePanel(li.game_id, parent=self.overlay)
                else:
                    Executive.call('join_game', ui_message, li.game_id)

        def on_message(self, _type, *args):
            if _type == 'current_games':
                from gamepack import gamemodes as modes
                current_games = args[0]
                glist = self.gamelist
                glist.clear()
                for gi in current_games:
                    gcls = modes.get(gi['type'], None)
                    if gcls:
                        gname = gcls.ui_meta.name
                        n_persons = gcls.n_persons
                    else:
                        gname = u'未知游戏类型'
                        n_persons = 0

                    li = glist.append([
                        gi['id'],
                        gi['name'],
                        gname,
                        '%d/%d' % (
                            gi['nplayers'],
                            n_persons,
                        ),
                        [u'等待中', u'游戏中'][gi['started']]
                    ], color=(0, 0, 0, 255) if gi['started'] else (0xef, 0x75, 0x45, 0xff))
                    li.game_id = gi['id']
                    li.started = gi['started']

    class ChatBox(ChatBoxFrame):
        def __init__(self, parent):
            ChatBoxFrame.__init__(
                self, parent=parent,
                #x=35, y=20, width=700, height=180,
                x=35+255, y=20, width=700-255, height=180,
            )

    class OnlineUsers(Frame):
        def __init__(self, parent):
            Frame.__init__(
                self, parent=parent,
                caption=u'当前在线玩家',
                x=750, y=220, width=240, height=420,
                bot_reserve=10,
            )
            self.box = TextArea(
                parent=self, x=2, y=12, width=240-4, height=420-24-2-10
            )

        def on_message(self, _type, *args):
            lookup = {
                'hang': u'|c0000ffff游戏大厅|r',
                'ingame': u'|G游戏中|r',
                'inroomwait': u'|R在房间中|r',
                'ready': u'|c9f5f9fff准备状态|r',
                'observing': u'|LB观战中|r',
            }
            if _type == 'current_users':
                users = args[0]
                box = self.box
                box.text = u'\u200b'
                self.caption = u'当前在线玩家：%d' % len(users)
                self.update()
                t = u'\n'.join(
                    u'%s([|c9100ffff%s|r], %s)' % (username.replace('|', '||'), uid, lookup.get(state, state))
                    for uid, username, state in users
                )
                box.append(t)

    class NoticeBox(Frame):
        def __init__(self, parent):
            Frame.__init__(
                self, x=750, y=20, width=240, height=180,
                caption=u'花果子念报', parent=parent,
            )
            ta = self.textarea = TextArea(
                parent=self, x=2, y=10+2, width=240-4, height=180-24-2-10
            )
            ta.text = u'正在获取最新新闻……'

            def update(rst):
                if rst:
                    _, content = rst
                    try:
                        ta.text = content.decode('utf-8')
                        return
                    except Exception as e:
                        import traceback
                        traceback.print_exc(e)

                ta.text = u'|R无法显示新闻！|r'

            from settings import HALL_NOTICE_URL
            Executive.call('fetch_resource', update, HALL_NOTICE_URL)

    class StatusBox(Frame):
        def __init__(self, parent):
            Frame.__init__(
                self, x=35, y=20, width=240, height=180,
                caption=u'帐号信息', parent=parent,
            )
            self.textarea = TextArea(
                parent=self, x=2, y=10+2, width=240-4, height=180-24-2-10
            )

        def on_message(self, _type, *args):
            if _type == 'your_account':
                acc = Executive.gamemgr.account
                ta = self.textarea
                ta.text = u'\u200b'
                f = u'|c0000ffff%s：|r %s\n'
                ta.append(f % (u'UID', acc.userid))
                ta.append(f % (u'用户名', acc.username))
                ta.append(f % (u'节操', acc.other['credits']))
                ta.append(f % (u'游戏数', acc.other['games']))
                ta.append(f % (u'逃跑数', acc.other['drops']))
                ta.append(f % (u'称号', acc.other['title']))

    def __init__(self, *args, **kwargs):
        Screen.__init__(self, *args, **kwargs)
        self.bg = common_res.bg_gamehall.get()

        self.gamelist = self.GameList(self)

        chat = self.chat_box = GameHallScreen.ChatBox(parent=self)
        chat.text = u'您现在处于游戏大厅！\n'
        self.playerlist = GameHallScreen.OnlineUsers(parent=self)
        self.noticebox = GameHallScreen.NoticeBox(parent=self)
        self.statusbox = GameHallScreen.StatusBox(parent=self)

        VolumeTuner(parent=self, x=850, y=660)
        NoInviteButton(parent=self, x=654, y=660, width=80, height=35)

        b = Button(parent=self,
            x=750, y=660, width=80, height=35,
            color=Colors.orange, caption=u'卡牌查看器',
        )

        @b.event
        def on_click():
            openurl('http://thb.io')

        Executive.call('get_hallinfo', ui_message, None)

    def on_message(self, _type, *args):
        rst = handle_chat(_type, args)
        if rst:
            self.chat_box.append(rst)
            return

        elif _type == 'game_joined':
            GameScreen(args[0]).switch()

        elif _type == 'gamehall_error':
            log.error('GameHall Error: %s' % args[0])  # TODO
            mapping = {
                'cant_join_game': u'无法加入游戏！'
            }
            ConfirmBox(mapping.get(args[0], args[0]), parent=self)

        elif _type == 'observe_refused':
            uname = args[0]
            self.chat_box.append(u'|R%s 回绝了你的旁观请求|r\n' % uname)

        else:
            Screen.on_message(self, _type, *args)

    def draw(self):
        #glColor3f(.9, .9, .9)
        glColor3f(1, 1, 1)
        self.bg.blit(0, 0)
        self.draw_subcontrols()

    def on_switch(self):
        SoundManager.switch_bgm(common_res.bgm_hall)


class GameScreen(Screen):
    flash_alpha = InterpDesc('_flash_alpha')

    class InvitePanel(Panel):
        def __init__(self, game_id, *a, **k):
            Panel.__init__(
                self, width=550, height=340,
                zindex=10000,
                *a, **k
            )
            self.game_id = game_id
            self.x = (self.overlay.width - 550) // 2
            self.y = (self.overlay.height - 340) // 2

            self.btncancel = btncancel = Button(
                u'关闭', parent=self, x=440, y=25, width=90, height=40
            )

            self.labels = pyglet.graphics.Batch()

            Label(
                u'邀请游戏', font_size=12, x=275, y=306,
                anchor_x='center', anchor_y='bottom',
                color=Colors.green.heavy + (255, ),
                shadow=(2, 207, 240, 156, 204),
                batch=self.labels,
            )

            @btncancel.event
            def on_click():
                self.delete()

            Executive.call('get_hallinfo', ui_message, None)

        def draw(self):
            Panel.draw(self)
            self.labels.draw()

        def on_message(self, _type, *args):
            if _type == 'current_users':
                ul = args[0]
                ul = [(uid, uname) for uid, uname, state in ul if state in ('hang', 'observing')]

                for i, (uid, uname) in enumerate(ul):
                    y, x = divmod(i, 5)
                    x, y = 30 + 100*x, 250 - 60*y
                    s = Button(
                        uname,
                        color=Colors.orange,
                        parent=self, x=x, y=y,
                        width=95, height=30,
                    )

                    @s.event
                    def on_click(s=s, uid=uid, un=uname):
                        Executive.call('invite_user', ui_message, uid)
                        self.overlay.chat_box.append(u'|R已经邀请了%s，请等待回应……|r\n' % un)
                        s.state = Button.DISABLED

    class RoomControlPanel(Control):
        def __init__(self, parent=None):
            Control.__init__(self, parent=parent, **r2d((0, 0, 820, 720)))
            self.btn_getready = Button(
                parent=self, caption=u'准备', **r2d((360, 80, 100, 35))
            )

            self.btn_invite = Button(
                parent=self, caption=u'邀请', **r2d((360, 40, 100, 35))
            )

            self.ready = False

            l = []

            class MyPP(PlayerPortrait):
                # this class is INTENTIONALLY put here
                # to make cached avatars get gc'd
                cached_avatar = {}

            for x, y, color in parent.ui_class.portrait_location:
                l.append(MyPP('NONAME', parent=self, x=x, y=y, color=color))
            self.portraits = l

            @self.btn_getready.event
            def on_click():
                if self.ready:
                    Executive.call('cancel_ready', ui_message, [])
                    self.ready = False
                    self.btn_getready.caption = u'准备'
                    self.btn_getready.update()
                else:
                    Executive.call('get_ready', ui_message, [])
                    #self.btn_getready.state = Button.DISABLED
                    self.ready = True
                    self.btn_getready.caption = u'取消准备'
                    self.btn_getready.update()

            @self.btn_invite.event  # noqa
            def on_click():
                GameScreen.InvitePanel(self.parent.game.gameid, parent=self)

        def draw(self):
            self.draw_subcontrols()

        def on_message(self, _type, *args):
            if _type == 'player_change':
                self.update_portrait(args[0])
            elif _type == 'kick_request':
                u1, u2, count = args[0]
                self.parent.chat_box.append(
                    u'|B|R>> |c0000ffff%s|r希望|c0000ffff|B%s|r离开游戏，已有%d人请求\n' % (
                        u1[1], u2[1], count
                    )
                )
            elif _type == 'game_joined':
                self.ready = False
                self.btn_getready.caption = u'准备'
                self.btn_getready.state = Button.NORMAL

                for p in self.portraits:
                    p.account = None

        def update_portrait(self, pl):
            def players():
                return {
                    p.account.username
                    for p in self.portraits
                    if p.account
                }

            orig_players = players()
            full = True

            for i, p in enumerate(pl):
                accdata = p['account']
                acc = Account.parse(accdata) if accdata else None
                if not accdata: full = False

                port = self.portraits[i]
                port.account = acc
                port.ready = (p['state'] == 'ready')

                port.update()

            curr_players = players()

            for player in (orig_players - curr_players):
                self.parent.chat_box.append(
                    u'|B|R>> |r玩家|c0000ffff|B%s|r已离开游戏\n' % player
                )

            for player in (curr_players - orig_players):
                self.parent.chat_box.append(
                    u'|B|R>> |r玩家|c0000ffff|B%s|r已进入游戏\n' % player
                )

            if not self.ready and full and orig_players != curr_players:
                if Executive.gamemgr.account.username in curr_players:
                    from utils import notify
                    notify(u'东方符斗祭 - 满员提醒', u'房间已满员，请准备。')

    class EventsBox(Frame):
        def __init__(self, parent):
            Frame.__init__(
                self, parent=parent,
                caption=u'游戏信息',
                x=820, y=350, width=204, height=370,
                bot_reserve=0, bg=common_res.bg_eventsbox.get(),
            )
            self.box = TextArea(
                parent=self, x=2, y=2, width=200, height=370-24-2
            )

        def append(self, v):
            self.box.append(v)

        def clear(self):
            self.box.text = u'\u200b'

    class ChatBox(ChatBoxFrame):
        def __init__(self, parent):
            ChatBoxFrame.__init__(
                self, parent=parent,
                x=820, y=0, width=204, height=352,
                bg=common_res.bg_chatbox.get(),
            )

    def __init__(self, game, *args, **kwargs):
        Screen.__init__(self, *args, **kwargs)

        self.backdrop = common_res.bg_ingame.get()
        self.flash_alpha = 0.0

        self.game = game
        self.ui_class = game.ui_meta.ui_class
        self.gameui = self.ui_class(
            parent=False, game=game,
            **r2d((0, 0, 820, 720))
        )  # add when game starts

        self.events_box = GameScreen.EventsBox(parent=self)
        self.chat_box = GameScreen.ChatBox(parent=self)
        self.panel = GameScreen.RoomControlPanel(parent=self)
        self.btn_exit = Button(
            parent=self, caption=u'退出房间', zindex=1,
            **r2d((730, 680, 75, 25))
        )
        self.btn_no_invite = NoInviteButton(
            parent=self, zindex=1, **r2d((730, 650, 75, 25))
        )

        VolumeTuner(parent=self, x=690, y=670)

        @self.btn_exit.event
        def on_click():
            box = ConfirmBox(u'真的要离开吗？', buttons=ConfirmBox.Presets.OKCancel, parent=self)

            @box.event
            def on_confirm(val):
                if val:
                    Executive.call('exit_game', ui_message, [])

    def on_message(self, _type, *args):
        rst = handle_chat(_type, args)
        if rst:
            self.chat_box.append(rst)
            return

        elif _type == 'game_started':
            from utils import notify
            notify(u'东方符斗祭 - 游戏提醒', u'游戏已开始，请注意。')
            self.remove_control(self.panel)
            self.add_control(self.gameui)
            self.gameui.init()
            self.game.start()

        elif _type == 'end_game':
            self.remove_control(self.gameui)
            self.add_control(self.panel)
            g = args[0]

        elif _type == 'client_game_finished':
            g = args[0]
            g.ui_meta.ui_class.show_result(g)

        elif _type in ('game_left', 'fleed'):
            GameHallScreen().switch()

        elif _type == 'game_joined':
            # last game ended, this is the auto
            # created game
            self.game = args[0]
            self.panel.btn_getready.state = Button.NORMAL
            self.gameui = self.ui_class(
                parent=False, game=self.game,
                **r2d((0, 0, 820, 720))
            )
            SoundManager.switch_bgm(common_res.bgm_hall)
            self.backdrop = common_res.bg_ingame.get()
            self.set_color(Colors.green)
            self.events_box.clear()

        elif _type == 'game_crashed':
            ConfirmBox(
                u'游戏逻辑已经崩溃，请退出房间！\n'
                u'这是不正常的状态，你可以报告bug。\n'
                u'游戏ID：%d' % self.game.gameid,
                parent=self
            )
            from __main__ import do_crashreport
            do_crashreport()

        elif _type == 'observe_request':
            uid, uname = args[0]
            box = ConfirmBox(
                u'玩家 %s 希望旁观你的游戏，是否允许？\n'
                u'旁观玩家可以看到你的手牌。' % uname, timeout=20,
                parent=self, buttons=((u'允许', True), (u'不允许', False)), default=False
            )

            @box.event
            def on_confirm(val, uid=uid):
                Executive.call('observe_grant', ui_message, [uid, val])

        elif _type == 'observer_enter':
            obuid, obname, uname = args[0]
            self.chat_box.append(
                u'|B|R>> |r|c0000ffff%s|r[|c9100ffff%d|r]|r趴在了|c0000ffff%s|r身后\n' % (obname, obuid, uname)
            )

        elif _type == 'observer_leave':
            obuid, obname, uname = args[0]
            self.chat_box.append(
                u'|B|R>> |r|c0000ffff%s|r飘走了\n' % obname
            )

        else:
            Screen.on_message(self, _type, *args)

    def draw(self):
        glColor3f(1, 1, 1)
        self.backdrop.blit(0, 0)
        glColor4f(0, 0, 0, .5)
        glRectf(0, 0, 1000, 138)
        glColor3f(0.1922, 0.2706, 0.3882)
        glRectf(0, 138, 1000, 140)
        glColor3f(1, 1, 1)
        self.draw_subcontrols()
        fa = self.flash_alpha
        if fa:
            glColor4f(1, 1, 1, fa)
            glRectf(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT)

    def set_flash(self, duration):
        self.flash_alpha = CosineInterp(1.0, 0.0, duration)

    def set_color(self, color):
        self.events_box.set_color(color)
        self.chat_box.set_color(color)

    def on_switch(self):
        SoundManager.switch_bgm(common_res.bgm_hall)

########NEW FILE########
__FILENAME__ = shaders
# -*- coding: utf-8 -*-

from base.shader import *
from pyglet.gl import gl_info

have = gl_info.have_version

import logging

log = logging.getLogger('shaders')


def _get_gaussian_coef(radius):
    from math import erfc
    a = 3.0 / radius * 0.707106781

    f = lambda x: 0.5*erfc(-x*a)

    l = [f(0.5 + i) - f(-0.5 + i) for i in xrange(radius+1)]
    l = [i for i in l if i>0.01]
    l1 = l[1:]
    l1.reverse()
    l = l1 + l
    s = sum(l)
    l = [i/s for i in l]
    return l

try:
    r = 9
    coef = _get_gaussian_coef(r)
    src = '''
        uniform sampler2D tex;
        uniform ivec2 size;
        void main()
        {
            vec2 xy = gl_TexCoord[0].xy;
            vec4 s = vec4(0.0, 0.0, 0.0, 0.0);
            %s
            gl_FragColor = vec4(s.rgb, 1.0);
        }
    '''
    l = len(coef)//2
    fshader = FragmentShader(
        src % '\n'.join(
            's += texture2D(tex, vec2(xy.x+(%d.0/float(size[0])), xy.y)) * %f;' % (i, v)
            for i, v in zip(xrange(-l, l+1), coef)
        )
    )
    GaussianBlurHorizontal = ShaderProgram(fshader)

    fshader = FragmentShader(
        src % '\n'.join(
            's += texture2D(tex, vec2(xy.x, xy.y+(%d.0/float(size[1])))) * %f;' % (i, v)
            for i, v in zip(xrange(-l, l+1), coef)
        )
    )
    GaussianBlurVertical = ShaderProgram(fshader)

except Exception as e:
    if isinstance(e, ShaderError):
        log.error(e.infolog)
    else:
        log.exception(e)
    GaussianBlurHorizontal = GaussianBlurVertical = DummyShader

########NEW FILE########
__FILENAME__ = soundmgr
# -*- coding: utf-8 -*-

import pyglet
from pyglet.media import Player, ManagedSoundPlayer
from .base.interp import InterpDesc, LinearInterp
from user_settings import UserSettings

from utils import instantiate


@instantiate
class SoundManager(object):
    volume_factor = InterpDesc('_volume_factor')  # 音量系数

    def __init__(self):
        self.cur_bgm = None
        self.bgm_next = None
        self.bgm_switching = False
        self.bgm_player = Player()
        self.bgm_player.eos_action = Player.EOS_LOOP
        self.muted = False

    def switch_bgm(self, bgm):
        if self.muted:
            self.bgm_next = bgm
            return

        if not self.cur_bgm:
            self.instant_switch_bgm(bgm)
            return

        if bgm is self.cur_bgm:
            return

        self.volume_factor = LinearInterp(1.0, 0.0, 1.0)

        self.bgm_next = bgm
        if not self.bgm_switching:
            self.bgm_switching = True
            pyglet.clock.schedule_interval(self._set_vol, 0.1)
            pyglet.clock.schedule_once(self._bgm_fade_out_done, 1.0)

    def _bgm_fade_out_done(self, _=None):
        pyglet.clock.unschedule(self._set_vol)
        self.bgm_player.next()
        self.bgm_player.queue(self.bgm_next())
        self.volume_factor = 1.0
        self._set_vol()
        self.bgm_player.play()
        self.bgm_switching = False
        self.cur_bgm = self.bgm_next
        self.bgm_next = None

    def instant_switch_bgm(self, bgm):
        pyglet.clock.unschedule(self._bgm_fade_out_done)
        self.bgm_next = bgm
        if not self.muted:
            self._bgm_fade_out_done()

    def mute(self):
        if self.muted: return
        self.muted = True
        self.volume_factor = 0.0
        self.bgm_player.pause()
        pyglet.clock.unschedule(self._set_vol)
        pyglet.clock.unschedule(self._bgm_fade_out_done)
        self.bgm_next = self.cur_bgm
        self.cur_bgm = None

    def unmute(self):
        if not self.muted: return
        self.muted = False
        self.bgm_next and self.instant_switch_bgm(self.bgm_next)

    def play(self, snd):
        if self.muted: return
        player = ManagedSoundPlayer()
        player.volume = self.volume
        player.queue(snd)
        player.play()

    @property
    def volume(self):
        return UserSettings.volume

    @volume.setter
    def volume(self, value):
        UserSettings.volume = value

    def set_volume(self, vol):
        self.volume = vol
        self._set_vol()

    def get_volume(self):
        return self.volume * self.volume_factor

    def _set_vol(self, _=None):
        self.bgm_player.volume = self.volume_factor * self.volume

########NEW FILE########
__FILENAME__ = emergency_update
# - * - coding: utf-8 - * -

import sys
reload(sys)
sys.setdefaultencoding(sys.getfilesystemencoding())

import autoupdate
import settings

def cb(*a):
    print a

import socket
from gevent import socket as gsock

if not sys.platform.startswith('linux'):
    gsock.getaddrinfo = socket.getaddrinfo
    gsock.gethostbyname = socket.gethostbyname

import gevent
from gevent import monkey
monkey.patch_socket()

rst = gevent.spawn(autoupdate.do_update, settings.UPDATE_BASE, settings.UPDATE_URL, cb).get()

print 'Result:', rst

########NEW FILE########
__FILENAME__ = autoenv
# -*- coding: utf-8 -*-
from game_common import GameError, GameEnded, sync_primitive, InterruptActionFlow, GameException, GameObject, Action, EventHandler, InputTransaction, Game  # noqa
from gevent import Greenlet


class Game(Game, Greenlet):
    pass


def user_input(*a, **k):
    return U(*a, **k)  # noqa


def init(place, custom=None):
    global Game, user_input
    if custom:
        locals.update(custom)
    elif place == 'Server':
        from server.core import Game as G, user_input as U
    elif place == 'Client':
        from client.core import Game as G, user_input as U  # noqa
    else:
        raise Exception('Where am I?')

    Game.__bases__ = (G,)
    globals().update(locals())

########NEW FILE########
__FILENAME__ = game_common
# -*- coding: utf-8 -*-

import logging
import gevent
import random
from gevent import Timeout
from contextlib import contextmanager

log = logging.getLogger('Game')

intern('action_can_fire')
intern('action_before')
intern('action_apply')
intern('action_after')

all_gameobjects = set()
game_objects_hierarchy = set()


class GameObjectMeta(type):
    def __new__(mcls, clsname, bases, _dict):
        for k, v in _dict.items():
            if isinstance(v, (list, set)):
                _dict[k] = tuple(v)  # mutable obj not allowed

        cls = type.__new__(mcls, clsname, bases, _dict)
        all_gameobjects.add(cls)
        for b in bases:
            game_objects_hierarchy.add((b, cls))

        return cls

    def __getattribute__(cls, name):
        value = type.__getattribute__(cls, name)
        if isinstance(value, classmethod):
            try:
                rep_class = cls.rep_class(cls)
                return lambda *a, **k: value.__get__(None, rep_class)
            except:
                pass

        return value

    @staticmethod
    def _dump_gameobject_hierarchy():
        with open('/dev/shm/gomap.dot', 'w') as f:
            f.write('digraph {\nrankdir=LR;\n')
            f.write('\n'.join([
                '"%s" -> "%s";' % (a.__name__, b.__name__)
                for a, b in game_objects_hierarchy
            ]))
            f.write('}')

    # def __setattr__(cls, field, v):
    #     type.__setattr__(cls, field, v)
    #     if field in ('ui_meta', ):
    #         return
    #
    #     log.warning('SetAttr: %s.%s = %s' % (cls.__name__, field, repr(v)))


class GameObject(object):
    __metaclass__ = GameObjectMeta


class TimeLimitExceeded(Timeout):
    __metaclass__ = GameObjectMeta


class GameException(Exception):
    __metaclass__ = GameObjectMeta

    def __init__(self, msg=None, **kwargs):
        Exception.__init__(self, msg)
        self.__dict__.update(kwargs)


class GameError(GameException):
    pass


class GameEnded(GameException):
    pass


class InterruptActionFlow(GameException):
    pass


class EventHandler(GameObject):
    execute_before = tuple()
    execute_after = tuple()

    def handle(self, evt_type, data):
        raise GameError('Override handle function to implement EventHandler logics!')

    @staticmethod
    def make_list(eh_classes):
        table = {}

        before_all = []
        after_all = []
        rest = []

        eh_classes = set(eh_classes)
        for cls in eh_classes:
            if cls.execute_before == '__all__':
                before_all.append(cls())
                assert not cls.execute_after
            elif cls.execute_after == '__all__':
                after_all.append(cls())
                assert not cls.execute_before
            else:
                rest.append(cls)

        allnames = set(cls.__name__ for cls in eh_classes)

        for cls in rest:
            eh = cls()
            eh.execute_before = set(eh.execute_before) & allnames  # make it instance var
            eh.execute_after = set(eh.execute_after) & allnames
            table[cls.__name__] = eh

        for clsname in table:
            eh = table[clsname]
            for before in eh.execute_before:
                table[before].execute_after.add(clsname)

            for after in eh.execute_after:
                table[after].execute_before.add(clsname)

        l = table.values()
        l.sort(key=lambda v: v.__class__.__name__)  # must sync between server and client

        toposorted = []
        while l:
            deferred = []
            commit = []
            for eh in l:
                if not eh.execute_after:
                    for b in eh.execute_before:
                        table[b].execute_after.remove(eh.__class__.__name__)
                    commit.append(eh)
                else:
                    deferred.append(eh)

            if not commit:
                raise GameError("Can't resolve dependencies! Check for circular reference!")

            toposorted.extend(commit)
            l = deferred

        rst = before_all + toposorted + after_all

        assert len(rst) == len(eh_classes)

        return rst

    @staticmethod
    def _dump_eh_dependency_graph():
        from game.autoenv import EventHandler
        ehs = set([i for i in all_gameobjects if issubclass(i, EventHandler)])
        ehs.remove(EventHandler)
        dependencies = set()
        for eh in ehs:
            for b in eh.execute_before:
                dependencies.add((eh.__name__, b))

            for a in eh.execute_after:
                dependencies.add((a, eh.__name__))

        with open('/dev/shm/eh_relations.dot', 'w') as f:
            f.write('digraph {\nrankdir=LR;\n')
            f.write('\n'.join([
                '%s -> %s;' % (a, b)
                for a, b in dependencies
            ]))
            f.write('}')


class Action(GameObject):
    cancelled = False
    done = False

    def __new__(cls, *a, **k):
        try:
            g = Game.getgame()
            actual_cls = g.action_types.get(cls, cls)
        except:
            g = None
            actual_cls = cls

        obj = GameObject.__new__(actual_cls, *a, **k)

        if g:
            for hook in reversed(g._action_hooks):
                obj = hook(obj)

        return obj

    @staticmethod
    def rep_class(cls):
        try:
            g = Game.getgame()
            return g.action_types.get(cls, cls)
        except:
            return cls

    def __init__(self, source, target):
        self.source = source
        self.target = target

    def can_fire(self):
        '''
        Return true if the action can be fired.
        '''
        _self, rst = Game.getgame().emit_event('action_can_fire', (self, self.is_valid()))
        assert _self is self, "You can't replace action in 'action_can_fire' event!"
        return rst

    def apply_action(self):
        raise GameError('Override apply_action to implement Action logics!')

    def is_valid(self):
        '''
        Return True if this action is complete and ready to fire.
        '''
        return True

    def __repr__(self):
        return self.__class__.__name__


class AbstractPlayer(GameObject):
    def reveal(self, obj_list):
        raise GameError('Abstract')

    def __repr__(self):
        return self.__class__.__name__


class Game(GameObject):
    '''
    The Game class, all game mode derives from this.
    Provides fundamental behaviors.

    Instance variables:
        players: list(Players)
        event_handlers: list(EventHandler)

        and all game related vars, eg. tags used by [EventHandler]s and [Action]s
    '''
    # event_handlers = []
    IS_DEBUG = False

    def __init__(self):
        self.event_handlers = []
        self.action_stack = []
        self.hybrid_stack = []
        self.action_types = {}
        self.ended = False
        self._action_hooks = []
        self.winners = []
        self.turn_count = 0

    def game_start(self):
        '''
        Game logic goes here.
        GameModes should override this.
        '''
        raise GameError('Override this function to implement Game logics!')

    def game_end(self):
        self.ended = True
        try:
            winner = self.winners[0].identity
        except:
            winner = None

        log.info(u'>> Winner: %s', winner)

        raise GameEnded

    def emit_event(self, evt_type, data):
        '''
        Fire an event, all relevant event handlers will see this,
        data can be modified.
        '''
        random.random() < 0.01 and gevent.sleep(0)  # prevent buggy logic code blocking scheduling
        if isinstance(data, (list, tuple, str, unicode)):
            s = data
        else:
            s = data.__class__.__name__
        log.debug('emit_event: %s %s' % (evt_type, s))

        if evt_type in ('action_before', 'action_apply', 'action_after'):
            action_event = True
            assert isinstance(data, Action)
        else:
            action_event = False

        for evt in self.event_handlers:
            try:
                self.hybrid_stack.append(evt)
                data = evt.handle(evt_type, data)
            finally:
                assert evt is self.hybrid_stack.pop()

            if data is None:
                log.debug('EventHandler %s returned None' % evt.__class__.__name__)

            if action_event and data.cancelled:
                break

        return data

    @staticmethod
    def getgame():
        from .autoenv import Game
        return Game.getgame()

    def process_action(self, action):
        '''
        Process an action
        '''
        if self.ended: return False

        if action.done:
            log.debug('action already done %s' % action.__class__.__name__)
            return action.succeeded
        elif action.cancelled:
            log.debug('action cancelled/invalid %s' % action.__class__.__name__)
            return False

        if not action.can_fire():
            log.debug('action invalid %s' % action.__class__.__name__)
            return False

        action = self.emit_event('action_before', action)
        if action.done:
            log.debug('action already done %s' % action.__class__.__name__)
            rst = action.succeeded
        elif action.cancelled or not action.can_fire():
            log.debug('action cancelled/invalid %s' % action.__class__.__name__)
            rst = False
        else:
            log.debug('applying action %s' % action.__class__.__name__)
                #, src=%d, dst=%d' % (
                #action.__class__.__name__,
                #self.players.index(action.source) if hasattr(action, 'source') else -1,
                #self.players.index(action.target),
            #))
            action = self.emit_event('action_apply', action)
            assert not action.cancelled
            try:
                self.action_stack.append(action)
                self.hybrid_stack.append(action)
                rst = action.apply_action()
            finally:
                _a = self.action_stack.pop()
                _b = self.hybrid_stack.pop()
                assert _a is _b is action

                # If exception occurs here,
                # the action should be abandoned,
                # code below makes no sense,
                # so it's ok to ignore them.

            assert rst in [True, False], 'Action.apply_action must return boolean!'
            try:
                action.succeeded = rst
            except AttributeError:
                pass

            action = self.emit_event('action_after', action)

            rst = action.succeeded
            action.done = True

        return rst

    def get_playerid(self, p):
        return self.players.index(p)
        try:
            return self.players.index(p)
        except ValueError:
            return None

    def player_fromid(self, pid):
        return self.players[pid]
        try:
            return self.players[pid]
        except IndexError:
            return None

    def get_synctag(self):
        raise GameError('Abstract')

    @contextmanager
    def action_hook(self, hook):
        ''' Dark art, do not use '''
        try:
            self._action_hooks.append(hook)
            yield
        finally:
            expected_hook = self._action_hooks.pop()
            assert expected_hook is hook


class SyncPrimitive(GameObject):
    def __init__(self, value):
        self.value = value

    def sync(self, data):
        self.value = self.value.__class__(data)

    def __data__(self):
        return self.value


def sync_primitive(val, to):
    if not to:  # sync to nobody
        return val

    if isinstance(val, list):
        l = [SyncPrimitive(i) for i in val]
        to.reveal(l)
        return val.__class__(
            i.value for i in l
        )
    else:
        v = SyncPrimitive(val)
        to.reveal(v)
        return v.value


class Inputlet(GameObject):
    RETRY = object()
    '''
    NOTICE: Inputlet instance variable should
            not be used as side channel for infomation
            passing in game logic code.
    '''
    def __init__(self, initiator, *args, **kwargs):
        self.initiator = initiator
        self.init(*args, **kwargs)

    @classmethod
    def tag(cls):
        clsname = cls.__name__
        assert clsname.endswith('Inputlet')
        return clsname[:-8]

    def init(self):
        pass

    def parse(self, data):
        '''
        Process parsed data, return result,
        return value of this func will be the return value
        of user_input func.
        '''
        return None

    def post_process(self, actor, args):
        '''
        This method is called after self.parse succeeded,
        so game logic may have chance to transform (and validate)
        input result before input process finishes.
        '''
        return args

    def with_post_process(self, f):
        '''
        Helper method, to make this possible
        @ilet.with_post_process
        def process(args):
            ...
        '''
        self.post_process = f
        return f

    def data(self):
        '''
        Encode self, used for reconstrcting
        inputlet state from the other end.
        Will be fed into self.process() of the other end.
        '''
        return None

    def __repr__(self):
        return '<I:{}>'.format(self.tag())


class InputTransaction(object):
    def __init__(self, name, involved, **kwargs):
        self.name = name
        self.involved = involved[:]
        self.__dict__.update(kwargs)

    def __enter__(self):
        return self.begin()

    def begin(self):
        from game.autoenv import Game
        g = Game.getgame()
        g.emit_event('user_input_transaction_begin', self)
        return self

    def __exit__(self, *excinfo):
        self.end()
        return False

    def end(self):
        from game.autoenv import Game
        g = Game.getgame()
        g.emit_event('user_input_transaction_end', self)

    def notify(self, evt_name, arg):
        '''
        Event For UI
        '''
        Game.getgame().emit_event('user_input_transaction_feedback', (self, evt_name, arg))

    def __repr__(self):
        return '<T:{}>'.format(self.name)

########NEW FILE########
__FILENAME__ = actions
# -*- coding: utf-8 -*-

# All generic and cards' Actions, EventHandlers are here
from game.autoenv import Game, EventHandler, Action
from game.autoenv import sync_primitive, user_input, InputTransaction

from .inputlets import ActionInputlet, ChoosePeerCardInputlet

from utils import check, check_type, CheckFailed, BatchList, group_by

import logging
log = logging.getLogger('THBattle_Actions')

from collections import namedtuple
ActionLimitParams = namedtuple(
    'ActionLimitParams',
    'ilet actor cards players usage'
)


# ------------------------------------------
# aux functions

def ask_for_action(initiator, actors, categories, candidates, trans=None):
    # initiator: Action or EH requesting this
    # actors: players involved
    # categories: card categories, eg: ['cards', 'showncards']
    # candidates: players can be selection target, eg: g.players

    assert categories or candidates
    assert actors

    ilet = ActionInputlet(initiator, categories, candidates)

    @ilet.with_post_process
    def process(actor, rst):
        g = Game.getgame()
        usage = getattr(initiator, 'card_usage', 'none')
        try:
            check(rst)
            skills, cards, players, params = rst
            [check(not c.detached) for c in cards]
            if categories:
                if skills:
                    # check(len(skills) == 1)  # why? disabling it.
                    # will reveal in skill_wrap
                    skill = skill_wrap(actor, skills, cards, params)
                    check(skill)
                    wrapped = [skill]
                    usage = skill.usage if usage == 'launch' else usage
                else:
                    if not getattr(initiator, 'no_reveal', False):
                        g.players.reveal(cards)

                    wrapped = cards

                check(initiator.cond(wrapped))
                assert not (usage == 'none' and cards)  # should not pass check
            else:
                wrapped = []

            if candidates:
                players, valid = initiator.choose_player_target(players)
                check(valid)

            arg = ActionLimitParams(
                ilet=ilet, actor=actor, cards=wrapped,
                players=players, usage=usage
            )
            arg2, permitted = g.emit_event('action_limit', (arg, True))
            assert arg == arg2

            check(permitted)

            return skills, cards, players, params

        except CheckFailed:
            return None

    p, rst = user_input(actors, ilet, type='any', trans=trans)
    if rst:
        skills, cards, players, params = rst
        if skills:
            cards = [skill_transform(p, skills, cards, params)]

        if not cards and not players:
            return p, None

        [c.detach() for c in cards]

        return p, (cards, players)
    else:
        return None, None


def user_choose_cards(initiator, actor, categories, trans=None):
    check_type([str, Ellipsis], categories)

    _, rst = ask_for_action(initiator, [actor], categories, (), trans)
    if not rst:
        return None

    return rst[0]  # cards


def user_choose_players(initiator, actor, candidates, trans=None):
    _, rst = ask_for_action(initiator, [actor], (), candidates, trans)
    if not rst:
        return None

    return rst[1]  # players


def random_choose_card(cardlists):
    from itertools import chain
    allcards = list(chain.from_iterable(cardlists))
    if not allcards:
        return None

    g = Game.getgame()
    c = g.random.choice(allcards)
    v = sync_primitive(c.syncid, g.players)
    cl = g.deck.lookupcards([v])
    assert len(cl) == 1
    c = cl[0]
    c.detach()
    return c


def skill_wrap(actor, skills, cards, params, no_reveal=False, detach=False):
    # no_reveal: for ui
    g = Game.getgame()
    try:
        check(all(c.resides_in.owner is actor for c in cards))
        for skill_cls in skills:
            check(skill_cls in actor.skills)

            if not no_reveal and not getattr(skill_cls, 'no_reveal', False):
                g.players.exclude(actor).reveal(cards)

            card = skill_cls.wrap(cards, actor, params)
            check(card.check())

            if detach and not getattr(skill_cls, 'no_drop', False):
                for c in cards: c.detach()

            cards = [card]

        return cards[0]

    except CheckFailed:
        return None


def skill_transform(actor, skills, cards, params):
    g = Game.getgame()
    s = skill_wrap(actor, skills, cards, params, detach=True)
    if not s:
        return None

    g.deck.register_vcard(s)
    # migrate_cards(cards, actor.cards, False, True)
    # s.move_to(actor.cards)
    return s


class MigrateCardsTransaction(object):
    def __init__(self):
        self.action = Game.getgame().action_stack[-1]
        self.movements = []

    def move(self, cards, _from, to):
        self.movements.append((cards, _from, to))

    def __iter__(self):
        return iter(self.movements)

    def __enter__(self):
        return self

    def __exit__(self, *excinfo):
        self.commit()

    def commit(self):
        g = Game.getgame()
        DETACHED = migrate_cards.DETACHED
        act = self.action

        for cards, _from, to in self.movements:
            if to is not DETACHED:
                for c in cards: c.move_to(to)
            else:
                for c in cards: c.detach()

        for cards, _from, to in self.movements:
            g.emit_event('card_migration', (act, cards, _from, to))

        g.emit_event('post_card_migration', self)


def migrate_cards(cards, to, unwrap=False, detached=False, trans=None):
    if not trans:
        with MigrateCardsTransaction() as trans:
            migrate_cards(cards, to, unwrap, detached, trans)
        return

    g = Game.getgame()
    from .cards import VirtualCard
    groups = group_by(cards, lambda c: id(c) if c.is_card(VirtualCard) else id(c.resides_in))

    DETACHED = migrate_cards.DETACHED
    detaching = to is DETACHED

    for l in groups:
        if detached:
            assert not [c for c in l if not c.detached]
            cl = DETACHED
        else:
            cl = l[0].resides_in

        if l[0].is_card(VirtualCard):
            assert len(l) == 1
            trans.move(l, cl, DETACHED if unwrap else to)
            migrate_cards(
                l[0].associated_cards,
                to if unwrap or detaching else to.owner.special,
                unwrap if type(unwrap) is bool else unwrap - 1,
                detached,
                trans
            )

        else:
            trans.move(l, cl, to)


def detach_cards(cards, trans=None):
    migrate_cards(cards, migrate_cards.DETACHED, trans=trans)


class _MigrateCardsDetached(object):
    owner = None
    type = 'detached'


migrate_cards.SINGLE_LAYER = 1
migrate_cards.DETACHED = _MigrateCardsDetached()


def register_eh(cls):
    action_eventhandlers.add(cls)
    return cls
action_eventhandlers = set()

# ------------------------------------------


class GenericAction(Action): pass


class LaunchCardAction(object): pass


class UserAction(Action):  # card/character skill actions
    pass


class PlayerDeath(GenericAction):
    def apply_action(self):
        tgt = self.target
        g = Game.getgame()
        tgt.dead = True
        others = g.players.exclude(tgt)
        from .actions import DropCards
        lists = [tgt.cards, tgt.showncards, tgt.equips, tgt.fatetell, tgt.special]
        lists.extend(tgt.showncardlists)
        for cl in lists:
            if not cl: continue
            others.reveal(list(cl))
            g.process_action(DropCards(tgt, cl))
            assert not cl

        tgt.skills[:] = []
        return True


class PlayerRevive(GenericAction):
    def __init__(self, source, target, hp):
        self.source = source
        self.target = target
        self.hp = hp

    def apply_action(self):
        tgt = self.target
        assert tgt.dead

        tgt.dead = False
        tgt.maxlife = tgt.__class__.maxlife
        tgt.skills = list(tgt.__class__.skills)

        tgt.life = min(tgt.maxlife, self.hp)
        return True

    def is_valid(self):
        return self.target.dead


class TryRevive(GenericAction):
    def __init__(self, target, dmgact):
        self.source = self.target = target
        self.dmgact = dmgact
        g = Game.getgame()
        if target.dead:
            log.error('TryRevive buggy condition, __init__')
            return
        self.asklist = BatchList(
            p for p in g.players if not p.dead
        ).rotate_to(target)

    def apply_action(self):
        tgt = self.target
        if tgt.tags['in_tryrevive']:
            # nested TryRevive, just return True
            # will trigger when Eirin uses Diamond Exinwan to heal self
            return True

        if tgt.dead:
            log.error('TryRevive buggy condition, apply')
            import traceback
            traceback.print_stack()
            return False

        tgt.tags['in_tryrevive'] = True
        g = Game.getgame()
        pl = self.asklist
        from .cards import LaunchHeal
        for p in pl:
            while True:
                if g.process_action(LaunchHeal(p, tgt)):
                    if tgt.life > 0:
                        tgt.tags['in_tryrevive'] = False
                        return True
                    continue
                break
        tgt.tags['in_tryrevive'] = False
        return tgt.life > 0

    def is_valid(self):
        tgt = self.target
        return not tgt.dead and tgt.maxlife > 0


class BaseDamage(GenericAction):
    def __init__(self, source, target, amount=1):
        self.source = source
        self.target = target
        self.amount = amount

    def apply_action(self):
        tgt = self.target
        tgt.life -= self.amount
        return True


class Damage(BaseDamage):
    pass


class LifeLost(BaseDamage):
    def __init__(self, source, target, amount=1):
        self.source = None
        self.target = target
        self.amount = amount


class MaxLifeChange(GenericAction):
    def __init__(self, source, target, amount):
        self.source = source
        self.target = target
        self.amount = amount

    def apply_action(self):
        src = self.source
        tgt = self.target
        g = Game.getgame()
        tgt.maxlife += self.amount

        if tgt.life > tgt.maxlife:
            g.process_action(
                LifeLost(src, tgt, abs(tgt.life - tgt.maxlife))
            )
            assert tgt.life == tgt.maxlife

        assert tgt.maxlife or tgt.dead

        return True


# ---------------------------------------------------

class DropCards(GenericAction):
    def __init__(self, target, cards, detached=False):
        self.target = target
        self.cards = cards
        self.detached = detached

    def apply_action(self):
        g = Game.getgame()
        target = self.target
        cards = self.cards
        assert all(c.resides_in.owner in (target, None) for c in cards), 'WTF?!'
        migrate_cards(cards, g.deck.droppedcards, unwrap=True, detached=self.detached)

        return True

    def is_valid(self):
        return True


class DropUsedCard(DropCards):
    pass


class UseCard(UserAction):
    card_usage = 'use'
    # launch_action = None

    def __init__(self, target):
        self.source = self.target = target
        self.card = None
        # self.cond = __subclass__.cond

    def apply_action(self):
        g = Game.getgame()
        target = self.target

        if not self.card:  # ask if not already provided
            cards = user_choose_cards(self, target, ('cards', 'showncards'))
            if not cards or len(cards) != 1:
                self.card = None
                return False

            self.card = cards[0]

        if self.card_usage == 'launch':
            tgt = self.target
            act = self.launch_action(source=tgt, target=tgt)
            return launch_card(self, [], act)

        else:
            drop = DropUsedCard(target, cards=[self.card])
            g.process_action(drop)
            return True

    def cond(self, cl):
        raise NotImplementedError


class DropCardStage(GenericAction):
    card_usage = 'drop'

    def __init__(self, target):
        self.source = self.target = target
        self.dropn = len(target.cards) + len(target.showncards) - target.life
        self.cards = []

    def apply_action(self):
        target = self.target
        if target.dead: return False
        n = self.dropn
        if n <= 0: return True

        g = Game.getgame()
        cards = user_choose_cards(self, target, ('cards', 'showncards'))
        if cards:
            g.process_action(DropCards(target, cards=cards))
        else:
            from itertools import chain
            cards = list(chain(target.cards, target.showncards))[min(-n, 0):]
            g.players.exclude(target).reveal(cards)
            g.process_action(DropCards(target, cards=cards))

        self.cards = cards
        return True

    def cond(self, cards):
        tgt = self.target
        if not len(cards) == self.dropn:
            return False

        if not all(c.resides_in in (tgt.cards, tgt.showncards) for c in cards):
            return False

        from .cards import Skill
        if any(c.is_card(Skill) for c in cards):
            return False

        return True


class DrawCards(GenericAction):
    def __init__(self, target, amount=2):
        self.source = self.target = target
        self.amount = amount

    def apply_action(self):
        g = Game.getgame()
        target = self.target

        cards = g.deck.getcards(self.amount)

        target.reveal(cards)
        migrate_cards(cards, target.cards)
        self.cards = cards
        return True

    def is_valid(self):
        return not self.target.dead


class DrawCardStage(DrawCards):
    pass


def launch_card(lca, target_list, action):
    assert isinstance(lca, LaunchCardAction)

    g = Game.getgame()
    src = lca.source
    card = lca.card
    try:
        if not getattr(card, 'no_drop', False):
            detach_cards([card])  # emit events
        else:
            card.detach()

        _, tl = g.emit_event('choose_target', (lca, target_list))
        assert _ is lca

        if isinstance(action, Action):
            a = action
        else:
            assert issubclass(action, UserAction)

            tgt = tl[0] if tl else src
            a = action(source=src, target=tgt)
            a.target_list = tl

        a.associated_card = card
        lca.card_action = a

        _ = g.emit_event('post_choose_target', (lca, tl))
        assert _ == (lca, tl)

        return g.process_action(a)
    finally:

        if card.detached:
            # card/skill still in disputed state,
            # means no actions have done anything to the card/skill,
            # drop it
            if not getattr(card, 'no_drop', False):
                g.process_action(DropUsedCard(src, cards=[card], detached=True))
            else:
                from .cards import VirtualCard
                for c in VirtualCard.unwrap([card]):
                    if c.detached: c.attach()


class LaunchCard(GenericAction, LaunchCardAction):
    def __init__(self, source, target_list, card):
        tl, tl_valid = card.target(Game.getgame(), source, target_list)
        self.source, self.target_list, self.card, self.tl_valid = source, tl, card, tl_valid
        self.target = target_list[0] if target_list else source

    def apply_action(self):
        card = self.card
        tl = self.target_list
        if not card: return False

        action = card.associated_action
        if not action: return False

        launch_card(self, tl, action)
        return True

    def is_valid(self):
        if not self.tl_valid:
            log.debug('LaunchCard.tl_valid FALSE')
            return False

        card = self.card
        if not card:
            log.debug('LaunchCard.card FALSE')
            return False

        src = self.source

        dist = self.calc_distance(src, card)
        if not all([dist[p] <= 0 for p in self.target_list]):
            log.debug('LaunchCard: does not fulfill distance constraint')
            return False

        cls = card.associated_action

        tl = self.target_list
        target = tl[0] if tl else src
        act = cls(source=src, target=target)
        act.associated_card = card
        act.target_list = tl
        if not act.can_fire():
            log.debug('LaunchCard card_action.can_fire() FALSE')
            return False

        return True

    @classmethod
    def calc_distance(cls, source, card):
        dist = cls.calc_base_distance(source)
        g = Game.getgame()

        g.emit_event('calcdistance', (source, card, dist))
        card_dist = getattr(card, 'distance', 1000)
        for p in dist:
            dist[p] -= card_dist
        g.emit_event('post_calcdistance', (source, card, dist))

        return dist

    @classmethod
    def calc_raw_distance(cls, source, card):
        dist = cls.calc_base_distance(source)
        g = Game.getgame()

        g.emit_event('calcdistance', (source, card, dist))
        return dist

    @classmethod
    def calc_base_distance(cls, src):
        g = Game.getgame()
        pl = [p for p in g.players if not p.dead]
        loc = pl.index(src)
        n = len(pl)
        dist = {
            p: min(abs(i), n-abs(i))
            for p, i in zip(pl, xrange(-loc, -loc+n))
        }
        return dist


class ActionStageLaunchCard(LaunchCard):
    pass


@register_eh
class ShuffleHandler(EventHandler):
    def handle(self, evt_type, arg):
        if evt_type == 'action_stage_action':
            self.do_shuffle()

        elif evt_type in ('action_before', 'action_after') and isinstance(arg, ActionStage):
            self.do_shuffle()

        elif evt_type == 'user_input_start':
            trans, ilet = arg
            if isinstance(ilet, ChoosePeerCardInputlet):
                self.do_shuffle([ilet.target])

        # <!-- This causes severe problems, do not use -->
        # elif evt_type == 'card_migration':
        #     act, cl, _from, to = arg
        #     to.owner and to.type == 'cards' and self.do_shuffle([to.owner])

        return arg

    @staticmethod
    def do_shuffle(pl=None):
        from .cards import VirtualCard
        g = Game.getgame()

        for p in pl or g.players:
            if not p.cards: continue
            if any([c.is_card(VirtualCard) for c in p.cards]):
                log.warning('VirtualCard in cards of %s, not shuffling.' % repr(p))
                continue

            g.deck.shuffle(p.cards)


class ActionStage(GenericAction):
    card_usage = 'launch'

    def __init__(self, target):
        self.target = target
        self.in_user_input = False

    def apply_action(self):
        g = Game.getgame()
        target = self.target
        if target.dead: return False

        try:
            while not target.dead:
                try:
                    g.emit_event('action_stage_action', target)
                    self.in_user_input = True
                    with InputTransaction('ActionStageAction', [target]) as trans:
                        p, rst = ask_for_action(
                            self, [target], ('cards', 'showncards'), g.players, trans
                        )
                    check(p is target)
                finally:
                    self.in_user_input = False

                cards, target_list = rst
                g.players.reveal(cards)
                card = cards[0]

                if not g.process_action(ActionStageLaunchCard(target, target_list, card)):
                    # invalid input
                    log.debug('ActionStage: LaunchCard failed.')
                    break

        except CheckFailed:
            pass

        return True

    def cond(self, cl):
        from .cards import Skill
        if not cl: return False

        tgt = self.target
        if not len(cl) == 1:
            return False

        c = cl[0]
        return (
            c.is_card(Skill) or c.resides_in in (tgt.cards, tgt.showncards)
        ) and (c.associated_action)

    def choose_player_target(self, tl):
        return tl, True


class FatetellStage(GenericAction):
    def __init__(self, target):
        self.target = target

    def apply_action(self):
        g = Game.getgame()
        target = self.target
        if target.dead: return False
        ft_cards = target.fatetell
        while ft_cards:
            if target.dead: break
            card = ft_cards[-1]  # what comes last, launches first.
            g.process_action(LaunchFatetellCard(target, card))

        return True


class BaseFatetell(GenericAction):
    def __init__(self, target, cond):
        self.target = target
        self.cond = cond
        self.initiator = Game.getgame().hybrid_stack[-1]

    def apply_action(self):
        g = Game.getgame()
        card, = g.deck.getcards(1)
        g.players.reveal(card)
        self.card = card
        migrate_cards([card], g.deck.droppedcards)
        g.emit_event(self.type, self)
        return self.succeeded

    def set_card(self, card):
        self.card = card

    @property
    def succeeded(self):
        # This is necessary, for ui
        return self.cond(self.card)


class Fatetell(BaseFatetell):
    type = 'fatetell'


class TurnOverCard(BaseFatetell):
    type = 'turnover'


class FatetellAction(GenericAction): pass


class LaunchFatetellCard(FatetellAction):
    def __init__(self, target, card):
        self.source = target
        self.target = target
        self.card = card

    def apply_action(self):
        g = Game.getgame()
        target = self.target
        card = self.card
        act = card.delayed_action
        assert act
        a = act(source=target, target=target)
        a.associated_card = card
        g.process_action(a)
        a.fatetell_postprocess()
        return True


class ForEach(UserAction):
    # action_cls == __subclass__.action_cls
    include_dead = False

    def prepare(self):
        pass

    def cleanup(self):
        pass

    def __init__(self, source, target):
        self.source = source
        self.target = None

    def apply_action(self):
        tl = self.target_list
        source = self.source
        card = self.associated_card
        g = Game.getgame()

        try:
            self.prepare()
            for t in tl:
                if t.dead and not self.include_dead:
                    continue
                a = self.action_cls(source, t)
                a.associated_card = card
                a.parent_action = self
                g.process_action(a)

        finally:
            self.cleanup()

        return True


class PlayerTurn(GenericAction):
    def __init__(self, target):
        self.source = self.target = target

    def apply_action(self):
        g = Game.getgame()
        p = self.target
        p.tags['turn_count'] += 1
        g.turn_count += 1
        g.current_turn = p

        g.process_action(FatetellStage(p))
        g.process_action(DrawCardStage(p))
        g.process_action(ActionStage(p))
        g.process_action(DropCardStage(p))

        return True


class DummyAction(GenericAction):
    def __init__(self, source, target, result=True):
        self.source, self.target, self.result = \
            source, target, result

    def apply_action(self):
        return self.result


class RevealIdentity(GenericAction):
    def __init__(self, target, to):
        self.target = target
        self.to = to

    def apply_action(self):
        tgt = self.target
        self.to.reveal(tgt.identity)
        return True


class Pindian(UserAction):
    no_reveal = True
    card_usage = 'pindian'

    def __init__(self, source, target):
        self.source = source
        self.target = target

    def apply_action(self):
        src = self.source
        tgt = self.target
        g = Game.getgame()

        pl = BatchList([tgt, src])
        pindian_card = {src: None, tgt: None}

        with InputTransaction('Pindian', pl) as trans:
            for p in pl:
                cards = user_choose_cards(self, p, ('cards', 'showncards'), trans)
                if cards:
                    card = cards[0]
                else:
                    card = random_choose_card([p.cards, p.showncards])

                pindian_card[p] = card
                detach_cards([card])
                g.emit_event('pindian_card_chosen', (p, card))

        g.players.reveal([pindian_card[src], pindian_card[tgt]])
        g.emit_event('pindian_card_revealed', self)  # for ui.
        g.process_action(DropCards(src, [pindian_card[src]], detached=True))
        g.process_action(DropCards(tgt, [pindian_card[tgt]], detached=True))

        return pindian_card[src].number > pindian_card[tgt].number

    @staticmethod
    def cond(cl):
        from .cards import Skill
        return len(cl) == 1 and \
            (not cl[0].is_card(Skill)) and \
            cl[0].resides_in.type in ('cards', 'showncards')

    def is_valid(self):
        src = self.source
        tgt = self.target
        if src.dead or tgt.dead: return False
        if not (src.cards or src.showncards): return False
        if not (tgt.cards or tgt.showncards): return False
        return True


@register_eh
class DyingHandler(EventHandler):
    def handle(self, evt_type, act):
        if not evt_type == 'action_after': return act
        if not isinstance(act, BaseDamage): return act

        src = act.source
        tgt = act.target
        if tgt.dead or tgt.life > 0: return act

        g = Game.getgame()
        if g.process_action(TryRevive(tgt, dmgact=act)):
            return act

        g.process_action(PlayerDeath(src, tgt))

        return act


@register_eh
class CardUsageHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_limit':
            arg, permitted = act
            if not permitted: return act

            if arg.usage != 'drop': return act
            cards = arg.cards
            if getattr(arg.ilet.initiator, 'card_usage', None) == 'launch':
                assert len(cards) == 1
                while getattr(cards[0], 'usage', None) != 'drop':
                    assert len(cards) == 1
                    cards = cards[0].associated_cards
                cards = cards[0].associated_cards

            from .cards import VirtualCard
            return arg, not any([c.is_card(VirtualCard) for c in cards])
                    
        return act


class ShowCards(GenericAction):
    def __init__(self, target, cards):
        self.source = self.target = target
        self.cards = cards

    def apply_action(self):
        if not self.cards:
            return False

        g = Game.getgame()
        cards = self.cards
        g.players.reveal(cards)
        g.emit_event('showcards', (self.target, cards))
        # user_input(
        #     [p for p in g.players if not p.dead],
        #     ChooseOptionInputlet(self, (True,)),
        #     type='all', timeout=1,
        # )  # just a delay
        return True

########NEW FILE########
__FILENAME__ = base
# -*- coding: utf-8 -*-
# Cards and Deck classes

from collections import deque
from ..common import get_seed_for
from game.autoenv import Game, GameError, GameObject
from weakref import WeakValueDictionary
import logging
import random

log = logging.getLogger('THBattle_Cards')


class Card(GameObject):
    NOTSET = 0
    SPADE = 1
    HEART = 2
    CLUB = 3
    DIAMOND = 4

    RED = 5
    BLACK = 6

    SUIT_REV = {
        0: '?',
        1: 'SPADE', 2: 'HEART',
        3: 'CLUB', 4: 'DIAMOND',
    }

    NUM_REV = {
        0: '?', 1: 'A', 2: '2', 3: '3', 4: '4',
        5: '5', 6: '6', 7: '7', 8: '8', 9: '9',
        10: '10', 11: 'J', 12: 'Q', 13: 'K',
    }

    _color = None
    card_classes = {}
    usage = 'launch'

    def __init__(self, suit=NOTSET, number=0, resides_in=None):
        self.syncid = 0  # Deck will touch this
        self.suit = suit
        self.number = number
        self.resides_in = resides_in

    def __data__(self):
        return dict(
            type=self.__class__.__name__,
            suit=self.suit,
            number=self.number,
            syncid=self.syncid,
        )

    def __eq__(self, other):
        if not isinstance(other, Card): return False
        return self.syncid == other.syncid

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return 84065234 + self.syncid

    def sync(self, data):  # this only executes at client side, let it crash.
        if data['syncid'] != self.syncid:
            logging.error(
                'CardOOS: server: %s, %d, %d, syncid=%d; client: %s, %d, %d, syncid=%d',

                data['type'],
                self.SUIT_REV.get(data['suit'], data['suit']),
                self.NUM_REV.get(data['number'], data['number']),
                data['syncid'],

                self.__class__.__name__,
                self.SUIT_REV.get(self.suit),
                self.NUM_REV.get(self.number),
                self.syncid,
            )
            raise GameError('Card: out of sync')

        clsname = data['type']
        cls = Card.card_classes.get(clsname)
        if not cls: raise GameError('Card: unknown card class')
        self.__class__ = cls
        self.suit = data['suit']
        self.number = data['number']

    def move_to(self, resides_in):
        self.detach()
        if resides_in is not None:
            resides_in.append(self)

        self.resides_in = resides_in

    def detach(self):
        try:
            self.resides_in.remove(self)
        except (AttributeError, ValueError):
            pass

    def attach(self):
        if self not in self.resides_in:
            self.resides_in.append(self)

    @property
    def detached(self):
        return self.resides_in is not None and self not in self.resides_in

    def __repr__(self):
        return u"{name}({suit}, {num}{detached})".format(
            name=self.__class__.__name__,
            suit=self.SUIT_REV.get(self.suit, self.suit),
            num=self. NUM_REV.get(self.number, self.number),
            detached=u', detached' if self.detached else u''
        )

    def is_card(self, cls):
        return isinstance(self, cls)

    @property
    def color(self):
        if self._color is not None: return self._color
        s = self.suit
        if s in (Card.HEART, Card.DIAMOND):
            return Card.RED
        elif s in (Card.SPADE, Card.CLUB):
            return Card.BLACK
        else:
            return Card.NOTSET

    @color.setter
    def color(self, val):
        self._color = val


class VirtualCard(Card):
    __eq__ = object.__eq__
    __ne__ = object.__ne__
    __hash__ = object.__hash__

    sort_index = 0
    syncid = 0
    usage = 'none'

    def __init__(self, player):
        self.player = player
        self.suit = Card.NOTSET
        self.number = 0
        self.resides_in = player.cards
        self.action_params = {}

    def __data__(self):
        return {
            'class': self.__class__.__name__,
            'syncid': self.syncid,
            'vcard': True,
            'params': self.action_params,
        }

    def check(self):  # override this
        return False

    @classmethod
    def unwrap(cls, vcards):
        l = []
        sl = vcards[:]

        while sl:
            s = sl.pop()
            try:
                sl.extend(s.associated_cards)
            except AttributeError:
                l.append(s)

        return l

    @classmethod
    def wrap(cls, cl, player, params=None):
        vc = cls(player)
        if not cl:
            vc.associated_cards = []
            return vc

        suit = cl[0].suit if len(cl) == 1 else Card.NOTSET

        color = set([c.color for c in cl])
        color = color.pop() if len(color) == 1 else Card.NOTSET

        num = set([c.number for c in cl])
        num = num.pop() if len(num) == 1 else Card.NOTSET

        vc.suit, vc.number, vc.color = suit, num, color
        vc.associated_cards = cl[:]
        vc.action_params = params or {}
        return vc

    def sync(self, data):
        assert data['vcard']
        assert self.__class__.__name__ == data['class']
        assert self.syncid == data['syncid']
        assert self.action_params == data['params']


class CardList(GameObject, deque):
    DECKCARD = 'deckcard'
    DROPPEDCARD = 'droppedcard'
    CARDS = 'cards'
    SHOWNCARDS = 'showncards'
    EQUIPS = 'equips'
    FATETELL = 'fatetell'
    SPECIAL = 'special'
    FAITHS = 'faiths'

    def __init__(self, owner, type):
        self.owner = owner
        self.type = type
        deque.__init__(self)

    def __repr__(self):
        return "CardList(owner=%s, type=%s, len == %d)" % (self.owner, self.type, len(self))


class Deck(GameObject):
    def __init__(self, card_definition=None):
        if not card_definition:
            from .definition import card_definition

        self.cards_record = {}
        self.vcards_record = WeakValueDictionary()
        self.droppedcards = CardList(None, 'droppedcard')
        self.disputed = CardList(None, 'disputed')
        cards = CardList(None, 'deckcard')
        self.cards = cards
        cards.extend(
            cls(suit, n, cards)
            for cls, suit, n in card_definition
        )
        self.shuffle(cards)

    def getcards(self, num):
        cl = self.cards
        if len(self.cards) <= num:
            dcl = self.droppedcards

            assert all(not c.is_card(VirtualCard) for c in dcl)
            dropped = list(dcl)

            dcl.clear()
            dcl.extend(dropped[-10:])

            tmpcl = CardList(None, 'temp')
            l = [c.__class__(c.suit, c.number, cl) for c in dropped[:-10]]
            tmpcl.extend(l)
            self.shuffle(tmpcl)
            cl.extend(tmpcl)

        cl = self.cards
        rst = []
        for i in xrange(min(len(cl), num)):
            rst.append(cl[i])

        return rst

    def lookupcards(self, idlist):
        l = []
        cr = self.cards_record
        vcr = self.vcards_record
        for cid in idlist:
            c = vcr.get(cid, None) or cr.get(cid, None)
            c and l.append(c)

        return l

    def register_card(self, card):
        assert not card.syncid
        sid = Game.getgame().get_synctag()
        card.syncid = sid
        self.cards_record[sid] = card
        return sid

    def register_vcard(self, vc):
        sid = Game.getgame().get_synctag()
        vc.syncid = sid
        self.vcards_record[sid] = vc
        return sid

    def shuffle(self, cl):
        owner = cl.owner
        seed = get_seed_for(owner)

        if seed:  # cardlist owner & server
            shuffler = random.Random(seed)
            shuffler.shuffle(cl)
        else:  # others
            for c in cl:
                c.__class__ = HiddenCard
                c.suit = c.number = 0

        for c in cl:
            c.syncid = 0
            self.register_card(c)


class Skill(VirtualCard):
    category = ('skill', )

    def __init__(self, player):
        assert player is not None
        self.associated_cards = []
        VirtualCard.__init__(self, player)

    def check(self):  # override this
        return False

    # target = xxx
    # associated_action = xxx
    # instance var: associated_cards = xxx


class TreatAsSkill(Skill):
    treat_as = None  # can't be VirtualCard here
    usage = 'launch'

    @property
    def category(self):
        return ('skill', ) + self.treat_as.category

    def check(self):
        return False

    def is_card(self, cls):
        if issubclass(self.treat_as, cls): return True
        return isinstance(self, cls)

    def __getattribute__(self, name):
        try:
            return object.__getattribute__(self, name)
        except AttributeError:
            tr = object.__getattribute__(self, 'treat_as')
            return getattr(tr, name)


# card targets:
@staticmethod
def t_None(g, source, tl):
    return (None, False)


@staticmethod
def t_Self(g, source, tl):
    return ([source], True)


@staticmethod
def t_OtherOne(g, source, tl):
    tl = [t for t in tl if not t.dead]
    try:
        tl.remove(source)
    except ValueError:
        pass
    return (tl[-1:], bool(len(tl)))


@staticmethod
def t_One(g, source, tl):
    tl = [t for t in tl if not t.dead]
    return (tl[-1:], bool(len(tl)))


@staticmethod
def t_All(g, source, tl):
    l = g.players.rotate_to(source)
    del l[0]
    return ([t for t in l if not t.dead], True)


@staticmethod
def t_AllInclusive(g, source, tl):
    l = g.players.rotate_to(source)
    return ([t for t in l if not t.dead], True)


def t_OtherLessEqThanN(n):
    @staticmethod
    def _t_OtherLessEqThanN(g, source, tl):
        tl = [t for t in tl if not t.dead]
        try:
            tl.remove(source)
        except ValueError:
            pass
        return (tl[:n], bool(len(tl)))
    return _t_OtherLessEqThanN


@staticmethod
def t_OneOrNone(g, source, tl):
    tl = [t for t in tl if not t.dead]
    return (tl[-1:], True)


def t_OtherN(n):
    @staticmethod
    def _t_OtherN(g, source, tl):
        tl = [t for t in tl if not t.dead]
        try:
            tl.remove(source)
        except ValueError:
            pass
        return (tl[:n], bool(len(tl) >= n))
    return _t_OtherN


class HiddenCard(Card):  # special thing....
    associated_action = None
    target = t_None

########NEW FILE########
__FILENAME__ = basic
# -*- coding: utf-8 -*-

from game.autoenv import Game, EventHandler
from ..actions import ActionStage, ActionStageLaunchCard, Damage, DropCards
from ..actions import GenericAction, LaunchCardAction
from ..actions import PlayerTurn, UseCard, UserAction
from ..actions import register_eh, user_choose_cards, launch_card


class BasicAction(UserAction):
    pass


class BaseAttack(UserAction):

    def __init__(self, source, target, damage=1):
        self.source = source
        self.target = target
        self.damage = damage

    def apply_action(self):
        g = Game.getgame()
        source, target = self.source, self.target
        rst = g.process_action(LaunchGraze(target))
        self1, rst = g.emit_event('attack_aftergraze', (self, not rst))
        assert self1 is self
        assert rst in (False, True)
        if rst:
            g.process_action(Damage(source, target, amount=self.damage))
            return True
        else:
            return False


class Attack(BaseAttack, BasicAction):
    pass


class InevitableAttack(Attack):
    def apply_action(self):
        g = Game.getgame()
        dmg = Damage(self.source, self.target, amount=self.damage)
        g.process_action(dmg)
        return True


@register_eh
class AttackCardHandler(EventHandler):
    def handle(self, evt_type, act):
        #if evt_type == 'action_before' and isinstance(act, PlayerTurn):
        if evt_type == 'action_before' and isinstance(act, ActionStage):
            act.target.tags['attack_num'] = 1

        elif evt_type == 'action_apply':
            if isinstance(act, ActionStageLaunchCard):
                from .definition import AttackCard
                if act.card.is_card(AttackCard):
                    act.source.tags['attack_num'] -= 1

        elif evt_type == 'calcdistance':
            src, card, dist = act
            from .definition import AttackCard
            if card.is_card(AttackCard):
                from .equipment import WeaponSkill

                l = [s.range - 1 for s in src.skills if issubclass(s, WeaponSkill)]
                if not l: return act
                l = min(l)

                for p in dist:
                    dist[p] -= l

        elif evt_type == 'action_can_fire' and isinstance(act[0], ActionStageLaunchCard):
            lc, rst = act
            from .definition import AttackCard
            if lc.card.is_card(AttackCard):
                src = lc.source
                if src.tags['freeattack'] >= src.tags['turn_count']:
                    return act

                if src.tags['attack_num'] <= 0:
                    return (lc, False)

        return act

    @staticmethod
    def set_freeattack(player):
        player.tags['freeattack'] = player.tags['turn_count']

    @staticmethod
    def cancel_freeattack(player):
        player.tags['freeattack'] = 0

    @staticmethod
    def is_freeattack(player):
        return player.tags['freeattack'] >= player.tags['turn_count']


class Heal(BasicAction):

    def __init__(self, source, target, amount=1):
        self.source = source
        self.target = target
        self.amount = amount

    def apply_action(self):
        target = self.target
        if target.life < target.maxlife:
            target.life = min(target.life + self.amount, target.maxlife)
            return True
        else:
            return False

    def is_valid(self):
        tgt = self.target
        return not tgt.dead and tgt.life < tgt.maxlife


class GrazeAction(BasicAction):

    def apply_action(self):
        return True


class BaseUseGraze(UseCard):
    def cond(self, cl):
        from .. import cards
        t = self.target
        return (
            len(cl) == 1 and
            cl[0].is_card(cards.GrazeCard) and
            (cl[0].is_card(cards.VirtualCard) or cl[0].resides_in.owner is t)
        )


class UseGraze(BaseUseGraze):
    pass


class LaunchGraze(BaseUseGraze, LaunchCardAction):
    card_usage = 'launch'
    launch_action = GrazeAction


class UseAttack(UseCard):
    def cond(self, cl):
        from .. import cards
        t = self.target
        return (
            len(cl) == 1 and
            cl[0].is_card(cards.AttackCard) and
            (cl[0].is_card(cards.VirtualCard) or cl[0].resides_in.owner is t)
        )


class LaunchHeal(UserAction, LaunchCardAction):
    card_usage = 'launch'

    def apply_action(self):
        src = self.source
        cards = user_choose_cards(self, src, ('cards', 'showncards'))
        if not cards:
            self.card = None
            return False
        else:
            self.card = cards[0]
            tgt = self.target
            launch_card(self, [tgt], Heal)
            return True

    def cond(self, cl):
        from .. import cards
        t = self.source
        return (
            len(cl) == 1 and
            cl[0].is_card(cards.HealCard) and
            (cl[0].is_card(cards.VirtualCard) or cl[0].resides_in.owner is t)
        )


class Wine(BasicAction):
    def apply_action(self):
        self.target.tags['wine'] = True
        return True


class SoberUp(GenericAction):
    def apply_action(self):
        self.target.tags['wine'] = False
        return True


class WineRevive(GenericAction):
    def __init__(self, act):
        self.act = act
        self.source = act.target
        self.target = act.target

    def apply_action(self):
        self.act.amount -= 1
        tgt = self.target
        Game.getgame().process_action(SoberUp(tgt, tgt))
        return True


@register_eh
class WineHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, BaseAttack):
            pact = getattr(act, 'parent_action', act)
            if getattr(pact, 'in_wine', False):
                act.damage += 1

        elif evt_type == 'post_choose_target':
            act, tl = arg = act

            from ..cards import AttackCard
            if act.card.is_card(AttackCard):
                src = act.source
                if src.tags['wine']:
                    Game.getgame().process_action(SoberUp(src, src))
                    act.card_action.in_wine = True

            return arg

        elif evt_type == 'action_apply' and isinstance(act, PlayerTurn):
            src = act.target
            if src.tags['wine']:
                Game.getgame().process_action(SoberUp(src, src))

        elif evt_type == 'action_apply' and isinstance(act, Damage):
            if act.cancelled: return act
            if act.amount < 1: return act
            tgt = act.target
            if act.amount >= tgt.life and tgt.tags['wine']:
                g = Game.getgame()
                g.process_action(WineRevive(act))

        return act


class Exinwan(BasicAction):
    # 恶心丸
    def apply_action(self):
        return True


class ExinwanEffect(GenericAction):
    # 恶心丸
    card_usage = 'drop'

    def apply_action(self):
        g = Game.getgame()
        target = self.target
        if target.dead:
            return False

        cards = user_choose_cards(self, target, ('cards', 'showncards', 'equips'))

        if cards:
            g.process_action(DropCards(target=target, cards=cards))
        else:
            g.process_action(Damage(source=None, target=target))

        return True

    def cond(self, cards):
        if len(cards) != 2: return False
        from .base import Skill
        if any(isinstance(c, Skill) for c in cards): return False
        return True


@register_eh
class ExinwanHandler(EventHandler):
    # 恶心丸
    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, DropCards):
            for c in act.cards:
                c.exinwan_lastin = c.resides_in.type
            return act

        elif evt_type == 'action_after' and isinstance(act, DropCards):
            from .definition import ExinwanCard
            from .base import VirtualCard
            typelist = ('cards', 'showncards')
            cards = [c for c in act.cards if getattr(c, 'exinwan_lastin', None) in typelist]
            cards = VirtualCard.unwrap(cards)
            cards = [c for c in cards if c.is_card(ExinwanCard)]
            if cards:
                g = Game.getgame()
                pact = g.action_stack[-1]

                target = pact.source

                for i in xrange(len(cards)):
                    g.process_action(ExinwanEffect(target, target))

        return act

########NEW FILE########
__FILENAME__ = definition
# -*- coding: utf-8 -*-
# Cards and Deck definition

#from .base import *
from .base import Card, t_None, t_One, t_Self, t_OtherOne, t_All, t_AllInclusive, t_OtherLessEqThanN

from game import GameObjectMeta


def card_meta(clsname, bases, _dict):
    for a in ('associated_action', 'target', 'category'):
        assert a in _dict

    cls = GameObjectMeta(clsname, (Card,), _dict)
    Card.card_classes[clsname] = cls
    return cls

__metaclass__ = card_meta

# ==================================================


class DummyCard:
    associated_action = None
    target = t_None
    category = ('dummy', )

    def __init__(self, suit=Card.NOTSET, number=0, resides_in=None, **kwargs):
        Card.__init__(self, suit, number, resides_in)
        self.__dict__.update(kwargs)


from . import basic


class AttackCard:
    associated_action = basic.Attack
    target = t_OtherOne
    category = ('basic', )
    distance = 1


class GrazeCard:
    associated_action = None
    target = t_None
    category = ('basic', )


class HealCard:
    associated_action = basic.Heal
    target = t_Self
    category = ('basic', )


class WineCard:
    associated_action = basic.Wine
    target = t_Self
    category = ('basic', )


class ExinwanCard:
    associated_action = basic.Exinwan
    target = t_Self
    category = ('basic', )

# --------------------------------------------------

from . import spellcard


class DemolitionCard:
    associated_action = spellcard.Demolition
    target = t_OtherOne
    category = ('spellcard', 'instant_spellcard')


class RejectCard:
    associated_action = None
    target = t_None
    category = ('spellcard', 'instant_spellcard')


class SealingArrayCard:
    associated_action = spellcard.DelayedLaunchCard
    target = t_OtherOne
    category = ('spellcard', 'delayed_spellcard')
    delayed_action = spellcard.SealingArray
    no_drop = True


class FrozenFrogCard:
    associated_action = spellcard.DelayedLaunchCard
    target = t_OtherOne
    category = ('spellcard', 'delayed_spellcard')
    distance = 1
    delayed_action = spellcard.FrozenFrog
    no_drop = True


class NazrinRodCard:
    associated_action = spellcard.NazrinRod
    target = t_Self
    category = ('spellcard', 'instant_spellcard')


class SinsackCard:
    associated_action = spellcard.DelayedLaunchCard
    target = t_Self
    category = ('spellcard', 'delayed_spellcard')
    delayed_action = spellcard.Sinsack
    no_drop = True


class YukariDimensionCard:
    associated_action = spellcard.YukariDimension
    target = t_OtherOne
    category = ('spellcard', 'instant_spellcard')
    distance = 1


class DuelCard:
    associated_action = spellcard.Duel
    target = t_OtherOne
    category = ('spellcard', 'instant_spellcard')


class MapCannonCard:
    associated_action = spellcard.MapCannon
    target = t_All
    category = ('spellcard', 'instant_spellcard')


class SinsackCarnivalCard:
    associated_action = spellcard.SinsackCarnival
    target = t_All
    category = ('spellcard', 'instant_spellcard')


class FeastCard:
    associated_action = spellcard.Feast
    target = t_AllInclusive
    category = ('spellcard', 'instant_spellcard')


class HarvestCard:
    associated_action = spellcard.Harvest
    target = t_AllInclusive
    category = ('spellcard', 'instant_spellcard')


class DollControlCard:
    associated_action = spellcard.DollControl

    def t_DollControl(g, source, tl):
        if not tl: return ([], False)
        tl = tl[:]
        while tl and source is tl[0]:
            del tl[0]
        return (tl[:2], len(tl) >= 2)

    target = staticmethod(t_DollControl)
    category = ('spellcard', 'instant_spellcard')
    del t_DollControl


class DonationBoxCard:
    associated_action = spellcard.DonationBox
    target = t_OtherLessEqThanN(2)
    category = ('spellcard', 'instant_spellcard')


# --------------------------------------------------

from . import equipment


class MomijiShieldCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'shield')
    equipment_skill = equipment.MomijiShieldSkill
    equipment_category = 'shield'


class OpticalCloakCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'shield')
    equipment_skill = equipment.OpticalCloakSkill
    equipment_category = 'shield'


class GreenUFOCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'greenufo')
    equipment_skill = equipment.GreenUFOSkill
    equipment_category = 'greenufo'


class RedUFOCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'redufo')
    equipment_skill = equipment.RedUFOSkill
    equipment_category = 'redufo'


class HakuroukenCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'weapon')
    equipment_skill = equipment.HakuroukenSkill
    equipment_category = 'weapon'


class ElementalReactorCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'weapon')
    equipment_skill = equipment.ElementalReactorSkill
    equipment_category = 'weapon'


class UmbrellaCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'shield')
    equipment_skill = equipment.UmbrellaSkill
    equipment_category = 'shield'


class RoukankenCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'weapon')
    equipment_skill = equipment.RoukankenSkill
    equipment_category = 'weapon'


class GungnirCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'weapon')
    equipment_skill = equipment.GungnirSkill
    equipment_category = 'weapon'


class LaevateinCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'weapon')
    equipment_skill = equipment.LaevateinSkill
    equipment_category = 'weapon'


class NenshaPhoneCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'weapon')
    equipment_skill = equipment.NenshaPhoneSkill
    equipment_category = 'weapon'


class RepentanceStickCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'weapon')
    equipment_skill = equipment.RepentanceStickSkill
    equipment_category = 'weapon'


class MaidenCostumeCard:
    associated_action = equipment.WearEquipmentAction
    target = t_One
    category = ('equipment', 'shield')
    equipment_skill = equipment.MaidenCostumeSkill
    equipment_category = 'shield'
    distance = 2


class IbukiGourdCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'redufo')
    equipment_skill = equipment.IbukiGourdSkill
    equipment_category = 'redufo'


class HouraiJewelCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'weapon')
    equipment_skill = equipment.HouraiJewelSkill
    equipment_category = 'weapon'


class SaigyouBranchCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'shield')
    equipment_skill = equipment.SaigyouBranchSkill
    equipment_category = 'shield'


class AyaRoundfanCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'weapon')
    equipment_skill = equipment.AyaRoundfanSkill
    equipment_category = 'weapon'


class ScarletRhapsodyCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'weapon')
    equipment_skill = equipment.ScarletRhapsodySkill
    equipment_category = 'weapon'


class DeathSickleCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'weapon')
    equipment_skill = equipment.DeathSickleSkill
    equipment_category = 'weapon'


class KeystoneCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'greenufo')
    equipment_skill = equipment.KeystoneSkill
    equipment_category = 'greenufo'


class WitchBroomCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'redufo')
    equipment_skill = equipment.WitchBroomSkill
    equipment_category = 'redufo'


class YinYangOrbCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'accessories')
    equipment_skill = equipment.YinYangOrbSkill
    equipment_category = 'accessories'


class SuwakoHatCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'accessories')
    equipment_skill = equipment.SuwakoHatSkill
    equipment_category = 'accessories'


class YoumuPhantomCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'accessories')
    equipment_skill = equipment.YoumuPhantomSkill
    equipment_category = 'accessories'


class IceWingCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'accessories')
    equipment_skill = equipment.IceWingSkill
    equipment_category = 'accessories'


class GrimoireCard:
    associated_action = equipment.WearEquipmentAction
    target = t_Self
    category = ('equipment', 'weapon')
    equipment_skill = equipment.GrimoireSkill
    equipment_category = 'weapon'

# ==================================================

__metaclass__ = type

SPADE, HEART, CLUB, DIAMOND = Card.SPADE, Card.HEART, Card.CLUB, Card.DIAMOND
A, J, Q, K = 1, 11, 12, 13

card_definition = [
    # ======= Spade =======
    (SinsackCard, SPADE, A),
    (DeathSickleCard, SPADE, 2),
    (RepentanceStickCard, SPADE, 3),
    (RoukankenCard, SPADE, 4),
    (HakuroukenCard, SPADE, 5),
    (GungnirCard, SPADE, 6),
    (SinsackCarnivalCard, SPADE, 7),
    (SinsackCarnivalCard, SPADE, 8),
    (SealingArrayCard, SPADE, 9),
    (SealingArrayCard, SPADE, 10),
    (AttackCard, SPADE, J),
    (AttackCard, SPADE, Q),
    (KeystoneCard, SPADE, K),

    (DuelCard, SPADE, A),
    (RejectCard, SPADE, 2),
    (AttackCard, SPADE, 3),
    (AttackCard, SPADE, 4),
    (YukariDimensionCard, SPADE, 5),
    (YukariDimensionCard, SPADE, 6),
    (AttackCard, SPADE, 7),
    (AttackCard, SPADE, 8),
    (WineCard, SPADE, 9),
    (AttackCard, SPADE, 10),
    (AttackCard, SPADE, J),
    (RejectCard, SPADE, Q),
    (WitchBroomCard, SPADE, K),

    (DonationBoxCard, SPADE, A),
    (OpticalCloakCard, SPADE, 2),
    (DemolitionCard, SPADE, 3),
    (DemolitionCard, SPADE, 4),
    (AttackCard, SPADE, 8),
    (IceWingCard, SPADE, 9),
    (AttackCard, SPADE, 10),
    (DonationBoxCard, SPADE, J),
    (AttackCard, SPADE, Q),
    (YinYangOrbCard, SPADE, K),

    # ======= Heart =======
    (FeastCard, HEART, A),
    (MaidenCostumeCard, HEART, 2),
    (HarvestCard, HEART, 3),
    (HarvestCard, HEART, 4),
    (AyaRoundfanCard, HEART, 5),
    (AttackCard, HEART, 6),
    (NazrinRodCard, HEART, 7),
    (NazrinRodCard, HEART, 8),
    (NazrinRodCard, HEART, 9),
    (SealingArrayCard, HEART, 10),
    (AttackCard, HEART, J),
    (DemolitionCard, HEART, Q),
    (GreenUFOCard, HEART, K),

    (MapCannonCard, HEART, A),
    (RejectCard, HEART, 2),
    (HealCard, HEART, 3),
    (HealCard, HEART, 4),
    (HealCard, HEART, 5),
    (HealCard, HEART, 6),
    (HealCard, HEART, 7),
    (HealCard, HEART, 8),
    (HealCard, HEART, 9),
    (AttackCard, HEART, 10),
    (AttackCard, HEART, J),
    (AttackCard, HEART, Q),
    (RejectCard, HEART, K),

    (SinsackCard, HEART, A),
    (GrazeCard, HEART, 2),
    (GrazeCard, HEART, 3),
    (GrazeCard, HEART, 4),
    (HealCard, HEART, 8),
    (GrazeCard, HEART, 9),
    (GrazeCard, HEART, 10),
    (GrazeCard, HEART, J),
    (GrazeCard, HEART, Q),
    (YinYangOrbCard, HEART, K),

    # ======= Club =======
    (SuwakoHatCard, CLUB, A),
    (MomijiShieldCard, CLUB, 2),
    (AttackCard, CLUB, 3),
    (DemolitionCard, CLUB, 4),
    (AttackCard, CLUB, 5),
    (AttackCard, CLUB, 6),
    (SinsackCarnivalCard, CLUB, 7),
    (AttackCard, CLUB, 8),
    (WineCard, CLUB, 9),
    (AttackCard, CLUB, 10),
    (AttackCard, CLUB, J),
    (ExinwanCard, CLUB, Q),
    (GreenUFOCard, CLUB, K),

    (DuelCard, CLUB, A),
    (AttackCard, CLUB, 2),
    (AttackCard, CLUB, 3),
    (AttackCard, CLUB, 4),
    (FrozenFrogCard, CLUB, 5),
    (FrozenFrogCard, CLUB, 6),
    (AttackCard, CLUB, 7),
    (DemolitionCard, CLUB, 8),
    (WineCard, CLUB, 9),
    (AttackCard, CLUB, 10),
    (AttackCard, CLUB, J),
    (RejectCard, CLUB, Q),
    (RedUFOCard, CLUB, K),

    (YoumuPhantomCard, CLUB, A),
    (UmbrellaCard, CLUB, 2),
    (AttackCard, CLUB, 3),
    (AttackCard, CLUB, 4),
    (AttackCard, CLUB, 8),
    (IbukiGourdCard, CLUB, 9),
    (AttackCard, CLUB, 10),
    (AttackCard, CLUB, J),
    (SaigyouBranchCard, CLUB, Q),
    (DollControlCard, CLUB, K),

    # ======= Diamond =======
    (ElementalReactorCard, DIAMOND, A),
    (GrazeCard, DIAMOND, 2),
    (GrazeCard, DIAMOND, 3),
    (GrazeCard, DIAMOND, 4),
    (ScarletRhapsodyCard, DIAMOND, 5),
    (GrazeCard, DIAMOND, 6),
    (GrazeCard, DIAMOND, 7),
    (GrazeCard, DIAMOND, 8),
    (GrazeCard, DIAMOND, 9),
    (NenshaPhoneCard, DIAMOND, 10),
    (LaevateinCard, DIAMOND, J),
    (GrimoireCard, DIAMOND, Q),
    (GreenUFOCard, DIAMOND, K),

    (DuelCard, DIAMOND, A),
    (GrazeCard, DIAMOND, 2),
    (HealCard, DIAMOND, 3),
    (HealCard, DIAMOND, 4),
    (YukariDimensionCard, DIAMOND, 5),
    (YukariDimensionCard, DIAMOND, 6),
    (AttackCard, DIAMOND, 7),
    (AttackCard, DIAMOND, 8),
    (WineCard, DIAMOND, 9),
    (AttackCard, DIAMOND, 10),
    (ExinwanCard, DIAMOND, J),
    (RejectCard, DIAMOND, Q),
    (RedUFOCard, DIAMOND, K),

    (HouraiJewelCard, DIAMOND, A),
    (GrazeCard, DIAMOND, 2),
    (AttackCard, DIAMOND, 3),
    (AttackCard, DIAMOND, 4),
    (GrazeCard, DIAMOND, 8),
    (WineCard, DIAMOND, 9),
    (GrazeCard, DIAMOND, 10),
    (GrazeCard, DIAMOND, J),
    (HealCard, DIAMOND, Q),
    (DollControlCard, DIAMOND, K),
]

# ANCHOR(card)
# card_definition = [
# ] * 1000

del A, J, Q, K

########NEW FILE########
__FILENAME__ = equipment
# -*- coding: utf-8 -*-

from game.autoenv import Game, EventHandler, user_input, GameError
from ..actions import UserAction, DropCards, FatetellAction, Fatetell, GenericAction, LaunchCard, ForEach, Damage, PlayerTurn, DrawCards, DummyAction, DropCardStage, MaxLifeChange
from ..actions import migrate_cards, register_eh, user_choose_cards, random_choose_card, MigrateCardsTransaction
from .base import Card, VirtualCard, Skill, TreatAsSkill, t_None, t_OtherOne, t_OtherLessEqThanN
from ..inputlets import ChooseOptionInputlet, ChoosePeerCardInputlet

from . import basic, spellcard

from utils import check, CheckFailed, classmix


class WearEquipmentAction(UserAction):
    def apply_action(self):
        g = Game.getgame()
        card = self.associated_card
        target = self.target
        equips = target.equips
        g = Game.getgame()
        
        with MigrateCardsTransaction() as trans:
            for oc in equips:
                if oc.equipment_category == card.equipment_category:
                    migrate_cards([oc], g.deck.droppedcards, trans=trans)
                    break
            migrate_cards([card], target.equips, trans)

        return True


@register_eh
class EquipmentTransferHandler(EventHandler):
    def handle(self, evt, args):
        if evt == 'card_migration':
            act, cards, _from, to = args
            if _from is not None and _from.type == 'equips':
                for c in cards:
                    try:
                        _from.owner.skills.remove(c.equipment_skill)
                    except ValueError:
                        pass

            if to is not None and to.type == 'equips':
                for c in cards:
                    to.owner.skills.append(c.equipment_skill)

        return args


class ShieldSkill(Skill):
    associated_action = None
    target = t_None


class OpticalCloakSkill(TreatAsSkill, ShieldSkill):  # just a tag
    treat_as = Card.card_classes['GrazeCard']

    def check(self):
        return False


class OpticalCloak(FatetellAction):
    # 光学迷彩
    def apply_action(self):
        g = Game.getgame()
        target = self.target
        ft = Fatetell(target, lambda card: card.suit in (Card.HEART, Card.DIAMOND))
        g.process_action(ft)
        self.fatetell_card = ft.card
        return bool(ft.succeeded)


@register_eh
class OpticalCloakHandler(EventHandler):
    def handle(self, evt_type, act):
        from .basic import BaseUseGraze
        if evt_type == 'action_apply' and isinstance(act, BaseUseGraze):
            tgt = act.target
            if not tgt.has_skill(OpticalCloakSkill): return act
            if act.card: return act
           
            if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
                return act
            
            g = Game.getgame()
            if g.process_action(OpticalCloak(tgt, tgt)):
                act.card = OpticalCloakSkill(tgt)
        
        return act


class MomijiShieldSkill(ShieldSkill):
    pass


class MomijiShield(GenericAction):
    def __init__(self, act):
        self.action = act
        self.source = self.target = act.target

    def apply_action(self):
        self.action.cancelled = True
        return True


@register_eh
class MomijiShieldHandler(EventHandler):
    execute_before = ('HouraiJewelHandler', )

    def handle(self, evt_type, act):
        from .basic import BaseAttack
        if not (evt_type == 'action_before' and isinstance(act, BaseAttack)): return act
        tgt = act.target
        if not tgt.has_skill(MomijiShieldSkill): return act
        if not act.associated_card.color == Card.BLACK: return act
        g = Game.getgame()
        g.process_action(MomijiShield(act))

        return act


class UFOSkill(Skill):
    associated_action = None
    target = t_None


class GreenUFOSkill(UFOSkill):
    increment = 1


class RedUFOSkill(UFOSkill):
    increment = 1


@register_eh
class UFODistanceHandler(EventHandler):
    def handle(self, evt_type, arg):
        if not evt_type == 'calcdistance': return arg

        src, card, dist = arg
        for s in src.skills:
            if not issubclass(s, RedUFOSkill): continue
            incr = s.increment
            incr = incr(src) if callable(incr) else incr
            for p in dist:
                dist[p] -= incr

        for p in dist:
            for s in p.skills:
                if not issubclass(s, GreenUFOSkill): continue
                incr = s.increment
                dist[p] += incr(p) if callable(incr) else incr

        return arg


class WeaponSkill(Skill):
    range = 1


class RoukankenSkill(WeaponSkill):
    associated_action = None
    target = t_None
    range = 3


class Roukanken(GenericAction):
    def __init__(self, act):
        assert isinstance(act, basic.BaseAttack)
        self.action = act
        self.source = act.source
        self.target = act.target

    def apply_action(self):
        act = self.action
        target = act.target
        skills = target.skills
        for e in target.equips:
            s = e.equipment_skill
            if issubclass(s, ShieldSkill):
                skills.remove(s)

        try:
            rst = Game.getgame().process_action(act)
        finally:
            for card in target.equips:
                s = card.equipment_skill
                if issubclass(s, ShieldSkill):
                    target.has_skill(s) or skills.append(s)

        return rst


@register_eh
class RoukankenEffectHandler(EventHandler):
    execute_before = (
        'MomijiShieldHandler',
        'OpticalCloakHandler',
        'SaigyouBranchHandler',
        'HouraiJewelHandler',
        'SpearTheGungnirHandler',
        'HakuroukenHandler',
    )

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, basic.BaseAttack):
            if hasattr(act, 'hakurouken_tag'):
                return act
            act.hakurouken_tag = True
            source = act.source
            if source.has_skill(RoukankenSkill):
                act = Roukanken(act)
                return act
        return act


class NenshaPhoneSkill(WeaponSkill):
    associated_action = None
    target = t_None
    range = 4


class NenshaPhone(GenericAction):
    def apply_action(self):
        tgt = self.target

        cards = list(tgt.cards)[:2]
        g = Game.getgame()
        g.players.exclude(tgt).reveal(cards)
        migrate_cards(cards, tgt.showncards)

        return True


@register_eh
class NenshaPhoneHandler(EventHandler):
    def handle(self, evt_type, act):
        from .basic import BaseAttack
        if not evt_type == 'action_after': return act
        if not isinstance(act, BaseAttack): return act
        if not act.succeeded: return act
        src = act.source
        tgt = act.target
        if tgt.dead: return act
        if not tgt.cards: return act
        if not src.has_skill(NenshaPhoneSkill): return act
        if not user_input([src], ChooseOptionInputlet(self, (False, True))): return act
        g = Game.getgame()
        g.process_action(NenshaPhone(src, tgt))
        return act


class ElementalReactorSkill(WeaponSkill):
    associated_action = None
    target = t_None
    range = 1


@register_eh
class ElementalReactorHandler(EventHandler):
    execute_after = ('EquipmentTransferHandler', )

    def handle(self, evt_type, arg):
        if evt_type == 'action_stage_action':
            tgt = arg
            if not tgt.has_skill(ElementalReactorSkill): return arg
            basic.AttackCardHandler.set_freeattack(tgt)

        elif evt_type == 'card_migration':
            act, cards, _from, to = arg

            from .definition import ElementalReactorCard

            if _from is not None and _from.type == 'equips':
                src = _from.owner
                for c in cards:
                    if c.is_card(ElementalReactorCard):
                        basic.AttackCardHandler.cancel_freeattack(src)

        return arg


class GungnirSkill(TreatAsSkill, WeaponSkill):
    target = t_OtherOne
    range = 3
    treat_as = Card.card_classes['AttackCard']  # arghhhhh, nasty circular references!

    def check(self):
        cl = self.associated_cards
        cat = ('cards', 'showncards')
        if not all(c.resides_in.type in cat for c in cl): return False
        return len(cl) == 2


class ScarletRhapsody(ForEach):
    action_cls = basic.Attack


class ScarletRhapsodySkill(WeaponSkill):
    range = 4
    associated_action = ScarletRhapsody
    target = t_OtherLessEqThanN(3)
    usage = 'launch'

    def check(self):
        try:
            cl = self.associated_cards
            check(len(cl) == 1)
            card = cl[0]
            from .definition import AttackCard
            check(card.is_card(AttackCard))
            tgt = card.resides_in.owner

            raw = VirtualCard.unwrap([card])
            check(len(raw) == 1)
            check(raw[0].resides_in in (tgt.cards, tgt.showncards))
            cards = set(tgt.cards) | set(tgt.showncards)
            check(cards <= set(raw))

            return True
        except CheckFailed:
            return False

    def is_card(self, cls):
        from ..cards import AttackCard
        if issubclass(AttackCard, cls): return True
        return isinstance(self, cls)

    @property
    def distance(self):
        try:
            return max(1, self.associated_cards[0].distance)
        except:
            return 1


class RepentanceStickSkill(WeaponSkill):
    range = 2
    associated_action = None
    target = t_None


class RepentanceStick(GenericAction):
    def apply_action(self):
        src, tgt = self.source, self.target
        g = Game.getgame()

        catnames = ['cards', 'showncards', 'equips', 'fatetell']
        cats = [getattr(tgt, i) for i in catnames]

        l = []
        for i in xrange(2):
            if not (tgt.cards or tgt.showncards or tgt.equips or tgt.fatetell):
                break

            card = user_input(
                [src], ChoosePeerCardInputlet(self, tgt, catnames)
            )

            if not card:
                card = random_choose_card(cats)
            if card:
                l.append(card)
                g.players.exclude(tgt).reveal(card)
                g.process_action(DropCards(target=tgt, cards=[card]))
        self.cards = l
        return True


@register_eh
class RepentanceStickHandler(EventHandler):
    execute_before = ('WineHandler', )

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, Damage):
            if act.cancelled: return act
            src, tgt = act.source, act.target
            if src and src.has_skill(RepentanceStickSkill):
                g = Game.getgame()
                pa = g.action_stack[-1]
                if not isinstance(pa, basic.BaseAttack): return act
                if not (tgt.cards or tgt.showncards or tgt.equips or tgt.fatetell):
                    return act

                if not user_input([src], ChooseOptionInputlet(self, (False, True))):
                    return act

                g.process_action(RepentanceStick(src, tgt))
                act.cancelled = True

        return act


class MaidenCostumeSkill(ShieldSkill):
    pass


class MaidenCostumeEffect(spellcard.NonResponsiveInstantSpellCardAction):
    def apply_action(self):
        g = Game.getgame()
        g.process_action(Damage(source=self.source, target=self.target))
        return True


@register_eh
class MaidenCostumeHandler(EventHandler):
    execute_before = ('RejectHandler', )

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, spellcard.SinsackCarnivalEffect):
            target = act.target
            if not act.cancelled and target.has_skill(MaidenCostumeSkill):
                act.cancelled = True
                nact = MaidenCostumeEffect(source=act.source, target=target)
                nact.associated_card = act.associated_card
                Game.getgame().process_action(nact)
        return act


class IbukiGourdSkill(RedUFOSkill):
    increment = 0


@register_eh
class IbukiGourdHandler(EventHandler):
    execute_after = ('WineHandler', 'CiguateraHandler', )

    def handle(self, evt_type, arg):
        if evt_type == 'action_after' and isinstance(arg, PlayerTurn):
            target = arg.target
            if target.has_skill(IbukiGourdSkill):
                g = Game.getgame()
                g.process_action(basic.Wine(target, target))
        elif evt_type == 'card_migration':
            from .definition import IbukiGourdCard
            act, cl, _from, to = arg
            if any(c.is_card(IbukiGourdCard) for c in cl):
                target = None
                if _from.type == 'equips':
                    target = _from.owner
                elif to.type == 'equips':
                    target = to.owner

                if target:
                    g = Game.getgame()
                    g.process_action(basic.Wine(target, target))

        return arg


class HouraiJewelAttack(basic.BaseAttack, spellcard.InstantSpellCardAction):
    def apply_action(self):
        g = Game.getgame()
        g.process_action(Damage(self.source, self.target))
        return True


class HouraiJewelSkill(WeaponSkill):
    associated_action = None
    target = t_None
    range = 1


@register_eh
class HouraiJewelHandler(EventHandler):
    execute_before = ('RejectHandler', 'WineHandler')  # wine does not affect this.

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, basic.Attack):
            src = act.source
            if not src.has_skill(HouraiJewelSkill): return act
            if isinstance(act, HouraiJewelAttack): return act
            if user_input([src], ChooseOptionInputlet(self, (False, True))):
                act.__class__ = classmix(HouraiJewelAttack, act.__class__)

        return act


class UmbrellaSkill(ShieldSkill):
    pass


class UmbrellaEffect(GenericAction):
    def __init__(self, act):
        self.source = self.target = act.target
        self.action = act

    def apply_action(self):
        return True


@register_eh
class UmbrellaHandler(EventHandler):
    # 紫的阳伞
    execute_before = ('RejectHandler', )

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, Damage):
            if not act.target.has_skill(UmbrellaSkill): return act
            g = Game.getgame()
            pact = g.action_stack[-1]

            if isinstance(pact, spellcard.SpellCardAction):
                act.cancelled = True
                Game.getgame().process_action(UmbrellaEffect(pact))

        return act


class SaigyouBranchSkill(TreatAsSkill, ShieldSkill):
    treat_as = Card.card_classes['RejectCard']

    def check(self):
        return False


class SaigyouBranch(FatetellAction):
    def __init__(self, source, act):
        self.source = source
        self.target = source
        self.act = act

    def apply_action(self):
        act = self.act
        src = self.source

        g = Game.getgame()
        ft = Fatetell(src, lambda card: 9 <= card.number <= 13)
        g.process_action(ft)
        if ft.succeeded:
            rej = spellcard.LaunchReject(src, act, SaigyouBranchSkill(src))
            g.process_action(rej)
            return True
        else:
            return False


@register_eh
class SaigyouBranchHandler(EventHandler):
    execute_before = ('RejectHandler', )
    execute_after = ('HouraiJewelHandler', )

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, spellcard.SpellCardAction):
            src, tgt = act.source, act.target
            if not tgt.has_skill(SaigyouBranchSkill): return act
            if act.cancelled: return act
            if isinstance(act, spellcard.Reject): return act  # can't respond to reject

            if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
                return act

            Game.getgame().process_action(SaigyouBranch(tgt, act))

        return act


class HakuroukenSkill(WeaponSkill):
    range = 2
    associated_action = None
    target = t_None


class Hakurouken(GenericAction):
    card_usage = 'drop'

    def apply_action(self):
        src = self.source
        tgt = self.target

        cards = user_choose_cards(self, tgt, ('cards', 'showncards'))
        g = Game.getgame()
        if cards:
            self.peer_action = 'drop'
            g.process_action(DropCards(tgt, cards))
        else:
            self.peer_action = 'draw'
            g.process_action(DrawCards(src, 1))

        return True

    def cond(self, cards):
        tgt = self.target
        return len(cards) == 1 and cards[0].resides_in in (tgt.cards, tgt.showncards)


@register_eh
class HakuroukenHandler(EventHandler):
    # BUG WITH OUT THIS LINE:
    # src equips [Gourd, Hakurouken], tgt drops Exinwan
    # then src drops Gourd,
    # but Attack.damage == 1, Wine tag preserved.
    execute_before = ('WineHandler', 'MomijiShieldHandler')

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, basic.BaseAttack):
            if act.cancelled: return act
            src = act.source
            if not src.has_skill(HakuroukenSkill): return act
            card = act.associated_card
            if not card.color == Card.BLACK: return act

            if not user_input([src], ChooseOptionInputlet(self, (False, True))):
                return act

            Game.getgame().process_action(Hakurouken(src, act.target))

        return act


class AyaRoundfan(GenericAction):
    def apply_action(self):
        src = self.source
        tgt = self.target

        g = Game.getgame()

        equip = user_input([src], ChoosePeerCardInputlet(self, tgt, ['equips']))
        if not equip:
            equip = random_choose_card([tgt.equips])
        g.process_action(DropCards(tgt, [equip]))
        self.card = equip

        return True


class AyaRoundfanSkill(WeaponSkill):
    range = 5
    associated_action = None
    target = t_None


@register_eh
class AyaRoundfanHandler(EventHandler):
    card_usage = 'drop'

    def handle(self, evt_type, act):
        if evt_type == 'action_after' and isinstance(act, basic.BaseAttack):
            if not act.succeeded: return act
            src = act.source
            tgt = act.target
            if src.has_skill(AyaRoundfanSkill) and tgt.equips:
                cards = user_choose_cards(self, src, ['cards', 'showncards'])
                if not cards: return act
                g = Game.getgame()
                g.process_action(DropCards(src, cards))
                g.process_action(AyaRoundfan(src, tgt))
        return act

    def cond(self, cards):
        if not len(cards) == 1: return False
        return cards[0].resides_in.type in ('cards', 'showncards')


class Laevatein(UserAction):
    def apply_action(self):
        return True  # logic handled in LaevateinHandler


class LaevateinSkill(WeaponSkill):
    range = 3
    associated_action = None
    target = t_None


@register_eh
class LaevateinHandler(EventHandler):
    card_usage = 'drop'

    def handle(self, evt_type, arg):
        if evt_type == 'attack_aftergraze':
            act, succeed = arg
            assert isinstance(act, basic.BaseAttack)
            if succeed:
                return arg

            src = act.source
            tgt = act.target
            if not src or not src.has_skill(LaevateinSkill):
                return arg

            g = Game.getgame()
            cards = user_choose_cards(self, src, ('cards', 'showncards', 'equips'))
            if not cards:
                return arg

            g.process_action(DropCards(src, cards))
            g.process_action(Laevatein(src, tgt))
            return act, True

        return arg

    def cond(self, cards):
        if not len(cards) == 2: return False

        if any(c.resides_in.type not in (
            'cards', 'showncards', 'equips'
        ) for c in cards): return False

        from ..cards import LaevateinCard
        if any(
            c.resides_in.type == 'equips' and c.is_card(LaevateinCard)
            for c in cards
        ): return False

        return True


class DeathSickleSkill(WeaponSkill):
    range = 2
    associated_action = None
    target = t_None


class DeathSickle(GenericAction):
    def __init__(self, act):
        self.action = act
        self.source, self.target = act.source, act.target

    def apply_action(self):
        self.action.damage += 1
        return True


@register_eh
class DeathSickleHandler(EventHandler):
    execute_before = ('WineHandler', )

    def handle(self, evt_type, act):
        if evt_type == 'action_apply' and isinstance(act, Damage):
            from .basic import Attack
            g = Game.getgame()
            pact = g.action_stack[-1]
            if not isinstance(pact, Attack): return act
            src = act.source
            if not src or not src.has_skill(DeathSickleSkill): return act
            tgt = act.target
            if len(tgt.cards) + len(tgt.showncards) == 0:
                act.amount += 1

        return act


class KeystoneSkill(GreenUFOSkill):
    increment = 1


class Keystone(GenericAction):
    def __init__(self, act):
        assert isinstance(act, spellcard.Sinsack)
        self.source = self.target = act.target
        self.action = act

    def apply_action(self):
        self.action.cancelled = True
        return True


@register_eh
class KeystoneHandler(EventHandler):
    execute_before = ('SaigyouBranchHandler', 'RejectHandler')

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, spellcard.Sinsack):
            tgt = act.target
            if tgt.has_skill(KeystoneSkill):
                Game.getgame().process_action(Keystone(act))

        return act


class WitchBroomSkill(RedUFOSkill):
    increment = 2


class AccessoriesSkill(Skill):
    associated_action = None
    target = t_None


class YinYangOrb(GenericAction):
    def __init__(self, ft):
        self.ftact = ft
        self.source = self.target = ft.target

    def apply_action(self):
        ft = self.ftact
        tgt = ft.target

        from .definition import YinYangOrbCard
        for e in tgt.equips:
            if e.is_card(YinYangOrbCard):
                g = Game.getgame()
                g.process_action(DropCards(tgt, [e]))
                self.card = e
                ft.set_card(e)
                break
        else:
            raise GameError('Player has YinYangOrb skill but no equip!')

        return True


class YinYangOrbSkill(AccessoriesSkill):
    pass


@register_eh
class YinYangOrbHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'fatetell':
            tgt = act.target
            if not tgt.has_skill(YinYangOrbSkill): return act
            if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
                return act

            g = Game.getgame()
            g.process_action(YinYangOrb(act))

        return act


class SuwakoHatSkill(AccessoriesSkill):
    pass


@register_eh
class SuwakoHatHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, DropCardStage):
            tgt = act.target
            if tgt.has_skill(SuwakoHatSkill):
                act.dropn = max(act.dropn - 2, 0)
        return act


class YoumuPhantomSkill(AccessoriesSkill):
    pass


@register_eh
class YoumuPhantomHandler(EventHandler):
    def handle(self, evt_type, arg):
        if not evt_type == 'card_migration': return arg

        act, cards, _from, to = arg

        from .definition import YoumuPhantomCard

        g = Game.getgame()

        if _from is not None and _from.type == 'equips':
            for c in cards:
                if c.is_card(YoumuPhantomCard):
                    from .basic import Heal

                    owner = _from.owner

                    g.process_action(MaxLifeChange(owner, owner, -1))
                    if not owner.dead:
                        g.process_action(Heal(owner, owner))

        if to is not None and to.type == 'equips':
            for c in cards:
                if c.is_card(YoumuPhantomCard):
                    g.process_action(MaxLifeChange(to.owner, to.owner, 1))

        return arg


class IceWingSkill(AccessoriesSkill):
    pass


class IceWing(GenericAction):
    def __init__(self, act):
        assert isinstance(act, (spellcard.SealingArray, spellcard.FrozenFrog))
        self.source = self.target = act.target
        self.action = act

    def apply_action(self):
        self.action.cancelled = True
        return True


@register_eh
class IceWingHandler(EventHandler):
    execute_before = ('RejectHandler', 'SaigyouBranchHandler')
    _effect_cls = spellcard.SealingArray, spellcard.FrozenFrog

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, self._effect_cls):
            if act.target.has_skill(IceWingSkill):
                Game.getgame().process_action(IceWing(act))

        return act


class GrimoireSkill(TreatAsSkill, WeaponSkill):
    range = 1
    from .base import Card
    lookup_tbl = {
        Card.SPADE: Card.card_classes['SinsackCarnivalCard'],  # again...
        Card.HEART: Card.card_classes['FeastCard'],
        Card.CLUB: Card.card_classes['MapCannonCard'],
        Card.DIAMOND: Card.card_classes['HarvestCard'],
    }
    del Card

    @property
    def treat_as(self):
        cl = self.associated_cards
        if not (cl and cl[0].suit):
            from .definition import DummyCard
            return DummyCard
        return self.lookup_tbl[cl[0].suit]

    def check(self):
        cl = self.associated_cards
        if not len(cl) == 1: return False
        if not cl[0].resides_in.type in ('cards', 'showncards', 'equips'):
            return False
        if not cl[0].suit: return False
        return True


@register_eh
class GrimoireHandler(EventHandler):
    def handle(self, evt_type, arg):
        if evt_type == 'action_can_fire':
            act, v = arg
            if not isinstance(act, LaunchCard): return arg
            c = act.card
            if c.is_card(GrimoireSkill):
                src = act.source
                t = src.tags

                if t['turn_count'] <= t['grimoire_tag']:
                    return (act, False)

                if basic.AttackCardHandler.is_freeattack(act.source):
                    return arg

                if t['attack_num'] <= 0:
                    return (act, False)

        elif evt_type == 'action_after' and isinstance(arg, LaunchCard):
            c = arg.card
            if c.is_card(GrimoireSkill):
                t = arg.source.tags
                t['attack_num'] -= 1
                t['grimoire_tag'] = t['turn_count']
        return arg

########NEW FILE########
__FILENAME__ = spellcard
# -*- coding: utf-8 -*-

from game.autoenv import Game, EventHandler, user_input, InputTransaction
from game import sync_primitive
from . import basic
from .base import VirtualCard
from ..actions import random_choose_card, register_eh, migrate_cards, ask_for_action
from ..actions import user_choose_cards
from ..actions import GenericAction, UserAction, LaunchCardAction, DropCards
from ..actions import DrawCards, Fatetell, ActionStage, Damage, ForEach
from ..actions import LaunchCard, DrawCardStage, launch_card
from ..inputlets import ChoosePeerCardInputlet, ChooseIndividualCardInputlet

from utils import check, CheckFailed, BatchList, flatten


class SpellCardAction(UserAction):
    pass


class InstantSpellCardAction(SpellCardAction):
    pass


class NonResponsiveInstantSpellCardAction(InstantSpellCardAction):
    pass


class Demolition(InstantSpellCardAction):
    # 城管执法

    def apply_action(self):
        g = Game.getgame()
        src = self.source
        tgt = self.target

        catnames = ['cards', 'showncards', 'equips', 'fatetell']
        cats = [getattr(tgt, i) for i in catnames]
        card = user_input([src], ChoosePeerCardInputlet(self, tgt, catnames))
        if not card:
            card = random_choose_card(cats)
            if not card:
                return False

        self.card = card
        g.players.exclude(tgt).reveal(card)
        g.process_action(
            DropCards(target=tgt, cards=[card])
        )
        return True

    def is_valid(self):
        tgt = self.target
        catnames = ['cards', 'showncards', 'equips', 'fatetell']
        return bool([getattr(tgt, i) for i in catnames])


class Reject(InstantSpellCardAction):
    # 好人卡
    def __init__(self, source, target_act):
        self.source = source
        self.target_act = target_act
        self.target = target_act.target

    def apply_action(self):
        if not isinstance(self.target_act, SpellCardAction):
            return False
        self.target_act.cancelled = True
        return True


class LaunchReject(GenericAction, LaunchCardAction):
    def __init__(self, source, target_act, card):
        self.source = source
        self.target_act = target_act
        self.target = target_act.target
        self.card = card

    def apply_action(self):
        action = Reject(source=self.source, target_act=self.target_act)
        launch_card(self, [], action)
        return True


@register_eh
class RejectHandler(EventHandler):
    card_usage = 'launch'

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, SpellCardAction):
            if act.cancelled: return act  # some other thing have done the job
            if isinstance(act, NonResponsiveInstantSpellCardAction):
                return act

            g = Game.getgame()

            has_reject = False
            while g.SERVER_SIDE:
                from ..characters.reimu import Reimu
                for p in g.players:
                    if isinstance(p, Reimu):
                        has_reject = True
                        break

                if has_reject: break

                from .definition import RejectCard
                for c in flatten([[p.cards, p.showncards] for p in g.players]):
                    if isinstance(c, RejectCard):
                        has_reject = True
                        break

                break

            has_reject = sync_primitive(has_reject, g.players)
            if not has_reject: return act

            self.target_act = act  # for ui

            pl = BatchList(p for p in g.players if not p.dead)

            p, rst = ask_for_action(self, pl, ('cards', 'showncards'), [])
            if not p: return act
            cards, _ = rst
            assert cards and self.cond(cards)
            g.process_action(LaunchReject(p, act, cards[0]))

        return act

    def cond(self, cardlist):
        from .. import cards
        try:
            check(len(cardlist) == 1)
            check(cardlist[0].is_card(cards.RejectCard))
            return True
        except CheckFailed:
            return False


class DelayedSpellCardAction(SpellCardAction): pass  # 延时SC


class DelayedLaunchCard(UserAction):
    def apply_action(self):
        card = self.associated_card
        action = card.delayed_action
        assert issubclass(action, DelayedSpellCardAction)

        t = self.target
        migrate_cards([card], t.fatetell)

        return True

    def is_valid(self):
        if not self.associated_card: return False
        if not len(self.target_list) == 1: return False
        return True


class SealingArray(DelayedSpellCardAction):
    # 封魔阵
    def apply_action(self):
        g = Game.getgame()
        target = self.target
        from ..cards import Card
        ft = Fatetell(target, lambda card: card.suit != Card.HEART)
        g.process_action(ft)
        if ft.succeeded:
            target.tags['sealed'] = True
            return True
        else:
            return False

    def fatetell_postprocess(self):
        g = Game.getgame()
        target = self.target
        g.process_action(DropCards(target, [self.associated_card]))


@register_eh
class SealingArrayHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, ActionStage):
            target = act.target
            if target.tags.get('sealed'):
                del target.tags['sealed']
                act.cancelled = True
        return act


class NazrinRod(InstantSpellCardAction):
    # 纳兹琳的探宝棒

    def apply_action(self):
        g = Game.getgame()
        g.process_action(DrawCards(self.target, amount=2))
        return True


class Sinsack(DelayedSpellCardAction):
    # 罪袋
    def apply_action(self):
        g = Game.getgame()
        target = self.target
        from ..cards import Card
        ft = Fatetell(target, lambda card: card.suit == Card.SPADE and 1 <= card.number <= 8)
        g.process_action(ft)
        if ft.succeeded:
            g.process_action(Damage(None, target, amount=3))
            return True
        return False

    def fatetell_postprocess(self):
        g = Game.getgame()
        target = self.target
        if (not self.cancelled) and self.succeeded:
            g.process_action(DropCards(target, [self.associated_card]))
        else:
            pl = g.players
            stop = pl.index(target)
            next = stop - len(pl) + 1
            while next < stop:
                if not pl[next].dead:
                    migrate_cards([self.associated_card], pl[next].fatetell)
                    return
                next += 1


class YukariDimension(InstantSpellCardAction):
    # 紫的隙间

    def apply_action(self):
        src = self.source
        tgt = self.target

        catnames = ['cards', 'showncards', 'equips', 'fatetell']
        cats = [getattr(tgt, i) for i in catnames]
        card = user_input([src], ChoosePeerCardInputlet(self, tgt, catnames))
        if not card:
            card = random_choose_card(cats)
            if not card:
                return False

        self.card = card
        src.reveal(card)
        migrate_cards([card], src.cards, unwrap=True)
        return True

    def is_valid(self):
        tgt = self.target
        catnames = ['cards', 'showncards', 'equips', 'fatetell']
        return bool([getattr(tgt, i) for i in catnames])


class BaseDuel(UserAction):
    # 弹幕战
    def __init__(self, source, target, damage=1):
        self.source = source
        self.target = target
        self.source_damage = self.target_damage = damage

    def apply_action(self):
        g = Game.getgame()
        source = self.source
        target = self.target

        s, t = source, target
        sd, td = self.source_damage, self.target_damage
        while True:
            if t.dead: break
            if not g.process_action(basic.UseAttack(t)): break
            s, t = t, s
            sd, td = td, sd

        if not t.dead:
            g.process_action(Damage(s, t, amount=sd))

        return s is source


class Duel(BaseDuel, InstantSpellCardAction):
    pass


class MapCannonEffect(InstantSpellCardAction):
    # 地图炮
    def apply_action(self):
        g = Game.getgame()
        source, target = self.source, self.target
        graze_action = basic.UseGraze(target)
        if not g.process_action(graze_action):
            g.process_action(Damage(source, target, amount=1))
            return True
        else:
            return False


class MapCannon(ForEach):
    action_cls = MapCannonEffect


class SinsackCarnivalEffect(InstantSpellCardAction):
    # 罪袋狂欢
    def apply_action(self):
        g = Game.getgame()
        source, target = self.source, self.target
        use_action = basic.UseAttack(target)
        if not g.process_action(use_action):
            g.process_action(Damage(source, target, amount=1))
            return True
        else:
            return False


class SinsackCarnival(ForEach):
    action_cls = SinsackCarnivalEffect


class FeastEffect(InstantSpellCardAction):
    # 宴会
    def apply_action(self):
        src, tgt = self.source, self.target
        g = Game.getgame()
        if tgt.life < tgt.maxlife:
            g.process_action(basic.Heal(src, tgt))
        else:
            g.process_action(basic.Wine(src, tgt))
        return True


class Feast(ForEach):
    action_cls = FeastEffect


class HarvestEffect(InstantSpellCardAction):
    # 五谷丰登 效果
    def apply_action(self):
        g = Game.getgame()
        cards = self.parent_action.cards
        cards_avail = [c for c in cards if c.resides_in is g.deck.disputed]
        if not cards_avail: return False
        tgt = self.target

        card = user_input(
            [tgt],
            ChooseIndividualCardInputlet(self, cards_avail),
            trans=self.parent_action.trans,
        ) or random_choose_card([cards_avail])

        migrate_cards([card], tgt.cards)

        self.parent_action.trans.notify('harvest_choose', card)
        self.card = card
        return True

    def is_valid(self):
        try:
            cards = self.parent_action.cards
        except:
            return False

        g = Game.getgame()
        return bool([c for c in cards if c.resides_in is g.deck.disputed])


class Harvest(ForEach):
    action_cls = HarvestEffect

    def prepare(self):
        tl = self.target_list
        g = Game.getgame()
        cards = g.deck.getcards(len(tl))
        g.players.reveal(cards)
        migrate_cards(cards, g.deck.disputed)
        trans = InputTransaction('HarvestChoose', g.players, cards=cards)
        trans.begin()
        self.cards = cards
        self.trans = trans

    def cleanup(self):
        g = Game.getgame()
        self.trans.end()
        g.emit_event('harvest_finish', self)
        dropped = g.deck.droppedcards
        migrate_cards([c for c in self.cards if c.resides_in is g.deck.disputed], dropped)


class DollControl(InstantSpellCardAction):
    card_usage = 'launch'

    def apply_action(self):
        tl = self.target_list
        assert len(tl) == 2
        src = self.source

        controllee, attackee = tl
        cards = user_choose_cards(self, controllee, ['cards', 'showncards'])
        g = Game.getgame()

        if cards:
            g.players.reveal(cards)
            g.process_action(LaunchCard(controllee, [attackee], cards[0]))
        else:
            l = [e for e in controllee.equips if e.equipment_category == 'weapon']
            migrate_cards(l, src.cards)
        return True

    def cond(self, cl):
        if len(cl) != 1: return False
        if not cl[0].associated_action: return False
        if issubclass(cl[0].associated_action, basic.Attack): return True
        return False


class DonationBoxEffect(InstantSpellCardAction):
    card_usage = 'handover'

    def apply_action(self):
        t = self.target
        src = self.source
        g = Game.getgame()

        catnames = ('cards', 'showncards', 'equips')
        cats = [getattr(t, i) for i in catnames]
        cards = user_choose_cards(self, t, catnames)
        if not cards:
            cards = [random_choose_card(cats)]

        if cards:
            g.players.exclude(t).reveal(cards)
            migrate_cards(cards, src.showncards)

        return True

    def cond(self, cards):
        return len(cards) == 1 and cards[0].resides_in.type in (
            'cards', 'showncards', 'equips'
        ) and not isinstance(cards[0], VirtualCard)

    def is_valid(self):
        t = self.target
        if t.cards or t.showncards or t.equips: return True
        return False


class DonationBox(ForEach):
    action_cls = DonationBoxEffect

    def is_valid(self):
        tl = self.target_list
        if not 0 < len(tl) <= 2: return False

        if not all(
            t.cards or t.showncards or t.equips
            for t in tl
        ): return False

        return True


class FrozenFrog(DelayedSpellCardAction):
    # 冻青蛙
    def apply_action(self):
        g = Game.getgame()
        target = self.target
        from ..cards import Card
        ft = Fatetell(target, lambda card: card.suit != Card.SPADE)
        g.process_action(ft)
        if ft.succeeded:
            target.tags['freezed'] = True
            return True
        else:
            return False

    def fatetell_postprocess(self):
        g = Game.getgame()
        target = self.target
        g.process_action(DropCards(target, [self.associated_card]))


@register_eh
class FrozenFrogHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, DrawCardStage):
            tgt = act.target
            if tgt.tags.get('freezed'):
                del tgt.tags['freezed']
                act.cancelled = True
        return act

########NEW FILE########
__FILENAME__ = akari
# -*- coding: utf-8 -*-

from .baseclasses import Character, register_character_to


@register_character_to('special')
class Akari(Character):
    # dummy player for hidden choices
    skills = []
    eventhandlers_required = []
    maxlife = 0

########NEW FILE########
__FILENAME__ = alice
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, user_input, Game
from baseclasses import Character, register_character
from ..actions import DrawCards, UserAction, ActionStageLaunchCard, DropCardStage, user_choose_players, DropCards, random_choose_card
from ..cards import Skill, TreatAsSkill, AttackCardHandler, DollControlCard, t_None
from ..inputlets import ChoosePeerCardInputlet, ChooseOptionInputlet


class LittleLegion(Skill):
    associated_action = None
    target = t_None


class LittleLegionDrawCards(DrawCards):
    pass


class LittleLegionAction(UserAction):
    def apply_action(self):
        g = Game.getgame()
        src = self.source
        tgt = self.target

        catnames = ['cards', 'showncards', 'equips']
        cats = [getattr(tgt, i) for i in catnames]
        card = user_input([src], ChoosePeerCardInputlet(self, tgt, catnames))
        if not card:
            card = random_choose_card(cats)
            if not card:
                return False

        self.card = card
        g.players.exclude(tgt).reveal(card)
        g.process_action(
            DropCards(target=tgt, cards=[card])
        )
        return True


class LittleLegionHandler(EventHandler):
    def handle(self, evt_type, arg):
        if evt_type == 'choose_target':
            lca, tl = arg
            if 'equipment' not in lca.card.category: return arg

            src = lca.source
            if src.dead or not src.has_skill(LittleLegion): return arg
            if not user_input([src], ChooseOptionInputlet(self, (False, True))):
                return arg
            g = Game.getgame()
            g.process_action(LittleLegionDrawCards(src, 1))

        elif evt_type == 'post_card_migration':
            pl = set([_from.owner for _, _from, _ in arg
                      if _from is not None and _from.type == 'equips'])
            pl = [p for p in pl if p.has_skill(LittleLegion) and not p.dead]

            g = Game.getgame()
            for p in pl:
                self.source = p
                if not user_input([p], ChooseOptionInputlet(self, (False, True))):
                    continue
                tl = user_choose_players(self, p, g.players.exclude(p))
                if tl:
                    assert len(tl) == 1
                    g.process_action(LittleLegionAction(p, tl[0]))

        return arg

    def cond(self, cl):
        return True

    def choose_player_target(self, tl):
        if not tl:
            return tl, False

        tgt = tl[0]
        if tgt is self.source:
            return [], False

        return ([tgt], bool(tgt.equips or tgt.cards or tgt.showncards))


class MaidensBunraku(Skill):
    associated_action = None
    target = t_None


class MaidensBunrakuHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_apply' and isinstance(act, DropCardStage):
            tgt = act.target
            if not tgt.has_skill(MaidensBunraku): return act
            amount = (len(tgt.equips) + 1) / 2
            act.dropn -= amount if amount > 1 else 1

        return act


class DollCrusader(TreatAsSkill):
    treat_as = DollControlCard

    def check(self):
        cl = self.associated_cards
        if not cl and len(cl) == 1: return False
        c = cl[0]
        if c.resides_in.type not in ('cards', 'showncards', 'equips'):
            return False

        return 'instant_spellcard' in c.category


class DollCrusaderHandler(EventHandler):
    def handle(self, evt_type, arg):
        if evt_type == 'action_after' and isinstance(arg, ActionStageLaunchCard):
            c = arg.card
            if c.is_card(DollCrusader):
                src = arg.source
                src.tags['alice_doll_tag'] = src.tags['turn_count']

        elif evt_type == 'action_can_fire':
            act, valid = arg
            if isinstance(act, ActionStageLaunchCard):
                c = act.card
                if c.is_card(DollCrusader):
                    t = act.source.tags
                    if t['alice_doll_tag'] >= t['turn_count']:
                        return act, False

        return arg


@register_character
class Alice(Character):
    skills = [LittleLegion, MaidensBunraku]
    eventhandlers_required = [LittleLegionHandler, MaidensBunrakuHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = baseclasses
# -*- coding: utf-8 -*-

from game.autoenv import GameObject
from options import options
from collections import defaultdict

# common, id5, id8, raid, raid_ex, faith, kof, 3v3, testing
# -id5, -id8, ...
characters_by_category = defaultdict(set)


class Character(GameObject):
    character_classes = {}

    def __init__(self, player):
        self.player = player

    def get_skills(self, skill):
        return [s for s in self.skills if issubclass(s, skill)]

    has_skill = get_skills

    def __repr__(self):
        return '<Char: {}>'.format(self.__class__.__name__)

    def __getattr__(self, k):
        return getattr(self.player, k)

    def __setattr__(self, k, v):
        GameObject.__setattr__(self, k, v)
        if not k.startswith('__') and k.endswith('__'):
            assert not hasattr(self.player, k)


def register_character_to(*cats):
    sets = [characters_by_category[c] for c in set(cats)]

    def register(cls):
        Character.character_classes[cls.__name__] = cls
        [s.add(cls) for s in sets]
        cls.categories = cats
        return cls

    return register

register_character = register_character_to('common')

if options.testing:
    register_testing_character = register_character
else:
    register_testing_character = lambda x: x
    

def get_characters(*cats, **kwargs):
    cats = set(cats)
    if '-common' in cats:
        cats.discard('-common')
    else:
        cats.add('common')

    chars = set()
    chars.update(*[characters_by_category[c] for c in cats])
    chars.difference_update(*[characters_by_category['-' + c] for c in cats])
    chars = list(sorted(chars, key=lambda i: i.__name__))
    return chars


def mixin_character(player, char_cls):
    assert issubclass(char_cls, Character)
    old = None
    if isinstance(player, Character):
        old = player.__class__
        player = player.player

    new = char_cls(player)
    new.skills = list(char_cls.skills)
    new.maxlife = char_cls.maxlife
    new.life = char_cls.maxlife
    new.dead = False
    return new, old

########NEW FILE########
__FILENAME__ = chen
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, Game, user_input
from .baseclasses import Character, register_character
from ..actions import ForEach, LaunchCard, DrawCards, UserAction
from ..inputlets import ChooseOptionInputlet
from ..cards import Skill, AttackCard, DollControlCard, RejectCard, InstantSpellCardAction, t_OtherOne, Heal


class FlyingSkandaAction(ForEach):
    @property
    def action_cls(self):
        skill = self.associated_card
        card = skill.associated_cards[0]
        action = card.associated_action
        return action

    def is_valid(self):
        p = self.source
        if p.tags['turn_count'] <= p.tags['flying_skanda']:
            return False
        if any(t.dead for t in self.target_list):
            return False
        return True


class FlyingSkanda(Skill):
    associated_action = FlyingSkandaAction
    usage = 'launch'

    def target(self, g, source, tl):
        cl = self.associated_cards
        if not cl: return ([], False)
        c = cl[0]
        if len(tl) < 2:
            return c.target(g, source, tl)
        else:
            rst = c.target(g, source, tl[:-1])
            a = tl[-1]
            if a is source:
                return rst[0], False
            else:
                return rst[0] + [a], rst[1]

    @property
    def distance(self):
        cl = self.associated_cards
        if not cl: return 0
        return cl[0].distance

    def check(self):
        cl = self.associated_cards
        if len(cl) != 1: return False
        c = cl[0]
        if c.is_card(AttackCard): return True

        if c.is_card(DollControlCard): return False
        if c.is_card(RejectCard): return False

        act = c.associated_action
        if not issubclass(act, InstantSpellCardAction): return False
        return True

    def is_card(self, cls):
        cl = self.associated_cards
        if cl and cl[0].is_card(cls): return True
        return isinstance(self, cls)


class FlyingSkandaHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_after' and isinstance(act, LaunchCard):
            if not act.card.is_card(FlyingSkanda): return act
            act.source.tags['flying_skanda'] = act.source.tags['turn_count']
        return act


class ShikigamiAction(UserAction):
    def apply_action(self):
        tgt = self.target
        src = self.source

        g = Game.getgame()

        if tgt.life < tgt.maxlife and user_input([tgt],
            ChooseOptionInputlet(self, (False, True))
        ):
            g.process_action(Heal(src, tgt))
        else:
            g.process_action(DrawCards(tgt, 2))

        tgt.tags['shikigami_target'] = src
        src.tags['shikigami_target'] = tgt
        src.tags['shikigami_tag'] = src.tags['turn_count']
        
        return True

    def is_valid(self):
        return 'shikigami_tag' not in self.source.tags


class Shikigami(Skill):
    associated_action = ShikigamiAction
    target = t_OtherOne

    def check(self):
        return not self.associated_cards


class ShikigamiHandler(EventHandler):
    def handle(self, evt_type, arg):
        if evt_type == 'post_calcdistance':
            src, card, dist = arg
            if not card.is_card(AttackCard): return arg

            tgt = src.tags.get('shikigami_target')
            if not tgt or tgt.dead: return arg

            g = Game.getgame()
            if g.current_turn is not src: return arg

            origin = src if 'shikigami_tag' in src.tags else tgt
            if origin.tags['shikigami_tag'] != origin.tags['turn_count']:
                return arg

            dist2 = LaunchCard.calc_raw_distance(tgt, AttackCard())

            for k in dist2:
                if dist[k] > 0 and dist2[k] <= 1:
                    dist[k] = 0

        return arg


@register_character
class Chen(Character):
    skills = [FlyingSkanda, Shikigami]
    eventhandlers_required = [FlyingSkandaHandler, ShikigamiHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = cirno
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler
from .baseclasses import Character, register_character
from ..cards import Card, FrozenFrogCard, TreatAsSkill


class PerfectFreeze(TreatAsSkill):
    treat_as = FrozenFrogCard

    def check(self):
        cl = self.associated_cards
        if not (cl and len(cl) == 1): return False
        c = cl[0]
        if not c.resides_in.type in (
            'cards', 'showncards', 'equips'
        ): return False
        if c.suit not in (Card.SPADE, Card.CLUB): return False
        if 'skill' in c.category: return False
        return bool(set(c.category) & {'basic', 'equipment'})


class PerfectFreezeHandler(EventHandler):
    def handle(self, evt_type, arg):
        if evt_type == 'calcdistance':
            src, card, dist = arg
            if not src.has_skill(PerfectFreeze): return arg
            if not card.is_card(FrozenFrogCard): return arg
            for p in dist:
                dist[p] -= 1

        return arg


@register_character
class Cirno(Character):
    skills = [PerfectFreeze]
    eventhandlers_required = [PerfectFreezeHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = daiyousei
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, Game
from .baseclasses import Character, register_character
from ..actions import ActionStage, DrawCardStage, migrate_cards, UserAction
from ..cards import Skill, Heal, t_None, t_OtherOne


class Support(UserAction):
    def apply_action(self):
        cl = self.associated_card.associated_cards
        src = self.source
        tgt = self.target
        l = src.tags.get('daiyousei_spnum', 0)
        n = len(cl)
        if l < 3 <= l + n:
            g = Game.getgame()
            g.process_action(Heal(src, src))
        src.tags['daiyousei_spnum'] = l + n
        tgt.reveal(cl)
        migrate_cards([self.associated_card], tgt.cards, unwrap=True)
        self.cards = cl
        return True


class SupportSkill(Skill):
    associated_action = Support
    target = t_OtherOne
    usage = 'handover'
    no_drop = True
    no_reveal = True

    def check(self):
        cl = self.associated_cards
        return cl and all(
            c.resides_in is not None and
            c.resides_in.type in ('cards', 'showncards', 'equips')
            for c in cl
        )


class Moe(Skill):
    associated_action = None
    target = t_None


class MoeDrawCard(DrawCardStage):
    pass


class DaiyouseiHandler(EventHandler):
    # Well, well, things are getting messy
    def handle(self, evt_type, act):
        if evt_type == 'action_before':
            if isinstance(act, DrawCardStage):
                tgt = act.target
                if tgt.has_skill(Moe):
                    act.amount += tgt.maxlife - tgt.life
                    act.__class__ = MoeDrawCard
            elif isinstance(act, ActionStage):
                tgt = act.target
                if tgt.has_skill(SupportSkill):
                    tgt.tags['daiyousei_spnum'] = 0
        return act


@register_character
class Daiyousei(Character):
    skills = [SupportSkill, Moe]
    eventhandlers_required = [DaiyouseiHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = dummy
# -*- coding: utf-8 -*-
from .baseclasses import Character, register_testing_character


@register_testing_character
class Dummy(Character):
    skills = []
    eventhandlers_required = []
    maxlife = 5

########NEW FILE########
__FILENAME__ = eirin
# -*- coding: utf-8 -*-
from .baseclasses import Character, register_character_to
from ..cards import Card, Heal, HealCard, Skill, t_None, t_One


class FirstAid(Skill):
    associated_action = None
    target = t_None
    usage = 'launch'

    def check(self):
        cl = self.associated_cards
        if not cl or len(cl) != 1: return False
        c = cl[0]
        return bool(
            c.resides_in is not None and
            c.resides_in.type in ('cards', 'showncards', 'equips') and
            c.suit in (Card.HEART, Card.DIAMOND)
        )

    def is_card(self, cls):
        if issubclass(HealCard, cls): return True
        return isinstance(self, cls)


class EirinHeal(Heal):
    def apply_action(self):
        src = self.source
        src.tags['medic_tag'] = src.tags['turn_count']
        return Heal.apply_action(self)

    def is_valid(self):
        src = self.source
        if src.tags.get('turn_count', 0) <= src.tags.get('medic_tag', 0):
            return False
        return True


class Medic(Skill):
    associated_action = EirinHeal
    target = t_One
    usage = 'drop'

    def check(self):
        cl = self.associated_cards
        if bool(
            cl and len(cl) == 1 and
            cl[0].resides_in is not None and
            cl[0].resides_in.type in ('cards', 'showncards')
        ): return True
        return False


@register_character_to('common', '-kof')
class Eirin(Character):
    skills = [Medic, FirstAid]
    eventhandlers_required = []
    maxlife = 3

########NEW FILE########
__FILENAME__ = flandre
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, Game, user_input
from .baseclasses import Character, register_character
from ..actions import GenericAction, ActionStageLaunchCard, DrawCardStage
from ..cards import ElementalReactorSkill, AttackCard, AttackCardHandler, BaseAttack, BaseDuel, Skill, t_None
from ..inputlets import ChooseOptionInputlet


class CriticalStrike(Skill):
    associated_action = None
    target = t_None


class CriticalStrikeAction(GenericAction):
    def apply_action(self):
        tgt = self.target
        tgt.tags['flan_cs'] = tgt.tags['turn_count']
        tgt.tags['flan_targets'] = []
        return True


class CriticalStrikeHandler(EventHandler):
    execute_after = (
        'AttackCardHandler',
        'FrozenFrogHandler',
        'ElementalReactorHandler',
    )
    execute_before = (
        'MomijiShieldHandler',
    )

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, DrawCardStage):
            if act.cancelled: return act
            tgt = act.target
            if not tgt.has_skill(CriticalStrike): return act
            if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
                return act

            Game.getgame().process_action(CriticalStrikeAction(tgt, tgt))

            act.amount = max(0, act.amount - 1)

        elif evt_type == 'action_apply' and isinstance(act, (BaseAttack, BaseDuel)):
            src = act.source
            st = src.tags
            if not st['flan_cs'] >= st['turn_count']: return act
            if not Game.getgame().current_turn is src: return act
            if not src.has_skill(CriticalStrike): return act
            tgt = act.target
            if isinstance(act, BaseAttack):
                st['flan_targets'].append(tgt)
                act.damage += 1
            elif isinstance(act, BaseDuel):
                act.source_damage += 1

        elif evt_type == 'action_can_fire':
            arg = act
            act, valid = arg
            if not isinstance(act, ActionStageLaunchCard): return arg
            c = act.card
            src = act.source
            tags = src.tags
            if not src.has_skill(CriticalStrike): return arg
            if not tags['flan_cs'] >= tags['turn_count']: return arg
            if not c.is_card(AttackCard): return arg
            if src.has_skill(ElementalReactorSkill): return arg
            if set(act.target_list) & set(tags['flan_targets']):
                return (act, False)

            return arg

        elif evt_type == 'action_stage_action':
            tgt = act
            tags = tgt.tags
            if not tgt.has_skill(CriticalStrike): return act
            if not tags['flan_cs'] >= tags['turn_count']: return act
            AttackCardHandler.set_freeattack(tgt)

        return act


@register_character
class Flandre(Character):
    skills = [CriticalStrike]
    eventhandlers_required = [CriticalStrikeHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = kaguya
# -*- coding: utf-8 -*-

from game.autoenv import Game, EventHandler, user_input
from .baseclasses import Character, register_character
from ..actions import UserAction, LaunchCard, Damage, DrawCards, LaunchCardAction, LifeLost
from ..actions import user_choose_cards, migrate_cards, skill_transform
from ..cards import Skill, t_None, Card, SealingArrayCard, TreatAsSkill, VirtualCard, Heal
from ..inputlets import ChooseOptionInputlet


class Dilemma(Skill):
    associated_action = None
    target = t_None


class DilemmaDamageAction(UserAction):
    card_usage = 'handover'

    def apply_action(self):
        src = self.source
        tgt = self.target

        cards = user_choose_cards(self, tgt, ('cards', 'showncards', 'equips'))
        g = Game.getgame()
        if cards:
            self.peer_action = 'card'
            g.players.exclude(tgt).reveal(cards)
            migrate_cards(cards, src.cards)
        else:
            self.peer_action = 'life'
            g.process_action(LifeLost(src, tgt, 1))

        return True

    def cond(self, cards):
        if len(cards) != 1: return False
        card = cards[0]
        if not card.resides_in.type in (
            'cards', 'showncards', 'equips'
        ): return False

        return card.suit == Card.DIAMOND


class DilemmaHealAction(DrawCards):
    def __init__(self, source, target, amount=2):
        self.source = source
        self.target = target
        self.amount = amount


class DilemmaHandler(EventHandler):
    execute_after = ('DyingHandler', )

    def handle(self, evt_type, act):
        if evt_type != 'action_after': return act
        if not isinstance(act, (Damage, Heal)): return act

        src = act.source
        tgt = act.target
        if tgt.dead: return act
        if not tgt.has_skill(Dilemma): return act
        if not src: return act

        self.dilemma_type = 'negative' if isinstance(act, Damage) else 'positive'
        if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
            return act

        g = Game.getgame()
        if isinstance(act, Damage):
            g.process_action(DilemmaDamageAction(tgt, src))
        else:  # Heal
            g.process_action(DilemmaHealAction(tgt, src, 1))

        return act


class ImperishableNight(TreatAsSkill):
    treat_as = SealingArrayCard

    def check(self):
        return Game.getgame().current_turn is not self.player


class ImperishableNightHandler(EventHandler):
    card_usage = 'launch'

    def handle(self, evt_type, act):
        if evt_type != 'action_after': return act
        if not isinstance(act, LaunchCardAction): return act

        g = Game.getgame()

        card = act.card
        if not card: return act
        if 'basic' not in card.category: return act
        if card.color != Card.RED: return act

        if card.is_card(VirtualCard):
            rawcards = VirtualCard.unwrap([card])
        else:
            rawcards = [card]

        if not all(
            c.resides_in is None or c.resides_in.type == 'droppedcard'
            for c in rawcards
        ): return act

        tgt = act.source
        self.target = tgt  # for ui

        if tgt.dead: return act

        for p in g.players:
            if p.dead or p is tgt: continue
            if not p.has_skill(ImperishableNight): continue
            if p is g.current_turn: continue

            if not user_input([p], ChooseOptionInputlet(self, (False, True))):
                continue

            cards = user_choose_cards(self, p, ('cards', 'showncards', 'equips'))

            if cards:
                skill = skill_transform(p, [ImperishableNight], cards, {})
                assert skill  # should not fail
                rst = g.process_action(LaunchCard(p, [tgt], skill))
                assert rst

        return act

    def cond(self, cards):
        if len(cards) != 1: return False
        card = cards[0]
        if not card.resides_in.type in (
            'cards', 'showncards', 'equips'
        ): return False
        if 'skill' in card.category: return False
        if card.color != Card.RED: return False
        return bool(set(card.category) & {'basic', 'equipment'})


@register_character
class Kaguya(Character):
    skills = [Dilemma, ImperishableNight]
    eventhandlers_required = [DilemmaHandler, ImperishableNightHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = kanako
# -*- coding: utf-8 -*-
from ..actions import ActionStage, Damage, DrawCardStage, DrawCards, DropCards
from ..actions import ForEach, GenericAction, PlayerTurn, UserAction, user_choose_cards
from ..cards import AttackCard, InstantSpellCardAction, RedUFOSkill, RejectCard
from ..cards import Skill, VirtualCard, t_None
from ..inputlets import ChooseOptionInputlet
from .baseclasses import Character, register_character
from game.autoenv import EventHandler, Game, user_input


class Onbashira(RedUFOSkill):
    associated_action = None
    target = t_None

    @staticmethod
    def increment(src):
        if Game.getgame().current_turn is not src: return 0
        return src.tags.get('onbashira', 0)


class OnbashiraAction(GenericAction):
    def __init__(self, target, amount):
        self.source = self.target = target
        self.amount = amount

    def apply_action(self):
        tags = self.target.tags
        tags['onbashira'] = self.amount
        return True


class OnbashiraTarget(GenericAction):
    card_usage = 'drop'

    def __init__(self, source, target, amount):
        self.source = source
        self.target = target
        self.amount = amount

    def apply_action(self):
        tgt = self.target
        cards = user_choose_cards(self, tgt, ('cards', 'showncards', 'equips'))

        if cards:
            self.cards = cards
            g = Game.getgame()
            g.process_action(DropCards(tgt, cards=cards))
        else:
            self.cards = None
            self.target.tags['onbashira_target'] = True

        return True

    def cond(self, cl):
        if len(cl) != self.amount: return False

        t = self.target
        if cl[0].resides_in not in (t.cards, t.showncards, t.equips):
            return False

        return True

    def is_valid(self):
        return self.amount > 0


class OnbashiraHandler(EventHandler):
    execute_after = ('CiguateraHandler', )

    def handle(self, evt_type, act):
        if evt_type == 'action_apply' and isinstance(act, DrawCardStage):
            if act.cancelled: return act
            tgt = act.target
            if not tgt.has_skill(Onbashira): return act
            rst = user_input([tgt], ChooseOptionInputlet(self, (0, 1, 2)))

            if not rst: rst = 0
            Game.getgame().process_action(OnbashiraAction(tgt, rst))
            act.amount = max(0, act.amount - rst)

        elif evt_type == 'action_after' and isinstance(act, PlayerTurn):
            tgt = act.target
            if tgt.has_skill(Onbashira):
                tgt.tags['onbashira'] = 0
            for p in Game.getgame().players:
                p.tags['onbashira_target'] = False

        elif evt_type == 'action_limit':
            arg, permitted = act
            if not permitted: return act
            if arg.usage not in ('use', 'launch'): return act

            g = Game.getgame()
            p = g.current_turn
            if not p or not p.has_skill(Onbashira): return act

            src = arg.actor
            if src.tags.get('onbashira_target'):
                cards = VirtualCard.unwrap(arg.cards)
                zone = src.cards, src.showncards
                return arg, all([c.resides_in not in zone for c in cards])

            return act

        elif evt_type == 'post_choose_target':
            act, tl = arg = act
            src = act.source
            g = Game.getgame()
            if src is not g.current_turn: return arg
            if not src.has_skill(Onbashira): return arg

            dlvl = src.tags['onbashira']
            if not dlvl > 0: return arg

            if not act.card.is_card(AttackCard):
                if act.card.is_card(RejectCard): return arg
                aact = getattr(act.card, 'associated_action', None)
                if not aact: return arg
                if not issubclass(aact, InstantSpellCardAction):
                    if not issubclass(aact, ForEach): return arg
                    if not issubclass(aact.action_cls, InstantSpellCardAction):
                        return arg
                    if len(tl) != 1: return arg

                else:
                    tl = tl[:1]  # only the first one should be the target

            for tgt in tl:
                if tgt is not src:
                    g.process_action(OnbashiraTarget(src, tgt, src.tags['onbashira']))

            return arg

        return act


class KanakoFaith(Skill):
    associated_action = None
    target = t_None


class KanakoFaithAction(UserAction):
    def apply_action(self):
        tags = self.target.tags
        tags['kanako_faith'] = tags['turn_count']
        return True


class KanakoFaithDrawCards(DrawCards):
    pass


class KanakoFaithHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_after':
            if isinstance(act, Damage):
                src = act.source
                tgt = act.target
                if not src or src is tgt: return act
                if not src.has_skill(KanakoFaith): return act

                g = Game.getgame()
                if g.current_turn is not src: return act
                g.process_action(KanakoFaithAction(src, src))

            elif isinstance(act, ActionStage):
                tgt = act.target
                if not tgt.has_skill(KanakoFaith): return act
                if not tgt.tags['kanako_faith'] >= tgt.tags['turn_count']:
                    return act
                Game.getgame().process_action(KanakoFaithDrawCards(tgt, 1))

        return act


@register_character
class Kanako(Character):
    skills = [Onbashira, KanakoFaith]
    eventhandlers_required = [OnbashiraHandler, KanakoFaithHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = koakuma
# -*- coding: utf-8 -*-
from game.autoenv import Game
from .baseclasses import Character, register_character
from ..actions import DrawCards, UserAction
from ..cards import Skill, t_Self


class FindAction(UserAction):
    def apply_action(self):
        g = Game.getgame()
        cards = self.associated_card.associated_cards
        n = len(cards)
        # card will be dropped at LaunchCard
        #g.process_action(DropCards(self.target, cards))
        tgt = self.target
        g.process_action(DrawCards(tgt, n))
        tgt.tags['find_tag'] = tgt.tags['turn_count']
        return True

    def is_valid(self):
        try:
            p = self.target
            if p.tags.get('turn_count', 0) <= p.tags.get('find_tag', 0):
                return False

            return True

        except AttributeError:  # well, some cards are skill?
            return False


class Find(Skill):
    associated_action = FindAction
    target = t_Self
    usage = 'drop'

    def check(self):
        cl = self.associated_cards
        return cl and all(
            c.resides_in is not None and
            c.resides_in.type in (
                'cards', 'showncards', 'equips'
            ) for c in self.associated_cards
        )


@register_character
class Koakuma(Character):
    skills = [Find]
    eventhandlers_required = []
    maxlife = 4

########NEW FILE########
__FILENAME__ = kogasa
# -*- coding: utf-8 -*-

from game.autoenv import Game, EventHandler, user_input
from .baseclasses import Character, register_character
from ..actions import Damage, DrawCards, DrawCardStage, migrate_cards
from ..actions import random_choose_card, UserAction, user_choose_players
from ..cards import Card, Skill, t_None, t_One, t_OtherOne
from ..inputlets import ChooseOptionInputlet, ChoosePeerCardInputlet


class Jolly(Skill):
    associated_action = None
    target = t_None


class Surprise(UserAction):
    def apply_action(self):
        src = self.source
        tgt = self.target
        options = (
            Card.SPADE, Card.HEART,
            Card.CLUB, Card.DIAMOND,
        )

        suit = user_input([tgt], ChooseOptionInputlet(self, options))
        card = user_input([tgt], ChoosePeerCardInputlet(self, src, ('cards', 'showncards')))
        card = card or random_choose_card([src.cards, src.showncards])

        src.tags['surprise_tag'] = src.tags['turn_count']
        assert card

        g = Game.getgame()
        g.players.exclude(src).reveal(card)
        migrate_cards([card], tgt.showncards)

        if card.suit != suit:
            g.process_action(Damage(src, tgt))
            rst = True
        else:
            rst = False

        g.process_action(DrawCards(src, 1))

        return rst

    def is_valid(self):
        src = self.source
        if self.associated_card.associated_cards: return False
        if src.tags.get('turn_count', 0) <= src.tags.get('surprise_tag', 0):
            return False
        if not (src.cards or src.showncards):
            return False
        return True


class SurpriseSkill(Skill):
    associated_action = Surprise
    target = t_OtherOne

    def check(self):
        return not self.associated_cards


class JollyDrawCard(DrawCards):
    def __init__(self, source, target):
        self.source = source
        self.target = target
        self.amount = 1


class JollyHandler(EventHandler):
    choose_player_target = t_One

    def handle(self, evt_type, act):
        if evt_type == 'action_after' and isinstance(act, DrawCardStage):
            tgt = act.target

            if not tgt.has_skill(Jolly): return act

            g = Game.getgame()
            pl = user_choose_players(self, tgt, [p for p in g.players if not p.dead])
            if not pl: pl = [tgt]

            p = pl[0]

            g.process_action(JollyDrawCard(tgt, p))

        return act

    def cond(self, cards):
        return not cards

    def choose_player_target(self, tl):
        if not tl: return (tl, False)
        return (tl[-1:], True)


@register_character
class Kogasa(Character):
    skills = [SurpriseSkill, Jolly]
    eventhandlers_required = [JollyHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = kokoro
# -*- coding: utf-8 -*-

from game.autoenv import Game, EventHandler, user_input
from .baseclasses import Character, register_character_to
from ..actions import UserAction, ActionStage, ShowCards, DropCards
from ..actions import migrate_cards, user_choose_cards
from ..cards import Card, Skill, t_None, t_OtherOne
from ..inputlets import ChooseOptionInputlet, HopeMaskInputlet


class HopeMaskAction(UserAction):
    def apply_action(self):
        tgt = self.target
        g = Game.getgame()
        n = 1 + tgt.maxlife - tgt.life
        cards = g.deck.getcards(n)

        tgt.reveal(cards)
        putback, acquire = user_input([tgt], HopeMaskInputlet(self, cards), timeout=20)
        acquire and g.process_action(ShowCards(tgt, acquire))
        migrate_cards(acquire, tgt.cards)

        assert not putback or set(putback) == set(g.deck.getcards(len(putback)))

        deck = g.deck.cards
        for i, c in enumerate(putback):
            deck[i] = c

        assert not putback or putback == g.deck.getcards(len(putback))

        self.acquire = acquire

        return True


class HopeMaskHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_apply' and isinstance(act, ActionStage):
            tgt = act.target
            if not tgt.has_skill(HopeMask): return act
            if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
                return act
            Game.getgame().process_action(HopeMaskAction(tgt, tgt))

        return act


class HopeMask(Skill):
    associated_action = None
    target = t_None


class DarkNohAction(UserAction):
    card_usage = 'drop'

    def apply_action(self):
        src = self.source
        tgt = self.target
        g = Game.getgame()

        src.tags['darknoh_tag'] = src.tags['turn_count']
        sk = self.associated_card
        card = sk.associated_cards[0]
        self.card = card
        migrate_cards([sk], tgt.showncards, unwrap=True)
        self.n = n = len(tgt.cards) + len(tgt.showncards) - tgt.life
        if n <= 0: return True

        cards = user_choose_cards(self, tgt, ('cards', 'showncards'))
        if not cards:
            cl = list(tgt.cards) + list(tgt.showncards)
            try:
                cl.remove(card)
            except:
                pass

            cards = cl[:n]

        g.players.reveal(cards)
        g.process_action(DropCards(tgt, cards))

        return True

    def cond(self, cards):
        if len(cards) != self.n or self.card in cards:
            return False

        tgt = self.target
        if not all([c in tgt.cards or c in tgt.showncards for c in cards]):
            return False

        return True

    def is_valid(self):
        src = self.source
        tgt = self.target

        if src.tags['darknoh_tag'] >= src.tags['turn_count']:
            return False

        if src.life > tgt.life:
            return False

        return True


class DarkNoh(Skill):
    no_drop = True
    associated_action = DarkNohAction
    target = t_OtherOne
    usage = 'handover'

    def check(self):
        cards = self.associated_cards
        if len(cards) != 1: return False
        c = cards[0]
        if c.resides_in is None: return False
        if not c.resides_in.type in ('cards', 'showncards', 'equips'): return False
        if c.suit not in (Card.SPADE, Card.CLUB): return False
        return True


@register_character_to('common', '-raid')
class Kokoro(Character):
    skills = [HopeMask, DarkNoh]
    eventhandlers_required = [HopeMaskHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = komachi
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, Game, user_input
from .baseclasses import Character, register_character
from ..actions import Damage, DrawCards, DropCards, GenericAction, LaunchCard, MaxLifeChange, migrate_cards, PlayerTurn, random_choose_card, UserAction
from ..cards import Skill, t_None, t_OtherOne, Heal
from ..inputlets import ChooseOptionInputlet, ChoosePeerCardInputlet


class RiversideAction(UserAction):
    def apply_action(self):
        g = Game.getgame()
        src = self.source
        tgt = self.target
        src.tags['riverside_tag'] = src.tags['turn_count']
        tgt.tags['riverside_target'] = g.turn_count
        minhp = min([p.life for p in g.players if not p.dead])
        if tgt.life == minhp:
            has_card = tgt.cards or tgt.showncards or tgt.equips
            if has_card and user_input([src], ChooseOptionInputlet(self, ('drop', 'draw'))) == 'drop':
                self.action = 'drop'
                catnames = ('cards', 'showncards', 'equips')
                card = user_input([src], ChoosePeerCardInputlet(self, tgt, catnames))
                card = card or random_choose_card([tgt.cards, tgt.showncards, tgt.equips])
                g.players.reveal(card)
                g.process_action(DropCards(tgt, [card]))
            else:
                self.action = 'draw'
                g.process_action(DrawCards(src, 1))

        return True

    def is_valid(self):
        src = self.source
        # Fire with Exinwan -> dead -> skills cleared -> assertion fail
        # assert src.has_skill(Riverside)
        return not src.tags['riverside_tag'] >= src.tags['turn_count']


class RiversideHandler(EventHandler):
    def handle(self, evt_type, arg):
        if evt_type == 'calcdistance':
            src, card, dist = arg
            if not src.has_skill(Riverside): return arg
            
            turn_count = Game.getgame().turn_count
            for p in dist:
                if p.tags.get('riverside_target') == turn_count:
                    dist[p] -= 10000

        return arg


class Riverside(Skill):
    associated_action = RiversideAction
    target = t_OtherOne
    usage = 'drop'

    def check(self):
        cl = self.associated_cards
        if len(cl) != 1: return False
        return cl[0].resides_in.type in ('cards', 'showncards', 'equips')


class ReturningAwake(GenericAction):
    def apply_action(self):
        g = Game.getgame()
        tgt = self.target
        tgt.skills.remove(Returning)
        tgt.skills.append(FerryFee)
        g.process_action(MaxLifeChange(tgt, tgt, -1))

        return True


class ReturningHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, PlayerTurn):
            tgt = act.target
            if not tgt.has_skill(Returning): return act
            g = Game.getgame()
            ncards = len(tgt.cards) + len(tgt.showncards)
            if tgt.life <= 2 and tgt.life < ncards:
                g.process_action(ReturningAwake(tgt, tgt))

        return act


class Returning(Skill):
    associated_action = None
    target = t_None


class FerryFee(Skill):
    associated_action = None
    target = t_None
    distance = 1


class FerryFeeEffect(UserAction):
    def __init__(self, source, target, card):
        self.source = source
        self.target = target
        self.card = card

    def apply_action(self):
        src = self.source
        card = self.card
        src.reveal(card)
        migrate_cards([card], src.cards, unwrap=True)
        return True


class FerryFeeHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_after' and isinstance(act, Damage):
            src = act.source
            tgt = act.target
            if not (src and src.has_skill(FerryFee)): return act
            if not (tgt.cards or tgt.showncards or tgt.equips): return act
            dist = LaunchCard.calc_distance(src, FerryFee(src))
            if not dist.get(tgt, 10000) <= 0: return act
            if user_input([src], ChooseOptionInputlet(self, (False, True))):
                catnames = ('cards', 'showncards', 'equips')
                card = user_input([src], ChoosePeerCardInputlet(self, tgt, catnames))
                card = card or random_choose_card([tgt.cards, tgt.showncards, tgt.equips])
                if not card: return act
                g = Game.getgame()
                g.process_action(FerryFeeEffect(src, tgt, card))

        return act


@register_character
class Komachi(Character):
    skills = [Riverside, Returning]
    eventhandlers_required = [RiversideHandler, ReturningHandler, FerryFeeHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = mamizou
# -*- coding: utf-8 -*-

from ..actions import ActionStageLaunchCard
from .baseclasses import Character, register_character_to
from ..cards import Card, TreatAsSkill, DummyCard
from game.autoenv import EventHandler


class Morphing(TreatAsSkill):

    @property
    def treat_as(self):
        return self.get_morph_cls() or DummyCard

    def check(self):
        cl = self.associated_cards

        if not all(
            c.resides_in is not None and
            c.resides_in.type in ('cards', 'showncards')
            for c in cl
        ): return False

        return self.is_morph_valid()

    def is_morph_valid(self):
        cls = self.get_morph_cls()
        if not cls or 'delayed_spellcard' in cls.category:
            return False

        cl = self.associated_cards
        cats = set(cl[0].category)
        cats.update(cl[1].category)

        if 'skill' in cats:
            return False

        if not cats & set(cls.category) & {'basic', 'spellcard'}:
            return False

        return True

    def get_morph_cls(self):
        params = getattr(self, 'action_params', {})
        return Card.card_classes.get(params.get('mamizou_morphing'))


class MorphingHandler(EventHandler):
    def handle(self, evt_type, arg):
        if evt_type == 'action_after' and isinstance(arg, ActionStageLaunchCard):
            c = arg.card
            if c.is_card(Morphing):
                src = arg.source
                src.tags['mamizou_morphing_tag'] = src.tags['turn_count']

        elif evt_type == 'action_can_fire':
            act, valid = arg
            if isinstance(act, ActionStageLaunchCard):
                c = act.card
                if c.is_card(Morphing):
                    t = act.source.tags
                    if t['mamizou_morphing_tag'] >= t['turn_count']:
                        return act, False

        return arg


@register_character_to('common', '-kof')
class Mamizou(Character):
    skills = [Morphing]
    eventhandlers_required = [MorphingHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = marisa
# -*- coding: utf-8 -*-
from game.autoenv import Game, user_input
from .baseclasses import Character, register_character
from ..actions import UserAction, migrate_cards, random_choose_card, LaunchCard
from ..cards import Skill, AttackCard, t_OtherOne, TreatAsSkill
from ..inputlets import ChoosePeerCardInputlet


class Daze(TreatAsSkill):
    treat_as = AttackCard
    distance = 99999

    def check(self):
        if self.associated_cards: return False
        return True


class BorrowAction(UserAction):
    def apply_action(self):
        src = self.source
        tgt = self.target
        g = Game.getgame()

        c = user_input([src], ChoosePeerCardInputlet(self, tgt, ('cards', 'showncards', 'equips')))
        c = c or random_choose_card([tgt.cards, tgt.showncards])
        if not c: return False
        src.reveal(c)
        migrate_cards([c], src.cards)
        src.tags['borrow_tag'] = src.tags['turn_count']

        g.process_action(LaunchCard(tgt, [src], Daze(tgt)))

        return True

    def is_valid(self):
        src = self.source
        tgt = self.target
        if src.tags['turn_count'] <= src.tags['borrow_tag']:
            return False

        if not (tgt.cards or tgt.showncards or tgt.equips):
            return False

        return True


class Borrow(Skill):
    associated_action = BorrowAction
    target = t_OtherOne

    def check(self):
        if self.associated_cards: return False
        return True


@register_character
class Marisa(Character):
    skills = [Borrow]
    eventhandlers_required = []
    maxlife = 4

########NEW FILE########
__FILENAME__ = medicine
# -*- coding: utf-8 -*-
from ..actions import Damage, DrawCardStage, DrawCards, DropCards, FatetellStage, PlayerTurn
from ..actions import UserAction, GenericAction, user_choose_cards, ShowCards
from ..cards import Wine, Skill, t_None, Card, SoberUp, VirtualCard
from ..inputlets import ChooseOptionInputlet
from .baseclasses import Character, register_character
from game.autoenv import EventHandler, Game, user_input


class Ciguatera(Skill):
    associated_action = None
    target = t_None


class CiguateraAction(UserAction):
    def __init__(self, source, target, cards):
        self.source = source
        self.target = target
        self.cards = cards

    def apply_action(self):
        tgt = self.target
        src = self.source
        g = Game.getgame()
        g.process_action(DropCards(src, self.cards))
        g.process_action(Wine(tgt, tgt))
        tags = tgt.tags
        tags['ciguatera_tag'] = g.turn_count
        tags['ciguatera_src'] = src

        return True


class CiguateraTurnEnd(GenericAction):
    card_usage = 'drop'

    def apply_action(self):
        src = self.source
        tgt = self.target
        g = Game.getgame()
        g.process_action(SoberUp(src, src))
        
        draw = DrawCards(tgt, amount=1)
        
        if draw.can_fire():
            cards = user_choose_cards(self, src, ('cards', 'showncards'))
        else:
            cards = None

        if cards:
            assert len(cards) == 1
            self.card = cards[0]
            g.process_action(DropCards(src, cards))
            g.process_action(draw)
        else:
            self.card = None
            g.process_action(Damage(None, src))

        return True

    def cond(self, cl):
        return len(cl) == 1

    def is_valid(self):
        return self.source.tags.get('wine', False)


class CiguateraHandler(EventHandler):
    card_usage = 'drop'

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, FatetellStage):
            g = Game.getgame()
            for p in g.players:
                if p.dead: continue
                if not p.has_skill(Ciguatera): continue

                cards = user_choose_cards(self, p, ('cards', 'showncards'))
                if cards:
                    g.process_action(CiguateraAction(p, act.target, cards))

        if evt_type == 'action_after' and isinstance(act, PlayerTurn):
            tgt = act.target
            tags = tgt.tags
            g = Game.getgame()
            if tags.get('ciguatera_tag') == g.turn_count:
                src = tgt.tags['ciguatera_src']
                g.process_action(CiguateraTurnEnd(tgt, src))

        return act

    def cond(self, cl):
        if len(cl) != 1:
            return False

        return cl[0].resides_in.type in ('cards', 'showncards')


class Melancholy(Skill):
    associated_action = None
    target = t_None


class MelancholyAction(GenericAction):
    def __init__(self, source, target, amount):
        self.source = source
        self.target = target
        self.amount = amount

    def apply_action(self):
        src = self.source
        tgt = self.target
        draw = DrawCards(src, self.amount)
        g = Game.getgame()
        g.process_action(draw)
        g.process_action(ShowCards(src, draw.cards))
        if [c for c in draw.cards if c.suit != Card.CLUB]:  # any non-club
            tgt.tags['melancholy_tag'] = g.turn_count
            self.effective = True

        else:
            self.effective = False

        return True 


class MelancholyHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_after' and isinstance(act, Damage):
            tgt = act.target
            src = act.source

            if not src: return act
            if not tgt.has_skill(Melancholy): return act

            if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
                return act

            Game.getgame().process_action(MelancholyAction(tgt, src, amount=act.amount))

        elif evt_type == 'action_limit':
            arg, permitted = act
            if not permitted: return act
            if arg.usage not in ('use', 'launch'): return act

            src = arg.actor
            g = Game.getgame()
            if src.tags.get('melancholy_tag') == g.turn_count:
                cards = VirtualCard.unwrap(arg.cards)
                zone = src.cards, src.showncards
                return arg, all([c.resides_in not in zone for c in cards])

        return act

@register_character
class Medicine(Character):
    skills = [Ciguatera, Melancholy]
    eventhandlers_required = [CiguateraHandler, MelancholyHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = meirin
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, Game, user_input
from .baseclasses import Character, register_character
from ..actions import DropCards, GenericAction, MaxLifeChange, random_choose_card, PlayerTurn
from ..cards import AttackCard, BaseAttack, DummyCard, GrazeCard, LaunchGraze, Skill, t_None, TreatAsSkill
from ..inputlets import ChooseOptionInputlet, ChoosePeerCardInputlet


class LoongPunch(Skill):
    associated_action = None
    target = t_None


class Taichi(TreatAsSkill):
    @property
    def treat_as(self):
        cl = self.associated_cards
        if not cl: return DummyCard
        c = cl[0]
        if c.is_card(GrazeCard):
            return AttackCard
        if c.is_card(AttackCard):
            return GrazeCard
        return DummyCard

    def check(self):
        cl = self.associated_cards
        if not cl or len(cl) != 1: return False
        c = cl[0]
        if not (c.is_card(AttackCard) or c.is_card(GrazeCard)): return False
        return c.resides_in is not None and c.resides_in.type in (
            'cards', 'showncards',
        )


class RiverBehind(Skill):
    associated_action = None
    target = t_None


class LoongPunchAction(GenericAction):
    def __init__(self, source, target, _type):
        self.source = source
        self.target = target
        self.type = _type

    def apply_action(self):
        g = Game.getgame()
        src = self.source
        tgt = self.target
        c = user_input([src], ChoosePeerCardInputlet(self, tgt, ('cards', 'showncards')))
        c = c or random_choose_card([tgt.cards, tgt.showncards])
        if not c: return False
        g.players.exclude(tgt).reveal(c)
        g.process_action(DropCards(tgt, [c]))
        return True


class LoongPunchHandler(EventHandler):
    execute_after = ('DeathSickleHandler', )

    def handle(self, evt_type, act):
        if evt_type == 'action_after' and isinstance(act, LaunchGraze):
            if not act.succeeded: return act
            g = Game.getgame()
            pact = g.action_stack[-1]
            if not isinstance(pact, BaseAttack): return act
            self.do_effect(pact.source, pact.target, 'attack')
            self.do_effect(pact.target, pact.source, 'graze')

        return act

    def do_effect(self, src, tgt, _type):
        if not src.has_skill(LoongPunch): return
        if not (tgt.cards or tgt.showncards): return
        if not user_input([src], ChooseOptionInputlet(self, (False, True))): return

        g = Game.getgame()
        g.process_action(LoongPunchAction(src, tgt, _type))


class RiverBehindAwake(GenericAction):
    def apply_action(self):
        tgt = self.target
        assert tgt.has_skill(RiverBehind)
        tgt.skills.remove(RiverBehind)
        tgt.skills.append(Taichi)
        g = Game.getgame()
        g.process_action(MaxLifeChange(tgt, tgt, -1))
        return True


class RiverBehindHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_apply' and isinstance(act, PlayerTurn):
            tgt = act.target
            if not tgt.has_skill(RiverBehind): return act
            g = Game.getgame()
            if tgt.life <= 2 and tgt.life <= min(p.life for p in g.players if not p.dead):
                g.process_action(RiverBehindAwake(tgt, tgt))
        return act


@register_character
class Meirin(Character):
    skills = [LoongPunch, RiverBehind]
    eventhandlers_required = [RiverBehindHandler, LoongPunchHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = minoriko
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, Game
from .baseclasses import Character, register_character
from ..actions import LaunchCard, DrawCardStage, migrate_cards
from ..cards import Harvest, HarvestCard, Skill, t_AllInclusive, t_None, Card


class Foison(Skill):
    associated_action = None
    target = t_None


class FoisonDrawCardStage(DrawCardStage):
    def apply_action(self):
        self.amount = max(self.amount, 5 - len(self.target.cards) - len(self.target.showncards))
        return DrawCardStage.apply_action(self)


class FoisonHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, DrawCardStage):
            tgt = act.target
            if tgt.has_skill(Foison):
                act.__class__ = FoisonDrawCardStage
        return act


class AutumnFeastAction(Harvest):
    def apply_action(self):
        tags = self.source.tags
        tags['autumnfeast_tag'] = tags['turn_count']
        return Harvest.apply_action(self)

    def is_valid(self):
        tags = self.source.tags
        if tags['turn_count'] <= tags['autumnfeast_tag']:
            return False
        return Harvest.is_valid(self)


class AutumnFeast(Skill):
    associated_action = AutumnFeastAction
    target = t_AllInclusive
    usage = 'launch'

    def check(self):
        cl = self.associated_cards
        if cl and len(cl) == 2 and all(c.color == Card.RED for c in cl):
            return True
        return False


class AkiTribute(Skill):
    associated_action = None
    target = t_None


class AkiTributeHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'choose_target':
            act, tl = arg = act
            card = act.card
            if not card.is_card(HarvestCard): return arg
            pl = [p for p in tl if p.has_skill(AkiTribute) and not p.dead]
            assert len(pl) <= 1, 'Multiple AkiTributes!'
            if not pl: return arg
            p = pl[0]
            tl.remove(p)
            tl.insert(0, p)
            return act, tl

        elif evt_type == 'harvest_finish':
            g = Game.getgame()
            pl = [p for p in g.players if p.has_skill(AkiTribute) and not p.dead]
            assert len(pl) <= 1, 'Multiple AkiTributes!'
            if not pl: return act
            p = pl[0]
            migrate_cards([
                c for c in act.cards
                if c.resides_in is g.deck.disputed
            ], p.showncards)

        return act


@register_character
class Minoriko(Character):
    skills = [Foison, AutumnFeast, AkiTribute]
    eventhandlers_required = [FoisonHandler, AkiTributeHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = mokou
# -*- coding: utf-8 -*-

from game.autoenv import Game, EventHandler, user_input
from .baseclasses import Character, register_character
from ..actions import UserAction, FatetellStage, DropCards, DrawCards, LifeLost, PlayerTurn
from ..actions import user_choose_cards
from ..cards import Card, Skill, t_None
from ..cards.basic import Heal
from ..inputlets import ChooseOptionInputlet


class Ashes(Skill):
    associated_action = None
    target = t_None


class Reborn(Skill):
    associated_action = None
    target = t_None


class AshesAction(UserAction):
    def __init__(self, target):
        self.source = self.target = target

    def apply_action(self):
        tgt = self.target
        g = Game.getgame()
        g.process_action(LifeLost(tgt, tgt))
        g.process_action(DrawCards(tgt))
        return True


class RebornAction(UserAction):
    def __init__(self, target):
        self.source = self.target = target

    def apply_action(self):
        tgt = self.target
        g = Game.getgame()
        g.process_action(Heal(tgt, tgt))
        return True


class AshesHandler(EventHandler):
    execute_before = ('CiguateraHandler', )
    
    def handle(self, evt_type, act):
        if evt_type == 'action_after' and isinstance(act, PlayerTurn):
            tgt = act.target
            if tgt.dead or not tgt.has_skill(Ashes): return act
            if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
                return act

            Game.getgame().process_action(AshesAction(tgt))

        return act


class RebornHandler(EventHandler):
    execute_before = ('CiguateraHandler', )
    card_usage = 'drop'
    
    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, FatetellStage):
            self.target = tgt = act.target
            if not tgt.has_skill(Reborn): return act
            cards = user_choose_cards(self, tgt, ('cards', 'showncards', 'equips'))
            if cards:
                g = Game.getgame()
                g.process_action(DropCards(tgt, cards))
                g.process_action(RebornAction(tgt))

        return act

    def cond(self, cards):
        if len(cards) != self.target.life: return False

        for card in cards:
            if card.color != Card.RED: return False

            if not card.resides_in.type in ('cards', 'showncards', 'equips'):
                return False

        return True


@register_character
class Mokou(Character):
    skills = [Reborn, Ashes]
    eventhandlers_required = [AshesHandler, RebornHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = momiji
# -*- coding: utf-8 -*-

from game.autoenv import Game, EventHandler, user_input
from .baseclasses import Character, register_character
from ..actions import user_choose_cards, Damage, LaunchCard
from ..cards import Card, AttackCard, RedUFOSkill, BaseAttack, Attack, Skill, t_None, t_OtherOne, TreatAsSkill
from ..inputlets import ChooseOptionInputlet


class SentryHandler(EventHandler):
    execute_after = (
        'RepentanceStickHandler',
        'UmbrellaHandler',
    )
    card_usage = 'launch'

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, Damage):
            g = Game.getgame()
            pact = g.action_stack[-1]
            pcard = getattr(pact, 'associated_card', None)
            if not pcard: return act
            if pcard.is_card(SentryAttack):
                # Sentry effect
                src = pact.source
                if not src.dead and user_input([src], ChooseOptionInputlet(self, (False, True))):
                    # Guard
                    dmg = pcard.target_damage
                    dmg.amount = max(0, dmg.amount - 1)
                    act.cancelled = True
                else:
                    # Attack
                    pass

            elif pcard.is_card(AttackCard) and isinstance(pact, BaseAttack):
                # Sentry fire
                for p in g.players:
                    if p.dead: continue
                    if not p.has_skill(Sentry): continue
                    if p is pact.source: continue

                    tgt = pact.source
                    self.target = tgt  # for ui
                    dist = LaunchCard.calc_distance(p, AttackCard())
                    if dist.get(tgt, 1) > 0: continue
                    cl = user_choose_cards(self, p, ('cards', 'showncards', 'equips'))
                    if not cl: continue
                    c = SentryAttack.wrap(cl, p)
                    c.target_damage = act
                    g.process_action(LaunchCard(p, [tgt], c))
            else:
                return act

        return act

    def cond(self, cl):
        if not len(cl) == 1: return False
        c = cl[0]
        if not (c.is_card(AttackCard) or c.suit == Card.CLUB):
            return False

        return True


class SentryAttack(TreatAsSkill):
    treat_as = AttackCard


class Sentry(Skill):
    associated_action = None
    target = t_None


class SharpEye(RedUFOSkill):
    increment = 1


@register_character
class Momiji(Character):
    skills = [Sentry, SharpEye]
    eventhandlers_required = [SentryHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = nazrin
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, Game, user_input
from .baseclasses import Character, register_character
from ..actions import FatetellAction, Fatetell, FatetellStage, migrate_cards
from ..cards import Card, Skill, TreatAsSkill, GrazeCard, t_None
from ..inputlets import ChooseOptionInputlet


class TreasureHunt(FatetellAction):
    def apply_action(self):
        tgt = self.target
        ft = Fatetell(tgt, lambda c: c.suit in (Card.SPADE, Card.CLUB))
        g = Game.getgame()
        if g.process_action(ft):
            self.card = c = ft.card
            migrate_cards([c], tgt.cards)
            return True

        return False


class TreasureHuntSkill(Skill):
    associated_action = None
    target = t_None


class TreasureHuntHandler(EventHandler):
    execute_before = ('CiguateraHandler', )
    
    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, FatetellStage):
            tgt = act.target
            if not tgt.has_skill(TreasureHuntSkill): return act
            g = Game.getgame()
            while True:
                if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
                    return act
                if not g.process_action(TreasureHunt(tgt, tgt)):
                    return act
        return act


class Agile(TreatAsSkill):
    treat_as = GrazeCard

    def check(self):
        cl = self.associated_cards
        return (
            cl and len(cl) == 1 and
            cl[0].suit in (Card.SPADE, Card.CLUB) and
            cl[0].resides_in.type in ('cards', 'showncards')
        )


@register_character
class Nazrin(Character):
    skills = [TreasureHuntSkill, Agile]
    eventhandlers_required = [TreasureHuntHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = parsee
# -*- coding: utf-8 -*-
from game.autoenv import Game, user_input
from .baseclasses import Character, register_character
from ..actions import EventHandler, UserAction, migrate_cards, LaunchCard
from ..cards import Card, TreatAsSkill, DemolitionCard, DummyCard, Demolition

from ..inputlets import ChooseOptionInputlet


class Envy(TreatAsSkill):
    treat_as = DemolitionCard

    def check(self):
        cards = self.associated_cards
        if len(cards) != 1: return False
        c = cards[0]
        if c.resides_in is None: return False
        if not c.resides_in.type in ('cards', 'showncards', 'equips'): return False
        if c.suit not in (Card.SPADE, Card.CLUB): return False
        return True


class EnvyRecycleAction(UserAction):
    def __init__(self, source, target, card):
        self.source = source
        self.target = target
        self.card = card

    def apply_action(self):
        card = self.card
        assert not card.resides_in or card.resides_in.owner is None
        migrate_cards([card], self.source.cards, unwrap=True)
        return True


class EnvyRecycle(DummyCard):
    distance = 1


class EnvyHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type != 'action_after': return act
        if not isinstance(act, Demolition): return act
        if not act.associated_card.is_card(Envy): return act

        src = act.source
        tgt = act.target
        self.card = card = act.card

        if src.dead: return act
        if card.suit != Card.DIAMOND: return act

        dist = LaunchCard.calc_distance(src, EnvyRecycle())
        if not dist[tgt] <= 0: return act

        if not user_input([src], ChooseOptionInputlet(self, (False, True))):
            return act

        g = Game.getgame()
        g.process_action(EnvyRecycleAction(src, tgt, card))

        return act


@register_character
class Parsee(Character):
    skills = [Envy]
    eventhandlers_required = [EnvyHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = patchouli
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, Game
from .baseclasses import Character, register_character
from ..actions import DrawCards, GenericAction
from ..cards import Card, Skill, RejectCard, SpellCardAction, t_None


class Library(Skill):
    associated_action = None
    target = t_None


class Knowledge(Skill):
    associated_action = None
    target = t_None


class LibraryDrawCards(DrawCards):
    pass


class KnowledgeAction(GenericAction):
    def __init__(self, act):
        self.source = self.target = act.target
        self.action = act

    def apply_action(self):
        self.action.cancelled = True
        return True


class PatchouliHandler(EventHandler):
    execute_before = ('RejectHandler', )

    def handle(self, evt_type, act):
        if evt_type == 'choose_target':
            act, tl = arg = act
            src = act.source

            if not src.has_skill(Library):
                return arg

            if 'instant_spellcard' in act.card.category:
                Game.getgame().process_action(LibraryDrawCards(src, 1))

            return arg

        if evt_type == 'action_before':

            if isinstance(act, SpellCardAction) and not act.cancelled:
                tgt = act.target
                if tgt.has_skill(Knowledge):
                    c = getattr(act, 'associated_card', None)
                    if c and c.suit == Card.SPADE and not c.is_card(RejectCard):
                        Game.getgame().process_action(KnowledgeAction(act))

        return act


@register_character
class Patchouli(Character):
    skills = [Library, Knowledge]
    eventhandlers_required = [PatchouliHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = ran
# -*- coding: utf-8 -*-
from game.autoenv import Game, EventHandler, user_input
from .baseclasses import Character, register_character
from ..actions import GenericAction, Damage, user_choose_cards
from ..actions import DropCards, PlayerTurn
from ..cards import Skill, t_None, InstantSpellCardAction, Reject, SpellCardAction
from ..inputlets import ProphetInputlet, ChooseOptionInputlet


class Prophet(Skill):
    associated_action = None
    target = t_None


class ExtremeIntelligence(Skill):
    associated_action = None
    target = t_None


class ProphetAction(GenericAction):
    def apply_action(self):
        tgt = self.target
        g = Game.getgame()
        n = min(len([p for p in g.players if not p.dead]), 5)
        cards = g.deck.getcards(n)

        assert cards == g.deck.getcards(n)

        tgt.reveal(cards)

        upcards, downcards = user_input([tgt], ProphetInputlet(self, cards), timeout=45) or [range(n), []]

        deck = g.deck.cards
        for i, c in enumerate(downcards):
            deck[i] = c
        deck.rotate(-len(downcards))

        for i, c in enumerate(upcards):
            deck[i] = c

        assert g.deck.getcards(len(upcards)) == upcards

        return True


class ProphetHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_apply' and isinstance(act, PlayerTurn):
            tgt = act.target
            if not tgt.has_skill(Prophet): return act
            if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
                return act
            Game.getgame().process_action(ProphetAction(tgt, tgt))

        return act


class ExtremeIntelligenceAction(GenericAction):
    card_usage = 'drop'

    def __init__(self, source, target, act):
        self.source, self.target, self.action = \
            source, act.target, act

    def apply_action(self):
        p = self.source
        cards = user_choose_cards(self, p, ('cards', 'showncards', 'equips'))
        if not cards: return False
        p.tags['ran_ei'] = p.tags['turn_count'] + 1
        g = Game.getgame()
        g.process_action(DropCards(p, cards))

        act = self.action
        nact = act.__class__(source=p, target=act.target)
        try:
            nact.target_list = act.target_list
        except AttributeError:
            pass

        try:
            # this is for actions triggered by ForEach action.
            # Well, actually it's for Harvest since only this
            # uses the attrib
            nact.parent_action = act.parent_action
        except AttributeError:
            pass

        try:
            nact.associated_card = act.associated_card
        except AttributeError:
            pass

        g.process_action(nact)
        return True

    def cond(self, cl):
        return len(cl) == 1


class ExtremeIntelligenceHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_after' and isinstance(act, InstantSpellCardAction):
            if isinstance(act, Reject): return act
            g = Game.getgame()
            target = g.current_turn

            for p in g.players.exclude(target):
                if p.dead: continue
                if not p.has_skill(ExtremeIntelligence): continue
                if p.tags['ran_ei'] >= p.tags['turn_count'] + 1: continue
                
                try:
                    tl = act.target_list
                except AttributeError:
                    tl = [act.target]
                if any(t.dead for t in tl): return act
            
                if not act.can_fire(): return act  # act cannot fire again

                if not user_input([p], ChooseOptionInputlet(self, (False, True))):
                    continue

                g.process_action(ExtremeIntelligenceAction(p, act.target, act))

        elif evt_type == 'game_begin':
            g = Game.getgame()
            for p in g.players:
                if isinstance(p, Ran):
                    p.tags['ran_ei'] = 0  # for ui

        return act


class NakedFox(Skill):
    associated_action = None
    target = t_None


class NakedFoxAction(GenericAction):
    def __init__(self, dmg):
        self.source = self.target = dmg.target
        self.dmgact = dmg
        self.dmgamount = dmg.amount  # for UI

    def apply_action(self):
        self.dmgact.amount -= 1
        return True


class NakedFoxHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, Damage):
            g = Game.getgame()
            tgt = act.target
            if not tgt.has_skill(NakedFox): return act
            pact = g.action_stack[-1]
            if not isinstance(pact, SpellCardAction): return act
            if tgt.cards or tgt.showncards: return act
            if act.amount < 1: return act

            g.process_action(NakedFoxAction(act))
            return act

        return act


@register_character
class Ran(Character):
    skills = [Prophet, ExtremeIntelligence, NakedFox]
    eventhandlers_required = [
        ProphetHandler,
        ExtremeIntelligenceHandler,
        NakedFoxHandler,
    ]
    maxlife = 3

########NEW FILE########
__FILENAME__ = reimu
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, Game
from .baseclasses import Character, register_character
from ..actions import migrate_cards, PlayerRevive, UserAction
from ..cards import Card, Skill, TreatAsSkill, RejectCard, GreenUFOSkill, UFOSkill, t_None


class Flight(GreenUFOSkill):
    @staticmethod
    def increment(src):
        for c in src.equips:
            if issubclass(c.equipment_skill, UFOSkill):
                return 0

        return 1


class SpiritualAttack(TreatAsSkill):
    treat_as = RejectCard

    def check(self):
        cl = self.associated_cards
        if not(cl and len(cl) == 1 and cl[0].color == Card.RED):
            return False

        c = cl[0]
        if c.resides_in is None or c.resides_in.type not in (
            'cards', 'showncards'
        ): return False

        return True


class TributeTarget(Skill):
    associated_action = None
    target = t_None


class TributeAction(UserAction):
    def apply_action(self):
        cl = self.associated_card.associated_cards
        tgt = self.target
        tgt.reveal(cl)
        migrate_cards([self.associated_card], tgt.cards, unwrap=True)
        src = self.source
        src.tags['tribute_tag'] = src.tags['turn_count']
        return True

    def is_valid(self):
        p = self.source

        if p.tags.get('turn_count', 0) <= p.tags.get('tribute_tag', 0):
            return False

        tgt = self.target

        if tgt.dead: return False
        if len(tgt.cards) + len(tgt.showncards) >= tgt.maxlife: return False
        return True


class Tribute(Skill):
    associated_action = TributeAction
    no_drop = True
    no_reveal = True
    usage = 'handover'

    def check(self):
        cl = self.associated_cards
        rst = cl and len(cl) == 1 and (
            cl[0].resides_in is not None and
            cl[0].resides_in.type in ('cards', 'showncards')
        )
        return rst

    @staticmethod
    def target(g, source, tl):
        tl = [t for t in tl if not t.dead and t.has_skill(TributeTarget)]
        try:
            tl.remove(source)
        except ValueError:
            pass
        return (tl[-1:], bool(len(tl)))


class TributeHandler(EventHandler):
    def handle(self, evt_type, arg):
        if evt_type == 'game_begin':
            self.add()

        elif evt_type == 'switch_character':
            cond = any([
                isinstance(p, Character) and p.has_skill(TributeTarget)
                for p in Game.getgame().players
            ])

            self.add() if cond else self.remove()

        elif evt_type == 'action_after' and isinstance(arg, PlayerRevive):
            self.add()

        return arg

    def add(self):
        g = Game.getgame()
        for p in g.players:
            if not isinstance(p, Character): continue
            if p.has_skill(TributeTarget): continue
            if not p.has_skill(Tribute):
                p.skills.append(Tribute)

    def remove(self):
        g = Game.getgame()
        for p in g.players:
            if not isinstance(p, Character): continue
            try:
                p.skills.remove(Tribute)
            except ValueError:
                pass


@register_character
class Reimu(Character):
    #skills = [SealingArraySkill, Flight, TributeTarget]
    skills = [SpiritualAttack, Flight]
    eventhandlers_required = []
    maxlife = 3

########NEW FILE########
__FILENAME__ = remilia
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, Game, user_input
from .baseclasses import Character, register_character
from ..actions import Damage, GenericAction
from ..cards import Skill, t_None, InevitableAttack, Attack, Heal, Card
from ..inputlets import ChooseOptionInputlet


class SpearTheGungnir(Skill):
    associated_action = None
    target = t_None


class SpearTheGungnirAction(GenericAction):
    def __init__(self, act):
        self.act = act
        self.source = act.source
        self.target = act.target

    def apply_action(self):
        self.act.__class__ = InevitableAttack
        return True


class SpearTheGungnirHandler(EventHandler):
    execute_before = ('ScarletRhapsodySwordHandler', )
    execute_after = (
        'HakuroukenEffectHandler',
        'HouraiJewelHandler',
    )

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, Attack):
            src = act.source
            if not src.has_skill(SpearTheGungnir): return act
            if isinstance(act, InevitableAttack): return act

            tgt = act.target

            while True:
                if tgt.life > src.life: break
                if len(tgt.cards) + len(tgt.showncards) < len(src.cards) + len(src.showncards): break
                return act

            if user_input([act.source], ChooseOptionInputlet(self, (False, True))):
                Game.getgame().process_action(SpearTheGungnirAction(act))

        return act


class VampireKiss(Skill):
    associated_action = None
    target = t_None


class VampireKissAction(GenericAction):
    def apply_action(self):
        return Game.getgame().process_action(
            Heal(self.target, self.source)
        )


class VampireKissHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_apply' and isinstance(act, Damage):
            src, tgt = act.source, act.target
            if not (src and src.has_skill(VampireKiss)): return act
            if src.life >= src.maxlife: return act
            g = Game.getgame()
            pact = g.action_stack[-1]
            if not isinstance(pact, Attack): return act
            card = pact.associated_card
            if (not card) or card.color != Card.RED: return act
            g.process_action(VampireKissAction(src, tgt))

        return act


@register_character
class Remilia(Character):
    skills = [SpearTheGungnir, VampireKiss]
    eventhandlers_required = [SpearTheGungnirHandler, VampireKissHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = remilia_ex
# -*- coding: utf-8 -*-

from game.autoenv import Game, EventHandler, user_input
from .baseclasses import Character, register_character_to

from ..actions import UserAction, DropCards, LifeLost, LaunchCard, ForEach, DrawCards, ActionStage, DropCardStage, ask_for_action
from ..actions import random_choose_card, user_choose_cards
from ..cards import Card, Skill, InevitableAttack, AttackCard, DelayedLaunchCard
from ..cards import t_OtherOne, t_None, t_All, VirtualCard
from ..inputlets import ChoosePeerCardInputlet

from ..thbraid import use_faith

from .remilia import SpearTheGungnir, SpearTheGungnirHandler
from .remilia import VampireKiss, VampireKissHandler


class HeartBreakAction(InevitableAttack):
    def __init__(self, source, target):
        self.source = source
        self.target = target
        self.damage = 2

    def apply_action(self):
        use_faith(self.source, 4)
        return InevitableAttack.apply_action(self)


class HeartBreak(Skill):
    associated_action = HeartBreakAction
    target = t_OtherOne

    color = property(lambda _: Card.RED).setter(lambda _, v: None)

    def is_card(self, cls):
        if issubclass(AttackCard, cls): return True
        return isinstance(self, cls)

    def check(self):
        if self.associated_cards: return False
        return len(self.player.faiths) >= 4


class NeverNightAction(UserAction):
    def apply_action(self):
        g = Game.getgame()
        src = self.source
        use_faith(src, 3)
        src.tags['nevernight_tag'] = src.tags['turn_count']

        for p in self.target_list:
            if not (p.cards or p.showncards or p.equips):
                if p.faiths:
                    g.process_action(DropCards(p, p.faiths))
            else:

                catnames = ('cards', 'showncards', 'equips')
                cats = [getattr(p, i) for i in catnames]
                c = user_input([src], ChoosePeerCardInputlet(self, p, catnames))
                c = c or random_choose_card(cats)

                g.players.reveal(c)

                g.process_action(DropCards(p, [c]))

        return True

    def is_valid(self):
        tags = self.source.tags
        return tags['turn_count'] > tags['nevernight_tag']


class NeverNight(Skill):
    associated_action = NeverNightAction
    target = t_All

    def check(self):
        if self.associated_cards: return False
        return len(self.player.faiths) >= 3


class ScarletFogEffect(UserAction):
    card_usage = 'launch'

    def apply_action(self):
        g = Game.getgame()
        p = self.target

        _pl = g.attackers[:]
        _pl.remove(p)
        pl = []
        atkcard = AttackCard()
        for t in _pl:
            if LaunchCard(p, [t], atkcard).can_fire():
                pl.append(t)

        if not pl:
            g.process_action(LifeLost(p, p, 1))
            return True

        _, rst = ask_for_action(self, (p, ), ('cards', 'showncards'), pl)
        if rst:
            c = rst[0][0]; t = rst[1][0]
            g.process_action(LaunchCard(p, [t], c))
        else:
            g.process_action(LifeLost(p, p, 1))

        return True

    def cond(self, cl):
        return len(cl) == 1 and cl[0].is_card(AttackCard)

    def choose_player_target(self, tl):
        if not tl:
            return (tl, False)

        return (tl[-1:], True)


class ScarletFogAction(ForEach):
    action_cls = ScarletFogEffect

    def prepare(self):
        src = self.source
        tags = src.tags
        tags['scarletfog_tag'] = tags['turn_count']

    def is_valid(self):
        tags = self.source.tags
        return tags['turn_count'] > tags['scarletfog_tag']


class ScarletFog(Skill):
    associated_action = ScarletFogAction
    target = t_All
    usage = 'drop'

    def check(self):
        cl = self.associated_cards
        if not len(cl) == 1: return False
        c = cl[0]
        if c.is_card(VirtualCard): return False
        if c.color != Card.RED: return False
        return True


class QueenOfMidnight(Skill):
    associated_action = None
    target = t_None


class QueenOfMidnightHandler(EventHandler):
    execute_after = ('SealingArrayHandler', )

    def handle(self, evt_type, act):
        if evt_type == 'action_apply' and isinstance(act, ActionStage):
            g = Game.getgame()
            tgt = act.target
            if not tgt.has_skill(QueenOfMidnight): return act
            if act.cancelled: return act
            g.process_action(DrawCards(act.target, 4))

        elif evt_type == 'action_before' and isinstance(act, DropCardStage):
            tgt = act.target
            if tgt.has_skill(QueenOfMidnight):
                act.dropn = max(act.dropn - 3, 0)

        return act


class Septet(Skill):
    associated_action = None
    target = t_None


class SeptetHandler(EventHandler):
    card_usage = 'drop'

    def handle(self, evt_type, act):
        if evt_type == 'action_after' and isinstance(act, DelayedLaunchCard):
            src = act.source
            tgt = act.target
            if not tgt.has_skill(Septet): return act
            self.action = act
            cl = user_choose_cards(self, src, ['cards', 'showncards'])
            g = Game.getgame()
            if cl:
                g.process_action(DropCards(src, cl))
            else:
                g.process_action(DropCards(tgt, [act.associated_card]))

        return act

    def cond(self, cl):
        if not len(cl) == 1: return False
        c = cl[0]
        if not c.color == self.action.associated_card.color: return False
        cat = c.category
        return 'skill' not in cat and 'spellcard' in cat


class RemiliaEx2(Character):
    maxlife = 6
    skills = [
        HeartBreak,
        NeverNight,
        VampireKiss,
        SpearTheGungnir,
        ScarletFog,
        QueenOfMidnight,
        Septet,
    ]

    eventhandlers_required = [
        SpearTheGungnirHandler,
        VampireKissHandler,
        QueenOfMidnightHandler,
        SeptetHandler,
    ]


@register_character_to('raid_ex')
class RemiliaEx(Character):
    maxlife = 6
    skills = [NeverNight, SpearTheGungnir, VampireKiss]
    eventhandlers_required = [VampireKissHandler, SpearTheGungnirHandler]

    stage2 = RemiliaEx2

########NEW FILE########
__FILENAME__ = rinnosuke
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, Game
from .baseclasses import Character, register_character
from ..actions import DrawCards, UserAction
from ..cards import Skill, Heal, t_None, t_OtherOne


class Psychopath(Skill):
    associated_action = None
    target = t_None


class NetoruAction(UserAction):
    def apply_action(self):
        g = Game.getgame()
        src = self.source
        src.tags['netoru_tag'] = src.tags['turn_count']
        tgt = self.target
        g.process_action(Heal(src, tgt))
        if src.life < src.maxlife:
            g.process_action(Heal(src, src))
        return True

    def is_valid(self):
        src = self.source
        tgt = self.target
        if src.tags['netoru_tag'] >= src.tags['turn_count']:
            return False
        return not (tgt.dead or tgt.life >= tgt.maxlife)


class Netoru(Skill):
    associated_action = NetoruAction
    target = t_OtherOne
    usage = 'drop'

    def check(self):
        cl = self.associated_cards
        return cl and len(cl) == 2 and all(
            c.resides_in is not None and
            c.resides_in.type in ('cards', 'showncards')
            for c in cl
        )


class PsychopathDrawCards(DrawCards):
    pass


class PsychopathHandler(EventHandler):
    def handle(self, evt_type, args):
        if evt_type == 'card_migration':
            act, cards, _from, to = args
            if _from is not None and _from.type == 'equips':
                src = _from.owner
                if src.has_skill(Psychopath) and not src.dead:
                    g = Game.getgame()
                    g.process_action(PsychopathDrawCards(src, len(cards)*2))
        return args


@register_character
class Rinnosuke(Character):
    skills = [Netoru, Psychopath]
    eventhandlers_required = [PsychopathHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = rumia
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, Game
from .baseclasses import Character, register_character
from ..actions import DrawCards, PlayerTurn, UserAction, user_choose_cards, LaunchCard, Damage
from ..cards import Skill, BaseDuel, t_None, t_OtherN, AttackCard


class DarknessDuel(BaseDuel):
    pass


class DarknessAction(UserAction):
    card_usage = 'launch'

    def apply_action(self):
        attacker, victim = self.target_list
        src = self.source
        g = Game.getgame()
        tags = self.source.tags
        tags['darkness_tag'] = tags['turn_count']

        cards = user_choose_cards(self, attacker, ('cards', 'showncards'))
        if cards:
            c = cards[0]
            g.process_action(LaunchCard(attacker, [victim], c))
        else:
            g.process_action(Damage(src, attacker, 1))

        return True

    def cond(self, cl):
        if len(cl) != 1: return False
        c = cl[0]
        if not c.is_card(AttackCard): return False
        return True

    def is_valid(self):
        tags = self.source.tags
        if tags['turn_count'] <= tags['darkness_tag']:
            return False

        attacker, victim = self.target_list
        if not LaunchCard(attacker, [victim], AttackCard()).can_fire():
            return False

        return True


class Darkness(Skill):
    associated_action = DarknessAction
    target = t_OtherN(2)
    usage = 'drop'

    def check(self):
        cl = self.associated_cards
        if not(cl and len(cl) == 1): return False
        c = cl[0]
        if c.resides_in is None or c.resides_in.type not in (
            'cards', 'showncards', 'equips'
        ): return False
        return True


class Cheating(Skill):
    associated_action = None
    target = t_None


class CheatingDrawCards(DrawCards):
    pass


class CheatingHandler(EventHandler):
    execute_before = ('CiguateraHandler', )
    
    def handle(self, evt_type, act):
        if evt_type == 'action_after' and isinstance(act, PlayerTurn):
            tgt = act.target
            if tgt.has_skill(Cheating) and not tgt.dead:
                g = Game.getgame()
                g.process_action(CheatingDrawCards(tgt, 1))
        return act


@register_character
class Rumia(Character):
    skills = [Darkness, Cheating]
    eventhandlers_required = [CheatingHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = sakuya
# -*- coding: utf-8 -*-

from game.autoenv import EventHandler, Game
from .baseclasses import Character, register_character
from ..actions import ActionStage, FatetellStage, GenericAction
from ..cards import Skill, AttackCard, WearEquipmentAction, TreatAsSkill, t_None


class FlyingKnife(TreatAsSkill):
    treat_as = AttackCard
    distance = 99999

    def check(self):
        cards = self.associated_cards
        if len(cards) != 1: return False
        c = cards[0]
        if c.resides_in is None: return False
        if not c.resides_in.type in ('cards', 'showncards', 'equips'): return False
        act = c.associated_action
        if not (act and issubclass(act, WearEquipmentAction)): return False
        return True


class LunaClockActionStage(GenericAction):
    def apply_action(self):
        tags = self.target.tags
        tags['lunaclock'] = True
        Game.getgame().process_action(ActionStage(self.target))
        tags['lunaclock'] = False
        tags['turn_count'] += 1
        return True


class LunaClock(Skill):
    associated_action = None
    target = t_None


class LunaClockHandler(EventHandler):
    execute_after = ('CiguateraHandler', )
    
    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, FatetellStage):
            src = act.target
            if not src.has_skill(LunaClock): return act
            Game.getgame().process_action(LunaClockActionStage(src, src))
        return act


@register_character
class Sakuya(Character):
    skills = [FlyingKnife, LunaClock]
    eventhandlers_required = [LunaClockHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = sanae
# -*- coding: utf-8 -*-

from game.autoenv import EventHandler, Game, user_input
from .baseclasses import Character, register_character
from ..actions import Damage, DrawCards, DropCards, GenericAction, UserAction, user_choose_players, user_choose_cards
from ..cards import Skill, t_None, t_OtherOne, Attack
from ..inputlets import ChooseOptionInputlet


class DrawingLotAction(UserAction):
    def apply_action(self):
        src = self.source
        tgt = self.target
        tags = src.tags
        tags['drawinglot_tag'] = tags['turn_count']

        g = Game.getgame()
        diff = max(p.life for p in g.players) - tgt.life
        diff = min(diff, 4)
        diff = max(diff, 1)

        g.process_action(DrawCards(tgt, amount=diff))
        self.amount = diff
        return True

    def is_valid(self):
        tags = self.source.tags
        return tags['turn_count'] > tags['drawinglot_tag']


class DrawingLot(Skill):
    associated_action = DrawingLotAction
    target = t_OtherOne

    def check(self):
        if self.associated_cards: return False
        return True


class Miracle(Skill):
    associated_action = None
    target = t_None


class MiracleAction(GenericAction):
    amount = -1
    card_usage = 'drop'

    def apply_action(self):
        tgt = self.target
        amount = tgt.maxlife - tgt.life
        self.amount = amount
        self._do_effect(tgt)

        g = Game.getgame()
        minlife = min([p.life for p in g.players if not p.dead])
        if not tgt.life == minlife: return True

        candidates = [p for p in g.players if p is not tgt and not p.dead]
        pl = user_choose_players(self, tgt, candidates)
        if not pl: return True

        self._do_effect(pl[0])
        return True

    def _do_effect(self, p):
        g = Game.getgame()
        amount = self.amount
        allcards = list(p.showncards) + list(p.cards) + list(p.equips)
        if len(allcards) <= amount:
            cards = allcards
        else:
            cards = user_choose_cards(self, p, ('cards', 'showncards', 'equips'))
            cards = cards or allcards[:amount]

        g.players.reveal(cards)

        g.process_action(DropCards(p, cards))
        g.process_action(DrawCards(p, amount))

    def choose_player_target(self, tl):
        if not tl: return (tl, False)
        return (tl[-1:], True)

    def cond(self, cl):
        if len(cl) != self.amount: return False
        if any(['skill' in c.category for c in cl]): return False
        return True


class MiracleHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_after' and isinstance(act, Damage):
            tgt = act.target
            if not tgt.has_skill(Miracle): return act
            if tgt.dead: return act

            g = Game.getgame()
            pact = g.action_stack[-1]
            if not isinstance(pact, Attack): return act

            if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
                return act

            g.process_action(MiracleAction(tgt, tgt))

        return act


@register_character
class Sanae(Character):
    skills = [DrawingLot, Miracle]
    eventhandlers_required = [MiracleHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = seiga
# -*- coding: utf-8 -*-
from game.autoenv import Game, EventHandler, user_input
from .baseclasses import Character, register_character
from ..actions import migrate_cards, GenericAction, LaunchCard, UserAction
from ..cards import AttackCard, AttackCardHandler, Skill
from ..inputlets import ChooseOptionInputlet


class HeterodoxySkipAction(GenericAction):
    def apply_action(self):
        return True


class HeterodoxyHandler(EventHandler):
    execute_before = ('MaidenCostumeHandler', )

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and hasattr(act, 'parent_action'):
            tgt = act.target
            if not tgt.has_skill(Heterodoxy): return act

            g = Game.getgame()
            for a in reversed(g.action_stack):
                if isinstance(a, HeterodoxyAction):
                    break
            else:
                return act

            if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
                return act

            act.cancelled = True
            g.process_action(HeterodoxySkipAction(tgt, tgt))

        return act


class HeterodoxyAction(UserAction):
    def apply_action(self):
        g = Game.getgame()
        card = self.associated_card.associated_cards[0]
        src = self.source
        victim = self.target
        tgts = self.target_list[1:]

        g.players.reveal(card)
        migrate_cards([self.associated_card], victim.cards, unwrap=migrate_cards.SINGLE_LAYER)

        if card.is_card(AttackCard):
            src.tags['attack_num'] -= 1

        lc = LaunchCard(victim, tgts, card)

        g = Game.getgame()
        g.process_action(lc)

        return True

    def is_valid(self):
        src = self.source
        card = self.associated_card.associated_cards[0]
        if card.is_card(AttackCard) and src.tags['attack_num'] < 1:
            if not AttackCardHandler.is_freeattack(src):
                return False

        victim = self.target
        tgts = self.target_list[1:]
        lc = LaunchCard(victim, tgts, card)
        return lc.can_fire()


class Heterodoxy(Skill):
    no_drop = True
    associated_action = HeterodoxyAction
    usage = 'handover'

    def check(self):
        cl = self.associated_cards
        return (
            cl and len(cl) == 1 and
            cl[0].resides_in.type in ('cards', 'showncards') and
            not cl[0].is_card(Skill) and
            getattr(cl[0], 'associated_action', None)
        )

    def target(self, g, src, tl):
        cl = self.associated_cards
        if not cl: return ([], False)
        c = cl[0]
        tname = c.target.__name__

        tl = [t for t in tl if not t.dead]

        if not tl: return [], False
        if tl[0] is self.player: return [], False

        if tname in ('t_Self', 't_All', 't_AllInclusive'):
            return tl[-1:], True
        else:
            _tl, valid = c.target(g, tl[0], tl[1:])
            return [tl[0]] + _tl, valid


@register_character
class Seiga(Character):
    skills = [Heterodoxy]
    eventhandlers_required = [HeterodoxyHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = seija
# -*- coding: utf-8 -*-

from ..actions import DrawCards, UserAction, LaunchCard, Pindian
from ..cards import Skill, t_None, AttackCard, DuelCard, TreatAsSkill, BaseAttack
from ..inputlets import ChooseOptionInputlet
from .baseclasses import Character, register_character
from game.autoenv import EventHandler, Game, user_input


class InciteAttack(TreatAsSkill):
    treat_as = AttackCard

    def check(self):
        return not self.associated_cards


class InciteFailAttack(TreatAsSkill):
    treat_as = AttackCard
    distance = 99999

    def check(self):
        return not self.associated_cards


class InciteSilentFailAction(UserAction):
    def __init__(self, source, target):
        self.source = source
        self.target = target

    def apply_action(self):
        return True


class InciteAction(UserAction):
    def apply_action(self):
        src = self.source
        tags = src.tags
        tgt, victim = self.target_list

        tags['incite_tag'] = tags['turn_count']

        g = Game.getgame()
        if g.process_action(Pindian(src, tgt)):
            g.process_action(LaunchCard(tgt, [victim], InciteAttack(tgt)))

        else:
            if user_input([tgt], ChooseOptionInputlet(self, (False, True))):
                g.process_action(LaunchCard(tgt, [src], InciteFailAttack(tgt)))
            else:
                g.process_action(InciteSilentFailAction(src, tgt))

        return True

    def is_valid(self):
        src = self.source
        tags = src.tags
        if tags['turn_count'] <= tags['incite_tag']:
            return False

        tgt, victim = self.target_list
        if not Pindian(src, tgt).can_fire(): return False
        return LaunchCard(tgt, [victim], InciteAttack(tgt)).can_fire()


class Incite(Skill):
    associated_action = InciteAction
    usage = 'none'

    def target(self, g, source, tl):
        tl = [t for t in tl if not t.dead]

        if not tl or tl[0] is source:
            return ([], False)

        tl_, valid = AttackCard.target(g, tl[0], tl[1:])
        return tl[:1] + tl_, valid

    def check(self):
        return not self.associated_cards


class Reversal(Skill):
    associated_action = None
    target = t_None


class ReversalDuel(TreatAsSkill):
    treat_as = DuelCard

    def check(self):
        return not self.associated_cards


class ReversalHandler(EventHandler):
    execute_before = (
        'HouraiJewelHandler',
        'RejectHandler',
        'YugiHandler',
    )

    execute_after = (
        'DeathSickleHandler',
        'RoukankenEffectHandler',
    )

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, BaseAttack):
            src = act.source
            tgt = act.target
            g = Game.getgame()

            #if tgt is g.current_turn: return act
            if not tgt.has_skill(Reversal): return act
            if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
                return act

            def nhand(p):
                return len(p.cards) + len(p.showncards)

            g.process_action(DrawCards(tgt, 1))
            if nhand(tgt) > nhand(src):
                g.process_action(LaunchCard(src, [tgt], ReversalDuel(src)))
                act.cancelled = True

        return act


@register_character
class Seija(Character):
    skills = [Incite, Reversal]
    eventhandlers_required = [ReversalHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = shikieiki
# -*- coding: utf-8 -*-

from game.autoenv import Game, EventHandler, user_input
from .baseclasses import Character, register_character
from ..actions import UserAction, DropCards, Damage
from ..actions import migrate_cards, user_choose_cards
from ..cards import Skill, t_None
from ..inputlets import ChooseOptionInputlet, ChoosePeerCardInputlet


class Trial(Skill):
    associated_action = None
    target = t_None


class Majesty(Skill):
    associated_action = None
    target = t_None


class TrialAction(UserAction):
    def __init__(self, source, target, ft, card):
        self.source, self.target, self.ft, self.card = \
            source, target, ft, card

    def apply_action(self):
        g = Game.getgame()
        c = self.card
        g.players.exclude(self.source).reveal(c)
        g.process_action(DropCards(self.source, [c]))
        self.ft.set_card(c)
        return True


class TrialHandler(EventHandler):
    execute_before = ('YinYangOrbHandler', )
    card_usage = 'use'

    def handle(self, evt_type, act):
        if evt_type == 'fatetell':
            g = Game.getgame()
            pl = g.players.rotate_to(act.target)
            for p in pl:
                if p.dead: continue
                if not p.has_skill(Trial): continue

                if not user_input([p], ChooseOptionInputlet(self, (False, True))):
                    return act

                cards = user_choose_cards(self, p, ('cards', 'showncards', 'equips'))
                if cards:
                    c = cards[0]
                    g.process_action(TrialAction(p, act.target, act, c))

        return act

    def cond(self, cards):
        return len(cards) == 1


class MajestyAction(UserAction):
    def apply_action(self):
        src, tgt = self.source, self.target
        c = user_input([src], ChoosePeerCardInputlet(self, tgt, ('cards', 'showncards', 'equips')))
        if not c: return False
        src.reveal(c)
        migrate_cards([c], src.cards)
        return True


class MajestyHandler(EventHandler):
    def handle(self, evt_type, act):
        if not evt_type == 'action_after': return act
        if not isinstance(act, Damage): return act
        src, tgt = act.source, act.target
        if not src: return act

        cats = [
            src.cards, src.showncards, src.equips
        ]

        if not any(cats): return act
        if tgt.dead: return act
        if not tgt.has_skill(Majesty): return act

        if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
            return act

        Game.getgame().process_action(MajestyAction(tgt, src))

        return act


@register_character
class Shikieiki(Character):
    skills = [Trial, Majesty]
    eventhandlers_required = [TrialHandler, MajestyHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = suika
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, Game
from .baseclasses import Character, register_character
from ..actions import DrawCards, GenericAction, MaxLifeChange
from ..cards import Card, Skill, TreatAsSkill, SoberUp, AttackCard, IbukiGourdCard, WineCard, WeaponSkill, WearEquipmentAction, t_None


class Drunkard(TreatAsSkill):
    treat_as = WineCard

    def check(self):
        cl = self.associated_cards
        if not (cl and len(cl) == 1 and cl[0].color == Card.BLACK):
            return False
        if cl[0].resides_in.type not in ('cards', 'showncards', 'equips'):
            return False
        return True


class GreatLandscape(Skill):
    associated_action = None
    target = t_None


class GreatLandscapeHandler(EventHandler):
    def handle(self, evt_type, arg):
        if evt_type == 'calcdistance':
            src, card, dist = arg
            if card.is_card(AttackCard):
                if not src.has_skill(GreatLandscape): return arg

                for s in src.skills:
                    if issubclass(s, WeaponSkill):
                        return arg

                correction = src.maxlife - src.life
                for p in dist:
                    dist[p] -= correction
        return arg


class WineGod(Skill):
    associated_action = None
    target = t_None


class WineDream(Skill):
    associated_action = None
    target = t_None


class WineGodAwake(GenericAction):
    def apply_action(self):
        tgt = self.target
        tgt.skills.remove(WineGod)
        tgt.skills.append(WineDream)
        g = Game.getgame()
        g.process_action(MaxLifeChange(tgt, tgt, -1))
        return True


class WineGodHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_after' and isinstance(act, WearEquipmentAction):
            card = act.associated_card
            if not card.is_card(IbukiGourdCard): return act
            tgt = act.target
            if not tgt.has_skill(WineGod): return act
            g = Game.getgame()
            g.process_action(WineGodAwake(tgt, tgt))
        return act


class WineDreamHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_after' and isinstance(act, SoberUp):
            src = act.source
            if not src.has_skill(WineDream): return act
            g = Game.getgame()
            g.process_action(DrawCards(src, 1))
        return act


@register_character
class Suika(Character):
    skills = [GreatLandscape, Drunkard, WineGod]
    eventhandlers_required = [
        #DrunkardHandler,
        GreatLandscapeHandler,
        WineGodHandler,
        WineDreamHandler
    ]
    maxlife = 4

########NEW FILE########
__FILENAME__ = tenshi
# -*- coding: utf-8 -*-
from game.autoenv import Game, EventHandler, user_input
from ..actions import UserAction, DrawCards, Damage, Fatetell, LaunchCard
from ..actions import ask_for_action, migrate_cards, GenericAction
from ..cards import Skill, t_None, Card
from ..inputlets import ChooseOptionInputlet
from .baseclasses import Character, register_character


class Masochist(Skill):
    associated_action = None
    target = t_None


class MasochistAction(UserAction):
    no_reveal = True
    card_usage = 'handover'

    def __init__(self, target, n):
        self.source, self.target, self.amount = target, target, n

    def apply_action(self):
        g = Game.getgame()
        tgt = self.target
        a = DrawCards(tgt, self.amount * 2)
        g.process_action(a)
        self.cards = cards = a.cards
        n = len(cards)
        while n > 0:
            pl = [p for p in g.players if not p.dead]
            pl.remove(tgt)
            _, rst = ask_for_action(self, [tgt], ('cards',), pl)
            if not rst: return True
            cl, pl = rst
            pl[0].reveal(cl)
            migrate_cards(cl, pl[0].cards)
            n -= len(cl)

        return True

    def cond(self, cl):
        cards = self.cards
        return all(c in cards for c in cl)

    def choose_player_target(self, tl):
        if not tl:
            return (tl, False)

        return (tl[-1:], True)


class MasochistHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_after' and isinstance(act, Damage):
            tgt = act.target
            if tgt.dead: return act
            if not tgt.has_skill(Masochist): return act
            if not act.amount: return act

            if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
                return act

            Game.getgame().process_action(MasochistAction(tgt, act.amount))

        return act


class ScarletPerception(Skill):
    distance = 1
    associated_action = None
    target = t_None


class ScarletPerceptionAction(GenericAction):
    def __init__(self, source, target, card):
        self.source = source
        self.target = target
        self.card = card

    def apply_action(self):
        migrate_cards([self.card], self.source.cards)
        return True


class ScarletPerceptionHandler(EventHandler):
    execute_before = ('YinYangOrbHandler', )
    execute_after = ('TrialHandler', )

    def handle(self, evt_type, act):
        if evt_type == 'action_after' and isinstance(act, Fatetell):
            tgt = act.target
            if act.card.color != Card.RED: return act

            g = Game.getgame()
            pl = [p for p in g.players if p.has_skill(ScarletPerception) and not p.dead]
            assert len(pl) <= 1

            if pl:
                p = pl[0]
                dist = LaunchCard.calc_distance(p, ScarletPerception(p))
                if dist.get(tgt, 1) <= 0:
                    g.process_action(ScarletPerceptionAction(p, tgt, act.card))

        return act


@register_character
class Tenshi(Character):
    skills = [Masochist, ScarletPerception]
    eventhandlers_required = [MasochistHandler, ScarletPerceptionHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = tewi
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, Game
from .baseclasses import Character, register_character
from ..actions import DrawCards, PlayerRevive
from ..cards import Skill, t_None


class Luck(Skill):
    associated_action = None
    target = t_None


class LuckDrawCards(DrawCards):
    pass


class LuckHandler(EventHandler):
    def handle(self, evt_type, arg):
        if evt_type == 'card_migration':
            act, l, _from, to = arg  # (action, cardlist, from, to)
            p = _from.owner
        elif evt_type == 'action_after' and isinstance(arg, PlayerRevive):
            p = arg.target
        elif evt_type == 'choose_target':
            p = arg[0].source
        else:
            p = None

        if p and p.has_skill(Luck) and not p.dead:
            if not (p.cards or p.showncards):
                Game.getgame().process_action(LuckDrawCards(p, 2))
        return arg


@register_character
class Tewi(Character):
    skills = [Luck]
    eventhandlers_required = [LuckHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = youmu
# -*- coding: utf-8 -*-

from game.autoenv import EventHandler, Game, user_input
from .baseclasses import Character, register_character
from ..actions import ActionStage, Damage, DropCards, GenericAction, migrate_cards, random_choose_card, UserAction, MaxLifeChange, MigrateCardsTransaction
from ..cards import Skill, Attack, LaunchGraze, HakuroukenCard, RoukankenCard, WearEquipmentAction, BaseDuel, t_None, UseAttack, Heal, t_Self, AttackCardHandler
from ..inputlets import ChooseIndividualCardInputlet
from utils import classmix


class MijincihangzhanAttack(Attack):
    pass

class MijincihangzhanDuelMixin(object):
    # 迷津慈航斩 弹幕战
    def apply_action(self):
        g = Game.getgame()
        source = self.source
        target = self.target

        d = (source, target)
        dmg = (self.source_damage, self.target_damage)
        while True:
            d = (d[1], d[0])
            dmg = (dmg[1], dmg[0])
            if d[1].has_skill(Nitoryuu):
                if not (
                    g.process_action(UseAttack(d[0])) and
                    g.process_action(UseAttack(d[0]))
                ): break
            else:
                if not g.process_action(UseAttack(d[0])): break

        g.process_action(Damage(d[1], d[0], amount=dmg[1]))
        return d[1] is source


class XianshiwangzhiAwake(GenericAction):
    def apply_action(self):
        g = Game.getgame()
        tgt = self.target
        tgt.skills.append(Xianshiwangzhi)
        tgt.tags['attack_num'] += 1
        g.process_action(MaxLifeChange(tgt, tgt, 1))
        g.process_action(Heal(tgt, tgt, 1))
        return True


class YoumuWearEquipmentAction(UserAction):
    def apply_action(self):
        g = Game.getgame()
        card = self.associated_card
        target = self.target
        equips = target.equips
        g = Game.getgame()
        cat = card.equipment_category

        with MigrateCardsTransaction() as trans:
            if cat == 'weapon':
                weapons = [e for e in equips if e.equipment_category == 'weapon']
                if len(weapons) > 1:
                    e = user_input(
                        [target], ChooseIndividualCardInputlet(self, weapons),
                    ) or random_choose_card([weapons])
                    migrate_cards([e], g.deck.droppedcards, trans=trans)

            else:
                for oc in equips:
                    if oc.equipment_category == cat:
                        migrate_cards([oc], g.deck.droppedcards, trans=trans)
                        break

            migrate_cards([card], target.equips, trans=trans)

        return True


class YoumuHandler(EventHandler):
    execute_before = ('ScarletRhapsodySwordHandler', 'LaevateinHandler', 'HouraiJewelHandler')
    execute_after = ('AttackCardHandler', )

    def handle(self, evt_type, act):
        if evt_type == 'action_before':
            if isinstance(act, Attack):
                if not act.source.has_skill(Mijincihangzhan): return act
                act.__class__ = classmix(MijincihangzhanAttack, act.__class__)
                act.graze_count = 0
            elif isinstance(act, BaseDuel):
                if not isinstance(act, MijincihangzhanDuelMixin):
                    act.__class__ = classmix(MijincihangzhanDuelMixin, act.__class__)
            elif isinstance(act, WearEquipmentAction):
                if not act.source.has_skill(Nitoryuu): return act
                act.__class__ = YoumuWearEquipmentAction

        elif evt_type == 'action_apply' and isinstance(act, ActionStage):
            p = act.target
            p.tags['attack_num'] += p.tags.get('nitoryuu_tag', False)

        elif evt_type == 'card_migration':
            def weapons(cards):
                return [c for c in cards
                        if c.equipment_category == 'weapon']

            act, cards, _from, to = arg = act

            for cl in (_from, to):
                if cl.type != 'equips': continue
                p = cl.owner
                if p.has_skill(Nitoryuu):
                    active = len(weapons(p.equips)) >= 2
                    oactive = p.tags.get('nitoryuu_tag', False)
                    p.tags['attack_num'] += active - oactive
                    p.tags['nitoryuu_tag'] = active

            return arg

        elif evt_type == 'attack_aftergraze':
            act, rst = arg = act
            if rst: return arg
            if not isinstance(act, MijincihangzhanAttack): return arg

            g = Game.getgame() 
            return act, not g.process_action(LaunchGraze(act.target))

        return act


class NitoryuuDropWeapon(UserAction):
    def apply_action(self):
        tgt = self.target
        equips = tgt.equips
        weapons = [e for e in equips if e.equipment_category == 'weapon']
        e = user_input(
            [tgt], ChooseIndividualCardInputlet(self, weapons),
        ) or random_choose_card([weapons])
        g = Game.getgame()
        g.process_action(DropCards(tgt, [e]))

        return True

    def is_valid(self):
        return self.source.tags.get('nitoryuu_tag', False)


class Mijincihangzhan(Skill):
    # 迷津慈航斩
    associated_action = None
    target = t_None


class Nitoryuu(Skill):
    # 二刀流
    associated_action = NitoryuuDropWeapon
    target = t_Self

    def check(self):
        return not self.associated_cards


class Xianshiwangzhi(Skill):
    # 现世妄执
    associated_action = None
    target = t_None


@register_character
class Youmu(Character):
    skills = [Mijincihangzhan, Nitoryuu]
    eventhandlers_required = [YoumuHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = yugi
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, user_input, Game
from .baseclasses import Character, register_character
from ..actions import DropCards, Fatetell, FatetellAction
from ..cards import Card, RedUFOSkill, Skill, t_None, BaseAttack, InevitableAttack
from ..inputlets import ChooseOptionInputlet, ChoosePeerCardInputlet
from utils import classmix


class AssaultSkill(RedUFOSkill):
    increment = 1


class FreakingPowerSkill(Skill):
    associated_action = None
    target = t_None


class FreakingPower(FatetellAction):
    def __init__(self, atkact):
        self.atkact = atkact
        self.source = atkact.source
        self.target = atkact.target

    def apply_action(self):
        act = self.atkact
        src = act.source
        ft = Fatetell(src, lambda c: c.suit in (Card.HEART, Card.DIAMOND))
        g = Game.getgame()
        if g.process_action(ft):
            act.__class__ = classmix(InevitableAttack, act.__class__)
        else:
            act.yugifptag = True
        return True


class YugiHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, BaseAttack) and not hasattr(act, 'yugifptag'):
            src = act.source
            if not src.has_skill(FreakingPowerSkill): return act
            if not user_input([src], ChooseOptionInputlet(self, (False, True))):
                return act
            tgt = act.target
            Game.getgame().process_action(FreakingPower(act))

        elif evt_type == 'action_after' and hasattr(act, 'yugifptag'):
            if not act.succeeded: return act
            src = act.source; tgt = act.target
            g = Game.getgame()
            catnames = ('cards', 'showncards', 'equips')
            card = user_input([src], ChoosePeerCardInputlet(self, tgt, catnames))
            if card:
                g.players.exclude(tgt).reveal(card)
                g.process_action(DropCards(tgt, [card]))

        return act


@register_character
class Yugi(Character):
    skills = [AssaultSkill, FreakingPowerSkill]
    eventhandlers_required = [YugiHandler]
    maxlife = 4

########NEW FILE########
__FILENAME__ = yukari
# -*- coding: utf-8 -*-
from game.autoenv import Game, EventHandler, user_input
from .baseclasses import Character, register_character
from ..actions import UserAction, GenericAction, FatetellStage, DropCards, DrawCardStage, LaunchCard, ActionStage, DropCardStage
from ..actions import user_choose_cards, random_choose_card, migrate_cards, ask_for_action
from ..cards import Skill, t_None
from ..inputlets import ChooseIndividualCardInputlet, ChooseOptionInputlet, ChoosePeerCardInputlet


class Realm(Skill):
    associated_action = None
    target = t_None


class RealmSkipFatetell(UserAction):
    def __init__(self, target, fts):
        self.source = self.target = target
        self.fts = fts

    def apply_action(self):
        self.fts.cancelled = True
        return True


class RealmSkipFatetellHandler(EventHandler):
    execute_after = ('CiguateraHandler', )
    card_usage = 'drop'

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, FatetellStage):
            self.target = tgt = act.target
            if not tgt.has_skill(Realm): return act
            if not tgt.fatetell: return act

            cl = user_choose_cards(self, tgt, ['cards', 'showncards', 'equips'])
            if not cl: return act

            g = Game.getgame()
            g.process_action(DropCards(tgt, cl))
            g.process_action(RealmSkipFatetell(tgt, act))

        return act

    def cond(self, cl):
        if len(cl) != 1: return False
        t = self.target
        if cl[0].resides_in not in (t.cards, t.showncards):
            return False

        return True


class RealmSkipDrawCard(GenericAction):
    def __init__(self, target, dcs, pl):
        self.source = self.target = target
        self.dcs = dcs
        self.pl = pl

    def apply_action(self):
        self.dcs.cancelled = True
        tgt = self.target

        for p in self.pl:
            c = user_input([tgt], ChoosePeerCardInputlet(self, p, ('cards', 'showncards')))
            c = c or random_choose_card([p.cards, p.showncards])
            if not c: continue
            tgt.reveal(c)
            migrate_cards([c], tgt.cards)

        return True


class RealmSkipDrawCardHandler(EventHandler):
    execute_after = ('FrozenFrogHandler', )
    card_usage = 'drop'

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, DrawCardStage):
            if act.cancelled: return act
            self.target = tgt = act.target
            if not tgt.has_skill(Realm): return act

            g = Game.getgame()

            pl = [p for p in g.players if not p.dead and (p.cards or p.showncards)]

            _, rst = ask_for_action(self, [tgt], ('cards', 'showncards', 'equips'), pl)
            if not rst: return act

            cl, pl = rst

            g = Game.getgame()
            g.process_action(DropCards(tgt, cl))
            g.process_action(RealmSkipDrawCard(tgt, act, pl))

        return act

    def cond(self, cl):
        if len(cl) != 1: return False
        t = self.target
        if cl[0].resides_in not in (t.cards, t.showncards):
            return False

        return True

    def choose_player_target(self, tl):
        if not tl:
            return (tl, False)

        return (tl[:2], True)


class RealmSkipAction(UserAction):
    def __init__(self, target, act, pl):
        self.source = self.target = target
        self.act = act
        self.pl = pl

    def apply_action(self):
        self.act.cancelled = True
        _from, _to = self.pl
        tgt = self.target
        from itertools import chain
        allcards = list(chain.from_iterable([_from.equips, _from.fatetell]))

        if not allcards:
            # Dropped by Exinwan
            return False

        card = user_input([tgt], ChooseIndividualCardInputlet(self, allcards))
        if not card:
            card = random_choose_card([_from.equips, _from.fatetell])

        if card.resides_in is _from.fatetell:
            if user_input([tgt], ChooseOptionInputlet(self, (False, True))):
                migrate_cards([card], _to.fatetell)
            else:
                migrate_cards([card], _to.cards, unwrap=True)

        elif card.resides_in is _from.equips:
            cats = set([c.equipment_category for c in _to.equips])
            if (card.equipment_category not in cats and
                user_input([tgt], ChooseOptionInputlet(self, (False, True)))):
                migrate_cards([card], _to.equips)
            else:
                migrate_cards([card], _to.cards)
        else:
            assert False, 'WTF?!'

        return True


class RealmSkipActionHandler(EventHandler):
    execute_after = ('SealingArrayHandler', )
    card_usage = 'drop'

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, ActionStage):
            self.target = tgt = act.target
            if act.cancelled: return act
            if not tgt.has_skill(Realm): return act

            g = Game.getgame()

            pl = [p for p in g.players if not p.dead]

            _, rst = ask_for_action(self, [tgt], ('cards', 'showncards', 'equips'), pl)
            if not rst: return act
            cl, pl = rst
            if len(pl) != 2: return act

            g.process_action(DropCards(tgt, cl))
            g.process_action(RealmSkipAction(tgt, act, pl))

        return act

    def cond(self, cl):
        if len(cl) != 1: return False
        t = self.target
        if cl[0].resides_in not in (t.cards, t.showncards):
            return False

        return True

    def choose_player_target(self, tl):
        if not tl:
            return (tl, False)

        tl = tl[:2]
        return (tl, bool(len(tl) == 2 and (tl[0].equips or tl[0].fatetell)))


class RealmSkipDropCard(UserAction):
    def __init__(self, target, fts):
        self.source = self.target = target
        self.fts = fts

    def apply_action(self):
        self.fts.cancelled = True
        return True


class RealmSkipDropCardHandler(EventHandler):
    execute_after = ('SuwakoHatHandler',)
    card_usage = 'drop'

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, DropCardStage):
            if act.dropn < 1: return act
            self.target = tgt = act.target
            if not tgt.has_skill(Realm): return act

            cl = user_choose_cards(self, tgt, ['cards', 'showncards', 'equips'])
            if not cl: return act

            g = Game.getgame()
            g.process_action(DropCards(tgt, cl))
            g.process_action(RealmSkipDropCard(tgt, act))

        return act

    def cond(self, cl):
        if len(cl) != 1: return False
        t = self.target
        if cl[0].resides_in not in (t.cards, t.showncards):
            return False

        return True


@register_character
class Yukari(Character):
    skills = [Realm]
    eventhandlers_required = [
        RealmSkipFatetellHandler,
        RealmSkipDrawCardHandler,
        RealmSkipActionHandler,
        RealmSkipDropCardHandler,
    ]
    maxlife = 4

########NEW FILE########
__FILENAME__ = yuuka
# -*- coding: utf-8 -*-
from game.autoenv import EventHandler, Game
from .baseclasses import register_character, Character
from ..actions import BaseDamage, GenericAction, TryRevive
from ..cards import Attack, AttackCard, Card, GrazeCard, Skill, t_None, t_OtherOne
from utils import classmix


class FlowerQueen(Skill):
    associated_action = Attack
    target = t_OtherOne
    distance = 1
    usage = 'launch'

    def check(self):
        cl = self.associated_cards
        if not cl or len(cl) != 1: return False
        c = cl[0]
        if not c.suit == Card.CLUB: return False
        return c.resides_in is not None and c.resides_in.type in (
            'cards', 'showncards', 'equips',
        )

    def is_card(self, cls):
        if issubclass(AttackCard, cls) or issubclass(GrazeCard, cls): return True
        return isinstance(self, cls)


class MagicCannon(Skill):
    associated_action = None
    target = t_None


class PerfectKill(Skill):
    associated_action = None
    target = t_None
    distance = 1


class MagicCannonAttack(Attack):
    pass


class PerfectKillAction(GenericAction):
    def __init__(self, source, target, act):
        self.source, self.target, self.act = \
            source, target, act

    def apply_action(self):
        self.act.asklist = [self.source, self.target]
        return True


class YuukaHandler(EventHandler):
    execute_before = ('ScarletRhapsodySwordHandler', )

    def handle(self, evt_type, act):
        if evt_type == 'action_before' and isinstance(act, Attack):
            c = getattr(act, 'associated_card', None)
            if not c: return act
            src = act.source
            if not src.has_skill(MagicCannon): return act
            if c.color == Card.RED:
                act.damage += 1
                act.__class__ = classmix(MagicCannonAttack, act.__class__)

        elif evt_type == 'action_before' and isinstance(act, TryRevive):
            g = Game.getgame()
            dmg = act.dmgact
            assert isinstance(dmg, BaseDamage)
            src = dmg.source
            tgt = dmg.target
            if src != tgt and src and src.has_skill(PerfectKill):
                g.process_action(PerfectKillAction(src, dmg.target, act))

        return act


@register_character
class Yuuka(Character):
    skills = [FlowerQueen, MagicCannon, PerfectKill]
    eventhandlers_required = [YuukaHandler]
    maxlife = 3

########NEW FILE########
__FILENAME__ = common
# -*- coding: utf-8 -*-
import logging
log = logging.getLogger('thb.common')

from game.autoenv import Game, sync_primitive
from utils import Enum


class CharChoice(object):
    real_cls = None
    chosen = False

    def __init__(self, char_cls):
        self.char_cls = char_cls

    def __data__(self):
        return self.char_cls.__name__

    def sync(self, data):
        from .characters.baseclasses import Character
        self.char_cls = Character.character_classes[data]

    def __repr__(self):
        return '<Choice: {}>'.format('None' if not self.char_cls else self.char_cls.__name__)


class PlayerIdentity(object):
    def __init__(self):
        self._type = self.TYPE.HIDDEN

    def __data__(self):
        return ['identity', self.type]

    def __str__(self):
        return self.TYPE.rlookup(self.type)

    def sync(self, data):
        assert data[0] == 'identity'
        self._type = data[1]

    def is_type(self, t):
        g = Game.getgame()
        pl = g.players
        return sync_primitive(self.type == t, pl)

    def set_type(self, t):
        if Game.SERVER_SIDE:
            self._type = t

    def get_type(self):
        return self._type

    type = property(get_type, set_type)


def get_seed_for(p):
    if Game.SERVER_SIDE:
        seed = long(Game.getgame().random.randint(1, 10 ** 20))
    else:
        seed = 0L

    return sync_primitive(seed, p)

########NEW FILE########
__FILENAME__ = inputlets
# -*- coding: utf-8 -*-

# -- stdlib --
import logging
log = logging.getLogger('Inputlets')

# -- third party --
# -- own --
from game import Inputlet
from game.autoenv import Game
from utils import check, check_type, CheckFailed


# -- code --

class ChooseOptionInputlet(Inputlet):
    def init(self, options):
        self.options = options
        self.result = None

    def parse(self, data):
        if data not in self.options:
            return None

        return data

    def data(self):
        return self.result

    def set_option(self, value):
        'For UI'
        self.result = value


class ActionInputlet(Inputlet):
    def init(self, categories, candidates):
        self.categories = categories
        self.candidates = candidates

        self.skills = []
        self.cards = []
        self.players = []
        self.params = {}

    def parse(self, data):
        # data = [
        #     [skill_index1, ...],
        #     [card_syncid1, ...],
        #     [player_id1, ...],
        #     {'action_param1': 'AttackCard'},
        # ]

        actor = self.actor
        g = Game.getgame()
        categories = self.categories
        categories = [getattr(actor, i) for i in categories] if categories else None
        candidates = self.candidates

        skills = []
        cards = []
        players = []
        params = {}

        _ = Ellipsis
        try:
            check_type([[int, _]] * 3 + [dict], data)

            sid_list, cid_list, pid_list, params = data

            if candidates:
                check(candidates)
                pl = [g.player_fromid(i) for i in pid_list]
                check(all([p in candidates for p in pl]))
                players = pl

            if categories:
                cards = g.deck.lookupcards(cid_list)
                check(len(cards) == len(cid_list))  # Invalid id

                cs = set(cards)
                check(len(cs) == len(cid_list))  # repeated ids

                if sid_list:
                    assert actor.cards in categories or actor.showncards in categories
                    check(all(cat.owner is actor for cat in categories))
                    check(all(c.resides_in.owner is actor for c in cards))  # Cards belong to actor?
                    for skill_id in sid_list:
                        check(0 <= skill_id < len(actor.skills))
                    skills = [actor.skills[i] for i in sid_list]
                else:
                    check(all(c.resides_in in categories for c in cards))  # Cards in desired categories?

            return [skills, cards, players, params]

        except CheckFailed:
            return None

    def data(self):
        g = Game.getgame()
        actor_skills = self.actor.skills
        sid_list = [actor_skills.index(s) for s in self.skills]
        cid_list = [c.syncid for c in self.cards]
        pid_list = [g.get_playerid(p) for p in self.players]
        return [sid_list, cid_list, pid_list, self.params]

    def set_result(self, skills, cards, players, params=None):
        self.skills = skills
        self.cards = cards
        self.players = players
        self.params = params or {}


class ChooseIndividualCardInputlet(Inputlet):
    def init(self, cards):
        self.cards = cards
        self.selected = None

    def parse(self, data):
        try:
            cid = data
            check(isinstance(cid, int))
            cards = [c for c in self.cards if c.syncid == cid]
            check(len(cards))  # Invalid id
            return cards[0]

        except CheckFailed:
            return None

    def data(self):
        sel = self.selected
        return sel.syncid if sel else None

    def set_card(self, c):
        assert c in self.cards
        self.selected = c

    def post_process(self, actor, card):
        if card:
            log.debug('ChooseIndividualCardInputlet: detaching %r!', card)
            card.detach()

        return card


class ChoosePeerCardInputlet(Inputlet):
    def init(self, target, categories):
        self.target = target
        self.categories = categories
        self.selected = None

    def parse(self, data):
        target = self.target
        categories = self.categories
        categories = [getattr(target, i) for i in categories]

        assert all(c.owner is target for c in categories)
        try:
            check(sum(len(c) for c in categories))  # no cards at all

            cid = data
            g = Game.getgame()

            check(isinstance(cid, int))

            cards = g.deck.lookupcards((cid,))

            check(len(cards) == 1)  # Invalid id
            card = cards[0]

            check(card.resides_in.owner is target)
            check(card.resides_in in categories)

            return card

        except CheckFailed:
            return None

    def data(self):
        sel = self.selected
        return sel.syncid if sel else None

    def set_card(self, c):
        assert c.resides_in.type in self.categories
        self.selected = c

    def post_process(self, actor, card):
        if card:
            log.debug('ChoosePeerCardInputlet: detaching %r!', card)
            card.detach()

        return card


class ProphetInputlet(Inputlet):
    '''For Ran'''
    def init(self, cards):
        self.cards = cards
        self.upcards = []
        self.downcards = []

    def parse(self, data):
        _ = Ellipsis
        try:
            check_type([[int, _]] * 2, data)
            upcards = data[0]
            downcards = data[1]
            check(sorted(upcards + downcards) == range(len(self.cards)))
        except CheckFailed:
            return [self.cards, []]

        cards = self.cards
        upcards = [cards[i] for i in upcards]
        downcards = [cards[i] for i in downcards]

        return [upcards, downcards]

    def data(self):
        cards = self.cards
        upcards = self.upcards
        downcards = self.downcards
        if not set(cards) == set(upcards + downcards):
            return [range(len(self.cards)), []]

        upcards = [cards.index(c) for c in upcards]
        downcards = [cards.index(c) for c in downcards]
        return [upcards, downcards]

    def set_result(self, upcards, downcards):
        assert set(self.cards) == set(upcards + downcards)
        self.upcards = upcards
        self.downcards = downcards


class ChooseGirlInputlet(Inputlet):
    def init(self, mapping):
        # mapping = {
        #   Player1: [CharChoice1, ...],
        #   ...
        # }
        m = dict(mapping)
        from .common import CharChoice
        for k in m:
            assert all([isinstance(i, CharChoice) for i in m[k]])
            m[k] = m[k][:]

        self.mapping = m
        self.choice = None

    def parse(self, i):
        m = self.mapping
        actor = self.actor
        try:
            check(actor in m)
            check_type(int, i)
            check(0 <= i < len(m[actor]))
            choice = m[actor][i]
            check(not choice.chosen)
            return choice
        except CheckFailed:
            return None

    def data(self):
        if self.choice is None:
            return None

        try:
            return self.mapping[self.actor].index(self.choice)
        except:
            log.exception('WTF?!')
            return None

    def set_choice(self, choice):
        assert choice in self.mapping[self.actor]
        self.choice = choice


class SortCharacterInputlet(Inputlet):
    def init(self, mapping, limit=None):
        # mapping = {
        #   Player1: [CharChoice1, ...],
        #   ...
        # }
        s = set([len(l) for l in mapping.values()])
        assert(len(s) == 1)
        self.num = n = s.pop()
        self.limit = limit if n >= limit else n
        self.mapping = mapping
        self.result = range(n)

    def parse(self, data):
        n = self.num
        try:
            check(data)
            check_type([int] * n, data)
            check(set(data) == set(range(n)))
            return data

        except CheckFailed:
            return range(n)

    def data(self):
        assert set(self.result) == set(range(self.num))
        return self.result

    def set_result(self, result):
        assert set(result) == set(range(self.num))
        self.result = result


class HopeMaskInputlet(Inputlet):
    '''For Kokoro'''
    def init(self, cards):
        self.cards = cards
        self.putback = []
        self.acquire = []

    def parse(self, data):
        _ = Ellipsis
        try:
            check_type([[int, _]] * 2, data)
            putback = data[0]
            acquire = data[1]
            check(sorted(putback+acquire) == range(len(self.cards)))

            cards = self.cards
            putback = [cards[i] for i in putback]
            acquire = [cards[i] for i in acquire]

        except CheckFailed:
            return [self.cards, []]

        return [putback, acquire]

    def is_valid(self, putback, acquire):
        if not set(self.cards) == set(putback + acquire):
            return False

        if acquire:
            suit = acquire[0].suit
            if not all([c.suit == suit for c in acquire]):
                return False

        return True

    def data(self):
        cards = self.cards
        putback = self.putback
        acquire = self.acquire
        if not set(cards) == set(putback + acquire):
            return [range(len(self.cards)), []]

        putback = [cards.index(c) for c in putback]
        acquire = [cards.index(c) for c in acquire]
        return [putback, acquire]

    def set_result(self, putback, acquire):
        assert self.is_valid(putback, acquire)
        self.putback = putback
        self.acquire = acquire

    def post_process(self, actor, rst):
        g = Game.getgame()
        putback, acquire = rst
        g.players.exclude(actor).reveal(acquire)

        try:
            check(self.is_valid(putback, acquire))
        except CheckFailed:
            return [self.cards, []]

        return rst

########NEW FILE########
__FILENAME__ = thb3v3
# -*- coding: utf-8 -*-
import random

from game.autoenv import Game, EventHandler, InterruptActionFlow, user_input, InputTransaction

from .actions import PlayerDeath, DrawCards, PlayerTurn, RevealIdentity
from .actions import action_eventhandlers

from .characters.baseclasses import mixin_character

from itertools import cycle
from collections import defaultdict

from utils import BatchList, Enum, filter_out

from .common import PlayerIdentity, get_seed_for, sync_primitive, CharChoice
from .inputlets import ChooseGirlInputlet

import logging
log = logging.getLogger('THBattle')

_game_ehs = {}
_game_actions = {}


def game_eh(cls):
    _game_ehs[cls.__name__] = cls
    return cls


def game_action(cls):
    _game_actions[cls.__name__] = cls
    return cls


@game_eh
class DeathHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type != 'action_after': return act
        if not isinstance(act, PlayerDeath): return act

        g = Game.getgame()

        # see if game ended
        force1, force2 = g.forces
        if all(p.dead or p.dropped for p in force1):
            g.winners = force2[:]
            g.game_end()

        if all(p.dead or p.dropped for p in force2):
            g.winners = force1[:]
            g.game_end()

        return act


class Identity(PlayerIdentity):
    class TYPE(Enum):
        HIDDEN = 0
        HAKUREI = 1
        MORIYA = 2


class THBattle(Game):
    n_persons = 6
    game_ehs = _game_ehs
    game_actions = _game_actions
    order_list = (0, 5, 3, 4, 2, 1)

    def game_start(g):
        # game started, init state
        from cards import Deck

        g.deck = Deck()

        g.ehclasses = ehclasses = list(action_eventhandlers) + g.game_ehs.values()

        for i, p in enumerate(g.players):
            p.identity = Identity()
            p.identity.type = (Identity.TYPE.HAKUREI, Identity.TYPE.MORIYA)[i % 2]

        g.forces = forces = BatchList([BatchList(), BatchList()])
        for i, p in enumerate(g.players):
            f = i % 2
            p.force = f
            forces[f].append(p)

        # choose girls -->
        from . import characters
        chars = characters.get_characters('3v3')

        seed = get_seed_for(g.players)
        random.Random(seed).shuffle(chars)

        # ANCHOR(test)
        testing = []
        testing = filter_out(chars, lambda c: c.__name__ in testing)
        chars.extend(testing)

        choices = [CharChoice(cls) for cls in chars[-16:]]
        del chars[-12:]

        for c in choices[:4]:
            c.char_cls = characters.akari.Akari

        if Game.SERVER_SIDE:
            for c, cls in zip(choices[:4], g.random.sample(chars, 4)):  # yes, must random.sample
                c.real_cls = cls

        # ----- roll ------
        roll = range(len(g.players))
        g.random.shuffle(roll)
        pl = g.players
        roll = sync_primitive(roll, pl)
        roll = [pl[i] for i in roll]
        g.emit_event('game_roll', roll)
        first = roll[0]
        g.emit_event('game_roll_result', first)
        # ----

        first_index = g.players.index(first)
        n = len(g.order_list)
        order = [g.players[(first_index + i) % n] for i in g.order_list]

        # akaris = {}  # DO NOT USE DICT! THEY ARE UNORDERED!
        akaris = []
        mapping = {p: choices for p in g.players}
        with InputTransaction('ChooseGirl', g.players, mapping=mapping) as trans:
            for p in order:
                c = user_input([p], ChooseGirlInputlet(g, mapping), timeout=30, trans=trans)
                c = c or [_c for _c in choices if not _c.chosen][0]
                c.chosen = p

                if issubclass(c.char_cls, characters.akari.Akari):
                    akaris.append((p, c))
                else:
                    g.set_character(p, c.char_cls)

                trans.notify('girl_chosen', c)

        # reveal akaris
        if akaris:
            for p, c in akaris:
                c.char_cls = c.real_cls

            g.players.reveal([i[1] for i in akaris])

            for p, c in akaris:
                g.set_character(p, c.char_cls)

        g.event_handlers = EventHandler.make_list(ehclasses)

        # -------
        for p in g.players:
            log.info(
                u'>> Player: %s:%s %s',
                p.__class__.__name__,
                Identity.TYPE.rlookup(p.identity.type),
                p.account.username,
            )
        # -------

        first = g.players[first_index]

        pl = g.players
        for p in pl:
            g.process_action(RevealIdentity(p, pl))

        g.emit_event('game_begin', g)

        for p in g.players:
            g.process_action(DrawCards(p, amount=3 if p is first else 4))

        pl = g.players.rotate_to(first)

        for i, p in enumerate(cycle(pl)):
            if i >= 6000: break
            if not p.dead:
                g.emit_event('player_turn', p)
                try:
                    g.process_action(PlayerTurn(p))
                except InterruptActionFlow:
                    pass

    def can_leave(self, p):
        return getattr(p, 'dead', False)

    def set_character(g, p, cls):
        # mix char class with player -->
        new, old_cls = mixin_character(p, cls)
        g.decorate(new)
        g.players.replace(p, new)
        g.forces[0].replace(p, new)
        g.forces[1].replace(p, new)
        assert not old_cls
        ehs = g.ehclasses
        ehs.extend(cls.eventhandlers_required)
        g.emit_event('switch_character', new)
        return new

    def decorate(g, p):
        from .cards import CardList
        from .characters.baseclasses import Character
        assert isinstance(p, Character)

        p.cards = CardList(p, 'cards')  # Cards in hand
        p.showncards = CardList(p, 'showncards')  # Cards which are shown to the others, treated as 'Cards in hand'
        p.equips = CardList(p, 'equips')  # Equipments
        p.fatetell = CardList(p, 'fatetell')  # Cards in the Fatetell Zone
        p.special = CardList(p, 'special')  # used on special purpose
        p.showncardlists = [p.showncards, p.fatetell]
        p.tags = defaultdict(int)

########NEW FILE########
__FILENAME__ = thbfaith
# -*- coding: utf-8 -*-

# -- stdlib --
from collections import defaultdict
from itertools import cycle
import logging
import random

# -- third party --

# -- own --
from .actions import action_eventhandlers, migrate_cards
from .actions import PlayerDeath, DrawCards, PlayerTurn, RevealIdentity, UserAction, MigrateCardsTransaction
from .characters.baseclasses import mixin_character
from .common import PlayerIdentity, get_seed_for, sync_primitive, CharChoice
from game.autoenv import Game, EventHandler, GameEnded, InterruptActionFlow, user_input, InputTransaction
from .inputlets import ChooseGirlInputlet, ChooseOptionInputlet, SortCharacterInputlet
from utils import BatchList, Enum

# -- code --
log = logging.getLogger('THBattle')

_game_ehs = {}
_game_actions = {}


def game_eh(cls):
    _game_ehs[cls.__name__] = cls
    return cls


@game_eh
class DeathHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type != 'action_after': return act
        if not isinstance(act, PlayerDeath): return act

        g = Game.getgame()

        tgt = act.target
        force = tgt.force
        if len(force.pool) <= 1:
            forces = g.forces[:]
            forces.remove(force)
            g.winners = forces[0][:]
            g.game_end()

        g = Game.getgame()

        pool = tgt.force.pool
        assert pool

        mapping = {tgt: pool}
        with InputTransaction('ChooseGirl', [tgt], mapping=mapping) as trans:
            c = user_input([tgt], ChooseGirlInputlet(g, mapping), timeout=30, trans=trans)
            c = c or [_c for _c in pool if not _c.chosen][0]
            c.chosen = tgt
            pool.remove(c)
            trans.notify('girl_chosen', c)

        tgt = g.switch_character(tgt, c)
        g.process_action(DrawCards(tgt, 4))

        if user_input([tgt], ChooseOptionInputlet(self, (False, True))):
            g.process_action(RedrawCards(tgt, tgt))

        return act


class RedrawCards(UserAction):
    def apply_action(self):
        tgt = self.target
        g = Game.getgame()

        with MigrateCardsTransaction() as trans:
            migrate_cards(tgt.cards, g.deck.droppedcards, trans=trans)
            
            cards = g.deck.getcards(4)
            tgt.reveal(cards)
            migrate_cards(cards, tgt.cards, trans=trans)
        
        return True


class Identity(PlayerIdentity):
    class TYPE(Enum):
        HIDDEN = 0
        HAKUREI = 1
        MORIYA = 2


class THBattleFaith(Game):
    n_persons = 6
    game_ehs = _game_ehs
    game_actions = _game_actions

    def game_start(g):
        # game started, init state
        from cards import Deck

        g.deck = Deck()

        g.ehclasses = list(action_eventhandlers) + g.game_ehs.values()

        # reseat
        seed = get_seed_for(g.players)
        random.Random(seed).shuffle(g.players)
        g.emit_event('reseat', None)

        H, M = Identity.TYPE.HAKUREI, Identity.TYPE.MORIYA
        L = [[H, H, M, M, H, M], [H, M, H, M, H, M]]
        rnd = random.Random(get_seed_for(g.players))
        L = rnd.choice(L) * 2
        s = rnd.randrange(0, 6)
        idlist = L[s:s+6]
        del H, M, L, s, rnd

        for p, identity in zip(g.players, idlist):
            p.identity = Identity()
            p.identity.type = identity
            g.process_action(RevealIdentity(p, g.players))

        force_hakurei = BatchList()
        force_moriya = BatchList()
        force_hakurei.pool = []
        force_moriya.pool = []

        for p in g.players:
            if p.identity.type == Identity.TYPE.HAKUREI:
                force_hakurei.append(p)
                p.force = force_hakurei
            elif p.identity.type == Identity.TYPE.MORIYA:
                force_moriya.append(p)
                p.force = force_moriya

        g.forces = BatchList([force_hakurei, force_moriya])

        # ----- roll ------
        roll = range(len(g.players))
        g.random.shuffle(roll)
        pl = g.players
        roll = sync_primitive(roll, pl)
        roll = [pl[i] for i in roll]
        g.emit_event('game_roll', roll)
        first = roll[0]
        g.emit_event('game_roll_result', first)
        # ----

        # choose girls -->
        from . import characters
        chars = characters.get_characters('faith')
        g.random.shuffle(chars)

        if Game.SERVER_SIDE:
            choices = [CharChoice(cls) for cls in chars[-24:]]
        else:
            choices = [CharChoice(None) for _ in xrange(24)]

        del chars[-24:]

        for p in g.players:
            c = choices[-3:]
            del choices[-3:]
            akari = CharChoice(characters.akari.Akari)
            akari.real_cls = chars.pop()
            c.append(akari)
            p.choices = c
            p.choices_chosen = []
            p.reveal(c)

        mapping = {p: p.choices for p in g.players}

        rst = user_input(g.players, SortCharacterInputlet(g, mapping, 2), timeout=30, type='all')
        for p in g.players:
            p.choices_chosen = [mapping[p][i] for i in rst[p][:2]]

        for p in g.players:
            a, b = p.choices_chosen
            b.chosen = None
            p.force.reveal(b)
            g.switch_character(p, a)
            p.force.pool.append(b)
            del p.choices_chosen

        for p in g.players:
            if p.player is first:
                first = p
                break

        pl = g.players
        first_index = pl.index(first)
        order = BatchList(range(len(pl))).rotate_to(first_index)

        for p in pl:
            g.process_action(RevealIdentity(p, pl))

        g.emit_event('game_begin', g)

        for p in pl:
            g.process_action(DrawCards(p, amount=4))

        pl = g.players.rotate_to(first)
        rst = user_input(pl[1:], ChooseOptionInputlet(DeathHandler(), (False, True)), type='all')

        for p in pl[1:]:
            rst.get(p) and g.process_action(RedrawCards(p, p))

        pl = g.players
        for i, idx in enumerate(cycle(order)):
            if i >= 6000: break
            p = pl[idx]
            if p.dead: continue

            g.emit_event('player_turn', p)
            try:
                g.process_action(PlayerTurn(p))
            except InterruptActionFlow:
                pass


    def can_leave(g, p):
        return False

    def update_event_handlers(g):
        ehclasses = list(action_eventhandlers) + g.game_ehs.values()
        ehclasses += g.ehclasses
        g.event_handlers = EventHandler.make_list(ehclasses)

    def switch_character(g, p, choice):
        choice.char_cls = choice.real_cls or choice.char_cls  # reveal akari

        g.players.reveal(choice)
        cls = choice.char_cls

        log.info(u'>> NewCharacter: %s %s', Identity.TYPE.rlookup(p.identity.type), cls.__name__)

        # mix char class with player -->
        old = p
        p, oldcls = mixin_character(p, cls)
        g.decorate(p)
        g.players.replace(old, p)
        g.forces[0].replace(old, p)
        g.forces[1].replace(old, p)

        ehs = g.ehclasses
        ehs.extend(p.eventhandlers_required)

        g.update_event_handlers()
        g.emit_event('switch_character', p)

        return p

    def decorate(g, p):
        from cards import CardList
        p.cards = CardList(p, 'cards')  # Cards in hand
        p.showncards = CardList(p, 'showncards')  # Cards which are shown to the others, treated as 'Cards in hand'
        p.equips = CardList(p, 'equips')  # Equipments
        p.fatetell = CardList(p, 'fatetell')  # Cards in the Fatetell Zone
        p.special = CardList(p, 'special')  # used on special purpose
        p.showncardlists = [p.showncards, p.fatetell]
        p.tags = defaultdict(int)

########NEW FILE########
__FILENAME__ = thbidentity
# -*- coding: utf-8 -*-
import random
from game.autoenv import Game, EventHandler, GameEnded, InterruptActionFlow, user_input, InputTransaction

from .actions import PlayerTurn, PlayerDeath, DrawCards, DropCards, RevealIdentity
from .actions import action_eventhandlers
from .characters.baseclasses import mixin_character

from itertools import cycle
from collections import defaultdict
from utils import Enum

from .common import PlayerIdentity, sync_primitive, CharChoice, get_seed_for
from .inputlets import ChooseGirlInputlet

import logging
log = logging.getLogger('THBattleIdentity')
_game_ehs = {}
_game_actions = {}


def game_eh(cls):
    _game_ehs[cls.__name__] = cls
    return cls


def game_action(cls):
    _game_actions[cls.__name__] = cls
    return cls


@game_eh
class DeathHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type != 'action_after': return act
        if not isinstance(act, PlayerDeath): return act
        tgt = act.target
        g = Game.getgame()

        g.process_action(RevealIdentity(tgt, g.players))

        if act.source:
            src = act.source
            if tgt.identity.type == Identity.TYPE.ATTACKER:
                g.process_action(DrawCards(src, 3))
            elif tgt.identity.type == Identity.TYPE.ACCOMPLICE:
                if src.identity.type == Identity.TYPE.BOSS:
                    if src.cards:
                        g.players.exclude(src).reveal(list(src.cards))
                        g.process_action(DropCards(src, src.cards))
                    if src.showncards: g.process_action(DropCards(src, src.showncards))
                    if src.equips: g.process_action(DropCards(src, src.equips))

        # see if game ended
        T = Identity.TYPE

        def build():
            deads = defaultdict(list)
            for p in g.players:
                if p.dead:
                    deads[p.identity.type].append(p)
            return deads

        # curtain's win
        survivors = [p for p in g.players if not p.dead]
        if len(survivors) == 1:
            pl = g.players
            pl.reveal([p.identity for p in g.players])

            if survivors[0].identity.type == T.CURTAIN:
                g.winners = survivors[:]
                g.game_end()

        deads = build()

        # boss & accomplices' win
        if len(deads[T.ATTACKER]) == g.identities.count(T.ATTACKER):
            if len(deads[T.CURTAIN]) == g.identities.count(T.CURTAIN):
                pl = g.players
                pl.reveal([p.identity for p in g.players])

                g.winners = [p for p in pl if p.identity.type in (T.BOSS, T.ACCOMPLICE)]
                g.game_end()

        # attackers' win
        if len(deads[T.BOSS]):
            pl = g.players
            pl.reveal([p.identity for p in g.players])

            g.winners = [p for p in pl if p.identity.type == T.ATTACKER]
            g.game_end()

        return act


class Identity(PlayerIdentity):
    # 城管 BOSS 道中 黑幕
    class TYPE(Enum):
        HIDDEN = 0
        ATTACKER = 1
        BOSS = 4
        ACCOMPLICE = 2
        CURTAIN = 3


class THBattleIdentity(Game):
    n_persons = 8
    character_categories = ('id', 'id8')
    game_actions = _game_actions
    T = Identity.TYPE
    identities = [
        T.ATTACKER, T.ATTACKER, T.ATTACKER, T.ATTACKER,
        T.ACCOMPLICE, T.ACCOMPLICE,
        T.CURTAIN,
    ]
    del T

    def game_start(g):
        # game started, init state
        from cards import Deck

        g.deck = Deck()

        g.ehclasses = ehclasses = list(action_eventhandlers) + _game_ehs.values()

        # choose girls init -->
        from .characters import get_characters
        chars = get_characters(*g.character_categories)
        from .characters.akari import Akari

        if Game.CLIENT_SIDE:
            chars = [None] * len(chars)

        g.random.shuffle(chars)

        # choose boss
        idx = sync_primitive(g.random.randrange(len(g.players)), g.players)
        boss = g.boss = g.players[idx]

        boss.identity = Identity()
        boss.identity.type = Identity.TYPE.BOSS

        g.process_action(RevealIdentity(boss, g.players))

        boss.choices = [CharChoice(c) for c in chars[:4]]
        boss.choices.append(CharChoice(Akari))
        del chars[:4]

        for p in g.players.exclude(boss):
            p.choices = [CharChoice(c) for c in chars[:3]]
            p.choices.append(CharChoice(Akari))
            del chars[:3]

        for p in g.players:
            p.reveal(p.choices)

        mapping = {boss: boss.choices}
        with InputTransaction('ChooseGirl', [boss], mapping=mapping) as trans:
            c = user_input([boss], ChooseGirlInputlet(g, mapping), 30, 'single', trans)

            c = c or boss.choices[-1]
            c.chosen = boss
            g.players.reveal(c)
            trans.notify('girl_chosen', c)

            if c.char_cls is Akari:
                c = CharChoice(chars.pop())
                g.players.reveal(c)

            # mix it in advance
            # so the others could see it

            boss = g.switch_character(boss, c.char_cls)

            # boss's hp bonus
            if g.n_persons > 5:
                boss.maxlife += 1

            boss.life = boss.maxlife

        # reseat
        seed = get_seed_for(g.players)
        random.Random(seed).shuffle(g.players)
        g.emit_event('reseat', None)

        # tell the others their own identity
        il = list(g.identities)
        g.random.shuffle(il)
        for p in g.players.exclude(boss):
            p.identity = Identity()
            id = il.pop()
            if Game.SERVER_SIDE:
                p.identity.type = id
            g.process_action(RevealIdentity(p, p))

        pl = g.players.exclude(boss)
        mapping = {p: p.choices for p in pl}  # CAUTION, DICT HERE
        with InputTransaction('ChooseGirl', pl, mapping=mapping) as trans:
            ilet = ChooseGirlInputlet(g, mapping)
            ilet.with_post_process(lambda p, rst: trans.notify('girl_chosen', rst) or rst)
            result = user_input(pl, ilet, type='all', trans=trans)

        # not enough chars for random, reuse unselected
        for p in pl:
            if result[p]: result[p].chosen = p
            chars.extend([i.char_cls for i in p.choices if not i.chosen and i.char_cls is not Akari])

        seed = get_seed_for(g.players)
        random.Random(seed).shuffle(chars)

        # mix char class with player -->
        for p in pl:
            c = result[p]
            c = c or p.choices[-1]
            g.players.reveal(c)

            if c.char_cls is Akari:
                c = CharChoice(chars.pop())
                g.players.reveal(c)

            p = g.switch_character(p, c.char_cls)

        g.event_handlers = EventHandler.make_list(ehclasses)

        g.emit_event('game_begin', g)

        for p in g.players:
            g.process_action(DrawCards(p, amount=4))

        pl = g.players.rotate_to(boss)

        for i, p in enumerate(cycle(pl)):
            if i >= 6000: break
            if not p.dead:
                try:
                    g.process_action(PlayerTurn(p))
                except InterruptActionFlow:
                    pass

    
    def can_leave(self, p):
        return getattr(p, 'dead', False)

    def switch_character(g, p, cls):
        # mix char class with player -->
        old = p
        p, oldcls = mixin_character(p, cls)
        g.decorate(p)
        g.players.replace(old, p)

        ehs = g.ehclasses
        assert not oldcls
        ehs.extend(p.eventhandlers_required)
        g.emit_event('switch_character', p)

        return p

    def decorate(self, p):
        from cards import CardList
        p.cards = CardList(p, 'cards')  # Cards in hand
        p.showncards = CardList(p, 'showncards')  # Cards which are shown to the others, treated as 'Cards in hand'
        p.equips = CardList(p, 'equips')  # Equipments
        p.fatetell = CardList(p, 'fatetell')  # Cards in the Fatetell Zone
        p.special = CardList(p, 'special')  # used on special purpose
        p.showncardlists = [p.showncards, p.fatetell]  # cardlists should shown to others
        p.tags = defaultdict(int)


class THBattleIdentity5(THBattleIdentity):
    n_persons = 5
    character_categories = ('id', 'id5')
    T = Identity.TYPE

    identities = [
        T.ATTACKER, T.ATTACKER,
        T.ACCOMPLICE,
        T.CURTAIN,
    ]
    del T

########NEW FILE########
__FILENAME__ = thbkof
# -*- coding: utf-8 -*-
import random
from itertools import cycle
from collections import defaultdict
import logging

from utils import Enum, filter_out

from game.autoenv import Game, EventHandler, GameEnded, InterruptActionFlow, InputTransaction, user_input
from game import sync_primitive

from .common import PlayerIdentity, CharChoice, get_seed_for

from .actions import PlayerDeath, PlayerTurn, DrawCards, RevealIdentity
from .actions import action_eventhandlers

from .characters.baseclasses import mixin_character

from .inputlets import ChooseGirlInputlet, SortCharacterInputlet

log = logging.getLogger('THBattle')
_game_ehs = {}


def game_eh(cls):
    _game_ehs[cls.__name__] = cls
    return cls


@game_eh
class DeathHandler(EventHandler):
    def handle(self, evt_type, act):
        if evt_type != 'action_after': return act
        if not isinstance(act, PlayerDeath): return act
        tgt = act.target

        g = Game.getgame()

        if not tgt.characters:
            pl = g.players[:]
            pl.remove(tgt)
            g.winners = pl
            g.game_end()

        pl = g.players
        if pl[0].dropped:
            g.winners = [pl[1]]
            g.game_end()

        if pl[1].dropped:
            g.winners = [pl[0]]
            g.game_end()

        return act


@game_eh
class KOFCharacterSwitchHandler(EventHandler):
    def handle(self, evt_type, act):
        cond = evt_type in ('action_before', 'action_after')
        cond = cond and isinstance(act, PlayerTurn)
        cond = cond or evt_type == 'action_stage_action'
        cond and self.do_switch()
        return act

    @staticmethod
    def do_switch():
        g = Game.getgame()

        for p in [p for p in g.players if p.dead and p.characters]:
            new = g.next_character(p)
            g.process_action(DrawCards(new, 4))


class Identity(PlayerIdentity):
    class TYPE(Enum):
        HIDDEN = 0
        HAKUREI = 1
        MORIYA = 2


class THBattleKOF(Game):
    n_persons = 2
    game_ehs = _game_ehs

    def game_start(g):
        # game started, init state

        from cards import Deck

        g.deck = Deck()

        g.ehclasses = []

        for i, p in enumerate(g.players):
            p.identity = Identity()
            p.identity.type = (Identity.TYPE.HAKUREI, Identity.TYPE.MORIYA)[i % 2]

        # choose girls -->
        from characters import get_characters
        chars = get_characters('kof')

        testing = []
        testing = filter_out(chars, lambda c: c.__name__ in testing)

        _chars = g.random.sample(chars, 10)
        _chars.extend(testing)
        
        from characters.akari import Akari
        if Game.SERVER_SIDE:
            choice = [CharChoice(cls) for cls in _chars[-10:]]

            for c in g.random.sample(choice, 4):
                c.real_cls = c.char_cls
                c.char_cls = Akari

        elif Game.CLIENT_SIDE:
            choice = [CharChoice(None) for i in xrange(10)]

        # -----------

        g.players.reveal(choice)

        # roll
        roll = range(len(g.players))
        g.random.shuffle(roll)
        pl = g.players
        roll = sync_primitive(roll, pl)

        roll = [pl[i] for i in roll]

        g.emit_event('game_roll', roll)

        first = roll[0]
        second = roll[1]

        g.emit_event('game_roll_result', first)
        # ----

        # akaris = {}  # DO NOT USE DICT! THEY ARE UNORDERED!
        akaris = []

        A, B = first, second
        order = [A, B, B, A, A, B, B, A, A, B]
        A.choices = []
        B.choices = []
        choice_mapping = {A: choice, B: choice}
        del A, B

        with InputTransaction('ChooseGirl', g.players, mapping=choice_mapping) as trans:
            for p in order:
                c = user_input([p], ChooseGirlInputlet(g, choice_mapping), 10, 'single', trans)
                if not c:
                    # first non-chosen char
                    for c in choice:
                        if not c.chosen:
                            c.chosen = p
                            break

                if issubclass(c.char_cls, Akari):
                    akaris.append((p, c))

                c.chosen = p
                p.choices.append(c)

                trans.notify('girl_chosen', c)

        # reveal akaris for themselves
        for p, c in akaris:
            c.char_cls = c.real_cls
            p.reveal(c)

        for p in g.players:
            seed = get_seed_for(p)
            random.Random(seed).shuffle(p.choices)

        mapping = {first: first.choices, second: second.choices}
        rst = user_input(g.players, SortCharacterInputlet(g, mapping, 3), timeout=30, type='all')

        for p in g.players:
            perm = p.choices
            perm = [   # weird snap for debug
                perm[i]
                for i in
                rst[p]
                [:3]
            ]
            p.characters = [c.char_cls for c in perm]
            del p.choices

        first = g.next_character(first)
        second = g.next_character(second)

        order = [0, 1] if first is g.players[0] else [1, 0]

        pl = g.players
        for p in pl:
            g.process_action(RevealIdentity(p, pl))

        g.emit_event('game_begin', g)

        for p in pl:
            g.process_action(DrawCards(p, amount=3 if p is first else 4))

        for i, idx in enumerate(cycle(order)):
            p = g.players[idx]
            if i >= 6000: break
            if p.dead:
                assert p.characters  # if not holds true, DeathHandler should end game.
                KOFCharacterSwitchHandler.do_switch()
                p = g.players[idx]  # player changed

            assert not p.dead

            try:
                g.emit_event('player_turn', p)
                g.process_action(PlayerTurn(p))
            except InterruptActionFlow:
                pass

    
    def can_leave(g, p):
        return False

    def update_event_handlers(g):
        ehclasses = list(action_eventhandlers) + g.game_ehs.values()
        ehclasses += g.ehclasses
        g.event_handlers = EventHandler.make_list(ehclasses)

    def next_character(g, p):
        assert p.characters
        char = CharChoice(p.characters.pop(0))
        g.players.reveal(char)
        cls = char.char_cls

        # mix char class with player -->
        new, old_cls = mixin_character(p, cls)
        g.decorate(new)
        g.players.replace(p, new)

        ehs = g.ehclasses
        ehs.extend(cls.eventhandlers_required)
        g.update_event_handlers()

        g.emit_event('switch_character', new)

        return new

    def decorate(g, p):
        from .cards import CardList
        from .characters.baseclasses import Character
        assert isinstance(p, Character)

        p.cards = CardList(p, 'cards')  # Cards in hand
        p.showncards = CardList(p, 'showncards')  # Cards which are shown to the others, treated as 'Cards in hand'
        p.equips = CardList(p, 'equips')  # Equipments
        p.fatetell = CardList(p, 'fatetell')  # Cards in the Fatetell Zone
        p.special = CardList(p, 'special')  # used on special purpose
        p.showncardlists = [p.showncards, p.fatetell]
        p.tags = defaultdict(int)

########NEW FILE########
__FILENAME__ = thbraid
# -*- coding: utf-8 -*-
import random
import logging

from game.autoenv import Game, EventHandler, GameEnded, InterruptActionFlow, GameException, user_input, InputTransaction

from .actions import ActionStage, ActionStageLaunchCard, Damage, DrawCards
from .actions import DropCards, GenericAction, LaunchCard, PlayerDeath
from .actions import PlayerRevive, UserAction, BaseDamage, RevealIdentity
from .actions import PlayerTurn, MaxLifeChange, action_eventhandlers
from .actions import LifeLost
from .actions import migrate_cards, user_choose_cards
from .characters.baseclasses import mixin_character

from .inputlets import ChooseOptionInputlet, ChooseIndividualCardInputlet, ChooseGirlInputlet

from .cards import Skill, t_None
from collections import defaultdict

from .common import PlayerIdentity, CharChoice, get_seed_for

from utils import BatchList, Enum

log = logging.getLogger('THBattleRaid')

_game_ehs = {}
_game_actions = {}


def game_eh(cls):
    _game_ehs[cls.__name__] = cls
    return cls


def game_action(cls):
    _game_actions[cls.__name__] = cls
    return cls


@game_eh
class DeathHandler(EventHandler):
    def handle(self, evt_type, act):
        if not evt_type == 'action_after': return act
        if not isinstance(act, PlayerDeath): return act

        tgt = act.target
        g = Game.getgame()

        # attackers' win
        if tgt is g.mutant:
            g.winners = g.attackers
            g.game_end()

        # mutant's win
        if all(p.dead for p in g.attackers):
            g.winners = [g.mutant]
            g.game_end()

        if tgt in g.attackers:
            for p in [p for p in g.attackers if not p.dead]:
                if user_input([p], ChooseOptionInputlet(self, (False, True))):
                    g.process_action(DrawCards(p, 1))

        return act


def use_faith(target, amount=1):
    g = Game.getgame()
    assert amount <= len(target.faiths)
    if len(target.faiths) == amount:
        g.process_action(DropCards(target, list(target.faiths)))
        return

    for i in xrange(amount):
        c = user_input([target], ChooseIndividualCardInputlet(None, target.faiths))
        if not c: break
        g.process_action(DropCards(target, [c]))
        amount -= 1

    if amount:
        g.process_action(DropCards(target, list(target.faiths)[:amount]))


class CollectFaith(GenericAction):
    def __init__(self, source, target, amount):
        self.source = source
        self.target = target
        self.amount = amount

    def apply_action(self):
        tgt = self.target

        g = Game.getgame()

        amount = max(0, 5 - len(tgt.faiths))
        amount = min(amount, self.amount)

        if not amount: return False

        cards = g.deck.getcards(amount)
        g.players.reveal(cards)
        migrate_cards(cards, tgt.faiths)
        self.cards = cards

        return True


@game_eh
class CollectFaithHandler(EventHandler):
    def handle(self, evt_type, act):
        if not evt_type == 'action_apply': return act
        if not isinstance(act, Damage): return act
        src = act.source
        if not src: return act

        g = Game.getgame()
        g.process_action(CollectFaith(src, src, act.amount))
        return act


class CooperationAction(UserAction):
    card_usage = 'handover'

    def apply_action(self):
        src = self.source
        tgt = self.target
        g = Game.getgame()

        src.tags['cooperation_tag'] = src.tags['turn_count']
        skill = self.associated_card
        self.ncards = len(skill.associated_cards)

        migrate_cards([skill], tgt.showncards, unwrap=True)

        returned = user_choose_cards(self, tgt, ['cards', 'showncards'])
        if not returned:
            returned = (list(tgt.showncards) + list(tgt.cards))[:self.ncards]

        g.players.reveal(returned)
        migrate_cards(returned, src.showncards)

        return True

    def is_valid(self):
        tags = self.source.tags
        return tags['turn_count'] > tags['cooperation_tag']

    def cond(self, cl):
        if not len(cl) == self.ncards: return False
        tgt = self.target
        return all(c.resides_in in (tgt.cards, tgt.showncards) for c in cl)


class Cooperation(Skill):
    associated_action = CooperationAction
    no_drop = True
    usage = 'handover'

    def target(self, g, src, tl):
        attackers = g.attackers
        tl = [p for p in tl if not p.dead and p is not src and p in attackers]
        return (tl[-1:], bool(len(tl)))

    def check(self):
        cl = self.associated_cards
        if not cl: return False
        if not len(cl) <= 2: return False
        return all(c.resides_in is not None and c.resides_in.type in (
            'cards', 'showncards',
        ) for c in cl)


class Protection(Skill):
    associated_action = None
    target = t_None


class ProtectionAction(GenericAction):
    def __init__(self, source, dmgact):
        self.source = source
        self.target = dmgact.target
        self.dmgact = dmgact

    def apply_action(self):
        g = Game.getgame()
        src = self.source

        use_faith(src, 1)

        act = self.dmgact
        act.cancelled = True

        g.process_action(LifeLost(src, src, act.amount))
        g.process_action(CollectFaith(g.mutant, g.mutant, 1))

        return True


@game_eh
class ProtectionHandler(EventHandler):
    execute_before = ('WineHandler', )
    execute_after = ('RepentanceStickHandler', )

    def handle(self, evt_type, act):
        if evt_type != 'action_before': return act
        if not isinstance(act, Damage): return act
        if act.cancelled: return act

        g = Game.getgame()
        tgt = act.target

        pl = g.attackers[:]
        if tgt not in pl: return act
        if tgt.life != min([p.life for p in pl if not p.dead]): return act

        g = Game.getgame()
        pl.remove(tgt)

        self.dmgact = act

        pl = [p for p in pl if not p.dead and len(p.faiths) and p.has_skill(Protection)]
        for p in pl:
            if user_input([p], ChooseOptionInputlet(self, (False, True))):
                g.process_action(ProtectionAction(p, act))
                break

        return act


class Parry(Skill):
    associated_action = None
    target = t_None


class ParryAction(GenericAction):
    def __init__(self, source, dmgact):
        self.source = source
        self.target = dmgact.target
        self.dmgact = dmgact

    def apply_action(self):
        use_faith(self.source, 2)
        self.dmgact.amount -= 1
        return True


@game_eh
class ParryHandler(EventHandler):
    execute_before = ('ProtectionHandler', )
    execute_after = ('RepentanceStickHandler', )

    def handle(self, evt_type, act):
        if evt_type != 'action_before': return act
        if not isinstance(act, Damage): return act
        tgt = act.target
        if not tgt.has_skill(Parry): return act
        if not len(tgt.faiths) >= 2: return act
        if not (act.amount >= 2 or tgt.life <= act.amount): return act

        if not user_input([tgt], ChooseOptionInputlet(self, (False, True))):
            return act

        g = Game.getgame()
        g.process_action(ParryAction(tgt, act))

        return act


@game_eh
class RaidPlayerReviveHandler(EventHandler):
    def handle(self, evt_type, act):
        if not evt_type == 'action_after': return act
        if not isinstance(act, PlayerRevive): return act
        tgt = act.target
        tgt.skills.extend([
            Cooperation, Protection, Parry,
        ])

        if not tgt.tags['oneup_used']:
            tgt.skills.append(OneUp)

        return act


class OneUpAction(UserAction):
    def apply_action(self):
        src = self.source
        tgt = self.target

        g = Game.getgame()
        assert tgt.dead, 'WTF?!'
        assert tgt in g.attackers

        use_faith(src, 3)
        src.skills.remove(OneUp)
        src.tags['oneup_used'] = True

        g.process_action(PlayerRevive(tgt, tgt, 3))
        tgt.tags['action'] = True

        return True

    def is_valid(self):
        return self.target.dead


class OneUp(Skill):
    associated_action = OneUpAction

    def target(self, g, src, tl):
        attackers = g.attackers
        tl = [p for p in tl if p.dead and p in attackers]
        return (tl[-1:], bool(len(tl)))

    def check(self):
        if len(self.player.faiths) < 3: return False
        return not self.associated_cards


class FaithExchange(UserAction):
    card_usage = 'move_out'

    def apply_action(self):
        tgt = self.target
        g = Game.getgame()
        n = 0
        for i in xrange(len(tgt.faiths)):
            c = user_input([tgt], ChooseIndividualCardInputlet(None, tgt.faiths))
            if not c: break
            migrate_cards([c], tgt.showncards)
            n += 1

        if not n:
            return True

        self.amount = n

        cards = user_choose_cards(self, tgt, ['cards', 'showncards'])
        if not cards:
            cards = list(tgt.showncards)[:self.amount]

        g.players.reveal(cards)
        migrate_cards(cards, tgt.faiths)

        return True

    def cond(self, cl):
        return len(cl) == self.amount


@game_eh
class FaithExchangeHandler(EventHandler):
    def handle(self, evt_type, act):
        if not evt_type == 'action_before': return act
        if not isinstance(act, ActionStage): return act
        g = Game.getgame()
        tgt = act.target
        if not tgt.faiths: return act
        g.process_action(FaithExchange(tgt, tgt))
        return act


class Identity(PlayerIdentity):
    # 异变 解决者
    class TYPE(Enum):
        HIDDEN = 0
        MUTANT = 1
        ATTACKER = 2


class RaidLaunchCard(LaunchCard):
    @classmethod
    def calc_base_distance(cls, src):
        g = Game.getgame()
        return {p: 1 for p in g.players}


class RaidActionStageLaunchCard(RaidLaunchCard, ActionStageLaunchCard):
    pass


class RequestAction(object):  # for choose_option
    pass


class GetFaith(object):  # for choose_option
    pass


class MutantMorph(GameException):
    pass


@game_eh
class MutantMorphHandler(EventHandler):
    def handle(self, evt_type, act):
        if not evt_type == 'action_after': return act
        if not isinstance(act, BaseDamage): return act
        g = Game.getgame()
        tgt = act.target
        if tgt is not g.mutant: return act
        if tgt.morphed: return act

        if tgt.life <= tgt.__class__.maxlife // 2:
            raise MutantMorph

        return act


class THBattleRaid(Game):
    n_persons = 4
    game_actions = _game_actions
    game_ehs = _game_ehs

    def game_start(g):
        # game started, init state

        g.action_types[LaunchCard] = RaidLaunchCard
        g.action_types[ActionStageLaunchCard] = RaidActionStageLaunchCard

        g.ehclasses = []

        # reveal identities
        mutant = g.mutant = g.players[0]
        attackers = g.attackers = BatchList(g.players[1:])

        mutant.identity = Identity()
        mutant.identity.type = Identity.TYPE.MUTANT

        g.process_action(RevealIdentity(mutant, g.players))

        for p in attackers:
            p.identity = Identity()
            p.identity.type = Identity.TYPE.ATTACKER

            g.process_action(RevealIdentity(p, g.players))

        from characters import get_characters

        # mutant's choose
        raid_chars = get_characters('raid_ex', '-common')

        choices = [CharChoice(cls) for cls in raid_chars]
        mapping = {mutant: choices}
        with InputTransaction('ChooseGirl', [mutant], mapping=mapping) as trans:
            c = user_input([mutant], ChooseGirlInputlet(g, mapping), timeout=5, trans=trans)
            c = c or choices[0]
            c.chosen = mutant
            trans.notify('girl_chosen', c)

            # mix it in advance
            # so the others could see it

            g.mutant = mutant = g.switch_character(mutant, c.char_cls)

            mutant.life = mutant.maxlife
            mutant.morphed = False

        # init deck & mutant's initial equip
        # (SinsackCard, SPADE, 1)
        # (SinsackCard, HEART, Q)
        from cards import Deck, SinsackCard, ElementalReactorCard, card_definition
        raid_carddef = [
            carddef for carddef in card_definition
            if carddef[0] not in (SinsackCard, ElementalReactorCard)
        ]

        g.deck = Deck(raid_carddef)

        # attackers' choose
        chars = get_characters('raid')
        seed = get_seed_for(g.players)
        random.Random(seed).shuffle(chars)

        for p in g.attackers:
            p.choices = [CharChoice(cls) for cls in chars[:5]]
            del chars[:5]

        # -----------
        mapping = {p: p.choices for p in g.attackers}
        with InputTransaction('ChooseGirl', g.attackers, mapping=mapping) as trans:
            ilet = ChooseGirlInputlet(g, mapping)
            ilet.with_post_process(lambda p, rst: trans.notify('girl_chosen', rst) or rst)
            result = user_input(g.attackers, ilet, 30, 'all', trans)

        # mix char class with player -->
        for p in g.attackers:
            c = result[p] or CharChoice(chars.pop())
            c.chosen = p
            p = g.switch_character(p, c.char_cls)
            p.skills.extend([
                Cooperation, Protection,
                Parry, OneUp,
            ])

        g.update_event_handlers()

        g.emit_event('game_begin', g)

        # -------
        log.info(u'>> Game info: ')
        log.info(u'>> Mutant: %s', mutant.__class__.__name__)
        for p in attackers:
            log.info(u'>> Attacker: %s', p.__class__.__name__)

        # -------

        g.process_action(DrawCards(mutant, amount=6))
        for p in attackers:
            g.process_action(DrawCards(p, amount=4))

        # stage 1
        try:
            for i in xrange(500):
                g.process_action(CollectFaith(mutant, mutant, 1))

                avail = [p for p in attackers if not p.dead and len(p.faiths) < 5]
                if avail:
                    p, _ = user_input(
                        avail,
                        ChooseOptionInputlet(GetFaith, (None, True)),
                        type='any',
                    )
                    p = p or avail[0]
                    g.process_action(CollectFaith(p, p, 1))

                g.emit_event('round_start', False)

                for p in attackers:
                    p.tags['action'] = True

                while True:
                    try:
                        g.process_action(PlayerTurn(mutant))
                    except InterruptActionFlow:
                        pass

                    avail = BatchList([p for p in attackers if p.tags['action'] and not p.dead])
                    if not avail:
                        break

                    p, _ = user_input(
                        avail,
                        ChooseOptionInputlet(RequestAction, (None, True)),
                        type='any',
                    )

                    p = p or avail[0]
                    p.tags['action'] = False

                    try:
                        g.process_action(PlayerTurn(p))
                    except InterruptActionFlow:
                        pass

                    if not [p for p in attackers if p.tags['action'] and not p.dead]:
                        break

        except MutantMorph:
            pass

        # morphing
        stage1 = mutant.__class__
        stage2 = stage1.stage2

        for s in stage1.skills:
            try:
                mutant.skills.remove(s)
            except ValueError:
                pass

        mutant.skills.extend(stage2.skills)

        ehclasses = g.ehclasses
        for s in stage1.eventhandlers_required:
            try:
                ehclasses.remove(s)
            except ValueError:
                pass

        ehclasses.extend(stage2.eventhandlers_required)

        g.process_action(
            MaxLifeChange(mutant, mutant, -(stage1.maxlife // 2))
        )
        mutant.morphed = True

        mutant.__class__ = stage2

        g.update_event_handlers()

        for p in attackers:
            g.process_action(CollectFaith(p, p, 1))

        g.process_action(DropCards(mutant, mutant.fatetell))

        g.emit_event('mutant_morph', mutant)

        g.pause(4)

        # stage 2
        for i in xrange(500):
            g.process_action(CollectFaith(mutant, mutant, 1))

            avail = [p for p in attackers if not p.dead and len(p.faiths) < 5]
            if avail:
                p, _ = user_input(
                    avail,
                    ChooseOptionInputlet(GetFaith, (None, True)),
                    type='any',
                )
                p = p or avail[0]
                g.process_action(CollectFaith(p, p, 1))

            g.emit_event('round_start', False)

            for p in attackers:
                p.tags['action'] = True

            try:
                g.process_action(PlayerTurn(mutant))
            except InterruptActionFlow:
                pass

            while True:
                avail = BatchList([p for p in attackers if p.tags['action'] and not p.dead])
                if not avail:
                    break

                p, _ = user_input(
                    avail,
                    ChooseOptionInputlet(RequestAction, (None, True)),
                    type='any'
                )

                p = p or avail[0]

                p.tags['action'] = False
                try:
                    g.process_action(PlayerTurn(p))
                except InterruptActionFlow:
                    pass

    def can_leave(self, p):
        return False

    def switch_character(g, p, cls):
        old = p
        p, oldcls = mixin_character(p, cls)
        g.decorate(p)
        g.players.replace(old, p)
        g.attackers.replace(old, p)

        ehs = g.ehclasses
        ehs.extend(p.eventhandlers_required)
        g.emit_event('switch_character', p)

        return p

    def update_event_handlers(self):
        ehclasses = list(action_eventhandlers) + self.game_ehs.values()
        ehclasses += self.ehclasses
        self.event_handlers = EventHandler.make_list(ehclasses)

    def decorate(self, p):
        from cards import CardList
        p.cards = CardList(p, 'cards')  # Cards in hand
        p.showncards = CardList(p, 'showncards')  # Cards which are shown to the others, treated as 'Cards in hand'
        p.equips = CardList(p, 'equips')  # Equipments
        p.fatetell = CardList(p, 'fatetell')  # Cards in the Fatetell Zone
        p.faiths = CardList(p, 'faiths')  # 'faith' cards
        p.special = CardList(p, 'special')  # used on special purpose

        p.showncardlists = [p.showncards, p.faiths, p.fatetell]  # cardlists should shown to others

        p.tags = defaultdict(int)
        p.tags['faithcounter'] = True  # for ui

########NEW FILE########
__FILENAME__ = effects
# -*- coding: utf-8 -*-

from client.ui.base.interp import LinearInterp
from client.ui.controls import BalloonPromptMixin, Colors, Control, Panel, SmallProgressBar, Button
from client.ui.soundmgr import SoundManager

from client.ui.resource import resource as common_res
from gamepack.thb.ui.resource import resource as gres

from .game_controls import CardSprite, SmallCardSprite

import pyglet
from pyglet.text import Label

from ..actions import Action, ActionStage, BaseFatetell, Damage, LaunchCard, Pindian, PlayerDeath, PlayerTurn, UserAction
from ..cards import VirtualCard, RejectHandler
from ..inputlets import ActionInputlet

from game.autoenv import Game

from functools import partial
from collections import defaultdict as ddict

from utils import BatchList, group_by

from pyglet.sprite import Sprite

import logging
log = logging.getLogger('THBattleUI_Effects')


class OneShotAnim(Sprite):
    def on_animation_end(self):
        self.delete()


LoopingAnim = Sprite


class TagAnim(Control, BalloonPromptMixin):
    def __init__(self, img, x, y, text, *a, **k):
        Control.__init__(self, x=x, y=y, width=25, height=25, *a, **k)
        self.image = img
        self.sprite = LoopingAnim(img)
        self.init_balloon(text)

    def draw(self):
        self.sprite.draw()

    def set_position(self, x, y):
        self.x, self.y = x, y


def before_launch_card_effects(self, arg):
    from .. import actions
    act = arg[0]
    rawcards = VirtualCard.unwrap([act.card])
    for cards in group_by(rawcards, lambda c: id(c.resides_in)):
        card_migration_effects(
            self, (
                actions.DropUsedCard(act.source, [act.card]),
                cards,
                cards[0].resides_in,
                self.game.deck.droppedcards,
            )
        )


def card_migration_effects(self, args):  # here self is the SimpleGameUI instance
    act, cards, _from, to = args
    g = self.game
    handcard_update = False
    dropcard_update = False
    csl = BatchList()

    from .. import actions

    # --- src ---
    rawcards = [c for c in cards if not c.is_card(VirtualCard)]

    if _from.type == 'equips':  # equip area
        equips = self.player2portrait(_from.owner).equipcard_area
        for cs in equips.cards[:]:
            if cs.associated_card in cards:
                cs.delete()
        equips.update()

    if _from.type == 'fatetell':  # fatetell tag
        port = self.player2portrait(_from.owner)
        taganims = port.taganims
        for a in [t for t in taganims if hasattr(t, 'for_fatetell_card')]:
            if a.for_fatetell_card in cards:
                a.delete()
                taganims.remove(a)
        port.tagarrange()

    if to is None: return  # not supposed to have visual effects

    hca_mapping = {cs.associated_card: (cs, i) for i, cs in enumerate(self.handcard_area.control_list)}
    dca_mapping = {cs.associated_card: (cs, i+100) for i, cs in enumerate(self.dropcard_area.control_list)}
    pca = None
    for c in rawcards:
        # handcard
        k = hca_mapping.get(c, None)
        if k:
            cs, i = k
            handcard_update = True
            cs.sort_idx = i
            csl.append(cs)
            continue

        # dropped card
        k = dca_mapping.get(c, None)
        if k:
            cs, i = k
            dropcard_update = True
            cs.sort_idx = i
            csl.append(cs)
            continue

        # others
        if not pca:
            if _from.type in ('deckcard', 'droppedcard', 'disputed') or not _from.owner:
                pca = self.deck_area
            #elif not _from.owner:
            #    break
            else:
                pca = self.player2portrait(_from.owner).portcard_area

        cs = CardSprite(c, parent=pca)
        cs.associated_card = c
        cs.sort_idx = -1
        csl.append(cs)

    csl.sort(key=lambda cs: cs.sort_idx)
    csl.update()

    pca and pca.arrange()

    # --- dest ---

    if to.type == 'equips':  # equip area
        equips = self.player2portrait(to.owner).equipcard_area
        for c in cards:
            cs = SmallCardSprite(c, parent=equips, x=0, y=0)
            cs.associated_card = c
        equips.update()

    if to.type == 'fatetell':  # fatetell tag
        port = self.player2portrait(to.owner)
        taganims = port.taganims
        for c in cards:
            a = TagAnim(
                c.ui_meta.tag_anim(c),
                0, 0,
                c.ui_meta.description,
                parent=self,
            )
            a.for_fatetell_card = c
            port.taganims.append(a)
        port.tagarrange()

    if to.owner is g.me and to.type in ('cards', 'showncards'):
        handcard_update = True
        hca = self.handcard_area
        for cs in csl:
            cs.migrate_to(hca)
            cs.gray = False

    else:
        if to.type in ('droppedcard', 'disputed'):
            dropcard_update = True
            ca = self.dropcard_area
            if isinstance(act, BaseFatetell):
                assert len(csl) == 1
                csl[0].gray = not act.succeeded  # may be race condition
                csl[0].do_fatetell_anim()
            else:
                gray = not isinstance(act, (
                    actions.DropUsedCard,
                )) and not to.type == 'disputed'
                for cs in csl:
                    cs.gray = gray
            csl.migrate_to(ca)
        elif to.owner:
            ca = self.player2portrait(to.owner).portcard_area
            for cs in csl:
                cs.migrate_to(ca)
                cs.gray = False
            ca.update()
            ca.fade()
        else:
            for cs in csl:
                cs.delete()

    handcard_update and self.handcard_area.update()
    dropcard_update and self.dropcard_area.update()


def damage_effect(self, act):
    t = act.target
    port = self.player2portrait(t)
    OneShotAnim(gres.hurt, x=port.x, y=port.y, batch=self.animations)
    SoundManager.play(gres.sound.hit)


def _update_tags(self, p):
    port = self.player2portrait(p)
    taganims = port.taganims
    old = {a.for_tag: a for a in taganims if hasattr(a, 'for_tag')}
    old_tags = set(old.keys())
    new_tags = set()

    updated_tags = set()

    from .ui_meta.tags import tags as tags_meta

    for t in list(p.tags):
        meta = tags_meta.get(t)
        if meta and meta.display(p, p.tags[t]):
            new_tags.add(t)

    for t in old_tags:  # to be removed
        if t in new_tags:
            anim = tags_meta[t].tag_anim(p)
            if old[t].image == anim:
                continue
            else:
                updated_tags.add(t)
                # fallthrough

        old[t].delete()
        taganims.remove(old[t])

    # for t in new_tags - old_tags: # to be added
    for t in updated_tags | (new_tags - old_tags):  # to be added
        a = TagAnim(
            tags_meta[t].tag_anim(p),
            0, 0,
            tags_meta[t].description,
            parent=self,
        )
        a.for_tag = t
        taganims.append(a)

    port.tagarrange()


def after_launch_effect(self, act):
    _update_tags(self, act.source)
    for p in act.target_list:
        _update_tags(self, p)


def action_stage_effect_before(self, act):
    _update_tags(self, act.target)

action_stage_effect_after = action_stage_effect_before


def player_turn_effect(self, act):
    p = act.target
    port = self.player2portrait(p)
    if not hasattr(self, 'turn_frame') or not self.turn_frame:
        self.turn_frame = LoopingAnim(
            common_res.turn_frame,
            batch=self.animations
        )
    self.turn_frame.position = (port.x - 6, port.y - 4)
    self.prompt_raw('--------------------\n')
    for _p in Game.getgame().players:
        _update_tags(self, _p)


def player_death_update(self, act):
    self.player2portrait(act.target).update()
    _update_tags(self, act.target)


def player_turn_after_update(self, act):
    global input_snd_enabled
    player_death_update(self, act)
    if act.target is Game.getgame().me:
        input_snd_enabled = True


def _aese(_type, self, act):
    meta = getattr(act, 'ui_meta', None)
    if not meta: return
    prompt = getattr(meta, _type, None)
    if not prompt: return
    s = prompt(act)
    if s is not None:
        if isinstance(s, (tuple, list)):
            [self.prompt(i) for i in s]
        else:
            self.prompt(s)


action_effect_string_before = partial(_aese, 'effect_string_before')
action_effect_string_after = partial(_aese, 'effect_string')
action_effect_string_apply = partial(_aese, 'effect_string_apply')


def action_effect_before(self, act):
    action_effect_string_before(self, act)
    if hasattr(act, 'ui_meta'):
        rays = getattr(act.ui_meta, 'ray', None)
        rays = rays(act) if rays else []
        for f, t in rays:
            self.ray(f, t)


class UIPindianEffect(Panel):
    def __init__(self, act, *a, **k):
        w = 20 + 91 + 20 + 91 + 20
        h = 20 + 125 + 20 + 20 + 20

        self.action = act
        src = act.source
        tgt = act.target

        self.lbls = batch = pyglet.graphics.Batch()

        self.srclbl = Label(
            text=src.ui_meta.char_name, x=20+91//2, y=165, font_size=12,
            color=(255, 255, 160, 255), shadow=(2, 0, 0, 0, 230),
            anchor_x='center', anchor_y='bottom', batch=batch
        )

        self.tgtlbl = Label(
            text=tgt.ui_meta.char_name, x=20+91+20+91//2, y=165, font_size=12,
            color=(255, 255, 160, 255), shadow=(2, 0, 0, 0, 230),
            anchor_x='center', anchor_y='bottom', batch=batch
        )

        Panel.__init__(self, width=1, height=1, zindex=5, *a, **k)
        parent = self.parent
        self.x, self.y = (parent.width - w)//2, (parent.height - h)//2 + 20
        self.width, self.height = w, h
        self.update()

    def draw(self):
        Panel.draw(self)
        self.lbls.draw()

    def on_message(self, _type, *args):
        if _type == 'evt_action_after' and isinstance(args[0], Pindian):
            rst = args[0].succeeded
            if rst:
                self.tgtcs.gray = True
                self.srclbl.color = (80, 255, 80, 255)
                self.tgtlbl.color = (0, 0, 0, 0)
            else:
                self.srccs.gray = True
                self.tgtlbl.color = (80, 255, 80, 255)
                self.srclbl.color = (0, 0, 0, 0)

            self.srccs.update()
            self.tgtcs.update()

            pyglet.clock.schedule_once(lambda *a: self.delete(), 2)

        elif _type == 'evt_pindian_card_revealed':
            self.srccs.update()
            self.tgtcs.update()

        elif _type == 'evt_pindian_card_chosen':
            p, card = args[0]
            if p is self.action.source:
                self.srccs = CardSprite(card, parent=self, x=20, y=20)
            else:
                self.tgtcs = CardSprite(card, parent=self, x=20+91+20, y=20)
        
            from .. import actions
            card_migration_effects(
                self.parent, (
                    actions.DropUsedCard(p, [card]),
                    [card],
                    card.resides_in,
                    self.parent.game.deck.droppedcards,
                )
            )


def pindian_effect(self, act):
    UIPindianEffect(act, parent=self)


def input_snd_prompt():
    SoundManager.play(common_res.sound.input)


input_snd_enabled = True


def user_input_effects(self, ilet):
    global input_snd_enabled
    import sys
    if sys.platform == 'win32':
        from ctypes import windll
        u = windll.user32
        from client.ui.base.baseclasses import main_window
        if u.GetForegroundWindow() != main_window._hwnd:
            u.FlashWindow(main_window._hwnd, 1)

    g = Game.getgame()
    if getattr(g, 'current_turn', None) is not g.me:
        input_snd_enabled = True

    # HACK
    if input_snd_enabled:
        if isinstance(ilet, ActionInputlet) and isinstance(ilet.initiator, RejectHandler):
            input_snd_prompt()

    if getattr(g, 'current_turn', None) is g.me:
        input_snd_enabled = False


mapping_actions = ddict(dict, {
    'before': {
        Pindian: pindian_effect,
        ActionStage: action_stage_effect_before,
        PlayerTurn: player_turn_effect,
        Action: action_effect_before,
    },
    'apply': {
        Action: action_effect_string_apply,
        Damage: damage_effect,
    },
    'after': {
        PlayerDeath: player_death_update,
        LaunchCard: after_launch_effect,
        ActionStage: action_stage_effect_after,
        PlayerTurn: player_turn_after_update,
        Action: action_effect_string_after,
    }
})


def action_effects(_type, self, act):
    cls = act.__class__

    if isinstance(act, UserAction):
        g = self.game
        for p in g.players:
            _update_tags(self, p)

    while cls is not object:
        f = mapping_actions[_type].get(cls)
        if f: f(self, act)
        cls = cls.__base__


def user_input_start_effects(self, arg):
    trans, ilet = arg
    cturn = getattr(self, 'current_turn', None)

    if trans.name == 'ActionStageAction':
        self.dropcard_area.fade()

    if trans.name == 'ChooseGirl':
        self.prompt(u'|R%s|r正在选择……' % ilet.actor.account.username)

    p = ilet.actor
    port = self.player2portrait(p)
    if p is not cturn:
        # drawing turn frame
        port.actor_frame = LoopingAnim(
            common_res.actor_frame,
            x=port.x - 6, y=port.y - 4,
            batch=self.animations
        )

    pbar = SmallProgressBar(
        parent=self,
        x=port.x, y=port.y - 15,
        width=port.width,
        # all animations have zindex 2,
        # turn/target frame will overdrawn on this
        # if zindex<2
        zindex=3,
    )

    pbar.value = LinearInterp(
        1.0, 0.0, ilet.timeout,
        on_done=lambda self, desc: self.delete(),
    )
    port.actor_pbar = pbar


def user_input_finish_effects(self, arg):
    trans, ilet, rst = arg
    p = ilet.actor

    port = self.player2portrait(p)
    if getattr(port, 'actor_frame', False):
        port.actor_frame.delete()
        port.actor_frame = None

    if getattr(port, 'actor_pbar', False):
        port.actor_pbar.delete()
        port.actor_pbar = None


def game_roll_prompt(self, pl):
    self.prompt(u'Roll点顺序：')
    for p in pl:
        self.prompt(p.account.username)
    self.prompt_raw('--------------------\n')


def game_roll_result_prompt(self, p):
    self.prompt(u'|R%s|r点数最大' % p.account.username)


def reseat_effects(self, _):
    pl = self.game.players.rotate_to(self.game.me)
    ports = [self.player2portrait(p) for p in pl]
    assert set(ports) == set(self.char_portraits)
    locations = self.gcp_location[:len(self.game.players)]
    for port, (x, y, tp, _) in zip(ports, locations):
        port.tag_placement = tp
        port.animate_to(x, y)
        port.update()
    self.char_portraits[:] = ports


def mutant_morph_effects(self, mutant):
    meta = mutant.ui_meta
    gs = self.get_game_screen()

    gs.set_flash(5.0)
    gs.set_color(getattr(Colors, meta.color_scheme))
    gs.backdrop = meta.wallpaper
    SoundManager.instant_switch_bgm(meta.bgm)


class UIShowCardsEffect(Panel):
    def __init__(self, target, cards, *a, **k):
        Panel.__init__(
            self, x=1, y=1, width=1, height=1, zindex=5,
            *a, **k
        )
        self.lbls = lbls = pyglet.graphics.Batch()

        w, h = 95 * len(cards), 125
        w = 30 + w + 30
        h = 60 + h + 50

        def lbl(text, x, y):
            Label(
                text=text, x=x, y=y, font_size=12,
                anchor_x='center', anchor_y='center',
                color=(255, 255, 160, 255), shadow=(2, 0, 0, 0, 230),
                batch=lbls,
            )

        lbl(u'%s展示的牌' % target.ui_meta.char_name, w//2, h-25)

        parent = self.parent
        self.x, self.y = (parent.width - w)//2, (parent.height - h)//2
        self.width, self.height = w, h
        self.update()

        for i, c in enumerate(cards):
            cs = CardSprite(c, parent=self, x=30 + 95 * i, y=60)
            cs.associated_card = c

        btn = Button(parent=self, caption=u'看完了', x=w-122, y=15, width=100, height=30)

        @btn.event
        def on_click(*a):
            self.delete()

        pyglet.clock.schedule_once(lambda _: self.delete(), 0.5 + len(cards) * 1.2)

    def draw(self):
        Panel.draw(self)
        self.lbls.draw()


def showcards_effect(self, arg):
    target, cards = arg
    UIShowCardsEffect(target, cards, parent=self)


def fatetell_effect(self, act):
    from gamepack.thb.ui.ui_meta.common import card_desc

    act_name = None

    try:
        card = act.initiator.associated_card
        act_name = card.ui_meta.name
    except AttributeError:
        pass

    try:
        act_name = act.initiator.ui_meta.fatetell_display_name
    except AttributeError:
        pass

    if act_name:
        prompt = u'|G【%s】|r进行了一次判定（|G%s|r），结果为%s。' % (
            act.target.ui_meta.char_name,
            act_name,
            card_desc(act.card)
        )
    else:
        prompt = u'|G【%s】|r进行了一次判定，结果为%s。' % (
            act.target.ui_meta.char_name,
            card_desc(act.card)
        )

    self.prompt(prompt)

mapping_events = ddict(bool, {
    'action_before': partial(action_effects, 'before'),
    'action_apply': partial(action_effects, 'apply'),
    'action_after': partial(action_effects, 'after'),
    'fatetell': fatetell_effect,
    'user_input_start': user_input_start_effects,
    'user_input': user_input_effects,
    'user_input_finish': user_input_finish_effects,
    'card_migration': card_migration_effects,
    'choose_target': before_launch_card_effects,
    'game_roll': game_roll_prompt,
    'game_roll_result': game_roll_result_prompt,
    'reseat': reseat_effects,
    'mutant_morph': mutant_morph_effects,
    'showcards': showcards_effect,
})


def handle_event(self, _type, data):
    f = mapping_events.get(_type)
    if f: f(self, data)

########NEW FILE########
__FILENAME__ = game_controls
# -*- coding: utf-8 -*-

# -- stdlib --

# -- third party --
from pyglet.gl import GL_CLIENT_VERTEX_ARRAY_BIT, GL_QUADS, GL_T2F_C4F_N3F_V3F, GL_T4F_V4F
from pyglet.gl import GLfloat, glColor3f, glColor4f, glDrawArrays, glInterleavedArrays
from pyglet.gl import glLoadIdentity, glPopClientAttrib, glPopMatrix, glPushClientAttrib
from pyglet.gl import glPushMatrix, glRotatef, glScalef, glTranslatef, glRectf
from pyglet.text import Label
import pyglet

# -- own --
from ..cards import CardList
from client.ui.base import Control
from client.ui.base.interp import CosineInterp, FixedInterp, LinearInterp, SineInterp
from client.ui.base.interp import getinterp, InterpDesc, ChainInterp, AbstractInterp
from client.ui.controls import BalloonPromptMixin
from client.ui.controls import Frame, Panel, Button, Colors, ImageButton, TextArea, OptionButton
from client.ui.resource import resource as common_res, get_atlas
from game.autoenv import Game
from .. import actions
from resource import resource as game_res
from utils import flatten, rectv2f, rrectv2f


# -- code --
class CardSprite(Control, BalloonPromptMixin):
    x = InterpDesc('_x')
    y = InterpDesc('_y')
    back_scale = InterpDesc('_bs')
    question_scale = InterpDesc('_qs')
    ftanim_alpha = InterpDesc('_fta')
    ftanim_cardalpha = InterpDesc('_ftca')
    shine_alpha = InterpDesc('_shine_alpha')
    alpha = InterpDesc('_alpha')
    width, height = 91, 125

    def __init__(self, card, x=0.0, y=0.0, *args, **kwargs):
        Control.__init__(self, *args, **kwargs)

        self._w, self._h = 91, 125
        self.shine = False
        self.gray = False
        self.x, self.y = x, y
        self.shine_alpha = 0.0
        self.alpha = 1.0
        self.card = card

        self.ft_anim = False

        self.update()

    @staticmethod
    def batch_draw(csl):
        glPushMatrix()
        glLoadIdentity()

        vertices = []
        for cs in csl:
            ax, ay = cs.abs_coords()
            if cs.ft_anim:
                qs = cs.question_scale
                bs = cs.back_scale
                aa = cs.ftanim_alpha
                ca = cs.ftanim_cardalpha
                if cs.gray:
                    c = (.66, .66, .66, ca)
                else:
                    c = (1., 1., 1., ca)
                vertices += cs.img.get_t2c4n3v3_vertices(c, ax, ay)

                n, s = cs.number, cs.suit
                if n: vertices += game_res.cardnum[s % 2 * 13 + n - 1].get_t2c4n3v3_vertices(c, ax + 5, ay + 105)
                if s: vertices += game_res.suit[s - 1].get_t2c4n3v3_vertices(c, ax + 6, ay + 94)

                c = (1, 1, 1, aa)

                if qs:
                    vertices += game_res.card_question.get_t2c4n3v3_vertices(c, ax+(1-qs)*45, ay, 0, qs*91)

                if bs:
                    vertices += game_res.card_hidden.get_t2c4n3v3_vertices(c, ax+(1-bs)*45, ay, 0, bs*91)
            else:
                a = cs.alpha
                if cs.gray:
                    c = (.66, .66, .66, a)
                else:
                    c = (1., 1., 1., a)
                vertices += cs.img.get_t2c4n3v3_vertices(c, ax, ay)
                resides_in = cs.card.resides_in
                if resides_in and resides_in.type == 'showncards':
                    vertices += game_res.card_showncardtag.get_t2c4n3v3_vertices(c, ax, ay)

                n, s = cs.number, cs.suit
                if n: vertices += game_res.cardnum[s % 2 * 13 + n - 1].get_t2c4n3v3_vertices(c, ax + 5, ay + 105)
                if s: vertices += game_res.suit[s-1].get_t2c4n3v3_vertices(c, ax+6, ay+94)

                vertices += game_res.card_shinesoft.get_t2c4n3v3_vertices(
                    (1., 1., 1., cs.shine_alpha), ax-6, ay-6
                )

        if vertices:
            n = len(vertices)
            buf = (GLfloat*n)()
            buf[:] = vertices
            glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT)
            glInterleavedArrays(GL_T2F_C4F_N3F_V3F, 0, buf)
            with get_atlas('card').texture:
                glDrawArrays(GL_QUADS, 0, n/12)
            glPopClientAttrib()

        glPopMatrix()

    def update(self):
        card = self.card
        meta = card.ui_meta

        self.img = meta.image

        self.number, self.suit = card.number, card.suit

        t = getattr(meta, 'description', None)
        if t: self.init_balloon(t)

    def on_mouse_enter(self, x, y):
        self.shine_alpha = 1.0

    def on_mouse_leave(self, x, y):
        self.shine_alpha = SineInterp(1.0, 0.0, 0.3)

    def do_fatetell_anim(self):
        self.ft_anim = True
        self.question_scale = ChainInterp(
            SineInterp(0.0, 1.0, 0.1),
            CosineInterp(1.0, 0.0, 0.1),
            FixedInterp(0.0, 0.2),
            SineInterp(0.0, 1.0, 0.1),
            CosineInterp(1.0, 0.0, 0.1),
            FixedInterp(0.0, 0.2),
            SineInterp(0.0, 1.0, 0.1)
        )
        self.back_scale = ChainInterp(
            FixedInterp(0.0, 0.2),
            SineInterp(0.0, 1.0, 0.1),
            CosineInterp(1.0, 0.0, 0.1),
            FixedInterp(0.0, 0.2),
            SineInterp(0.0, 1.0, 0.1),
            CosineInterp(1.0, 0.0, 0.1),
        )
        self.ftanim_alpha = ChainInterp(
            FixedInterp(1.0, 1.0),
            LinearInterp(1.0, 0.0, 2.0),
            on_done=self._end_ft_anim,
        )
        self.ftanim_cardalpha = ChainInterp(
            FixedInterp(0.0, 1.0),
            FixedInterp(1.0, 0.0),
        )

    def _end_ft_anim(self, _self, desc):
        self.ft_anim = False


@staticmethod
def cardarea_batch_draw(cl):
    csl = []
    for c in cl:
        csl += c.control_list
    CardSprite.batch_draw(csl)


class HandCardArea(Control):
    def __init__(self, fold_size=5, *args, **kwargs):
        Control.__init__(self, *args, **kwargs)
        self.fold_size = fold_size
        self.view = kwargs['parent']

    batch_draw = cardarea_batch_draw

    def update(self):
        fsz = self.fold_size
        n = len(self.control_list)
        width = min(fsz * 93.0 + 42, n * 93.0)
        step = (width - 91)/(n - 1) if n > 1 else 0
        for i, c in enumerate(self.control_list):
            c.zindex = i
            try:
                sel = c.hca_selected
            except AttributeError:
                sel = c.hca_selected = False
            c.x = SineInterp(c.x, 2 + int(step * i), 0.6)
            c.y = SineInterp(c.y, 20 if sel else 0, 0.6)

    def toggle(self, c, t):
        s = c.hca_selected = not c.hca_selected
        c.y = SineInterp(c.y, 20 if s else 0, t)
        self.view.notify('selection_change')

    def on_mouse_click(self, x, y, button, modifier):
        c = self.control_frompoint1(x, y)
        c and self.toggle(c, 0.1)

    cards = property(
        lambda self: self.control_list,
        lambda self, x: setattr(self, 'control_list', x)
    )


class PortraitCardArea(Control):
    def hit_test(self, x, y):
        return False

    batch_draw = cardarea_batch_draw

    def arrange(self):
        csl = self.control_list
        if not csl: return
        n = len(csl)

        w, h, = self.width, self.height
        offs = 20
        csw = offs * (n-1) + 93
        cor_x, cor_y = (w - csw)/2, (h - 125)/2
        for i, cs in enumerate(csl):
            if isinstance(getinterp(cs, 'x'), AbstractInterp):
                cs.x = SineInterp(cs.x, i*offs + cor_x, 0.6)
                cs.y = SineInterp(cs.y, cor_y, 0.6)
            else:
                cs.x, cs.y = i*offs + cor_x, cor_y

    def update(self):
        csl = self.control_list
        if not csl: return
        n = len(csl)

        w, h, = self.width, self.height
        offs = 20
        csw = offs * (n-1) + 93
        cor_x, cor_y = (w - csw)/2, (h - 125)/2
        for i, cs in enumerate(csl):
            cs.x = SineInterp(cs.x, i*offs + cor_x, 0.6)
            cs.y = SineInterp(cs.y, cor_y, 0.6)

    def fade(self):
        for cs in self.control_list:
            cs.alpha = ChainInterp(
                FixedInterp(1.0, 0.45),
                CosineInterp(1.0, 0.0, 0.3),
                on_done=self._on_cardanimdone,
            )

    def _on_cardanimdone(self, card, desc):
        card.delete()


class DropCardArea(Control):
    def __init__(self, fold_size=5, *args, **kwargs):
        Control.__init__(self, *args, **kwargs)
        self.fold_size = fold_size

    batch_draw = cardarea_batch_draw

    def update(self):
        fsz = self.fold_size
        n = len(self.control_list)
        width = min(fsz*93.0, n*93.0)
        step = (width - 91)/(n-1) if n > 1 else 0

        if step < 30:
            step = 30
            width = (n-1)*30 + 93

        ox = (self.width - width) // 2

        for i, c in enumerate(self.control_list):
            c.zindex = i
            c.x = SineInterp(c.x, 2 + ox + int(step * i), 0.5)
            c.y = SineInterp(c.y, 0, 0.5)

    def fade(self):
        for cs in self.control_list:
            try:
                cs.dca_tag
                continue
            except AttributeError:
                cs.dca_tag = 1

            cs.alpha = ChainInterp(
                FixedInterp(1.0, 3),
                CosineInterp(1.0, 0.0, 1),
                on_done=self._on_cardanimdone,
            )

    def _on_cardanimdone(self, card, desc):
        card.delete()
        self.update()

    def hit_test(self, x, y):
        return self.control_frompoint1(x, y)


class Ray(Control):
    scale = InterpDesc('_scale')
    alpha = InterpDesc('_alpha')

    def __init__(self, x0, y0, x1, y1, *args, **kwargs):
        Control.__init__(self, *args, **kwargs)
        from math import sqrt, atan2, pi
        self.x, self.y = x0, y0
        dx, dy = x1 - x0, y1 - y0
        scale = sqrt(dx*dx+dy*dy) / common_res.ray.width
        self.angle = atan2(dy, dx) / pi * 180
        self.scale = SineInterp(0.0, scale, 0.4)
        self.alpha = ChainInterp(
            FixedInterp(1.0, 1),
            CosineInterp(1.0, 0.0, 0.5),
            on_done=lambda self, desc: self.delete()
        )

    def draw(self):
        glPushMatrix()
        glRotatef(self.angle, 0., 0., 1.)
        glScalef(self.scale, 1., 1.)
        glTranslatef(0., -common_res.ray.height/2, 0.)
        glColor4f(1., 1., 1., self.alpha)
        common_res.ray.blit(0, 0)
        glPopMatrix()

    def hit_test(self, x, y):
        return False


class SkillSelectionBox(Control):
    class SkillButton(Button):
        def __init__(self, skill, sid, enable, view, *a, **k):
            Button.__init__(self, skill.ui_meta.name, width=71, height=20, *a, **k)
            self.selected = False
            self.state = Button.NORMAL if enable else Button.DISABLED
            self.color = Colors.blue
            self.skill = skill
            self.sid = sid
            self.view = view
            self.params_ui = None
            self.update()

        def on_click(self):
            if self.selected:
                self.parent.selection.remove(self.sid)
                self.color = Colors.blue
                self.selected = False
                self.update()
                ui = self.params_ui
                ui and ui.delete()

            else:
                self.color = Colors.orange
                self.update()
                self.parent.selection.append(self.sid)
                self.selected = True
                pui = getattr(self.skill.ui_meta, 'params_ui', None)
                if pui:
                    self.params_ui = pui(parent=self.view)

            self.view.notify('selection_change')

        def delete(self):
            self.params_ui and self.params_ui.delete()
            Button.delete(self)

    def __init__(self, *a, **k):
        Control.__init__(self, *a, **k)
        self.selection = []

    def set_skills(self, lst):
        # lst = ((skill1, sid1, enable), (skill2, sid2, enable), ...)
        y = self.height
        for b in self.buttons[:]:
            b.delete()

        assert not self.buttons

        for skill, sid, enable in lst:
            y -= 22
            SkillSelectionBox.SkillButton(skill, sid, enable, self.parent, parent=self, x=0, y=y)

        self.selection = []

    @property
    def buttons(self):
        return self.control_list

    def get_selected_index(self):
        return self.selection

    def draw(self):
        self.draw_subcontrols()

    def hit_test(self, x, y):
        return self.control_frompoint1(x, y)


class SmallCardSprite(Control, BalloonPromptMixin):
    width, height = 33, 46
    x = InterpDesc('_x')
    y = InterpDesc('_y')

    def __init__(self, card, x=0.0, y=0.0, *args, **kwargs):
        Control.__init__(self, *args, **kwargs)
        self._w, self._h = 33, 46
        self.x, self.y = x, y
        self.selected = False
        self.hover = False
        self.card = card

        self.img = card.ui_meta.image_small
        self.init_balloon(card.ui_meta.description)

    @staticmethod
    def batch_draw(csl):
        glPushMatrix()
        glLoadIdentity()
        vertices = []
        for cs in csl:
            ax, ay = cs.abs_coords()
            vertices += cs.img.get_t4f_v4f_vertices(ax, ay)

            s = cs.card.suit
            n = cs.card.number

            ssuit = game_res.smallsuit
            snum = game_res.smallnum

            if n == 10:  # special case
                # g[0].blit(1+g[0].vertices[0], 33+g[0].vertices[1])
                # g[1].blit(5+g[1].vertices[0], 33+g[1].vertices[1])
                vertices += snum[s % 2 * 14 + 10].get_t4f_v4f_vertices(ax - 1, ay + 31)
                vertices += snum[s % 2 * 14 + 0].get_t4f_v4f_vertices(ax + 3, ay + 31)
            else:
                vertices += snum[s % 2 * 14 + n].get_t4f_v4f_vertices(ax + 1, ay + 31)

            vertices += ssuit[s - 1].get_t4f_v4f_vertices(ax + 1, ay + 22)

            if cs.selected:
                vertices += game_res.scardframe_selected.get_t4f_v4f_vertices(ax, ay)
            else:
                vertices += game_res.scardframe_normal.get_t4f_v4f_vertices(ax, ay)

        n = len(vertices)
        buf = (GLfloat*n)()
        buf[:] = vertices
        glColor3f(1., 1., 1.)
        glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT)
        glInterleavedArrays(GL_T4F_V4F, 0, buf)
        with get_atlas('card').texture:
            glDrawArrays(GL_QUADS, 0, n/8)

        glPopClientAttrib()
        glPopMatrix()


class EquipCardArea(Control):
    def __init__(self, fold_size=4, view=None, *args, **kwargs):
        Control.__init__(self, *args, **kwargs)
        self.width, self.height = 35*4, 46
        self.fold_size = fold_size
        self.selectable = False
        self.view = view

    @staticmethod
    def batch_draw(cl):
        csl = []
        for c in cl:
            csl += c.control_list
        SmallCardSprite.batch_draw(csl)

    def update(self):
        fsz = self.fold_size
        n = len(self.control_list)
        width = min(fsz*35.0, n*35.0)
        step = int((width - 34) / (n - 1)) if n > 1 else 0
        for i, c in enumerate(self.control_list):
            c.zindex = i
            c.x = SineInterp(c.x, 2 + step * i, 0.4)
            c.y = SineInterp(c.y, 0, 0.4)

    def on_mouse_click(self, x, y, button, modifier):
        if not self.selectable: return
        c = self.control_frompoint1(x, y)
        if c:
            c.selected = not c.selected
            self.view and self.view.notify('selection_change')

    def clear_selection(self):
        for c in self.control_list:
            c.selected = False

        self.view and self.view.notify('selection_change')

    def hit_test(self, x, y):
        return self.control_frompoint1(x, y)

    cards = property(
        lambda self: self.control_list,
        lambda self, x: setattr(self, 'control_list', x)
    )


class ShownCardPanel(Panel):
    current = None

    def __init__(self, character, *a, **k):
        self.character = character
        ShownCardPanel.current = self

        categories = character.showncardlists

        h = 30 + len(categories)*145 + 10
        w = 100 + 6*93.0+30
        self.lbls = lbls = pyglet.graphics.Batch()

        Panel.__init__(self, width=1, height=1, zindex=5, *a, **k)

        y = 30

        i = 0
        for cat in reversed(categories):

            Label(
                text=CardList.ui_meta.lookup[cat.type], x=30, y=y+62+145*i, font_size=12,
                color=(255, 255, 160, 255), shadow=(2, 0, 0, 0, 130),
                anchor_x='left', anchor_y='center', batch=lbls,
            )
            ca = DropCardArea(
                parent=self,
                x=100, y=y+145*i,
                fold_size=6,
                width=6*93, height=125,
            )
            for c in cat:
                cs = CardSprite(c, parent=ca)
                cs.associated_card = c
            ca.update()
            i += 1

        p = self.parent
        self.x, self.y = (p.width - w)//2, (p.height - h)//2
        self.width, self.height = w, h
        self.update()

        btn = ImageButton(
            common_res.buttons.close_blue,
            parent=self,
            x=w-20, y=h-20,
        )

        @btn.event
        def on_click():
            self.delete()

    def draw(self):
        Panel.draw(self)
        self.lbls.draw()

    def delete(self):
        Panel.delete(self)
        ShownCardPanel.current = None


class _CharacterFigure(Control):
    def __init__(self, texture, prompt, parent, *a, **k):
        self.texture = texture
        self.prompt = prompt

        width = texture.width
        height = texture.height

        x = (parent.width - width) // 2
        y = (parent.height - height) // 2

        self._x = x
        self._y = y

        Control.__init__(self, *a, x=x, y=y, width=width, height=height, parent=parent, zindex=999999, **k)

        ta = TextArea(
            parent=self,
            # font_size=12,
            x=2, y=2, width=width, height=100,
        )

        ta.append(prompt)
        h = ta.content_height
        ta.height = h
        self.ta_height = h

    def draw(self):
        glColor3f(1, 1, 1)
        self.texture.blit(0, 0)
        glColor4f(1, 1, 1, 0.65)
        glRectf(0, 0, self.width, self.ta_height)
        self.draw_subcontrols()

    def hit_test(self, x, y):
        return self.control_frompoint1(x, y)

    @property
    def x(self):
        return self._x

    @x.setter
    def x(self, v):
        pass

    @property
    def y(self):
        return self._y

    @y.setter
    def y(self, v):
        pass


class GameCharacterPortrait(Frame, BalloonPromptMixin):
    dropped = False
    fleed = False
    actor_frame = None
    turn_frame = None

    def __init__(self, x=0.0, y=0.0, color=Colors.blue, tag_placement='me', *args, **kwargs):
        self.bg = None
        self.character = None
        self._color = color
        self._disabled = False
        self._last_balloon = None
        self.player = None
        self._selected = False
        self.taganims = []
        self.tag_placement = tag_placement

        Frame.__init__(
            self, width=149, height=195,
            bot_reserve=20, color=color,
            thin_shadow=True,
            **kwargs
        )
        self.view = view = self.parent
        self.x, self.y = x, y

        self.charname_lbl = self.add_label(
            u'', 7, self.height-30,
            width=16, multiline=True,
            font_size=9,
            anchor_x='left', anchor_y='top',
            color=(255, 255, 255, 255),
            shadow=(1, 0, 0, 0, 179),
        )

        self.portcard_area = PortraitCardArea(
            parent=view,
            x=self.x, y=self.y,
            width=self.width, height=self.height,
            zindex=100,
        )
        self.equipcard_area = EquipCardArea(
            view=view, parent=self, x=3, y=6,
        )

        w, h = self.width, self.height

        tbl = view.game.ui_meta.identity_table
        colortbl = view.game.ui_meta.identity_color
        conf = [(tbl[k], getattr(Colors, colortbl[k]), k) for k in tbl]

        self.identity_btn = b = OptionButton(
            conf=conf, default=0, parent=self,
            x=w-42-4, y=h-24-10-18,
            width=42, height=18,
        )

        @b.event
        def on_value_changed(v):
            self.set_color(b.color)

        def tagarrange_bottom():
            x, y = self.x, self.y
            w, h = self.width, self.height
            x += w + 1
            y -= 27
            for a in self.taganims:  # they are pyglet.sprite.Sprite instances
                x -= 27
                a.set_position(x, y)

        def tagarrange_me():
            x, y = self.x, self.y
            w, h = self.width, self.height
            x += w + 6
            y += 142
            for a in self.taganims:  # they are pyglet.sprite.Sprite instances
                a.set_position(x, y)
                x += 27

        def tagarrange_right():
            x, y = self.x, self.y
            w, h = self.width, self.height
            x += w + 3
            y += 1
            for a in self.taganims:  # they are pyglet.sprite.Sprite instances
                a.set_position(x, y)
                y += 27

        def tagarrange_left():
            x, y = self.x, self.y
            w, h = self.width, self.height
            x -= 28
            y += 1
            for a in self.taganims:  # they are pyglet.sprite.Sprite instances
                a.set_position(x, y)
                y += 27

        self._tagarrange_funcs = {
            'bottom': tagarrange_bottom,
            'me': tagarrange_me,
            'left': tagarrange_left,
            'right': tagarrange_right,
        }

        showncard_btn = ImageButton(
            common_res.buttons.port_showncard,
            parent=self,
            x=self.width - 22, y=90,
        )

        @showncard_btn.event  # noqa
        def on_click():
            p = self.character
            if not p: return
            if not p.showncardlists: return  # before the 'real' game_start
            last = ShownCardPanel.current
            if last:
                last.delete()
                if last.character is p:
                    return

            ShownCardPanel(p, parent=self.view)

    def update(self):
        p = self.player
        if not p: return

        nick = u"<%s>" % p.account.username
        if self.dropped:
            if self.fleed:
                prefix = u'(逃跑)'
            else:
                prefix = u'(掉线)'

            nick = prefix + nick

        self.caption = nick
        char = self.character

        if char:
            meta = char.ui_meta
            self.bg = meta.port_image
            self.update_bg()
            self.set_charname(meta.char_name)
            if self._last_balloon != meta.description:
                self.init_balloon(meta.description, (2, 74, 145, 96))
                self._last_balloon = meta.description

        self.bot_reserve = 74
        self.gray_tex = None
        Frame.update(self)
        self.update_position()
        self.update_color()
        self.tagarrange()

    def balloon_show(self):
        try:
            meta = self.character.ui_meta
            figure_image = meta.figure_image
        except:
            return BalloonPromptMixin.balloon_show(self)

        try:
            figure_image_alter = meta.figure_image_alter
            if figure_image_alter.decrypted:
                figure_image = figure_image_alter

        except:
            pass

        return _CharacterFigure(
            figure_image.get(),
            meta.description,
            parent=self.parent,
        )

    @property
    def color(self):
        if not self.character:
            return self._color

        if self.character.dead:
            return Colors.gray

        return self._color

    @property
    def bg(self):
        if not self.character:
            return self._bg

        if self.character.dead:
            return self._bg.grayed

        return self._bg

    @bg.setter
    def bg(self, val):
        self._bg = val

    def _fill_batch(self, batch):
        Frame._fill_batch(self, batch)
        self._gcp_framevlist = batch.add(16, GL_QUADS, self.frame_group, 'c4B', 'v2f')
        self._highlight_disabled = batch.add(4, GL_QUADS, self.top_group, 'c4B', 'v2f')
        self._highlight = batch.add(4, GL_QUADS, self.top_group, 'c4B', 'v2f')

        self.selected = self.selected
        self.disabled = self.disabled
        GameCharacterPortrait.update_position(self)
        GameCharacterPortrait.update_color(self)

    def set_postion(self, x, y):
        Frame.set_position(self, x, y)
        GameCharacterPortrait.update_position(self)

    def update_position(self):
        Frame.update_position(self)
        w, h = self.width, self.height
        ax, ay = self.abs_coords()
        self._gcp_framevlist.vertices[:] = flatten([
            rectv2f(2, 2, w-4, 54-2, ax, ay),  # equip box
            rrectv2f(2.5, 2.5, 4*36, 52, ax, ay),  # equip box border
            rectv2f(w-2-32, 66, 32, 22, ax, ay),  # cardnum box
            rrectv2f(w-2-32, 66, 32, 22, ax, ay),  # cardnum box border
        ])

        full = rectv2f(0, 0, w, h, ax, ay)
        self._highlight_disabled.vertices[:] = full
        self._highlight.vertices[:] = full

        if self.actor_frame:
            self.actor_frame.set_position(self.x - 6, self.y - 4)

        if self.turn_frame:
            self.turn_frame.set_position(self.x - 6, self.y - 4)

    def set_color(self, color):
        Frame.set_color(self, color)
        GameCharacterPortrait.update_color(self)

    def update_color(self):
        Frame.update_color(self)
        C = Colors.get4i
        c = self.color
        heavy = C(c.heavy); light = C(c.light)
        self._gcp_framevlist.colors = flatten([
            [255, 255, 255, 255] * 4,  # equip box
            [heavy] * 4,  # equip box border
            [light] * 4,  # cardnum box
            [heavy] * 4,  # cardnum box border
        ])

    def set_charname(self, char_name):
        self.charname_lbl.text = char_name

    @property
    def disabled(self):
        return self._disabled

    @disabled.setter
    def disabled(self, val):
        self._disabled = val
        color = (0, 0, 0, 128) if val else (0, 0, 0, 0)
        self._highlight_disabled.colors[:] = color * 4

    @property
    def selected(self):
        return self._selected

    @selected.setter
    def selected(self, val):
        self._selected = val
        color = (255, 255, 204, 153) if val else (0, 0, 0, 0)
        self._highlight.colors[:] = color * 4

    @staticmethod
    def batch_draw_status(gcps):
        glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT)
        vertices = []
        for port in gcps:
            char = port.character
            if not char: continue

            hp = game_res.hp; hp_bg = game_res.hp_bg
            if char.dead:
                hp = hp.grayed
                hp_bg = hp_bg.grayed

            # hp bar
            w = hp.width
            x = port.x; y = port.y
            for i in xrange(char.maxlife):
                vertices.extend(
                    hp_bg.get_t4f_v4f_vertices(5+x+i*w, 56+y)
                )

            for i in xrange(max(char.life, 0)):
                vertices.extend(
                    hp.get_t4f_v4f_vertices(5+x+i*w, 56+y)
                )

        nums = game_res.num
        for port in gcps:
            x, y, w, h = port.x, port.y, port.width, port.height
            char = port.character
            if not char: continue

            n = len(char.cards) + len(char.showncards)
            seq = str(n)
            ox = (32 - len(seq)*14)//2
            for i, ch in enumerate(seq):
                n = ord(ch) - ord('0')
                #x, y = w - 34 + ox + i*14, 68
                vertices.extend(nums[n].get_t4f_v4f_vertices(
                    x + w - 34 + ox + i*14,
                    y + 68
                ))

        if vertices:
            with nums[0].owner:
                n = len(vertices)
                buf = (GLfloat*n)()
                buf[:] = vertices
                glInterleavedArrays(GL_T4F_V4F, 0, buf)
                glDrawArrays(GL_QUADS, 0, n/8)

        glPopClientAttrib()

    @staticmethod
    def batch_draw(gcps):
        glPushMatrix()
        glLoadIdentity()
        Frame.batch_draw(gcps)
        GameCharacterPortrait.batch_draw_status(gcps)
        glPopMatrix()
        cl = []
        map(cl.extend, [p.control_list for p in gcps])
        Control.do_draw(cl)

    @property
    def zindex(self):
        return 0

    @zindex.setter
    def zindex(self, val):
        pass

    def delete(self):
        Frame.delete(self)
        self.portcard_area.delete()

    def tagarrange(self):
        self._tagarrange_funcs[self.tag_placement]()

    def on_message(self, _type, *args):
        if _type == 'evt_action_after' and isinstance(args[0], actions.RevealIdentity):
            act = args[0]
            g = Game.getgame()
            me = g.me
            if (act.target in (self.player, self.character)) and (me in act.to if isinstance(act.to, list) else me is act.to):
                btn = self.identity_btn
                btn.value = act.target.identity.type
                btn.state = Button.DISABLED
                btn.update()
                # self.update()
        elif _type == 'evt_switch_character':
            p = args[0]
            if p.player is self.player:
                self.character = p
                self.update()

    def animate_to(self, x, y):
        tx = SineInterp(self.x, x, 1)
        ty = SineInterp(self.y, y, 1)
        pca = self.portcard_area

        def _update(dt):
            if tx.finished:
                pyglet.clock.unschedule(_update)
                self.identity_btn.update()
                return

            pca.x = x
            pca.y = y
            self.set_position(tx.value, ty.value)

        pyglet.clock.schedule_interval_soft(_update, 1/60.0)

########NEW FILE########
__FILENAME__ = inputs
# -*- coding: utf-8 -*-

import itertools
import logging
import math
import random

log = logging.getLogger('THBattleUI_Input')

import pyglet

from game.autoenv import Game
from gamepack.thb import actions as thbactions
from gamepack.thb.cards import CardList, RejectHandler

from pyglet.text import Label

from client.ui.controls import BalloonPromptMixin, BigProgressBar
from client.ui.controls import Button, ConfirmButtons, Control
from client.ui.controls import ImageButton, ImageSelector
from client.ui.controls import Panel

from client.ui.base.interp import AbstractInterp, getinterp, InterpDesc, LinearInterp, SineInterp

from client.ui.resource import resource as common_res
from .game_controls import DropCardArea, CardSprite


class InputHandler(object):
    def process_user_input_start(self, ilet):
        pass

    def process_user_input(self, ilet):
        pass

    def process_user_input_finish(self, ilet, rst):
        pass

    def delete(self):
        pass

    def cleanup(self):
        pass


class UIActionConfirmButtons(ConfirmButtons):
    DEFAULT_BUTTONS = ((u'确定', True), (u'结束', False))

    def __init__(self, buttons=DEFAULT_BUTTONS, delay=0.5, **k):
        self._valid = True
        ConfirmButtons.__init__(self, buttons=buttons, delay=delay, **k)

    def update(self):
        for b in self.buttons:
            b.state = Button.DISABLED if self.disabled else Button.NORMAL

        if not self.valid:
            self.buttons[0].state = Button.DISABLED

    @property
    def valid(self):
        return self._valid

    @valid.setter
    def valid(self, valid):
        self._valid = valid
        self.update()

    def disable(self):
        self.disabled = True
        self.update()

    def enable(self):
        self.disabled = False
        self.update()


class UISelectTarget(Control, InputHandler):

    def __init__(self, trans, *a, **k):
        Control.__init__(self, *a, **k)
        self.trans = trans
        self.inputlet = None
        self.label = None
        self.action_params = {}
        self.view = self.parent

        self.x, self.y, self.width, self.height = (285, 162, 531, 58)

    def process_user_input(self, ilet):
        view = self.view
        self.confirmbtn = UIActionConfirmButtons(
            parent=self, x=259, y=4, width=165, height=24,
        )
        self.progress_bar = BigProgressBar(parent=self, x=0, y=0, width=250)
        self.label = Label(
            text=u"HEY SOMETHING'S WRONG", x=125, y=28, font_size=12,
            color=(255, 255, 160, 255), shadow=(2, 0, 0, 0, 179),
            anchor_x='center', anchor_y='bottom',
        )

        view.add_observer('selection_change', self._on_selection_change)

        g = Game.getgame()
        port = view.player2portrait(g.me)
        port.equipcard_area.clear_selection()

        # view.notify('selection_change') # the clear_selection thing will trigger this

        @self.confirmbtn.event
        def on_confirm(is_ok):
            is_ok and ilet.set_result(*self.get_result())
            ilet.done()
            end_transaction(self.trans)

        self.progress_bar.value = LinearInterp(
            1.0, 0.0, ilet.timeout,
            on_done=lambda *a: on_confirm(False)
        )

        self.inputlet = ilet

    def set_text(self, text):
        self.label.text = text

    def _on_selection_change(self):
        self.set_valid(False)
        self.on_selection_change()

    def on_selection_change(self):
        # subclasses should surpress it
        self.set_valid()

    def get_result(self):  # override this to customize
        view = self.view
        return [
            view.get_selected_skills(),
            view.get_selected_cards(),
            view.get_selected_players(),
            view.get_action_params(),
        ]

    def hit_test(self, x, y):
        return self.control_frompoint1(x, y)

    def cleanup(self):
        if not self.label: return  # processed user_input
        self.view.end_select_player()

    def set_valid(self, valid=True):
        self.confirmbtn.valid = valid

    def draw(self):
        self.draw_subcontrols()
        lbl = self.label
        lbl and lbl.draw()

    def delete(self):
        self.view.remove_observer('selection_change', self._on_selection_change)
        super(UISelectTarget, self).delete()


class UIDoPassiveAction(UISelectTarget):
    _auto_chosen = False
    _snd_prompt = False
    _in_auto_reject_delay = False

    def process_user_input(self, ilet):
        UISelectTarget.process_user_input(self, ilet)

        initiator = ilet.initiator
        candidates = ilet.candidates

        g = Game.getgame()
        if isinstance(initiator, RejectHandler):
            ori = self.set_valid
            self._sv_val = False

            def reject_sv(valid=False):
                self._sv_val = True

            self.set_valid = reject_sv

            def delay(dt):
                self.set_valid = ori
                if self._sv_val: ori()

            pyglet.clock.schedule_once(delay, 0.1 + 0.2 * math.sqrt(g.players.index(g.me)))

        if candidates:
            parent = self.parent
            disables = [p for p in g.players if p not in candidates]
            parent.begin_select_player(disables)

        self.view.notify('selection_change')

    def on_selection_change(self):
        try:
            ilet = self.inputlet
            if not ilet: return
            if self._in_auto_reject_delay: return

            initiator = ilet.initiator
            categories = ilet.categories
            candidates = ilet.candidates

            g = Game.getgame()
            view = self.parent
            if not view: return

            cond = initiator.cond
            usage = getattr(initiator, 'card_usage', 'none')

            if isinstance(initiator, RejectHandler):
                self._sv_val = False
                self.set_text(u'自动结算好人卡…')
                if not any([cond([c]) for c in itertools.chain(g.me.cards, g.me.showncards)]):
                    from gamepack.thb.characters import reimu
                    if not (isinstance(g.me, reimu.Reimu) and not g.me.dead):  # HACK: but it works fine
                        self._in_auto_reject_delay = True
                        v = 0.3 - math.log(random.random())
                        self.set_text(u'自动结算好人卡(%.2f秒)' % v)

                        def complete(*a):
                            ilet.done()
                            end_transaction(self.trans)

                        pyglet.clock.schedule_once(complete, v)
                        return

            if categories:
                if not self._auto_chosen:
                    self._auto_chosen = True
                    from itertools import chain
                    for c in chain(g.me.showncards, g.me.cards):
                        if not cond([c]): continue
                        hca = view.handcard_area
                        for cs in hca.cards:
                            if cs.associated_card == c:
                                break
                        else:
                            raise Exception('WTF?!')

                        hca.toggle(cs, 0.3)
                        return

                skills = view.get_selected_skills()
                cards = rawcards = view.get_selected_cards()
                params = view.get_action_params()

                if skills:
                    for skill_cls in skills:
                        cards = [skill_cls.wrap(cards, g.me, params)]
                        try:
                            rst, reason = cards[0].ui_meta.is_complete(g, cards)
                        except:
                            rst, reason = False, u'[card.ui_meta.is_complete错误]'
                            log.exception('card.ui_meta.is_complete error')

                        if not rst:
                            self.set_text(reason)
                            return

                    usage = cards[0].usage if usage == 'launch' else usage

                c = cond(cards)
                c1, text = initiator.ui_meta.choose_card_text(g, initiator, cards)
                assert c == c1
                self.set_text(text)

                if not c: return

            if candidates:
                players = view.get_selected_players()
                players, valid = initiator.choose_player_target(players)
                try:
                    valid1, reason = initiator.ui_meta.target(players)
                    assert bool(valid) == bool(valid1)
                except:
                    log.exception('act.ui_meta.target error')
                    valid1, reason = valid, u'[act.ui_meta.target错误]'

                view.set_selected_players(players)
                self.set_text(reason)
                if not valid: return

            arg = thbactions.ActionLimitParams(
                ilet=ilet, actor=g.me,
                cards=cards if categories else (),
                players=players if candidates else (),
                usage=usage
            )

            assert not (categories and usage == 'none' and rawcards)

            arg2, permitted = g.emit_event('action_limit', (arg, True))
            assert arg == arg2

            if not permitted:
                self.set_text(u'您不能这样出牌')
                return

            self.set_valid()
        except:
            log.exception('on_selection_change')

    def cleanup(self):
        try:
            hca = self.parent.handcard_area
            for cs in hca.control_list:
                if cs.hca_selected:
                    hca.toggle(cs, 0.3)
        except AttributeError:
            # parent is none, self already deleted
            pass
        UISelectTarget.cleanup(self)


class UIDoActionStage(UISelectTarget):
    # for actions.ActionStage
    #def get_result(self):
    #    pass

    def on_selection_change(self):
        view = self.parent
        skills = view.get_selected_skills()
        cards = rawcards = view.get_selected_cards()
        params = view.get_action_params()

        g = Game.getgame()

        if skills:
            cards = [skills[0].wrap(cards, g.me, params)]
            for skill_cls in skills[1:]:
                try:
                    isc = getattr(cards[0].ui_meta, 'is_complete', None)
                    if not isc:
                        self.set_text(u'您不能像这样组合技能')
                        return
                    rst, reason = isc(g, cards)
                    if not rst:
                        self.set_text(reason)
                        return
                except:
                    self.set_text(u'[card.ui_meta.is_complete错误]')
                    log.exception('card.ui_meta.is_complete error')
                    return

                cards = [skill_cls.wrap(cards, g.me, params)]

        if not cards:
            self.set_text(u'请出牌…')
            view.end_select_player()
            return

        if len(cards) != 1:
            self.set_text(u'请选择一张牌使用')
            view.end_select_player()
            return

        card = cards[0]

        from ..cards import VirtualCard
        if not card.is_card(VirtualCard):
            if not card.resides_in in (g.me.cards, g.me.showncards):
                self.set_text(u'您选择的牌不符合出牌规则')
                view.end_select_player()
                return

        target_list, tl_valid = card.target(g, g.me, view.get_selected_players())
        if target_list is not None:
            view.set_selected_players(target_list)
            disables = []
            # if card.target in (thbcards.t_One, thbcards.t_OtherOne):
            if card.target.__name__ in ('t_One', 't_OtherOne'):
                for p in g.players:
                    act = thbactions.ActionStageLaunchCard(g.me, [p], card)
                    if not act.can_fire():
                        disables.append(p)

            view.begin_select_player(disables)
            for i in disables:
                try:
                    target_list.remove(i)
                except ValueError:
                    pass

        try:
            rst, reason = card.ui_meta.is_action_valid(g, cards, target_list)
        except Exception as e:
            log.exception(e)
            rst, reason = (True, u'[card.ui_meta.is_action_valid错误]')

        self.set_text(reason)
        if not rst:
            return

        if not tl_valid:
            self.set_text(u'您选择的目标不符合规则')
            return

        act = thbactions.ActionStageLaunchCard(g.me, target_list, card)

        if skills:
            card = thbactions.skill_wrap(g.me, skills, rawcards, params, no_reveal=True)

        if card:
            arg = thbactions.ActionLimitParams(
                ilet=self.inputlet, actor=g.me,
                cards=[card],
                players=target_list,
                usage=card.usage,
            )

            assert not (arg.usage == 'none' and rawcards)

            arg2, permitted = g.emit_event('action_limit', (arg, True))
            assert arg == arg2

            if permitted and act.can_fire():
                self.set_valid()
                return

        self.set_text(u'您不能这样出牌')


class GirlSelector(ImageSelector, BalloonPromptMixin):
    x = InterpDesc('_x')
    y = InterpDesc('_y')

    def __init__(self, choice, group, x=0, y=0, *a, **k):

        self.choice = choice
        cc = choice.char_cls
        meta = cc.ui_meta
        pimg = meta.port_image
        self.char_name = meta.char_name
        self.char_maxlife = cc.maxlife

        self.x = x
        self.y = y

        ImageSelector.__init__(
            self, pimg, group,
            *a, **k
        )

        self.init_balloon(meta.description)


class UIChooseGirl(Panel, InputHandler):
    def __init__(self, trans, *a, **k):
        self.trans = trans
        self.pbar = None

        g = Game.getgame()
        choices = trans.mapping[g.me]

        w, h = 500 + 1*160, 390 + 1*113
        Panel.__init__(self, width=w, height=h, zindex=5, *a, **k)
        p = self.parent
        pw, ph = p.width, p.height
        self.x, self.y = (pw - w)/2, (ph - h)/2
        self.inputlet = None
        choices = self.choices = [c for c in choices if c.char_cls and not getattr(c, 'chosen', False)]
        self.selectors = selectors = []
        for i, c in enumerate(choices):
            y, x = divmod(i, 4)
            x, y = 15 + 160*x, 45 + 113*(3 - y)
            gs = GirlSelector(c, selectors, parent=self, x=x, y=y)

            @gs.event
            def on_dblclick(gs=gs):
                c = gs.choice
                ilet = self.inputlet
                if not c.chosen and ilet:
                    ilet.set_choice(c)
                    ilet.done()
                    self.end_selection()

            selectors.append(gs)

    def process_user_input(self, ilet):
        self.inputlet = ilet
        self.begin_selection()

    def on_girl_chosen(self, choice):
        for c in self.selectors:
            if c.choice is choice:
                c.disable()
                break

        self.parent.update_portraits()

    def begin_selection(self):
        self.pbar and self.pbar.delete()
        self.pbar = BigProgressBar(
            parent=self, x=(self.width-250)//2, y=9, width=250,
        )

        def on_done(*a):
            # self.inputlet.done()
            # FIXME: blindly did this.
            self.inputlet and self.inputlet.done()
            self.end_selection()

        self.pbar.value = LinearInterp(
            1.0, 0.0, self.inputlet.timeout,
            on_done=on_done,
        )

    def end_selection(self):
        self.inputlet = None
        self.pbar.delete()


class UIChoosePeerCard(Panel, InputHandler):
    def __init__(self, trans, *a, **k):
        self.trans = trans
        self.lbls = pyglet.graphics.Batch()
        Panel.__init__(self, width=1, height=1, zindex=5, *a, **k)

    def process_user_input(self, ilet):
        target = ilet.target
        categories = [getattr(target, i) for i in ilet.categories]

        h = 40 + len(categories)*145 + 10
        w = 100 + 6*93.0+30

        y = 40
        i = 0
        for cat in reversed(categories):
            if not len(cat):
                h -= 145  # no cards in this category
                continue

            Label(
                text=CardList.ui_meta.lookup[cat.type], font_size=12,
                color=(255, 255, 160, 255), shadow=(2, 0, 0, 0, 230),
                x=30, y=y+62+145*i, anchor_x='left', anchor_y='center',
                batch=self.lbls,
            )

            ca = DropCardArea(
                parent=self,
                x=100, y=y+145*i,
                fold_size=6,
                width=6*93, height=125,
            )
            for c in cat:
                cs = CardSprite(c, parent=ca)
                cs.associated_card = c

                @cs.event
                def on_mouse_dblclick(x, y, btn, mod, cs=cs):
                    ilet.set_card(cs.associated_card)
                    ilet.done()
                    end_transaction(self.trans)

            ca.update()
            i += 1

        p = self.parent
        self.x, self.y = (p.width - w)//2, (p.height - h)//2
        self.width, self.height = w, h
        self.update()

        self.progress_bar = b = BigProgressBar(
            parent=self, x=(w-250)//2, y=7, width=250
        )
        b.value = LinearInterp(
            1.0, 0.0, ilet.timeout,
            on_done=lambda *a: self.cleanup()
        )

        btn = ImageButton(
            common_res.buttons.close_blue,
            parent=self,
            x=w-20, y=h-20,
        )

        @btn.event
        def on_click():
            ilet.done()

    def draw(self):
        Panel.draw(self)
        self.lbls.draw()


class UIChooseOption(Control, InputHandler):

    def __init__(self, trans, *a, **k):
        Control.__init__(self, *a, **k)
        self.trans = trans
        self.label = None

        self.x, self.y, self.width, self.height = (285, 162, 531, 58)

    def process_user_input(self, ilet):
        try:
            ui_meta = ilet.initiator.ui_meta
            choose_option_buttons = ui_meta.choose_option_buttons
            choose_option_prompt = ui_meta.choose_option_prompt
            if callable(choose_option_prompt):
                choose_option_prompt = choose_option_prompt(ilet.initiator)

        except AttributeError:
            choose_option_buttons = ((u'确定', True), (u'结束', False))
            choose_option_prompt = u'UIChooseOption: %s missing ui_meta' % (
                ilet.initiator.__class__.__name__
            )

        self.confirmbtn = UIActionConfirmButtons(
            parent=self, x=259, y=4, width=165, height=24,
            buttons=choose_option_buttons,
        )
        self.progress_bar = b = BigProgressBar(parent=self, x=0, y=0, width=250)
        b.value = LinearInterp(
            1.0, 0.0, ilet.timeout,
            on_done=lambda *a: on_confirm(None)
        )
        self.label = Label(
            text=choose_option_prompt, x=125, y=28, font_size=12,
            color=(255, 255, 160, 255), shadow=(2, 0, 0, 0, 179),
            anchor_x='center', anchor_y='bottom',
        )

        @self.confirmbtn.event
        def on_confirm(val):
            ilet.set_option(val)
            ilet.done()
            end_transaction(self.trans)

    def hit_test(self, x, y):
        return self.control_frompoint1(x, y)

    def draw(self):
        self.draw_subcontrols()
        lbl = self.label
        lbl and lbl.draw()


class UIChooseIndividualCard(Panel, InputHandler):
    def __init__(self, trans, *a, **k):
        self.trans = trans
        Panel.__init__(self, width=1, height=1, zindex=5, *a, **k)

    def process_user_input(self, ilet):
        cards = ilet.cards

        cw = min(6, len(cards)) * 93
        h = 30 + 145 + 10
        w = 30 + cw + 30

        ca = DropCardArea(
            parent=self,
            x=30, y=30,
            fold_size=6,
            width=cw, height=125,
        )

        for c in cards:
            cs = CardSprite(c, parent=ca)
            cs.associated_card = c

            @cs.event
            def on_mouse_dblclick(x, y, btn, mod, cs=cs):
                ilet.set_card(cs.associated_card)
                ilet.done()
                end_transaction(self.trans)

        ca.update()

        p = self.parent
        self.x, self.y = (p.width - w)//2, (p.height - h)//2
        self.width, self.height = w, h
        self.update()

        btn = ImageButton(
            common_res.buttons.close_blue,
            parent=self,
            x=w-20, y=h-20,
        )

        @btn.event
        def on_click():
            ilet.done()
            end_transaction(self.trans)


class UIHarvestChoose(Panel, InputHandler):
    def __init__(self, trans, *a, **k):
        self.trans = trans
        cards = trans.cards
        self.inputlet = None

        w = 20 + (91 + 10) * 4 + 20
        h = 20 + 125 + 20 + 125 + 20 + 20

        self.lbl = Label(
            text=u"等待玩家的其他操作", x=w//2, y=300, font_size=12,
            color=(255, 255, 160, 255), shadow=(2, 0, 0, 0, 230),
            anchor_x='center', anchor_y='bottom'
        )

        Panel.__init__(self, width=1, height=1, zindex=5, *a, **k)
        parent = self.parent
        self.x, self.y = (parent.width - w)//2, (parent.height - h)//2 + 20
        self.width, self.height = w, h
        self.update()

        self.mapping = mapping = {}
        for i, c in enumerate(cards):
            y, x = divmod(i, 4)
            x, y = 20 + (91 + 10) * x, 20 + (125 + 20) * (1 - y)
            cs = CardSprite(c, parent=self, x=x, y=y)
            cs.associated_card = c
            mapping[id(c)] = cs

            @cs.event
            def on_mouse_dblclick(x, y, button, modifier, cs=cs):
                if cs.gray: return
                ilet = self.inputlet
                if not ilet: return
                ilet.set_card(cs.associated_card)
                ilet.done()

    def draw(self):
        Panel.draw(self)
        self.lbl.draw()

    def process_user_input_start(self, ilet):
        self.lbl.text = u'等待%s选择卡牌' % (ilet.actor.ui_meta.char_name)
        self.lbl.color = (255, 255, 160, 255)

    def process_user_input(self, ilet):
        assert ilet.actor is Game.getgame().me
        self.inputlet = ilet
        self.lbl.text = u'请你选择一张卡牌'
        self.lbl.color = (160, 251, 255, 255)

    def process_user_input_finish(self, ilet, rst):
        self.lbl.text = u'等待玩家的其他操作'
        self.lbl.color = (255, 255, 160, 255)
        self.inputlet = None

    def on_harvest_choose(self, card):
        self.mapping[id(card)].gray = True


class Dragger(Control):
    dragging = False

    def __init__(self, *a, **k):
        Control.__init__(self, *a, **k)
        self.width, self.height = self.expected_size(self.rows, self.cols)

    @classmethod
    def expected_size(cls, rows=None, cols=None):
        return (
            (cls.item_width + 4) * (cols or cls.cols),
            (cls.item_height + 15) * (rows or cls.rows),
        )

    def update(self):
        for j, l in enumerate(reversed(self.sprites)):
            for i, cs in enumerate(l):
                nx, ny = self._to_loc(i, j)
                cs.x = SineInterp(cs.x, nx, 0.3)
                cs.y = SineInterp(cs.y, ny, 0.3)
                self.update_sprite(cs, i, j)

        self.dispatch_event('on_update')

    def update_sprite(self, cs, i, j):
        pass

    def init(self):
        self.sprites = [list() for i in xrange(self.rows)]
        self.sprites[0] = self.control_list[:]
        for cs in self.sprites[0]:
            cs.zindex = 0
        self.update()
        self.cur_zindex = 1

    def on_mouse_press(self, x, y, button, modifier):
        c = self.control_frompoint1(x, y)
        if c:
            self.dragging = True
            self.sprite = c

    def on_mouse_drag(self, x, y, dx, dy, button, modifier):
        if not self.dragging: return
        c = self.sprite
        ni = self._to_index(x, y)
        cx, cy = getinterp(c, 'x'), getinterp(c, 'y')
        if isinstance(cx, AbstractInterp): cx = cx._to
        if isinstance(cy, AbstractInterp): cy = cy._to

        oi = self._to_index(cx + self.item_width // 2, cy + self.item_height // 2)
        if oi != ni:
            c.zindex = self.cur_zindex
            self.cur_zindex += 1
            ll = list(reversed(self.sprites))
            ll[oi[1]].remove(c)
            ll[ni[1]].insert(ni[0], c)
            self.update()

    def on_mouse_release(self, x, y, btn, modifier):
        self.dragging = False

    def _to_index(self, x, y):
        return int(x / (self.item_width + 4)), int(y / (self.item_height + 30))

    def _to_loc(self, i, j):
        return i * (self.item_width + 4), j * (self.item_height + 30)

    def draw(self):
        self.draw_subcontrols()

    def get_result(self):
        return self.sprites

Dragger.register_event_type('on_update')


class RanProphetControl(Dragger):
    cols, rows = 5, 2
    item_width, item_height = 91, 125


class UIRanProphet(Panel, InputHandler):
    def __init__(self, trans, parent, *a, **k):
        Panel.__init__(
            self, x=1, y=1, width=1, height=1, zindex=5, parent=parent,
            *a, **k
        )
        self.lbls = pyglet.graphics.Batch()
        self.trans = trans

    def process_user_input(self, ilet):
        cards = ilet.cards

        w, h = RanProphetControl.expected_size()
        w = 100 + w + 20
        h = 60 + h + 50

        def lbl(text, x, y):
            Label(
                text=text, x=x, y=y, font_size=12,
                anchor_x='center', anchor_y='center',
                color=(255, 255, 160, 255), shadow=(2, 0, 0, 0, 230),
                batch=self.lbls,
            )

        lbl(u'牌堆底', 50, 122)
        lbl(u'牌堆顶', 50, 277)
        lbl(u'请拖动调整牌的位置', w//2, h-25)

        parent = self.parent
        self.x, self.y = (parent.width - w)//2, (parent.height - h)//2
        self.width, self.height = w, h
        self.update()

        self.rpc = rpc = RanProphetControl(parent=self, x=100, y=60)
        for i, c in enumerate(cards):
            cs = CardSprite(c, parent=rpc)
            cs.associated_card = c

        rpc.init()

        btn = Button(parent=self, caption=u'调整完成', x=w-120, y=15, width=100, height=30)

        @btn.event
        def on_click(*a):
            up, down = self.rpc.get_result()
            up = [c.associated_card for c in up]
            down = [c.associated_card for c in down]
            ilet.set_result(up, down)
            ilet.done()
            end_transaction(self.trans)

        b = BigProgressBar(parent=self, x=100, y=15, width=250)
        b.value = LinearInterp(1.0, 0.0, ilet.timeout, on_done=on_click)

    def draw(self):
        Panel.draw(self)
        self.lbls.draw()


class CharacterSorterControl(Dragger):
    rows = 1
    item_width, item_height = 145, 96

    def __init__(self, total, limit, *a, **k):
        Dragger.__init__(self, *a, cols=total, **k)
        self.limit = limit

    def update_sprite(self, c, i, j):
        c.disable() if i >= self.limit else c.enable()


class UICharacterSorter(Panel, InputHandler):
    def __init__(self, trans, parent, *a, **k):
        self.trans = trans
        self.lbls = pyglet.graphics.Batch()
        Panel.__init__(
            self, x=1, y=1, width=1, height=1, zindex=5, parent=parent,
            *a, **k
        )

    def process_user_input(self, ilet):
        g = Game.getgame()
        me = g.me
        choices = ilet.mapping[me]
        for i, c in enumerate(choices):
            c._choice_index = i

        w, h = CharacterSorterControl.expected_size(1, ilet.num)
        w = 20 + w + 20
        h = 60 + h + 50

        def lbl(text, x, y):
            Label(
                text=text, font_size=12, x=x, y=y,
                color=(255, 255, 160, 255), shadow=(2, 0, 0, 0, 190),
                anchor_x='center', anchor_y='center', batch=self.lbls,
            )

        lbl(u'请拖动调整角色的出场顺序', w//2, h-25)

        parent = self.parent
        self.x, self.y = (parent.width - w)//2, (parent.height - h)//2
        self.width, self.height = w, h
        self.update()

        self.sorter = sorter = CharacterSorterControl(
            ilet.num, ilet.limit,
            parent=self, x=20, y=60
        )
        selectors = []
        for i, c in enumerate(choices):
            selectors.append(
                GirlSelector(c, selectors, parent=sorter)
            )
        sorter.init()

        btn = Button(parent=self, caption=u'调整完成', x=w-120, y=15, width=100, height=30)

        @btn.event
        def on_click(*a, **k):
            gslist, = self.sorter.get_result()
            index = [c.choice._choice_index for c in gslist]
            ilet.set_result(index)
            ilet.done()
            end_transaction(self.trans)

        b = BigProgressBar(parent=self, x=100, y=15, width=250)
        b.value = LinearInterp(1.0, 0.0, ilet.timeout, on_done=on_click)

    def draw(self):
        Panel.draw(self)
        self.lbls.draw()


class KokoroHopeMaskControl(Dragger):
    cols, rows = 4, 2
    item_width, item_height = 91, 125


class UIKokoroHomeMask(Panel, InputHandler):
    def __init__(self, trans, parent, *a, **k):
        Panel.__init__(
            self, x=1, y=1, width=1, height=1, zindex=5, parent=parent,
            *a, **k
        )
        self.lbls = pyglet.graphics.Batch()
        self.trans = trans

    def process_user_input(self, ilet):
        cards = ilet.cards

        w, h = KokoroHopeMaskControl.expected_size()
        w = 100 + w + 20
        h = 60 + h + 50

        def lbl(text, x, y):
            Label(
                text=text, x=x, y=y, font_size=12,
                anchor_x='center', anchor_y='center',
                color=(255, 255, 160, 255), shadow=(2, 0, 0, 0, 230),
                batch=self.lbls,
            )

        lbl(u'请拖动调整牌的位置，获得的牌必须是同花色的', w // 2, h - 25)
        lbl(u'牌堆顶', 50, 277)
        lbl(u'展示并获得', 50, 122)

        parent = self.parent
        self.x, self.y = (parent.width - w)//2, (parent.height - h)//2
        self.width, self.height = w, h
        self.update()

        self.ctrl = ctrl = KokoroHopeMaskControl(parent=self, x=100, y=60)
        for i, c in enumerate(cards):
            cs = CardSprite(c, parent=ctrl)
            cs.associated_card = c

        ctrl.init()

        btn = Button(parent=self, caption=u'完成', x=w-120, y=15, width=100, height=30)

        @btn.event
        def on_click(*a):
            ilet.done()
            end_transaction(self.trans)

        @ctrl.event
        def on_update():
            putback, acquire = self.ctrl.get_result()
            putback = [c.associated_card for c in putback]
            acquire = [c.associated_card for c in acquire]
            if ilet.is_valid(putback, acquire):
                ilet.set_result(putback, acquire)
                btn.state = Button.NORMAL
            else:
                btn.state = Button.DISABLED

        b = BigProgressBar(parent=self, x=100, y=15, width=250)
        b.value = LinearInterp(1.0, 0.0, ilet.timeout, on_done=on_click)

    def draw(self):
        Panel.draw(self)
        self.lbls.draw()


mapping = {
    # InputTransaction name -> Handler class
    'Action': UIDoPassiveAction,
    'Pindian': UIDoPassiveAction,
    'ActionStageAction': UIDoActionStage,
    'ChooseGirl': UIChooseGirl,
    'ChoosePeerCard': UIChoosePeerCard,
    'ChooseOption': UIChooseOption,
    'ChooseIndividualCard': UIChooseIndividualCard,

    'SortCharacter': UICharacterSorter,

    'HarvestChoose': UIHarvestChoose,

    'Prophet': UIRanProphet,
    'HopeMask': UIKokoroHomeMask,
}


input_handler_mapping = {}  # InputTransaction -> UIControl instance


def end_transaction(trans):
    ui = input_handler_mapping.pop(trans, None)
    ui and ui.cleanup()
    ui and ui.delete()


def handle_event(self, _type, arg):
    g = Game.getgame()
    if _type == 'user_input_transaction_begin':
        trans = arg
        log.debug('Processing user_input_transaction_begin: %s', trans)
        if g.me not in trans.involved:
            return

        last = input_handler_mapping.pop(trans, None)
        last and log.error('WTF?! InputTransaction reentrancy')
        last and last.cleanup()

        cls = mapping.get(trans.name, None)
        if not cls:
            log.error('No appropriate input handler for %s !' % trans.name)
            end_transaction(trans)
            return

        this = cls(trans, parent=self)
        input_handler_mapping[trans] = this
        log.debug('End processing user_input_transaction_begin')

    elif _type == 'user_input_transaction_end':
        log.debug('Processing user_input_transaction_end: %s', arg)
        end_transaction(arg)
        log.debug('End processing user_input_transaction_end')

    elif _type == 'user_input':
        from .effects import input_snd_prompt
        input_snd_prompt()

        trans, ilet = arg
        log.debug('Processing user_input: %s', trans)
        ui = input_handler_mapping.get(trans, None)
        if not ui:
            log.error('WTF: no associated transaction')
            log.error('trans: %r  ilet: %r', trans, ilet)
            log.error('hybrid_stack: %r', g.hybrid_stack)
            log.debug('Error processing user_input: %s', trans)
            return

        def afk_autocomplete(*a):
            self.afk and done()

        def done():
            pyglet.clock.unschedule(afk_autocomplete)
            ilet.event.set()
            log.debug('End processing user_input: %s', trans)

        ilet.done = done
        pyglet.clock.schedule_once(afk_autocomplete, 2)
        ui.process_user_input(ilet)
        log.debug('Processing user_input: %s scheduled', trans)

    elif _type == 'user_input_start':
        trans, ilet = arg
        ilet.actor is g.me and self.refresh_input_state()
        ui = input_handler_mapping.get(trans, None)
        if not ui: return
        ui.process_user_input_start(ilet)

    elif _type == 'user_input_finish':
        trans, ilet, rst = arg
        ilet.actor is g.me and self.refresh_input_state()
        ui = input_handler_mapping.get(trans, None)
        if not ui: return
        ui.process_user_input_finish(ilet, rst)

    elif _type == 'user_input_transaction_feedback':
        trans, evt_name, v = arg
        ui = input_handler_mapping.get(trans, None)
        if not ui: return
        getattr(ui, 'on_' + evt_name)(v)

########NEW FILE########
__FILENAME__ = resource
# -*- coding: utf-8 -*-

from client.ui.resloader import Resource, _ResourceDesc
from client.ui.resloader import anim, bgm, define_atlas, encrypted_texture
from client.ui.resloader import img, img_grid, img_with_grayed, lazytexture
from client.ui.resloader import sound, subdir, texture
import os

respath = os.path.join(os.path.dirname(__file__), 'res')
define_atlas('portrait', (1024, 2048))


class ui_meta(_ResourceDesc):
    __slots__ = ('name', )

    def load(self, loader):
        import gamepack.thb.ui.ui_meta  # noqa


resource = Resource(respath, [
    bgm('bgm_game'),

    [img_with_grayed('thblogo_' + i) for i in [
        '3v3', '8id', '5id', 'kof', 'raid', 'faith',
    ]],

    img('win'), img('lose'),
    anim('hurt', [50, 50, 50, 50, 200, 30, 30, 30, 30, 2000]),

    [img('card_' + i, 'card') for i in [
        'shinesoft', 'hidden', 'question', 'showncardtag',

        'attack', 'graze', 'heal', 'demolition', 'reject', 'sealarray',
        'nazrinrod', 'opticalcloak', 'greenufo', 'redufo', 'sinsack',
        'yukaridimension', 'duel', 'sinsackcarnival', 'mapcannon',
        'hakurouken', 'reactor', 'umbrella', 'roukanken', 'gungnir',
        'laevatein', 'repentancestick', 'wine', 'feast',
        'harvest', 'maidencostume', 'exinwan', 'ibukigourd', 'houraijewel',
        'saigyoubranch', 'ayaroundfan',
        'scarletrhapsodysword', 'deathsickle', 'keystone', 'witchbroom',
        'yinyangorb', 'suwakohat', 'phantom', 'icewing', 'grimoire',
        'dollcontrol', 'donationbox', 'frozenfrog', 'nenshaphone',
        'momijishield',

        'opticalcloak_small', 'greenufo_small', 'redufo_small',
        'hakurouken_small', 'reactor_small', 'umbrella_small',
        'roukanken_small', 'gungnir_small', 'laevatein_small',
        'repentancestick_small', 'maidencostume_small',
        'ibukigourd_small', 'houraijewel_small', 'saigyoubranch_small',
        'ayaroundfan_small', 'scarletrhapsodysword_small',
        'deathsickle_small', 'keystone_small', 'witchbroom_small',
        'yinyangorb_small', 'suwakohat_small', 'phantom_small',
        'icewing_small', 'grimoire_small', 'nenshaphone_small',
        'momijishield_small',
    ]],


    img('scardframe_normal', 'card'),
    img('scardframe_selected', 'card'),

    img_grid('cardnum', 2, 13, 'card'),
    img_grid('suit', 1, 4, 'card'),
    img_grid('smallsuit', 1, 4, 'card'),
    img_grid('smallnum', 2, 14, 'card'),

    anim('tag_sealarray', [83]*36, True),
    anim('tag_wine', [150]*3, True),
    anim('tag_lunaclock', [200]*10, True),
    img('tag_riverside'),
    img('tag_action'),
    img('tag_attacked'),
    img('tag_flandrecs'),
    img('tag_frozenfrog'),
    img('tag_gameintro'),
    img('tag_sinsack'),
    img('tag_ran_ei'),
    img_grid('tag_faiths', 1, 7),

    [img_with_grayed('%s_port' % p, 'portrait') for p in [
        'parsee', 'youmu', 'koakuma', 'marisa', 'daiyousei',
        'flandre', 'nazrin', 'alice', 'yugi', 'tewi',
        'patchouli', 'reimu', 'eirin', 'kogasa', 'shikieiki',
        'tenshi', 'rumia', 'yuuka', 'rinnosuke', 'ran',
        'remilia', 'minoriko', 'meirin', 'suika', 'chen',
        'yukari', 'cirno', 'sakuya', 'sanae', 'akari',
        'seiga', 'kaguya', 'momiji', 'komachi', 'mokou',
        'kokoro', 'mamizou', 'seija', 'kanako', 'medicine',

        'remilia_ex', 'remilia_ex2',
    ]],

    [lazytexture('%s_figure' % p) for p in [
        'daiyousei', 'eirin', 'koakuma', 'yukari', 'komachi',
        'kokoro', 'cirno', 'patchouli',
    ]],

    [encrypted_texture('%s_figure_alter' % p) for p in [
        'komachi', 'patchouli',
    ]],

    img_with_grayed('dummy_port', 'portrait'),

    img_with_grayed('hp', 'portrait'),
    img_with_grayed('hp_bg', 'portrait'),

    img_grid('num', 1, 10, 'portrait'),

    texture('remilia_ex_wallpaper'),

    bgm('bgm_remilia_ex'),

    subdir('sound', [
        sound('hit'),
    ]),

    ui_meta('thb_uimeta'),
])

########NEW FILE########
__FILENAME__ = actions
# -*- coding: utf-8 -*-

from gamepack.thb import actions
from utils import BatchList

from .common import gen_metafunc, card_desc, G

# -----BEGIN ACTIONS UI META-----
__metaclass__ = gen_metafunc(actions)


class DrawCards:
    def effect_string(act):
        return u'|G【%s】|r摸了%d张牌。' % (
            act.target.ui_meta.char_name, act.amount,
        )


class DropCardStage:
    # choose_card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'OK，就这些了')
        else:
            return (False, u'请弃掉%d张牌…' % act.dropn)

    def effect_string(act):
        if act.dropn > 0 and act.cards:
            s = u'、'.join(card_desc(c) for c in act.cards)
            return u'|G【%s】|r弃掉了%d张牌：%s' % (
                act.target.ui_meta.char_name, act.dropn, s,
            )


class Damage:
    update_portrait = True

    def effect_string(act):
        s, t = act.source, act.target
        if s:
            return u'|G【%s】|r对|G【%s】|r造成了%d点伤害。' % (
                s.ui_meta.char_name, t.ui_meta.char_name, act.amount
            )
        else:
            return u'|G【%s】|r受到了%d点无来源的伤害。' % (
                t.ui_meta.char_name, act.amount
            )


class LifeLost:
    update_portrait = True

    def effect_string(act):
        return u'|G【%s】|r流失了%d点体力。' % (
            act.target.ui_meta.char_name, act.amount
        )


class LaunchCard:
    def effect_string_before(act):
        s, tl = act.source, BatchList(act.target_list)
        c = act.card
        from gamepack.thb.cards import Skill
        if isinstance(c, Skill):
            effect_string = getattr(c.ui_meta, 'effect_string', None)
            if effect_string:
                return effect_string(act)
        
        if c:
            return u'|G【%s】|r对|G【%s】|r使用了|G%s|r。' % (
                s.ui_meta.char_name,
                u'】|r、|G【'.join(tl.ui_meta.char_name),
                act.card.ui_meta.name
            )

    def ray(act):
        if getattr(act.card.ui_meta, 'custom_ray', False):
            return []

        s = act.source
        return [(s, t) for t in act.target_list]


class PlayerDeath:
    barrier = True
    update_portrait = True

    def effect_string(act):
        tgt = act.target
        return u'|G【%s】|rMISS了。' % (
            tgt.ui_meta.char_name,
        )


class PlayerRevive:
    barrier = True
    update_portrait = True

    def effect_string(act):
        tgt = act.target
        return u'|G【%s】|r重新回到了场上。' % (
            tgt.ui_meta.char_name,
        )


class TurnOverCard:
    def effect_string(act):
        tgt = act.target
        return u'|G【%s】|r翻开了牌堆顶的一张牌，%s' % (
            tgt.ui_meta.char_name,
            card_desc(act.card)
        )


class RevealIdentity:
    def effect_string(act):
        g = G()
        me = g.me
        if not (me in act.to if isinstance(act.to, list) else me is act.to):
            return

        tgt = act.target
        i = tgt.identity
        try:
            name = u'|G%s|r' % tgt.ui_meta.char_name
        except:
            name = u'|R%s|r' % tgt.account.username

        return u'%s的身份是：|R%s|r' % (
            name,
            G().ui_meta.identity_table[i.type],
        )


class Pindian:
    # choose_card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'不服来战！')
        else:
            return (False, u'请选择一张牌用于拼点')

    def effect_string_before(act):
        return u'|G【%s】|r对|G【%s】|r发起了拼点' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )

    def effect_string(act):
        winner = act.source if act.succeeded else act.target
        return u'|G【%s】|r是人生赢家！' % (
            winner.ui_meta.char_name
        )

# -----END ACTIONS UI META-----

########NEW FILE########
__FILENAME__ = base
# -*- coding: utf-8 -*-

from gamepack.thb import cards
from gamepack.thb.ui.ui_meta.common import gen_metafunc

from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(cards)


class CardList:
    lookup = {
        'cards': u'手牌区',
        'showncards': u'明牌区',
        'equips': u'装备区',
        'fatetell': u'判定区',
        'faiths': u'信仰',
    }


class HiddenCard:
    # action_stage meta
    image = gres.card_hidden
    name = u'隐藏卡片'
    description = u'|R隐藏卡片|r\n\n这张卡片你看不到'

    def is_action_valid(g, cl, target_list):
        return (False, u'这是BUG，你没法发动这张牌…')

########NEW FILE########
__FILENAME__ = basic
# -*- coding: utf-8 -*-

from gamepack.thb import cards
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(cards)


class AttackCard:
    # action_stage meta
    image = gres.card_attack
    name = u'弹幕'
    description = (
        u'|R弹幕|r\n\n'
        u'你的出牌阶段，对除你外，你攻击范围内的一名角色使用，效果是对该角色造成1点伤害。\n'
        u'|B|R>> |r游戏开始时你的攻击范围是1。\n'
        u'|B|R>> |r每个出牌阶段你只能使用一张【弹幕】。'
    )

    def is_action_valid(g, cl, target_list):
        if not target_list:
            return (False, u'请选择弹幕的目标')

        return (True, u'来一发！')


class GrazeCard:
    # action_stage meta
    name = u'擦弹'
    image = gres.card_graze
    description = (
        u'|R擦弹|r\n\n'
        u'当你受到【弹幕】的攻击时，你可以使用一张【擦弹】来抵消【弹幕】的效果。\n'
        u'|B|R>> |r【擦弹】通常情况下只能在回合外使用或打出。\n'
    )

    def is_action_valid(g, cl, target_list):
        return (False, u'你不能主动使用擦弹')


class WineCard:
    # action_stage meta
    name = u'酒'
    image = gres.card_wine
    description = (
        u'|R酒|r\n\n'
        u'使用后获得|B喝醉|r状态。\n'
        u'|B喝醉|r状态下，使用【弹幕】命中后伤害+1，受到致命伤害时伤害-1。\n'
        u'|B|R>> |r效果触发或者轮到自己的行动回合时须弃掉|B喝醉|r状态。'
    )

    def is_action_valid(g, cl, target_list):
        if g.me.tags.get('wine', False):
            return (True, u'你已经醉了，还要再喝吗？')
        return (True, u'青岛啤酒，神主也爱喝！')


class Wine:
    def effect_string(act):
        return u'|G【%s】|r喝醉了…' % act.target.ui_meta.char_name


class WineRevive:
    def effect_string(act):
        return u'|G【%s】|r醒酒了。' % act.target.ui_meta.char_name


class ExinwanCard:
    # action_stage meta
    name = u'恶心丸'
    image = gres.card_exinwan
    description = (
        u'|R恶心丸|r\n\n'
        u'主动使用时没有额外效果。当该牌以任意的方式由手牌/明牌区进入弃牌堆时，引发弃牌动作的玩家需要选择其中一项执行：\n'
        u'|B|R>> |r受到一点伤害，无来源\n'
        u'|B|R>> |r弃两张牌'
    )

    def is_action_valid(g, cl, target_list):
        return (True, u'哼，哼，哼哼……')


class ExinwanEffect:
    # choose_card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'节操给你，离我远点！')
        else:
            return (False, u'请选择两张牌（不选则受到一点无源伤害）')

    def effect_string_before(act):
        return u'|G【%s】|r被恶心到了！' % act.target.ui_meta.char_name


class UseGraze:
    # choose_card meta
    image = gres.card_graze

    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'我闪！')
        else:
            return (False, u'请打出一张【擦弹】…')

    def effect_string(act):
        if not act.succeeded: return None
        t = act.target
        return u'|G【%s】|r打出了|G%s|r。' % (
            t.ui_meta.char_name,
            act.card.ui_meta.name,
        )


class LaunchGraze:
    # choose_card meta
    image = gres.card_graze

    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'我闪！')
        else:
            return (False, u'请使用一张【擦弹】抵消【弹幕】效果…')

    def effect_string(act):
        if not act.succeeded: return None
        t = act.target
        return u'|G【%s】|r使用了|G%s|r。' % (
            t.ui_meta.char_name,
            act.card.ui_meta.name,
        )


class UseAttack:
    # choose_card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'打架？来吧！')
        else:
            return (False, u'请打出一张弹幕…')

    def effect_string(act):
        if not act.succeeded: return None
        t = act.target
        return u'|G【%s】|r打出了|G%s|r。' % (
            t.ui_meta.char_name,
            act.card.ui_meta.name,
        )


class HealCard:
    # action_stage meta
    image = gres.card_heal
    name = u'麻薯'
    description = (
        u'|R麻薯|r\n\n'
        u'【麻薯】能在两种情况下使用：\n'
        u'1、在你的出牌阶段，你可以使用它来回复你的1点体力。\n'
        u'2、当有角色处于濒死状态时，你可以对该角色使用【麻薯】，防止该角色的死亡。\n'
        u'|B|R>> |r出牌阶段，若你没有损失体力，你不可以对自己使用【麻薯】。'
    )

    def is_action_valid(g, cl, target_list):
        target = target_list[0]

        if target.life >= target.maxlife:
            return (False, u'您已经吃饱了')
        else:
            return (True, u'来一口，精神焕发！')


class LaunchHeal:
    # choose_card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'神说，你不能在这里MISS(对%s使用)' % act.target.ui_meta.char_name)
        else:
            return (False, u'请选择一张【麻薯】(对%s使用)…' % act.target.ui_meta.char_name)

    def effect_string(act):
        if act.succeeded:
            return u'|G【%s】|r对|G【%s】|r使用了|G麻薯|r。' % (
                act.source.ui_meta.char_name,
                act.target.ui_meta.char_name,
            )


class Heal:
    def effect_string(act):
        if act.succeeded:
            return u'|G【%s】|r回复了%d点体力。' % (
                act.target.ui_meta.char_name, act.amount
            )

########NEW FILE########
__FILENAME__ = equipment
# -*- coding: utf-8 -*-

from gamepack.thb import actions
from gamepack.thb import cards

from gamepack.thb.ui.ui_meta.common import gen_metafunc, card_desc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid

from gamepack.thb.ui.resource import resource as gres


from utils import BatchList
__metaclass__ = gen_metafunc(cards)


def equip_iav(g, cl, target_list):
    return (True, u'配上好装备，不再掉节操！')


class OpticalCloakCard:
    # action_stage meta
    name = u'光学迷彩'
    image = gres.card_opticalcloak
    image_small = gres.card_opticalcloak_small
    description = (
        u'|R光学迷彩|r\n\n'
        u'装备【光学迷彩】后，每次需要出【擦弹】时（例如受到【弹幕】或【地图炮】攻击时），可以选择判定，若判定结果为红色花色（红桃或方块），则等效于出了一张【擦弹】；否则需再出【擦弹】。'
    )

    is_action_valid = equip_iav


class OpticalCloakSkill:
    # Skill
    name = u'光学迷彩'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class OpticalCloakHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【光学迷彩】吗？'


class OpticalCloak:
    fatetell_display_name = u'光学迷彩'

    def effect_string_before(act):
        return u'|G【%s】|r祭起了|G光学迷彩|r…' % (
            act.target.ui_meta.char_name,
        )

    def effect_string(act):
        if act.succeeded:
            return u'效果拔群！'
        else:
            return u'但是被看穿了…'


class MomijiShieldCard:
    # action_stage meta
    name = u'天狗盾'
    image = gres.card_momijishield
    image_small = gres.card_momijishield_small
    description = (
        u'|R天狗盾|r\n\n'
        u'装备后，黑色【弹幕】对你无效。'
    )

    is_action_valid = equip_iav


class MomijiShieldSkill:
    # Skill
    name = u'天狗盾'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class MomijiShield:
    def effect_string(act):
        return u'被|G天狗盾|r挡下了…'


ufo_desc = (
    u'|R%s|r\n\n'
    u'UFO用来改变自己与其他玩家之间的距离。\n'
    u'|B|R>> |r红色UFO为进攻用，当你计算和其它玩家的距离时,在原有的基础上减少相应距离，若结果小于1则依然视为1。\n'
    u'|B|R>> |r绿色UFO为防守用，当其它玩家计算和你的距离时,在原有的基础上增加相应距离。\n'
    u'|B|R>> |r你可以同时装备两种UFO'
)


class GreenUFOCard:
    # action_stage meta
    name = u'绿色UFO'
    image = gres.card_greenufo
    image_small = gres.card_greenufo_small
    description = ufo_desc % name

    is_action_valid = equip_iav


class GreenUFOSkill:
    # Skill
    name = u'绿色UFO'
    no_display = True
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class RedUFOCard:
    # action_stage meta
    name = u'红色UFO'
    image = gres.card_redufo
    image_small = gres.card_redufo_small
    description = ufo_desc % name

    is_action_valid = equip_iav


class RedUFOSkill:
    # Skill
    name = u'红色UFO'
    no_display = True
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class RoukankenCard:
    # action_stage meta
    name = u'楼观剑'
    image = gres.card_roukanken
    image_small = gres.card_roukanken_small
    description = (
        u'|R楼观剑|r\n\n'
        u'攻击范围3，每当你使用【弹幕】攻击一名角色时，无视该角色的防具。'
    )
    is_action_valid = equip_iav


class RoukankenSkill:
    # Skill
    name = u'楼观剑'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class Roukanken:
    def effect_string_apply(act):
        return u'没有什么防具是|G楼观剑|r斩不断的！'


class ElementalReactorCard:
    # action_stage meta
    name = u'八卦炉'
    image = gres.card_reactor
    image_small = gres.card_reactor_small
    description = (
        u'|R八卦炉|r\n\n'
        u'攻击范围1，出牌阶段可以使用任意张【弹幕】。'
    )

    is_action_valid = equip_iav


class ElementalReactorSkill:
    # Skill
    name = u'八卦炉'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class UmbrellaCard:
    # action_stage meta
    name = u'阳伞'
    image = gres.card_umbrella
    image_small = gres.card_umbrella_small
    description = (
        u'|R阳伞|r\n\n'
        u'装备后符卡造成的伤害对你无效。'
    )

    is_action_valid = equip_iav


class UmbrellaSkill:
    # Skill
    name = u'紫的阳伞'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class UmbrellaEffect:
    def effect_string_before(act):
        a = act.action
        card = getattr(a, 'associated_card', None)
        s = u'|G%s|r' % card.ui_meta.name if card else u''
        return u'|G【%s】|r受到的%s效果被|G阳伞|r挡下了' % (
            act.target.ui_meta.char_name,
            s,
        )


class GungnirCard:
    # action_stage meta
    name = u'冈格尼尔'
    image = gres.card_gungnir
    image_small = gres.card_gungnir_small
    description = (
        u'|R冈格尼尔|r\n\n'
        u'攻击范围3，当你需要使用或打出一张【弹幕】时，你可以将两张手牌当一张【弹幕】来使用或打出。'
    )

    is_action_valid = equip_iav


class GungnirSkill:
    # Skill
    name = u'冈格尼尔'

    def clickable(g):
        try:
            act = g.hybrid_stack[-1]
            if act.cond([cards.GungnirSkill(g.me)]):
                return True

        except (IndexError, AttributeError):
            pass

        return False

    def is_complete(g, cl):
        skill = cl[0]
        me = g.me
        assert skill.is_card(cards.GungnirSkill)
        acards = skill.associated_cards
        if len(acards) != 2:
            return (False, u'请选择2张手牌！')
        elif any(c.resides_in not in (me.cards, me.showncards) for c in acards):
            return (False, u'只能使用手牌发动！')
        return (True, u'反正这条也看不到，偷个懒~~~')

    def is_action_valid(g, cl, target_list, is_complete=is_complete):
        skill = cl[0]
        assert skill.is_card(cards.GungnirSkill)
        rst, reason = is_complete(g, cl)
        if not rst:
            return (rst, reason)
        else:
            return cards.AttackCard.ui_meta.is_action_valid(g, [skill], target_list)

    def effect_string(act):
        # for LaunchCard.effect_string
        source = act.source
        target = act.target
        s = u'|G【%s】|r发动了|G冈格尼尔|r之枪，将两张牌当作|G弹幕|r对|G【%s】|r使用。' % (
            source.ui_meta.char_name,
            target.ui_meta.char_name,
        )
        return s


class ScarletRhapsodyCard:
    # action_stage meta
    name = u'绯想之剑'
    image = gres.card_scarletrhapsodysword
    image_small = gres.card_scarletrhapsodysword_small
    description = (
        u'|R绯想之剑|r\n\n'
        u'攻击范围4，当你使用的【弹幕】是你的最后一张手牌时，你可以为这张【弹幕】指定至多三名目标，然后依次结算之。'
    )

    is_action_valid = equip_iav


class ScarletRhapsodySkill:
    # Skill
    name = u'绯想之剑'

    def clickable(game):
        me = game.me
        try:
            act = game.action_stack[-1]
            if isinstance(act, actions.ActionStage):
                cl = list(me.cards) + list(me.showncards)
                if len(cl) == 1:
                    return True

        except IndexError:
            pass

        return False

    def is_action_valid(g, cl, target_list):
        skill = cl[0]
        assert skill.is_card(cards.ScarletRhapsodySkill)
        acards = skill.associated_cards
        if not (len(acards) == 1 and acards[0].is_card(cards.AttackCard)):
            return (False, u'请选择你的最后一张【弹幕】！')
        else:
            if not target_list:
                return (False, u'请选择弹幕的目标（最多可以选择3名玩家）')

            if g.me in target_list:
                return (True, u'您真的要自残么？！')
            else:
                return (True, u'全人类的绯想天！')

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        source = act.source
        tl = BatchList(act.target_list)

        return u'全人类的绯想天，当然不能只打一个！于是|G【%s】|r选了|G【%s】|r一共%d个目标！' % (
            source.ui_meta.char_name,
            u'】|r、|G【'.join(tl.ui_meta.char_name),
            len(tl),
        )


class RepentanceStickCard:
    # action_stage meta
    name = u'悔悟棒'
    image = gres.card_repentancestick
    image_small = gres.card_repentancestick_small
    description = (
        u'|R悔悟棒|r\n\n'
        u'攻击范围2，当你使用【弹幕】造成伤害时，你可以防止此伤害，改为弃置该目标角色的两张牌（弃完第一张再弃第二张）。'
    )

    is_action_valid = equip_iav


class RepentanceStickSkill:
    # Skill
    name = u'悔悟棒'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class RepentanceStickHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【悔悟棒】吗？'


class RepentanceStick:
    def effect_string_before(act):
        return (
            u'|G【%s】|r用|G悔悟棒|r狠狠的敲了|G【%s】|r一通…'
        ) % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,

        )

    def effect_string(act):
        cl = BatchList(act.cards)
        return u'又抢过|G【%s】|r的|G%s|r扔了出去！' % (
            act.target.ui_meta.char_name,
            u'|r和|G'.join(cl.ui_meta.name)
        )


class MaidenCostumeEffect:
    def effect_string(act):
        return u'|G【%s】|r美美的穿着巫女服，却在危险来到的时候踩到了裙边……' % (
            act.target.ui_meta.char_name,
        )


class MaidenCostumeCard:
    # action_stage meta
    name = u'巫女服'
    image = gres.card_maidencostume
    image_small = gres.card_maidencostume_small
    description = (
        u'|R巫女服|r\n\n'
        u'距离限制2，你可以将这张牌置于任意一名处于距离内的玩家的装备区里。\n'
        u'受到【罪袋狂欢】效果时，无法回避。'
    )

    def is_action_valid(g, cl, target_list):
        if not target_list:
            return (False, u'请选择目标')
        t = target_list[0]
        if g.me is t:
            return (True, u'真的要自己穿上吗？')
        return (True, u'\腋/！')


class MaidenCostumeSkill:
    # Skill
    name = u'巫女服'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class IbukiGourdCard:
    # action_stage meta
    name = u'伊吹瓢'
    image = gres.card_ibukigourd
    image_small = gres.card_ibukigourd_small
    is_action_valid = equip_iav
    description = (
        u'|R伊吹瓢|r\n\n'
        u'当装备在进攻马位置。在装备、失去装备及回合结束时获得|B喝醉|r状态'
    )


class IbukiGourdSkill:
    # Skill
    name = u'伊吹瓢'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class HouraiJewelCard:
    # action_stage meta
    name = u'蓬莱玉枝'
    image = gres.card_houraijewel
    image_small = gres.card_houraijewel_small
    description = (
        u'|R蓬莱玉枝|r\n\n'
        u'攻击范围1，当使用【弹幕】时可以选择发动。发动后【弹幕】带有符卡性质，可以被【好人卡】抵消，不可以使用【擦弹】躲过。\n'
        u'|B|R>> |r计算在出【弹幕】的次数内。\n'
        u'|B|R>> |r蓬莱玉枝造成的伤害为固定的1点'
    )

    is_action_valid = equip_iav


class HouraiJewelSkill:
    # Skill
    name = u'蓬莱玉枝'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class HouraiJewelHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【蓬莱玉枝】吗？'


class HouraiJewelAttack:
    def effect_string_apply(act):
        return (
            u'|G【%s】|r发动了|G蓬莱玉枝|r，包裹着魔法核心的弹幕冲向了|G【%s】|r！'
        ) % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class SaigyouBranchCard:
    # action_stage meta
    name = u'西行妖'
    image = gres.card_saigyoubranch
    image_small = gres.card_saigyoubranch_small
    description = (
        u'|R西行妖|r\n\n'
        u'每当你成为其他人符卡的目标时，你可以进行一次判定：若判定牌点数为9到K，则视为你使用了一张【好人卡】。'
    )
    is_action_valid = equip_iav


class SaigyouBranchSkill:
    # Skill
    name = u'西行妖'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class SaigyouBranchHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【西行妖】吗？'


class SaigyouBranch:
    fatetell_display_name = u'西行妖'

    def effect_string_before(act):
        return (
            u'|G西行妖|r的枝条受到了|G【%s】|r春度的滋养，'
            u'在关键时刻突然撑出一片结界，试图将符卡挡下！'
        ) % (
            act.source.ui_meta.char_name,
        )

    def effect_string(act):
        if not act.succeeded:
            return (
                u'但是很明显|G【%s】|r的春度不够用了…'
            ) % (
                act.source.ui_meta.char_name,
            )


class HakuroukenCard:
    # action_stage meta
    name = u'白楼剑'
    image = gres.card_hakurouken
    image_small = gres.card_hakurouken_small
    description = (
        u'|R白楼剑|r\n\n'
        u'攻击范围2，当你使用【弹幕】指定了一名角色为目标后，若此弹幕为黑色，你可以令对方选择一项：\n'
        u'|B|R>> |r弃一张手牌\n'
        u'|B|R>> |r你摸一张牌'
    )
    is_action_valid = equip_iav


class HakuroukenSkill:
    # Skill
    name = u'白楼剑'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class Hakurouken:
    # choose_card
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'弃置这张牌')
        else:
            return (False, u'请弃掉一张牌（否则对方摸一张牌）')

    def effect_string_before(act):
        return (
            u'|G【%s】|r祭起了|G白楼剑|r，试图斩断|G【%s】|r的迷惘！'
        ) % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )

    def effect_string(act):
        if act.peer_action == 'drop':
            return u'|G【%s】|r弃置了一张牌。' % act.target.ui_meta.char_name
        else:
            return u'|G【%s】|r摸了一张牌。' % act.source.ui_meta.char_name


class HakuroukenHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【白楼剑】吗？'


class AyaRoundfanCard:
    # action_stage meta
    name = u'团扇'
    image = gres.card_ayaroundfan
    image_small = gres.card_ayaroundfan_small
    description = (
        u'|R团扇|r\n\n'
        u'攻击距离5，当你使用【弹幕】命中时，可以弃一张手牌，卸掉目标的一件装备。'
    )
    is_action_valid = equip_iav


class AyaRoundfanSkill:
    # Skill
    name = u'团扇'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class AyaRoundfanHandler:
    # choose_card
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'这种妨碍拍摄的东西，统统脱掉！')
        else:
            return (False, u'请弃掉一张手牌发动团扇（否则不发动）')


class AyaRoundfan:
    def effect_string_before(act):
        return (
            u'|G【%s】|r觉得手中的|G团扇|r用起来好顺手，便加大力度试了试…'
        ) % (
            act.source.ui_meta.char_name,
        )

    def effect_string(act):
        return (
            u'于是|G【%s】|r的|G%s|r就飞了出去！'
        ) % (
            act.target.ui_meta.char_name,
            act.card.ui_meta.name,
        )


class NenshaPhoneCard:
    # action_stage meta
    name = u'念写机'
    image = gres.card_nenshaphone
    image_small = gres.card_nenshaphone_small
    description = (
        u'|R念写机|r\n\n'
        u'攻击距离4，当你使用【弹幕】命中时，可以将目标的两张手牌置入明牌区。'
    )
    is_action_valid = equip_iav


class NenshaPhoneSkill:
    # Skill
    name = u'念写机'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class NenshaPhoneHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【念写机】吗？'


class NenshaPhone:
    def effect_string(act):
        return (
            u'|G【%s】|r表示，将|G【%s】|r推倒后拍摄胖次，是记者的自我修养中不可或缺的一部分。'
        ) % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class LaevateinCard:
    # action_stage meta
    name = u'莱瓦汀'
    image = gres.card_laevatein
    image_small = gres.card_laevatein_small
    description = (
        u'|R莱瓦汀|r\n\n'
        u'攻击距离3，目标角色使用【擦弹】抵消你使用【弹幕】的效果时，你可以弃两张牌（可以是手牌也可以是自己的其它装备牌），使此【弹幕】强制命中对方，无法闪避。'
    )
    is_action_valid = equip_iav


class LaevateinSkill:
    # Skill
    name = u'莱瓦汀'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class LaevateinHandler:
    # choose_card
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'灭世之炎岂能轻易闪过！')
        else:
            return (False, u'请弃掉两张牌发动莱瓦汀（否则不发动）')


class Laevatein:
    def effect_string_before(act):
        return u'|G莱瓦汀|r的灭世之炎岂能轻易闪过！'


class DeathSickleCard:
    # action_stage meta
    name = u'死神之镰'
    image = gres.card_deathsickle
    image_small = gres.card_deathsickle_small
    description = (
        u'|R死神之镰|r\n\n'
        u'攻击范围2，|B锁定技|r，当你使用的【弹幕】造成伤害时，若目标没有手牌，此【弹幕】的伤害+1。'
    )
    is_action_valid = equip_iav


class DeathSickleSkill:
    # Skill
    name = u'死神之镰'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class DeathSickle:
    def effect_string(act):
        return (
            u'|G【%s】|r看到|G【%s】|r一副丧家犬的模样，'
            u'手中的|G死神之镰|r不自觉地一狠…'
        ) % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class KeystoneCard:
    # action_stage meta
    name = u'要石'
    image = gres.card_keystone
    image_small = gres.card_keystone_small
    description = (
        u'|R要石|r\n\n'
        u'特殊的绿色UFO装备，距离+1\n'
        u'装备后不受【罪袋】的影响'
    )
    is_action_valid = equip_iav


class KeystoneSkill:
    # Skill
    name = u'要石'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class Keystone:
    def effect_string(act):
        return u'|G【%s】|r站在|G要石|r上，照着|G罪袋|r的脸一脚踹了下去！' % (
            act.target.ui_meta.char_name
        )


class WitchBroomCard:
    # action_stage meta
    name = u'魔女扫把'
    image = gres.card_witchbroom
    image_small = gres.card_witchbroom_small
    is_action_valid = equip_iav
    description = (
        u'|R魔女扫把|r\n\n'
        u'特殊的红色UFO装备，距离-2'
    )


class WitchBroomSkill:
    # Skill
    no_display = True


class YinYangOrbCard:
    # action_stage meta
    name = u'阴阳玉'
    image = gres.card_yinyangorb
    image_small = gres.card_yinyangorb_small
    description = (
        u'|R阴阳玉|r\n\n'
        u'当你的判定牌即将生效时，可以用装备着的【阴阳玉】代替判定牌生效。'
    )
    is_action_valid = equip_iav


class YinYangOrbSkill:
    # Skill
    name = u'阴阳玉'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class YinYangOrbHandler:
    # choose_option
    choose_option_buttons = ((u'替换', True), (u'不替换', False))
    choose_option_prompt = u'你要使用【阴阳玉】替换当前的判定牌吗？'


class YinYangOrb:
    def effect_string(act):
        return (
            u'|G【%s】|r用|G%s|r代替了她的判定牌'
        ) % (
            act.target.ui_meta.char_name,
            card_desc(act.card),
        )


class SuwakoHatCard:
    # action_stage meta
    name = u'青蛙帽'
    image = gres.card_suwakohat
    image_small = gres.card_suwakohat_small
    description = (
        u'|R青蛙帽|r\n\n'
        u'装备后，手牌上限+2'
    )
    is_action_valid = equip_iav


class SuwakoHatSkill:
    # Skill
    name = u'青蛙帽'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class YoumuPhantomCard:
    # action_stage meta
    name = u'半灵'
    image = gres.card_phantom
    image_small = gres.card_phantom_small
    description = (
        u'|R半灵|r\n\n'
        u'装备时增加一点体力上限，当失去装备区里的【半灵】时，回复一点体力。'
    )

    is_action_valid = equip_iav


class YoumuPhantomSkill:
    # Skill
    name = u'半灵'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class IceWingCard:
    # action_stage meta
    name = u'⑨的翅膀'
    image = gres.card_icewing
    image_small = gres.card_icewing_small
    description = (
        u'|R⑨的翅膀|r\n\n'
        u'装备后不受【封魔阵】和【冻青蛙】的影响。'
    )

    is_action_valid = equip_iav


class IceWingSkill:
    # Skill
    name = u'⑨的翅膀'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class IceWing:
    def effect_string(act):
        return u'|G【%s】|r借着|G⑨的翅膀|r飞了出来，|G%s|r没起到什么作用' % (
            act.target.ui_meta.char_name,
            act.action.associated_card.ui_meta.name,
        )


class GrimoireCard:
    # action_stage meta
    name = u'魔导书'
    image = gres.card_grimoire
    image_small = gres.card_grimoire_small
    description = (
        u'|R魔导书|r\n\n'
        u'攻击距离1，当在你的出牌阶段仍然可以使用【弹幕】时，你可以弃一张牌，发动魔导书，并且计入【弹幕】的使用次数，一回合限一次。\n'
        u'|B|R>> |r弃牌为红桃：视为发动【宴会】\n'
        u'|B|R>> |r弃牌为方片：视为发动【五谷丰登】\n'
        u'|B|R>> |r弃牌为黑桃：视为发动【罪袋狂欢】\n'
        u'|B|R>> |r弃牌为梅花：视为发动【地图炮】'
    )
    is_action_valid = equip_iav


class GrimoireSkill:
    # Skill
    name = u'魔导书'

    def clickable(game):
        me = game.me
        t = me.tags
        if t['grimoire_tag'] >= t['turn_count']:
            return False

        try:
            act = game.action_stack[-1]
            if isinstance(act, actions.ActionStage):
                if me.tags['freeattack'] >= me.tags['turn_count']:
                    return True

                if me.tags['attack_num'] > 0:
                    return True

                if me.has_skill(cards.ElementalReactorSkill):
                    return True

        except IndexError:
            pass

        return False

    def is_action_valid(g, cl, target_list):
        skill = cl[0]
        assert skill.is_card(cards.GrimoireSkill)
        acards = skill.associated_cards
        if not (len(acards)) == 1:
            return (False, u'请选择一张牌')
        else:
            s = skill.lookup_tbl[acards[0].suit].ui_meta.name
            return (True, u'发动【%s】' % s)

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        source = act.source
        card = act.card
        return (
            u'|G【%s】|r抓起一张牌放入|G魔导书|r' +
            u'，念动咒语，发动了|G%s|r。'
        ) % (
            source.ui_meta.char_name,
            card.lookup_tbl[card.associated_cards[0].suit].ui_meta.name
        )

########NEW FILE########
__FILENAME__ = spellcard
# -*- coding: utf-8 -*-

from gamepack.thb import cards
from gamepack.thb.ui.ui_meta.common import gen_metafunc, card_desc
from gamepack.thb.ui.resource import resource as gres


__metaclass__ = gen_metafunc(cards)


class DemolitionCard:
    # action_stage meta
    image = gres.card_demolition
    name = u'城管执法'
    description = (
        u'|R城管执法|r\n\n'
        u'出牌阶段对(除自己外)任意一名玩家使用，随机抽取并弃掉对方一张手牌，或选择并弃掉一张对方面前的牌(包括装备、明牌区和判定区内延时类符卡)。'
    )

    def is_action_valid(g, cl, target_list):
        if not target_list:
            return (False, u'请选择拆除目标')

        target = target_list[0]
        if not len(target.cards) + len(target.showncards) + len(target.equips) + len(target.fatetell):
            return (False, u'这货已经没有牌了')
        else:
            return (True, u'嗯，你的牌太多了')


class Demolition:
    def effect_string(act):
        if not act.succeeded: return None
        return u'|G【%s】|r卸掉了|G【%s】|r的%s。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
            card_desc(act.card),
        )


class RejectCard:
    # action_stage meta
    name = u'好人卡'
    image = gres.card_reject
    description = (
        u'|R好人卡|r\n\n'
        u'目标符卡对目标角色生效前，对目标符卡使用。抵消该符卡对其指定的一名目标角色产生的效果。'
    )

    def is_action_valid(g, cl, target_list):
        return (False, u'你不能主动出好人卡')


class RejectHandler:
    # choose_card meta
    def choose_card_text(g, act, cards):
        c = act.target_act.associated_card
        name = c.ui_meta.name

        s = u'【%s】受到的【%s】' % (
            act.target_act.target.ui_meta.char_name,
            name,
        )

        if act.cond(cards):
            return (True, u'对不起，你是一个好人(%s)' % s)
        else:
            return (False, u'请选择一张好人卡（%s)' % s)


class Reject:
    def effect_string_before(act):
        return u'|G【%s】|r为|G【%s】|r受到的|G%s|r使用了|G%s|r。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
            act.target_act.associated_card.ui_meta.name,
            act.associated_card.ui_meta.name,
        )

    def ray(act):
        return [(act.source, act.target)]


class SealingArrayCard:
    # action_stage meta
    name = u'封魔阵'
    image = gres.card_sealarray
    tag_anim = lambda c: gres.tag_sealarray
    description = (
        u'|R封魔阵|r\n\n'
        u'延时类符卡\n'
        u'出牌阶段对任意一名玩家使用,将此牌置于目标玩家判定区,对方在其判定阶段需判定——如果判定结果为红桃，则照常行动，弃掉【封魔阵】；如果判定结果不是红桃，则该回合跳过出牌阶段（照常摸牌和弃牌），弃掉【封魔阵】。\n'
        u'|B|R>> |r仅当需要开始进行【封魔阵】的判定时,才能使用【好人卡】抵消之(抵消后弃掉【封魔阵】)。'
    )

    def is_action_valid(g, cl, target_list):
        if len(target_list) != 1:
            return (False, u'请选择封魔阵的目标')
        t = target_list[0]
        if g.me is t:
            return (False, u'你不能跟自己过不去啊！')

        return (True, u'画个圈圈诅咒你！')


class SealingArray:
    def effect_string(act):
        tgt = act.target
        if act.succeeded:
            return u'|G【%s】|r被困在了封魔阵中' % tgt.ui_meta.char_name
        else:
            return u'封魔阵没有布置完善，|G【%s】|r侥幸逃了出来' % tgt.ui_meta.char_name


class FrozenFrogCard:
    # action_stage meta
    name = u'冻青蛙'
    image = gres.card_frozenfrog
    tag_anim = lambda c: gres.tag_frozenfrog
    description = (
        u'|R冻青蛙|r\n\n'
        u'延时类符卡\n'
        u'出牌阶段对任意一名玩家使用,将此牌置于目标玩家判定区,对方在其摸牌阶段需判定——如果判定结果不为黑桃，则该回合跳过摸牌阶段。无论判定是否成功，弃掉该【冻青蛙】。\n'
        u'|B|R>> |r仅当需要开始进行【冻青蛙】的判定时,才能使用【好人卡】抵消之(抵消后弃掉【冻青蛙】)。'
    )

    def is_action_valid(g, cl, target_list):
        if len(target_list) != 1:
            return (False, u'请选择冻青蛙的目标')
        t = target_list[0]
        if g.me is t:
            return (False, u'你不能跟自己过不去啊！')

        return (True, u'伸手党什么的，冻住就好了！')


class FrozenFrog:
    def effect_string(act):
        tgt = act.target
        if act.succeeded:
            return u'|G【%s】|r被冻住了……' % tgt.ui_meta.char_name
        else:
            return u'幻想乡今天大晴，|G【%s】|r没有被冻住~' % tgt.ui_meta.char_name


class NazrinRodCard:
    # action_stage meta
    name = u'寻龙尺'
    image = gres.card_nazrinrod
    description = (
        u'|R寻龙尺|r\n\n'
        u'非延时符卡\n'
        u'出牌阶段使用，从牌堆摸两张牌。'
    )

    def is_action_valid(g, cl, target_list):
        return (True, u'看看能找到什么好东西~')


class SinsackCard:
    # action_stage meta
    name = u'罪袋'
    image = gres.card_sinsack
    tag_anim = lambda c: gres.tag_sinsack
    description = (
        u'|R罪袋|r\n\n'
        u'延时类符卡\n'
        u'出牌阶段使用,将【罪袋】横置于自己面前:\n'
        u'|B|R>> |r【罪袋】将一直放在那里直到这回合结束,当自己下回合进入回合开始阶段时,自己需要判定——若判定结果为黑桃1~黑桃8的牌,视为被【罪袋】推倒,受到3点伤害,并将【罪袋】弃掉;否则,将【罪袋】传给右边的玩家,右边的玩家在他/她的回合开始阶段需要做同样的判定,以此类推,直到【罪袋】生效为止,弃掉【罪袋】。\n'
        u'|B|R>> |r仅当需要开始进行【罪袋】的判定时,才能使用【好人卡】抵消之,但抵消后不弃掉【罪袋】,而是将之传递给下家。'
    )

    def is_action_valid(g, cl, target_list):
        return (True, u'别来找我！')


class Sinsack:
    def effect_string(act):
        tgt = act.target
        if act.succeeded:
            return u'罪袋终于找到了机会，将|G【%s】|r推倒了…' % tgt.ui_meta.char_name


class YukariDimensionCard:
    # action_stage meta
    image = gres.card_yukaridimension
    name = u'隙间'

    description = (
        u'|R隙间|r\n\n'
        u'出牌阶段对距离为1的一名玩家使用，随机抽取并获得对方一张手牌，或选择并获得一张对方面前的牌(包括装备、明牌区内的牌和判定区的延时类符卡)。'
    )

    def is_action_valid(g, cl, target_list):
        if not target_list:
            return (False, u'请选择目标')

        target = target_list[0]
        if not (target.cards or target.showncards or target.equips or target.fatetell):
            return (False, u'这货已经没有牌了')
        else:
            return (True, u'请把胖次给我！')


class YukariDimension:
    def effect_string(act):
        src, tgt = act.source, act.target
        if act.succeeded:
            return u'|G【%s】|r透过隙间拿走了|G【%s】|r的1张牌' % (
                src.ui_meta.char_name,
                tgt.ui_meta.char_name
            )


class DuelCard:
    # action_stage meta
    image = gres.card_duel
    name = u'弹幕战'
    description = (
        u'|R弹幕战|r\n\n'
        u'出牌阶段对(除自己外)任意一名玩家使用，由目标角色先开始，你和他（她）轮流打出一张【弹幕】，【弹幕战】对首先不出【弹幕】的一方造成1点伤害；另一方成为此伤害的来源。'
    )

    def is_action_valid(g, cl, target_list):
        if not target_list:
            return (False, u'请选择弹幕战的目标')

        return (True, u'来，战个痛快！')


class MapCannonCard:
    image = gres.card_mapcannon
    name = u'地图炮'
    description = (
        u'|R地图炮|r\n\n'
        u'按行动顺序结算，除非目标角色打出一张【擦弹】，否则该角色受到【地图炮】对其造成的1点伤害。'
    )

    def is_action_valid(g, cl, target_list):
        return (True, u'一个都不能跑！')


class SinsackCarnivalCard:
    image = gres.card_sinsackcarnival
    name = u'罪袋狂欢'
    description = (
        u'|R罪袋狂欢|r\n\n'
        u'出牌阶段使用,(除自己外)所有玩家各需出一张【弹幕】，没有【弹幕】（或不出）的玩家受到一点伤害。'
    )

    def is_action_valid(g, cl, target_list):
        return (True, u'罪袋们来送水啦！')


class FeastCard:
    # action_stage meta
    image = gres.card_feast
    name = u'宴会'
    description = (
        u'|R宴会|r\n\n'
        u'对所有玩家生效，每一个体力不满的玩家回复一点体力，满体力玩家获得|B喝醉|r状态。'
    )

    def is_action_valid(g, cl, target_list):
        return (True, u'开宴啦~~')


class HarvestCard:
    # action_stage meta
    image = gres.card_harvest
    name = u'五谷丰登'
    description = (
        u'|R五谷丰登|r\n\n'
        u'你从牌堆顶亮出等同于现存角色数量的牌，然后所有角色按行动顺序结算，选择并获得这些牌中的一张。'
    )

    def is_action_valid(g, cl, target_list):
        return (True, u'麻薯会有的，节操是没有的！')


class HarvestEffect:
    def effect_string(act):
        if not act.succeeded: return None
        tgt = act.target
        c = act.card
        return u'|G【%s】|r获得了|G%s|r' % (
            tgt.ui_meta.char_name,
            c.ui_meta.name,
        )


class DollControlCard:
    # action_stage meta
    name = u'人形操控'
    image = gres.card_dollcontrol
    description = (
        u'|R人形操控|r\n\n'
        u'对装备有武器的玩家使用，令其使用一张【弹幕】攻击另一名指定玩家，否则将武器交给自己。'
    )
    custom_ray = True

    def is_action_valid(g, cl, tl):
        n = len(tl)
        if n == 0:
            return (False, u'请选择被控者')

        if tl[0] is g.me:
            return (False, u'你不可以控制你自己')

        if all(e.equipment_category != 'weapon' for e in tl[0].equips):
            return (False, u'被控者没有武器！')

        if n == 1:
            return (False, u'请选择被控者的攻击目标')
        elif n == 2:
            from gamepack.thb import actions, cards
            c = cards.AttackCard()
            lc = actions.LaunchCard(tl[0], [tl[1]], c)
            if not lc.can_fire():
                return (False, u'被控者无法向目标出【弹幕】！')
            return (True, u'乖，听话！')


class DollControl:
    # choose card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'那好吧…')
        else:
            return (False, u'请出【弹幕】（否则你的武器会被拿走）')

    def ray(act):
        src = act.source
        tl = act.target_list
        return [(src, tl[0]), (tl[0], tl[1])]


class DonationBoxCard:
    # action_stage meta
    name = u'塞钱箱'
    image = gres.card_donationbox
    description = (
        u'|R塞钱箱|r\n\n'
        u'指定1-2名有手牌或装备的玩家，被指定玩家必须选择一张手牌或装备牌置入你的明牌区。'
    )

    def is_action_valid(g, cl, tl):
        n = len(tl)
        if not n:
            return (False, u'请选择1-2名玩家')

        for t in tl:
            if not (t.cards or t.showncards or t.equips):
                return (False, u'目标没有可以给你的牌')

        return (True, u'纳奉！纳奉！')


class DonationBoxEffect:
    # choose card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'这是抢劫啊！')
        else:
            return (False, u'请选择一张牌（否则会随机选择一张）')

########NEW FILE########
__FILENAME__ = akari
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.akari)


class Akari:
    # Character
    char_name = u'随机角色'
    port_image = gres.akari_port
    description = (
        u'|DB会是谁呢 随机角色 体力：?|r\n\n'
        u'|G阿卡林|r：消失在画面里的能力。在开局之前，没有人知道这是谁。'
    )

########NEW FILE########
__FILENAME__ = alice
# -*- coding: utf-8 -*-

from gamepack.thb import actions
from gamepack.thb import cards
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.ui_meta.common import limit1_skill_used
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.alice)


class Alice:
    # Character
    char_name = u'爱丽丝'
    port_image = gres.alice_port
    description = (
        u'|DB七色的人偶使 爱丽丝 体力：3|r\n\n'
        u'|G小小军势|r：当你使用装备牌时，你可以摸一张牌。当你失去装备牌区的牌后，你可以弃置其它角色的一张牌。\n\n'
        u'|G少女文乐|r：锁定技，你的手牌上限+X（X为你装备区牌数量的一半，向上取整且至少为1）。'
    )


class LittleLegion:
    # Skill
    name = u'小小军势'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class LittleLegionDrawCards:
    pass


class LittleLegionAction:
    def effect_string(act):
        return u'|G【%s】|r对|G【%s】|r发动了|G小小军势|r。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name
        )


class LittleLegionHandler:
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【小小军势】吗？'

    def target(tl):
        if not tl:
            return False, u'小小军势：弃置目标的一张牌'

        tgt = tl[0]

        if tgt.cards or tgt.showncards or tgt.equips:
            return True, u'让你见识一下这人偶军团的厉害！'
        else:
            return False, u'这货已经没有牌了'


class MaidensBunraku:
    # Skill
    name = u'少女文乐'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class DollCrusader:
    # Skill
    name = u'玩偶十字军'
    custom_ray = True

    def clickable(game):
        me = game.me

        try:
            act = game.action_stack[-1]
            if limit1_skill_used('alice_doll_tag'):
                return False
        except IndexError:
            return False

        cond = isinstance(act, actions.ActionStage)
        cond = cond and act.target is me
        cond = cond and (me.cards or me.showncards)
        return bool(cond)

    def is_action_valid(g, cl, target_list):
        skill = cl[0]
        cl = skill.associated_cards
        while True:
            if len(cl) != 1: break
            if 'instant_spellcard' not in cl[0].category: break
            return cards.DollControlCard.ui_meta.is_action_valid(g, [skill], target_list)

        return (False, u'请选择一张非延时符卡！')

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        source = act.source
        target = act.target
        s = u'|G【%s】|r突然向|G【%s】|r射出魔法丝线，将她当作玩偶一样玩弄了起来！' % (
            source.ui_meta.char_name,
            target.ui_meta.char_name,
        )
        return s

# ----------

########NEW FILE########
__FILENAME__ = chen
# -*- coding: utf-8 -*-

from gamepack.thb import actions
from gamepack.thb import cards
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.resource import resource as gres
from utils import BatchList

__metaclass__ = gen_metafunc(characters.chen)


class FlyingSkanda:
    # Skill
    name = u'飞翔韦驮天'

    def clickable(game):
        me = game.me
        if me.tags['flying_skanda'] >= me.tags['turn_count']: return False
        try:
            act = game.action_stack[-1]
            if isinstance(act, actions.ActionStage) and act.target is me:
                return True
        except IndexError:
            pass
        return False

    def is_action_valid(g, cl, target_list):
        skill = cl[0]
        acards = skill.associated_cards
        if len(acards) != 1:
            return (False, u'请选择一张牌！')
        c = acards[0]

        while True:
            if c.is_card(cards.AttackCard): break

            rst = c.is_card(cards.RejectCard)
            rst = rst or c.is_card(cards.DollControlCard)
            rst = (not rst) and issubclass(c.associated_action, cards.InstantSpellCardAction)
            if rst: break

            return (False, u'请选择一张【弹幕】或者除【人形操控】与【好人卡】之外的非延时符卡！')

        if len(target_list) != 2:
            return (False, u'请选择目标（2名玩家）')

        if g.me is target_list[-1]:
            return (False, u'不允许选择自己')
        else:
            return (True, u'喵！')

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        source = act.source
        card = act.card.associated_cards[0]
        tl = BatchList(act.target_list)

        if card.is_card(cards.AttackCard):
            s = u'弹幕掺了金坷垃，攻击范围一千八！'
        else:
            s = u'符卡掺了金坷垃，一张能顶两张用！'

        return u'|G【%s】|r：“%s|G【%s】|r接招吧！”' % (
            source.ui_meta.char_name,
            s,
            u'】|r、|G【'.join(tl.ui_meta.char_name),
        )


class Shikigami:
    # Skill
    name = u'式神'
    def clickable(game):
        me = game.me
        if me.tags.get('shikigami_tag'): return False
        try:
            act = game.action_stack[-1]
            if isinstance(act, actions.ActionStage) and act.target is me:
                return True
        except IndexError:
            pass
        return False

    def is_action_valid(g, cl, tl):
        skill = cl[0]
        cl = skill.associated_cards
        if cl:
            return (False, u'请不要选择牌')

        if not tl:
            return (False, u'请选择一名玩家')
        else:
            return (True, u'发动【式神】')


class ShikigamiAction:
    choose_option_buttons = ((u'摸2张牌', False), (u'回复1点体力', True))
    choose_option_prompt = u'请为受到的【式神】选择效果'


class Chen:
    # Character
    char_name = u'橙'
    port_image = gres.chen_port
    description = (
        u'|DB凶兆的黑喵 橙 体力：4|r\n\n'
        u'|G飞翔韦驮天|r：出牌阶段，你使用的一张【弹幕】或除了【人形操控】与【好人卡】之外的非延时性单体符卡可以额外指定一个目标。每阶段限一次。\n\n'
        u'|G式神|r：|B限定技|r，出牌阶段，你可以令一名其他角色选择一项：摸2张牌或回复一点体力。直到你的下个回合开始，你和该角色可以于自己的回合内对对方攻击范围内的角色使用【弹幕】。'
    )

########NEW FILE########
__FILENAME__ = cirno
# -*- coding: utf-8 -*-

from gamepack.thb import cards
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, my_turn, meta_property
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.cirno)


class PerfectFreeze:
    # Skill
    name = u'完美冻结'

    @meta_property
    def image(c):
        return c.associated_cards[0].ui_meta.image

    tag_anim = lambda c: gres.tag_frozenfrog
    description = (
        u'|G【琪露诺】|r的技能产生的|G冻青蛙|r'
    )

    def clickable(game):
        me = game.me
        if not my_turn():
            return False

        if me.cards or me.showncards or me.equips:
            return True

        return False

    def is_action_valid(g, cl, target_list):
        skill = cl[0]
        cl = skill.associated_cards
        if len(cl) != 1:
            return (False, u'请选择一张牌！')

        c = cl[0]
        if c.is_card(cards.Skill):
            return (False, u'你不能像这样组合技能')

        if c.suit in (cards.Card.SPADE, cards.Card.CLUB):
            if set(c.category) & {'basic', 'equipment'}:
                return (True, u'PERFECT FREEZE~')

        return (False, u'请选择一张黑色的基本牌或装备牌！')

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        source = act.source
        card = act.card
        target = act.target
        return (
            u'|G【%s】|r发动了|G完美冻结|r技能，用|G%s|r' +
            u'把|G【%s】|r装进了大冰块里！'
        ) % (
            source.ui_meta.char_name,
            card.associated_cards[0].ui_meta.name,
            target.ui_meta.char_name,
        )


class Cirno:
    # Character
    char_name = u'琪露诺'
    port_image = gres.cirno_port
    figure_image = gres.cirno_figure
    description = (
        u'|DB跟青蛙过不去的笨蛋 琪露诺 体力：4|r\n\n'
        u'|G完美冻结|r：出牌阶段，可以将你的任意一张黑色的基本牌或装备牌当【冻青蛙】使用；你可以对与你距离2以内的角色使用【冻青蛙】。\n\n'
        u'|DB（画师：渚FUN）|r'
    )

########NEW FILE########
__FILENAME__ = daiyousei
# -*- coding: utf-8 -*-

from gamepack.thb import actions
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.daiyousei)


class Daiyousei:
    # Character
    char_name = u'大妖精'
    port_image = gres.daiyousei_port
    figure_image = gres.daiyousei_figure
    description = (
        u'|DB全身萌点的保姆 大妖精 体力：3|r\n\n'
        u'|G支援|r：出牌阶段，你可以将任意数量的除了判定区外的牌以任意分配方式交给其他角色，若你于此阶段中给出的牌张数达到或超过3张时，你回复1点体力。\n\n'
        u'|G卖萌|r：摸牌阶段，你可以摸 2+当前损失的体力数 的牌。\n\n'
        u'|DB（画师：渚FUN）|r'
    )


class SupportSkill:
    # Skill
    name = u'支援'

    def clickable(game):
        me = game.me

        try:
            act = game.action_stack[-1]
        except IndexError:
            return False

        if isinstance(act, actions.ActionStage) and (me.cards or me.showncards or me.equips):
            return True

        return False

    def is_action_valid(g, cl, target_list):
        cl = cl[0].associated_cards
        if not cl: return (False, u'请选择要给出的牌')
        me = g.me
        allcards = list(me.cards) + list(me.showncards) + list(me.equips)
        if any(
            c not in allcards
            for c in cl
        ): return (False, u'你只能选择手牌与装备牌！')
        if len(target_list) != 1: return (False, u'请选择1名玩家')
        return (True, u'加油！')

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        return u'|G【%s】|r发动了|G支援|r技能，将%d张牌交给了|G【%s】|r' % (
            act.source.ui_meta.char_name,
            len(act.card.associated_cards),
            act.target.ui_meta.char_name,
        )


class Moe:
    # Skill
    name = u'卖萌'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class MoeDrawCard:
    def effect_string(act):
        return u'|G【%s】|r用手扯开脸颊，向大家做了一个夸张的笑脸，摸了%d张牌跑开了' % (
            act.target.ui_meta.char_name,
            act.amount,
        )

# ----------

########NEW FILE########
__FILENAME__ = dummy
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.dummy)


class Dummy:
    # Character
    char_name = u'机器人'
    port_image = gres.dummy_port
    description = (
        u'|DB河童工厂的残次品 机器人 体力：5|r\n\n'
        u'|G我很强壮|r：嗯，很强壮……'
    )

########NEW FILE########
__FILENAME__ = eirin
# -*- coding: utf-8 -*-

from gamepack.thb import actions
from gamepack.thb import cards
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import limit1_skill_used
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.eirin)


class FirstAid:
    # Skill
    name = u'急救'

    def clickable(game):
        try:
            act = game.action_stack[-1]
        except IndexError:
            return False

        if isinstance(act, cards.LaunchHeal):
            return True

        return False

    def is_complete(g, cl):
        skill = cl[0]
        acards = skill.associated_cards
        C = cards.Card
        if len(acards) != 1 or acards[0].suit not in (C.DIAMOND, C.HEART):
            return (False, u'请选择一张红色牌！')

        return (True, u'k看不到@#@#￥@#￥')


class Medic:
    # Skill
    name = u'医者'

    def clickable(game):
        me = game.me

        if limit1_skill_used('medic_tag'):
            return False

        try:
            act = game.action_stack[-1]
        except IndexError:
            return False

        if isinstance(act, actions.ActionStage) and (me.cards or me.showncards):
            return True

        return False

    def is_action_valid(g, cl, tl):
        skill = cl[0]
        me = g.me
        cl = skill.associated_cards
        if len(cl) != 1:
            return (False, u'请选择一张手牌！')
        elif any(c.resides_in not in (me.cards, me.showncards) for c in cl):
            return (False, u'只能使用手牌发动！')
        elif not tl or len(tl) != 1:
            return (False, u'请选择一名受伤的玩家')
        elif tl[0].maxlife <= tl[0].life:
            return (False, u'这只精神着呢，不用管她')
        return (True, u'少女，身体要紧啊！')

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        return (
            u'|G【%s】|r用一张|G%s|r做药引做了一贴膏药，'
            u'细心地贴在了|G【%s】|r的伤口上。'
        ) % (
            act.source.ui_meta.char_name,
            act.card.associated_cards[0].ui_meta.name,
            act.target.ui_meta.char_name,
        )


class Eirin:
    # Character
    char_name = u'八意永琳'
    port_image = gres.eirin_port
    figure_image = gres.eirin_figure
    description = (
        u'|DB街中的药贩 八意永琳 体力：3|r\n\n'
        u'|G医者|r：出牌阶段，你可以主动弃掉一张手牌，令任一目标角色回复1点体力。每回合限一次。\n\n'
        u'|G急救|r：当任意人进入濒死状态时，你可以将你的红色手牌或装备牌当做【麻薯】使用。\n\n'
        u'|RKOF模式下不可用\n\n'
        u'|DB（画师：渚FUN）|r'
    )

########NEW FILE########
__FILENAME__ = flandre
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.flandre)


class Flandre:
    # Character
    char_name = u'芙兰朵露'
    port_image = gres.flandre_port
    description = (
        u'|DB玩坏你哦 芙兰朵露 体力：4|r\n\n'
        u'|G狂咲|r：在你的摸牌阶段，如果你选择只摸一张牌，那么在你的出牌阶段你可以出任意张【弹幕】，并且【弹幕】和【弹幕战】的伤害为2点，但是对同一目标只能使用一张【弹幕】。'
    )


class CriticalStrike:
    # Skill
    name = u'狂咲'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class CriticalStrikeHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【狂咲】吗？'


class CriticalStrikeAction:
    def effect_string(act):
        return u'|G【%s】|r突然呵呵一笑，进入了黑化状态！' % (
            act.target.ui_meta.char_name,
        )

########NEW FILE########
__FILENAME__ = kaguya
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, meta_property
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.kaguya)


class Kaguya:
    # Character
    char_name = u'蓬莱山辉夜'
    port_image = gres.kaguya_port
    description = (
        u'|DB永远的公主殿下 蓬莱山辉夜 体力：3|r\n\n'
        u'|G难题|r：一名角色每次令你回复一点体力时，你可以令该角色摸一张牌；你每受到一次伤害后，可令伤害来源交给你一张方片牌，否则其失去一点体力。\n\n'
        u'|G永夜|r：在你的回合外，当一名角色的一张红色基本牌因使用进入弃牌堆时，你可以将一张红色基本牌/装备牌置于该角色的判定区视为【封魔阵】。'
    )


class Dilemma:
    # Skill
    name = u'难题'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class DilemmaDamageAction:
    # choose_card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'交出一张方片牌')
        else:
            return (False, u'请选择交出一张方片牌（否则失去一点体力）')

    def effect_string_before(act):
        return u'|G【%s】|r对|G【%s】|r发动了|G难题|r。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name
        )

    def effect_string(act):
        if act.peer_action == 'card':
            return u'|G【%s】|r给了|G【%s】|r一张牌。' % (
                act.target.ui_meta.char_name,
                act.source.ui_meta.char_name
            )
        # elif act.peer_action == 'life':
        #     <handled by LifeLost>


class DilemmaHealAction:
    def effect_string(act):
        return u'|G【%s】|r发动了|G难题|r，|G【%s】|r摸了一张牌。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class DilemmaHandler:
    # choose_option meta
    choose_option_buttons = ((u'发动', True), (u'不发动', False))

    def choose_option_prompt(act):
        _type = {
            'positive': u'正面效果',
            'negative': u'负面效果'
        }.get(act.dilemma_type, u'WTF?!')
        return u'你要发动【难题】吗（%s）？' % _type


class ImperishableNight:
    # Skill
    name = u'永夜'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid

    @meta_property
    def image(c):
        return c.associated_cards[0].ui_meta.image

    tag_anim = lambda c: gres.tag_sealarray
    description = (
        u'|G【蓬莱山辉夜】|r的技能产生的【封魔阵】'
    )

    def effect_string(act):
        return u'|G【%s】|r对|G【%s】|r使用了|G永夜|r。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name
        )


class ImperishableNightHandler:
    # choose_option meta
    choose_option_buttons = ((u'发动', True), (u'不发动', False))

    def choose_option_prompt(act):
        prompt = u'你要发动【永夜】吗（对%s）？'
        return prompt % act.target.ui_meta.char_name

    # choose_card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'陷入永夜吧！')
        else:
            return (False, u'请选择一张红色的基本牌或装备牌')

########NEW FILE########
__FILENAME__ = kanako
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, card_desc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.kanako)


class Kanako:
    # Character
    char_name = u'八坂神奈子'
    port_image = gres.kanako_port
    description = (
        u'|DB妖怪山上的神明 八坂神奈子 体力：4|r\n\n'
        u'|G御柱：|r摸牌阶段，你可以少摸X张牌（X最大为2）发动。你获得以下技能直到回合结束：\n'
        u'|B|R>> |r你与其他玩家结算距离时始终-X\n'
        u'|B|R>> |r当一名其他角色成为你使用的 非延时符卡的唯一目标 或 弹幕目标 时，该角色需弃置X张牌，否则不能使用或打出手牌直到回合结束。\n\n'
        u'|G信仰|r：|B锁定技|r，若你在出牌阶段内对其他角色造成过伤害，出牌阶段结束时你摸一张牌。'
    )


class Onbashira:
    # Skill
    name = u'御柱'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid
    no_display = False


class OnbashiraTarget:
    def choose_card_text(g, act, cards):
        prompt = u'御柱：弃置%d张牌（否则不能使用/打出手牌）' % act.amount
        return act.cond(cards), prompt

    def effect_string_before(act):
        return u'|G【%s】|r对|G【%s】|r大喊：“|G御柱|r灰过去了！”' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )

    def effect_string(act):
        if act.cards:
            return u'御柱震飞了|G【%s】|r的%s。' % (
                act.target.ui_meta.char_name,
                u'和'.join([card_desc(c) for c in act.cards]),
            )
        else:
            return u'|G【%s】|r惊呆了。' % act.target.ui_meta.char_name


class OnbashiraHandler:
    # choose_option
    choose_option_buttons = ((u'少摸一张', 1), (u'少摸两张', 2), (u'不发动', 0))
    choose_option_prompt = u'少摸X张牌，发动【御柱】'


class OnbashiraAction:
    def effect_string(act):
        if act.amount:
            return u'|G【%s】|r：“大家看，%s根|G御柱|r！”' % (
                act.target.ui_meta.char_name,
                u'零一两三'[act.amount],
            )


class KanakoFaith:
    name = u'信仰'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class KanakoFaithDrawCards:
    def effect_string(act):
        return u'|G【%s】|r：“嘛，只要御柱仍的勤快，|G信仰|r什么总是有的～”' % (
            act.target.ui_meta.char_name,
        )

########NEW FILE########
__FILENAME__ = koakuma
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, my_turn
from gamepack.thb.ui.ui_meta.common import limit1_skill_used
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.koakuma)


class Koakuma:
    # Character
    char_name = u'小恶魔'
    port_image = gres.koakuma_port
    figure_image = gres.koakuma_figure
    description = (
        u'|DB图书管理员 小恶魔 体力：4|r\n\n'
        u'|G寻找|r：出牌阶段，你可以弃掉任意数量的牌，然后摸取等量的牌。每回合里，你最多可以使用一次寻找。\n\n'
        u'|DB（画师：渚FUN，Takibi）|r'
    )


class Find:
    # Skill
    name = u'寻找'

    def clickable(game):
        me = game.me
        if limit1_skill_used('find_tag'):
            return False

        if my_turn() and (me.cards or me.showncards or me.equips):
            return True

        return False

    def is_action_valid(g, cl, target_list):
        skill = cl[0]
        assert skill.is_card(characters.koakuma.Find)
        if not len(skill.associated_cards):
            return (False, u'请选择需要换掉的牌！')

        if not [g.me] == target_list:
            return (False, 'BUG!!')

        return (True, u'换掉这些牌')

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        source = act.source
        card = act.card
        s = u'|G【%s】|r发动了寻找技能，换掉了%d张牌。' % (
            source.ui_meta.char_name,
            len(card.associated_cards),
        )
        return s

########NEW FILE########
__FILENAME__ = kogasa
# -*- coding: utf-8 -*-

from gamepack.thb import actions
from gamepack.thb import cards
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres


__metaclass__ = gen_metafunc(characters.kogasa)


class Jolly:
    # Skill
    name = u'愉快'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class JollyDrawCard:
    def effect_string(act):
        return u'|G【%s】|r高兴地让|G【%s】|r摸了%d张牌~' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
            act.amount,
        )


class JollyHandler:
    def choose_card_text(g, act, cards):
        if cards:
            return (False, u'请不要选择牌！')

        return (True, u'(～￣▽￣)～')

    # choose_players
    def target(pl):
        if not pl:
            return (False, u'请选择1名玩家，该玩家摸一张牌')

        return (True, u'(～￣▽￣)～')


class SurpriseSkill:
    # Skill
    name = u'惊吓'

    def clickable(game):
        me = game.me

        if me.tags.get('surprise_tag', 0) >= me.tags.get('turn_count', 0):
            return False

        try:
            act = game.action_stack[-1]
        except IndexError:
            return False

        if isinstance(act, actions.ActionStage) and (me.cards or me.showncards):
            return True

        return False

    def is_action_valid(g, cl, tl):
        if len(tl) != 1:
            return (False, u'请选择惊吓对象…')

        if len(cl[0].associated_cards):
            return (False, u'请不要选择牌！')

        #return (True, u'(´・ω・`)')
        return (True, u'\ ( °▽ °) /')

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        return (
            u'|G【%s】|r突然出现在|G【%s】|r面前，伞上'
            u'的大舌头直接糊在了|G【%s】|r的脸上！'
        ) % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class Surprise:
    # choose_option
    choose_option_buttons = (
        (u'黑桃', cards.Card.SPADE),
        (u'红桃', cards.Card.HEART),
        (u'草花', cards.Card.CLUB),
        (u'方片', cards.Card.DIAMOND),
    )

    # choose_option
    choose_option_buttons = (
        (u'♠', cards.Card.SPADE),
        (u'♡', cards.Card.HEART),
        (u'♣', cards.Card.CLUB),
        (u'♢', cards.Card.DIAMOND),
    )

    choose_option_prompt = u'请选择一个花色…'

    def effect_string(act):
        if act.succeeded:
            return u'效果拔群！'
        else:
            return u'似乎没有什么效果'


class Kogasa:
    # Character
    char_name = u'多多良小伞'
    port_image = gres.kogasa_port
    description = (
        u'|DB愉快的遗忘之伞 多多良小伞 体力：3|r\n\n'
        u'|G惊吓|r：出牌阶段，你可以指定另一名角色选择一种花色，抽取你的一张手牌，该角色将这张牌加入明牌区。若此牌与所选花色不吻合，则你对该角色造成1点伤害。无论结果如何，你摸一张牌。每阶段限用一次。\n\n'
        u'|G愉快|r：摸牌阶段摸牌后，你可以指定一人摸1张牌。'
    )

########NEW FILE########
__FILENAME__ = kokoro
# -*- coding: utf-8 -*-

from gamepack.thb import cards
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, my_turn
from gamepack.thb.ui.ui_meta.common import card_desc, limit1_skill_used
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.kokoro)


class Kokoro:
    # Character
    char_name = u'秦心'
    port_image = gres.kokoro_port
    figure_image = gres.kokoro_figure
    description = (
        u'|DB表情丰富的扑克脸 秦心 体力：3|r\n\n'
        u'|G希望之面|r：出牌阶段开始时。你可以观看牌堆顶1+X张牌，然后展示并获得其中任意数量的同一种花色的牌，其余以任意顺序置于牌堆顶（X为你已损失的体力值）。\n\n'
        u'|G暗黑能乐|r：出牌阶段，你可以将一张黑色牌置于体力不低于你的其他角色的明牌区，该角色需弃置除获得的牌以外的手牌直至手牌数等于其当前体力值。每阶段限一次。\n\n'
        u'|R异变模式不可用|r\n\n'
        u'|DB（画师：Takibi）|r'
    )


class HopeMask:
    # Skill
    name = u'希望之面'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class HopeMaskHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【希望之面】吗？'


class HopeMaskAction:
    def effect_string_before(act):
        return u'|G【%s】|r挑选面具中……' % (act.source.ui_meta.char_name)

    def effect_string(act):
        if not len(act.acquire):
            return None

        s = u'、'.join([card_desc(c) for c in act.acquire])
        return u'|G【%s】|r拿起了%s，贴在了自己的脸上。' % (
            act.source.ui_meta.char_name, s,
        )


class DarkNohAction:
    # choose_card
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'真坑！')
        else:
            return (False, u'请弃置%d张手牌（不能包含获得的那一张）' % act.n)


class DarkNoh:
    # Skill
    name = u'暗黑能乐'

    def clickable(game):
        me = game.me
        if limit1_skill_used('darknoh_tag'):
            return False

        if not my_turn():
            return False

        if me.cards or me.showncards or me.equips:
            return True

        return False

    def is_action_valid(g, cl, target_list):
        skill = cl[0]
        cl = skill.associated_cards
        if len(cl) != 1 or cl[0].suit not in (cards.Card.SPADE, cards.Card.CLUB):
            return (False, u'请选择一张黑色的牌！')

        c = cl[0]
        if c.is_card(cards.Skill):
            return (False, u'你不能像这样组合技能')

        return (True, u'发动暗黑能乐')

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        source = act.source
        card = act.card
        target = act.target
        return [
            u'|G【%s】|r：“这点失控还不够，让你的所有感情也一起爆发吧！”' % source.ui_meta.char_name,
            u'|G【%s】|r使用|G%s|r对|G【%s】|r发动了|G暗黑能乐|r。' % (
                source.ui_meta.char_name,
                card.associated_cards[0].ui_meta.name,
                target.ui_meta.char_name,
            )
        ]

########NEW FILE########
__FILENAME__ = komachi
# -*- coding: utf-8 -*-

from gamepack.thb import cards
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, my_turn
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.ui_meta.common import limit1_skill_used
from gamepack.thb.ui.resource import resource as gres


__metaclass__ = gen_metafunc(characters.komachi)


class Komachi:
    # Character
    char_name = u'小野塚小町'
    port_image = gres.komachi_port
    figure_image = gres.komachi_figure
    figure_image_alter = gres.komachi_figure_alter
    description = (
        u'|DB乳不巨何以聚人心 小野塚小町 体力：4|r\n\n'
        u'|G彼岸|r：出牌阶段，你可以弃置一张牌并指定一名角色，你与其距离视为1直到回合结束。若该角色为全场体力最少的角色（或之一），你可以弃置其一张牌或摸一张牌。每阶段限一次。\n\n'
        u'|G归航|r：|B觉醒技|r，回合开始阶段，若你的体力值低于手牌数且小于等于2，你失去一点体力上限并获得技能|R渡钱|r。\n\n'
        u'|R渡钱|r：你对距离为1的角色造成一次伤害后，你可以获得其一张牌。\n\n'
        u'|DB（画师：渚FUN）|r'
    )


class Riverside:
    # Skill
    name = u'彼岸'

    def clickable(g):
        if not my_turn(): return False
        if limit1_skill_used('riverside_tag'): return False

        me = g.me
        return bool(me.cards or me.showncards or me.equips)

    def is_action_valid(g, cl, tl):
        acards = cl[0].associated_cards
        if (not acards) or len(acards) != 1:
            return (False, u'请选择一张牌')

        card = acards[0]

        if card.resides_in.type not in ('cards', 'showncards', 'equips'):
            return (False, u'WTF?!')

        if card.is_card(cards.Skill):
            return (False, u'你不可以像这样组合技能')

        return (True, u'近一点~再近一点~~')

    def effect_string(act):
        return u'|G【%s】|r对|G【%s】|r使用了|G彼岸|r。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name
        )


class RiversideAction:
    # choose_option meta
    choose_option_buttons = ((u'弃置一张牌', 'drop'), (u'摸一张牌', 'draw'))
    choose_option_prompt = u'彼岸：你希望发动的效果？'


class ReturningAwake:
    def effect_string(act):
        return u'|G【%s】|r：“啊啊不能再偷懒啦！要被四季大人说教啦！”' % (
            act.target.ui_meta.char_name,
        )


class Returning:
    # Skill
    name = u'归航'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class FerryFee:
    # Skill
    name = u'渡钱'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class FerryFeeEffect:
    def effect_string(act):
        return u'|G【%s】|r收走了|G【%s】|r的一张牌作为|G渡钱|r。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class FerryFeeHandler:
    # choose_option meta
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动渡钱吗？'

########NEW FILE########
__FILENAME__ = mamizou
# -*- coding: utf-8 -*-

from gamepack.thb import cards, characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, limit1_skill_used, my_turn
from gamepack.thb.ui.resource import resource as gres
from client.ui.controls import Panel, Colors, Button
from utils import BatchList


__metaclass__ = gen_metafunc(characters.mamizou)


class MorphingCardSelectionUI(Panel):
    def __init__(self, parent, *a, **k):
        w, h = 480, 300  # 15 + (70+5)*6 + 15, 15 + (25+2) * 10 + 15
        x = (parent.width - w) // 2
        y = (parent.height - h) // 2
        Panel.__init__(self, x=x, y=y, width=w, height=h, parent=parent, zindex=10, *a, **k)
        self.view = view = parent
        view.add_observer('selection_change', self.on_selection_change)
        self.buttons = {}
        self.on_selection_change()

    def on_selection_change(self):
        view = self.view
        params = view.get_action_params()
        selection = cards.Card.card_classes.get(params.get('mamizou_morphing'))

        self.buttons = buttons = {}
        [b.delete() for b in self.control_list[:]]

        cl = view.get_selected_cards()
        if len(cl) != 2:
            return

        cats = set(cl[0].category)
        cats.update(cl[1].category)

        if 'skill' in cats:
            return

        cats = cats & {'basic', 'spellcard'}
        if not cats:
            return

        if 'spellcard' in cats:
            cats.discard('spellcard')
            cats.add('instant_spellcard')

        classes = [
            cls for cls in cards.Card.card_classes.values()
            if set(cls.category) & cats
        ]

        for i, cls in enumerate(classes):
            y, x = divmod(i, 6)
            b = Button(
                cls.ui_meta.name,
                parent=self, color=self.category_color(cls.category),
                x=15 + 75 * x, y=300 - 15 - (y+1)*27, width=70, height=25,
            )

            b.cls = cls
            buttons[cls] = b

            if selection is cls:
                b.color = Colors.orange

            @b.event
            def on_click(b=b):
                selection = cards.Card.card_classes.get(params.get('mamizou_morphing'))
                if b.cls is selection:
                    return

                clsname = b.cls.__name__
                last = self.buttons.get(selection)
                if last:
                    last.color = self.category_color(last.cls.category)

                b.color = Colors.orange
                params['mamizou_morphing'] = clsname
                self.view.notify('selection_change')

    def delete(self):
        self.view.remove_observer('selection_change', self.on_selection_change)
        Panel.delete(self)

    def category_color(self, category):
        return Colors.blue if 'basic' in category else Colors.green


class Morphing:
    # Skill
    name = u'变化'
    params_ui = MorphingCardSelectionUI

    def clickable(game):
        me = game.me

        if limit1_skill_used('mamizou_morphing_tag'):
            return False

        if not (my_turn() and (me.cards or me.showncards)):
            return False

        return True

    def is_action_valid(g, cl, target_list):
        skill = cl[0]
        assert skill.is_card(characters.mamizou.Morphing)
        cl = skill.associated_cards
        if len(cl) != 2 or any([c.resides_in.type not in ('cards', 'showncards') for c in cl]):
            return (False, u'请选择两张手牌！')

        cls = skill.get_morph_cls()
        if not cls:
            return (False, u'请选择需要变化的牌')

        if not skill.is_morph_valid():
            return (False, u'选择的变化牌不符和规则')

        return skill.treat_as.ui_meta.is_action_valid(g, [skill], target_list)

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        source = act.source
        card = act.card
        tl = BatchList(act.target_list)
        cl = BatchList(card.associated_cards)
        s = u'|G【%s】|r发动了|G变化|r技能，将|G%s|r当作|G%s|r对|G【%s】|r使用。' % (
            source.ui_meta.char_name,
            u'|r、|G'.join(cl.ui_meta.name),
            card.treat_as.ui_meta.name,
            u'】|r、|G【'.join(tl.ui_meta.char_name),
        )

        return s


class Mamizou:
    # Character
    char_name = u'二岩猯藏'
    port_image = gres.mamizou_port
    description = (
        u'|DB大狸子 二岩猯藏 体力：4|r\n\n'
        u'|G变化|r：出牌阶段限一次，你将两张手牌当做任何一张基本牌或非延时符卡使用。按此法使用的两张牌中至少有一张必须和你声明的牌类别一致。\n\n'
        u'|RKOF模式不可用\n\n|r'
        u'|DB（人物设计：鵺子丶爱丽丝）|r'
    )

########NEW FILE########
__FILENAME__ = marisa
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, my_turn
from gamepack.thb.ui.ui_meta.common import limit1_skill_used
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.marisa)


class Marisa:
    # Character
    char_name = u'雾雨魔理沙'
    port_image = gres.marisa_port
    description = (
        u'|DB绝非普通的强盗少女 雾雨魔理沙 体力：4|r\n\n'
        u'|G借走|r：出牌阶段，你可以获得一名角色的一张牌，视为该角色对你使用了一张【弹幕】，每阶段限一次。'
    )


class Daze:
    name = u'打贼'

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        return u'|G【%s】|r喊道：“打贼啦！”向|G【%s】|r使用了|G弹幕|r。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class Borrow:
    # Skill
    name = u'借走'

    def clickable(g):
        if limit1_skill_used('borrow_tag'):
            return False

        if not my_turn(): return False

        return True

    def is_action_valid(g, cl, target_list):
        skill = cl[0]
        if skill.associated_cards:
            return (False, u'请不要选择牌!')

        if len(target_list) != 1:
            return (False, u'请选择1名玩家')

        tgt = target_list[0]
        if not (tgt.cards or tgt.showncards or tgt.equips):
            return (False, u'目标没有牌可以“借给”你')

        return (True, u'我死了以后你们再拿回去好了！')

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        return u'大盗|G【%s】|r又出来“|G借走|r”了|G【%s】|r的牌。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )

########NEW FILE########
__FILENAME__ = medicine
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, card_desc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.medicine)


class Medicine:
    # Character
    char_name = u'梅蒂欣'
    port_image = gres.medicine_port
    description = (
        u'|DB 小小的甜蜜毒药 梅蒂欣 体力：3|r\n\n'
        u'|G神经之毒|r：一名角色的准备阶段开始时，你可以弃置一张手牌，令该角色获得|G喝醉|r状态。若该角色在该回合结束阶段开始时处于|G喝醉|r状态，其失去|G喝醉|r状态并选择一项：①弃置一张手牌并令你摸一张牌；②受到一点无来源伤害。\n\n'
        u'|G忧郁之毒|r：每当你受到X点有来源的伤害后，你可以摸X张牌并展示，若其中至少一张不为梅花，伤害来源无法使用或打出手牌直到该回合结束。'
    )


class Ciguatera:
    # Skill
    name = u'神经之毒'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class CiguateraAction:
    def effect_string_before(act):
        return u'|G【%s】|r对|G【%s】|r使用了|G神经之毒|r。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name
        )


class CiguateraTurnEnd:
    def choose_card_text(g, act, cards):
        return act.cond(cards), u'受到一点无来源伤害，或者弃置一张手牌并让【%s】摸一张牌' % act.target.ui_meta.char_name

    def effect_string_before(act):
        return u'|G【%s】|r受到|G【%s】|r的|G神经之毒|r爆发了。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name
        )

    def effect_string(act):
        if act.card:
            return u'|G【%s】|r弃掉了%s。' % (
                act.source.ui_meta.char_name,
                card_desc(act.card)
            )


class CiguateraHandler:
    def choose_card_text(g, act, cards):
        return act.cond(cards), u'弃置一张手牌，发动【神经之毒】'


class Melancholy:
    # Skill
    name = u'忧郁之毒'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class MelancholyAction:
    def effect_string_before(act):
        return u'|G【%s】|r对|G【%s】|r使用了|G忧郁之毒|r。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name
        )

    def effect_string(act):
        return (u'|G【%s】|r陷入了忧郁。' if act.effective 
                else u'但|G【%s】|r缓了过来。' ) % act.target.ui_meta.char_name


class MelancholyHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'是否发动【忧郁之毒】'


########NEW FILE########
__FILENAME__ = meirin
# -*- coding: utf-8 -*-

from gamepack.thb import actions
from gamepack.thb import cards
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.ui_meta.common import build_handcard
from gamepack.thb.ui.resource import resource as gres


__metaclass__ = gen_metafunc(characters.meirin)


class RiverBehind:
    # Skill
    name = u'背水'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class Taichi:
    # Skill
    name = u'太极'

    def clickable(game):
        try:
            act = game.action_stack[-1]
            if isinstance(act, actions.ActionStage):
                return True

            if act.cond([build_handcard(cards.AttackCard)]):
                return True

            if act.cond([build_handcard(cards.GrazeCard)]):
                return True

        except:
            pass

        return False

    def is_complete(g, cl):
        skill = cl[0]
        cl = skill.associated_cards
        from gamepack.thb.cards import AttackCard, GrazeCard
        if len(cl) != 1 or not (cl[0].is_card(AttackCard) or cl[0].is_card(GrazeCard)):
            return (False, u'请选择一张【弹幕】或者【擦弹】！')
        return (True, u'动之则分，静之则合。无过不及，随曲就伸')

    def is_action_valid(g, cl, target_list, is_complete=is_complete):
        skill = cl[0]
        rst, reason = is_complete(g, cl)
        if not rst:
            return (rst, reason)
        else:
            return skill.treat_as.ui_meta.is_action_valid(g, [skill], target_list)

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        source = act.source
        return (
            u'动之则分，静之则合。无过不及，随曲就伸……|G【%s】|r凭|G太极|r之势，轻松应对。'
        ) % (
            source.ui_meta.char_name,
        )


class LoongPunch:
    # Skill
    name = u'龙拳'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class LoongPunchHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【龙拳】吗？'


class LoongPunchAction:
    def effect_string_before(act):
        if act.type == 'attack':
            return u'|G【%s】|r闪过了|G弹幕|r，却没有闪过|G【%s】|r的拳劲，一张手牌被|G【%s】|r震飞！' % (
                act.target.ui_meta.char_name,
                act.source.ui_meta.char_name,
                act.source.ui_meta.char_name,
            )
        if act.type == 'graze':
            return u'|G【%s】|r擦过弹幕，随即以拳劲沿着弹幕轨迹回震，|G【%s】|r措手不及，一张手牌掉在了地上。' % (
                act.source.ui_meta.char_name,
                act.target.ui_meta.char_name,
            )


class RiverBehindAwake:
    def effect_string_before(act):
        return u'|G【%s】|r发现自己处境危险，于是强行催动内力护住身体，顺便参悟了太极拳。' % (
            act.target.ui_meta.char_name,
        )


class Meirin:
    # Character
    char_name = u'红美铃'
    port_image = gres.meirin_port
    description = (
        u'|DB我只打盹我不翘班 红美铃 体力：4|r\n\n'
        u'|G龙拳|r：每当你使用【弹幕】被【擦弹】抵消或使用【擦弹】抵消【弹幕】时，你可以弃置对方的一张手牌。\n\n'
        u'|G背水|r：|B觉醒技|r，回合开始阶段，当你的体力为2或者更少，并且是全场最低时，损失一点体力上限，同时获得|R太极|r技能。\n\n'
        u'|R太极|r：你可将【弹幕】作为【擦弹】，【擦弹】作为【弹幕】使用或打出。'
    )

########NEW FILE########
__FILENAME__ = minoriko
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, my_turn
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.ui_meta.common import limit1_skill_used
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.minoriko)


class Foison:
    # Skill
    name = u'丰收'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class FoisonDrawCardStage:
    def effect_string(act):
        return u'大丰收！|G【%s】|r一下子收获了%d张牌！' % (
            act.source.ui_meta.char_name,
            act.amount,
        )


class AutumnFeast:
    # Skill
    name = u'秋祭'

    def clickable(game):
        me = game.me
        if not my_turn(): return False
        if limit1_skill_used('autumnfeast_tag'): return False

        if not (me.cards or me.showncards or me.equips):
            return False

        return True

    def is_action_valid(g, cl, target_list):
        skill = cl[0]
        cl = skill.associated_cards
        from gamepack.thb.cards import Card
        if len(cl) != 2 or any(c.color != Card.RED for c in cl):
            return (False, u'请选择2张红色的牌！')
        return (True, u'发麻薯啦~')

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        source = act.source
        return (
            u'|G【%s】|r：麻薯年年有，今年特别多！'
        ) % (
            source.ui_meta.char_name,
        )


class AkiTribute:
    # Skill
    name = u'上贡'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class Minoriko:
    # Character
    char_name = u'秋穰子'
    port_image = gres.minoriko_port
    description = (
        u'|DB没人气的丰收神 秋穰子 体力：3|r\n\n'
        u'|G丰收|r：|B锁定技|r，摸牌阶段摸牌后，若你的手牌数不足5张，你可以补至5张。\n\n'
        u'|G秋祭|r：你可以将两张红色的手牌或装备牌当作【五谷丰登】使用。一回合限一次。\n\n'
        u'|G上贡|r：|B锁定技|r，任何人使用【五谷丰登】时，你首先拿牌。在【五谷丰登】结算完毕后，若仍有牌没有被拿走，你将这些牌收入明牌区。'
    )

########NEW FILE########
__FILENAME__ = mokou
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.mokou)


class Mokou:
    # Character
    char_name = u'藤原妹红'
    port_image = gres.mokou_port
    description = (
        u'|DBFFF团资深团员 藤原妹红 体力：4|r\n\n'
        u'|G浴火|r：回合结束阶段，你可以流失一点体力，摸2张牌。\n\n'
        u'|G重生|r：回合开始阶段，你可以弃置X张红色牌并回复一点体力（X为你的当前体力值）。'
    )


class Ashes:
    # Skill
    name = u'浴火'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class AshesAction:
    def effect_string_before(act):
        return u'|G【%s】|r：“不~可~饶~恕~！”' % (
            act.target.ui_meta.char_name
        )


class AshesHandler:
    # choose_option meta
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【浴火】吗？'


class Reborn:
    # Skill
    name = u'重生'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class RebornAction:
    def effect_string(act):
        return u'|G【%s】|r使用了|G重生|r。' % (
            act.target.ui_meta.char_name
        )


class RebornHandler:
    # choose_card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'弃置这些牌并回复1点体力')
        else:
            return (False, u'重生：选择%d张红色牌弃置并回复一点体力' % act.target.life)

########NEW FILE########
__FILENAME__ = momiji
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.momiji)


class Momiji:
    # Character
    char_name = u'犬走椛'
    port_image = gres.momiji_port
    description = (
        u'|DB山中的千里眼 犬走椛 体力：4|r\n\n'
        u'|G哨戒|r：当其他玩家（记作A）使用弹幕并对另一玩家（记作B）造成伤害时，若A在你的攻击距离内，你可以使用一张弹幕或梅花色牌作为弹幕对A使用。若此弹幕造成伤害，你可以防止此伤害，并且使B受到的伤害-1。\n\n'
        u'|G千里眼|r：你与其他玩家结算距离时始终-1'
    )


class Sentry:
    # Skill
    name = u'哨戒'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class SharpEye:
    # Skill
    name = u'千里眼'
    no_display = False
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class SentryAttack:
    # Skill
    name = u'哨戒'


class SentryHandler:
    # choose_option meta
    choose_option_buttons = ((u'保护', True), (u'伤害', False))
    choose_option_prompt = u'你希望发动的效果？'

    # choose_card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'吃我大弹幕啦！(对%s发动哨戒)' % act.target.ui_meta.char_name)
        else:
            return (False, u'请选择一张弹幕或者草花色牌发动哨戒(对%s)' % act.target.ui_meta.char_name)

########NEW FILE########
__FILENAME__ = nazrin
# -*- coding: utf-8 -*-

from gamepack.thb import cards
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.nazrin)


class Nazrin:
    # Character
    char_name = u'纳兹琳'
    port_image = gres.nazrin_port
    description = (
        u'|DB探宝的小小大将 纳兹琳 体力：3|r\n\n'
        u'|G轻敏|r：你可以将你的黑色手牌当作【擦弹】使用或打出。\n\n'
        u'|G探宝|r：回合开始阶段，你可以进行判定。判定结束后，若为黑色，你获得此判定牌，并且可以继续发动探宝。'
    )


class TreasureHuntSkill:
    # Skill
    name = u'探宝'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class TreasureHuntHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【探宝】吗？'


class Agile:
    # Skill
    name = u'轻敏'

    def clickable(game):
        me = game.me

        try:
            act = game.action_stack[-1]
        except IndexError:
            return False

        if isinstance(act, cards.BaseUseGraze) and (me.cards or me.showncards):
            return True

        return False

    def is_complete(g, cl):
        skill = cl[0]
        cl = skill.associated_cards
        if len(cl) != 1:
            return (False, u'请选择一张牌！')
        else:
            c = cl[0]
            if c.resides_in not in (g.me.cards, g.me.showncards):
                return (False, u'请选择手牌！')
            if c.suit not in (cards.Card.SPADE, cards.Card.CLUB):
                return (False, u'请选择一张黑色的牌！')
            return (True, u'这种三脚猫的弹幕，想要打中我是不可能的啦~')


class TreasureHunt:
    fatetell_display_name = u'探宝'

    def effect_string(act):
        if act.succeeded:
            return u'|G【%s】|r找到了|G%s|r' % (
                act.target.ui_meta.char_name,
                act.card.ui_meta.name,
            )
        else:
            return u'|G【%s】|r什么也没有找到…' % (
                act.target.ui_meta.char_name,
            )

########NEW FILE########
__FILENAME__ = parsee
# -*- coding: utf-8 -*-

from gamepack.thb import cards
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, my_turn
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.parsee)


class Parsee:
    # Character
    char_name = u'水桥帕露西'
    port_image = gres.parsee_port
    description = (
        u'|DB地壳下的嫉妒心 水桥帕露西 体力：4|r\n\n'
        u'|G嫉妒|r：出牌阶段，你可以将一张黑色牌当做【城管执法】使用，若以此法使一名距离1以内角色的一张方片牌进入弃牌堆，你可以获得之。'
    )


class Envy:
    # Skill
    name = u'嫉妒'

    def clickable(game):
        me = game.me

        if my_turn() and (me.cards or me.showncards or me.equips):
            return True

        return False

    def is_action_valid(g, cl, target_list):
        skill = cl[0]
        assert skill.is_card(characters.parsee.Envy)
        cl = skill.associated_cards
        if len(cl) != 1:
            return (False, u'请选择一张牌！')
        else:
            c = cl[0]
            if c.suit not in (cards.Card.SPADE, cards.Card.CLUB):
                return (False, u'请选择一张黑色的牌！')
            return cards.DemolitionCard.ui_meta.is_action_valid(g, [skill], target_list)

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        source = act.source
        card = act.card
        target = act.target
        s = u'|G【%s】|r发动了嫉妒技能，将|G%s|r当作|G%s|r对|G【%s】|r使用。' % (
            source.ui_meta.char_name,
            card.associated_cards[0].ui_meta.name,
            card.treat_as.ui_meta.name,
            target.ui_meta.char_name,
        )
        return s


class EnvyHandler:
    choose_option_buttons = ((u'获得', True), (u'不获得', False))

    def choose_option_prompt(act):
        return u'你要获得【%s】吗？' % act.card.ui_meta.name


class EnvyRecycleAction:
    def effect_string(act):
        return u'|G【%s】|r：“喂喂这么好的牌扔掉不觉得可惜么？不要嫉妒我。”' % (
            act.source.ui_meta.char_name
        )

########NEW FILE########
__FILENAME__ = patchouli
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.patchouli)


class Library:
    # Skill
    name = u'图书'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class LibraryDrawCards:
    def effect_string(act):
        return u'|G【%s】|r发动了|G图书|r技能，摸1张牌。' % (
            act.source.ui_meta.char_name,
        )


class Knowledge:
    # Skill
    name = u'博学'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class KnowledgeAction:
    def effect_string(act):
        return u'|G【%s】|r一眼就看穿了这张符卡，直接挡下。' % (
            act.source.ui_meta.char_name,
        )


class Patchouli:
    # Character
    char_name = u'帕秋莉'
    port_image = gres.patchouli_port
    figure_image = gres.patchouli_figure
    figure_image_alter = gres.patchouli_figure_alter
    description = (
        u'|DB不动的大图书馆 帕秋莉 体力：3|r\n\n'
        u'|G图书|r：|B锁定技|r，每当你使用了一张非延时符卡时，你摸一张牌。\n\n'
        u'|G博学|r：|B锁定技|r，黑桃色符卡对你无效。\n\n'
        u'|DB（画师：渚FUN）|r'
    )

########NEW FILE########
__FILENAME__ = ran
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.ran)


class Prophet:
    # Skill
    name = u'神算'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class ExtremeIntelligence:
    # Skill
    name = u'极智'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class ProphetHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【神算】吗？'


class ProphetAction:
    def effect_string_before(act):
        return u'众人正准备接招呢，|G【%s】|r却掐着指头算了起来…' % (
            act.target.ui_meta.char_name,
        )


class ExtremeIntelligenceHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【极智】吗？'


class ExtremeIntelligenceAction:
    # choose_card
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'再来！')
        else:
            return (False, u'请选择1张牌弃置')

    def effect_string_before(act):
        return (
            u'|G【%s】|r刚松了一口气，却看见一张一模一样的符卡从|G【%s】|r的方向飞来！'
        ) % (
            act.target.ui_meta.char_name,
            act.source.ui_meta.char_name,
        )


class NakedFox:
    # Skill
    name = u'素裸'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class NakedFoxAction:
    def effect_string_before(act):
        if act.dmgamount <= 1:
            s = u'符卡飞到了|G【%s】|r毛茸茸的大尾巴里，然后……就没有然后了……'
        else:
            s = u'符卡飞到了|G【%s】|r毛茸茸的大尾巴里，恩……似乎还是有点疼……'

        return s % act.target.ui_meta.char_name


class Ran:
    # Character
    char_name = u'八云蓝'
    port_image = gres.ran_port
    description = (
        u'|DB天河一号的核心 八云蓝 体力：3|r\n\n'
        u'|G神算|r：在你的判定流程前，可以翻开等于场上存活人数（不超过5张）的牌，并以任意的顺序放回牌堆的上面或者下面。\n\n'
        u'|G极智|r：在你的回合外，当一张非延时符卡对一名角色生效后，你可以弃置一张牌对该角色重新进行一次结算，此时发动者视为你。每轮限一次。\n\n'
        u'|G素裸|r：在你没有手牌时，你受到的符卡伤害-1'
    )

########NEW FILE########
__FILENAME__ = reimu
# -*- coding: utf-8 -*-

from gamepack.thb import actions
from gamepack.thb import cards
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.ui_meta.common import limit1_skill_used
from gamepack.thb.ui.resource import resource as gres


__metaclass__ = gen_metafunc(characters.reimu)


class Flight:
    # Skill
    name = u'飞行'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class SpiritualAttack:
    name = u'灵击'

    def clickable(g):
        me = g.me

        if not (me.cards or me.showncards): return False

        try:
            act = g.hybrid_stack[-1]
            if act.cond([characters.reimu.SpiritualAttack(me)]):
                return True

        except (IndexError, AttributeError):
            pass

        return False

    def is_complete(g, cl):
        skill = cl[0]
        me = g.me
        assert skill.is_card(characters.reimu.SpiritualAttack)
        acards = skill.associated_cards
        if len(acards) != 1:
            return (False, u'请选择1张手牌！')

        c = acards[0]

        if c.resides_in not in (me.cards, me.showncards):
            return (False, u'只能使用手牌发动！')
        elif not c.color == cards.Card.RED:
            return (False, u'请选择红色手牌！')

        return (True, u'反正这条也看不到，偷个懒~~~')

    def is_action_valid(g, cl, target_list):
        return (False, u'你不能主动使用灵击')


class TributeTarget:
    # Skill
    name = u'纳奉'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class Tribute:
    # Skill
    name = u'塞钱'

    def clickable(game):
        me = game.me

        if limit1_skill_used('tribute_tag'):
            return False

        try:
            act = game.action_stack[-1]
        except IndexError:
            return False

        if isinstance(act, actions.ActionStage) and (me.cards or me.showncards or me.equips):
            return True

        return False

    def is_action_valid(g, cl, tl):
        cl = cl[0].associated_cards
        if not cl: return (False, u'请选择要给出的牌')
        if len(cl) != 1: return (False, u'只能选择一张手牌')

        if not cl[0].resides_in.type in ('cards', 'showncards'):
            return (False, u'只能选择手牌！')

        if len(tl) != 1 or not tl[0].has_skill(characters.reimu.TributeTarget):
            return (False, u'请选择一只灵梦')

        if len(tl[0].cards) + len(tl[0].showncards) >= tl[0].maxlife:
            return (False, u'灵梦的塞钱箱满了')

        return (True, u'塞钱……会发生什么呢？')

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        return (
            u'|G【%s】|r向|G【%s】|r的塞钱箱里放了一张牌… 会发生什么呢？'
        ) % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class Reimu:
    # Character
    char_name = u'博丽灵梦'
    port_image = gres.reimu_port
    description = (
        u'|DB节操满地跑的城管 博丽灵梦 体力：3|r\n\n'
        u'|G灵击|r：你可以将你的任意一张红色手牌当【好人卡】使用。\n\n'
        u'|G飞行|r：锁定技，当你没有装备任何UFO时，其他玩家对你结算距离时始终+1'
    )

########NEW FILE########
__FILENAME__ = remilia
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.remilia)


class SpearTheGungnir:
    # Skill
    name = u'神枪'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class SpearTheGungnirAction:
    def effect_string(act):
        return u'|G【%s】|r举起右手，将|G弹幕|r汇聚成一把命运之矛，向|G【%s】|r掷去！' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class SpearTheGungnirHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【神枪】吗？'


class VampireKiss:
    # Skill
    name = u'红魔之吻'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class VampireKissAction:
    def effect_string_before(act):
        return u'|G【%s】|r:“B型血，赞！”' % (
            act.source.ui_meta.char_name
        )


class Remilia:
    # Character
    char_name = u'蕾米莉亚'
    port_image = gres.remilia_port
    description = (
        u'|DB永远幼小的红月 蕾米莉亚 体力：4|r\n\n'
        u'|G神枪|r：出牌阶段，出现以下情况之一，你可以令你的【弹幕】不能被【擦弹】抵消：\n'
        u'|B|R>> |r目标角色的体力值 大于 你的体力值。\n'
        u'|B|R>> |r目标角色的手牌数 小于 你的手牌数。\n\n'
        u'|G红魔之吻|r：|B锁定技|r，对玩家使用红色【弹幕】命中时，回复1点体力值。'
    )

########NEW FILE########
__FILENAME__ = remilia_ex
# -*- coding: utf-8 -*-

from gamepack.thb import cards
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, my_turn
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.ui_meta.common import limit1_skill_used
from gamepack.thb.ui.resource import resource as gres
from utils import BatchList

__metaclass__ = gen_metafunc(characters.remilia_ex)


remilia_ex_description = (
    u'|DB永远威严的红月 蕾米莉亚 体力：6|r\n\n'
    u'|G神枪|r：出牌阶段，出现以下情况之一，你可以令你的【弹幕】不能被【擦弹】抵消：\n'
    u'|B|R>> |r目标角色的体力值 大于 你的体力值。\n'
    u'|B|R>> |r目标角色的手牌数 小于 你的手牌数。\n\n'
    u'|G红魔之吻|r：|B锁定技|r，对玩家使用红色【弹幕】命中时，回复1点体力值。\n\n'
    u'|G不夜城|r：|DB信仰消耗3|r，在出牌阶段主动发动。你依次弃置所有解决者的一张手牌或装备牌。如果解决者无牌可弃，则弃置所有信仰。一回合一次。\n\n'
    u'|B|R=== 以下是变身后获得的技能 ===|r\n\n'
    u'|G碎心|r：|DB信仰消耗4|r。你可以发动该技能，视为对任意一名玩家使用【弹幕】。用此方法使用的【弹幕】视为红色，距离无限不可闪避，对目标造成2点伤害。\n\n'
    u'|G红雾|r：出牌阶段，你可以弃置一张红色手牌，令所有解决者依次对另一名解决者使用一张【弹幕】，无法如此做者失去1点体力。一回合一次。\n\n'
    u'|G七重奏|r：|B锁定技|r，解决者向你的判定区放置卡牌时，需额外弃置一张颜色相同的符卡。\n\n'
    u'|G夜王|r：|B锁定技|r，你在自己的出牌阶段时额外摸4张牌。你的手牌上限+3。'
)


class RemiliaEx:
    # Character
    char_name = u'异·蕾米莉亚'
    port_image = gres.remilia_ex_port
    description = remilia_ex_description


class RemiliaEx2:
    # Character
    char_name = u'异·蕾米莉亚'
    port_image = gres.remilia_ex2_port
    description = remilia_ex_description

    wallpaper = gres.remilia_ex_wallpaper
    bgm = gres.bgm_remilia_ex
    color_scheme = 'red'


class HeartBreak:
    # Skill
    name = u'碎心'

    def effect_string(act):
        return u'|G【%s】|r将信仰灌注在神枪里，向|G【%s】|r使用了|G碎心|r。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )

    def clickable(g):
        me = g.me
        if len(me.faiths) < 4: return False
        return True

    def is_action_valid(g, cl, tl):
        if cl[0].associated_cards:
            return (False, u'请不要选择牌')

        if not tl:
            return (False, u'请选择一名解决者')

        return (True, u'发动碎心')


class NeverNight:
    # Skill
    name = u'不夜城'

    def effect_string(act):
        tl = BatchList(act.target_list)
        return u'|G【%s】|r使用了3点信仰，向|G【%s】|r使用了|G不夜城|r。' % (
            act.source.ui_meta.char_name,
            u'】|r、|G【'.join(tl.ui_meta.char_name),
        )

    def clickable(g):
        me = g.me
        if not my_turn(): return False
        if len(me.faiths) < 3: return False
        if limit1_skill_used('nevernight_tag'): return False
        return True

    def is_action_valid(g, cl, tl):
        if cl[0].associated_cards:
            return (False, u'请不要选择牌')

        if not tl:
            return (False, u'WTF?!')

        return (True, u'发动不夜城')


class ScarletFogEffect:
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'红雾里看不清，先来一发再说！')
        else:
            return (False, u'请对另一名解决者使用一张【弹幕】（否则失去一点体力）')

    # choose_players
    def target(pl):
        if not pl:
            return (False, u'请对另一名解决者使用一张【弹幕】（否则失去一点体力）')

        return (True, u'红雾里看不清，先来一发再说！')


class ScarletFog:
    # Skill
    name = u'红雾'

    def effect_string(act):
        tl = BatchList(act.target_list)
        return u'|G【%s】|r向|G【%s】|r发动了|G红雾|r！' % (
            act.source.ui_meta.char_name,
            u'】|r、|G【'.join(tl.ui_meta.char_name),
        )

    def clickable(g):
        if not my_turn(): return False
        if limit1_skill_used('scarletfog_tag'): return False
        return True

    def is_action_valid(g, cl, tl):
        acards = cl[0].associated_cards
        if (not acards) or len(acards) != 1:
            return (False, u'请选择一张红色手牌')

        card = acards[0]

        if card.color != cards.Card.RED or card.resides_in.type not in ('cards', 'showncards'):
            return (False, u'请选择一张红色的手牌!')

        if card.is_card(cards.Skill):
            return (False, u'你不可以像这样组合技能')

        if not tl:
            return (False, u'WTF?!')

        return (True, u'发动红雾')


class QueenOfMidnight:
    # Skill
    name = u'夜王'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class Septet:
    # Skill
    name = u'七重奏'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class SeptetHandler:
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'弃置并使延时符卡生效')
        else:
            return (False, u'【七重奏】请选择一张颜色相同的符卡弃置')

########NEW FILE########
__FILENAME__ = rinnosuke
# -*- coding: utf-8 -*-

from gamepack.thb import actions
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.rinnosuke)


class Netoru:
    # Skill
    name = u'寝取'

    def clickable(game):
        me = game.me
        try:
            if me.tags['netoru_tag'] >= me.tags['turn_count']:
                return False
            act = game.action_stack[-1]
            if isinstance(act, actions.ActionStage):
                return True
        except IndexError:
            pass
        return False

    def is_action_valid(g, cl, tl):
        skill = cl[0]
        cl = skill.associated_cards
        me = g.me
        if not cl or len(cl) != 2:
            return (False, u'请选择两张手牌')
        elif any(c.resides_in not in (me.cards, me.showncards) for c in cl):
            return (False, u'只能使用手牌发动！')

        if len(tl) != 1:
            return (False, u'请选择一名受伤的玩家')

        t = tl[0]
        if t.life >= t.maxlife:
            return (False, u'这位少女节操满满，不会答应你的…')
        else:
            return (True, u'少女，做个好梦~')

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        return u'|G【%s】|r一改平日的猥琐形象，竟然用花言巧语将|G【%s】|r骗去啪啪啪了！' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class Psychopath:
    # Skill
    name = u'变态'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class PsychopathDrawCards:
    def effect_string(act):
        return (
            u'|G【%s】|r满脸猥琐地将装备脱掉，结果众人抄起了%d张牌糊在了他身上。'
        ) % (
            act.target.ui_meta.char_name,
            act.amount,
        )


class Rinnosuke:
    # Character
    char_name = u'森近霖之助'
    port_image = gres.rinnosuke_port
    description = (
        u'|DB变态出没注意 森近霖之助 体力：3|r\n\n'
        u'|G变态|r：当你失去一张装备区里的牌时，你可以立即摸两张牌。\n\n'
        u'|G寝取|r：出牌阶段，你可以弃两张手牌并指定一名除了你之外的受伤的角色：你和目标角色各回复1点体力。每回合限用一次。'
    )

########NEW FILE########
__FILENAME__ = rumia
# -*- coding: utf-8 -*-

from gamepack.thb import actions
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.ui_meta.common import limit1_skill_used
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.rumia)


class Darkness:
    # Skill
    name = u'黑暗'
    custom_ray = True

    def clickable(game):
        try:
            if limit1_skill_used('darkness_tag'):
                return False
            act = game.action_stack[-1]
            if isinstance(act, actions.ActionStage):
                return True
        except IndexError:
            pass
        return False

    def is_action_valid(g, cl, tl):
        skill = cl[0]
        cl = skill.associated_cards
        if not cl or len(cl) != 1:
            return (False, u'请选择一张牌')

        if not len(tl):
            return (False, u'请选择第一名玩家（向第二名玩家出【弹幕】）')
        elif len(tl) == 1:
            return (False, u'请选择第二名玩家（【弹幕】的目标）')
        else:
            return (True, u'你们的关系…是~这样吗？')

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        return u'|G【%s】|r在黑暗中一通乱搅，结果|G【%s】|r和|G【%s】|r打了起来！' % (
            act.source.ui_meta.char_name,
            act.target_list[0].ui_meta.char_name,
            act.target_list[1].ui_meta.char_name,
        )


class DarknessAction:
    def ray(act):
        src = act.source
        tl = act.target_list
        return [(src, tl[0]), (tl[0], tl[1])]

    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'使用【弹幕】')
        else:
            return (False, u'请使用一张【弹幕】（否则受到一点伤害）')


class Cheating:
    # Skill
    name = u'作弊'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class CheatingDrawCards:
    def effect_string(act):
        return u'突然不知道是谁把太阳挡住了。等到大家回过神来，赫然发现牌堆里少了一张牌！'


class Rumia:
    # Character
    char_name = u'露米娅'
    port_image = gres.rumia_port
    description = (
        u'|DB宵暗的妖怪 露米娅 体力：3|r\n\n'
        u'|G黑暗|r：出牌阶段，你可以弃置一张牌，指定一名其他角色。该角色需对由你指定的在其攻击范围内的另一名角色使用一张【弹幕】，否则受到一点你所造成的伤害。每阶段限一次。\n\n'
        u'|G作弊|r：弃牌阶段后，你摸一张牌。'
    )

########NEW FILE########
__FILENAME__ = sakuya
# -*- coding: utf-8 -*-

from gamepack.thb import cards
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.sakuya)


class Sakuya:
    # Character
    char_name = u'十六夜咲夜'
    port_image = gres.sakuya_port
    description = (
        u'|DB完全潇洒的PAD长 十六夜咲夜 体力：4|r\n\n'
        u'|G月时计|r：|B锁定技|r，在你的判定阶段开始前，你执行一个额外的出牌阶段。\n\n'
        u'|G飞刀|r：你可以将一张装备牌当【弹幕】使用或打出。你以此法使用【弹幕】时无距离限制。'
    )


class FlyingKnife:
    # Skill
    name = u'飞刀'

    def clickable(g):
        me = g.me

        if not (me.cards or me.showncards or me.equips): return False

        try:
            act = g.hybrid_stack[-1]
            if act.cond([characters.sakuya.FlyingKnife(me)]):
                act = g.action_stack[-1]
                if act.target is g.me:
                    return True

        except (IndexError, AttributeError):
            pass

        return False

    def is_complete(g, cl):
        skill = cl[0]
        assert skill.is_card(characters.sakuya.FlyingKnife)
        cl = skill.associated_cards
        if len(cl) != 1 or not issubclass(cl[0].associated_action, cards.WearEquipmentAction):
            return (False, u'请选择一张装备牌！')
        return (True, '快看！灰出去了！')

    def is_action_valid(g, cl, target_list, is_complete=is_complete):
        rst, reason = is_complete(g, cl)
        if not rst:
            return rst, reason
        else:
            return cards.AttackCard.ui_meta.is_action_valid(g, cl, target_list)

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        source = act.source
        card = act.card
        target = act.target
        s = u'|G【%s】|r将|G%s|r制成了|G飞刀|r，向|G【%s】|r掷去！' % (
            source.ui_meta.char_name,
            card.associated_cards[0].ui_meta.name,
            target.ui_meta.char_name,
        )
        return s


class LunaClock:
    # Skill
    name = u'月时计'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid

########NEW FILE########
__FILENAME__ = sanae
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, my_turn
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.ui_meta.common import limit1_skill_used
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.sanae)


class Sanae:
    # Character
    char_name = u'东风谷早苗'
    port_image = gres.sanae_port
    description = (
        u'|DB常识满满的现人神 东风谷早苗 体力：3|r\n\n'
        u'|G御神签|r：出牌阶段，你可以指定一名其他角色，然后让其摸取等同于其残机数与场上残机数最多的角色的残机数之差的牌（至多4张，至少1张）。每阶段限一次。\n\n'
        u'|G奇迹|r：当你受到一次【弹幕】的伤害后，你可以弃置X张牌（不足则全弃）然后摸X张牌。若你的体力为全场最少的角色或之一，你可以令一名其他角色也如此做。（X为你已损失的体力值）'
    )


class DrawingLotAction:
    def effect_string(act):
        return u'大吉！|G【%s】|r脸上满满的满足感，摸了%d张牌。' % (
            act.target.ui_meta.char_name,
            act.amount,
        )


class DrawingLot:
    name = u'御神签'

    def clickable(g):
        if my_turn() and not limit1_skill_used('drawinglot_tag'):
            return True

        return False

    def effect_string(act):
        return u'|G【%s】|r给|G【%s】|r抽了一签……' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )

    def is_action_valid(g, cl, tl):
        if cl[0].associated_cards:
            return (False, u'请不要选择牌！')

        return (True, u'一定是好运气的！')


class Miracle:
    # Skill
    name = u'奇迹'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class MiracleAction:
    def effect_string(act):
        return u'|G【%s】|r说，要有|G奇迹！' % (
            act.source.ui_meta.char_name,
        )

    # choose_players
    def target(pl):
        if not pl:
            return (False, u'奇迹：请选择1名其他玩家，执行相同的动作')

        return (True, u'奇迹！')

    # choose_card
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'弃置这些牌，并摸%d张牌' % act.amount)
        else:
            return (False, u'请选择%d张牌弃置，并摸%d张牌' % (act.amount, act.amount))


class MiracleHandler:
    # choose_option meta
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【奇迹】吗？'

########NEW FILE########
__FILENAME__ = seiga
# -*- coding: utf-8 -*-

from gamepack.thb import cards
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, my_turn
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.seiga)


class Seiga:
    # Character
    char_name = u'霍青娥'
    port_image = gres.seiga_port
    description = (
        u'|DB僵尸别跑 霍青娥 体力：4|r\n\n'
        u'|G邪仙|r：你的回合内，你可以将一张可以主动发动的手牌交给任意一名玩家，并以该玩家的身份立即使用。\n'
        u'|B|R>> |r以此方法使用弹幕时，弹幕的“一回合一次”的限制由你来承担\n'
        u'|B|R>> |r在结算的过程中，你可以选择跳过指向多人的卡牌效果结算。'

        # u'|G穿墙|r：当你成为可指向多人的卡牌、技能的目标时，你可以使该效果无效并摸一张牌。'
    )


class HeterodoxyHandler:
    # choose_option meta
    choose_option_buttons = ((u'跳过结算', True), (u'正常结算', False))
    choose_option_prompt = u'你要跳过当前的卡牌结算吗？'


class HeterodoxySkipAction:
    def effect_string(act):
        return u'|G【%s】|r跳过了卡牌效果的结算' % (
            act.source.ui_meta.char_name,
        )


class HeterodoxyAction:
    def ray(act):
        return [(act.source, act.target_list[0])]


class Heterodoxy:
    # Skill
    name = u'邪仙'
    custom_ray = True

    def clickable(g):
        if not my_turn(): return False

        me = g.me
        return bool(me.cards or me.showncards or me.equips)

    def effect_string(act):
        return u'|G【%s】|r发动了邪仙技能，以|G【%s】|r的身份使用了卡牌' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )

    def is_action_valid(g, cl, tl):
        acards = cl[0].associated_cards
        if (not acards) or len(acards) != 1:
            return (False, u'请选择一张手牌')

        card = acards[0]

        if card.resides_in.type not in ('cards', 'showncards'):
            return (False, u'请选择一张手牌!')

        if card.is_card(cards.Skill):
            return (False, u'你不可以像这样组合技能')

        if not getattr(card, 'associated_action', None):
            return (False, u'请的选择可以主动发动的卡牌！')

        if not tl:
            return (False, u'请选择一名玩家作为卡牌发起者')

        victim = tl[0]
        _tl, valid = card.target(g, victim, tl[1:])
        return card.ui_meta.is_action_valid(g, [card], _tl)

        # can't reach here
        # return (True, u'僵尸什么的最萌了！')
        # orig

########NEW FILE########
__FILENAME__ = seija
# -*- coding: utf-8 -*-

from gamepack.thb import actions
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.ui_meta.common import limit1_skill_used
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.seija)


class InciteAttack:
    name = u'挑拨'
    def effect_string(act):
        return u'|G【%s】|r立刻将|G弹幕|r甩在了|G【%s】|r的脸上：“看也就看了，能别说么？”' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class InciteFailAttack:
    name = u'挑拨'
    def effect_string(act):
        return u'|G【%s】|r立刻将|G弹幕|r甩在了|G【%s】|r的脸上：“你怎么知道是蓝白条的？”' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class InciteSilentFailAction:
    def effect_string(act):
        return u'|G【%s】|r低头看了一眼，诶，好像真的是蓝白条……' % (
            act.target.ui_meta.char_name,
        )


class Incite:
    # Skill
    name = u'挑拨'
    custom_ray = True

    def clickable(game):
        try:
            if limit1_skill_used('incite_tag'):
                return False
            act = game.action_stack[-1]
            if isinstance(act, actions.ActionStage):
                return True
        except IndexError:
            pass

        return False

    def is_action_valid(g, cl, tl):
        if cl[0].associated_cards:
            return (False, u'请不要选择牌！')

        if not len(tl):
            return (False, u'请选择第一名玩家（【拼点】的对象）')
        elif len(tl) == 1:
            return (False, u'请选择第二名玩家（【弹幕】的目标）')
        else:
            return (True, u'大嘴正邪愉快的一天开始了～')

    def effect_string(act):
        src = act.source
        tgt, victim = act.target_list
        if victim is src:
            return u'|G【%s】|r一脸坏笑，对|G【%s】|r说：“那个啥…… 蓝白条，赞！”' % (
                src.ui_meta.char_name,
                tgt.ui_meta.char_name,
            )
        else:
            return u'|G【%s】|r一脸坏笑，对|G【%s】|r说：“你知道吗，|G【%s】|r刚才看了你的胖次，蓝白条，赞！”' % (
                src.ui_meta.char_name,
                tgt.ui_meta.char_name,
                victim.ui_meta.char_name,
            )


class InciteAction:
    # choose_option
    choose_option_buttons = ((u'使用', True), (u'不使用', False))

    def ray(act):
        src = act.source
        tl = act.target_list
        return [(src, tl[0]), (tl[0], tl[1])]

    def choose_option_prompt(act):
        return u'你要对【%s】使用【弹幕】吗？' % act.source.ui_meta.char_name


class Reversal:
    # Skill
    name = u'逆转'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class ReversalDuel:
    name = u'逆转'

    def effect_string(act):
        return u'|G【%s】|r对|G【%s】|r：“你敢打我脸，我就敢打回去！”' % (
            act.target.ui_meta.char_name,
            act.source.ui_meta.char_name,
        )


class ReversalHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【逆转】吗？'


class Seija:
    # Character
    char_name = u'鬼人正邪'
    port_image = gres.seija_port
    description = (
        u'|DB逆袭的天邪鬼 鬼人正邪 体力：3|r\n\n'
        u'|G挑拨|r：出牌阶段，你可以与一名角色拼点，若你赢，视为该角色对其攻击范围内一名由你指定的角色使用了一张【弹幕】。若你没赢，该角色可以视为对你使用了一张【弹幕】。每阶段限一次。\n\n'
        u'|G逆转|r：你受到【弹幕】效果时，你可以摸一张牌，然后若此时你的手牌数大于该角色，此弹幕对你无效并视为该角色对你使用了一张【弹幕战】。'
    )

########NEW FILE########
__FILENAME__ = shikieiki
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.ui_meta.common import card_desc
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.shikieiki)


class Trial:
    # Skill
    name = u'审判'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class TrialAction:
    def effect_string(act):
        return u'幻想乡各地巫女妖怪纷纷表示坚决拥护|G【%s】|r将|G【%s】|r的判定结果修改为%s的有关决定！' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
            card_desc(act.card)
        )


class Majesty:
    # Skill
    name = u'威严'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class MajestyAction:
    def effect_string(act):
        return u'|G【%s】|r脸上挂满黑线，收走了|G【%s】|r的一张牌填补自己的|G威严|r。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class TrialHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【审判】吗？'

    # choose_card
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'有罪！')
        else:
            return (False, u'请选择一张牌代替当前的判定牌')


class MajestyHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【威严】吗？'


class Shikieiki:
    # Character
    char_name = u'四季映姬'
    port_image = gres.shikieiki_port
    description = (
        u'|DB胸不平何以平天下 四季映姬 体力：3|r\n\n'
        u'|G审判|r：在任意角色的判定牌生效前，你可以打出一张牌代替之。\n\n'
        u'|G威严|r：可以立即从对你造成伤害的来源处获得一张牌。'
    )

########NEW FILE########
__FILENAME__ = suika
# -*- coding: utf-8 -*-

from gamepack.thb import actions
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.suika)


class Drunkard:
    # Skill
    name = u'酒鬼'

    def clickable(game):
        me = game.me

        try:
            act = game.action_stack[-1]
        except IndexError:
            return False

        if isinstance(act, actions.ActionStage) and act.target is me and (me.cards or me.showncards or me.equips):
            return True

        return False

    def is_action_valid(g, cl, target_list):
        skill = cl[0]
        cl = skill.associated_cards
        from gamepack.thb.cards import Card
        if not (
            cl and len(cl) == 1 and
            cl[0].color == Card.BLACK and
            cl[0].resides_in.type in ('cards', 'showncards', 'equips')
        ): return (False, u'请选择一张黑色牌！')
        return (True, u'常在地狱走，怎能没有二锅头！')

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        source = act.source
        s = u'|G【%s】|r不知从哪里拿出一瓶酒，大口喝下。' % (
            source.ui_meta.char_name,
        )
        return s


class GreatLandscape:
    # Skill
    name = u'大江山'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class WineGod:
    # Skill
    name = u'醉神'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class WineDream:
    # Skill
    name = u'醉梦'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class WineGodAwake:
    def effect_string_before(act):
        return u'|G【%s】|r找到了自己的本命酒胡芦……喂这样喝没问题吗？' % (
            act.target.ui_meta.char_name,
        )


class Suika:
    # Character
    char_name = u'伊吹萃香'
    port_image = gres.suika_port
    description = (
        u'|DB小小的酒鬼夜行 伊吹萃香 体力：4|r\n\n'
        u'|G大江山|r：|B锁定技|r，当你没有装备武器时，你的攻击范围始终+X，X为你已损失的体力数。\n\n'
        u'|G酒鬼|r：你的出牌阶段，你可以将黑色的手牌或装备牌当【酒】使用。\n\n'
        u'|G醉神|r：|B觉醒技|r，当你装备【伊吹瓢】时，你必须减少1点体力上限，并永久获得技能|R醉梦|r\n\n'
        u'|R醉梦|r：|B锁定技|r，当你解除喝醉状态时，你摸1张牌。'
    )

########NEW FILE########
__FILENAME__ = tenshi
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, card_desc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.tenshi)


class Masochist:
    # Skill
    name = u'抖Ｍ'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class MasochistHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【抖Ｍ】吗？'


class MasochistAction:
    # choose_card
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'给你牌~')
        else:
            return (False, u'请选择你要给出的牌（否则给自己）')

    def target(pl):
        if not pl:
            return (False, u'请选择1名玩家')

        return (True, u'给你牌~')

    def effect_string_before(act):
        return u'不过|G【%s】|r好像很享受的样子…' % (
            act.target.ui_meta.char_name,
        )


class ScarletPerception:
    # Skill
    name = u'绯想'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class ScarletPerceptionAction:
    def effect_string(act):
        return u'|G【%s】|r获得了%s' % (
            act.source.ui_meta.char_name,
            card_desc(act.card)
        )


class Tenshi:
    # Character
    char_name = u'比那名居天子'
    port_image = gres.tenshi_port
    description = (
        u'|DB有顶天的大M子 比那名居天子 体力：3|r\n\n'
        u'|G抖Ｍ|r：每当你受到X点伤害，你可以摸X*2张牌，然后将这些牌分配给任意的角色。\n\n'
        u'|G绯想|r：与你距离为1以内的角色的红色判定牌进入弃牌堆后，你获得之。'
    )

########NEW FILE########
__FILENAME__ = tewi
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.tewi)


class Luck:
    # Skill
    name = u'幸运'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class LuckDrawCards:
    def effect_string(act):
        return u'|G【%s】|r觉得手上没有牌就输了，于是又摸了2张牌。' % (
            act.source.ui_meta.char_name,
        )


class Tewi:
    # Character
    char_name = u'因幡帝'
    port_image = gres.tewi_port
    description = (
        u'|DB幸运的腹黑兔子 因幡帝 体力：4|r\n\n'
        u'|G幸运|r：|B锁定技|r，当你的手牌数为0时，立即摸2张牌。'
    )

########NEW FILE########
__FILENAME__ = youmu
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc, my_turn
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.youmu)


class Youmu:
    # Character
    char_name = u'魂魄妖梦'
    port_image = gres.youmu_port
    description = (
        u'|DB半分虚幻的厨师 魂魄妖梦 体力：4|r\n\n'
        u'|G迷津慈航斩|r：|B锁定技|r，你使用【弹幕】时，目标角色需连续使用两张【擦弹】才能抵消；与你进行【弹幕战】的角色每次需连续打出两张【弹幕】。\n\n'
        u'|G二刀流|r：你可以同时装备两把武器。同时装备时，攻击距离加成按其中较低者计算，武器技能同时有效，且你于出牌阶段可以额外使用一张弹幕。\n'
        u'|B|R>> |r成为【人形操控】目标并且不出【弹幕】的话，两把武器会被一起拿走\n'
        u'|B|R>> |r当你同时装备两把武器时，你可以主动的弃置其中一把'
    )


class Mijincihangzhan:
    # Skill
    name = u'迷津慈航斩'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class MijincihangzhanAttack:
    def effect_string_apply(act):
        src = act.source
        return u'|G【%s】|r在弹幕中注入了妖力，弹幕形成了一个巨大的光刃，怕是不能轻易地闪开的！' % (
            src.ui_meta.char_name,
        )


class Nitoryuu:
    # Skill
    name = u'二刀流'

    def clickable(game):
        me = game.me
        weapons = [e for e in me.equips if e.equipment_category == 'weapon']
        return my_turn() and len(weapons) == 2

    def is_action_valid(g, cl, target_list):
        skill = cl[0]

        if not [g.me] == target_list:
            return (False, 'BUG!!')

        if skill.associated_cards:
            return (False, u'请不要选择牌！')

        return (True, u'二刀流：主动弃置一把武器')

    def effect_string(act):
        return u'|G【%s】|r弃置了自己的一把武器' % (
            act.target.ui_meta.char_name,
        )


class Xianshiwangzhi:
    # Skill
    name = u'现世妄执'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid

########NEW FILE########
__FILENAME__ = yugi
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.yugi)


class Yugi:
    # Character
    char_name = u'星熊勇仪'
    port_image = gres.yugi_port
    description = (
        u'|DB人所谈论的怪力乱神 星熊勇仪 体力：4|r\n\n'
        #u'|G强袭|r：你可以自损1点体力，或者使用一张武器牌/【酒】，对任意一名在你的攻击范围内的玩家造成一点伤害。\n\n'
        u'|G强袭|r：你与其他玩家结算距离时始终-1\n\n'
        u'|G怪力|r：你对别的角色出【弹幕】时可以选择做一次判定：若判定牌为红色花色，则此【弹幕】不可回避，直接命中；若判定牌为黑色花色，则此【弹幕】可回避，但如果对方没有出【擦弹】，则命中后可以选择弃掉对方一张牌。'
    )


class AssaultSkill:
    # Skill
    name = u'强袭'
    no_display = False
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class FreakingPowerSkill:
    # Skill
    name = u'怪力'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class FreakingPower:
    fatetell_display_name = u'怪力'

    def effect_string_before(act):
        return u'|G【%s】|r稍微认真了一下，弹幕以惊人的速度冲向|G【%s】|r' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class YugiHandler:
    # choose_option
    choose_option_buttons = ((u'发动', True), (u'不发动', False))
    choose_option_prompt = u'你要发动【怪力】吗？'

########NEW FILE########
__FILENAME__ = yukari
# -*- coding: utf-8 -*-

from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres
from utils import BatchList

__metaclass__ = gen_metafunc(characters.yukari)


class Realm:
    # Skill
    name = u'境界'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class RealmSkipFatetell:
    def effect_string_before(act):
        return u'|G【%s】|r 发动了|G境界|r，跳过了判定阶段。' % (
            act.target.ui_meta.char_name,
        )


class RealmSkipFatetellHandler:
    # choose_card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'跳过判定阶段')
        else:
            return (False, u'请弃置一张手牌，跳过判定阶段')


class RealmSkipDrawCard:
    def effect_string_before(act):
        tl = BatchList(act.pl)
        return u'|G【%s】|r发动了|G境界|r，跳过了摸牌阶段，并抽取了|G【%s】|r的手牌。' % (
            act.target.ui_meta.char_name,
            u'】|r和|G【'.join(tl.ui_meta.char_name),
        )


class RealmSkipDrawCardHandler:
    # choose_card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'跳过摸牌阶段，并获得任意1～2名角色的一张手牌')
        else:
            return (False, u'请弃置一张手牌，跳过摸牌阶段')

    # choose_players
    def target(tl):
        if not tl:
            return (False, u'请选择1-2名其他玩家，随机出抽取一张手牌')

        return (True, u'跳过摸牌阶段，并获得任意1～2名角色的一张手牌')


class RealmSkipAction:
    # choose_option meta
    choose_option_buttons = ((u'相应区域', True), (u'手牌区', False))
    choose_option_prompt = u'你要将这张卡牌移动到何处？'

    def effect_string_before(act):
        return u'|G【%s】|r发动了|G境界|r，跳过了出牌阶段，并移动了场上的卡牌。' % (
            act.target.ui_meta.char_name,
        )


class RealmSkipActionHandler:
    # choose_card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'跳过出牌阶段，并移动场上卡牌')
        else:
            return (False, u'请弃置一张手牌，跳过出牌阶段')

    # choose_players
    def target(tl):
        if not tl:
            return (False, u'[出牌]将第一名玩家的装备/判定牌移至第二名玩家的相应区域')

        rst = bool(tl[0].equips or tl[0].fatetell)
        if rst:
            return (len(tl) == 2, u'[出牌]将第一名玩家的装备/判定牌移至第二名玩家的相应区域')
        else:
            return (False, u'第一名玩家没有牌可以让你移动！')


class RealmSkipDropCard:
    def effect_string_before(act):
        return u'|G【%s】|r发动了|G境界|r，跳过了弃牌阶段。' % (
            act.target.ui_meta.char_name,
        )


class RealmSkipDropCardHandler:
    # choose_card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'弃置一张牌，跳过弃牌阶段')
        else:
            return (False, u'弃置一张手牌，跳过弃牌阶段')


class Yukari:
    # Character
    char_name = u'八云紫'
    port_image = gres.yukari_port
    figure_image = gres.yukari_figure
    description = (
        u'|DB永远17岁 八云紫 体力：4|r\n\n'
        u'|G境界|r：你可以弃置一张手牌跳过你的一个阶段（回合开始和回合结束阶段除外）\n'
        u'|B|R>>|r 若你跳过摸牌阶段，你可以获得任意1～2名角色的一张手牌；\n'
        u'|B|R>>|r 若你跳过出牌阶段，你可以将一名角色装备区或判定区的一张牌移动到另一名角色的装备区或判定区相同位置（不可替换原装备）或交给其他任意一名角色。\n\n'
        u'|DB（画师：渚FUN）|r'
    )

########NEW FILE########
__FILENAME__ = yuuka
# -*- coding: utf-8 -*-

from gamepack.thb import actions
from gamepack.thb import cards
from gamepack.thb import characters
from gamepack.thb.ui.ui_meta.common import gen_metafunc
from gamepack.thb.ui.ui_meta.common import passive_clickable, passive_is_action_valid
from gamepack.thb.ui.resource import resource as gres

__metaclass__ = gen_metafunc(characters.yuuka)


class FlowerQueen:
    # Skill
    name = u'花王'

    def clickable(game):
        me = game.me
        try:
            act = game.action_stack[-1]
            if isinstance(act, actions.ActionStage) and act.target is me:
                return True
            if isinstance(act, (cards.UseAttack, cards.BaseUseGraze, cards.DollControl)):
                return True
        except IndexError:
            pass
        return False

    def is_complete(g, cl):
        skill = cl[0]
        acards = skill.associated_cards
        if len(acards) != 1 or acards[0].suit != cards.Card.CLUB:
            return (False, u'请选择1张草花色牌！')
        return (True, u'反正这条也看不到，偷个懒~~~')

    def is_action_valid(g, cl, target_list, is_complete=is_complete):
        skill = cl[0]
        rst, reason = is_complete(g, cl)
        if not rst:
            return (rst, reason)
        else:
            return cards.AttackCard.ui_meta.is_action_valid(g, [skill], target_list)

    def effect_string(act):
        # for LaunchCard.ui_meta.effect_string
        return None  # FIXME


class MagicCannon:
    # Skill
    name = u'魔炮'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class MagicCannonAttack:
    def effect_string_apply(act):
        return (
            u'|G【%s】|r已经做好了迎接弹幕的准备，谁知冲过来的竟是一束|G魔炮|r！'
        ) % (
            act.target.ui_meta.char_name,
        )


class PerfectKill:
    # Skill
    name = u'完杀'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class PerfectKillAction:
    def effect_string(act):
        return (
            u'在场的人无不被|G【%s】|r的气场镇住，竟连上前递|G麻薯|r的勇气都没有了！'
        ) % (
            act.source.ui_meta.char_name,
        )


class Yuuka:
    # Character
    char_name = u'风见幽香'
    port_image = gres.yuuka_port
    description = (
        u'|DB四季的鲜花之主 风见幽香 体力：3|r\n\n'
        u'|G花王|r：你的所有的梅花牌都可以当做【弹幕】和【擦弹】使用或打出。\n\n'
        u'|G魔炮|r：锁定技，你在使用红色的【弹幕】时伤害+1\n\n'
        u'|G完杀|r：锁定技，由你击杀的玩家只能由你的和被击杀玩家的【麻薯】救起。'
    )

########NEW FILE########
__FILENAME__ = common
# -*- coding: utf-8 -*-

from game.autoenv import Game
G = Game.getgame

from types import FunctionType
from collections import OrderedDict

metadata = OrderedDict()


class UIMetaAccesser(object):
    def __init__(self, obj, cls):
        self.obj = obj
        self.cls = cls

    def __getattr__(self, name):
        cls = self.cls
        if hasattr(cls, '_is_mixedclass'):
            l = list(cls.__bases__)
        else:
            l = [cls]

        while l:
            c = l.pop(0)
            try:
                val = metadata[c][name]

                if isinstance(val, FunctionType) and getattr(val, '_is_property', False):
                    val = val(self.obj or self.cls)

                return val

            except KeyError:
                pass
            b = c.__base__
            if b is not object: l.append(b)
        raise AttributeError('%s.%s' % (self.cls.__name__, name))


class UIMetaDescriptor(object):
    def __get__(self, obj, cls):
        return UIMetaAccesser(obj, cls)


def gen_metafunc(_for):
    def metafunc(clsname, bases, _dict):
        meta_for = getattr(_for, clsname)
        meta_for.ui_meta = UIMetaDescriptor()
        if meta_for in metadata:
            raise Exception('%s ui_meta redefinition!' % meta_for)

        metadata[meta_for] = _dict

    return metafunc


def meta_property(f):
    f._is_property = True
    return f


# -----BEGIN COMMON FUNCTIONS-----


def my_turn():
    g = G()

    try:
        act = g.action_stack[-1]
    except IndexError:
        return False

    from gamepack.thb import actions
    if not isinstance(act, actions.ActionStage):
        return False

    if act.target is not g.me: return False

    if not act.in_user_input: return False

    return True


def limit1_skill_used(tag):
    t = G().me.tags
    return t[tag] >= t['turn_count']


def passive_clickable(game):
    return False


def passive_is_action_valid(g, cl, target_list):
    return (False, 'BUG!')


def card_desc(c):
    from gamepack.thb.cards import Card

    if c.suit == Card.SPADE:
        suit = u'|r♠'
    elif c.suit == Card.HEART:
        suit = u'|r|cb03a11ff♡'
    elif c.suit == Card.CLUB:
        suit = u'|r♣'
    elif c.suit == Card.DIAMOND:
        suit = u'|r|cb03a11ff♢'
    else:
        suit = u'|r错误'

    num = ' A23456789_JQK'[c.number]
    if num == '_': num = '10'
    return suit + num + ' |G%s|r' % c.ui_meta.name


def build_handcard(cardcls):
    from gamepack.thb.cards import CardList
    cl = CardList(G().me, 'cards')
    c = cardcls()
    c.move_to(cl)
    return c

########NEW FILE########
__FILENAME__ = modes
# -*- coding: utf-8 -*-

from gamepack.thb import thb3v3, thbidentity, thbraid, thbkof, thbfaith
from gamepack.thb.ui.resource import resource as gres

from .common import gen_metafunc, card_desc, my_turn
from .common import limit1_skill_used, passive_clickable, passive_is_action_valid

# -----BEGIN THB3v3 UI META-----
__metaclass__ = gen_metafunc(thb3v3)


class THBattle:
    name = u'符斗祭 - 3v3'
    logo = gres.thblogo_3v3
    description = (
        u'|R游戏人数|r：6人\n'
        u'\n'
        u'阵营分为|!B博丽|r和|!O守矢|r，每个阵营3名玩家，交错入座。\n'
        u'由ROLL点最高的人开始，按照顺时针1-2-2-1的方式选将。\n'
        u'选将完成由ROLL点最高的玩家开始行动。\n'
        u'ROLL点最高的玩家开局摸3张牌，其余玩家开局摸4张牌。\n'
        u'\n'
        u'|R胜利条件|r：击坠所有对方阵营玩家。'
    )

    from gamepack.thb.ui.view import THBattleUI as ui_class  # noqa

    T = thb3v3.Identity.TYPE
    identity_table = {
        T.HIDDEN: u'？',
        T.HAKUREI: u'博丽',
        T.MORIYA: u'守矢'
    }

    identity_color = {
        T.HIDDEN: u'blue',
        T.HAKUREI: u'blue',
        T.MORIYA: u'orange'
    }

    del T

# -----END THB3v3 UI META-----

# -----BEGIN THBKOF UI META-----
__metaclass__ = gen_metafunc(thbkof)


class THBattleKOF:
    name = u'符斗祭 - KOF模式'
    logo = gres.thblogo_kof
    description = (
        u'|R游戏人数|r：2人\n'
        u'\n'
        u'|R选将模式|r：选将按照1-2-2-2-2-1来选择。\n'
        u'\n'
        u'|R决定出场顺序|r：选好角色后，进行排序。拖动角色可以进行排序，左边3名为出场角色，越靠左的最先出场（注意：当把一个角色拖到另一个角色左边时，靠右的角色会被顶下去）\n'
        u'\n'
        u'|R游戏过程|r：选好角色后，将会翻开第一个角色进行对决，其他角色为隐藏，中途不能调换顺序。当有一方角色MISS后，需弃置所有的牌（手牌、装备牌、判定区的牌），然后翻开下一个角色，摸4张牌。\n'
        u'\n'
        u'|R胜利条件|r：当其中一方3名角色全部MISS，判对方胜出'
    )

    from gamepack.thb.ui.view import THBattleKOFUI
    ui_class = THBattleKOFUI

    T = thbkof.Identity.TYPE
    identity_table = {
        T.HIDDEN: u'？',
        T.HAKUREI: u'博丽',
        T.MORIYA: u'守矢'
    }

    identity_color = {
        T.HIDDEN: u'blue',
        T.HAKUREI: u'blue',
        T.MORIYA: u'orange'
    }

    del T

# -----END THB3v3 UI META-----


# -----BEGIN THBIdentity UI META-----
__metaclass__ = gen_metafunc(thbidentity)


class THBattleIdentity:
    name = u'符斗祭 - 标准8人身份场'
    logo = gres.thblogo_8id
    description = (
        u'|R游戏人数|r：8人\n'
        u'\n'
        u'|R身份分配|r：1|!RBOSS|r、2|!O道中|r、1|!G黑幕|r、4|!B城管|r\n'
        u'\n'
        u'|!RBOSS|r：|!RBOSS|r的体力上限+1。游戏开局时展示身份。胜利条件为击坠所有|!B城管|r以及|!G黑幕|r。\n'
        u'\n'
        u'|!O道中|r：胜利条件为击坠所有|!B城管|r以及|!G黑幕|r。\n'
        u'\n'
        u'|!B城管|r：胜利条件为击坠|!RBOSS|r。当|!B城管|rMISS时，击坠者摸3张牌。\n'
        u'\n'
        u'|!G黑幕|r：胜利条件为在除了|!RBOSS|r的其他人都MISS的状况下击坠|!RBOSS|r。\n'
        u'\n'
        u'玩家的身份会在MISS后公开。|!RBOSS|r的身份会在开局的时候公开。'
    )

    from gamepack.thb.ui.view import THBattleIdentityUI
    ui_class = THBattleIdentityUI

    T = thbidentity.Identity.TYPE
    identity_table = {
        T.HIDDEN: u'？',
        T.ATTACKER: u'城管',
        T.BOSS: u'BOSS',
        T.ACCOMPLICE: u'道中',
        T.CURTAIN: u'黑幕',
    }

    identity_color = {
        T.HIDDEN: u'blue',
        T.ATTACKER: u'blue',
        T.BOSS: u'red',
        T.ACCOMPLICE: u'orange',
        T.CURTAIN: u'green',
    }

    del T


class THBattleIdentity5:
    name = u'符斗祭 - 标准5人身份场'
    logo = gres.thblogo_5id
    description = (
        u'|R游戏人数|r：5人\n'
        u'\n'
        u'|R身份分配|r：1|!RBOSS|r、1|!O道中|r、1|!G黑幕|r、2|!B城管|r\n'
        u'\n'
        u'|!RBOSS|r：游戏开局时展示身份。胜利条件为击坠所有|!B城管|r以及|!G黑幕|r。\n'
        u'\n'
        u'|!O道中|r：胜利条件为击坠所有|!B城管|r以及|!G黑幕|r。\n'
        u'\n'
        u'|!B城管|r：胜利条件为击坠|!RBOSS|r。当|!B城管|rMISS时，击坠者摸3张牌。\n'
        u'\n'
        u'|!G黑幕|r：胜利条件为在除了|!RBOSS|r的其他人都MISS的状况下击坠|!RBOSS|r。\n'
        u'\n'
        u'玩家的身份会在MISS后公开。|!RBOSS|r的身份会在开局的时候公开。'
    )

    from gamepack.thb.ui.view import THBattleIdentity5UI
    ui_class = THBattleIdentity5UI

    T = thbidentity.Identity.TYPE
    identity_table = {
        T.HIDDEN: u'？',
        T.ATTACKER: u'城管',
        T.BOSS: u'BOSS',
        T.ACCOMPLICE: u'道中',
        T.CURTAIN: u'黑幕',
    }

    identity_color = {
        T.HIDDEN: u'blue',
        T.ATTACKER: u'blue',
        T.BOSS: u'red',
        T.ACCOMPLICE: u'orange',
        T.CURTAIN: u'green',
    }

    del T

# -----END THBIdentity UI META-----


# -----BEGIN THBRaid UI META-----
__metaclass__ = gen_metafunc(thbraid)


class THBattleRaid:
    name = u'符斗祭 - 异变模式'
    logo = gres.thblogo_raid

    from gamepack.thb.ui.view import THBattleRaidUI
    ui_class = THBattleRaidUI

    T = thbraid.Identity.TYPE
    identity_table = {
        T.HIDDEN: u'？',
        T.MUTANT: u'异变',
        T.ATTACKER: u'解决者',
    }

    identity_color = {
        T.HIDDEN: u'blue',
        T.MUTANT: u'red',
        T.ATTACKER: u'blue',
    }

    del T

    description = (
        u"|R势力|r： 异变（1人） vs 解决者（3人）\n"
        u"\n"
        u"|R信仰|r：所有人都有额外的“信仰”，信仰使用卡牌做标记，需向他人展示。信仰可以在自己的出牌阶段前与手牌做交换。交换后进入明牌区。每对其他玩家造成一点伤害时，获得一点。信仰上限为5点。异变在每轮开始时获得一点信仰，解决者不获得。\n"
        u"\n"
        u"|R距离|r：所有人之间的默认距离为1\n"
        u"\n"
        u"|R出牌顺序|r：\n"
        u"(异变->解决者1->异变->解决者2->异变->解决者3)->……\n"
        u"异变变身后, 立即终止卡牌结算，从异变开始：\n"
        u"(异变->解决者1->解决者2->解决者3)->……\n"
        u"解决者们可以任意决定行动顺序，但是每轮一个解决者仅能行动一次。\n"
        u"当所有在场的玩家结束了各自回合之后，算作一轮。\n"
        u"\n"
        u"|R异变变身|r：当1阶段的异变体力值变化成小于等于默认体力上限的一半时，变身成2阶段，获得2阶段技能，体力上限减少默认体力上限的一半，弃置判定区的所有牌。异变变身时，所有解决者各获得1点信仰。\n"
        u"\n"
        u"|R卡牌|r：牌堆中没有【罪袋】和【八卦炉】\n"
        u"\n"
        u"|R摸牌|r：游戏开始时，3个解决者每人摸4张牌，异变摸6张。当任意解决者阵亡时，弃置所有信仰，其他存活的解决者可以选择立即在牌堆里摸1张牌。\n"
        u"\n"
        u"|R解决者额外技能|r：\n"
        u"|G合作|r：在你的出牌阶段，你可以将至多两张手牌交给其他的一名解决者。收到牌的解决者需交还相同数量的手牌，交换后进入明牌区。一回合一次。\n"
        u"|G保护|r：当其他解决者受到伤害时，如果该解决者的体力是全场最低之一，你可以使用1点信仰防止此伤害。若如此做，你承受相同数量的体力流失，并且异变获得一点信仰。\n"
        u"|G招架|r：若你受到了2点及以上/致命的伤害时，你可以使用2点信仰使伤害-1。在 保护 之前结算。\n"
        u"|G1UP|r：|B限定技|r，你可以使用3点信仰使已经阵亡的解决者重新上场。重新上场的解决者回复3点体力，算作当前回合没有行动。"
    )


class DeathHandler:
    # choose_option
    choose_option_buttons = ((u'摸一张', True), (u'不摸牌', False))
    choose_option_prompt = u'你要摸一张牌吗？'


class CollectFaith:
    def effect_string(act):
        if not act.succeeded: return None
        if not len(act.cards): return None
        s = u'、'.join(card_desc(c) for c in act.cards)
        return u'|G【%s】|r收集了%d点信仰：%s' % (
            act.target.ui_meta.char_name, len(act.cards), s,
        )


class CooperationAction:
    # choose_card meta
    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'OK，就这些了')
        else:
            return (False, u'请选择%d张手牌交还…' % act.ncards)


class Cooperation:
    # Skill
    name = u'合作'

    def clickable(g):
        if not my_turn(): return False
        if limit1_skill_used('cooperation_tag'): return False
        return True

    def is_action_valid(g, cl, target_list):
        acards = cl[0].associated_cards
        if not acards:
            return (False, u'请选择希望交换的手牌')

        if len(acards) > 2:
            return (False, u'最多选择两张')

        if any(c.resides_in.type not in ('cards', 'showncards') for c in acards):
            return (False, u'只能选择手牌！')

        if len(target_list) != 1:
            return (False, u'请选择一名解决者')

        return (True, u'合作愉快~')

    def effect_string(act):
        return u'|G【%s】|r与|G【%s】|r相互合作，交换了手牌。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class Protection:
    # Skill
    name = u'保护'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class ProtectionAction:
    def effect_string(act):
        return u'|G【%s】|r帮|G【%s】|r承受了伤害。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class ProtectionHandler:
    # choose_option
    choose_option_buttons = ((u'保护', True), (u'不保护', False))

    def choose_option_prompt(act):
        return u'你要使用1点信仰承受此次的%d点伤害吗？' % act.dmgact.amount


class Parry:
    # Skill
    name = u'招架'
    clickable = passive_clickable
    is_action_valid = passive_is_action_valid


class ParryAction:
    def effect_string(act):
        return u'|G【%s】|r使用了|G招架|r，减免了1点伤害。' % (
            act.target.ui_meta.char_name,
        )


class ParryHandler:
    # choose_option
    choose_option_buttons = ((u'招架', True), (u'不招架', False))
    choose_option_prompt = u'你要使用2点信仰减免1点伤害吗？'


class OneUp:
    # Skill
    name = '1UP'

    def clickable(g):
        if not my_turn(): return False
        return len(g.me.faiths) >= 3

    def is_action_valid(g, cl, target_list):
        acards = cl[0].associated_cards
        if len(acards):
            return (False, u'请不要选择牌！')

        if not (len(target_list) == 1 and target_list[0].dead):
            return (False, u'请选择一名已经离场的玩家')

        return (True, u'神说，你不能在这里死去')

    def effect_string(act):
        return u'|G【%s】|r用3点信仰换了一枚1UP，贴到了|G【%s】|r的身上。' % (
            act.source.ui_meta.char_name,
            act.target.ui_meta.char_name,
        )


class OneUpAction:
    update_portrait = True


class FaithExchange:
    def effect_string_before(act):
        return u'|G【%s】|r正在交换信仰牌……' % (
            act.target.ui_meta.char_name,
        )

    def choose_card_text(g, act, cards):
        if act.cond(cards):
            return (True, u'OK，就这些了')
        else:
            return (False, u'请选择%d张手牌作为信仰…' % act.amount)


class RequestAction:
    # choose_option
    choose_option_buttons = ((u'行动', True), (u'等一下', None))
    choose_option_prompt = u'你要行动吗？'


class GetFaith:
    # choose_option
    choose_option_buttons = ((u'我要信仰', True), (u'给其他人', None))
    choose_option_prompt = u'你要获得一点信仰吗（只有一人可以获得）？'

# -----END THBRaid UI META-----

# -----BEGIN THBFaith UI META-----
__metaclass__ = gen_metafunc(thbfaith)


class THBattleFaith:
    name = u'符斗祭 - 信仰争夺战'
    logo = gres.thblogo_faith
    description = (
        u'|R游戏人数|r：6人\n'
        u'\n'
        u'|G游戏开始|r：游戏开始时，随机向在场玩家分配6张身份牌：3|!B博丽|r，3|!O守矢|r，双方对立。若出现同一方阵营座次连续三人的情况，则第三人须与下一名座次的玩家交换身份牌。\n'
        u'\n'
        u'|G选将阶段|r：共发给每人4张角色牌，其中一张为暗置。每名玩家选择其中一张作为出场角色，再选择一张作为备用角色（不得查看暗置角色牌）。将三张备用角色牌置于一旁作为备用角色。\n'
        u'\n'
        u'|G游戏开始|r：游戏开始时，所有角色摸4张牌，此时除首先行动的玩家均可以进行一次弃置4张牌并重新摸4张牌的操作。\n'
        u'\n'
        u'|G玩家死亡|r：当一名玩家死亡时，改玩家需弃置其所有的牌，然后弃置该玩家全部区域内的牌。从剩余的备用角色中选择一名作为出场角色并明示之，之后摸4张牌。此时该角色可以弃置全部的4张牌并重新摸4张牌。玩家死亡不执行任何奖惩。\n'
        u'\n'
        u'|G胜负条件|r：当一方死亡角色数到达三名，或投降时，该方判负。'
    )

    from gamepack.thb.ui.view import THBattleFaithUI as ui_class  # noqa

    T = thbfaith.Identity.TYPE
    identity_table = {
        T.HIDDEN: u'？',
        T.HAKUREI: u'博丽',
        T.MORIYA: u'守矢'
    }

    identity_color = {
        T.HIDDEN: u'blue',
        T.HAKUREI: u'blue',
        T.MORIYA: u'orange'
    }

    del T


class DeathHandler:  # noqa
    # choose_option
    choose_option_buttons = ((u'全部换走', True), (u'不用换', False))
    choose_option_prompt = u'你要将摸到的牌全部换掉吗？'

# -----END THB3v3 UI META-----

########NEW FILE########
__FILENAME__ = tags
# -*- coding: utf-8 -*-

from gamepack.thb.ui.resource import resource as gres
from gamepack.thb import cards

from .common import G
from utils import DataHolder

# -----BEGIN TAGS UI META-----
tags = {}


def tag_metafunc(clsname, bases, _dict):
    data = DataHolder.parse(_dict)
    tags[clsname] = data

__metaclass__ = tag_metafunc


class attack_num:
    tag_anim = lambda p: gres.tag_attacked

    def display(p, v):
        if cards.AttackCardHandler.is_freeattack(p):
            return False

        return v <= 0 and G().current_turn is p

    description = u'该玩家在此回合不能再使用【弹幕】了'


class wine:
    tag_anim = lambda p: gres.tag_wine
    display = lambda p, v: v
    description = u'喝醉了…'


class flan_cs:
    tag_anim = lambda p: gres.tag_flandrecs
    display = lambda p, v: v >= p.tags['turn_count'] and G().current_turn is p
    description = u'玩坏你哦！'


class lunaclock:
    tag_anim = lambda p: gres.tag_lunaclock
    display = lambda p, v: v and G().current_turn is p
    description = u'咲夜的时间！'


class faithcounter:
    def tag_anim(p):
        n = min(len(p.faiths), 6)
        return gres.tag_faiths[n]

    display = lambda p, v: v
    description = u'信仰数'


class action:
    tag_anim = lambda p: gres.tag_action
    display = lambda p, v: v
    description = u'可以行动'


class riverside_target:
    tag_anim = lambda p: gres.tag_riverside
    display = lambda p, v: v == G().turn_count
    description = u'被指定为彼岸的目标'


class ran_ei:
    tag_anim = lambda p: gres.tag_ran_ei
    display = lambda p, v: v < p.tags['turn_count'] + 1
    description = u'还可以发动【极智】'

# -----END TAGS UI META-----

########NEW FILE########
__FILENAME__ = view
# -*- coding: utf-8 -*-

# -- stdlib --
import logging
import random

# -- third party --
from gevent.event import Event
from pyglet.gl import glColor3f, glRectf
import gevent
import pyglet

# -- own --
from client.ui.base import Control, Overlay, process_msg
from client.ui.controls import Colors, Panel, TextArea, Button, BalloonPromptMixin, OptionButton
from client.ui.resource import resource as cres
from client.ui.soundmgr import SoundManager
from game.autoenv import Game, EventHandler
from .game_controls import HandCardArea, PortraitCardArea, DropCardArea
from .game_controls import Ray, GameCharacterPortrait, SkillSelectionBox
from gamepack.thb.ui.resource import resource as gres
from .. import actions
from . import effects
from . import inputs
from utils import rect_to_dict as r2d
from utils.misc import Observable

# -- code --
log = logging.getLogger('THBattleUI')


class UIEventHook(EventHandler):
    @classmethod
    def evt_user_input(cls, arg):
        trans, ilet = arg
        evt = Event()
        ilet.event = evt
        process_msg(('evt_user_input', arg))
        evt.wait()
        return ilet

    @classmethod
    def handle(cls, evt, data):
        name = 'evt_%s' % evt
        try:
            f = getattr(cls, name)
        except AttributeError:
            process_msg((name, data))
            random.random() < 0.005 and gevent.sleep(0)
            return data

        rst = f(data)
        return rst


class DeckIndicator(Control):
    def draw(self):
        w, h = self.width, self.height
        g = Game.getgame()
        try:
            n = len(g.deck.cards)
        except AttributeError:
            return

        glColor3f(*[i/255.0 for i in Colors.blue.light])
        glRectf(0, 0, w, h)
        glColor3f(*[i/255.0 for i in Colors.blue.heavy])
        glRectf(0, h, w, 0)

        glColor3f(1, 1, 1)
        try:
            nums = gres.num
            seq = str(n)
            ox = (w - len(seq)*14) // 2
            oy = (h - nums[0].height) // 2
            with nums[0].owner:
                for i, ch in enumerate(seq):
                    n = ord(ch) - ord('0')
                    # x, y = w - 34 + ox + i*14, 68
                    nums[n].blit_nobind(ox + i*14, oy)

        except AttributeError:
            pass


class ResultPanel(Panel):
    fill_color = (1.0, 1.0, 0.9, 0.5)

    def __init__(self, g, *a, **k):
        Panel.__init__(self, width=550, height=340, zindex=10000, *a, **k)
        parent = self.parent
        self.x = (parent.width - 550) // 2
        self.y = (parent.height - 340) // 2
        self.textarea = ta = TextArea(
            parent=self, x=30, y=30, width=550-30, height=340-60,
            font_size=12,
        )
        ta.text = u''
        winners = g.winners
        for p in g.players:
            s = u'|G%s|r(|R%s|r, |c0000ffff%s|r, %s)\n' % (
                p.ui_meta.char_name, p.account.username.replace('|', '||'),
                g.ui_meta.identity_table[p.identity.type],
                u'|R胜利|r' if p in winners else u'失败'
            )
            ta.append(s)

        if g.me in winners:
            self.pic = gres.win
        else:
            self.pic = gres.lose

        close = Button(
            u'关闭', parent=self, x=440, y=25, width=90, height=40
        )

        @close.event
        def on_click():
            self.delete()

    def draw(self):
        Panel.draw(self)
        pic = self.pic
        glColor3f(1, 1, 1)
        self.pic.blit(self.width - pic.width - 10, self.height - pic.height - 10)


class GameIntroIcon(Control, BalloonPromptMixin):
    def __init__(self, game, *a, **k):
        Control.__init__(self, *a, **k)
        intro = getattr(game.ui_meta, 'description', None)
        intro and self.init_balloon(intro, width=480)

    def draw(self):
        glColor3f(1, 1, 1)
        gres.tag_gameintro.blit(0, 0)


class THBattleUI(Control, Observable):
    portrait_location = [
        (60, 300, Colors.blue),
        (250, 450, Colors.orange),
        (450, 450, Colors.blue),
        (640, 300, Colors.orange),
        (450, 150, Colors.blue),
        (250, 150, Colors.orange),
    ]

    gcp_location = [
        (3, 1, 'me', Colors.blue),
        (669, 280, 'left', Colors.orange),
        (155 + 180 + 180, 520, 'bottom', Colors.blue),
        (155 + 180, 520, 'bottom', Colors.orange),
        (155, 520, 'bottom', Colors.blue),
        (3, 280, 'right', Colors.orange),
    ]

    def __init__(self, game, *a, **k):
        self.game = game
        game.event_observer = UIEventHook

        Control.__init__(self, can_focus=True, *a, **k)

        self.keystrokes = '\x00'
        self.char_portraits = None

        self.deck_indicator = DeckIndicator(
            parent=self, x=30, y=680, width=50, height=25,
        )

        self.handcard_area = HandCardArea(
            parent=self, view=self, x=238, y=9, zindex=3,
            width=93*5+42, height=145,
        )

        self.deck_area = PortraitCardArea(
            parent=self, width=1, height=1,
            x=self.width//2, y=self.height//2, zindex=4,
        )

        self.btn_afk = OptionButton(
            parent=self, zindex=1, conf=(
                (u'让⑨帮你玩', Colors.blue, False),
                (u'⑨在帮你玩', Colors.orange, True),
            ), **r2d((730, 620, 75, 25))
        )

        self.gameintro_icon = GameIntroIcon(
            parent=self, game=game,
            **r2d((690, 630, 25, 25))
        )

        self.dropcard_area = DropCardArea(
            parent=self, x=0, y=324, zindex=3,
            width=820, height=125,
        )

        class Animations(pyglet.graphics.Batch, Control):
            def __init__(self, **k):
                pyglet.graphics.Batch.__init__(self)
                Control.__init__(
                    self, x=0, y=0,
                    width=0, height=0, zindex=2,
                    **k
                )

            def hit_test(self, x, y):
                return False

        self.animations = Animations(parent=self)
        self.selecting_player = 0
        self.action_params = {}

    @property
    def afk(self):
        return self.btn_afk.value

    def init(self):
        ports = self.char_portraits = [
            GameCharacterPortrait(parent=self, color=color,
                x=x, y=y, tag_placement=tp)
            for x, y, tp, color in self.gcp_location[:len(self.game.players)]
        ]

        pl = self.game.players
        shift = pl.index(self.game.me)
        for i, c in enumerate(ports):
            p = pl[(shift + i) % self.game.n_persons]
            c.player = p
            c.update()

        ports[0].equipcard_area.selectable = True  # it's TheChosenOne

        self.begin_select_player()
        self.end_select_player()
        self.skill_box = SkillSelectionBox(
            parent=self, x=161, y=9, width=70, height=22*6-4
        )

        SoundManager.switch_bgm(gres.bgm_game)

        self.more_init()

    def more_init(self):
        pass

    def player2portrait(self, p):
        from gamepack.thb.characters.baseclasses import Character
        if isinstance(p, Character):
            p = p.player

        for port in self.char_portraits:
            if port.player == p:
                break
        else:
            raise ValueError(p)
        return port

    def refresh_input_state(self):
        self.action_params = {}

        g = self.game
        skills = getattr(g.me, 'skills', None)
        if skills is not None:
            skills = [
                (s, i, s.ui_meta.clickable(g))
                for i, s in enumerate(skills)
                if not getattr(s.ui_meta, 'no_display', False)
            ]

            skills.sort(key=lambda i: -i[2])

            self.skill_box.set_skills(skills)

    PORT_UPDATE_MESSAGES = {
        'evt_game_begin',
        'evt_switch_character',
    }

    def update_portraits(self):
        for port in self.char_portraits:
            port.update()

    def on_message(self, _type, *args):
        if _type == 'evt_action_before' and isinstance(args[0], actions.PlayerTurn):
            self.current_turn = args[0].target

        elif _type == 'player_change':
            for i, pd in enumerate(args[0]):
                p = self.game.players[i]
                port = self.player2portrait(p)
                port.dropped = (pd['state'] in ('dropped', 'fleed'))
                port.fleed = (pd['state'] == 'fleed')
                port.update()

        elif _type in self.PORT_UPDATE_MESSAGES:
            self.update_portraits()

        elif _type == 'evt_action_after':
            act = args[0]
            meta = getattr(act, 'ui_meta', None)
            if meta and getattr(meta, 'update_portrait', None):
                pl = set()
                if act.source:
                    pl.add(act.source)

                if hasattr(act, 'target_list'):
                    pl.update(act.target_list)
                elif act.target:
                    pl.add(act.target)

                for p in pl:
                    self.player2portrait(p).update()

        self.more_on_message(_type, args)

        if _type.startswith('evt_'):
            effects.handle_event(self, _type[4:], args[0])
            inputs.handle_event(self, _type[4:], args[0])

    def more_on_message(self, _type, args):
        pass

    def on_text(self, text):
        # The easter egg
        ks = self.keystrokes
        ks = (ks + text)[:40]
        self.keystrokes = ks

        from gamepack.thb.characters.baseclasses import Character

        for c in Character.character_classes.itervalues():
            try:
                alter = c.ui_meta.figure_image_alter
            except:
                continue

            for i in xrange(len(ks)):
                if alter.decrypt(ks[-i:]):
                    SoundManager.play(cres.sound.input)

    def draw(self):
        self.draw_subcontrols()

    def ray(self, f, t):
        if f == t: return
        sp = self.player2portrait(f)
        dp = self.player2portrait(t)
        x0, y0 = sp.x + sp.width/2, sp.y + sp.height/2
        x1, y1 = dp.x + dp.width/2, dp.y + dp.height/2
        Ray(x0, y0, x1, y1, parent=self, zindex=10)

    def prompt(self, s):
        self.prompt_raw(u'|B|cff0000ff>> |r' + unicode(s) + u'\n')

    def prompt_raw(self, s):
        self.parent.events_box.append(s)

    def begin_select_player(self, disables=[]):
        #if self.selecting_player: return
        self.selecting_player = True
        #self.selected_players = []
        for p in self.game.players:
            port = self.player2portrait(p)

            if p in disables:
                port.disabled = True
                port.selected = False
                try:
                    self.selected_players.remove(p)
                except ValueError:
                    pass
            else:
                port.disabled = False

    def get_selected_players(self):
        return self.selected_players

    def set_selected_players(self, players):
        for p in self.char_portraits:
            p.selected = False

        for p in players:
            self.player2portrait(p).selected = True

        self.selected_players = players[:]

    def end_select_player(self):
        #if not self.selecting_player: return
        self.selecting_player = False
        self.selected_players = []
        for p in self.char_portraits:
            p.selected = False
            p.disabled = False

    def get_selected_cards(self):
        return [
            cs.associated_card
            for cs in self.handcard_area.cards
            if cs.hca_selected
        ] + [
            cs.associated_card
            for cs in self.player2portrait(self.game.me).equipcard_area.cards
            if cs.selected
        ]

    def get_selected_skills(self):
        skills = self.game.me.skills
        return sorted([
            skills[i] for i in self.skill_box.get_selected_index()
        ], key=lambda s: s.sort_index)

    def get_action_params(self):
        return self.action_params

    def on_mouse_click(self, x, y, button, modifier):
        c = self.control_frompoint1_recursive(x, y)
        if isinstance(c, GameCharacterPortrait) and self.selecting_player and not c.disabled:
            char = c.character
            if not char: return True
            sel = c.selected
            psel = self.selected_players
            if sel:
                c.selected = False
                psel.remove(char)
            else:
                c.selected = True
                psel.append(char)
            self.notify('selection_change')
        return True

    def get_game_screen(self):
        assert self.parent
        return self.parent

    @staticmethod
    def show_result(g):
        ResultPanel(g, parent=Overlay.cur_overlay)


class THBattleIdentityUI(THBattleUI):
    portrait_location = [
        (150, 430, Colors.blue),
        (290, 430, Colors.blue),
        (430, 430, Colors.blue),
        (570, 430, Colors.blue),

        (150, 170, Colors.blue),
        (290, 170, Colors.blue),
        (430, 170, Colors.blue),
        (570, 170, Colors.blue),
    ]

    gcp_location = [
        (3, 1, 'me', Colors.blue),
        (669, 210, 'left', Colors.blue),
        (669, 420, 'left', Colors.blue),
        (505, 520, 'bottom', Colors.blue),
        (335, 520, 'bottom', Colors.blue),
        (165, 520, 'bottom', Colors.blue),
        (3, 420, 'right', Colors.blue),
        (3, 210, 'right', Colors.blue),
    ]


class THBattleIdentity5UI(THBattleIdentityUI):
    portrait_location = [
        (290, 450, Colors.blue),
        (490, 450, Colors.blue),

        (190, 150, Colors.blue),
        (380, 150, Colors.blue),
        (570, 150, Colors.blue),
    ]

    gcp_location = [
        (3, 1, 'me', Colors.blue),
        (669, 270, 'left', Colors.blue),
        (455, 520, 'bottom', Colors.blue),
        (215, 520, 'bottom', Colors.blue),
        (3, 270, 'right', Colors.blue),
    ]


class THBattleKOFUI(THBattleUI):
    portrait_location = [
        (250, 300, Colors.orange),
        (450, 300, Colors.blue),
    ]

    gcp_location = [
        (3, 1, 'me', Colors.blue),
        (335, 520, 'bottom', Colors.orange),
    ]


class THBattleRaidUI(THBattleUI):
    portrait_location = [
        (380, 450, Colors.red),

        (190, 150, Colors.blue),
        (380, 150, Colors.blue),
        (570, 150, Colors.blue),
    ]

    gcp_location = [
        (3, 1, 'me', Colors.blue),
        (669, 315, 'left', Colors.blue),
        (335, 520, 'bottom', Colors.blue),
        (3, 315, 'right', Colors.blue),
    ]


class THBattleFaithUI(THBattleUI):
    portrait_location = [
        (60, 300, Colors.blue),
        (250, 450, Colors.blue),
        (450, 450, Colors.blue),
        (640, 300, Colors.blue),
        (450, 150, Colors.blue),
        (250, 150, Colors.blue),
    ]

    gcp_location = [
        (3, 1, 'me', Colors.blue),
        (669, 280, 'left', Colors.blue),
        (155+180+180, 520, 'bottom', Colors.blue),
        (155+180, 520, 'bottom', Colors.blue),
        (155, 520, 'bottom', Colors.blue),
        (3, 280, 'right', Colors.blue),
    ]

    def more_init(self):
        self.remaining_indicator = TextArea(
            parent=self, x=25, y=620, width=100, height=50, font_size=12,
        )

    def more_on_message(self, _type, args):
        if _type in ('evt_switch_character', 'evt_action_stage_action'):
            try:
                hakurei, moriya = self.game.forces
            except:
                return

            h, m = len(hakurei.pool) - 1, len(moriya.pool) - 1
            if h < 0 or m < 0:
                return

            self.remaining_indicator.text = (
                u'|s1e5effbff|c315597ff博丽：%d 人|r\n'
                u'|s1886666ff|W守矢：%d 人|r'
            ) % (h, m)

########NEW FILE########
__FILENAME__ = client
# -*- coding: utf-8 -*-
from gevent import Greenlet
from gevent.queue import Queue
from network import Endpoint
import logging

log = logging.getLogger("Server")

from .common import GamedataMixin


class Server(Endpoint, GamedataMixin, Greenlet):
    '''
    Used at client side, to represent server
    '''

    def __init__(self, sock, addr):
        Endpoint.__init__(self, sock, addr)
        Greenlet.__init__(self)
        self.ctlcmds = Queue(0)
        self.userid = 0
        self.init_gamedata_mixin()

    def _run(self):
        while True:
            cmd, data = self.read()
            if cmd == 'gamedata':
                self.gamedata(data)
            else:
                self.ctlcmds.put([cmd, data])

    def gwrite(self, tag, data):
        log.debug('GAME_WRITE: %s', repr([tag, data]))
        encoded = self.encode(['gamedata', [tag, data]])
        self.raw_write(encoded)

########NEW FILE########
__FILENAME__ = common
# -*- coding: utf-8 -*-

# -- stdlib --
from collections import deque
import logging
log = logging.getLogger('network')

# -- third party --
from gevent import getcurrent
from gevent.event import Event

# -- own --
from utils import Packet, instantiate
from .endpoint import EndpointDied

# -- code --


class GamedataMixin(object):
    @instantiate
    class NODATA(object):
        def __repr__(self):
            return 'NODATA'

    def init_gamedata_mixin(self):
        self.gdqueue = deque(maxlen=100000)
        self.gdevent = Event()
        self._in_gexpect = False

    def gamedata(self, data):
        p = Packet(data)
        self.gdqueue.append(p)
        self.gdevent.set()

    def gexpect(self, tag, blocking=True):
        try:
            assert not self._in_gexpect, 'NOT REENTRANT'
            self._in_gexpect = True
            blocking and log.debug('GAME_EXPECT: %s', repr(tag))
            l = self.gdqueue
            e = self.gdevent
            e.clear()

            glob = False
            if tag.endswith('*'):
                tag = tag[:-1]
                glob = True

            while True:
                for i, packet in enumerate(l):
                    if isinstance(packet, EndpointDied):
                        raise packet

                    if packet[0] == tag or (glob and packet[0].startswith(tag)):
                        log.debug('GAME_READ: %s', repr(packet))
                        del l[i]
                        return packet

                    else:
                        log.debug('GAME_DATA_MISS: %s', repr(packet))
                        log.debug('EXPECTS: %s, GAME: %s', tag, getcurrent())

                if blocking:
                    e.wait(timeout=5)
                    e.clear()
                else:
                    e.clear()
                    return None, self.NODATA
        finally:
            self._in_gexpect = False

    def gclear(self):
        '''
        Clear the gamedata queue,
        used when a game starts, to eliminate data from last game,
        which confuses the new game.
        '''
        self.gdqueue.clear()

    def gbreak(self):
        # is it a hack?
        # XXX: definitly, and why it's here?! can't remember
        # Explanation:
        # Well, when sb. exit game in input state,
        # the others must wait until his timeout exceeded.
        # called by gamehall.exit_game to break such condition.
        self.gdqueue.append(EndpointDied())
        self.gdevent.set()

########NEW FILE########
__FILENAME__ = endpoint
from gevent import socket, coros
import simplejson as json
import logging

log = logging.getLogger("Endpoint")

class EndpointDied(Exception):
    pass

class Endpoint(object):

    ENDPOINT_DEBUG = False

    def __init__(self, sock, address):
        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        self.sock = sock
        self.sockfile = sock.makefile()
        self.writelock = coros.RLock()
        self.address = address
        self.link_state = 'connected' # or disconnected

    def __repr__(self):
        return '%s:%s:%s' % (
            self.__class__.__name__,
            self.address[0],
            self.address[1],
        )

    @staticmethod
    def encode(p):
        def default(o):
            return o.__data__() if hasattr(o, '__data__') else repr(o)
        return json.dumps(p, default=default) + "\n"

    def raw_write(self, s):
        if self.link_state == 'connected':
            if Endpoint.ENDPOINT_DEBUG:
                log.debug("SEND>> %s" % s[:-1])
            try:
                with self.writelock:
                    self.sock.sendall(s)
            except IOError:
                self.close()
        else:
            log.debug('Write after disconnected: %s' % s[:-1])
            return False

    def write(self, p):
        '''
        Send json encoded packet
        '''
        self.raw_write(self.encode(p))

    def close(self):
        if not self.link_state == 'disconnected':
            self.link_state = 'disconnected'
            self.sockfile.close()
            self.sock.close()

    def read(self):
        if self.link_state != 'connected':
            raise EndpointDied()

        f = self.sockfile
        while True:
            try:
                s = f.readline(1048576)
                if s == '':
                    self.close()
                    raise EndpointDied()

                if Endpoint.ENDPOINT_DEBUG:
                    log.debug("<<RECV %s" % s[:-1])

                d = json.loads(s)
                return d

            except json.JSONDecodeError:
                self.write(['bad_format', None])
                continue

            except IOError:
                self.close()
                raise EndpointDied()

########NEW FILE########
__FILENAME__ = server
# -*- coding: utf-8 -*-

# -- stdlib --
import logging
log = logging.getLogger("Client")

# -- third party --
from gevent import Greenlet, Timeout
import simplejson as json

# -- own --
from .common import GamedataMixin
from network import Endpoint, EndpointDied
from utils import BatchList, log_failure

# -- code --


__all__ = ['Client']


class Client(Endpoint, GamedataMixin, Greenlet):
    def __init__(self, sock, addr):
        Endpoint.__init__(self, sock, addr)
        Greenlet.__init__(self)
        self.observers = BatchList()
        self.init_gamedata_mixin()
        self.gdhistory = []
        self.usergdhistory = []

    @log_failure(log)
    def _run(self):
        self.account = None

        # ----- Banner -----
        from settings import VERSION
        self.write(['thbattle_greeting', VERSION])
        # ------------------

        self.state = 'connected'
        while True:
            try:
                hasdata = False
                with Timeout(90, False):
                    cmd, data = self.read()
                    hasdata = True

                if not hasdata:
                    self.close()
                    # client should send heartbeat periodically
                    raise EndpointDied

                if cmd == 'gamedata':
                    self.gamedata(data)
                else:
                    self.handle_command(cmd, data)

            except EndpointDied:
                self.gbreak()
                break

        # client died, do clean ups
        self.handle_drop()

    def gexpect(self, tag, blocking=True):
        tag, data = GamedataMixin.gexpect(self, tag, blocking)
        tag and self.usergdhistory.append((self.player_index, tag, data))
        return tag, data

    def gwrite(self, tag, data):
        log.debug('GAME_WRITE: %s', repr([tag, data]))
        encoded = self.encode(['gamedata', [tag, data]])
        self.raw_write(encoded)
        self.gdhistory.append([tag, json.loads(self.encode(data))])
        self.observers and self.observers.raw_write(encoded)

    def replay(self, ob):
        for data in self.gdhistory:
            ob.raw_write(json.dumps(['gamedata', data]) + '\n')

    def __data__(self):
        return [self.account.userid, self.account.username, self.state]

    def close(self):
        Endpoint.close(self)
        self.kill(EndpointDied)

    def __repr__(self):
        acc = self.account
        if not acc:
            return Endpoint.__repr__(self)

        return '%s:%s:%s' % (
            self.__class__.__name__,
            self.address[0],
            acc.username.encode('utf-8'),
        )


class DroppedClient(Endpoint):
    read = write = raw_write = gclear = lambda *a, **k: None

    def __init__(self, client=None):
        client and self.__dict__.update(client.__dict__)

    def gwrite(self, tag, data):
        self.gdhistory.append([tag, json.loads(self.encode(data))])

    def gexpect(self, tag, blocking=True):
        raise EndpointDied

    @property
    def state(self):
        return 'dropped'

    @state.setter
    def state(self, val):
        pass

########NEW FILE########
__FILENAME__ = options
# -*- coding: utf-8 -*-

# dummy, place for options
class options(object):
    def __getattr__(self, name):
        return None

options = options()

########NEW FILE########
__FILENAME__ = carbon
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import ctypes

from pyglet.app import windows, BaseEventLoop
from pyglet.window.carbon import carbon, types, constants, _oscheck

EventLoopTimerProc = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_void_p)
kEventDurationForever = ctypes.c_double(constants.kEventDurationForever)

class CarbonEventLoop(BaseEventLoop):
    def run(self):
        self._setup()

        e = ctypes.c_void_p()
        event_dispatcher = carbon.GetEventDispatcherTarget()
        self._event_loop = event_loop = carbon.GetMainEventLoop()
        event_queue = carbon.GetMainEventQueue()
        self._timer = timer = ctypes.c_void_p()
        idle_event_proc = EventLoopTimerProc(self._timer_proc)
        carbon.InstallEventLoopTimer(event_loop,
                                     ctypes.c_double(0.1), #?
                                     kEventDurationForever,
                                     idle_event_proc,
                                     None,
                                     ctypes.byref(timer))

        self._force_idle = False
        self._allow_polling = True

        self.dispatch_event('on_enter')

        while not self.has_exit:
            if self._force_idle:
                duration = 0
            else:
                duration = kEventDurationForever
            if carbon.ReceiveNextEvent(0, None, duration,
                                       True, ctypes.byref(e)) == 0:
                carbon.SendEventToEventTarget(e, event_dispatcher)
                carbon.ReleaseEvent(e)

            # Manual idle event
            if carbon.GetNumEventsInQueue(event_queue) == 0 or self._force_idle:
                self._force_idle = False
                self._timer_proc(timer, None, False)

        carbon.RemoveEventLoopTimer(self._timer)
        self.dispatch_event('on_exit')

    def _stop_polling(self):
        carbon.SetEventLoopTimerNextFireTime(self._timer, ctypes.c_double(0.0))

    def _enter_blocking(self):
        carbon.SetEventLoopTimerNextFireTime(self._timer, ctypes.c_double(0.0))
        self._allow_polling = False

    def _exit_blocking(self):
        self._allow_polling = True

    def _timer_proc(self, timer, data, in_events=True):
        allow_polling = True

        for window in windows:
            # Check for live resizing
            if window._resizing is not None:
                allow_polling = False
                old_width, old_height = window._resizing
                rect = types.Rect()
                carbon.GetWindowBounds(window._window,
                                       constants.kWindowContentRgn,
                                       ctypes.byref(rect))
                width = rect.right - rect.left
                height = rect.bottom - rect.top
                if width != old_width or height != old_height:
                    window._resizing = width, height
                    window.switch_to()
                    window.dispatch_event('on_resize', width, height)

            # Check for live dragging
            if window._dragging:
                allow_polling = False

            # Check for deferred recreate
            if window._recreate_deferred:
                if in_events:
                    # Break out of ReceiveNextEvent so it can be processed
                    # in next iteration.
                    carbon.QuitEventLoop(self._event_loop)
                    self._force_idle = True
                else:
                    # Do it now.
                    window._recreate_immediate()

        sleep_time = self.idle()

        if sleep_time is None:
            sleep_time = constants.kEventDurationForever
        elif sleep_time < 0.01 and allow_polling and self._allow_polling:
            # Switch event loop to polling.
            if in_events:
                carbon.QuitEventLoop(self._event_loop)
            self._force_idle = True
            sleep_time = constants.kEventDurationForever
        carbon.SetEventLoopTimerNextFireTime(timer, ctypes.c_double(sleep_time))


########NEW FILE########
__FILENAME__ = win32
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
# $Id:$

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import ctypes
import time

from pyglet.app import windows, BaseEventLoop
from pyglet.window.win32 import _user32, types, constants

class Win32EventLoop(BaseEventLoop):
    def run(self):
        self._setup()

        self._timer_proc = types.TIMERPROC(self._timer_func)
        self._timer = timer = _user32.SetTimer(0, 0, 0, self._timer_proc)
        self._polling = False
        self._allow_polling = True
        msg = types.MSG()

        self.dispatch_event('on_enter')

        while not self.has_exit:
            if self._polling:
                while _user32.PeekMessageW(ctypes.byref(msg),
                                           0, 0, 0, constants.PM_REMOVE):
                    _user32.TranslateMessage(ctypes.byref(msg))
                    _user32.DispatchMessageW(ctypes.byref(msg))
                self._timer_func(0, 0, timer, 0)
            else:
                _user32.GetMessageW(ctypes.byref(msg), 0, 0, 0)
                _user32.TranslateMessage(ctypes.byref(msg))
                _user32.DispatchMessageW(ctypes.byref(msg))

                # Manual idle event
                msg_types = \
                    _user32.GetQueueStatus(constants.QS_ALLINPUT) & 0xffff0000
                if (msg.message != constants.WM_TIMER and
                    not msg_types & ~(constants.QS_TIMER<<16)):
                    self._timer_func(0, 0, timer, 0)

        self.dispatch_event('on_exit')

    def _idle_chance(self):
        if (self._next_idle_time is not None and
            self._next_idle_time <= time.time()):
            self._timer_func(0, 0, self._timer, 0)

    def _timer_func(self, hwnd, msg, timer, t):
        sleep_time = self.idle()

        if sleep_time is None:
            # Block indefinitely
            millis = constants.USER_TIMER_MAXIMUM
            self._next_idle_time = None
            self._polling = False
            _user32.SetTimer(0, timer, millis, self._timer_proc)
        elif sleep_time < 0.01 and self._allow_polling:
            # Degenerate to polling
            millis = constants.USER_TIMER_MAXIMUM
            self._next_idle_time = 0.
            if not self._polling:
                self._polling = True
                _user32.SetTimer(0, timer, millis, self._timer_proc)
        else:
            # Block until timer
            # XXX hack to avoid oversleep; needs to be api
            sleep_time = max(sleep_time - 0.01, 0)
            millis = int(sleep_time * 1000)
            self._next_idle_time = time.time() + sleep_time
            self._polling = False
            _user32.SetTimer(0, timer, millis, self._timer_proc)

########NEW FILE########
__FILENAME__ = xlib
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: xlib.py 2496 2009-08-19 01:17:30Z benjamin.coder.smith $'

import select

from pyglet.app import displays, windows, BaseEventLoop
from pyglet.window.xlib import xlib

class XlibEventLoop(BaseEventLoop):
    def run(self):
        self._setup()

        e = xlib.XEvent()
        t = 0
        sleep_time = 0.

        self.dispatch_event('on_enter')

        while not self.has_exit:
            # Check for already pending events
            for display in displays:
                if xlib.XPending(display._display):
                    pending_displays = (display,)
                    break
            else:
                # None found; select on all file descriptors or timeout
                iwtd = self.get_select_files()
                pending_displays, _, _ = select.select(iwtd, (), (), sleep_time)

            # Dispatch platform events
            for display in pending_displays:
                while xlib.XPending(display._display):
                    xlib.XNextEvent(display._display, e)

                    # Key events are filtered by the xlib window event
                    # handler so they get a shot at the prefiltered event.
                    if e.xany.type not in (xlib.KeyPress, xlib.KeyRelease):
                        if xlib.XFilterEvent(e, e.xany.window):
                            continue
                    try:
                        window = display._window_map[e.xany.window]
                    except KeyError:
                        continue

                    window.dispatch_platform_event(e)

            # Dispatch resize events
            for window in windows:
                if window._needs_resize:
                    window.switch_to()
                    window.dispatch_event('on_resize',
                                          window._width, window._height)
                    window.dispatch_event('on_expose')
                    window._needs_resize = False

            sleep_time = self.idle()

        self.dispatch_event('on_exit')

    def get_select_files(self):
        return list(displays)

########NEW FILE########
__FILENAME__ = clock
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Precise framerate calculation, scheduling and framerate limiting.

Measuring time
==============

The `tick` and `get_fps` functions can be used in conjunction to fulfil most
games' basic requirements::

    from pyglet import clock
    while True:
        dt = clock.tick()
        # ... update and render ...
        print 'FPS is %f' % clock.get_fps()

The ``dt`` value returned gives the number of seconds (as a float) since the
last "tick".

The `get_fps` function averages the framerate over a sliding window of
approximately 1 second.  (You can calculate the instantaneous framerate by
taking the reciprocal of ``dt``).

Always remember to `tick` the clock!

Limiting frame-rate
===================

The framerate can be limited::

    clock.set_fps_limit(60)

This causes `clock` to sleep during each `tick` in an attempt to keep the
number of ticks (frames) per second below 60.

The implementation uses platform-dependent high-resolution sleep functions
to achieve better accuracy with busy-waiting than would be possible using
just the `time` module.

Scheduling
==========

You can schedule a function to be called every time the clock is ticked::

    def callback(dt):
        print '%f seconds since last callback' % dt

    clock.schedule(callback)

The `schedule_interval` method causes a function to be called every "n"
seconds::

    clock.schedule_interval(callback, .5)   # called twice a second

The `schedule_once` method causes a function to be called once "n" seconds
in the future::

    clock.schedule_once(callback, 5)        # called in 5 seconds

All of the `schedule` methods will pass on any additional args or keyword args
you specify to the callback function::

    def animate(dt, velocity, sprite):
       sprite.position += dt * velocity

    clock.schedule(animate, velocity=5.0, sprite=alien)

You can cancel a function scheduled with any of these methods using
`unschedule`::

    clock.unschedule(animate)

Displaying FPS
==============

The ClockDisplay class provides a simple FPS counter.  You should create
an instance of ClockDisplay once during the application's start up::

    fps_display = clock.ClockDisplay()

Call draw on the ClockDisplay object for each frame::

    fps_display.draw()

There are several options to change the font, color and text displayed
within the __init__ method.

Using multiple clocks
=====================

The clock functions are all relayed to an instance of `Clock` which is
initialised with the module.  You can get this instance to use directly::

    clk = clock.get_default()

You can also replace the default clock with your own:

    myclk = clock.Clock()
    clock.set_default(myclk)

Each clock maintains its own set of scheduled functions and FPS
limiting/measurement.  Each clock must be "ticked" separately.

Multiple and derived clocks potentially allow you to separate "game-time" and
"wall-time", or to synchronise your clock to an audio or video stream instead
of the system clock.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: clock.py 2541 2009-12-31 04:31:11Z benjamin.coder.smith@gmail.com $'

import time
import sys
import ctypes

import pyglet.lib

if sys.platform in ('win32', 'cygwin'):
    # Win32 Sleep function is only 10-millisecond resolution, so instead
    # use a waitable timer object, which has up to 100-nanosecond resolution
    # (hardware and implementation dependent, of course).
    _kernel32 = ctypes.windll.kernel32
    class _ClockBase(object):
        def __init__(self):
            self._timer = _kernel32.CreateWaitableTimerA(ctypes.c_void_p(),
                True, ctypes.c_void_p())

        def sleep(self, microseconds):
            delay = ctypes.c_longlong(int(-microseconds * 10))
            _kernel32.SetWaitableTimer(self._timer, ctypes.byref(delay),
                0, ctypes.c_void_p(), ctypes.c_void_p(), False)
            _kernel32.WaitForSingleObject(self._timer, 0xffffffff)
    _default_time_function = time.clock

else:
    _c = pyglet.lib.load_library('c', darwin='/usr/lib/libc.dylib')
    _c.usleep.argtypes = [ctypes.c_ulong]

    class _ClockBase(object):
        def sleep(self, microseconds):
            _c.usleep(int(microseconds))
    _default_time_function = time.time

class _ScheduledItem(object):
    __slots__ = ['func', 'args', 'kwargs']
    def __init__(self, func, args, kwargs):
        self.func = func
        self.args = args
        self.kwargs = kwargs

class _ScheduledIntervalItem(object):
    __slots__ = ['func', 'interval', 'last_ts', 'next_ts',
                 'args', 'kwargs']
    def __init__(self, func, interval, last_ts, next_ts, args, kwargs):
        self.func = func
        self.interval = interval
        self.last_ts = last_ts
        self.next_ts = next_ts
        self.args = args
        self.kwargs = kwargs

def _dummy_schedule_func(*args, **kwargs):
    '''Dummy function that does nothing, placed onto zombie scheduled items
    to ensure they have no side effect if already queued inside tick() method.
    '''
    pass

class Clock(_ClockBase):
    '''Class for calculating and limiting framerate, and for calling scheduled
    functions.
    '''

    #: The minimum amount of time in seconds this clock will attempt to sleep
    #: for when framerate limiting.  Higher values will increase the
    #: accuracy of the limiting but also increase CPU usage while
    #: busy-waiting.  Lower values mean the process sleeps more often, but is
    #: prone to over-sleep and run at a potentially lower or uneven framerate
    #: than desired.
    MIN_SLEEP = 0.005

    #: The amount of time in seconds this clock subtracts from sleep values
    #: to compensate for lazy operating systems.
    SLEEP_UNDERSHOOT = MIN_SLEEP - 0.001

    # List of functions to call every tick.
    _schedule_items = None

    # List of schedule interval items kept in sort order.
    _schedule_interval_items = None

    # If True, a sleep(0) is inserted on every tick.
    _force_sleep = False

    def __init__(self, fps_limit=None, time_function=_default_time_function):
        '''Initialise a Clock, with optional framerate limit and custom
        time function.

        :Parameters:
            `fps_limit` : float
                If not None, the maximum allowable framerate.  Defaults
                to None.  Deprecated in pyglet 1.1.
            `time_function` : function
                Function to return the elapsed time of the application,
                in seconds.  Defaults to time.time, but can be replaced
                to allow for easy time dilation effects or game pausing.

        '''

        super(Clock, self).__init__()
        self.time = time_function
        self.next_ts = self.time()
        self.last_ts = None
        self.times = []

        self.set_fps_limit(fps_limit)
        self.cumulative_time = 0

        self._schedule_items = []
        self._schedule_interval_items = []

    def tick(self, poll=False):
        '''Signify that one frame has passed.

        This will call any scheduled functions that have elapsed.

        :Parameters:
            `poll` : bool
                If True, the function will call any scheduled functions
                but will not sleep or busy-wait for any reason.  Recommended
                for advanced applications managing their own sleep timers
                only.

                Since pyglet 1.1.

        :rtype: float
        :return: The number of seconds since the last "tick", or 0 if this was
            the first frame.
        '''
        if poll:
            if self.period_limit:
                self.next_ts = self.next_ts + self.period_limit
        else:
            if self.period_limit:
                self._limit()

            if self._force_sleep:
                self.sleep(0)

        ts = self.time()
        if self.last_ts is None:
            delta_t = 0
        else:
            delta_t = ts - self.last_ts
            self.times.insert(0, delta_t)
            if len(self.times) > self.window_size:
                self.cumulative_time -= self.times.pop()
        self.cumulative_time += delta_t
        self.last_ts = ts

        # Call functions scheduled for every frame
        # Dupe list just in case one of the items unchedules itself
        for item in list(self._schedule_items):
            item.func(delta_t, *item.args, **item.kwargs)

        # Call all scheduled interval functions and reschedule for future.
        need_resort = False
        # Dupe list just in case one of the items unchedules itself
        for item in list(self._schedule_interval_items):
            if item.next_ts > ts:
                break
            item.func(ts - item.last_ts, *item.args, **item.kwargs)
            if item.interval:
                # Try to keep timing regular, even if overslept this time;
                # but don't schedule in the past (which could lead to
                # infinitely-worsing error).
                item.next_ts = item.last_ts + item.interval
                item.last_ts = ts
                if item.next_ts <= ts:
                    if ts - item.next_ts < 0.05:
                        # Only missed by a little bit, keep the same schedule
                        item.next_ts = ts + item.interval
                    else:
                        # Missed by heaps, do a soft reschedule to avoid
                        # lumping everything together.
                        item.next_ts = self._get_soft_next_ts(ts, item.interval)
                        # Fake last_ts to avoid repeatedly over-scheduling in
                        # future.  Unfortunately means the next reported dt is
                        # incorrect (looks like interval but actually isn't).
                        item.last_ts = item.next_ts - item.interval
                need_resort = True
            else:
                item.next_ts = None

        # Remove finished one-shots.
        self._schedule_interval_items = \
            [item for item in self._schedule_interval_items \
             if item.next_ts is not None]

        if need_resort:
            # TODO bubble up changed items might be faster
            self._schedule_interval_items.sort(key=lambda a: a.next_ts)

        return delta_t

    def _limit(self):
        '''Sleep until the next frame is due.  Called automatically by
        `tick` if a framerate limit has been set.

        This method uses several heuristics to determine whether to
        sleep or busy-wait (or both).
        '''
        ts = self.time()
        # Sleep to just before the desired time
        sleeptime = self.get_sleep_time(False)
        while sleeptime - self.SLEEP_UNDERSHOOT > self.MIN_SLEEP:
            self.sleep(1000000 * (sleeptime - self.SLEEP_UNDERSHOOT))
            sleeptime = self.get_sleep_time(False)

        # Busy-loop CPU to get closest to the mark
        sleeptime = self.next_ts - self.time()
        while sleeptime > 0:
            sleeptime = self.next_ts - self.time()

        if sleeptime < -2 * self.period_limit:
            # Missed the time by a long shot, let's reset the clock
            # print >> sys.stderr, 'Step %f' % -sleeptime
            self.next_ts = ts + 2 * self.period_limit
        else:
            # Otherwise keep the clock steady
            self.next_ts = self.next_ts + self.period_limit

    def get_sleep_time(self, sleep_idle):
        '''Get the time until the next item is scheduled.

        This method considers all scheduled items and the current
        ``fps_limit``, if any.

        Applications can choose to continue receiving updates at the
        maximum framerate during idle time (when no functions are scheduled),
        or they can sleep through their idle time and allow the CPU to
        switch to other processes or run in low-power mode.

        If `sleep_idle` is ``True`` the latter behaviour is selected, and
        ``None`` will be returned if there are no scheduled items.

        Otherwise, if `sleep_idle` is ``False``, a sleep time allowing
        the maximum possible framerate (considering ``fps_limit``) will
        be returned; or an earlier time if a scheduled function is ready.

        :Parameters:
            `sleep_idle` : bool
                If True, the application intends to sleep through its idle
                time; otherwise it will continue ticking at the maximum
                frame rate allowed.

        :rtype: float
        :return: Time until the next scheduled event in seconds, or ``None``
            if there is no event scheduled.

        :since: pyglet 1.1
        '''
        if self._schedule_items or not sleep_idle:
            if not self.period_limit:
                return 0.
            else:
                wake_time = self.next_ts
                if self._schedule_interval_items:
                    wake_time = min(wake_time,
                                    self._schedule_interval_items[0].next_ts)
                return max(wake_time - self.time(), 0.)

        if self._schedule_interval_items:
            return max(self._schedule_interval_items[0].next_ts - self.time(),
                       0)

        return None

    def set_fps_limit(self, fps_limit):
        '''Set the framerate limit.

        The framerate limit applies only when a function is scheduled
        for every frame.  That is, the framerate limit can be exceeded by
        scheduling a function for a very small period of time.

        :Parameters:
            `fps_limit` : float
                Maximum frames per second allowed, or None to disable
                limiting.

        :deprecated: Use `pyglet.app.run` and `schedule_interval` instead.
        '''
        if not fps_limit:
            self.period_limit = None
        else:
            self.period_limit = 1. / fps_limit
        self.window_size = fps_limit or 60

    def get_fps_limit(self):
        '''Get the framerate limit.

        :rtype: float
        :return: The framerate limit previously set in the constructor or
            `set_fps_limit`, or None if no limit was set.
        '''
        if self.period_limit:
            return 1. / self.period_limit
        else:
            return 0

    def get_fps(self):
        '''Get the average FPS of recent history.

        The result is the average of a sliding window of the last "n" frames,
        where "n" is some number designed to cover approximately 1 second.

        :rtype: float
        :return: The measured frames per second.
        '''
        if not self.cumulative_time:
            return 0
        return len(self.times) / self.cumulative_time

    def schedule(self, func, *args, **kwargs):
        '''Schedule a function to be called every frame.

        The function should have a prototype that includes ``dt`` as the
        first argument, which gives the elapsed time, in seconds, since the
        last clock tick.  Any additional arguments given to this function
        are passed on to the callback::

            def callback(dt, *args, **kwargs):
                pass

        :Parameters:
            `func` : function
                The function to call each frame.
        '''
        item = _ScheduledItem(func, args, kwargs)
        self._schedule_items.append(item)

    def _schedule_item(self, func, last_ts, next_ts, interval, *args, **kwargs):
        item = _ScheduledIntervalItem(
            func, interval, last_ts, next_ts, args, kwargs)

        # Insert in sort order
        for i, other in enumerate(self._schedule_interval_items):
            if other.next_ts > next_ts:
                self._schedule_interval_items.insert(i, item)
                break
        else:
            self._schedule_interval_items.append(item)

    def schedule_interval(self, func, interval, *args, **kwargs):
        '''Schedule a function to be called every `interval` seconds.

        Specifying an interval of 0 prevents the function from being
        called again (see `schedule` to call a function as often as possible).

        The callback function prototype is the same as for `schedule`.

        :Parameters:
            `func` : function
                The function to call when the timer lapses.
            `interval` : float
                The number of seconds to wait between each call.

        '''
        last_ts = self.last_ts or self.next_ts

        # Schedule from now, unless now is sufficiently close to last_ts, in
        # which case use last_ts.  This clusters together scheduled items that
        # probably want to be scheduled together.  The old (pre 1.1.1)
        # behaviour was to always use self.last_ts, and not look at ts.  The
        # new behaviour is needed because clock ticks can now be quite
        # irregular, and span several seconds.
        ts = self.time()
        if ts - last_ts > 0.2:
            last_ts = ts

        next_ts = last_ts + interval
        self._schedule_item(func, last_ts, next_ts, interval, *args, **kwargs)

    def schedule_interval_soft(self, func, interval, *args, **kwargs):
        '''Schedule a function to be called every `interval` seconds,
        beginning at a time that does not coincide with other scheduled
        events.

        This method is similar to `schedule_interval`, except that the
        clock will move the interval out of phase with other scheduled
        functions so as to distribute CPU more load evenly over time.

        This is useful for functions that need to be called regularly,
        but not relative to the initial start time.  `pyglet.media`
        does this for scheduling audio buffer updates, which need to occur
        regularly -- if all audio updates are scheduled at the same time
        (for example, mixing several tracks of a music score, or playing
        multiple videos back simultaneously), the resulting load on the
        CPU is excessive for those intervals but idle outside.  Using
        the soft interval scheduling, the load is more evenly distributed.

        Soft interval scheduling can also be used as an easy way to schedule
        graphics animations out of phase; for example, multiple flags
        waving in the wind.

        :since: pyglet 1.1

        :Parameters:
            `func` : function
                The function to call when the timer lapses.
            `interval` : float
                The number of seconds to wait between each call.

        '''
        last_ts = self.last_ts or self.next_ts

        # See schedule_interval
        ts = self.time()
        if ts - last_ts > 0.2:
            last_ts = ts

        next_ts = self._get_soft_next_ts(last_ts, interval)
        last_ts = next_ts - interval
        self._schedule_item(func, last_ts, next_ts, interval, *args, **kwargs)

    def _get_soft_next_ts(self, last_ts, interval):
        def taken(ts, e):
            '''Return True if the given time has already got an item
            scheduled nearby.
            '''
            for item in self._schedule_interval_items:
                if item.next_ts is None:
                    pass
                elif abs(item.next_ts - ts) <= e:
                    return True
                elif item.next_ts > ts + e:
                    return False
            return False

        # Binary division over interval:
        #
        # 0                          interval
        # |--------------------------|
        #   5  3   6   2   7  4  8   1          Order of search
        #
        # i.e., first scheduled at interval,
        #       then at            interval/2
        #       then at            interval/4
        #       then at            interval*3/4
        #       then at            ...
        #
        # Schedule is hopefully then evenly distributed for any interval,
        # and any number of scheduled functions.

        next_ts = last_ts + interval
        if not taken(next_ts, interval / 4):
            return next_ts

        dt = interval
        divs = 1
        while True:
            next_ts = last_ts
            for i in range(divs - 1):
                next_ts += dt
                if not taken(next_ts, dt / 4):
                    return next_ts
            dt /= 2
            divs *= 2

            # Avoid infinite loop in pathological case
            if divs > 16:
                return next_ts

    def schedule_once(self, func, delay, *args, **kwargs):
        '''Schedule a function to be called once after `delay` seconds.

        The callback function prototype is the same as for `schedule`.

        :Parameters:
            `func` : function
                The function to call when the timer lapses.
            `delay` : float
                The number of seconds to wait before the timer lapses.
        '''
        last_ts = self.last_ts or self.next_ts

        # See schedule_interval
        ts = self.time()
        if ts - last_ts > 0.2:
            last_ts = ts

        next_ts = last_ts + delay
        self._schedule_item(func, last_ts, next_ts, 0, *args, **kwargs)

    def unschedule(self, func):
        '''Remove a function from the schedule.

        If the function appears in the schedule more than once, all occurrences
        are removed.  If the function was not scheduled, no error is raised.

        :Parameters:
            `func` : function
                The function to remove from the schedule.

        '''
        # First replace zombie items' func with a dummy func that does
        # nothing, in case the list has already been cloned inside tick().
        # (Fixes issue 326).
        for item in self._schedule_items:
            if item.func == func:
                item.func = _dummy_schedule_func

        for item in self._schedule_interval_items:
            if item.func == func:
                item.func = _dummy_schedule_func

        # Now remove matching items from both schedule lists.
        self._schedule_items = \
            [item for item in self._schedule_items \
                  if item.func is not _dummy_schedule_func]

        self._schedule_interval_items = \
            [item for item in self._schedule_interval_items \
                  if item.func is not _dummy_schedule_func]

# Default clock.
_default = Clock()

def set_default(default):
    '''Set the default clock to use for all module-level functions.

    By default an instance of `Clock` is used.

    :Parameters:
        `default` : `Clock`
            The default clock to use.
    '''
    global _default
    _default = default

def get_default():
    '''Return the `Clock` instance that is used by all module-level
    clock functions.

    :rtype: `Clock`
    :return: The default clock.
    '''
    return _default

def tick(poll=False):
    '''Signify that one frame has passed on the default clock.

    This will call any scheduled functions that have elapsed.

    :Parameters:
        `poll` : bool
            If True, the function will call any scheduled functions
            but will not sleep or busy-wait for any reason.  Recommended
            for advanced applications managing their own sleep timers
            only.

            Since pyglet 1.1.

    :rtype: float
    :return: The number of seconds since the last "tick", or 0 if this was the
        first frame.
    '''

    return _default.tick(poll)

def get_sleep_time(sleep_idle):
    '''Get the time until the next item is scheduled on the default clock.

    See `Clock.get_sleep_time` for details.

    :Parameters:
        `sleep_idle` : bool
            If True, the application intends to sleep through its idle
            time; otherwise it will continue ticking at the maximum
            frame rate allowed.

    :rtype: float
    :return: Time until the next scheduled event in seconds, or ``None``
        if there is no event scheduled.

    :since: pyglet 1.1
    '''
    return _default.get_sleep_time(sleep_idle)

def get_fps():
    '''Return the current measured FPS of the default clock.

    :rtype: float
    '''
    return _default.get_fps()

def set_fps_limit(fps_limit):
    '''Set the framerate limit for the default clock.

    :Parameters:
        `fps_limit` : float
            Maximum frames per second allowed, or None to disable
            limiting.

    :deprecated: Use `pyglet.app.run` and `schedule_interval` instead.
    '''
    _default.set_fps_limit(fps_limit)

def get_fps_limit():
    '''Get the framerate limit for the default clock.

    :return: The framerate limit previously set by `set_fps_limit`, or None if
        no limit was set.

    '''
    return _default.get_fps_limit()

def schedule(func, *args, **kwargs):
    '''Schedule 'func' to be called every frame on the default clock.

    The arguments passed to func are ``dt``, followed by any ``*args`` and
    ``**kwargs`` given here.

    :Parameters:
        `func` : function
            The function to call each frame.
    '''
    _default.schedule(func, *args, **kwargs)

def schedule_interval(func, interval, *args, **kwargs):
    '''Schedule 'func' to be called every 'interval' seconds on the default
    clock.

    The arguments passed to 'func' are 'dt' (time since last function call),
    followed by any ``*args`` and ``**kwargs`` given here.

    :Parameters:
        `func` : function
            The function to call when the timer lapses.
        `interval` : float
            The number of seconds to wait between each call.

    '''
    _default.schedule_interval(func, interval, *args, **kwargs)

def schedule_interval_soft(func, interval, *args, **kwargs):
    '''Schedule 'func' to be called every 'interval' seconds on the default
    clock, beginning at a time that does not coincide with other scheduled
    events.

    The arguments passed to 'func' are 'dt' (time since last function call),
    followed by any ``*args`` and ``**kwargs`` given here.

    :see: `Clock.schedule_interval_soft`

    :since: pyglet 1.1

    :Parameters:
        `func` : function
            The function to call when the timer lapses.
        `interval` : float
            The number of seconds to wait between each call.

    '''
    _default.schedule_interval_soft(func, interval, *args, **kwargs)

def schedule_once(func, delay, *args, **kwargs):
    '''Schedule 'func' to be called once after 'delay' seconds (can be
    a float) on the default clock.  The arguments passed to 'func' are
    'dt' (time since last function call), followed by any ``*args`` and
    ``**kwargs`` given here.

    If no default clock is set, the func is queued and will be scheduled
    on the default clock as soon as it is created.

    :Parameters:
        `func` : function
            The function to call when the timer lapses.
        `delay` : float
            The number of seconds to wait before the timer lapses.

    '''
    _default.schedule_once(func, delay, *args, **kwargs)

def unschedule(func):
    '''Remove 'func' from the default clock's schedule.  No error
    is raised if the func was never scheduled.

    :Parameters:
        `func` : function
            The function to remove from the schedule.

    '''
    _default.unschedule(func)

class ClockDisplay(object):
    '''Display current clock values, such as FPS.

    This is a convenience class for displaying diagnostics such as the
    framerate.  See the module documentation for example usage.

    :Ivariables:
        `label` : `pyglet.font.Text`
            The label which is displayed.

    '''

    def __init__(self,
                 font=None,
                 interval=0.25,
                 format='%(fps).2f',
                 color=(.5, .5, .5, .5),
                 clock=None):
        '''Create a ClockDisplay.

        All parameters are optional.  By default, a large translucent
        font will be used to display the FPS to two decimal places.

        :Parameters:
            `font` : `pyglet.font.Font`
                The font to format text in.
            `interval` : float
                The number of seconds between updating the display.
            `format` : str
                A format string describing the format of the text.  This
                string is modulated with the dict ``{'fps' : fps}``.
            `color` : 4-tuple of float
                The color, including alpha, passed to ``glColor4f``.
            `clock` : `Clock`
                The clock which determines the time.  If None, the default
                clock is used.

        '''

        if clock is None:
            clock = _default
        self.clock = clock
        self.clock.schedule_interval(self.update_text, interval)

        if not font:
            from pyglet.font import load as load_font
            font = load_font('', 36, bold=True)

        import pyglet.font
        self.label = pyglet.font.Text(font, '', color=color, x=10, y=10)

        self.format = format

    def unschedule(self):
        '''Remove the display from its clock's schedule.

        `ClockDisplay` uses `Clock.schedule_interval` to periodically update
        its display label.  Even if the ClockDisplay is not being used any
        more, its update method will still be scheduled, which can be a
        resource drain.  Call this method to unschedule the update method
        and allow the ClockDisplay to be garbage collected.

        :since: pyglet 1.1
        '''
        self.clock.unschedule(self.update_text)

    def update_text(self, dt=0):
        '''Scheduled method to update the label text.'''
        fps = self.clock.get_fps()
        self.label.text = self.format % {'fps': fps}

    def draw(self):
        '''Method called each frame to render the label.'''
        self.label.draw()

def test_clock():
    import getopt
    test_seconds = 1
    test_fps = 60
    show_fps = False
    options, args = getopt.getopt(sys.argv[1:], 'vht:f:',
        ['time=', 'fps=', 'help'])
    for key, value in options:
        if key in ('-t', '--time'):
            test_seconds = float(value)
        elif key in ('-f', '--fps'):
            test_fps = float(value)
        elif key in ('-v'):
            show_fps = True
        elif key in ('-h', '--help'):
            print ('Usage: clock.py <options>\n'
                   '\n'
                   'Options:\n'
                   '  -t   --time       Number of seconds to run for.\n'
                   '  -f   --fps        Target FPS.\n'
                   '\n'
                   'Tests the clock module by measuring how close we can\n'
                   'get to the desired FPS by sleeping and busy-waiting.')
            sys.exit(0)

    set_fps_limit(test_fps)
    start = time.time()

    # Add one because first frame has no update interval.
    n_frames = int(test_seconds * test_fps + 1)

    print 'Testing %f FPS for %f seconds...' % (test_fps, test_seconds)
    for i in xrange(n_frames):
        tick()
        if show_fps:
            print get_fps()
    total_time = time.time() - start
    total_error = total_time - test_seconds
    print 'Total clock error: %f secs' % total_error
    print 'Total clock error / secs: %f secs/secs' % \
        (total_error / test_seconds)

    # Not fair to add the extra frame in this calc, since no-one's interested
    # in the startup situation.
    print 'Average FPS: %f' % ((n_frames - 1) / total_time)

if __name__ == '__main__':
    test_clock()

########NEW FILE########
__FILENAME__ = com
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
# $Id:$

'''Minimal Windows COM interface.

Allows pyglet to use COM interfaces on Windows without comtypes.  Unlike
comtypes, this module does not provide property interfaces, read typelibs,
nice-ify return values or permit Python implementations of COM interfaces.  We
don't need anything that sophisticated to work with DirectX.

All interfaces should derive from IUnknown (defined in this module).  The
Python COM interfaces are actually pointers to the implementation (take note
when translating methods that take an interface as argument).

Interfaces can define methods::

    class IDirectSound8(com.IUnknown):
        _methods_ = [
            ('CreateSoundBuffer', com.STDMETHOD()),
            ('GetCaps', com.STDMETHOD(LPDSCAPS)),
            ...
        ]

Only use STDMETHOD or METHOD for the method types (not ordinary ctypes
function types).  The 'this' pointer is bound automatically... e.g., call::

    device = IDirectSound8()
    DirectSoundCreate8(None, ctypes.byref(device), None)

    caps = DSCAPS()
    device.GetCaps(caps)

Because STDMETHODs use HRESULT as the return type, there is no need to check
the return value.

Don't forget to manually manage memory... call Release() when you're done with
an interface.
'''

import ctypes
import sys

if sys.platform != 'win32':
    raise ImportError('pyglet.com requires a Windows build of Python')

class GUID(ctypes.Structure):
    _fields_ = [
        ('Data1', ctypes.c_ulong),
        ('Data2', ctypes.c_ushort),
        ('Data3', ctypes.c_ushort),
        ('Data4', ctypes.c_ubyte * 8)
    ]

    def __init__(self, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8):
        self.Data1 = l
        self.Data2 = w1
        self.Data3 = w2
        self.Data4[:] = (b1, b2, b3, b4, b5, b6, b7, b8)

LPGUID = ctypes.POINTER(GUID)
IID = GUID
REFIID = ctypes.POINTER(IID)

class METHOD(object):
    '''COM method.'''
    def __init__(self, restype, *args):
        self.restype = restype
        self.argtypes = args

    def get_field(self):
        return ctypes.WINFUNCTYPE(self.restype, *self.argtypes)

class STDMETHOD(METHOD):
    '''COM method with HRESULT return value.'''
    def __init__(self, *args):
        super(STDMETHOD, self).__init__(ctypes.HRESULT, *args)

class COMMethodInstance(object):
    '''Binds a COM interface method.'''
    def __init__(self, name, i, method):
        self.name = name
        self.i = i
        self.method = method

    def __get__(self, obj, tp):
        if obj is not None:
            return lambda *args: \
                self.method.get_field()(self.i, self.name)(obj, *args)
        raise AttributeError()

class COMInterface(ctypes.Structure):
    '''Dummy struct to serve as the type of all COM pointers.'''
    _fields_ = [
        ('lpVtbl', ctypes.c_void_p),
    ]

class InterfaceMetaclass(type(ctypes.POINTER(COMInterface))):
    '''Creates COM interface pointers.'''
    def __new__(cls, name, bases, dct):
        methods = []
        for base in bases[::-1]:
            methods.extend(base.__dict__.get('_methods_', ()))
        methods.extend(dct.get('_methods_', ()))

        for i, (n, method) in enumerate(methods):
            dct[n] = COMMethodInstance(n, i, method)

        dct['_type_'] = COMInterface

        return super(InterfaceMetaclass, cls).__new__(cls, name, bases, dct)

class Interface(ctypes.POINTER(COMInterface)):
    '''Base COM interface pointer.'''
    __metaclass__ = InterfaceMetaclass

class IUnknown(Interface):
    _methods_ = [
        ('QueryInterface', STDMETHOD(REFIID, ctypes.c_void_p)),
        ('AddRef', METHOD(ctypes.c_int)),
        ('Release', METHOD(ctypes.c_int))
    ]


########NEW FILE########
__FILENAME__ = event
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Event dispatch framework.

All objects that produce events in pyglet implement `EventDispatcher`,
providing a consistent interface for registering and manipulating event
handlers.  A commonly used event dispatcher is `pyglet.window.Window`.

Event types
===========

For each event dispatcher there is a set of events that it dispatches; these
correspond with the type of event handlers you can attach.  Event types are
identified by their name, for example, ''on_resize''.  If you are creating a
new class which implements `EventDispatcher`, you must call
`EventDispatcher.register_event_type` for each event type.

Attaching event handlers
========================

An event handler is simply a function or method.  You can attach an event
handler by setting the appropriate function on the instance::

    def on_resize(width, height):
        # ...
    dispatcher.on_resize = on_resize

There is also a convenience decorator that reduces typing::

    @dispatcher.event
    def on_resize(width, height):
        # ...

You may prefer to subclass and override the event handlers instead::

    class MyDispatcher(DispatcherClass):
        def on_resize(self, width, height):
            # ...

Event handler stack
===================

When attaching an event handler to a dispatcher using the above methods, it
replaces any existing handler (causing the original handler to no longer be
called).  Each dispatcher maintains a stack of event handlers, allowing you to
insert an event handler "above" the existing one rather than replacing it.

There are two main use cases for "pushing" event handlers:

* Temporarily intercepting the events coming from the dispatcher by pushing a
  custom set of handlers onto the dispatcher, then later "popping" them all
  off at once.
* Creating "chains" of event handlers, where the event propagates from the
  top-most (most recently added) handler to the bottom, until a handler
  takes care of it.

Use `EventDispatcher.push_handlers` to create a new level in the stack and
attach handlers to it.  You can push several handlers at once::

    dispatcher.push_handlers(on_resize, on_key_press)

If your function handlers have different names to the events they handle, use
keyword arguments::

    dispatcher.push_handlers(on_resize=my_resize,
                             on_key_press=my_key_press)

After an event handler has processed an event, it is passed on to the
next-lowest event handler, unless the handler returns `EVENT_HANDLED`, which
prevents further propagation.

To remove all handlers on the top stack level, use
`EventDispatcher.pop_handlers`.

Note that any handlers pushed onto the stack have precedence over the
handlers set directly on the instance (for example, using the methods
described in the previous section), regardless of when they were set.
For example, handler ``foo`` is called before handler ``bar`` in the following
example::

    dispatcher.push_handlers(on_resize=foo)
    dispatcher.on_resize = bar

Dispatching events
==================

pyglet uses a single-threaded model for all application code.  Event
handlers are only ever invoked as a result of calling
EventDispatcher.dispatch_events`.

It is up to the specific event dispatcher to queue relevant events until they
can be dispatched, at which point the handlers are called in the order the
events were originally generated.

This implies that your application runs with a main loop that continuously
updates the application state and checks for new events::

    while True:
        dispatcher.dispatch_events()
        # ... additional per-frame processing

Not all event dispatchers require the call to ``dispatch_events``; check with
the particular class documentation.

'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: event.py 2541 2009-12-31 04:31:11Z benjamin.coder.smith@gmail.com $'

import inspect

EVENT_HANDLED = True
EVENT_UNHANDLED = None

class EventException(Exception):
    '''An exception raised when an event handler could not be attached.
    '''
    pass

class EventDispatcher(object):
    '''Generic event dispatcher interface.

    See the module docstring for usage.
    '''
    # Placeholder empty stack; real stack is created only if needed
    _event_stack = ()

    @classmethod
    def register_event_type(cls, name):
        '''Register an event type with the dispatcher.

        Registering event types allows the dispatcher to validate event
        handler names as they are attached, and to search attached objects for
        suitable handlers.

        :Parameters:
            `name` : str
                Name of the event to register.

        '''
        if not hasattr(cls, 'event_types'):
            cls.event_types = []
        cls.event_types.append(name)
        return name

    def push_handlers(self, *args, **kwargs):
        '''Push a level onto the top of the handler stack, then attach zero or
        more event handlers.

        If keyword arguments are given, they name the event type to attach.
        Otherwise, a callable's `__name__` attribute will be used.  Any other
        object may also be specified, in which case it will be searched for
        callables with event names.
        '''
        # Create event stack if necessary
        if type(self._event_stack) is tuple:
            self._event_stack = []

        # Place dict full of new handlers at beginning of stack
        self._event_stack.insert(0, {})
        self.set_handlers(*args, **kwargs)

    def _get_handlers(self, args, kwargs):
        '''Implement handler matching on arguments for set_handlers and
        remove_handlers.
        '''
        for object in args:
            if inspect.isroutine(object):
                # Single magically named function
                name = object.__name__
                if name not in self.event_types:
                    raise EventException('Unknown event "%s"' % name)
                yield name, object
            else:
                # Single instance with magically named methods
                for name in dir(object):
                    if name in self.event_types:
                        yield name, getattr(object, name)
        for name, handler in kwargs.items():
            # Function for handling given event (no magic)
            if name not in self.event_types:
                raise EventException('Unknown event "%s"' % name)
            yield name, handler

    def set_handlers(self, *args, **kwargs):
        '''Attach one or more event handlers to the top level of the handler
        stack.

        See `push_handlers` for the accepted argument types.
        '''
        # Create event stack if necessary
        if type(self._event_stack) is tuple:
            self._event_stack = [{}]

        for name, handler in self._get_handlers(args, kwargs):
            self.set_handler(name, handler)

    def set_handler(self, name, handler):
        '''Attach a single event handler.

        :Parameters:
            `name` : str
                Name of the event type to attach to.
            `handler` : callable
                Event handler to attach.

        '''
        # Create event stack if necessary
        if type(self._event_stack) is tuple:
            self._event_stack = [{}]

        self._event_stack[0][name] = handler

    def pop_handlers(self):
        '''Pop the top level of event handlers off the stack.
        '''
        assert self._event_stack and 'No handlers pushed'

        del self._event_stack[0]

    def remove_handlers(self, *args, **kwargs):
        '''Remove event handlers from the event stack.

        See `push_handlers` for the accepted argument types.  All handlers
        are removed from the first stack frame that contains any of the given
        handlers.  No error is raised if any handler does not appear in that
        frame, or if no stack frame contains any of the given handlers.

        If the stack frame is empty after removing the handlers, it is
        removed from the stack.  Note that this interferes with the expected
        symmetry of `push_handlers` and `pop_handlers`.
        '''
        handlers = list(self._get_handlers(args, kwargs))

        # Find the first stack frame containing any of the handlers
        def find_frame():
            for frame in self._event_stack:
                for name, handler in handlers:
                    try:
                        if frame[name] == handler:
                            return frame
                    except KeyError:
                        pass
        frame = find_frame()

        # No frame matched; no error.
        if not frame:
            return

        # Remove each handler from the frame.
        for name, handler in handlers:
            try:
                if frame[name] == handler:
                    del frame[name]
            except KeyError:
                pass

        # Remove the frame if it's empty.
        if not frame:
            self._event_stack.remove(frame)

    def remove_handler(self, name, handler):
        '''Remove a single event handler.

        The given event handler is removed from the first handler stack frame
        it appears in.  The handler must be the exact same callable as passed
        to `set_handler`, `set_handlers` or `push_handlers`; and the name
        must match the event type it is bound to.

        No error is raised if the event handler is not set.

        :Parameters:
            `name` : str
                Name of the event type to remove.
            `handler` : callable
                Event handler to remove.
        '''
        for frame in self._event_stack:
            try:
                if frame[name] is handler:
                    del frame[name]
                    break
            except KeyError:
                pass

    def dispatch_event(self, event_type, *args):
        '''Dispatch a single event to the attached handlers.

        The event is propagated to all handlers from from the top of the stack
        until one returns `EVENT_HANDLED`.  This method should be used only by
        `EventDispatcher` implementors; applications should call
        the ``dispatch_events`` method.

        :Parameters:
            `event_type` : str
                Name of the event.
            `args` : sequence
                Arguments to pass to the event handler.

        '''
        assert event_type in self.event_types

        # Search handler stack for matching event handlers
        for frame in list(self._event_stack):
            handler = frame.get(event_type, None)
            if handler:
                try:
                    if handler(*args):
                        return True
                except TypeError:
                    self._raise_dispatch_exception(event_type, args, handler)


        # Check instance for an event handler
        if hasattr(self, event_type):
            try:
                return getattr(self, event_type)(*args)
            except TypeError:
                self._raise_dispatch_exception(
                    event_type, args, getattr(self, event_type))

            return False

    def _raise_dispatch_exception(self, event_type, args, handler):
        # A common problem in applications is having the wrong number of
        # arguments in an event handler.  This is caught as a TypeError in
        # dispatch_event but the error message is obfuscated.
        #
        # Here we check if there is indeed a mismatch in argument count,
        # and construct a more useful exception message if so.  If this method
        # doesn't find a problem with the number of arguments, the error
        # is re-raised as if we weren't here.

        n_args = len(args)

        # Inspect the handler
        handler_args, handler_varargs, _, handler_defaults = \
            inspect.getargspec(handler)
        n_handler_args = len(handler_args)

        # Remove "self" arg from handler if it's a bound method
        if inspect.ismethod(handler) and handler.im_self:
            n_handler_args -= 1

        # Allow *args varargs to overspecify arguments
        if handler_varargs:
            n_handler_args = max(n_handler_args, n_args)

        # Allow default values to overspecify arguments
        if (n_handler_args > n_args and
            handler_defaults and
            n_handler_args - len(handler_defaults) <= n_args):
            n_handler_args = n_args

        if n_handler_args != n_args:
            if inspect.isfunction(handler) or inspect.ismethod(handler):
                descr = '%s at %s:%d' % (
                    handler.func_name,
                    handler.func_code.co_filename,
                    handler.func_code.co_firstlineno)
            else:
                descr = repr(handler)

            raise TypeError(
                '%s event was dispatched with %d arguments, but '
                'handler %s has an incompatible function signature' %
                (event_type, len(args), descr))
        else:
            raise

    def event(self, *args):
        '''Function decorator for an event handler.

        Usage::

            win = window.Window()

            @win.event
            def on_resize(self, width, height):
                # ...

        or::

            @win.event('on_resize')
            def foo(self, width, height):
                # ...

        '''
        if len(args) == 0:                      # @window.event()
            def decorator(func):
                name = func.__name__
                self.set_handler(name, func)
                return func
            return decorator
        elif inspect.isroutine(args[0]):        # @window.event
            func = args[0]
            name = func.__name__
            self.set_handler(name, func)
            return args[0]
        elif type(args[0]) in (str, unicode):   # @window.event('on_resize')
            name = args[0]
            def decorator(func):
                self.set_handler(name, func)
                return func
            return decorator

########NEW FILE########
__FILENAME__ = base
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Abstract classes used by pyglet.font implementations.

These classes should not be constructed directly.  Instead, use the functions
in `pyglet.font` to obtain platform-specific instances.  You can use these
classes as a documented interface to the concrete classes.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: base.py 2541 2009-12-31 04:31:11Z benjamin.coder.smith@gmail.com $'

import unicodedata

from pyglet.gl import *
from pyglet import image

_other_grapheme_extend = \
    map(unichr, [0x09be, 0x09d7, 0x0be3, 0x0b57, 0x0bbe, 0x0bd7, 0x0cc2,
                 0x0cd5, 0x0cd6, 0x0d3e, 0x0d57, 0x0dcf, 0x0ddf, 0x200c,
                 0x200d, 0xff9e, 0xff9f]) # skip codepoints above U+10000
_logical_order_exception = \
    map(unichr, range(0xe40, 0xe45) + range(0xec0, 0xec4))

_grapheme_extend = lambda c, cc: \
    cc in ('Me', 'Mn') or c in _other_grapheme_extend

_CR = u'\u000d'
_LF = u'\u000a'
_control = lambda c, cc: cc in ('ZI', 'Zp', 'Cc', 'Cf') and not \
    c in map(unichr, [0x000d, 0x000a, 0x200c, 0x200d])
_extend = lambda c, cc: _grapheme_extend(c, cc) or \
    c in map(unichr, [0xe30, 0xe32, 0xe33, 0xe45, 0xeb0, 0xeb2, 0xeb3])
_prepend = lambda c, cc: c in _logical_order_exception
_spacing_mark = lambda c, cc: cc == 'Mc' and c not in _other_grapheme_extend

def _grapheme_break(left, right):
    # GB1
    if left is None:
        return True

    # GB2 not required, see end of get_grapheme_clusters

    # GB3
    if left == _CR and right == _LF:
        return False

    left_cc = unicodedata.category(left)

    # GB4
    if _control(left, left_cc):
        return True

    right_cc = unicodedata.category(right)

    # GB5
    if _control(right, right_cc):
        return True

    # GB6, GB7, GB8 not implemented

    # GB9
    if _extend(right, right_cc):
        return False

    # GB9a
    if _spacing_mark(right, right_cc):
        return False

    # GB9b
    if _prepend(left, left_cc):
        return False

    # GB10
    return True

def get_grapheme_clusters(text):
    '''Implements Table 2 of UAX #29: Grapheme Cluster Boundaries.

    Does not currently implement Hangul syllable rules.

    :Parameters:
        `text` : unicode
            String to cluster.

    :since: pyglet 1.1.2

    :rtype: List of `unicode`
    :return: List of Unicode grapheme clusters
    '''
    clusters = []
    cluster = ''
    left = None
    for right in text:
        if cluster and _grapheme_break(left, right):
            clusters.append(cluster)
            cluster = ''
        elif cluster:
            # Add a zero-width space to keep len(clusters) == len(text)
            clusters.append(u'\u200b')
        cluster += right
        left = right

    # GB2
    if cluster:
        clusters.append(cluster)
    return clusters

class Glyph(image.TextureRegion):
    '''A single glyph located within a larger texture.

    Glyphs are drawn most efficiently using the higher level APIs, for example
    `GlyphString`.

    :Ivariables:
        `advance` : int
            The horizontal advance of this glyph, in pixels.
        `vertices` : (int, int, int, int)
            The vertices of this glyph, with (0,0) originating at the
            left-side bearing at the baseline.

    '''

    advance = 0
    vertices = (0, 0, 0, 0)

    def set_bearings(self, baseline, left_side_bearing, advance):
        '''Set metrics for this glyph.

        :Parameters:
            `baseline` : int
                Distance from the bottom of the glyph to its baseline;
                typically negative.
            `left_side_bearing` : int
                Distance to add to the left edge of the glyph.
            `advance` : int
                Distance to move the horizontal advance to the next glyph.

        '''
        self.advance = advance
        self.vertices = (
            left_side_bearing,
            -baseline,
            left_side_bearing + self.width,
            -baseline + self.height)

    def draw(self):
        '''Debug method.

        Use the higher level APIs for performance and kerning.
        '''
        glBindTexture(GL_TEXTURE_2D, self.owner.id)
        glBegin(GL_QUADS)
        self.draw_quad_vertices()
        glEnd()

    def draw_quad_vertices(self):
        '''Debug method.

        Use the higher level APIs for performance and kerning.
        '''
        glTexCoord3f(*self.tex_coords[:3])
        glVertex2f(self.vertices[0], self.vertices[1])
        glTexCoord3f(*self.tex_coords[3:6])
        glVertex2f(self.vertices[2], self.vertices[1])
        glTexCoord3f(*self.tex_coords[6:9])
        glVertex2f(self.vertices[2], self.vertices[3])
        glTexCoord3f(*self.tex_coords[9:12])
        glVertex2f(self.vertices[0], self.vertices[3])

    def get_kerning_pair(self, right_glyph):
        '''Not implemented.
        '''
        return 0

class GlyphTextureAtlas(image.Texture):
    '''A texture within which glyphs can be drawn.
    '''
    region_class = Glyph
    x = 0
    y = 0
    line_height = 0

    def apply_blend_state(self):
        '''Set the OpenGL blend state for the glyphs in this texture.
        '''
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
        glEnable(GL_BLEND)

    def fit(self, image):
        '''Place `image` within this texture.

        :Parameters:
            `image` : `pyglet.image.AbstractImage`
                Image to place within the texture.

        :rtype: `Glyph`
        :return: The glyph representing the image from this texture, or None
            if the image doesn't fit.
        '''
        if self.x + image.width > self.width:
            self.x = 0
            self.y += self.line_height
            self.line_height = 0
        if self.y + image.height > self.height:
            return None

        self.line_height = max(self.line_height, image.height)
        region = self.get_region(
            self.x, self.y, image.width, image.height)
        if image.width > 0:
            region.blit_into(image, 0, 0, 0)
            self.x += image.width + 1
        return region

class GlyphRenderer(object):
    '''Abstract class for creating glyph images.
    '''
    def __init__(self, font):
        pass

    def render(self, text):
        raise NotImplementedError('Subclass must override')

class FontException(Exception):
    '''Generic exception related to errors from the font module.  Typically
    these relate to invalid font data.'''
    pass

class Font(object):
    '''Abstract font class able to produce glyphs.

    To construct a font, use `pyglet.font.load`, which will instantiate the
    platform-specific font class.

    Internally, this class is used by the platform classes to manage the set
    of textures into which glyphs are written.

    :Ivariables:
        `ascent` : int
            Maximum ascent above the baseline, in pixels.
        `descent` : int
            Maximum descent below the baseline, in pixels. Usually negative.
    '''
    texture_width = 256
    texture_height = 256
    texture_internalformat = GL_ALPHA

    # These should also be set by subclass when known
    ascent = 0
    descent = 0

    glyph_renderer_class = GlyphRenderer
    texture_class = GlyphTextureAtlas

    def __init__(self):
        self.textures = []
        self.glyphs = {}

    @classmethod
    def add_font_data(cls, data):
        '''Add font data to the font loader.

        This is a class method and affects all fonts loaded.  Data must be
        some byte string of data, for example, the contents of a TrueType font
        file.  Subclasses can override this method to add the font data into
        the font registry.

        There is no way to instantiate a font given the data directly, you
        must use `pyglet.font.load` specifying the font name.
        '''
        pass

    @classmethod
    def have_font(cls, name):
        '''Determine if a font with the given name is installed.

        :Parameters:
            `name` : str
                Name of a font to search for

        :rtype: bool
        '''
        return True

    def create_glyph(self, image):
        '''Create a glyph using the given image.

        This is used internally by `Font` subclasses to add glyph data
        to the font.  Glyphs are packed within large textures maintained by
        `Font`.  This method inserts the image into a font texture and returns
        a glyph reference; it is up to the subclass to add metadata to the
        glyph.

        Applications should not use this method directly.

        :Parameters:
            `image` : `pyglet.image.AbstractImage`
                The image to write to the font texture.

        :rtype: `Glyph`
        '''
        glyph = None
        for texture in self.textures:
            glyph = texture.fit(image)
            if glyph:
                break
        if not glyph:
            if image.width > self.texture_width or \
               image.height > self.texture_height:
                texture = self.texture_class.create_for_size(GL_TEXTURE_2D,
                    image.width * 2, image.height * 2,
                    self.texture_internalformat)
                self.texture_width = texture.width
                self.texture_height = texture.height
            else:
                texture = self.texture_class.create_for_size(GL_TEXTURE_2D,
                    self.texture_width, self.texture_height,
                    self.texture_internalformat)
            self.textures.insert(0, texture)
            glyph = texture.fit(image)
        return glyph

    def get_glyphs(self, text):
        '''Create and return a list of Glyphs for `text`.

        If any characters do not have a known glyph representation in this
        font, a substitution will be made.

        :Parameters:
            `text` : str or unicode
                Text to render.

        :rtype: list of `Glyph`
        '''
        glyph_renderer = None
        glyphs = []         # glyphs that are committed.
        for c in get_grapheme_clusters(unicode(text)):
            # Get the glyph for 'c'.  Hide tabs (Windows and Linux render
            # boxes)
            if c == '\t':
                c = ' '
            if c not in self.glyphs:
                if not glyph_renderer:
                    glyph_renderer = self.glyph_renderer_class(self)
                self.glyphs[c] = glyph_renderer.render(c)
            glyphs.append(self.glyphs[c])
        return glyphs


    def get_glyphs_for_width(self, text, width):
        '''Return a list of glyphs for `text` that fit within the given width.

        If the entire text is larger than 'width', as much as possible will be
        used while breaking after a space or zero-width space character.  If a
        newline is encountered in text, only text up to that newline will be
        used.  If no break opportunities (newlines or spaces) occur within
        `width`, the text up to the first break opportunity will be used (this
        will exceed `width`).  If there are no break opportunities, the entire
        text will be used.

        You can assume that each character of the text is represented by
        exactly one glyph; so the amount of text "used up" can be determined
        by examining the length of the returned glyph list.

        :Parameters:
            `text` : str or unicode
                Text to render.
            `width` : int
                Maximum width of returned glyphs.

        :rtype: list of `Glyph`

        :see: `GlyphString`
        '''
        glyph_renderer = None
        glyph_buffer = []   # next glyphs to be added, as soon as a BP is found
        glyphs = []         # glyphs that are committed.
        for c in text:
            if c == '\n':
                glyphs += glyph_buffer
                break

            # Get the glyph for 'c'
            if c not in self.glyphs:
                if not glyph_renderer:
                    glyph_renderer = self.glyph_renderer_class(self)
                self.glyphs[c] = glyph_renderer.render(c)
            glyph = self.glyphs[c]

            # Add to holding buffer and measure
            glyph_buffer.append(glyph)
            width -= glyph.advance

            # If over width and have some committed glyphs, finish.
            if width <= 0 and len(glyphs) > 0:
                break

            # If a valid breakpoint, commit holding buffer
            if c in u'\u0020\u200b':
                glyphs += glyph_buffer
                glyph_buffer = []

        # If nothing was committed, commit everything (no breakpoints found).
        if len(glyphs) == 0:
            glyphs = glyph_buffer

        return glyphs



########NEW FILE########
__FILENAME__ = carbon
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

# TODO Tiger and later: need to set kWindowApplicationScaledAttribute for DPI
# independence?

from ctypes import *
import math
from sys import byteorder

from pyglet.font import base
import pyglet.image
from pyglet.window.carbon import carbon, _oscheck
from pyglet.window.carbon import _create_cfstring
from pyglet.window.carbon.types import *


class FixedPoint(Structure):
    _fields_ = [
        ('x', Fixed),
        ('y', Fixed)
    ]

class ATSTrapezoid(Structure):
    _fields_ = [
        ('upperLeft', FixedPoint),
        ('upperRight', FixedPoint),
        ('lowerRight', FixedPoint),
        ('lowerLeft', FixedPoint)
    ]

# TODO: most of the ATS and CG here not used any more.

CGGlyph = c_ushort
ATSUFontID = c_uint32
RGBColor = c_short * 3
ATSURGBAlphaColor = c_float * 4

kCGImageAlphaNone = 0
kCGImageAlphaPremultipliedLast = 1
kCGTextFill = 0

kATSUInvalidFontErr = -8796

kATSFontContextUnspecified = 0
kATSFontContextGlobal = 1
kATSFontContextLocal = 2

kATSFontFilterSelectorUnspecified = 0
kATSFontFilterSelectorGeneration = 3
kATSFontFilterSelectorFontFamily = 7
kATSFontFilterSelectorFontFamilyApplierFunction = 8
kATSFontFilterSelectorFontApplierFunction = 9

kATSOptionFlagsDoNotNotify = 0x00000001 << 8
kATSOptionFlagsIterationScopeMask = 0x00000007 << 12
kATSOptionFlagsDefaultScope = 0x00000000 << 12
kATSOptionFlagsUnRestrictedScope = 0x00000001 << 12
kATSOptionFlagsRestrictedScope = 0x00000002 << 12
kATSOptionFlagsProcessSubdirectories = 0x00000001 << 6

kATSUFromTextBeginning = c_ulong(0xFFFFFFFF)
kATSUToTextEnd = c_ulong(0xFFFFFFFF)

kATSULineAscentTag = 8
kATSULineDescentTag = 9
ATSUTextMeasurement = Fixed

kATSUQDBoldfaceTag            = 256
kATSUQDItalicTag              = 257
kATSUFontTag                  = 261
kATSUSizeTag                  = 262
kATSUCGContextTag             = 32767
kATSUColorTag                 = 263
kATSURGBAlphaColorTag         = 288

kATSULineWidthTag             = 1

kFontFullName                 = 4
kFontNoPlatformCode           = c_ulong(-1)
kFontNoScriptCode             = c_ulong(-1)
kFontNoLanguageCode           = c_ulong(-1)

kATSUseDeviceOrigins          = 1

kATSFontFormatUnspecified     = 0
kATSFontContextLocal          = 2

carbon.CGColorSpaceCreateWithName.restype = c_void_p
carbon.CGBitmapContextCreate.restype = POINTER(c_void_p)

UniCharArrayOffset  = c_uint32
UniCharCount = c_uint32

kATSULayoutOperationJustification = 1
kATSULayoutOperationPostLayoutAdjustment = 0x20
kATSULayoutOperationCallbackStatusHandled = 0
kATSULayoutOperationCallbackStatusContinue = c_long(1)
kATSULayoutOperationOverrideTag = 15
kATSUDirectDataAdvanceDeltaFixedArray = 0
kATSUDirectDataDeviceDeltaSInt16Array = 2
kATSUDirectDataLayoutRecordATSLayoutRecordVersion1 = 100

ATSUDirectLayoutOperationOverrideUPP = CFUNCTYPE(c_int,
    c_int, c_void_p, c_uint32, c_void_p, POINTER(c_int))

class ATSULayoutOperationOverrideSpecifier(Structure):
    _fields_ = [
        ('operationSelector', c_uint32),
        ('overrideUPP', ATSUDirectLayoutOperationOverrideUPP)
    ]

class ATSLayoutRecord(Structure):
    _pack_ = 2
    _fields_ = [
        ('glyphID', c_uint16),
        ('flags', c_uint32),
        ('originalOffset', c_uint32),
        ('realPos', Fixed),
    ]

def fixed(value):
    return c_int32(carbon.Long2Fix(c_long(int(value))))

carbon.Fix2X.restype = c_double
def fix2float(value):
    return carbon.Fix2X(value)

def create_atsu_style(attributes):
    # attributes is a dict of ATSUAttributeTag => ctypes value
    tags, values = zip(*attributes.items())
    tags = (c_int * len(tags))(*tags)
    sizes = (c_uint * len(values))(*[sizeof(v) for v in values])
    values = (c_void_p * len(values))(*[cast(pointer(v), c_void_p) \
                                        for v in values])

    style = c_void_p()
    carbon.ATSUCreateStyle(byref(style))
    carbon.ATSUSetAttributes(style, len(tags), tags, sizes, values)
    return style

def set_layout_attributes(layout, attributes):
    if attributes:
        # attributes is a dict of ATSUAttributeTag => ctypes value
        tags, values = zip(*attributes.items())
        tags = (c_int * len(tags))(*tags)
        sizes = (c_uint * len(values))(*[sizeof(v) for v in values])
        values = (c_void_p * len(values))(*[cast(pointer(v), c_void_p) \
                                            for v in values])

        r = carbon.ATSUSetLayoutControls(layout, len(tags), tags, sizes, values)
        _oscheck(r)

def str_ucs2(text):
    if byteorder == 'big':
        text = text.encode('utf_16_be')
    else:
        text = text.encode('utf_16_le')   # explicit endian avoids BOM
    return create_string_buffer(text + '\0')


class CarbonGlyphRenderer(base.GlyphRenderer):
    _bitmap = None
    _bitmap_context = None
    _bitmap_rect = None

    _glyph_advance = 0 # set through callback

    def __init__(self, font):
        super(CarbonGlyphRenderer, self).__init__(font)
        self._create_bitmap_context(256, 256)
        self.font = font

    def __del__(self):
        try:
            if self._bitmap_context:
                carbon.CGContextRelease(self._bitmap_context)
        except:
            pass

    def _layout_callback(self, operation, line, ref, extra, callback_status):
        records = c_void_p()
        n_records = c_uint()

        r = carbon.ATSUDirectGetLayoutDataArrayPtrFromLineRef(line,
            kATSUDirectDataLayoutRecordATSLayoutRecordVersion1,
            0,
            byref(records),
            byref(n_records))
        _oscheck(r)

        records = cast(records,
                       POINTER(ATSLayoutRecord * n_records.value)).contents
        self._glyph_advance = fix2float(records[-1].realPos)

        callback_status.contents = kATSULayoutOperationCallbackStatusContinue
        return 0

    def render(self, text):
        # Convert text to UCS2
        text_len = len(text)
        text_ucs2 = str_ucs2(text)

        # Create layout override handler to extract device advance value.
        override_spec = ATSULayoutOperationOverrideSpecifier()
        override_spec.operationSelector = \
            kATSULayoutOperationPostLayoutAdjustment
        override_spec.overrideUPP = \
            ATSUDirectLayoutOperationOverrideUPP(self._layout_callback)

        # Create ATSU text layout for this text and font
        layout = c_void_p()
        carbon.ATSUCreateTextLayout(byref(layout))
        set_layout_attributes(layout, {
            kATSUCGContextTag: self._bitmap_context,
            kATSULayoutOperationOverrideTag: override_spec})
        carbon.ATSUSetTextPointerLocation(layout,
            text_ucs2,
            kATSUFromTextBeginning,
            kATSUToTextEnd,
            text_len)
        carbon.ATSUSetRunStyle(layout, self.font.atsu_style,
            kATSUFromTextBeginning, kATSUToTextEnd)

        # Turning on transient font matching screws up font layout
        # predictability when strange fonts are installed
        # <ah> Don't believe this.  Can't get foreign/special characters
        #      without transient on.
        carbon.ATSUSetTransientFontMatching(layout, True)

        # Get bitmap dimensions required
        rect = Rect()
        carbon.ATSUMeasureTextImage(layout,
            kATSUFromTextBeginning,
            kATSUToTextEnd,
            0, 0,
            byref(rect))
        image_width = rect.right - rect.left + 2
        image_height = rect.bottom - rect.top + 2
        baseline = rect.bottom + 1
        lsb = rect.left

        # Resize Quartz context if necessary
        if (image_width > self._bitmap_rect.size.width or
            image_height > self._bitmap_rect.size.height):
            self._create_bitmap_context(
                int(max(image_width, self._bitmap_rect.size.width)),
                int(max(image_height, self._bitmap_rect.size.height)))

            set_layout_attributes(layout, {
                kATSUCGContextTag: self._bitmap_context})

        # Draw to the bitmap
        carbon.CGContextClearRect(self._bitmap_context, self._bitmap_rect)
        carbon.ATSUDrawText(layout,
            0,
            kATSUToTextEnd,
            fixed(-lsb + 1), fixed(baseline))

        advance = self._glyph_advance

        # Round advance to nearest int.  It actually looks good with sub-pixel
        # advance as well -- Helvetica at 12pt is more tightly spaced, but
        # Times New Roman at 12pt is too light.  With integer positioning
        # overall look seems darker and perhaps more uniform.  It's also more
        # similar (programmatically) to Win32 and FreeType.  Still, worth
        # messing around with (comment out next line) if you're interested.
        advance = int(round(advance))

        # Fix advance for zero-width space
        if text == u'\u200b':
            advance = 0

        # A negative pitch is required, but it is much faster to load the
        # glyph upside-down and flip the tex_coords.  Note region used
        # to start at top of glyph image.
        pitch = int(4 * self._bitmap_rect.size.width)
        image = pyglet.image.ImageData(image_width,
            self._bitmap_rect.size.height, 'RGBA', self._bitmap, pitch)
        skip_rows = int(self._bitmap_rect.size.height - image_height)
        image = image.get_region(0, skip_rows, image.width, image_height)
        glyph = self.font.create_glyph(image)
        glyph.set_bearings(baseline, lsb - 1, int(advance))
        t = list(glyph.tex_coords)
        glyph.tex_coords = t[9:12] + t[6:9] + t[3:6] + t[:3]

        return glyph

    def _create_bitmap_context(self, width, height):
        '''Create or recreate bitmap and Quartz context.'''
        if self._bitmap_context:
            carbon.CGContextRelease(self._bitmap_context)
        components = 4
        pitch = width * components
        self._bitmap = (c_ubyte * (pitch * height))()
        color_space = carbon.CGColorSpaceCreateDeviceRGB()
        context = carbon.CGBitmapContextCreate(self._bitmap,
            width, height, 8, pitch,
            color_space, kCGImageAlphaPremultipliedLast)
        carbon.CGColorSpaceRelease(color_space)

        # Disable RGB decimated antialiasing, use standard
        # antialiasing which won't break alpha.
        carbon.CGContextSetShouldSmoothFonts(context, False)
        carbon.CGContextSetShouldAntialias(context, True)

        self._bitmap_context = context
        self._bitmap_rect = CGRect()
        self._bitmap_rect.origin.x = 0
        self._bitmap_rect.origin.y = 0
        self._bitmap_rect.size.width = width
        self._bitmap_rect.size.height = height


class CarbonFont(base.Font):
    glyph_renderer_class = CarbonGlyphRenderer

    def __init__(self, name, size, bold=False, italic=False, dpi=None):
        super(CarbonFont, self).__init__()

        if not name:
            name = 'Helvetica'

        if dpi is None:
            dpi = 96 # pyglet 1.1; in pyglet 1.0 this was 72.

        # If application is not DPI-aware, DPI is fixed at 72.  Scale
        # font size to emulate other DPI.  This will need to be fixed if issue
        # #87 is implemented.
        size = size * dpi / 72.

        name = name.encode('ascii', 'ignore')

        font_id = ATSUFontID()
        carbon.ATSUFindFontFromName(
            name,
            len(name),
            kFontFullName,
            kFontNoPlatformCode,
            kFontNoScriptCode,
            kFontNoLanguageCode,
            byref(font_id))

        attributes = {
            kATSUSizeTag: fixed(size),
            kATSUFontTag: font_id,
            kATSURGBAlphaColorTag: ATSURGBAlphaColor(1, 1, 1, 1),
            kATSUQDBoldfaceTag: c_byte(bold),
            kATSUQDItalicTag: c_byte(italic)
        }
        self.atsu_style = create_atsu_style(attributes)

        self.calculate_metrics()

    @classmethod
    def have_font(cls, name):
        font_id = ATSUFontID()
        name = name.encode('ascii', 'ignore')
        r = carbon.ATSUFindFontFromName(
            name,
            len(name),
            kFontFullName,
            kFontNoPlatformCode,
            kFontNoScriptCode,
            kFontNoLanguageCode,
            byref(font_id))
        return r != kATSUInvalidFontErr

    def calculate_metrics(self):
        # It seems the only way to get the font's ascent and descent is to lay
        # out some glyphs and measure them.

        # fake ucs2 string
        text = '\0a'

        layout = c_void_p()
        carbon.ATSUCreateTextLayout(byref(layout))
        carbon.ATSUSetTextPointerLocation(layout, text,
            kATSUFromTextBeginning, kATSUToTextEnd, 1)
        carbon.ATSUSetRunStyle(layout, self.atsu_style,
            kATSUFromTextBeginning, kATSUToTextEnd)

        # determine the metrics for this font only
        carbon.ATSUSetTransientFontMatching(layout, False)

        value = ATSUTextMeasurement()
        carbon.ATSUGetLineControl(layout, 0, kATSULineAscentTag,
            sizeof(value), byref(value), None)
        self.ascent = int(math.ceil(fix2float(value)))
        carbon.ATSUGetLineControl(layout, 0, kATSULineDescentTag,
            sizeof(value), byref(value), None)
        self.descent = -int(math.ceil(fix2float(value)))

    @classmethod
    def add_font_data(cls, data):
        container = c_void_p()
        r = carbon.ATSFontActivateFromMemory(data, len(data),
            kATSFontContextLocal, kATSFontFormatUnspecified, None, 0,
            byref(container))
        _oscheck(r)

########NEW FILE########
__FILENAME__ = freetype
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: freetype.py 2496 2009-08-19 01:17:30Z benjamin.coder.smith $'

import ctypes
from ctypes import *
from warnings import warn

import pyglet.lib
from pyglet.font import base
from pyglet import image
from pyglet.font.freetype_lib import *

# fontconfig library definitions
fontconfig = pyglet.lib.load_library('fontconfig')

FcResult = c_int

fontconfig.FcPatternBuild.restype = c_void_p
fontconfig.FcFontMatch.restype = c_void_p
fontconfig.FcFreeTypeCharIndex.restype = c_uint

FC_FAMILY = 'family'
FC_SIZE = 'size'
FC_SLANT = 'slant'
FC_WEIGHT = 'weight'
FC_FT_FACE = 'ftface'
FC_FILE = 'file'

FC_WEIGHT_REGULAR = 80
FC_WEIGHT_BOLD = 200

FC_SLANT_ROMAN = 0
FC_SLANT_ITALIC = 100

FT_STYLE_FLAG_ITALIC = 1
FT_STYLE_FLAG_BOLD = 2

(FT_RENDER_MODE_NORMAL,
 FT_RENDER_MODE_LIGHT,
 FT_RENDER_MODE_MONO,
 FT_RENDER_MODE_LCD,
 FT_RENDER_MODE_LCD_V) = range(5)

def FT_LOAD_TARGET_(x):
    return (x & 15) << 16

FT_LOAD_TARGET_NORMAL = FT_LOAD_TARGET_(FT_RENDER_MODE_NORMAL)
FT_LOAD_TARGET_LIGHT = FT_LOAD_TARGET_(FT_RENDER_MODE_LIGHT)
FT_LOAD_TARGET_MONO = FT_LOAD_TARGET_(FT_RENDER_MODE_MONO)
FT_LOAD_TARGET_LCD = FT_LOAD_TARGET_(FT_RENDER_MODE_LCD)
FT_LOAD_TARGET_LCD_V = FT_LOAD_TARGET_(FT_RENDER_MODE_LCD_V)

(FT_PIXEL_MODE_NONE,
 FT_PIXEL_MODE_MONO,
 FT_PIXEL_MODE_GRAY,
 FT_PIXEL_MODE_GRAY2,
 FT_PIXEL_MODE_GRAY4,
 FT_PIXEL_MODE_LCD,
 FT_PIXEL_MODE_LCD_V) = range(7)

(FcTypeVoid,
 FcTypeInteger,
 FcTypeDouble,
 FcTypeString,
 FcTypeBool,
 FcTypeMatrix,
 FcTypeCharSet,
 FcTypeFTFace,
 FcTypeLangSet) = range(9)
FcType = c_int

(FcMatchPattern,
 FcMatchFont) = range(2)
FcMatchKind = c_int

class _FcValueUnion(Union):
    _fields_ = [
        ('s', c_char_p),
        ('i', c_int),
        ('b', c_int),
        ('d', c_double),
        ('m', c_void_p),
        ('c', c_void_p),
        ('f', c_void_p),
        ('p', c_void_p),
        ('l', c_void_p),
    ]

class FcValue(Structure):
    _fields_ = [
        ('type', FcType),
        ('u', _FcValueUnion)
    ]

# End of library definitions

def f16p16_to_float(value):
    return float(value) / (1 << 16)

def float_to_f16p16(value):
    return int(value * (1 << 16))

def f26p6_to_float(value):
    return float(value) / (1 << 6)

def float_to_f26p6(value):
    return int(value * (1 << 6))

class FreeTypeGlyphRenderer(base.GlyphRenderer):
    def __init__(self, font):
        super(FreeTypeGlyphRenderer, self).__init__(font)
        self.font = font

    def render(self, text):
        face = self.font.face
        FT_Set_Char_Size(face, 0, self.font._face_size,
                         self.font._dpi, self.font._dpi)
        glyph_index = fontconfig.FcFreeTypeCharIndex(byref(face), ord(text[0]))
        error = FT_Load_Glyph(face, glyph_index, FT_LOAD_RENDER)
        if error != 0:
            raise base.FontException(
                'Could not load glyph for "%c"' % text[0], error)
        glyph_slot = face.glyph.contents
        width = glyph_slot.bitmap.width
        height = glyph_slot.bitmap.rows
        baseline = height - glyph_slot.bitmap_top
        lsb = glyph_slot.bitmap_left
        advance = int(f26p6_to_float(glyph_slot.advance.x))
        mode = glyph_slot.bitmap.pixel_mode
        pitch = glyph_slot.bitmap.pitch

        if mode == FT_PIXEL_MODE_MONO:
            # BCF fonts always render to 1 bit mono, regardless of render
            # flags. (freetype 2.3.5)
            bitmap_data = cast(glyph_slot.bitmap.buffer,
                               POINTER(c_ubyte * (pitch * height))).contents
            data = (c_ubyte * (pitch * 8 * height))()
            data_i = 0
            for byte in bitmap_data:
                # Data is MSB; left-most pixel in a byte has value 128.
                data[data_i + 0] = (byte & 0x80) and 255 or 0
                data[data_i + 1] = (byte & 0x40) and 255 or 0
                data[data_i + 2] = (byte & 0x20) and 255 or 0
                data[data_i + 3] = (byte & 0x10) and 255 or 0
                data[data_i + 4] = (byte & 0x08) and 255 or 0
                data[data_i + 5] = (byte & 0x04) and 255 or 0
                data[data_i + 6] = (byte & 0x02) and 255 or 0
                data[data_i + 7] = (byte & 0x01) and 255 or 0
                data_i += 8
            pitch <<= 3
        elif mode == FT_PIXEL_MODE_GRAY:
            # Usual case
            data = glyph_slot.bitmap.buffer
        else:
            raise base.FontException('Unsupported render mode for this glyph')

        # pitch should be negative, but much faster to just swap tex_coords
        img = image.ImageData(width, height, 'A', data, pitch)
        glyph = self.font.create_glyph(img)
        glyph.set_bearings(baseline, lsb, advance)
        t = list(glyph.tex_coords)
        glyph.tex_coords = t[9:12] + t[6:9] + t[3:6] + t[:3]

        return glyph

class FreeTypeMemoryFont(object):
    def __init__(self, data):
        self.buffer = (ctypes.c_byte * len(data))()
        ctypes.memmove(self.buffer, data, len(data))

        ft_library = ft_get_library()
        self.face = FT_Face()
        r = FT_New_Memory_Face(ft_library,
            self.buffer, len(self.buffer), 0, self.face)
        if r != 0:
            raise base.FontException('Could not load font data')

        self.name = self.face.contents.family_name
        self.bold = self.face.contents.style_flags & FT_STYLE_FLAG_BOLD != 0
        self.italic = self.face.contents.style_flags & FT_STYLE_FLAG_ITALIC != 0

        # Replace Freetype's generic family name with TTF/OpenType specific
        # name if we can find one; there are some instances where Freetype
        # gets it wrong.
        if self.face.contents.face_flags & FT_FACE_FLAG_SFNT:
            name = FT_SfntName()
            for i in range(FT_Get_Sfnt_Name_Count(self.face)):
                result = FT_Get_Sfnt_Name(self.face, i, name)
                if result != 0:
                    continue
                if not (name.platform_id == TT_PLATFORM_MICROSOFT and
                        name.encoding_id == TT_MS_ID_UNICODE_CS):
                    continue
                if name.name_id == TT_NAME_ID_FONT_FAMILY:
                    string = string_at(name.string, name.string_len)
                    self.name = string.decode('utf-16be', 'ignore')

    def __del__(self):
        try:
            FT_Done_Face(self.face)
        except:
            pass

class FreeTypeFont(base.Font):
    glyph_renderer_class = FreeTypeGlyphRenderer

    # Map font (name, bold, italic) to FreeTypeMemoryFont
    _memory_fonts = {}

    def __init__(self, name, size, bold=False, italic=False, dpi=None):
        super(FreeTypeFont, self).__init__()

        if dpi is None:
            dpi = 96  # as of pyglet 1.1; pyglet 1.0 had 72.

        # Check if font name/style matches a font loaded into memory by user
        lname = name and name.lower() or ''
        if (lname, bold, italic) in self._memory_fonts:
            font = self._memory_fonts[lname, bold, italic]
            self._set_face(font.face, size, dpi)
            return

        # Use fontconfig to match the font (or substitute a default).
        ft_library = ft_get_library()

        match = self.get_fontconfig_match(name, size, bold, italic)
        if not match:
            raise base.FontException('Could not match font "%s"' % name)

        f = FT_Face()
        if fontconfig.FcPatternGetFTFace(match, FC_FT_FACE, 0, byref(f)) != 0:
            value = FcValue()
            result = fontconfig.FcPatternGet(match, FC_FILE, 0, byref(value))
            if result != 0:
                raise base.FontException('No filename or FT face for "%s"' % \
                                         name)
            result = FT_New_Face(ft_library, value.u.s, 0, byref(f))
            if result:
                raise base.FontException('Could not load "%s": %d' % \
                                         (name, result))

        fontconfig.FcPatternDestroy(match)

        self._set_face(f, size, dpi)

    def _set_face(self, face, size, dpi):
        self.face = face.contents
        self._face_size = float_to_f26p6(size)
        self._dpi = dpi

        FT_Set_Char_Size(self.face, 0, float_to_f26p6(size), dpi, dpi)
        metrics = self.face.size.contents.metrics
        if metrics.ascender == 0 and metrics.descender == 0:
            # Workaround broken fonts with no metrics.  Has been observed with
            # courR12-ISO8859-1.pcf.gz: "Courier" "Regular"
            #
            # None of the metrics fields are filled in, so render a glyph and
            # grab its height as the ascent, and make up an arbitrary
            # descent.
            i = fontconfig.FcFreeTypeCharIndex(byref(self.face), ord('X'))
            FT_Load_Glyph(self.face, i, FT_LOAD_RENDER)
            self.ascent = self.face.available_sizes.contents.height
            self.descent = -self.ascent // 4  # arbitrary.
        else:
            self.ascent = int(f26p6_to_float(metrics.ascender))
            self.descent = int(f26p6_to_float(metrics.descender))

    @staticmethod
    def get_fontconfig_match(name, size, bold, italic):
        if bold:
            bold = FC_WEIGHT_BOLD
        else:
            bold = FC_WEIGHT_REGULAR

        if italic:
            italic = FC_SLANT_ITALIC
        else:
            italic = FC_SLANT_ROMAN

        fontconfig.FcInit()

        if isinstance(name, unicode):
            name = name.encode('utf8')

        pattern = fontconfig.FcPatternCreate()
        fontconfig.FcPatternAddDouble(pattern, FC_SIZE, c_double(size))
        fontconfig.FcPatternAddInteger(pattern, FC_WEIGHT, bold)
        fontconfig.FcPatternAddInteger(pattern, FC_SLANT, italic)
        fontconfig.FcPatternAddString(pattern, FC_FAMILY, name)
        fontconfig.FcConfigSubstitute(0, pattern, FcMatchPattern)
        fontconfig.FcDefaultSubstitute(pattern)

        # Look for a font that matches pattern
        result = FcResult()
        match = fontconfig.FcFontMatch(0, pattern, byref(result))
        fontconfig.FcPatternDestroy(pattern)

        return match

    @classmethod
    def have_font(cls, name):
        value = FcValue()
        match = cls.get_fontconfig_match(name, 12, False, False)
        #result = fontconfig.FcPatternGet(match, FC_FAMILY, 0, byref(value))
        if value.u.s == name:
            return True
        else:
            name = name.lower()
            for font in cls._memory_fonts.values():
                if font.name.lower() == name:
                    return True
        return False

    @classmethod
    def add_font_data(cls, data):
        font = FreeTypeMemoryFont(data)
        cls._memory_fonts[font.name.lower(), font.bold, font.italic] = font

########NEW FILE########
__FILENAME__ = freetype_lib
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: freetype_lib.py 2496 2009-08-19 01:17:30Z benjamin.coder.smith $'

from ctypes import *
from base import FontException
import pyglet.lib

_libfreetype = pyglet.lib.load_library('freetype')

_font_data = {}

def _get_function(name, argtypes, rtype):
    try:
        func = getattr(_libfreetype, name)
        func.argtypes = argtypes
        func.restype = rtype
        return func
    except AttributeError, e:
            raise ImportError(e)

FT_Done_FreeType = _get_function('FT_Done_FreeType', [c_void_p], None)
FT_Done_Face = _get_function('FT_Done_Face', [c_void_p], None)


class FT_LibraryRec(Structure):
    _fields_ = [
        ('dummy', c_int),
    ]

    def __del__(self):
        global _library
        try:
            FT_Done_FreeType(byref(self))
            _library = None
        except:
            pass
FT_Library = POINTER(FT_LibraryRec)

class FT_Glyph_Metrics(Structure):
    _fields_ = [
        ('width', c_long),
        ('height', c_long),
        ('horiBearingX', c_long),
        ('horiBearingY', c_long),
        ('horiAdvance', c_long),
        ('vertBearingX', c_long),
        ('vertBearingY', c_long),
        ('vertAdvance', c_long),
    ]

    def dump(self):
        for (name, type) in self._fields_:
            print 'FT_Glyph_Metrics', name, `getattr(self, name)`

class FT_Generic(Structure):
    _fields_ = [('data', c_void_p), ('finalizer', c_void_p)]

class FT_BBox(Structure):
    _fields_ = [('xMin', c_long), ('yMin', c_long), ('xMax', c_long),
        ('yMax', c_long)]

class FT_Vector(Structure):
    _fields_ = [('x', c_long), ('y', c_long)]

class FT_Bitmap(Structure):
    _fields_ = [
        ('rows', c_int),
        ('width', c_int),
        ('pitch', c_int),
        # declaring buffer as c_char_p confuses ctypes, poor dear
        ('buffer', POINTER(c_ubyte)),
        ('num_grays', c_short),
        ('pixel_mode', c_ubyte),
        ('palette_mode', c_char),
        ('palette', c_void_p),
    ]

class FT_Outline(Structure):
    _fields_ = [
        ('n_contours', c_short),      # number of contours in glyph
        ('n_points', c_short),        # number of points in the glyph
        ('points', POINTER(FT_Vector)),  # the outline's points
        ('tags', c_char_p),            # the points flags
        ('contours', POINTER(c_short)),  # the contour end points
        ('flags', c_int),             # outline masks
    ]

class FT_GlyphSlotRec(Structure):
    _fields_ = [
        ('library', FT_Library),
        ('face', c_void_p),
        ('next', c_void_p),
        ('reserved', c_uint),
        ('generic', FT_Generic),

        ('metrics', FT_Glyph_Metrics),
        ('linearHoriAdvance', c_long),
        ('linearVertAdvance', c_long),
        ('advance', FT_Vector),

        ('format', c_int),

        ('bitmap', FT_Bitmap),
        ('bitmap_left', c_int),
        ('bitmap_top', c_int),

        ('outline', FT_Outline),
        ('num_subglyphs', c_uint),
        ('subglyphs', c_void_p),

        ('control_data', c_void_p),
        ('control_len', c_long),

        ('lsb_delta', c_long),
        ('rsb_delta', c_long),
        ('other', c_void_p),
        ('internal', c_void_p),
    ]
FT_GlyphSlot = POINTER(FT_GlyphSlotRec)

class FT_Size_Metrics(Structure):
    _fields_ = [
        ('x_ppem', c_ushort),    # horizontal pixels per EM
        ('y_ppem', c_ushort),    # vertical pixels per EM

        ('x_scale', c_long),     # two scales used to convert font units
        ('y_scale', c_long),     # to 26.6 frac. pixel coordinates

        ('ascender', c_long),    # ascender in 26.6 frac. pixels
        ('descender', c_long),   # descender in 26.6 frac. pixels
        ('height', c_long),      # text height in 26.6 frac. pixels
        ('max_advance', c_long), # max horizontal advance, in 26.6 pixels
    ]

class FT_SizeRec(Structure):
    _fields_ = [
        ('face', c_void_p),
        ('generic', FT_Generic),
        ('metrics', FT_Size_Metrics),
        ('internal', c_void_p),
    ]
FT_Size = POINTER(FT_SizeRec)

class FT_Bitmap_Size(Structure):
    _fields_ = [
        ('height', c_ushort),
        ('width', c_ushort),
        ('size', c_long),
        ('x_ppem', c_long),
        ('y_ppem', c_long),
    ]

# face_flags values
FT_FACE_FLAG_SCALABLE          = 1 <<  0
FT_FACE_FLAG_FIXED_SIZES       = 1 <<  1
FT_FACE_FLAG_FIXED_WIDTH       = 1 <<  2
FT_FACE_FLAG_SFNT              = 1 <<  3
FT_FACE_FLAG_HORIZONTAL        = 1 <<  4
FT_FACE_FLAG_VERTICAL          = 1 <<  5
FT_FACE_FLAG_KERNING           = 1 <<  6
FT_FACE_FLAG_FAST_GLYPHS       = 1 <<  7
FT_FACE_FLAG_MULTIPLE_MASTERS  = 1 <<  8
FT_FACE_FLAG_GLYPH_NAMES       = 1 <<  9
FT_FACE_FLAG_EXTERNAL_STREAM   = 1 << 10
FT_FACE_FLAG_HINTER            = 1 << 11

class FT_FaceRec(Structure):
    _fields_ = [
          ('num_faces', c_long),
          ('face_index', c_long),

          ('face_flags', c_long),
          ('style_flags', c_long),

          ('num_glyphs', c_long),
          ('family_name', c_char_p),
          ('style_name', c_char_p),

          ('num_fixed_sizes', c_int),
          ('available_sizes', POINTER(FT_Bitmap_Size)),

          ('num_charmaps', c_int),
          ('charmaps', c_void_p),

          ('generic', FT_Generic),

          ('bbox', FT_BBox),

          ('units_per_EM', c_ushort),
          ('ascender', c_short),
          ('descender', c_short),
          ('height', c_short),

          ('max_advance_width', c_short),
          ('max_advance_height', c_short),

          ('underline_position', c_short),
          ('underline_thickness', c_short),

          ('glyph', FT_GlyphSlot),
          ('size', FT_Size),
          ('charmap', c_void_p),

          ('driver', c_void_p),
          ('memory', c_void_p),
          ('stream', c_void_p),

          ('sizes_list_head', c_void_p),
          ('sizes_list_tail', c_void_p),

          ('autohint', FT_Generic),
          ('extensions', c_void_p),
          ('internal', c_void_p),
    ]

    def dump(self):
        for (name, type) in self._fields_:
            print 'FT_FaceRec', name, `getattr(self, name)`

    def has_kerning(self):
        return self.face_flags & FT_FACE_FLAG_KERNING

FT_Face = POINTER(FT_FaceRec)

class Error(Exception):
    def __init__(self, message, errcode):
        self.message = message
        self.errcode = errcode

    def __str__(self):
        return '%s: %s (%s)'%(self.__class__.__name__, self.message,
            self._ft_errors.get(self.errcode, 'unknown error'))
    _ft_errors = {
        0x00: "no error" ,
        0x01: "cannot open resource" ,
        0x02: "unknown file format" ,
        0x03: "broken file" ,
        0x04: "invalid FreeType version" ,
        0x05: "module version is too low" ,
        0x06: "invalid argument" ,
        0x07: "unimplemented feature" ,
        0x08: "broken table" ,
        0x09: "broken offset within table" ,
        0x10: "invalid glyph index" ,
        0x11: "invalid character code" ,
        0x12: "unsupported glyph image format" ,
        0x13: "cannot render this glyph format" ,
        0x14: "invalid outline" ,
        0x15: "invalid composite glyph" ,
        0x16: "too many hints" ,
        0x17: "invalid pixel size" ,
        0x20: "invalid object handle" ,
        0x21: "invalid library handle" ,
        0x22: "invalid module handle" ,
        0x23: "invalid face handle" ,
        0x24: "invalid size handle" ,
        0x25: "invalid glyph slot handle" ,
        0x26: "invalid charmap handle" ,
        0x27: "invalid cache manager handle" ,
        0x28: "invalid stream handle" ,
        0x30: "too many modules" ,
        0x31: "too many extensions" ,
        0x40: "out of memory" ,
        0x41: "unlisted object" ,
        0x51: "cannot open stream" ,
        0x52: "invalid stream seek" ,
        0x53: "invalid stream skip" ,
        0x54: "invalid stream read" ,
        0x55: "invalid stream operation" ,
        0x56: "invalid frame operation" ,
        0x57: "nested frame access" ,
        0x58: "invalid frame read" ,
        0x60: "raster uninitialized" ,
        0x61: "raster corrupted" ,
        0x62: "raster overflow" ,
        0x63: "negative height while rastering" ,
        0x70: "too many registered caches" ,
        0x80: "invalid opcode" ,
        0x81: "too few arguments" ,
        0x82: "stack overflow" ,
        0x83: "code overflow" ,
        0x84: "bad argument" ,
        0x85: "division by zero" ,
        0x86: "invalid reference" ,
        0x87: "found debug opcode" ,
        0x88: "found ENDF opcode in execution stream" ,
        0x89: "nested DEFS" ,
        0x8A: "invalid code range" ,
        0x8B: "execution context too long" ,
        0x8C: "too many function definitions" ,
        0x8D: "too many instruction definitions" ,
        0x8E: "SFNT font table missing" ,
        0x8F: "horizontal header (hhea, table missing" ,
        0x90: "locations (loca, table missing" ,
        0x91: "name table missing" ,
        0x92: "character map (cmap, table missing" ,
        0x93: "horizontal metrics (hmtx, table missing" ,
        0x94: "PostScript (post, table missing" ,
        0x95: "invalid horizontal metrics" ,
        0x96: "invalid character map (cmap, format" ,
        0x97: "invalid ppem value" ,
        0x98: "invalid vertical metrics" ,
        0x99: "could not find context" ,
        0x9A: "invalid PostScript (post, table format" ,
        0x9B: "invalid PostScript (post, table" ,
        0xA0: "opcode syntax error" ,
        0xA1: "argument stack underflow" ,
        0xA2: "ignore" ,
        0xB0: "`STARTFONT' field missing" ,
        0xB1: "`FONT' field missing" ,
        0xB2: "`SIZE' field missing" ,
        0xB3: "`CHARS' field missing" ,
        0xB4: "`STARTCHAR' field missing" ,
        0xB5: "`ENCODING' field missing" ,
        0xB6: "`BBX' field missing" ,
        0xB7: "`BBX' too big" ,
    }

FT_LOAD_RENDER = 0x4

FT_F26Dot6 = c_long

FT_Init_FreeType = _get_function('FT_Init_FreeType',
    [POINTER(FT_Library)], c_int)
FT_New_Memory_Face = _get_function('FT_New_Memory_Face',
    [FT_Library, POINTER(c_byte), c_long, c_long, POINTER(FT_Face)], c_int)
FT_New_Face = _get_function('FT_New_Face',
    [FT_Library, c_char_p, c_long, POINTER(FT_Face)], c_int)
FT_Set_Pixel_Sizes = _get_function('FT_Set_Pixel_Sizes',
    [FT_Face, c_uint, c_uint], c_int)
FT_Set_Char_Size = _get_function('FT_Set_Char_Size',
    [FT_Face, FT_F26Dot6, FT_F26Dot6, c_uint, c_uint], c_int)
FT_Load_Glyph = _get_function('FT_Load_Glyph',
    [FT_Face, c_uint, c_int32], c_int)
FT_Get_Char_Index = _get_function('FT_Get_Char_Index',
    [FT_Face, c_ulong], c_uint)
FT_Load_Char = _get_function('FT_Load_Char',
    [FT_Face, c_ulong, c_int], c_int)
FT_Get_Kerning = _get_function('FT_Get_Kerning',
    [FT_Face, c_uint, c_uint, c_uint, POINTER(FT_Vector)], c_int)

# SFNT interface

class FT_SfntName(Structure):
    _fields_ = [
        ('platform_id', c_ushort),
        ('encoding_id', c_ushort),
        ('language_id', c_ushort),
        ('name_id', c_ushort),
        ('string', POINTER(c_byte)),
        ('string_len', c_uint)
    ]

FT_Get_Sfnt_Name_Count = _get_function('FT_Get_Sfnt_Name_Count',
    [FT_Face], c_uint)
FT_Get_Sfnt_Name = _get_function('FT_Get_Sfnt_Name',
    [FT_Face, c_uint, POINTER(FT_SfntName)], c_int)

TT_PLATFORM_MICROSOFT = 3
TT_MS_ID_UNICODE_CS = 1
TT_NAME_ID_COPYRIGHT          = 0
TT_NAME_ID_FONT_FAMILY        = 1
TT_NAME_ID_FONT_SUBFAMILY     = 2
TT_NAME_ID_UNIQUE_ID          = 3
TT_NAME_ID_FULL_NAME          = 4
TT_NAME_ID_VERSION_STRING     = 5
TT_NAME_ID_PS_NAME            = 6
TT_NAME_ID_TRADEMARK          = 7
TT_NAME_ID_MANUFACTURER       = 8
TT_NAME_ID_DESIGNER           = 9
TT_NAME_ID_DESCRIPTION        = 10
TT_NAME_ID_VENDOR_URL         = 11
TT_NAME_ID_DESIGNER_URL       = 12
TT_NAME_ID_LICENSE            = 13
TT_NAME_ID_LICENSE_URL        = 14
TT_NAME_ID_PREFERRED_FAMILY   = 16
TT_NAME_ID_PREFERRED_SUBFAMILY= 17
TT_NAME_ID_MAC_FULL_NAME      = 18
TT_NAME_ID_CID_FINDFONT_NAME  = 20

_library = None
def ft_get_library():
    global _library
    if not _library:
        _library = FT_Library()
        error = FT_Init_FreeType(byref(_library))
        if error:
            raise FontException(
                'an error occurred during library initialization', error)
    return _library

########NEW FILE########
__FILENAME__ = ttf
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
# $Id: ttf.py 2541 2009-12-31 04:31:11Z benjamin.coder.smith@gmail.com $

"""
Implementation of the Truetype file format.

Typical applications will not need to use this module directly; look at
`pyglyph.font` instead.

References:
 * http://developer.apple.com/fonts/TTRefMan/RM06
 * http://www.microsoft.com/typography/otspec
"""

__docformat__ = 'restructuredtext'
__version__ = '$Id: ttf.py 2541 2009-12-31 04:31:11Z benjamin.coder.smith@gmail.com $'

import codecs
import os
import mmap
import struct

class TruetypeInfo:
    """Information about a single Truetype face.

    The class memory-maps the font file to read the tables, so
    it is vital that you call the `close` method to avoid large memory
    leaks.  Once closed, you cannot call any of the ``get_*`` methods.

    Not all tables have been implemented yet (or likely ever will).
    Currently only the name and metric tables are read; in particular
    there is no glyph or hinting information.
    """

    _name_id_lookup = {
        'copyright': 0,
        'family': 1,
        'subfamily': 2,
        'identifier': 3,
        'name': 4,
        'version': 5,
        'postscript': 6,
        'trademark': 7,
        'manufacturer': 8,
        'designer': 9,
        'description': 10,
        'vendor-url': 11,
        'designer-url': 12,
        'license': 13,
        'license-url': 14,
        'preferred-family': 16,
        'preferred-subfamily': 17,
        'compatible-name': 18,
        'sample': 19,
    }

    _platform_id_lookup = {
        'unicode': 0,
        'macintosh': 1,
        'iso': 2,
        'microsoft': 3,
        'custom': 4
    }

    _microsoft_encoding_lookup = {
        1: 'utf_16_be',
        2: 'shift_jis',
        4: 'big5',
        6: 'johab',
        10: 'utf_16_be'
    }

    _macintosh_encoding_lookup = {
        0: 'mac_roman'
    }

    def __init__(self, filename):
        """Read the given TrueType file.

        :Parameters:
            `filename`
                The name of any Windows, OS2 or Macintosh Truetype file.

        The object must be closed (see `close`) after use.

        An exception will be raised if the file does not exist or cannot
        be read.
        """
        if not filename: filename = ''
        len = os.stat(filename).st_size
        self._fileno = os.open(filename, os.O_RDONLY)
        if hasattr(mmap, 'MAP_SHARED'):
            self._data = mmap.mmap(self._fileno, len, mmap.MAP_SHARED,
                mmap.PROT_READ)
        else:
            self._data = mmap.mmap(self._fileno, len, None, mmap.ACCESS_READ)

        offsets = _read_offset_table(self._data, 0)
        self._tables = {}
        for table in _read_table_directory_entry.array(self._data,
            offsets.size, offsets.num_tables):
            self._tables[table.tag] = table

        self._names = None
        self._horizontal_metrics = None
        self._character_advances = None
        self._character_kernings = None
        self._glyph_kernings = None
        self._character_map = None
        self._glyph_map = None
        self._font_selection_flags = None

        self.header = \
            _read_head_table(self._data, self._tables['head'].offset)
        self.horizontal_header = \
            _read_horizontal_header(self._data, self._tables['hhea'].offset)

    def get_font_selection_flags(self):
        """Return the font selection flags, as defined in OS/2 table"""
        if not self._font_selection_flags:
            OS2_table = \
                _read_OS2_table(self._data, self._tables['OS/2'].offset)
            self._font_selection_flags = OS2_table.fs_selection
        return self._font_selection_flags

    def is_bold(self):
        """Returns True iff the font describes itself as bold."""
        return bool(self.get_font_selection_flags() & 0x20)

    def is_italic(self):
        """Returns True iff the font describes itself as italic."""
        return bool(self.get_font_selection_flags() & 0x1)

    def get_names(self):
        """Returns a dictionary of names defined in the file.

        The key of each item is a tuple of ``platform_id``, ``name_id``,
        where each ID is the number as described in the Truetype format.

        The value of each item is a tuple of
        ``encoding_id``, ``language_id``, ``value``, where ``value`` is
        an encoded string.
        """
        if self._names:
            return self._names
        naming_table = \
            _read_naming_table(self._data, self._tables['name'].offset)
        name_records = \
            _read_name_record.array(self._data,
                self._tables['name'].offset + naming_table.size,
                naming_table.count)
        storage = naming_table.string_offset + self._tables['name'].offset
        self._names = {}
        for record in name_records:
            value = self._data[record.offset + storage:\
                               record.offset + storage + record.length]
            key = record.platform_id, record.name_id
            value = (record.encoding_id, record.language_id, value)
            if not key in self._names:
                self._names[key] = []
            self._names[key].append(value)
        return self._names

    def get_name(self, name, platform=None, languages=None):
        """Returns the value of the given name in this font.

        :Parameters:
            `name`
                Either an integer, representing the name_id desired (see
                font format); or a string describing it, see below for
                valid names.
            `platform`
                Platform for the requested name.  Can be the integer ID,
                or a string describing it.  By default, the Microsoft
                platform is searched first, then Macintosh.
            `languages`
                A list of language IDs to search.  The first language
                which defines the requested name will be used.  By default,
                all English dialects are searched.

        If the name is not found, ``None`` is returned.  If the name
        is found, the value will be decoded and returned as a unicode
        string.  Currently only some common encodings are supported.

        Valid names to request are (supply as a string)::

            'copyright'
            'family'
            'subfamily'
            'identifier'
            'name'
            'version'
            'postscript'
            'trademark'
            'manufacturer'
            'designer'
            'description'
            'vendor-url'
            'designer-url'
            'license'
            'license-url'
            'preferred-family'
            'preferred-subfamily'
            'compatible-name'
            'sample'

        Valid platforms to request are (supply as a string)::

            'unicode'
            'macintosh'
            'iso'
            'microsoft'
            'custom'
        """

        names = self.get_names()
        if type(name) == str:
            name = self._name_id_lookup[name]
        if not platform:
            for platform in ('microsoft','macintosh'):
                value = self.get_name(name, platform, languages)
                if value:
                    return value
        if type(platform) == str:
            platform = self._platform_id_lookup[platform]
        if not (platform, name) in names:
            return None

        if platform == 3: # setup for microsoft
            encodings = self._microsoft_encoding_lookup
            if not languages:
                # Default to english languages for microsoft
                languages = (0x409,0x809,0xc09,0x1009,0x1409,0x1809)
        elif platform == 1: # setup for macintosh
            encodings = self.__macintosh_encoding_lookup
            if not languages:
                # Default to english for macintosh
                languages = (0,)

        for record in names[(platform, name)]:
            if record[1] in languages and record[0] in encodings:
                decoder = codecs.getdecoder(encodings[record[0]])
                return decoder(record[2])[0]
        return None

    def get_horizontal_metrics(self):
        """Return all horizontal metric entries in table format."""
        if not self._horizontal_metrics:
            ar = _read_long_hor_metric.array(self._data,
                 self._tables['hmtx'].offset,
                 self.horizontal_header.number_of_h_metrics)
            self._horizontal_metrics = ar
        return self._horizontal_metrics

    def get_character_advances(self):
        """Return a dictionary of character->advance.

        They key of the dictionary is a unit-length unicode string,
        and the value is a float giving the horizontal advance in
        em.
        """
        if self._character_advances:
            return self._character_advances
        ga = self.get_glyph_advances()
        gmap = self.get_glyph_map()
        self._character_advances = {}
        for i in range(len(ga)):
            if i in gmap and not gmap[i] in self._character_advances:
                self._character_advances[gmap[i]] = ga[i]
        return self._character_advances

    def get_glyph_advances(self):
        """Return a dictionary of glyph->advance.

        They key of the dictionary is the glyph index and the value is a float
        giving the horizontal advance in em.
        """
        hm = self.get_horizontal_metrics()
        return [float(m.advance_width) / self.header.units_per_em for m in hm]

    def get_character_kernings(self):
        """Return a dictionary of (left,right)->kerning

        The key of the dictionary is a tuple of ``(left, right)``
        where each element is a unit-length unicode string.  The
        value of the dictionary is the horizontal pairwise kerning
        in em.
        """
        if not self._character_kernings:
            gmap = self.get_glyph_map()
            kerns = self.get_glyph_kernings()
            self._character_kernings = {}
            for pair, value in kerns.items():
                lglyph, rglyph = pair
                lchar = lglyph in gmap and gmap[lglyph] or None
                rchar = rglyph in gmap and gmap[rglyph] or None
                if lchar and rchar:
                    self._character_kernings[(lchar, rchar)] = value
        return self._character_kernings

    def get_glyph_kernings(self):
        """Return a dictionary of (left,right)->kerning

        The key of the dictionary is a tuple of ``(left, right)``
        where each element is a glyph index.  The value of the dictionary is
        the horizontal pairwise kerning in em.
        """
        if self._glyph_kernings:
            return self._glyph_kernings
        header = \
            _read_kern_header_table(self._data, self._tables['kern'].offset)
        offset = self._tables['kern'].offset + header.size
        kernings = {}
        for i in range(header.n_tables):
            header = _read_kern_subtable_header(self._data, offset)
            if header.coverage & header.horizontal_mask \
               and not header.coverage & header.minimum_mask \
               and not header.coverage & header.perpendicular_mask:
                if header.coverage & header.format_mask == 0:
                    self._add_kernings_format0(kernings, offset + header.size)
            offset += header.length
        self._glyph_kernings = kernings
        return kernings

    def _add_kernings_format0(self, kernings, offset):
        header = _read_kern_subtable_format0(self._data, offset)
        kerning_pairs = _read_kern_subtable_format0Pair.array(self._data,
            offset + header.size, header.n_pairs)
        for pair in kerning_pairs:
            if (pair.left, pair.right) in kernings:
                kernings[(pair.left, pair.right)] += pair.value \
                    / float(self.header.units_per_em)
            else:
                kernings[(pair.left, pair.right)] = pair.value \
                    / float(self.header.units_per_em)

    def get_glyph_map(self):
        """Calculate and return a reverse character map.

        Returns a dictionary where the key is a glyph index and the
        value is a unit-length unicode string.
        """
        if self._glyph_map:
            return self._glyph_map
        cmap = self.get_character_map()
        self._glyph_map = {}
        for ch, glyph in cmap.items():
            if not glyph in self._glyph_map:
                self._glyph_map[glyph] = ch
        return self._glyph_map

    def get_character_map(self):
        """Return the character map.

        Returns a dictionary where the key is a unit-length unicode
        string and the value is a glyph index.  Currently only
        format 4 character maps are read.
        """
        if self._character_map:
            return self._character_map
        cmap = _read_cmap_header(self._data, self._tables['cmap'].offset)
        records = _read_cmap_encoding_record.array(self._data,
            self._tables['cmap'].offset + cmap.size, cmap.num_tables)
        self._character_map = {}
        for record in records:
            if record.platform_id == 3 and record.encoding_id == 1:
                # Look at Windows Unicode charmaps only
                offset = self._tables['cmap'].offset + record.offset
                format_header = _read_cmap_format_header(self._data, offset)
                if format_header.format == 4:
                    self._character_map = \
                        self._get_character_map_format4(offset)
                    break
        return self._character_map

    def _get_character_map_format4(self, offset):
        # This is absolutely, without question, the *worst* file
        # format ever.  Whoever the fuckwit is that thought this up is
        # a fuckwit.
        header = _read_cmap_format4Header(self._data, offset)
        seg_count = header.seg_count_x2 / 2
        array_size = struct.calcsize('>%dH' % seg_count)
        end_count = self._read_array('>%dH' % seg_count,
            offset + header.size)
        start_count = self._read_array('>%dH' % seg_count,
            offset + header.size + array_size + 2)
        id_delta = self._read_array('>%dh' % seg_count,
            offset + header.size + array_size + 2 + array_size)
        id_range_offset_address = \
            offset + header.size + array_size + 2 + array_size + array_size
        id_range_offset = self._read_array('>%dH' % seg_count,
            id_range_offset_address)
        character_map = {}
        for i in range(0, seg_count):
            if id_range_offset[i] != 0:
                if id_range_offset[i] == 65535:
                    continue  # Hack around a dodgy font (babelfish.ttf)
                for c in range(start_count[i], end_count[i] + 1):
                    addr = id_range_offset[i] + 2*(c - start_count[i]) + \
                        id_range_offset_address + 2*i
                    g = struct.unpack('>H', self._data[addr:addr+2])[0]
                    if g != 0:
                        character_map[unichr(c)] = (g + id_delta[i]) % 65536
            else:
                for c in range(start_count[i], end_count[i] + 1):
                    g = (c + id_delta[i]) % 65536
                    if g != 0:
                        character_map[unichr(c)] = g
        return character_map

    def _read_array(self, format, offset):
        size = struct.calcsize(format)
        return struct.unpack(format, self._data[offset:offset+size])

    def close(self):
        """Close the font file.

        This is a good idea, since the entire file is memory mapped in
        until this method is called.  After closing cannot rely on the
        ``get_*`` methods.
        """

        self._data.close()
        os.close(self._fileno)

def _read_table(*entries):
    """ Generic table constructor used for table formats listed at
    end of file."""
    fmt = '>'
    names = []
    for entry in entries:
        name, type = entry.split(':')
        names.append(name)
        fmt += type
    class _table_class:
        size = struct.calcsize(fmt)
        def __init__(self, data, offset):
            items = struct.unpack(fmt, data[offset:offset+self.size])
            self.pairs = zip(names, items)
            for name, value in self.pairs:
                setattr(self, name, value)

        def __repr__(self):
            s = '{' +  ', '.join(['%s = %s' % (name, value) \
                                  for name, value in self.pairs]) + '}'
            return s

        @staticmethod
        def array(data, offset, count):
            tables = []
            for i in range(count):
                tables.append(_table_class(data, offset))
                offset += _table_class.size
            return tables

    return _table_class


# Table formats (see references)

_read_offset_table = _read_table('scalertype:I',
                        'num_tables:H',
                        'search_range:H',
                        'entry_selector:H',
                        'range_shift:H')

_read_table_directory_entry = _read_table('tag:4s',
                                'check_sum:I',
                                'offset:I',
                                'length:I')
_read_head_table = _read_table('version:i',
                          'font_revision:i',
                          'check_sum_adjustment:L',
                          'magic_number:L',
                          'flags:H',
                          'units_per_em:H',
                          'created:Q',
                          'modified:Q',
                          'x_min:h',
                          'y_min:h',
                          'x_max:h',
                          'y_max:h',
                          'mac_style:H',
                          'lowest_rec_p_pEM:H',
                          'font_direction_hint:h',
                          'index_to_loc_format:h',
                          'glyph_data_format:h')

_read_OS2_table = _read_table('version:H',
                         'x_avg_char_width:h',
                         'us_weight_class:H',
                         'us_width_class:H',
                         'fs_type:H',
                         'y_subscript_x_size:h',
                         'y_subscript_y_size:h',
                         'y_subscript_x_offset:h',
                         'y_subscript_y_offset:h',
                         'y_superscript_x_size:h',
                         'y_superscript_y_size:h',
                         'y_superscript_x_offset:h',
                         'y_superscript_y_offset:h',
                         'y_strikeout_size:h',
                         'y_strikeout_position:h',
                         's_family_class:h',
                         'panose1:B',
                         'panose2:B',
                         'panose3:B',
                         'panose4:B',
                         'panose5:B',
                         'panose6:B',
                         'panose7:B',
                         'panose8:B',
                         'panose9:B',
                         'panose10:B',
                         'ul_unicode_range1:L',
                         'ul_unicode_range2:L',
                         'ul_unicode_range3:L',
                         'ul_unicode_range4:L',
                         'ach_vend_id:I',
                         'fs_selection:H',
                         'us_first_char_index:H',
                         'us_last_char_index:H',
                         's_typo_ascender:h',
                         's_typo_descender:h',
                         's_typo_line_gap:h',
                         'us_win_ascent:H',
                         'us_win_descent:H',
                         'ul_code_page_range1:L',
                         'ul_code_page_range2:L',
                         'sx_height:h',
                         's_cap_height:h',
                         'us_default_char:H',
                         'us_break_char:H',
                         'us_max_context:H')

_read_kern_header_table = _read_table('version_num:H',
                                'n_tables:H')

_read_kern_subtable_header = _read_table('version:H',
                                   'length:H',
                                   'coverage:H')
_read_kern_subtable_header.horizontal_mask = 0x1
_read_kern_subtable_header.minimum_mask = 0x2
_read_kern_subtable_header.perpendicular_mask = 0x4
_read_kern_subtable_header.override_mask = 0x5
_read_kern_subtable_header.format_mask = 0xf0

_read_kern_subtable_format0 = _read_table('n_pairs:H',
                                    'search_range:H',
                                    'entry_selector:H',
                                    'range_shift:H')
_read_kern_subtable_format0Pair = _read_table('left:H',
                                        'right:H',
                                        'value:h')

_read_cmap_header = _read_table('version:H',
                           'num_tables:H')

_read_cmap_encoding_record = _read_table('platform_id:H',
                                   'encoding_id:H',
                                   'offset:L')

_read_cmap_format_header = _read_table('format:H',
                                 'length:H')
_read_cmap_format4Header = _read_table('format:H',
                                  'length:H',
                                  'language:H',
                                  'seg_count_x2:H',
                                  'search_range:H',
                                  'entry_selector:H',
                                  'range_shift:H')

_read_horizontal_header = _read_table('version:i',
                                 'Advance:h',
                                 'Descender:h',
                                 'LineGap:h',
                                 'advance_width_max:H',
                                 'min_left_side_bearing:h',
                                 'min_right_side_bearing:h',
                                 'x_max_extent:h',
                                 'caret_slope_rise:h',
                                 'caret_slope_run:h',
                                 'caret_offset:h',
                                 'reserved1:h',
                                 'reserved2:h',
                                 'reserved3:h',
                                 'reserved4:h',
                                 'metric_data_format:h',
                                 'number_of_h_metrics:H')

_read_long_hor_metric = _read_table('advance_width:H',
                              'lsb:h')

_read_naming_table = _read_table('format:H',
                            'count:H',
                            'string_offset:H')

_read_name_record = _read_table('platform_id:H',
                           'encoding_id:H',
                           'language_id:H',
                           'name_id:H',
                           'length:H',
                           'offset:H')

########NEW FILE########
__FILENAME__ = win32
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

# TODO Windows Vista: need to call SetProcessDPIAware?  May affect GDI+ calls
# as well as font.

from ctypes import *
import ctypes
import math

from sys import byteorder
import pyglet
from pyglet.font import base
import pyglet.image
from pyglet.window.win32.constants import *
from pyglet.window.win32.types import *
from pyglet.window.win32 import _gdi32 as gdi32, _user32 as user32
from pyglet.window.win32 import _kernel32 as kernel32

_debug_font = pyglet.options['debug_font']

HFONT = HANDLE
HBITMAP = HANDLE
HDC = HANDLE
HGDIOBJ = HANDLE
gdi32.CreateFontIndirectA.restype = HFONT
gdi32.CreateCompatibleBitmap.restype = HBITMAP
gdi32.CreateCompatibleDC.restype = HDC
user32.GetDC.restype = HDC
gdi32.GetStockObject.restype = HGDIOBJ
gdi32.CreateDIBSection.restype = HBITMAP

class LOGFONT(Structure):
    _fields_ = [
        ('lfHeight', c_long),
        ('lfWidth', c_long),
        ('lfEscapement', c_long),
        ('lfOrientation', c_long),
        ('lfWeight', c_long),
        ('lfItalic', c_byte),
        ('lfUnderline', c_byte),
        ('lfStrikeOut', c_byte),
        ('lfCharSet', c_byte),
        ('lfOutPrecision', c_byte),
        ('lfClipPrecision', c_byte),
        ('lfQuality', c_byte),
        ('lfPitchAndFamily', c_byte),
        ('lfFaceName', (c_char * LF_FACESIZE))  # Use ASCII
    ]
    __slots__ = [f[0] for f in _fields_]

class TEXTMETRIC(Structure):
    _fields_ = [
        ('tmHeight', c_long),
        ('tmAscent', c_long),
        ('tmDescent', c_long),
        ('tmInternalLeading', c_long),
        ('tmExternalLeading', c_long),
        ('tmAveCharWidth', c_long),
        ('tmMaxCharWidth', c_long),
        ('tmWeight', c_long),
        ('tmOverhang', c_long),
        ('tmDigitizedAspectX', c_long),
        ('tmDigitizedAspectY', c_long),
        ('tmFirstChar', c_char),  # Use ASCII
        ('tmLastChar', c_char),
        ('tmDefaultChar', c_char),
        ('tmBreakChar', c_char),
        ('tmItalic', c_byte),
        ('tmUnderlined', c_byte),
        ('tmStruckOut', c_byte),
        ('tmPitchAndFamily', c_byte),
        ('tmCharSet', c_byte)
    ]
    __slots__ = [f[0] for f in _fields_]

class ABC(Structure):
    _fields_ = [
        ('abcA', c_int),
        ('abcB', c_uint),
        ('abcC', c_int)
    ]
    __slots__ = [f[0] for f in _fields_]

class BITMAPINFOHEADER(Structure):
    _fields_ = [
        ('biSize', c_uint32),
        ('biWidth', c_int),
        ('biHeight', c_int),
        ('biPlanes', c_short),
        ('biBitCount', c_short),
        ('biCompression', c_uint32),
        ('biSizeImage', c_uint32),
        ('biXPelsPerMeter', c_long),
        ('biYPelsPerMeter', c_long),
        ('biClrUsed', c_uint32),
        ('biClrImportant', c_uint32)
    ]
    __slots__ = [f[0] for f in _fields_]

class RGBQUAD(Structure):
    _fields_ = [
        ('rgbBlue', c_byte),
        ('rgbGreen', c_byte),
        ('rgbRed', c_byte),
        ('rgbReserved', c_byte)
    ]

    def __init__(self, r, g, b):
        self.rgbRed = r
        self.rgbGreen = g
        self.rgbBlue = b


class BITMAPINFO(Structure):
    _fields_ = [
        ('bmiHeader', BITMAPINFOHEADER),
        ('bmiColors', c_ulong * 3)
    ]

def str_ucs2(text):
    if byteorder == 'big':
        text = text.encode('utf_16_be')
    else:
        text = text.encode('utf_16_le')   # explicit endian avoids BOM
    return create_string_buffer(text + '\0')

_debug_dir = 'debug_font'
def _debug_filename(base, extension):
    import os
    if not os.path.exists(_debug_dir):
        os.makedirs(_debug_dir)
    name = '%s-%%d.%%s' % os.path.join(_debug_dir, base)
    num = 1
    while os.path.exists(name % (num, extension)):
        num += 1
    return name % (num, extension)

def _debug_image(image, name):
    filename = _debug_filename(name, 'png')
    image.save(filename)
    _debug('Saved image %r to %s' % (image, filename))

_debug_logfile = None
def _debug(msg):
    global _debug_logfile
    if not _debug_logfile:
        _debug_logfile = open(_debug_filename('log', 'txt'), 'wt')
    _debug_logfile.write(msg + '\n')

class Win32GlyphRenderer(base.GlyphRenderer):
    _bitmap = None
    _dc = None
    _bitmap_rect = None

    def __init__(self, font):
        super(Win32GlyphRenderer, self).__init__(font)
        self.font = font

        # Pessimistically round up width and height to 4 byte alignment
        width = font.max_glyph_width
        height = font.ascent - font.descent
        width = (width | 0x3) + 1
        height = (height | 0x3) + 1
        self._create_bitmap(width, height)

        gdi32.SelectObject(self._dc, self.font.hfont)

    def _create_bitmap(self, width, height):
        pass

    def render(self, text):
        raise NotImplementedError('abstract')

class GDIGlyphRenderer(Win32GlyphRenderer):
    def __del__(self):
        try:
            if self._dc:
                gdi32.DeleteDC(self._dc)
            if self._bitmap:
                gdi32.DeleteObject(self._bitmap)
        except:
            pass

    def render(self, text):
        # Attempt to get ABC widths (only for TrueType)
        abc = ABC()
        if gdi32.GetCharABCWidthsW(self._dc,
            ord(text), ord(text), byref(abc)):
            width = abc.abcB
            lsb = abc.abcA
            advance = abc.abcA + abc.abcB + abc.abcC
        else:
            width_buf = c_int()
            gdi32.GetCharWidth32W(self._dc,
                ord(text), ord(text), byref(width_buf))
            width = width_buf.value
            lsb = 0
            advance = width

        # Can't get glyph-specific dimensions, use whole line-height.
        height = self._bitmap_height
        image = self._get_image(text, width, height, lsb)

        glyph = self.font.create_glyph(image)
        glyph.set_bearings(-self.font.descent, lsb, advance)

        if _debug_font:
            _debug('%r.render(%s)' % (self, text))
            _debug('abc.abcA = %r' % abc.abcA)
            _debug('abc.abcB = %r' % abc.abcB)
            _debug('abc.abcC = %r' % abc.abcC)
            _debug('width = %r' % width)
            _debug('height = %r' % height)
            _debug('lsb = %r' % lsb)
            _debug('advance = %r' % advance)
            _debug_image(image, 'glyph_%s' % text)
            _debug_image(self.font.textures[0], 'tex_%s' % text)

        return glyph

    def _get_image(self, text, width, height, lsb):
        # There's no such thing as a greyscale bitmap format in GDI.  We can
        # create an 8-bit palette bitmap with 256 shades of grey, but
        # unfortunately antialiasing will not work on such a bitmap.  So, we
        # use a 32-bit bitmap and use the red channel as OpenGL's alpha.

        gdi32.SelectObject(self._dc, self._bitmap)
        gdi32.SelectObject(self._dc, self.font.hfont)
        gdi32.SetBkColor(self._dc, 0x0)
        gdi32.SetTextColor(self._dc, 0x00ffffff)
        gdi32.SetBkMode(self._dc, OPAQUE)

        # Draw to DC
        user32.FillRect(self._dc, byref(self._bitmap_rect), self._black)
        gdi32.ExtTextOutA(self._dc, -lsb, 0, 0, c_void_p(), text,
            len(text), c_void_p())
        gdi32.GdiFlush()

        # Create glyph object and copy bitmap data to texture
        image = pyglet.image.ImageData(width, height,
            'AXXX', self._bitmap_data, self._bitmap_rect.right * 4)
        return image

    def _create_bitmap(self, width, height):
        self._black = gdi32.GetStockObject(BLACK_BRUSH)
        self._white = gdi32.GetStockObject(WHITE_BRUSH)

        if self._dc:
            gdi32.ReleaseDC(self._dc)
        if self._bitmap:
            gdi32.DeleteObject(self._bitmap)

        pitch = width * 4
        data = POINTER(c_byte * (height * pitch))()
        info = BITMAPINFO()
        info.bmiHeader.biSize = sizeof(info.bmiHeader)
        info.bmiHeader.biWidth = width
        info.bmiHeader.biHeight = height
        info.bmiHeader.biPlanes = 1
        info.bmiHeader.biBitCount = 32
        info.bmiHeader.biCompression = BI_RGB

        self._dc = gdi32.CreateCompatibleDC(c_void_p())
        self._bitmap = gdi32.CreateDIBSection(c_void_p(),
            byref(info), DIB_RGB_COLORS, byref(data), c_void_p(),
            0)
        # Spookiness: the above line causes a "not enough storage" error,
        # even though that error cannot be generated according to docs,
        # and everything works fine anyway.  Call SetLastError to clear it.
        kernel32.SetLastError(0)

        self._bitmap_data = data.contents
        self._bitmap_rect = RECT()
        self._bitmap_rect.left = 0
        self._bitmap_rect.right = width
        self._bitmap_rect.top = 0
        self._bitmap_rect.bottom = height
        self._bitmap_height = height

        if _debug_font:
            _debug('%r._create_dc(%d, %d)' % (self, width, height))
            _debug('_dc = %r' % self._dc)
            _debug('_bitmap = %r' % self._bitmap)
            _debug('pitch = %r' % pitch)
            _debug('info.bmiHeader.biSize = %r' % info.bmiHeader.biSize)

class Win32Font(base.Font):
    glyph_renderer_class = GDIGlyphRenderer

    def __init__(self, name, size, bold=False, italic=False, dpi=None):
        super(Win32Font, self).__init__()

        self.logfont = self.get_logfont(name, size, bold, italic, dpi)
        self.hfont = gdi32.CreateFontIndirectA(byref(self.logfont))

        # Create a dummy DC for coordinate mapping
        dc = user32.GetDC(0)
        metrics = TEXTMETRIC()
        gdi32.SelectObject(dc, self.hfont)
        gdi32.GetTextMetricsA(dc, byref(metrics))
        self.ascent = metrics.tmAscent
        self.descent = -metrics.tmDescent
        self.max_glyph_width = metrics.tmMaxCharWidth

    @staticmethod
    def get_logfont(name, size, bold, italic, dpi):
        # Create a dummy DC for coordinate mapping
        dc = user32.GetDC(0)
        if dpi is None:
            dpi = 96
        logpixelsy = dpi

        logfont = LOGFONT()
        # Conversion of point size to device pixels
        logfont.lfHeight = int(-size * logpixelsy / 72)
        if bold:
            logfont.lfWeight = FW_BOLD
        else:
            logfont.lfWeight = FW_NORMAL
        logfont.lfItalic = italic
        logfont.lfFaceName = name
        logfont.lfQuality = ANTIALIASED_QUALITY
        return logfont

    @classmethod
    def have_font(cls, name):
        # CreateFontIndirect always returns a font... have to work out
        # something with EnumFontFamily... TODO
        return True

    @classmethod
    def add_font_data(cls, data):
        numfonts = c_uint32()
        gdi32.AddFontMemResourceEx(data, len(data), 0, byref(numfonts))

# --- GDI+ font rendering ---

from pyglet.image.codecs.gdiplus import PixelFormat32bppARGB, gdiplus, Rect
from pyglet.image.codecs.gdiplus import ImageLockModeRead, BitmapData

DriverStringOptionsCmapLookup = 1
DriverStringOptionsRealizedAdvance = 4
TextRenderingHintAntiAlias = 4
TextRenderingHintAntiAliasGridFit = 3

StringFormatFlagsDirectionRightToLeft = 0x00000001
StringFormatFlagsDirectionVertical = 0x00000002
StringFormatFlagsNoFitBlackBox = 0x00000004
StringFormatFlagsDisplayFormatControl = 0x00000020
StringFormatFlagsNoFontFallback = 0x00000400
StringFormatFlagsMeasureTrailingSpaces = 0x00000800
StringFormatFlagsNoWrap = 0x00001000
StringFormatFlagsLineLimit = 0x00002000
StringFormatFlagsNoClip = 0x00004000

class Rectf(ctypes.Structure):
    _fields_ = [
        ('x', ctypes.c_float),
        ('y', ctypes.c_float),
        ('width', ctypes.c_float),
        ('height', ctypes.c_float),
    ]

class GDIPlusGlyphRenderer(Win32GlyphRenderer):
    def _create_bitmap(self, width, height):
        self._data = (ctypes.c_byte * (4 * width * height))()
        self._bitmap = ctypes.c_void_p()
        self._format = PixelFormat32bppARGB
        gdiplus.GdipCreateBitmapFromScan0(width, height, width * 4,
            self._format, self._data, ctypes.byref(self._bitmap))

        self._graphics = ctypes.c_void_p()
        gdiplus.GdipGetImageGraphicsContext(self._bitmap,
            ctypes.byref(self._graphics))
        gdiplus.GdipSetPageUnit(self._graphics, UnitPixel)

        self._dc = user32.GetDC(0)
        gdi32.SelectObject(self._dc, self.font.hfont)

        gdiplus.GdipSetTextRenderingHint(self._graphics,
            TextRenderingHintAntiAliasGridFit)


        self._brush = ctypes.c_void_p()
        gdiplus.GdipCreateSolidFill(0xffffffff, ctypes.byref(self._brush))


        self._matrix = ctypes.c_void_p()
        gdiplus.GdipCreateMatrix(ctypes.byref(self._matrix))

        self._flags = (DriverStringOptionsCmapLookup |
                       DriverStringOptionsRealizedAdvance)

        self._rect = Rect(0, 0, width, height)

        self._bitmap_height = height

    def render(self, text):
        ch = ctypes.create_unicode_buffer(text)

        # Layout rectangle; not clipped against so not terribly important.
        width = 10000
        height = self._bitmap_height
        rect = Rectf(0, self._bitmap_height
                        - self.font.ascent + self.font.descent,
                     width, height)

        # Set up GenericTypographic with 1 character measure range
        generic = ctypes.c_void_p()
        gdiplus.GdipStringFormatGetGenericTypographic(ctypes.byref(generic))
        format = ctypes.c_void_p()
        gdiplus.GdipCloneStringFormat(generic, ctypes.byref(format))

        # Measure advance
        bbox = Rectf()
        flags = (StringFormatFlagsMeasureTrailingSpaces |
                 StringFormatFlagsNoClip |
                 StringFormatFlagsNoFitBlackBox)
        gdiplus.GdipSetStringFormatFlags(format, flags)
        gdiplus.GdipMeasureString(self._graphics, ch, len(ch) - 1,
            self.font._gdipfont, ctypes.byref(rect), format,
            ctypes.byref(bbox), 0, 0)

        lsb = 0
        advance = int(math.ceil(bbox.width))

        # XXX HACK HACK HACK
        # Windows GDI+ is a filthy broken toy.  No way to measure the bounding
        # box of a string, or to obtain LSB.  What a joke.
        #
        # For historical note, GDI cannot be used because it cannot composite
        # into a bitmap with alpha.
        #
        # It looks like MS have abandoned GDI and GDI+ and are finally
        # supporting accurate text measurement with alpha composition in .NET
        # 2.0 (WinForms) via the TextRenderer class; this has no C interface
        # though, so we're entirely screwed.
        #
        # So anyway, this hack bumps up the width if the font is italic;
        # this compensates for some common fonts.  It's also a stupid waste of
        # texture memory.

        width = advance
        if self.font.italic:
            width += width // 2

        # XXX END HACK HACK HACK

        # Draw character to bitmap

        gdiplus.GdipGraphicsClear(self._graphics, 0x00000000)
        gdiplus.GdipDrawString(self._graphics, ch, len(ch) - 1,
            self.font._gdipfont, ctypes.byref(rect), format,
            self._brush)
        gdiplus.GdipFlush(self._graphics, 1)

        bitmap_data = BitmapData()
        gdiplus.GdipBitmapLockBits(self._bitmap,
            byref(self._rect), ImageLockModeRead, self._format,
            byref(bitmap_data))

        # Create buffer for RawImage
        buffer = create_string_buffer(
            bitmap_data.Stride * bitmap_data.Height)
        memmove(buffer, bitmap_data.Scan0, len(buffer))

        # Unlock data
        gdiplus.GdipBitmapUnlockBits(self._bitmap, byref(bitmap_data))

        image = pyglet.image.ImageData(width, height,
            'BGRA', buffer, -bitmap_data.Stride)

        glyph = self.font.create_glyph(image)
        glyph.set_bearings(-self.font.descent, lsb, advance)

        return glyph

FontStyleBold = 1
FontStyleItalic = 2
UnitPixel = 2
UnitPoint = 3

class GDIPlusFont(Win32Font):
    glyph_renderer_class = GDIPlusGlyphRenderer

    _private_fonts = None

    _default_name = 'Arial'

    def __init__(self, name, size, bold=False, italic=False, dpi=None):
        if not name:
            name = self._default_name
        super(GDIPlusFont, self).__init__(name, size, bold, italic, dpi)

        family = ctypes.c_void_p()
        name = ctypes.c_wchar_p(name)

        # Look in private collection first:
        if self._private_fonts:
            gdiplus.GdipCreateFontFamilyFromName(name,
                self._private_fonts, ctypes.byref(family))

        # Then in system collection:
        if not family:
            gdiplus.GdipCreateFontFamilyFromName(name,
                None, ctypes.byref(family))

        # Nothing found, use default font.
        if not family:
            name = self._default_name
            gdiplus.GdipCreateFontFamilyFromName(ctypes.c_wchar_p(name),
                None, ctypes.byref(family))

        if dpi is None:
            unit = UnitPoint
            self.dpi = 96
        else:
            unit = UnitPixel
            size = (size * dpi) / 72
            self.dpi = dpi

        style = 0
        if bold:
            style |= FontStyleBold
        if italic:
            style |= FontStyleItalic
        self.italic = italic # XXX needed for HACK HACK HACK
        self._gdipfont = ctypes.c_void_p()
        gdiplus.GdipCreateFont(family, ctypes.c_float(size),
            style, unit, ctypes.byref(self._gdipfont))

    @classmethod
    def add_font_data(cls, data):
        super(GDIPlusFont, cls).add_font_data(data)

        if not cls._private_fonts:
            cls._private_fonts = ctypes.c_void_p()
            gdiplus.GdipNewPrivateFontCollection(
                ctypes.byref(cls._private_fonts))
        gdiplus.GdipPrivateAddMemoryFont(cls._private_fonts, data, len(data))

########NEW FILE########
__FILENAME__ = agl
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for /System/Library/Frameworks/AGL.framework/Headers/agl.h

Generated by tools/gengl.py.
Do not modify this file.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: gengl.py 601 2007-02-04 05:36:59Z Alex.Holkner $'

from ctypes import *
from pyglet.gl.lib import link_AGL as _link_function
from pyglet.gl.lib import c_ptrdiff_t

if not _link_function:
    raise ImportError('AGL framework is not available.')

# BEGIN GENERATED CONTENT (do not edit below this line)

# This content is generated by tools/gengl.py.
# Wrapper for /System/Library/Frameworks/AGL.framework/Headers/agl.h


AGL_VERSION_2_0 = 1 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:41
class struct_GDevice(Structure):
    __slots__ = [
    ]
struct_GDevice._fields_ = [
    ('_opaque_struct', c_int)
]

GDevice = struct_GDevice 	# /System/Library/Frameworks/ApplicationServices.framework/Frameworks/QD.framework/Headers/Quickdraw.h:1347
GDPtr = POINTER(GDevice) 	# /System/Library/Frameworks/ApplicationServices.framework/Frameworks/QD.framework/Headers/Quickdraw.h:1348
GDHandle = POINTER(GDPtr) 	# /System/Library/Frameworks/ApplicationServices.framework/Frameworks/QD.framework/Headers/Quickdraw.h:1349
AGLDevice = GDHandle 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:46
class struct_OpaqueGrafPtr(Structure):
    __slots__ = [
    ]
struct_OpaqueGrafPtr._fields_ = [
    ('_opaque_struct', c_int)
]

GrafPtr = POINTER(struct_OpaqueGrafPtr) 	# /System/Library/Frameworks/ApplicationServices.framework/Frameworks/QD.framework/Headers/Quickdraw.h:1009
CGrafPtr = GrafPtr 	# /System/Library/Frameworks/ApplicationServices.framework/Frameworks/QD.framework/Headers/Quickdraw.h:1392
AGLDrawable = CGrafPtr 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:51
class struct___AGLRendererInfoRec(Structure):
    __slots__ = [
    ]
struct___AGLRendererInfoRec._fields_ = [
    ('_opaque_struct', c_int)
]

AGLRendererInfo = POINTER(struct___AGLRendererInfoRec) 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:56
class struct___AGLPixelFormatRec(Structure):
    __slots__ = [
    ]
struct___AGLPixelFormatRec._fields_ = [
    ('_opaque_struct', c_int)
]

AGLPixelFormat = POINTER(struct___AGLPixelFormatRec) 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:57
class struct___AGLContextRec(Structure):
    __slots__ = [
    ]
struct___AGLContextRec._fields_ = [
    ('_opaque_struct', c_int)
]

AGLContext = POINTER(struct___AGLContextRec) 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:58
class struct___AGLPBufferRec(Structure):
    __slots__ = [
    ]
struct___AGLPBufferRec._fields_ = [
    ('_opaque_struct', c_int)
]

AGLPbuffer = POINTER(struct___AGLPBufferRec) 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:59
AGL_NONE = 0 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:66
AGL_ALL_RENDERERS = 1 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:67
AGL_BUFFER_SIZE = 2 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:68
AGL_LEVEL = 3 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:69
AGL_RGBA = 4 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:70
AGL_DOUBLEBUFFER = 5 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:71
AGL_STEREO = 6 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:72
AGL_AUX_BUFFERS = 7 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:73
AGL_RED_SIZE = 8 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:74
AGL_GREEN_SIZE = 9 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:75
AGL_BLUE_SIZE = 10 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:76
AGL_ALPHA_SIZE = 11 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:77
AGL_DEPTH_SIZE = 12 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:78
AGL_STENCIL_SIZE = 13 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:79
AGL_ACCUM_RED_SIZE = 14 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:80
AGL_ACCUM_GREEN_SIZE = 15 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:81
AGL_ACCUM_BLUE_SIZE = 16 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:82
AGL_ACCUM_ALPHA_SIZE = 17 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:83
AGL_PIXEL_SIZE = 50 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:88
AGL_MINIMUM_POLICY = 51 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:89
AGL_MAXIMUM_POLICY = 52 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:90
AGL_OFFSCREEN = 53 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:91
AGL_FULLSCREEN = 54 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:92
AGL_SAMPLE_BUFFERS_ARB = 55 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:93
AGL_SAMPLES_ARB = 56 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:94
AGL_AUX_DEPTH_STENCIL = 57 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:95
AGL_COLOR_FLOAT = 58 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:96
AGL_MULTISAMPLE = 59 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:97
AGL_SUPERSAMPLE = 60 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:98
AGL_SAMPLE_ALPHA = 61 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:99
AGL_RENDERER_ID = 70 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:104
AGL_SINGLE_RENDERER = 71 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:105
AGL_NO_RECOVERY = 72 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:106
AGL_ACCELERATED = 73 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:107
AGL_CLOSEST_POLICY = 74 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:108
AGL_ROBUST = 75 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:109
AGL_BACKING_STORE = 76 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:110
AGL_MP_SAFE = 78 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:111
AGL_WINDOW = 80 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:113
AGL_MULTISCREEN = 81 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:114
AGL_VIRTUAL_SCREEN = 82 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:115
AGL_COMPLIANT = 83 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:116
AGL_PBUFFER = 90 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:118
AGL_BUFFER_MODES = 100 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:135
AGL_MIN_LEVEL = 101 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:136
AGL_MAX_LEVEL = 102 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:137
AGL_COLOR_MODES = 103 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:138
AGL_ACCUM_MODES = 104 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:139
AGL_DEPTH_MODES = 105 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:140
AGL_STENCIL_MODES = 106 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:141
AGL_MAX_AUX_BUFFERS = 107 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:142
AGL_VIDEO_MEMORY = 120 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:143
AGL_TEXTURE_MEMORY = 121 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:144
AGL_RENDERER_COUNT = 128 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:145
AGL_SWAP_RECT = 200 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:150
AGL_BUFFER_RECT = 202 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:151
AGL_SWAP_LIMIT = 203 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:152
AGL_COLORMAP_TRACKING = 210 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:153
AGL_COLORMAP_ENTRY = 212 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:154
AGL_RASTERIZATION = 220 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:155
AGL_SWAP_INTERVAL = 222 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:156
AGL_STATE_VALIDATION = 230 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:157
AGL_BUFFER_NAME = 231 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:158
AGL_ORDER_CONTEXT_TO_FRONT = 232 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:159
AGL_CONTEXT_SURFACE_ID = 233 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:160
AGL_CONTEXT_DISPLAY_ID = 234 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:161
AGL_SURFACE_ORDER = 235 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:162
AGL_SURFACE_OPACITY = 236 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:163
AGL_CLIP_REGION = 254 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:164
AGL_FS_CAPTURE_SINGLE = 255 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:165
AGL_SURFACE_BACKING_SIZE = 304 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:166
AGL_ENABLE_SURFACE_BACKING_SIZE = 305 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:167
AGL_SURFACE_VOLATILE = 306 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:168
AGL_FORMAT_CACHE_SIZE = 501 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:172
AGL_CLEAR_FORMAT_CACHE = 502 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:173
AGL_RETAIN_RENDERERS = 503 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:174
AGL_MONOSCOPIC_BIT = 1 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:177
AGL_STEREOSCOPIC_BIT = 2 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:178
AGL_SINGLEBUFFER_BIT = 4 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:179
AGL_DOUBLEBUFFER_BIT = 8 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:180
AGL_0_BIT = 1 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:183
AGL_1_BIT = 2 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:184
AGL_2_BIT = 4 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:185
AGL_3_BIT = 8 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:186
AGL_4_BIT = 16 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:187
AGL_5_BIT = 32 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:188
AGL_6_BIT = 64 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:189
AGL_8_BIT = 128 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:190
AGL_10_BIT = 256 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:191
AGL_12_BIT = 512 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:192
AGL_16_BIT = 1024 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:193
AGL_24_BIT = 2048 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:194
AGL_32_BIT = 4096 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:195
AGL_48_BIT = 8192 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:196
AGL_64_BIT = 16384 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:197
AGL_96_BIT = 32768 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:198
AGL_128_BIT = 65536 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:199
AGL_RGB8_BIT = 1 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:202
AGL_RGB8_A8_BIT = 2 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:203
AGL_BGR233_BIT = 4 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:204
AGL_BGR233_A8_BIT = 8 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:205
AGL_RGB332_BIT = 16 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:206
AGL_RGB332_A8_BIT = 32 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:207
AGL_RGB444_BIT = 64 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:208
AGL_ARGB4444_BIT = 128 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:209
AGL_RGB444_A8_BIT = 256 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:210
AGL_RGB555_BIT = 512 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:211
AGL_ARGB1555_BIT = 1024 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:212
AGL_RGB555_A8_BIT = 2048 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:213
AGL_RGB565_BIT = 4096 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:214
AGL_RGB565_A8_BIT = 8192 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:215
AGL_RGB888_BIT = 16384 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:216
AGL_ARGB8888_BIT = 32768 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:217
AGL_RGB888_A8_BIT = 65536 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:218
AGL_RGB101010_BIT = 131072 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:219
AGL_ARGB2101010_BIT = 262144 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:220
AGL_RGB101010_A8_BIT = 524288 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:221
AGL_RGB121212_BIT = 1048576 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:222
AGL_ARGB12121212_BIT = 2097152 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:223
AGL_RGB161616_BIT = 4194304 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:224
AGL_ARGB16161616_BIT = 8388608 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:225
AGL_INDEX8_BIT = 536870912 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:226
AGL_INDEX16_BIT = 1073741824 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:227
AGL_RGBFLOAT64_BIT = 16777216 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:228
AGL_RGBAFLOAT64_BIT = 33554432 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:229
AGL_RGBFLOAT128_BIT = 67108864 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:230
AGL_RGBAFLOAT128_BIT = 134217728 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:231
AGL_RGBFLOAT256_BIT = 268435456 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:232
AGL_RGBAFLOAT256_BIT = 536870912 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:233
AGL_NO_ERROR = 0 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:238
AGL_BAD_ATTRIBUTE = 10000 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:240
AGL_BAD_PROPERTY = 10001 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:241
AGL_BAD_PIXELFMT = 10002 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:242
AGL_BAD_RENDINFO = 10003 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:243
AGL_BAD_CONTEXT = 10004 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:244
AGL_BAD_DRAWABLE = 10005 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:245
AGL_BAD_GDEV = 10006 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:246
AGL_BAD_STATE = 10007 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:247
AGL_BAD_VALUE = 10008 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:248
AGL_BAD_MATCH = 10009 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:249
AGL_BAD_ENUM = 10010 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:250
AGL_BAD_OFFSCREEN = 10011 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:251
AGL_BAD_FULLSCREEN = 10012 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:252
AGL_BAD_WINDOW = 10013 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:253
AGL_BAD_POINTER = 10014 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:254
AGL_BAD_MODULE = 10015 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:255
AGL_BAD_ALLOC = 10016 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:256
AGL_BAD_CONNECTION = 10017 	# /System/Library/Frameworks/AGL.framework/Headers/agl.h:257
GLint = c_long 	# /System/Library/Frameworks/OpenGL.framework/Headers/gl.h:47
# /System/Library/Frameworks/AGL.framework/Headers/agl.h:264
aglChoosePixelFormat = _link_function('aglChoosePixelFormat', AGLPixelFormat, [POINTER(AGLDevice), GLint, POINTER(GLint)], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:265
aglDestroyPixelFormat = _link_function('aglDestroyPixelFormat', None, [AGLPixelFormat], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:266
aglNextPixelFormat = _link_function('aglNextPixelFormat', AGLPixelFormat, [AGLPixelFormat], None)

GLboolean = c_ubyte 	# /System/Library/Frameworks/OpenGL.framework/Headers/gl.h:43
# /System/Library/Frameworks/AGL.framework/Headers/agl.h:267
aglDescribePixelFormat = _link_function('aglDescribePixelFormat', GLboolean, [AGLPixelFormat, GLint, POINTER(GLint)], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:268
aglDevicesOfPixelFormat = _link_function('aglDevicesOfPixelFormat', POINTER(AGLDevice), [AGLPixelFormat, POINTER(GLint)], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:273
aglQueryRendererInfo = _link_function('aglQueryRendererInfo', AGLRendererInfo, [POINTER(AGLDevice), GLint], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:274
aglDestroyRendererInfo = _link_function('aglDestroyRendererInfo', None, [AGLRendererInfo], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:275
aglNextRendererInfo = _link_function('aglNextRendererInfo', AGLRendererInfo, [AGLRendererInfo], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:276
aglDescribeRenderer = _link_function('aglDescribeRenderer', GLboolean, [AGLRendererInfo, GLint, POINTER(GLint)], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:281
aglCreateContext = _link_function('aglCreateContext', AGLContext, [AGLPixelFormat, AGLContext], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:282
aglDestroyContext = _link_function('aglDestroyContext', GLboolean, [AGLContext], None)

GLuint = c_ulong 	# /System/Library/Frameworks/OpenGL.framework/Headers/gl.h:51
# /System/Library/Frameworks/AGL.framework/Headers/agl.h:283
aglCopyContext = _link_function('aglCopyContext', GLboolean, [AGLContext, AGLContext, GLuint], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:284
aglUpdateContext = _link_function('aglUpdateContext', GLboolean, [AGLContext], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:289
aglSetCurrentContext = _link_function('aglSetCurrentContext', GLboolean, [AGLContext], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:290
aglGetCurrentContext = _link_function('aglGetCurrentContext', AGLContext, [], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:295
aglSetDrawable = _link_function('aglSetDrawable', GLboolean, [AGLContext, AGLDrawable], None)

GLsizei = c_long 	# /System/Library/Frameworks/OpenGL.framework/Headers/gl.h:48
GLvoid = None 	# /System/Library/Frameworks/OpenGL.framework/Headers/gl.h:56
# /System/Library/Frameworks/AGL.framework/Headers/agl.h:296
aglSetOffScreen = _link_function('aglSetOffScreen', GLboolean, [AGLContext, GLsizei, GLsizei, GLsizei, POINTER(GLvoid)], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:297
aglSetFullScreen = _link_function('aglSetFullScreen', GLboolean, [AGLContext, GLsizei, GLsizei, GLsizei, GLint], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:298
aglGetDrawable = _link_function('aglGetDrawable', AGLDrawable, [AGLContext], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:303
aglSetVirtualScreen = _link_function('aglSetVirtualScreen', GLboolean, [AGLContext, GLint], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:304
aglGetVirtualScreen = _link_function('aglGetVirtualScreen', GLint, [AGLContext], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:309
aglGetVersion = _link_function('aglGetVersion', None, [POINTER(GLint), POINTER(GLint)], None)

GLenum = c_ulong 	# /System/Library/Frameworks/OpenGL.framework/Headers/gl.h:42
# /System/Library/Frameworks/AGL.framework/Headers/agl.h:314
aglConfigure = _link_function('aglConfigure', GLboolean, [GLenum, GLuint], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:319
aglSwapBuffers = _link_function('aglSwapBuffers', None, [AGLContext], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:324
aglEnable = _link_function('aglEnable', GLboolean, [AGLContext, GLenum], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:325
aglDisable = _link_function('aglDisable', GLboolean, [AGLContext, GLenum], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:326
aglIsEnabled = _link_function('aglIsEnabled', GLboolean, [AGLContext, GLenum], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:327
aglSetInteger = _link_function('aglSetInteger', GLboolean, [AGLContext, GLenum, POINTER(GLint)], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:328
aglGetInteger = _link_function('aglGetInteger', GLboolean, [AGLContext, GLenum, POINTER(GLint)], None)

Style = c_ubyte 	# /System/Library/Frameworks/CoreServices.framework/Headers/../Frameworks/CarbonCore.framework/Headers/MacTypes.h:524
# /System/Library/Frameworks/AGL.framework/Headers/agl.h:333
aglUseFont = _link_function('aglUseFont', GLboolean, [AGLContext, GLint, Style, GLint, GLint, GLint, GLint], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:338
aglGetError = _link_function('aglGetError', GLenum, [], None)

GLubyte = c_ubyte 	# /System/Library/Frameworks/OpenGL.framework/Headers/gl.h:49
# /System/Library/Frameworks/AGL.framework/Headers/agl.h:339
aglErrorString = _link_function('aglErrorString', POINTER(GLubyte), [GLenum], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:344
aglResetLibrary = _link_function('aglResetLibrary', None, [], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:349
aglSurfaceTexture = _link_function('aglSurfaceTexture', None, [AGLContext, GLenum, GLenum, AGLContext], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:354
aglCreatePBuffer = _link_function('aglCreatePBuffer', GLboolean, [GLint, GLint, GLenum, GLenum, c_long, POINTER(AGLPbuffer)], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:355
aglDestroyPBuffer = _link_function('aglDestroyPBuffer', GLboolean, [AGLPbuffer], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:356
aglDescribePBuffer = _link_function('aglDescribePBuffer', GLboolean, [AGLPbuffer, POINTER(GLint), POINTER(GLint), POINTER(GLenum), POINTER(GLenum), POINTER(GLint)], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:357
aglTexImagePBuffer = _link_function('aglTexImagePBuffer', GLboolean, [AGLContext, AGLPbuffer, GLint], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:362
aglSetPBuffer = _link_function('aglSetPBuffer', GLboolean, [AGLContext, AGLPbuffer, GLint, GLint, GLint], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:363
aglGetPBuffer = _link_function('aglGetPBuffer', GLboolean, [AGLContext, POINTER(AGLPbuffer), POINTER(GLint), POINTER(GLint), POINTER(GLint)], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:368
aglGetCGLContext = _link_function('aglGetCGLContext', GLboolean, [AGLContext, POINTER(POINTER(None))], None)

# /System/Library/Frameworks/AGL.framework/Headers/agl.h:369
aglGetCGLPixelFormat = _link_function('aglGetCGLPixelFormat', GLboolean, [AGLPixelFormat, POINTER(POINTER(None))], None)


__all__ = ['AGL_VERSION_2_0', 'AGLDevice', 'AGLDrawable', 'AGLRendererInfo',
'AGLPixelFormat', 'AGLContext', 'AGLPbuffer', 'AGL_NONE', 'AGL_ALL_RENDERERS',
'AGL_BUFFER_SIZE', 'AGL_LEVEL', 'AGL_RGBA', 'AGL_DOUBLEBUFFER', 'AGL_STEREO',
'AGL_AUX_BUFFERS', 'AGL_RED_SIZE', 'AGL_GREEN_SIZE', 'AGL_BLUE_SIZE',
'AGL_ALPHA_SIZE', 'AGL_DEPTH_SIZE', 'AGL_STENCIL_SIZE', 'AGL_ACCUM_RED_SIZE',
'AGL_ACCUM_GREEN_SIZE', 'AGL_ACCUM_BLUE_SIZE', 'AGL_ACCUM_ALPHA_SIZE',
'AGL_PIXEL_SIZE', 'AGL_MINIMUM_POLICY', 'AGL_MAXIMUM_POLICY', 'AGL_OFFSCREEN',
'AGL_FULLSCREEN', 'AGL_SAMPLE_BUFFERS_ARB', 'AGL_SAMPLES_ARB',
'AGL_AUX_DEPTH_STENCIL', 'AGL_COLOR_FLOAT', 'AGL_MULTISAMPLE',
'AGL_SUPERSAMPLE', 'AGL_SAMPLE_ALPHA', 'AGL_RENDERER_ID',
'AGL_SINGLE_RENDERER', 'AGL_NO_RECOVERY', 'AGL_ACCELERATED',
'AGL_CLOSEST_POLICY', 'AGL_ROBUST', 'AGL_BACKING_STORE', 'AGL_MP_SAFE',
'AGL_WINDOW', 'AGL_MULTISCREEN', 'AGL_VIRTUAL_SCREEN', 'AGL_COMPLIANT',
'AGL_PBUFFER', 'AGL_BUFFER_MODES', 'AGL_MIN_LEVEL', 'AGL_MAX_LEVEL',
'AGL_COLOR_MODES', 'AGL_ACCUM_MODES', 'AGL_DEPTH_MODES', 'AGL_STENCIL_MODES',
'AGL_MAX_AUX_BUFFERS', 'AGL_VIDEO_MEMORY', 'AGL_TEXTURE_MEMORY',
'AGL_RENDERER_COUNT', 'AGL_SWAP_RECT', 'AGL_BUFFER_RECT', 'AGL_SWAP_LIMIT',
'AGL_COLORMAP_TRACKING', 'AGL_COLORMAP_ENTRY', 'AGL_RASTERIZATION',
'AGL_SWAP_INTERVAL', 'AGL_STATE_VALIDATION', 'AGL_BUFFER_NAME',
'AGL_ORDER_CONTEXT_TO_FRONT', 'AGL_CONTEXT_SURFACE_ID',
'AGL_CONTEXT_DISPLAY_ID', 'AGL_SURFACE_ORDER', 'AGL_SURFACE_OPACITY',
'AGL_CLIP_REGION', 'AGL_FS_CAPTURE_SINGLE', 'AGL_SURFACE_BACKING_SIZE',
'AGL_ENABLE_SURFACE_BACKING_SIZE', 'AGL_SURFACE_VOLATILE',
'AGL_FORMAT_CACHE_SIZE', 'AGL_CLEAR_FORMAT_CACHE', 'AGL_RETAIN_RENDERERS',
'AGL_MONOSCOPIC_BIT', 'AGL_STEREOSCOPIC_BIT', 'AGL_SINGLEBUFFER_BIT',
'AGL_DOUBLEBUFFER_BIT', 'AGL_0_BIT', 'AGL_1_BIT', 'AGL_2_BIT', 'AGL_3_BIT',
'AGL_4_BIT', 'AGL_5_BIT', 'AGL_6_BIT', 'AGL_8_BIT', 'AGL_10_BIT',
'AGL_12_BIT', 'AGL_16_BIT', 'AGL_24_BIT', 'AGL_32_BIT', 'AGL_48_BIT',
'AGL_64_BIT', 'AGL_96_BIT', 'AGL_128_BIT', 'AGL_RGB8_BIT', 'AGL_RGB8_A8_BIT',
'AGL_BGR233_BIT', 'AGL_BGR233_A8_BIT', 'AGL_RGB332_BIT', 'AGL_RGB332_A8_BIT',
'AGL_RGB444_BIT', 'AGL_ARGB4444_BIT', 'AGL_RGB444_A8_BIT', 'AGL_RGB555_BIT',
'AGL_ARGB1555_BIT', 'AGL_RGB555_A8_BIT', 'AGL_RGB565_BIT',
'AGL_RGB565_A8_BIT', 'AGL_RGB888_BIT', 'AGL_ARGB8888_BIT',
'AGL_RGB888_A8_BIT', 'AGL_RGB101010_BIT', 'AGL_ARGB2101010_BIT',
'AGL_RGB101010_A8_BIT', 'AGL_RGB121212_BIT', 'AGL_ARGB12121212_BIT',
'AGL_RGB161616_BIT', 'AGL_ARGB16161616_BIT', 'AGL_INDEX8_BIT',
'AGL_INDEX16_BIT', 'AGL_RGBFLOAT64_BIT', 'AGL_RGBAFLOAT64_BIT',
'AGL_RGBFLOAT128_BIT', 'AGL_RGBAFLOAT128_BIT', 'AGL_RGBFLOAT256_BIT',
'AGL_RGBAFLOAT256_BIT', 'AGL_NO_ERROR', 'AGL_BAD_ATTRIBUTE',
'AGL_BAD_PROPERTY', 'AGL_BAD_PIXELFMT', 'AGL_BAD_RENDINFO', 'AGL_BAD_CONTEXT',
'AGL_BAD_DRAWABLE', 'AGL_BAD_GDEV', 'AGL_BAD_STATE', 'AGL_BAD_VALUE',
'AGL_BAD_MATCH', 'AGL_BAD_ENUM', 'AGL_BAD_OFFSCREEN', 'AGL_BAD_FULLSCREEN',
'AGL_BAD_WINDOW', 'AGL_BAD_POINTER', 'AGL_BAD_MODULE', 'AGL_BAD_ALLOC',
'AGL_BAD_CONNECTION', 'aglChoosePixelFormat', 'aglDestroyPixelFormat',
'aglNextPixelFormat', 'aglDescribePixelFormat', 'aglDevicesOfPixelFormat',
'aglQueryRendererInfo', 'aglDestroyRendererInfo', 'aglNextRendererInfo',
'aglDescribeRenderer', 'aglCreateContext', 'aglDestroyContext',
'aglCopyContext', 'aglUpdateContext', 'aglSetCurrentContext',
'aglGetCurrentContext', 'aglSetDrawable', 'aglSetOffScreen',
'aglSetFullScreen', 'aglGetDrawable', 'aglSetVirtualScreen',
'aglGetVirtualScreen', 'aglGetVersion', 'aglConfigure', 'aglSwapBuffers',
'aglEnable', 'aglDisable', 'aglIsEnabled', 'aglSetInteger', 'aglGetInteger',
'aglUseFont', 'aglGetError', 'aglErrorString', 'aglResetLibrary',
'aglSurfaceTexture', 'aglCreatePBuffer', 'aglDestroyPBuffer',
'aglDescribePBuffer', 'aglTexImagePBuffer', 'aglSetPBuffer', 'aglGetPBuffer',
'aglGetCGLContext', 'aglGetCGLPixelFormat']
# END GENERATED CONTENT (do not edit above this line)




########NEW FILE########
__FILENAME__ = gl
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for /usr/include/GL/gl.h

Generated by tools/gengl.py.
Do not modify this file.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: gl.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

from ctypes import *
from pyglet.gl.lib import link_GL as _link_function
from pyglet.gl.lib import c_ptrdiff_t

# BEGIN GENERATED CONTENT (do not edit below this line)

# This content is generated by tools/gengl.py.
# Wrapper for /usr/include/GL/gl.h


GLenum = c_uint 	# /usr/include/GL/gl.h:53
GLboolean = c_ubyte 	# /usr/include/GL/gl.h:54
GLbitfield = c_uint 	# /usr/include/GL/gl.h:55
GLbyte = c_char 	# /usr/include/GL/gl.h:56
GLshort = c_short 	# /usr/include/GL/gl.h:57
GLint = c_int 	# /usr/include/GL/gl.h:58
GLsizei = c_int 	# /usr/include/GL/gl.h:59
GLubyte = c_ubyte 	# /usr/include/GL/gl.h:60
GLushort = c_ushort 	# /usr/include/GL/gl.h:61
GLuint = c_uint 	# /usr/include/GL/gl.h:62
GLfloat = c_float 	# /usr/include/GL/gl.h:63
GLclampf = c_float 	# /usr/include/GL/gl.h:64
GLdouble = c_double 	# /usr/include/GL/gl.h:65
GLclampd = c_double 	# /usr/include/GL/gl.h:66
GLvoid = None 	# /usr/include/GL/gl.h:67
GL_VERSION_1_1 = 1 	# /usr/include/GL/gl.h:77
GL_CURRENT_BIT = 1 	# /usr/include/GL/gl.h:80
GL_POINT_BIT = 2 	# /usr/include/GL/gl.h:81
GL_LINE_BIT = 4 	# /usr/include/GL/gl.h:82
GL_POLYGON_BIT = 8 	# /usr/include/GL/gl.h:83
GL_POLYGON_STIPPLE_BIT = 16 	# /usr/include/GL/gl.h:84
GL_PIXEL_MODE_BIT = 32 	# /usr/include/GL/gl.h:85
GL_LIGHTING_BIT = 64 	# /usr/include/GL/gl.h:86
GL_FOG_BIT = 128 	# /usr/include/GL/gl.h:87
GL_DEPTH_BUFFER_BIT = 256 	# /usr/include/GL/gl.h:88
GL_ACCUM_BUFFER_BIT = 512 	# /usr/include/GL/gl.h:89
GL_STENCIL_BUFFER_BIT = 1024 	# /usr/include/GL/gl.h:90
GL_VIEWPORT_BIT = 2048 	# /usr/include/GL/gl.h:91
GL_TRANSFORM_BIT = 4096 	# /usr/include/GL/gl.h:92
GL_ENABLE_BIT = 8192 	# /usr/include/GL/gl.h:93
GL_COLOR_BUFFER_BIT = 16384 	# /usr/include/GL/gl.h:94
GL_HINT_BIT = 32768 	# /usr/include/GL/gl.h:95
GL_EVAL_BIT = 65536 	# /usr/include/GL/gl.h:96
GL_LIST_BIT = 131072 	# /usr/include/GL/gl.h:97
GL_TEXTURE_BIT = 262144 	# /usr/include/GL/gl.h:98
GL_SCISSOR_BIT = 524288 	# /usr/include/GL/gl.h:99
GL_ALL_ATTRIB_BITS = 4294967295 	# /usr/include/GL/gl.h:100
GL_CLIENT_PIXEL_STORE_BIT = 1 	# /usr/include/GL/gl.h:109
GL_CLIENT_VERTEX_ARRAY_BIT = 2 	# /usr/include/GL/gl.h:110
GL_CLIENT_ALL_ATTRIB_BITS = 4294967295 	# /usr/include/GL/gl.h:111
GL_FALSE = 0 	# /usr/include/GL/gl.h:114
GL_TRUE = 1 	# /usr/include/GL/gl.h:115
GL_POINTS = 0 	# /usr/include/GL/gl.h:118
GL_LINES = 1 	# /usr/include/GL/gl.h:119
GL_LINE_LOOP = 2 	# /usr/include/GL/gl.h:120
GL_LINE_STRIP = 3 	# /usr/include/GL/gl.h:121
GL_TRIANGLES = 4 	# /usr/include/GL/gl.h:122
GL_TRIANGLE_STRIP = 5 	# /usr/include/GL/gl.h:123
GL_TRIANGLE_FAN = 6 	# /usr/include/GL/gl.h:124
GL_QUADS = 7 	# /usr/include/GL/gl.h:125
GL_QUAD_STRIP = 8 	# /usr/include/GL/gl.h:126
GL_POLYGON = 9 	# /usr/include/GL/gl.h:127
GL_ACCUM = 256 	# /usr/include/GL/gl.h:130
GL_LOAD = 257 	# /usr/include/GL/gl.h:131
GL_RETURN = 258 	# /usr/include/GL/gl.h:132
GL_MULT = 259 	# /usr/include/GL/gl.h:133
GL_ADD = 260 	# /usr/include/GL/gl.h:134
GL_NEVER = 512 	# /usr/include/GL/gl.h:137
GL_LESS = 513 	# /usr/include/GL/gl.h:138
GL_EQUAL = 514 	# /usr/include/GL/gl.h:139
GL_LEQUAL = 515 	# /usr/include/GL/gl.h:140
GL_GREATER = 516 	# /usr/include/GL/gl.h:141
GL_NOTEQUAL = 517 	# /usr/include/GL/gl.h:142
GL_GEQUAL = 518 	# /usr/include/GL/gl.h:143
GL_ALWAYS = 519 	# /usr/include/GL/gl.h:144
GL_ZERO = 0 	# /usr/include/GL/gl.h:147
GL_ONE = 1 	# /usr/include/GL/gl.h:148
GL_SRC_COLOR = 768 	# /usr/include/GL/gl.h:149
GL_ONE_MINUS_SRC_COLOR = 769 	# /usr/include/GL/gl.h:150
GL_SRC_ALPHA = 770 	# /usr/include/GL/gl.h:151
GL_ONE_MINUS_SRC_ALPHA = 771 	# /usr/include/GL/gl.h:152
GL_DST_ALPHA = 772 	# /usr/include/GL/gl.h:153
GL_ONE_MINUS_DST_ALPHA = 773 	# /usr/include/GL/gl.h:154
GL_DST_COLOR = 774 	# /usr/include/GL/gl.h:159
GL_ONE_MINUS_DST_COLOR = 775 	# /usr/include/GL/gl.h:160
GL_SRC_ALPHA_SATURATE = 776 	# /usr/include/GL/gl.h:161
GL_NONE = 0 	# /usr/include/GL/gl.h:205
GL_FRONT_LEFT = 1024 	# /usr/include/GL/gl.h:206
GL_FRONT_RIGHT = 1025 	# /usr/include/GL/gl.h:207
GL_BACK_LEFT = 1026 	# /usr/include/GL/gl.h:208
GL_BACK_RIGHT = 1027 	# /usr/include/GL/gl.h:209
GL_FRONT = 1028 	# /usr/include/GL/gl.h:210
GL_BACK = 1029 	# /usr/include/GL/gl.h:211
GL_LEFT = 1030 	# /usr/include/GL/gl.h:212
GL_RIGHT = 1031 	# /usr/include/GL/gl.h:213
GL_FRONT_AND_BACK = 1032 	# /usr/include/GL/gl.h:214
GL_AUX0 = 1033 	# /usr/include/GL/gl.h:215
GL_AUX1 = 1034 	# /usr/include/GL/gl.h:216
GL_AUX2 = 1035 	# /usr/include/GL/gl.h:217
GL_AUX3 = 1036 	# /usr/include/GL/gl.h:218
GL_NO_ERROR = 0 	# /usr/include/GL/gl.h:289
GL_INVALID_ENUM = 1280 	# /usr/include/GL/gl.h:290
GL_INVALID_VALUE = 1281 	# /usr/include/GL/gl.h:291
GL_INVALID_OPERATION = 1282 	# /usr/include/GL/gl.h:292
GL_STACK_OVERFLOW = 1283 	# /usr/include/GL/gl.h:293
GL_STACK_UNDERFLOW = 1284 	# /usr/include/GL/gl.h:294
GL_OUT_OF_MEMORY = 1285 	# /usr/include/GL/gl.h:295
GL_TABLE_TOO_LARGE = 32817 	# /usr/include/GL/gl.h:296
GL_2D = 1536 	# /usr/include/GL/gl.h:299
GL_3D = 1537 	# /usr/include/GL/gl.h:300
GL_3D_COLOR = 1538 	# /usr/include/GL/gl.h:301
GL_3D_COLOR_TEXTURE = 1539 	# /usr/include/GL/gl.h:302
GL_4D_COLOR_TEXTURE = 1540 	# /usr/include/GL/gl.h:303
GL_PASS_THROUGH_TOKEN = 1792 	# /usr/include/GL/gl.h:306
GL_POINT_TOKEN = 1793 	# /usr/include/GL/gl.h:307
GL_LINE_TOKEN = 1794 	# /usr/include/GL/gl.h:308
GL_POLYGON_TOKEN = 1795 	# /usr/include/GL/gl.h:309
GL_BITMAP_TOKEN = 1796 	# /usr/include/GL/gl.h:310
GL_DRAW_PIXEL_TOKEN = 1797 	# /usr/include/GL/gl.h:311
GL_COPY_PIXEL_TOKEN = 1798 	# /usr/include/GL/gl.h:312
GL_LINE_RESET_TOKEN = 1799 	# /usr/include/GL/gl.h:313
GL_EXP = 2048 	# /usr/include/GL/gl.h:317
GL_EXP2 = 2049 	# /usr/include/GL/gl.h:318
GL_CW = 2304 	# /usr/include/GL/gl.h:329
GL_CCW = 2305 	# /usr/include/GL/gl.h:330
GL_COEFF = 2560 	# /usr/include/GL/gl.h:333
GL_ORDER = 2561 	# /usr/include/GL/gl.h:334
GL_DOMAIN = 2562 	# /usr/include/GL/gl.h:335
GL_PIXEL_MAP_I_TO_I = 3184 	# /usr/include/GL/gl.h:338
GL_PIXEL_MAP_S_TO_S = 3185 	# /usr/include/GL/gl.h:339
GL_PIXEL_MAP_I_TO_R = 3186 	# /usr/include/GL/gl.h:340
GL_PIXEL_MAP_I_TO_G = 3187 	# /usr/include/GL/gl.h:341
GL_PIXEL_MAP_I_TO_B = 3188 	# /usr/include/GL/gl.h:342
GL_PIXEL_MAP_I_TO_A = 3189 	# /usr/include/GL/gl.h:343
GL_PIXEL_MAP_R_TO_R = 3190 	# /usr/include/GL/gl.h:344
GL_PIXEL_MAP_G_TO_G = 3191 	# /usr/include/GL/gl.h:345
GL_PIXEL_MAP_B_TO_B = 3192 	# /usr/include/GL/gl.h:346
GL_PIXEL_MAP_A_TO_A = 3193 	# /usr/include/GL/gl.h:347
GL_VERTEX_ARRAY_POINTER = 32910 	# /usr/include/GL/gl.h:350
GL_NORMAL_ARRAY_POINTER = 32911 	# /usr/include/GL/gl.h:351
GL_COLOR_ARRAY_POINTER = 32912 	# /usr/include/GL/gl.h:352
GL_INDEX_ARRAY_POINTER = 32913 	# /usr/include/GL/gl.h:353
GL_TEXTURE_COORD_ARRAY_POINTER = 32914 	# /usr/include/GL/gl.h:354
GL_EDGE_FLAG_ARRAY_POINTER = 32915 	# /usr/include/GL/gl.h:355
GL_CURRENT_COLOR = 2816 	# /usr/include/GL/gl.h:358
GL_CURRENT_INDEX = 2817 	# /usr/include/GL/gl.h:359
GL_CURRENT_NORMAL = 2818 	# /usr/include/GL/gl.h:360
GL_CURRENT_TEXTURE_COORDS = 2819 	# /usr/include/GL/gl.h:361
GL_CURRENT_RASTER_COLOR = 2820 	# /usr/include/GL/gl.h:362
GL_CURRENT_RASTER_INDEX = 2821 	# /usr/include/GL/gl.h:363
GL_CURRENT_RASTER_TEXTURE_COORDS = 2822 	# /usr/include/GL/gl.h:364
GL_CURRENT_RASTER_POSITION = 2823 	# /usr/include/GL/gl.h:365
GL_CURRENT_RASTER_POSITION_VALID = 2824 	# /usr/include/GL/gl.h:366
GL_CURRENT_RASTER_DISTANCE = 2825 	# /usr/include/GL/gl.h:367
GL_POINT_SMOOTH = 2832 	# /usr/include/GL/gl.h:368
GL_POINT_SIZE = 2833 	# /usr/include/GL/gl.h:369
GL_SMOOTH_POINT_SIZE_RANGE = 2834 	# /usr/include/GL/gl.h:370
GL_SMOOTH_POINT_SIZE_GRANULARITY = 2835 	# /usr/include/GL/gl.h:371
GL_POINT_SIZE_RANGE = 2834 	# /usr/include/GL/gl.h:372
GL_POINT_SIZE_GRANULARITY = 2835 	# /usr/include/GL/gl.h:373
GL_LINE_SMOOTH = 2848 	# /usr/include/GL/gl.h:374
GL_LINE_WIDTH = 2849 	# /usr/include/GL/gl.h:375
GL_SMOOTH_LINE_WIDTH_RANGE = 2850 	# /usr/include/GL/gl.h:376
GL_SMOOTH_LINE_WIDTH_GRANULARITY = 2851 	# /usr/include/GL/gl.h:377
GL_LINE_WIDTH_RANGE = 2850 	# /usr/include/GL/gl.h:378
GL_LINE_WIDTH_GRANULARITY = 2851 	# /usr/include/GL/gl.h:379
GL_LINE_STIPPLE = 2852 	# /usr/include/GL/gl.h:380
GL_LINE_STIPPLE_PATTERN = 2853 	# /usr/include/GL/gl.h:381
GL_LINE_STIPPLE_REPEAT = 2854 	# /usr/include/GL/gl.h:382
GL_LIST_MODE = 2864 	# /usr/include/GL/gl.h:383
GL_MAX_LIST_NESTING = 2865 	# /usr/include/GL/gl.h:384
GL_LIST_BASE = 2866 	# /usr/include/GL/gl.h:385
GL_LIST_INDEX = 2867 	# /usr/include/GL/gl.h:386
GL_POLYGON_MODE = 2880 	# /usr/include/GL/gl.h:387
GL_POLYGON_SMOOTH = 2881 	# /usr/include/GL/gl.h:388
GL_POLYGON_STIPPLE = 2882 	# /usr/include/GL/gl.h:389
GL_EDGE_FLAG = 2883 	# /usr/include/GL/gl.h:390
GL_CULL_FACE = 2884 	# /usr/include/GL/gl.h:391
GL_CULL_FACE_MODE = 2885 	# /usr/include/GL/gl.h:392
GL_FRONT_FACE = 2886 	# /usr/include/GL/gl.h:393
GL_LIGHTING = 2896 	# /usr/include/GL/gl.h:394
GL_LIGHT_MODEL_LOCAL_VIEWER = 2897 	# /usr/include/GL/gl.h:395
GL_LIGHT_MODEL_TWO_SIDE = 2898 	# /usr/include/GL/gl.h:396
GL_LIGHT_MODEL_AMBIENT = 2899 	# /usr/include/GL/gl.h:397
GL_SHADE_MODEL = 2900 	# /usr/include/GL/gl.h:398
GL_COLOR_MATERIAL_FACE = 2901 	# /usr/include/GL/gl.h:399
GL_COLOR_MATERIAL_PARAMETER = 2902 	# /usr/include/GL/gl.h:400
GL_COLOR_MATERIAL = 2903 	# /usr/include/GL/gl.h:401
GL_FOG = 2912 	# /usr/include/GL/gl.h:402
GL_FOG_INDEX = 2913 	# /usr/include/GL/gl.h:403
GL_FOG_DENSITY = 2914 	# /usr/include/GL/gl.h:404
GL_FOG_START = 2915 	# /usr/include/GL/gl.h:405
GL_FOG_END = 2916 	# /usr/include/GL/gl.h:406
GL_FOG_MODE = 2917 	# /usr/include/GL/gl.h:407
GL_FOG_COLOR = 2918 	# /usr/include/GL/gl.h:408
GL_DEPTH_RANGE = 2928 	# /usr/include/GL/gl.h:409
GL_DEPTH_TEST = 2929 	# /usr/include/GL/gl.h:410
GL_DEPTH_WRITEMASK = 2930 	# /usr/include/GL/gl.h:411
GL_DEPTH_CLEAR_VALUE = 2931 	# /usr/include/GL/gl.h:412
GL_DEPTH_FUNC = 2932 	# /usr/include/GL/gl.h:413
GL_ACCUM_CLEAR_VALUE = 2944 	# /usr/include/GL/gl.h:414
GL_STENCIL_TEST = 2960 	# /usr/include/GL/gl.h:415
GL_STENCIL_CLEAR_VALUE = 2961 	# /usr/include/GL/gl.h:416
GL_STENCIL_FUNC = 2962 	# /usr/include/GL/gl.h:417
GL_STENCIL_VALUE_MASK = 2963 	# /usr/include/GL/gl.h:418
GL_STENCIL_FAIL = 2964 	# /usr/include/GL/gl.h:419
GL_STENCIL_PASS_DEPTH_FAIL = 2965 	# /usr/include/GL/gl.h:420
GL_STENCIL_PASS_DEPTH_PASS = 2966 	# /usr/include/GL/gl.h:421
GL_STENCIL_REF = 2967 	# /usr/include/GL/gl.h:422
GL_STENCIL_WRITEMASK = 2968 	# /usr/include/GL/gl.h:423
GL_MATRIX_MODE = 2976 	# /usr/include/GL/gl.h:424
GL_NORMALIZE = 2977 	# /usr/include/GL/gl.h:425
GL_VIEWPORT = 2978 	# /usr/include/GL/gl.h:426
GL_MODELVIEW_STACK_DEPTH = 2979 	# /usr/include/GL/gl.h:427
GL_PROJECTION_STACK_DEPTH = 2980 	# /usr/include/GL/gl.h:428
GL_TEXTURE_STACK_DEPTH = 2981 	# /usr/include/GL/gl.h:429
GL_MODELVIEW_MATRIX = 2982 	# /usr/include/GL/gl.h:430
GL_PROJECTION_MATRIX = 2983 	# /usr/include/GL/gl.h:431
GL_TEXTURE_MATRIX = 2984 	# /usr/include/GL/gl.h:432
GL_ATTRIB_STACK_DEPTH = 2992 	# /usr/include/GL/gl.h:433
GL_CLIENT_ATTRIB_STACK_DEPTH = 2993 	# /usr/include/GL/gl.h:434
GL_ALPHA_TEST = 3008 	# /usr/include/GL/gl.h:435
GL_ALPHA_TEST_FUNC = 3009 	# /usr/include/GL/gl.h:436
GL_ALPHA_TEST_REF = 3010 	# /usr/include/GL/gl.h:437
GL_DITHER = 3024 	# /usr/include/GL/gl.h:438
GL_BLEND_DST = 3040 	# /usr/include/GL/gl.h:439
GL_BLEND_SRC = 3041 	# /usr/include/GL/gl.h:440
GL_BLEND = 3042 	# /usr/include/GL/gl.h:441
GL_LOGIC_OP_MODE = 3056 	# /usr/include/GL/gl.h:442
GL_INDEX_LOGIC_OP = 3057 	# /usr/include/GL/gl.h:443
GL_LOGIC_OP = 3057 	# /usr/include/GL/gl.h:444
GL_COLOR_LOGIC_OP = 3058 	# /usr/include/GL/gl.h:445
GL_AUX_BUFFERS = 3072 	# /usr/include/GL/gl.h:446
GL_DRAW_BUFFER = 3073 	# /usr/include/GL/gl.h:447
GL_READ_BUFFER = 3074 	# /usr/include/GL/gl.h:448
GL_SCISSOR_BOX = 3088 	# /usr/include/GL/gl.h:449
GL_SCISSOR_TEST = 3089 	# /usr/include/GL/gl.h:450
GL_INDEX_CLEAR_VALUE = 3104 	# /usr/include/GL/gl.h:451
GL_INDEX_WRITEMASK = 3105 	# /usr/include/GL/gl.h:452
GL_COLOR_CLEAR_VALUE = 3106 	# /usr/include/GL/gl.h:453
GL_COLOR_WRITEMASK = 3107 	# /usr/include/GL/gl.h:454
GL_INDEX_MODE = 3120 	# /usr/include/GL/gl.h:455
GL_RGBA_MODE = 3121 	# /usr/include/GL/gl.h:456
GL_DOUBLEBUFFER = 3122 	# /usr/include/GL/gl.h:457
GL_STEREO = 3123 	# /usr/include/GL/gl.h:458
GL_RENDER_MODE = 3136 	# /usr/include/GL/gl.h:459
GL_PERSPECTIVE_CORRECTION_HINT = 3152 	# /usr/include/GL/gl.h:460
GL_POINT_SMOOTH_HINT = 3153 	# /usr/include/GL/gl.h:461
GL_LINE_SMOOTH_HINT = 3154 	# /usr/include/GL/gl.h:462
GL_POLYGON_SMOOTH_HINT = 3155 	# /usr/include/GL/gl.h:463
GL_FOG_HINT = 3156 	# /usr/include/GL/gl.h:464
GL_TEXTURE_GEN_S = 3168 	# /usr/include/GL/gl.h:465
GL_TEXTURE_GEN_T = 3169 	# /usr/include/GL/gl.h:466
GL_TEXTURE_GEN_R = 3170 	# /usr/include/GL/gl.h:467
GL_TEXTURE_GEN_Q = 3171 	# /usr/include/GL/gl.h:468
GL_PIXEL_MAP_I_TO_I_SIZE = 3248 	# /usr/include/GL/gl.h:469
GL_PIXEL_MAP_S_TO_S_SIZE = 3249 	# /usr/include/GL/gl.h:470
GL_PIXEL_MAP_I_TO_R_SIZE = 3250 	# /usr/include/GL/gl.h:471
GL_PIXEL_MAP_I_TO_G_SIZE = 3251 	# /usr/include/GL/gl.h:472
GL_PIXEL_MAP_I_TO_B_SIZE = 3252 	# /usr/include/GL/gl.h:473
GL_PIXEL_MAP_I_TO_A_SIZE = 3253 	# /usr/include/GL/gl.h:474
GL_PIXEL_MAP_R_TO_R_SIZE = 3254 	# /usr/include/GL/gl.h:475
GL_PIXEL_MAP_G_TO_G_SIZE = 3255 	# /usr/include/GL/gl.h:476
GL_PIXEL_MAP_B_TO_B_SIZE = 3256 	# /usr/include/GL/gl.h:477
GL_PIXEL_MAP_A_TO_A_SIZE = 3257 	# /usr/include/GL/gl.h:478
GL_UNPACK_SWAP_BYTES = 3312 	# /usr/include/GL/gl.h:479
GL_UNPACK_LSB_FIRST = 3313 	# /usr/include/GL/gl.h:480
GL_UNPACK_ROW_LENGTH = 3314 	# /usr/include/GL/gl.h:481
GL_UNPACK_SKIP_ROWS = 3315 	# /usr/include/GL/gl.h:482
GL_UNPACK_SKIP_PIXELS = 3316 	# /usr/include/GL/gl.h:483
GL_UNPACK_ALIGNMENT = 3317 	# /usr/include/GL/gl.h:484
GL_PACK_SWAP_BYTES = 3328 	# /usr/include/GL/gl.h:485
GL_PACK_LSB_FIRST = 3329 	# /usr/include/GL/gl.h:486
GL_PACK_ROW_LENGTH = 3330 	# /usr/include/GL/gl.h:487
GL_PACK_SKIP_ROWS = 3331 	# /usr/include/GL/gl.h:488
GL_PACK_SKIP_PIXELS = 3332 	# /usr/include/GL/gl.h:489
GL_PACK_ALIGNMENT = 3333 	# /usr/include/GL/gl.h:490
GL_MAP_COLOR = 3344 	# /usr/include/GL/gl.h:491
GL_MAP_STENCIL = 3345 	# /usr/include/GL/gl.h:492
GL_INDEX_SHIFT = 3346 	# /usr/include/GL/gl.h:493
GL_INDEX_OFFSET = 3347 	# /usr/include/GL/gl.h:494
GL_RED_SCALE = 3348 	# /usr/include/GL/gl.h:495
GL_RED_BIAS = 3349 	# /usr/include/GL/gl.h:496
GL_ZOOM_X = 3350 	# /usr/include/GL/gl.h:497
GL_ZOOM_Y = 3351 	# /usr/include/GL/gl.h:498
GL_GREEN_SCALE = 3352 	# /usr/include/GL/gl.h:499
GL_GREEN_BIAS = 3353 	# /usr/include/GL/gl.h:500
GL_BLUE_SCALE = 3354 	# /usr/include/GL/gl.h:501
GL_BLUE_BIAS = 3355 	# /usr/include/GL/gl.h:502
GL_ALPHA_SCALE = 3356 	# /usr/include/GL/gl.h:503
GL_ALPHA_BIAS = 3357 	# /usr/include/GL/gl.h:504
GL_DEPTH_SCALE = 3358 	# /usr/include/GL/gl.h:505
GL_DEPTH_BIAS = 3359 	# /usr/include/GL/gl.h:506
GL_MAX_EVAL_ORDER = 3376 	# /usr/include/GL/gl.h:507
GL_MAX_LIGHTS = 3377 	# /usr/include/GL/gl.h:508
GL_MAX_CLIP_PLANES = 3378 	# /usr/include/GL/gl.h:509
GL_MAX_TEXTURE_SIZE = 3379 	# /usr/include/GL/gl.h:510
GL_MAX_PIXEL_MAP_TABLE = 3380 	# /usr/include/GL/gl.h:511
GL_MAX_ATTRIB_STACK_DEPTH = 3381 	# /usr/include/GL/gl.h:512
GL_MAX_MODELVIEW_STACK_DEPTH = 3382 	# /usr/include/GL/gl.h:513
GL_MAX_NAME_STACK_DEPTH = 3383 	# /usr/include/GL/gl.h:514
GL_MAX_PROJECTION_STACK_DEPTH = 3384 	# /usr/include/GL/gl.h:515
GL_MAX_TEXTURE_STACK_DEPTH = 3385 	# /usr/include/GL/gl.h:516
GL_MAX_VIEWPORT_DIMS = 3386 	# /usr/include/GL/gl.h:517
GL_MAX_CLIENT_ATTRIB_STACK_DEPTH = 3387 	# /usr/include/GL/gl.h:518
GL_SUBPIXEL_BITS = 3408 	# /usr/include/GL/gl.h:519
GL_INDEX_BITS = 3409 	# /usr/include/GL/gl.h:520
GL_RED_BITS = 3410 	# /usr/include/GL/gl.h:521
GL_GREEN_BITS = 3411 	# /usr/include/GL/gl.h:522
GL_BLUE_BITS = 3412 	# /usr/include/GL/gl.h:523
GL_ALPHA_BITS = 3413 	# /usr/include/GL/gl.h:524
GL_DEPTH_BITS = 3414 	# /usr/include/GL/gl.h:525
GL_STENCIL_BITS = 3415 	# /usr/include/GL/gl.h:526
GL_ACCUM_RED_BITS = 3416 	# /usr/include/GL/gl.h:527
GL_ACCUM_GREEN_BITS = 3417 	# /usr/include/GL/gl.h:528
GL_ACCUM_BLUE_BITS = 3418 	# /usr/include/GL/gl.h:529
GL_ACCUM_ALPHA_BITS = 3419 	# /usr/include/GL/gl.h:530
GL_NAME_STACK_DEPTH = 3440 	# /usr/include/GL/gl.h:531
GL_AUTO_NORMAL = 3456 	# /usr/include/GL/gl.h:532
GL_MAP1_COLOR_4 = 3472 	# /usr/include/GL/gl.h:533
GL_MAP1_INDEX = 3473 	# /usr/include/GL/gl.h:534
GL_MAP1_NORMAL = 3474 	# /usr/include/GL/gl.h:535
GL_MAP1_TEXTURE_COORD_1 = 3475 	# /usr/include/GL/gl.h:536
GL_MAP1_TEXTURE_COORD_2 = 3476 	# /usr/include/GL/gl.h:537
GL_MAP1_TEXTURE_COORD_3 = 3477 	# /usr/include/GL/gl.h:538
GL_MAP1_TEXTURE_COORD_4 = 3478 	# /usr/include/GL/gl.h:539
GL_MAP1_VERTEX_3 = 3479 	# /usr/include/GL/gl.h:540
GL_MAP1_VERTEX_4 = 3480 	# /usr/include/GL/gl.h:541
GL_MAP2_COLOR_4 = 3504 	# /usr/include/GL/gl.h:542
GL_MAP2_INDEX = 3505 	# /usr/include/GL/gl.h:543
GL_MAP2_NORMAL = 3506 	# /usr/include/GL/gl.h:544
GL_MAP2_TEXTURE_COORD_1 = 3507 	# /usr/include/GL/gl.h:545
GL_MAP2_TEXTURE_COORD_2 = 3508 	# /usr/include/GL/gl.h:546
GL_MAP2_TEXTURE_COORD_3 = 3509 	# /usr/include/GL/gl.h:547
GL_MAP2_TEXTURE_COORD_4 = 3510 	# /usr/include/GL/gl.h:548
GL_MAP2_VERTEX_3 = 3511 	# /usr/include/GL/gl.h:549
GL_MAP2_VERTEX_4 = 3512 	# /usr/include/GL/gl.h:550
GL_MAP1_GRID_DOMAIN = 3536 	# /usr/include/GL/gl.h:551
GL_MAP1_GRID_SEGMENTS = 3537 	# /usr/include/GL/gl.h:552
GL_MAP2_GRID_DOMAIN = 3538 	# /usr/include/GL/gl.h:553
GL_MAP2_GRID_SEGMENTS = 3539 	# /usr/include/GL/gl.h:554
GL_TEXTURE_1D = 3552 	# /usr/include/GL/gl.h:555
GL_TEXTURE_2D = 3553 	# /usr/include/GL/gl.h:556
GL_FEEDBACK_BUFFER_POINTER = 3568 	# /usr/include/GL/gl.h:557
GL_FEEDBACK_BUFFER_SIZE = 3569 	# /usr/include/GL/gl.h:558
GL_FEEDBACK_BUFFER_TYPE = 3570 	# /usr/include/GL/gl.h:559
GL_SELECTION_BUFFER_POINTER = 3571 	# /usr/include/GL/gl.h:560
GL_SELECTION_BUFFER_SIZE = 3572 	# /usr/include/GL/gl.h:561
GL_POLYGON_OFFSET_UNITS = 10752 	# /usr/include/GL/gl.h:562
GL_POLYGON_OFFSET_POINT = 10753 	# /usr/include/GL/gl.h:563
GL_POLYGON_OFFSET_LINE = 10754 	# /usr/include/GL/gl.h:564
GL_POLYGON_OFFSET_FILL = 32823 	# /usr/include/GL/gl.h:565
GL_POLYGON_OFFSET_FACTOR = 32824 	# /usr/include/GL/gl.h:566
GL_TEXTURE_BINDING_1D = 32872 	# /usr/include/GL/gl.h:567
GL_TEXTURE_BINDING_2D = 32873 	# /usr/include/GL/gl.h:568
GL_TEXTURE_BINDING_3D = 32874 	# /usr/include/GL/gl.h:569
GL_VERTEX_ARRAY = 32884 	# /usr/include/GL/gl.h:570
GL_NORMAL_ARRAY = 32885 	# /usr/include/GL/gl.h:571
GL_COLOR_ARRAY = 32886 	# /usr/include/GL/gl.h:572
GL_INDEX_ARRAY = 32887 	# /usr/include/GL/gl.h:573
GL_TEXTURE_COORD_ARRAY = 32888 	# /usr/include/GL/gl.h:574
GL_EDGE_FLAG_ARRAY = 32889 	# /usr/include/GL/gl.h:575
GL_VERTEX_ARRAY_SIZE = 32890 	# /usr/include/GL/gl.h:576
GL_VERTEX_ARRAY_TYPE = 32891 	# /usr/include/GL/gl.h:577
GL_VERTEX_ARRAY_STRIDE = 32892 	# /usr/include/GL/gl.h:578
GL_NORMAL_ARRAY_TYPE = 32894 	# /usr/include/GL/gl.h:579
GL_NORMAL_ARRAY_STRIDE = 32895 	# /usr/include/GL/gl.h:580
GL_COLOR_ARRAY_SIZE = 32897 	# /usr/include/GL/gl.h:581
GL_COLOR_ARRAY_TYPE = 32898 	# /usr/include/GL/gl.h:582
GL_COLOR_ARRAY_STRIDE = 32899 	# /usr/include/GL/gl.h:583
GL_INDEX_ARRAY_TYPE = 32901 	# /usr/include/GL/gl.h:584
GL_INDEX_ARRAY_STRIDE = 32902 	# /usr/include/GL/gl.h:585
GL_TEXTURE_COORD_ARRAY_SIZE = 32904 	# /usr/include/GL/gl.h:586
GL_TEXTURE_COORD_ARRAY_TYPE = 32905 	# /usr/include/GL/gl.h:587
GL_TEXTURE_COORD_ARRAY_STRIDE = 32906 	# /usr/include/GL/gl.h:588
GL_EDGE_FLAG_ARRAY_STRIDE = 32908 	# /usr/include/GL/gl.h:589
GL_TEXTURE_WIDTH = 4096 	# /usr/include/GL/gl.h:602
GL_TEXTURE_HEIGHT = 4097 	# /usr/include/GL/gl.h:603
GL_TEXTURE_INTERNAL_FORMAT = 4099 	# /usr/include/GL/gl.h:604
GL_TEXTURE_COMPONENTS = 4099 	# /usr/include/GL/gl.h:605
GL_TEXTURE_BORDER_COLOR = 4100 	# /usr/include/GL/gl.h:606
GL_TEXTURE_BORDER = 4101 	# /usr/include/GL/gl.h:607
GL_TEXTURE_RED_SIZE = 32860 	# /usr/include/GL/gl.h:608
GL_TEXTURE_GREEN_SIZE = 32861 	# /usr/include/GL/gl.h:609
GL_TEXTURE_BLUE_SIZE = 32862 	# /usr/include/GL/gl.h:610
GL_TEXTURE_ALPHA_SIZE = 32863 	# /usr/include/GL/gl.h:611
GL_TEXTURE_LUMINANCE_SIZE = 32864 	# /usr/include/GL/gl.h:612
GL_TEXTURE_INTENSITY_SIZE = 32865 	# /usr/include/GL/gl.h:613
GL_TEXTURE_PRIORITY = 32870 	# /usr/include/GL/gl.h:614
GL_TEXTURE_RESIDENT = 32871 	# /usr/include/GL/gl.h:615
GL_DONT_CARE = 4352 	# /usr/include/GL/gl.h:618
GL_FASTEST = 4353 	# /usr/include/GL/gl.h:619
GL_NICEST = 4354 	# /usr/include/GL/gl.h:620
GL_AMBIENT = 4608 	# /usr/include/GL/gl.h:654
GL_DIFFUSE = 4609 	# /usr/include/GL/gl.h:655
GL_SPECULAR = 4610 	# /usr/include/GL/gl.h:656
GL_POSITION = 4611 	# /usr/include/GL/gl.h:657
GL_SPOT_DIRECTION = 4612 	# /usr/include/GL/gl.h:658
GL_SPOT_EXPONENT = 4613 	# /usr/include/GL/gl.h:659
GL_SPOT_CUTOFF = 4614 	# /usr/include/GL/gl.h:660
GL_CONSTANT_ATTENUATION = 4615 	# /usr/include/GL/gl.h:661
GL_LINEAR_ATTENUATION = 4616 	# /usr/include/GL/gl.h:662
GL_QUADRATIC_ATTENUATION = 4617 	# /usr/include/GL/gl.h:663
GL_COMPILE = 4864 	# /usr/include/GL/gl.h:666
GL_COMPILE_AND_EXECUTE = 4865 	# /usr/include/GL/gl.h:667
GL_BYTE = 5120 	# /usr/include/GL/gl.h:670
GL_UNSIGNED_BYTE = 5121 	# /usr/include/GL/gl.h:671
GL_SHORT = 5122 	# /usr/include/GL/gl.h:672
GL_UNSIGNED_SHORT = 5123 	# /usr/include/GL/gl.h:673
GL_INT = 5124 	# /usr/include/GL/gl.h:674
GL_UNSIGNED_INT = 5125 	# /usr/include/GL/gl.h:675
GL_FLOAT = 5126 	# /usr/include/GL/gl.h:676
GL_2_BYTES = 5127 	# /usr/include/GL/gl.h:677
GL_3_BYTES = 5128 	# /usr/include/GL/gl.h:678
GL_4_BYTES = 5129 	# /usr/include/GL/gl.h:679
GL_DOUBLE = 5130 	# /usr/include/GL/gl.h:680
GL_DOUBLE_EXT = 5130 	# /usr/include/GL/gl.h:681
GL_CLEAR = 5376 	# /usr/include/GL/gl.h:696
GL_AND = 5377 	# /usr/include/GL/gl.h:697
GL_AND_REVERSE = 5378 	# /usr/include/GL/gl.h:698
GL_COPY = 5379 	# /usr/include/GL/gl.h:699
GL_AND_INVERTED = 5380 	# /usr/include/GL/gl.h:700
GL_NOOP = 5381 	# /usr/include/GL/gl.h:701
GL_XOR = 5382 	# /usr/include/GL/gl.h:702
GL_OR = 5383 	# /usr/include/GL/gl.h:703
GL_NOR = 5384 	# /usr/include/GL/gl.h:704
GL_EQUIV = 5385 	# /usr/include/GL/gl.h:705
GL_INVERT = 5386 	# /usr/include/GL/gl.h:706
GL_OR_REVERSE = 5387 	# /usr/include/GL/gl.h:707
GL_COPY_INVERTED = 5388 	# /usr/include/GL/gl.h:708
GL_OR_INVERTED = 5389 	# /usr/include/GL/gl.h:709
GL_NAND = 5390 	# /usr/include/GL/gl.h:710
GL_SET = 5391 	# /usr/include/GL/gl.h:711
GL_EMISSION = 5632 	# /usr/include/GL/gl.h:739
GL_SHININESS = 5633 	# /usr/include/GL/gl.h:740
GL_AMBIENT_AND_DIFFUSE = 5634 	# /usr/include/GL/gl.h:741
GL_COLOR_INDEXES = 5635 	# /usr/include/GL/gl.h:742
GL_MODELVIEW = 5888 	# /usr/include/GL/gl.h:748
GL_PROJECTION = 5889 	# /usr/include/GL/gl.h:749
GL_TEXTURE = 5890 	# /usr/include/GL/gl.h:750
GL_COLOR = 6144 	# /usr/include/GL/gl.h:769
GL_DEPTH = 6145 	# /usr/include/GL/gl.h:770
GL_STENCIL = 6146 	# /usr/include/GL/gl.h:771
GL_COLOR_INDEX = 6400 	# /usr/include/GL/gl.h:774
GL_STENCIL_INDEX = 6401 	# /usr/include/GL/gl.h:775
GL_DEPTH_COMPONENT = 6402 	# /usr/include/GL/gl.h:776
GL_RED = 6403 	# /usr/include/GL/gl.h:777
GL_GREEN = 6404 	# /usr/include/GL/gl.h:778
GL_BLUE = 6405 	# /usr/include/GL/gl.h:779
GL_ALPHA = 6406 	# /usr/include/GL/gl.h:780
GL_RGB = 6407 	# /usr/include/GL/gl.h:781
GL_RGBA = 6408 	# /usr/include/GL/gl.h:782
GL_LUMINANCE = 6409 	# /usr/include/GL/gl.h:783
GL_LUMINANCE_ALPHA = 6410 	# /usr/include/GL/gl.h:784
GL_BITMAP = 6656 	# /usr/include/GL/gl.h:830
GL_POINT = 6912 	# /usr/include/GL/gl.h:845
GL_LINE = 6913 	# /usr/include/GL/gl.h:846
GL_FILL = 6914 	# /usr/include/GL/gl.h:847
GL_RENDER = 7168 	# /usr/include/GL/gl.h:864
GL_FEEDBACK = 7169 	# /usr/include/GL/gl.h:865
GL_SELECT = 7170 	# /usr/include/GL/gl.h:866
GL_FLAT = 7424 	# /usr/include/GL/gl.h:869
GL_SMOOTH = 7425 	# /usr/include/GL/gl.h:870
GL_KEEP = 7680 	# /usr/include/GL/gl.h:884
GL_REPLACE = 7681 	# /usr/include/GL/gl.h:885
GL_INCR = 7682 	# /usr/include/GL/gl.h:886
GL_DECR = 7683 	# /usr/include/GL/gl.h:887
GL_VENDOR = 7936 	# /usr/include/GL/gl.h:891
GL_RENDERER = 7937 	# /usr/include/GL/gl.h:892
GL_VERSION = 7938 	# /usr/include/GL/gl.h:893
GL_EXTENSIONS = 7939 	# /usr/include/GL/gl.h:894
GL_S = 8192 	# /usr/include/GL/gl.h:903
GL_T = 8193 	# /usr/include/GL/gl.h:904
GL_R = 8194 	# /usr/include/GL/gl.h:905
GL_Q = 8195 	# /usr/include/GL/gl.h:906
GL_MODULATE = 8448 	# /usr/include/GL/gl.h:909
GL_DECAL = 8449 	# /usr/include/GL/gl.h:910
GL_TEXTURE_ENV_MODE = 8704 	# /usr/include/GL/gl.h:916
GL_TEXTURE_ENV_COLOR = 8705 	# /usr/include/GL/gl.h:917
GL_TEXTURE_ENV = 8960 	# /usr/include/GL/gl.h:920
GL_EYE_LINEAR = 9216 	# /usr/include/GL/gl.h:923
GL_OBJECT_LINEAR = 9217 	# /usr/include/GL/gl.h:924
GL_SPHERE_MAP = 9218 	# /usr/include/GL/gl.h:925
GL_TEXTURE_GEN_MODE = 9472 	# /usr/include/GL/gl.h:928
GL_OBJECT_PLANE = 9473 	# /usr/include/GL/gl.h:929
GL_EYE_PLANE = 9474 	# /usr/include/GL/gl.h:930
GL_NEAREST = 9728 	# /usr/include/GL/gl.h:933
GL_LINEAR = 9729 	# /usr/include/GL/gl.h:934
GL_NEAREST_MIPMAP_NEAREST = 9984 	# /usr/include/GL/gl.h:939
GL_LINEAR_MIPMAP_NEAREST = 9985 	# /usr/include/GL/gl.h:940
GL_NEAREST_MIPMAP_LINEAR = 9986 	# /usr/include/GL/gl.h:941
GL_LINEAR_MIPMAP_LINEAR = 9987 	# /usr/include/GL/gl.h:942
GL_TEXTURE_MAG_FILTER = 10240 	# /usr/include/GL/gl.h:945
GL_TEXTURE_MIN_FILTER = 10241 	# /usr/include/GL/gl.h:946
GL_TEXTURE_WRAP_S = 10242 	# /usr/include/GL/gl.h:947
GL_TEXTURE_WRAP_T = 10243 	# /usr/include/GL/gl.h:948
GL_PROXY_TEXTURE_1D = 32867 	# /usr/include/GL/gl.h:955
GL_PROXY_TEXTURE_2D = 32868 	# /usr/include/GL/gl.h:956
GL_CLAMP = 10496 	# /usr/include/GL/gl.h:959
GL_REPEAT = 10497 	# /usr/include/GL/gl.h:960
GL_R3_G3_B2 = 10768 	# /usr/include/GL/gl.h:963
GL_ALPHA4 = 32827 	# /usr/include/GL/gl.h:964
GL_ALPHA8 = 32828 	# /usr/include/GL/gl.h:965
GL_ALPHA12 = 32829 	# /usr/include/GL/gl.h:966
GL_ALPHA16 = 32830 	# /usr/include/GL/gl.h:967
GL_LUMINANCE4 = 32831 	# /usr/include/GL/gl.h:968
GL_LUMINANCE8 = 32832 	# /usr/include/GL/gl.h:969
GL_LUMINANCE12 = 32833 	# /usr/include/GL/gl.h:970
GL_LUMINANCE16 = 32834 	# /usr/include/GL/gl.h:971
GL_LUMINANCE4_ALPHA4 = 32835 	# /usr/include/GL/gl.h:972
GL_LUMINANCE6_ALPHA2 = 32836 	# /usr/include/GL/gl.h:973
GL_LUMINANCE8_ALPHA8 = 32837 	# /usr/include/GL/gl.h:974
GL_LUMINANCE12_ALPHA4 = 32838 	# /usr/include/GL/gl.h:975
GL_LUMINANCE12_ALPHA12 = 32839 	# /usr/include/GL/gl.h:976
GL_LUMINANCE16_ALPHA16 = 32840 	# /usr/include/GL/gl.h:977
GL_INTENSITY = 32841 	# /usr/include/GL/gl.h:978
GL_INTENSITY4 = 32842 	# /usr/include/GL/gl.h:979
GL_INTENSITY8 = 32843 	# /usr/include/GL/gl.h:980
GL_INTENSITY12 = 32844 	# /usr/include/GL/gl.h:981
GL_INTENSITY16 = 32845 	# /usr/include/GL/gl.h:982
GL_RGB4 = 32847 	# /usr/include/GL/gl.h:983
GL_RGB5 = 32848 	# /usr/include/GL/gl.h:984
GL_RGB8 = 32849 	# /usr/include/GL/gl.h:985
GL_RGB10 = 32850 	# /usr/include/GL/gl.h:986
GL_RGB12 = 32851 	# /usr/include/GL/gl.h:987
GL_RGB16 = 32852 	# /usr/include/GL/gl.h:988
GL_RGBA2 = 32853 	# /usr/include/GL/gl.h:989
GL_RGBA4 = 32854 	# /usr/include/GL/gl.h:990
GL_RGB5_A1 = 32855 	# /usr/include/GL/gl.h:991
GL_RGBA8 = 32856 	# /usr/include/GL/gl.h:992
GL_RGB10_A2 = 32857 	# /usr/include/GL/gl.h:993
GL_RGBA12 = 32858 	# /usr/include/GL/gl.h:994
GL_RGBA16 = 32859 	# /usr/include/GL/gl.h:995
GL_V2F = 10784 	# /usr/include/GL/gl.h:998
GL_V3F = 10785 	# /usr/include/GL/gl.h:999
GL_C4UB_V2F = 10786 	# /usr/include/GL/gl.h:1000
GL_C4UB_V3F = 10787 	# /usr/include/GL/gl.h:1001
GL_C3F_V3F = 10788 	# /usr/include/GL/gl.h:1002
GL_N3F_V3F = 10789 	# /usr/include/GL/gl.h:1003
GL_C4F_N3F_V3F = 10790 	# /usr/include/GL/gl.h:1004
GL_T2F_V3F = 10791 	# /usr/include/GL/gl.h:1005
GL_T4F_V4F = 10792 	# /usr/include/GL/gl.h:1006
GL_T2F_C4UB_V3F = 10793 	# /usr/include/GL/gl.h:1007
GL_T2F_C3F_V3F = 10794 	# /usr/include/GL/gl.h:1008
GL_T2F_N3F_V3F = 10795 	# /usr/include/GL/gl.h:1009
GL_T2F_C4F_N3F_V3F = 10796 	# /usr/include/GL/gl.h:1010
GL_T4F_C4F_N3F_V4F = 10797 	# /usr/include/GL/gl.h:1011
GL_CLIP_PLANE0 = 12288 	# /usr/include/GL/gl.h:1020
GL_CLIP_PLANE1 = 12289 	# /usr/include/GL/gl.h:1021
GL_CLIP_PLANE2 = 12290 	# /usr/include/GL/gl.h:1022
GL_CLIP_PLANE3 = 12291 	# /usr/include/GL/gl.h:1023
GL_CLIP_PLANE4 = 12292 	# /usr/include/GL/gl.h:1024
GL_CLIP_PLANE5 = 12293 	# /usr/include/GL/gl.h:1025
GL_LIGHT0 = 16384 	# /usr/include/GL/gl.h:1028
GL_LIGHT1 = 16385 	# /usr/include/GL/gl.h:1029
GL_LIGHT2 = 16386 	# /usr/include/GL/gl.h:1030
GL_LIGHT3 = 16387 	# /usr/include/GL/gl.h:1031
GL_LIGHT4 = 16388 	# /usr/include/GL/gl.h:1032
GL_LIGHT5 = 16389 	# /usr/include/GL/gl.h:1033
GL_LIGHT6 = 16390 	# /usr/include/GL/gl.h:1034
GL_LIGHT7 = 16391 	# /usr/include/GL/gl.h:1035
GL_ABGR_EXT = 32768 	# /usr/include/GL/gl.h:1038
GL_FUNC_SUBTRACT_EXT = 32778 	# /usr/include/GL/gl.h:1041
GL_FUNC_REVERSE_SUBTRACT_EXT = 32779 	# /usr/include/GL/gl.h:1042
GL_UNSIGNED_BYTE_3_3_2_EXT = 32818 	# /usr/include/GL/gl.h:1045
GL_UNSIGNED_SHORT_4_4_4_4_EXT = 32819 	# /usr/include/GL/gl.h:1046
GL_UNSIGNED_SHORT_5_5_5_1_EXT = 32820 	# /usr/include/GL/gl.h:1047
GL_UNSIGNED_INT_8_8_8_8_EXT = 32821 	# /usr/include/GL/gl.h:1048
GL_UNSIGNED_INT_10_10_10_2_EXT = 32822 	# /usr/include/GL/gl.h:1049
GL_PACK_SKIP_IMAGES = 32875 	# /usr/include/GL/gl.h:1052
GL_PACK_IMAGE_HEIGHT = 32876 	# /usr/include/GL/gl.h:1053
GL_UNPACK_SKIP_IMAGES = 32877 	# /usr/include/GL/gl.h:1054
GL_UNPACK_IMAGE_HEIGHT = 32878 	# /usr/include/GL/gl.h:1055
GL_TEXTURE_3D = 32879 	# /usr/include/GL/gl.h:1056
GL_PROXY_TEXTURE_3D = 32880 	# /usr/include/GL/gl.h:1057
GL_TEXTURE_DEPTH = 32881 	# /usr/include/GL/gl.h:1058
GL_TEXTURE_WRAP_R = 32882 	# /usr/include/GL/gl.h:1059
GL_MAX_3D_TEXTURE_SIZE = 32883 	# /usr/include/GL/gl.h:1060
GL_BGR = 32992 	# /usr/include/GL/gl.h:1061
GL_BGRA = 32993 	# /usr/include/GL/gl.h:1062
GL_UNSIGNED_BYTE_3_3_2 = 32818 	# /usr/include/GL/gl.h:1063
GL_UNSIGNED_BYTE_2_3_3_REV = 33634 	# /usr/include/GL/gl.h:1064
GL_UNSIGNED_SHORT_5_6_5 = 33635 	# /usr/include/GL/gl.h:1065
GL_UNSIGNED_SHORT_5_6_5_REV = 33636 	# /usr/include/GL/gl.h:1066
GL_UNSIGNED_SHORT_4_4_4_4 = 32819 	# /usr/include/GL/gl.h:1067
GL_UNSIGNED_SHORT_4_4_4_4_REV = 33637 	# /usr/include/GL/gl.h:1068
GL_UNSIGNED_SHORT_5_5_5_1 = 32820 	# /usr/include/GL/gl.h:1069
GL_UNSIGNED_SHORT_1_5_5_5_REV = 33638 	# /usr/include/GL/gl.h:1070
GL_UNSIGNED_INT_8_8_8_8 = 32821 	# /usr/include/GL/gl.h:1071
GL_UNSIGNED_INT_8_8_8_8_REV = 33639 	# /usr/include/GL/gl.h:1072
GL_UNSIGNED_INT_10_10_10_2 = 32822 	# /usr/include/GL/gl.h:1073
GL_UNSIGNED_INT_2_10_10_10_REV = 33640 	# /usr/include/GL/gl.h:1074
GL_RESCALE_NORMAL = 32826 	# /usr/include/GL/gl.h:1075
GL_LIGHT_MODEL_COLOR_CONTROL = 33272 	# /usr/include/GL/gl.h:1076
GL_SINGLE_COLOR = 33273 	# /usr/include/GL/gl.h:1077
GL_SEPARATE_SPECULAR_COLOR = 33274 	# /usr/include/GL/gl.h:1078
GL_CLAMP_TO_EDGE = 33071 	# /usr/include/GL/gl.h:1079
GL_TEXTURE_MIN_LOD = 33082 	# /usr/include/GL/gl.h:1080
GL_TEXTURE_MAX_LOD = 33083 	# /usr/include/GL/gl.h:1081
GL_TEXTURE_BASE_LEVEL = 33084 	# /usr/include/GL/gl.h:1082
GL_TEXTURE_MAX_LEVEL = 33085 	# /usr/include/GL/gl.h:1083
GL_MAX_ELEMENTS_VERTICES = 33000 	# /usr/include/GL/gl.h:1084
GL_MAX_ELEMENTS_INDICES = 33001 	# /usr/include/GL/gl.h:1085
GL_ALIASED_POINT_SIZE_RANGE = 33901 	# /usr/include/GL/gl.h:1086
GL_ALIASED_LINE_WIDTH_RANGE = 33902 	# /usr/include/GL/gl.h:1087
GL_ACTIVE_TEXTURE = 34016 	# /usr/include/GL/gl.h:1090
GL_CLIENT_ACTIVE_TEXTURE = 34017 	# /usr/include/GL/gl.h:1091
GL_MAX_TEXTURE_UNITS = 34018 	# /usr/include/GL/gl.h:1092
GL_TEXTURE0 = 33984 	# /usr/include/GL/gl.h:1093
GL_TEXTURE1 = 33985 	# /usr/include/GL/gl.h:1094
GL_TEXTURE2 = 33986 	# /usr/include/GL/gl.h:1095
GL_TEXTURE3 = 33987 	# /usr/include/GL/gl.h:1096
GL_TEXTURE4 = 33988 	# /usr/include/GL/gl.h:1097
GL_TEXTURE5 = 33989 	# /usr/include/GL/gl.h:1098
GL_TEXTURE6 = 33990 	# /usr/include/GL/gl.h:1099
GL_TEXTURE7 = 33991 	# /usr/include/GL/gl.h:1100
GL_TEXTURE8 = 33992 	# /usr/include/GL/gl.h:1101
GL_TEXTURE9 = 33993 	# /usr/include/GL/gl.h:1102
GL_TEXTURE10 = 33994 	# /usr/include/GL/gl.h:1103
GL_TEXTURE11 = 33995 	# /usr/include/GL/gl.h:1104
GL_TEXTURE12 = 33996 	# /usr/include/GL/gl.h:1105
GL_TEXTURE13 = 33997 	# /usr/include/GL/gl.h:1106
GL_TEXTURE14 = 33998 	# /usr/include/GL/gl.h:1107
GL_TEXTURE15 = 33999 	# /usr/include/GL/gl.h:1108
GL_TEXTURE16 = 34000 	# /usr/include/GL/gl.h:1109
GL_TEXTURE17 = 34001 	# /usr/include/GL/gl.h:1110
GL_TEXTURE18 = 34002 	# /usr/include/GL/gl.h:1111
GL_TEXTURE19 = 34003 	# /usr/include/GL/gl.h:1112
GL_TEXTURE20 = 34004 	# /usr/include/GL/gl.h:1113
GL_TEXTURE21 = 34005 	# /usr/include/GL/gl.h:1114
GL_TEXTURE22 = 34006 	# /usr/include/GL/gl.h:1115
GL_TEXTURE23 = 34007 	# /usr/include/GL/gl.h:1116
GL_TEXTURE24 = 34008 	# /usr/include/GL/gl.h:1117
GL_TEXTURE25 = 34009 	# /usr/include/GL/gl.h:1118
GL_TEXTURE26 = 34010 	# /usr/include/GL/gl.h:1119
GL_TEXTURE27 = 34011 	# /usr/include/GL/gl.h:1120
GL_TEXTURE28 = 34012 	# /usr/include/GL/gl.h:1121
GL_TEXTURE29 = 34013 	# /usr/include/GL/gl.h:1122
GL_TEXTURE30 = 34014 	# /usr/include/GL/gl.h:1123
GL_TEXTURE31 = 34015 	# /usr/include/GL/gl.h:1124
GL_NORMAL_MAP = 34065 	# /usr/include/GL/gl.h:1125
GL_REFLECTION_MAP = 34066 	# /usr/include/GL/gl.h:1126
GL_TEXTURE_CUBE_MAP = 34067 	# /usr/include/GL/gl.h:1127
GL_TEXTURE_BINDING_CUBE_MAP = 34068 	# /usr/include/GL/gl.h:1128
GL_TEXTURE_CUBE_MAP_POSITIVE_X = 34069 	# /usr/include/GL/gl.h:1129
GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 34070 	# /usr/include/GL/gl.h:1130
GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 34071 	# /usr/include/GL/gl.h:1131
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072 	# /usr/include/GL/gl.h:1132
GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 34073 	# /usr/include/GL/gl.h:1133
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074 	# /usr/include/GL/gl.h:1134
GL_PROXY_TEXTURE_CUBE_MAP = 34075 	# /usr/include/GL/gl.h:1135
GL_MAX_CUBE_MAP_TEXTURE_SIZE = 34076 	# /usr/include/GL/gl.h:1136
GL_COMBINE = 34160 	# /usr/include/GL/gl.h:1137
GL_COMBINE_RGB = 34161 	# /usr/include/GL/gl.h:1138
GL_COMBINE_ALPHA = 34162 	# /usr/include/GL/gl.h:1139
GL_RGB_SCALE = 34163 	# /usr/include/GL/gl.h:1140
GL_ADD_SIGNED = 34164 	# /usr/include/GL/gl.h:1141
GL_INTERPOLATE = 34165 	# /usr/include/GL/gl.h:1142
GL_CONSTANT = 34166 	# /usr/include/GL/gl.h:1143
GL_PRIMARY_COLOR = 34167 	# /usr/include/GL/gl.h:1144
GL_PREVIOUS = 34168 	# /usr/include/GL/gl.h:1145
GL_SOURCE0_RGB = 34176 	# /usr/include/GL/gl.h:1146
GL_SOURCE1_RGB = 34177 	# /usr/include/GL/gl.h:1147
GL_SOURCE2_RGB = 34178 	# /usr/include/GL/gl.h:1148
GL_SOURCE0_ALPHA = 34184 	# /usr/include/GL/gl.h:1149
GL_SOURCE1_ALPHA = 34185 	# /usr/include/GL/gl.h:1150
GL_SOURCE2_ALPHA = 34186 	# /usr/include/GL/gl.h:1151
GL_OPERAND0_RGB = 34192 	# /usr/include/GL/gl.h:1152
GL_OPERAND1_RGB = 34193 	# /usr/include/GL/gl.h:1153
GL_OPERAND2_RGB = 34194 	# /usr/include/GL/gl.h:1154
GL_OPERAND0_ALPHA = 34200 	# /usr/include/GL/gl.h:1155
GL_OPERAND1_ALPHA = 34201 	# /usr/include/GL/gl.h:1156
GL_OPERAND2_ALPHA = 34202 	# /usr/include/GL/gl.h:1157
GL_SUBTRACT = 34023 	# /usr/include/GL/gl.h:1158
GL_TRANSPOSE_MODELVIEW_MATRIX = 34019 	# /usr/include/GL/gl.h:1159
GL_TRANSPOSE_PROJECTION_MATRIX = 34020 	# /usr/include/GL/gl.h:1160
GL_TRANSPOSE_TEXTURE_MATRIX = 34021 	# /usr/include/GL/gl.h:1161
GL_TRANSPOSE_COLOR_MATRIX = 34022 	# /usr/include/GL/gl.h:1162
GL_COMPRESSED_ALPHA = 34025 	# /usr/include/GL/gl.h:1163
GL_COMPRESSED_LUMINANCE = 34026 	# /usr/include/GL/gl.h:1164
GL_COMPRESSED_LUMINANCE_ALPHA = 34027 	# /usr/include/GL/gl.h:1165
GL_COMPRESSED_INTENSITY = 34028 	# /usr/include/GL/gl.h:1166
GL_COMPRESSED_RGB = 34029 	# /usr/include/GL/gl.h:1167
GL_COMPRESSED_RGBA = 34030 	# /usr/include/GL/gl.h:1168
GL_TEXTURE_COMPRESSION_HINT = 34031 	# /usr/include/GL/gl.h:1169
GL_TEXTURE_COMPRESSED_IMAGE_SIZE = 34464 	# /usr/include/GL/gl.h:1170
GL_TEXTURE_COMPRESSED = 34465 	# /usr/include/GL/gl.h:1171
GL_NUM_COMPRESSED_TEXTURE_FORMATS = 34466 	# /usr/include/GL/gl.h:1172
GL_COMPRESSED_TEXTURE_FORMATS = 34467 	# /usr/include/GL/gl.h:1173
GL_DOT3_RGB = 34478 	# /usr/include/GL/gl.h:1174
GL_DOT3_RGBA = 34479 	# /usr/include/GL/gl.h:1175
GL_CLAMP_TO_BORDER = 33069 	# /usr/include/GL/gl.h:1176
GL_MULTISAMPLE = 32925 	# /usr/include/GL/gl.h:1177
GL_SAMPLE_ALPHA_TO_COVERAGE = 32926 	# /usr/include/GL/gl.h:1178
GL_SAMPLE_ALPHA_TO_ONE = 32927 	# /usr/include/GL/gl.h:1179
GL_SAMPLE_COVERAGE = 32928 	# /usr/include/GL/gl.h:1180
GL_SAMPLE_BUFFERS = 32936 	# /usr/include/GL/gl.h:1181
GL_SAMPLES = 32937 	# /usr/include/GL/gl.h:1182
GL_SAMPLE_COVERAGE_VALUE = 32938 	# /usr/include/GL/gl.h:1183
GL_SAMPLE_COVERAGE_INVERT = 32939 	# /usr/include/GL/gl.h:1184
GL_MULTISAMPLE_BIT = 536870912 	# /usr/include/GL/gl.h:1185
GL_VERTEX_ARRAY_EXT = 32884 	# /usr/include/GL/gl.h:1188
GL_NORMAL_ARRAY_EXT = 32885 	# /usr/include/GL/gl.h:1189
GL_COLOR_ARRAY_EXT = 32886 	# /usr/include/GL/gl.h:1190
GL_INDEX_ARRAY_EXT = 32887 	# /usr/include/GL/gl.h:1191
GL_TEXTURE_COORD_ARRAY_EXT = 32888 	# /usr/include/GL/gl.h:1192
GL_EDGE_FLAG_ARRAY_EXT = 32889 	# /usr/include/GL/gl.h:1193
GL_VERTEX_ARRAY_SIZE_EXT = 32890 	# /usr/include/GL/gl.h:1194
GL_VERTEX_ARRAY_TYPE_EXT = 32891 	# /usr/include/GL/gl.h:1195
GL_VERTEX_ARRAY_STRIDE_EXT = 32892 	# /usr/include/GL/gl.h:1196
GL_VERTEX_ARRAY_COUNT_EXT = 32893 	# /usr/include/GL/gl.h:1197
GL_NORMAL_ARRAY_TYPE_EXT = 32894 	# /usr/include/GL/gl.h:1198
GL_NORMAL_ARRAY_STRIDE_EXT = 32895 	# /usr/include/GL/gl.h:1199
GL_NORMAL_ARRAY_COUNT_EXT = 32896 	# /usr/include/GL/gl.h:1200
GL_COLOR_ARRAY_SIZE_EXT = 32897 	# /usr/include/GL/gl.h:1201
GL_COLOR_ARRAY_TYPE_EXT = 32898 	# /usr/include/GL/gl.h:1202
GL_COLOR_ARRAY_STRIDE_EXT = 32899 	# /usr/include/GL/gl.h:1203
GL_COLOR_ARRAY_COUNT_EXT = 32900 	# /usr/include/GL/gl.h:1204
GL_INDEX_ARRAY_TYPE_EXT = 32901 	# /usr/include/GL/gl.h:1205
GL_INDEX_ARRAY_STRIDE_EXT = 32902 	# /usr/include/GL/gl.h:1206
GL_INDEX_ARRAY_COUNT_EXT = 32903 	# /usr/include/GL/gl.h:1207
GL_TEXTURE_COORD_ARRAY_SIZE_EXT = 32904 	# /usr/include/GL/gl.h:1208
GL_TEXTURE_COORD_ARRAY_TYPE_EXT = 32905 	# /usr/include/GL/gl.h:1209
GL_TEXTURE_COORD_ARRAY_STRIDE_EXT = 32906 	# /usr/include/GL/gl.h:1210
GL_TEXTURE_COORD_ARRAY_COUNT_EXT = 32907 	# /usr/include/GL/gl.h:1211
GL_EDGE_FLAG_ARRAY_STRIDE_EXT = 32908 	# /usr/include/GL/gl.h:1212
GL_EDGE_FLAG_ARRAY_COUNT_EXT = 32909 	# /usr/include/GL/gl.h:1213
GL_VERTEX_ARRAY_POINTER_EXT = 32910 	# /usr/include/GL/gl.h:1214
GL_NORMAL_ARRAY_POINTER_EXT = 32911 	# /usr/include/GL/gl.h:1215
GL_COLOR_ARRAY_POINTER_EXT = 32912 	# /usr/include/GL/gl.h:1216
GL_INDEX_ARRAY_POINTER_EXT = 32913 	# /usr/include/GL/gl.h:1217
GL_TEXTURE_COORD_ARRAY_POINTER_EXT = 32914 	# /usr/include/GL/gl.h:1218
GL_EDGE_FLAG_ARRAY_POINTER_EXT = 32915 	# /usr/include/GL/gl.h:1219
GL_TEXTURE_MIN_LOD_SGIS = 33082 	# /usr/include/GL/gl.h:1222
GL_TEXTURE_MAX_LOD_SGIS = 33083 	# /usr/include/GL/gl.h:1223
GL_TEXTURE_BASE_LEVEL_SGIS = 33084 	# /usr/include/GL/gl.h:1224
GL_TEXTURE_MAX_LEVEL_SGIS = 33085 	# /usr/include/GL/gl.h:1225
GL_SHARED_TEXTURE_PALETTE_EXT = 33275 	# /usr/include/GL/gl.h:1228
GL_RESCALE_NORMAL_EXT = 32826 	# /usr/include/GL/gl.h:1231
GL_TEXTURE_COMPARE_SGIX = 33178 	# /usr/include/GL/gl.h:1234
GL_TEXTURE_COMPARE_OPERATOR_SGIX = 33179 	# /usr/include/GL/gl.h:1235
GL_TEXTURE_LEQUAL_R_SGIX = 33180 	# /usr/include/GL/gl.h:1236
GL_TEXTURE_GEQUAL_R_SGIX = 33181 	# /usr/include/GL/gl.h:1237
GL_DEPTH_COMPONENT16_SGIX = 33189 	# /usr/include/GL/gl.h:1240
GL_DEPTH_COMPONENT24_SGIX = 33190 	# /usr/include/GL/gl.h:1241
GL_DEPTH_COMPONENT32_SGIX = 33191 	# /usr/include/GL/gl.h:1242
GL_GENERATE_MIPMAP_SGIS = 33169 	# /usr/include/GL/gl.h:1245
GL_GENERATE_MIPMAP_HINT_SGIS = 33170 	# /usr/include/GL/gl.h:1246
GL_POINT_SIZE_MIN = 33062 	# /usr/include/GL/gl.h:1249
GL_POINT_SIZE_MAX = 33063 	# /usr/include/GL/gl.h:1250
GL_POINT_FADE_THRESHOLD_SIZE = 33064 	# /usr/include/GL/gl.h:1251
GL_POINT_DISTANCE_ATTENUATION = 33065 	# /usr/include/GL/gl.h:1252
GL_FOG_COORDINATE_SOURCE = 33872 	# /usr/include/GL/gl.h:1253
GL_FOG_COORDINATE = 33873 	# /usr/include/GL/gl.h:1254
GL_FRAGMENT_DEPTH = 33874 	# /usr/include/GL/gl.h:1255
GL_CURRENT_FOG_COORDINATE = 33875 	# /usr/include/GL/gl.h:1256
GL_FOG_COORDINATE_ARRAY_TYPE = 33876 	# /usr/include/GL/gl.h:1257
GL_FOG_COORDINATE_ARRAY_STRIDE = 33877 	# /usr/include/GL/gl.h:1258
GL_FOG_COORDINATE_ARRAY_POINTER = 33878 	# /usr/include/GL/gl.h:1259
GL_FOG_COORDINATE_ARRAY = 33879 	# /usr/include/GL/gl.h:1260
GL_COLOR_SUM = 33880 	# /usr/include/GL/gl.h:1261
GL_CURRENT_SECONDARY_COLOR = 33881 	# /usr/include/GL/gl.h:1262
GL_SECONDARY_COLOR_ARRAY_SIZE = 33882 	# /usr/include/GL/gl.h:1263
GL_SECONDARY_COLOR_ARRAY_TYPE = 33883 	# /usr/include/GL/gl.h:1264
GL_SECONDARY_COLOR_ARRAY_STRIDE = 33884 	# /usr/include/GL/gl.h:1265
GL_SECONDARY_COLOR_ARRAY_POINTER = 33885 	# /usr/include/GL/gl.h:1266
GL_SECONDARY_COLOR_ARRAY = 33886 	# /usr/include/GL/gl.h:1267
GL_INCR_WRAP = 34055 	# /usr/include/GL/gl.h:1268
GL_DECR_WRAP = 34056 	# /usr/include/GL/gl.h:1269
GL_MAX_TEXTURE_LOD_BIAS = 34045 	# /usr/include/GL/gl.h:1270
GL_TEXTURE_FILTER_CONTROL = 34048 	# /usr/include/GL/gl.h:1271
GL_TEXTURE_LOD_BIAS = 34049 	# /usr/include/GL/gl.h:1272
GL_GENERATE_MIPMAP = 33169 	# /usr/include/GL/gl.h:1273
GL_GENERATE_MIPMAP_HINT = 33170 	# /usr/include/GL/gl.h:1274
GL_BLEND_DST_RGB = 32968 	# /usr/include/GL/gl.h:1275
GL_BLEND_SRC_RGB = 32969 	# /usr/include/GL/gl.h:1276
GL_BLEND_DST_ALPHA = 32970 	# /usr/include/GL/gl.h:1277
GL_BLEND_SRC_ALPHA = 32971 	# /usr/include/GL/gl.h:1278
GL_MIRRORED_REPEAT = 33648 	# /usr/include/GL/gl.h:1279
GL_DEPTH_COMPONENT16 = 33189 	# /usr/include/GL/gl.h:1280
GL_DEPTH_COMPONENT24 = 33190 	# /usr/include/GL/gl.h:1281
GL_DEPTH_COMPONENT32 = 33191 	# /usr/include/GL/gl.h:1282
GL_TEXTURE_DEPTH_SIZE = 34890 	# /usr/include/GL/gl.h:1283
GL_DEPTH_TEXTURE_MODE = 34891 	# /usr/include/GL/gl.h:1284
GL_TEXTURE_COMPARE_MODE = 34892 	# /usr/include/GL/gl.h:1285
GL_TEXTURE_COMPARE_FUNC = 34893 	# /usr/include/GL/gl.h:1286
GL_COMPARE_R_TO_TEXTURE = 34894 	# /usr/include/GL/gl.h:1287
# /usr/include/GL/gl.h:1291
glAccum = _link_function('glAccum', None, [GLenum, GLfloat], None)

# /usr/include/GL/gl.h:1292
glAlphaFunc = _link_function('glAlphaFunc', None, [GLenum, GLclampf], None)

# /usr/include/GL/gl.h:1293
glAreTexturesResident = _link_function('glAreTexturesResident', GLboolean, [GLsizei, POINTER(GLuint), POINTER(GLboolean)], None)

# /usr/include/GL/gl.h:1294
glArrayElement = _link_function('glArrayElement', None, [GLint], None)

# /usr/include/GL/gl.h:1295
glBegin = _link_function('glBegin', None, [GLenum], None)

# /usr/include/GL/gl.h:1296
glBindTexture = _link_function('glBindTexture', None, [GLenum, GLuint], None)

# /usr/include/GL/gl.h:1297
glBitmap = _link_function('glBitmap', None, [GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat, POINTER(GLubyte)], None)

# /usr/include/GL/gl.h:1298
glBlendFunc = _link_function('glBlendFunc', None, [GLenum, GLenum], None)

# /usr/include/GL/gl.h:1299
glCallList = _link_function('glCallList', None, [GLuint], None)

# /usr/include/GL/gl.h:1300
glCallLists = _link_function('glCallLists', None, [GLsizei, GLenum, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1301
glClear = _link_function('glClear', None, [GLbitfield], None)

# /usr/include/GL/gl.h:1302
glClearAccum = _link_function('glClearAccum', None, [GLfloat, GLfloat, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1303
glClearColor = _link_function('glClearColor', None, [GLclampf, GLclampf, GLclampf, GLclampf], None)

# /usr/include/GL/gl.h:1304
glClearDepth = _link_function('glClearDepth', None, [GLclampd], None)

# /usr/include/GL/gl.h:1305
glClearIndex = _link_function('glClearIndex', None, [GLfloat], None)

# /usr/include/GL/gl.h:1306
glClearStencil = _link_function('glClearStencil', None, [GLint], None)

# /usr/include/GL/gl.h:1307
glClipPlane = _link_function('glClipPlane', None, [GLenum, POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1308
glColor3b = _link_function('glColor3b', None, [GLbyte, GLbyte, GLbyte], None)

# /usr/include/GL/gl.h:1309
glColor3bv = _link_function('glColor3bv', None, [POINTER(GLbyte)], None)

# /usr/include/GL/gl.h:1310
glColor3d = _link_function('glColor3d', None, [GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1311
glColor3dv = _link_function('glColor3dv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1312
glColor3f = _link_function('glColor3f', None, [GLfloat, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1313
glColor3fv = _link_function('glColor3fv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1314
glColor3i = _link_function('glColor3i', None, [GLint, GLint, GLint], None)

# /usr/include/GL/gl.h:1315
glColor3iv = _link_function('glColor3iv', None, [POINTER(GLint)], None)

# /usr/include/GL/gl.h:1316
glColor3s = _link_function('glColor3s', None, [GLshort, GLshort, GLshort], None)

# /usr/include/GL/gl.h:1317
glColor3sv = _link_function('glColor3sv', None, [POINTER(GLshort)], None)

# /usr/include/GL/gl.h:1318
glColor3ub = _link_function('glColor3ub', None, [GLubyte, GLubyte, GLubyte], None)

# /usr/include/GL/gl.h:1319
glColor3ubv = _link_function('glColor3ubv', None, [POINTER(GLubyte)], None)

# /usr/include/GL/gl.h:1320
glColor3ui = _link_function('glColor3ui', None, [GLuint, GLuint, GLuint], None)

# /usr/include/GL/gl.h:1321
glColor3uiv = _link_function('glColor3uiv', None, [POINTER(GLuint)], None)

# /usr/include/GL/gl.h:1322
glColor3us = _link_function('glColor3us', None, [GLushort, GLushort, GLushort], None)

# /usr/include/GL/gl.h:1323
glColor3usv = _link_function('glColor3usv', None, [POINTER(GLushort)], None)

# /usr/include/GL/gl.h:1324
glColor4b = _link_function('glColor4b', None, [GLbyte, GLbyte, GLbyte, GLbyte], None)

# /usr/include/GL/gl.h:1325
glColor4bv = _link_function('glColor4bv', None, [POINTER(GLbyte)], None)

# /usr/include/GL/gl.h:1326
glColor4d = _link_function('glColor4d', None, [GLdouble, GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1327
glColor4dv = _link_function('glColor4dv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1328
glColor4f = _link_function('glColor4f', None, [GLfloat, GLfloat, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1329
glColor4fv = _link_function('glColor4fv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1330
glColor4i = _link_function('glColor4i', None, [GLint, GLint, GLint, GLint], None)

# /usr/include/GL/gl.h:1331
glColor4iv = _link_function('glColor4iv', None, [POINTER(GLint)], None)

# /usr/include/GL/gl.h:1332
glColor4s = _link_function('glColor4s', None, [GLshort, GLshort, GLshort, GLshort], None)

# /usr/include/GL/gl.h:1333
glColor4sv = _link_function('glColor4sv', None, [POINTER(GLshort)], None)

# /usr/include/GL/gl.h:1334
glColor4ub = _link_function('glColor4ub', None, [GLubyte, GLubyte, GLubyte, GLubyte], None)

# /usr/include/GL/gl.h:1335
glColor4ubv = _link_function('glColor4ubv', None, [POINTER(GLubyte)], None)

# /usr/include/GL/gl.h:1336
glColor4ui = _link_function('glColor4ui', None, [GLuint, GLuint, GLuint, GLuint], None)

# /usr/include/GL/gl.h:1337
glColor4uiv = _link_function('glColor4uiv', None, [POINTER(GLuint)], None)

# /usr/include/GL/gl.h:1338
glColor4us = _link_function('glColor4us', None, [GLushort, GLushort, GLushort, GLushort], None)

# /usr/include/GL/gl.h:1339
glColor4usv = _link_function('glColor4usv', None, [POINTER(GLushort)], None)

# /usr/include/GL/gl.h:1340
glColorMask = _link_function('glColorMask', None, [GLboolean, GLboolean, GLboolean, GLboolean], None)

# /usr/include/GL/gl.h:1341
glColorMaterial = _link_function('glColorMaterial', None, [GLenum, GLenum], None)

# /usr/include/GL/gl.h:1342
glColorPointer = _link_function('glColorPointer', None, [GLint, GLenum, GLsizei, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1343
glCopyPixels = _link_function('glCopyPixels', None, [GLint, GLint, GLsizei, GLsizei, GLenum], None)

# /usr/include/GL/gl.h:1344
glCopyTexImage1D = _link_function('glCopyTexImage1D', None, [GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint], None)

# /usr/include/GL/gl.h:1345
glCopyTexImage2D = _link_function('glCopyTexImage2D', None, [GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint], None)

# /usr/include/GL/gl.h:1346
glCopyTexSubImage1D = _link_function('glCopyTexSubImage1D', None, [GLenum, GLint, GLint, GLint, GLint, GLsizei], None)

# /usr/include/GL/gl.h:1347
glCopyTexSubImage2D = _link_function('glCopyTexSubImage2D', None, [GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei], None)

# /usr/include/GL/gl.h:1348
glCullFace = _link_function('glCullFace', None, [GLenum], None)

# /usr/include/GL/gl.h:1349
glDeleteLists = _link_function('glDeleteLists', None, [GLuint, GLsizei], None)

# /usr/include/GL/gl.h:1350
glDeleteTextures = _link_function('glDeleteTextures', None, [GLsizei, POINTER(GLuint)], None)

# /usr/include/GL/gl.h:1351
glDepthFunc = _link_function('glDepthFunc', None, [GLenum], None)

# /usr/include/GL/gl.h:1352
glDepthMask = _link_function('glDepthMask', None, [GLboolean], None)

# /usr/include/GL/gl.h:1353
glDepthRange = _link_function('glDepthRange', None, [GLclampd, GLclampd], None)

# /usr/include/GL/gl.h:1354
glDisable = _link_function('glDisable', None, [GLenum], None)

# /usr/include/GL/gl.h:1355
glDisableClientState = _link_function('glDisableClientState', None, [GLenum], None)

# /usr/include/GL/gl.h:1356
glDrawArrays = _link_function('glDrawArrays', None, [GLenum, GLint, GLsizei], None)

# /usr/include/GL/gl.h:1357
glDrawBuffer = _link_function('glDrawBuffer', None, [GLenum], None)

# /usr/include/GL/gl.h:1358
glDrawElements = _link_function('glDrawElements', None, [GLenum, GLsizei, GLenum, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1359
glDrawPixels = _link_function('glDrawPixels', None, [GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1360
glEdgeFlag = _link_function('glEdgeFlag', None, [GLboolean], None)

# /usr/include/GL/gl.h:1361
glEdgeFlagPointer = _link_function('glEdgeFlagPointer', None, [GLsizei, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1362
glEdgeFlagv = _link_function('glEdgeFlagv', None, [POINTER(GLboolean)], None)

# /usr/include/GL/gl.h:1363
glEnable = _link_function('glEnable', None, [GLenum], None)

# /usr/include/GL/gl.h:1364
glEnableClientState = _link_function('glEnableClientState', None, [GLenum], None)

# /usr/include/GL/gl.h:1365
glEnd = _link_function('glEnd', None, [], None)

# /usr/include/GL/gl.h:1366
glEndList = _link_function('glEndList', None, [], None)

# /usr/include/GL/gl.h:1367
glEvalCoord1d = _link_function('glEvalCoord1d', None, [GLdouble], None)

# /usr/include/GL/gl.h:1368
glEvalCoord1dv = _link_function('glEvalCoord1dv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1369
glEvalCoord1f = _link_function('glEvalCoord1f', None, [GLfloat], None)

# /usr/include/GL/gl.h:1370
glEvalCoord1fv = _link_function('glEvalCoord1fv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1371
glEvalCoord2d = _link_function('glEvalCoord2d', None, [GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1372
glEvalCoord2dv = _link_function('glEvalCoord2dv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1373
glEvalCoord2f = _link_function('glEvalCoord2f', None, [GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1374
glEvalCoord2fv = _link_function('glEvalCoord2fv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1375
glEvalMesh1 = _link_function('glEvalMesh1', None, [GLenum, GLint, GLint], None)

# /usr/include/GL/gl.h:1376
glEvalMesh2 = _link_function('glEvalMesh2', None, [GLenum, GLint, GLint, GLint, GLint], None)

# /usr/include/GL/gl.h:1377
glEvalPoint1 = _link_function('glEvalPoint1', None, [GLint], None)

# /usr/include/GL/gl.h:1378
glEvalPoint2 = _link_function('glEvalPoint2', None, [GLint, GLint], None)

# /usr/include/GL/gl.h:1379
glFeedbackBuffer = _link_function('glFeedbackBuffer', None, [GLsizei, GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1380
glFinish = _link_function('glFinish', None, [], None)

# /usr/include/GL/gl.h:1381
glFlush = _link_function('glFlush', None, [], None)

# /usr/include/GL/gl.h:1382
glFogf = _link_function('glFogf', None, [GLenum, GLfloat], None)

# /usr/include/GL/gl.h:1383
glFogfv = _link_function('glFogfv', None, [GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1384
glFogi = _link_function('glFogi', None, [GLenum, GLint], None)

# /usr/include/GL/gl.h:1385
glFogiv = _link_function('glFogiv', None, [GLenum, POINTER(GLint)], None)

# /usr/include/GL/gl.h:1386
glFrontFace = _link_function('glFrontFace', None, [GLenum], None)

# /usr/include/GL/gl.h:1387
glFrustum = _link_function('glFrustum', None, [GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1388
glGenLists = _link_function('glGenLists', GLuint, [GLsizei], None)

# /usr/include/GL/gl.h:1389
glGenTextures = _link_function('glGenTextures', None, [GLsizei, POINTER(GLuint)], None)

# /usr/include/GL/gl.h:1390
glGetBooleanv = _link_function('glGetBooleanv', None, [GLenum, POINTER(GLboolean)], None)

# /usr/include/GL/gl.h:1391
glGetClipPlane = _link_function('glGetClipPlane', None, [GLenum, POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1392
glGetDoublev = _link_function('glGetDoublev', None, [GLenum, POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1393
glGetError = _link_function('glGetError', GLenum, [], None)

# /usr/include/GL/gl.h:1394
glGetFloatv = _link_function('glGetFloatv', None, [GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1395
glGetIntegerv = _link_function('glGetIntegerv', None, [GLenum, POINTER(GLint)], None)

# /usr/include/GL/gl.h:1396
glGetLightfv = _link_function('glGetLightfv', None, [GLenum, GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1397
glGetLightiv = _link_function('glGetLightiv', None, [GLenum, GLenum, POINTER(GLint)], None)

# /usr/include/GL/gl.h:1398
glGetMapdv = _link_function('glGetMapdv', None, [GLenum, GLenum, POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1399
glGetMapfv = _link_function('glGetMapfv', None, [GLenum, GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1400
glGetMapiv = _link_function('glGetMapiv', None, [GLenum, GLenum, POINTER(GLint)], None)

# /usr/include/GL/gl.h:1401
glGetMaterialfv = _link_function('glGetMaterialfv', None, [GLenum, GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1402
glGetMaterialiv = _link_function('glGetMaterialiv', None, [GLenum, GLenum, POINTER(GLint)], None)

# /usr/include/GL/gl.h:1403
glGetPixelMapfv = _link_function('glGetPixelMapfv', None, [GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1404
glGetPixelMapuiv = _link_function('glGetPixelMapuiv', None, [GLenum, POINTER(GLuint)], None)

# /usr/include/GL/gl.h:1405
glGetPixelMapusv = _link_function('glGetPixelMapusv', None, [GLenum, POINTER(GLushort)], None)

# /usr/include/GL/gl.h:1406
glGetPointerv = _link_function('glGetPointerv', None, [GLenum, POINTER(POINTER(GLvoid))], None)

# /usr/include/GL/gl.h:1407
glGetPolygonStipple = _link_function('glGetPolygonStipple', None, [POINTER(GLubyte)], None)

# /usr/include/GL/gl.h:1408
glGetString = _link_function('glGetString', POINTER(GLubyte), [GLenum], None)

# /usr/include/GL/gl.h:1409
glGetTexEnvfv = _link_function('glGetTexEnvfv', None, [GLenum, GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1410
glGetTexEnviv = _link_function('glGetTexEnviv', None, [GLenum, GLenum, POINTER(GLint)], None)

# /usr/include/GL/gl.h:1411
glGetTexGendv = _link_function('glGetTexGendv', None, [GLenum, GLenum, POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1412
glGetTexGenfv = _link_function('glGetTexGenfv', None, [GLenum, GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1413
glGetTexGeniv = _link_function('glGetTexGeniv', None, [GLenum, GLenum, POINTER(GLint)], None)

# /usr/include/GL/gl.h:1414
glGetTexImage = _link_function('glGetTexImage', None, [GLenum, GLint, GLenum, GLenum, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1415
glGetTexLevelParameterfv = _link_function('glGetTexLevelParameterfv', None, [GLenum, GLint, GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1416
glGetTexLevelParameteriv = _link_function('glGetTexLevelParameteriv', None, [GLenum, GLint, GLenum, POINTER(GLint)], None)

# /usr/include/GL/gl.h:1417
glGetTexParameterfv = _link_function('glGetTexParameterfv', None, [GLenum, GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1418
glGetTexParameteriv = _link_function('glGetTexParameteriv', None, [GLenum, GLenum, POINTER(GLint)], None)

# /usr/include/GL/gl.h:1419
glHint = _link_function('glHint', None, [GLenum, GLenum], None)

# /usr/include/GL/gl.h:1420
glIndexMask = _link_function('glIndexMask', None, [GLuint], None)

# /usr/include/GL/gl.h:1421
glIndexPointer = _link_function('glIndexPointer', None, [GLenum, GLsizei, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1422
glIndexd = _link_function('glIndexd', None, [GLdouble], None)

# /usr/include/GL/gl.h:1423
glIndexdv = _link_function('glIndexdv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1424
glIndexf = _link_function('glIndexf', None, [GLfloat], None)

# /usr/include/GL/gl.h:1425
glIndexfv = _link_function('glIndexfv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1426
glIndexi = _link_function('glIndexi', None, [GLint], None)

# /usr/include/GL/gl.h:1427
glIndexiv = _link_function('glIndexiv', None, [POINTER(GLint)], None)

# /usr/include/GL/gl.h:1428
glIndexs = _link_function('glIndexs', None, [GLshort], None)

# /usr/include/GL/gl.h:1429
glIndexsv = _link_function('glIndexsv', None, [POINTER(GLshort)], None)

# /usr/include/GL/gl.h:1430
glIndexub = _link_function('glIndexub', None, [GLubyte], None)

# /usr/include/GL/gl.h:1431
glIndexubv = _link_function('glIndexubv', None, [POINTER(GLubyte)], None)

# /usr/include/GL/gl.h:1432
glInitNames = _link_function('glInitNames', None, [], None)

# /usr/include/GL/gl.h:1433
glInterleavedArrays = _link_function('glInterleavedArrays', None, [GLenum, GLsizei, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1434
glIsEnabled = _link_function('glIsEnabled', GLboolean, [GLenum], None)

# /usr/include/GL/gl.h:1435
glIsList = _link_function('glIsList', GLboolean, [GLuint], None)

# /usr/include/GL/gl.h:1436
glIsTexture = _link_function('glIsTexture', GLboolean, [GLuint], None)

# /usr/include/GL/gl.h:1437
glLightModelf = _link_function('glLightModelf', None, [GLenum, GLfloat], None)

# /usr/include/GL/gl.h:1438
glLightModelfv = _link_function('glLightModelfv', None, [GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1439
glLightModeli = _link_function('glLightModeli', None, [GLenum, GLint], None)

# /usr/include/GL/gl.h:1440
glLightModeliv = _link_function('glLightModeliv', None, [GLenum, POINTER(GLint)], None)

# /usr/include/GL/gl.h:1441
glLightf = _link_function('glLightf', None, [GLenum, GLenum, GLfloat], None)

# /usr/include/GL/gl.h:1442
glLightfv = _link_function('glLightfv', None, [GLenum, GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1443
glLighti = _link_function('glLighti', None, [GLenum, GLenum, GLint], None)

# /usr/include/GL/gl.h:1444
glLightiv = _link_function('glLightiv', None, [GLenum, GLenum, POINTER(GLint)], None)

# /usr/include/GL/gl.h:1445
glLineStipple = _link_function('glLineStipple', None, [GLint, GLushort], None)

# /usr/include/GL/gl.h:1446
glLineWidth = _link_function('glLineWidth', None, [GLfloat], None)

# /usr/include/GL/gl.h:1447
glListBase = _link_function('glListBase', None, [GLuint], None)

# /usr/include/GL/gl.h:1448
glLoadIdentity = _link_function('glLoadIdentity', None, [], None)

# /usr/include/GL/gl.h:1449
glLoadMatrixd = _link_function('glLoadMatrixd', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1450
glLoadMatrixf = _link_function('glLoadMatrixf', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1451
glLoadName = _link_function('glLoadName', None, [GLuint], None)

# /usr/include/GL/gl.h:1452
glLogicOp = _link_function('glLogicOp', None, [GLenum], None)

# /usr/include/GL/gl.h:1453
glMap1d = _link_function('glMap1d', None, [GLenum, GLdouble, GLdouble, GLint, GLint, POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1454
glMap1f = _link_function('glMap1f', None, [GLenum, GLfloat, GLfloat, GLint, GLint, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1455
glMap2d = _link_function('glMap2d', None, [GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1456
glMap2f = _link_function('glMap2f', None, [GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1457
glMapGrid1d = _link_function('glMapGrid1d', None, [GLint, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1458
glMapGrid1f = _link_function('glMapGrid1f', None, [GLint, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1459
glMapGrid2d = _link_function('glMapGrid2d', None, [GLint, GLdouble, GLdouble, GLint, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1460
glMapGrid2f = _link_function('glMapGrid2f', None, [GLint, GLfloat, GLfloat, GLint, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1461
glMaterialf = _link_function('glMaterialf', None, [GLenum, GLenum, GLfloat], None)

# /usr/include/GL/gl.h:1462
glMaterialfv = _link_function('glMaterialfv', None, [GLenum, GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1463
glMateriali = _link_function('glMateriali', None, [GLenum, GLenum, GLint], None)

# /usr/include/GL/gl.h:1464
glMaterialiv = _link_function('glMaterialiv', None, [GLenum, GLenum, POINTER(GLint)], None)

# /usr/include/GL/gl.h:1465
glMatrixMode = _link_function('glMatrixMode', None, [GLenum], None)

# /usr/include/GL/gl.h:1466
glMultMatrixd = _link_function('glMultMatrixd', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1467
glMultMatrixf = _link_function('glMultMatrixf', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1468
glNewList = _link_function('glNewList', None, [GLuint, GLenum], None)

# /usr/include/GL/gl.h:1469
glNormal3b = _link_function('glNormal3b', None, [GLbyte, GLbyte, GLbyte], None)

# /usr/include/GL/gl.h:1470
glNormal3bv = _link_function('glNormal3bv', None, [POINTER(GLbyte)], None)

# /usr/include/GL/gl.h:1471
glNormal3d = _link_function('glNormal3d', None, [GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1472
glNormal3dv = _link_function('glNormal3dv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1473
glNormal3f = _link_function('glNormal3f', None, [GLfloat, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1474
glNormal3fv = _link_function('glNormal3fv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1475
glNormal3i = _link_function('glNormal3i', None, [GLint, GLint, GLint], None)

# /usr/include/GL/gl.h:1476
glNormal3iv = _link_function('glNormal3iv', None, [POINTER(GLint)], None)

# /usr/include/GL/gl.h:1477
glNormal3s = _link_function('glNormal3s', None, [GLshort, GLshort, GLshort], None)

# /usr/include/GL/gl.h:1478
glNormal3sv = _link_function('glNormal3sv', None, [POINTER(GLshort)], None)

# /usr/include/GL/gl.h:1479
glNormalPointer = _link_function('glNormalPointer', None, [GLenum, GLsizei, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1480
glOrtho = _link_function('glOrtho', None, [GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1481
glPassThrough = _link_function('glPassThrough', None, [GLfloat], None)

# /usr/include/GL/gl.h:1482
glPixelMapfv = _link_function('glPixelMapfv', None, [GLenum, GLsizei, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1483
glPixelMapuiv = _link_function('glPixelMapuiv', None, [GLenum, GLsizei, POINTER(GLuint)], None)

# /usr/include/GL/gl.h:1484
glPixelMapusv = _link_function('glPixelMapusv', None, [GLenum, GLsizei, POINTER(GLushort)], None)

# /usr/include/GL/gl.h:1485
glPixelStoref = _link_function('glPixelStoref', None, [GLenum, GLfloat], None)

# /usr/include/GL/gl.h:1486
glPixelStorei = _link_function('glPixelStorei', None, [GLenum, GLint], None)

# /usr/include/GL/gl.h:1487
glPixelTransferf = _link_function('glPixelTransferf', None, [GLenum, GLfloat], None)

# /usr/include/GL/gl.h:1488
glPixelTransferi = _link_function('glPixelTransferi', None, [GLenum, GLint], None)

# /usr/include/GL/gl.h:1489
glPixelZoom = _link_function('glPixelZoom', None, [GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1490
glPointSize = _link_function('glPointSize', None, [GLfloat], None)

# /usr/include/GL/gl.h:1491
glPolygonMode = _link_function('glPolygonMode', None, [GLenum, GLenum], None)

# /usr/include/GL/gl.h:1492
glPolygonOffset = _link_function('glPolygonOffset', None, [GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1493
glPolygonStipple = _link_function('glPolygonStipple', None, [POINTER(GLubyte)], None)

# /usr/include/GL/gl.h:1494
glPopAttrib = _link_function('glPopAttrib', None, [], None)

# /usr/include/GL/gl.h:1495
glPopClientAttrib = _link_function('glPopClientAttrib', None, [], None)

# /usr/include/GL/gl.h:1496
glPopMatrix = _link_function('glPopMatrix', None, [], None)

# /usr/include/GL/gl.h:1497
glPopName = _link_function('glPopName', None, [], None)

# /usr/include/GL/gl.h:1498
glPrioritizeTextures = _link_function('glPrioritizeTextures', None, [GLsizei, POINTER(GLuint), POINTER(GLclampf)], None)

# /usr/include/GL/gl.h:1499
glPushAttrib = _link_function('glPushAttrib', None, [GLbitfield], None)

# /usr/include/GL/gl.h:1500
glPushClientAttrib = _link_function('glPushClientAttrib', None, [GLbitfield], None)

# /usr/include/GL/gl.h:1501
glPushMatrix = _link_function('glPushMatrix', None, [], None)

# /usr/include/GL/gl.h:1502
glPushName = _link_function('glPushName', None, [GLuint], None)

# /usr/include/GL/gl.h:1503
glRasterPos2d = _link_function('glRasterPos2d', None, [GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1504
glRasterPos2dv = _link_function('glRasterPos2dv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1505
glRasterPos2f = _link_function('glRasterPos2f', None, [GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1506
glRasterPos2fv = _link_function('glRasterPos2fv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1507
glRasterPos2i = _link_function('glRasterPos2i', None, [GLint, GLint], None)

# /usr/include/GL/gl.h:1508
glRasterPos2iv = _link_function('glRasterPos2iv', None, [POINTER(GLint)], None)

# /usr/include/GL/gl.h:1509
glRasterPos2s = _link_function('glRasterPos2s', None, [GLshort, GLshort], None)

# /usr/include/GL/gl.h:1510
glRasterPos2sv = _link_function('glRasterPos2sv', None, [POINTER(GLshort)], None)

# /usr/include/GL/gl.h:1511
glRasterPos3d = _link_function('glRasterPos3d', None, [GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1512
glRasterPos3dv = _link_function('glRasterPos3dv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1513
glRasterPos3f = _link_function('glRasterPos3f', None, [GLfloat, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1514
glRasterPos3fv = _link_function('glRasterPos3fv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1515
glRasterPos3i = _link_function('glRasterPos3i', None, [GLint, GLint, GLint], None)

# /usr/include/GL/gl.h:1516
glRasterPos3iv = _link_function('glRasterPos3iv', None, [POINTER(GLint)], None)

# /usr/include/GL/gl.h:1517
glRasterPos3s = _link_function('glRasterPos3s', None, [GLshort, GLshort, GLshort], None)

# /usr/include/GL/gl.h:1518
glRasterPos3sv = _link_function('glRasterPos3sv', None, [POINTER(GLshort)], None)

# /usr/include/GL/gl.h:1519
glRasterPos4d = _link_function('glRasterPos4d', None, [GLdouble, GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1520
glRasterPos4dv = _link_function('glRasterPos4dv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1521
glRasterPos4f = _link_function('glRasterPos4f', None, [GLfloat, GLfloat, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1522
glRasterPos4fv = _link_function('glRasterPos4fv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1523
glRasterPos4i = _link_function('glRasterPos4i', None, [GLint, GLint, GLint, GLint], None)

# /usr/include/GL/gl.h:1524
glRasterPos4iv = _link_function('glRasterPos4iv', None, [POINTER(GLint)], None)

# /usr/include/GL/gl.h:1525
glRasterPos4s = _link_function('glRasterPos4s', None, [GLshort, GLshort, GLshort, GLshort], None)

# /usr/include/GL/gl.h:1526
glRasterPos4sv = _link_function('glRasterPos4sv', None, [POINTER(GLshort)], None)

# /usr/include/GL/gl.h:1527
glReadBuffer = _link_function('glReadBuffer', None, [GLenum], None)

# /usr/include/GL/gl.h:1528
glReadPixels = _link_function('glReadPixels', None, [GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1529
glRectd = _link_function('glRectd', None, [GLdouble, GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1530
glRectdv = _link_function('glRectdv', None, [POINTER(GLdouble), POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1531
glRectf = _link_function('glRectf', None, [GLfloat, GLfloat, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1532
glRectfv = _link_function('glRectfv', None, [POINTER(GLfloat), POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1533
glRecti = _link_function('glRecti', None, [GLint, GLint, GLint, GLint], None)

# /usr/include/GL/gl.h:1534
glRectiv = _link_function('glRectiv', None, [POINTER(GLint), POINTER(GLint)], None)

# /usr/include/GL/gl.h:1535
glRects = _link_function('glRects', None, [GLshort, GLshort, GLshort, GLshort], None)

# /usr/include/GL/gl.h:1536
glRectsv = _link_function('glRectsv', None, [POINTER(GLshort), POINTER(GLshort)], None)

# /usr/include/GL/gl.h:1537
glRenderMode = _link_function('glRenderMode', GLint, [GLenum], None)

# /usr/include/GL/gl.h:1538
glRotated = _link_function('glRotated', None, [GLdouble, GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1539
glRotatef = _link_function('glRotatef', None, [GLfloat, GLfloat, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1540
glScaled = _link_function('glScaled', None, [GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1541
glScalef = _link_function('glScalef', None, [GLfloat, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1542
glScissor = _link_function('glScissor', None, [GLint, GLint, GLsizei, GLsizei], None)

# /usr/include/GL/gl.h:1543
glSelectBuffer = _link_function('glSelectBuffer', None, [GLsizei, POINTER(GLuint)], None)

# /usr/include/GL/gl.h:1544
glShadeModel = _link_function('glShadeModel', None, [GLenum], None)

# /usr/include/GL/gl.h:1545
glStencilFunc = _link_function('glStencilFunc', None, [GLenum, GLint, GLuint], None)

# /usr/include/GL/gl.h:1546
glStencilMask = _link_function('glStencilMask', None, [GLuint], None)

# /usr/include/GL/gl.h:1547
glStencilOp = _link_function('glStencilOp', None, [GLenum, GLenum, GLenum], None)

# /usr/include/GL/gl.h:1548
glTexCoord1d = _link_function('glTexCoord1d', None, [GLdouble], None)

# /usr/include/GL/gl.h:1549
glTexCoord1dv = _link_function('glTexCoord1dv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1550
glTexCoord1f = _link_function('glTexCoord1f', None, [GLfloat], None)

# /usr/include/GL/gl.h:1551
glTexCoord1fv = _link_function('glTexCoord1fv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1552
glTexCoord1i = _link_function('glTexCoord1i', None, [GLint], None)

# /usr/include/GL/gl.h:1553
glTexCoord1iv = _link_function('glTexCoord1iv', None, [POINTER(GLint)], None)

# /usr/include/GL/gl.h:1554
glTexCoord1s = _link_function('glTexCoord1s', None, [GLshort], None)

# /usr/include/GL/gl.h:1555
glTexCoord1sv = _link_function('glTexCoord1sv', None, [POINTER(GLshort)], None)

# /usr/include/GL/gl.h:1556
glTexCoord2d = _link_function('glTexCoord2d', None, [GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1557
glTexCoord2dv = _link_function('glTexCoord2dv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1558
glTexCoord2f = _link_function('glTexCoord2f', None, [GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1559
glTexCoord2fv = _link_function('glTexCoord2fv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1560
glTexCoord2i = _link_function('glTexCoord2i', None, [GLint, GLint], None)

# /usr/include/GL/gl.h:1561
glTexCoord2iv = _link_function('glTexCoord2iv', None, [POINTER(GLint)], None)

# /usr/include/GL/gl.h:1562
glTexCoord2s = _link_function('glTexCoord2s', None, [GLshort, GLshort], None)

# /usr/include/GL/gl.h:1563
glTexCoord2sv = _link_function('glTexCoord2sv', None, [POINTER(GLshort)], None)

# /usr/include/GL/gl.h:1564
glTexCoord3d = _link_function('glTexCoord3d', None, [GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1565
glTexCoord3dv = _link_function('glTexCoord3dv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1566
glTexCoord3f = _link_function('glTexCoord3f', None, [GLfloat, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1567
glTexCoord3fv = _link_function('glTexCoord3fv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1568
glTexCoord3i = _link_function('glTexCoord3i', None, [GLint, GLint, GLint], None)

# /usr/include/GL/gl.h:1569
glTexCoord3iv = _link_function('glTexCoord3iv', None, [POINTER(GLint)], None)

# /usr/include/GL/gl.h:1570
glTexCoord3s = _link_function('glTexCoord3s', None, [GLshort, GLshort, GLshort], None)

# /usr/include/GL/gl.h:1571
glTexCoord3sv = _link_function('glTexCoord3sv', None, [POINTER(GLshort)], None)

# /usr/include/GL/gl.h:1572
glTexCoord4d = _link_function('glTexCoord4d', None, [GLdouble, GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1573
glTexCoord4dv = _link_function('glTexCoord4dv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1574
glTexCoord4f = _link_function('glTexCoord4f', None, [GLfloat, GLfloat, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1575
glTexCoord4fv = _link_function('glTexCoord4fv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1576
glTexCoord4i = _link_function('glTexCoord4i', None, [GLint, GLint, GLint, GLint], None)

# /usr/include/GL/gl.h:1577
glTexCoord4iv = _link_function('glTexCoord4iv', None, [POINTER(GLint)], None)

# /usr/include/GL/gl.h:1578
glTexCoord4s = _link_function('glTexCoord4s', None, [GLshort, GLshort, GLshort, GLshort], None)

# /usr/include/GL/gl.h:1579
glTexCoord4sv = _link_function('glTexCoord4sv', None, [POINTER(GLshort)], None)

# /usr/include/GL/gl.h:1580
glTexCoordPointer = _link_function('glTexCoordPointer', None, [GLint, GLenum, GLsizei, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1581
glTexEnvf = _link_function('glTexEnvf', None, [GLenum, GLenum, GLfloat], None)

# /usr/include/GL/gl.h:1582
glTexEnvfv = _link_function('glTexEnvfv', None, [GLenum, GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1583
glTexEnvi = _link_function('glTexEnvi', None, [GLenum, GLenum, GLint], None)

# /usr/include/GL/gl.h:1584
glTexEnviv = _link_function('glTexEnviv', None, [GLenum, GLenum, POINTER(GLint)], None)

# /usr/include/GL/gl.h:1585
glTexGend = _link_function('glTexGend', None, [GLenum, GLenum, GLdouble], None)

# /usr/include/GL/gl.h:1586
glTexGendv = _link_function('glTexGendv', None, [GLenum, GLenum, POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1587
glTexGenf = _link_function('glTexGenf', None, [GLenum, GLenum, GLfloat], None)

# /usr/include/GL/gl.h:1588
glTexGenfv = _link_function('glTexGenfv', None, [GLenum, GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1589
glTexGeni = _link_function('glTexGeni', None, [GLenum, GLenum, GLint], None)

# /usr/include/GL/gl.h:1590
glTexGeniv = _link_function('glTexGeniv', None, [GLenum, GLenum, POINTER(GLint)], None)

# /usr/include/GL/gl.h:1591
glTexImage1D = _link_function('glTexImage1D', None, [GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1592
glTexImage2D = _link_function('glTexImage2D', None, [GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1593
glTexParameterf = _link_function('glTexParameterf', None, [GLenum, GLenum, GLfloat], None)

# /usr/include/GL/gl.h:1594
glTexParameterfv = _link_function('glTexParameterfv', None, [GLenum, GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1595
glTexParameteri = _link_function('glTexParameteri', None, [GLenum, GLenum, GLint], None)

# /usr/include/GL/gl.h:1596
glTexParameteriv = _link_function('glTexParameteriv', None, [GLenum, GLenum, POINTER(GLint)], None)

# /usr/include/GL/gl.h:1597
glTexSubImage1D = _link_function('glTexSubImage1D', None, [GLenum, GLint, GLint, GLsizei, GLenum, GLenum, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1598
glTexSubImage2D = _link_function('glTexSubImage2D', None, [GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1599
glTranslated = _link_function('glTranslated', None, [GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1600
glTranslatef = _link_function('glTranslatef', None, [GLfloat, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1601
glVertex2d = _link_function('glVertex2d', None, [GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1602
glVertex2dv = _link_function('glVertex2dv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1603
glVertex2f = _link_function('glVertex2f', None, [GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1604
glVertex2fv = _link_function('glVertex2fv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1605
glVertex2i = _link_function('glVertex2i', None, [GLint, GLint], None)

# /usr/include/GL/gl.h:1606
glVertex2iv = _link_function('glVertex2iv', None, [POINTER(GLint)], None)

# /usr/include/GL/gl.h:1607
glVertex2s = _link_function('glVertex2s', None, [GLshort, GLshort], None)

# /usr/include/GL/gl.h:1608
glVertex2sv = _link_function('glVertex2sv', None, [POINTER(GLshort)], None)

# /usr/include/GL/gl.h:1609
glVertex3d = _link_function('glVertex3d', None, [GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1610
glVertex3dv = _link_function('glVertex3dv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1611
glVertex3f = _link_function('glVertex3f', None, [GLfloat, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1612
glVertex3fv = _link_function('glVertex3fv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1613
glVertex3i = _link_function('glVertex3i', None, [GLint, GLint, GLint], None)

# /usr/include/GL/gl.h:1614
glVertex3iv = _link_function('glVertex3iv', None, [POINTER(GLint)], None)

# /usr/include/GL/gl.h:1615
glVertex3s = _link_function('glVertex3s', None, [GLshort, GLshort, GLshort], None)

# /usr/include/GL/gl.h:1616
glVertex3sv = _link_function('glVertex3sv', None, [POINTER(GLshort)], None)

# /usr/include/GL/gl.h:1617
glVertex4d = _link_function('glVertex4d', None, [GLdouble, GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/gl.h:1618
glVertex4dv = _link_function('glVertex4dv', None, [POINTER(GLdouble)], None)

# /usr/include/GL/gl.h:1619
glVertex4f = _link_function('glVertex4f', None, [GLfloat, GLfloat, GLfloat, GLfloat], None)

# /usr/include/GL/gl.h:1620
glVertex4fv = _link_function('glVertex4fv', None, [POINTER(GLfloat)], None)

# /usr/include/GL/gl.h:1621
glVertex4i = _link_function('glVertex4i', None, [GLint, GLint, GLint, GLint], None)

# /usr/include/GL/gl.h:1622
glVertex4iv = _link_function('glVertex4iv', None, [POINTER(GLint)], None)

# /usr/include/GL/gl.h:1623
glVertex4s = _link_function('glVertex4s', None, [GLshort, GLshort, GLshort, GLshort], None)

# /usr/include/GL/gl.h:1624
glVertex4sv = _link_function('glVertex4sv', None, [POINTER(GLshort)], None)

# /usr/include/GL/gl.h:1625
glVertexPointer = _link_function('glVertexPointer', None, [GLint, GLenum, GLsizei, POINTER(GLvoid)], None)

# /usr/include/GL/gl.h:1626
glViewport = _link_function('glViewport', None, [GLint, GLint, GLsizei, GLsizei], None)


__all__ = ['GLenum', 'GLboolean', 'GLbitfield', 'GLbyte', 'GLshort', 'GLint',
'GLsizei', 'GLubyte', 'GLushort', 'GLuint', 'GLfloat', 'GLclampf', 'GLdouble',
'GLclampd', 'GLvoid', 'GL_VERSION_1_1', 'GL_CURRENT_BIT', 'GL_POINT_BIT',
'GL_LINE_BIT', 'GL_POLYGON_BIT', 'GL_POLYGON_STIPPLE_BIT',
'GL_PIXEL_MODE_BIT', 'GL_LIGHTING_BIT', 'GL_FOG_BIT', 'GL_DEPTH_BUFFER_BIT',
'GL_ACCUM_BUFFER_BIT', 'GL_STENCIL_BUFFER_BIT', 'GL_VIEWPORT_BIT',
'GL_TRANSFORM_BIT', 'GL_ENABLE_BIT', 'GL_COLOR_BUFFER_BIT', 'GL_HINT_BIT',
'GL_EVAL_BIT', 'GL_LIST_BIT', 'GL_TEXTURE_BIT', 'GL_SCISSOR_BIT',
'GL_ALL_ATTRIB_BITS', 'GL_CLIENT_PIXEL_STORE_BIT',
'GL_CLIENT_VERTEX_ARRAY_BIT', 'GL_CLIENT_ALL_ATTRIB_BITS', 'GL_FALSE',
'GL_TRUE', 'GL_POINTS', 'GL_LINES', 'GL_LINE_LOOP', 'GL_LINE_STRIP',
'GL_TRIANGLES', 'GL_TRIANGLE_STRIP', 'GL_TRIANGLE_FAN', 'GL_QUADS',
'GL_QUAD_STRIP', 'GL_POLYGON', 'GL_ACCUM', 'GL_LOAD', 'GL_RETURN', 'GL_MULT',
'GL_ADD', 'GL_NEVER', 'GL_LESS', 'GL_EQUAL', 'GL_LEQUAL', 'GL_GREATER',
'GL_NOTEQUAL', 'GL_GEQUAL', 'GL_ALWAYS', 'GL_ZERO', 'GL_ONE', 'GL_SRC_COLOR',
'GL_ONE_MINUS_SRC_COLOR', 'GL_SRC_ALPHA', 'GL_ONE_MINUS_SRC_ALPHA',
'GL_DST_ALPHA', 'GL_ONE_MINUS_DST_ALPHA', 'GL_DST_COLOR',
'GL_ONE_MINUS_DST_COLOR', 'GL_SRC_ALPHA_SATURATE', 'GL_NONE', 'GL_FRONT_LEFT',
'GL_FRONT_RIGHT', 'GL_BACK_LEFT', 'GL_BACK_RIGHT', 'GL_FRONT', 'GL_BACK',
'GL_LEFT', 'GL_RIGHT', 'GL_FRONT_AND_BACK', 'GL_AUX0', 'GL_AUX1', 'GL_AUX2',
'GL_AUX3', 'GL_NO_ERROR', 'GL_INVALID_ENUM', 'GL_INVALID_VALUE',
'GL_INVALID_OPERATION', 'GL_STACK_OVERFLOW', 'GL_STACK_UNDERFLOW',
'GL_OUT_OF_MEMORY', 'GL_TABLE_TOO_LARGE', 'GL_2D', 'GL_3D', 'GL_3D_COLOR',
'GL_3D_COLOR_TEXTURE', 'GL_4D_COLOR_TEXTURE', 'GL_PASS_THROUGH_TOKEN',
'GL_POINT_TOKEN', 'GL_LINE_TOKEN', 'GL_POLYGON_TOKEN', 'GL_BITMAP_TOKEN',
'GL_DRAW_PIXEL_TOKEN', 'GL_COPY_PIXEL_TOKEN', 'GL_LINE_RESET_TOKEN', 'GL_EXP',
'GL_EXP2', 'GL_CW', 'GL_CCW', 'GL_COEFF', 'GL_ORDER', 'GL_DOMAIN',
'GL_PIXEL_MAP_I_TO_I', 'GL_PIXEL_MAP_S_TO_S', 'GL_PIXEL_MAP_I_TO_R',
'GL_PIXEL_MAP_I_TO_G', 'GL_PIXEL_MAP_I_TO_B', 'GL_PIXEL_MAP_I_TO_A',
'GL_PIXEL_MAP_R_TO_R', 'GL_PIXEL_MAP_G_TO_G', 'GL_PIXEL_MAP_B_TO_B',
'GL_PIXEL_MAP_A_TO_A', 'GL_VERTEX_ARRAY_POINTER', 'GL_NORMAL_ARRAY_POINTER',
'GL_COLOR_ARRAY_POINTER', 'GL_INDEX_ARRAY_POINTER',
'GL_TEXTURE_COORD_ARRAY_POINTER', 'GL_EDGE_FLAG_ARRAY_POINTER',
'GL_CURRENT_COLOR', 'GL_CURRENT_INDEX', 'GL_CURRENT_NORMAL',
'GL_CURRENT_TEXTURE_COORDS', 'GL_CURRENT_RASTER_COLOR',
'GL_CURRENT_RASTER_INDEX', 'GL_CURRENT_RASTER_TEXTURE_COORDS',
'GL_CURRENT_RASTER_POSITION', 'GL_CURRENT_RASTER_POSITION_VALID',
'GL_CURRENT_RASTER_DISTANCE', 'GL_POINT_SMOOTH', 'GL_POINT_SIZE',
'GL_SMOOTH_POINT_SIZE_RANGE', 'GL_SMOOTH_POINT_SIZE_GRANULARITY',
'GL_POINT_SIZE_RANGE', 'GL_POINT_SIZE_GRANULARITY', 'GL_LINE_SMOOTH',
'GL_LINE_WIDTH', 'GL_SMOOTH_LINE_WIDTH_RANGE',
'GL_SMOOTH_LINE_WIDTH_GRANULARITY', 'GL_LINE_WIDTH_RANGE',
'GL_LINE_WIDTH_GRANULARITY', 'GL_LINE_STIPPLE', 'GL_LINE_STIPPLE_PATTERN',
'GL_LINE_STIPPLE_REPEAT', 'GL_LIST_MODE', 'GL_MAX_LIST_NESTING',
'GL_LIST_BASE', 'GL_LIST_INDEX', 'GL_POLYGON_MODE', 'GL_POLYGON_SMOOTH',
'GL_POLYGON_STIPPLE', 'GL_EDGE_FLAG', 'GL_CULL_FACE', 'GL_CULL_FACE_MODE',
'GL_FRONT_FACE', 'GL_LIGHTING', 'GL_LIGHT_MODEL_LOCAL_VIEWER',
'GL_LIGHT_MODEL_TWO_SIDE', 'GL_LIGHT_MODEL_AMBIENT', 'GL_SHADE_MODEL',
'GL_COLOR_MATERIAL_FACE', 'GL_COLOR_MATERIAL_PARAMETER', 'GL_COLOR_MATERIAL',
'GL_FOG', 'GL_FOG_INDEX', 'GL_FOG_DENSITY', 'GL_FOG_START', 'GL_FOG_END',
'GL_FOG_MODE', 'GL_FOG_COLOR', 'GL_DEPTH_RANGE', 'GL_DEPTH_TEST',
'GL_DEPTH_WRITEMASK', 'GL_DEPTH_CLEAR_VALUE', 'GL_DEPTH_FUNC',
'GL_ACCUM_CLEAR_VALUE', 'GL_STENCIL_TEST', 'GL_STENCIL_CLEAR_VALUE',
'GL_STENCIL_FUNC', 'GL_STENCIL_VALUE_MASK', 'GL_STENCIL_FAIL',
'GL_STENCIL_PASS_DEPTH_FAIL', 'GL_STENCIL_PASS_DEPTH_PASS', 'GL_STENCIL_REF',
'GL_STENCIL_WRITEMASK', 'GL_MATRIX_MODE', 'GL_NORMALIZE', 'GL_VIEWPORT',
'GL_MODELVIEW_STACK_DEPTH', 'GL_PROJECTION_STACK_DEPTH',
'GL_TEXTURE_STACK_DEPTH', 'GL_MODELVIEW_MATRIX', 'GL_PROJECTION_MATRIX',
'GL_TEXTURE_MATRIX', 'GL_ATTRIB_STACK_DEPTH', 'GL_CLIENT_ATTRIB_STACK_DEPTH',
'GL_ALPHA_TEST', 'GL_ALPHA_TEST_FUNC', 'GL_ALPHA_TEST_REF', 'GL_DITHER',
'GL_BLEND_DST', 'GL_BLEND_SRC', 'GL_BLEND', 'GL_LOGIC_OP_MODE',
'GL_INDEX_LOGIC_OP', 'GL_LOGIC_OP', 'GL_COLOR_LOGIC_OP', 'GL_AUX_BUFFERS',
'GL_DRAW_BUFFER', 'GL_READ_BUFFER', 'GL_SCISSOR_BOX', 'GL_SCISSOR_TEST',
'GL_INDEX_CLEAR_VALUE', 'GL_INDEX_WRITEMASK', 'GL_COLOR_CLEAR_VALUE',
'GL_COLOR_WRITEMASK', 'GL_INDEX_MODE', 'GL_RGBA_MODE', 'GL_DOUBLEBUFFER',
'GL_STEREO', 'GL_RENDER_MODE', 'GL_PERSPECTIVE_CORRECTION_HINT',
'GL_POINT_SMOOTH_HINT', 'GL_LINE_SMOOTH_HINT', 'GL_POLYGON_SMOOTH_HINT',
'GL_FOG_HINT', 'GL_TEXTURE_GEN_S', 'GL_TEXTURE_GEN_T', 'GL_TEXTURE_GEN_R',
'GL_TEXTURE_GEN_Q', 'GL_PIXEL_MAP_I_TO_I_SIZE', 'GL_PIXEL_MAP_S_TO_S_SIZE',
'GL_PIXEL_MAP_I_TO_R_SIZE', 'GL_PIXEL_MAP_I_TO_G_SIZE',
'GL_PIXEL_MAP_I_TO_B_SIZE', 'GL_PIXEL_MAP_I_TO_A_SIZE',
'GL_PIXEL_MAP_R_TO_R_SIZE', 'GL_PIXEL_MAP_G_TO_G_SIZE',
'GL_PIXEL_MAP_B_TO_B_SIZE', 'GL_PIXEL_MAP_A_TO_A_SIZE',
'GL_UNPACK_SWAP_BYTES', 'GL_UNPACK_LSB_FIRST', 'GL_UNPACK_ROW_LENGTH',
'GL_UNPACK_SKIP_ROWS', 'GL_UNPACK_SKIP_PIXELS', 'GL_UNPACK_ALIGNMENT',
'GL_PACK_SWAP_BYTES', 'GL_PACK_LSB_FIRST', 'GL_PACK_ROW_LENGTH',
'GL_PACK_SKIP_ROWS', 'GL_PACK_SKIP_PIXELS', 'GL_PACK_ALIGNMENT',
'GL_MAP_COLOR', 'GL_MAP_STENCIL', 'GL_INDEX_SHIFT', 'GL_INDEX_OFFSET',
'GL_RED_SCALE', 'GL_RED_BIAS', 'GL_ZOOM_X', 'GL_ZOOM_Y', 'GL_GREEN_SCALE',
'GL_GREEN_BIAS', 'GL_BLUE_SCALE', 'GL_BLUE_BIAS', 'GL_ALPHA_SCALE',
'GL_ALPHA_BIAS', 'GL_DEPTH_SCALE', 'GL_DEPTH_BIAS', 'GL_MAX_EVAL_ORDER',
'GL_MAX_LIGHTS', 'GL_MAX_CLIP_PLANES', 'GL_MAX_TEXTURE_SIZE',
'GL_MAX_PIXEL_MAP_TABLE', 'GL_MAX_ATTRIB_STACK_DEPTH',
'GL_MAX_MODELVIEW_STACK_DEPTH', 'GL_MAX_NAME_STACK_DEPTH',
'GL_MAX_PROJECTION_STACK_DEPTH', 'GL_MAX_TEXTURE_STACK_DEPTH',
'GL_MAX_VIEWPORT_DIMS', 'GL_MAX_CLIENT_ATTRIB_STACK_DEPTH',
'GL_SUBPIXEL_BITS', 'GL_INDEX_BITS', 'GL_RED_BITS', 'GL_GREEN_BITS',
'GL_BLUE_BITS', 'GL_ALPHA_BITS', 'GL_DEPTH_BITS', 'GL_STENCIL_BITS',
'GL_ACCUM_RED_BITS', 'GL_ACCUM_GREEN_BITS', 'GL_ACCUM_BLUE_BITS',
'GL_ACCUM_ALPHA_BITS', 'GL_NAME_STACK_DEPTH', 'GL_AUTO_NORMAL',
'GL_MAP1_COLOR_4', 'GL_MAP1_INDEX', 'GL_MAP1_NORMAL',
'GL_MAP1_TEXTURE_COORD_1', 'GL_MAP1_TEXTURE_COORD_2',
'GL_MAP1_TEXTURE_COORD_3', 'GL_MAP1_TEXTURE_COORD_4', 'GL_MAP1_VERTEX_3',
'GL_MAP1_VERTEX_4', 'GL_MAP2_COLOR_4', 'GL_MAP2_INDEX', 'GL_MAP2_NORMAL',
'GL_MAP2_TEXTURE_COORD_1', 'GL_MAP2_TEXTURE_COORD_2',
'GL_MAP2_TEXTURE_COORD_3', 'GL_MAP2_TEXTURE_COORD_4', 'GL_MAP2_VERTEX_3',
'GL_MAP2_VERTEX_4', 'GL_MAP1_GRID_DOMAIN', 'GL_MAP1_GRID_SEGMENTS',
'GL_MAP2_GRID_DOMAIN', 'GL_MAP2_GRID_SEGMENTS', 'GL_TEXTURE_1D',
'GL_TEXTURE_2D', 'GL_FEEDBACK_BUFFER_POINTER', 'GL_FEEDBACK_BUFFER_SIZE',
'GL_FEEDBACK_BUFFER_TYPE', 'GL_SELECTION_BUFFER_POINTER',
'GL_SELECTION_BUFFER_SIZE', 'GL_POLYGON_OFFSET_UNITS',
'GL_POLYGON_OFFSET_POINT', 'GL_POLYGON_OFFSET_LINE', 'GL_POLYGON_OFFSET_FILL',
'GL_POLYGON_OFFSET_FACTOR', 'GL_TEXTURE_BINDING_1D', 'GL_TEXTURE_BINDING_2D',
'GL_TEXTURE_BINDING_3D', 'GL_VERTEX_ARRAY', 'GL_NORMAL_ARRAY',
'GL_COLOR_ARRAY', 'GL_INDEX_ARRAY', 'GL_TEXTURE_COORD_ARRAY',
'GL_EDGE_FLAG_ARRAY', 'GL_VERTEX_ARRAY_SIZE', 'GL_VERTEX_ARRAY_TYPE',
'GL_VERTEX_ARRAY_STRIDE', 'GL_NORMAL_ARRAY_TYPE', 'GL_NORMAL_ARRAY_STRIDE',
'GL_COLOR_ARRAY_SIZE', 'GL_COLOR_ARRAY_TYPE', 'GL_COLOR_ARRAY_STRIDE',
'GL_INDEX_ARRAY_TYPE', 'GL_INDEX_ARRAY_STRIDE', 'GL_TEXTURE_COORD_ARRAY_SIZE',
'GL_TEXTURE_COORD_ARRAY_TYPE', 'GL_TEXTURE_COORD_ARRAY_STRIDE',
'GL_EDGE_FLAG_ARRAY_STRIDE', 'GL_TEXTURE_WIDTH', 'GL_TEXTURE_HEIGHT',
'GL_TEXTURE_INTERNAL_FORMAT', 'GL_TEXTURE_COMPONENTS',
'GL_TEXTURE_BORDER_COLOR', 'GL_TEXTURE_BORDER', 'GL_TEXTURE_RED_SIZE',
'GL_TEXTURE_GREEN_SIZE', 'GL_TEXTURE_BLUE_SIZE', 'GL_TEXTURE_ALPHA_SIZE',
'GL_TEXTURE_LUMINANCE_SIZE', 'GL_TEXTURE_INTENSITY_SIZE',
'GL_TEXTURE_PRIORITY', 'GL_TEXTURE_RESIDENT', 'GL_DONT_CARE', 'GL_FASTEST',
'GL_NICEST', 'GL_AMBIENT', 'GL_DIFFUSE', 'GL_SPECULAR', 'GL_POSITION',
'GL_SPOT_DIRECTION', 'GL_SPOT_EXPONENT', 'GL_SPOT_CUTOFF',
'GL_CONSTANT_ATTENUATION', 'GL_LINEAR_ATTENUATION',
'GL_QUADRATIC_ATTENUATION', 'GL_COMPILE', 'GL_COMPILE_AND_EXECUTE', 'GL_BYTE',
'GL_UNSIGNED_BYTE', 'GL_SHORT', 'GL_UNSIGNED_SHORT', 'GL_INT',
'GL_UNSIGNED_INT', 'GL_FLOAT', 'GL_2_BYTES', 'GL_3_BYTES', 'GL_4_BYTES',
'GL_DOUBLE', 'GL_DOUBLE_EXT', 'GL_CLEAR', 'GL_AND', 'GL_AND_REVERSE',
'GL_COPY', 'GL_AND_INVERTED', 'GL_NOOP', 'GL_XOR', 'GL_OR', 'GL_NOR',
'GL_EQUIV', 'GL_INVERT', 'GL_OR_REVERSE', 'GL_COPY_INVERTED',
'GL_OR_INVERTED', 'GL_NAND', 'GL_SET', 'GL_EMISSION', 'GL_SHININESS',
'GL_AMBIENT_AND_DIFFUSE', 'GL_COLOR_INDEXES', 'GL_MODELVIEW', 'GL_PROJECTION',
'GL_TEXTURE', 'GL_COLOR', 'GL_DEPTH', 'GL_STENCIL', 'GL_COLOR_INDEX',
'GL_STENCIL_INDEX', 'GL_DEPTH_COMPONENT', 'GL_RED', 'GL_GREEN', 'GL_BLUE',
'GL_ALPHA', 'GL_RGB', 'GL_RGBA', 'GL_LUMINANCE', 'GL_LUMINANCE_ALPHA',
'GL_BITMAP', 'GL_POINT', 'GL_LINE', 'GL_FILL', 'GL_RENDER', 'GL_FEEDBACK',
'GL_SELECT', 'GL_FLAT', 'GL_SMOOTH', 'GL_KEEP', 'GL_REPLACE', 'GL_INCR',
'GL_DECR', 'GL_VENDOR', 'GL_RENDERER', 'GL_VERSION', 'GL_EXTENSIONS', 'GL_S',
'GL_T', 'GL_R', 'GL_Q', 'GL_MODULATE', 'GL_DECAL', 'GL_TEXTURE_ENV_MODE',
'GL_TEXTURE_ENV_COLOR', 'GL_TEXTURE_ENV', 'GL_EYE_LINEAR', 'GL_OBJECT_LINEAR',
'GL_SPHERE_MAP', 'GL_TEXTURE_GEN_MODE', 'GL_OBJECT_PLANE', 'GL_EYE_PLANE',
'GL_NEAREST', 'GL_LINEAR', 'GL_NEAREST_MIPMAP_NEAREST',
'GL_LINEAR_MIPMAP_NEAREST', 'GL_NEAREST_MIPMAP_LINEAR',
'GL_LINEAR_MIPMAP_LINEAR', 'GL_TEXTURE_MAG_FILTER', 'GL_TEXTURE_MIN_FILTER',
'GL_TEXTURE_WRAP_S', 'GL_TEXTURE_WRAP_T', 'GL_PROXY_TEXTURE_1D',
'GL_PROXY_TEXTURE_2D', 'GL_CLAMP', 'GL_REPEAT', 'GL_R3_G3_B2', 'GL_ALPHA4',
'GL_ALPHA8', 'GL_ALPHA12', 'GL_ALPHA16', 'GL_LUMINANCE4', 'GL_LUMINANCE8',
'GL_LUMINANCE12', 'GL_LUMINANCE16', 'GL_LUMINANCE4_ALPHA4',
'GL_LUMINANCE6_ALPHA2', 'GL_LUMINANCE8_ALPHA8', 'GL_LUMINANCE12_ALPHA4',
'GL_LUMINANCE12_ALPHA12', 'GL_LUMINANCE16_ALPHA16', 'GL_INTENSITY',
'GL_INTENSITY4', 'GL_INTENSITY8', 'GL_INTENSITY12', 'GL_INTENSITY16',
'GL_RGB4', 'GL_RGB5', 'GL_RGB8', 'GL_RGB10', 'GL_RGB12', 'GL_RGB16',
'GL_RGBA2', 'GL_RGBA4', 'GL_RGB5_A1', 'GL_RGBA8', 'GL_RGB10_A2', 'GL_RGBA12',
'GL_RGBA16', 'GL_V2F', 'GL_V3F', 'GL_C4UB_V2F', 'GL_C4UB_V3F', 'GL_C3F_V3F',
'GL_N3F_V3F', 'GL_C4F_N3F_V3F', 'GL_T2F_V3F', 'GL_T4F_V4F', 'GL_T2F_C4UB_V3F',
'GL_T2F_C3F_V3F', 'GL_T2F_N3F_V3F', 'GL_T2F_C4F_N3F_V3F',
'GL_T4F_C4F_N3F_V4F', 'GL_CLIP_PLANE0', 'GL_CLIP_PLANE1', 'GL_CLIP_PLANE2',
'GL_CLIP_PLANE3', 'GL_CLIP_PLANE4', 'GL_CLIP_PLANE5', 'GL_LIGHT0',
'GL_LIGHT1', 'GL_LIGHT2', 'GL_LIGHT3', 'GL_LIGHT4', 'GL_LIGHT5', 'GL_LIGHT6',
'GL_LIGHT7', 'GL_ABGR_EXT', 'GL_FUNC_SUBTRACT_EXT',
'GL_FUNC_REVERSE_SUBTRACT_EXT', 'GL_UNSIGNED_BYTE_3_3_2_EXT',
'GL_UNSIGNED_SHORT_4_4_4_4_EXT', 'GL_UNSIGNED_SHORT_5_5_5_1_EXT',
'GL_UNSIGNED_INT_8_8_8_8_EXT', 'GL_UNSIGNED_INT_10_10_10_2_EXT',
'GL_PACK_SKIP_IMAGES', 'GL_PACK_IMAGE_HEIGHT', 'GL_UNPACK_SKIP_IMAGES',
'GL_UNPACK_IMAGE_HEIGHT', 'GL_TEXTURE_3D', 'GL_PROXY_TEXTURE_3D',
'GL_TEXTURE_DEPTH', 'GL_TEXTURE_WRAP_R', 'GL_MAX_3D_TEXTURE_SIZE', 'GL_BGR',
'GL_BGRA', 'GL_UNSIGNED_BYTE_3_3_2', 'GL_UNSIGNED_BYTE_2_3_3_REV',
'GL_UNSIGNED_SHORT_5_6_5', 'GL_UNSIGNED_SHORT_5_6_5_REV',
'GL_UNSIGNED_SHORT_4_4_4_4', 'GL_UNSIGNED_SHORT_4_4_4_4_REV',
'GL_UNSIGNED_SHORT_5_5_5_1', 'GL_UNSIGNED_SHORT_1_5_5_5_REV',
'GL_UNSIGNED_INT_8_8_8_8', 'GL_UNSIGNED_INT_8_8_8_8_REV',
'GL_UNSIGNED_INT_10_10_10_2', 'GL_UNSIGNED_INT_2_10_10_10_REV',
'GL_RESCALE_NORMAL', 'GL_LIGHT_MODEL_COLOR_CONTROL', 'GL_SINGLE_COLOR',
'GL_SEPARATE_SPECULAR_COLOR', 'GL_CLAMP_TO_EDGE', 'GL_TEXTURE_MIN_LOD',
'GL_TEXTURE_MAX_LOD', 'GL_TEXTURE_BASE_LEVEL', 'GL_TEXTURE_MAX_LEVEL',
'GL_MAX_ELEMENTS_VERTICES', 'GL_MAX_ELEMENTS_INDICES',
'GL_ALIASED_POINT_SIZE_RANGE', 'GL_ALIASED_LINE_WIDTH_RANGE',
'GL_ACTIVE_TEXTURE', 'GL_CLIENT_ACTIVE_TEXTURE', 'GL_MAX_TEXTURE_UNITS',
'GL_TEXTURE0', 'GL_TEXTURE1', 'GL_TEXTURE2', 'GL_TEXTURE3', 'GL_TEXTURE4',
'GL_TEXTURE5', 'GL_TEXTURE6', 'GL_TEXTURE7', 'GL_TEXTURE8', 'GL_TEXTURE9',
'GL_TEXTURE10', 'GL_TEXTURE11', 'GL_TEXTURE12', 'GL_TEXTURE13',
'GL_TEXTURE14', 'GL_TEXTURE15', 'GL_TEXTURE16', 'GL_TEXTURE17',
'GL_TEXTURE18', 'GL_TEXTURE19', 'GL_TEXTURE20', 'GL_TEXTURE21',
'GL_TEXTURE22', 'GL_TEXTURE23', 'GL_TEXTURE24', 'GL_TEXTURE25',
'GL_TEXTURE26', 'GL_TEXTURE27', 'GL_TEXTURE28', 'GL_TEXTURE29',
'GL_TEXTURE30', 'GL_TEXTURE31', 'GL_NORMAL_MAP', 'GL_REFLECTION_MAP',
'GL_TEXTURE_CUBE_MAP', 'GL_TEXTURE_BINDING_CUBE_MAP',
'GL_TEXTURE_CUBE_MAP_POSITIVE_X', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_X',
'GL_TEXTURE_CUBE_MAP_POSITIVE_Y', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_Y',
'GL_TEXTURE_CUBE_MAP_POSITIVE_Z', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_Z',
'GL_PROXY_TEXTURE_CUBE_MAP', 'GL_MAX_CUBE_MAP_TEXTURE_SIZE', 'GL_COMBINE',
'GL_COMBINE_RGB', 'GL_COMBINE_ALPHA', 'GL_RGB_SCALE', 'GL_ADD_SIGNED',
'GL_INTERPOLATE', 'GL_CONSTANT', 'GL_PRIMARY_COLOR', 'GL_PREVIOUS',
'GL_SOURCE0_RGB', 'GL_SOURCE1_RGB', 'GL_SOURCE2_RGB', 'GL_SOURCE0_ALPHA',
'GL_SOURCE1_ALPHA', 'GL_SOURCE2_ALPHA', 'GL_OPERAND0_RGB', 'GL_OPERAND1_RGB',
'GL_OPERAND2_RGB', 'GL_OPERAND0_ALPHA', 'GL_OPERAND1_ALPHA',
'GL_OPERAND2_ALPHA', 'GL_SUBTRACT', 'GL_TRANSPOSE_MODELVIEW_MATRIX',
'GL_TRANSPOSE_PROJECTION_MATRIX', 'GL_TRANSPOSE_TEXTURE_MATRIX',
'GL_TRANSPOSE_COLOR_MATRIX', 'GL_COMPRESSED_ALPHA', 'GL_COMPRESSED_LUMINANCE',
'GL_COMPRESSED_LUMINANCE_ALPHA', 'GL_COMPRESSED_INTENSITY',
'GL_COMPRESSED_RGB', 'GL_COMPRESSED_RGBA', 'GL_TEXTURE_COMPRESSION_HINT',
'GL_TEXTURE_COMPRESSED_IMAGE_SIZE', 'GL_TEXTURE_COMPRESSED',
'GL_NUM_COMPRESSED_TEXTURE_FORMATS', 'GL_COMPRESSED_TEXTURE_FORMATS',
'GL_DOT3_RGB', 'GL_DOT3_RGBA', 'GL_CLAMP_TO_BORDER', 'GL_MULTISAMPLE',
'GL_SAMPLE_ALPHA_TO_COVERAGE', 'GL_SAMPLE_ALPHA_TO_ONE', 'GL_SAMPLE_COVERAGE',
'GL_SAMPLE_BUFFERS', 'GL_SAMPLES', 'GL_SAMPLE_COVERAGE_VALUE',
'GL_SAMPLE_COVERAGE_INVERT', 'GL_MULTISAMPLE_BIT', 'GL_VERTEX_ARRAY_EXT',
'GL_NORMAL_ARRAY_EXT', 'GL_COLOR_ARRAY_EXT', 'GL_INDEX_ARRAY_EXT',
'GL_TEXTURE_COORD_ARRAY_EXT', 'GL_EDGE_FLAG_ARRAY_EXT',
'GL_VERTEX_ARRAY_SIZE_EXT', 'GL_VERTEX_ARRAY_TYPE_EXT',
'GL_VERTEX_ARRAY_STRIDE_EXT', 'GL_VERTEX_ARRAY_COUNT_EXT',
'GL_NORMAL_ARRAY_TYPE_EXT', 'GL_NORMAL_ARRAY_STRIDE_EXT',
'GL_NORMAL_ARRAY_COUNT_EXT', 'GL_COLOR_ARRAY_SIZE_EXT',
'GL_COLOR_ARRAY_TYPE_EXT', 'GL_COLOR_ARRAY_STRIDE_EXT',
'GL_COLOR_ARRAY_COUNT_EXT', 'GL_INDEX_ARRAY_TYPE_EXT',
'GL_INDEX_ARRAY_STRIDE_EXT', 'GL_INDEX_ARRAY_COUNT_EXT',
'GL_TEXTURE_COORD_ARRAY_SIZE_EXT', 'GL_TEXTURE_COORD_ARRAY_TYPE_EXT',
'GL_TEXTURE_COORD_ARRAY_STRIDE_EXT', 'GL_TEXTURE_COORD_ARRAY_COUNT_EXT',
'GL_EDGE_FLAG_ARRAY_STRIDE_EXT', 'GL_EDGE_FLAG_ARRAY_COUNT_EXT',
'GL_VERTEX_ARRAY_POINTER_EXT', 'GL_NORMAL_ARRAY_POINTER_EXT',
'GL_COLOR_ARRAY_POINTER_EXT', 'GL_INDEX_ARRAY_POINTER_EXT',
'GL_TEXTURE_COORD_ARRAY_POINTER_EXT', 'GL_EDGE_FLAG_ARRAY_POINTER_EXT',
'GL_TEXTURE_MIN_LOD_SGIS', 'GL_TEXTURE_MAX_LOD_SGIS',
'GL_TEXTURE_BASE_LEVEL_SGIS', 'GL_TEXTURE_MAX_LEVEL_SGIS',
'GL_SHARED_TEXTURE_PALETTE_EXT', 'GL_RESCALE_NORMAL_EXT',
'GL_TEXTURE_COMPARE_SGIX', 'GL_TEXTURE_COMPARE_OPERATOR_SGIX',
'GL_TEXTURE_LEQUAL_R_SGIX', 'GL_TEXTURE_GEQUAL_R_SGIX',
'GL_DEPTH_COMPONENT16_SGIX', 'GL_DEPTH_COMPONENT24_SGIX',
'GL_DEPTH_COMPONENT32_SGIX', 'GL_GENERATE_MIPMAP_SGIS',
'GL_GENERATE_MIPMAP_HINT_SGIS', 'GL_POINT_SIZE_MIN', 'GL_POINT_SIZE_MAX',
'GL_POINT_FADE_THRESHOLD_SIZE', 'GL_POINT_DISTANCE_ATTENUATION',
'GL_FOG_COORDINATE_SOURCE', 'GL_FOG_COORDINATE', 'GL_FRAGMENT_DEPTH',
'GL_CURRENT_FOG_COORDINATE', 'GL_FOG_COORDINATE_ARRAY_TYPE',
'GL_FOG_COORDINATE_ARRAY_STRIDE', 'GL_FOG_COORDINATE_ARRAY_POINTER',
'GL_FOG_COORDINATE_ARRAY', 'GL_COLOR_SUM', 'GL_CURRENT_SECONDARY_COLOR',
'GL_SECONDARY_COLOR_ARRAY_SIZE', 'GL_SECONDARY_COLOR_ARRAY_TYPE',
'GL_SECONDARY_COLOR_ARRAY_STRIDE', 'GL_SECONDARY_COLOR_ARRAY_POINTER',
'GL_SECONDARY_COLOR_ARRAY', 'GL_INCR_WRAP', 'GL_DECR_WRAP',
'GL_MAX_TEXTURE_LOD_BIAS', 'GL_TEXTURE_FILTER_CONTROL', 'GL_TEXTURE_LOD_BIAS',
'GL_GENERATE_MIPMAP', 'GL_GENERATE_MIPMAP_HINT', 'GL_BLEND_DST_RGB',
'GL_BLEND_SRC_RGB', 'GL_BLEND_DST_ALPHA', 'GL_BLEND_SRC_ALPHA',
'GL_MIRRORED_REPEAT', 'GL_DEPTH_COMPONENT16', 'GL_DEPTH_COMPONENT24',
'GL_DEPTH_COMPONENT32', 'GL_TEXTURE_DEPTH_SIZE', 'GL_DEPTH_TEXTURE_MODE',
'GL_TEXTURE_COMPARE_MODE', 'GL_TEXTURE_COMPARE_FUNC',
'GL_COMPARE_R_TO_TEXTURE', 'glAccum', 'glAlphaFunc', 'glAreTexturesResident',
'glArrayElement', 'glBegin', 'glBindTexture', 'glBitmap', 'glBlendFunc',
'glCallList', 'glCallLists', 'glClear', 'glClearAccum', 'glClearColor',
'glClearDepth', 'glClearIndex', 'glClearStencil', 'glClipPlane', 'glColor3b',
'glColor3bv', 'glColor3d', 'glColor3dv', 'glColor3f', 'glColor3fv',
'glColor3i', 'glColor3iv', 'glColor3s', 'glColor3sv', 'glColor3ub',
'glColor3ubv', 'glColor3ui', 'glColor3uiv', 'glColor3us', 'glColor3usv',
'glColor4b', 'glColor4bv', 'glColor4d', 'glColor4dv', 'glColor4f',
'glColor4fv', 'glColor4i', 'glColor4iv', 'glColor4s', 'glColor4sv',
'glColor4ub', 'glColor4ubv', 'glColor4ui', 'glColor4uiv', 'glColor4us',
'glColor4usv', 'glColorMask', 'glColorMaterial', 'glColorPointer',
'glCopyPixels', 'glCopyTexImage1D', 'glCopyTexImage2D', 'glCopyTexSubImage1D',
'glCopyTexSubImage2D', 'glCullFace', 'glDeleteLists', 'glDeleteTextures',
'glDepthFunc', 'glDepthMask', 'glDepthRange', 'glDisable',
'glDisableClientState', 'glDrawArrays', 'glDrawBuffer', 'glDrawElements',
'glDrawPixels', 'glEdgeFlag', 'glEdgeFlagPointer', 'glEdgeFlagv', 'glEnable',
'glEnableClientState', 'glEnd', 'glEndList', 'glEvalCoord1d',
'glEvalCoord1dv', 'glEvalCoord1f', 'glEvalCoord1fv', 'glEvalCoord2d',
'glEvalCoord2dv', 'glEvalCoord2f', 'glEvalCoord2fv', 'glEvalMesh1',
'glEvalMesh2', 'glEvalPoint1', 'glEvalPoint2', 'glFeedbackBuffer', 'glFinish',
'glFlush', 'glFogf', 'glFogfv', 'glFogi', 'glFogiv', 'glFrontFace',
'glFrustum', 'glGenLists', 'glGenTextures', 'glGetBooleanv', 'glGetClipPlane',
'glGetDoublev', 'glGetError', 'glGetFloatv', 'glGetIntegerv', 'glGetLightfv',
'glGetLightiv', 'glGetMapdv', 'glGetMapfv', 'glGetMapiv', 'glGetMaterialfv',
'glGetMaterialiv', 'glGetPixelMapfv', 'glGetPixelMapuiv', 'glGetPixelMapusv',
'glGetPointerv', 'glGetPolygonStipple', 'glGetString', 'glGetTexEnvfv',
'glGetTexEnviv', 'glGetTexGendv', 'glGetTexGenfv', 'glGetTexGeniv',
'glGetTexImage', 'glGetTexLevelParameterfv', 'glGetTexLevelParameteriv',
'glGetTexParameterfv', 'glGetTexParameteriv', 'glHint', 'glIndexMask',
'glIndexPointer', 'glIndexd', 'glIndexdv', 'glIndexf', 'glIndexfv',
'glIndexi', 'glIndexiv', 'glIndexs', 'glIndexsv', 'glIndexub', 'glIndexubv',
'glInitNames', 'glInterleavedArrays', 'glIsEnabled', 'glIsList',
'glIsTexture', 'glLightModelf', 'glLightModelfv', 'glLightModeli',
'glLightModeliv', 'glLightf', 'glLightfv', 'glLighti', 'glLightiv',
'glLineStipple', 'glLineWidth', 'glListBase', 'glLoadIdentity',
'glLoadMatrixd', 'glLoadMatrixf', 'glLoadName', 'glLogicOp', 'glMap1d',
'glMap1f', 'glMap2d', 'glMap2f', 'glMapGrid1d', 'glMapGrid1f', 'glMapGrid2d',
'glMapGrid2f', 'glMaterialf', 'glMaterialfv', 'glMateriali', 'glMaterialiv',
'glMatrixMode', 'glMultMatrixd', 'glMultMatrixf', 'glNewList', 'glNormal3b',
'glNormal3bv', 'glNormal3d', 'glNormal3dv', 'glNormal3f', 'glNormal3fv',
'glNormal3i', 'glNormal3iv', 'glNormal3s', 'glNormal3sv', 'glNormalPointer',
'glOrtho', 'glPassThrough', 'glPixelMapfv', 'glPixelMapuiv', 'glPixelMapusv',
'glPixelStoref', 'glPixelStorei', 'glPixelTransferf', 'glPixelTransferi',
'glPixelZoom', 'glPointSize', 'glPolygonMode', 'glPolygonOffset',
'glPolygonStipple', 'glPopAttrib', 'glPopClientAttrib', 'glPopMatrix',
'glPopName', 'glPrioritizeTextures', 'glPushAttrib', 'glPushClientAttrib',
'glPushMatrix', 'glPushName', 'glRasterPos2d', 'glRasterPos2dv',
'glRasterPos2f', 'glRasterPos2fv', 'glRasterPos2i', 'glRasterPos2iv',
'glRasterPos2s', 'glRasterPos2sv', 'glRasterPos3d', 'glRasterPos3dv',
'glRasterPos3f', 'glRasterPos3fv', 'glRasterPos3i', 'glRasterPos3iv',
'glRasterPos3s', 'glRasterPos3sv', 'glRasterPos4d', 'glRasterPos4dv',
'glRasterPos4f', 'glRasterPos4fv', 'glRasterPos4i', 'glRasterPos4iv',
'glRasterPos4s', 'glRasterPos4sv', 'glReadBuffer', 'glReadPixels', 'glRectd',
'glRectdv', 'glRectf', 'glRectfv', 'glRecti', 'glRectiv', 'glRects',
'glRectsv', 'glRenderMode', 'glRotated', 'glRotatef', 'glScaled', 'glScalef',
'glScissor', 'glSelectBuffer', 'glShadeModel', 'glStencilFunc',
'glStencilMask', 'glStencilOp', 'glTexCoord1d', 'glTexCoord1dv',
'glTexCoord1f', 'glTexCoord1fv', 'glTexCoord1i', 'glTexCoord1iv',
'glTexCoord1s', 'glTexCoord1sv', 'glTexCoord2d', 'glTexCoord2dv',
'glTexCoord2f', 'glTexCoord2fv', 'glTexCoord2i', 'glTexCoord2iv',
'glTexCoord2s', 'glTexCoord2sv', 'glTexCoord3d', 'glTexCoord3dv',
'glTexCoord3f', 'glTexCoord3fv', 'glTexCoord3i', 'glTexCoord3iv',
'glTexCoord3s', 'glTexCoord3sv', 'glTexCoord4d', 'glTexCoord4dv',
'glTexCoord4f', 'glTexCoord4fv', 'glTexCoord4i', 'glTexCoord4iv',
'glTexCoord4s', 'glTexCoord4sv', 'glTexCoordPointer', 'glTexEnvf',
'glTexEnvfv', 'glTexEnvi', 'glTexEnviv', 'glTexGend', 'glTexGendv',
'glTexGenf', 'glTexGenfv', 'glTexGeni', 'glTexGeniv', 'glTexImage1D',
'glTexImage2D', 'glTexParameterf', 'glTexParameterfv', 'glTexParameteri',
'glTexParameteriv', 'glTexSubImage1D', 'glTexSubImage2D', 'glTranslated',
'glTranslatef', 'glVertex2d', 'glVertex2dv', 'glVertex2f', 'glVertex2fv',
'glVertex2i', 'glVertex2iv', 'glVertex2s', 'glVertex2sv', 'glVertex3d',
'glVertex3dv', 'glVertex3f', 'glVertex3fv', 'glVertex3i', 'glVertex3iv',
'glVertex3s', 'glVertex3sv', 'glVertex4d', 'glVertex4dv', 'glVertex4f',
'glVertex4fv', 'glVertex4i', 'glVertex4iv', 'glVertex4s', 'glVertex4sv',
'glVertexPointer', 'glViewport']
# END GENERATED CONTENT (do not edit above this line)




########NEW FILE########
__FILENAME__ = glext_arb
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for http://oss.sgi.com/projects/ogl-sample/ABI/glext.h

Generated by tools/gengl.py.
Do not modify this file.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: glext_arb.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

from ctypes import *
from pyglet.gl.lib import link_GL as _link_function
from pyglet.gl.lib import c_ptrdiff_t

# BEGIN GENERATED CONTENT (do not edit below this line)

# This content is generated by tools/gengl.py.
# Wrapper for http://oss.sgi.com/projects/ogl-sample/ABI/glext.h


# GLEXT_LEGACY (/usr/include/GL/gl.h:70)
GL_GLEXT_VERSION = 29 	# GL/glext.h:57
# VERSION_1_2 (GL/glext.h:59)
GL_UNSIGNED_BYTE_3_3_2 = 32818 	# GL/glext.h:60
GL_UNSIGNED_SHORT_4_4_4_4 = 32819 	# GL/glext.h:61
GL_UNSIGNED_SHORT_5_5_5_1 = 32820 	# GL/glext.h:62
GL_UNSIGNED_INT_8_8_8_8 = 32821 	# GL/glext.h:63
GL_UNSIGNED_INT_10_10_10_2 = 32822 	# GL/glext.h:64
GL_RESCALE_NORMAL = 32826 	# GL/glext.h:65
GL_TEXTURE_BINDING_3D = 32874 	# GL/glext.h:66
GL_PACK_SKIP_IMAGES = 32875 	# GL/glext.h:67
GL_PACK_IMAGE_HEIGHT = 32876 	# GL/glext.h:68
GL_UNPACK_SKIP_IMAGES = 32877 	# GL/glext.h:69
GL_UNPACK_IMAGE_HEIGHT = 32878 	# GL/glext.h:70
GL_TEXTURE_3D = 32879 	# GL/glext.h:71
GL_PROXY_TEXTURE_3D = 32880 	# GL/glext.h:72
GL_TEXTURE_DEPTH = 32881 	# GL/glext.h:73
GL_TEXTURE_WRAP_R = 32882 	# GL/glext.h:74
GL_MAX_3D_TEXTURE_SIZE = 32883 	# GL/glext.h:75
GL_UNSIGNED_BYTE_2_3_3_REV = 33634 	# GL/glext.h:76
GL_UNSIGNED_SHORT_5_6_5 = 33635 	# GL/glext.h:77
GL_UNSIGNED_SHORT_5_6_5_REV = 33636 	# GL/glext.h:78
GL_UNSIGNED_SHORT_4_4_4_4_REV = 33637 	# GL/glext.h:79
GL_UNSIGNED_SHORT_1_5_5_5_REV = 33638 	# GL/glext.h:80
GL_UNSIGNED_INT_8_8_8_8_REV = 33639 	# GL/glext.h:81
GL_UNSIGNED_INT_2_10_10_10_REV = 33640 	# GL/glext.h:82
GL_BGR = 32992 	# GL/glext.h:83
GL_BGRA = 32993 	# GL/glext.h:84
GL_MAX_ELEMENTS_VERTICES = 33000 	# GL/glext.h:85
GL_MAX_ELEMENTS_INDICES = 33001 	# GL/glext.h:86
GL_CLAMP_TO_EDGE = 33071 	# GL/glext.h:87
GL_TEXTURE_MIN_LOD = 33082 	# GL/glext.h:88
GL_TEXTURE_MAX_LOD = 33083 	# GL/glext.h:89
GL_TEXTURE_BASE_LEVEL = 33084 	# GL/glext.h:90
GL_TEXTURE_MAX_LEVEL = 33085 	# GL/glext.h:91
GL_LIGHT_MODEL_COLOR_CONTROL = 33272 	# GL/glext.h:92
GL_SINGLE_COLOR = 33273 	# GL/glext.h:93
GL_SEPARATE_SPECULAR_COLOR = 33274 	# GL/glext.h:94
GL_SMOOTH_POINT_SIZE_RANGE = 2834 	# GL/glext.h:95
GL_SMOOTH_POINT_SIZE_GRANULARITY = 2835 	# GL/glext.h:96
GL_SMOOTH_LINE_WIDTH_RANGE = 2850 	# GL/glext.h:97
GL_SMOOTH_LINE_WIDTH_GRANULARITY = 2851 	# GL/glext.h:98
GL_ALIASED_POINT_SIZE_RANGE = 33901 	# GL/glext.h:99
GL_ALIASED_LINE_WIDTH_RANGE = 33902 	# GL/glext.h:100
# ARB_imaging (GL/glext.h:103)
GL_CONSTANT_COLOR = 32769 	# GL/glext.h:104
GL_ONE_MINUS_CONSTANT_COLOR = 32770 	# GL/glext.h:105
GL_CONSTANT_ALPHA = 32771 	# GL/glext.h:106
GL_ONE_MINUS_CONSTANT_ALPHA = 32772 	# GL/glext.h:107
GL_BLEND_COLOR = 32773 	# GL/glext.h:108
GL_FUNC_ADD = 32774 	# GL/glext.h:109
GL_MIN = 32775 	# GL/glext.h:110
GL_MAX = 32776 	# GL/glext.h:111
GL_BLEND_EQUATION = 32777 	# GL/glext.h:112
GL_FUNC_SUBTRACT = 32778 	# GL/glext.h:113
GL_FUNC_REVERSE_SUBTRACT = 32779 	# GL/glext.h:114
GL_CONVOLUTION_1D = 32784 	# GL/glext.h:115
GL_CONVOLUTION_2D = 32785 	# GL/glext.h:116
GL_SEPARABLE_2D = 32786 	# GL/glext.h:117
GL_CONVOLUTION_BORDER_MODE = 32787 	# GL/glext.h:118
GL_CONVOLUTION_FILTER_SCALE = 32788 	# GL/glext.h:119
GL_CONVOLUTION_FILTER_BIAS = 32789 	# GL/glext.h:120
GL_REDUCE = 32790 	# GL/glext.h:121
GL_CONVOLUTION_FORMAT = 32791 	# GL/glext.h:122
GL_CONVOLUTION_WIDTH = 32792 	# GL/glext.h:123
GL_CONVOLUTION_HEIGHT = 32793 	# GL/glext.h:124
GL_MAX_CONVOLUTION_WIDTH = 32794 	# GL/glext.h:125
GL_MAX_CONVOLUTION_HEIGHT = 32795 	# GL/glext.h:126
GL_POST_CONVOLUTION_RED_SCALE = 32796 	# GL/glext.h:127
GL_POST_CONVOLUTION_GREEN_SCALE = 32797 	# GL/glext.h:128
GL_POST_CONVOLUTION_BLUE_SCALE = 32798 	# GL/glext.h:129
GL_POST_CONVOLUTION_ALPHA_SCALE = 32799 	# GL/glext.h:130
GL_POST_CONVOLUTION_RED_BIAS = 32800 	# GL/glext.h:131
GL_POST_CONVOLUTION_GREEN_BIAS = 32801 	# GL/glext.h:132
GL_POST_CONVOLUTION_BLUE_BIAS = 32802 	# GL/glext.h:133
GL_POST_CONVOLUTION_ALPHA_BIAS = 32803 	# GL/glext.h:134
GL_HISTOGRAM = 32804 	# GL/glext.h:135
GL_PROXY_HISTOGRAM = 32805 	# GL/glext.h:136
GL_HISTOGRAM_WIDTH = 32806 	# GL/glext.h:137
GL_HISTOGRAM_FORMAT = 32807 	# GL/glext.h:138
GL_HISTOGRAM_RED_SIZE = 32808 	# GL/glext.h:139
GL_HISTOGRAM_GREEN_SIZE = 32809 	# GL/glext.h:140
GL_HISTOGRAM_BLUE_SIZE = 32810 	# GL/glext.h:141
GL_HISTOGRAM_ALPHA_SIZE = 32811 	# GL/glext.h:142
GL_HISTOGRAM_LUMINANCE_SIZE = 32812 	# GL/glext.h:143
GL_HISTOGRAM_SINK = 32813 	# GL/glext.h:144
GL_MINMAX = 32814 	# GL/glext.h:145
GL_MINMAX_FORMAT = 32815 	# GL/glext.h:146
GL_MINMAX_SINK = 32816 	# GL/glext.h:147
GL_TABLE_TOO_LARGE = 32817 	# GL/glext.h:148
GL_COLOR_MATRIX = 32945 	# GL/glext.h:149
GL_COLOR_MATRIX_STACK_DEPTH = 32946 	# GL/glext.h:150
GL_MAX_COLOR_MATRIX_STACK_DEPTH = 32947 	# GL/glext.h:151
GL_POST_COLOR_MATRIX_RED_SCALE = 32948 	# GL/glext.h:152
GL_POST_COLOR_MATRIX_GREEN_SCALE = 32949 	# GL/glext.h:153
GL_POST_COLOR_MATRIX_BLUE_SCALE = 32950 	# GL/glext.h:154
GL_POST_COLOR_MATRIX_ALPHA_SCALE = 32951 	# GL/glext.h:155
GL_POST_COLOR_MATRIX_RED_BIAS = 32952 	# GL/glext.h:156
GL_POST_COLOR_MATRIX_GREEN_BIAS = 32953 	# GL/glext.h:157
GL_POST_COLOR_MATRIX_BLUE_BIAS = 32954 	# GL/glext.h:158
GL_POST_COLOR_MATRIX_ALPHA_BIAS = 32955 	# GL/glext.h:159
GL_COLOR_TABLE = 32976 	# GL/glext.h:160
GL_POST_CONVOLUTION_COLOR_TABLE = 32977 	# GL/glext.h:161
GL_POST_COLOR_MATRIX_COLOR_TABLE = 32978 	# GL/glext.h:162
GL_PROXY_COLOR_TABLE = 32979 	# GL/glext.h:163
GL_PROXY_POST_CONVOLUTION_COLOR_TABLE = 32980 	# GL/glext.h:164
GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE = 32981 	# GL/glext.h:165
GL_COLOR_TABLE_SCALE = 32982 	# GL/glext.h:166
GL_COLOR_TABLE_BIAS = 32983 	# GL/glext.h:167
GL_COLOR_TABLE_FORMAT = 32984 	# GL/glext.h:168
GL_COLOR_TABLE_WIDTH = 32985 	# GL/glext.h:169
GL_COLOR_TABLE_RED_SIZE = 32986 	# GL/glext.h:170
GL_COLOR_TABLE_GREEN_SIZE = 32987 	# GL/glext.h:171
GL_COLOR_TABLE_BLUE_SIZE = 32988 	# GL/glext.h:172
GL_COLOR_TABLE_ALPHA_SIZE = 32989 	# GL/glext.h:173
GL_COLOR_TABLE_LUMINANCE_SIZE = 32990 	# GL/glext.h:174
GL_COLOR_TABLE_INTENSITY_SIZE = 32991 	# GL/glext.h:175
GL_CONSTANT_BORDER = 33105 	# GL/glext.h:176
GL_REPLICATE_BORDER = 33107 	# GL/glext.h:177
GL_CONVOLUTION_BORDER_COLOR = 33108 	# GL/glext.h:178
# VERSION_1_3 (GL/glext.h:181)
GL_TEXTURE0 = 33984 	# GL/glext.h:182
GL_TEXTURE1 = 33985 	# GL/glext.h:183
GL_TEXTURE2 = 33986 	# GL/glext.h:184
GL_TEXTURE3 = 33987 	# GL/glext.h:185
GL_TEXTURE4 = 33988 	# GL/glext.h:186
GL_TEXTURE5 = 33989 	# GL/glext.h:187
GL_TEXTURE6 = 33990 	# GL/glext.h:188
GL_TEXTURE7 = 33991 	# GL/glext.h:189
GL_TEXTURE8 = 33992 	# GL/glext.h:190
GL_TEXTURE9 = 33993 	# GL/glext.h:191
GL_TEXTURE10 = 33994 	# GL/glext.h:192
GL_TEXTURE11 = 33995 	# GL/glext.h:193
GL_TEXTURE12 = 33996 	# GL/glext.h:194
GL_TEXTURE13 = 33997 	# GL/glext.h:195
GL_TEXTURE14 = 33998 	# GL/glext.h:196
GL_TEXTURE15 = 33999 	# GL/glext.h:197
GL_TEXTURE16 = 34000 	# GL/glext.h:198
GL_TEXTURE17 = 34001 	# GL/glext.h:199
GL_TEXTURE18 = 34002 	# GL/glext.h:200
GL_TEXTURE19 = 34003 	# GL/glext.h:201
GL_TEXTURE20 = 34004 	# GL/glext.h:202
GL_TEXTURE21 = 34005 	# GL/glext.h:203
GL_TEXTURE22 = 34006 	# GL/glext.h:204
GL_TEXTURE23 = 34007 	# GL/glext.h:205
GL_TEXTURE24 = 34008 	# GL/glext.h:206
GL_TEXTURE25 = 34009 	# GL/glext.h:207
GL_TEXTURE26 = 34010 	# GL/glext.h:208
GL_TEXTURE27 = 34011 	# GL/glext.h:209
GL_TEXTURE28 = 34012 	# GL/glext.h:210
GL_TEXTURE29 = 34013 	# GL/glext.h:211
GL_TEXTURE30 = 34014 	# GL/glext.h:212
GL_TEXTURE31 = 34015 	# GL/glext.h:213
GL_ACTIVE_TEXTURE = 34016 	# GL/glext.h:214
GL_CLIENT_ACTIVE_TEXTURE = 34017 	# GL/glext.h:215
GL_MAX_TEXTURE_UNITS = 34018 	# GL/glext.h:216
GL_TRANSPOSE_MODELVIEW_MATRIX = 34019 	# GL/glext.h:217
GL_TRANSPOSE_PROJECTION_MATRIX = 34020 	# GL/glext.h:218
GL_TRANSPOSE_TEXTURE_MATRIX = 34021 	# GL/glext.h:219
GL_TRANSPOSE_COLOR_MATRIX = 34022 	# GL/glext.h:220
GL_MULTISAMPLE = 32925 	# GL/glext.h:221
GL_SAMPLE_ALPHA_TO_COVERAGE = 32926 	# GL/glext.h:222
GL_SAMPLE_ALPHA_TO_ONE = 32927 	# GL/glext.h:223
GL_SAMPLE_COVERAGE = 32928 	# GL/glext.h:224
GL_SAMPLE_BUFFERS = 32936 	# GL/glext.h:225
GL_SAMPLES = 32937 	# GL/glext.h:226
GL_SAMPLE_COVERAGE_VALUE = 32938 	# GL/glext.h:227
GL_SAMPLE_COVERAGE_INVERT = 32939 	# GL/glext.h:228
GL_MULTISAMPLE_BIT = 536870912 	# GL/glext.h:229
GL_NORMAL_MAP = 34065 	# GL/glext.h:230
GL_REFLECTION_MAP = 34066 	# GL/glext.h:231
GL_TEXTURE_CUBE_MAP = 34067 	# GL/glext.h:232
GL_TEXTURE_BINDING_CUBE_MAP = 34068 	# GL/glext.h:233
GL_TEXTURE_CUBE_MAP_POSITIVE_X = 34069 	# GL/glext.h:234
GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 34070 	# GL/glext.h:235
GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 34071 	# GL/glext.h:236
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072 	# GL/glext.h:237
GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 34073 	# GL/glext.h:238
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074 	# GL/glext.h:239
GL_PROXY_TEXTURE_CUBE_MAP = 34075 	# GL/glext.h:240
GL_MAX_CUBE_MAP_TEXTURE_SIZE = 34076 	# GL/glext.h:241
GL_COMPRESSED_ALPHA = 34025 	# GL/glext.h:242
GL_COMPRESSED_LUMINANCE = 34026 	# GL/glext.h:243
GL_COMPRESSED_LUMINANCE_ALPHA = 34027 	# GL/glext.h:244
GL_COMPRESSED_INTENSITY = 34028 	# GL/glext.h:245
GL_COMPRESSED_RGB = 34029 	# GL/glext.h:246
GL_COMPRESSED_RGBA = 34030 	# GL/glext.h:247
GL_TEXTURE_COMPRESSION_HINT = 34031 	# GL/glext.h:248
GL_TEXTURE_COMPRESSED_IMAGE_SIZE = 34464 	# GL/glext.h:249
GL_TEXTURE_COMPRESSED = 34465 	# GL/glext.h:250
GL_NUM_COMPRESSED_TEXTURE_FORMATS = 34466 	# GL/glext.h:251
GL_COMPRESSED_TEXTURE_FORMATS = 34467 	# GL/glext.h:252
GL_CLAMP_TO_BORDER = 33069 	# GL/glext.h:253
GL_COMBINE = 34160 	# GL/glext.h:254
GL_COMBINE_RGB = 34161 	# GL/glext.h:255
GL_COMBINE_ALPHA = 34162 	# GL/glext.h:256
GL_SOURCE0_RGB = 34176 	# GL/glext.h:257
GL_SOURCE1_RGB = 34177 	# GL/glext.h:258
GL_SOURCE2_RGB = 34178 	# GL/glext.h:259
GL_SOURCE0_ALPHA = 34184 	# GL/glext.h:260
GL_SOURCE1_ALPHA = 34185 	# GL/glext.h:261
GL_SOURCE2_ALPHA = 34186 	# GL/glext.h:262
GL_OPERAND0_RGB = 34192 	# GL/glext.h:263
GL_OPERAND1_RGB = 34193 	# GL/glext.h:264
GL_OPERAND2_RGB = 34194 	# GL/glext.h:265
GL_OPERAND0_ALPHA = 34200 	# GL/glext.h:266
GL_OPERAND1_ALPHA = 34201 	# GL/glext.h:267
GL_OPERAND2_ALPHA = 34202 	# GL/glext.h:268
GL_RGB_SCALE = 34163 	# GL/glext.h:269
GL_ADD_SIGNED = 34164 	# GL/glext.h:270
GL_INTERPOLATE = 34165 	# GL/glext.h:271
GL_SUBTRACT = 34023 	# GL/glext.h:272
GL_CONSTANT = 34166 	# GL/glext.h:273
GL_PRIMARY_COLOR = 34167 	# GL/glext.h:274
GL_PREVIOUS = 34168 	# GL/glext.h:275
GL_DOT3_RGB = 34478 	# GL/glext.h:276
GL_DOT3_RGBA = 34479 	# GL/glext.h:277
# VERSION_1_4 (GL/glext.h:280)
GL_BLEND_DST_RGB = 32968 	# GL/glext.h:281
GL_BLEND_SRC_RGB = 32969 	# GL/glext.h:282
GL_BLEND_DST_ALPHA = 32970 	# GL/glext.h:283
GL_BLEND_SRC_ALPHA = 32971 	# GL/glext.h:284
GL_POINT_SIZE_MIN = 33062 	# GL/glext.h:285
GL_POINT_SIZE_MAX = 33063 	# GL/glext.h:286
GL_POINT_FADE_THRESHOLD_SIZE = 33064 	# GL/glext.h:287
GL_POINT_DISTANCE_ATTENUATION = 33065 	# GL/glext.h:288
GL_GENERATE_MIPMAP = 33169 	# GL/glext.h:289
GL_GENERATE_MIPMAP_HINT = 33170 	# GL/glext.h:290
GL_DEPTH_COMPONENT16 = 33189 	# GL/glext.h:291
GL_DEPTH_COMPONENT24 = 33190 	# GL/glext.h:292
GL_DEPTH_COMPONENT32 = 33191 	# GL/glext.h:293
GL_MIRRORED_REPEAT = 33648 	# GL/glext.h:294
GL_FOG_COORDINATE_SOURCE = 33872 	# GL/glext.h:295
GL_FOG_COORDINATE = 33873 	# GL/glext.h:296
GL_FRAGMENT_DEPTH = 33874 	# GL/glext.h:297
GL_CURRENT_FOG_COORDINATE = 33875 	# GL/glext.h:298
GL_FOG_COORDINATE_ARRAY_TYPE = 33876 	# GL/glext.h:299
GL_FOG_COORDINATE_ARRAY_STRIDE = 33877 	# GL/glext.h:300
GL_FOG_COORDINATE_ARRAY_POINTER = 33878 	# GL/glext.h:301
GL_FOG_COORDINATE_ARRAY = 33879 	# GL/glext.h:302
GL_COLOR_SUM = 33880 	# GL/glext.h:303
GL_CURRENT_SECONDARY_COLOR = 33881 	# GL/glext.h:304
GL_SECONDARY_COLOR_ARRAY_SIZE = 33882 	# GL/glext.h:305
GL_SECONDARY_COLOR_ARRAY_TYPE = 33883 	# GL/glext.h:306
GL_SECONDARY_COLOR_ARRAY_STRIDE = 33884 	# GL/glext.h:307
GL_SECONDARY_COLOR_ARRAY_POINTER = 33885 	# GL/glext.h:308
GL_SECONDARY_COLOR_ARRAY = 33886 	# GL/glext.h:309
GL_MAX_TEXTURE_LOD_BIAS = 34045 	# GL/glext.h:310
GL_TEXTURE_FILTER_CONTROL = 34048 	# GL/glext.h:311
GL_TEXTURE_LOD_BIAS = 34049 	# GL/glext.h:312
GL_INCR_WRAP = 34055 	# GL/glext.h:313
GL_DECR_WRAP = 34056 	# GL/glext.h:314
GL_TEXTURE_DEPTH_SIZE = 34890 	# GL/glext.h:315
GL_DEPTH_TEXTURE_MODE = 34891 	# GL/glext.h:316
GL_TEXTURE_COMPARE_MODE = 34892 	# GL/glext.h:317
GL_TEXTURE_COMPARE_FUNC = 34893 	# GL/glext.h:318
GL_COMPARE_R_TO_TEXTURE = 34894 	# GL/glext.h:319
# VERSION_1_5 (GL/glext.h:322)
GL_BUFFER_SIZE = 34660 	# GL/glext.h:323
GL_BUFFER_USAGE = 34661 	# GL/glext.h:324
GL_QUERY_COUNTER_BITS = 34916 	# GL/glext.h:325
GL_CURRENT_QUERY = 34917 	# GL/glext.h:326
GL_QUERY_RESULT = 34918 	# GL/glext.h:327
GL_QUERY_RESULT_AVAILABLE = 34919 	# GL/glext.h:328
GL_ARRAY_BUFFER = 34962 	# GL/glext.h:329
GL_ELEMENT_ARRAY_BUFFER = 34963 	# GL/glext.h:330
GL_ARRAY_BUFFER_BINDING = 34964 	# GL/glext.h:331
GL_ELEMENT_ARRAY_BUFFER_BINDING = 34965 	# GL/glext.h:332
GL_VERTEX_ARRAY_BUFFER_BINDING = 34966 	# GL/glext.h:333
GL_NORMAL_ARRAY_BUFFER_BINDING = 34967 	# GL/glext.h:334
GL_COLOR_ARRAY_BUFFER_BINDING = 34968 	# GL/glext.h:335
GL_INDEX_ARRAY_BUFFER_BINDING = 34969 	# GL/glext.h:336
GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING = 34970 	# GL/glext.h:337
GL_EDGE_FLAG_ARRAY_BUFFER_BINDING = 34971 	# GL/glext.h:338
GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING = 34972 	# GL/glext.h:339
GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING = 34973 	# GL/glext.h:340
GL_WEIGHT_ARRAY_BUFFER_BINDING = 34974 	# GL/glext.h:341
GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975 	# GL/glext.h:342
GL_READ_ONLY = 35000 	# GL/glext.h:343
GL_WRITE_ONLY = 35001 	# GL/glext.h:344
GL_READ_WRITE = 35002 	# GL/glext.h:345
GL_BUFFER_ACCESS = 35003 	# GL/glext.h:346
GL_BUFFER_MAPPED = 35004 	# GL/glext.h:347
GL_BUFFER_MAP_POINTER = 35005 	# GL/glext.h:348
GL_STREAM_DRAW = 35040 	# GL/glext.h:349
GL_STREAM_READ = 35041 	# GL/glext.h:350
GL_STREAM_COPY = 35042 	# GL/glext.h:351
GL_STATIC_DRAW = 35044 	# GL/glext.h:352
GL_STATIC_READ = 35045 	# GL/glext.h:353
GL_STATIC_COPY = 35046 	# GL/glext.h:354
GL_DYNAMIC_DRAW = 35048 	# GL/glext.h:355
GL_DYNAMIC_READ = 35049 	# GL/glext.h:356
GL_DYNAMIC_COPY = 35050 	# GL/glext.h:357
GL_SAMPLES_PASSED = 35092 	# GL/glext.h:358
GL_FOG_COORD_SRC = 33872 	# GL/glext.h:359
GL_FOG_COORD = 33873 	# GL/glext.h:360
GL_CURRENT_FOG_COORD = 33875 	# GL/glext.h:361
GL_FOG_COORD_ARRAY_TYPE = 33876 	# GL/glext.h:362
GL_FOG_COORD_ARRAY_STRIDE = 33877 	# GL/glext.h:363
GL_FOG_COORD_ARRAY_POINTER = 33878 	# GL/glext.h:364
GL_FOG_COORD_ARRAY = 33879 	# GL/glext.h:365
GL_FOG_COORD_ARRAY_BUFFER_BINDING = 34973 	# GL/glext.h:366
GL_SRC0_RGB = 34176 	# GL/glext.h:367
GL_SRC1_RGB = 34177 	# GL/glext.h:368
GL_SRC2_RGB = 34178 	# GL/glext.h:369
GL_SRC0_ALPHA = 34184 	# GL/glext.h:370
GL_SRC1_ALPHA = 34185 	# GL/glext.h:371
GL_SRC2_ALPHA = 34186 	# GL/glext.h:372
# VERSION_2_0 (GL/glext.h:375)
GL_BLEND_EQUATION_RGB = 32777 	# GL/glext.h:376
GL_VERTEX_ATTRIB_ARRAY_ENABLED = 34338 	# GL/glext.h:377
GL_VERTEX_ATTRIB_ARRAY_SIZE = 34339 	# GL/glext.h:378
GL_VERTEX_ATTRIB_ARRAY_STRIDE = 34340 	# GL/glext.h:379
GL_VERTEX_ATTRIB_ARRAY_TYPE = 34341 	# GL/glext.h:380
GL_CURRENT_VERTEX_ATTRIB = 34342 	# GL/glext.h:381
GL_VERTEX_PROGRAM_POINT_SIZE = 34370 	# GL/glext.h:382
GL_VERTEX_PROGRAM_TWO_SIDE = 34371 	# GL/glext.h:383
GL_VERTEX_ATTRIB_ARRAY_POINTER = 34373 	# GL/glext.h:384
GL_STENCIL_BACK_FUNC = 34816 	# GL/glext.h:385
GL_STENCIL_BACK_FAIL = 34817 	# GL/glext.h:386
GL_STENCIL_BACK_PASS_DEPTH_FAIL = 34818 	# GL/glext.h:387
GL_STENCIL_BACK_PASS_DEPTH_PASS = 34819 	# GL/glext.h:388
GL_MAX_DRAW_BUFFERS = 34852 	# GL/glext.h:389
GL_DRAW_BUFFER0 = 34853 	# GL/glext.h:390
GL_DRAW_BUFFER1 = 34854 	# GL/glext.h:391
GL_DRAW_BUFFER2 = 34855 	# GL/glext.h:392
GL_DRAW_BUFFER3 = 34856 	# GL/glext.h:393
GL_DRAW_BUFFER4 = 34857 	# GL/glext.h:394
GL_DRAW_BUFFER5 = 34858 	# GL/glext.h:395
GL_DRAW_BUFFER6 = 34859 	# GL/glext.h:396
GL_DRAW_BUFFER7 = 34860 	# GL/glext.h:397
GL_DRAW_BUFFER8 = 34861 	# GL/glext.h:398
GL_DRAW_BUFFER9 = 34862 	# GL/glext.h:399
GL_DRAW_BUFFER10 = 34863 	# GL/glext.h:400
GL_DRAW_BUFFER11 = 34864 	# GL/glext.h:401
GL_DRAW_BUFFER12 = 34865 	# GL/glext.h:402
GL_DRAW_BUFFER13 = 34866 	# GL/glext.h:403
GL_DRAW_BUFFER14 = 34867 	# GL/glext.h:404
GL_DRAW_BUFFER15 = 34868 	# GL/glext.h:405
GL_BLEND_EQUATION_ALPHA = 34877 	# GL/glext.h:406
GL_POINT_SPRITE = 34913 	# GL/glext.h:407
GL_COORD_REPLACE = 34914 	# GL/glext.h:408
GL_MAX_VERTEX_ATTRIBS = 34921 	# GL/glext.h:409
GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922 	# GL/glext.h:410
GL_MAX_TEXTURE_COORDS = 34929 	# GL/glext.h:411
GL_MAX_TEXTURE_IMAGE_UNITS = 34930 	# GL/glext.h:412
GL_FRAGMENT_SHADER = 35632 	# GL/glext.h:413
GL_VERTEX_SHADER = 35633 	# GL/glext.h:414
GL_MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657 	# GL/glext.h:415
GL_MAX_VERTEX_UNIFORM_COMPONENTS = 35658 	# GL/glext.h:416
GL_MAX_VARYING_FLOATS = 35659 	# GL/glext.h:417
GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660 	# GL/glext.h:418
GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661 	# GL/glext.h:419
GL_SHADER_TYPE = 35663 	# GL/glext.h:420
GL_FLOAT_VEC2 = 35664 	# GL/glext.h:421
GL_FLOAT_VEC3 = 35665 	# GL/glext.h:422
GL_FLOAT_VEC4 = 35666 	# GL/glext.h:423
GL_INT_VEC2 = 35667 	# GL/glext.h:424
GL_INT_VEC3 = 35668 	# GL/glext.h:425
GL_INT_VEC4 = 35669 	# GL/glext.h:426
GL_BOOL = 35670 	# GL/glext.h:427
GL_BOOL_VEC2 = 35671 	# GL/glext.h:428
GL_BOOL_VEC3 = 35672 	# GL/glext.h:429
GL_BOOL_VEC4 = 35673 	# GL/glext.h:430
GL_FLOAT_MAT2 = 35674 	# GL/glext.h:431
GL_FLOAT_MAT3 = 35675 	# GL/glext.h:432
GL_FLOAT_MAT4 = 35676 	# GL/glext.h:433
GL_SAMPLER_1D = 35677 	# GL/glext.h:434
GL_SAMPLER_2D = 35678 	# GL/glext.h:435
GL_SAMPLER_3D = 35679 	# GL/glext.h:436
GL_SAMPLER_CUBE = 35680 	# GL/glext.h:437
GL_SAMPLER_1D_SHADOW = 35681 	# GL/glext.h:438
GL_SAMPLER_2D_SHADOW = 35682 	# GL/glext.h:439
GL_DELETE_STATUS = 35712 	# GL/glext.h:440
GL_COMPILE_STATUS = 35713 	# GL/glext.h:441
GL_LINK_STATUS = 35714 	# GL/glext.h:442
GL_VALIDATE_STATUS = 35715 	# GL/glext.h:443
GL_INFO_LOG_LENGTH = 35716 	# GL/glext.h:444
GL_ATTACHED_SHADERS = 35717 	# GL/glext.h:445
GL_ACTIVE_UNIFORMS = 35718 	# GL/glext.h:446
GL_ACTIVE_UNIFORM_MAX_LENGTH = 35719 	# GL/glext.h:447
GL_SHADER_SOURCE_LENGTH = 35720 	# GL/glext.h:448
GL_ACTIVE_ATTRIBUTES = 35721 	# GL/glext.h:449
GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = 35722 	# GL/glext.h:450
GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723 	# GL/glext.h:451
GL_SHADING_LANGUAGE_VERSION = 35724 	# GL/glext.h:452
GL_CURRENT_PROGRAM = 35725 	# GL/glext.h:453
GL_POINT_SPRITE_COORD_ORIGIN = 36000 	# GL/glext.h:454
GL_LOWER_LEFT = 36001 	# GL/glext.h:455
GL_UPPER_LEFT = 36002 	# GL/glext.h:456
GL_STENCIL_BACK_REF = 36003 	# GL/glext.h:457
GL_STENCIL_BACK_VALUE_MASK = 36004 	# GL/glext.h:458
GL_STENCIL_BACK_WRITEMASK = 36005 	# GL/glext.h:459
# ARB_multitexture (GL/glext.h:462)
GL_TEXTURE0_ARB = 33984 	# GL/glext.h:463
GL_TEXTURE1_ARB = 33985 	# GL/glext.h:464
GL_TEXTURE2_ARB = 33986 	# GL/glext.h:465
GL_TEXTURE3_ARB = 33987 	# GL/glext.h:466
GL_TEXTURE4_ARB = 33988 	# GL/glext.h:467
GL_TEXTURE5_ARB = 33989 	# GL/glext.h:468
GL_TEXTURE6_ARB = 33990 	# GL/glext.h:469
GL_TEXTURE7_ARB = 33991 	# GL/glext.h:470
GL_TEXTURE8_ARB = 33992 	# GL/glext.h:471
GL_TEXTURE9_ARB = 33993 	# GL/glext.h:472
GL_TEXTURE10_ARB = 33994 	# GL/glext.h:473
GL_TEXTURE11_ARB = 33995 	# GL/glext.h:474
GL_TEXTURE12_ARB = 33996 	# GL/glext.h:475
GL_TEXTURE13_ARB = 33997 	# GL/glext.h:476
GL_TEXTURE14_ARB = 33998 	# GL/glext.h:477
GL_TEXTURE15_ARB = 33999 	# GL/glext.h:478
GL_TEXTURE16_ARB = 34000 	# GL/glext.h:479
GL_TEXTURE17_ARB = 34001 	# GL/glext.h:480
GL_TEXTURE18_ARB = 34002 	# GL/glext.h:481
GL_TEXTURE19_ARB = 34003 	# GL/glext.h:482
GL_TEXTURE20_ARB = 34004 	# GL/glext.h:483
GL_TEXTURE21_ARB = 34005 	# GL/glext.h:484
GL_TEXTURE22_ARB = 34006 	# GL/glext.h:485
GL_TEXTURE23_ARB = 34007 	# GL/glext.h:486
GL_TEXTURE24_ARB = 34008 	# GL/glext.h:487
GL_TEXTURE25_ARB = 34009 	# GL/glext.h:488
GL_TEXTURE26_ARB = 34010 	# GL/glext.h:489
GL_TEXTURE27_ARB = 34011 	# GL/glext.h:490
GL_TEXTURE28_ARB = 34012 	# GL/glext.h:491
GL_TEXTURE29_ARB = 34013 	# GL/glext.h:492
GL_TEXTURE30_ARB = 34014 	# GL/glext.h:493
GL_TEXTURE31_ARB = 34015 	# GL/glext.h:494
GL_ACTIVE_TEXTURE_ARB = 34016 	# GL/glext.h:495
GL_CLIENT_ACTIVE_TEXTURE_ARB = 34017 	# GL/glext.h:496
GL_MAX_TEXTURE_UNITS_ARB = 34018 	# GL/glext.h:497
# ARB_transpose_matrix (GL/glext.h:500)
GL_TRANSPOSE_MODELVIEW_MATRIX_ARB = 34019 	# GL/glext.h:501
GL_TRANSPOSE_PROJECTION_MATRIX_ARB = 34020 	# GL/glext.h:502
GL_TRANSPOSE_TEXTURE_MATRIX_ARB = 34021 	# GL/glext.h:503
GL_TRANSPOSE_COLOR_MATRIX_ARB = 34022 	# GL/glext.h:504
# ARB_multisample (GL/glext.h:507)
GL_MULTISAMPLE_ARB = 32925 	# GL/glext.h:508
GL_SAMPLE_ALPHA_TO_COVERAGE_ARB = 32926 	# GL/glext.h:509
GL_SAMPLE_ALPHA_TO_ONE_ARB = 32927 	# GL/glext.h:510
GL_SAMPLE_COVERAGE_ARB = 32928 	# GL/glext.h:511
GL_SAMPLE_BUFFERS_ARB = 32936 	# GL/glext.h:512
GL_SAMPLES_ARB = 32937 	# GL/glext.h:513
GL_SAMPLE_COVERAGE_VALUE_ARB = 32938 	# GL/glext.h:514
GL_SAMPLE_COVERAGE_INVERT_ARB = 32939 	# GL/glext.h:515
GL_MULTISAMPLE_BIT_ARB = 536870912 	# GL/glext.h:516
# ARB_texture_env_add (GL/glext.h:519)
# ARB_texture_cube_map (GL/glext.h:522)
GL_NORMAL_MAP_ARB = 34065 	# GL/glext.h:523
GL_REFLECTION_MAP_ARB = 34066 	# GL/glext.h:524
GL_TEXTURE_CUBE_MAP_ARB = 34067 	# GL/glext.h:525
GL_TEXTURE_BINDING_CUBE_MAP_ARB = 34068 	# GL/glext.h:526
GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB = 34069 	# GL/glext.h:527
GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB = 34070 	# GL/glext.h:528
GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB = 34071 	# GL/glext.h:529
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB = 34072 	# GL/glext.h:530
GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB = 34073 	# GL/glext.h:531
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB = 34074 	# GL/glext.h:532
GL_PROXY_TEXTURE_CUBE_MAP_ARB = 34075 	# GL/glext.h:533
GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB = 34076 	# GL/glext.h:534
# ARB_texture_compression (GL/glext.h:537)
GL_COMPRESSED_ALPHA_ARB = 34025 	# GL/glext.h:538
GL_COMPRESSED_LUMINANCE_ARB = 34026 	# GL/glext.h:539
GL_COMPRESSED_LUMINANCE_ALPHA_ARB = 34027 	# GL/glext.h:540
GL_COMPRESSED_INTENSITY_ARB = 34028 	# GL/glext.h:541
GL_COMPRESSED_RGB_ARB = 34029 	# GL/glext.h:542
GL_COMPRESSED_RGBA_ARB = 34030 	# GL/glext.h:543
GL_TEXTURE_COMPRESSION_HINT_ARB = 34031 	# GL/glext.h:544
GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB = 34464 	# GL/glext.h:545
GL_TEXTURE_COMPRESSED_ARB = 34465 	# GL/glext.h:546
GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB = 34466 	# GL/glext.h:547
GL_COMPRESSED_TEXTURE_FORMATS_ARB = 34467 	# GL/glext.h:548
# ARB_texture_border_clamp (GL/glext.h:551)
GL_CLAMP_TO_BORDER_ARB = 33069 	# GL/glext.h:552
# ARB_point_parameters (GL/glext.h:555)
GL_POINT_SIZE_MIN_ARB = 33062 	# GL/glext.h:556
GL_POINT_SIZE_MAX_ARB = 33063 	# GL/glext.h:557
GL_POINT_FADE_THRESHOLD_SIZE_ARB = 33064 	# GL/glext.h:558
GL_POINT_DISTANCE_ATTENUATION_ARB = 33065 	# GL/glext.h:559
# ARB_vertex_blend (GL/glext.h:562)
GL_MAX_VERTEX_UNITS_ARB = 34468 	# GL/glext.h:563
GL_ACTIVE_VERTEX_UNITS_ARB = 34469 	# GL/glext.h:564
GL_WEIGHT_SUM_UNITY_ARB = 34470 	# GL/glext.h:565
GL_VERTEX_BLEND_ARB = 34471 	# GL/glext.h:566
GL_CURRENT_WEIGHT_ARB = 34472 	# GL/glext.h:567
GL_WEIGHT_ARRAY_TYPE_ARB = 34473 	# GL/glext.h:568
GL_WEIGHT_ARRAY_STRIDE_ARB = 34474 	# GL/glext.h:569
GL_WEIGHT_ARRAY_SIZE_ARB = 34475 	# GL/glext.h:570
GL_WEIGHT_ARRAY_POINTER_ARB = 34476 	# GL/glext.h:571
GL_WEIGHT_ARRAY_ARB = 34477 	# GL/glext.h:572
GL_MODELVIEW0_ARB = 5888 	# GL/glext.h:573
GL_MODELVIEW1_ARB = 34058 	# GL/glext.h:574
GL_MODELVIEW2_ARB = 34594 	# GL/glext.h:575
GL_MODELVIEW3_ARB = 34595 	# GL/glext.h:576
GL_MODELVIEW4_ARB = 34596 	# GL/glext.h:577
GL_MODELVIEW5_ARB = 34597 	# GL/glext.h:578
GL_MODELVIEW6_ARB = 34598 	# GL/glext.h:579
GL_MODELVIEW7_ARB = 34599 	# GL/glext.h:580
GL_MODELVIEW8_ARB = 34600 	# GL/glext.h:581
GL_MODELVIEW9_ARB = 34601 	# GL/glext.h:582
GL_MODELVIEW10_ARB = 34602 	# GL/glext.h:583
GL_MODELVIEW11_ARB = 34603 	# GL/glext.h:584
GL_MODELVIEW12_ARB = 34604 	# GL/glext.h:585
GL_MODELVIEW13_ARB = 34605 	# GL/glext.h:586
GL_MODELVIEW14_ARB = 34606 	# GL/glext.h:587
GL_MODELVIEW15_ARB = 34607 	# GL/glext.h:588
GL_MODELVIEW16_ARB = 34608 	# GL/glext.h:589
GL_MODELVIEW17_ARB = 34609 	# GL/glext.h:590
GL_MODELVIEW18_ARB = 34610 	# GL/glext.h:591
GL_MODELVIEW19_ARB = 34611 	# GL/glext.h:592
GL_MODELVIEW20_ARB = 34612 	# GL/glext.h:593
GL_MODELVIEW21_ARB = 34613 	# GL/glext.h:594
GL_MODELVIEW22_ARB = 34614 	# GL/glext.h:595
GL_MODELVIEW23_ARB = 34615 	# GL/glext.h:596
GL_MODELVIEW24_ARB = 34616 	# GL/glext.h:597
GL_MODELVIEW25_ARB = 34617 	# GL/glext.h:598
GL_MODELVIEW26_ARB = 34618 	# GL/glext.h:599
GL_MODELVIEW27_ARB = 34619 	# GL/glext.h:600
GL_MODELVIEW28_ARB = 34620 	# GL/glext.h:601
GL_MODELVIEW29_ARB = 34621 	# GL/glext.h:602
GL_MODELVIEW30_ARB = 34622 	# GL/glext.h:603
GL_MODELVIEW31_ARB = 34623 	# GL/glext.h:604
# ARB_matrix_palette (GL/glext.h:607)
GL_MATRIX_PALETTE_ARB = 34880 	# GL/glext.h:608
GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB = 34881 	# GL/glext.h:609
GL_MAX_PALETTE_MATRICES_ARB = 34882 	# GL/glext.h:610
GL_CURRENT_PALETTE_MATRIX_ARB = 34883 	# GL/glext.h:611
GL_MATRIX_INDEX_ARRAY_ARB = 34884 	# GL/glext.h:612
GL_CURRENT_MATRIX_INDEX_ARB = 34885 	# GL/glext.h:613
GL_MATRIX_INDEX_ARRAY_SIZE_ARB = 34886 	# GL/glext.h:614
GL_MATRIX_INDEX_ARRAY_TYPE_ARB = 34887 	# GL/glext.h:615
GL_MATRIX_INDEX_ARRAY_STRIDE_ARB = 34888 	# GL/glext.h:616
GL_MATRIX_INDEX_ARRAY_POINTER_ARB = 34889 	# GL/glext.h:617
# ARB_texture_env_combine (GL/glext.h:620)
GL_COMBINE_ARB = 34160 	# GL/glext.h:621
GL_COMBINE_RGB_ARB = 34161 	# GL/glext.h:622
GL_COMBINE_ALPHA_ARB = 34162 	# GL/glext.h:623
GL_SOURCE0_RGB_ARB = 34176 	# GL/glext.h:624
GL_SOURCE1_RGB_ARB = 34177 	# GL/glext.h:625
GL_SOURCE2_RGB_ARB = 34178 	# GL/glext.h:626
GL_SOURCE0_ALPHA_ARB = 34184 	# GL/glext.h:627
GL_SOURCE1_ALPHA_ARB = 34185 	# GL/glext.h:628
GL_SOURCE2_ALPHA_ARB = 34186 	# GL/glext.h:629
GL_OPERAND0_RGB_ARB = 34192 	# GL/glext.h:630
GL_OPERAND1_RGB_ARB = 34193 	# GL/glext.h:631
GL_OPERAND2_RGB_ARB = 34194 	# GL/glext.h:632
GL_OPERAND0_ALPHA_ARB = 34200 	# GL/glext.h:633
GL_OPERAND1_ALPHA_ARB = 34201 	# GL/glext.h:634
GL_OPERAND2_ALPHA_ARB = 34202 	# GL/glext.h:635
GL_RGB_SCALE_ARB = 34163 	# GL/glext.h:636
GL_ADD_SIGNED_ARB = 34164 	# GL/glext.h:637
GL_INTERPOLATE_ARB = 34165 	# GL/glext.h:638
GL_SUBTRACT_ARB = 34023 	# GL/glext.h:639
GL_CONSTANT_ARB = 34166 	# GL/glext.h:640
GL_PRIMARY_COLOR_ARB = 34167 	# GL/glext.h:641
GL_PREVIOUS_ARB = 34168 	# GL/glext.h:642
# ARB_texture_env_crossbar (GL/glext.h:645)
# ARB_texture_env_dot3 (GL/glext.h:648)
GL_DOT3_RGB_ARB = 34478 	# GL/glext.h:649
GL_DOT3_RGBA_ARB = 34479 	# GL/glext.h:650
# ARB_texture_mirrored_repeat (GL/glext.h:653)
GL_MIRRORED_REPEAT_ARB = 33648 	# GL/glext.h:654
# ARB_depth_texture (GL/glext.h:657)
GL_DEPTH_COMPONENT16_ARB = 33189 	# GL/glext.h:658
GL_DEPTH_COMPONENT24_ARB = 33190 	# GL/glext.h:659
GL_DEPTH_COMPONENT32_ARB = 33191 	# GL/glext.h:660
GL_TEXTURE_DEPTH_SIZE_ARB = 34890 	# GL/glext.h:661
GL_DEPTH_TEXTURE_MODE_ARB = 34891 	# GL/glext.h:662
# ARB_shadow (GL/glext.h:665)
GL_TEXTURE_COMPARE_MODE_ARB = 34892 	# GL/glext.h:666
GL_TEXTURE_COMPARE_FUNC_ARB = 34893 	# GL/glext.h:667
GL_COMPARE_R_TO_TEXTURE_ARB = 34894 	# GL/glext.h:668
# ARB_shadow_ambient (GL/glext.h:671)
GL_TEXTURE_COMPARE_FAIL_VALUE_ARB = 32959 	# GL/glext.h:672
# ARB_window_pos (GL/glext.h:675)
# ARB_vertex_program (GL/glext.h:678)
GL_COLOR_SUM_ARB = 33880 	# GL/glext.h:679
GL_VERTEX_PROGRAM_ARB = 34336 	# GL/glext.h:680
GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB = 34338 	# GL/glext.h:681
GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB = 34339 	# GL/glext.h:682
GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB = 34340 	# GL/glext.h:683
GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB = 34341 	# GL/glext.h:684
GL_CURRENT_VERTEX_ATTRIB_ARB = 34342 	# GL/glext.h:685
GL_PROGRAM_LENGTH_ARB = 34343 	# GL/glext.h:686
GL_PROGRAM_STRING_ARB = 34344 	# GL/glext.h:687
GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB = 34350 	# GL/glext.h:688
GL_MAX_PROGRAM_MATRICES_ARB = 34351 	# GL/glext.h:689
GL_CURRENT_MATRIX_STACK_DEPTH_ARB = 34368 	# GL/glext.h:690
GL_CURRENT_MATRIX_ARB = 34369 	# GL/glext.h:691
GL_VERTEX_PROGRAM_POINT_SIZE_ARB = 34370 	# GL/glext.h:692
GL_VERTEX_PROGRAM_TWO_SIDE_ARB = 34371 	# GL/glext.h:693
GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB = 34373 	# GL/glext.h:694
GL_PROGRAM_ERROR_POSITION_ARB = 34379 	# GL/glext.h:695
GL_PROGRAM_BINDING_ARB = 34423 	# GL/glext.h:696
GL_MAX_VERTEX_ATTRIBS_ARB = 34921 	# GL/glext.h:697
GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB = 34922 	# GL/glext.h:698
GL_PROGRAM_ERROR_STRING_ARB = 34932 	# GL/glext.h:699
GL_PROGRAM_FORMAT_ASCII_ARB = 34933 	# GL/glext.h:700
GL_PROGRAM_FORMAT_ARB = 34934 	# GL/glext.h:701
GL_PROGRAM_INSTRUCTIONS_ARB = 34976 	# GL/glext.h:702
GL_MAX_PROGRAM_INSTRUCTIONS_ARB = 34977 	# GL/glext.h:703
GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB = 34978 	# GL/glext.h:704
GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB = 34979 	# GL/glext.h:705
GL_PROGRAM_TEMPORARIES_ARB = 34980 	# GL/glext.h:706
GL_MAX_PROGRAM_TEMPORARIES_ARB = 34981 	# GL/glext.h:707
GL_PROGRAM_NATIVE_TEMPORARIES_ARB = 34982 	# GL/glext.h:708
GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB = 34983 	# GL/glext.h:709
GL_PROGRAM_PARAMETERS_ARB = 34984 	# GL/glext.h:710
GL_MAX_PROGRAM_PARAMETERS_ARB = 34985 	# GL/glext.h:711
GL_PROGRAM_NATIVE_PARAMETERS_ARB = 34986 	# GL/glext.h:712
GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB = 34987 	# GL/glext.h:713
GL_PROGRAM_ATTRIBS_ARB = 34988 	# GL/glext.h:714
GL_MAX_PROGRAM_ATTRIBS_ARB = 34989 	# GL/glext.h:715
GL_PROGRAM_NATIVE_ATTRIBS_ARB = 34990 	# GL/glext.h:716
GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB = 34991 	# GL/glext.h:717
GL_PROGRAM_ADDRESS_REGISTERS_ARB = 34992 	# GL/glext.h:718
GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB = 34993 	# GL/glext.h:719
GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = 34994 	# GL/glext.h:720
GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = 34995 	# GL/glext.h:721
GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB = 34996 	# GL/glext.h:722
GL_MAX_PROGRAM_ENV_PARAMETERS_ARB = 34997 	# GL/glext.h:723
GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB = 34998 	# GL/glext.h:724
GL_TRANSPOSE_CURRENT_MATRIX_ARB = 34999 	# GL/glext.h:725
GL_MATRIX0_ARB = 35008 	# GL/glext.h:726
GL_MATRIX1_ARB = 35009 	# GL/glext.h:727
GL_MATRIX2_ARB = 35010 	# GL/glext.h:728
GL_MATRIX3_ARB = 35011 	# GL/glext.h:729
GL_MATRIX4_ARB = 35012 	# GL/glext.h:730
GL_MATRIX5_ARB = 35013 	# GL/glext.h:731
GL_MATRIX6_ARB = 35014 	# GL/glext.h:732
GL_MATRIX7_ARB = 35015 	# GL/glext.h:733
GL_MATRIX8_ARB = 35016 	# GL/glext.h:734
GL_MATRIX9_ARB = 35017 	# GL/glext.h:735
GL_MATRIX10_ARB = 35018 	# GL/glext.h:736
GL_MATRIX11_ARB = 35019 	# GL/glext.h:737
GL_MATRIX12_ARB = 35020 	# GL/glext.h:738
GL_MATRIX13_ARB = 35021 	# GL/glext.h:739
GL_MATRIX14_ARB = 35022 	# GL/glext.h:740
GL_MATRIX15_ARB = 35023 	# GL/glext.h:741
GL_MATRIX16_ARB = 35024 	# GL/glext.h:742
GL_MATRIX17_ARB = 35025 	# GL/glext.h:743
GL_MATRIX18_ARB = 35026 	# GL/glext.h:744
GL_MATRIX19_ARB = 35027 	# GL/glext.h:745
GL_MATRIX20_ARB = 35028 	# GL/glext.h:746
GL_MATRIX21_ARB = 35029 	# GL/glext.h:747
GL_MATRIX22_ARB = 35030 	# GL/glext.h:748
GL_MATRIX23_ARB = 35031 	# GL/glext.h:749
GL_MATRIX24_ARB = 35032 	# GL/glext.h:750
GL_MATRIX25_ARB = 35033 	# GL/glext.h:751
GL_MATRIX26_ARB = 35034 	# GL/glext.h:752
GL_MATRIX27_ARB = 35035 	# GL/glext.h:753
GL_MATRIX28_ARB = 35036 	# GL/glext.h:754
GL_MATRIX29_ARB = 35037 	# GL/glext.h:755
GL_MATRIX30_ARB = 35038 	# GL/glext.h:756
GL_MATRIX31_ARB = 35039 	# GL/glext.h:757
# ARB_fragment_program (GL/glext.h:760)
GL_FRAGMENT_PROGRAM_ARB = 34820 	# GL/glext.h:761
GL_PROGRAM_ALU_INSTRUCTIONS_ARB = 34821 	# GL/glext.h:762
GL_PROGRAM_TEX_INSTRUCTIONS_ARB = 34822 	# GL/glext.h:763
GL_PROGRAM_TEX_INDIRECTIONS_ARB = 34823 	# GL/glext.h:764
GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = 34824 	# GL/glext.h:765
GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = 34825 	# GL/glext.h:766
GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = 34826 	# GL/glext.h:767
GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB = 34827 	# GL/glext.h:768
GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB = 34828 	# GL/glext.h:769
GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB = 34829 	# GL/glext.h:770
GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = 34830 	# GL/glext.h:771
GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = 34831 	# GL/glext.h:772
GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = 34832 	# GL/glext.h:773
GL_MAX_TEXTURE_COORDS_ARB = 34929 	# GL/glext.h:774
GL_MAX_TEXTURE_IMAGE_UNITS_ARB = 34930 	# GL/glext.h:775
# ARB_vertex_buffer_object (GL/glext.h:778)
GL_BUFFER_SIZE_ARB = 34660 	# GL/glext.h:779
GL_BUFFER_USAGE_ARB = 34661 	# GL/glext.h:780
GL_ARRAY_BUFFER_ARB = 34962 	# GL/glext.h:781
GL_ELEMENT_ARRAY_BUFFER_ARB = 34963 	# GL/glext.h:782
GL_ARRAY_BUFFER_BINDING_ARB = 34964 	# GL/glext.h:783
GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB = 34965 	# GL/glext.h:784
GL_VERTEX_ARRAY_BUFFER_BINDING_ARB = 34966 	# GL/glext.h:785
GL_NORMAL_ARRAY_BUFFER_BINDING_ARB = 34967 	# GL/glext.h:786
GL_COLOR_ARRAY_BUFFER_BINDING_ARB = 34968 	# GL/glext.h:787
GL_INDEX_ARRAY_BUFFER_BINDING_ARB = 34969 	# GL/glext.h:788
GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB = 34970 	# GL/glext.h:789
GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB = 34971 	# GL/glext.h:790
GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB = 34972 	# GL/glext.h:791
GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB = 34973 	# GL/glext.h:792
GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB = 34974 	# GL/glext.h:793
GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB = 34975 	# GL/glext.h:794
GL_READ_ONLY_ARB = 35000 	# GL/glext.h:795
GL_WRITE_ONLY_ARB = 35001 	# GL/glext.h:796
GL_READ_WRITE_ARB = 35002 	# GL/glext.h:797
GL_BUFFER_ACCESS_ARB = 35003 	# GL/glext.h:798
GL_BUFFER_MAPPED_ARB = 35004 	# GL/glext.h:799
GL_BUFFER_MAP_POINTER_ARB = 35005 	# GL/glext.h:800
GL_STREAM_DRAW_ARB = 35040 	# GL/glext.h:801
GL_STREAM_READ_ARB = 35041 	# GL/glext.h:802
GL_STREAM_COPY_ARB = 35042 	# GL/glext.h:803
GL_STATIC_DRAW_ARB = 35044 	# GL/glext.h:804
GL_STATIC_READ_ARB = 35045 	# GL/glext.h:805
GL_STATIC_COPY_ARB = 35046 	# GL/glext.h:806
GL_DYNAMIC_DRAW_ARB = 35048 	# GL/glext.h:807
GL_DYNAMIC_READ_ARB = 35049 	# GL/glext.h:808
GL_DYNAMIC_COPY_ARB = 35050 	# GL/glext.h:809
# ARB_occlusion_query (GL/glext.h:812)
GL_QUERY_COUNTER_BITS_ARB = 34916 	# GL/glext.h:813
GL_CURRENT_QUERY_ARB = 34917 	# GL/glext.h:814
GL_QUERY_RESULT_ARB = 34918 	# GL/glext.h:815
GL_QUERY_RESULT_AVAILABLE_ARB = 34919 	# GL/glext.h:816
GL_SAMPLES_PASSED_ARB = 35092 	# GL/glext.h:817
# ARB_shader_objects (GL/glext.h:820)
GL_PROGRAM_OBJECT_ARB = 35648 	# GL/glext.h:821
GL_SHADER_OBJECT_ARB = 35656 	# GL/glext.h:822
GL_OBJECT_TYPE_ARB = 35662 	# GL/glext.h:823
GL_OBJECT_SUBTYPE_ARB = 35663 	# GL/glext.h:824
GL_FLOAT_VEC2_ARB = 35664 	# GL/glext.h:825
GL_FLOAT_VEC3_ARB = 35665 	# GL/glext.h:826
GL_FLOAT_VEC4_ARB = 35666 	# GL/glext.h:827
GL_INT_VEC2_ARB = 35667 	# GL/glext.h:828
GL_INT_VEC3_ARB = 35668 	# GL/glext.h:829
GL_INT_VEC4_ARB = 35669 	# GL/glext.h:830
GL_BOOL_ARB = 35670 	# GL/glext.h:831
GL_BOOL_VEC2_ARB = 35671 	# GL/glext.h:832
GL_BOOL_VEC3_ARB = 35672 	# GL/glext.h:833
GL_BOOL_VEC4_ARB = 35673 	# GL/glext.h:834
GL_FLOAT_MAT2_ARB = 35674 	# GL/glext.h:835
GL_FLOAT_MAT3_ARB = 35675 	# GL/glext.h:836
GL_FLOAT_MAT4_ARB = 35676 	# GL/glext.h:837
GL_SAMPLER_1D_ARB = 35677 	# GL/glext.h:838
GL_SAMPLER_2D_ARB = 35678 	# GL/glext.h:839
GL_SAMPLER_3D_ARB = 35679 	# GL/glext.h:840
GL_SAMPLER_CUBE_ARB = 35680 	# GL/glext.h:841
GL_SAMPLER_1D_SHADOW_ARB = 35681 	# GL/glext.h:842
GL_SAMPLER_2D_SHADOW_ARB = 35682 	# GL/glext.h:843
GL_SAMPLER_2D_RECT_ARB = 35683 	# GL/glext.h:844
GL_SAMPLER_2D_RECT_SHADOW_ARB = 35684 	# GL/glext.h:845
GL_OBJECT_DELETE_STATUS_ARB = 35712 	# GL/glext.h:846
GL_OBJECT_COMPILE_STATUS_ARB = 35713 	# GL/glext.h:847
GL_OBJECT_LINK_STATUS_ARB = 35714 	# GL/glext.h:848
GL_OBJECT_VALIDATE_STATUS_ARB = 35715 	# GL/glext.h:849
GL_OBJECT_INFO_LOG_LENGTH_ARB = 35716 	# GL/glext.h:850
GL_OBJECT_ATTACHED_OBJECTS_ARB = 35717 	# GL/glext.h:851
GL_OBJECT_ACTIVE_UNIFORMS_ARB = 35718 	# GL/glext.h:852
GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB = 35719 	# GL/glext.h:853
GL_OBJECT_SHADER_SOURCE_LENGTH_ARB = 35720 	# GL/glext.h:854
# ARB_vertex_shader (GL/glext.h:857)
GL_VERTEX_SHADER_ARB = 35633 	# GL/glext.h:858
GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB = 35658 	# GL/glext.h:859
GL_MAX_VARYING_FLOATS_ARB = 35659 	# GL/glext.h:860
GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB = 35660 	# GL/glext.h:861
GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB = 35661 	# GL/glext.h:862
GL_OBJECT_ACTIVE_ATTRIBUTES_ARB = 35721 	# GL/glext.h:863
GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB = 35722 	# GL/glext.h:864
# ARB_fragment_shader (GL/glext.h:867)
GL_FRAGMENT_SHADER_ARB = 35632 	# GL/glext.h:868
GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB = 35657 	# GL/glext.h:869
GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB = 35723 	# GL/glext.h:870
# ARB_shading_language_100 (GL/glext.h:873)
GL_SHADING_LANGUAGE_VERSION_ARB = 35724 	# GL/glext.h:874
# ARB_texture_non_power_of_two (GL/glext.h:877)
# ARB_point_sprite (GL/glext.h:880)
GL_POINT_SPRITE_ARB = 34913 	# GL/glext.h:881
GL_COORD_REPLACE_ARB = 34914 	# GL/glext.h:882
# ARB_fragment_program_shadow (GL/glext.h:885)
# ARB_draw_buffers (GL/glext.h:888)
GL_MAX_DRAW_BUFFERS_ARB = 34852 	# GL/glext.h:889
GL_DRAW_BUFFER0_ARB = 34853 	# GL/glext.h:890
GL_DRAW_BUFFER1_ARB = 34854 	# GL/glext.h:891
GL_DRAW_BUFFER2_ARB = 34855 	# GL/glext.h:892
GL_DRAW_BUFFER3_ARB = 34856 	# GL/glext.h:893
GL_DRAW_BUFFER4_ARB = 34857 	# GL/glext.h:894
GL_DRAW_BUFFER5_ARB = 34858 	# GL/glext.h:895
GL_DRAW_BUFFER6_ARB = 34859 	# GL/glext.h:896
GL_DRAW_BUFFER7_ARB = 34860 	# GL/glext.h:897
GL_DRAW_BUFFER8_ARB = 34861 	# GL/glext.h:898
GL_DRAW_BUFFER9_ARB = 34862 	# GL/glext.h:899
GL_DRAW_BUFFER10_ARB = 34863 	# GL/glext.h:900
GL_DRAW_BUFFER11_ARB = 34864 	# GL/glext.h:901
GL_DRAW_BUFFER12_ARB = 34865 	# GL/glext.h:902
GL_DRAW_BUFFER13_ARB = 34866 	# GL/glext.h:903
GL_DRAW_BUFFER14_ARB = 34867 	# GL/glext.h:904
GL_DRAW_BUFFER15_ARB = 34868 	# GL/glext.h:905
# ARB_texture_rectangle (GL/glext.h:908)
GL_TEXTURE_RECTANGLE_ARB = 34037 	# GL/glext.h:909
GL_TEXTURE_BINDING_RECTANGLE_ARB = 34038 	# GL/glext.h:910
GL_PROXY_TEXTURE_RECTANGLE_ARB = 34039 	# GL/glext.h:911
GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB = 34040 	# GL/glext.h:912
# ARB_color_buffer_float (GL/glext.h:915)
GL_RGBA_FLOAT_MODE_ARB = 34848 	# GL/glext.h:916
GL_CLAMP_VERTEX_COLOR_ARB = 35098 	# GL/glext.h:917
GL_CLAMP_FRAGMENT_COLOR_ARB = 35099 	# GL/glext.h:918
GL_CLAMP_READ_COLOR_ARB = 35100 	# GL/glext.h:919
GL_FIXED_ONLY_ARB = 35101 	# GL/glext.h:920
# ARB_half_float_pixel (GL/glext.h:923)
GL_HALF_FLOAT_ARB = 5131 	# GL/glext.h:924
# ARB_texture_float (GL/glext.h:927)
GL_TEXTURE_RED_TYPE_ARB = 35856 	# GL/glext.h:928
GL_TEXTURE_GREEN_TYPE_ARB = 35857 	# GL/glext.h:929
GL_TEXTURE_BLUE_TYPE_ARB = 35858 	# GL/glext.h:930
GL_TEXTURE_ALPHA_TYPE_ARB = 35859 	# GL/glext.h:931
GL_TEXTURE_LUMINANCE_TYPE_ARB = 35860 	# GL/glext.h:932
GL_TEXTURE_INTENSITY_TYPE_ARB = 35861 	# GL/glext.h:933
GL_TEXTURE_DEPTH_TYPE_ARB = 35862 	# GL/glext.h:934
GL_UNSIGNED_NORMALIZED_ARB = 35863 	# GL/glext.h:935
GL_RGBA32F_ARB = 34836 	# GL/glext.h:936
GL_RGB32F_ARB = 34837 	# GL/glext.h:937
GL_ALPHA32F_ARB = 34838 	# GL/glext.h:938
GL_INTENSITY32F_ARB = 34839 	# GL/glext.h:939
GL_LUMINANCE32F_ARB = 34840 	# GL/glext.h:940
GL_LUMINANCE_ALPHA32F_ARB = 34841 	# GL/glext.h:941
GL_RGBA16F_ARB = 34842 	# GL/glext.h:942
GL_RGB16F_ARB = 34843 	# GL/glext.h:943
GL_ALPHA16F_ARB = 34844 	# GL/glext.h:944
GL_INTENSITY16F_ARB = 34845 	# GL/glext.h:945
GL_LUMINANCE16F_ARB = 34846 	# GL/glext.h:946
GL_LUMINANCE_ALPHA16F_ARB = 34847 	# GL/glext.h:947
# ARB_pixel_buffer_object (GL/glext.h:950)
GL_PIXEL_PACK_BUFFER_ARB = 35051 	# GL/glext.h:951
GL_PIXEL_UNPACK_BUFFER_ARB = 35052 	# GL/glext.h:952
GL_PIXEL_PACK_BUFFER_BINDING_ARB = 35053 	# GL/glext.h:953
GL_PIXEL_UNPACK_BUFFER_BINDING_ARB = 35055 	# GL/glext.h:954
# EXT_abgr (GL/glext.h:957)
GL_ABGR_EXT = 32768 	# GL/glext.h:958
# EXT_blend_color (GL/glext.h:961)
GL_CONSTANT_COLOR_EXT = 32769 	# GL/glext.h:962
GL_ONE_MINUS_CONSTANT_COLOR_EXT = 32770 	# GL/glext.h:963
GL_CONSTANT_ALPHA_EXT = 32771 	# GL/glext.h:964
GL_ONE_MINUS_CONSTANT_ALPHA_EXT = 32772 	# GL/glext.h:965
GL_BLEND_COLOR_EXT = 32773 	# GL/glext.h:966
# EXT_polygon_offset (GL/glext.h:969)
GL_POLYGON_OFFSET_EXT = 32823 	# GL/glext.h:970
GL_POLYGON_OFFSET_FACTOR_EXT = 32824 	# GL/glext.h:971
GL_POLYGON_OFFSET_BIAS_EXT = 32825 	# GL/glext.h:972
# EXT_texture (GL/glext.h:975)
GL_ALPHA4_EXT = 32827 	# GL/glext.h:976
GL_ALPHA8_EXT = 32828 	# GL/glext.h:977
GL_ALPHA12_EXT = 32829 	# GL/glext.h:978
GL_ALPHA16_EXT = 32830 	# GL/glext.h:979
GL_LUMINANCE4_EXT = 32831 	# GL/glext.h:980
GL_LUMINANCE8_EXT = 32832 	# GL/glext.h:981
GL_LUMINANCE12_EXT = 32833 	# GL/glext.h:982
GL_LUMINANCE16_EXT = 32834 	# GL/glext.h:983
GL_LUMINANCE4_ALPHA4_EXT = 32835 	# GL/glext.h:984
GL_LUMINANCE6_ALPHA2_EXT = 32836 	# GL/glext.h:985
GL_LUMINANCE8_ALPHA8_EXT = 32837 	# GL/glext.h:986
GL_LUMINANCE12_ALPHA4_EXT = 32838 	# GL/glext.h:987
GL_LUMINANCE12_ALPHA12_EXT = 32839 	# GL/glext.h:988
GL_LUMINANCE16_ALPHA16_EXT = 32840 	# GL/glext.h:989
GL_INTENSITY_EXT = 32841 	# GL/glext.h:990
GL_INTENSITY4_EXT = 32842 	# GL/glext.h:991
GL_INTENSITY8_EXT = 32843 	# GL/glext.h:992
GL_INTENSITY12_EXT = 32844 	# GL/glext.h:993
GL_INTENSITY16_EXT = 32845 	# GL/glext.h:994
GL_RGB2_EXT = 32846 	# GL/glext.h:995
GL_RGB4_EXT = 32847 	# GL/glext.h:996
GL_RGB5_EXT = 32848 	# GL/glext.h:997
GL_RGB8_EXT = 32849 	# GL/glext.h:998
GL_RGB10_EXT = 32850 	# GL/glext.h:999
GL_RGB12_EXT = 32851 	# GL/glext.h:1000
GL_RGB16_EXT = 32852 	# GL/glext.h:1001
GL_RGBA2_EXT = 32853 	# GL/glext.h:1002
GL_RGBA4_EXT = 32854 	# GL/glext.h:1003
GL_RGB5_A1_EXT = 32855 	# GL/glext.h:1004
GL_RGBA8_EXT = 32856 	# GL/glext.h:1005
GL_RGB10_A2_EXT = 32857 	# GL/glext.h:1006
GL_RGBA12_EXT = 32858 	# GL/glext.h:1007
GL_RGBA16_EXT = 32859 	# GL/glext.h:1008
GL_TEXTURE_RED_SIZE_EXT = 32860 	# GL/glext.h:1009
GL_TEXTURE_GREEN_SIZE_EXT = 32861 	# GL/glext.h:1010
GL_TEXTURE_BLUE_SIZE_EXT = 32862 	# GL/glext.h:1011
GL_TEXTURE_ALPHA_SIZE_EXT = 32863 	# GL/glext.h:1012
GL_TEXTURE_LUMINANCE_SIZE_EXT = 32864 	# GL/glext.h:1013
GL_TEXTURE_INTENSITY_SIZE_EXT = 32865 	# GL/glext.h:1014
GL_REPLACE_EXT = 32866 	# GL/glext.h:1015
GL_PROXY_TEXTURE_1D_EXT = 32867 	# GL/glext.h:1016
GL_PROXY_TEXTURE_2D_EXT = 32868 	# GL/glext.h:1017
GL_TEXTURE_TOO_LARGE_EXT = 32869 	# GL/glext.h:1018
# EXT_texture3D (GL/glext.h:1021)
GL_PACK_SKIP_IMAGES_EXT = 32875 	# GL/glext.h:1022
GL_PACK_IMAGE_HEIGHT_EXT = 32876 	# GL/glext.h:1023
GL_UNPACK_SKIP_IMAGES_EXT = 32877 	# GL/glext.h:1024
GL_UNPACK_IMAGE_HEIGHT_EXT = 32878 	# GL/glext.h:1025
GL_TEXTURE_3D_EXT = 32879 	# GL/glext.h:1026
GL_PROXY_TEXTURE_3D_EXT = 32880 	# GL/glext.h:1027
GL_TEXTURE_DEPTH_EXT = 32881 	# GL/glext.h:1028
GL_TEXTURE_WRAP_R_EXT = 32882 	# GL/glext.h:1029
GL_MAX_3D_TEXTURE_SIZE_EXT = 32883 	# GL/glext.h:1030
# SGIS_texture_filter4 (GL/glext.h:1033)
GL_FILTER4_SGIS = 33094 	# GL/glext.h:1034
GL_TEXTURE_FILTER4_SIZE_SGIS = 33095 	# GL/glext.h:1035
# EXT_subtexture (GL/glext.h:1038)
# EXT_copy_texture (GL/glext.h:1041)
# EXT_histogram (GL/glext.h:1044)
GL_HISTOGRAM_EXT = 32804 	# GL/glext.h:1045
GL_PROXY_HISTOGRAM_EXT = 32805 	# GL/glext.h:1046
GL_HISTOGRAM_WIDTH_EXT = 32806 	# GL/glext.h:1047
GL_HISTOGRAM_FORMAT_EXT = 32807 	# GL/glext.h:1048
GL_HISTOGRAM_RED_SIZE_EXT = 32808 	# GL/glext.h:1049
GL_HISTOGRAM_GREEN_SIZE_EXT = 32809 	# GL/glext.h:1050
GL_HISTOGRAM_BLUE_SIZE_EXT = 32810 	# GL/glext.h:1051
GL_HISTOGRAM_ALPHA_SIZE_EXT = 32811 	# GL/glext.h:1052
GL_HISTOGRAM_LUMINANCE_SIZE_EXT = 32812 	# GL/glext.h:1053
GL_HISTOGRAM_SINK_EXT = 32813 	# GL/glext.h:1054
GL_MINMAX_EXT = 32814 	# GL/glext.h:1055
GL_MINMAX_FORMAT_EXT = 32815 	# GL/glext.h:1056
GL_MINMAX_SINK_EXT = 32816 	# GL/glext.h:1057
GL_TABLE_TOO_LARGE_EXT = 32817 	# GL/glext.h:1058
# EXT_convolution (GL/glext.h:1061)
GL_CONVOLUTION_1D_EXT = 32784 	# GL/glext.h:1062
GL_CONVOLUTION_2D_EXT = 32785 	# GL/glext.h:1063
GL_SEPARABLE_2D_EXT = 32786 	# GL/glext.h:1064
GL_CONVOLUTION_BORDER_MODE_EXT = 32787 	# GL/glext.h:1065
GL_CONVOLUTION_FILTER_SCALE_EXT = 32788 	# GL/glext.h:1066
GL_CONVOLUTION_FILTER_BIAS_EXT = 32789 	# GL/glext.h:1067
GL_REDUCE_EXT = 32790 	# GL/glext.h:1068
GL_CONVOLUTION_FORMAT_EXT = 32791 	# GL/glext.h:1069
GL_CONVOLUTION_WIDTH_EXT = 32792 	# GL/glext.h:1070
GL_CONVOLUTION_HEIGHT_EXT = 32793 	# GL/glext.h:1071
GL_MAX_CONVOLUTION_WIDTH_EXT = 32794 	# GL/glext.h:1072
GL_MAX_CONVOLUTION_HEIGHT_EXT = 32795 	# GL/glext.h:1073
GL_POST_CONVOLUTION_RED_SCALE_EXT = 32796 	# GL/glext.h:1074
GL_POST_CONVOLUTION_GREEN_SCALE_EXT = 32797 	# GL/glext.h:1075
GL_POST_CONVOLUTION_BLUE_SCALE_EXT = 32798 	# GL/glext.h:1076
GL_POST_CONVOLUTION_ALPHA_SCALE_EXT = 32799 	# GL/glext.h:1077
GL_POST_CONVOLUTION_RED_BIAS_EXT = 32800 	# GL/glext.h:1078
GL_POST_CONVOLUTION_GREEN_BIAS_EXT = 32801 	# GL/glext.h:1079
GL_POST_CONVOLUTION_BLUE_BIAS_EXT = 32802 	# GL/glext.h:1080
GL_POST_CONVOLUTION_ALPHA_BIAS_EXT = 32803 	# GL/glext.h:1081
# SGI_color_matrix (GL/glext.h:1084)
GL_COLOR_MATRIX_SGI = 32945 	# GL/glext.h:1085
GL_COLOR_MATRIX_STACK_DEPTH_SGI = 32946 	# GL/glext.h:1086
GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI = 32947 	# GL/glext.h:1087
GL_POST_COLOR_MATRIX_RED_SCALE_SGI = 32948 	# GL/glext.h:1088
GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI = 32949 	# GL/glext.h:1089
GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI = 32950 	# GL/glext.h:1090
GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI = 32951 	# GL/glext.h:1091
GL_POST_COLOR_MATRIX_RED_BIAS_SGI = 32952 	# GL/glext.h:1092
GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI = 32953 	# GL/glext.h:1093
GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI = 32954 	# GL/glext.h:1094
GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI = 32955 	# GL/glext.h:1095
# SGI_color_table (GL/glext.h:1098)
GL_COLOR_TABLE_SGI = 32976 	# GL/glext.h:1099
GL_POST_CONVOLUTION_COLOR_TABLE_SGI = 32977 	# GL/glext.h:1100
GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI = 32978 	# GL/glext.h:1101
GL_PROXY_COLOR_TABLE_SGI = 32979 	# GL/glext.h:1102
GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI = 32980 	# GL/glext.h:1103
GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI = 32981 	# GL/glext.h:1104
GL_COLOR_TABLE_SCALE_SGI = 32982 	# GL/glext.h:1105
GL_COLOR_TABLE_BIAS_SGI = 32983 	# GL/glext.h:1106
GL_COLOR_TABLE_FORMAT_SGI = 32984 	# GL/glext.h:1107
GL_COLOR_TABLE_WIDTH_SGI = 32985 	# GL/glext.h:1108
GL_COLOR_TABLE_RED_SIZE_SGI = 32986 	# GL/glext.h:1109
GL_COLOR_TABLE_GREEN_SIZE_SGI = 32987 	# GL/glext.h:1110
GL_COLOR_TABLE_BLUE_SIZE_SGI = 32988 	# GL/glext.h:1111
GL_COLOR_TABLE_ALPHA_SIZE_SGI = 32989 	# GL/glext.h:1112
GL_COLOR_TABLE_LUMINANCE_SIZE_SGI = 32990 	# GL/glext.h:1113
GL_COLOR_TABLE_INTENSITY_SIZE_SGI = 32991 	# GL/glext.h:1114
# SGIS_pixel_texture (GL/glext.h:1117)
GL_PIXEL_TEXTURE_SGIS = 33619 	# GL/glext.h:1118
GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS = 33620 	# GL/glext.h:1119
GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS = 33621 	# GL/glext.h:1120
GL_PIXEL_GROUP_COLOR_SGIS = 33622 	# GL/glext.h:1121
# SGIX_pixel_texture (GL/glext.h:1124)
GL_PIXEL_TEX_GEN_SGIX = 33081 	# GL/glext.h:1125
GL_PIXEL_TEX_GEN_MODE_SGIX = 33579 	# GL/glext.h:1126
# SGIS_texture4D (GL/glext.h:1129)
GL_PACK_SKIP_VOLUMES_SGIS = 33072 	# GL/glext.h:1130
GL_PACK_IMAGE_DEPTH_SGIS = 33073 	# GL/glext.h:1131
GL_UNPACK_SKIP_VOLUMES_SGIS = 33074 	# GL/glext.h:1132
GL_UNPACK_IMAGE_DEPTH_SGIS = 33075 	# GL/glext.h:1133
GL_TEXTURE_4D_SGIS = 33076 	# GL/glext.h:1134
GL_PROXY_TEXTURE_4D_SGIS = 33077 	# GL/glext.h:1135
GL_TEXTURE_4DSIZE_SGIS = 33078 	# GL/glext.h:1136
GL_TEXTURE_WRAP_Q_SGIS = 33079 	# GL/glext.h:1137
GL_MAX_4D_TEXTURE_SIZE_SGIS = 33080 	# GL/glext.h:1138
GL_TEXTURE_4D_BINDING_SGIS = 33103 	# GL/glext.h:1139
# SGI_texture_color_table (GL/glext.h:1142)
GL_TEXTURE_COLOR_TABLE_SGI = 32956 	# GL/glext.h:1143
GL_PROXY_TEXTURE_COLOR_TABLE_SGI = 32957 	# GL/glext.h:1144
# EXT_cmyka (GL/glext.h:1147)
GL_CMYK_EXT = 32780 	# GL/glext.h:1148
GL_CMYKA_EXT = 32781 	# GL/glext.h:1149
GL_PACK_CMYK_HINT_EXT = 32782 	# GL/glext.h:1150
GL_UNPACK_CMYK_HINT_EXT = 32783 	# GL/glext.h:1151
# EXT_texture_object (GL/glext.h:1154)
GL_TEXTURE_PRIORITY_EXT = 32870 	# GL/glext.h:1155
GL_TEXTURE_RESIDENT_EXT = 32871 	# GL/glext.h:1156
GL_TEXTURE_1D_BINDING_EXT = 32872 	# GL/glext.h:1157
GL_TEXTURE_2D_BINDING_EXT = 32873 	# GL/glext.h:1158
GL_TEXTURE_3D_BINDING_EXT = 32874 	# GL/glext.h:1159
# SGIS_detail_texture (GL/glext.h:1162)
GL_DETAIL_TEXTURE_2D_SGIS = 32917 	# GL/glext.h:1163
GL_DETAIL_TEXTURE_2D_BINDING_SGIS = 32918 	# GL/glext.h:1164
GL_LINEAR_DETAIL_SGIS = 32919 	# GL/glext.h:1165
GL_LINEAR_DETAIL_ALPHA_SGIS = 32920 	# GL/glext.h:1166
GL_LINEAR_DETAIL_COLOR_SGIS = 32921 	# GL/glext.h:1167
GL_DETAIL_TEXTURE_LEVEL_SGIS = 32922 	# GL/glext.h:1168
GL_DETAIL_TEXTURE_MODE_SGIS = 32923 	# GL/glext.h:1169
GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS = 32924 	# GL/glext.h:1170
# SGIS_sharpen_texture (GL/glext.h:1173)
GL_LINEAR_SHARPEN_SGIS = 32941 	# GL/glext.h:1174
GL_LINEAR_SHARPEN_ALPHA_SGIS = 32942 	# GL/glext.h:1175
GL_LINEAR_SHARPEN_COLOR_SGIS = 32943 	# GL/glext.h:1176
GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS = 32944 	# GL/glext.h:1177
# EXT_packed_pixels (GL/glext.h:1180)
GL_UNSIGNED_BYTE_3_3_2_EXT = 32818 	# GL/glext.h:1181
GL_UNSIGNED_SHORT_4_4_4_4_EXT = 32819 	# GL/glext.h:1182
GL_UNSIGNED_SHORT_5_5_5_1_EXT = 32820 	# GL/glext.h:1183
GL_UNSIGNED_INT_8_8_8_8_EXT = 32821 	# GL/glext.h:1184
GL_UNSIGNED_INT_10_10_10_2_EXT = 32822 	# GL/glext.h:1185
# SGIS_texture_lod (GL/glext.h:1188)
GL_TEXTURE_MIN_LOD_SGIS = 33082 	# GL/glext.h:1189
GL_TEXTURE_MAX_LOD_SGIS = 33083 	# GL/glext.h:1190
GL_TEXTURE_BASE_LEVEL_SGIS = 33084 	# GL/glext.h:1191
GL_TEXTURE_MAX_LEVEL_SGIS = 33085 	# GL/glext.h:1192
# SGIS_multisample (GL/glext.h:1195)
GL_MULTISAMPLE_SGIS = 32925 	# GL/glext.h:1196
GL_SAMPLE_ALPHA_TO_MASK_SGIS = 32926 	# GL/glext.h:1197
GL_SAMPLE_ALPHA_TO_ONE_SGIS = 32927 	# GL/glext.h:1198
GL_SAMPLE_MASK_SGIS = 32928 	# GL/glext.h:1199
GL_1PASS_SGIS = 32929 	# GL/glext.h:1200
GL_2PASS_0_SGIS = 32930 	# GL/glext.h:1201
GL_2PASS_1_SGIS = 32931 	# GL/glext.h:1202
GL_4PASS_0_SGIS = 32932 	# GL/glext.h:1203
GL_4PASS_1_SGIS = 32933 	# GL/glext.h:1204
GL_4PASS_2_SGIS = 32934 	# GL/glext.h:1205
GL_4PASS_3_SGIS = 32935 	# GL/glext.h:1206
GL_SAMPLE_BUFFERS_SGIS = 32936 	# GL/glext.h:1207
GL_SAMPLES_SGIS = 32937 	# GL/glext.h:1208
GL_SAMPLE_MASK_VALUE_SGIS = 32938 	# GL/glext.h:1209
GL_SAMPLE_MASK_INVERT_SGIS = 32939 	# GL/glext.h:1210
GL_SAMPLE_PATTERN_SGIS = 32940 	# GL/glext.h:1211
# EXT_rescale_normal (GL/glext.h:1214)
GL_RESCALE_NORMAL_EXT = 32826 	# GL/glext.h:1215
# EXT_vertex_array (GL/glext.h:1218)
GL_VERTEX_ARRAY_EXT = 32884 	# GL/glext.h:1219
GL_NORMAL_ARRAY_EXT = 32885 	# GL/glext.h:1220
GL_COLOR_ARRAY_EXT = 32886 	# GL/glext.h:1221
GL_INDEX_ARRAY_EXT = 32887 	# GL/glext.h:1222
GL_TEXTURE_COORD_ARRAY_EXT = 32888 	# GL/glext.h:1223
GL_EDGE_FLAG_ARRAY_EXT = 32889 	# GL/glext.h:1224
GL_VERTEX_ARRAY_SIZE_EXT = 32890 	# GL/glext.h:1225
GL_VERTEX_ARRAY_TYPE_EXT = 32891 	# GL/glext.h:1226
GL_VERTEX_ARRAY_STRIDE_EXT = 32892 	# GL/glext.h:1227
GL_VERTEX_ARRAY_COUNT_EXT = 32893 	# GL/glext.h:1228
GL_NORMAL_ARRAY_TYPE_EXT = 32894 	# GL/glext.h:1229
GL_NORMAL_ARRAY_STRIDE_EXT = 32895 	# GL/glext.h:1230
GL_NORMAL_ARRAY_COUNT_EXT = 32896 	# GL/glext.h:1231
GL_COLOR_ARRAY_SIZE_EXT = 32897 	# GL/glext.h:1232
GL_COLOR_ARRAY_TYPE_EXT = 32898 	# GL/glext.h:1233
GL_COLOR_ARRAY_STRIDE_EXT = 32899 	# GL/glext.h:1234
GL_COLOR_ARRAY_COUNT_EXT = 32900 	# GL/glext.h:1235
GL_INDEX_ARRAY_TYPE_EXT = 32901 	# GL/glext.h:1236
GL_INDEX_ARRAY_STRIDE_EXT = 32902 	# GL/glext.h:1237
GL_INDEX_ARRAY_COUNT_EXT = 32903 	# GL/glext.h:1238
GL_TEXTURE_COORD_ARRAY_SIZE_EXT = 32904 	# GL/glext.h:1239
GL_TEXTURE_COORD_ARRAY_TYPE_EXT = 32905 	# GL/glext.h:1240
GL_TEXTURE_COORD_ARRAY_STRIDE_EXT = 32906 	# GL/glext.h:1241
GL_TEXTURE_COORD_ARRAY_COUNT_EXT = 32907 	# GL/glext.h:1242
GL_EDGE_FLAG_ARRAY_STRIDE_EXT = 32908 	# GL/glext.h:1243
GL_EDGE_FLAG_ARRAY_COUNT_EXT = 32909 	# GL/glext.h:1244
GL_VERTEX_ARRAY_POINTER_EXT = 32910 	# GL/glext.h:1245
GL_NORMAL_ARRAY_POINTER_EXT = 32911 	# GL/glext.h:1246
GL_COLOR_ARRAY_POINTER_EXT = 32912 	# GL/glext.h:1247
GL_INDEX_ARRAY_POINTER_EXT = 32913 	# GL/glext.h:1248
GL_TEXTURE_COORD_ARRAY_POINTER_EXT = 32914 	# GL/glext.h:1249
GL_EDGE_FLAG_ARRAY_POINTER_EXT = 32915 	# GL/glext.h:1250
# EXT_misc_attribute (GL/glext.h:1253)
# SGIS_generate_mipmap (GL/glext.h:1256)
GL_GENERATE_MIPMAP_SGIS = 33169 	# GL/glext.h:1257
GL_GENERATE_MIPMAP_HINT_SGIS = 33170 	# GL/glext.h:1258
# SGIX_clipmap (GL/glext.h:1261)
GL_LINEAR_CLIPMAP_LINEAR_SGIX = 33136 	# GL/glext.h:1262
GL_TEXTURE_CLIPMAP_CENTER_SGIX = 33137 	# GL/glext.h:1263
GL_TEXTURE_CLIPMAP_FRAME_SGIX = 33138 	# GL/glext.h:1264
GL_TEXTURE_CLIPMAP_OFFSET_SGIX = 33139 	# GL/glext.h:1265
GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX = 33140 	# GL/glext.h:1266
GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX = 33141 	# GL/glext.h:1267
GL_TEXTURE_CLIPMAP_DEPTH_SGIX = 33142 	# GL/glext.h:1268
GL_MAX_CLIPMAP_DEPTH_SGIX = 33143 	# GL/glext.h:1269
GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX = 33144 	# GL/glext.h:1270
GL_NEAREST_CLIPMAP_NEAREST_SGIX = 33869 	# GL/glext.h:1271
GL_NEAREST_CLIPMAP_LINEAR_SGIX = 33870 	# GL/glext.h:1272
GL_LINEAR_CLIPMAP_NEAREST_SGIX = 33871 	# GL/glext.h:1273
# SGIX_shadow (GL/glext.h:1276)
GL_TEXTURE_COMPARE_SGIX = 33178 	# GL/glext.h:1277
GL_TEXTURE_COMPARE_OPERATOR_SGIX = 33179 	# GL/glext.h:1278
GL_TEXTURE_LEQUAL_R_SGIX = 33180 	# GL/glext.h:1279
GL_TEXTURE_GEQUAL_R_SGIX = 33181 	# GL/glext.h:1280
# SGIS_texture_edge_clamp (GL/glext.h:1283)
GL_CLAMP_TO_EDGE_SGIS = 33071 	# GL/glext.h:1284
# SGIS_texture_border_clamp (GL/glext.h:1287)
GL_CLAMP_TO_BORDER_SGIS = 33069 	# GL/glext.h:1288
# EXT_blend_minmax (GL/glext.h:1291)
GL_FUNC_ADD_EXT = 32774 	# GL/glext.h:1292
GL_MIN_EXT = 32775 	# GL/glext.h:1293
GL_MAX_EXT = 32776 	# GL/glext.h:1294
GL_BLEND_EQUATION_EXT = 32777 	# GL/glext.h:1295
# EXT_blend_subtract (GL/glext.h:1298)
GL_FUNC_SUBTRACT_EXT = 32778 	# GL/glext.h:1299
GL_FUNC_REVERSE_SUBTRACT_EXT = 32779 	# GL/glext.h:1300
# EXT_blend_logic_op (GL/glext.h:1303)
# SGIX_interlace (GL/glext.h:1306)
GL_INTERLACE_SGIX = 32916 	# GL/glext.h:1307
# SGIX_pixel_tiles (GL/glext.h:1310)
GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX = 33086 	# GL/glext.h:1311
GL_PIXEL_TILE_CACHE_INCREMENT_SGIX = 33087 	# GL/glext.h:1312
GL_PIXEL_TILE_WIDTH_SGIX = 33088 	# GL/glext.h:1313
GL_PIXEL_TILE_HEIGHT_SGIX = 33089 	# GL/glext.h:1314
GL_PIXEL_TILE_GRID_WIDTH_SGIX = 33090 	# GL/glext.h:1315
GL_PIXEL_TILE_GRID_HEIGHT_SGIX = 33091 	# GL/glext.h:1316
GL_PIXEL_TILE_GRID_DEPTH_SGIX = 33092 	# GL/glext.h:1317
GL_PIXEL_TILE_CACHE_SIZE_SGIX = 33093 	# GL/glext.h:1318
# SGIS_texture_select (GL/glext.h:1321)
GL_DUAL_ALPHA4_SGIS = 33040 	# GL/glext.h:1322
GL_DUAL_ALPHA8_SGIS = 33041 	# GL/glext.h:1323
GL_DUAL_ALPHA12_SGIS = 33042 	# GL/glext.h:1324
GL_DUAL_ALPHA16_SGIS = 33043 	# GL/glext.h:1325
GL_DUAL_LUMINANCE4_SGIS = 33044 	# GL/glext.h:1326
GL_DUAL_LUMINANCE8_SGIS = 33045 	# GL/glext.h:1327
GL_DUAL_LUMINANCE12_SGIS = 33046 	# GL/glext.h:1328
GL_DUAL_LUMINANCE16_SGIS = 33047 	# GL/glext.h:1329
GL_DUAL_INTENSITY4_SGIS = 33048 	# GL/glext.h:1330
GL_DUAL_INTENSITY8_SGIS = 33049 	# GL/glext.h:1331
GL_DUAL_INTENSITY12_SGIS = 33050 	# GL/glext.h:1332
GL_DUAL_INTENSITY16_SGIS = 33051 	# GL/glext.h:1333
GL_DUAL_LUMINANCE_ALPHA4_SGIS = 33052 	# GL/glext.h:1334
GL_DUAL_LUMINANCE_ALPHA8_SGIS = 33053 	# GL/glext.h:1335
GL_QUAD_ALPHA4_SGIS = 33054 	# GL/glext.h:1336
GL_QUAD_ALPHA8_SGIS = 33055 	# GL/glext.h:1337
GL_QUAD_LUMINANCE4_SGIS = 33056 	# GL/glext.h:1338
GL_QUAD_LUMINANCE8_SGIS = 33057 	# GL/glext.h:1339
GL_QUAD_INTENSITY4_SGIS = 33058 	# GL/glext.h:1340
GL_QUAD_INTENSITY8_SGIS = 33059 	# GL/glext.h:1341
GL_DUAL_TEXTURE_SELECT_SGIS = 33060 	# GL/glext.h:1342
GL_QUAD_TEXTURE_SELECT_SGIS = 33061 	# GL/glext.h:1343
# SGIX_sprite (GL/glext.h:1346)
GL_SPRITE_SGIX = 33096 	# GL/glext.h:1347
GL_SPRITE_MODE_SGIX = 33097 	# GL/glext.h:1348
GL_SPRITE_AXIS_SGIX = 33098 	# GL/glext.h:1349
GL_SPRITE_TRANSLATION_SGIX = 33099 	# GL/glext.h:1350
GL_SPRITE_AXIAL_SGIX = 33100 	# GL/glext.h:1351
GL_SPRITE_OBJECT_ALIGNED_SGIX = 33101 	# GL/glext.h:1352
GL_SPRITE_EYE_ALIGNED_SGIX = 33102 	# GL/glext.h:1353
# SGIX_texture_multi_buffer (GL/glext.h:1356)
GL_TEXTURE_MULTI_BUFFER_HINT_SGIX = 33070 	# GL/glext.h:1357
# EXT_point_parameters (GL/glext.h:1360)
GL_POINT_SIZE_MIN_EXT = 33062 	# GL/glext.h:1361
GL_POINT_SIZE_MAX_EXT = 33063 	# GL/glext.h:1362
GL_POINT_FADE_THRESHOLD_SIZE_EXT = 33064 	# GL/glext.h:1363
GL_DISTANCE_ATTENUATION_EXT = 33065 	# GL/glext.h:1364
# SGIS_point_parameters (GL/glext.h:1367)
GL_POINT_SIZE_MIN_SGIS = 33062 	# GL/glext.h:1368
GL_POINT_SIZE_MAX_SGIS = 33063 	# GL/glext.h:1369
GL_POINT_FADE_THRESHOLD_SIZE_SGIS = 33064 	# GL/glext.h:1370
GL_DISTANCE_ATTENUATION_SGIS = 33065 	# GL/glext.h:1371
# SGIX_instruments (GL/glext.h:1374)
GL_INSTRUMENT_BUFFER_POINTER_SGIX = 33152 	# GL/glext.h:1375
GL_INSTRUMENT_MEASUREMENTS_SGIX = 33153 	# GL/glext.h:1376
# SGIX_texture_scale_bias (GL/glext.h:1379)
GL_POST_TEXTURE_FILTER_BIAS_SGIX = 33145 	# GL/glext.h:1380
GL_POST_TEXTURE_FILTER_SCALE_SGIX = 33146 	# GL/glext.h:1381
GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX = 33147 	# GL/glext.h:1382
GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX = 33148 	# GL/glext.h:1383
# SGIX_framezoom (GL/glext.h:1386)
GL_FRAMEZOOM_SGIX = 33163 	# GL/glext.h:1387
GL_FRAMEZOOM_FACTOR_SGIX = 33164 	# GL/glext.h:1388
GL_MAX_FRAMEZOOM_FACTOR_SGIX = 33165 	# GL/glext.h:1389
# SGIX_tag_sample_buffer (GL/glext.h:1392)
# FfdMaskSGIX (GL/glext.h:1395)
GL_TEXTURE_DEFORMATION_BIT_SGIX = 1 	# GL/glext.h:1396
GL_GEOMETRY_DEFORMATION_BIT_SGIX = 2 	# GL/glext.h:1397
# SGIX_polynomial_ffd (GL/glext.h:1400)
GL_GEOMETRY_DEFORMATION_SGIX = 33172 	# GL/glext.h:1401
GL_TEXTURE_DEFORMATION_SGIX = 33173 	# GL/glext.h:1402
GL_DEFORMATIONS_MASK_SGIX = 33174 	# GL/glext.h:1403
GL_MAX_DEFORMATION_ORDER_SGIX = 33175 	# GL/glext.h:1404
# SGIX_reference_plane (GL/glext.h:1407)
GL_REFERENCE_PLANE_SGIX = 33149 	# GL/glext.h:1408
GL_REFERENCE_PLANE_EQUATION_SGIX = 33150 	# GL/glext.h:1409
# SGIX_flush_raster (GL/glext.h:1412)
# SGIX_depth_texture (GL/glext.h:1415)
GL_DEPTH_COMPONENT16_SGIX = 33189 	# GL/glext.h:1416
GL_DEPTH_COMPONENT24_SGIX = 33190 	# GL/glext.h:1417
GL_DEPTH_COMPONENT32_SGIX = 33191 	# GL/glext.h:1418
# SGIS_fog_function (GL/glext.h:1421)
GL_FOG_FUNC_SGIS = 33066 	# GL/glext.h:1422
GL_FOG_FUNC_POINTS_SGIS = 33067 	# GL/glext.h:1423
GL_MAX_FOG_FUNC_POINTS_SGIS = 33068 	# GL/glext.h:1424
# SGIX_fog_offset (GL/glext.h:1427)
GL_FOG_OFFSET_SGIX = 33176 	# GL/glext.h:1428
GL_FOG_OFFSET_VALUE_SGIX = 33177 	# GL/glext.h:1429
# HP_image_transform (GL/glext.h:1432)
GL_IMAGE_SCALE_X_HP = 33109 	# GL/glext.h:1433
GL_IMAGE_SCALE_Y_HP = 33110 	# GL/glext.h:1434
GL_IMAGE_TRANSLATE_X_HP = 33111 	# GL/glext.h:1435
GL_IMAGE_TRANSLATE_Y_HP = 33112 	# GL/glext.h:1436
GL_IMAGE_ROTATE_ANGLE_HP = 33113 	# GL/glext.h:1437
GL_IMAGE_ROTATE_ORIGIN_X_HP = 33114 	# GL/glext.h:1438
GL_IMAGE_ROTATE_ORIGIN_Y_HP = 33115 	# GL/glext.h:1439
GL_IMAGE_MAG_FILTER_HP = 33116 	# GL/glext.h:1440
GL_IMAGE_MIN_FILTER_HP = 33117 	# GL/glext.h:1441
GL_IMAGE_CUBIC_WEIGHT_HP = 33118 	# GL/glext.h:1442
GL_CUBIC_HP = 33119 	# GL/glext.h:1443
GL_AVERAGE_HP = 33120 	# GL/glext.h:1444
GL_IMAGE_TRANSFORM_2D_HP = 33121 	# GL/glext.h:1445
GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = 33122 	# GL/glext.h:1446
GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = 33123 	# GL/glext.h:1447
# HP_convolution_border_modes (GL/glext.h:1450)
GL_IGNORE_BORDER_HP = 33104 	# GL/glext.h:1451
GL_CONSTANT_BORDER_HP = 33105 	# GL/glext.h:1452
GL_REPLICATE_BORDER_HP = 33107 	# GL/glext.h:1453
GL_CONVOLUTION_BORDER_COLOR_HP = 33108 	# GL/glext.h:1454
# INGR_palette_buffer (GL/glext.h:1457)
# SGIX_texture_add_env (GL/glext.h:1460)
GL_TEXTURE_ENV_BIAS_SGIX = 32958 	# GL/glext.h:1461
# EXT_color_subtable (GL/glext.h:1464)
# PGI_vertex_hints (GL/glext.h:1467)
GL_VERTEX_DATA_HINT_PGI = 107050 	# GL/glext.h:1468
GL_VERTEX_CONSISTENT_HINT_PGI = 107051 	# GL/glext.h:1469
GL_MATERIAL_SIDE_HINT_PGI = 107052 	# GL/glext.h:1470
GL_MAX_VERTEX_HINT_PGI = 107053 	# GL/glext.h:1471
GL_COLOR3_BIT_PGI = 65536 	# GL/glext.h:1472
GL_COLOR4_BIT_PGI = 131072 	# GL/glext.h:1473
GL_EDGEFLAG_BIT_PGI = 262144 	# GL/glext.h:1474
GL_INDEX_BIT_PGI = 524288 	# GL/glext.h:1475
GL_MAT_AMBIENT_BIT_PGI = 1048576 	# GL/glext.h:1476
GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI = 2097152 	# GL/glext.h:1477
GL_MAT_DIFFUSE_BIT_PGI = 4194304 	# GL/glext.h:1478
GL_MAT_EMISSION_BIT_PGI = 8388608 	# GL/glext.h:1479
GL_MAT_COLOR_INDEXES_BIT_PGI = 16777216 	# GL/glext.h:1480
GL_MAT_SHININESS_BIT_PGI = 33554432 	# GL/glext.h:1481
GL_MAT_SPECULAR_BIT_PGI = 67108864 	# GL/glext.h:1482
GL_NORMAL_BIT_PGI = 134217728 	# GL/glext.h:1483
GL_TEXCOORD1_BIT_PGI = 268435456 	# GL/glext.h:1484
GL_TEXCOORD2_BIT_PGI = 536870912 	# GL/glext.h:1485
GL_TEXCOORD3_BIT_PGI = 1073741824 	# GL/glext.h:1486
GL_TEXCOORD4_BIT_PGI = 2147483648 	# GL/glext.h:1487
GL_VERTEX23_BIT_PGI = 4 	# GL/glext.h:1488
GL_VERTEX4_BIT_PGI = 8 	# GL/glext.h:1489
# PGI_misc_hints (GL/glext.h:1492)
GL_PREFER_DOUBLEBUFFER_HINT_PGI = 107000 	# GL/glext.h:1493
GL_CONSERVE_MEMORY_HINT_PGI = 107005 	# GL/glext.h:1494
GL_RECLAIM_MEMORY_HINT_PGI = 107006 	# GL/glext.h:1495
GL_NATIVE_GRAPHICS_HANDLE_PGI = 107010 	# GL/glext.h:1496
GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI = 107011 	# GL/glext.h:1497
GL_NATIVE_GRAPHICS_END_HINT_PGI = 107012 	# GL/glext.h:1498
GL_ALWAYS_FAST_HINT_PGI = 107020 	# GL/glext.h:1499
GL_ALWAYS_SOFT_HINT_PGI = 107021 	# GL/glext.h:1500
GL_ALLOW_DRAW_OBJ_HINT_PGI = 107022 	# GL/glext.h:1501
GL_ALLOW_DRAW_WIN_HINT_PGI = 107023 	# GL/glext.h:1502
GL_ALLOW_DRAW_FRG_HINT_PGI = 107024 	# GL/glext.h:1503
GL_ALLOW_DRAW_MEM_HINT_PGI = 107025 	# GL/glext.h:1504
GL_STRICT_DEPTHFUNC_HINT_PGI = 107030 	# GL/glext.h:1505
GL_STRICT_LIGHTING_HINT_PGI = 107031 	# GL/glext.h:1506
GL_STRICT_SCISSOR_HINT_PGI = 107032 	# GL/glext.h:1507
GL_FULL_STIPPLE_HINT_PGI = 107033 	# GL/glext.h:1508
GL_CLIP_NEAR_HINT_PGI = 107040 	# GL/glext.h:1509
GL_CLIP_FAR_HINT_PGI = 107041 	# GL/glext.h:1510
GL_WIDE_LINE_HINT_PGI = 107042 	# GL/glext.h:1511
GL_BACK_NORMALS_HINT_PGI = 107043 	# GL/glext.h:1512
# EXT_paletted_texture (GL/glext.h:1515)
GL_COLOR_INDEX1_EXT = 32994 	# GL/glext.h:1516
GL_COLOR_INDEX2_EXT = 32995 	# GL/glext.h:1517
GL_COLOR_INDEX4_EXT = 32996 	# GL/glext.h:1518
GL_COLOR_INDEX8_EXT = 32997 	# GL/glext.h:1519
GL_COLOR_INDEX12_EXT = 32998 	# GL/glext.h:1520
GL_COLOR_INDEX16_EXT = 32999 	# GL/glext.h:1521
GL_TEXTURE_INDEX_SIZE_EXT = 33005 	# GL/glext.h:1522
# EXT_clip_volume_hint (GL/glext.h:1525)
GL_CLIP_VOLUME_CLIPPING_HINT_EXT = 33008 	# GL/glext.h:1526
# SGIX_list_priority (GL/glext.h:1529)
GL_LIST_PRIORITY_SGIX = 33154 	# GL/glext.h:1530
# SGIX_ir_instrument1 (GL/glext.h:1533)
GL_IR_INSTRUMENT1_SGIX = 33151 	# GL/glext.h:1534
# SGIX_calligraphic_fragment (GL/glext.h:1537)
GL_CALLIGRAPHIC_FRAGMENT_SGIX = 33155 	# GL/glext.h:1538
# SGIX_texture_lod_bias (GL/glext.h:1541)
GL_TEXTURE_LOD_BIAS_S_SGIX = 33166 	# GL/glext.h:1542
GL_TEXTURE_LOD_BIAS_T_SGIX = 33167 	# GL/glext.h:1543
GL_TEXTURE_LOD_BIAS_R_SGIX = 33168 	# GL/glext.h:1544
# SGIX_shadow_ambient (GL/glext.h:1547)
GL_SHADOW_AMBIENT_SGIX = 32959 	# GL/glext.h:1548
# EXT_index_texture (GL/glext.h:1551)
# EXT_index_material (GL/glext.h:1554)
GL_INDEX_MATERIAL_EXT = 33208 	# GL/glext.h:1555
GL_INDEX_MATERIAL_PARAMETER_EXT = 33209 	# GL/glext.h:1556
GL_INDEX_MATERIAL_FACE_EXT = 33210 	# GL/glext.h:1557
# EXT_index_func (GL/glext.h:1560)
GL_INDEX_TEST_EXT = 33205 	# GL/glext.h:1561
GL_INDEX_TEST_FUNC_EXT = 33206 	# GL/glext.h:1562
GL_INDEX_TEST_REF_EXT = 33207 	# GL/glext.h:1563
# EXT_index_array_formats (GL/glext.h:1566)
GL_IUI_V2F_EXT = 33197 	# GL/glext.h:1567
GL_IUI_V3F_EXT = 33198 	# GL/glext.h:1568
GL_IUI_N3F_V2F_EXT = 33199 	# GL/glext.h:1569
GL_IUI_N3F_V3F_EXT = 33200 	# GL/glext.h:1570
GL_T2F_IUI_V2F_EXT = 33201 	# GL/glext.h:1571
GL_T2F_IUI_V3F_EXT = 33202 	# GL/glext.h:1572
GL_T2F_IUI_N3F_V2F_EXT = 33203 	# GL/glext.h:1573
GL_T2F_IUI_N3F_V3F_EXT = 33204 	# GL/glext.h:1574
# EXT_compiled_vertex_array (GL/glext.h:1577)
GL_ARRAY_ELEMENT_LOCK_FIRST_EXT = 33192 	# GL/glext.h:1578
GL_ARRAY_ELEMENT_LOCK_COUNT_EXT = 33193 	# GL/glext.h:1579
# EXT_cull_vertex (GL/glext.h:1582)
GL_CULL_VERTEX_EXT = 33194 	# GL/glext.h:1583
GL_CULL_VERTEX_EYE_POSITION_EXT = 33195 	# GL/glext.h:1584
GL_CULL_VERTEX_OBJECT_POSITION_EXT = 33196 	# GL/glext.h:1585
# SGIX_ycrcb (GL/glext.h:1588)
GL_YCRCB_422_SGIX = 33211 	# GL/glext.h:1589
GL_YCRCB_444_SGIX = 33212 	# GL/glext.h:1590
# SGIX_fragment_lighting (GL/glext.h:1593)
GL_FRAGMENT_LIGHTING_SGIX = 33792 	# GL/glext.h:1594
GL_FRAGMENT_COLOR_MATERIAL_SGIX = 33793 	# GL/glext.h:1595
GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX = 33794 	# GL/glext.h:1596
GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX = 33795 	# GL/glext.h:1597
GL_MAX_FRAGMENT_LIGHTS_SGIX = 33796 	# GL/glext.h:1598
GL_MAX_ACTIVE_LIGHTS_SGIX = 33797 	# GL/glext.h:1599
GL_CURRENT_RASTER_NORMAL_SGIX = 33798 	# GL/glext.h:1600
GL_LIGHT_ENV_MODE_SGIX = 33799 	# GL/glext.h:1601
GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX = 33800 	# GL/glext.h:1602
GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX = 33801 	# GL/glext.h:1603
GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX = 33802 	# GL/glext.h:1604
GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX = 33803 	# GL/glext.h:1605
GL_FRAGMENT_LIGHT0_SGIX = 33804 	# GL/glext.h:1606
GL_FRAGMENT_LIGHT1_SGIX = 33805 	# GL/glext.h:1607
GL_FRAGMENT_LIGHT2_SGIX = 33806 	# GL/glext.h:1608
GL_FRAGMENT_LIGHT3_SGIX = 33807 	# GL/glext.h:1609
GL_FRAGMENT_LIGHT4_SGIX = 33808 	# GL/glext.h:1610
GL_FRAGMENT_LIGHT5_SGIX = 33809 	# GL/glext.h:1611
GL_FRAGMENT_LIGHT6_SGIX = 33810 	# GL/glext.h:1612
GL_FRAGMENT_LIGHT7_SGIX = 33811 	# GL/glext.h:1613
# IBM_rasterpos_clip (GL/glext.h:1616)
GL_RASTER_POSITION_UNCLIPPED_IBM = 103010 	# GL/glext.h:1617
# HP_texture_lighting (GL/glext.h:1620)
GL_TEXTURE_LIGHTING_MODE_HP = 33127 	# GL/glext.h:1621
GL_TEXTURE_POST_SPECULAR_HP = 33128 	# GL/glext.h:1622
GL_TEXTURE_PRE_SPECULAR_HP = 33129 	# GL/glext.h:1623
# EXT_draw_range_elements (GL/glext.h:1626)
GL_MAX_ELEMENTS_VERTICES_EXT = 33000 	# GL/glext.h:1627
GL_MAX_ELEMENTS_INDICES_EXT = 33001 	# GL/glext.h:1628
# WIN_phong_shading (GL/glext.h:1631)
GL_PHONG_WIN = 33002 	# GL/glext.h:1632
GL_PHONG_HINT_WIN = 33003 	# GL/glext.h:1633
# WIN_specular_fog (GL/glext.h:1636)
GL_FOG_SPECULAR_TEXTURE_WIN = 33004 	# GL/glext.h:1637
# EXT_light_texture (GL/glext.h:1640)
GL_FRAGMENT_MATERIAL_EXT = 33609 	# GL/glext.h:1641
GL_FRAGMENT_NORMAL_EXT = 33610 	# GL/glext.h:1642
GL_FRAGMENT_COLOR_EXT = 33612 	# GL/glext.h:1643
GL_ATTENUATION_EXT = 33613 	# GL/glext.h:1644
GL_SHADOW_ATTENUATION_EXT = 33614 	# GL/glext.h:1645
GL_TEXTURE_APPLICATION_MODE_EXT = 33615 	# GL/glext.h:1646
GL_TEXTURE_LIGHT_EXT = 33616 	# GL/glext.h:1647
GL_TEXTURE_MATERIAL_FACE_EXT = 33617 	# GL/glext.h:1648
GL_TEXTURE_MATERIAL_PARAMETER_EXT = 33618 	# GL/glext.h:1649
# SGIX_blend_alpha_minmax (GL/glext.h:1653)
GL_ALPHA_MIN_SGIX = 33568 	# GL/glext.h:1654
GL_ALPHA_MAX_SGIX = 33569 	# GL/glext.h:1655
# SGIX_impact_pixel_texture (GL/glext.h:1658)
GL_PIXEL_TEX_GEN_Q_CEILING_SGIX = 33156 	# GL/glext.h:1659
GL_PIXEL_TEX_GEN_Q_ROUND_SGIX = 33157 	# GL/glext.h:1660
GL_PIXEL_TEX_GEN_Q_FLOOR_SGIX = 33158 	# GL/glext.h:1661
GL_PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX = 33159 	# GL/glext.h:1662
GL_PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX = 33160 	# GL/glext.h:1663
GL_PIXEL_TEX_GEN_ALPHA_LS_SGIX = 33161 	# GL/glext.h:1664
GL_PIXEL_TEX_GEN_ALPHA_MS_SGIX = 33162 	# GL/glext.h:1665
# EXT_bgra (GL/glext.h:1668)
GL_BGR_EXT = 32992 	# GL/glext.h:1669
GL_BGRA_EXT = 32993 	# GL/glext.h:1670
# SGIX_async (GL/glext.h:1673)
GL_ASYNC_MARKER_SGIX = 33577 	# GL/glext.h:1674
# SGIX_async_pixel (GL/glext.h:1677)
GL_ASYNC_TEX_IMAGE_SGIX = 33628 	# GL/glext.h:1678
GL_ASYNC_DRAW_PIXELS_SGIX = 33629 	# GL/glext.h:1679
GL_ASYNC_READ_PIXELS_SGIX = 33630 	# GL/glext.h:1680
GL_MAX_ASYNC_TEX_IMAGE_SGIX = 33631 	# GL/glext.h:1681
GL_MAX_ASYNC_DRAW_PIXELS_SGIX = 33632 	# GL/glext.h:1682
GL_MAX_ASYNC_READ_PIXELS_SGIX = 33633 	# GL/glext.h:1683
# SGIX_async_histogram (GL/glext.h:1686)
GL_ASYNC_HISTOGRAM_SGIX = 33580 	# GL/glext.h:1687
GL_MAX_ASYNC_HISTOGRAM_SGIX = 33581 	# GL/glext.h:1688
# INTEL_texture_scissor (GL/glext.h:1691)
# INTEL_parallel_arrays (GL/glext.h:1694)
GL_PARALLEL_ARRAYS_INTEL = 33780 	# GL/glext.h:1695
GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL = 33781 	# GL/glext.h:1696
GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL = 33782 	# GL/glext.h:1697
GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL = 33783 	# GL/glext.h:1698
GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL = 33784 	# GL/glext.h:1699
# HP_occlusion_test (GL/glext.h:1702)
GL_OCCLUSION_TEST_HP = 33125 	# GL/glext.h:1703
GL_OCCLUSION_TEST_RESULT_HP = 33126 	# GL/glext.h:1704
# EXT_pixel_transform (GL/glext.h:1707)
GL_PIXEL_TRANSFORM_2D_EXT = 33584 	# GL/glext.h:1708
GL_PIXEL_MAG_FILTER_EXT = 33585 	# GL/glext.h:1709
GL_PIXEL_MIN_FILTER_EXT = 33586 	# GL/glext.h:1710
GL_PIXEL_CUBIC_WEIGHT_EXT = 33587 	# GL/glext.h:1711
GL_CUBIC_EXT = 33588 	# GL/glext.h:1712
GL_AVERAGE_EXT = 33589 	# GL/glext.h:1713
GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = 33590 	# GL/glext.h:1714
GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = 33591 	# GL/glext.h:1715
GL_PIXEL_TRANSFORM_2D_MATRIX_EXT = 33592 	# GL/glext.h:1716
# EXT_pixel_transform_color_table (GL/glext.h:1719)
# EXT_shared_texture_palette (GL/glext.h:1722)
GL_SHARED_TEXTURE_PALETTE_EXT = 33275 	# GL/glext.h:1723
# EXT_separate_specular_color (GL/glext.h:1726)
GL_LIGHT_MODEL_COLOR_CONTROL_EXT = 33272 	# GL/glext.h:1727
GL_SINGLE_COLOR_EXT = 33273 	# GL/glext.h:1728
GL_SEPARATE_SPECULAR_COLOR_EXT = 33274 	# GL/glext.h:1729
# EXT_secondary_color (GL/glext.h:1732)
GL_COLOR_SUM_EXT = 33880 	# GL/glext.h:1733
GL_CURRENT_SECONDARY_COLOR_EXT = 33881 	# GL/glext.h:1734
GL_SECONDARY_COLOR_ARRAY_SIZE_EXT = 33882 	# GL/glext.h:1735
GL_SECONDARY_COLOR_ARRAY_TYPE_EXT = 33883 	# GL/glext.h:1736
GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT = 33884 	# GL/glext.h:1737
GL_SECONDARY_COLOR_ARRAY_POINTER_EXT = 33885 	# GL/glext.h:1738
GL_SECONDARY_COLOR_ARRAY_EXT = 33886 	# GL/glext.h:1739
# EXT_texture_perturb_normal (GL/glext.h:1742)
GL_PERTURB_EXT = 34222 	# GL/glext.h:1743
GL_TEXTURE_NORMAL_EXT = 34223 	# GL/glext.h:1744
# EXT_multi_draw_arrays (GL/glext.h:1747)
# EXT_fog_coord (GL/glext.h:1750)
GL_FOG_COORDINATE_SOURCE_EXT = 33872 	# GL/glext.h:1751
GL_FOG_COORDINATE_EXT = 33873 	# GL/glext.h:1752
GL_FRAGMENT_DEPTH_EXT = 33874 	# GL/glext.h:1753
GL_CURRENT_FOG_COORDINATE_EXT = 33875 	# GL/glext.h:1754
GL_FOG_COORDINATE_ARRAY_TYPE_EXT = 33876 	# GL/glext.h:1755
GL_FOG_COORDINATE_ARRAY_STRIDE_EXT = 33877 	# GL/glext.h:1756
GL_FOG_COORDINATE_ARRAY_POINTER_EXT = 33878 	# GL/glext.h:1757
GL_FOG_COORDINATE_ARRAY_EXT = 33879 	# GL/glext.h:1758
# REND_screen_coordinates (GL/glext.h:1761)
GL_SCREEN_COORDINATES_REND = 33936 	# GL/glext.h:1762
GL_INVERTED_SCREEN_W_REND = 33937 	# GL/glext.h:1763
# EXT_coordinate_frame (GL/glext.h:1766)
GL_TANGENT_ARRAY_EXT = 33849 	# GL/glext.h:1767
GL_BINORMAL_ARRAY_EXT = 33850 	# GL/glext.h:1768
GL_CURRENT_TANGENT_EXT = 33851 	# GL/glext.h:1769
GL_CURRENT_BINORMAL_EXT = 33852 	# GL/glext.h:1770
GL_TANGENT_ARRAY_TYPE_EXT = 33854 	# GL/glext.h:1771
GL_TANGENT_ARRAY_STRIDE_EXT = 33855 	# GL/glext.h:1772
GL_BINORMAL_ARRAY_TYPE_EXT = 33856 	# GL/glext.h:1773
GL_BINORMAL_ARRAY_STRIDE_EXT = 33857 	# GL/glext.h:1774
GL_TANGENT_ARRAY_POINTER_EXT = 33858 	# GL/glext.h:1775
GL_BINORMAL_ARRAY_POINTER_EXT = 33859 	# GL/glext.h:1776
GL_MAP1_TANGENT_EXT = 33860 	# GL/glext.h:1777
GL_MAP2_TANGENT_EXT = 33861 	# GL/glext.h:1778
GL_MAP1_BINORMAL_EXT = 33862 	# GL/glext.h:1779
GL_MAP2_BINORMAL_EXT = 33863 	# GL/glext.h:1780
# EXT_texture_env_combine (GL/glext.h:1783)
GL_COMBINE_EXT = 34160 	# GL/glext.h:1784
GL_COMBINE_RGB_EXT = 34161 	# GL/glext.h:1785
GL_COMBINE_ALPHA_EXT = 34162 	# GL/glext.h:1786
GL_RGB_SCALE_EXT = 34163 	# GL/glext.h:1787
GL_ADD_SIGNED_EXT = 34164 	# GL/glext.h:1788
GL_INTERPOLATE_EXT = 34165 	# GL/glext.h:1789
GL_CONSTANT_EXT = 34166 	# GL/glext.h:1790
GL_PRIMARY_COLOR_EXT = 34167 	# GL/glext.h:1791
GL_PREVIOUS_EXT = 34168 	# GL/glext.h:1792
GL_SOURCE0_RGB_EXT = 34176 	# GL/glext.h:1793
GL_SOURCE1_RGB_EXT = 34177 	# GL/glext.h:1794
GL_SOURCE2_RGB_EXT = 34178 	# GL/glext.h:1795
GL_SOURCE0_ALPHA_EXT = 34184 	# GL/glext.h:1796
GL_SOURCE1_ALPHA_EXT = 34185 	# GL/glext.h:1797
GL_SOURCE2_ALPHA_EXT = 34186 	# GL/glext.h:1798
GL_OPERAND0_RGB_EXT = 34192 	# GL/glext.h:1799
GL_OPERAND1_RGB_EXT = 34193 	# GL/glext.h:1800
GL_OPERAND2_RGB_EXT = 34194 	# GL/glext.h:1801
GL_OPERAND0_ALPHA_EXT = 34200 	# GL/glext.h:1802
GL_OPERAND1_ALPHA_EXT = 34201 	# GL/glext.h:1803
GL_OPERAND2_ALPHA_EXT = 34202 	# GL/glext.h:1804
# APPLE_specular_vector (GL/glext.h:1807)
GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE = 34224 	# GL/glext.h:1808
# APPLE_transform_hint (GL/glext.h:1811)
GL_TRANSFORM_HINT_APPLE = 34225 	# GL/glext.h:1812
# SGIX_fog_scale (GL/glext.h:1815)
GL_FOG_SCALE_SGIX = 33276 	# GL/glext.h:1816
GL_FOG_SCALE_VALUE_SGIX = 33277 	# GL/glext.h:1817
# SUNX_constant_data (GL/glext.h:1820)
GL_UNPACK_CONSTANT_DATA_SUNX = 33237 	# GL/glext.h:1821
GL_TEXTURE_CONSTANT_DATA_SUNX = 33238 	# GL/glext.h:1822
# SUN_global_alpha (GL/glext.h:1825)
GL_GLOBAL_ALPHA_SUN = 33241 	# GL/glext.h:1826
GL_GLOBAL_ALPHA_FACTOR_SUN = 33242 	# GL/glext.h:1827
# SUN_triangle_list (GL/glext.h:1830)
GL_RESTART_SUN = 1 	# GL/glext.h:1831
GL_REPLACE_MIDDLE_SUN = 2 	# GL/glext.h:1832
GL_REPLACE_OLDEST_SUN = 3 	# GL/glext.h:1833
GL_TRIANGLE_LIST_SUN = 33239 	# GL/glext.h:1834
GL_REPLACEMENT_CODE_SUN = 33240 	# GL/glext.h:1835
GL_REPLACEMENT_CODE_ARRAY_SUN = 34240 	# GL/glext.h:1836
GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN = 34241 	# GL/glext.h:1837
GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN = 34242 	# GL/glext.h:1838
GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN = 34243 	# GL/glext.h:1839
GL_R1UI_V3F_SUN = 34244 	# GL/glext.h:1840
GL_R1UI_C4UB_V3F_SUN = 34245 	# GL/glext.h:1841
GL_R1UI_C3F_V3F_SUN = 34246 	# GL/glext.h:1842
GL_R1UI_N3F_V3F_SUN = 34247 	# GL/glext.h:1843
GL_R1UI_C4F_N3F_V3F_SUN = 34248 	# GL/glext.h:1844
GL_R1UI_T2F_V3F_SUN = 34249 	# GL/glext.h:1845
GL_R1UI_T2F_N3F_V3F_SUN = 34250 	# GL/glext.h:1846
GL_R1UI_T2F_C4F_N3F_V3F_SUN = 34251 	# GL/glext.h:1847
# SUN_vertex (GL/glext.h:1850)
# EXT_blend_func_separate (GL/glext.h:1853)
GL_BLEND_DST_RGB_EXT = 32968 	# GL/glext.h:1854
GL_BLEND_SRC_RGB_EXT = 32969 	# GL/glext.h:1855
GL_BLEND_DST_ALPHA_EXT = 32970 	# GL/glext.h:1856
GL_BLEND_SRC_ALPHA_EXT = 32971 	# GL/glext.h:1857
# INGR_color_clamp (GL/glext.h:1860)
GL_RED_MIN_CLAMP_INGR = 34144 	# GL/glext.h:1861
GL_GREEN_MIN_CLAMP_INGR = 34145 	# GL/glext.h:1862
GL_BLUE_MIN_CLAMP_INGR = 34146 	# GL/glext.h:1863
GL_ALPHA_MIN_CLAMP_INGR = 34147 	# GL/glext.h:1864
GL_RED_MAX_CLAMP_INGR = 34148 	# GL/glext.h:1865
GL_GREEN_MAX_CLAMP_INGR = 34149 	# GL/glext.h:1866
GL_BLUE_MAX_CLAMP_INGR = 34150 	# GL/glext.h:1867
GL_ALPHA_MAX_CLAMP_INGR = 34151 	# GL/glext.h:1868
# INGR_interlace_read (GL/glext.h:1871)
GL_INTERLACE_READ_INGR = 34152 	# GL/glext.h:1872
# EXT_stencil_wrap (GL/glext.h:1875)
GL_INCR_WRAP_EXT = 34055 	# GL/glext.h:1876
GL_DECR_WRAP_EXT = 34056 	# GL/glext.h:1877
# EXT_422_pixels (GL/glext.h:1880)
GL_422_EXT = 32972 	# GL/glext.h:1881
GL_422_REV_EXT = 32973 	# GL/glext.h:1882
GL_422_AVERAGE_EXT = 32974 	# GL/glext.h:1883
GL_422_REV_AVERAGE_EXT = 32975 	# GL/glext.h:1884
# NV_texgen_reflection (GL/glext.h:1887)
GL_NORMAL_MAP_NV = 34065 	# GL/glext.h:1888
GL_REFLECTION_MAP_NV = 34066 	# GL/glext.h:1889
# EXT_texture_cube_map (GL/glext.h:1892)
GL_NORMAL_MAP_EXT = 34065 	# GL/glext.h:1893
GL_REFLECTION_MAP_EXT = 34066 	# GL/glext.h:1894
GL_TEXTURE_CUBE_MAP_EXT = 34067 	# GL/glext.h:1895
GL_TEXTURE_BINDING_CUBE_MAP_EXT = 34068 	# GL/glext.h:1896
GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT = 34069 	# GL/glext.h:1897
GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT = 34070 	# GL/glext.h:1898
GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT = 34071 	# GL/glext.h:1899
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT = 34072 	# GL/glext.h:1900
GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT = 34073 	# GL/glext.h:1901
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT = 34074 	# GL/glext.h:1902
GL_PROXY_TEXTURE_CUBE_MAP_EXT = 34075 	# GL/glext.h:1903
GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT = 34076 	# GL/glext.h:1904
# SUN_convolution_border_modes (GL/glext.h:1907)
GL_WRAP_BORDER_SUN = 33236 	# GL/glext.h:1908
# EXT_texture_env_add (GL/glext.h:1911)
# EXT_texture_lod_bias (GL/glext.h:1914)
GL_MAX_TEXTURE_LOD_BIAS_EXT = 34045 	# GL/glext.h:1915
GL_TEXTURE_FILTER_CONTROL_EXT = 34048 	# GL/glext.h:1916
GL_TEXTURE_LOD_BIAS_EXT = 34049 	# GL/glext.h:1917
# EXT_texture_filter_anisotropic (GL/glext.h:1920)
GL_TEXTURE_MAX_ANISOTROPY_EXT = 34046 	# GL/glext.h:1921
GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047 	# GL/glext.h:1922
# EXT_vertex_weighting (GL/glext.h:1925)
GL_MODELVIEW0_STACK_DEPTH_EXT = 0 	# GL/glext.h:1926
GL_MODELVIEW1_STACK_DEPTH_EXT = 34050 	# GL/glext.h:1927
GL_MODELVIEW0_MATRIX_EXT = 0 	# GL/glext.h:1928
GL_MODELVIEW1_MATRIX_EXT = 34054 	# GL/glext.h:1929
GL_VERTEX_WEIGHTING_EXT = 34057 	# GL/glext.h:1930
GL_MODELVIEW0_EXT = 0 	# GL/glext.h:1931
GL_MODELVIEW1_EXT = 34058 	# GL/glext.h:1932
GL_CURRENT_VERTEX_WEIGHT_EXT = 34059 	# GL/glext.h:1933
GL_VERTEX_WEIGHT_ARRAY_EXT = 34060 	# GL/glext.h:1934
GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT = 34061 	# GL/glext.h:1935
GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT = 34062 	# GL/glext.h:1936
GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT = 34063 	# GL/glext.h:1937
GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT = 34064 	# GL/glext.h:1938
# NV_light_max_exponent (GL/glext.h:1941)
GL_MAX_SHININESS_NV = 34052 	# GL/glext.h:1942
GL_MAX_SPOT_EXPONENT_NV = 34053 	# GL/glext.h:1943
# NV_vertex_array_range (GL/glext.h:1946)
GL_VERTEX_ARRAY_RANGE_NV = 34077 	# GL/glext.h:1947
GL_VERTEX_ARRAY_RANGE_LENGTH_NV = 34078 	# GL/glext.h:1948
GL_VERTEX_ARRAY_RANGE_VALID_NV = 34079 	# GL/glext.h:1949
GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV = 34080 	# GL/glext.h:1950
GL_VERTEX_ARRAY_RANGE_POINTER_NV = 34081 	# GL/glext.h:1951
# NV_register_combiners (GL/glext.h:1954)
GL_REGISTER_COMBINERS_NV = 34082 	# GL/glext.h:1955
GL_VARIABLE_A_NV = 34083 	# GL/glext.h:1956
GL_VARIABLE_B_NV = 34084 	# GL/glext.h:1957
GL_VARIABLE_C_NV = 34085 	# GL/glext.h:1958
GL_VARIABLE_D_NV = 34086 	# GL/glext.h:1959
GL_VARIABLE_E_NV = 34087 	# GL/glext.h:1960
GL_VARIABLE_F_NV = 34088 	# GL/glext.h:1961
GL_VARIABLE_G_NV = 34089 	# GL/glext.h:1962
GL_CONSTANT_COLOR0_NV = 34090 	# GL/glext.h:1963
GL_CONSTANT_COLOR1_NV = 34091 	# GL/glext.h:1964
GL_PRIMARY_COLOR_NV = 34092 	# GL/glext.h:1965
GL_SECONDARY_COLOR_NV = 34093 	# GL/glext.h:1966
GL_SPARE0_NV = 34094 	# GL/glext.h:1967
GL_SPARE1_NV = 34095 	# GL/glext.h:1968
GL_DISCARD_NV = 34096 	# GL/glext.h:1969
GL_E_TIMES_F_NV = 34097 	# GL/glext.h:1970
GL_SPARE0_PLUS_SECONDARY_COLOR_NV = 34098 	# GL/glext.h:1971
GL_UNSIGNED_IDENTITY_NV = 34102 	# GL/glext.h:1972
GL_UNSIGNED_INVERT_NV = 34103 	# GL/glext.h:1973
GL_EXPAND_NORMAL_NV = 34104 	# GL/glext.h:1974
GL_EXPAND_NEGATE_NV = 34105 	# GL/glext.h:1975
GL_HALF_BIAS_NORMAL_NV = 34106 	# GL/glext.h:1976
GL_HALF_BIAS_NEGATE_NV = 34107 	# GL/glext.h:1977
GL_SIGNED_IDENTITY_NV = 34108 	# GL/glext.h:1978
GL_SIGNED_NEGATE_NV = 34109 	# GL/glext.h:1979
GL_SCALE_BY_TWO_NV = 34110 	# GL/glext.h:1980
GL_SCALE_BY_FOUR_NV = 34111 	# GL/glext.h:1981
GL_SCALE_BY_ONE_HALF_NV = 34112 	# GL/glext.h:1982
GL_BIAS_BY_NEGATIVE_ONE_HALF_NV = 34113 	# GL/glext.h:1983
GL_COMBINER_INPUT_NV = 34114 	# GL/glext.h:1984
GL_COMBINER_MAPPING_NV = 34115 	# GL/glext.h:1985
GL_COMBINER_COMPONENT_USAGE_NV = 34116 	# GL/glext.h:1986
GL_COMBINER_AB_DOT_PRODUCT_NV = 34117 	# GL/glext.h:1987
GL_COMBINER_CD_DOT_PRODUCT_NV = 34118 	# GL/glext.h:1988
GL_COMBINER_MUX_SUM_NV = 34119 	# GL/glext.h:1989
GL_COMBINER_SCALE_NV = 34120 	# GL/glext.h:1990
GL_COMBINER_BIAS_NV = 34121 	# GL/glext.h:1991
GL_COMBINER_AB_OUTPUT_NV = 34122 	# GL/glext.h:1992
GL_COMBINER_CD_OUTPUT_NV = 34123 	# GL/glext.h:1993
GL_COMBINER_SUM_OUTPUT_NV = 34124 	# GL/glext.h:1994
GL_MAX_GENERAL_COMBINERS_NV = 34125 	# GL/glext.h:1995
GL_NUM_GENERAL_COMBINERS_NV = 34126 	# GL/glext.h:1996
GL_COLOR_SUM_CLAMP_NV = 34127 	# GL/glext.h:1997
GL_COMBINER0_NV = 34128 	# GL/glext.h:1998
GL_COMBINER1_NV = 34129 	# GL/glext.h:1999
GL_COMBINER2_NV = 34130 	# GL/glext.h:2000
GL_COMBINER3_NV = 34131 	# GL/glext.h:2001
GL_COMBINER4_NV = 34132 	# GL/glext.h:2002
GL_COMBINER5_NV = 34133 	# GL/glext.h:2003
GL_COMBINER6_NV = 34134 	# GL/glext.h:2004
GL_COMBINER7_NV = 34135 	# GL/glext.h:2005
# NV_fog_distance (GL/glext.h:2013)
GL_FOG_DISTANCE_MODE_NV = 34138 	# GL/glext.h:2014
GL_EYE_RADIAL_NV = 34139 	# GL/glext.h:2015
GL_EYE_PLANE_ABSOLUTE_NV = 34140 	# GL/glext.h:2016
# NV_texgen_emboss (GL/glext.h:2020)
GL_EMBOSS_LIGHT_NV = 34141 	# GL/glext.h:2021
GL_EMBOSS_CONSTANT_NV = 34142 	# GL/glext.h:2022
GL_EMBOSS_MAP_NV = 34143 	# GL/glext.h:2023
# NV_blend_square (GL/glext.h:2026)
# NV_texture_env_combine4 (GL/glext.h:2029)
GL_COMBINE4_NV = 34051 	# GL/glext.h:2030
GL_SOURCE3_RGB_NV = 34179 	# GL/glext.h:2031
GL_SOURCE3_ALPHA_NV = 34187 	# GL/glext.h:2032
GL_OPERAND3_RGB_NV = 34195 	# GL/glext.h:2033
GL_OPERAND3_ALPHA_NV = 34203 	# GL/glext.h:2034
# MESA_resize_buffers (GL/glext.h:2037)
# MESA_window_pos (GL/glext.h:2040)
# EXT_texture_compression_s3tc (GL/glext.h:2043)
GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 33776 	# GL/glext.h:2044
GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777 	# GL/glext.h:2045
GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778 	# GL/glext.h:2046
GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779 	# GL/glext.h:2047
# IBM_cull_vertex (GL/glext.h:2050)
GL_CULL_VERTEX_IBM = 103050 	# GL/glext.h:2051
# IBM_multimode_draw_arrays (GL/glext.h:2054)
# IBM_vertex_array_lists (GL/glext.h:2057)
GL_VERTEX_ARRAY_LIST_IBM = 103070 	# GL/glext.h:2058
GL_NORMAL_ARRAY_LIST_IBM = 103071 	# GL/glext.h:2059
GL_COLOR_ARRAY_LIST_IBM = 103072 	# GL/glext.h:2060
GL_INDEX_ARRAY_LIST_IBM = 103073 	# GL/glext.h:2061
GL_TEXTURE_COORD_ARRAY_LIST_IBM = 103074 	# GL/glext.h:2062
GL_EDGE_FLAG_ARRAY_LIST_IBM = 103075 	# GL/glext.h:2063
GL_FOG_COORDINATE_ARRAY_LIST_IBM = 103076 	# GL/glext.h:2064
GL_SECONDARY_COLOR_ARRAY_LIST_IBM = 103077 	# GL/glext.h:2065
GL_VERTEX_ARRAY_LIST_STRIDE_IBM = 103080 	# GL/glext.h:2066
GL_NORMAL_ARRAY_LIST_STRIDE_IBM = 103081 	# GL/glext.h:2067
GL_COLOR_ARRAY_LIST_STRIDE_IBM = 103082 	# GL/glext.h:2068
GL_INDEX_ARRAY_LIST_STRIDE_IBM = 103083 	# GL/glext.h:2069
GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM = 103084 	# GL/glext.h:2070
GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM = 103085 	# GL/glext.h:2071
GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM = 103086 	# GL/glext.h:2072
GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM = 103087 	# GL/glext.h:2073
# SGIX_subsample (GL/glext.h:2076)
GL_PACK_SUBSAMPLE_RATE_SGIX = 34208 	# GL/glext.h:2077
GL_UNPACK_SUBSAMPLE_RATE_SGIX = 34209 	# GL/glext.h:2078
GL_PIXEL_SUBSAMPLE_4444_SGIX = 34210 	# GL/glext.h:2079
GL_PIXEL_SUBSAMPLE_2424_SGIX = 34211 	# GL/glext.h:2080
GL_PIXEL_SUBSAMPLE_4242_SGIX = 34212 	# GL/glext.h:2081
# SGIX_ycrcb_subsample (GL/glext.h:2084)
# SGIX_ycrcba (GL/glext.h:2087)
GL_YCRCB_SGIX = 33560 	# GL/glext.h:2088
GL_YCRCBA_SGIX = 33561 	# GL/glext.h:2089
# SGI_depth_pass_instrument (GL/glext.h:2092)
GL_DEPTH_PASS_INSTRUMENT_SGIX = 33552 	# GL/glext.h:2093
GL_DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX = 33553 	# GL/glext.h:2094
GL_DEPTH_PASS_INSTRUMENT_MAX_SGIX = 33554 	# GL/glext.h:2095
# 3DFX_texture_compression_FXT1 (GL/glext.h:2098)
GL_COMPRESSED_RGB_FXT1_3DFX = 34480 	# GL/glext.h:2099
GL_COMPRESSED_RGBA_FXT1_3DFX = 34481 	# GL/glext.h:2100
# 3DFX_multisample (GL/glext.h:2103)
GL_MULTISAMPLE_3DFX = 34482 	# GL/glext.h:2104
GL_SAMPLE_BUFFERS_3DFX = 34483 	# GL/glext.h:2105
GL_SAMPLES_3DFX = 34484 	# GL/glext.h:2106
GL_MULTISAMPLE_BIT_3DFX = 536870912 	# GL/glext.h:2107
# 3DFX_tbuffer (GL/glext.h:2110)
# EXT_multisample (GL/glext.h:2113)
GL_MULTISAMPLE_EXT = 32925 	# GL/glext.h:2114
GL_SAMPLE_ALPHA_TO_MASK_EXT = 32926 	# GL/glext.h:2115
GL_SAMPLE_ALPHA_TO_ONE_EXT = 32927 	# GL/glext.h:2116
GL_SAMPLE_MASK_EXT = 32928 	# GL/glext.h:2117
GL_1PASS_EXT = 32929 	# GL/glext.h:2118
GL_2PASS_0_EXT = 32930 	# GL/glext.h:2119
GL_2PASS_1_EXT = 32931 	# GL/glext.h:2120
GL_4PASS_0_EXT = 32932 	# GL/glext.h:2121
GL_4PASS_1_EXT = 32933 	# GL/glext.h:2122
GL_4PASS_2_EXT = 32934 	# GL/glext.h:2123
GL_4PASS_3_EXT = 32935 	# GL/glext.h:2124
GL_SAMPLE_BUFFERS_EXT = 32936 	# GL/glext.h:2125
GL_SAMPLES_EXT = 32937 	# GL/glext.h:2126
GL_SAMPLE_MASK_VALUE_EXT = 32938 	# GL/glext.h:2127
GL_SAMPLE_MASK_INVERT_EXT = 32939 	# GL/glext.h:2128
GL_SAMPLE_PATTERN_EXT = 32940 	# GL/glext.h:2129
GL_MULTISAMPLE_BIT_EXT = 536870912 	# GL/glext.h:2130
# SGIX_vertex_preclip (GL/glext.h:2133)
GL_VERTEX_PRECLIP_SGIX = 33774 	# GL/glext.h:2134
GL_VERTEX_PRECLIP_HINT_SGIX = 33775 	# GL/glext.h:2135
# SGIX_convolution_accuracy (GL/glext.h:2138)
GL_CONVOLUTION_HINT_SGIX = 33558 	# GL/glext.h:2139
# SGIX_resample (GL/glext.h:2142)
GL_PACK_RESAMPLE_SGIX = 33836 	# GL/glext.h:2143
GL_UNPACK_RESAMPLE_SGIX = 33837 	# GL/glext.h:2144
GL_RESAMPLE_REPLICATE_SGIX = 33838 	# GL/glext.h:2145
GL_RESAMPLE_ZERO_FILL_SGIX = 33839 	# GL/glext.h:2146
GL_RESAMPLE_DECIMATE_SGIX = 33840 	# GL/glext.h:2147
# SGIS_point_line_texgen (GL/glext.h:2150)
GL_EYE_DISTANCE_TO_POINT_SGIS = 33264 	# GL/glext.h:2151
GL_OBJECT_DISTANCE_TO_POINT_SGIS = 33265 	# GL/glext.h:2152
GL_EYE_DISTANCE_TO_LINE_SGIS = 33266 	# GL/glext.h:2153
GL_OBJECT_DISTANCE_TO_LINE_SGIS = 33267 	# GL/glext.h:2154
GL_EYE_POINT_SGIS = 33268 	# GL/glext.h:2155
GL_OBJECT_POINT_SGIS = 33269 	# GL/glext.h:2156
GL_EYE_LINE_SGIS = 33270 	# GL/glext.h:2157
GL_OBJECT_LINE_SGIS = 33271 	# GL/glext.h:2158
# SGIS_texture_color_mask (GL/glext.h:2161)
GL_TEXTURE_COLOR_WRITEMASK_SGIS = 33263 	# GL/glext.h:2162
# EXT_texture_env_dot3 (GL/glext.h:2165)
GL_DOT3_RGB_EXT = 34624 	# GL/glext.h:2166
GL_DOT3_RGBA_EXT = 34625 	# GL/glext.h:2167
# ATI_texture_mirror_once (GL/glext.h:2170)
GL_MIRROR_CLAMP_ATI = 34626 	# GL/glext.h:2171
GL_MIRROR_CLAMP_TO_EDGE_ATI = 34627 	# GL/glext.h:2172
# NV_fence (GL/glext.h:2175)
GL_ALL_COMPLETED_NV = 34034 	# GL/glext.h:2176
GL_FENCE_STATUS_NV = 34035 	# GL/glext.h:2177
GL_FENCE_CONDITION_NV = 34036 	# GL/glext.h:2178
# IBM_texture_mirrored_repeat (GL/glext.h:2181)
GL_MIRRORED_REPEAT_IBM = 33648 	# GL/glext.h:2182
# NV_evaluators (GL/glext.h:2185)
GL_EVAL_2D_NV = 34496 	# GL/glext.h:2186
GL_EVAL_TRIANGULAR_2D_NV = 34497 	# GL/glext.h:2187
GL_MAP_TESSELLATION_NV = 34498 	# GL/glext.h:2188
GL_MAP_ATTRIB_U_ORDER_NV = 34499 	# GL/glext.h:2189
GL_MAP_ATTRIB_V_ORDER_NV = 34500 	# GL/glext.h:2190
GL_EVAL_FRACTIONAL_TESSELLATION_NV = 34501 	# GL/glext.h:2191
GL_EVAL_VERTEX_ATTRIB0_NV = 34502 	# GL/glext.h:2192
GL_EVAL_VERTEX_ATTRIB1_NV = 34503 	# GL/glext.h:2193
GL_EVAL_VERTEX_ATTRIB2_NV = 34504 	# GL/glext.h:2194
GL_EVAL_VERTEX_ATTRIB3_NV = 34505 	# GL/glext.h:2195
GL_EVAL_VERTEX_ATTRIB4_NV = 34506 	# GL/glext.h:2196
GL_EVAL_VERTEX_ATTRIB5_NV = 34507 	# GL/glext.h:2197
GL_EVAL_VERTEX_ATTRIB6_NV = 34508 	# GL/glext.h:2198
GL_EVAL_VERTEX_ATTRIB7_NV = 34509 	# GL/glext.h:2199
GL_EVAL_VERTEX_ATTRIB8_NV = 34510 	# GL/glext.h:2200
GL_EVAL_VERTEX_ATTRIB9_NV = 34511 	# GL/glext.h:2201
GL_EVAL_VERTEX_ATTRIB10_NV = 34512 	# GL/glext.h:2202
GL_EVAL_VERTEX_ATTRIB11_NV = 34513 	# GL/glext.h:2203
GL_EVAL_VERTEX_ATTRIB12_NV = 34514 	# GL/glext.h:2204
GL_EVAL_VERTEX_ATTRIB13_NV = 34515 	# GL/glext.h:2205
GL_EVAL_VERTEX_ATTRIB14_NV = 34516 	# GL/glext.h:2206
GL_EVAL_VERTEX_ATTRIB15_NV = 34517 	# GL/glext.h:2207
GL_MAX_MAP_TESSELLATION_NV = 34518 	# GL/glext.h:2208
GL_MAX_RATIONAL_EVAL_ORDER_NV = 34519 	# GL/glext.h:2209
# NV_packed_depth_stencil (GL/glext.h:2212)
GL_DEPTH_STENCIL_NV = 34041 	# GL/glext.h:2213
GL_UNSIGNED_INT_24_8_NV = 34042 	# GL/glext.h:2214
# NV_register_combiners2 (GL/glext.h:2217)
GL_PER_STAGE_CONSTANTS_NV = 34101 	# GL/glext.h:2218
# NV_texture_compression_vtc (GL/glext.h:2221)
# NV_texture_rectangle (GL/glext.h:2224)
GL_TEXTURE_RECTANGLE_NV = 34037 	# GL/glext.h:2225
GL_TEXTURE_BINDING_RECTANGLE_NV = 34038 	# GL/glext.h:2226
GL_PROXY_TEXTURE_RECTANGLE_NV = 34039 	# GL/glext.h:2227
GL_MAX_RECTANGLE_TEXTURE_SIZE_NV = 34040 	# GL/glext.h:2228
# NV_texture_shader (GL/glext.h:2231)
GL_OFFSET_TEXTURE_RECTANGLE_NV = 34380 	# GL/glext.h:2232
GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV = 34381 	# GL/glext.h:2233
GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV = 34382 	# GL/glext.h:2234
GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV = 34521 	# GL/glext.h:2235
GL_UNSIGNED_INT_S8_S8_8_8_NV = 34522 	# GL/glext.h:2236
GL_UNSIGNED_INT_8_8_S8_S8_REV_NV = 34523 	# GL/glext.h:2237
GL_DSDT_MAG_INTENSITY_NV = 34524 	# GL/glext.h:2238
GL_SHADER_CONSISTENT_NV = 34525 	# GL/glext.h:2239
GL_TEXTURE_SHADER_NV = 34526 	# GL/glext.h:2240
GL_SHADER_OPERATION_NV = 34527 	# GL/glext.h:2241
GL_CULL_MODES_NV = 34528 	# GL/glext.h:2242
GL_OFFSET_TEXTURE_MATRIX_NV = 34529 	# GL/glext.h:2243
GL_OFFSET_TEXTURE_SCALE_NV = 34530 	# GL/glext.h:2244
GL_OFFSET_TEXTURE_BIAS_NV = 34531 	# GL/glext.h:2245
GL_OFFSET_TEXTURE_2D_MATRIX_NV = 34529 	# GL/glext.h:2246
GL_OFFSET_TEXTURE_2D_SCALE_NV = 34530 	# GL/glext.h:2247
GL_OFFSET_TEXTURE_2D_BIAS_NV = 34531 	# GL/glext.h:2248
GL_PREVIOUS_TEXTURE_INPUT_NV = 34532 	# GL/glext.h:2249
GL_CONST_EYE_NV = 34533 	# GL/glext.h:2250
GL_PASS_THROUGH_NV = 34534 	# GL/glext.h:2251
GL_CULL_FRAGMENT_NV = 34535 	# GL/glext.h:2252
GL_OFFSET_TEXTURE_2D_NV = 34536 	# GL/glext.h:2253
GL_DEPENDENT_AR_TEXTURE_2D_NV = 34537 	# GL/glext.h:2254
GL_DEPENDENT_GB_TEXTURE_2D_NV = 34538 	# GL/glext.h:2255
GL_DOT_PRODUCT_NV = 34540 	# GL/glext.h:2256
GL_DOT_PRODUCT_DEPTH_REPLACE_NV = 34541 	# GL/glext.h:2257
GL_DOT_PRODUCT_TEXTURE_2D_NV = 34542 	# GL/glext.h:2258
GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV = 34544 	# GL/glext.h:2259
GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV = 34545 	# GL/glext.h:2260
GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV = 34546 	# GL/glext.h:2261
GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV = 34547 	# GL/glext.h:2262
GL_HILO_NV = 34548 	# GL/glext.h:2263
GL_DSDT_NV = 34549 	# GL/glext.h:2264
GL_DSDT_MAG_NV = 34550 	# GL/glext.h:2265
GL_DSDT_MAG_VIB_NV = 34551 	# GL/glext.h:2266
GL_HILO16_NV = 34552 	# GL/glext.h:2267
GL_SIGNED_HILO_NV = 34553 	# GL/glext.h:2268
GL_SIGNED_HILO16_NV = 34554 	# GL/glext.h:2269
GL_SIGNED_RGBA_NV = 34555 	# GL/glext.h:2270
GL_SIGNED_RGBA8_NV = 34556 	# GL/glext.h:2271
GL_SIGNED_RGB_NV = 34558 	# GL/glext.h:2272
GL_SIGNED_RGB8_NV = 34559 	# GL/glext.h:2273
GL_SIGNED_LUMINANCE_NV = 34561 	# GL/glext.h:2274
GL_SIGNED_LUMINANCE8_NV = 34562 	# GL/glext.h:2275
GL_SIGNED_LUMINANCE_ALPHA_NV = 34563 	# GL/glext.h:2276
GL_SIGNED_LUMINANCE8_ALPHA8_NV = 34564 	# GL/glext.h:2277
GL_SIGNED_ALPHA_NV = 34565 	# GL/glext.h:2278
GL_SIGNED_ALPHA8_NV = 34566 	# GL/glext.h:2279
GL_SIGNED_INTENSITY_NV = 34567 	# GL/glext.h:2280
GL_SIGNED_INTENSITY8_NV = 34568 	# GL/glext.h:2281
GL_DSDT8_NV = 34569 	# GL/glext.h:2282
GL_DSDT8_MAG8_NV = 34570 	# GL/glext.h:2283
GL_DSDT8_MAG8_INTENSITY8_NV = 34571 	# GL/glext.h:2284
GL_SIGNED_RGB_UNSIGNED_ALPHA_NV = 34572 	# GL/glext.h:2285
GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV = 34573 	# GL/glext.h:2286
GL_HI_SCALE_NV = 34574 	# GL/glext.h:2287
GL_LO_SCALE_NV = 34575 	# GL/glext.h:2288
GL_DS_SCALE_NV = 34576 	# GL/glext.h:2289
GL_DT_SCALE_NV = 34577 	# GL/glext.h:2290
GL_MAGNITUDE_SCALE_NV = 34578 	# GL/glext.h:2291
GL_VIBRANCE_SCALE_NV = 34579 	# GL/glext.h:2292
GL_HI_BIAS_NV = 34580 	# GL/glext.h:2293
GL_LO_BIAS_NV = 34581 	# GL/glext.h:2294
GL_DS_BIAS_NV = 34582 	# GL/glext.h:2295
GL_DT_BIAS_NV = 34583 	# GL/glext.h:2296
GL_MAGNITUDE_BIAS_NV = 34584 	# GL/glext.h:2297
GL_VIBRANCE_BIAS_NV = 34585 	# GL/glext.h:2298
GL_TEXTURE_BORDER_VALUES_NV = 34586 	# GL/glext.h:2299
GL_TEXTURE_HI_SIZE_NV = 34587 	# GL/glext.h:2300
GL_TEXTURE_LO_SIZE_NV = 34588 	# GL/glext.h:2301
GL_TEXTURE_DS_SIZE_NV = 34589 	# GL/glext.h:2302
GL_TEXTURE_DT_SIZE_NV = 34590 	# GL/glext.h:2303
GL_TEXTURE_MAG_SIZE_NV = 34591 	# GL/glext.h:2304
# NV_texture_shader2 (GL/glext.h:2307)
GL_DOT_PRODUCT_TEXTURE_3D_NV = 34543 	# GL/glext.h:2308
# NV_vertex_array_range2 (GL/glext.h:2311)
GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV = 34099 	# GL/glext.h:2312
# NV_vertex_program (GL/glext.h:2315)
GL_VERTEX_PROGRAM_NV = 34336 	# GL/glext.h:2316
GL_VERTEX_STATE_PROGRAM_NV = 34337 	# GL/glext.h:2317
GL_ATTRIB_ARRAY_SIZE_NV = 34339 	# GL/glext.h:2318
GL_ATTRIB_ARRAY_STRIDE_NV = 34340 	# GL/glext.h:2319
GL_ATTRIB_ARRAY_TYPE_NV = 34341 	# GL/glext.h:2320
GL_CURRENT_ATTRIB_NV = 34342 	# GL/glext.h:2321
GL_PROGRAM_LENGTH_NV = 34343 	# GL/glext.h:2322
GL_PROGRAM_STRING_NV = 34344 	# GL/glext.h:2323
GL_MODELVIEW_PROJECTION_NV = 34345 	# GL/glext.h:2324
GL_IDENTITY_NV = 34346 	# GL/glext.h:2325
GL_INVERSE_NV = 34347 	# GL/glext.h:2326
GL_TRANSPOSE_NV = 34348 	# GL/glext.h:2327
GL_INVERSE_TRANSPOSE_NV = 34349 	# GL/glext.h:2328
GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV = 34350 	# GL/glext.h:2329
GL_MAX_TRACK_MATRICES_NV = 34351 	# GL/glext.h:2330
GL_MATRIX0_NV = 34352 	# GL/glext.h:2331
GL_MATRIX1_NV = 34353 	# GL/glext.h:2332
GL_MATRIX2_NV = 34354 	# GL/glext.h:2333
GL_MATRIX3_NV = 34355 	# GL/glext.h:2334
GL_MATRIX4_NV = 34356 	# GL/glext.h:2335
GL_MATRIX5_NV = 34357 	# GL/glext.h:2336
GL_MATRIX6_NV = 34358 	# GL/glext.h:2337
GL_MATRIX7_NV = 34359 	# GL/glext.h:2338
GL_CURRENT_MATRIX_STACK_DEPTH_NV = 34368 	# GL/glext.h:2339
GL_CURRENT_MATRIX_NV = 34369 	# GL/glext.h:2340
GL_VERTEX_PROGRAM_POINT_SIZE_NV = 34370 	# GL/glext.h:2341
GL_VERTEX_PROGRAM_TWO_SIDE_NV = 34371 	# GL/glext.h:2342
GL_PROGRAM_PARAMETER_NV = 34372 	# GL/glext.h:2343
GL_ATTRIB_ARRAY_POINTER_NV = 34373 	# GL/glext.h:2344
GL_PROGRAM_TARGET_NV = 34374 	# GL/glext.h:2345
GL_PROGRAM_RESIDENT_NV = 34375 	# GL/glext.h:2346
GL_TRACK_MATRIX_NV = 34376 	# GL/glext.h:2347
GL_TRACK_MATRIX_TRANSFORM_NV = 34377 	# GL/glext.h:2348
GL_VERTEX_PROGRAM_BINDING_NV = 34378 	# GL/glext.h:2349
GL_PROGRAM_ERROR_POSITION_NV = 34379 	# GL/glext.h:2350
GL_VERTEX_ATTRIB_ARRAY0_NV = 34384 	# GL/glext.h:2351
GL_VERTEX_ATTRIB_ARRAY1_NV = 34385 	# GL/glext.h:2352
GL_VERTEX_ATTRIB_ARRAY2_NV = 34386 	# GL/glext.h:2353
GL_VERTEX_ATTRIB_ARRAY3_NV = 34387 	# GL/glext.h:2354
GL_VERTEX_ATTRIB_ARRAY4_NV = 34388 	# GL/glext.h:2355
GL_VERTEX_ATTRIB_ARRAY5_NV = 34389 	# GL/glext.h:2356
GL_VERTEX_ATTRIB_ARRAY6_NV = 34390 	# GL/glext.h:2357
GL_VERTEX_ATTRIB_ARRAY7_NV = 34391 	# GL/glext.h:2358
GL_VERTEX_ATTRIB_ARRAY8_NV = 34392 	# GL/glext.h:2359
GL_VERTEX_ATTRIB_ARRAY9_NV = 34393 	# GL/glext.h:2360
GL_VERTEX_ATTRIB_ARRAY10_NV = 34394 	# GL/glext.h:2361
GL_VERTEX_ATTRIB_ARRAY11_NV = 34395 	# GL/glext.h:2362
GL_VERTEX_ATTRIB_ARRAY12_NV = 34396 	# GL/glext.h:2363
GL_VERTEX_ATTRIB_ARRAY13_NV = 34397 	# GL/glext.h:2364
GL_VERTEX_ATTRIB_ARRAY14_NV = 34398 	# GL/glext.h:2365
GL_VERTEX_ATTRIB_ARRAY15_NV = 34399 	# GL/glext.h:2366
GL_MAP1_VERTEX_ATTRIB0_4_NV = 34400 	# GL/glext.h:2367
GL_MAP1_VERTEX_ATTRIB1_4_NV = 34401 	# GL/glext.h:2368
GL_MAP1_VERTEX_ATTRIB2_4_NV = 34402 	# GL/glext.h:2369
GL_MAP1_VERTEX_ATTRIB3_4_NV = 34403 	# GL/glext.h:2370
GL_MAP1_VERTEX_ATTRIB4_4_NV = 34404 	# GL/glext.h:2371
GL_MAP1_VERTEX_ATTRIB5_4_NV = 34405 	# GL/glext.h:2372
GL_MAP1_VERTEX_ATTRIB6_4_NV = 34406 	# GL/glext.h:2373
GL_MAP1_VERTEX_ATTRIB7_4_NV = 34407 	# GL/glext.h:2374
GL_MAP1_VERTEX_ATTRIB8_4_NV = 34408 	# GL/glext.h:2375
GL_MAP1_VERTEX_ATTRIB9_4_NV = 34409 	# GL/glext.h:2376
GL_MAP1_VERTEX_ATTRIB10_4_NV = 34410 	# GL/glext.h:2377
GL_MAP1_VERTEX_ATTRIB11_4_NV = 34411 	# GL/glext.h:2378
GL_MAP1_VERTEX_ATTRIB12_4_NV = 34412 	# GL/glext.h:2379
GL_MAP1_VERTEX_ATTRIB13_4_NV = 34413 	# GL/glext.h:2380
GL_MAP1_VERTEX_ATTRIB14_4_NV = 34414 	# GL/glext.h:2381
GL_MAP1_VERTEX_ATTRIB15_4_NV = 34415 	# GL/glext.h:2382
GL_MAP2_VERTEX_ATTRIB0_4_NV = 34416 	# GL/glext.h:2383
GL_MAP2_VERTEX_ATTRIB1_4_NV = 34417 	# GL/glext.h:2384
GL_MAP2_VERTEX_ATTRIB2_4_NV = 34418 	# GL/glext.h:2385
GL_MAP2_VERTEX_ATTRIB3_4_NV = 34419 	# GL/glext.h:2386
GL_MAP2_VERTEX_ATTRIB4_4_NV = 34420 	# GL/glext.h:2387
GL_MAP2_VERTEX_ATTRIB5_4_NV = 34421 	# GL/glext.h:2388
GL_MAP2_VERTEX_ATTRIB6_4_NV = 34422 	# GL/glext.h:2389
GL_MAP2_VERTEX_ATTRIB7_4_NV = 34423 	# GL/glext.h:2390
GL_MAP2_VERTEX_ATTRIB8_4_NV = 34424 	# GL/glext.h:2391
GL_MAP2_VERTEX_ATTRIB9_4_NV = 34425 	# GL/glext.h:2392
GL_MAP2_VERTEX_ATTRIB10_4_NV = 34426 	# GL/glext.h:2393
GL_MAP2_VERTEX_ATTRIB11_4_NV = 34427 	# GL/glext.h:2394
GL_MAP2_VERTEX_ATTRIB12_4_NV = 34428 	# GL/glext.h:2395
GL_MAP2_VERTEX_ATTRIB13_4_NV = 34429 	# GL/glext.h:2396
GL_MAP2_VERTEX_ATTRIB14_4_NV = 34430 	# GL/glext.h:2397
GL_MAP2_VERTEX_ATTRIB15_4_NV = 34431 	# GL/glext.h:2398
# SGIX_texture_coordinate_clamp (GL/glext.h:2401)
GL_TEXTURE_MAX_CLAMP_S_SGIX = 33641 	# GL/glext.h:2402
GL_TEXTURE_MAX_CLAMP_T_SGIX = 33642 	# GL/glext.h:2403
GL_TEXTURE_MAX_CLAMP_R_SGIX = 33643 	# GL/glext.h:2404
# SGIX_scalebias_hint (GL/glext.h:2407)
GL_SCALEBIAS_HINT_SGIX = 33570 	# GL/glext.h:2408
# OML_interlace (GL/glext.h:2411)
GL_INTERLACE_OML = 35200 	# GL/glext.h:2412
GL_INTERLACE_READ_OML = 35201 	# GL/glext.h:2413
# OML_subsample (GL/glext.h:2416)
GL_FORMAT_SUBSAMPLE_24_24_OML = 35202 	# GL/glext.h:2417
GL_FORMAT_SUBSAMPLE_244_244_OML = 35203 	# GL/glext.h:2418
# OML_resample (GL/glext.h:2421)
GL_PACK_RESAMPLE_OML = 35204 	# GL/glext.h:2422
GL_UNPACK_RESAMPLE_OML = 35205 	# GL/glext.h:2423
GL_RESAMPLE_REPLICATE_OML = 35206 	# GL/glext.h:2424
GL_RESAMPLE_ZERO_FILL_OML = 35207 	# GL/glext.h:2425
GL_RESAMPLE_AVERAGE_OML = 35208 	# GL/glext.h:2426
GL_RESAMPLE_DECIMATE_OML = 35209 	# GL/glext.h:2427
# NV_copy_depth_to_color (GL/glext.h:2430)
GL_DEPTH_STENCIL_TO_RGBA_NV = 34926 	# GL/glext.h:2431
GL_DEPTH_STENCIL_TO_BGRA_NV = 34927 	# GL/glext.h:2432
# ATI_envmap_bumpmap (GL/glext.h:2435)
GL_BUMP_ROT_MATRIX_ATI = 34677 	# GL/glext.h:2436
GL_BUMP_ROT_MATRIX_SIZE_ATI = 34678 	# GL/glext.h:2437
GL_BUMP_NUM_TEX_UNITS_ATI = 34679 	# GL/glext.h:2438
GL_BUMP_TEX_UNITS_ATI = 34680 	# GL/glext.h:2439
GL_DUDV_ATI = 34681 	# GL/glext.h:2440
GL_DU8DV8_ATI = 34682 	# GL/glext.h:2441
GL_BUMP_ENVMAP_ATI = 34683 	# GL/glext.h:2442
GL_BUMP_TARGET_ATI = 34684 	# GL/glext.h:2443
# ATI_fragment_shader (GL/glext.h:2446)
GL_FRAGMENT_SHADER_ATI = 35104 	# GL/glext.h:2447
GL_REG_0_ATI = 35105 	# GL/glext.h:2448
GL_REG_1_ATI = 35106 	# GL/glext.h:2449
GL_REG_2_ATI = 35107 	# GL/glext.h:2450
GL_REG_3_ATI = 35108 	# GL/glext.h:2451
GL_REG_4_ATI = 35109 	# GL/glext.h:2452
GL_REG_5_ATI = 35110 	# GL/glext.h:2453
GL_REG_6_ATI = 35111 	# GL/glext.h:2454
GL_REG_7_ATI = 35112 	# GL/glext.h:2455
GL_REG_8_ATI = 35113 	# GL/glext.h:2456
GL_REG_9_ATI = 35114 	# GL/glext.h:2457
GL_REG_10_ATI = 35115 	# GL/glext.h:2458
GL_REG_11_ATI = 35116 	# GL/glext.h:2459
GL_REG_12_ATI = 35117 	# GL/glext.h:2460
GL_REG_13_ATI = 35118 	# GL/glext.h:2461
GL_REG_14_ATI = 35119 	# GL/glext.h:2462
GL_REG_15_ATI = 35120 	# GL/glext.h:2463
GL_REG_16_ATI = 35121 	# GL/glext.h:2464
GL_REG_17_ATI = 35122 	# GL/glext.h:2465
GL_REG_18_ATI = 35123 	# GL/glext.h:2466
GL_REG_19_ATI = 35124 	# GL/glext.h:2467
GL_REG_20_ATI = 35125 	# GL/glext.h:2468
GL_REG_21_ATI = 35126 	# GL/glext.h:2469
GL_REG_22_ATI = 35127 	# GL/glext.h:2470
GL_REG_23_ATI = 35128 	# GL/glext.h:2471
GL_REG_24_ATI = 35129 	# GL/glext.h:2472
GL_REG_25_ATI = 35130 	# GL/glext.h:2473
GL_REG_26_ATI = 35131 	# GL/glext.h:2474
GL_REG_27_ATI = 35132 	# GL/glext.h:2475
GL_REG_28_ATI = 35133 	# GL/glext.h:2476
GL_REG_29_ATI = 35134 	# GL/glext.h:2477
GL_REG_30_ATI = 35135 	# GL/glext.h:2478
GL_REG_31_ATI = 35136 	# GL/glext.h:2479
GL_CON_0_ATI = 35137 	# GL/glext.h:2480
GL_CON_1_ATI = 35138 	# GL/glext.h:2481
GL_CON_2_ATI = 35139 	# GL/glext.h:2482
GL_CON_3_ATI = 35140 	# GL/glext.h:2483
GL_CON_4_ATI = 35141 	# GL/glext.h:2484
GL_CON_5_ATI = 35142 	# GL/glext.h:2485
GL_CON_6_ATI = 35143 	# GL/glext.h:2486
GL_CON_7_ATI = 35144 	# GL/glext.h:2487
GL_CON_8_ATI = 35145 	# GL/glext.h:2488
GL_CON_9_ATI = 35146 	# GL/glext.h:2489
GL_CON_10_ATI = 35147 	# GL/glext.h:2490
GL_CON_11_ATI = 35148 	# GL/glext.h:2491
GL_CON_12_ATI = 35149 	# GL/glext.h:2492
GL_CON_13_ATI = 35150 	# GL/glext.h:2493
GL_CON_14_ATI = 35151 	# GL/glext.h:2494
GL_CON_15_ATI = 35152 	# GL/glext.h:2495
GL_CON_16_ATI = 35153 	# GL/glext.h:2496
GL_CON_17_ATI = 35154 	# GL/glext.h:2497
GL_CON_18_ATI = 35155 	# GL/glext.h:2498
GL_CON_19_ATI = 35156 	# GL/glext.h:2499
GL_CON_20_ATI = 35157 	# GL/glext.h:2500
GL_CON_21_ATI = 35158 	# GL/glext.h:2501
GL_CON_22_ATI = 35159 	# GL/glext.h:2502
GL_CON_23_ATI = 35160 	# GL/glext.h:2503
GL_CON_24_ATI = 35161 	# GL/glext.h:2504
GL_CON_25_ATI = 35162 	# GL/glext.h:2505
GL_CON_26_ATI = 35163 	# GL/glext.h:2506
GL_CON_27_ATI = 35164 	# GL/glext.h:2507
GL_CON_28_ATI = 35165 	# GL/glext.h:2508
GL_CON_29_ATI = 35166 	# GL/glext.h:2509
GL_CON_30_ATI = 35167 	# GL/glext.h:2510
GL_CON_31_ATI = 35168 	# GL/glext.h:2511
GL_MOV_ATI = 35169 	# GL/glext.h:2512
GL_ADD_ATI = 35171 	# GL/glext.h:2513
GL_MUL_ATI = 35172 	# GL/glext.h:2514
GL_SUB_ATI = 35173 	# GL/glext.h:2515
GL_DOT3_ATI = 35174 	# GL/glext.h:2516
GL_DOT4_ATI = 35175 	# GL/glext.h:2517
GL_MAD_ATI = 35176 	# GL/glext.h:2518
GL_LERP_ATI = 35177 	# GL/glext.h:2519
GL_CND_ATI = 35178 	# GL/glext.h:2520
GL_CND0_ATI = 35179 	# GL/glext.h:2521
GL_DOT2_ADD_ATI = 35180 	# GL/glext.h:2522
GL_SECONDARY_INTERPOLATOR_ATI = 35181 	# GL/glext.h:2523
GL_NUM_FRAGMENT_REGISTERS_ATI = 35182 	# GL/glext.h:2524
GL_NUM_FRAGMENT_CONSTANTS_ATI = 35183 	# GL/glext.h:2525
GL_NUM_PASSES_ATI = 35184 	# GL/glext.h:2526
GL_NUM_INSTRUCTIONS_PER_PASS_ATI = 35185 	# GL/glext.h:2527
GL_NUM_INSTRUCTIONS_TOTAL_ATI = 35186 	# GL/glext.h:2528
GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI = 35187 	# GL/glext.h:2529
GL_NUM_LOOPBACK_COMPONENTS_ATI = 35188 	# GL/glext.h:2530
GL_COLOR_ALPHA_PAIRING_ATI = 35189 	# GL/glext.h:2531
GL_SWIZZLE_STR_ATI = 35190 	# GL/glext.h:2532
GL_SWIZZLE_STQ_ATI = 35191 	# GL/glext.h:2533
GL_SWIZZLE_STR_DR_ATI = 35192 	# GL/glext.h:2534
GL_SWIZZLE_STQ_DQ_ATI = 35193 	# GL/glext.h:2535
GL_SWIZZLE_STRQ_ATI = 35194 	# GL/glext.h:2536
GL_SWIZZLE_STRQ_DQ_ATI = 35195 	# GL/glext.h:2537
GL_RED_BIT_ATI = 1 	# GL/glext.h:2538
GL_GREEN_BIT_ATI = 2 	# GL/glext.h:2539
GL_BLUE_BIT_ATI = 4 	# GL/glext.h:2540
GL_2X_BIT_ATI = 1 	# GL/glext.h:2541
GL_4X_BIT_ATI = 2 	# GL/glext.h:2542
GL_8X_BIT_ATI = 4 	# GL/glext.h:2543
GL_HALF_BIT_ATI = 8 	# GL/glext.h:2544
GL_QUARTER_BIT_ATI = 16 	# GL/glext.h:2545
GL_EIGHTH_BIT_ATI = 32 	# GL/glext.h:2546
GL_SATURATE_BIT_ATI = 64 	# GL/glext.h:2547
GL_COMP_BIT_ATI = 2 	# GL/glext.h:2548
GL_NEGATE_BIT_ATI = 4 	# GL/glext.h:2549
GL_BIAS_BIT_ATI = 8 	# GL/glext.h:2550
# ATI_pn_triangles (GL/glext.h:2553)
GL_PN_TRIANGLES_ATI = 34800 	# GL/glext.h:2554
GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI = 34801 	# GL/glext.h:2555
GL_PN_TRIANGLES_POINT_MODE_ATI = 34802 	# GL/glext.h:2556
GL_PN_TRIANGLES_NORMAL_MODE_ATI = 34803 	# GL/glext.h:2557
GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI = 34804 	# GL/glext.h:2558
GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI = 34805 	# GL/glext.h:2559
GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI = 34806 	# GL/glext.h:2560
GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI = 34807 	# GL/glext.h:2561
GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI = 34808 	# GL/glext.h:2562
# ATI_vertex_array_object (GL/glext.h:2565)
GL_STATIC_ATI = 34656 	# GL/glext.h:2566
GL_DYNAMIC_ATI = 34657 	# GL/glext.h:2567
GL_PRESERVE_ATI = 34658 	# GL/glext.h:2568
GL_DISCARD_ATI = 34659 	# GL/glext.h:2569
GL_OBJECT_BUFFER_SIZE_ATI = 34660 	# GL/glext.h:2570
GL_OBJECT_BUFFER_USAGE_ATI = 34661 	# GL/glext.h:2571
GL_ARRAY_OBJECT_BUFFER_ATI = 34662 	# GL/glext.h:2572
GL_ARRAY_OBJECT_OFFSET_ATI = 34663 	# GL/glext.h:2573
# EXT_vertex_shader (GL/glext.h:2576)
GL_VERTEX_SHADER_EXT = 34688 	# GL/glext.h:2577
GL_VERTEX_SHADER_BINDING_EXT = 34689 	# GL/glext.h:2578
GL_OP_INDEX_EXT = 34690 	# GL/glext.h:2579
GL_OP_NEGATE_EXT = 34691 	# GL/glext.h:2580
GL_OP_DOT3_EXT = 34692 	# GL/glext.h:2581
GL_OP_DOT4_EXT = 34693 	# GL/glext.h:2582
GL_OP_MUL_EXT = 34694 	# GL/glext.h:2583
GL_OP_ADD_EXT = 34695 	# GL/glext.h:2584
GL_OP_MADD_EXT = 34696 	# GL/glext.h:2585
GL_OP_FRAC_EXT = 34697 	# GL/glext.h:2586
GL_OP_MAX_EXT = 34698 	# GL/glext.h:2587
GL_OP_MIN_EXT = 34699 	# GL/glext.h:2588
GL_OP_SET_GE_EXT = 34700 	# GL/glext.h:2589
GL_OP_SET_LT_EXT = 34701 	# GL/glext.h:2590
GL_OP_CLAMP_EXT = 34702 	# GL/glext.h:2591
GL_OP_FLOOR_EXT = 34703 	# GL/glext.h:2592
GL_OP_ROUND_EXT = 34704 	# GL/glext.h:2593
GL_OP_EXP_BASE_2_EXT = 34705 	# GL/glext.h:2594
GL_OP_LOG_BASE_2_EXT = 34706 	# GL/glext.h:2595
GL_OP_POWER_EXT = 34707 	# GL/glext.h:2596
GL_OP_RECIP_EXT = 34708 	# GL/glext.h:2597
GL_OP_RECIP_SQRT_EXT = 34709 	# GL/glext.h:2598
GL_OP_SUB_EXT = 34710 	# GL/glext.h:2599
GL_OP_CROSS_PRODUCT_EXT = 34711 	# GL/glext.h:2600
GL_OP_MULTIPLY_MATRIX_EXT = 34712 	# GL/glext.h:2601
GL_OP_MOV_EXT = 34713 	# GL/glext.h:2602
GL_OUTPUT_VERTEX_EXT = 34714 	# GL/glext.h:2603
GL_OUTPUT_COLOR0_EXT = 34715 	# GL/glext.h:2604
GL_OUTPUT_COLOR1_EXT = 34716 	# GL/glext.h:2605
GL_OUTPUT_TEXTURE_COORD0_EXT = 34717 	# GL/glext.h:2606
GL_OUTPUT_TEXTURE_COORD1_EXT = 34718 	# GL/glext.h:2607
GL_OUTPUT_TEXTURE_COORD2_EXT = 34719 	# GL/glext.h:2608
GL_OUTPUT_TEXTURE_COORD3_EXT = 34720 	# GL/glext.h:2609
GL_OUTPUT_TEXTURE_COORD4_EXT = 34721 	# GL/glext.h:2610
GL_OUTPUT_TEXTURE_COORD5_EXT = 34722 	# GL/glext.h:2611
GL_OUTPUT_TEXTURE_COORD6_EXT = 34723 	# GL/glext.h:2612
GL_OUTPUT_TEXTURE_COORD7_EXT = 34724 	# GL/glext.h:2613
GL_OUTPUT_TEXTURE_COORD8_EXT = 34725 	# GL/glext.h:2614
GL_OUTPUT_TEXTURE_COORD9_EXT = 34726 	# GL/glext.h:2615
GL_OUTPUT_TEXTURE_COORD10_EXT = 34727 	# GL/glext.h:2616
GL_OUTPUT_TEXTURE_COORD11_EXT = 34728 	# GL/glext.h:2617
GL_OUTPUT_TEXTURE_COORD12_EXT = 34729 	# GL/glext.h:2618
GL_OUTPUT_TEXTURE_COORD13_EXT = 34730 	# GL/glext.h:2619
GL_OUTPUT_TEXTURE_COORD14_EXT = 34731 	# GL/glext.h:2620
GL_OUTPUT_TEXTURE_COORD15_EXT = 34732 	# GL/glext.h:2621
GL_OUTPUT_TEXTURE_COORD16_EXT = 34733 	# GL/glext.h:2622
GL_OUTPUT_TEXTURE_COORD17_EXT = 34734 	# GL/glext.h:2623
GL_OUTPUT_TEXTURE_COORD18_EXT = 34735 	# GL/glext.h:2624
GL_OUTPUT_TEXTURE_COORD19_EXT = 34736 	# GL/glext.h:2625
GL_OUTPUT_TEXTURE_COORD20_EXT = 34737 	# GL/glext.h:2626
GL_OUTPUT_TEXTURE_COORD21_EXT = 34738 	# GL/glext.h:2627
GL_OUTPUT_TEXTURE_COORD22_EXT = 34739 	# GL/glext.h:2628
GL_OUTPUT_TEXTURE_COORD23_EXT = 34740 	# GL/glext.h:2629
GL_OUTPUT_TEXTURE_COORD24_EXT = 34741 	# GL/glext.h:2630
GL_OUTPUT_TEXTURE_COORD25_EXT = 34742 	# GL/glext.h:2631
GL_OUTPUT_TEXTURE_COORD26_EXT = 34743 	# GL/glext.h:2632
GL_OUTPUT_TEXTURE_COORD27_EXT = 34744 	# GL/glext.h:2633
GL_OUTPUT_TEXTURE_COORD28_EXT = 34745 	# GL/glext.h:2634
GL_OUTPUT_TEXTURE_COORD29_EXT = 34746 	# GL/glext.h:2635
GL_OUTPUT_TEXTURE_COORD30_EXT = 34747 	# GL/glext.h:2636
GL_OUTPUT_TEXTURE_COORD31_EXT = 34748 	# GL/glext.h:2637
GL_OUTPUT_FOG_EXT = 34749 	# GL/glext.h:2638
GL_SCALAR_EXT = 34750 	# GL/glext.h:2639
GL_VECTOR_EXT = 34751 	# GL/glext.h:2640
GL_MATRIX_EXT = 34752 	# GL/glext.h:2641
GL_VARIANT_EXT = 34753 	# GL/glext.h:2642
GL_INVARIANT_EXT = 34754 	# GL/glext.h:2643
GL_LOCAL_CONSTANT_EXT = 34755 	# GL/glext.h:2644
GL_LOCAL_EXT = 34756 	# GL/glext.h:2645
GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT = 34757 	# GL/glext.h:2646
GL_MAX_VERTEX_SHADER_VARIANTS_EXT = 34758 	# GL/glext.h:2647
GL_MAX_VERTEX_SHADER_INVARIANTS_EXT = 34759 	# GL/glext.h:2648
GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 34760 	# GL/glext.h:2649
GL_MAX_VERTEX_SHADER_LOCALS_EXT = 34761 	# GL/glext.h:2650
GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT = 34762 	# GL/glext.h:2651
GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT = 34763 	# GL/glext.h:2652
GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 34764 	# GL/glext.h:2653
GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT = 34765 	# GL/glext.h:2654
GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT = 34766 	# GL/glext.h:2655
GL_VERTEX_SHADER_INSTRUCTIONS_EXT = 34767 	# GL/glext.h:2656
GL_VERTEX_SHADER_VARIANTS_EXT = 34768 	# GL/glext.h:2657
GL_VERTEX_SHADER_INVARIANTS_EXT = 34769 	# GL/glext.h:2658
GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 34770 	# GL/glext.h:2659
GL_VERTEX_SHADER_LOCALS_EXT = 34771 	# GL/glext.h:2660
GL_VERTEX_SHADER_OPTIMIZED_EXT = 34772 	# GL/glext.h:2661
GL_X_EXT = 34773 	# GL/glext.h:2662
GL_Y_EXT = 34774 	# GL/glext.h:2663
GL_Z_EXT = 34775 	# GL/glext.h:2664
GL_W_EXT = 34776 	# GL/glext.h:2665
GL_NEGATIVE_X_EXT = 34777 	# GL/glext.h:2666
GL_NEGATIVE_Y_EXT = 34778 	# GL/glext.h:2667
GL_NEGATIVE_Z_EXT = 34779 	# GL/glext.h:2668
GL_NEGATIVE_W_EXT = 34780 	# GL/glext.h:2669
GL_ZERO_EXT = 34781 	# GL/glext.h:2670
GL_ONE_EXT = 34782 	# GL/glext.h:2671
GL_NEGATIVE_ONE_EXT = 34783 	# GL/glext.h:2672
GL_NORMALIZED_RANGE_EXT = 34784 	# GL/glext.h:2673
GL_FULL_RANGE_EXT = 34785 	# GL/glext.h:2674
GL_CURRENT_VERTEX_EXT = 34786 	# GL/glext.h:2675
GL_MVP_MATRIX_EXT = 34787 	# GL/glext.h:2676
GL_VARIANT_VALUE_EXT = 34788 	# GL/glext.h:2677
GL_VARIANT_DATATYPE_EXT = 34789 	# GL/glext.h:2678
GL_VARIANT_ARRAY_STRIDE_EXT = 34790 	# GL/glext.h:2679
GL_VARIANT_ARRAY_TYPE_EXT = 34791 	# GL/glext.h:2680
GL_VARIANT_ARRAY_EXT = 34792 	# GL/glext.h:2681
GL_VARIANT_ARRAY_POINTER_EXT = 34793 	# GL/glext.h:2682
GL_INVARIANT_VALUE_EXT = 34794 	# GL/glext.h:2683
GL_INVARIANT_DATATYPE_EXT = 34795 	# GL/glext.h:2684
GL_LOCAL_CONSTANT_VALUE_EXT = 34796 	# GL/glext.h:2685
GL_LOCAL_CONSTANT_DATATYPE_EXT = 34797 	# GL/glext.h:2686
# ATI_vertex_streams (GL/glext.h:2689)
GL_MAX_VERTEX_STREAMS_ATI = 34667 	# GL/glext.h:2690
GL_VERTEX_STREAM0_ATI = 34668 	# GL/glext.h:2691
GL_VERTEX_STREAM1_ATI = 34669 	# GL/glext.h:2692
GL_VERTEX_STREAM2_ATI = 34670 	# GL/glext.h:2693
GL_VERTEX_STREAM3_ATI = 34671 	# GL/glext.h:2694
GL_VERTEX_STREAM4_ATI = 34672 	# GL/glext.h:2695
GL_VERTEX_STREAM5_ATI = 34673 	# GL/glext.h:2696
GL_VERTEX_STREAM6_ATI = 34674 	# GL/glext.h:2697
GL_VERTEX_STREAM7_ATI = 34675 	# GL/glext.h:2698
GL_VERTEX_SOURCE_ATI = 34676 	# GL/glext.h:2699
# ATI_element_array (GL/glext.h:2702)
GL_ELEMENT_ARRAY_ATI = 34664 	# GL/glext.h:2703
GL_ELEMENT_ARRAY_TYPE_ATI = 34665 	# GL/glext.h:2704
GL_ELEMENT_ARRAY_POINTER_ATI = 34666 	# GL/glext.h:2705
# SUN_mesh_array (GL/glext.h:2708)
GL_QUAD_MESH_SUN = 34324 	# GL/glext.h:2709
GL_TRIANGLE_MESH_SUN = 34325 	# GL/glext.h:2710
# SUN_slice_accum (GL/glext.h:2713)
GL_SLICE_ACCUM_SUN = 34252 	# GL/glext.h:2714
# NV_multisample_filter_hint (GL/glext.h:2717)
GL_MULTISAMPLE_FILTER_HINT_NV = 34100 	# GL/glext.h:2718
# NV_depth_clamp (GL/glext.h:2721)
GL_DEPTH_CLAMP_NV = 34383 	# GL/glext.h:2722
# NV_occlusion_query (GL/glext.h:2725)
GL_PIXEL_COUNTER_BITS_NV = 34916 	# GL/glext.h:2726
GL_CURRENT_OCCLUSION_QUERY_ID_NV = 34917 	# GL/glext.h:2727
GL_PIXEL_COUNT_NV = 34918 	# GL/glext.h:2728
GL_PIXEL_COUNT_AVAILABLE_NV = 34919 	# GL/glext.h:2729
# NV_point_sprite (GL/glext.h:2732)
GL_POINT_SPRITE_NV = 34913 	# GL/glext.h:2733
GL_COORD_REPLACE_NV = 34914 	# GL/glext.h:2734
GL_POINT_SPRITE_R_MODE_NV = 34915 	# GL/glext.h:2735
# NV_texture_shader3 (GL/glext.h:2738)
GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV = 34896 	# GL/glext.h:2739
GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV = 34897 	# GL/glext.h:2740
GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV = 34898 	# GL/glext.h:2741
GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV = 34899 	# GL/glext.h:2742
GL_OFFSET_HILO_TEXTURE_2D_NV = 34900 	# GL/glext.h:2743
GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV = 34901 	# GL/glext.h:2744
GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV = 34902 	# GL/glext.h:2745
GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV = 34903 	# GL/glext.h:2746
GL_DEPENDENT_HILO_TEXTURE_2D_NV = 34904 	# GL/glext.h:2747
GL_DEPENDENT_RGB_TEXTURE_3D_NV = 34905 	# GL/glext.h:2748
GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV = 34906 	# GL/glext.h:2749
GL_DOT_PRODUCT_PASS_THROUGH_NV = 34907 	# GL/glext.h:2750
GL_DOT_PRODUCT_TEXTURE_1D_NV = 34908 	# GL/glext.h:2751
GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV = 34909 	# GL/glext.h:2752
GL_HILO8_NV = 34910 	# GL/glext.h:2753
GL_SIGNED_HILO8_NV = 34911 	# GL/glext.h:2754
GL_FORCE_BLUE_TO_ONE_NV = 34912 	# GL/glext.h:2755
# NV_vertex_program1_1 (GL/glext.h:2758)
# EXT_shadow_funcs (GL/glext.h:2761)
# EXT_stencil_two_side (GL/glext.h:2764)
GL_STENCIL_TEST_TWO_SIDE_EXT = 35088 	# GL/glext.h:2765
GL_ACTIVE_STENCIL_FACE_EXT = 35089 	# GL/glext.h:2766
# ATI_text_fragment_shader (GL/glext.h:2769)
GL_TEXT_FRAGMENT_SHADER_ATI = 33280 	# GL/glext.h:2770
# APPLE_client_storage (GL/glext.h:2773)
GL_UNPACK_CLIENT_STORAGE_APPLE = 34226 	# GL/glext.h:2774
# APPLE_element_array (GL/glext.h:2777)
GL_ELEMENT_ARRAY_APPLE = 34664 	# GL/glext.h:2778
GL_ELEMENT_ARRAY_TYPE_APPLE = 34665 	# GL/glext.h:2779
GL_ELEMENT_ARRAY_POINTER_APPLE = 34666 	# GL/glext.h:2780
# APPLE_fence (GL/glext.h:2783)
GL_DRAW_PIXELS_APPLE = 35338 	# GL/glext.h:2784
GL_FENCE_APPLE = 35339 	# GL/glext.h:2785
# APPLE_vertex_array_object (GL/glext.h:2788)
GL_VERTEX_ARRAY_BINDING_APPLE = 34229 	# GL/glext.h:2789
# APPLE_vertex_array_range (GL/glext.h:2792)
GL_VERTEX_ARRAY_RANGE_APPLE = 34077 	# GL/glext.h:2793
GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE = 34078 	# GL/glext.h:2794
GL_VERTEX_ARRAY_STORAGE_HINT_APPLE = 34079 	# GL/glext.h:2795
GL_VERTEX_ARRAY_RANGE_POINTER_APPLE = 34081 	# GL/glext.h:2796
GL_STORAGE_CACHED_APPLE = 34238 	# GL/glext.h:2797
GL_STORAGE_SHARED_APPLE = 34239 	# GL/glext.h:2798
# APPLE_ycbcr_422 (GL/glext.h:2801)
GL_YCBCR_422_APPLE = 34233 	# GL/glext.h:2802
GL_UNSIGNED_SHORT_8_8_APPLE = 34234 	# GL/glext.h:2803
GL_UNSIGNED_SHORT_8_8_REV_APPLE = 34235 	# GL/glext.h:2804
# S3_s3tc (GL/glext.h:2807)
GL_RGB_S3TC = 33696 	# GL/glext.h:2808
GL_RGB4_S3TC = 33697 	# GL/glext.h:2809
GL_RGBA_S3TC = 33698 	# GL/glext.h:2810
GL_RGBA4_S3TC = 33699 	# GL/glext.h:2811
# ATI_draw_buffers (GL/glext.h:2814)
GL_MAX_DRAW_BUFFERS_ATI = 34852 	# GL/glext.h:2815
GL_DRAW_BUFFER0_ATI = 34853 	# GL/glext.h:2816
GL_DRAW_BUFFER1_ATI = 34854 	# GL/glext.h:2817
GL_DRAW_BUFFER2_ATI = 34855 	# GL/glext.h:2818
GL_DRAW_BUFFER3_ATI = 34856 	# GL/glext.h:2819
GL_DRAW_BUFFER4_ATI = 34857 	# GL/glext.h:2820
GL_DRAW_BUFFER5_ATI = 34858 	# GL/glext.h:2821
GL_DRAW_BUFFER6_ATI = 34859 	# GL/glext.h:2822
GL_DRAW_BUFFER7_ATI = 34860 	# GL/glext.h:2823
GL_DRAW_BUFFER8_ATI = 34861 	# GL/glext.h:2824
GL_DRAW_BUFFER9_ATI = 34862 	# GL/glext.h:2825
GL_DRAW_BUFFER10_ATI = 34863 	# GL/glext.h:2826
GL_DRAW_BUFFER11_ATI = 34864 	# GL/glext.h:2827
GL_DRAW_BUFFER12_ATI = 34865 	# GL/glext.h:2828
GL_DRAW_BUFFER13_ATI = 34866 	# GL/glext.h:2829
GL_DRAW_BUFFER14_ATI = 34867 	# GL/glext.h:2830
GL_DRAW_BUFFER15_ATI = 34868 	# GL/glext.h:2831
# ATI_pixel_format_float (GL/glext.h:2834)
GL_TYPE_RGBA_FLOAT_ATI = 34848 	# GL/glext.h:2835
GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI = 34869 	# GL/glext.h:2836
# ATI_texture_env_combine3 (GL/glext.h:2839)
GL_MODULATE_ADD_ATI = 34628 	# GL/glext.h:2840
GL_MODULATE_SIGNED_ADD_ATI = 34629 	# GL/glext.h:2841
GL_MODULATE_SUBTRACT_ATI = 34630 	# GL/glext.h:2842
# ATI_texture_float (GL/glext.h:2845)
GL_RGBA_FLOAT32_ATI = 34836 	# GL/glext.h:2846
GL_RGB_FLOAT32_ATI = 34837 	# GL/glext.h:2847
GL_ALPHA_FLOAT32_ATI = 34838 	# GL/glext.h:2848
GL_INTENSITY_FLOAT32_ATI = 34839 	# GL/glext.h:2849
GL_LUMINANCE_FLOAT32_ATI = 34840 	# GL/glext.h:2850
GL_LUMINANCE_ALPHA_FLOAT32_ATI = 34841 	# GL/glext.h:2851
GL_RGBA_FLOAT16_ATI = 34842 	# GL/glext.h:2852
GL_RGB_FLOAT16_ATI = 34843 	# GL/glext.h:2853
GL_ALPHA_FLOAT16_ATI = 34844 	# GL/glext.h:2854
GL_INTENSITY_FLOAT16_ATI = 34845 	# GL/glext.h:2855
GL_LUMINANCE_FLOAT16_ATI = 34846 	# GL/glext.h:2856
GL_LUMINANCE_ALPHA_FLOAT16_ATI = 34847 	# GL/glext.h:2857
# NV_float_buffer (GL/glext.h:2860)
GL_FLOAT_R_NV = 34944 	# GL/glext.h:2861
GL_FLOAT_RG_NV = 34945 	# GL/glext.h:2862
GL_FLOAT_RGB_NV = 34946 	# GL/glext.h:2863
GL_FLOAT_RGBA_NV = 34947 	# GL/glext.h:2864
GL_FLOAT_R16_NV = 34948 	# GL/glext.h:2865
GL_FLOAT_R32_NV = 34949 	# GL/glext.h:2866
GL_FLOAT_RG16_NV = 34950 	# GL/glext.h:2867
GL_FLOAT_RG32_NV = 34951 	# GL/glext.h:2868
GL_FLOAT_RGB16_NV = 34952 	# GL/glext.h:2869
GL_FLOAT_RGB32_NV = 34953 	# GL/glext.h:2870
GL_FLOAT_RGBA16_NV = 34954 	# GL/glext.h:2871
GL_FLOAT_RGBA32_NV = 34955 	# GL/glext.h:2872
GL_TEXTURE_FLOAT_COMPONENTS_NV = 34956 	# GL/glext.h:2873
GL_FLOAT_CLEAR_COLOR_VALUE_NV = 34957 	# GL/glext.h:2874
GL_FLOAT_RGBA_MODE_NV = 34958 	# GL/glext.h:2875
# NV_fragment_program (GL/glext.h:2878)
GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV = 34920 	# GL/glext.h:2879
GL_FRAGMENT_PROGRAM_NV = 34928 	# GL/glext.h:2880
GL_MAX_TEXTURE_COORDS_NV = 34929 	# GL/glext.h:2881
GL_MAX_TEXTURE_IMAGE_UNITS_NV = 34930 	# GL/glext.h:2882
GL_FRAGMENT_PROGRAM_BINDING_NV = 34931 	# GL/glext.h:2883
GL_PROGRAM_ERROR_STRING_NV = 34932 	# GL/glext.h:2884
# NV_half_float (GL/glext.h:2887)
GL_HALF_FLOAT_NV = 5131 	# GL/glext.h:2888
# NV_pixel_data_range (GL/glext.h:2891)
GL_WRITE_PIXEL_DATA_RANGE_NV = 34936 	# GL/glext.h:2892
GL_READ_PIXEL_DATA_RANGE_NV = 34937 	# GL/glext.h:2893
GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV = 34938 	# GL/glext.h:2894
GL_READ_PIXEL_DATA_RANGE_LENGTH_NV = 34939 	# GL/glext.h:2895
GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV = 34940 	# GL/glext.h:2896
GL_READ_PIXEL_DATA_RANGE_POINTER_NV = 34941 	# GL/glext.h:2897
# NV_primitive_restart (GL/glext.h:2900)
GL_PRIMITIVE_RESTART_NV = 34136 	# GL/glext.h:2901
GL_PRIMITIVE_RESTART_INDEX_NV = 34137 	# GL/glext.h:2902
# NV_texture_expand_normal (GL/glext.h:2905)
GL_TEXTURE_UNSIGNED_REMAP_MODE_NV = 34959 	# GL/glext.h:2906
# NV_vertex_program2 (GL/glext.h:2909)
# ATI_map_object_buffer (GL/glext.h:2912)
# ATI_separate_stencil (GL/glext.h:2915)
GL_STENCIL_BACK_FUNC_ATI = 34816 	# GL/glext.h:2916
GL_STENCIL_BACK_FAIL_ATI = 34817 	# GL/glext.h:2917
GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI = 34818 	# GL/glext.h:2918
GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI = 34819 	# GL/glext.h:2919
# ATI_vertex_attrib_array_object (GL/glext.h:2922)
# OES_read_format (GL/glext.h:2925)
GL_IMPLEMENTATION_COLOR_READ_TYPE_OES = 35738 	# GL/glext.h:2926
GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES = 35739 	# GL/glext.h:2927
# EXT_depth_bounds_test (GL/glext.h:2930)
GL_DEPTH_BOUNDS_TEST_EXT = 34960 	# GL/glext.h:2931
GL_DEPTH_BOUNDS_EXT = 34961 	# GL/glext.h:2932
# EXT_texture_mirror_clamp (GL/glext.h:2935)
GL_MIRROR_CLAMP_EXT = 34626 	# GL/glext.h:2936
GL_MIRROR_CLAMP_TO_EDGE_EXT = 34627 	# GL/glext.h:2937
GL_MIRROR_CLAMP_TO_BORDER_EXT = 35090 	# GL/glext.h:2938
# EXT_blend_equation_separate (GL/glext.h:2941)
GL_BLEND_EQUATION_RGB_EXT = 32777 	# GL/glext.h:2942
GL_BLEND_EQUATION_ALPHA_EXT = 34877 	# GL/glext.h:2943
# MESA_pack_invert (GL/glext.h:2946)
GL_PACK_INVERT_MESA = 34648 	# GL/glext.h:2947
# MESA_ycbcr_texture (GL/glext.h:2950)
GL_UNSIGNED_SHORT_8_8_MESA = 34234 	# GL/glext.h:2951
GL_UNSIGNED_SHORT_8_8_REV_MESA = 34235 	# GL/glext.h:2952
GL_YCBCR_MESA = 34647 	# GL/glext.h:2953
# EXT_pixel_buffer_object (GL/glext.h:2956)
GL_PIXEL_PACK_BUFFER_EXT = 35051 	# GL/glext.h:2957
GL_PIXEL_UNPACK_BUFFER_EXT = 35052 	# GL/glext.h:2958
GL_PIXEL_PACK_BUFFER_BINDING_EXT = 35053 	# GL/glext.h:2959
GL_PIXEL_UNPACK_BUFFER_BINDING_EXT = 35055 	# GL/glext.h:2960
# NV_fragment_program_option (GL/glext.h:2963)
# NV_fragment_program2 (GL/glext.h:2966)
GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV = 35060 	# GL/glext.h:2967
GL_MAX_PROGRAM_CALL_DEPTH_NV = 35061 	# GL/glext.h:2968
GL_MAX_PROGRAM_IF_DEPTH_NV = 35062 	# GL/glext.h:2969
GL_MAX_PROGRAM_LOOP_DEPTH_NV = 35063 	# GL/glext.h:2970
GL_MAX_PROGRAM_LOOP_COUNT_NV = 35064 	# GL/glext.h:2971
# NV_vertex_program2_option (GL/glext.h:2974)
# NV_vertex_program3 (GL/glext.h:2979)
# EXT_framebuffer_object (GL/glext.h:2983)
GL_INVALID_FRAMEBUFFER_OPERATION_EXT = 1286 	# GL/glext.h:2984
GL_MAX_RENDERBUFFER_SIZE_EXT = 34024 	# GL/glext.h:2985
GL_FRAMEBUFFER_BINDING_EXT = 36006 	# GL/glext.h:2986
GL_RENDERBUFFER_BINDING_EXT = 36007 	# GL/glext.h:2987
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT = 36048 	# GL/glext.h:2988
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT = 36049 	# GL/glext.h:2989
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT = 36050 	# GL/glext.h:2990
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT = 36051 	# GL/glext.h:2991
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT = 36052 	# GL/glext.h:2992
GL_FRAMEBUFFER_COMPLETE_EXT = 36053 	# GL/glext.h:2993
GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT = 36054 	# GL/glext.h:2994
GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT = 36055 	# GL/glext.h:2995
GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT_EXT = 36056 	# GL/glext.h:2996
GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT = 36057 	# GL/glext.h:2997
GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT = 36058 	# GL/glext.h:2998
GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT = 36059 	# GL/glext.h:2999
GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT = 36060 	# GL/glext.h:3000
GL_FRAMEBUFFER_UNSUPPORTED_EXT = 36061 	# GL/glext.h:3001
GL_MAX_COLOR_ATTACHMENTS_EXT = 36063 	# GL/glext.h:3002
GL_COLOR_ATTACHMENT0_EXT = 36064 	# GL/glext.h:3003
GL_COLOR_ATTACHMENT1_EXT = 36065 	# GL/glext.h:3004
GL_COLOR_ATTACHMENT2_EXT = 36066 	# GL/glext.h:3005
GL_COLOR_ATTACHMENT3_EXT = 36067 	# GL/glext.h:3006
GL_COLOR_ATTACHMENT4_EXT = 36068 	# GL/glext.h:3007
GL_COLOR_ATTACHMENT5_EXT = 36069 	# GL/glext.h:3008
GL_COLOR_ATTACHMENT6_EXT = 36070 	# GL/glext.h:3009
GL_COLOR_ATTACHMENT7_EXT = 36071 	# GL/glext.h:3010
GL_COLOR_ATTACHMENT8_EXT = 36072 	# GL/glext.h:3011
GL_COLOR_ATTACHMENT9_EXT = 36073 	# GL/glext.h:3012
GL_COLOR_ATTACHMENT10_EXT = 36074 	# GL/glext.h:3013
GL_COLOR_ATTACHMENT11_EXT = 36075 	# GL/glext.h:3014
GL_COLOR_ATTACHMENT12_EXT = 36076 	# GL/glext.h:3015
GL_COLOR_ATTACHMENT13_EXT = 36077 	# GL/glext.h:3016
GL_COLOR_ATTACHMENT14_EXT = 36078 	# GL/glext.h:3017
GL_COLOR_ATTACHMENT15_EXT = 36079 	# GL/glext.h:3018
GL_DEPTH_ATTACHMENT_EXT = 36096 	# GL/glext.h:3019
GL_STENCIL_ATTACHMENT_EXT = 36128 	# GL/glext.h:3020
GL_FRAMEBUFFER_EXT = 36160 	# GL/glext.h:3021
GL_RENDERBUFFER_EXT = 36161 	# GL/glext.h:3022
GL_RENDERBUFFER_WIDTH_EXT = 36162 	# GL/glext.h:3023
GL_RENDERBUFFER_HEIGHT_EXT = 36163 	# GL/glext.h:3024
GL_RENDERBUFFER_INTERNAL_FORMAT_EXT = 36164 	# GL/glext.h:3025
GL_STENCIL_INDEX1_EXT = 36166 	# GL/glext.h:3026
GL_STENCIL_INDEX4_EXT = 36167 	# GL/glext.h:3027
GL_STENCIL_INDEX8_EXT = 36168 	# GL/glext.h:3028
GL_STENCIL_INDEX16_EXT = 36169 	# GL/glext.h:3029
GL_RENDERBUFFER_RED_SIZE_EXT = 36176 	# GL/glext.h:3030
GL_RENDERBUFFER_GREEN_SIZE_EXT = 36177 	# GL/glext.h:3031
GL_RENDERBUFFER_BLUE_SIZE_EXT = 36178 	# GL/glext.h:3032
GL_RENDERBUFFER_ALPHA_SIZE_EXT = 36179 	# GL/glext.h:3033
GL_RENDERBUFFER_DEPTH_SIZE_EXT = 36180 	# GL/glext.h:3034
GL_RENDERBUFFER_STENCIL_SIZE_EXT = 36181 	# GL/glext.h:3035
# GREMEDY_string_marker (GL/glext.h:3038)
# VERSION_2_0 (GL/glext.h:3045)
GLchar = c_char 	# GL/glext.h:3047
# VERSION_1_5 (GL/glext.h:3050)
GLintptr = c_ptrdiff_t 	# GL/glext.h:3052
GLsizeiptr = c_ptrdiff_t 	# GL/glext.h:3053
# ARB_vertex_buffer_object (GL/glext.h:3056)
GLintptrARB = c_ptrdiff_t 	# GL/glext.h:3058
GLsizeiptrARB = c_ptrdiff_t 	# GL/glext.h:3059
# ARB_shader_objects (GL/glext.h:3062)
GLcharARB = c_char 	# GL/glext.h:3064
GLhandleARB = c_uint 	# GL/glext.h:3065
# ARB_half_float_pixel (GL/glext.h:3069)
GLhalfARB = c_ushort 	# GL/glext.h:3070
# NV_half_float (GL/glext.h:3073)
GLhalfNV = c_ushort 	# GL/glext.h:3074
# VERSION_1_2 (GL/glext.h:3077)
GL_VERSION_1_2 = 1 	# GL/glext.h:3078
GLclampf = c_float 	# /usr/include/GL/gl.h:64
# GL/glext.h:3080
glBlendColor = _link_function('glBlendColor', None, [GLclampf, GLclampf, GLclampf, GLclampf], 'VERSION_1_2')

GLenum = c_uint 	# /usr/include/GL/gl.h:53
# GL/glext.h:3081
glBlendEquation = _link_function('glBlendEquation', None, [GLenum], 'VERSION_1_2')

GLuint = c_uint 	# /usr/include/GL/gl.h:62
GLsizei = c_int 	# /usr/include/GL/gl.h:59
GLvoid = None 	# /usr/include/GL/gl.h:67
# GL/glext.h:3082
glDrawRangeElements = _link_function('glDrawRangeElements', None, [GLenum, GLuint, GLuint, GLsizei, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3083
glColorTable = _link_function('glColorTable', None, [GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

GLfloat = c_float 	# /usr/include/GL/gl.h:63
# GL/glext.h:3084
glColorTableParameterfv = _link_function('glColorTableParameterfv', None, [GLenum, GLenum, POINTER(GLfloat)], 'VERSION_1_2')

GLint = c_int 	# /usr/include/GL/gl.h:58
# GL/glext.h:3085
glColorTableParameteriv = _link_function('glColorTableParameteriv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_2')

# GL/glext.h:3086
glCopyColorTable = _link_function('glCopyColorTable', None, [GLenum, GLenum, GLint, GLint, GLsizei], 'VERSION_1_2')

# GL/glext.h:3087
glGetColorTable = _link_function('glGetColorTable', None, [GLenum, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3088
glGetColorTableParameterfv = _link_function('glGetColorTableParameterfv', None, [GLenum, GLenum, POINTER(GLfloat)], 'VERSION_1_2')

# GL/glext.h:3089
glGetColorTableParameteriv = _link_function('glGetColorTableParameteriv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_2')

# GL/glext.h:3090
glColorSubTable = _link_function('glColorSubTable', None, [GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3091
glCopyColorSubTable = _link_function('glCopyColorSubTable', None, [GLenum, GLsizei, GLint, GLint, GLsizei], 'VERSION_1_2')

# GL/glext.h:3092
glConvolutionFilter1D = _link_function('glConvolutionFilter1D', None, [GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3093
glConvolutionFilter2D = _link_function('glConvolutionFilter2D', None, [GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3094
glConvolutionParameterf = _link_function('glConvolutionParameterf', None, [GLenum, GLenum, GLfloat], 'VERSION_1_2')

# GL/glext.h:3095
glConvolutionParameterfv = _link_function('glConvolutionParameterfv', None, [GLenum, GLenum, POINTER(GLfloat)], 'VERSION_1_2')

# GL/glext.h:3096
glConvolutionParameteri = _link_function('glConvolutionParameteri', None, [GLenum, GLenum, GLint], 'VERSION_1_2')

# GL/glext.h:3097
glConvolutionParameteriv = _link_function('glConvolutionParameteriv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_2')

# GL/glext.h:3098
glCopyConvolutionFilter1D = _link_function('glCopyConvolutionFilter1D', None, [GLenum, GLenum, GLint, GLint, GLsizei], 'VERSION_1_2')

# GL/glext.h:3099
glCopyConvolutionFilter2D = _link_function('glCopyConvolutionFilter2D', None, [GLenum, GLenum, GLint, GLint, GLsizei, GLsizei], 'VERSION_1_2')

# GL/glext.h:3100
glGetConvolutionFilter = _link_function('glGetConvolutionFilter', None, [GLenum, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3101
glGetConvolutionParameterfv = _link_function('glGetConvolutionParameterfv', None, [GLenum, GLenum, POINTER(GLfloat)], 'VERSION_1_2')

# GL/glext.h:3102
glGetConvolutionParameteriv = _link_function('glGetConvolutionParameteriv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_2')

# GL/glext.h:3103
glGetSeparableFilter = _link_function('glGetSeparableFilter', None, [GLenum, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid), POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3104
glSeparableFilter2D = _link_function('glSeparableFilter2D', None, [GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid)], 'VERSION_1_2')

GLboolean = c_ubyte 	# /usr/include/GL/gl.h:54
# GL/glext.h:3105
glGetHistogram = _link_function('glGetHistogram', None, [GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3106
glGetHistogramParameterfv = _link_function('glGetHistogramParameterfv', None, [GLenum, GLenum, POINTER(GLfloat)], 'VERSION_1_2')

# GL/glext.h:3107
glGetHistogramParameteriv = _link_function('glGetHistogramParameteriv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_2')

# GL/glext.h:3108
glGetMinmax = _link_function('glGetMinmax', None, [GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3109
glGetMinmaxParameterfv = _link_function('glGetMinmaxParameterfv', None, [GLenum, GLenum, POINTER(GLfloat)], 'VERSION_1_2')

# GL/glext.h:3110
glGetMinmaxParameteriv = _link_function('glGetMinmaxParameteriv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_2')

# GL/glext.h:3111
glHistogram = _link_function('glHistogram', None, [GLenum, GLsizei, GLenum, GLboolean], 'VERSION_1_2')

# GL/glext.h:3112
glMinmax = _link_function('glMinmax', None, [GLenum, GLenum, GLboolean], 'VERSION_1_2')

# GL/glext.h:3113
glResetHistogram = _link_function('glResetHistogram', None, [GLenum], 'VERSION_1_2')

# GL/glext.h:3114
glResetMinmax = _link_function('glResetMinmax', None, [GLenum], 'VERSION_1_2')

# GL/glext.h:3115
glTexImage3D = _link_function('glTexImage3D', None, [GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3116
glTexSubImage3D = _link_function('glTexSubImage3D', None, [GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3117
glCopyTexSubImage3D = _link_function('glCopyTexSubImage3D', None, [GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei], 'VERSION_1_2')

PFNGLBLENDCOLORPROC = CFUNCTYPE(None, GLclampf, GLclampf, GLclampf, GLclampf) 	# GL/glext.h:3119
PFNGLBLENDEQUATIONPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3120
PFNGLDRAWRANGEELEMENTSPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLsizei, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3121
PFNGLCOLORTABLEPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3122
PFNGLCOLORTABLEPARAMETERFVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3123
PFNGLCOLORTABLEPARAMETERIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3124
PFNGLCOPYCOLORTABLEPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLint, GLsizei) 	# GL/glext.h:3125
PFNGLGETCOLORTABLEPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3126
PFNGLGETCOLORTABLEPARAMETERFVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3127
PFNGLGETCOLORTABLEPARAMETERIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3128
PFNGLCOLORSUBTABLEPROC = CFUNCTYPE(None, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3129
PFNGLCOPYCOLORSUBTABLEPROC = CFUNCTYPE(None, GLenum, GLsizei, GLint, GLint, GLsizei) 	# GL/glext.h:3130
PFNGLCONVOLUTIONFILTER1DPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3131
PFNGLCONVOLUTIONFILTER2DPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3132
PFNGLCONVOLUTIONPARAMETERFPROC = CFUNCTYPE(None, GLenum, GLenum, GLfloat) 	# GL/glext.h:3133
PFNGLCONVOLUTIONPARAMETERFVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3134
PFNGLCONVOLUTIONPARAMETERIPROC = CFUNCTYPE(None, GLenum, GLenum, GLint) 	# GL/glext.h:3135
PFNGLCONVOLUTIONPARAMETERIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3136
PFNGLCOPYCONVOLUTIONFILTER1DPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLint, GLsizei) 	# GL/glext.h:3137
PFNGLCOPYCONVOLUTIONFILTER2DPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLint, GLsizei, GLsizei) 	# GL/glext.h:3138
PFNGLGETCONVOLUTIONFILTERPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3139
PFNGLGETCONVOLUTIONPARAMETERFVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3140
PFNGLGETCONVOLUTIONPARAMETERIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3141
PFNGLGETSEPARABLEFILTERPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid), POINTER(GLvoid)) 	# GL/glext.h:3142
PFNGLSEPARABLEFILTER2DPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid)) 	# GL/glext.h:3143
PFNGLGETHISTOGRAMPROC = CFUNCTYPE(None, GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3144
PFNGLGETHISTOGRAMPARAMETERFVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3145
PFNGLGETHISTOGRAMPARAMETERIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3146
PFNGLGETMINMAXPROC = CFUNCTYPE(None, GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3147
PFNGLGETMINMAXPARAMETERFVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3148
PFNGLGETMINMAXPARAMETERIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3149
PFNGLHISTOGRAMPROC = CFUNCTYPE(None, GLenum, GLsizei, GLenum, GLboolean) 	# GL/glext.h:3150
PFNGLMINMAXPROC = CFUNCTYPE(None, GLenum, GLenum, GLboolean) 	# GL/glext.h:3151
PFNGLRESETHISTOGRAMPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3152
PFNGLRESETMINMAXPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3153
PFNGLTEXIMAGE3DPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3154
PFNGLTEXSUBIMAGE3DPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3155
PFNGLCOPYTEXSUBIMAGE3DPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei) 	# GL/glext.h:3156
# VERSION_1_3 (GL/glext.h:3159)
GL_VERSION_1_3 = 1 	# GL/glext.h:3160
# GL/glext.h:3162
glActiveTexture = _link_function('glActiveTexture', None, [GLenum], 'VERSION_1_3')

# GL/glext.h:3163
glClientActiveTexture = _link_function('glClientActiveTexture', None, [GLenum], 'VERSION_1_3')

GLdouble = c_double 	# /usr/include/GL/gl.h:65
# GL/glext.h:3164
glMultiTexCoord1d = _link_function('glMultiTexCoord1d', None, [GLenum, GLdouble], 'VERSION_1_3')

# GL/glext.h:3165
glMultiTexCoord1dv = _link_function('glMultiTexCoord1dv', None, [GLenum, POINTER(GLdouble)], 'VERSION_1_3')

# GL/glext.h:3166
glMultiTexCoord1f = _link_function('glMultiTexCoord1f', None, [GLenum, GLfloat], 'VERSION_1_3')

# GL/glext.h:3167
glMultiTexCoord1fv = _link_function('glMultiTexCoord1fv', None, [GLenum, POINTER(GLfloat)], 'VERSION_1_3')

# GL/glext.h:3168
glMultiTexCoord1i = _link_function('glMultiTexCoord1i', None, [GLenum, GLint], 'VERSION_1_3')

# GL/glext.h:3169
glMultiTexCoord1iv = _link_function('glMultiTexCoord1iv', None, [GLenum, POINTER(GLint)], 'VERSION_1_3')

GLshort = c_short 	# /usr/include/GL/gl.h:57
# GL/glext.h:3170
glMultiTexCoord1s = _link_function('glMultiTexCoord1s', None, [GLenum, GLshort], 'VERSION_1_3')

# GL/glext.h:3171
glMultiTexCoord1sv = _link_function('glMultiTexCoord1sv', None, [GLenum, POINTER(GLshort)], 'VERSION_1_3')

# GL/glext.h:3172
glMultiTexCoord2d = _link_function('glMultiTexCoord2d', None, [GLenum, GLdouble, GLdouble], 'VERSION_1_3')

# GL/glext.h:3173
glMultiTexCoord2dv = _link_function('glMultiTexCoord2dv', None, [GLenum, POINTER(GLdouble)], 'VERSION_1_3')

# GL/glext.h:3174
glMultiTexCoord2f = _link_function('glMultiTexCoord2f', None, [GLenum, GLfloat, GLfloat], 'VERSION_1_3')

# GL/glext.h:3175
glMultiTexCoord2fv = _link_function('glMultiTexCoord2fv', None, [GLenum, POINTER(GLfloat)], 'VERSION_1_3')

# GL/glext.h:3176
glMultiTexCoord2i = _link_function('glMultiTexCoord2i', None, [GLenum, GLint, GLint], 'VERSION_1_3')

# GL/glext.h:3177
glMultiTexCoord2iv = _link_function('glMultiTexCoord2iv', None, [GLenum, POINTER(GLint)], 'VERSION_1_3')

# GL/glext.h:3178
glMultiTexCoord2s = _link_function('glMultiTexCoord2s', None, [GLenum, GLshort, GLshort], 'VERSION_1_3')

# GL/glext.h:3179
glMultiTexCoord2sv = _link_function('glMultiTexCoord2sv', None, [GLenum, POINTER(GLshort)], 'VERSION_1_3')

# GL/glext.h:3180
glMultiTexCoord3d = _link_function('glMultiTexCoord3d', None, [GLenum, GLdouble, GLdouble, GLdouble], 'VERSION_1_3')

# GL/glext.h:3181
glMultiTexCoord3dv = _link_function('glMultiTexCoord3dv', None, [GLenum, POINTER(GLdouble)], 'VERSION_1_3')

# GL/glext.h:3182
glMultiTexCoord3f = _link_function('glMultiTexCoord3f', None, [GLenum, GLfloat, GLfloat, GLfloat], 'VERSION_1_3')

# GL/glext.h:3183
glMultiTexCoord3fv = _link_function('glMultiTexCoord3fv', None, [GLenum, POINTER(GLfloat)], 'VERSION_1_3')

# GL/glext.h:3184
glMultiTexCoord3i = _link_function('glMultiTexCoord3i', None, [GLenum, GLint, GLint, GLint], 'VERSION_1_3')

# GL/glext.h:3185
glMultiTexCoord3iv = _link_function('glMultiTexCoord3iv', None, [GLenum, POINTER(GLint)], 'VERSION_1_3')

# GL/glext.h:3186
glMultiTexCoord3s = _link_function('glMultiTexCoord3s', None, [GLenum, GLshort, GLshort, GLshort], 'VERSION_1_3')

# GL/glext.h:3187
glMultiTexCoord3sv = _link_function('glMultiTexCoord3sv', None, [GLenum, POINTER(GLshort)], 'VERSION_1_3')

# GL/glext.h:3188
glMultiTexCoord4d = _link_function('glMultiTexCoord4d', None, [GLenum, GLdouble, GLdouble, GLdouble, GLdouble], 'VERSION_1_3')

# GL/glext.h:3189
glMultiTexCoord4dv = _link_function('glMultiTexCoord4dv', None, [GLenum, POINTER(GLdouble)], 'VERSION_1_3')

# GL/glext.h:3190
glMultiTexCoord4f = _link_function('glMultiTexCoord4f', None, [GLenum, GLfloat, GLfloat, GLfloat, GLfloat], 'VERSION_1_3')

# GL/glext.h:3191
glMultiTexCoord4fv = _link_function('glMultiTexCoord4fv', None, [GLenum, POINTER(GLfloat)], 'VERSION_1_3')

# GL/glext.h:3192
glMultiTexCoord4i = _link_function('glMultiTexCoord4i', None, [GLenum, GLint, GLint, GLint, GLint], 'VERSION_1_3')

# GL/glext.h:3193
glMultiTexCoord4iv = _link_function('glMultiTexCoord4iv', None, [GLenum, POINTER(GLint)], 'VERSION_1_3')

# GL/glext.h:3194
glMultiTexCoord4s = _link_function('glMultiTexCoord4s', None, [GLenum, GLshort, GLshort, GLshort, GLshort], 'VERSION_1_3')

# GL/glext.h:3195
glMultiTexCoord4sv = _link_function('glMultiTexCoord4sv', None, [GLenum, POINTER(GLshort)], 'VERSION_1_3')

# GL/glext.h:3196
glLoadTransposeMatrixf = _link_function('glLoadTransposeMatrixf', None, [POINTER(GLfloat)], 'VERSION_1_3')

# GL/glext.h:3197
glLoadTransposeMatrixd = _link_function('glLoadTransposeMatrixd', None, [POINTER(GLdouble)], 'VERSION_1_3')

# GL/glext.h:3198
glMultTransposeMatrixf = _link_function('glMultTransposeMatrixf', None, [POINTER(GLfloat)], 'VERSION_1_3')

# GL/glext.h:3199
glMultTransposeMatrixd = _link_function('glMultTransposeMatrixd', None, [POINTER(GLdouble)], 'VERSION_1_3')

# GL/glext.h:3200
glSampleCoverage = _link_function('glSampleCoverage', None, [GLclampf, GLboolean], 'VERSION_1_3')

# GL/glext.h:3201
glCompressedTexImage3D = _link_function('glCompressedTexImage3D', None, [GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)], 'VERSION_1_3')

# GL/glext.h:3202
glCompressedTexImage2D = _link_function('glCompressedTexImage2D', None, [GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)], 'VERSION_1_3')

# GL/glext.h:3203
glCompressedTexImage1D = _link_function('glCompressedTexImage1D', None, [GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, POINTER(GLvoid)], 'VERSION_1_3')

# GL/glext.h:3204
glCompressedTexSubImage3D = _link_function('glCompressedTexSubImage3D', None, [GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)], 'VERSION_1_3')

# GL/glext.h:3205
glCompressedTexSubImage2D = _link_function('glCompressedTexSubImage2D', None, [GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)], 'VERSION_1_3')

# GL/glext.h:3206
glCompressedTexSubImage1D = _link_function('glCompressedTexSubImage1D', None, [GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, POINTER(GLvoid)], 'VERSION_1_3')

# GL/glext.h:3207
glGetCompressedTexImage = _link_function('glGetCompressedTexImage', None, [GLenum, GLint, POINTER(GLvoid)], 'VERSION_1_3')

PFNGLACTIVETEXTUREPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3209
PFNGLCLIENTACTIVETEXTUREPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3210
PFNGLMULTITEXCOORD1DPROC = CFUNCTYPE(None, GLenum, GLdouble) 	# GL/glext.h:3211
PFNGLMULTITEXCOORD1DVPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3212
PFNGLMULTITEXCOORD1FPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:3213
PFNGLMULTITEXCOORD1FVPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3214
PFNGLMULTITEXCOORD1IPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:3215
PFNGLMULTITEXCOORD1IVPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3216
PFNGLMULTITEXCOORD1SPROC = CFUNCTYPE(None, GLenum, GLshort) 	# GL/glext.h:3217
PFNGLMULTITEXCOORD1SVPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3218
PFNGLMULTITEXCOORD2DPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble) 	# GL/glext.h:3219
PFNGLMULTITEXCOORD2DVPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3220
PFNGLMULTITEXCOORD2FPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat) 	# GL/glext.h:3221
PFNGLMULTITEXCOORD2FVPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3222
PFNGLMULTITEXCOORD2IPROC = CFUNCTYPE(None, GLenum, GLint, GLint) 	# GL/glext.h:3223
PFNGLMULTITEXCOORD2IVPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3224
PFNGLMULTITEXCOORD2SPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort) 	# GL/glext.h:3225
PFNGLMULTITEXCOORD2SVPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3226
PFNGLMULTITEXCOORD3DPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3227
PFNGLMULTITEXCOORD3DVPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3228
PFNGLMULTITEXCOORD3FPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3229
PFNGLMULTITEXCOORD3FVPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3230
PFNGLMULTITEXCOORD3IPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint) 	# GL/glext.h:3231
PFNGLMULTITEXCOORD3IVPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3232
PFNGLMULTITEXCOORD3SPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort, GLshort) 	# GL/glext.h:3233
PFNGLMULTITEXCOORD3SVPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3234
PFNGLMULTITEXCOORD4DPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3235
PFNGLMULTITEXCOORD4DVPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3236
PFNGLMULTITEXCOORD4FPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3237
PFNGLMULTITEXCOORD4FVPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3238
PFNGLMULTITEXCOORD4IPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint) 	# GL/glext.h:3239
PFNGLMULTITEXCOORD4IVPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3240
PFNGLMULTITEXCOORD4SPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort, GLshort, GLshort) 	# GL/glext.h:3241
PFNGLMULTITEXCOORD4SVPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3242
PFNGLLOADTRANSPOSEMATRIXFPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3243
PFNGLLOADTRANSPOSEMATRIXDPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3244
PFNGLMULTTRANSPOSEMATRIXFPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3245
PFNGLMULTTRANSPOSEMATRIXDPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3246
PFNGLSAMPLECOVERAGEPROC = CFUNCTYPE(None, GLclampf, GLboolean) 	# GL/glext.h:3247
PFNGLCOMPRESSEDTEXIMAGE3DPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3248
PFNGLCOMPRESSEDTEXIMAGE2DPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3249
PFNGLCOMPRESSEDTEXIMAGE1DPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3250
PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3251
PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3252
PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3253
PFNGLGETCOMPRESSEDTEXIMAGEPROC = CFUNCTYPE(None, GLenum, GLint, POINTER(GLvoid)) 	# GL/glext.h:3254
# VERSION_1_4 (GL/glext.h:3257)
GL_VERSION_1_4 = 1 	# GL/glext.h:3258
# GL/glext.h:3260
glBlendFuncSeparate = _link_function('glBlendFuncSeparate', None, [GLenum, GLenum, GLenum, GLenum], 'VERSION_1_4')

# GL/glext.h:3261
glFogCoordf = _link_function('glFogCoordf', None, [GLfloat], 'VERSION_1_4')

# GL/glext.h:3262
glFogCoordfv = _link_function('glFogCoordfv', None, [POINTER(GLfloat)], 'VERSION_1_4')

# GL/glext.h:3263
glFogCoordd = _link_function('glFogCoordd', None, [GLdouble], 'VERSION_1_4')

# GL/glext.h:3264
glFogCoorddv = _link_function('glFogCoorddv', None, [POINTER(GLdouble)], 'VERSION_1_4')

# GL/glext.h:3265
glFogCoordPointer = _link_function('glFogCoordPointer', None, [GLenum, GLsizei, POINTER(GLvoid)], 'VERSION_1_4')

# GL/glext.h:3266
glMultiDrawArrays = _link_function('glMultiDrawArrays', None, [GLenum, POINTER(GLint), POINTER(GLsizei), GLsizei], 'VERSION_1_4')

# GL/glext.h:3267
glMultiDrawElements = _link_function('glMultiDrawElements', None, [GLenum, POINTER(GLsizei), GLenum, POINTER(POINTER(GLvoid)), GLsizei], 'VERSION_1_4')

# GL/glext.h:3268
glPointParameterf = _link_function('glPointParameterf', None, [GLenum, GLfloat], 'VERSION_1_4')

# GL/glext.h:3269
glPointParameterfv = _link_function('glPointParameterfv', None, [GLenum, POINTER(GLfloat)], 'VERSION_1_4')

# GL/glext.h:3270
glPointParameteri = _link_function('glPointParameteri', None, [GLenum, GLint], 'VERSION_1_4')

# GL/glext.h:3271
glPointParameteriv = _link_function('glPointParameteriv', None, [GLenum, POINTER(GLint)], 'VERSION_1_4')

GLbyte = c_char 	# /usr/include/GL/gl.h:56
# GL/glext.h:3272
glSecondaryColor3b = _link_function('glSecondaryColor3b', None, [GLbyte, GLbyte, GLbyte], 'VERSION_1_4')

# GL/glext.h:3273
glSecondaryColor3bv = _link_function('glSecondaryColor3bv', None, [POINTER(GLbyte)], 'VERSION_1_4')

# GL/glext.h:3274
glSecondaryColor3d = _link_function('glSecondaryColor3d', None, [GLdouble, GLdouble, GLdouble], 'VERSION_1_4')

# GL/glext.h:3275
glSecondaryColor3dv = _link_function('glSecondaryColor3dv', None, [POINTER(GLdouble)], 'VERSION_1_4')

# GL/glext.h:3276
glSecondaryColor3f = _link_function('glSecondaryColor3f', None, [GLfloat, GLfloat, GLfloat], 'VERSION_1_4')

# GL/glext.h:3277
glSecondaryColor3fv = _link_function('glSecondaryColor3fv', None, [POINTER(GLfloat)], 'VERSION_1_4')

# GL/glext.h:3278
glSecondaryColor3i = _link_function('glSecondaryColor3i', None, [GLint, GLint, GLint], 'VERSION_1_4')

# GL/glext.h:3279
glSecondaryColor3iv = _link_function('glSecondaryColor3iv', None, [POINTER(GLint)], 'VERSION_1_4')

# GL/glext.h:3280
glSecondaryColor3s = _link_function('glSecondaryColor3s', None, [GLshort, GLshort, GLshort], 'VERSION_1_4')

# GL/glext.h:3281
glSecondaryColor3sv = _link_function('glSecondaryColor3sv', None, [POINTER(GLshort)], 'VERSION_1_4')

GLubyte = c_ubyte 	# /usr/include/GL/gl.h:60
# GL/glext.h:3282
glSecondaryColor3ub = _link_function('glSecondaryColor3ub', None, [GLubyte, GLubyte, GLubyte], 'VERSION_1_4')

# GL/glext.h:3283
glSecondaryColor3ubv = _link_function('glSecondaryColor3ubv', None, [POINTER(GLubyte)], 'VERSION_1_4')

# GL/glext.h:3284
glSecondaryColor3ui = _link_function('glSecondaryColor3ui', None, [GLuint, GLuint, GLuint], 'VERSION_1_4')

# GL/glext.h:3285
glSecondaryColor3uiv = _link_function('glSecondaryColor3uiv', None, [POINTER(GLuint)], 'VERSION_1_4')

GLushort = c_ushort 	# /usr/include/GL/gl.h:61
# GL/glext.h:3286
glSecondaryColor3us = _link_function('glSecondaryColor3us', None, [GLushort, GLushort, GLushort], 'VERSION_1_4')

# GL/glext.h:3287
glSecondaryColor3usv = _link_function('glSecondaryColor3usv', None, [POINTER(GLushort)], 'VERSION_1_4')

# GL/glext.h:3288
glSecondaryColorPointer = _link_function('glSecondaryColorPointer', None, [GLint, GLenum, GLsizei, POINTER(GLvoid)], 'VERSION_1_4')

# GL/glext.h:3289
glWindowPos2d = _link_function('glWindowPos2d', None, [GLdouble, GLdouble], 'VERSION_1_4')

# GL/glext.h:3290
glWindowPos2dv = _link_function('glWindowPos2dv', None, [POINTER(GLdouble)], 'VERSION_1_4')

# GL/glext.h:3291
glWindowPos2f = _link_function('glWindowPos2f', None, [GLfloat, GLfloat], 'VERSION_1_4')

# GL/glext.h:3292
glWindowPos2fv = _link_function('glWindowPos2fv', None, [POINTER(GLfloat)], 'VERSION_1_4')

# GL/glext.h:3293
glWindowPos2i = _link_function('glWindowPos2i', None, [GLint, GLint], 'VERSION_1_4')

# GL/glext.h:3294
glWindowPos2iv = _link_function('glWindowPos2iv', None, [POINTER(GLint)], 'VERSION_1_4')

# GL/glext.h:3295
glWindowPos2s = _link_function('glWindowPos2s', None, [GLshort, GLshort], 'VERSION_1_4')

# GL/glext.h:3296
glWindowPos2sv = _link_function('glWindowPos2sv', None, [POINTER(GLshort)], 'VERSION_1_4')

# GL/glext.h:3297
glWindowPos3d = _link_function('glWindowPos3d', None, [GLdouble, GLdouble, GLdouble], 'VERSION_1_4')

# GL/glext.h:3298
glWindowPos3dv = _link_function('glWindowPos3dv', None, [POINTER(GLdouble)], 'VERSION_1_4')

# GL/glext.h:3299
glWindowPos3f = _link_function('glWindowPos3f', None, [GLfloat, GLfloat, GLfloat], 'VERSION_1_4')

# GL/glext.h:3300
glWindowPos3fv = _link_function('glWindowPos3fv', None, [POINTER(GLfloat)], 'VERSION_1_4')

# GL/glext.h:3301
glWindowPos3i = _link_function('glWindowPos3i', None, [GLint, GLint, GLint], 'VERSION_1_4')

# GL/glext.h:3302
glWindowPos3iv = _link_function('glWindowPos3iv', None, [POINTER(GLint)], 'VERSION_1_4')

# GL/glext.h:3303
glWindowPos3s = _link_function('glWindowPos3s', None, [GLshort, GLshort, GLshort], 'VERSION_1_4')

# GL/glext.h:3304
glWindowPos3sv = _link_function('glWindowPos3sv', None, [POINTER(GLshort)], 'VERSION_1_4')

PFNGLBLENDFUNCSEPARATEPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:3306
PFNGLFOGCOORDFPROC = CFUNCTYPE(None, GLfloat) 	# GL/glext.h:3307
PFNGLFOGCOORDFVPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3308
PFNGLFOGCOORDDPROC = CFUNCTYPE(None, GLdouble) 	# GL/glext.h:3309
PFNGLFOGCOORDDVPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3310
PFNGLFOGCOORDPOINTERPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3311
PFNGLMULTIDRAWARRAYSPROC = CFUNCTYPE(None, GLenum, POINTER(GLint), POINTER(GLsizei), GLsizei) 	# GL/glext.h:3312
PFNGLMULTIDRAWELEMENTSPROC = CFUNCTYPE(None, GLenum, POINTER(GLsizei), GLenum, POINTER(POINTER(GLvoid)), GLsizei) 	# GL/glext.h:3313
PFNGLPOINTPARAMETERFPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:3314
PFNGLPOINTPARAMETERFVPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3315
PFNGLPOINTPARAMETERIPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:3316
PFNGLPOINTPARAMETERIVPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3317
PFNGLSECONDARYCOLOR3BPROC = CFUNCTYPE(None, GLbyte, GLbyte, GLbyte) 	# GL/glext.h:3318
PFNGLSECONDARYCOLOR3BVPROC = CFUNCTYPE(None, POINTER(GLbyte)) 	# GL/glext.h:3319
PFNGLSECONDARYCOLOR3DPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3320
PFNGLSECONDARYCOLOR3DVPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3321
PFNGLSECONDARYCOLOR3FPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3322
PFNGLSECONDARYCOLOR3FVPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3323
PFNGLSECONDARYCOLOR3IPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:3324
PFNGLSECONDARYCOLOR3IVPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:3325
PFNGLSECONDARYCOLOR3SPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort) 	# GL/glext.h:3326
PFNGLSECONDARYCOLOR3SVPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:3327
PFNGLSECONDARYCOLOR3UBPROC = CFUNCTYPE(None, GLubyte, GLubyte, GLubyte) 	# GL/glext.h:3328
PFNGLSECONDARYCOLOR3UBVPROC = CFUNCTYPE(None, POINTER(GLubyte)) 	# GL/glext.h:3329
PFNGLSECONDARYCOLOR3UIPROC = CFUNCTYPE(None, GLuint, GLuint, GLuint) 	# GL/glext.h:3330
PFNGLSECONDARYCOLOR3UIVPROC = CFUNCTYPE(None, POINTER(GLuint)) 	# GL/glext.h:3331
PFNGLSECONDARYCOLOR3USPROC = CFUNCTYPE(None, GLushort, GLushort, GLushort) 	# GL/glext.h:3332
PFNGLSECONDARYCOLOR3USVPROC = CFUNCTYPE(None, POINTER(GLushort)) 	# GL/glext.h:3333
PFNGLSECONDARYCOLORPOINTERPROC = CFUNCTYPE(None, GLint, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3334
PFNGLWINDOWPOS2DPROC = CFUNCTYPE(None, GLdouble, GLdouble) 	# GL/glext.h:3335
PFNGLWINDOWPOS2DVPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3336
PFNGLWINDOWPOS2FPROC = CFUNCTYPE(None, GLfloat, GLfloat) 	# GL/glext.h:3337
PFNGLWINDOWPOS2FVPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3338
PFNGLWINDOWPOS2IPROC = CFUNCTYPE(None, GLint, GLint) 	# GL/glext.h:3339
PFNGLWINDOWPOS2IVPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:3340
PFNGLWINDOWPOS2SPROC = CFUNCTYPE(None, GLshort, GLshort) 	# GL/glext.h:3341
PFNGLWINDOWPOS2SVPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:3342
PFNGLWINDOWPOS3DPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3343
PFNGLWINDOWPOS3DVPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3344
PFNGLWINDOWPOS3FPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3345
PFNGLWINDOWPOS3FVPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3346
PFNGLWINDOWPOS3IPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:3347
PFNGLWINDOWPOS3IVPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:3348
PFNGLWINDOWPOS3SPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort) 	# GL/glext.h:3349
PFNGLWINDOWPOS3SVPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:3350
# VERSION_1_5 (GL/glext.h:3353)
GL_VERSION_1_5 = 1 	# GL/glext.h:3354
# GL/glext.h:3356
glGenQueries = _link_function('glGenQueries', None, [GLsizei, POINTER(GLuint)], 'VERSION_1_5')

# GL/glext.h:3357
glDeleteQueries = _link_function('glDeleteQueries', None, [GLsizei, POINTER(GLuint)], 'VERSION_1_5')

# GL/glext.h:3358
glIsQuery = _link_function('glIsQuery', GLboolean, [GLuint], 'VERSION_1_5')

# GL/glext.h:3359
glBeginQuery = _link_function('glBeginQuery', None, [GLenum, GLuint], 'VERSION_1_5')

# GL/glext.h:3360
glEndQuery = _link_function('glEndQuery', None, [GLenum], 'VERSION_1_5')

# GL/glext.h:3361
glGetQueryiv = _link_function('glGetQueryiv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_5')

# GL/glext.h:3362
glGetQueryObjectiv = _link_function('glGetQueryObjectiv', None, [GLuint, GLenum, POINTER(GLint)], 'VERSION_1_5')

# GL/glext.h:3363
glGetQueryObjectuiv = _link_function('glGetQueryObjectuiv', None, [GLuint, GLenum, POINTER(GLuint)], 'VERSION_1_5')

# GL/glext.h:3364
glBindBuffer = _link_function('glBindBuffer', None, [GLenum, GLuint], 'VERSION_1_5')

# GL/glext.h:3365
glDeleteBuffers = _link_function('glDeleteBuffers', None, [GLsizei, POINTER(GLuint)], 'VERSION_1_5')

# GL/glext.h:3366
glGenBuffers = _link_function('glGenBuffers', None, [GLsizei, POINTER(GLuint)], 'VERSION_1_5')

# GL/glext.h:3367
glIsBuffer = _link_function('glIsBuffer', GLboolean, [GLuint], 'VERSION_1_5')

# GL/glext.h:3368
glBufferData = _link_function('glBufferData', None, [GLenum, GLsizeiptr, POINTER(GLvoid), GLenum], 'VERSION_1_5')

# GL/glext.h:3369
glBufferSubData = _link_function('glBufferSubData', None, [GLenum, GLintptr, GLsizeiptr, POINTER(GLvoid)], 'VERSION_1_5')

# GL/glext.h:3370
glGetBufferSubData = _link_function('glGetBufferSubData', None, [GLenum, GLintptr, GLsizeiptr, POINTER(GLvoid)], 'VERSION_1_5')

# GL/glext.h:3371
glMapBuffer = _link_function('glMapBuffer', POINTER(GLvoid), [GLenum, GLenum], 'VERSION_1_5')

# GL/glext.h:3372
glUnmapBuffer = _link_function('glUnmapBuffer', GLboolean, [GLenum], 'VERSION_1_5')

# GL/glext.h:3373
glGetBufferParameteriv = _link_function('glGetBufferParameteriv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_5')

# GL/glext.h:3374
glGetBufferPointerv = _link_function('glGetBufferPointerv', None, [GLenum, GLenum, POINTER(POINTER(GLvoid))], 'VERSION_1_5')

PFNGLGENQUERIESPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:3376
PFNGLDELETEQUERIESPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:3377
PFNGLISQUERYPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:3378
PFNGLBEGINQUERYPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:3379
PFNGLENDQUERYPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3380
PFNGLGETQUERYIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3381
PFNGLGETQUERYOBJECTIVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:3382
PFNGLGETQUERYOBJECTUIVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLuint)) 	# GL/glext.h:3383
PFNGLBINDBUFFERPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:3384
PFNGLDELETEBUFFERSPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:3385
PFNGLGENBUFFERSPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:3386
PFNGLISBUFFERPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:3387
PFNGLBUFFERDATAPROC = CFUNCTYPE(None, GLenum, GLsizeiptr, POINTER(GLvoid), GLenum) 	# GL/glext.h:3388
PFNGLBUFFERSUBDATAPROC = CFUNCTYPE(None, GLenum, GLintptr, GLsizeiptr, POINTER(GLvoid)) 	# GL/glext.h:3389
PFNGLGETBUFFERSUBDATAPROC = CFUNCTYPE(None, GLenum, GLintptr, GLsizeiptr, POINTER(GLvoid)) 	# GL/glext.h:3390
PFNGLMAPBUFFERPROC = CFUNCTYPE(POINTER(GLvoid), GLenum, GLenum) 	# GL/glext.h:3391
PFNGLUNMAPBUFFERPROC = CFUNCTYPE(GLboolean, GLenum) 	# GL/glext.h:3392
PFNGLGETBUFFERPARAMETERIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3393
PFNGLGETBUFFERPOINTERVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:3394
# VERSION_2_0 (GL/glext.h:3397)
GL_VERSION_2_0 = 1 	# GL/glext.h:3398
# GL/glext.h:3400
glBlendEquationSeparate = _link_function('glBlendEquationSeparate', None, [GLenum, GLenum], 'VERSION_2_0')

# GL/glext.h:3401
glDrawBuffers = _link_function('glDrawBuffers', None, [GLsizei, POINTER(GLenum)], 'VERSION_2_0')

# GL/glext.h:3402
glStencilOpSeparate = _link_function('glStencilOpSeparate', None, [GLenum, GLenum, GLenum, GLenum], 'VERSION_2_0')

# GL/glext.h:3403
glStencilFuncSeparate = _link_function('glStencilFuncSeparate', None, [GLenum, GLenum, GLint, GLuint], 'VERSION_2_0')

# GL/glext.h:3404
glStencilMaskSeparate = _link_function('glStencilMaskSeparate', None, [GLenum, GLuint], 'VERSION_2_0')

# GL/glext.h:3405
glAttachShader = _link_function('glAttachShader', None, [GLuint, GLuint], 'VERSION_2_0')

# GL/glext.h:3406
glBindAttribLocation = _link_function('glBindAttribLocation', None, [GLuint, GLuint, POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3407
glCompileShader = _link_function('glCompileShader', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3408
glCreateProgram = _link_function('glCreateProgram', GLuint, [], 'VERSION_2_0')

# GL/glext.h:3409
glCreateShader = _link_function('glCreateShader', GLuint, [GLenum], 'VERSION_2_0')

# GL/glext.h:3410
glDeleteProgram = _link_function('glDeleteProgram', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3411
glDeleteShader = _link_function('glDeleteShader', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3412
glDetachShader = _link_function('glDetachShader', None, [GLuint, GLuint], 'VERSION_2_0')

# GL/glext.h:3413
glDisableVertexAttribArray = _link_function('glDisableVertexAttribArray', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3414
glEnableVertexAttribArray = _link_function('glEnableVertexAttribArray', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3415
glGetActiveAttrib = _link_function('glGetActiveAttrib', None, [GLuint, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3416
glGetActiveUniform = _link_function('glGetActiveUniform', None, [GLuint, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3417
glGetAttachedShaders = _link_function('glGetAttachedShaders', None, [GLuint, GLsizei, POINTER(GLsizei), POINTER(GLuint)], 'VERSION_2_0')

# GL/glext.h:3418
glGetAttribLocation = _link_function('glGetAttribLocation', GLint, [GLuint, POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3419
glGetProgramiv = _link_function('glGetProgramiv', None, [GLuint, GLenum, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3420
glGetProgramInfoLog = _link_function('glGetProgramInfoLog', None, [GLuint, GLsizei, POINTER(GLsizei), POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3421
glGetShaderiv = _link_function('glGetShaderiv', None, [GLuint, GLenum, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3422
glGetShaderInfoLog = _link_function('glGetShaderInfoLog', None, [GLuint, GLsizei, POINTER(GLsizei), POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3423
glGetShaderSource = _link_function('glGetShaderSource', None, [GLuint, GLsizei, POINTER(GLsizei), POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3424
glGetUniformLocation = _link_function('glGetUniformLocation', GLint, [GLuint, POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3425
glGetUniformfv = _link_function('glGetUniformfv', None, [GLuint, GLint, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3426
glGetUniformiv = _link_function('glGetUniformiv', None, [GLuint, GLint, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3427
glGetVertexAttribdv = _link_function('glGetVertexAttribdv', None, [GLuint, GLenum, POINTER(GLdouble)], 'VERSION_2_0')

# GL/glext.h:3428
glGetVertexAttribfv = _link_function('glGetVertexAttribfv', None, [GLuint, GLenum, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3429
glGetVertexAttribiv = _link_function('glGetVertexAttribiv', None, [GLuint, GLenum, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3430
glGetVertexAttribPointerv = _link_function('glGetVertexAttribPointerv', None, [GLuint, GLenum, POINTER(POINTER(GLvoid))], 'VERSION_2_0')

# GL/glext.h:3431
glIsProgram = _link_function('glIsProgram', GLboolean, [GLuint], 'VERSION_2_0')

# GL/glext.h:3432
glIsShader = _link_function('glIsShader', GLboolean, [GLuint], 'VERSION_2_0')

# GL/glext.h:3433
glLinkProgram = _link_function('glLinkProgram', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3434
glShaderSource = _link_function('glShaderSource', None, [GLuint, GLsizei, POINTER(POINTER(GLchar)), POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3435
glUseProgram = _link_function('glUseProgram', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3436
glUniform1f = _link_function('glUniform1f', None, [GLint, GLfloat], 'VERSION_2_0')

# GL/glext.h:3437
glUniform2f = _link_function('glUniform2f', None, [GLint, GLfloat, GLfloat], 'VERSION_2_0')

# GL/glext.h:3438
glUniform3f = _link_function('glUniform3f', None, [GLint, GLfloat, GLfloat, GLfloat], 'VERSION_2_0')

# GL/glext.h:3439
glUniform4f = _link_function('glUniform4f', None, [GLint, GLfloat, GLfloat, GLfloat, GLfloat], 'VERSION_2_0')

# GL/glext.h:3440
glUniform1i = _link_function('glUniform1i', None, [GLint, GLint], 'VERSION_2_0')

# GL/glext.h:3441
glUniform2i = _link_function('glUniform2i', None, [GLint, GLint, GLint], 'VERSION_2_0')

# GL/glext.h:3442
glUniform3i = _link_function('glUniform3i', None, [GLint, GLint, GLint, GLint], 'VERSION_2_0')

# GL/glext.h:3443
glUniform4i = _link_function('glUniform4i', None, [GLint, GLint, GLint, GLint, GLint], 'VERSION_2_0')

# GL/glext.h:3444
glUniform1fv = _link_function('glUniform1fv', None, [GLint, GLsizei, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3445
glUniform2fv = _link_function('glUniform2fv', None, [GLint, GLsizei, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3446
glUniform3fv = _link_function('glUniform3fv', None, [GLint, GLsizei, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3447
glUniform4fv = _link_function('glUniform4fv', None, [GLint, GLsizei, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3448
glUniform1iv = _link_function('glUniform1iv', None, [GLint, GLsizei, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3449
glUniform2iv = _link_function('glUniform2iv', None, [GLint, GLsizei, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3450
glUniform3iv = _link_function('glUniform3iv', None, [GLint, GLsizei, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3451
glUniform4iv = _link_function('glUniform4iv', None, [GLint, GLsizei, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3452
glUniformMatrix2fv = _link_function('glUniformMatrix2fv', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3453
glUniformMatrix3fv = _link_function('glUniformMatrix3fv', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3454
glUniformMatrix4fv = _link_function('glUniformMatrix4fv', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3455
glValidateProgram = _link_function('glValidateProgram', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3456
glVertexAttrib1d = _link_function('glVertexAttrib1d', None, [GLuint, GLdouble], 'VERSION_2_0')

# GL/glext.h:3457
glVertexAttrib1dv = _link_function('glVertexAttrib1dv', None, [GLuint, POINTER(GLdouble)], 'VERSION_2_0')

# GL/glext.h:3458
glVertexAttrib1f = _link_function('glVertexAttrib1f', None, [GLuint, GLfloat], 'VERSION_2_0')

# GL/glext.h:3459
glVertexAttrib1fv = _link_function('glVertexAttrib1fv', None, [GLuint, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3460
glVertexAttrib1s = _link_function('glVertexAttrib1s', None, [GLuint, GLshort], 'VERSION_2_0')

# GL/glext.h:3461
glVertexAttrib1sv = _link_function('glVertexAttrib1sv', None, [GLuint, POINTER(GLshort)], 'VERSION_2_0')

# GL/glext.h:3462
glVertexAttrib2d = _link_function('glVertexAttrib2d', None, [GLuint, GLdouble, GLdouble], 'VERSION_2_0')

# GL/glext.h:3463
glVertexAttrib2dv = _link_function('glVertexAttrib2dv', None, [GLuint, POINTER(GLdouble)], 'VERSION_2_0')

# GL/glext.h:3464
glVertexAttrib2f = _link_function('glVertexAttrib2f', None, [GLuint, GLfloat, GLfloat], 'VERSION_2_0')

# GL/glext.h:3465
glVertexAttrib2fv = _link_function('glVertexAttrib2fv', None, [GLuint, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3466
glVertexAttrib2s = _link_function('glVertexAttrib2s', None, [GLuint, GLshort, GLshort], 'VERSION_2_0')

# GL/glext.h:3467
glVertexAttrib2sv = _link_function('glVertexAttrib2sv', None, [GLuint, POINTER(GLshort)], 'VERSION_2_0')

# GL/glext.h:3468
glVertexAttrib3d = _link_function('glVertexAttrib3d', None, [GLuint, GLdouble, GLdouble, GLdouble], 'VERSION_2_0')

# GL/glext.h:3469
glVertexAttrib3dv = _link_function('glVertexAttrib3dv', None, [GLuint, POINTER(GLdouble)], 'VERSION_2_0')

# GL/glext.h:3470
glVertexAttrib3f = _link_function('glVertexAttrib3f', None, [GLuint, GLfloat, GLfloat, GLfloat], 'VERSION_2_0')

# GL/glext.h:3471
glVertexAttrib3fv = _link_function('glVertexAttrib3fv', None, [GLuint, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3472
glVertexAttrib3s = _link_function('glVertexAttrib3s', None, [GLuint, GLshort, GLshort, GLshort], 'VERSION_2_0')

# GL/glext.h:3473
glVertexAttrib3sv = _link_function('glVertexAttrib3sv', None, [GLuint, POINTER(GLshort)], 'VERSION_2_0')

# GL/glext.h:3474
glVertexAttrib4Nbv = _link_function('glVertexAttrib4Nbv', None, [GLuint, POINTER(GLbyte)], 'VERSION_2_0')

# GL/glext.h:3475
glVertexAttrib4Niv = _link_function('glVertexAttrib4Niv', None, [GLuint, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3476
glVertexAttrib4Nsv = _link_function('glVertexAttrib4Nsv', None, [GLuint, POINTER(GLshort)], 'VERSION_2_0')

# GL/glext.h:3477
glVertexAttrib4Nub = _link_function('glVertexAttrib4Nub', None, [GLuint, GLubyte, GLubyte, GLubyte, GLubyte], 'VERSION_2_0')

# GL/glext.h:3478
glVertexAttrib4Nubv = _link_function('glVertexAttrib4Nubv', None, [GLuint, POINTER(GLubyte)], 'VERSION_2_0')

# GL/glext.h:3479
glVertexAttrib4Nuiv = _link_function('glVertexAttrib4Nuiv', None, [GLuint, POINTER(GLuint)], 'VERSION_2_0')

# GL/glext.h:3480
glVertexAttrib4Nusv = _link_function('glVertexAttrib4Nusv', None, [GLuint, POINTER(GLushort)], 'VERSION_2_0')

# GL/glext.h:3481
glVertexAttrib4bv = _link_function('glVertexAttrib4bv', None, [GLuint, POINTER(GLbyte)], 'VERSION_2_0')

# GL/glext.h:3482
glVertexAttrib4d = _link_function('glVertexAttrib4d', None, [GLuint, GLdouble, GLdouble, GLdouble, GLdouble], 'VERSION_2_0')

# GL/glext.h:3483
glVertexAttrib4dv = _link_function('glVertexAttrib4dv', None, [GLuint, POINTER(GLdouble)], 'VERSION_2_0')

# GL/glext.h:3484
glVertexAttrib4f = _link_function('glVertexAttrib4f', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat], 'VERSION_2_0')

# GL/glext.h:3485
glVertexAttrib4fv = _link_function('glVertexAttrib4fv', None, [GLuint, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3486
glVertexAttrib4iv = _link_function('glVertexAttrib4iv', None, [GLuint, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3487
glVertexAttrib4s = _link_function('glVertexAttrib4s', None, [GLuint, GLshort, GLshort, GLshort, GLshort], 'VERSION_2_0')

# GL/glext.h:3488
glVertexAttrib4sv = _link_function('glVertexAttrib4sv', None, [GLuint, POINTER(GLshort)], 'VERSION_2_0')

# GL/glext.h:3489
glVertexAttrib4ubv = _link_function('glVertexAttrib4ubv', None, [GLuint, POINTER(GLubyte)], 'VERSION_2_0')

# GL/glext.h:3490
glVertexAttrib4uiv = _link_function('glVertexAttrib4uiv', None, [GLuint, POINTER(GLuint)], 'VERSION_2_0')

# GL/glext.h:3491
glVertexAttrib4usv = _link_function('glVertexAttrib4usv', None, [GLuint, POINTER(GLushort)], 'VERSION_2_0')

# GL/glext.h:3492
glVertexAttribPointer = _link_function('glVertexAttribPointer', None, [GLuint, GLint, GLenum, GLboolean, GLsizei, POINTER(GLvoid)], 'VERSION_2_0')

PFNGLBLENDEQUATIONSEPARATEPROC = CFUNCTYPE(None, GLenum, GLenum) 	# GL/glext.h:3494
PFNGLDRAWBUFFERSPROC = CFUNCTYPE(None, GLsizei, POINTER(GLenum)) 	# GL/glext.h:3495
PFNGLSTENCILOPSEPARATEPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:3496
PFNGLSTENCILFUNCSEPARATEPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLuint) 	# GL/glext.h:3497
PFNGLSTENCILMASKSEPARATEPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:3498
PFNGLATTACHSHADERPROC = CFUNCTYPE(None, GLuint, GLuint) 	# GL/glext.h:3499
PFNGLBINDATTRIBLOCATIONPROC = CFUNCTYPE(None, GLuint, GLuint, POINTER(GLchar)) 	# GL/glext.h:3500
PFNGLCOMPILESHADERPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3501
PFNGLCREATEPROGRAMPROC = CFUNCTYPE(GLuint) 	# GL/glext.h:3502
PFNGLCREATESHADERPROC = CFUNCTYPE(GLuint, GLenum) 	# GL/glext.h:3503
PFNGLDELETEPROGRAMPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3504
PFNGLDELETESHADERPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3505
PFNGLDETACHSHADERPROC = CFUNCTYPE(None, GLuint, GLuint) 	# GL/glext.h:3506
PFNGLDISABLEVERTEXATTRIBARRAYPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3507
PFNGLENABLEVERTEXATTRIBARRAYPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3508
PFNGLGETACTIVEATTRIBPROC = CFUNCTYPE(None, GLuint, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLchar)) 	# GL/glext.h:3509
PFNGLGETACTIVEUNIFORMPROC = CFUNCTYPE(None, GLuint, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLchar)) 	# GL/glext.h:3510
PFNGLGETATTACHEDSHADERSPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLuint)) 	# GL/glext.h:3511
PFNGLGETATTRIBLOCATIONPROC = CFUNCTYPE(GLint, GLuint, POINTER(GLchar)) 	# GL/glext.h:3512
PFNGLGETPROGRAMIVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:3513
PFNGLGETPROGRAMINFOLOGPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLchar)) 	# GL/glext.h:3514
PFNGLGETSHADERIVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:3515
PFNGLGETSHADERINFOLOGPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLchar)) 	# GL/glext.h:3516
PFNGLGETSHADERSOURCEPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLchar)) 	# GL/glext.h:3517
PFNGLGETUNIFORMLOCATIONPROC = CFUNCTYPE(GLint, GLuint, POINTER(GLchar)) 	# GL/glext.h:3518
PFNGLGETUNIFORMFVPROC = CFUNCTYPE(None, GLuint, GLint, POINTER(GLfloat)) 	# GL/glext.h:3519
PFNGLGETUNIFORMIVPROC = CFUNCTYPE(None, GLuint, GLint, POINTER(GLint)) 	# GL/glext.h:3520
PFNGLGETVERTEXATTRIBDVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3521
PFNGLGETVERTEXATTRIBFVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3522
PFNGLGETVERTEXATTRIBIVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:3523
PFNGLGETVERTEXATTRIBPOINTERVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:3524
PFNGLISPROGRAMPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:3525
PFNGLISSHADERPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:3526
PFNGLLINKPROGRAMPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3527
PFNGLSHADERSOURCEPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(POINTER(GLchar)), POINTER(GLint)) 	# GL/glext.h:3528
PFNGLUSEPROGRAMPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3529
PFNGLUNIFORM1FPROC = CFUNCTYPE(None, GLint, GLfloat) 	# GL/glext.h:3530
PFNGLUNIFORM2FPROC = CFUNCTYPE(None, GLint, GLfloat, GLfloat) 	# GL/glext.h:3531
PFNGLUNIFORM3FPROC = CFUNCTYPE(None, GLint, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3532
PFNGLUNIFORM4FPROC = CFUNCTYPE(None, GLint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3533
PFNGLUNIFORM1IPROC = CFUNCTYPE(None, GLint, GLint) 	# GL/glext.h:3534
PFNGLUNIFORM2IPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:3535
PFNGLUNIFORM3IPROC = CFUNCTYPE(None, GLint, GLint, GLint, GLint) 	# GL/glext.h:3536
PFNGLUNIFORM4IPROC = CFUNCTYPE(None, GLint, GLint, GLint, GLint, GLint) 	# GL/glext.h:3537
PFNGLUNIFORM1FVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:3538
PFNGLUNIFORM2FVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:3539
PFNGLUNIFORM3FVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:3540
PFNGLUNIFORM4FVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:3541
PFNGLUNIFORM1IVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:3542
PFNGLUNIFORM2IVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:3543
PFNGLUNIFORM3IVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:3544
PFNGLUNIFORM4IVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:3545
PFNGLUNIFORMMATRIX2FVPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:3546
PFNGLUNIFORMMATRIX3FVPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:3547
PFNGLUNIFORMMATRIX4FVPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:3548
PFNGLVALIDATEPROGRAMPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3549
PFNGLVERTEXATTRIB1DPROC = CFUNCTYPE(None, GLuint, GLdouble) 	# GL/glext.h:3550
PFNGLVERTEXATTRIB1DVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3551
PFNGLVERTEXATTRIB1FPROC = CFUNCTYPE(None, GLuint, GLfloat) 	# GL/glext.h:3552
PFNGLVERTEXATTRIB1FVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3553
PFNGLVERTEXATTRIB1SPROC = CFUNCTYPE(None, GLuint, GLshort) 	# GL/glext.h:3554
PFNGLVERTEXATTRIB1SVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:3555
PFNGLVERTEXATTRIB2DPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble) 	# GL/glext.h:3556
PFNGLVERTEXATTRIB2DVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3557
PFNGLVERTEXATTRIB2FPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat) 	# GL/glext.h:3558
PFNGLVERTEXATTRIB2FVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3559
PFNGLVERTEXATTRIB2SPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort) 	# GL/glext.h:3560
PFNGLVERTEXATTRIB2SVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:3561
PFNGLVERTEXATTRIB3DPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3562
PFNGLVERTEXATTRIB3DVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3563
PFNGLVERTEXATTRIB3FPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3564
PFNGLVERTEXATTRIB3FVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3565
PFNGLVERTEXATTRIB3SPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort, GLshort) 	# GL/glext.h:3566
PFNGLVERTEXATTRIB3SVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:3567
PFNGLVERTEXATTRIB4NBVPROC = CFUNCTYPE(None, GLuint, POINTER(GLbyte)) 	# GL/glext.h:3568
PFNGLVERTEXATTRIB4NIVPROC = CFUNCTYPE(None, GLuint, POINTER(GLint)) 	# GL/glext.h:3569
PFNGLVERTEXATTRIB4NSVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:3570
PFNGLVERTEXATTRIB4NUBPROC = CFUNCTYPE(None, GLuint, GLubyte, GLubyte, GLubyte, GLubyte) 	# GL/glext.h:3571
PFNGLVERTEXATTRIB4NUBVPROC = CFUNCTYPE(None, GLuint, POINTER(GLubyte)) 	# GL/glext.h:3572
PFNGLVERTEXATTRIB4NUIVPROC = CFUNCTYPE(None, GLuint, POINTER(GLuint)) 	# GL/glext.h:3573
PFNGLVERTEXATTRIB4NUSVPROC = CFUNCTYPE(None, GLuint, POINTER(GLushort)) 	# GL/glext.h:3574
PFNGLVERTEXATTRIB4BVPROC = CFUNCTYPE(None, GLuint, POINTER(GLbyte)) 	# GL/glext.h:3575
PFNGLVERTEXATTRIB4DPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3576
PFNGLVERTEXATTRIB4DVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3577
PFNGLVERTEXATTRIB4FPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3578
PFNGLVERTEXATTRIB4FVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3579
PFNGLVERTEXATTRIB4IVPROC = CFUNCTYPE(None, GLuint, POINTER(GLint)) 	# GL/glext.h:3580
PFNGLVERTEXATTRIB4SPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort, GLshort, GLshort) 	# GL/glext.h:3581
PFNGLVERTEXATTRIB4SVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:3582
PFNGLVERTEXATTRIB4UBVPROC = CFUNCTYPE(None, GLuint, POINTER(GLubyte)) 	# GL/glext.h:3583
PFNGLVERTEXATTRIB4UIVPROC = CFUNCTYPE(None, GLuint, POINTER(GLuint)) 	# GL/glext.h:3584
PFNGLVERTEXATTRIB4USVPROC = CFUNCTYPE(None, GLuint, POINTER(GLushort)) 	# GL/glext.h:3585
PFNGLVERTEXATTRIBPOINTERPROC = CFUNCTYPE(None, GLuint, GLint, GLenum, GLboolean, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3586
# ARB_multitexture (GL/glext.h:3589)
GL_ARB_multitexture = 1 	# GL/glext.h:3590
# GL/glext.h:3592
glActiveTextureARB = _link_function('glActiveTextureARB', None, [GLenum], 'ARB_multitexture')

# GL/glext.h:3593
glClientActiveTextureARB = _link_function('glClientActiveTextureARB', None, [GLenum], 'ARB_multitexture')

# GL/glext.h:3594
glMultiTexCoord1dARB = _link_function('glMultiTexCoord1dARB', None, [GLenum, GLdouble], 'ARB_multitexture')

# GL/glext.h:3595
glMultiTexCoord1dvARB = _link_function('glMultiTexCoord1dvARB', None, [GLenum, POINTER(GLdouble)], 'ARB_multitexture')

# GL/glext.h:3596
glMultiTexCoord1fARB = _link_function('glMultiTexCoord1fARB', None, [GLenum, GLfloat], 'ARB_multitexture')

# GL/glext.h:3597
glMultiTexCoord1fvARB = _link_function('glMultiTexCoord1fvARB', None, [GLenum, POINTER(GLfloat)], 'ARB_multitexture')

# GL/glext.h:3598
glMultiTexCoord1iARB = _link_function('glMultiTexCoord1iARB', None, [GLenum, GLint], 'ARB_multitexture')

# GL/glext.h:3599
glMultiTexCoord1ivARB = _link_function('glMultiTexCoord1ivARB', None, [GLenum, POINTER(GLint)], 'ARB_multitexture')

# GL/glext.h:3600
glMultiTexCoord1sARB = _link_function('glMultiTexCoord1sARB', None, [GLenum, GLshort], 'ARB_multitexture')

# GL/glext.h:3601
glMultiTexCoord1svARB = _link_function('glMultiTexCoord1svARB', None, [GLenum, POINTER(GLshort)], 'ARB_multitexture')

# GL/glext.h:3602
glMultiTexCoord2dARB = _link_function('glMultiTexCoord2dARB', None, [GLenum, GLdouble, GLdouble], 'ARB_multitexture')

# GL/glext.h:3603
glMultiTexCoord2dvARB = _link_function('glMultiTexCoord2dvARB', None, [GLenum, POINTER(GLdouble)], 'ARB_multitexture')

# GL/glext.h:3604
glMultiTexCoord2fARB = _link_function('glMultiTexCoord2fARB', None, [GLenum, GLfloat, GLfloat], 'ARB_multitexture')

# GL/glext.h:3605
glMultiTexCoord2fvARB = _link_function('glMultiTexCoord2fvARB', None, [GLenum, POINTER(GLfloat)], 'ARB_multitexture')

# GL/glext.h:3606
glMultiTexCoord2iARB = _link_function('glMultiTexCoord2iARB', None, [GLenum, GLint, GLint], 'ARB_multitexture')

# GL/glext.h:3607
glMultiTexCoord2ivARB = _link_function('glMultiTexCoord2ivARB', None, [GLenum, POINTER(GLint)], 'ARB_multitexture')

# GL/glext.h:3608
glMultiTexCoord2sARB = _link_function('glMultiTexCoord2sARB', None, [GLenum, GLshort, GLshort], 'ARB_multitexture')

# GL/glext.h:3609
glMultiTexCoord2svARB = _link_function('glMultiTexCoord2svARB', None, [GLenum, POINTER(GLshort)], 'ARB_multitexture')

# GL/glext.h:3610
glMultiTexCoord3dARB = _link_function('glMultiTexCoord3dARB', None, [GLenum, GLdouble, GLdouble, GLdouble], 'ARB_multitexture')

# GL/glext.h:3611
glMultiTexCoord3dvARB = _link_function('glMultiTexCoord3dvARB', None, [GLenum, POINTER(GLdouble)], 'ARB_multitexture')

# GL/glext.h:3612
glMultiTexCoord3fARB = _link_function('glMultiTexCoord3fARB', None, [GLenum, GLfloat, GLfloat, GLfloat], 'ARB_multitexture')

# GL/glext.h:3613
glMultiTexCoord3fvARB = _link_function('glMultiTexCoord3fvARB', None, [GLenum, POINTER(GLfloat)], 'ARB_multitexture')

# GL/glext.h:3614
glMultiTexCoord3iARB = _link_function('glMultiTexCoord3iARB', None, [GLenum, GLint, GLint, GLint], 'ARB_multitexture')

# GL/glext.h:3615
glMultiTexCoord3ivARB = _link_function('glMultiTexCoord3ivARB', None, [GLenum, POINTER(GLint)], 'ARB_multitexture')

# GL/glext.h:3616
glMultiTexCoord3sARB = _link_function('glMultiTexCoord3sARB', None, [GLenum, GLshort, GLshort, GLshort], 'ARB_multitexture')

# GL/glext.h:3617
glMultiTexCoord3svARB = _link_function('glMultiTexCoord3svARB', None, [GLenum, POINTER(GLshort)], 'ARB_multitexture')

# GL/glext.h:3618
glMultiTexCoord4dARB = _link_function('glMultiTexCoord4dARB', None, [GLenum, GLdouble, GLdouble, GLdouble, GLdouble], 'ARB_multitexture')

# GL/glext.h:3619
glMultiTexCoord4dvARB = _link_function('glMultiTexCoord4dvARB', None, [GLenum, POINTER(GLdouble)], 'ARB_multitexture')

# GL/glext.h:3620
glMultiTexCoord4fARB = _link_function('glMultiTexCoord4fARB', None, [GLenum, GLfloat, GLfloat, GLfloat, GLfloat], 'ARB_multitexture')

# GL/glext.h:3621
glMultiTexCoord4fvARB = _link_function('glMultiTexCoord4fvARB', None, [GLenum, POINTER(GLfloat)], 'ARB_multitexture')

# GL/glext.h:3622
glMultiTexCoord4iARB = _link_function('glMultiTexCoord4iARB', None, [GLenum, GLint, GLint, GLint, GLint], 'ARB_multitexture')

# GL/glext.h:3623
glMultiTexCoord4ivARB = _link_function('glMultiTexCoord4ivARB', None, [GLenum, POINTER(GLint)], 'ARB_multitexture')

# GL/glext.h:3624
glMultiTexCoord4sARB = _link_function('glMultiTexCoord4sARB', None, [GLenum, GLshort, GLshort, GLshort, GLshort], 'ARB_multitexture')

# GL/glext.h:3625
glMultiTexCoord4svARB = _link_function('glMultiTexCoord4svARB', None, [GLenum, POINTER(GLshort)], 'ARB_multitexture')

PFNGLACTIVETEXTUREARBPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3627
PFNGLCLIENTACTIVETEXTUREARBPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3628
PFNGLMULTITEXCOORD1DARBPROC = CFUNCTYPE(None, GLenum, GLdouble) 	# GL/glext.h:3629
PFNGLMULTITEXCOORD1DVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3630
PFNGLMULTITEXCOORD1FARBPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:3631
PFNGLMULTITEXCOORD1FVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3632
PFNGLMULTITEXCOORD1IARBPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:3633
PFNGLMULTITEXCOORD1IVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3634
PFNGLMULTITEXCOORD1SARBPROC = CFUNCTYPE(None, GLenum, GLshort) 	# GL/glext.h:3635
PFNGLMULTITEXCOORD1SVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3636
PFNGLMULTITEXCOORD2DARBPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble) 	# GL/glext.h:3637
PFNGLMULTITEXCOORD2DVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3638
PFNGLMULTITEXCOORD2FARBPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat) 	# GL/glext.h:3639
PFNGLMULTITEXCOORD2FVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3640
PFNGLMULTITEXCOORD2IARBPROC = CFUNCTYPE(None, GLenum, GLint, GLint) 	# GL/glext.h:3641
PFNGLMULTITEXCOORD2IVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3642
PFNGLMULTITEXCOORD2SARBPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort) 	# GL/glext.h:3643
PFNGLMULTITEXCOORD2SVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3644
PFNGLMULTITEXCOORD3DARBPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3645
PFNGLMULTITEXCOORD3DVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3646
PFNGLMULTITEXCOORD3FARBPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3647
PFNGLMULTITEXCOORD3FVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3648
PFNGLMULTITEXCOORD3IARBPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint) 	# GL/glext.h:3649
PFNGLMULTITEXCOORD3IVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3650
PFNGLMULTITEXCOORD3SARBPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort, GLshort) 	# GL/glext.h:3651
PFNGLMULTITEXCOORD3SVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3652
PFNGLMULTITEXCOORD4DARBPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3653
PFNGLMULTITEXCOORD4DVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3654
PFNGLMULTITEXCOORD4FARBPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3655
PFNGLMULTITEXCOORD4FVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3656
PFNGLMULTITEXCOORD4IARBPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint) 	# GL/glext.h:3657
PFNGLMULTITEXCOORD4IVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3658
PFNGLMULTITEXCOORD4SARBPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort, GLshort, GLshort) 	# GL/glext.h:3659
PFNGLMULTITEXCOORD4SVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3660
# ARB_transpose_matrix (GL/glext.h:3663)
GL_ARB_transpose_matrix = 1 	# GL/glext.h:3664
# GL/glext.h:3666
glLoadTransposeMatrixfARB = _link_function('glLoadTransposeMatrixfARB', None, [POINTER(GLfloat)], 'ARB_transpose_matrix')

# GL/glext.h:3667
glLoadTransposeMatrixdARB = _link_function('glLoadTransposeMatrixdARB', None, [POINTER(GLdouble)], 'ARB_transpose_matrix')

# GL/glext.h:3668
glMultTransposeMatrixfARB = _link_function('glMultTransposeMatrixfARB', None, [POINTER(GLfloat)], 'ARB_transpose_matrix')

# GL/glext.h:3669
glMultTransposeMatrixdARB = _link_function('glMultTransposeMatrixdARB', None, [POINTER(GLdouble)], 'ARB_transpose_matrix')

PFNGLLOADTRANSPOSEMATRIXFARBPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3671
PFNGLLOADTRANSPOSEMATRIXDARBPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3672
PFNGLMULTTRANSPOSEMATRIXFARBPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3673
PFNGLMULTTRANSPOSEMATRIXDARBPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3674
# ARB_multisample (GL/glext.h:3677)
GL_ARB_multisample = 1 	# GL/glext.h:3678
# GL/glext.h:3680
glSampleCoverageARB = _link_function('glSampleCoverageARB', None, [GLclampf, GLboolean], 'ARB_multisample')

PFNGLSAMPLECOVERAGEARBPROC = CFUNCTYPE(None, GLclampf, GLboolean) 	# GL/glext.h:3682
# ARB_texture_env_add (GL/glext.h:3685)
GL_ARB_texture_env_add = 1 	# GL/glext.h:3686
# ARB_texture_cube_map (GL/glext.h:3689)
GL_ARB_texture_cube_map = 1 	# GL/glext.h:3690
# ARB_texture_compression (GL/glext.h:3693)
GL_ARB_texture_compression = 1 	# GL/glext.h:3694
# GL/glext.h:3696
glCompressedTexImage3DARB = _link_function('glCompressedTexImage3DARB', None, [GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)], 'ARB_texture_compression')

# GL/glext.h:3697
glCompressedTexImage2DARB = _link_function('glCompressedTexImage2DARB', None, [GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)], 'ARB_texture_compression')

# GL/glext.h:3698
glCompressedTexImage1DARB = _link_function('glCompressedTexImage1DARB', None, [GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, POINTER(GLvoid)], 'ARB_texture_compression')

# GL/glext.h:3699
glCompressedTexSubImage3DARB = _link_function('glCompressedTexSubImage3DARB', None, [GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)], 'ARB_texture_compression')

# GL/glext.h:3700
glCompressedTexSubImage2DARB = _link_function('glCompressedTexSubImage2DARB', None, [GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)], 'ARB_texture_compression')

# GL/glext.h:3701
glCompressedTexSubImage1DARB = _link_function('glCompressedTexSubImage1DARB', None, [GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, POINTER(GLvoid)], 'ARB_texture_compression')

# GL/glext.h:3702
glGetCompressedTexImageARB = _link_function('glGetCompressedTexImageARB', None, [GLenum, GLint, POINTER(GLvoid)], 'ARB_texture_compression')

PFNGLCOMPRESSEDTEXIMAGE3DARBPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3704
PFNGLCOMPRESSEDTEXIMAGE2DARBPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3705
PFNGLCOMPRESSEDTEXIMAGE1DARBPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3706
PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3707
PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3708
PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3709
PFNGLGETCOMPRESSEDTEXIMAGEARBPROC = CFUNCTYPE(None, GLenum, GLint, POINTER(GLvoid)) 	# GL/glext.h:3710
# ARB_texture_border_clamp (GL/glext.h:3713)
GL_ARB_texture_border_clamp = 1 	# GL/glext.h:3714
# ARB_point_parameters (GL/glext.h:3717)
GL_ARB_point_parameters = 1 	# GL/glext.h:3718
# GL/glext.h:3720
glPointParameterfARB = _link_function('glPointParameterfARB', None, [GLenum, GLfloat], 'ARB_point_parameters')

# GL/glext.h:3721
glPointParameterfvARB = _link_function('glPointParameterfvARB', None, [GLenum, POINTER(GLfloat)], 'ARB_point_parameters')

PFNGLPOINTPARAMETERFARBPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:3723
PFNGLPOINTPARAMETERFVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3724
# ARB_vertex_blend (GL/glext.h:3727)
GL_ARB_vertex_blend = 1 	# GL/glext.h:3728
# GL/glext.h:3730
glWeightbvARB = _link_function('glWeightbvARB', None, [GLint, POINTER(GLbyte)], 'ARB_vertex_blend')

# GL/glext.h:3731
glWeightsvARB = _link_function('glWeightsvARB', None, [GLint, POINTER(GLshort)], 'ARB_vertex_blend')

# GL/glext.h:3732
glWeightivARB = _link_function('glWeightivARB', None, [GLint, POINTER(GLint)], 'ARB_vertex_blend')

# GL/glext.h:3733
glWeightfvARB = _link_function('glWeightfvARB', None, [GLint, POINTER(GLfloat)], 'ARB_vertex_blend')

# GL/glext.h:3734
glWeightdvARB = _link_function('glWeightdvARB', None, [GLint, POINTER(GLdouble)], 'ARB_vertex_blend')

# GL/glext.h:3735
glWeightubvARB = _link_function('glWeightubvARB', None, [GLint, POINTER(GLubyte)], 'ARB_vertex_blend')

# GL/glext.h:3736
glWeightusvARB = _link_function('glWeightusvARB', None, [GLint, POINTER(GLushort)], 'ARB_vertex_blend')

# GL/glext.h:3737
glWeightuivARB = _link_function('glWeightuivARB', None, [GLint, POINTER(GLuint)], 'ARB_vertex_blend')

# GL/glext.h:3738
glWeightPointerARB = _link_function('glWeightPointerARB', None, [GLint, GLenum, GLsizei, POINTER(GLvoid)], 'ARB_vertex_blend')

# GL/glext.h:3739
glVertexBlendARB = _link_function('glVertexBlendARB', None, [GLint], 'ARB_vertex_blend')

PFNGLWEIGHTBVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLbyte)) 	# GL/glext.h:3741
PFNGLWEIGHTSVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLshort)) 	# GL/glext.h:3742
PFNGLWEIGHTIVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLint)) 	# GL/glext.h:3743
PFNGLWEIGHTFVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLfloat)) 	# GL/glext.h:3744
PFNGLWEIGHTDVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLdouble)) 	# GL/glext.h:3745
PFNGLWEIGHTUBVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLubyte)) 	# GL/glext.h:3746
PFNGLWEIGHTUSVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLushort)) 	# GL/glext.h:3747
PFNGLWEIGHTUIVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLuint)) 	# GL/glext.h:3748
PFNGLWEIGHTPOINTERARBPROC = CFUNCTYPE(None, GLint, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3749
PFNGLVERTEXBLENDARBPROC = CFUNCTYPE(None, GLint) 	# GL/glext.h:3750
# ARB_matrix_palette (GL/glext.h:3753)
GL_ARB_matrix_palette = 1 	# GL/glext.h:3754
# GL/glext.h:3756
glCurrentPaletteMatrixARB = _link_function('glCurrentPaletteMatrixARB', None, [GLint], 'ARB_matrix_palette')

# GL/glext.h:3757
glMatrixIndexubvARB = _link_function('glMatrixIndexubvARB', None, [GLint, POINTER(GLubyte)], 'ARB_matrix_palette')

# GL/glext.h:3758
glMatrixIndexusvARB = _link_function('glMatrixIndexusvARB', None, [GLint, POINTER(GLushort)], 'ARB_matrix_palette')

# GL/glext.h:3759
glMatrixIndexuivARB = _link_function('glMatrixIndexuivARB', None, [GLint, POINTER(GLuint)], 'ARB_matrix_palette')

# GL/glext.h:3760
glMatrixIndexPointerARB = _link_function('glMatrixIndexPointerARB', None, [GLint, GLenum, GLsizei, POINTER(GLvoid)], 'ARB_matrix_palette')

PFNGLCURRENTPALETTEMATRIXARBPROC = CFUNCTYPE(None, GLint) 	# GL/glext.h:3762
PFNGLMATRIXINDEXUBVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLubyte)) 	# GL/glext.h:3763
PFNGLMATRIXINDEXUSVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLushort)) 	# GL/glext.h:3764
PFNGLMATRIXINDEXUIVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLuint)) 	# GL/glext.h:3765
PFNGLMATRIXINDEXPOINTERARBPROC = CFUNCTYPE(None, GLint, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3766
# ARB_texture_env_combine (GL/glext.h:3769)
GL_ARB_texture_env_combine = 1 	# GL/glext.h:3770
# ARB_texture_env_crossbar (GL/glext.h:3773)
GL_ARB_texture_env_crossbar = 1 	# GL/glext.h:3774
# ARB_texture_env_dot3 (GL/glext.h:3777)
GL_ARB_texture_env_dot3 = 1 	# GL/glext.h:3778
# ARB_texture_mirrored_repeat (GL/glext.h:3781)
GL_ARB_texture_mirrored_repeat = 1 	# GL/glext.h:3782
# ARB_depth_texture (GL/glext.h:3785)
GL_ARB_depth_texture = 1 	# GL/glext.h:3786
# ARB_shadow (GL/glext.h:3789)
GL_ARB_shadow = 1 	# GL/glext.h:3790
# ARB_shadow_ambient (GL/glext.h:3793)
GL_ARB_shadow_ambient = 1 	# GL/glext.h:3794
# ARB_window_pos (GL/glext.h:3797)
GL_ARB_window_pos = 1 	# GL/glext.h:3798
# GL/glext.h:3800
glWindowPos2dARB = _link_function('glWindowPos2dARB', None, [GLdouble, GLdouble], 'ARB_window_pos')

# GL/glext.h:3801
glWindowPos2dvARB = _link_function('glWindowPos2dvARB', None, [POINTER(GLdouble)], 'ARB_window_pos')

# GL/glext.h:3802
glWindowPos2fARB = _link_function('glWindowPos2fARB', None, [GLfloat, GLfloat], 'ARB_window_pos')

# GL/glext.h:3803
glWindowPos2fvARB = _link_function('glWindowPos2fvARB', None, [POINTER(GLfloat)], 'ARB_window_pos')

# GL/glext.h:3804
glWindowPos2iARB = _link_function('glWindowPos2iARB', None, [GLint, GLint], 'ARB_window_pos')

# GL/glext.h:3805
glWindowPos2ivARB = _link_function('glWindowPos2ivARB', None, [POINTER(GLint)], 'ARB_window_pos')

# GL/glext.h:3806
glWindowPos2sARB = _link_function('glWindowPos2sARB', None, [GLshort, GLshort], 'ARB_window_pos')

# GL/glext.h:3807
glWindowPos2svARB = _link_function('glWindowPos2svARB', None, [POINTER(GLshort)], 'ARB_window_pos')

# GL/glext.h:3808
glWindowPos3dARB = _link_function('glWindowPos3dARB', None, [GLdouble, GLdouble, GLdouble], 'ARB_window_pos')

# GL/glext.h:3809
glWindowPos3dvARB = _link_function('glWindowPos3dvARB', None, [POINTER(GLdouble)], 'ARB_window_pos')

# GL/glext.h:3810
glWindowPos3fARB = _link_function('glWindowPos3fARB', None, [GLfloat, GLfloat, GLfloat], 'ARB_window_pos')

# GL/glext.h:3811
glWindowPos3fvARB = _link_function('glWindowPos3fvARB', None, [POINTER(GLfloat)], 'ARB_window_pos')

# GL/glext.h:3812
glWindowPos3iARB = _link_function('glWindowPos3iARB', None, [GLint, GLint, GLint], 'ARB_window_pos')

# GL/glext.h:3813
glWindowPos3ivARB = _link_function('glWindowPos3ivARB', None, [POINTER(GLint)], 'ARB_window_pos')

# GL/glext.h:3814
glWindowPos3sARB = _link_function('glWindowPos3sARB', None, [GLshort, GLshort, GLshort], 'ARB_window_pos')

# GL/glext.h:3815
glWindowPos3svARB = _link_function('glWindowPos3svARB', None, [POINTER(GLshort)], 'ARB_window_pos')

PFNGLWINDOWPOS2DARBPROC = CFUNCTYPE(None, GLdouble, GLdouble) 	# GL/glext.h:3817
PFNGLWINDOWPOS2DVARBPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3818
PFNGLWINDOWPOS2FARBPROC = CFUNCTYPE(None, GLfloat, GLfloat) 	# GL/glext.h:3819
PFNGLWINDOWPOS2FVARBPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3820
PFNGLWINDOWPOS2IARBPROC = CFUNCTYPE(None, GLint, GLint) 	# GL/glext.h:3821
PFNGLWINDOWPOS2IVARBPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:3822
PFNGLWINDOWPOS2SARBPROC = CFUNCTYPE(None, GLshort, GLshort) 	# GL/glext.h:3823
PFNGLWINDOWPOS2SVARBPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:3824
PFNGLWINDOWPOS3DARBPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3825
PFNGLWINDOWPOS3DVARBPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3826
PFNGLWINDOWPOS3FARBPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3827
PFNGLWINDOWPOS3FVARBPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3828
PFNGLWINDOWPOS3IARBPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:3829
PFNGLWINDOWPOS3IVARBPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:3830
PFNGLWINDOWPOS3SARBPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort) 	# GL/glext.h:3831
PFNGLWINDOWPOS3SVARBPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:3832
# ARB_vertex_program (GL/glext.h:3835)
GL_ARB_vertex_program = 1 	# GL/glext.h:3836
# GL/glext.h:3838
glVertexAttrib1dARB = _link_function('glVertexAttrib1dARB', None, [GLuint, GLdouble], 'ARB_vertex_program')

# GL/glext.h:3839
glVertexAttrib1dvARB = _link_function('glVertexAttrib1dvARB', None, [GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:3840
glVertexAttrib1fARB = _link_function('glVertexAttrib1fARB', None, [GLuint, GLfloat], 'ARB_vertex_program')

# GL/glext.h:3841
glVertexAttrib1fvARB = _link_function('glVertexAttrib1fvARB', None, [GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:3842
glVertexAttrib1sARB = _link_function('glVertexAttrib1sARB', None, [GLuint, GLshort], 'ARB_vertex_program')

# GL/glext.h:3843
glVertexAttrib1svARB = _link_function('glVertexAttrib1svARB', None, [GLuint, POINTER(GLshort)], 'ARB_vertex_program')

# GL/glext.h:3844
glVertexAttrib2dARB = _link_function('glVertexAttrib2dARB', None, [GLuint, GLdouble, GLdouble], 'ARB_vertex_program')

# GL/glext.h:3845
glVertexAttrib2dvARB = _link_function('glVertexAttrib2dvARB', None, [GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:3846
glVertexAttrib2fARB = _link_function('glVertexAttrib2fARB', None, [GLuint, GLfloat, GLfloat], 'ARB_vertex_program')

# GL/glext.h:3847
glVertexAttrib2fvARB = _link_function('glVertexAttrib2fvARB', None, [GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:3848
glVertexAttrib2sARB = _link_function('glVertexAttrib2sARB', None, [GLuint, GLshort, GLshort], 'ARB_vertex_program')

# GL/glext.h:3849
glVertexAttrib2svARB = _link_function('glVertexAttrib2svARB', None, [GLuint, POINTER(GLshort)], 'ARB_vertex_program')

# GL/glext.h:3850
glVertexAttrib3dARB = _link_function('glVertexAttrib3dARB', None, [GLuint, GLdouble, GLdouble, GLdouble], 'ARB_vertex_program')

# GL/glext.h:3851
glVertexAttrib3dvARB = _link_function('glVertexAttrib3dvARB', None, [GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:3852
glVertexAttrib3fARB = _link_function('glVertexAttrib3fARB', None, [GLuint, GLfloat, GLfloat, GLfloat], 'ARB_vertex_program')

# GL/glext.h:3853
glVertexAttrib3fvARB = _link_function('glVertexAttrib3fvARB', None, [GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:3854
glVertexAttrib3sARB = _link_function('glVertexAttrib3sARB', None, [GLuint, GLshort, GLshort, GLshort], 'ARB_vertex_program')

# GL/glext.h:3855
glVertexAttrib3svARB = _link_function('glVertexAttrib3svARB', None, [GLuint, POINTER(GLshort)], 'ARB_vertex_program')

# GL/glext.h:3856
glVertexAttrib4NbvARB = _link_function('glVertexAttrib4NbvARB', None, [GLuint, POINTER(GLbyte)], 'ARB_vertex_program')

# GL/glext.h:3857
glVertexAttrib4NivARB = _link_function('glVertexAttrib4NivARB', None, [GLuint, POINTER(GLint)], 'ARB_vertex_program')

# GL/glext.h:3858
glVertexAttrib4NsvARB = _link_function('glVertexAttrib4NsvARB', None, [GLuint, POINTER(GLshort)], 'ARB_vertex_program')

# GL/glext.h:3859
glVertexAttrib4NubARB = _link_function('glVertexAttrib4NubARB', None, [GLuint, GLubyte, GLubyte, GLubyte, GLubyte], 'ARB_vertex_program')

# GL/glext.h:3860
glVertexAttrib4NubvARB = _link_function('glVertexAttrib4NubvARB', None, [GLuint, POINTER(GLubyte)], 'ARB_vertex_program')

# GL/glext.h:3861
glVertexAttrib4NuivARB = _link_function('glVertexAttrib4NuivARB', None, [GLuint, POINTER(GLuint)], 'ARB_vertex_program')

# GL/glext.h:3862
glVertexAttrib4NusvARB = _link_function('glVertexAttrib4NusvARB', None, [GLuint, POINTER(GLushort)], 'ARB_vertex_program')

# GL/glext.h:3863
glVertexAttrib4bvARB = _link_function('glVertexAttrib4bvARB', None, [GLuint, POINTER(GLbyte)], 'ARB_vertex_program')

# GL/glext.h:3864
glVertexAttrib4dARB = _link_function('glVertexAttrib4dARB', None, [GLuint, GLdouble, GLdouble, GLdouble, GLdouble], 'ARB_vertex_program')

# GL/glext.h:3865
glVertexAttrib4dvARB = _link_function('glVertexAttrib4dvARB', None, [GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:3866
glVertexAttrib4fARB = _link_function('glVertexAttrib4fARB', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat], 'ARB_vertex_program')

# GL/glext.h:3867
glVertexAttrib4fvARB = _link_function('glVertexAttrib4fvARB', None, [GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:3868
glVertexAttrib4ivARB = _link_function('glVertexAttrib4ivARB', None, [GLuint, POINTER(GLint)], 'ARB_vertex_program')

# GL/glext.h:3869
glVertexAttrib4sARB = _link_function('glVertexAttrib4sARB', None, [GLuint, GLshort, GLshort, GLshort, GLshort], 'ARB_vertex_program')

# GL/glext.h:3870
glVertexAttrib4svARB = _link_function('glVertexAttrib4svARB', None, [GLuint, POINTER(GLshort)], 'ARB_vertex_program')

# GL/glext.h:3871
glVertexAttrib4ubvARB = _link_function('glVertexAttrib4ubvARB', None, [GLuint, POINTER(GLubyte)], 'ARB_vertex_program')

# GL/glext.h:3872
glVertexAttrib4uivARB = _link_function('glVertexAttrib4uivARB', None, [GLuint, POINTER(GLuint)], 'ARB_vertex_program')

# GL/glext.h:3873
glVertexAttrib4usvARB = _link_function('glVertexAttrib4usvARB', None, [GLuint, POINTER(GLushort)], 'ARB_vertex_program')

# GL/glext.h:3874
glVertexAttribPointerARB = _link_function('glVertexAttribPointerARB', None, [GLuint, GLint, GLenum, GLboolean, GLsizei, POINTER(GLvoid)], 'ARB_vertex_program')

# GL/glext.h:3875
glEnableVertexAttribArrayARB = _link_function('glEnableVertexAttribArrayARB', None, [GLuint], 'ARB_vertex_program')

# GL/glext.h:3876
glDisableVertexAttribArrayARB = _link_function('glDisableVertexAttribArrayARB', None, [GLuint], 'ARB_vertex_program')

# GL/glext.h:3877
glProgramStringARB = _link_function('glProgramStringARB', None, [GLenum, GLenum, GLsizei, POINTER(GLvoid)], 'ARB_vertex_program')

# GL/glext.h:3878
glBindProgramARB = _link_function('glBindProgramARB', None, [GLenum, GLuint], 'ARB_vertex_program')

# GL/glext.h:3879
glDeleteProgramsARB = _link_function('glDeleteProgramsARB', None, [GLsizei, POINTER(GLuint)], 'ARB_vertex_program')

# GL/glext.h:3880
glGenProgramsARB = _link_function('glGenProgramsARB', None, [GLsizei, POINTER(GLuint)], 'ARB_vertex_program')

# GL/glext.h:3881
glProgramEnvParameter4dARB = _link_function('glProgramEnvParameter4dARB', None, [GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble], 'ARB_vertex_program')

# GL/glext.h:3882
glProgramEnvParameter4dvARB = _link_function('glProgramEnvParameter4dvARB', None, [GLenum, GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:3883
glProgramEnvParameter4fARB = _link_function('glProgramEnvParameter4fARB', None, [GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat], 'ARB_vertex_program')

# GL/glext.h:3884
glProgramEnvParameter4fvARB = _link_function('glProgramEnvParameter4fvARB', None, [GLenum, GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:3885
glProgramLocalParameter4dARB = _link_function('glProgramLocalParameter4dARB', None, [GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble], 'ARB_vertex_program')

# GL/glext.h:3886
glProgramLocalParameter4dvARB = _link_function('glProgramLocalParameter4dvARB', None, [GLenum, GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:3887
glProgramLocalParameter4fARB = _link_function('glProgramLocalParameter4fARB', None, [GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat], 'ARB_vertex_program')

# GL/glext.h:3888
glProgramLocalParameter4fvARB = _link_function('glProgramLocalParameter4fvARB', None, [GLenum, GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:3889
glGetProgramEnvParameterdvARB = _link_function('glGetProgramEnvParameterdvARB', None, [GLenum, GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:3890
glGetProgramEnvParameterfvARB = _link_function('glGetProgramEnvParameterfvARB', None, [GLenum, GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:3891
glGetProgramLocalParameterdvARB = _link_function('glGetProgramLocalParameterdvARB', None, [GLenum, GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:3892
glGetProgramLocalParameterfvARB = _link_function('glGetProgramLocalParameterfvARB', None, [GLenum, GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:3893
glGetProgramivARB = _link_function('glGetProgramivARB', None, [GLenum, GLenum, POINTER(GLint)], 'ARB_vertex_program')

# GL/glext.h:3894
glGetProgramStringARB = _link_function('glGetProgramStringARB', None, [GLenum, GLenum, POINTER(GLvoid)], 'ARB_vertex_program')

# GL/glext.h:3895
glGetVertexAttribdvARB = _link_function('glGetVertexAttribdvARB', None, [GLuint, GLenum, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:3896
glGetVertexAttribfvARB = _link_function('glGetVertexAttribfvARB', None, [GLuint, GLenum, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:3897
glGetVertexAttribivARB = _link_function('glGetVertexAttribivARB', None, [GLuint, GLenum, POINTER(GLint)], 'ARB_vertex_program')

# GL/glext.h:3898
glGetVertexAttribPointervARB = _link_function('glGetVertexAttribPointervARB', None, [GLuint, GLenum, POINTER(POINTER(GLvoid))], 'ARB_vertex_program')

# GL/glext.h:3899
glIsProgramARB = _link_function('glIsProgramARB', GLboolean, [GLuint], 'ARB_vertex_program')

PFNGLVERTEXATTRIB1DARBPROC = CFUNCTYPE(None, GLuint, GLdouble) 	# GL/glext.h:3901
PFNGLVERTEXATTRIB1DVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3902
PFNGLVERTEXATTRIB1FARBPROC = CFUNCTYPE(None, GLuint, GLfloat) 	# GL/glext.h:3903
PFNGLVERTEXATTRIB1FVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3904
PFNGLVERTEXATTRIB1SARBPROC = CFUNCTYPE(None, GLuint, GLshort) 	# GL/glext.h:3905
PFNGLVERTEXATTRIB1SVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:3906
PFNGLVERTEXATTRIB2DARBPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble) 	# GL/glext.h:3907
PFNGLVERTEXATTRIB2DVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3908
PFNGLVERTEXATTRIB2FARBPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat) 	# GL/glext.h:3909
PFNGLVERTEXATTRIB2FVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3910
PFNGLVERTEXATTRIB2SARBPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort) 	# GL/glext.h:3911
PFNGLVERTEXATTRIB2SVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:3912
PFNGLVERTEXATTRIB3DARBPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3913
PFNGLVERTEXATTRIB3DVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3914
PFNGLVERTEXATTRIB3FARBPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3915
PFNGLVERTEXATTRIB3FVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3916
PFNGLVERTEXATTRIB3SARBPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort, GLshort) 	# GL/glext.h:3917
PFNGLVERTEXATTRIB3SVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:3918
PFNGLVERTEXATTRIB4NBVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLbyte)) 	# GL/glext.h:3919
PFNGLVERTEXATTRIB4NIVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLint)) 	# GL/glext.h:3920
PFNGLVERTEXATTRIB4NSVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:3921
PFNGLVERTEXATTRIB4NUBARBPROC = CFUNCTYPE(None, GLuint, GLubyte, GLubyte, GLubyte, GLubyte) 	# GL/glext.h:3922
PFNGLVERTEXATTRIB4NUBVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLubyte)) 	# GL/glext.h:3923
PFNGLVERTEXATTRIB4NUIVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLuint)) 	# GL/glext.h:3924
PFNGLVERTEXATTRIB4NUSVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLushort)) 	# GL/glext.h:3925
PFNGLVERTEXATTRIB4BVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLbyte)) 	# GL/glext.h:3926
PFNGLVERTEXATTRIB4DARBPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3927
PFNGLVERTEXATTRIB4DVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3928
PFNGLVERTEXATTRIB4FARBPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3929
PFNGLVERTEXATTRIB4FVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3930
PFNGLVERTEXATTRIB4IVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLint)) 	# GL/glext.h:3931
PFNGLVERTEXATTRIB4SARBPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort, GLshort, GLshort) 	# GL/glext.h:3932
PFNGLVERTEXATTRIB4SVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:3933
PFNGLVERTEXATTRIB4UBVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLubyte)) 	# GL/glext.h:3934
PFNGLVERTEXATTRIB4UIVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLuint)) 	# GL/glext.h:3935
PFNGLVERTEXATTRIB4USVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLushort)) 	# GL/glext.h:3936
PFNGLVERTEXATTRIBPOINTERARBPROC = CFUNCTYPE(None, GLuint, GLint, GLenum, GLboolean, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3937
PFNGLENABLEVERTEXATTRIBARRAYARBPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3938
PFNGLDISABLEVERTEXATTRIBARRAYARBPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3939
PFNGLPROGRAMSTRINGARBPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3940
PFNGLBINDPROGRAMARBPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:3941
PFNGLDELETEPROGRAMSARBPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:3942
PFNGLGENPROGRAMSARBPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:3943
PFNGLPROGRAMENVPARAMETER4DARBPROC = CFUNCTYPE(None, GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3944
PFNGLPROGRAMENVPARAMETER4DVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3945
PFNGLPROGRAMENVPARAMETER4FARBPROC = CFUNCTYPE(None, GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3946
PFNGLPROGRAMENVPARAMETER4FVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3947
PFNGLPROGRAMLOCALPARAMETER4DARBPROC = CFUNCTYPE(None, GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3948
PFNGLPROGRAMLOCALPARAMETER4DVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3949
PFNGLPROGRAMLOCALPARAMETER4FARBPROC = CFUNCTYPE(None, GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3950
PFNGLPROGRAMLOCALPARAMETER4FVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3951
PFNGLGETPROGRAMENVPARAMETERDVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3952
PFNGLGETPROGRAMENVPARAMETERFVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3953
PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3954
PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3955
PFNGLGETPROGRAMIVARBPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3956
PFNGLGETPROGRAMSTRINGARBPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3957
PFNGLGETVERTEXATTRIBDVARBPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3958
PFNGLGETVERTEXATTRIBFVARBPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3959
PFNGLGETVERTEXATTRIBIVARBPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:3960
PFNGLGETVERTEXATTRIBPOINTERVARBPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:3961
PFNGLISPROGRAMARBPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:3962
# ARB_fragment_program (GL/glext.h:3965)
GL_ARB_fragment_program = 1 	# GL/glext.h:3966
# ARB_vertex_buffer_object (GL/glext.h:3970)
GL_ARB_vertex_buffer_object = 1 	# GL/glext.h:3971
# GL/glext.h:3973
glBindBufferARB = _link_function('glBindBufferARB', None, [GLenum, GLuint], 'ARB_vertex_buffer_object')

# GL/glext.h:3974
glDeleteBuffersARB = _link_function('glDeleteBuffersARB', None, [GLsizei, POINTER(GLuint)], 'ARB_vertex_buffer_object')

# GL/glext.h:3975
glGenBuffersARB = _link_function('glGenBuffersARB', None, [GLsizei, POINTER(GLuint)], 'ARB_vertex_buffer_object')

# GL/glext.h:3976
glIsBufferARB = _link_function('glIsBufferARB', GLboolean, [GLuint], 'ARB_vertex_buffer_object')

# GL/glext.h:3977
glBufferDataARB = _link_function('glBufferDataARB', None, [GLenum, GLsizeiptrARB, POINTER(GLvoid), GLenum], 'ARB_vertex_buffer_object')

# GL/glext.h:3978
glBufferSubDataARB = _link_function('glBufferSubDataARB', None, [GLenum, GLintptrARB, GLsizeiptrARB, POINTER(GLvoid)], 'ARB_vertex_buffer_object')

# GL/glext.h:3979
glGetBufferSubDataARB = _link_function('glGetBufferSubDataARB', None, [GLenum, GLintptrARB, GLsizeiptrARB, POINTER(GLvoid)], 'ARB_vertex_buffer_object')

# GL/glext.h:3980
glMapBufferARB = _link_function('glMapBufferARB', POINTER(GLvoid), [GLenum, GLenum], 'ARB_vertex_buffer_object')

# GL/glext.h:3981
glUnmapBufferARB = _link_function('glUnmapBufferARB', GLboolean, [GLenum], 'ARB_vertex_buffer_object')

# GL/glext.h:3982
glGetBufferParameterivARB = _link_function('glGetBufferParameterivARB', None, [GLenum, GLenum, POINTER(GLint)], 'ARB_vertex_buffer_object')

# GL/glext.h:3983
glGetBufferPointervARB = _link_function('glGetBufferPointervARB', None, [GLenum, GLenum, POINTER(POINTER(GLvoid))], 'ARB_vertex_buffer_object')

PFNGLBINDBUFFERARBPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:3985
PFNGLDELETEBUFFERSARBPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:3986
PFNGLGENBUFFERSARBPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:3987
PFNGLISBUFFERARBPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:3988
PFNGLBUFFERDATAARBPROC = CFUNCTYPE(None, GLenum, GLsizeiptrARB, POINTER(GLvoid), GLenum) 	# GL/glext.h:3989
PFNGLBUFFERSUBDATAARBPROC = CFUNCTYPE(None, GLenum, GLintptrARB, GLsizeiptrARB, POINTER(GLvoid)) 	# GL/glext.h:3990
PFNGLGETBUFFERSUBDATAARBPROC = CFUNCTYPE(None, GLenum, GLintptrARB, GLsizeiptrARB, POINTER(GLvoid)) 	# GL/glext.h:3991
PFNGLMAPBUFFERARBPROC = CFUNCTYPE(POINTER(GLvoid), GLenum, GLenum) 	# GL/glext.h:3992
PFNGLUNMAPBUFFERARBPROC = CFUNCTYPE(GLboolean, GLenum) 	# GL/glext.h:3993
PFNGLGETBUFFERPARAMETERIVARBPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3994
PFNGLGETBUFFERPOINTERVARBPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:3995
# ARB_occlusion_query (GL/glext.h:3998)
GL_ARB_occlusion_query = 1 	# GL/glext.h:3999
# GL/glext.h:4001
glGenQueriesARB = _link_function('glGenQueriesARB', None, [GLsizei, POINTER(GLuint)], 'ARB_occlusion_query')

# GL/glext.h:4002
glDeleteQueriesARB = _link_function('glDeleteQueriesARB', None, [GLsizei, POINTER(GLuint)], 'ARB_occlusion_query')

# GL/glext.h:4003
glIsQueryARB = _link_function('glIsQueryARB', GLboolean, [GLuint], 'ARB_occlusion_query')

# GL/glext.h:4004
glBeginQueryARB = _link_function('glBeginQueryARB', None, [GLenum, GLuint], 'ARB_occlusion_query')

# GL/glext.h:4005
glEndQueryARB = _link_function('glEndQueryARB', None, [GLenum], 'ARB_occlusion_query')

# GL/glext.h:4006
glGetQueryivARB = _link_function('glGetQueryivARB', None, [GLenum, GLenum, POINTER(GLint)], 'ARB_occlusion_query')

# GL/glext.h:4007
glGetQueryObjectivARB = _link_function('glGetQueryObjectivARB', None, [GLuint, GLenum, POINTER(GLint)], 'ARB_occlusion_query')

# GL/glext.h:4008
glGetQueryObjectuivARB = _link_function('glGetQueryObjectuivARB', None, [GLuint, GLenum, POINTER(GLuint)], 'ARB_occlusion_query')

PFNGLGENQUERIESARBPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:4010
PFNGLDELETEQUERIESARBPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:4011
PFNGLISQUERYARBPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:4012
PFNGLBEGINQUERYARBPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:4013
PFNGLENDQUERYARBPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:4014
PFNGLGETQUERYIVARBPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4015
PFNGLGETQUERYOBJECTIVARBPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:4016
PFNGLGETQUERYOBJECTUIVARBPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLuint)) 	# GL/glext.h:4017
# ARB_shader_objects (GL/glext.h:4020)
GL_ARB_shader_objects = 1 	# GL/glext.h:4021
# GL/glext.h:4023
glDeleteObjectARB = _link_function('glDeleteObjectARB', None, [GLhandleARB], 'ARB_shader_objects')

# GL/glext.h:4024
glGetHandleARB = _link_function('glGetHandleARB', GLhandleARB, [GLenum], 'ARB_shader_objects')

# GL/glext.h:4025
glDetachObjectARB = _link_function('glDetachObjectARB', None, [GLhandleARB, GLhandleARB], 'ARB_shader_objects')

# GL/glext.h:4026
glCreateShaderObjectARB = _link_function('glCreateShaderObjectARB', GLhandleARB, [GLenum], 'ARB_shader_objects')

# GL/glext.h:4027
glShaderSourceARB = _link_function('glShaderSourceARB', None, [GLhandleARB, GLsizei, POINTER(POINTER(GLcharARB)), POINTER(GLint)], 'ARB_shader_objects')

# GL/glext.h:4028
glCompileShaderARB = _link_function('glCompileShaderARB', None, [GLhandleARB], 'ARB_shader_objects')

# GL/glext.h:4029
glCreateProgramObjectARB = _link_function('glCreateProgramObjectARB', GLhandleARB, [], 'ARB_shader_objects')

# GL/glext.h:4030
glAttachObjectARB = _link_function('glAttachObjectARB', None, [GLhandleARB, GLhandleARB], 'ARB_shader_objects')

# GL/glext.h:4031
glLinkProgramARB = _link_function('glLinkProgramARB', None, [GLhandleARB], 'ARB_shader_objects')

# GL/glext.h:4032
glUseProgramObjectARB = _link_function('glUseProgramObjectARB', None, [GLhandleARB], 'ARB_shader_objects')

# GL/glext.h:4033
glValidateProgramARB = _link_function('glValidateProgramARB', None, [GLhandleARB], 'ARB_shader_objects')

# GL/glext.h:4034
glUniform1fARB = _link_function('glUniform1fARB', None, [GLint, GLfloat], 'ARB_shader_objects')

# GL/glext.h:4035
glUniform2fARB = _link_function('glUniform2fARB', None, [GLint, GLfloat, GLfloat], 'ARB_shader_objects')

# GL/glext.h:4036
glUniform3fARB = _link_function('glUniform3fARB', None, [GLint, GLfloat, GLfloat, GLfloat], 'ARB_shader_objects')

# GL/glext.h:4037
glUniform4fARB = _link_function('glUniform4fARB', None, [GLint, GLfloat, GLfloat, GLfloat, GLfloat], 'ARB_shader_objects')

# GL/glext.h:4038
glUniform1iARB = _link_function('glUniform1iARB', None, [GLint, GLint], 'ARB_shader_objects')

# GL/glext.h:4039
glUniform2iARB = _link_function('glUniform2iARB', None, [GLint, GLint, GLint], 'ARB_shader_objects')

# GL/glext.h:4040
glUniform3iARB = _link_function('glUniform3iARB', None, [GLint, GLint, GLint, GLint], 'ARB_shader_objects')

# GL/glext.h:4041
glUniform4iARB = _link_function('glUniform4iARB', None, [GLint, GLint, GLint, GLint, GLint], 'ARB_shader_objects')

# GL/glext.h:4042
glUniform1fvARB = _link_function('glUniform1fvARB', None, [GLint, GLsizei, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4043
glUniform2fvARB = _link_function('glUniform2fvARB', None, [GLint, GLsizei, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4044
glUniform3fvARB = _link_function('glUniform3fvARB', None, [GLint, GLsizei, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4045
glUniform4fvARB = _link_function('glUniform4fvARB', None, [GLint, GLsizei, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4046
glUniform1ivARB = _link_function('glUniform1ivARB', None, [GLint, GLsizei, POINTER(GLint)], 'ARB_shader_objects')

# GL/glext.h:4047
glUniform2ivARB = _link_function('glUniform2ivARB', None, [GLint, GLsizei, POINTER(GLint)], 'ARB_shader_objects')

# GL/glext.h:4048
glUniform3ivARB = _link_function('glUniform3ivARB', None, [GLint, GLsizei, POINTER(GLint)], 'ARB_shader_objects')

# GL/glext.h:4049
glUniform4ivARB = _link_function('glUniform4ivARB', None, [GLint, GLsizei, POINTER(GLint)], 'ARB_shader_objects')

# GL/glext.h:4050
glUniformMatrix2fvARB = _link_function('glUniformMatrix2fvARB', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4051
glUniformMatrix3fvARB = _link_function('glUniformMatrix3fvARB', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4052
glUniformMatrix4fvARB = _link_function('glUniformMatrix4fvARB', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4053
glGetObjectParameterfvARB = _link_function('glGetObjectParameterfvARB', None, [GLhandleARB, GLenum, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4054
glGetObjectParameterivARB = _link_function('glGetObjectParameterivARB', None, [GLhandleARB, GLenum, POINTER(GLint)], 'ARB_shader_objects')

# GL/glext.h:4055
glGetInfoLogARB = _link_function('glGetInfoLogARB', None, [GLhandleARB, GLsizei, POINTER(GLsizei), POINTER(GLcharARB)], 'ARB_shader_objects')

# GL/glext.h:4056
glGetAttachedObjectsARB = _link_function('glGetAttachedObjectsARB', None, [GLhandleARB, GLsizei, POINTER(GLsizei), POINTER(GLhandleARB)], 'ARB_shader_objects')

# GL/glext.h:4057
glGetUniformLocationARB = _link_function('glGetUniformLocationARB', GLint, [GLhandleARB, POINTER(GLcharARB)], 'ARB_shader_objects')

# GL/glext.h:4058
glGetActiveUniformARB = _link_function('glGetActiveUniformARB', None, [GLhandleARB, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLcharARB)], 'ARB_shader_objects')

# GL/glext.h:4059
glGetUniformfvARB = _link_function('glGetUniformfvARB', None, [GLhandleARB, GLint, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4060
glGetUniformivARB = _link_function('glGetUniformivARB', None, [GLhandleARB, GLint, POINTER(GLint)], 'ARB_shader_objects')

# GL/glext.h:4061
glGetShaderSourceARB = _link_function('glGetShaderSourceARB', None, [GLhandleARB, GLsizei, POINTER(GLsizei), POINTER(GLcharARB)], 'ARB_shader_objects')

PFNGLDELETEOBJECTARBPROC = CFUNCTYPE(None, GLhandleARB) 	# GL/glext.h:4063
PFNGLGETHANDLEARBPROC = CFUNCTYPE(GLhandleARB, GLenum) 	# GL/glext.h:4064
PFNGLDETACHOBJECTARBPROC = CFUNCTYPE(None, GLhandleARB, GLhandleARB) 	# GL/glext.h:4065
PFNGLCREATESHADEROBJECTARBPROC = CFUNCTYPE(GLhandleARB, GLenum) 	# GL/glext.h:4066
PFNGLSHADERSOURCEARBPROC = CFUNCTYPE(None, GLhandleARB, GLsizei, POINTER(POINTER(GLcharARB)), POINTER(GLint)) 	# GL/glext.h:4067
PFNGLCOMPILESHADERARBPROC = CFUNCTYPE(None, GLhandleARB) 	# GL/glext.h:4068
PFNGLCREATEPROGRAMOBJECTARBPROC = CFUNCTYPE(GLhandleARB) 	# GL/glext.h:4069
PFNGLATTACHOBJECTARBPROC = CFUNCTYPE(None, GLhandleARB, GLhandleARB) 	# GL/glext.h:4070
PFNGLLINKPROGRAMARBPROC = CFUNCTYPE(None, GLhandleARB) 	# GL/glext.h:4071
PFNGLUSEPROGRAMOBJECTARBPROC = CFUNCTYPE(None, GLhandleARB) 	# GL/glext.h:4072
PFNGLVALIDATEPROGRAMARBPROC = CFUNCTYPE(None, GLhandleARB) 	# GL/glext.h:4073
PFNGLUNIFORM1FARBPROC = CFUNCTYPE(None, GLint, GLfloat) 	# GL/glext.h:4074
PFNGLUNIFORM2FARBPROC = CFUNCTYPE(None, GLint, GLfloat, GLfloat) 	# GL/glext.h:4075
PFNGLUNIFORM3FARBPROC = CFUNCTYPE(None, GLint, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:4076
PFNGLUNIFORM4FARBPROC = CFUNCTYPE(None, GLint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:4077
PFNGLUNIFORM1IARBPROC = CFUNCTYPE(None, GLint, GLint) 	# GL/glext.h:4078
PFNGLUNIFORM2IARBPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:4079
PFNGLUNIFORM3IARBPROC = CFUNCTYPE(None, GLint, GLint, GLint, GLint) 	# GL/glext.h:4080
PFNGLUNIFORM4IARBPROC = CFUNCTYPE(None, GLint, GLint, GLint, GLint, GLint) 	# GL/glext.h:4081
PFNGLUNIFORM1FVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4082
PFNGLUNIFORM2FVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4083
PFNGLUNIFORM3FVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4084
PFNGLUNIFORM4FVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4085
PFNGLUNIFORM1IVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:4086
PFNGLUNIFORM2IVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:4087
PFNGLUNIFORM3IVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:4088
PFNGLUNIFORM4IVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:4089
PFNGLUNIFORMMATRIX2FVARBPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:4090
PFNGLUNIFORMMATRIX3FVARBPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:4091
PFNGLUNIFORMMATRIX4FVARBPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:4092
PFNGLGETOBJECTPARAMETERFVARBPROC = CFUNCTYPE(None, GLhandleARB, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4093
PFNGLGETOBJECTPARAMETERIVARBPROC = CFUNCTYPE(None, GLhandleARB, GLenum, POINTER(GLint)) 	# GL/glext.h:4094
PFNGLGETINFOLOGARBPROC = CFUNCTYPE(None, GLhandleARB, GLsizei, POINTER(GLsizei), POINTER(GLcharARB)) 	# GL/glext.h:4095
PFNGLGETATTACHEDOBJECTSARBPROC = CFUNCTYPE(None, GLhandleARB, GLsizei, POINTER(GLsizei), POINTER(GLhandleARB)) 	# GL/glext.h:4096
PFNGLGETUNIFORMLOCATIONARBPROC = CFUNCTYPE(GLint, GLhandleARB, POINTER(GLcharARB)) 	# GL/glext.h:4097
PFNGLGETACTIVEUNIFORMARBPROC = CFUNCTYPE(None, GLhandleARB, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLcharARB)) 	# GL/glext.h:4098
PFNGLGETUNIFORMFVARBPROC = CFUNCTYPE(None, GLhandleARB, GLint, POINTER(GLfloat)) 	# GL/glext.h:4099
PFNGLGETUNIFORMIVARBPROC = CFUNCTYPE(None, GLhandleARB, GLint, POINTER(GLint)) 	# GL/glext.h:4100
PFNGLGETSHADERSOURCEARBPROC = CFUNCTYPE(None, GLhandleARB, GLsizei, POINTER(GLsizei), POINTER(GLcharARB)) 	# GL/glext.h:4101
# ARB_vertex_shader (GL/glext.h:4104)
GL_ARB_vertex_shader = 1 	# GL/glext.h:4105
# GL/glext.h:4107
glBindAttribLocationARB = _link_function('glBindAttribLocationARB', None, [GLhandleARB, GLuint, POINTER(GLcharARB)], 'ARB_vertex_shader')

# GL/glext.h:4108
glGetActiveAttribARB = _link_function('glGetActiveAttribARB', None, [GLhandleARB, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLcharARB)], 'ARB_vertex_shader')

# GL/glext.h:4109
glGetAttribLocationARB = _link_function('glGetAttribLocationARB', GLint, [GLhandleARB, POINTER(GLcharARB)], 'ARB_vertex_shader')

PFNGLBINDATTRIBLOCATIONARBPROC = CFUNCTYPE(None, GLhandleARB, GLuint, POINTER(GLcharARB)) 	# GL/glext.h:4111
PFNGLGETACTIVEATTRIBARBPROC = CFUNCTYPE(None, GLhandleARB, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLcharARB)) 	# GL/glext.h:4112
PFNGLGETATTRIBLOCATIONARBPROC = CFUNCTYPE(GLint, GLhandleARB, POINTER(GLcharARB)) 	# GL/glext.h:4113
# ARB_fragment_shader (GL/glext.h:4116)
GL_ARB_fragment_shader = 1 	# GL/glext.h:4117
# ARB_shading_language_100 (GL/glext.h:4120)
GL_ARB_shading_language_100 = 1 	# GL/glext.h:4121
# ARB_texture_non_power_of_two (GL/glext.h:4124)
GL_ARB_texture_non_power_of_two = 1 	# GL/glext.h:4125
# ARB_point_sprite (GL/glext.h:4128)
GL_ARB_point_sprite = 1 	# GL/glext.h:4129
# ARB_fragment_program_shadow (GL/glext.h:4132)
GL_ARB_fragment_program_shadow = 1 	# GL/glext.h:4133
# ARB_draw_buffers (GL/glext.h:4136)
GL_ARB_draw_buffers = 1 	# GL/glext.h:4137
# GL/glext.h:4139
glDrawBuffersARB = _link_function('glDrawBuffersARB', None, [GLsizei, POINTER(GLenum)], 'ARB_draw_buffers')

PFNGLDRAWBUFFERSARBPROC = CFUNCTYPE(None, GLsizei, POINTER(GLenum)) 	# GL/glext.h:4141
# ARB_texture_rectangle (GL/glext.h:4144)
GL_ARB_texture_rectangle = 1 	# GL/glext.h:4145
# ARB_color_buffer_float (GL/glext.h:4148)
GL_ARB_color_buffer_float = 1 	# GL/glext.h:4149
# GL/glext.h:4151
glClampColorARB = _link_function('glClampColorARB', None, [GLenum, GLenum], 'ARB_color_buffer_float')

PFNGLCLAMPCOLORARBPROC = CFUNCTYPE(None, GLenum, GLenum) 	# GL/glext.h:4153
# ARB_half_float_pixel (GL/glext.h:4156)
GL_ARB_half_float_pixel = 1 	# GL/glext.h:4157
# ARB_texture_float (GL/glext.h:4160)
GL_ARB_texture_float = 1 	# GL/glext.h:4161
# ARB_pixel_buffer_object (GL/glext.h:4164)
GL_ARB_pixel_buffer_object = 1 	# GL/glext.h:4165
# EXT_abgr (GL/glext.h:4168)
GL_EXT_abgr = 1 	# GL/glext.h:4169
# EXT_blend_color (GL/glext.h:4172)
GL_EXT_blend_color = 1 	# GL/glext.h:4173
# GL/glext.h:4175
glBlendColorEXT = _link_function('glBlendColorEXT', None, [GLclampf, GLclampf, GLclampf, GLclampf], 'EXT_blend_color')

PFNGLBLENDCOLOREXTPROC = CFUNCTYPE(None, GLclampf, GLclampf, GLclampf, GLclampf) 	# GL/glext.h:4177
# EXT_polygon_offset (GL/glext.h:4180)
GL_EXT_polygon_offset = 1 	# GL/glext.h:4181
# GL/glext.h:4183
glPolygonOffsetEXT = _link_function('glPolygonOffsetEXT', None, [GLfloat, GLfloat], 'EXT_polygon_offset')

PFNGLPOLYGONOFFSETEXTPROC = CFUNCTYPE(None, GLfloat, GLfloat) 	# GL/glext.h:4185
# EXT_texture (GL/glext.h:4188)
GL_EXT_texture = 1 	# GL/glext.h:4189
# EXT_texture3D (GL/glext.h:4192)
GL_EXT_texture3D = 1 	# GL/glext.h:4193
# GL/glext.h:4195
glTexImage3DEXT = _link_function('glTexImage3DEXT', None, [GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, POINTER(GLvoid)], 'EXT_texture3D')

# GL/glext.h:4196
glTexSubImage3DEXT = _link_function('glTexSubImage3DEXT', None, [GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'EXT_texture3D')

PFNGLTEXIMAGE3DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4198
PFNGLTEXSUBIMAGE3DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4199
# SGIS_texture_filter4 (GL/glext.h:4202)
GL_SGIS_texture_filter4 = 1 	# GL/glext.h:4203
# GL/glext.h:4205
glGetTexFilterFuncSGIS = _link_function('glGetTexFilterFuncSGIS', None, [GLenum, GLenum, POINTER(GLfloat)], 'SGIS_texture_filter4')

# GL/glext.h:4206
glTexFilterFuncSGIS = _link_function('glTexFilterFuncSGIS', None, [GLenum, GLenum, GLsizei, POINTER(GLfloat)], 'SGIS_texture_filter4')

PFNGLGETTEXFILTERFUNCSGISPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4208
PFNGLTEXFILTERFUNCSGISPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4209
# EXT_subtexture (GL/glext.h:4212)
GL_EXT_subtexture = 1 	# GL/glext.h:4213
# GL/glext.h:4215
glTexSubImage1DEXT = _link_function('glTexSubImage1DEXT', None, [GLenum, GLint, GLint, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'EXT_subtexture')

# GL/glext.h:4216
glTexSubImage2DEXT = _link_function('glTexSubImage2DEXT', None, [GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'EXT_subtexture')

PFNGLTEXSUBIMAGE1DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4218
PFNGLTEXSUBIMAGE2DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4219
# EXT_copy_texture (GL/glext.h:4222)
GL_EXT_copy_texture = 1 	# GL/glext.h:4223
# GL/glext.h:4225
glCopyTexImage1DEXT = _link_function('glCopyTexImage1DEXT', None, [GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint], 'EXT_copy_texture')

# GL/glext.h:4226
glCopyTexImage2DEXT = _link_function('glCopyTexImage2DEXT', None, [GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint], 'EXT_copy_texture')

# GL/glext.h:4227
glCopyTexSubImage1DEXT = _link_function('glCopyTexSubImage1DEXT', None, [GLenum, GLint, GLint, GLint, GLint, GLsizei], 'EXT_copy_texture')

# GL/glext.h:4228
glCopyTexSubImage2DEXT = _link_function('glCopyTexSubImage2DEXT', None, [GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei], 'EXT_copy_texture')

# GL/glext.h:4229
glCopyTexSubImage3DEXT = _link_function('glCopyTexSubImage3DEXT', None, [GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei], 'EXT_copy_texture')

PFNGLCOPYTEXIMAGE1DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint) 	# GL/glext.h:4231
PFNGLCOPYTEXIMAGE2DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint) 	# GL/glext.h:4232
PFNGLCOPYTEXSUBIMAGE1DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLsizei) 	# GL/glext.h:4233
PFNGLCOPYTEXSUBIMAGE2DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei) 	# GL/glext.h:4234
PFNGLCOPYTEXSUBIMAGE3DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei) 	# GL/glext.h:4235
# EXT_histogram (GL/glext.h:4238)
GL_EXT_histogram = 1 	# GL/glext.h:4239
# GL/glext.h:4241
glGetHistogramEXT = _link_function('glGetHistogramEXT', None, [GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)], 'EXT_histogram')

# GL/glext.h:4242
glGetHistogramParameterfvEXT = _link_function('glGetHistogramParameterfvEXT', None, [GLenum, GLenum, POINTER(GLfloat)], 'EXT_histogram')

# GL/glext.h:4243
glGetHistogramParameterivEXT = _link_function('glGetHistogramParameterivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_histogram')

# GL/glext.h:4244
glGetMinmaxEXT = _link_function('glGetMinmaxEXT', None, [GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)], 'EXT_histogram')

# GL/glext.h:4245
glGetMinmaxParameterfvEXT = _link_function('glGetMinmaxParameterfvEXT', None, [GLenum, GLenum, POINTER(GLfloat)], 'EXT_histogram')

# GL/glext.h:4246
glGetMinmaxParameterivEXT = _link_function('glGetMinmaxParameterivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_histogram')

# GL/glext.h:4247
glHistogramEXT = _link_function('glHistogramEXT', None, [GLenum, GLsizei, GLenum, GLboolean], 'EXT_histogram')

# GL/glext.h:4248
glMinmaxEXT = _link_function('glMinmaxEXT', None, [GLenum, GLenum, GLboolean], 'EXT_histogram')

# GL/glext.h:4249
glResetHistogramEXT = _link_function('glResetHistogramEXT', None, [GLenum], 'EXT_histogram')

# GL/glext.h:4250
glResetMinmaxEXT = _link_function('glResetMinmaxEXT', None, [GLenum], 'EXT_histogram')

PFNGLGETHISTOGRAMEXTPROC = CFUNCTYPE(None, GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4252
PFNGLGETHISTOGRAMPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4253
PFNGLGETHISTOGRAMPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4254
PFNGLGETMINMAXEXTPROC = CFUNCTYPE(None, GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4255
PFNGLGETMINMAXPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4256
PFNGLGETMINMAXPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4257
PFNGLHISTOGRAMEXTPROC = CFUNCTYPE(None, GLenum, GLsizei, GLenum, GLboolean) 	# GL/glext.h:4258
PFNGLMINMAXEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLboolean) 	# GL/glext.h:4259
PFNGLRESETHISTOGRAMEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:4260
PFNGLRESETMINMAXEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:4261
# EXT_convolution (GL/glext.h:4264)
GL_EXT_convolution = 1 	# GL/glext.h:4265
# GL/glext.h:4267
glConvolutionFilter1DEXT = _link_function('glConvolutionFilter1DEXT', None, [GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'EXT_convolution')

# GL/glext.h:4268
glConvolutionFilter2DEXT = _link_function('glConvolutionFilter2DEXT', None, [GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'EXT_convolution')

# GL/glext.h:4269
glConvolutionParameterfEXT = _link_function('glConvolutionParameterfEXT', None, [GLenum, GLenum, GLfloat], 'EXT_convolution')

# GL/glext.h:4270
glConvolutionParameterfvEXT = _link_function('glConvolutionParameterfvEXT', None, [GLenum, GLenum, POINTER(GLfloat)], 'EXT_convolution')

# GL/glext.h:4271
glConvolutionParameteriEXT = _link_function('glConvolutionParameteriEXT', None, [GLenum, GLenum, GLint], 'EXT_convolution')

# GL/glext.h:4272
glConvolutionParameterivEXT = _link_function('glConvolutionParameterivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_convolution')

# GL/glext.h:4273
glCopyConvolutionFilter1DEXT = _link_function('glCopyConvolutionFilter1DEXT', None, [GLenum, GLenum, GLint, GLint, GLsizei], 'EXT_convolution')

# GL/glext.h:4274
glCopyConvolutionFilter2DEXT = _link_function('glCopyConvolutionFilter2DEXT', None, [GLenum, GLenum, GLint, GLint, GLsizei, GLsizei], 'EXT_convolution')

# GL/glext.h:4275
glGetConvolutionFilterEXT = _link_function('glGetConvolutionFilterEXT', None, [GLenum, GLenum, GLenum, POINTER(GLvoid)], 'EXT_convolution')

# GL/glext.h:4276
glGetConvolutionParameterfvEXT = _link_function('glGetConvolutionParameterfvEXT', None, [GLenum, GLenum, POINTER(GLfloat)], 'EXT_convolution')

# GL/glext.h:4277
glGetConvolutionParameterivEXT = _link_function('glGetConvolutionParameterivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_convolution')

# GL/glext.h:4278
glGetSeparableFilterEXT = _link_function('glGetSeparableFilterEXT', None, [GLenum, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid), POINTER(GLvoid)], 'EXT_convolution')

# GL/glext.h:4279
glSeparableFilter2DEXT = _link_function('glSeparableFilter2DEXT', None, [GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid)], 'EXT_convolution')

PFNGLCONVOLUTIONFILTER1DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4281
PFNGLCONVOLUTIONFILTER2DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4282
PFNGLCONVOLUTIONPARAMETERFEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLfloat) 	# GL/glext.h:4283
PFNGLCONVOLUTIONPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4284
PFNGLCONVOLUTIONPARAMETERIEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLint) 	# GL/glext.h:4285
PFNGLCONVOLUTIONPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4286
PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLint, GLsizei) 	# GL/glext.h:4287
PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLint, GLsizei, GLsizei) 	# GL/glext.h:4288
PFNGLGETCONVOLUTIONFILTEREXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4289
PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4290
PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4291
PFNGLGETSEPARABLEFILTEREXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid), POINTER(GLvoid)) 	# GL/glext.h:4292
PFNGLSEPARABLEFILTER2DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid)) 	# GL/glext.h:4293
# EXT_color_matrix (GL/glext.h:4296)
GL_EXT_color_matrix = 1 	# GL/glext.h:4297
# SGI_color_table (GL/glext.h:4300)
GL_SGI_color_table = 1 	# GL/glext.h:4301
# GL/glext.h:4303
glColorTableSGI = _link_function('glColorTableSGI', None, [GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'SGI_color_table')

# GL/glext.h:4304
glColorTableParameterfvSGI = _link_function('glColorTableParameterfvSGI', None, [GLenum, GLenum, POINTER(GLfloat)], 'SGI_color_table')

# GL/glext.h:4305
glColorTableParameterivSGI = _link_function('glColorTableParameterivSGI', None, [GLenum, GLenum, POINTER(GLint)], 'SGI_color_table')

# GL/glext.h:4306
glCopyColorTableSGI = _link_function('glCopyColorTableSGI', None, [GLenum, GLenum, GLint, GLint, GLsizei], 'SGI_color_table')

# GL/glext.h:4307
glGetColorTableSGI = _link_function('glGetColorTableSGI', None, [GLenum, GLenum, GLenum, POINTER(GLvoid)], 'SGI_color_table')

# GL/glext.h:4308
glGetColorTableParameterfvSGI = _link_function('glGetColorTableParameterfvSGI', None, [GLenum, GLenum, POINTER(GLfloat)], 'SGI_color_table')

# GL/glext.h:4309
glGetColorTableParameterivSGI = _link_function('glGetColorTableParameterivSGI', None, [GLenum, GLenum, POINTER(GLint)], 'SGI_color_table')

PFNGLCOLORTABLESGIPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4311
PFNGLCOLORTABLEPARAMETERFVSGIPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4312
PFNGLCOLORTABLEPARAMETERIVSGIPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4313
PFNGLCOPYCOLORTABLESGIPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLint, GLsizei) 	# GL/glext.h:4314
PFNGLGETCOLORTABLESGIPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4315
PFNGLGETCOLORTABLEPARAMETERFVSGIPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4316
PFNGLGETCOLORTABLEPARAMETERIVSGIPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4317
# SGIX_pixel_texture (GL/glext.h:4320)
GL_SGIX_pixel_texture = 1 	# GL/glext.h:4321
# GL/glext.h:4323
glPixelTexGenSGIX = _link_function('glPixelTexGenSGIX', None, [GLenum], 'SGIX_pixel_texture')

PFNGLPIXELTEXGENSGIXPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:4325
# SGIS_pixel_texture (GL/glext.h:4328)
GL_SGIS_pixel_texture = 1 	# GL/glext.h:4329
# GL/glext.h:4331
glPixelTexGenParameteriSGIS = _link_function('glPixelTexGenParameteriSGIS', None, [GLenum, GLint], 'SGIS_pixel_texture')

# GL/glext.h:4332
glPixelTexGenParameterivSGIS = _link_function('glPixelTexGenParameterivSGIS', None, [GLenum, POINTER(GLint)], 'SGIS_pixel_texture')

# GL/glext.h:4333
glPixelTexGenParameterfSGIS = _link_function('glPixelTexGenParameterfSGIS', None, [GLenum, GLfloat], 'SGIS_pixel_texture')

# GL/glext.h:4334
glPixelTexGenParameterfvSGIS = _link_function('glPixelTexGenParameterfvSGIS', None, [GLenum, POINTER(GLfloat)], 'SGIS_pixel_texture')

# GL/glext.h:4335
glGetPixelTexGenParameterivSGIS = _link_function('glGetPixelTexGenParameterivSGIS', None, [GLenum, POINTER(GLint)], 'SGIS_pixel_texture')

# GL/glext.h:4336
glGetPixelTexGenParameterfvSGIS = _link_function('glGetPixelTexGenParameterfvSGIS', None, [GLenum, POINTER(GLfloat)], 'SGIS_pixel_texture')

PFNGLPIXELTEXGENPARAMETERISGISPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:4338
PFNGLPIXELTEXGENPARAMETERIVSGISPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:4339
PFNGLPIXELTEXGENPARAMETERFSGISPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:4340
PFNGLPIXELTEXGENPARAMETERFVSGISPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4341
PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:4342
PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4343
# SGIS_texture4D (GL/glext.h:4346)
GL_SGIS_texture4D = 1 	# GL/glext.h:4347
# GL/glext.h:4349
glTexImage4DSGIS = _link_function('glTexImage4DSGIS', None, [GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, POINTER(GLvoid)], 'SGIS_texture4D')

# GL/glext.h:4350
glTexSubImage4DSGIS = _link_function('glTexSubImage4DSGIS', None, [GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'SGIS_texture4D')

PFNGLTEXIMAGE4DSGISPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4352
PFNGLTEXSUBIMAGE4DSGISPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4353
# SGI_texture_color_table (GL/glext.h:4356)
GL_SGI_texture_color_table = 1 	# GL/glext.h:4357
# EXT_cmyka (GL/glext.h:4360)
GL_EXT_cmyka = 1 	# GL/glext.h:4361
# EXT_texture_object (GL/glext.h:4364)
GL_EXT_texture_object = 1 	# GL/glext.h:4365
# GL/glext.h:4367
glAreTexturesResidentEXT = _link_function('glAreTexturesResidentEXT', GLboolean, [GLsizei, POINTER(GLuint), POINTER(GLboolean)], 'EXT_texture_object')

# GL/glext.h:4368
glBindTextureEXT = _link_function('glBindTextureEXT', None, [GLenum, GLuint], 'EXT_texture_object')

# GL/glext.h:4369
glDeleteTexturesEXT = _link_function('glDeleteTexturesEXT', None, [GLsizei, POINTER(GLuint)], 'EXT_texture_object')

# GL/glext.h:4370
glGenTexturesEXT = _link_function('glGenTexturesEXT', None, [GLsizei, POINTER(GLuint)], 'EXT_texture_object')

# GL/glext.h:4371
glIsTextureEXT = _link_function('glIsTextureEXT', GLboolean, [GLuint], 'EXT_texture_object')

# GL/glext.h:4372
glPrioritizeTexturesEXT = _link_function('glPrioritizeTexturesEXT', None, [GLsizei, POINTER(GLuint), POINTER(GLclampf)], 'EXT_texture_object')

PFNGLARETEXTURESRESIDENTEXTPROC = CFUNCTYPE(GLboolean, GLsizei, POINTER(GLuint), POINTER(GLboolean)) 	# GL/glext.h:4374
PFNGLBINDTEXTUREEXTPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:4375
PFNGLDELETETEXTURESEXTPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:4376
PFNGLGENTEXTURESEXTPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:4377
PFNGLISTEXTUREEXTPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:4378
PFNGLPRIORITIZETEXTURESEXTPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint), POINTER(GLclampf)) 	# GL/glext.h:4379
# SGIS_detail_texture (GL/glext.h:4382)
GL_SGIS_detail_texture = 1 	# GL/glext.h:4383
# GL/glext.h:4385
glDetailTexFuncSGIS = _link_function('glDetailTexFuncSGIS', None, [GLenum, GLsizei, POINTER(GLfloat)], 'SGIS_detail_texture')

# GL/glext.h:4386
glGetDetailTexFuncSGIS = _link_function('glGetDetailTexFuncSGIS', None, [GLenum, POINTER(GLfloat)], 'SGIS_detail_texture')

PFNGLDETAILTEXFUNCSGISPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4388
PFNGLGETDETAILTEXFUNCSGISPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4389
# SGIS_sharpen_texture (GL/glext.h:4392)
GL_SGIS_sharpen_texture = 1 	# GL/glext.h:4393
# GL/glext.h:4395
glSharpenTexFuncSGIS = _link_function('glSharpenTexFuncSGIS', None, [GLenum, GLsizei, POINTER(GLfloat)], 'SGIS_sharpen_texture')

# GL/glext.h:4396
glGetSharpenTexFuncSGIS = _link_function('glGetSharpenTexFuncSGIS', None, [GLenum, POINTER(GLfloat)], 'SGIS_sharpen_texture')

PFNGLSHARPENTEXFUNCSGISPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4398
PFNGLGETSHARPENTEXFUNCSGISPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4399
# EXT_packed_pixels (GL/glext.h:4402)
GL_EXT_packed_pixels = 1 	# GL/glext.h:4403
# SGIS_texture_lod (GL/glext.h:4406)
GL_SGIS_texture_lod = 1 	# GL/glext.h:4407
# SGIS_multisample (GL/glext.h:4410)
GL_SGIS_multisample = 1 	# GL/glext.h:4411
# GL/glext.h:4413
glSampleMaskSGIS = _link_function('glSampleMaskSGIS', None, [GLclampf, GLboolean], 'SGIS_multisample')

# GL/glext.h:4414
glSamplePatternSGIS = _link_function('glSamplePatternSGIS', None, [GLenum], 'SGIS_multisample')

PFNGLSAMPLEMASKSGISPROC = CFUNCTYPE(None, GLclampf, GLboolean) 	# GL/glext.h:4416
PFNGLSAMPLEPATTERNSGISPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:4417
# EXT_rescale_normal (GL/glext.h:4420)
GL_EXT_rescale_normal = 1 	# GL/glext.h:4421
# EXT_vertex_array (GL/glext.h:4424)
GL_EXT_vertex_array = 1 	# GL/glext.h:4425
# GL/glext.h:4427
glArrayElementEXT = _link_function('glArrayElementEXT', None, [GLint], 'EXT_vertex_array')

# GL/glext.h:4428
glColorPointerEXT = _link_function('glColorPointerEXT', None, [GLint, GLenum, GLsizei, GLsizei, POINTER(GLvoid)], 'EXT_vertex_array')

# GL/glext.h:4429
glDrawArraysEXT = _link_function('glDrawArraysEXT', None, [GLenum, GLint, GLsizei], 'EXT_vertex_array')

# GL/glext.h:4430
glEdgeFlagPointerEXT = _link_function('glEdgeFlagPointerEXT', None, [GLsizei, GLsizei, POINTER(GLboolean)], 'EXT_vertex_array')

# GL/glext.h:4431
glGetPointervEXT = _link_function('glGetPointervEXT', None, [GLenum, POINTER(POINTER(GLvoid))], 'EXT_vertex_array')

# GL/glext.h:4432
glIndexPointerEXT = _link_function('glIndexPointerEXT', None, [GLenum, GLsizei, GLsizei, POINTER(GLvoid)], 'EXT_vertex_array')

# GL/glext.h:4433
glNormalPointerEXT = _link_function('glNormalPointerEXT', None, [GLenum, GLsizei, GLsizei, POINTER(GLvoid)], 'EXT_vertex_array')

# GL/glext.h:4434
glTexCoordPointerEXT = _link_function('glTexCoordPointerEXT', None, [GLint, GLenum, GLsizei, GLsizei, POINTER(GLvoid)], 'EXT_vertex_array')

# GL/glext.h:4435
glVertexPointerEXT = _link_function('glVertexPointerEXT', None, [GLint, GLenum, GLsizei, GLsizei, POINTER(GLvoid)], 'EXT_vertex_array')

PFNGLARRAYELEMENTEXTPROC = CFUNCTYPE(None, GLint) 	# GL/glext.h:4437
PFNGLCOLORPOINTEREXTPROC = CFUNCTYPE(None, GLint, GLenum, GLsizei, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4438
PFNGLDRAWARRAYSEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLsizei) 	# GL/glext.h:4439
PFNGLEDGEFLAGPOINTEREXTPROC = CFUNCTYPE(None, GLsizei, GLsizei, POINTER(GLboolean)) 	# GL/glext.h:4440
PFNGLGETPOINTERVEXTPROC = CFUNCTYPE(None, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:4441
PFNGLINDEXPOINTEREXTPROC = CFUNCTYPE(None, GLenum, GLsizei, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4442
PFNGLNORMALPOINTEREXTPROC = CFUNCTYPE(None, GLenum, GLsizei, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4443
PFNGLTEXCOORDPOINTEREXTPROC = CFUNCTYPE(None, GLint, GLenum, GLsizei, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4444
PFNGLVERTEXPOINTEREXTPROC = CFUNCTYPE(None, GLint, GLenum, GLsizei, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4445
# EXT_misc_attribute (GL/glext.h:4448)
GL_EXT_misc_attribute = 1 	# GL/glext.h:4449
# SGIS_generate_mipmap (GL/glext.h:4452)
GL_SGIS_generate_mipmap = 1 	# GL/glext.h:4453
# SGIX_clipmap (GL/glext.h:4456)
GL_SGIX_clipmap = 1 	# GL/glext.h:4457
# SGIX_shadow (GL/glext.h:4460)
GL_SGIX_shadow = 1 	# GL/glext.h:4461
# SGIS_texture_edge_clamp (GL/glext.h:4464)
GL_SGIS_texture_edge_clamp = 1 	# GL/glext.h:4465
# SGIS_texture_border_clamp (GL/glext.h:4468)
GL_SGIS_texture_border_clamp = 1 	# GL/glext.h:4469
# EXT_blend_minmax (GL/glext.h:4472)
GL_EXT_blend_minmax = 1 	# GL/glext.h:4473
# GL/glext.h:4475
glBlendEquationEXT = _link_function('glBlendEquationEXT', None, [GLenum], 'EXT_blend_minmax')

PFNGLBLENDEQUATIONEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:4477
# EXT_blend_subtract (GL/glext.h:4480)
GL_EXT_blend_subtract = 1 	# GL/glext.h:4481
# EXT_blend_logic_op (GL/glext.h:4484)
GL_EXT_blend_logic_op = 1 	# GL/glext.h:4485
# SGIX_interlace (GL/glext.h:4488)
GL_SGIX_interlace = 1 	# GL/glext.h:4489
# SGIX_pixel_tiles (GL/glext.h:4492)
GL_SGIX_pixel_tiles = 1 	# GL/glext.h:4493
# SGIX_texture_select (GL/glext.h:4496)
GL_SGIX_texture_select = 1 	# GL/glext.h:4497
# SGIX_sprite (GL/glext.h:4500)
GL_SGIX_sprite = 1 	# GL/glext.h:4501
# GL/glext.h:4503
glSpriteParameterfSGIX = _link_function('glSpriteParameterfSGIX', None, [GLenum, GLfloat], 'SGIX_sprite')

# GL/glext.h:4504
glSpriteParameterfvSGIX = _link_function('glSpriteParameterfvSGIX', None, [GLenum, POINTER(GLfloat)], 'SGIX_sprite')

# GL/glext.h:4505
glSpriteParameteriSGIX = _link_function('glSpriteParameteriSGIX', None, [GLenum, GLint], 'SGIX_sprite')

# GL/glext.h:4506
glSpriteParameterivSGIX = _link_function('glSpriteParameterivSGIX', None, [GLenum, POINTER(GLint)], 'SGIX_sprite')

PFNGLSPRITEPARAMETERFSGIXPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:4508
PFNGLSPRITEPARAMETERFVSGIXPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4509
PFNGLSPRITEPARAMETERISGIXPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:4510
PFNGLSPRITEPARAMETERIVSGIXPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:4511
# SGIX_texture_multi_buffer (GL/glext.h:4514)
GL_SGIX_texture_multi_buffer = 1 	# GL/glext.h:4515
# EXT_point_parameters (GL/glext.h:4518)
GL_EXT_point_parameters = 1 	# GL/glext.h:4519
# GL/glext.h:4521
glPointParameterfEXT = _link_function('glPointParameterfEXT', None, [GLenum, GLfloat], 'EXT_point_parameters')

# GL/glext.h:4522
glPointParameterfvEXT = _link_function('glPointParameterfvEXT', None, [GLenum, POINTER(GLfloat)], 'EXT_point_parameters')

PFNGLPOINTPARAMETERFEXTPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:4524
PFNGLPOINTPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4525
# SGIS_point_parameters (GL/glext.h:4528)
GL_SGIS_point_parameters = 1 	# GL/glext.h:4529
# GL/glext.h:4531
glPointParameterfSGIS = _link_function('glPointParameterfSGIS', None, [GLenum, GLfloat], 'SGIS_point_parameters')

# GL/glext.h:4532
glPointParameterfvSGIS = _link_function('glPointParameterfvSGIS', None, [GLenum, POINTER(GLfloat)], 'SGIS_point_parameters')

PFNGLPOINTPARAMETERFSGISPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:4534
PFNGLPOINTPARAMETERFVSGISPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4535
# SGIX_instruments (GL/glext.h:4538)
GL_SGIX_instruments = 1 	# GL/glext.h:4539
# GL/glext.h:4541
glGetInstrumentsSGIX = _link_function('glGetInstrumentsSGIX', GLint, [], 'SGIX_instruments')

# GL/glext.h:4542
glInstrumentsBufferSGIX = _link_function('glInstrumentsBufferSGIX', None, [GLsizei, POINTER(GLint)], 'SGIX_instruments')

# GL/glext.h:4543
glPollInstrumentsSGIX = _link_function('glPollInstrumentsSGIX', GLint, [POINTER(GLint)], 'SGIX_instruments')

# GL/glext.h:4544
glReadInstrumentsSGIX = _link_function('glReadInstrumentsSGIX', None, [GLint], 'SGIX_instruments')

# GL/glext.h:4545
glStartInstrumentsSGIX = _link_function('glStartInstrumentsSGIX', None, [], 'SGIX_instruments')

# GL/glext.h:4546
glStopInstrumentsSGIX = _link_function('glStopInstrumentsSGIX', None, [GLint], 'SGIX_instruments')

PFNGLGETINSTRUMENTSSGIXPROC = CFUNCTYPE(GLint) 	# GL/glext.h:4548
PFNGLINSTRUMENTSBUFFERSGIXPROC = CFUNCTYPE(None, GLsizei, POINTER(GLint)) 	# GL/glext.h:4549
PFNGLPOLLINSTRUMENTSSGIXPROC = CFUNCTYPE(GLint, POINTER(GLint)) 	# GL/glext.h:4550
PFNGLREADINSTRUMENTSSGIXPROC = CFUNCTYPE(None, GLint) 	# GL/glext.h:4551
PFNGLSTARTINSTRUMENTSSGIXPROC = CFUNCTYPE(None) 	# GL/glext.h:4552
PFNGLSTOPINSTRUMENTSSGIXPROC = CFUNCTYPE(None, GLint) 	# GL/glext.h:4553
# SGIX_texture_scale_bias (GL/glext.h:4556)
GL_SGIX_texture_scale_bias = 1 	# GL/glext.h:4557
# SGIX_framezoom (GL/glext.h:4560)
GL_SGIX_framezoom = 1 	# GL/glext.h:4561
# GL/glext.h:4563
glFrameZoomSGIX = _link_function('glFrameZoomSGIX', None, [GLint], 'SGIX_framezoom')

PFNGLFRAMEZOOMSGIXPROC = CFUNCTYPE(None, GLint) 	# GL/glext.h:4565
# SGIX_tag_sample_buffer (GL/glext.h:4568)
GL_SGIX_tag_sample_buffer = 1 	# GL/glext.h:4569
# GL/glext.h:4571
glTagSampleBufferSGIX = _link_function('glTagSampleBufferSGIX', None, [], 'SGIX_tag_sample_buffer')

PFNGLTAGSAMPLEBUFFERSGIXPROC = CFUNCTYPE(None) 	# GL/glext.h:4573
# SGIX_polynomial_ffd (GL/glext.h:4576)
GL_SGIX_polynomial_ffd = 1 	# GL/glext.h:4577
# GL/glext.h:4579
glDeformationMap3dSGIX = _link_function('glDeformationMap3dSGIX', None, [GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, POINTER(GLdouble)], 'SGIX_polynomial_ffd')

# GL/glext.h:4580
glDeformationMap3fSGIX = _link_function('glDeformationMap3fSGIX', None, [GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, POINTER(GLfloat)], 'SGIX_polynomial_ffd')

GLbitfield = c_uint 	# /usr/include/GL/gl.h:55
# GL/glext.h:4581
glDeformSGIX = _link_function('glDeformSGIX', None, [GLbitfield], 'SGIX_polynomial_ffd')

# GL/glext.h:4582
glLoadIdentityDeformationMapSGIX = _link_function('glLoadIdentityDeformationMapSGIX', None, [GLbitfield], 'SGIX_polynomial_ffd')

PFNGLDEFORMATIONMAP3DSGIXPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, POINTER(GLdouble)) 	# GL/glext.h:4584
PFNGLDEFORMATIONMAP3FSGIXPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, POINTER(GLfloat)) 	# GL/glext.h:4585
PFNGLDEFORMSGIXPROC = CFUNCTYPE(None, GLbitfield) 	# GL/glext.h:4586
PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC = CFUNCTYPE(None, GLbitfield) 	# GL/glext.h:4587
# SGIX_reference_plane (GL/glext.h:4590)
GL_SGIX_reference_plane = 1 	# GL/glext.h:4591
# GL/glext.h:4593
glReferencePlaneSGIX = _link_function('glReferencePlaneSGIX', None, [POINTER(GLdouble)], 'SGIX_reference_plane')

PFNGLREFERENCEPLANESGIXPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:4595
# SGIX_flush_raster (GL/glext.h:4598)
GL_SGIX_flush_raster = 1 	# GL/glext.h:4599
# GL/glext.h:4601
glFlushRasterSGIX = _link_function('glFlushRasterSGIX', None, [], 'SGIX_flush_raster')

PFNGLFLUSHRASTERSGIXPROC = CFUNCTYPE(None) 	# GL/glext.h:4603
# SGIX_depth_texture (GL/glext.h:4606)
GL_SGIX_depth_texture = 1 	# GL/glext.h:4607
# SGIS_fog_function (GL/glext.h:4610)
GL_SGIS_fog_function = 1 	# GL/glext.h:4611
# GL/glext.h:4613
glFogFuncSGIS = _link_function('glFogFuncSGIS', None, [GLsizei, POINTER(GLfloat)], 'SGIS_fog_function')

# GL/glext.h:4614
glGetFogFuncSGIS = _link_function('glGetFogFuncSGIS', None, [POINTER(GLfloat)], 'SGIS_fog_function')

PFNGLFOGFUNCSGISPROC = CFUNCTYPE(None, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4616
PFNGLGETFOGFUNCSGISPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:4617
# SGIX_fog_offset (GL/glext.h:4620)
GL_SGIX_fog_offset = 1 	# GL/glext.h:4621
# HP_image_transform (GL/glext.h:4624)
GL_HP_image_transform = 1 	# GL/glext.h:4625
# GL/glext.h:4627
glImageTransformParameteriHP = _link_function('glImageTransformParameteriHP', None, [GLenum, GLenum, GLint], 'HP_image_transform')

# GL/glext.h:4628
glImageTransformParameterfHP = _link_function('glImageTransformParameterfHP', None, [GLenum, GLenum, GLfloat], 'HP_image_transform')

# GL/glext.h:4629
glImageTransformParameterivHP = _link_function('glImageTransformParameterivHP', None, [GLenum, GLenum, POINTER(GLint)], 'HP_image_transform')

# GL/glext.h:4630
glImageTransformParameterfvHP = _link_function('glImageTransformParameterfvHP', None, [GLenum, GLenum, POINTER(GLfloat)], 'HP_image_transform')

# GL/glext.h:4631
glGetImageTransformParameterivHP = _link_function('glGetImageTransformParameterivHP', None, [GLenum, GLenum, POINTER(GLint)], 'HP_image_transform')

# GL/glext.h:4632
glGetImageTransformParameterfvHP = _link_function('glGetImageTransformParameterfvHP', None, [GLenum, GLenum, POINTER(GLfloat)], 'HP_image_transform')

PFNGLIMAGETRANSFORMPARAMETERIHPPROC = CFUNCTYPE(None, GLenum, GLenum, GLint) 	# GL/glext.h:4634
PFNGLIMAGETRANSFORMPARAMETERFHPPROC = CFUNCTYPE(None, GLenum, GLenum, GLfloat) 	# GL/glext.h:4635
PFNGLIMAGETRANSFORMPARAMETERIVHPPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4636
PFNGLIMAGETRANSFORMPARAMETERFVHPPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4637
PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4638
PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4639
# HP_convolution_border_modes (GL/glext.h:4642)
GL_HP_convolution_border_modes = 1 	# GL/glext.h:4643
# SGIX_texture_add_env (GL/glext.h:4646)
GL_SGIX_texture_add_env = 1 	# GL/glext.h:4647
# EXT_color_subtable (GL/glext.h:4650)
GL_EXT_color_subtable = 1 	# GL/glext.h:4651
# GL/glext.h:4653
glColorSubTableEXT = _link_function('glColorSubTableEXT', None, [GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'EXT_color_subtable')

# GL/glext.h:4654
glCopyColorSubTableEXT = _link_function('glCopyColorSubTableEXT', None, [GLenum, GLsizei, GLint, GLint, GLsizei], 'EXT_color_subtable')

PFNGLCOLORSUBTABLEEXTPROC = CFUNCTYPE(None, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4656
PFNGLCOPYCOLORSUBTABLEEXTPROC = CFUNCTYPE(None, GLenum, GLsizei, GLint, GLint, GLsizei) 	# GL/glext.h:4657
# PGI_vertex_hints (GL/glext.h:4660)
GL_PGI_vertex_hints = 1 	# GL/glext.h:4661
# PGI_misc_hints (GL/glext.h:4664)
GL_PGI_misc_hints = 1 	# GL/glext.h:4665
# GL/glext.h:4667
glHintPGI = _link_function('glHintPGI', None, [GLenum, GLint], 'PGI_misc_hints')

PFNGLHINTPGIPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:4669
# EXT_paletted_texture (GL/glext.h:4672)
GL_EXT_paletted_texture = 1 	# GL/glext.h:4673
# GL/glext.h:4675
glColorTableEXT = _link_function('glColorTableEXT', None, [GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'EXT_paletted_texture')

# GL/glext.h:4676
glGetColorTableEXT = _link_function('glGetColorTableEXT', None, [GLenum, GLenum, GLenum, POINTER(GLvoid)], 'EXT_paletted_texture')

# GL/glext.h:4677
glGetColorTableParameterivEXT = _link_function('glGetColorTableParameterivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_paletted_texture')

# GL/glext.h:4678
glGetColorTableParameterfvEXT = _link_function('glGetColorTableParameterfvEXT', None, [GLenum, GLenum, POINTER(GLfloat)], 'EXT_paletted_texture')

PFNGLCOLORTABLEEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4680
PFNGLGETCOLORTABLEEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4681
PFNGLGETCOLORTABLEPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4682
PFNGLGETCOLORTABLEPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4683
# EXT_clip_volume_hint (GL/glext.h:4686)
GL_EXT_clip_volume_hint = 1 	# GL/glext.h:4687
# SGIX_list_priority (GL/glext.h:4690)
GL_SGIX_list_priority = 1 	# GL/glext.h:4691
# GL/glext.h:4693
glGetListParameterfvSGIX = _link_function('glGetListParameterfvSGIX', None, [GLuint, GLenum, POINTER(GLfloat)], 'SGIX_list_priority')

# GL/glext.h:4694
glGetListParameterivSGIX = _link_function('glGetListParameterivSGIX', None, [GLuint, GLenum, POINTER(GLint)], 'SGIX_list_priority')

# GL/glext.h:4695
glListParameterfSGIX = _link_function('glListParameterfSGIX', None, [GLuint, GLenum, GLfloat], 'SGIX_list_priority')

# GL/glext.h:4696
glListParameterfvSGIX = _link_function('glListParameterfvSGIX', None, [GLuint, GLenum, POINTER(GLfloat)], 'SGIX_list_priority')

# GL/glext.h:4697
glListParameteriSGIX = _link_function('glListParameteriSGIX', None, [GLuint, GLenum, GLint], 'SGIX_list_priority')

# GL/glext.h:4698
glListParameterivSGIX = _link_function('glListParameterivSGIX', None, [GLuint, GLenum, POINTER(GLint)], 'SGIX_list_priority')

PFNGLGETLISTPARAMETERFVSGIXPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4700
PFNGLGETLISTPARAMETERIVSGIXPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:4701
PFNGLLISTPARAMETERFSGIXPROC = CFUNCTYPE(None, GLuint, GLenum, GLfloat) 	# GL/glext.h:4702
PFNGLLISTPARAMETERFVSGIXPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4703
PFNGLLISTPARAMETERISGIXPROC = CFUNCTYPE(None, GLuint, GLenum, GLint) 	# GL/glext.h:4704
PFNGLLISTPARAMETERIVSGIXPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:4705
# SGIX_ir_instrument1 (GL/glext.h:4708)
GL_SGIX_ir_instrument1 = 1 	# GL/glext.h:4709
# SGIX_calligraphic_fragment (GL/glext.h:4712)
GL_SGIX_calligraphic_fragment = 1 	# GL/glext.h:4713
# SGIX_texture_lod_bias (GL/glext.h:4716)
GL_SGIX_texture_lod_bias = 1 	# GL/glext.h:4717
# SGIX_shadow_ambient (GL/glext.h:4720)
GL_SGIX_shadow_ambient = 1 	# GL/glext.h:4721
# EXT_index_texture (GL/glext.h:4724)
GL_EXT_index_texture = 1 	# GL/glext.h:4725
# EXT_index_material (GL/glext.h:4728)
GL_EXT_index_material = 1 	# GL/glext.h:4729
# GL/glext.h:4731
glIndexMaterialEXT = _link_function('glIndexMaterialEXT', None, [GLenum, GLenum], 'EXT_index_material')

PFNGLINDEXMATERIALEXTPROC = CFUNCTYPE(None, GLenum, GLenum) 	# GL/glext.h:4733
# EXT_index_func (GL/glext.h:4736)
GL_EXT_index_func = 1 	# GL/glext.h:4737
# GL/glext.h:4739
glIndexFuncEXT = _link_function('glIndexFuncEXT', None, [GLenum, GLclampf], 'EXT_index_func')

PFNGLINDEXFUNCEXTPROC = CFUNCTYPE(None, GLenum, GLclampf) 	# GL/glext.h:4741
# EXT_index_array_formats (GL/glext.h:4744)
GL_EXT_index_array_formats = 1 	# GL/glext.h:4745
# EXT_compiled_vertex_array (GL/glext.h:4748)
GL_EXT_compiled_vertex_array = 1 	# GL/glext.h:4749
# GL/glext.h:4751
glLockArraysEXT = _link_function('glLockArraysEXT', None, [GLint, GLsizei], 'EXT_compiled_vertex_array')

# GL/glext.h:4752
glUnlockArraysEXT = _link_function('glUnlockArraysEXT', None, [], 'EXT_compiled_vertex_array')

PFNGLLOCKARRAYSEXTPROC = CFUNCTYPE(None, GLint, GLsizei) 	# GL/glext.h:4754
PFNGLUNLOCKARRAYSEXTPROC = CFUNCTYPE(None) 	# GL/glext.h:4755
# EXT_cull_vertex (GL/glext.h:4758)
GL_EXT_cull_vertex = 1 	# GL/glext.h:4759
# GL/glext.h:4761
glCullParameterdvEXT = _link_function('glCullParameterdvEXT', None, [GLenum, POINTER(GLdouble)], 'EXT_cull_vertex')

# GL/glext.h:4762
glCullParameterfvEXT = _link_function('glCullParameterfvEXT', None, [GLenum, POINTER(GLfloat)], 'EXT_cull_vertex')

PFNGLCULLPARAMETERDVEXTPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:4764
PFNGLCULLPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4765
# SGIX_ycrcb (GL/glext.h:4768)
GL_SGIX_ycrcb = 1 	# GL/glext.h:4769
# SGIX_fragment_lighting (GL/glext.h:4772)
GL_SGIX_fragment_lighting = 1 	# GL/glext.h:4773
# GL/glext.h:4775
glFragmentColorMaterialSGIX = _link_function('glFragmentColorMaterialSGIX', None, [GLenum, GLenum], 'SGIX_fragment_lighting')

# GL/glext.h:4776
glFragmentLightfSGIX = _link_function('glFragmentLightfSGIX', None, [GLenum, GLenum, GLfloat], 'SGIX_fragment_lighting')

# GL/glext.h:4777
glFragmentLightfvSGIX = _link_function('glFragmentLightfvSGIX', None, [GLenum, GLenum, POINTER(GLfloat)], 'SGIX_fragment_lighting')

# GL/glext.h:4778
glFragmentLightiSGIX = _link_function('glFragmentLightiSGIX', None, [GLenum, GLenum, GLint], 'SGIX_fragment_lighting')

# GL/glext.h:4779
glFragmentLightivSGIX = _link_function('glFragmentLightivSGIX', None, [GLenum, GLenum, POINTER(GLint)], 'SGIX_fragment_lighting')

# GL/glext.h:4780
glFragmentLightModelfSGIX = _link_function('glFragmentLightModelfSGIX', None, [GLenum, GLfloat], 'SGIX_fragment_lighting')

# GL/glext.h:4781
glFragmentLightModelfvSGIX = _link_function('glFragmentLightModelfvSGIX', None, [GLenum, POINTER(GLfloat)], 'SGIX_fragment_lighting')

# GL/glext.h:4782
glFragmentLightModeliSGIX = _link_function('glFragmentLightModeliSGIX', None, [GLenum, GLint], 'SGIX_fragment_lighting')

# GL/glext.h:4783
glFragmentLightModelivSGIX = _link_function('glFragmentLightModelivSGIX', None, [GLenum, POINTER(GLint)], 'SGIX_fragment_lighting')

# GL/glext.h:4784
glFragmentMaterialfSGIX = _link_function('glFragmentMaterialfSGIX', None, [GLenum, GLenum, GLfloat], 'SGIX_fragment_lighting')

# GL/glext.h:4785
glFragmentMaterialfvSGIX = _link_function('glFragmentMaterialfvSGIX', None, [GLenum, GLenum, POINTER(GLfloat)], 'SGIX_fragment_lighting')

# GL/glext.h:4786
glFragmentMaterialiSGIX = _link_function('glFragmentMaterialiSGIX', None, [GLenum, GLenum, GLint], 'SGIX_fragment_lighting')

# GL/glext.h:4787
glFragmentMaterialivSGIX = _link_function('glFragmentMaterialivSGIX', None, [GLenum, GLenum, POINTER(GLint)], 'SGIX_fragment_lighting')

# GL/glext.h:4788
glGetFragmentLightfvSGIX = _link_function('glGetFragmentLightfvSGIX', None, [GLenum, GLenum, POINTER(GLfloat)], 'SGIX_fragment_lighting')

# GL/glext.h:4789
glGetFragmentLightivSGIX = _link_function('glGetFragmentLightivSGIX', None, [GLenum, GLenum, POINTER(GLint)], 'SGIX_fragment_lighting')

# GL/glext.h:4790
glGetFragmentMaterialfvSGIX = _link_function('glGetFragmentMaterialfvSGIX', None, [GLenum, GLenum, POINTER(GLfloat)], 'SGIX_fragment_lighting')

# GL/glext.h:4791
glGetFragmentMaterialivSGIX = _link_function('glGetFragmentMaterialivSGIX', None, [GLenum, GLenum, POINTER(GLint)], 'SGIX_fragment_lighting')

# GL/glext.h:4792
glLightEnviSGIX = _link_function('glLightEnviSGIX', None, [GLenum, GLint], 'SGIX_fragment_lighting')

PFNGLFRAGMENTCOLORMATERIALSGIXPROC = CFUNCTYPE(None, GLenum, GLenum) 	# GL/glext.h:4794
PFNGLFRAGMENTLIGHTFSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, GLfloat) 	# GL/glext.h:4795
PFNGLFRAGMENTLIGHTFVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4796
PFNGLFRAGMENTLIGHTISGIXPROC = CFUNCTYPE(None, GLenum, GLenum, GLint) 	# GL/glext.h:4797
PFNGLFRAGMENTLIGHTIVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4798
PFNGLFRAGMENTLIGHTMODELFSGIXPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:4799
PFNGLFRAGMENTLIGHTMODELFVSGIXPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4800
PFNGLFRAGMENTLIGHTMODELISGIXPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:4801
PFNGLFRAGMENTLIGHTMODELIVSGIXPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:4802
PFNGLFRAGMENTMATERIALFSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, GLfloat) 	# GL/glext.h:4803
PFNGLFRAGMENTMATERIALFVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4804
PFNGLFRAGMENTMATERIALISGIXPROC = CFUNCTYPE(None, GLenum, GLenum, GLint) 	# GL/glext.h:4805
PFNGLFRAGMENTMATERIALIVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4806
PFNGLGETFRAGMENTLIGHTFVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4807
PFNGLGETFRAGMENTLIGHTIVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4808
PFNGLGETFRAGMENTMATERIALFVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4809
PFNGLGETFRAGMENTMATERIALIVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4810
PFNGLLIGHTENVISGIXPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:4811
# IBM_rasterpos_clip (GL/glext.h:4814)
GL_IBM_rasterpos_clip = 1 	# GL/glext.h:4815
# HP_texture_lighting (GL/glext.h:4818)
GL_HP_texture_lighting = 1 	# GL/glext.h:4819
# EXT_draw_range_elements (GL/glext.h:4822)
GL_EXT_draw_range_elements = 1 	# GL/glext.h:4823
# GL/glext.h:4825
glDrawRangeElementsEXT = _link_function('glDrawRangeElementsEXT', None, [GLenum, GLuint, GLuint, GLsizei, GLenum, POINTER(GLvoid)], 'EXT_draw_range_elements')

PFNGLDRAWRANGEELEMENTSEXTPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLsizei, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4827
# WIN_phong_shading (GL/glext.h:4830)
GL_WIN_phong_shading = 1 	# GL/glext.h:4831
# WIN_specular_fog (GL/glext.h:4834)
GL_WIN_specular_fog = 1 	# GL/glext.h:4835
# EXT_light_texture (GL/glext.h:4838)
GL_EXT_light_texture = 1 	# GL/glext.h:4839
# GL/glext.h:4841
glApplyTextureEXT = _link_function('glApplyTextureEXT', None, [GLenum], 'EXT_light_texture')

# GL/glext.h:4842
glTextureLightEXT = _link_function('glTextureLightEXT', None, [GLenum], 'EXT_light_texture')

# GL/glext.h:4843
glTextureMaterialEXT = _link_function('glTextureMaterialEXT', None, [GLenum, GLenum], 'EXT_light_texture')

PFNGLAPPLYTEXTUREEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:4845
PFNGLTEXTURELIGHTEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:4846
PFNGLTEXTUREMATERIALEXTPROC = CFUNCTYPE(None, GLenum, GLenum) 	# GL/glext.h:4847
# SGIX_blend_alpha_minmax (GL/glext.h:4850)
GL_SGIX_blend_alpha_minmax = 1 	# GL/glext.h:4851
# EXT_bgra (GL/glext.h:4854)
GL_EXT_bgra = 1 	# GL/glext.h:4855
# SGIX_async (GL/glext.h:4858)
GL_SGIX_async = 1 	# GL/glext.h:4859
# GL/glext.h:4861
glAsyncMarkerSGIX = _link_function('glAsyncMarkerSGIX', None, [GLuint], 'SGIX_async')

# GL/glext.h:4862
glFinishAsyncSGIX = _link_function('glFinishAsyncSGIX', GLint, [POINTER(GLuint)], 'SGIX_async')

# GL/glext.h:4863
glPollAsyncSGIX = _link_function('glPollAsyncSGIX', GLint, [POINTER(GLuint)], 'SGIX_async')

# GL/glext.h:4864
glGenAsyncMarkersSGIX = _link_function('glGenAsyncMarkersSGIX', GLuint, [GLsizei], 'SGIX_async')

# GL/glext.h:4865
glDeleteAsyncMarkersSGIX = _link_function('glDeleteAsyncMarkersSGIX', None, [GLuint, GLsizei], 'SGIX_async')

# GL/glext.h:4866
glIsAsyncMarkerSGIX = _link_function('glIsAsyncMarkerSGIX', GLboolean, [GLuint], 'SGIX_async')

PFNGLASYNCMARKERSGIXPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:4868
PFNGLFINISHASYNCSGIXPROC = CFUNCTYPE(GLint, POINTER(GLuint)) 	# GL/glext.h:4869
PFNGLPOLLASYNCSGIXPROC = CFUNCTYPE(GLint, POINTER(GLuint)) 	# GL/glext.h:4870
PFNGLGENASYNCMARKERSSGIXPROC = CFUNCTYPE(GLuint, GLsizei) 	# GL/glext.h:4871
PFNGLDELETEASYNCMARKERSSGIXPROC = CFUNCTYPE(None, GLuint, GLsizei) 	# GL/glext.h:4872
PFNGLISASYNCMARKERSGIXPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:4873
# SGIX_async_pixel (GL/glext.h:4876)
GL_SGIX_async_pixel = 1 	# GL/glext.h:4877
# SGIX_async_histogram (GL/glext.h:4880)
GL_SGIX_async_histogram = 1 	# GL/glext.h:4881
# INTEL_parallel_arrays (GL/glext.h:4884)
GL_INTEL_parallel_arrays = 1 	# GL/glext.h:4885
# GL/glext.h:4887
glVertexPointervINTEL = _link_function('glVertexPointervINTEL', None, [GLint, GLenum, POINTER(POINTER(GLvoid))], 'INTEL_parallel_arrays')

# GL/glext.h:4888
glNormalPointervINTEL = _link_function('glNormalPointervINTEL', None, [GLenum, POINTER(POINTER(GLvoid))], 'INTEL_parallel_arrays')

# GL/glext.h:4889
glColorPointervINTEL = _link_function('glColorPointervINTEL', None, [GLint, GLenum, POINTER(POINTER(GLvoid))], 'INTEL_parallel_arrays')

# GL/glext.h:4890
glTexCoordPointervINTEL = _link_function('glTexCoordPointervINTEL', None, [GLint, GLenum, POINTER(POINTER(GLvoid))], 'INTEL_parallel_arrays')

PFNGLVERTEXPOINTERVINTELPROC = CFUNCTYPE(None, GLint, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:4892
PFNGLNORMALPOINTERVINTELPROC = CFUNCTYPE(None, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:4893
PFNGLCOLORPOINTERVINTELPROC = CFUNCTYPE(None, GLint, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:4894
PFNGLTEXCOORDPOINTERVINTELPROC = CFUNCTYPE(None, GLint, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:4895
# HP_occlusion_test (GL/glext.h:4898)
GL_HP_occlusion_test = 1 	# GL/glext.h:4899
# EXT_pixel_transform (GL/glext.h:4902)
GL_EXT_pixel_transform = 1 	# GL/glext.h:4903
# GL/glext.h:4905
glPixelTransformParameteriEXT = _link_function('glPixelTransformParameteriEXT', None, [GLenum, GLenum, GLint], 'EXT_pixel_transform')

# GL/glext.h:4906
glPixelTransformParameterfEXT = _link_function('glPixelTransformParameterfEXT', None, [GLenum, GLenum, GLfloat], 'EXT_pixel_transform')

# GL/glext.h:4907
glPixelTransformParameterivEXT = _link_function('glPixelTransformParameterivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_pixel_transform')

# GL/glext.h:4908
glPixelTransformParameterfvEXT = _link_function('glPixelTransformParameterfvEXT', None, [GLenum, GLenum, POINTER(GLfloat)], 'EXT_pixel_transform')

PFNGLPIXELTRANSFORMPARAMETERIEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLint) 	# GL/glext.h:4910
PFNGLPIXELTRANSFORMPARAMETERFEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLfloat) 	# GL/glext.h:4911
PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4912
PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4913
# EXT_pixel_transform_color_table (GL/glext.h:4916)
GL_EXT_pixel_transform_color_table = 1 	# GL/glext.h:4917
# EXT_shared_texture_palette (GL/glext.h:4920)
GL_EXT_shared_texture_palette = 1 	# GL/glext.h:4921
# EXT_separate_specular_color (GL/glext.h:4924)
GL_EXT_separate_specular_color = 1 	# GL/glext.h:4925
# EXT_secondary_color (GL/glext.h:4928)
GL_EXT_secondary_color = 1 	# GL/glext.h:4929
# GL/glext.h:4931
glSecondaryColor3bEXT = _link_function('glSecondaryColor3bEXT', None, [GLbyte, GLbyte, GLbyte], 'EXT_secondary_color')

# GL/glext.h:4932
glSecondaryColor3bvEXT = _link_function('glSecondaryColor3bvEXT', None, [POINTER(GLbyte)], 'EXT_secondary_color')

# GL/glext.h:4933
glSecondaryColor3dEXT = _link_function('glSecondaryColor3dEXT', None, [GLdouble, GLdouble, GLdouble], 'EXT_secondary_color')

# GL/glext.h:4934
glSecondaryColor3dvEXT = _link_function('glSecondaryColor3dvEXT', None, [POINTER(GLdouble)], 'EXT_secondary_color')

# GL/glext.h:4935
glSecondaryColor3fEXT = _link_function('glSecondaryColor3fEXT', None, [GLfloat, GLfloat, GLfloat], 'EXT_secondary_color')

# GL/glext.h:4936
glSecondaryColor3fvEXT = _link_function('glSecondaryColor3fvEXT', None, [POINTER(GLfloat)], 'EXT_secondary_color')

# GL/glext.h:4937
glSecondaryColor3iEXT = _link_function('glSecondaryColor3iEXT', None, [GLint, GLint, GLint], 'EXT_secondary_color')

# GL/glext.h:4938
glSecondaryColor3ivEXT = _link_function('glSecondaryColor3ivEXT', None, [POINTER(GLint)], 'EXT_secondary_color')

# GL/glext.h:4939
glSecondaryColor3sEXT = _link_function('glSecondaryColor3sEXT', None, [GLshort, GLshort, GLshort], 'EXT_secondary_color')

# GL/glext.h:4940
glSecondaryColor3svEXT = _link_function('glSecondaryColor3svEXT', None, [POINTER(GLshort)], 'EXT_secondary_color')

# GL/glext.h:4941
glSecondaryColor3ubEXT = _link_function('glSecondaryColor3ubEXT', None, [GLubyte, GLubyte, GLubyte], 'EXT_secondary_color')

# GL/glext.h:4942
glSecondaryColor3ubvEXT = _link_function('glSecondaryColor3ubvEXT', None, [POINTER(GLubyte)], 'EXT_secondary_color')

# GL/glext.h:4943
glSecondaryColor3uiEXT = _link_function('glSecondaryColor3uiEXT', None, [GLuint, GLuint, GLuint], 'EXT_secondary_color')

# GL/glext.h:4944
glSecondaryColor3uivEXT = _link_function('glSecondaryColor3uivEXT', None, [POINTER(GLuint)], 'EXT_secondary_color')

# GL/glext.h:4945
glSecondaryColor3usEXT = _link_function('glSecondaryColor3usEXT', None, [GLushort, GLushort, GLushort], 'EXT_secondary_color')

# GL/glext.h:4946
glSecondaryColor3usvEXT = _link_function('glSecondaryColor3usvEXT', None, [POINTER(GLushort)], 'EXT_secondary_color')

# GL/glext.h:4947
glSecondaryColorPointerEXT = _link_function('glSecondaryColorPointerEXT', None, [GLint, GLenum, GLsizei, POINTER(GLvoid)], 'EXT_secondary_color')

PFNGLSECONDARYCOLOR3BEXTPROC = CFUNCTYPE(None, GLbyte, GLbyte, GLbyte) 	# GL/glext.h:4949
PFNGLSECONDARYCOLOR3BVEXTPROC = CFUNCTYPE(None, POINTER(GLbyte)) 	# GL/glext.h:4950
PFNGLSECONDARYCOLOR3DEXTPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:4951
PFNGLSECONDARYCOLOR3DVEXTPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:4952
PFNGLSECONDARYCOLOR3FEXTPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:4953
PFNGLSECONDARYCOLOR3FVEXTPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:4954
PFNGLSECONDARYCOLOR3IEXTPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:4955
PFNGLSECONDARYCOLOR3IVEXTPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:4956
PFNGLSECONDARYCOLOR3SEXTPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort) 	# GL/glext.h:4957
PFNGLSECONDARYCOLOR3SVEXTPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:4958
PFNGLSECONDARYCOLOR3UBEXTPROC = CFUNCTYPE(None, GLubyte, GLubyte, GLubyte) 	# GL/glext.h:4959
PFNGLSECONDARYCOLOR3UBVEXTPROC = CFUNCTYPE(None, POINTER(GLubyte)) 	# GL/glext.h:4960
PFNGLSECONDARYCOLOR3UIEXTPROC = CFUNCTYPE(None, GLuint, GLuint, GLuint) 	# GL/glext.h:4961
PFNGLSECONDARYCOLOR3UIVEXTPROC = CFUNCTYPE(None, POINTER(GLuint)) 	# GL/glext.h:4962
PFNGLSECONDARYCOLOR3USEXTPROC = CFUNCTYPE(None, GLushort, GLushort, GLushort) 	# GL/glext.h:4963
PFNGLSECONDARYCOLOR3USVEXTPROC = CFUNCTYPE(None, POINTER(GLushort)) 	# GL/glext.h:4964
PFNGLSECONDARYCOLORPOINTEREXTPROC = CFUNCTYPE(None, GLint, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4965
# EXT_texture_perturb_normal (GL/glext.h:4968)
GL_EXT_texture_perturb_normal = 1 	# GL/glext.h:4969
# GL/glext.h:4971
glTextureNormalEXT = _link_function('glTextureNormalEXT', None, [GLenum], 'EXT_texture_perturb_normal')

PFNGLTEXTURENORMALEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:4973
# EXT_multi_draw_arrays (GL/glext.h:4976)
GL_EXT_multi_draw_arrays = 1 	# GL/glext.h:4977
# GL/glext.h:4979
glMultiDrawArraysEXT = _link_function('glMultiDrawArraysEXT', None, [GLenum, POINTER(GLint), POINTER(GLsizei), GLsizei], 'EXT_multi_draw_arrays')

# GL/glext.h:4980
glMultiDrawElementsEXT = _link_function('glMultiDrawElementsEXT', None, [GLenum, POINTER(GLsizei), GLenum, POINTER(POINTER(GLvoid)), GLsizei], 'EXT_multi_draw_arrays')

PFNGLMULTIDRAWARRAYSEXTPROC = CFUNCTYPE(None, GLenum, POINTER(GLint), POINTER(GLsizei), GLsizei) 	# GL/glext.h:4982
PFNGLMULTIDRAWELEMENTSEXTPROC = CFUNCTYPE(None, GLenum, POINTER(GLsizei), GLenum, POINTER(POINTER(GLvoid)), GLsizei) 	# GL/glext.h:4983
# EXT_fog_coord (GL/glext.h:4986)
GL_EXT_fog_coord = 1 	# GL/glext.h:4987
# GL/glext.h:4989
glFogCoordfEXT = _link_function('glFogCoordfEXT', None, [GLfloat], 'EXT_fog_coord')

# GL/glext.h:4990
glFogCoordfvEXT = _link_function('glFogCoordfvEXT', None, [POINTER(GLfloat)], 'EXT_fog_coord')

# GL/glext.h:4991
glFogCoorddEXT = _link_function('glFogCoorddEXT', None, [GLdouble], 'EXT_fog_coord')

# GL/glext.h:4992
glFogCoorddvEXT = _link_function('glFogCoorddvEXT', None, [POINTER(GLdouble)], 'EXT_fog_coord')

# GL/glext.h:4993
glFogCoordPointerEXT = _link_function('glFogCoordPointerEXT', None, [GLenum, GLsizei, POINTER(GLvoid)], 'EXT_fog_coord')

PFNGLFOGCOORDFEXTPROC = CFUNCTYPE(None, GLfloat) 	# GL/glext.h:4995
PFNGLFOGCOORDFVEXTPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:4996
PFNGLFOGCOORDDEXTPROC = CFUNCTYPE(None, GLdouble) 	# GL/glext.h:4997
PFNGLFOGCOORDDVEXTPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:4998
PFNGLFOGCOORDPOINTEREXTPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4999
# REND_screen_coordinates (GL/glext.h:5002)
GL_REND_screen_coordinates = 1 	# GL/glext.h:5003
# EXT_coordinate_frame (GL/glext.h:5006)
GL_EXT_coordinate_frame = 1 	# GL/glext.h:5007
# GL/glext.h:5009
glTangent3bEXT = _link_function('glTangent3bEXT', None, [GLbyte, GLbyte, GLbyte], 'EXT_coordinate_frame')

# GL/glext.h:5010
glTangent3bvEXT = _link_function('glTangent3bvEXT', None, [POINTER(GLbyte)], 'EXT_coordinate_frame')

# GL/glext.h:5011
glTangent3dEXT = _link_function('glTangent3dEXT', None, [GLdouble, GLdouble, GLdouble], 'EXT_coordinate_frame')

# GL/glext.h:5012
glTangent3dvEXT = _link_function('glTangent3dvEXT', None, [POINTER(GLdouble)], 'EXT_coordinate_frame')

# GL/glext.h:5013
glTangent3fEXT = _link_function('glTangent3fEXT', None, [GLfloat, GLfloat, GLfloat], 'EXT_coordinate_frame')

# GL/glext.h:5014
glTangent3fvEXT = _link_function('glTangent3fvEXT', None, [POINTER(GLfloat)], 'EXT_coordinate_frame')

# GL/glext.h:5015
glTangent3iEXT = _link_function('glTangent3iEXT', None, [GLint, GLint, GLint], 'EXT_coordinate_frame')

# GL/glext.h:5016
glTangent3ivEXT = _link_function('glTangent3ivEXT', None, [POINTER(GLint)], 'EXT_coordinate_frame')

# GL/glext.h:5017
glTangent3sEXT = _link_function('glTangent3sEXT', None, [GLshort, GLshort, GLshort], 'EXT_coordinate_frame')

# GL/glext.h:5018
glTangent3svEXT = _link_function('glTangent3svEXT', None, [POINTER(GLshort)], 'EXT_coordinate_frame')

# GL/glext.h:5019
glBinormal3bEXT = _link_function('glBinormal3bEXT', None, [GLbyte, GLbyte, GLbyte], 'EXT_coordinate_frame')

# GL/glext.h:5020
glBinormal3bvEXT = _link_function('glBinormal3bvEXT', None, [POINTER(GLbyte)], 'EXT_coordinate_frame')

# GL/glext.h:5021
glBinormal3dEXT = _link_function('glBinormal3dEXT', None, [GLdouble, GLdouble, GLdouble], 'EXT_coordinate_frame')

# GL/glext.h:5022
glBinormal3dvEXT = _link_function('glBinormal3dvEXT', None, [POINTER(GLdouble)], 'EXT_coordinate_frame')

# GL/glext.h:5023
glBinormal3fEXT = _link_function('glBinormal3fEXT', None, [GLfloat, GLfloat, GLfloat], 'EXT_coordinate_frame')

# GL/glext.h:5024
glBinormal3fvEXT = _link_function('glBinormal3fvEXT', None, [POINTER(GLfloat)], 'EXT_coordinate_frame')

# GL/glext.h:5025
glBinormal3iEXT = _link_function('glBinormal3iEXT', None, [GLint, GLint, GLint], 'EXT_coordinate_frame')

# GL/glext.h:5026
glBinormal3ivEXT = _link_function('glBinormal3ivEXT', None, [POINTER(GLint)], 'EXT_coordinate_frame')

# GL/glext.h:5027
glBinormal3sEXT = _link_function('glBinormal3sEXT', None, [GLshort, GLshort, GLshort], 'EXT_coordinate_frame')

# GL/glext.h:5028
glBinormal3svEXT = _link_function('glBinormal3svEXT', None, [POINTER(GLshort)], 'EXT_coordinate_frame')

# GL/glext.h:5029
glTangentPointerEXT = _link_function('glTangentPointerEXT', None, [GLenum, GLsizei, POINTER(GLvoid)], 'EXT_coordinate_frame')

# GL/glext.h:5030
glBinormalPointerEXT = _link_function('glBinormalPointerEXT', None, [GLenum, GLsizei, POINTER(GLvoid)], 'EXT_coordinate_frame')

PFNGLTANGENT3BEXTPROC = CFUNCTYPE(None, GLbyte, GLbyte, GLbyte) 	# GL/glext.h:5032
PFNGLTANGENT3BVEXTPROC = CFUNCTYPE(None, POINTER(GLbyte)) 	# GL/glext.h:5033
PFNGLTANGENT3DEXTPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:5034
PFNGLTANGENT3DVEXTPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:5035
PFNGLTANGENT3FEXTPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5036
PFNGLTANGENT3FVEXTPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:5037
PFNGLTANGENT3IEXTPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:5038
PFNGLTANGENT3IVEXTPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:5039
PFNGLTANGENT3SEXTPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort) 	# GL/glext.h:5040
PFNGLTANGENT3SVEXTPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:5041
PFNGLBINORMAL3BEXTPROC = CFUNCTYPE(None, GLbyte, GLbyte, GLbyte) 	# GL/glext.h:5042
PFNGLBINORMAL3BVEXTPROC = CFUNCTYPE(None, POINTER(GLbyte)) 	# GL/glext.h:5043
PFNGLBINORMAL3DEXTPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:5044
PFNGLBINORMAL3DVEXTPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:5045
PFNGLBINORMAL3FEXTPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5046
PFNGLBINORMAL3FVEXTPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:5047
PFNGLBINORMAL3IEXTPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:5048
PFNGLBINORMAL3IVEXTPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:5049
PFNGLBINORMAL3SEXTPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort) 	# GL/glext.h:5050
PFNGLBINORMAL3SVEXTPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:5051
PFNGLTANGENTPOINTEREXTPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:5052
PFNGLBINORMALPOINTEREXTPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:5053
# EXT_texture_env_combine (GL/glext.h:5056)
GL_EXT_texture_env_combine = 1 	# GL/glext.h:5057
# APPLE_specular_vector (GL/glext.h:5060)
GL_APPLE_specular_vector = 1 	# GL/glext.h:5061
# APPLE_transform_hint (GL/glext.h:5064)
GL_APPLE_transform_hint = 1 	# GL/glext.h:5065
# SGIX_fog_scale (GL/glext.h:5068)
GL_SGIX_fog_scale = 1 	# GL/glext.h:5069
# SUNX_constant_data (GL/glext.h:5072)
GL_SUNX_constant_data = 1 	# GL/glext.h:5073
# GL/glext.h:5075
glFinishTextureSUNX = _link_function('glFinishTextureSUNX', None, [], 'SUNX_constant_data')

PFNGLFINISHTEXTURESUNXPROC = CFUNCTYPE(None) 	# GL/glext.h:5077
# SUN_global_alpha (GL/glext.h:5080)
GL_SUN_global_alpha = 1 	# GL/glext.h:5081
# GL/glext.h:5083
glGlobalAlphaFactorbSUN = _link_function('glGlobalAlphaFactorbSUN', None, [GLbyte], 'SUN_global_alpha')

# GL/glext.h:5084
glGlobalAlphaFactorsSUN = _link_function('glGlobalAlphaFactorsSUN', None, [GLshort], 'SUN_global_alpha')

# GL/glext.h:5085
glGlobalAlphaFactoriSUN = _link_function('glGlobalAlphaFactoriSUN', None, [GLint], 'SUN_global_alpha')

# GL/glext.h:5086
glGlobalAlphaFactorfSUN = _link_function('glGlobalAlphaFactorfSUN', None, [GLfloat], 'SUN_global_alpha')

# GL/glext.h:5087
glGlobalAlphaFactordSUN = _link_function('glGlobalAlphaFactordSUN', None, [GLdouble], 'SUN_global_alpha')

# GL/glext.h:5088
glGlobalAlphaFactorubSUN = _link_function('glGlobalAlphaFactorubSUN', None, [GLubyte], 'SUN_global_alpha')

# GL/glext.h:5089
glGlobalAlphaFactorusSUN = _link_function('glGlobalAlphaFactorusSUN', None, [GLushort], 'SUN_global_alpha')

# GL/glext.h:5090
glGlobalAlphaFactoruiSUN = _link_function('glGlobalAlphaFactoruiSUN', None, [GLuint], 'SUN_global_alpha')

PFNGLGLOBALALPHAFACTORBSUNPROC = CFUNCTYPE(None, GLbyte) 	# GL/glext.h:5092
PFNGLGLOBALALPHAFACTORSSUNPROC = CFUNCTYPE(None, GLshort) 	# GL/glext.h:5093
PFNGLGLOBALALPHAFACTORISUNPROC = CFUNCTYPE(None, GLint) 	# GL/glext.h:5094
PFNGLGLOBALALPHAFACTORFSUNPROC = CFUNCTYPE(None, GLfloat) 	# GL/glext.h:5095
PFNGLGLOBALALPHAFACTORDSUNPROC = CFUNCTYPE(None, GLdouble) 	# GL/glext.h:5096
PFNGLGLOBALALPHAFACTORUBSUNPROC = CFUNCTYPE(None, GLubyte) 	# GL/glext.h:5097
PFNGLGLOBALALPHAFACTORUSSUNPROC = CFUNCTYPE(None, GLushort) 	# GL/glext.h:5098
PFNGLGLOBALALPHAFACTORUISUNPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5099
# SUN_triangle_list (GL/glext.h:5102)
GL_SUN_triangle_list = 1 	# GL/glext.h:5103
# GL/glext.h:5105
glReplacementCodeuiSUN = _link_function('glReplacementCodeuiSUN', None, [GLuint], 'SUN_triangle_list')

# GL/glext.h:5106
glReplacementCodeusSUN = _link_function('glReplacementCodeusSUN', None, [GLushort], 'SUN_triangle_list')

# GL/glext.h:5107
glReplacementCodeubSUN = _link_function('glReplacementCodeubSUN', None, [GLubyte], 'SUN_triangle_list')

# GL/glext.h:5108
glReplacementCodeuivSUN = _link_function('glReplacementCodeuivSUN', None, [POINTER(GLuint)], 'SUN_triangle_list')

# GL/glext.h:5109
glReplacementCodeusvSUN = _link_function('glReplacementCodeusvSUN', None, [POINTER(GLushort)], 'SUN_triangle_list')

# GL/glext.h:5110
glReplacementCodeubvSUN = _link_function('glReplacementCodeubvSUN', None, [POINTER(GLubyte)], 'SUN_triangle_list')

# GL/glext.h:5111
glReplacementCodePointerSUN = _link_function('glReplacementCodePointerSUN', None, [GLenum, GLsizei, POINTER(POINTER(GLvoid))], 'SUN_triangle_list')

PFNGLREPLACEMENTCODEUISUNPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5113
PFNGLREPLACEMENTCODEUSSUNPROC = CFUNCTYPE(None, GLushort) 	# GL/glext.h:5114
PFNGLREPLACEMENTCODEUBSUNPROC = CFUNCTYPE(None, GLubyte) 	# GL/glext.h:5115
PFNGLREPLACEMENTCODEUIVSUNPROC = CFUNCTYPE(None, POINTER(GLuint)) 	# GL/glext.h:5116
PFNGLREPLACEMENTCODEUSVSUNPROC = CFUNCTYPE(None, POINTER(GLushort)) 	# GL/glext.h:5117
PFNGLREPLACEMENTCODEUBVSUNPROC = CFUNCTYPE(None, POINTER(GLubyte)) 	# GL/glext.h:5118
PFNGLREPLACEMENTCODEPOINTERSUNPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(POINTER(GLvoid))) 	# GL/glext.h:5119
# SUN_vertex (GL/glext.h:5122)
GL_SUN_vertex = 1 	# GL/glext.h:5123
# GL/glext.h:5125
glColor4ubVertex2fSUN = _link_function('glColor4ubVertex2fSUN', None, [GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5126
glColor4ubVertex2fvSUN = _link_function('glColor4ubVertex2fvSUN', None, [POINTER(GLubyte), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5127
glColor4ubVertex3fSUN = _link_function('glColor4ubVertex3fSUN', None, [GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5128
glColor4ubVertex3fvSUN = _link_function('glColor4ubVertex3fvSUN', None, [POINTER(GLubyte), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5129
glColor3fVertex3fSUN = _link_function('glColor3fVertex3fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5130
glColor3fVertex3fvSUN = _link_function('glColor3fVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5131
glNormal3fVertex3fSUN = _link_function('glNormal3fVertex3fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5132
glNormal3fVertex3fvSUN = _link_function('glNormal3fVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5133
glColor4fNormal3fVertex3fSUN = _link_function('glColor4fNormal3fVertex3fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5134
glColor4fNormal3fVertex3fvSUN = _link_function('glColor4fNormal3fVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5135
glTexCoord2fVertex3fSUN = _link_function('glTexCoord2fVertex3fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5136
glTexCoord2fVertex3fvSUN = _link_function('glTexCoord2fVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5137
glTexCoord4fVertex4fSUN = _link_function('glTexCoord4fVertex4fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5138
glTexCoord4fVertex4fvSUN = _link_function('glTexCoord4fVertex4fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5139
glTexCoord2fColor4ubVertex3fSUN = _link_function('glTexCoord2fColor4ubVertex3fSUN', None, [GLfloat, GLfloat, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5140
glTexCoord2fColor4ubVertex3fvSUN = _link_function('glTexCoord2fColor4ubVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLubyte), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5141
glTexCoord2fColor3fVertex3fSUN = _link_function('glTexCoord2fColor3fVertex3fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5142
glTexCoord2fColor3fVertex3fvSUN = _link_function('glTexCoord2fColor3fVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5143
glTexCoord2fNormal3fVertex3fSUN = _link_function('glTexCoord2fNormal3fVertex3fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5144
glTexCoord2fNormal3fVertex3fvSUN = _link_function('glTexCoord2fNormal3fVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5145
glTexCoord2fColor4fNormal3fVertex3fSUN = _link_function('glTexCoord2fColor4fNormal3fVertex3fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5146
glTexCoord2fColor4fNormal3fVertex3fvSUN = _link_function('glTexCoord2fColor4fNormal3fVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5147
glTexCoord4fColor4fNormal3fVertex4fSUN = _link_function('glTexCoord4fColor4fNormal3fVertex4fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5148
glTexCoord4fColor4fNormal3fVertex4fvSUN = _link_function('glTexCoord4fColor4fNormal3fVertex4fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5149
glReplacementCodeuiVertex3fSUN = _link_function('glReplacementCodeuiVertex3fSUN', None, [GLuint, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5150
glReplacementCodeuiVertex3fvSUN = _link_function('glReplacementCodeuiVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5151
glReplacementCodeuiColor4ubVertex3fSUN = _link_function('glReplacementCodeuiColor4ubVertex3fSUN', None, [GLuint, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5152
glReplacementCodeuiColor4ubVertex3fvSUN = _link_function('glReplacementCodeuiColor4ubVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLubyte), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5153
glReplacementCodeuiColor3fVertex3fSUN = _link_function('glReplacementCodeuiColor3fVertex3fSUN', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5154
glReplacementCodeuiColor3fVertex3fvSUN = _link_function('glReplacementCodeuiColor3fVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5155
glReplacementCodeuiNormal3fVertex3fSUN = _link_function('glReplacementCodeuiNormal3fVertex3fSUN', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5156
glReplacementCodeuiNormal3fVertex3fvSUN = _link_function('glReplacementCodeuiNormal3fVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5157
glReplacementCodeuiColor4fNormal3fVertex3fSUN = _link_function('glReplacementCodeuiColor4fNormal3fVertex3fSUN', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5158
glReplacementCodeuiColor4fNormal3fVertex3fvSUN = _link_function('glReplacementCodeuiColor4fNormal3fVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5159
glReplacementCodeuiTexCoord2fVertex3fSUN = _link_function('glReplacementCodeuiTexCoord2fVertex3fSUN', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5160
glReplacementCodeuiTexCoord2fVertex3fvSUN = _link_function('glReplacementCodeuiTexCoord2fVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5161
glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = _link_function('glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5162
glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = _link_function('glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5163
glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = _link_function('glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5164
glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = _link_function('glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

PFNGLCOLOR4UBVERTEX2FSUNPROC = CFUNCTYPE(None, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat) 	# GL/glext.h:5166
PFNGLCOLOR4UBVERTEX2FVSUNPROC = CFUNCTYPE(None, POINTER(GLubyte), POINTER(GLfloat)) 	# GL/glext.h:5167
PFNGLCOLOR4UBVERTEX3FSUNPROC = CFUNCTYPE(None, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5168
PFNGLCOLOR4UBVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLubyte), POINTER(GLfloat)) 	# GL/glext.h:5169
PFNGLCOLOR3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5170
PFNGLCOLOR3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5171
PFNGLNORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5172
PFNGLNORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5173
PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5174
PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5175
PFNGLTEXCOORD2FVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5176
PFNGLTEXCOORD2FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5177
PFNGLTEXCOORD4FVERTEX4FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5178
PFNGLTEXCOORD4FVERTEX4FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5179
PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5180
PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLubyte), POINTER(GLfloat)) 	# GL/glext.h:5181
PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5182
PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5183
PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5184
PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5185
PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5186
PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5187
PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5188
PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5189
PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5190
PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLfloat)) 	# GL/glext.h:5191
PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5192
PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLubyte), POINTER(GLfloat)) 	# GL/glext.h:5193
PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5194
PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5195
PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5196
PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5197
PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5198
PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5199
PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5200
PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5201
PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5202
PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5203
PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5204
PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5205
# EXT_blend_func_separate (GL/glext.h:5208)
GL_EXT_blend_func_separate = 1 	# GL/glext.h:5209
# GL/glext.h:5211
glBlendFuncSeparateEXT = _link_function('glBlendFuncSeparateEXT', None, [GLenum, GLenum, GLenum, GLenum], 'EXT_blend_func_separate')

PFNGLBLENDFUNCSEPARATEEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:5213
# INGR_blend_func_separate (GL/glext.h:5216)
GL_INGR_blend_func_separate = 1 	# GL/glext.h:5217
# GL/glext.h:5219
glBlendFuncSeparateINGR = _link_function('glBlendFuncSeparateINGR', None, [GLenum, GLenum, GLenum, GLenum], 'INGR_blend_func_separate')

PFNGLBLENDFUNCSEPARATEINGRPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:5221
# INGR_color_clamp (GL/glext.h:5224)
GL_INGR_color_clamp = 1 	# GL/glext.h:5225
# INGR_interlace_read (GL/glext.h:5228)
GL_INGR_interlace_read = 1 	# GL/glext.h:5229
# EXT_stencil_wrap (GL/glext.h:5232)
GL_EXT_stencil_wrap = 1 	# GL/glext.h:5233
# EXT_422_pixels (GL/glext.h:5236)
GL_EXT_422_pixels = 1 	# GL/glext.h:5237
# NV_texgen_reflection (GL/glext.h:5240)
GL_NV_texgen_reflection = 1 	# GL/glext.h:5241
# SUN_convolution_border_modes (GL/glext.h:5244)
GL_SUN_convolution_border_modes = 1 	# GL/glext.h:5245
# EXT_texture_env_add (GL/glext.h:5248)
GL_EXT_texture_env_add = 1 	# GL/glext.h:5249
# EXT_texture_lod_bias (GL/glext.h:5252)
GL_EXT_texture_lod_bias = 1 	# GL/glext.h:5253
# EXT_texture_filter_anisotropic (GL/glext.h:5256)
GL_EXT_texture_filter_anisotropic = 1 	# GL/glext.h:5257
# EXT_vertex_weighting (GL/glext.h:5260)
GL_EXT_vertex_weighting = 1 	# GL/glext.h:5261
# GL/glext.h:5263
glVertexWeightfEXT = _link_function('glVertexWeightfEXT', None, [GLfloat], 'EXT_vertex_weighting')

# GL/glext.h:5264
glVertexWeightfvEXT = _link_function('glVertexWeightfvEXT', None, [POINTER(GLfloat)], 'EXT_vertex_weighting')

# GL/glext.h:5265
glVertexWeightPointerEXT = _link_function('glVertexWeightPointerEXT', None, [GLsizei, GLenum, GLsizei, POINTER(GLvoid)], 'EXT_vertex_weighting')

PFNGLVERTEXWEIGHTFEXTPROC = CFUNCTYPE(None, GLfloat) 	# GL/glext.h:5267
PFNGLVERTEXWEIGHTFVEXTPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:5268
PFNGLVERTEXWEIGHTPOINTEREXTPROC = CFUNCTYPE(None, GLsizei, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:5269
# NV_light_max_exponent (GL/glext.h:5272)
GL_NV_light_max_exponent = 1 	# GL/glext.h:5273
# NV_vertex_array_range (GL/glext.h:5276)
GL_NV_vertex_array_range = 1 	# GL/glext.h:5277
# GL/glext.h:5279
glFlushVertexArrayRangeNV = _link_function('glFlushVertexArrayRangeNV', None, [], 'NV_vertex_array_range')

# GL/glext.h:5280
glVertexArrayRangeNV = _link_function('glVertexArrayRangeNV', None, [GLsizei, POINTER(GLvoid)], 'NV_vertex_array_range')

PFNGLFLUSHVERTEXARRAYRANGENVPROC = CFUNCTYPE(None) 	# GL/glext.h:5282
PFNGLVERTEXARRAYRANGENVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:5283
# NV_register_combiners (GL/glext.h:5286)
GL_NV_register_combiners = 1 	# GL/glext.h:5287
# GL/glext.h:5289
glCombinerParameterfvNV = _link_function('glCombinerParameterfvNV', None, [GLenum, POINTER(GLfloat)], 'NV_register_combiners')

# GL/glext.h:5290
glCombinerParameterfNV = _link_function('glCombinerParameterfNV', None, [GLenum, GLfloat], 'NV_register_combiners')

# GL/glext.h:5291
glCombinerParameterivNV = _link_function('glCombinerParameterivNV', None, [GLenum, POINTER(GLint)], 'NV_register_combiners')

# GL/glext.h:5292
glCombinerParameteriNV = _link_function('glCombinerParameteriNV', None, [GLenum, GLint], 'NV_register_combiners')

# GL/glext.h:5293
glCombinerInputNV = _link_function('glCombinerInputNV', None, [GLenum, GLenum, GLenum, GLenum, GLenum, GLenum], 'NV_register_combiners')

# GL/glext.h:5294
glCombinerOutputNV = _link_function('glCombinerOutputNV', None, [GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLboolean, GLboolean, GLboolean], 'NV_register_combiners')

# GL/glext.h:5295
glFinalCombinerInputNV = _link_function('glFinalCombinerInputNV', None, [GLenum, GLenum, GLenum, GLenum], 'NV_register_combiners')

# GL/glext.h:5296
glGetCombinerInputParameterfvNV = _link_function('glGetCombinerInputParameterfvNV', None, [GLenum, GLenum, GLenum, GLenum, POINTER(GLfloat)], 'NV_register_combiners')

# GL/glext.h:5297
glGetCombinerInputParameterivNV = _link_function('glGetCombinerInputParameterivNV', None, [GLenum, GLenum, GLenum, GLenum, POINTER(GLint)], 'NV_register_combiners')

# GL/glext.h:5298
glGetCombinerOutputParameterfvNV = _link_function('glGetCombinerOutputParameterfvNV', None, [GLenum, GLenum, GLenum, POINTER(GLfloat)], 'NV_register_combiners')

# GL/glext.h:5299
glGetCombinerOutputParameterivNV = _link_function('glGetCombinerOutputParameterivNV', None, [GLenum, GLenum, GLenum, POINTER(GLint)], 'NV_register_combiners')

# GL/glext.h:5300
glGetFinalCombinerInputParameterfvNV = _link_function('glGetFinalCombinerInputParameterfvNV', None, [GLenum, GLenum, POINTER(GLfloat)], 'NV_register_combiners')

# GL/glext.h:5301
glGetFinalCombinerInputParameterivNV = _link_function('glGetFinalCombinerInputParameterivNV', None, [GLenum, GLenum, POINTER(GLint)], 'NV_register_combiners')

PFNGLCOMBINERPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5303
PFNGLCOMBINERPARAMETERFNVPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:5304
PFNGLCOMBINERPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:5305
PFNGLCOMBINERPARAMETERINVPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:5306
PFNGLCOMBINERINPUTNVPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:5307
PFNGLCOMBINEROUTPUTNVPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLboolean, GLboolean, GLboolean) 	# GL/glext.h:5308
PFNGLFINALCOMBINERINPUTNVPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:5309
PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5310
PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5311
PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5312
PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5313
PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5314
PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5315
# NV_fog_distance (GL/glext.h:5318)
GL_NV_fog_distance = 1 	# GL/glext.h:5319
# NV_texgen_emboss (GL/glext.h:5322)
GL_NV_texgen_emboss = 1 	# GL/glext.h:5323
# NV_blend_square (GL/glext.h:5326)
GL_NV_blend_square = 1 	# GL/glext.h:5327
# NV_texture_env_combine4 (GL/glext.h:5330)
GL_NV_texture_env_combine4 = 1 	# GL/glext.h:5331
# MESA_resize_buffers (GL/glext.h:5334)
GL_MESA_resize_buffers = 1 	# GL/glext.h:5335
# GL/glext.h:5337
glResizeBuffersMESA = _link_function('glResizeBuffersMESA', None, [], 'MESA_resize_buffers')

PFNGLRESIZEBUFFERSMESAPROC = CFUNCTYPE(None) 	# GL/glext.h:5339
# MESA_window_pos (GL/glext.h:5342)
GL_MESA_window_pos = 1 	# GL/glext.h:5343
# GL/glext.h:5345
glWindowPos2dMESA = _link_function('glWindowPos2dMESA', None, [GLdouble, GLdouble], 'MESA_window_pos')

# GL/glext.h:5346
glWindowPos2dvMESA = _link_function('glWindowPos2dvMESA', None, [POINTER(GLdouble)], 'MESA_window_pos')

# GL/glext.h:5347
glWindowPos2fMESA = _link_function('glWindowPos2fMESA', None, [GLfloat, GLfloat], 'MESA_window_pos')

# GL/glext.h:5348
glWindowPos2fvMESA = _link_function('glWindowPos2fvMESA', None, [POINTER(GLfloat)], 'MESA_window_pos')

# GL/glext.h:5349
glWindowPos2iMESA = _link_function('glWindowPos2iMESA', None, [GLint, GLint], 'MESA_window_pos')

# GL/glext.h:5350
glWindowPos2ivMESA = _link_function('glWindowPos2ivMESA', None, [POINTER(GLint)], 'MESA_window_pos')

# GL/glext.h:5351
glWindowPos2sMESA = _link_function('glWindowPos2sMESA', None, [GLshort, GLshort], 'MESA_window_pos')

# GL/glext.h:5352
glWindowPos2svMESA = _link_function('glWindowPos2svMESA', None, [POINTER(GLshort)], 'MESA_window_pos')

# GL/glext.h:5353
glWindowPos3dMESA = _link_function('glWindowPos3dMESA', None, [GLdouble, GLdouble, GLdouble], 'MESA_window_pos')

# GL/glext.h:5354
glWindowPos3dvMESA = _link_function('glWindowPos3dvMESA', None, [POINTER(GLdouble)], 'MESA_window_pos')

# GL/glext.h:5355
glWindowPos3fMESA = _link_function('glWindowPos3fMESA', None, [GLfloat, GLfloat, GLfloat], 'MESA_window_pos')

# GL/glext.h:5356
glWindowPos3fvMESA = _link_function('glWindowPos3fvMESA', None, [POINTER(GLfloat)], 'MESA_window_pos')

# GL/glext.h:5357
glWindowPos3iMESA = _link_function('glWindowPos3iMESA', None, [GLint, GLint, GLint], 'MESA_window_pos')

# GL/glext.h:5358
glWindowPos3ivMESA = _link_function('glWindowPos3ivMESA', None, [POINTER(GLint)], 'MESA_window_pos')

# GL/glext.h:5359
glWindowPos3sMESA = _link_function('glWindowPos3sMESA', None, [GLshort, GLshort, GLshort], 'MESA_window_pos')

# GL/glext.h:5360
glWindowPos3svMESA = _link_function('glWindowPos3svMESA', None, [POINTER(GLshort)], 'MESA_window_pos')

# GL/glext.h:5361
glWindowPos4dMESA = _link_function('glWindowPos4dMESA', None, [GLdouble, GLdouble, GLdouble, GLdouble], 'MESA_window_pos')

# GL/glext.h:5362
glWindowPos4dvMESA = _link_function('glWindowPos4dvMESA', None, [POINTER(GLdouble)], 'MESA_window_pos')

# GL/glext.h:5363
glWindowPos4fMESA = _link_function('glWindowPos4fMESA', None, [GLfloat, GLfloat, GLfloat, GLfloat], 'MESA_window_pos')

# GL/glext.h:5364
glWindowPos4fvMESA = _link_function('glWindowPos4fvMESA', None, [POINTER(GLfloat)], 'MESA_window_pos')

# GL/glext.h:5365
glWindowPos4iMESA = _link_function('glWindowPos4iMESA', None, [GLint, GLint, GLint, GLint], 'MESA_window_pos')

# GL/glext.h:5366
glWindowPos4ivMESA = _link_function('glWindowPos4ivMESA', None, [POINTER(GLint)], 'MESA_window_pos')

# GL/glext.h:5367
glWindowPos4sMESA = _link_function('glWindowPos4sMESA', None, [GLshort, GLshort, GLshort, GLshort], 'MESA_window_pos')

# GL/glext.h:5368
glWindowPos4svMESA = _link_function('glWindowPos4svMESA', None, [POINTER(GLshort)], 'MESA_window_pos')

PFNGLWINDOWPOS2DMESAPROC = CFUNCTYPE(None, GLdouble, GLdouble) 	# GL/glext.h:5370
PFNGLWINDOWPOS2DVMESAPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:5371
PFNGLWINDOWPOS2FMESAPROC = CFUNCTYPE(None, GLfloat, GLfloat) 	# GL/glext.h:5372
PFNGLWINDOWPOS2FVMESAPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:5373
PFNGLWINDOWPOS2IMESAPROC = CFUNCTYPE(None, GLint, GLint) 	# GL/glext.h:5374
PFNGLWINDOWPOS2IVMESAPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:5375
PFNGLWINDOWPOS2SMESAPROC = CFUNCTYPE(None, GLshort, GLshort) 	# GL/glext.h:5376
PFNGLWINDOWPOS2SVMESAPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:5377
PFNGLWINDOWPOS3DMESAPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:5378
PFNGLWINDOWPOS3DVMESAPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:5379
PFNGLWINDOWPOS3FMESAPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5380
PFNGLWINDOWPOS3FVMESAPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:5381
PFNGLWINDOWPOS3IMESAPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:5382
PFNGLWINDOWPOS3IVMESAPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:5383
PFNGLWINDOWPOS3SMESAPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort) 	# GL/glext.h:5384
PFNGLWINDOWPOS3SVMESAPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:5385
PFNGLWINDOWPOS4DMESAPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:5386
PFNGLWINDOWPOS4DVMESAPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:5387
PFNGLWINDOWPOS4FMESAPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5388
PFNGLWINDOWPOS4FVMESAPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:5389
PFNGLWINDOWPOS4IMESAPROC = CFUNCTYPE(None, GLint, GLint, GLint, GLint) 	# GL/glext.h:5390
PFNGLWINDOWPOS4IVMESAPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:5391
PFNGLWINDOWPOS4SMESAPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort, GLshort) 	# GL/glext.h:5392
PFNGLWINDOWPOS4SVMESAPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:5393
# IBM_cull_vertex (GL/glext.h:5396)
GL_IBM_cull_vertex = 1 	# GL/glext.h:5397
# IBM_multimode_draw_arrays (GL/glext.h:5400)
GL_IBM_multimode_draw_arrays = 1 	# GL/glext.h:5401
# GL/glext.h:5403
glMultiModeDrawArraysIBM = _link_function('glMultiModeDrawArraysIBM', None, [POINTER(GLenum), POINTER(GLint), POINTER(GLsizei), GLsizei, GLint], 'IBM_multimode_draw_arrays')

# GL/glext.h:5404
glMultiModeDrawElementsIBM = _link_function('glMultiModeDrawElementsIBM', None, [POINTER(GLenum), POINTER(GLsizei), GLenum, POINTER(POINTER(GLvoid)), GLsizei, GLint], 'IBM_multimode_draw_arrays')

PFNGLMULTIMODEDRAWARRAYSIBMPROC = CFUNCTYPE(None, POINTER(GLenum), POINTER(GLint), POINTER(GLsizei), GLsizei, GLint) 	# GL/glext.h:5406
PFNGLMULTIMODEDRAWELEMENTSIBMPROC = CFUNCTYPE(None, POINTER(GLenum), POINTER(GLsizei), GLenum, POINTER(POINTER(GLvoid)), GLsizei, GLint) 	# GL/glext.h:5407
# IBM_vertex_array_lists (GL/glext.h:5410)
GL_IBM_vertex_array_lists = 1 	# GL/glext.h:5411
# GL/glext.h:5413
glColorPointerListIBM = _link_function('glColorPointerListIBM', None, [GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint], 'IBM_vertex_array_lists')

# GL/glext.h:5414
glSecondaryColorPointerListIBM = _link_function('glSecondaryColorPointerListIBM', None, [GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint], 'IBM_vertex_array_lists')

# GL/glext.h:5415
glEdgeFlagPointerListIBM = _link_function('glEdgeFlagPointerListIBM', None, [GLint, POINTER(POINTER(GLboolean)), GLint], 'IBM_vertex_array_lists')

# GL/glext.h:5416
glFogCoordPointerListIBM = _link_function('glFogCoordPointerListIBM', None, [GLenum, GLint, POINTER(POINTER(GLvoid)), GLint], 'IBM_vertex_array_lists')

# GL/glext.h:5417
glIndexPointerListIBM = _link_function('glIndexPointerListIBM', None, [GLenum, GLint, POINTER(POINTER(GLvoid)), GLint], 'IBM_vertex_array_lists')

# GL/glext.h:5418
glNormalPointerListIBM = _link_function('glNormalPointerListIBM', None, [GLenum, GLint, POINTER(POINTER(GLvoid)), GLint], 'IBM_vertex_array_lists')

# GL/glext.h:5419
glTexCoordPointerListIBM = _link_function('glTexCoordPointerListIBM', None, [GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint], 'IBM_vertex_array_lists')

# GL/glext.h:5420
glVertexPointerListIBM = _link_function('glVertexPointerListIBM', None, [GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint], 'IBM_vertex_array_lists')

PFNGLCOLORPOINTERLISTIBMPROC = CFUNCTYPE(None, GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint) 	# GL/glext.h:5422
PFNGLSECONDARYCOLORPOINTERLISTIBMPROC = CFUNCTYPE(None, GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint) 	# GL/glext.h:5423
PFNGLEDGEFLAGPOINTERLISTIBMPROC = CFUNCTYPE(None, GLint, POINTER(POINTER(GLboolean)), GLint) 	# GL/glext.h:5424
PFNGLFOGCOORDPOINTERLISTIBMPROC = CFUNCTYPE(None, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint) 	# GL/glext.h:5425
PFNGLINDEXPOINTERLISTIBMPROC = CFUNCTYPE(None, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint) 	# GL/glext.h:5426
PFNGLNORMALPOINTERLISTIBMPROC = CFUNCTYPE(None, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint) 	# GL/glext.h:5427
PFNGLTEXCOORDPOINTERLISTIBMPROC = CFUNCTYPE(None, GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint) 	# GL/glext.h:5428
PFNGLVERTEXPOINTERLISTIBMPROC = CFUNCTYPE(None, GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint) 	# GL/glext.h:5429
# SGIX_subsample (GL/glext.h:5432)
GL_SGIX_subsample = 1 	# GL/glext.h:5433
# SGIX_ycrcba (GL/glext.h:5436)
GL_SGIX_ycrcba = 1 	# GL/glext.h:5437
# SGIX_ycrcb_subsample (GL/glext.h:5440)
GL_SGIX_ycrcb_subsample = 1 	# GL/glext.h:5441
# SGIX_depth_pass_instrument (GL/glext.h:5444)
GL_SGIX_depth_pass_instrument = 1 	# GL/glext.h:5445
# 3DFX_texture_compression_FXT1 (GL/glext.h:5448)
GL_3DFX_texture_compression_FXT1 = 1 	# GL/glext.h:5449
# 3DFX_multisample (GL/glext.h:5452)
GL_3DFX_multisample = 1 	# GL/glext.h:5453
# 3DFX_tbuffer (GL/glext.h:5456)
GL_3DFX_tbuffer = 1 	# GL/glext.h:5457
# GL/glext.h:5459
glTbufferMask3DFX = _link_function('glTbufferMask3DFX', None, [GLuint], '3DFX_tbuffer')

PFNGLTBUFFERMASK3DFXPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5461
# EXT_multisample (GL/glext.h:5464)
GL_EXT_multisample = 1 	# GL/glext.h:5465
# GL/glext.h:5467
glSampleMaskEXT = _link_function('glSampleMaskEXT', None, [GLclampf, GLboolean], 'EXT_multisample')

# GL/glext.h:5468
glSamplePatternEXT = _link_function('glSamplePatternEXT', None, [GLenum], 'EXT_multisample')

PFNGLSAMPLEMASKEXTPROC = CFUNCTYPE(None, GLclampf, GLboolean) 	# GL/glext.h:5470
PFNGLSAMPLEPATTERNEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:5471
# SGIX_vertex_preclip (GL/glext.h:5474)
GL_SGIX_vertex_preclip = 1 	# GL/glext.h:5475
# SGIX_convolution_accuracy (GL/glext.h:5478)
GL_SGIX_convolution_accuracy = 1 	# GL/glext.h:5479
# SGIX_resample (GL/glext.h:5482)
GL_SGIX_resample = 1 	# GL/glext.h:5483
# SGIS_point_line_texgen (GL/glext.h:5486)
GL_SGIS_point_line_texgen = 1 	# GL/glext.h:5487
# SGIS_texture_color_mask (GL/glext.h:5490)
GL_SGIS_texture_color_mask = 1 	# GL/glext.h:5491
# GL/glext.h:5493
glTextureColorMaskSGIS = _link_function('glTextureColorMaskSGIS', None, [GLboolean, GLboolean, GLboolean, GLboolean], 'SGIS_texture_color_mask')

PFNGLTEXTURECOLORMASKSGISPROC = CFUNCTYPE(None, GLboolean, GLboolean, GLboolean, GLboolean) 	# GL/glext.h:5495
# SGIX_igloo_interface (GL/glext.h:5498)
GL_SGIX_igloo_interface = 1 	# GL/glext.h:5499
# GL/glext.h:5501
glIglooInterfaceSGIX = _link_function('glIglooInterfaceSGIX', None, [GLenum, POINTER(GLvoid)], 'SGIX_igloo_interface')

PFNGLIGLOOINTERFACESGIXPROC = CFUNCTYPE(None, GLenum, POINTER(GLvoid)) 	# GL/glext.h:5503
# EXT_texture_env_dot3 (GL/glext.h:5506)
GL_EXT_texture_env_dot3 = 1 	# GL/glext.h:5507
# ATI_texture_mirror_once (GL/glext.h:5510)
GL_ATI_texture_mirror_once = 1 	# GL/glext.h:5511
# NV_fence (GL/glext.h:5514)
GL_NV_fence = 1 	# GL/glext.h:5515
# GL/glext.h:5517
glDeleteFencesNV = _link_function('glDeleteFencesNV', None, [GLsizei, POINTER(GLuint)], 'NV_fence')

# GL/glext.h:5518
glGenFencesNV = _link_function('glGenFencesNV', None, [GLsizei, POINTER(GLuint)], 'NV_fence')

# GL/glext.h:5519
glIsFenceNV = _link_function('glIsFenceNV', GLboolean, [GLuint], 'NV_fence')

# GL/glext.h:5520
glTestFenceNV = _link_function('glTestFenceNV', GLboolean, [GLuint], 'NV_fence')

# GL/glext.h:5521
glGetFenceivNV = _link_function('glGetFenceivNV', None, [GLuint, GLenum, POINTER(GLint)], 'NV_fence')

# GL/glext.h:5522
glFinishFenceNV = _link_function('glFinishFenceNV', None, [GLuint], 'NV_fence')

# GL/glext.h:5523
glSetFenceNV = _link_function('glSetFenceNV', None, [GLuint, GLenum], 'NV_fence')

PFNGLDELETEFENCESNVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:5525
PFNGLGENFENCESNVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:5526
PFNGLISFENCENVPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:5527
PFNGLTESTFENCENVPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:5528
PFNGLGETFENCEIVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5529
PFNGLFINISHFENCENVPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5530
PFNGLSETFENCENVPROC = CFUNCTYPE(None, GLuint, GLenum) 	# GL/glext.h:5531
# NV_evaluators (GL/glext.h:5534)
GL_NV_evaluators = 1 	# GL/glext.h:5535
# GL/glext.h:5537
glMapControlPointsNV = _link_function('glMapControlPointsNV', None, [GLenum, GLuint, GLenum, GLsizei, GLsizei, GLint, GLint, GLboolean, POINTER(GLvoid)], 'NV_evaluators')

# GL/glext.h:5538
glMapParameterivNV = _link_function('glMapParameterivNV', None, [GLenum, GLenum, POINTER(GLint)], 'NV_evaluators')

# GL/glext.h:5539
glMapParameterfvNV = _link_function('glMapParameterfvNV', None, [GLenum, GLenum, POINTER(GLfloat)], 'NV_evaluators')

# GL/glext.h:5540
glGetMapControlPointsNV = _link_function('glGetMapControlPointsNV', None, [GLenum, GLuint, GLenum, GLsizei, GLsizei, GLboolean, POINTER(GLvoid)], 'NV_evaluators')

# GL/glext.h:5541
glGetMapParameterivNV = _link_function('glGetMapParameterivNV', None, [GLenum, GLenum, POINTER(GLint)], 'NV_evaluators')

# GL/glext.h:5542
glGetMapParameterfvNV = _link_function('glGetMapParameterfvNV', None, [GLenum, GLenum, POINTER(GLfloat)], 'NV_evaluators')

# GL/glext.h:5543
glGetMapAttribParameterivNV = _link_function('glGetMapAttribParameterivNV', None, [GLenum, GLuint, GLenum, POINTER(GLint)], 'NV_evaluators')

# GL/glext.h:5544
glGetMapAttribParameterfvNV = _link_function('glGetMapAttribParameterfvNV', None, [GLenum, GLuint, GLenum, POINTER(GLfloat)], 'NV_evaluators')

# GL/glext.h:5545
glEvalMapsNV = _link_function('glEvalMapsNV', None, [GLenum, GLenum], 'NV_evaluators')

PFNGLMAPCONTROLPOINTSNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, GLsizei, GLsizei, GLint, GLint, GLboolean, POINTER(GLvoid)) 	# GL/glext.h:5547
PFNGLMAPPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5548
PFNGLMAPPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5549
PFNGLGETMAPCONTROLPOINTSNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, GLsizei, GLsizei, GLboolean, POINTER(GLvoid)) 	# GL/glext.h:5550
PFNGLGETMAPPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5551
PFNGLGETMAPPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5552
PFNGLGETMAPATTRIBPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5553
PFNGLGETMAPATTRIBPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5554
PFNGLEVALMAPSNVPROC = CFUNCTYPE(None, GLenum, GLenum) 	# GL/glext.h:5555
# NV_packed_depth_stencil (GL/glext.h:5558)
GL_NV_packed_depth_stencil = 1 	# GL/glext.h:5559
# NV_register_combiners2 (GL/glext.h:5562)
GL_NV_register_combiners2 = 1 	# GL/glext.h:5563
# GL/glext.h:5565
glCombinerStageParameterfvNV = _link_function('glCombinerStageParameterfvNV', None, [GLenum, GLenum, POINTER(GLfloat)], 'NV_register_combiners2')

# GL/glext.h:5566
glGetCombinerStageParameterfvNV = _link_function('glGetCombinerStageParameterfvNV', None, [GLenum, GLenum, POINTER(GLfloat)], 'NV_register_combiners2')

PFNGLCOMBINERSTAGEPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5568
PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5569
# NV_texture_compression_vtc (GL/glext.h:5572)
GL_NV_texture_compression_vtc = 1 	# GL/glext.h:5573
# NV_texture_rectangle (GL/glext.h:5576)
GL_NV_texture_rectangle = 1 	# GL/glext.h:5577
# NV_texture_shader (GL/glext.h:5580)
GL_NV_texture_shader = 1 	# GL/glext.h:5581
# NV_texture_shader2 (GL/glext.h:5584)
GL_NV_texture_shader2 = 1 	# GL/glext.h:5585
# NV_vertex_array_range2 (GL/glext.h:5588)
GL_NV_vertex_array_range2 = 1 	# GL/glext.h:5589
# NV_vertex_program (GL/glext.h:5592)
GL_NV_vertex_program = 1 	# GL/glext.h:5593
# GL/glext.h:5595
glAreProgramsResidentNV = _link_function('glAreProgramsResidentNV', GLboolean, [GLsizei, POINTER(GLuint), POINTER(GLboolean)], 'NV_vertex_program')

# GL/glext.h:5596
glBindProgramNV = _link_function('glBindProgramNV', None, [GLenum, GLuint], 'NV_vertex_program')

# GL/glext.h:5597
glDeleteProgramsNV = _link_function('glDeleteProgramsNV', None, [GLsizei, POINTER(GLuint)], 'NV_vertex_program')

# GL/glext.h:5598
glExecuteProgramNV = _link_function('glExecuteProgramNV', None, [GLenum, GLuint, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5599
glGenProgramsNV = _link_function('glGenProgramsNV', None, [GLsizei, POINTER(GLuint)], 'NV_vertex_program')

# GL/glext.h:5600
glGetProgramParameterdvNV = _link_function('glGetProgramParameterdvNV', None, [GLenum, GLuint, GLenum, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5601
glGetProgramParameterfvNV = _link_function('glGetProgramParameterfvNV', None, [GLenum, GLuint, GLenum, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5602
glGetProgramivNV = _link_function('glGetProgramivNV', None, [GLuint, GLenum, POINTER(GLint)], 'NV_vertex_program')

# GL/glext.h:5603
glGetProgramStringNV = _link_function('glGetProgramStringNV', None, [GLuint, GLenum, POINTER(GLubyte)], 'NV_vertex_program')

# GL/glext.h:5604
glGetTrackMatrixivNV = _link_function('glGetTrackMatrixivNV', None, [GLenum, GLuint, GLenum, POINTER(GLint)], 'NV_vertex_program')

# GL/glext.h:5605
glGetVertexAttribdvNV = _link_function('glGetVertexAttribdvNV', None, [GLuint, GLenum, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5606
glGetVertexAttribfvNV = _link_function('glGetVertexAttribfvNV', None, [GLuint, GLenum, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5607
glGetVertexAttribivNV = _link_function('glGetVertexAttribivNV', None, [GLuint, GLenum, POINTER(GLint)], 'NV_vertex_program')

# GL/glext.h:5608
glGetVertexAttribPointervNV = _link_function('glGetVertexAttribPointervNV', None, [GLuint, GLenum, POINTER(POINTER(GLvoid))], 'NV_vertex_program')

# GL/glext.h:5609
glIsProgramNV = _link_function('glIsProgramNV', GLboolean, [GLuint], 'NV_vertex_program')

# GL/glext.h:5610
glLoadProgramNV = _link_function('glLoadProgramNV', None, [GLenum, GLuint, GLsizei, POINTER(GLubyte)], 'NV_vertex_program')

# GL/glext.h:5611
glProgramParameter4dNV = _link_function('glProgramParameter4dNV', None, [GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble], 'NV_vertex_program')

# GL/glext.h:5612
glProgramParameter4dvNV = _link_function('glProgramParameter4dvNV', None, [GLenum, GLuint, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5613
glProgramParameter4fNV = _link_function('glProgramParameter4fNV', None, [GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat], 'NV_vertex_program')

# GL/glext.h:5614
glProgramParameter4fvNV = _link_function('glProgramParameter4fvNV', None, [GLenum, GLuint, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5615
glProgramParameters4dvNV = _link_function('glProgramParameters4dvNV', None, [GLenum, GLuint, GLuint, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5616
glProgramParameters4fvNV = _link_function('glProgramParameters4fvNV', None, [GLenum, GLuint, GLuint, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5617
glRequestResidentProgramsNV = _link_function('glRequestResidentProgramsNV', None, [GLsizei, POINTER(GLuint)], 'NV_vertex_program')

# GL/glext.h:5618
glTrackMatrixNV = _link_function('glTrackMatrixNV', None, [GLenum, GLuint, GLenum, GLenum], 'NV_vertex_program')

# GL/glext.h:5619
glVertexAttribPointerNV = _link_function('glVertexAttribPointerNV', None, [GLuint, GLint, GLenum, GLsizei, POINTER(GLvoid)], 'NV_vertex_program')

# GL/glext.h:5620
glVertexAttrib1dNV = _link_function('glVertexAttrib1dNV', None, [GLuint, GLdouble], 'NV_vertex_program')

# GL/glext.h:5621
glVertexAttrib1dvNV = _link_function('glVertexAttrib1dvNV', None, [GLuint, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5622
glVertexAttrib1fNV = _link_function('glVertexAttrib1fNV', None, [GLuint, GLfloat], 'NV_vertex_program')

# GL/glext.h:5623
glVertexAttrib1fvNV = _link_function('glVertexAttrib1fvNV', None, [GLuint, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5624
glVertexAttrib1sNV = _link_function('glVertexAttrib1sNV', None, [GLuint, GLshort], 'NV_vertex_program')

# GL/glext.h:5625
glVertexAttrib1svNV = _link_function('glVertexAttrib1svNV', None, [GLuint, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5626
glVertexAttrib2dNV = _link_function('glVertexAttrib2dNV', None, [GLuint, GLdouble, GLdouble], 'NV_vertex_program')

# GL/glext.h:5627
glVertexAttrib2dvNV = _link_function('glVertexAttrib2dvNV', None, [GLuint, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5628
glVertexAttrib2fNV = _link_function('glVertexAttrib2fNV', None, [GLuint, GLfloat, GLfloat], 'NV_vertex_program')

# GL/glext.h:5629
glVertexAttrib2fvNV = _link_function('glVertexAttrib2fvNV', None, [GLuint, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5630
glVertexAttrib2sNV = _link_function('glVertexAttrib2sNV', None, [GLuint, GLshort, GLshort], 'NV_vertex_program')

# GL/glext.h:5631
glVertexAttrib2svNV = _link_function('glVertexAttrib2svNV', None, [GLuint, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5632
glVertexAttrib3dNV = _link_function('glVertexAttrib3dNV', None, [GLuint, GLdouble, GLdouble, GLdouble], 'NV_vertex_program')

# GL/glext.h:5633
glVertexAttrib3dvNV = _link_function('glVertexAttrib3dvNV', None, [GLuint, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5634
glVertexAttrib3fNV = _link_function('glVertexAttrib3fNV', None, [GLuint, GLfloat, GLfloat, GLfloat], 'NV_vertex_program')

# GL/glext.h:5635
glVertexAttrib3fvNV = _link_function('glVertexAttrib3fvNV', None, [GLuint, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5636
glVertexAttrib3sNV = _link_function('glVertexAttrib3sNV', None, [GLuint, GLshort, GLshort, GLshort], 'NV_vertex_program')

# GL/glext.h:5637
glVertexAttrib3svNV = _link_function('glVertexAttrib3svNV', None, [GLuint, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5638
glVertexAttrib4dNV = _link_function('glVertexAttrib4dNV', None, [GLuint, GLdouble, GLdouble, GLdouble, GLdouble], 'NV_vertex_program')

# GL/glext.h:5639
glVertexAttrib4dvNV = _link_function('glVertexAttrib4dvNV', None, [GLuint, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5640
glVertexAttrib4fNV = _link_function('glVertexAttrib4fNV', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat], 'NV_vertex_program')

# GL/glext.h:5641
glVertexAttrib4fvNV = _link_function('glVertexAttrib4fvNV', None, [GLuint, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5642
glVertexAttrib4sNV = _link_function('glVertexAttrib4sNV', None, [GLuint, GLshort, GLshort, GLshort, GLshort], 'NV_vertex_program')

# GL/glext.h:5643
glVertexAttrib4svNV = _link_function('glVertexAttrib4svNV', None, [GLuint, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5644
glVertexAttrib4ubNV = _link_function('glVertexAttrib4ubNV', None, [GLuint, GLubyte, GLubyte, GLubyte, GLubyte], 'NV_vertex_program')

# GL/glext.h:5645
glVertexAttrib4ubvNV = _link_function('glVertexAttrib4ubvNV', None, [GLuint, POINTER(GLubyte)], 'NV_vertex_program')

# GL/glext.h:5646
glVertexAttribs1dvNV = _link_function('glVertexAttribs1dvNV', None, [GLuint, GLsizei, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5647
glVertexAttribs1fvNV = _link_function('glVertexAttribs1fvNV', None, [GLuint, GLsizei, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5648
glVertexAttribs1svNV = _link_function('glVertexAttribs1svNV', None, [GLuint, GLsizei, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5649
glVertexAttribs2dvNV = _link_function('glVertexAttribs2dvNV', None, [GLuint, GLsizei, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5650
glVertexAttribs2fvNV = _link_function('glVertexAttribs2fvNV', None, [GLuint, GLsizei, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5651
glVertexAttribs2svNV = _link_function('glVertexAttribs2svNV', None, [GLuint, GLsizei, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5652
glVertexAttribs3dvNV = _link_function('glVertexAttribs3dvNV', None, [GLuint, GLsizei, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5653
glVertexAttribs3fvNV = _link_function('glVertexAttribs3fvNV', None, [GLuint, GLsizei, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5654
glVertexAttribs3svNV = _link_function('glVertexAttribs3svNV', None, [GLuint, GLsizei, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5655
glVertexAttribs4dvNV = _link_function('glVertexAttribs4dvNV', None, [GLuint, GLsizei, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5656
glVertexAttribs4fvNV = _link_function('glVertexAttribs4fvNV', None, [GLuint, GLsizei, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5657
glVertexAttribs4svNV = _link_function('glVertexAttribs4svNV', None, [GLuint, GLsizei, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5658
glVertexAttribs4ubvNV = _link_function('glVertexAttribs4ubvNV', None, [GLuint, GLsizei, POINTER(GLubyte)], 'NV_vertex_program')

PFNGLAREPROGRAMSRESIDENTNVPROC = CFUNCTYPE(GLboolean, GLsizei, POINTER(GLuint), POINTER(GLboolean)) 	# GL/glext.h:5660
PFNGLBINDPROGRAMNVPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:5661
PFNGLDELETEPROGRAMSNVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:5662
PFNGLEXECUTEPROGRAMNVPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLfloat)) 	# GL/glext.h:5663
PFNGLGENPROGRAMSNVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:5664
PFNGLGETPROGRAMPARAMETERDVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, POINTER(GLdouble)) 	# GL/glext.h:5665
PFNGLGETPROGRAMPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5666
PFNGLGETPROGRAMIVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5667
PFNGLGETPROGRAMSTRINGNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLubyte)) 	# GL/glext.h:5668
PFNGLGETTRACKMATRIXIVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5669
PFNGLGETVERTEXATTRIBDVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLdouble)) 	# GL/glext.h:5670
PFNGLGETVERTEXATTRIBFVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5671
PFNGLGETVERTEXATTRIBIVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5672
PFNGLGETVERTEXATTRIBPOINTERVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:5673
PFNGLISPROGRAMNVPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:5674
PFNGLLOADPROGRAMNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLsizei, POINTER(GLubyte)) 	# GL/glext.h:5675
PFNGLPROGRAMPARAMETER4DNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:5676
PFNGLPROGRAMPARAMETER4DVNVPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLdouble)) 	# GL/glext.h:5677
PFNGLPROGRAMPARAMETER4FNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5678
PFNGLPROGRAMPARAMETER4FVNVPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLfloat)) 	# GL/glext.h:5679
PFNGLPROGRAMPARAMETERS4DVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, POINTER(GLdouble)) 	# GL/glext.h:5680
PFNGLPROGRAMPARAMETERS4FVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, POINTER(GLfloat)) 	# GL/glext.h:5681
PFNGLREQUESTRESIDENTPROGRAMSNVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:5682
PFNGLTRACKMATRIXNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, GLenum) 	# GL/glext.h:5683
PFNGLVERTEXATTRIBPOINTERNVPROC = CFUNCTYPE(None, GLuint, GLint, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:5684
PFNGLVERTEXATTRIB1DNVPROC = CFUNCTYPE(None, GLuint, GLdouble) 	# GL/glext.h:5685
PFNGLVERTEXATTRIB1DVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:5686
PFNGLVERTEXATTRIB1FNVPROC = CFUNCTYPE(None, GLuint, GLfloat) 	# GL/glext.h:5687
PFNGLVERTEXATTRIB1FVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:5688
PFNGLVERTEXATTRIB1SNVPROC = CFUNCTYPE(None, GLuint, GLshort) 	# GL/glext.h:5689
PFNGLVERTEXATTRIB1SVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:5690
PFNGLVERTEXATTRIB2DNVPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble) 	# GL/glext.h:5691
PFNGLVERTEXATTRIB2DVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:5692
PFNGLVERTEXATTRIB2FNVPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat) 	# GL/glext.h:5693
PFNGLVERTEXATTRIB2FVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:5694
PFNGLVERTEXATTRIB2SNVPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort) 	# GL/glext.h:5695
PFNGLVERTEXATTRIB2SVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:5696
PFNGLVERTEXATTRIB3DNVPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:5697
PFNGLVERTEXATTRIB3DVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:5698
PFNGLVERTEXATTRIB3FNVPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5699
PFNGLVERTEXATTRIB3FVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:5700
PFNGLVERTEXATTRIB3SNVPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort, GLshort) 	# GL/glext.h:5701
PFNGLVERTEXATTRIB3SVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:5702
PFNGLVERTEXATTRIB4DNVPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:5703
PFNGLVERTEXATTRIB4DVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:5704
PFNGLVERTEXATTRIB4FNVPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5705
PFNGLVERTEXATTRIB4FVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:5706
PFNGLVERTEXATTRIB4SNVPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort, GLshort, GLshort) 	# GL/glext.h:5707
PFNGLVERTEXATTRIB4SVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:5708
PFNGLVERTEXATTRIB4UBNVPROC = CFUNCTYPE(None, GLuint, GLubyte, GLubyte, GLubyte, GLubyte) 	# GL/glext.h:5709
PFNGLVERTEXATTRIB4UBVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLubyte)) 	# GL/glext.h:5710
PFNGLVERTEXATTRIBS1DVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLdouble)) 	# GL/glext.h:5711
PFNGLVERTEXATTRIBS1FVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:5712
PFNGLVERTEXATTRIBS1SVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLshort)) 	# GL/glext.h:5713
PFNGLVERTEXATTRIBS2DVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLdouble)) 	# GL/glext.h:5714
PFNGLVERTEXATTRIBS2FVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:5715
PFNGLVERTEXATTRIBS2SVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLshort)) 	# GL/glext.h:5716
PFNGLVERTEXATTRIBS3DVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLdouble)) 	# GL/glext.h:5717
PFNGLVERTEXATTRIBS3FVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:5718
PFNGLVERTEXATTRIBS3SVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLshort)) 	# GL/glext.h:5719
PFNGLVERTEXATTRIBS4DVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLdouble)) 	# GL/glext.h:5720
PFNGLVERTEXATTRIBS4FVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:5721
PFNGLVERTEXATTRIBS4SVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLshort)) 	# GL/glext.h:5722
PFNGLVERTEXATTRIBS4UBVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLubyte)) 	# GL/glext.h:5723
# SGIX_texture_coordinate_clamp (GL/glext.h:5726)
GL_SGIX_texture_coordinate_clamp = 1 	# GL/glext.h:5727
# SGIX_scalebias_hint (GL/glext.h:5730)
GL_SGIX_scalebias_hint = 1 	# GL/glext.h:5731
# OML_interlace (GL/glext.h:5734)
GL_OML_interlace = 1 	# GL/glext.h:5735
# OML_subsample (GL/glext.h:5738)
GL_OML_subsample = 1 	# GL/glext.h:5739
# OML_resample (GL/glext.h:5742)
GL_OML_resample = 1 	# GL/glext.h:5743
# NV_copy_depth_to_color (GL/glext.h:5746)
GL_NV_copy_depth_to_color = 1 	# GL/glext.h:5747
# ATI_envmap_bumpmap (GL/glext.h:5750)
GL_ATI_envmap_bumpmap = 1 	# GL/glext.h:5751
# GL/glext.h:5753
glTexBumpParameterivATI = _link_function('glTexBumpParameterivATI', None, [GLenum, POINTER(GLint)], 'ATI_envmap_bumpmap')

# GL/glext.h:5754
glTexBumpParameterfvATI = _link_function('glTexBumpParameterfvATI', None, [GLenum, POINTER(GLfloat)], 'ATI_envmap_bumpmap')

# GL/glext.h:5755
glGetTexBumpParameterivATI = _link_function('glGetTexBumpParameterivATI', None, [GLenum, POINTER(GLint)], 'ATI_envmap_bumpmap')

# GL/glext.h:5756
glGetTexBumpParameterfvATI = _link_function('glGetTexBumpParameterfvATI', None, [GLenum, POINTER(GLfloat)], 'ATI_envmap_bumpmap')

PFNGLTEXBUMPPARAMETERIVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:5758
PFNGLTEXBUMPPARAMETERFVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5759
PFNGLGETTEXBUMPPARAMETERIVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:5760
PFNGLGETTEXBUMPPARAMETERFVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5761
# ATI_fragment_shader (GL/glext.h:5764)
GL_ATI_fragment_shader = 1 	# GL/glext.h:5765
# GL/glext.h:5767
glGenFragmentShadersATI = _link_function('glGenFragmentShadersATI', GLuint, [GLuint], 'ATI_fragment_shader')

# GL/glext.h:5768
glBindFragmentShaderATI = _link_function('glBindFragmentShaderATI', None, [GLuint], 'ATI_fragment_shader')

# GL/glext.h:5769
glDeleteFragmentShaderATI = _link_function('glDeleteFragmentShaderATI', None, [GLuint], 'ATI_fragment_shader')

# GL/glext.h:5770
glBeginFragmentShaderATI = _link_function('glBeginFragmentShaderATI', None, [], 'ATI_fragment_shader')

# GL/glext.h:5771
glEndFragmentShaderATI = _link_function('glEndFragmentShaderATI', None, [], 'ATI_fragment_shader')

# GL/glext.h:5772
glPassTexCoordATI = _link_function('glPassTexCoordATI', None, [GLuint, GLuint, GLenum], 'ATI_fragment_shader')

# GL/glext.h:5773
glSampleMapATI = _link_function('glSampleMapATI', None, [GLuint, GLuint, GLenum], 'ATI_fragment_shader')

# GL/glext.h:5774
glColorFragmentOp1ATI = _link_function('glColorFragmentOp1ATI', None, [GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint], 'ATI_fragment_shader')

# GL/glext.h:5775
glColorFragmentOp2ATI = _link_function('glColorFragmentOp2ATI', None, [GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint], 'ATI_fragment_shader')

# GL/glext.h:5776
glColorFragmentOp3ATI = _link_function('glColorFragmentOp3ATI', None, [GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint], 'ATI_fragment_shader')

# GL/glext.h:5777
glAlphaFragmentOp1ATI = _link_function('glAlphaFragmentOp1ATI', None, [GLenum, GLuint, GLuint, GLuint, GLuint, GLuint], 'ATI_fragment_shader')

# GL/glext.h:5778
glAlphaFragmentOp2ATI = _link_function('glAlphaFragmentOp2ATI', None, [GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint], 'ATI_fragment_shader')

# GL/glext.h:5779
glAlphaFragmentOp3ATI = _link_function('glAlphaFragmentOp3ATI', None, [GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint], 'ATI_fragment_shader')

# GL/glext.h:5780
glSetFragmentShaderConstantATI = _link_function('glSetFragmentShaderConstantATI', None, [GLuint, POINTER(GLfloat)], 'ATI_fragment_shader')

PFNGLGENFRAGMENTSHADERSATIPROC = CFUNCTYPE(GLuint, GLuint) 	# GL/glext.h:5782
PFNGLBINDFRAGMENTSHADERATIPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5783
PFNGLDELETEFRAGMENTSHADERATIPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5784
PFNGLBEGINFRAGMENTSHADERATIPROC = CFUNCTYPE(None) 	# GL/glext.h:5785
PFNGLENDFRAGMENTSHADERATIPROC = CFUNCTYPE(None) 	# GL/glext.h:5786
PFNGLPASSTEXCOORDATIPROC = CFUNCTYPE(None, GLuint, GLuint, GLenum) 	# GL/glext.h:5787
PFNGLSAMPLEMAPATIPROC = CFUNCTYPE(None, GLuint, GLuint, GLenum) 	# GL/glext.h:5788
PFNGLCOLORFRAGMENTOP1ATIPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:5789
PFNGLCOLORFRAGMENTOP2ATIPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:5790
PFNGLCOLORFRAGMENTOP3ATIPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:5791
PFNGLALPHAFRAGMENTOP1ATIPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:5792
PFNGLALPHAFRAGMENTOP2ATIPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:5793
PFNGLALPHAFRAGMENTOP3ATIPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:5794
PFNGLSETFRAGMENTSHADERCONSTANTATIPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:5795
# ATI_pn_triangles (GL/glext.h:5798)
GL_ATI_pn_triangles = 1 	# GL/glext.h:5799
# GL/glext.h:5801
glPNTrianglesiATI = _link_function('glPNTrianglesiATI', None, [GLenum, GLint], 'ATI_pn_triangles')

# GL/glext.h:5802
glPNTrianglesfATI = _link_function('glPNTrianglesfATI', None, [GLenum, GLfloat], 'ATI_pn_triangles')

PFNGLPNTRIANGLESIATIPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:5804
PFNGLPNTRIANGLESFATIPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:5805
# ATI_vertex_array_object (GL/glext.h:5808)
GL_ATI_vertex_array_object = 1 	# GL/glext.h:5809
# GL/glext.h:5811
glNewObjectBufferATI = _link_function('glNewObjectBufferATI', GLuint, [GLsizei, POINTER(GLvoid), GLenum], 'ATI_vertex_array_object')

# GL/glext.h:5812
glIsObjectBufferATI = _link_function('glIsObjectBufferATI', GLboolean, [GLuint], 'ATI_vertex_array_object')

# GL/glext.h:5813
glUpdateObjectBufferATI = _link_function('glUpdateObjectBufferATI', None, [GLuint, GLuint, GLsizei, POINTER(GLvoid), GLenum], 'ATI_vertex_array_object')

# GL/glext.h:5814
glGetObjectBufferfvATI = _link_function('glGetObjectBufferfvATI', None, [GLuint, GLenum, POINTER(GLfloat)], 'ATI_vertex_array_object')

# GL/glext.h:5815
glGetObjectBufferivATI = _link_function('glGetObjectBufferivATI', None, [GLuint, GLenum, POINTER(GLint)], 'ATI_vertex_array_object')

# GL/glext.h:5816
glFreeObjectBufferATI = _link_function('glFreeObjectBufferATI', None, [GLuint], 'ATI_vertex_array_object')

# GL/glext.h:5817
glArrayObjectATI = _link_function('glArrayObjectATI', None, [GLenum, GLint, GLenum, GLsizei, GLuint, GLuint], 'ATI_vertex_array_object')

# GL/glext.h:5818
glGetArrayObjectfvATI = _link_function('glGetArrayObjectfvATI', None, [GLenum, GLenum, POINTER(GLfloat)], 'ATI_vertex_array_object')

# GL/glext.h:5819
glGetArrayObjectivATI = _link_function('glGetArrayObjectivATI', None, [GLenum, GLenum, POINTER(GLint)], 'ATI_vertex_array_object')

# GL/glext.h:5820
glVariantArrayObjectATI = _link_function('glVariantArrayObjectATI', None, [GLuint, GLenum, GLsizei, GLuint, GLuint], 'ATI_vertex_array_object')

# GL/glext.h:5821
glGetVariantArrayObjectfvATI = _link_function('glGetVariantArrayObjectfvATI', None, [GLuint, GLenum, POINTER(GLfloat)], 'ATI_vertex_array_object')

# GL/glext.h:5822
glGetVariantArrayObjectivATI = _link_function('glGetVariantArrayObjectivATI', None, [GLuint, GLenum, POINTER(GLint)], 'ATI_vertex_array_object')

PFNGLNEWOBJECTBUFFERATIPROC = CFUNCTYPE(GLuint, GLsizei, POINTER(GLvoid), GLenum) 	# GL/glext.h:5824
PFNGLISOBJECTBUFFERATIPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:5825
PFNGLUPDATEOBJECTBUFFERATIPROC = CFUNCTYPE(None, GLuint, GLuint, GLsizei, POINTER(GLvoid), GLenum) 	# GL/glext.h:5826
PFNGLGETOBJECTBUFFERFVATIPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5827
PFNGLGETOBJECTBUFFERIVATIPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5828
PFNGLFREEOBJECTBUFFERATIPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5829
PFNGLARRAYOBJECTATIPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLuint, GLuint) 	# GL/glext.h:5830
PFNGLGETARRAYOBJECTFVATIPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5831
PFNGLGETARRAYOBJECTIVATIPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5832
PFNGLVARIANTARRAYOBJECTATIPROC = CFUNCTYPE(None, GLuint, GLenum, GLsizei, GLuint, GLuint) 	# GL/glext.h:5833
PFNGLGETVARIANTARRAYOBJECTFVATIPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5834
PFNGLGETVARIANTARRAYOBJECTIVATIPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5835
# EXT_vertex_shader (GL/glext.h:5838)
GL_EXT_vertex_shader = 1 	# GL/glext.h:5839
# GL/glext.h:5841
glBeginVertexShaderEXT = _link_function('glBeginVertexShaderEXT', None, [], 'EXT_vertex_shader')

# GL/glext.h:5842
glEndVertexShaderEXT = _link_function('glEndVertexShaderEXT', None, [], 'EXT_vertex_shader')

# GL/glext.h:5843
glBindVertexShaderEXT = _link_function('glBindVertexShaderEXT', None, [GLuint], 'EXT_vertex_shader')

# GL/glext.h:5844
glGenVertexShadersEXT = _link_function('glGenVertexShadersEXT', GLuint, [GLuint], 'EXT_vertex_shader')

# GL/glext.h:5845
glDeleteVertexShaderEXT = _link_function('glDeleteVertexShaderEXT', None, [GLuint], 'EXT_vertex_shader')

# GL/glext.h:5846
glShaderOp1EXT = _link_function('glShaderOp1EXT', None, [GLenum, GLuint, GLuint], 'EXT_vertex_shader')

# GL/glext.h:5847
glShaderOp2EXT = _link_function('glShaderOp2EXT', None, [GLenum, GLuint, GLuint, GLuint], 'EXT_vertex_shader')

# GL/glext.h:5848
glShaderOp3EXT = _link_function('glShaderOp3EXT', None, [GLenum, GLuint, GLuint, GLuint, GLuint], 'EXT_vertex_shader')

# GL/glext.h:5849
glSwizzleEXT = _link_function('glSwizzleEXT', None, [GLuint, GLuint, GLenum, GLenum, GLenum, GLenum], 'EXT_vertex_shader')

# GL/glext.h:5850
glWriteMaskEXT = _link_function('glWriteMaskEXT', None, [GLuint, GLuint, GLenum, GLenum, GLenum, GLenum], 'EXT_vertex_shader')

# GL/glext.h:5851
glInsertComponentEXT = _link_function('glInsertComponentEXT', None, [GLuint, GLuint, GLuint], 'EXT_vertex_shader')

# GL/glext.h:5852
glExtractComponentEXT = _link_function('glExtractComponentEXT', None, [GLuint, GLuint, GLuint], 'EXT_vertex_shader')

# GL/glext.h:5853
glGenSymbolsEXT = _link_function('glGenSymbolsEXT', GLuint, [GLenum, GLenum, GLenum, GLuint], 'EXT_vertex_shader')

# GL/glext.h:5854
glSetInvariantEXT = _link_function('glSetInvariantEXT', None, [GLuint, GLenum, POINTER(GLvoid)], 'EXT_vertex_shader')

# GL/glext.h:5855
glSetLocalConstantEXT = _link_function('glSetLocalConstantEXT', None, [GLuint, GLenum, POINTER(GLvoid)], 'EXT_vertex_shader')

# GL/glext.h:5856
glVariantbvEXT = _link_function('glVariantbvEXT', None, [GLuint, POINTER(GLbyte)], 'EXT_vertex_shader')

# GL/glext.h:5857
glVariantsvEXT = _link_function('glVariantsvEXT', None, [GLuint, POINTER(GLshort)], 'EXT_vertex_shader')

# GL/glext.h:5858
glVariantivEXT = _link_function('glVariantivEXT', None, [GLuint, POINTER(GLint)], 'EXT_vertex_shader')

# GL/glext.h:5859
glVariantfvEXT = _link_function('glVariantfvEXT', None, [GLuint, POINTER(GLfloat)], 'EXT_vertex_shader')

# GL/glext.h:5860
glVariantdvEXT = _link_function('glVariantdvEXT', None, [GLuint, POINTER(GLdouble)], 'EXT_vertex_shader')

# GL/glext.h:5861
glVariantubvEXT = _link_function('glVariantubvEXT', None, [GLuint, POINTER(GLubyte)], 'EXT_vertex_shader')

# GL/glext.h:5862
glVariantusvEXT = _link_function('glVariantusvEXT', None, [GLuint, POINTER(GLushort)], 'EXT_vertex_shader')

# GL/glext.h:5863
glVariantuivEXT = _link_function('glVariantuivEXT', None, [GLuint, POINTER(GLuint)], 'EXT_vertex_shader')

# GL/glext.h:5864
glVariantPointerEXT = _link_function('glVariantPointerEXT', None, [GLuint, GLenum, GLuint, POINTER(GLvoid)], 'EXT_vertex_shader')

# GL/glext.h:5865
glEnableVariantClientStateEXT = _link_function('glEnableVariantClientStateEXT', None, [GLuint], 'EXT_vertex_shader')

# GL/glext.h:5866
glDisableVariantClientStateEXT = _link_function('glDisableVariantClientStateEXT', None, [GLuint], 'EXT_vertex_shader')

# GL/glext.h:5867
glBindLightParameterEXT = _link_function('glBindLightParameterEXT', GLuint, [GLenum, GLenum], 'EXT_vertex_shader')

# GL/glext.h:5868
glBindMaterialParameterEXT = _link_function('glBindMaterialParameterEXT', GLuint, [GLenum, GLenum], 'EXT_vertex_shader')

# GL/glext.h:5869
glBindTexGenParameterEXT = _link_function('glBindTexGenParameterEXT', GLuint, [GLenum, GLenum, GLenum], 'EXT_vertex_shader')

# GL/glext.h:5870
glBindTextureUnitParameterEXT = _link_function('glBindTextureUnitParameterEXT', GLuint, [GLenum, GLenum], 'EXT_vertex_shader')

# GL/glext.h:5871
glBindParameterEXT = _link_function('glBindParameterEXT', GLuint, [GLenum], 'EXT_vertex_shader')

# GL/glext.h:5872
glIsVariantEnabledEXT = _link_function('glIsVariantEnabledEXT', GLboolean, [GLuint, GLenum], 'EXT_vertex_shader')

# GL/glext.h:5873
glGetVariantBooleanvEXT = _link_function('glGetVariantBooleanvEXT', None, [GLuint, GLenum, POINTER(GLboolean)], 'EXT_vertex_shader')

# GL/glext.h:5874
glGetVariantIntegervEXT = _link_function('glGetVariantIntegervEXT', None, [GLuint, GLenum, POINTER(GLint)], 'EXT_vertex_shader')

# GL/glext.h:5875
glGetVariantFloatvEXT = _link_function('glGetVariantFloatvEXT', None, [GLuint, GLenum, POINTER(GLfloat)], 'EXT_vertex_shader')

# GL/glext.h:5876
glGetVariantPointervEXT = _link_function('glGetVariantPointervEXT', None, [GLuint, GLenum, POINTER(POINTER(GLvoid))], 'EXT_vertex_shader')

# GL/glext.h:5877
glGetInvariantBooleanvEXT = _link_function('glGetInvariantBooleanvEXT', None, [GLuint, GLenum, POINTER(GLboolean)], 'EXT_vertex_shader')

# GL/glext.h:5878
glGetInvariantIntegervEXT = _link_function('glGetInvariantIntegervEXT', None, [GLuint, GLenum, POINTER(GLint)], 'EXT_vertex_shader')

# GL/glext.h:5879
glGetInvariantFloatvEXT = _link_function('glGetInvariantFloatvEXT', None, [GLuint, GLenum, POINTER(GLfloat)], 'EXT_vertex_shader')

# GL/glext.h:5880
glGetLocalConstantBooleanvEXT = _link_function('glGetLocalConstantBooleanvEXT', None, [GLuint, GLenum, POINTER(GLboolean)], 'EXT_vertex_shader')

# GL/glext.h:5881
glGetLocalConstantIntegervEXT = _link_function('glGetLocalConstantIntegervEXT', None, [GLuint, GLenum, POINTER(GLint)], 'EXT_vertex_shader')

# GL/glext.h:5882
glGetLocalConstantFloatvEXT = _link_function('glGetLocalConstantFloatvEXT', None, [GLuint, GLenum, POINTER(GLfloat)], 'EXT_vertex_shader')

PFNGLBEGINVERTEXSHADEREXTPROC = CFUNCTYPE(None) 	# GL/glext.h:5884
PFNGLENDVERTEXSHADEREXTPROC = CFUNCTYPE(None) 	# GL/glext.h:5885
PFNGLBINDVERTEXSHADEREXTPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5886
PFNGLGENVERTEXSHADERSEXTPROC = CFUNCTYPE(GLuint, GLuint) 	# GL/glext.h:5887
PFNGLDELETEVERTEXSHADEREXTPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5888
PFNGLSHADEROP1EXTPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint) 	# GL/glext.h:5889
PFNGLSHADEROP2EXTPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint) 	# GL/glext.h:5890
PFNGLSHADEROP3EXTPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:5891
PFNGLSWIZZLEEXTPROC = CFUNCTYPE(None, GLuint, GLuint, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:5892
PFNGLWRITEMASKEXTPROC = CFUNCTYPE(None, GLuint, GLuint, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:5893
PFNGLINSERTCOMPONENTEXTPROC = CFUNCTYPE(None, GLuint, GLuint, GLuint) 	# GL/glext.h:5894
PFNGLEXTRACTCOMPONENTEXTPROC = CFUNCTYPE(None, GLuint, GLuint, GLuint) 	# GL/glext.h:5895
PFNGLGENSYMBOLSEXTPROC = CFUNCTYPE(GLuint, GLenum, GLenum, GLenum, GLuint) 	# GL/glext.h:5896
PFNGLSETINVARIANTEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLvoid)) 	# GL/glext.h:5897
PFNGLSETLOCALCONSTANTEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLvoid)) 	# GL/glext.h:5898
PFNGLVARIANTBVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLbyte)) 	# GL/glext.h:5899
PFNGLVARIANTSVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:5900
PFNGLVARIANTIVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLint)) 	# GL/glext.h:5901
PFNGLVARIANTFVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:5902
PFNGLVARIANTDVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:5903
PFNGLVARIANTUBVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLubyte)) 	# GL/glext.h:5904
PFNGLVARIANTUSVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLushort)) 	# GL/glext.h:5905
PFNGLVARIANTUIVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLuint)) 	# GL/glext.h:5906
PFNGLVARIANTPOINTEREXTPROC = CFUNCTYPE(None, GLuint, GLenum, GLuint, POINTER(GLvoid)) 	# GL/glext.h:5907
PFNGLENABLEVARIANTCLIENTSTATEEXTPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5908
PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5909
PFNGLBINDLIGHTPARAMETEREXTPROC = CFUNCTYPE(GLuint, GLenum, GLenum) 	# GL/glext.h:5910
PFNGLBINDMATERIALPARAMETEREXTPROC = CFUNCTYPE(GLuint, GLenum, GLenum) 	# GL/glext.h:5911
PFNGLBINDTEXGENPARAMETEREXTPROC = CFUNCTYPE(GLuint, GLenum, GLenum, GLenum) 	# GL/glext.h:5912
PFNGLBINDTEXTUREUNITPARAMETEREXTPROC = CFUNCTYPE(GLuint, GLenum, GLenum) 	# GL/glext.h:5913
PFNGLBINDPARAMETEREXTPROC = CFUNCTYPE(GLuint, GLenum) 	# GL/glext.h:5914
PFNGLISVARIANTENABLEDEXTPROC = CFUNCTYPE(GLboolean, GLuint, GLenum) 	# GL/glext.h:5915
PFNGLGETVARIANTBOOLEANVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLboolean)) 	# GL/glext.h:5916
PFNGLGETVARIANTINTEGERVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5917
PFNGLGETVARIANTFLOATVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5918
PFNGLGETVARIANTPOINTERVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:5919
PFNGLGETINVARIANTBOOLEANVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLboolean)) 	# GL/glext.h:5920
PFNGLGETINVARIANTINTEGERVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5921
PFNGLGETINVARIANTFLOATVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5922
PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLboolean)) 	# GL/glext.h:5923
PFNGLGETLOCALCONSTANTINTEGERVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5924
PFNGLGETLOCALCONSTANTFLOATVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5925
# ATI_vertex_streams (GL/glext.h:5928)
GL_ATI_vertex_streams = 1 	# GL/glext.h:5929
# GL/glext.h:5931
glVertexStream1sATI = _link_function('glVertexStream1sATI', None, [GLenum, GLshort], 'ATI_vertex_streams')

# GL/glext.h:5932
glVertexStream1svATI = _link_function('glVertexStream1svATI', None, [GLenum, POINTER(GLshort)], 'ATI_vertex_streams')

# GL/glext.h:5933
glVertexStream1iATI = _link_function('glVertexStream1iATI', None, [GLenum, GLint], 'ATI_vertex_streams')

# GL/glext.h:5934
glVertexStream1ivATI = _link_function('glVertexStream1ivATI', None, [GLenum, POINTER(GLint)], 'ATI_vertex_streams')

# GL/glext.h:5935
glVertexStream1fATI = _link_function('glVertexStream1fATI', None, [GLenum, GLfloat], 'ATI_vertex_streams')

# GL/glext.h:5936
glVertexStream1fvATI = _link_function('glVertexStream1fvATI', None, [GLenum, POINTER(GLfloat)], 'ATI_vertex_streams')

# GL/glext.h:5937
glVertexStream1dATI = _link_function('glVertexStream1dATI', None, [GLenum, GLdouble], 'ATI_vertex_streams')

# GL/glext.h:5938
glVertexStream1dvATI = _link_function('glVertexStream1dvATI', None, [GLenum, POINTER(GLdouble)], 'ATI_vertex_streams')

# GL/glext.h:5939
glVertexStream2sATI = _link_function('glVertexStream2sATI', None, [GLenum, GLshort, GLshort], 'ATI_vertex_streams')

# GL/glext.h:5940
glVertexStream2svATI = _link_function('glVertexStream2svATI', None, [GLenum, POINTER(GLshort)], 'ATI_vertex_streams')

# GL/glext.h:5941
glVertexStream2iATI = _link_function('glVertexStream2iATI', None, [GLenum, GLint, GLint], 'ATI_vertex_streams')

# GL/glext.h:5942
glVertexStream2ivATI = _link_function('glVertexStream2ivATI', None, [GLenum, POINTER(GLint)], 'ATI_vertex_streams')

# GL/glext.h:5943
glVertexStream2fATI = _link_function('glVertexStream2fATI', None, [GLenum, GLfloat, GLfloat], 'ATI_vertex_streams')

# GL/glext.h:5944
glVertexStream2fvATI = _link_function('glVertexStream2fvATI', None, [GLenum, POINTER(GLfloat)], 'ATI_vertex_streams')

# GL/glext.h:5945
glVertexStream2dATI = _link_function('glVertexStream2dATI', None, [GLenum, GLdouble, GLdouble], 'ATI_vertex_streams')

# GL/glext.h:5946
glVertexStream2dvATI = _link_function('glVertexStream2dvATI', None, [GLenum, POINTER(GLdouble)], 'ATI_vertex_streams')

# GL/glext.h:5947
glVertexStream3sATI = _link_function('glVertexStream3sATI', None, [GLenum, GLshort, GLshort, GLshort], 'ATI_vertex_streams')

# GL/glext.h:5948
glVertexStream3svATI = _link_function('glVertexStream3svATI', None, [GLenum, POINTER(GLshort)], 'ATI_vertex_streams')

# GL/glext.h:5949
glVertexStream3iATI = _link_function('glVertexStream3iATI', None, [GLenum, GLint, GLint, GLint], 'ATI_vertex_streams')

# GL/glext.h:5950
glVertexStream3ivATI = _link_function('glVertexStream3ivATI', None, [GLenum, POINTER(GLint)], 'ATI_vertex_streams')

# GL/glext.h:5951
glVertexStream3fATI = _link_function('glVertexStream3fATI', None, [GLenum, GLfloat, GLfloat, GLfloat], 'ATI_vertex_streams')

# GL/glext.h:5952
glVertexStream3fvATI = _link_function('glVertexStream3fvATI', None, [GLenum, POINTER(GLfloat)], 'ATI_vertex_streams')

# GL/glext.h:5953
glVertexStream3dATI = _link_function('glVertexStream3dATI', None, [GLenum, GLdouble, GLdouble, GLdouble], 'ATI_vertex_streams')

# GL/glext.h:5954
glVertexStream3dvATI = _link_function('glVertexStream3dvATI', None, [GLenum, POINTER(GLdouble)], 'ATI_vertex_streams')

# GL/glext.h:5955
glVertexStream4sATI = _link_function('glVertexStream4sATI', None, [GLenum, GLshort, GLshort, GLshort, GLshort], 'ATI_vertex_streams')

# GL/glext.h:5956
glVertexStream4svATI = _link_function('glVertexStream4svATI', None, [GLenum, POINTER(GLshort)], 'ATI_vertex_streams')

# GL/glext.h:5957
glVertexStream4iATI = _link_function('glVertexStream4iATI', None, [GLenum, GLint, GLint, GLint, GLint], 'ATI_vertex_streams')

# GL/glext.h:5958
glVertexStream4ivATI = _link_function('glVertexStream4ivATI', None, [GLenum, POINTER(GLint)], 'ATI_vertex_streams')

# GL/glext.h:5959
glVertexStream4fATI = _link_function('glVertexStream4fATI', None, [GLenum, GLfloat, GLfloat, GLfloat, GLfloat], 'ATI_vertex_streams')

# GL/glext.h:5960
glVertexStream4fvATI = _link_function('glVertexStream4fvATI', None, [GLenum, POINTER(GLfloat)], 'ATI_vertex_streams')

# GL/glext.h:5961
glVertexStream4dATI = _link_function('glVertexStream4dATI', None, [GLenum, GLdouble, GLdouble, GLdouble, GLdouble], 'ATI_vertex_streams')

# GL/glext.h:5962
glVertexStream4dvATI = _link_function('glVertexStream4dvATI', None, [GLenum, POINTER(GLdouble)], 'ATI_vertex_streams')

# GL/glext.h:5963
glNormalStream3bATI = _link_function('glNormalStream3bATI', None, [GLenum, GLbyte, GLbyte, GLbyte], 'ATI_vertex_streams')

# GL/glext.h:5964
glNormalStream3bvATI = _link_function('glNormalStream3bvATI', None, [GLenum, POINTER(GLbyte)], 'ATI_vertex_streams')

# GL/glext.h:5965
glNormalStream3sATI = _link_function('glNormalStream3sATI', None, [GLenum, GLshort, GLshort, GLshort], 'ATI_vertex_streams')

# GL/glext.h:5966
glNormalStream3svATI = _link_function('glNormalStream3svATI', None, [GLenum, POINTER(GLshort)], 'ATI_vertex_streams')

# GL/glext.h:5967
glNormalStream3iATI = _link_function('glNormalStream3iATI', None, [GLenum, GLint, GLint, GLint], 'ATI_vertex_streams')

# GL/glext.h:5968
glNormalStream3ivATI = _link_function('glNormalStream3ivATI', None, [GLenum, POINTER(GLint)], 'ATI_vertex_streams')

# GL/glext.h:5969
glNormalStream3fATI = _link_function('glNormalStream3fATI', None, [GLenum, GLfloat, GLfloat, GLfloat], 'ATI_vertex_streams')

# GL/glext.h:5970
glNormalStream3fvATI = _link_function('glNormalStream3fvATI', None, [GLenum, POINTER(GLfloat)], 'ATI_vertex_streams')

# GL/glext.h:5971
glNormalStream3dATI = _link_function('glNormalStream3dATI', None, [GLenum, GLdouble, GLdouble, GLdouble], 'ATI_vertex_streams')

# GL/glext.h:5972
glNormalStream3dvATI = _link_function('glNormalStream3dvATI', None, [GLenum, POINTER(GLdouble)], 'ATI_vertex_streams')

# GL/glext.h:5973
glClientActiveVertexStreamATI = _link_function('glClientActiveVertexStreamATI', None, [GLenum], 'ATI_vertex_streams')

# GL/glext.h:5974
glVertexBlendEnviATI = _link_function('glVertexBlendEnviATI', None, [GLenum, GLint], 'ATI_vertex_streams')

# GL/glext.h:5975
glVertexBlendEnvfATI = _link_function('glVertexBlendEnvfATI', None, [GLenum, GLfloat], 'ATI_vertex_streams')

PFNGLVERTEXSTREAM1SATIPROC = CFUNCTYPE(None, GLenum, GLshort) 	# GL/glext.h:5977
PFNGLVERTEXSTREAM1SVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:5978
PFNGLVERTEXSTREAM1IATIPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:5979
PFNGLVERTEXSTREAM1IVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:5980
PFNGLVERTEXSTREAM1FATIPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:5981
PFNGLVERTEXSTREAM1FVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5982
PFNGLVERTEXSTREAM1DATIPROC = CFUNCTYPE(None, GLenum, GLdouble) 	# GL/glext.h:5983
PFNGLVERTEXSTREAM1DVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:5984
PFNGLVERTEXSTREAM2SATIPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort) 	# GL/glext.h:5985
PFNGLVERTEXSTREAM2SVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:5986
PFNGLVERTEXSTREAM2IATIPROC = CFUNCTYPE(None, GLenum, GLint, GLint) 	# GL/glext.h:5987
PFNGLVERTEXSTREAM2IVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:5988
PFNGLVERTEXSTREAM2FATIPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat) 	# GL/glext.h:5989
PFNGLVERTEXSTREAM2FVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5990
PFNGLVERTEXSTREAM2DATIPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble) 	# GL/glext.h:5991
PFNGLVERTEXSTREAM2DVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:5992
PFNGLVERTEXSTREAM3SATIPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort, GLshort) 	# GL/glext.h:5993
PFNGLVERTEXSTREAM3SVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:5994
PFNGLVERTEXSTREAM3IATIPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint) 	# GL/glext.h:5995
PFNGLVERTEXSTREAM3IVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:5996
PFNGLVERTEXSTREAM3FATIPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5997
PFNGLVERTEXSTREAM3FVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5998
PFNGLVERTEXSTREAM3DATIPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:5999
PFNGLVERTEXSTREAM3DVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:6000
PFNGLVERTEXSTREAM4SATIPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort, GLshort, GLshort) 	# GL/glext.h:6001
PFNGLVERTEXSTREAM4SVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:6002
PFNGLVERTEXSTREAM4IATIPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint) 	# GL/glext.h:6003
PFNGLVERTEXSTREAM4IVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:6004
PFNGLVERTEXSTREAM4FATIPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:6005
PFNGLVERTEXSTREAM4FVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6006
PFNGLVERTEXSTREAM4DATIPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:6007
PFNGLVERTEXSTREAM4DVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:6008
PFNGLNORMALSTREAM3BATIPROC = CFUNCTYPE(None, GLenum, GLbyte, GLbyte, GLbyte) 	# GL/glext.h:6009
PFNGLNORMALSTREAM3BVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLbyte)) 	# GL/glext.h:6010
PFNGLNORMALSTREAM3SATIPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort, GLshort) 	# GL/glext.h:6011
PFNGLNORMALSTREAM3SVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:6012
PFNGLNORMALSTREAM3IATIPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint) 	# GL/glext.h:6013
PFNGLNORMALSTREAM3IVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:6014
PFNGLNORMALSTREAM3FATIPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:6015
PFNGLNORMALSTREAM3FVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6016
PFNGLNORMALSTREAM3DATIPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:6017
PFNGLNORMALSTREAM3DVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:6018
PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:6019
PFNGLVERTEXBLENDENVIATIPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:6020
PFNGLVERTEXBLENDENVFATIPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:6021
# ATI_element_array (GL/glext.h:6024)
GL_ATI_element_array = 1 	# GL/glext.h:6025
# GL/glext.h:6027
glElementPointerATI = _link_function('glElementPointerATI', None, [GLenum, POINTER(GLvoid)], 'ATI_element_array')

# GL/glext.h:6028
glDrawElementArrayATI = _link_function('glDrawElementArrayATI', None, [GLenum, GLsizei], 'ATI_element_array')

# GL/glext.h:6029
glDrawRangeElementArrayATI = _link_function('glDrawRangeElementArrayATI', None, [GLenum, GLuint, GLuint, GLsizei], 'ATI_element_array')

PFNGLELEMENTPOINTERATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLvoid)) 	# GL/glext.h:6031
PFNGLDRAWELEMENTARRAYATIPROC = CFUNCTYPE(None, GLenum, GLsizei) 	# GL/glext.h:6032
PFNGLDRAWRANGEELEMENTARRAYATIPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLsizei) 	# GL/glext.h:6033
# SUN_mesh_array (GL/glext.h:6036)
GL_SUN_mesh_array = 1 	# GL/glext.h:6037
# GL/glext.h:6039
glDrawMeshArraysSUN = _link_function('glDrawMeshArraysSUN', None, [GLenum, GLint, GLsizei, GLsizei], 'SUN_mesh_array')

PFNGLDRAWMESHARRAYSSUNPROC = CFUNCTYPE(None, GLenum, GLint, GLsizei, GLsizei) 	# GL/glext.h:6041
# SUN_slice_accum (GL/glext.h:6044)
GL_SUN_slice_accum = 1 	# GL/glext.h:6045
# NV_multisample_filter_hint (GL/glext.h:6048)
GL_NV_multisample_filter_hint = 1 	# GL/glext.h:6049
# NV_depth_clamp (GL/glext.h:6052)
GL_NV_depth_clamp = 1 	# GL/glext.h:6053
# NV_occlusion_query (GL/glext.h:6056)
GL_NV_occlusion_query = 1 	# GL/glext.h:6057
# GL/glext.h:6059
glGenOcclusionQueriesNV = _link_function('glGenOcclusionQueriesNV', None, [GLsizei, POINTER(GLuint)], 'NV_occlusion_query')

# GL/glext.h:6060
glDeleteOcclusionQueriesNV = _link_function('glDeleteOcclusionQueriesNV', None, [GLsizei, POINTER(GLuint)], 'NV_occlusion_query')

# GL/glext.h:6061
glIsOcclusionQueryNV = _link_function('glIsOcclusionQueryNV', GLboolean, [GLuint], 'NV_occlusion_query')

# GL/glext.h:6062
glBeginOcclusionQueryNV = _link_function('glBeginOcclusionQueryNV', None, [GLuint], 'NV_occlusion_query')

# GL/glext.h:6063
glEndOcclusionQueryNV = _link_function('glEndOcclusionQueryNV', None, [], 'NV_occlusion_query')

# GL/glext.h:6064
glGetOcclusionQueryivNV = _link_function('glGetOcclusionQueryivNV', None, [GLuint, GLenum, POINTER(GLint)], 'NV_occlusion_query')

# GL/glext.h:6065
glGetOcclusionQueryuivNV = _link_function('glGetOcclusionQueryuivNV', None, [GLuint, GLenum, POINTER(GLuint)], 'NV_occlusion_query')

PFNGLGENOCCLUSIONQUERIESNVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6067
PFNGLDELETEOCCLUSIONQUERIESNVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6068
PFNGLISOCCLUSIONQUERYNVPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:6069
PFNGLBEGINOCCLUSIONQUERYNVPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6070
PFNGLENDOCCLUSIONQUERYNVPROC = CFUNCTYPE(None) 	# GL/glext.h:6071
PFNGLGETOCCLUSIONQUERYIVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:6072
PFNGLGETOCCLUSIONQUERYUIVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLuint)) 	# GL/glext.h:6073
# NV_point_sprite (GL/glext.h:6076)
GL_NV_point_sprite = 1 	# GL/glext.h:6077
# GL/glext.h:6079
glPointParameteriNV = _link_function('glPointParameteriNV', None, [GLenum, GLint], 'NV_point_sprite')

# GL/glext.h:6080
glPointParameterivNV = _link_function('glPointParameterivNV', None, [GLenum, POINTER(GLint)], 'NV_point_sprite')

PFNGLPOINTPARAMETERINVPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:6082
PFNGLPOINTPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:6083
# NV_texture_shader3 (GL/glext.h:6086)
GL_NV_texture_shader3 = 1 	# GL/glext.h:6087
# NV_vertex_program1_1 (GL/glext.h:6090)
GL_NV_vertex_program1_1 = 1 	# GL/glext.h:6091
# EXT_shadow_funcs (GL/glext.h:6094)
GL_EXT_shadow_funcs = 1 	# GL/glext.h:6095
# EXT_stencil_two_side (GL/glext.h:6098)
GL_EXT_stencil_two_side = 1 	# GL/glext.h:6099
# GL/glext.h:6101
glActiveStencilFaceEXT = _link_function('glActiveStencilFaceEXT', None, [GLenum], 'EXT_stencil_two_side')

PFNGLACTIVESTENCILFACEEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:6103
# ATI_text_fragment_shader (GL/glext.h:6106)
GL_ATI_text_fragment_shader = 1 	# GL/glext.h:6107
# APPLE_client_storage (GL/glext.h:6110)
GL_APPLE_client_storage = 1 	# GL/glext.h:6111
# APPLE_element_array (GL/glext.h:6114)
GL_APPLE_element_array = 1 	# GL/glext.h:6115
# GL/glext.h:6117
glElementPointerAPPLE = _link_function('glElementPointerAPPLE', None, [GLenum, POINTER(GLvoid)], 'APPLE_element_array')

# GL/glext.h:6118
glDrawElementArrayAPPLE = _link_function('glDrawElementArrayAPPLE', None, [GLenum, GLint, GLsizei], 'APPLE_element_array')

# GL/glext.h:6119
glDrawRangeElementArrayAPPLE = _link_function('glDrawRangeElementArrayAPPLE', None, [GLenum, GLuint, GLuint, GLint, GLsizei], 'APPLE_element_array')

# GL/glext.h:6120
glMultiDrawElementArrayAPPLE = _link_function('glMultiDrawElementArrayAPPLE', None, [GLenum, POINTER(GLint), POINTER(GLsizei), GLsizei], 'APPLE_element_array')

# GL/glext.h:6121
glMultiDrawRangeElementArrayAPPLE = _link_function('glMultiDrawRangeElementArrayAPPLE', None, [GLenum, GLuint, GLuint, POINTER(GLint), POINTER(GLsizei), GLsizei], 'APPLE_element_array')

PFNGLELEMENTPOINTERAPPLEPROC = CFUNCTYPE(None, GLenum, POINTER(GLvoid)) 	# GL/glext.h:6123
PFNGLDRAWELEMENTARRAYAPPLEPROC = CFUNCTYPE(None, GLenum, GLint, GLsizei) 	# GL/glext.h:6124
PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLint, GLsizei) 	# GL/glext.h:6125
PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC = CFUNCTYPE(None, GLenum, POINTER(GLint), POINTER(GLsizei), GLsizei) 	# GL/glext.h:6126
PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, POINTER(GLint), POINTER(GLsizei), GLsizei) 	# GL/glext.h:6127
# APPLE_fence (GL/glext.h:6130)
GL_APPLE_fence = 1 	# GL/glext.h:6131
# GL/glext.h:6133
glGenFencesAPPLE = _link_function('glGenFencesAPPLE', None, [GLsizei, POINTER(GLuint)], 'APPLE_fence')

# GL/glext.h:6134
glDeleteFencesAPPLE = _link_function('glDeleteFencesAPPLE', None, [GLsizei, POINTER(GLuint)], 'APPLE_fence')

# GL/glext.h:6135
glSetFenceAPPLE = _link_function('glSetFenceAPPLE', None, [GLuint], 'APPLE_fence')

# GL/glext.h:6136
glIsFenceAPPLE = _link_function('glIsFenceAPPLE', GLboolean, [GLuint], 'APPLE_fence')

# GL/glext.h:6137
glTestFenceAPPLE = _link_function('glTestFenceAPPLE', GLboolean, [GLuint], 'APPLE_fence')

# GL/glext.h:6138
glFinishFenceAPPLE = _link_function('glFinishFenceAPPLE', None, [GLuint], 'APPLE_fence')

# GL/glext.h:6139
glTestObjectAPPLE = _link_function('glTestObjectAPPLE', GLboolean, [GLenum, GLuint], 'APPLE_fence')

# GL/glext.h:6140
glFinishObjectAPPLE = _link_function('glFinishObjectAPPLE', None, [GLenum, GLint], 'APPLE_fence')

PFNGLGENFENCESAPPLEPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6142
PFNGLDELETEFENCESAPPLEPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6143
PFNGLSETFENCEAPPLEPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6144
PFNGLISFENCEAPPLEPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:6145
PFNGLTESTFENCEAPPLEPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:6146
PFNGLFINISHFENCEAPPLEPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6147
PFNGLTESTOBJECTAPPLEPROC = CFUNCTYPE(GLboolean, GLenum, GLuint) 	# GL/glext.h:6148
PFNGLFINISHOBJECTAPPLEPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:6149
# APPLE_vertex_array_object (GL/glext.h:6152)
GL_APPLE_vertex_array_object = 1 	# GL/glext.h:6153
# GL/glext.h:6155
glBindVertexArrayAPPLE = _link_function('glBindVertexArrayAPPLE', None, [GLuint], 'APPLE_vertex_array_object')

# GL/glext.h:6156
glDeleteVertexArraysAPPLE = _link_function('glDeleteVertexArraysAPPLE', None, [GLsizei, POINTER(GLuint)], 'APPLE_vertex_array_object')

# GL/glext.h:6157
glGenVertexArraysAPPLE = _link_function('glGenVertexArraysAPPLE', None, [GLsizei, POINTER(GLuint)], 'APPLE_vertex_array_object')

# GL/glext.h:6158
glIsVertexArrayAPPLE = _link_function('glIsVertexArrayAPPLE', GLboolean, [GLuint], 'APPLE_vertex_array_object')

PFNGLBINDVERTEXARRAYAPPLEPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6160
PFNGLDELETEVERTEXARRAYSAPPLEPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6161
PFNGLGENVERTEXARRAYSAPPLEPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6162
PFNGLISVERTEXARRAYAPPLEPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:6163
# APPLE_vertex_array_range (GL/glext.h:6166)
GL_APPLE_vertex_array_range = 1 	# GL/glext.h:6167
# GL/glext.h:6169
glVertexArrayRangeAPPLE = _link_function('glVertexArrayRangeAPPLE', None, [GLsizei, POINTER(GLvoid)], 'APPLE_vertex_array_range')

# GL/glext.h:6170
glFlushVertexArrayRangeAPPLE = _link_function('glFlushVertexArrayRangeAPPLE', None, [GLsizei, POINTER(GLvoid)], 'APPLE_vertex_array_range')

# GL/glext.h:6171
glVertexArrayParameteriAPPLE = _link_function('glVertexArrayParameteriAPPLE', None, [GLenum, GLint], 'APPLE_vertex_array_range')

PFNGLVERTEXARRAYRANGEAPPLEPROC = CFUNCTYPE(None, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:6173
PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC = CFUNCTYPE(None, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:6174
PFNGLVERTEXARRAYPARAMETERIAPPLEPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:6175
# APPLE_ycbcr_422 (GL/glext.h:6178)
GL_APPLE_ycbcr_422 = 1 	# GL/glext.h:6179
# S3_s3tc (GL/glext.h:6182)
GL_S3_s3tc = 1 	# GL/glext.h:6183
# ATI_draw_buffers (GL/glext.h:6186)
GL_ATI_draw_buffers = 1 	# GL/glext.h:6187
# GL/glext.h:6189
glDrawBuffersATI = _link_function('glDrawBuffersATI', None, [GLsizei, POINTER(GLenum)], 'ATI_draw_buffers')

PFNGLDRAWBUFFERSATIPROC = CFUNCTYPE(None, GLsizei, POINTER(GLenum)) 	# GL/glext.h:6191
# ATI_pixel_format_float (GL/glext.h:6194)
GL_ATI_pixel_format_float = 1 	# GL/glext.h:6195
# ATI_texture_env_combine3 (GL/glext.h:6201)
GL_ATI_texture_env_combine3 = 1 	# GL/glext.h:6202
# ATI_texture_float (GL/glext.h:6205)
GL_ATI_texture_float = 1 	# GL/glext.h:6206
# NV_float_buffer (GL/glext.h:6209)
GL_NV_float_buffer = 1 	# GL/glext.h:6210
# NV_fragment_program (GL/glext.h:6213)
GL_NV_fragment_program = 1 	# GL/glext.h:6214
# GL/glext.h:6217
glProgramNamedParameter4fNV = _link_function('glProgramNamedParameter4fNV', None, [GLuint, GLsizei, POINTER(GLubyte), GLfloat, GLfloat, GLfloat, GLfloat], 'NV_fragment_program')

# GL/glext.h:6218
glProgramNamedParameter4dNV = _link_function('glProgramNamedParameter4dNV', None, [GLuint, GLsizei, POINTER(GLubyte), GLdouble, GLdouble, GLdouble, GLdouble], 'NV_fragment_program')

# GL/glext.h:6219
glProgramNamedParameter4fvNV = _link_function('glProgramNamedParameter4fvNV', None, [GLuint, GLsizei, POINTER(GLubyte), POINTER(GLfloat)], 'NV_fragment_program')

# GL/glext.h:6220
glProgramNamedParameter4dvNV = _link_function('glProgramNamedParameter4dvNV', None, [GLuint, GLsizei, POINTER(GLubyte), POINTER(GLdouble)], 'NV_fragment_program')

# GL/glext.h:6221
glGetProgramNamedParameterfvNV = _link_function('glGetProgramNamedParameterfvNV', None, [GLuint, GLsizei, POINTER(GLubyte), POINTER(GLfloat)], 'NV_fragment_program')

# GL/glext.h:6222
glGetProgramNamedParameterdvNV = _link_function('glGetProgramNamedParameterdvNV', None, [GLuint, GLsizei, POINTER(GLubyte), POINTER(GLdouble)], 'NV_fragment_program')

PFNGLPROGRAMNAMEDPARAMETER4FNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLubyte), GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:6224
PFNGLPROGRAMNAMEDPARAMETER4DNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLubyte), GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:6225
PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLubyte), POINTER(GLfloat)) 	# GL/glext.h:6226
PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLubyte), POINTER(GLdouble)) 	# GL/glext.h:6227
PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLubyte), POINTER(GLfloat)) 	# GL/glext.h:6228
PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLubyte), POINTER(GLdouble)) 	# GL/glext.h:6229
# NV_half_float (GL/glext.h:6232)
GL_NV_half_float = 1 	# GL/glext.h:6233
# GL/glext.h:6235
glVertex2hNV = _link_function('glVertex2hNV', None, [GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6236
glVertex2hvNV = _link_function('glVertex2hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6237
glVertex3hNV = _link_function('glVertex3hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6238
glVertex3hvNV = _link_function('glVertex3hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6239
glVertex4hNV = _link_function('glVertex4hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6240
glVertex4hvNV = _link_function('glVertex4hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6241
glNormal3hNV = _link_function('glNormal3hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6242
glNormal3hvNV = _link_function('glNormal3hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6243
glColor3hNV = _link_function('glColor3hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6244
glColor3hvNV = _link_function('glColor3hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6245
glColor4hNV = _link_function('glColor4hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6246
glColor4hvNV = _link_function('glColor4hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6247
glTexCoord1hNV = _link_function('glTexCoord1hNV', None, [GLhalfNV], 'NV_half_float')

# GL/glext.h:6248
glTexCoord1hvNV = _link_function('glTexCoord1hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6249
glTexCoord2hNV = _link_function('glTexCoord2hNV', None, [GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6250
glTexCoord2hvNV = _link_function('glTexCoord2hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6251
glTexCoord3hNV = _link_function('glTexCoord3hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6252
glTexCoord3hvNV = _link_function('glTexCoord3hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6253
glTexCoord4hNV = _link_function('glTexCoord4hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6254
glTexCoord4hvNV = _link_function('glTexCoord4hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6255
glMultiTexCoord1hNV = _link_function('glMultiTexCoord1hNV', None, [GLenum, GLhalfNV], 'NV_half_float')

# GL/glext.h:6256
glMultiTexCoord1hvNV = _link_function('glMultiTexCoord1hvNV', None, [GLenum, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6257
glMultiTexCoord2hNV = _link_function('glMultiTexCoord2hNV', None, [GLenum, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6258
glMultiTexCoord2hvNV = _link_function('glMultiTexCoord2hvNV', None, [GLenum, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6259
glMultiTexCoord3hNV = _link_function('glMultiTexCoord3hNV', None, [GLenum, GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6260
glMultiTexCoord3hvNV = _link_function('glMultiTexCoord3hvNV', None, [GLenum, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6261
glMultiTexCoord4hNV = _link_function('glMultiTexCoord4hNV', None, [GLenum, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6262
glMultiTexCoord4hvNV = _link_function('glMultiTexCoord4hvNV', None, [GLenum, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6263
glFogCoordhNV = _link_function('glFogCoordhNV', None, [GLhalfNV], 'NV_half_float')

# GL/glext.h:6264
glFogCoordhvNV = _link_function('glFogCoordhvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6265
glSecondaryColor3hNV = _link_function('glSecondaryColor3hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6266
glSecondaryColor3hvNV = _link_function('glSecondaryColor3hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6267
glVertexWeighthNV = _link_function('glVertexWeighthNV', None, [GLhalfNV], 'NV_half_float')

# GL/glext.h:6268
glVertexWeighthvNV = _link_function('glVertexWeighthvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6269
glVertexAttrib1hNV = _link_function('glVertexAttrib1hNV', None, [GLuint, GLhalfNV], 'NV_half_float')

# GL/glext.h:6270
glVertexAttrib1hvNV = _link_function('glVertexAttrib1hvNV', None, [GLuint, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6271
glVertexAttrib2hNV = _link_function('glVertexAttrib2hNV', None, [GLuint, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6272
glVertexAttrib2hvNV = _link_function('glVertexAttrib2hvNV', None, [GLuint, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6273
glVertexAttrib3hNV = _link_function('glVertexAttrib3hNV', None, [GLuint, GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6274
glVertexAttrib3hvNV = _link_function('glVertexAttrib3hvNV', None, [GLuint, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6275
glVertexAttrib4hNV = _link_function('glVertexAttrib4hNV', None, [GLuint, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6276
glVertexAttrib4hvNV = _link_function('glVertexAttrib4hvNV', None, [GLuint, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6277
glVertexAttribs1hvNV = _link_function('glVertexAttribs1hvNV', None, [GLuint, GLsizei, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6278
glVertexAttribs2hvNV = _link_function('glVertexAttribs2hvNV', None, [GLuint, GLsizei, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6279
glVertexAttribs3hvNV = _link_function('glVertexAttribs3hvNV', None, [GLuint, GLsizei, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6280
glVertexAttribs4hvNV = _link_function('glVertexAttribs4hvNV', None, [GLuint, GLsizei, POINTER(GLhalfNV)], 'NV_half_float')

PFNGLVERTEX2HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV) 	# GL/glext.h:6282
PFNGLVERTEX2HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6283
PFNGLVERTEX3HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6284
PFNGLVERTEX3HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6285
PFNGLVERTEX4HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6286
PFNGLVERTEX4HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6287
PFNGLNORMAL3HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6288
PFNGLNORMAL3HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6289
PFNGLCOLOR3HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6290
PFNGLCOLOR3HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6291
PFNGLCOLOR4HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6292
PFNGLCOLOR4HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6293
PFNGLTEXCOORD1HNVPROC = CFUNCTYPE(None, GLhalfNV) 	# GL/glext.h:6294
PFNGLTEXCOORD1HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6295
PFNGLTEXCOORD2HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV) 	# GL/glext.h:6296
PFNGLTEXCOORD2HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6297
PFNGLTEXCOORD3HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6298
PFNGLTEXCOORD3HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6299
PFNGLTEXCOORD4HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6300
PFNGLTEXCOORD4HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6301
PFNGLMULTITEXCOORD1HNVPROC = CFUNCTYPE(None, GLenum, GLhalfNV) 	# GL/glext.h:6302
PFNGLMULTITEXCOORD1HVNVPROC = CFUNCTYPE(None, GLenum, POINTER(GLhalfNV)) 	# GL/glext.h:6303
PFNGLMULTITEXCOORD2HNVPROC = CFUNCTYPE(None, GLenum, GLhalfNV, GLhalfNV) 	# GL/glext.h:6304
PFNGLMULTITEXCOORD2HVNVPROC = CFUNCTYPE(None, GLenum, POINTER(GLhalfNV)) 	# GL/glext.h:6305
PFNGLMULTITEXCOORD3HNVPROC = CFUNCTYPE(None, GLenum, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6306
PFNGLMULTITEXCOORD3HVNVPROC = CFUNCTYPE(None, GLenum, POINTER(GLhalfNV)) 	# GL/glext.h:6307
PFNGLMULTITEXCOORD4HNVPROC = CFUNCTYPE(None, GLenum, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6308
PFNGLMULTITEXCOORD4HVNVPROC = CFUNCTYPE(None, GLenum, POINTER(GLhalfNV)) 	# GL/glext.h:6309
PFNGLFOGCOORDHNVPROC = CFUNCTYPE(None, GLhalfNV) 	# GL/glext.h:6310
PFNGLFOGCOORDHVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6311
PFNGLSECONDARYCOLOR3HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6312
PFNGLSECONDARYCOLOR3HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6313
PFNGLVERTEXWEIGHTHNVPROC = CFUNCTYPE(None, GLhalfNV) 	# GL/glext.h:6314
PFNGLVERTEXWEIGHTHVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6315
PFNGLVERTEXATTRIB1HNVPROC = CFUNCTYPE(None, GLuint, GLhalfNV) 	# GL/glext.h:6316
PFNGLVERTEXATTRIB1HVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLhalfNV)) 	# GL/glext.h:6317
PFNGLVERTEXATTRIB2HNVPROC = CFUNCTYPE(None, GLuint, GLhalfNV, GLhalfNV) 	# GL/glext.h:6318
PFNGLVERTEXATTRIB2HVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLhalfNV)) 	# GL/glext.h:6319
PFNGLVERTEXATTRIB3HNVPROC = CFUNCTYPE(None, GLuint, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6320
PFNGLVERTEXATTRIB3HVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLhalfNV)) 	# GL/glext.h:6321
PFNGLVERTEXATTRIB4HNVPROC = CFUNCTYPE(None, GLuint, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6322
PFNGLVERTEXATTRIB4HVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLhalfNV)) 	# GL/glext.h:6323
PFNGLVERTEXATTRIBS1HVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLhalfNV)) 	# GL/glext.h:6324
PFNGLVERTEXATTRIBS2HVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLhalfNV)) 	# GL/glext.h:6325
PFNGLVERTEXATTRIBS3HVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLhalfNV)) 	# GL/glext.h:6326
PFNGLVERTEXATTRIBS4HVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLhalfNV)) 	# GL/glext.h:6327
# NV_pixel_data_range (GL/glext.h:6330)
GL_NV_pixel_data_range = 1 	# GL/glext.h:6331
# GL/glext.h:6333
glPixelDataRangeNV = _link_function('glPixelDataRangeNV', None, [GLenum, GLsizei, POINTER(GLvoid)], 'NV_pixel_data_range')

# GL/glext.h:6334
glFlushPixelDataRangeNV = _link_function('glFlushPixelDataRangeNV', None, [GLenum], 'NV_pixel_data_range')

PFNGLPIXELDATARANGENVPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:6336
PFNGLFLUSHPIXELDATARANGENVPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:6337
# NV_primitive_restart (GL/glext.h:6340)
GL_NV_primitive_restart = 1 	# GL/glext.h:6341
# GL/glext.h:6343
glPrimitiveRestartNV = _link_function('glPrimitiveRestartNV', None, [], 'NV_primitive_restart')

# GL/glext.h:6344
glPrimitiveRestartIndexNV = _link_function('glPrimitiveRestartIndexNV', None, [GLuint], 'NV_primitive_restart')

PFNGLPRIMITIVERESTARTNVPROC = CFUNCTYPE(None) 	# GL/glext.h:6346
PFNGLPRIMITIVERESTARTINDEXNVPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6347
# NV_texture_expand_normal (GL/glext.h:6350)
GL_NV_texture_expand_normal = 1 	# GL/glext.h:6351
# NV_vertex_program2 (GL/glext.h:6354)
GL_NV_vertex_program2 = 1 	# GL/glext.h:6355
# ATI_map_object_buffer (GL/glext.h:6358)
GL_ATI_map_object_buffer = 1 	# GL/glext.h:6359
# GL/glext.h:6361
glMapObjectBufferATI = _link_function('glMapObjectBufferATI', POINTER(GLvoid), [GLuint], 'ATI_map_object_buffer')

# GL/glext.h:6362
glUnmapObjectBufferATI = _link_function('glUnmapObjectBufferATI', None, [GLuint], 'ATI_map_object_buffer')

PFNGLMAPOBJECTBUFFERATIPROC = CFUNCTYPE(POINTER(GLvoid), GLuint) 	# GL/glext.h:6364
PFNGLUNMAPOBJECTBUFFERATIPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6365
# ATI_separate_stencil (GL/glext.h:6368)
GL_ATI_separate_stencil = 1 	# GL/glext.h:6369
# GL/glext.h:6371
glStencilOpSeparateATI = _link_function('glStencilOpSeparateATI', None, [GLenum, GLenum, GLenum, GLenum], 'ATI_separate_stencil')

# GL/glext.h:6372
glStencilFuncSeparateATI = _link_function('glStencilFuncSeparateATI', None, [GLenum, GLenum, GLint, GLuint], 'ATI_separate_stencil')

PFNGLSTENCILOPSEPARATEATIPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:6374
PFNGLSTENCILFUNCSEPARATEATIPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLuint) 	# GL/glext.h:6375
# ATI_vertex_attrib_array_object (GL/glext.h:6378)
GL_ATI_vertex_attrib_array_object = 1 	# GL/glext.h:6379
# GL/glext.h:6381
glVertexAttribArrayObjectATI = _link_function('glVertexAttribArrayObjectATI', None, [GLuint, GLint, GLenum, GLboolean, GLsizei, GLuint, GLuint], 'ATI_vertex_attrib_array_object')

# GL/glext.h:6382
glGetVertexAttribArrayObjectfvATI = _link_function('glGetVertexAttribArrayObjectfvATI', None, [GLuint, GLenum, POINTER(GLfloat)], 'ATI_vertex_attrib_array_object')

# GL/glext.h:6383
glGetVertexAttribArrayObjectivATI = _link_function('glGetVertexAttribArrayObjectivATI', None, [GLuint, GLenum, POINTER(GLint)], 'ATI_vertex_attrib_array_object')

PFNGLVERTEXATTRIBARRAYOBJECTATIPROC = CFUNCTYPE(None, GLuint, GLint, GLenum, GLboolean, GLsizei, GLuint, GLuint) 	# GL/glext.h:6385
PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6386
PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:6387
# OES_read_format (GL/glext.h:6390)
GL_OES_read_format = 1 	# GL/glext.h:6391
# EXT_depth_bounds_test (GL/glext.h:6394)
GL_EXT_depth_bounds_test = 1 	# GL/glext.h:6395
GLclampd = c_double 	# /usr/include/GL/gl.h:66
# GL/glext.h:6397
glDepthBoundsEXT = _link_function('glDepthBoundsEXT', None, [GLclampd, GLclampd], 'EXT_depth_bounds_test')

PFNGLDEPTHBOUNDSEXTPROC = CFUNCTYPE(None, GLclampd, GLclampd) 	# GL/glext.h:6399
# EXT_texture_mirror_clamp (GL/glext.h:6402)
GL_EXT_texture_mirror_clamp = 1 	# GL/glext.h:6403
# EXT_blend_equation_separate (GL/glext.h:6406)
GL_EXT_blend_equation_separate = 1 	# GL/glext.h:6407
# GL/glext.h:6409
glBlendEquationSeparateEXT = _link_function('glBlendEquationSeparateEXT', None, [GLenum, GLenum], 'EXT_blend_equation_separate')

PFNGLBLENDEQUATIONSEPARATEEXTPROC = CFUNCTYPE(None, GLenum, GLenum) 	# GL/glext.h:6411
# MESA_pack_invert (GL/glext.h:6414)
GL_MESA_pack_invert = 1 	# GL/glext.h:6415
# MESA_ycbcr_texture (GL/glext.h:6418)
GL_MESA_ycbcr_texture = 1 	# GL/glext.h:6419
# EXT_pixel_buffer_object (GL/glext.h:6422)
GL_EXT_pixel_buffer_object = 1 	# GL/glext.h:6423
# NV_fragment_program_option (GL/glext.h:6426)
GL_NV_fragment_program_option = 1 	# GL/glext.h:6427
# NV_fragment_program2 (GL/glext.h:6430)
GL_NV_fragment_program2 = 1 	# GL/glext.h:6431
# NV_vertex_program2_option (GL/glext.h:6434)
GL_NV_vertex_program2_option = 1 	# GL/glext.h:6435
# NV_vertex_program3 (GL/glext.h:6438)
GL_NV_vertex_program3 = 1 	# GL/glext.h:6439
# EXT_framebuffer_object (GL/glext.h:6442)
GL_EXT_framebuffer_object = 1 	# GL/glext.h:6443
# GL/glext.h:6445
glIsRenderbufferEXT = _link_function('glIsRenderbufferEXT', GLboolean, [GLuint], 'EXT_framebuffer_object')

# GL/glext.h:6446
glBindRenderbufferEXT = _link_function('glBindRenderbufferEXT', None, [GLenum, GLuint], 'EXT_framebuffer_object')

# GL/glext.h:6447
glDeleteRenderbuffersEXT = _link_function('glDeleteRenderbuffersEXT', None, [GLsizei, POINTER(GLuint)], 'EXT_framebuffer_object')

# GL/glext.h:6448
glGenRenderbuffersEXT = _link_function('glGenRenderbuffersEXT', None, [GLsizei, POINTER(GLuint)], 'EXT_framebuffer_object')

# GL/glext.h:6449
glRenderbufferStorageEXT = _link_function('glRenderbufferStorageEXT', None, [GLenum, GLenum, GLsizei, GLsizei], 'EXT_framebuffer_object')

# GL/glext.h:6450
glGetRenderbufferParameterivEXT = _link_function('glGetRenderbufferParameterivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_framebuffer_object')

# GL/glext.h:6451
glIsFramebufferEXT = _link_function('glIsFramebufferEXT', GLboolean, [GLuint], 'EXT_framebuffer_object')

# GL/glext.h:6452
glBindFramebufferEXT = _link_function('glBindFramebufferEXT', None, [GLenum, GLuint], 'EXT_framebuffer_object')

# GL/glext.h:6453
glDeleteFramebuffersEXT = _link_function('glDeleteFramebuffersEXT', None, [GLsizei, POINTER(GLuint)], 'EXT_framebuffer_object')

# GL/glext.h:6454
glGenFramebuffersEXT = _link_function('glGenFramebuffersEXT', None, [GLsizei, POINTER(GLuint)], 'EXT_framebuffer_object')

# GL/glext.h:6455
glCheckFramebufferStatusEXT = _link_function('glCheckFramebufferStatusEXT', GLenum, [GLenum], 'EXT_framebuffer_object')

# GL/glext.h:6456
glFramebufferTexture1DEXT = _link_function('glFramebufferTexture1DEXT', None, [GLenum, GLenum, GLenum, GLuint, GLint], 'EXT_framebuffer_object')

# GL/glext.h:6457
glFramebufferTexture2DEXT = _link_function('glFramebufferTexture2DEXT', None, [GLenum, GLenum, GLenum, GLuint, GLint], 'EXT_framebuffer_object')

# GL/glext.h:6458
glFramebufferTexture3DEXT = _link_function('glFramebufferTexture3DEXT', None, [GLenum, GLenum, GLenum, GLuint, GLint, GLint], 'EXT_framebuffer_object')

# GL/glext.h:6459
glFramebufferRenderbufferEXT = _link_function('glFramebufferRenderbufferEXT', None, [GLenum, GLenum, GLenum, GLuint], 'EXT_framebuffer_object')

# GL/glext.h:6460
glGetFramebufferAttachmentParameterivEXT = _link_function('glGetFramebufferAttachmentParameterivEXT', None, [GLenum, GLenum, GLenum, POINTER(GLint)], 'EXT_framebuffer_object')

# GL/glext.h:6461
glGenerateMipmapEXT = _link_function('glGenerateMipmapEXT', None, [GLenum], 'EXT_framebuffer_object')

PFNGLISRENDERBUFFEREXTPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:6463
PFNGLBINDRENDERBUFFEREXTPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:6464
PFNGLDELETERENDERBUFFERSEXTPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6465
PFNGLGENRENDERBUFFERSEXTPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6466
PFNGLRENDERBUFFERSTORAGEEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLsizei) 	# GL/glext.h:6467
PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:6468
PFNGLISFRAMEBUFFEREXTPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:6469
PFNGLBINDFRAMEBUFFEREXTPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:6470
PFNGLDELETEFRAMEBUFFERSEXTPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6471
PFNGLGENFRAMEBUFFERSEXTPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6472
PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC = CFUNCTYPE(GLenum, GLenum) 	# GL/glext.h:6473
PFNGLFRAMEBUFFERTEXTURE1DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLuint, GLint) 	# GL/glext.h:6474
PFNGLFRAMEBUFFERTEXTURE2DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLuint, GLint) 	# GL/glext.h:6475
PFNGLFRAMEBUFFERTEXTURE3DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLuint, GLint, GLint) 	# GL/glext.h:6476
PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLuint) 	# GL/glext.h:6477
PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:6478
PFNGLGENERATEMIPMAPEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:6479
# GREMEDY_string_marker (GL/glext.h:6482)
GL_GREMEDY_string_marker = 1 	# GL/glext.h:6483
# GL/glext.h:6485
glStringMarkerGREMEDY = _link_function('glStringMarkerGREMEDY', None, [GLsizei, POINTER(GLvoid)], 'GREMEDY_string_marker')

PFNGLSTRINGMARKERGREMEDYPROC = CFUNCTYPE(None, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:6487
# GLEXT_LEGACY (/usr/include/GL/gl.h:1633)

__all__ = ['GL_GLEXT_VERSION', 'GL_UNSIGNED_BYTE_3_3_2',
'GL_UNSIGNED_SHORT_4_4_4_4', 'GL_UNSIGNED_SHORT_5_5_5_1',
'GL_UNSIGNED_INT_8_8_8_8', 'GL_UNSIGNED_INT_10_10_10_2', 'GL_RESCALE_NORMAL',
'GL_TEXTURE_BINDING_3D', 'GL_PACK_SKIP_IMAGES', 'GL_PACK_IMAGE_HEIGHT',
'GL_UNPACK_SKIP_IMAGES', 'GL_UNPACK_IMAGE_HEIGHT', 'GL_TEXTURE_3D',
'GL_PROXY_TEXTURE_3D', 'GL_TEXTURE_DEPTH', 'GL_TEXTURE_WRAP_R',
'GL_MAX_3D_TEXTURE_SIZE', 'GL_UNSIGNED_BYTE_2_3_3_REV',
'GL_UNSIGNED_SHORT_5_6_5', 'GL_UNSIGNED_SHORT_5_6_5_REV',
'GL_UNSIGNED_SHORT_4_4_4_4_REV', 'GL_UNSIGNED_SHORT_1_5_5_5_REV',
'GL_UNSIGNED_INT_8_8_8_8_REV', 'GL_UNSIGNED_INT_2_10_10_10_REV', 'GL_BGR',
'GL_BGRA', 'GL_MAX_ELEMENTS_VERTICES', 'GL_MAX_ELEMENTS_INDICES',
'GL_CLAMP_TO_EDGE', 'GL_TEXTURE_MIN_LOD', 'GL_TEXTURE_MAX_LOD',
'GL_TEXTURE_BASE_LEVEL', 'GL_TEXTURE_MAX_LEVEL',
'GL_LIGHT_MODEL_COLOR_CONTROL', 'GL_SINGLE_COLOR',
'GL_SEPARATE_SPECULAR_COLOR', 'GL_SMOOTH_POINT_SIZE_RANGE',
'GL_SMOOTH_POINT_SIZE_GRANULARITY', 'GL_SMOOTH_LINE_WIDTH_RANGE',
'GL_SMOOTH_LINE_WIDTH_GRANULARITY', 'GL_ALIASED_POINT_SIZE_RANGE',
'GL_ALIASED_LINE_WIDTH_RANGE', 'GL_CONSTANT_COLOR',
'GL_ONE_MINUS_CONSTANT_COLOR', 'GL_CONSTANT_ALPHA',
'GL_ONE_MINUS_CONSTANT_ALPHA', 'GL_BLEND_COLOR', 'GL_FUNC_ADD', 'GL_MIN',
'GL_MAX', 'GL_BLEND_EQUATION', 'GL_FUNC_SUBTRACT', 'GL_FUNC_REVERSE_SUBTRACT',
'GL_CONVOLUTION_1D', 'GL_CONVOLUTION_2D', 'GL_SEPARABLE_2D',
'GL_CONVOLUTION_BORDER_MODE', 'GL_CONVOLUTION_FILTER_SCALE',
'GL_CONVOLUTION_FILTER_BIAS', 'GL_REDUCE', 'GL_CONVOLUTION_FORMAT',
'GL_CONVOLUTION_WIDTH', 'GL_CONVOLUTION_HEIGHT', 'GL_MAX_CONVOLUTION_WIDTH',
'GL_MAX_CONVOLUTION_HEIGHT', 'GL_POST_CONVOLUTION_RED_SCALE',
'GL_POST_CONVOLUTION_GREEN_SCALE', 'GL_POST_CONVOLUTION_BLUE_SCALE',
'GL_POST_CONVOLUTION_ALPHA_SCALE', 'GL_POST_CONVOLUTION_RED_BIAS',
'GL_POST_CONVOLUTION_GREEN_BIAS', 'GL_POST_CONVOLUTION_BLUE_BIAS',
'GL_POST_CONVOLUTION_ALPHA_BIAS', 'GL_HISTOGRAM', 'GL_PROXY_HISTOGRAM',
'GL_HISTOGRAM_WIDTH', 'GL_HISTOGRAM_FORMAT', 'GL_HISTOGRAM_RED_SIZE',
'GL_HISTOGRAM_GREEN_SIZE', 'GL_HISTOGRAM_BLUE_SIZE',
'GL_HISTOGRAM_ALPHA_SIZE', 'GL_HISTOGRAM_LUMINANCE_SIZE', 'GL_HISTOGRAM_SINK',
'GL_MINMAX', 'GL_MINMAX_FORMAT', 'GL_MINMAX_SINK', 'GL_TABLE_TOO_LARGE',
'GL_COLOR_MATRIX', 'GL_COLOR_MATRIX_STACK_DEPTH',
'GL_MAX_COLOR_MATRIX_STACK_DEPTH', 'GL_POST_COLOR_MATRIX_RED_SCALE',
'GL_POST_COLOR_MATRIX_GREEN_SCALE', 'GL_POST_COLOR_MATRIX_BLUE_SCALE',
'GL_POST_COLOR_MATRIX_ALPHA_SCALE', 'GL_POST_COLOR_MATRIX_RED_BIAS',
'GL_POST_COLOR_MATRIX_GREEN_BIAS', 'GL_POST_COLOR_MATRIX_BLUE_BIAS',
'GL_POST_COLOR_MATRIX_ALPHA_BIAS', 'GL_COLOR_TABLE',
'GL_POST_CONVOLUTION_COLOR_TABLE', 'GL_POST_COLOR_MATRIX_COLOR_TABLE',
'GL_PROXY_COLOR_TABLE', 'GL_PROXY_POST_CONVOLUTION_COLOR_TABLE',
'GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE', 'GL_COLOR_TABLE_SCALE',
'GL_COLOR_TABLE_BIAS', 'GL_COLOR_TABLE_FORMAT', 'GL_COLOR_TABLE_WIDTH',
'GL_COLOR_TABLE_RED_SIZE', 'GL_COLOR_TABLE_GREEN_SIZE',
'GL_COLOR_TABLE_BLUE_SIZE', 'GL_COLOR_TABLE_ALPHA_SIZE',
'GL_COLOR_TABLE_LUMINANCE_SIZE', 'GL_COLOR_TABLE_INTENSITY_SIZE',
'GL_CONSTANT_BORDER', 'GL_REPLICATE_BORDER', 'GL_CONVOLUTION_BORDER_COLOR',
'GL_TEXTURE0', 'GL_TEXTURE1', 'GL_TEXTURE2', 'GL_TEXTURE3', 'GL_TEXTURE4',
'GL_TEXTURE5', 'GL_TEXTURE6', 'GL_TEXTURE7', 'GL_TEXTURE8', 'GL_TEXTURE9',
'GL_TEXTURE10', 'GL_TEXTURE11', 'GL_TEXTURE12', 'GL_TEXTURE13',
'GL_TEXTURE14', 'GL_TEXTURE15', 'GL_TEXTURE16', 'GL_TEXTURE17',
'GL_TEXTURE18', 'GL_TEXTURE19', 'GL_TEXTURE20', 'GL_TEXTURE21',
'GL_TEXTURE22', 'GL_TEXTURE23', 'GL_TEXTURE24', 'GL_TEXTURE25',
'GL_TEXTURE26', 'GL_TEXTURE27', 'GL_TEXTURE28', 'GL_TEXTURE29',
'GL_TEXTURE30', 'GL_TEXTURE31', 'GL_ACTIVE_TEXTURE',
'GL_CLIENT_ACTIVE_TEXTURE', 'GL_MAX_TEXTURE_UNITS',
'GL_TRANSPOSE_MODELVIEW_MATRIX', 'GL_TRANSPOSE_PROJECTION_MATRIX',
'GL_TRANSPOSE_TEXTURE_MATRIX', 'GL_TRANSPOSE_COLOR_MATRIX', 'GL_MULTISAMPLE',
'GL_SAMPLE_ALPHA_TO_COVERAGE', 'GL_SAMPLE_ALPHA_TO_ONE', 'GL_SAMPLE_COVERAGE',
'GL_SAMPLE_BUFFERS', 'GL_SAMPLES', 'GL_SAMPLE_COVERAGE_VALUE',
'GL_SAMPLE_COVERAGE_INVERT', 'GL_MULTISAMPLE_BIT', 'GL_NORMAL_MAP',
'GL_REFLECTION_MAP', 'GL_TEXTURE_CUBE_MAP', 'GL_TEXTURE_BINDING_CUBE_MAP',
'GL_TEXTURE_CUBE_MAP_POSITIVE_X', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_X',
'GL_TEXTURE_CUBE_MAP_POSITIVE_Y', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_Y',
'GL_TEXTURE_CUBE_MAP_POSITIVE_Z', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_Z',
'GL_PROXY_TEXTURE_CUBE_MAP', 'GL_MAX_CUBE_MAP_TEXTURE_SIZE',
'GL_COMPRESSED_ALPHA', 'GL_COMPRESSED_LUMINANCE',
'GL_COMPRESSED_LUMINANCE_ALPHA', 'GL_COMPRESSED_INTENSITY',
'GL_COMPRESSED_RGB', 'GL_COMPRESSED_RGBA', 'GL_TEXTURE_COMPRESSION_HINT',
'GL_TEXTURE_COMPRESSED_IMAGE_SIZE', 'GL_TEXTURE_COMPRESSED',
'GL_NUM_COMPRESSED_TEXTURE_FORMATS', 'GL_COMPRESSED_TEXTURE_FORMATS',
'GL_CLAMP_TO_BORDER', 'GL_COMBINE', 'GL_COMBINE_RGB', 'GL_COMBINE_ALPHA',
'GL_SOURCE0_RGB', 'GL_SOURCE1_RGB', 'GL_SOURCE2_RGB', 'GL_SOURCE0_ALPHA',
'GL_SOURCE1_ALPHA', 'GL_SOURCE2_ALPHA', 'GL_OPERAND0_RGB', 'GL_OPERAND1_RGB',
'GL_OPERAND2_RGB', 'GL_OPERAND0_ALPHA', 'GL_OPERAND1_ALPHA',
'GL_OPERAND2_ALPHA', 'GL_RGB_SCALE', 'GL_ADD_SIGNED', 'GL_INTERPOLATE',
'GL_SUBTRACT', 'GL_CONSTANT', 'GL_PRIMARY_COLOR', 'GL_PREVIOUS',
'GL_DOT3_RGB', 'GL_DOT3_RGBA', 'GL_BLEND_DST_RGB', 'GL_BLEND_SRC_RGB',
'GL_BLEND_DST_ALPHA', 'GL_BLEND_SRC_ALPHA', 'GL_POINT_SIZE_MIN',
'GL_POINT_SIZE_MAX', 'GL_POINT_FADE_THRESHOLD_SIZE',
'GL_POINT_DISTANCE_ATTENUATION', 'GL_GENERATE_MIPMAP',
'GL_GENERATE_MIPMAP_HINT', 'GL_DEPTH_COMPONENT16', 'GL_DEPTH_COMPONENT24',
'GL_DEPTH_COMPONENT32', 'GL_MIRRORED_REPEAT', 'GL_FOG_COORDINATE_SOURCE',
'GL_FOG_COORDINATE', 'GL_FRAGMENT_DEPTH', 'GL_CURRENT_FOG_COORDINATE',
'GL_FOG_COORDINATE_ARRAY_TYPE', 'GL_FOG_COORDINATE_ARRAY_STRIDE',
'GL_FOG_COORDINATE_ARRAY_POINTER', 'GL_FOG_COORDINATE_ARRAY', 'GL_COLOR_SUM',
'GL_CURRENT_SECONDARY_COLOR', 'GL_SECONDARY_COLOR_ARRAY_SIZE',
'GL_SECONDARY_COLOR_ARRAY_TYPE', 'GL_SECONDARY_COLOR_ARRAY_STRIDE',
'GL_SECONDARY_COLOR_ARRAY_POINTER', 'GL_SECONDARY_COLOR_ARRAY',
'GL_MAX_TEXTURE_LOD_BIAS', 'GL_TEXTURE_FILTER_CONTROL', 'GL_TEXTURE_LOD_BIAS',
'GL_INCR_WRAP', 'GL_DECR_WRAP', 'GL_TEXTURE_DEPTH_SIZE',
'GL_DEPTH_TEXTURE_MODE', 'GL_TEXTURE_COMPARE_MODE', 'GL_TEXTURE_COMPARE_FUNC',
'GL_COMPARE_R_TO_TEXTURE', 'GL_BUFFER_SIZE', 'GL_BUFFER_USAGE',
'GL_QUERY_COUNTER_BITS', 'GL_CURRENT_QUERY', 'GL_QUERY_RESULT',
'GL_QUERY_RESULT_AVAILABLE', 'GL_ARRAY_BUFFER', 'GL_ELEMENT_ARRAY_BUFFER',
'GL_ARRAY_BUFFER_BINDING', 'GL_ELEMENT_ARRAY_BUFFER_BINDING',
'GL_VERTEX_ARRAY_BUFFER_BINDING', 'GL_NORMAL_ARRAY_BUFFER_BINDING',
'GL_COLOR_ARRAY_BUFFER_BINDING', 'GL_INDEX_ARRAY_BUFFER_BINDING',
'GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING', 'GL_EDGE_FLAG_ARRAY_BUFFER_BINDING',
'GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING',
'GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING', 'GL_WEIGHT_ARRAY_BUFFER_BINDING',
'GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING', 'GL_READ_ONLY', 'GL_WRITE_ONLY',
'GL_READ_WRITE', 'GL_BUFFER_ACCESS', 'GL_BUFFER_MAPPED',
'GL_BUFFER_MAP_POINTER', 'GL_STREAM_DRAW', 'GL_STREAM_READ', 'GL_STREAM_COPY',
'GL_STATIC_DRAW', 'GL_STATIC_READ', 'GL_STATIC_COPY', 'GL_DYNAMIC_DRAW',
'GL_DYNAMIC_READ', 'GL_DYNAMIC_COPY', 'GL_SAMPLES_PASSED', 'GL_FOG_COORD_SRC',
'GL_FOG_COORD', 'GL_CURRENT_FOG_COORD', 'GL_FOG_COORD_ARRAY_TYPE',
'GL_FOG_COORD_ARRAY_STRIDE', 'GL_FOG_COORD_ARRAY_POINTER',
'GL_FOG_COORD_ARRAY', 'GL_FOG_COORD_ARRAY_BUFFER_BINDING', 'GL_SRC0_RGB',
'GL_SRC1_RGB', 'GL_SRC2_RGB', 'GL_SRC0_ALPHA', 'GL_SRC1_ALPHA',
'GL_SRC2_ALPHA', 'GL_BLEND_EQUATION_RGB', 'GL_VERTEX_ATTRIB_ARRAY_ENABLED',
'GL_VERTEX_ATTRIB_ARRAY_SIZE', 'GL_VERTEX_ATTRIB_ARRAY_STRIDE',
'GL_VERTEX_ATTRIB_ARRAY_TYPE', 'GL_CURRENT_VERTEX_ATTRIB',
'GL_VERTEX_PROGRAM_POINT_SIZE', 'GL_VERTEX_PROGRAM_TWO_SIDE',
'GL_VERTEX_ATTRIB_ARRAY_POINTER', 'GL_STENCIL_BACK_FUNC',
'GL_STENCIL_BACK_FAIL', 'GL_STENCIL_BACK_PASS_DEPTH_FAIL',
'GL_STENCIL_BACK_PASS_DEPTH_PASS', 'GL_MAX_DRAW_BUFFERS', 'GL_DRAW_BUFFER0',
'GL_DRAW_BUFFER1', 'GL_DRAW_BUFFER2', 'GL_DRAW_BUFFER3', 'GL_DRAW_BUFFER4',
'GL_DRAW_BUFFER5', 'GL_DRAW_BUFFER6', 'GL_DRAW_BUFFER7', 'GL_DRAW_BUFFER8',
'GL_DRAW_BUFFER9', 'GL_DRAW_BUFFER10', 'GL_DRAW_BUFFER11', 'GL_DRAW_BUFFER12',
'GL_DRAW_BUFFER13', 'GL_DRAW_BUFFER14', 'GL_DRAW_BUFFER15',
'GL_BLEND_EQUATION_ALPHA', 'GL_POINT_SPRITE', 'GL_COORD_REPLACE',
'GL_MAX_VERTEX_ATTRIBS', 'GL_VERTEX_ATTRIB_ARRAY_NORMALIZED',
'GL_MAX_TEXTURE_COORDS', 'GL_MAX_TEXTURE_IMAGE_UNITS', 'GL_FRAGMENT_SHADER',
'GL_VERTEX_SHADER', 'GL_MAX_FRAGMENT_UNIFORM_COMPONENTS',
'GL_MAX_VERTEX_UNIFORM_COMPONENTS', 'GL_MAX_VARYING_FLOATS',
'GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS', 'GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS',
'GL_SHADER_TYPE', 'GL_FLOAT_VEC2', 'GL_FLOAT_VEC3', 'GL_FLOAT_VEC4',
'GL_INT_VEC2', 'GL_INT_VEC3', 'GL_INT_VEC4', 'GL_BOOL', 'GL_BOOL_VEC2',
'GL_BOOL_VEC3', 'GL_BOOL_VEC4', 'GL_FLOAT_MAT2', 'GL_FLOAT_MAT3',
'GL_FLOAT_MAT4', 'GL_SAMPLER_1D', 'GL_SAMPLER_2D', 'GL_SAMPLER_3D',
'GL_SAMPLER_CUBE', 'GL_SAMPLER_1D_SHADOW', 'GL_SAMPLER_2D_SHADOW',
'GL_DELETE_STATUS', 'GL_COMPILE_STATUS', 'GL_LINK_STATUS',
'GL_VALIDATE_STATUS', 'GL_INFO_LOG_LENGTH', 'GL_ATTACHED_SHADERS',
'GL_ACTIVE_UNIFORMS', 'GL_ACTIVE_UNIFORM_MAX_LENGTH',
'GL_SHADER_SOURCE_LENGTH', 'GL_ACTIVE_ATTRIBUTES',
'GL_ACTIVE_ATTRIBUTE_MAX_LENGTH', 'GL_FRAGMENT_SHADER_DERIVATIVE_HINT',
'GL_SHADING_LANGUAGE_VERSION', 'GL_CURRENT_PROGRAM',
'GL_POINT_SPRITE_COORD_ORIGIN', 'GL_LOWER_LEFT', 'GL_UPPER_LEFT',
'GL_STENCIL_BACK_REF', 'GL_STENCIL_BACK_VALUE_MASK',
'GL_STENCIL_BACK_WRITEMASK', 'GL_TEXTURE0_ARB', 'GL_TEXTURE1_ARB',
'GL_TEXTURE2_ARB', 'GL_TEXTURE3_ARB', 'GL_TEXTURE4_ARB', 'GL_TEXTURE5_ARB',
'GL_TEXTURE6_ARB', 'GL_TEXTURE7_ARB', 'GL_TEXTURE8_ARB', 'GL_TEXTURE9_ARB',
'GL_TEXTURE10_ARB', 'GL_TEXTURE11_ARB', 'GL_TEXTURE12_ARB',
'GL_TEXTURE13_ARB', 'GL_TEXTURE14_ARB', 'GL_TEXTURE15_ARB',
'GL_TEXTURE16_ARB', 'GL_TEXTURE17_ARB', 'GL_TEXTURE18_ARB',
'GL_TEXTURE19_ARB', 'GL_TEXTURE20_ARB', 'GL_TEXTURE21_ARB',
'GL_TEXTURE22_ARB', 'GL_TEXTURE23_ARB', 'GL_TEXTURE24_ARB',
'GL_TEXTURE25_ARB', 'GL_TEXTURE26_ARB', 'GL_TEXTURE27_ARB',
'GL_TEXTURE28_ARB', 'GL_TEXTURE29_ARB', 'GL_TEXTURE30_ARB',
'GL_TEXTURE31_ARB', 'GL_ACTIVE_TEXTURE_ARB', 'GL_CLIENT_ACTIVE_TEXTURE_ARB',
'GL_MAX_TEXTURE_UNITS_ARB', 'GL_TRANSPOSE_MODELVIEW_MATRIX_ARB',
'GL_TRANSPOSE_PROJECTION_MATRIX_ARB', 'GL_TRANSPOSE_TEXTURE_MATRIX_ARB',
'GL_TRANSPOSE_COLOR_MATRIX_ARB', 'GL_MULTISAMPLE_ARB',
'GL_SAMPLE_ALPHA_TO_COVERAGE_ARB', 'GL_SAMPLE_ALPHA_TO_ONE_ARB',
'GL_SAMPLE_COVERAGE_ARB', 'GL_SAMPLE_BUFFERS_ARB', 'GL_SAMPLES_ARB',
'GL_SAMPLE_COVERAGE_VALUE_ARB', 'GL_SAMPLE_COVERAGE_INVERT_ARB',
'GL_MULTISAMPLE_BIT_ARB', 'GL_NORMAL_MAP_ARB', 'GL_REFLECTION_MAP_ARB',
'GL_TEXTURE_CUBE_MAP_ARB', 'GL_TEXTURE_BINDING_CUBE_MAP_ARB',
'GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB',
'GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB',
'GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB',
'GL_PROXY_TEXTURE_CUBE_MAP_ARB', 'GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB',
'GL_COMPRESSED_ALPHA_ARB', 'GL_COMPRESSED_LUMINANCE_ARB',
'GL_COMPRESSED_LUMINANCE_ALPHA_ARB', 'GL_COMPRESSED_INTENSITY_ARB',
'GL_COMPRESSED_RGB_ARB', 'GL_COMPRESSED_RGBA_ARB',
'GL_TEXTURE_COMPRESSION_HINT_ARB', 'GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB',
'GL_TEXTURE_COMPRESSED_ARB', 'GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB',
'GL_COMPRESSED_TEXTURE_FORMATS_ARB', 'GL_CLAMP_TO_BORDER_ARB',
'GL_POINT_SIZE_MIN_ARB', 'GL_POINT_SIZE_MAX_ARB',
'GL_POINT_FADE_THRESHOLD_SIZE_ARB', 'GL_POINT_DISTANCE_ATTENUATION_ARB',
'GL_MAX_VERTEX_UNITS_ARB', 'GL_ACTIVE_VERTEX_UNITS_ARB',
'GL_WEIGHT_SUM_UNITY_ARB', 'GL_VERTEX_BLEND_ARB', 'GL_CURRENT_WEIGHT_ARB',
'GL_WEIGHT_ARRAY_TYPE_ARB', 'GL_WEIGHT_ARRAY_STRIDE_ARB',
'GL_WEIGHT_ARRAY_SIZE_ARB', 'GL_WEIGHT_ARRAY_POINTER_ARB',
'GL_WEIGHT_ARRAY_ARB', 'GL_MODELVIEW0_ARB', 'GL_MODELVIEW1_ARB',
'GL_MODELVIEW2_ARB', 'GL_MODELVIEW3_ARB', 'GL_MODELVIEW4_ARB',
'GL_MODELVIEW5_ARB', 'GL_MODELVIEW6_ARB', 'GL_MODELVIEW7_ARB',
'GL_MODELVIEW8_ARB', 'GL_MODELVIEW9_ARB', 'GL_MODELVIEW10_ARB',
'GL_MODELVIEW11_ARB', 'GL_MODELVIEW12_ARB', 'GL_MODELVIEW13_ARB',
'GL_MODELVIEW14_ARB', 'GL_MODELVIEW15_ARB', 'GL_MODELVIEW16_ARB',
'GL_MODELVIEW17_ARB', 'GL_MODELVIEW18_ARB', 'GL_MODELVIEW19_ARB',
'GL_MODELVIEW20_ARB', 'GL_MODELVIEW21_ARB', 'GL_MODELVIEW22_ARB',
'GL_MODELVIEW23_ARB', 'GL_MODELVIEW24_ARB', 'GL_MODELVIEW25_ARB',
'GL_MODELVIEW26_ARB', 'GL_MODELVIEW27_ARB', 'GL_MODELVIEW28_ARB',
'GL_MODELVIEW29_ARB', 'GL_MODELVIEW30_ARB', 'GL_MODELVIEW31_ARB',
'GL_MATRIX_PALETTE_ARB', 'GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB',
'GL_MAX_PALETTE_MATRICES_ARB', 'GL_CURRENT_PALETTE_MATRIX_ARB',
'GL_MATRIX_INDEX_ARRAY_ARB', 'GL_CURRENT_MATRIX_INDEX_ARB',
'GL_MATRIX_INDEX_ARRAY_SIZE_ARB', 'GL_MATRIX_INDEX_ARRAY_TYPE_ARB',
'GL_MATRIX_INDEX_ARRAY_STRIDE_ARB', 'GL_MATRIX_INDEX_ARRAY_POINTER_ARB',
'GL_COMBINE_ARB', 'GL_COMBINE_RGB_ARB', 'GL_COMBINE_ALPHA_ARB',
'GL_SOURCE0_RGB_ARB', 'GL_SOURCE1_RGB_ARB', 'GL_SOURCE2_RGB_ARB',
'GL_SOURCE0_ALPHA_ARB', 'GL_SOURCE1_ALPHA_ARB', 'GL_SOURCE2_ALPHA_ARB',
'GL_OPERAND0_RGB_ARB', 'GL_OPERAND1_RGB_ARB', 'GL_OPERAND2_RGB_ARB',
'GL_OPERAND0_ALPHA_ARB', 'GL_OPERAND1_ALPHA_ARB', 'GL_OPERAND2_ALPHA_ARB',
'GL_RGB_SCALE_ARB', 'GL_ADD_SIGNED_ARB', 'GL_INTERPOLATE_ARB',
'GL_SUBTRACT_ARB', 'GL_CONSTANT_ARB', 'GL_PRIMARY_COLOR_ARB',
'GL_PREVIOUS_ARB', 'GL_DOT3_RGB_ARB', 'GL_DOT3_RGBA_ARB',
'GL_MIRRORED_REPEAT_ARB', 'GL_DEPTH_COMPONENT16_ARB',
'GL_DEPTH_COMPONENT24_ARB', 'GL_DEPTH_COMPONENT32_ARB',
'GL_TEXTURE_DEPTH_SIZE_ARB', 'GL_DEPTH_TEXTURE_MODE_ARB',
'GL_TEXTURE_COMPARE_MODE_ARB', 'GL_TEXTURE_COMPARE_FUNC_ARB',
'GL_COMPARE_R_TO_TEXTURE_ARB', 'GL_TEXTURE_COMPARE_FAIL_VALUE_ARB',
'GL_COLOR_SUM_ARB', 'GL_VERTEX_PROGRAM_ARB',
'GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB', 'GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB',
'GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB', 'GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB',
'GL_CURRENT_VERTEX_ATTRIB_ARB', 'GL_PROGRAM_LENGTH_ARB',
'GL_PROGRAM_STRING_ARB', 'GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB',
'GL_MAX_PROGRAM_MATRICES_ARB', 'GL_CURRENT_MATRIX_STACK_DEPTH_ARB',
'GL_CURRENT_MATRIX_ARB', 'GL_VERTEX_PROGRAM_POINT_SIZE_ARB',
'GL_VERTEX_PROGRAM_TWO_SIDE_ARB', 'GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB',
'GL_PROGRAM_ERROR_POSITION_ARB', 'GL_PROGRAM_BINDING_ARB',
'GL_MAX_VERTEX_ATTRIBS_ARB', 'GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB',
'GL_PROGRAM_ERROR_STRING_ARB', 'GL_PROGRAM_FORMAT_ASCII_ARB',
'GL_PROGRAM_FORMAT_ARB', 'GL_PROGRAM_INSTRUCTIONS_ARB',
'GL_MAX_PROGRAM_INSTRUCTIONS_ARB', 'GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB',
'GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB', 'GL_PROGRAM_TEMPORARIES_ARB',
'GL_MAX_PROGRAM_TEMPORARIES_ARB', 'GL_PROGRAM_NATIVE_TEMPORARIES_ARB',
'GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB', 'GL_PROGRAM_PARAMETERS_ARB',
'GL_MAX_PROGRAM_PARAMETERS_ARB', 'GL_PROGRAM_NATIVE_PARAMETERS_ARB',
'GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB', 'GL_PROGRAM_ATTRIBS_ARB',
'GL_MAX_PROGRAM_ATTRIBS_ARB', 'GL_PROGRAM_NATIVE_ATTRIBS_ARB',
'GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB', 'GL_PROGRAM_ADDRESS_REGISTERS_ARB',
'GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB',
'GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB',
'GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB',
'GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB', 'GL_MAX_PROGRAM_ENV_PARAMETERS_ARB',
'GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB', 'GL_TRANSPOSE_CURRENT_MATRIX_ARB',
'GL_MATRIX0_ARB', 'GL_MATRIX1_ARB', 'GL_MATRIX2_ARB', 'GL_MATRIX3_ARB',
'GL_MATRIX4_ARB', 'GL_MATRIX5_ARB', 'GL_MATRIX6_ARB', 'GL_MATRIX7_ARB',
'GL_MATRIX8_ARB', 'GL_MATRIX9_ARB', 'GL_MATRIX10_ARB', 'GL_MATRIX11_ARB',
'GL_MATRIX12_ARB', 'GL_MATRIX13_ARB', 'GL_MATRIX14_ARB', 'GL_MATRIX15_ARB',
'GL_MATRIX16_ARB', 'GL_MATRIX17_ARB', 'GL_MATRIX18_ARB', 'GL_MATRIX19_ARB',
'GL_MATRIX20_ARB', 'GL_MATRIX21_ARB', 'GL_MATRIX22_ARB', 'GL_MATRIX23_ARB',
'GL_MATRIX24_ARB', 'GL_MATRIX25_ARB', 'GL_MATRIX26_ARB', 'GL_MATRIX27_ARB',
'GL_MATRIX28_ARB', 'GL_MATRIX29_ARB', 'GL_MATRIX30_ARB', 'GL_MATRIX31_ARB',
'GL_FRAGMENT_PROGRAM_ARB', 'GL_PROGRAM_ALU_INSTRUCTIONS_ARB',
'GL_PROGRAM_TEX_INSTRUCTIONS_ARB', 'GL_PROGRAM_TEX_INDIRECTIONS_ARB',
'GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB',
'GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB',
'GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB',
'GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB', 'GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB',
'GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB',
'GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB',
'GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB',
'GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB', 'GL_MAX_TEXTURE_COORDS_ARB',
'GL_MAX_TEXTURE_IMAGE_UNITS_ARB', 'GL_BUFFER_SIZE_ARB', 'GL_BUFFER_USAGE_ARB',
'GL_ARRAY_BUFFER_ARB', 'GL_ELEMENT_ARRAY_BUFFER_ARB',
'GL_ARRAY_BUFFER_BINDING_ARB', 'GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB',
'GL_VERTEX_ARRAY_BUFFER_BINDING_ARB', 'GL_NORMAL_ARRAY_BUFFER_BINDING_ARB',
'GL_COLOR_ARRAY_BUFFER_BINDING_ARB', 'GL_INDEX_ARRAY_BUFFER_BINDING_ARB',
'GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB',
'GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB',
'GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB',
'GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB',
'GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB',
'GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB', 'GL_READ_ONLY_ARB',
'GL_WRITE_ONLY_ARB', 'GL_READ_WRITE_ARB', 'GL_BUFFER_ACCESS_ARB',
'GL_BUFFER_MAPPED_ARB', 'GL_BUFFER_MAP_POINTER_ARB', 'GL_STREAM_DRAW_ARB',
'GL_STREAM_READ_ARB', 'GL_STREAM_COPY_ARB', 'GL_STATIC_DRAW_ARB',
'GL_STATIC_READ_ARB', 'GL_STATIC_COPY_ARB', 'GL_DYNAMIC_DRAW_ARB',
'GL_DYNAMIC_READ_ARB', 'GL_DYNAMIC_COPY_ARB', 'GL_QUERY_COUNTER_BITS_ARB',
'GL_CURRENT_QUERY_ARB', 'GL_QUERY_RESULT_ARB',
'GL_QUERY_RESULT_AVAILABLE_ARB', 'GL_SAMPLES_PASSED_ARB',
'GL_PROGRAM_OBJECT_ARB', 'GL_SHADER_OBJECT_ARB', 'GL_OBJECT_TYPE_ARB',
'GL_OBJECT_SUBTYPE_ARB', 'GL_FLOAT_VEC2_ARB', 'GL_FLOAT_VEC3_ARB',
'GL_FLOAT_VEC4_ARB', 'GL_INT_VEC2_ARB', 'GL_INT_VEC3_ARB', 'GL_INT_VEC4_ARB',
'GL_BOOL_ARB', 'GL_BOOL_VEC2_ARB', 'GL_BOOL_VEC3_ARB', 'GL_BOOL_VEC4_ARB',
'GL_FLOAT_MAT2_ARB', 'GL_FLOAT_MAT3_ARB', 'GL_FLOAT_MAT4_ARB',
'GL_SAMPLER_1D_ARB', 'GL_SAMPLER_2D_ARB', 'GL_SAMPLER_3D_ARB',
'GL_SAMPLER_CUBE_ARB', 'GL_SAMPLER_1D_SHADOW_ARB', 'GL_SAMPLER_2D_SHADOW_ARB',
'GL_SAMPLER_2D_RECT_ARB', 'GL_SAMPLER_2D_RECT_SHADOW_ARB',
'GL_OBJECT_DELETE_STATUS_ARB', 'GL_OBJECT_COMPILE_STATUS_ARB',
'GL_OBJECT_LINK_STATUS_ARB', 'GL_OBJECT_VALIDATE_STATUS_ARB',
'GL_OBJECT_INFO_LOG_LENGTH_ARB', 'GL_OBJECT_ATTACHED_OBJECTS_ARB',
'GL_OBJECT_ACTIVE_UNIFORMS_ARB', 'GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB',
'GL_OBJECT_SHADER_SOURCE_LENGTH_ARB', 'GL_VERTEX_SHADER_ARB',
'GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB', 'GL_MAX_VARYING_FLOATS_ARB',
'GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB',
'GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB', 'GL_OBJECT_ACTIVE_ATTRIBUTES_ARB',
'GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB', 'GL_FRAGMENT_SHADER_ARB',
'GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB',
'GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB', 'GL_SHADING_LANGUAGE_VERSION_ARB',
'GL_POINT_SPRITE_ARB', 'GL_COORD_REPLACE_ARB', 'GL_MAX_DRAW_BUFFERS_ARB',
'GL_DRAW_BUFFER0_ARB', 'GL_DRAW_BUFFER1_ARB', 'GL_DRAW_BUFFER2_ARB',
'GL_DRAW_BUFFER3_ARB', 'GL_DRAW_BUFFER4_ARB', 'GL_DRAW_BUFFER5_ARB',
'GL_DRAW_BUFFER6_ARB', 'GL_DRAW_BUFFER7_ARB', 'GL_DRAW_BUFFER8_ARB',
'GL_DRAW_BUFFER9_ARB', 'GL_DRAW_BUFFER10_ARB', 'GL_DRAW_BUFFER11_ARB',
'GL_DRAW_BUFFER12_ARB', 'GL_DRAW_BUFFER13_ARB', 'GL_DRAW_BUFFER14_ARB',
'GL_DRAW_BUFFER15_ARB', 'GL_TEXTURE_RECTANGLE_ARB',
'GL_TEXTURE_BINDING_RECTANGLE_ARB', 'GL_PROXY_TEXTURE_RECTANGLE_ARB',
'GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB', 'GL_RGBA_FLOAT_MODE_ARB',
'GL_CLAMP_VERTEX_COLOR_ARB', 'GL_CLAMP_FRAGMENT_COLOR_ARB',
'GL_CLAMP_READ_COLOR_ARB', 'GL_FIXED_ONLY_ARB', 'GL_HALF_FLOAT_ARB',
'GL_TEXTURE_RED_TYPE_ARB', 'GL_TEXTURE_GREEN_TYPE_ARB',
'GL_TEXTURE_BLUE_TYPE_ARB', 'GL_TEXTURE_ALPHA_TYPE_ARB',
'GL_TEXTURE_LUMINANCE_TYPE_ARB', 'GL_TEXTURE_INTENSITY_TYPE_ARB',
'GL_TEXTURE_DEPTH_TYPE_ARB', 'GL_UNSIGNED_NORMALIZED_ARB', 'GL_RGBA32F_ARB',
'GL_RGB32F_ARB', 'GL_ALPHA32F_ARB', 'GL_INTENSITY32F_ARB',
'GL_LUMINANCE32F_ARB', 'GL_LUMINANCE_ALPHA32F_ARB', 'GL_RGBA16F_ARB',
'GL_RGB16F_ARB', 'GL_ALPHA16F_ARB', 'GL_INTENSITY16F_ARB',
'GL_LUMINANCE16F_ARB', 'GL_LUMINANCE_ALPHA16F_ARB',
'GL_PIXEL_PACK_BUFFER_ARB', 'GL_PIXEL_UNPACK_BUFFER_ARB',
'GL_PIXEL_PACK_BUFFER_BINDING_ARB', 'GL_PIXEL_UNPACK_BUFFER_BINDING_ARB',
'GL_ABGR_EXT', 'GL_CONSTANT_COLOR_EXT', 'GL_ONE_MINUS_CONSTANT_COLOR_EXT',
'GL_CONSTANT_ALPHA_EXT', 'GL_ONE_MINUS_CONSTANT_ALPHA_EXT',
'GL_BLEND_COLOR_EXT', 'GL_POLYGON_OFFSET_EXT', 'GL_POLYGON_OFFSET_FACTOR_EXT',
'GL_POLYGON_OFFSET_BIAS_EXT', 'GL_ALPHA4_EXT', 'GL_ALPHA8_EXT',
'GL_ALPHA12_EXT', 'GL_ALPHA16_EXT', 'GL_LUMINANCE4_EXT', 'GL_LUMINANCE8_EXT',
'GL_LUMINANCE12_EXT', 'GL_LUMINANCE16_EXT', 'GL_LUMINANCE4_ALPHA4_EXT',
'GL_LUMINANCE6_ALPHA2_EXT', 'GL_LUMINANCE8_ALPHA8_EXT',
'GL_LUMINANCE12_ALPHA4_EXT', 'GL_LUMINANCE12_ALPHA12_EXT',
'GL_LUMINANCE16_ALPHA16_EXT', 'GL_INTENSITY_EXT', 'GL_INTENSITY4_EXT',
'GL_INTENSITY8_EXT', 'GL_INTENSITY12_EXT', 'GL_INTENSITY16_EXT',
'GL_RGB2_EXT', 'GL_RGB4_EXT', 'GL_RGB5_EXT', 'GL_RGB8_EXT', 'GL_RGB10_EXT',
'GL_RGB12_EXT', 'GL_RGB16_EXT', 'GL_RGBA2_EXT', 'GL_RGBA4_EXT',
'GL_RGB5_A1_EXT', 'GL_RGBA8_EXT', 'GL_RGB10_A2_EXT', 'GL_RGBA12_EXT',
'GL_RGBA16_EXT', 'GL_TEXTURE_RED_SIZE_EXT', 'GL_TEXTURE_GREEN_SIZE_EXT',
'GL_TEXTURE_BLUE_SIZE_EXT', 'GL_TEXTURE_ALPHA_SIZE_EXT',
'GL_TEXTURE_LUMINANCE_SIZE_EXT', 'GL_TEXTURE_INTENSITY_SIZE_EXT',
'GL_REPLACE_EXT', 'GL_PROXY_TEXTURE_1D_EXT', 'GL_PROXY_TEXTURE_2D_EXT',
'GL_TEXTURE_TOO_LARGE_EXT', 'GL_PACK_SKIP_IMAGES_EXT',
'GL_PACK_IMAGE_HEIGHT_EXT', 'GL_UNPACK_SKIP_IMAGES_EXT',
'GL_UNPACK_IMAGE_HEIGHT_EXT', 'GL_TEXTURE_3D_EXT', 'GL_PROXY_TEXTURE_3D_EXT',
'GL_TEXTURE_DEPTH_EXT', 'GL_TEXTURE_WRAP_R_EXT', 'GL_MAX_3D_TEXTURE_SIZE_EXT',
'GL_FILTER4_SGIS', 'GL_TEXTURE_FILTER4_SIZE_SGIS', 'GL_HISTOGRAM_EXT',
'GL_PROXY_HISTOGRAM_EXT', 'GL_HISTOGRAM_WIDTH_EXT', 'GL_HISTOGRAM_FORMAT_EXT',
'GL_HISTOGRAM_RED_SIZE_EXT', 'GL_HISTOGRAM_GREEN_SIZE_EXT',
'GL_HISTOGRAM_BLUE_SIZE_EXT', 'GL_HISTOGRAM_ALPHA_SIZE_EXT',
'GL_HISTOGRAM_LUMINANCE_SIZE_EXT', 'GL_HISTOGRAM_SINK_EXT', 'GL_MINMAX_EXT',
'GL_MINMAX_FORMAT_EXT', 'GL_MINMAX_SINK_EXT', 'GL_TABLE_TOO_LARGE_EXT',
'GL_CONVOLUTION_1D_EXT', 'GL_CONVOLUTION_2D_EXT', 'GL_SEPARABLE_2D_EXT',
'GL_CONVOLUTION_BORDER_MODE_EXT', 'GL_CONVOLUTION_FILTER_SCALE_EXT',
'GL_CONVOLUTION_FILTER_BIAS_EXT', 'GL_REDUCE_EXT',
'GL_CONVOLUTION_FORMAT_EXT', 'GL_CONVOLUTION_WIDTH_EXT',
'GL_CONVOLUTION_HEIGHT_EXT', 'GL_MAX_CONVOLUTION_WIDTH_EXT',
'GL_MAX_CONVOLUTION_HEIGHT_EXT', 'GL_POST_CONVOLUTION_RED_SCALE_EXT',
'GL_POST_CONVOLUTION_GREEN_SCALE_EXT', 'GL_POST_CONVOLUTION_BLUE_SCALE_EXT',
'GL_POST_CONVOLUTION_ALPHA_SCALE_EXT', 'GL_POST_CONVOLUTION_RED_BIAS_EXT',
'GL_POST_CONVOLUTION_GREEN_BIAS_EXT', 'GL_POST_CONVOLUTION_BLUE_BIAS_EXT',
'GL_POST_CONVOLUTION_ALPHA_BIAS_EXT', 'GL_COLOR_MATRIX_SGI',
'GL_COLOR_MATRIX_STACK_DEPTH_SGI', 'GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI',
'GL_POST_COLOR_MATRIX_RED_SCALE_SGI', 'GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI',
'GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI', 'GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI',
'GL_POST_COLOR_MATRIX_RED_BIAS_SGI', 'GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI',
'GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI', 'GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI',
'GL_COLOR_TABLE_SGI', 'GL_POST_CONVOLUTION_COLOR_TABLE_SGI',
'GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI', 'GL_PROXY_COLOR_TABLE_SGI',
'GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI',
'GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI', 'GL_COLOR_TABLE_SCALE_SGI',
'GL_COLOR_TABLE_BIAS_SGI', 'GL_COLOR_TABLE_FORMAT_SGI',
'GL_COLOR_TABLE_WIDTH_SGI', 'GL_COLOR_TABLE_RED_SIZE_SGI',
'GL_COLOR_TABLE_GREEN_SIZE_SGI', 'GL_COLOR_TABLE_BLUE_SIZE_SGI',
'GL_COLOR_TABLE_ALPHA_SIZE_SGI', 'GL_COLOR_TABLE_LUMINANCE_SIZE_SGI',
'GL_COLOR_TABLE_INTENSITY_SIZE_SGI', 'GL_PIXEL_TEXTURE_SGIS',
'GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS', 'GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS',
'GL_PIXEL_GROUP_COLOR_SGIS', 'GL_PIXEL_TEX_GEN_SGIX',
'GL_PIXEL_TEX_GEN_MODE_SGIX', 'GL_PACK_SKIP_VOLUMES_SGIS',
'GL_PACK_IMAGE_DEPTH_SGIS', 'GL_UNPACK_SKIP_VOLUMES_SGIS',
'GL_UNPACK_IMAGE_DEPTH_SGIS', 'GL_TEXTURE_4D_SGIS',
'GL_PROXY_TEXTURE_4D_SGIS', 'GL_TEXTURE_4DSIZE_SGIS',
'GL_TEXTURE_WRAP_Q_SGIS', 'GL_MAX_4D_TEXTURE_SIZE_SGIS',
'GL_TEXTURE_4D_BINDING_SGIS', 'GL_TEXTURE_COLOR_TABLE_SGI',
'GL_PROXY_TEXTURE_COLOR_TABLE_SGI', 'GL_CMYK_EXT', 'GL_CMYKA_EXT',
'GL_PACK_CMYK_HINT_EXT', 'GL_UNPACK_CMYK_HINT_EXT', 'GL_TEXTURE_PRIORITY_EXT',
'GL_TEXTURE_RESIDENT_EXT', 'GL_TEXTURE_1D_BINDING_EXT',
'GL_TEXTURE_2D_BINDING_EXT', 'GL_TEXTURE_3D_BINDING_EXT',
'GL_DETAIL_TEXTURE_2D_SGIS', 'GL_DETAIL_TEXTURE_2D_BINDING_SGIS',
'GL_LINEAR_DETAIL_SGIS', 'GL_LINEAR_DETAIL_ALPHA_SGIS',
'GL_LINEAR_DETAIL_COLOR_SGIS', 'GL_DETAIL_TEXTURE_LEVEL_SGIS',
'GL_DETAIL_TEXTURE_MODE_SGIS', 'GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS',
'GL_LINEAR_SHARPEN_SGIS', 'GL_LINEAR_SHARPEN_ALPHA_SGIS',
'GL_LINEAR_SHARPEN_COLOR_SGIS', 'GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS',
'GL_UNSIGNED_BYTE_3_3_2_EXT', 'GL_UNSIGNED_SHORT_4_4_4_4_EXT',
'GL_UNSIGNED_SHORT_5_5_5_1_EXT', 'GL_UNSIGNED_INT_8_8_8_8_EXT',
'GL_UNSIGNED_INT_10_10_10_2_EXT', 'GL_TEXTURE_MIN_LOD_SGIS',
'GL_TEXTURE_MAX_LOD_SGIS', 'GL_TEXTURE_BASE_LEVEL_SGIS',
'GL_TEXTURE_MAX_LEVEL_SGIS', 'GL_MULTISAMPLE_SGIS',
'GL_SAMPLE_ALPHA_TO_MASK_SGIS', 'GL_SAMPLE_ALPHA_TO_ONE_SGIS',
'GL_SAMPLE_MASK_SGIS', 'GL_1PASS_SGIS', 'GL_2PASS_0_SGIS', 'GL_2PASS_1_SGIS',
'GL_4PASS_0_SGIS', 'GL_4PASS_1_SGIS', 'GL_4PASS_2_SGIS', 'GL_4PASS_3_SGIS',
'GL_SAMPLE_BUFFERS_SGIS', 'GL_SAMPLES_SGIS', 'GL_SAMPLE_MASK_VALUE_SGIS',
'GL_SAMPLE_MASK_INVERT_SGIS', 'GL_SAMPLE_PATTERN_SGIS',
'GL_RESCALE_NORMAL_EXT', 'GL_VERTEX_ARRAY_EXT', 'GL_NORMAL_ARRAY_EXT',
'GL_COLOR_ARRAY_EXT', 'GL_INDEX_ARRAY_EXT', 'GL_TEXTURE_COORD_ARRAY_EXT',
'GL_EDGE_FLAG_ARRAY_EXT', 'GL_VERTEX_ARRAY_SIZE_EXT',
'GL_VERTEX_ARRAY_TYPE_EXT', 'GL_VERTEX_ARRAY_STRIDE_EXT',
'GL_VERTEX_ARRAY_COUNT_EXT', 'GL_NORMAL_ARRAY_TYPE_EXT',
'GL_NORMAL_ARRAY_STRIDE_EXT', 'GL_NORMAL_ARRAY_COUNT_EXT',
'GL_COLOR_ARRAY_SIZE_EXT', 'GL_COLOR_ARRAY_TYPE_EXT',
'GL_COLOR_ARRAY_STRIDE_EXT', 'GL_COLOR_ARRAY_COUNT_EXT',
'GL_INDEX_ARRAY_TYPE_EXT', 'GL_INDEX_ARRAY_STRIDE_EXT',
'GL_INDEX_ARRAY_COUNT_EXT', 'GL_TEXTURE_COORD_ARRAY_SIZE_EXT',
'GL_TEXTURE_COORD_ARRAY_TYPE_EXT', 'GL_TEXTURE_COORD_ARRAY_STRIDE_EXT',
'GL_TEXTURE_COORD_ARRAY_COUNT_EXT', 'GL_EDGE_FLAG_ARRAY_STRIDE_EXT',
'GL_EDGE_FLAG_ARRAY_COUNT_EXT', 'GL_VERTEX_ARRAY_POINTER_EXT',
'GL_NORMAL_ARRAY_POINTER_EXT', 'GL_COLOR_ARRAY_POINTER_EXT',
'GL_INDEX_ARRAY_POINTER_EXT', 'GL_TEXTURE_COORD_ARRAY_POINTER_EXT',
'GL_EDGE_FLAG_ARRAY_POINTER_EXT', 'GL_GENERATE_MIPMAP_SGIS',
'GL_GENERATE_MIPMAP_HINT_SGIS', 'GL_LINEAR_CLIPMAP_LINEAR_SGIX',
'GL_TEXTURE_CLIPMAP_CENTER_SGIX', 'GL_TEXTURE_CLIPMAP_FRAME_SGIX',
'GL_TEXTURE_CLIPMAP_OFFSET_SGIX', 'GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX',
'GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX', 'GL_TEXTURE_CLIPMAP_DEPTH_SGIX',
'GL_MAX_CLIPMAP_DEPTH_SGIX', 'GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX',
'GL_NEAREST_CLIPMAP_NEAREST_SGIX', 'GL_NEAREST_CLIPMAP_LINEAR_SGIX',
'GL_LINEAR_CLIPMAP_NEAREST_SGIX', 'GL_TEXTURE_COMPARE_SGIX',
'GL_TEXTURE_COMPARE_OPERATOR_SGIX', 'GL_TEXTURE_LEQUAL_R_SGIX',
'GL_TEXTURE_GEQUAL_R_SGIX', 'GL_CLAMP_TO_EDGE_SGIS',
'GL_CLAMP_TO_BORDER_SGIS', 'GL_FUNC_ADD_EXT', 'GL_MIN_EXT', 'GL_MAX_EXT',
'GL_BLEND_EQUATION_EXT', 'GL_FUNC_SUBTRACT_EXT',
'GL_FUNC_REVERSE_SUBTRACT_EXT', 'GL_INTERLACE_SGIX',
'GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX', 'GL_PIXEL_TILE_CACHE_INCREMENT_SGIX',
'GL_PIXEL_TILE_WIDTH_SGIX', 'GL_PIXEL_TILE_HEIGHT_SGIX',
'GL_PIXEL_TILE_GRID_WIDTH_SGIX', 'GL_PIXEL_TILE_GRID_HEIGHT_SGIX',
'GL_PIXEL_TILE_GRID_DEPTH_SGIX', 'GL_PIXEL_TILE_CACHE_SIZE_SGIX',
'GL_DUAL_ALPHA4_SGIS', 'GL_DUAL_ALPHA8_SGIS', 'GL_DUAL_ALPHA12_SGIS',
'GL_DUAL_ALPHA16_SGIS', 'GL_DUAL_LUMINANCE4_SGIS', 'GL_DUAL_LUMINANCE8_SGIS',
'GL_DUAL_LUMINANCE12_SGIS', 'GL_DUAL_LUMINANCE16_SGIS',
'GL_DUAL_INTENSITY4_SGIS', 'GL_DUAL_INTENSITY8_SGIS',
'GL_DUAL_INTENSITY12_SGIS', 'GL_DUAL_INTENSITY16_SGIS',
'GL_DUAL_LUMINANCE_ALPHA4_SGIS', 'GL_DUAL_LUMINANCE_ALPHA8_SGIS',
'GL_QUAD_ALPHA4_SGIS', 'GL_QUAD_ALPHA8_SGIS', 'GL_QUAD_LUMINANCE4_SGIS',
'GL_QUAD_LUMINANCE8_SGIS', 'GL_QUAD_INTENSITY4_SGIS',
'GL_QUAD_INTENSITY8_SGIS', 'GL_DUAL_TEXTURE_SELECT_SGIS',
'GL_QUAD_TEXTURE_SELECT_SGIS', 'GL_SPRITE_SGIX', 'GL_SPRITE_MODE_SGIX',
'GL_SPRITE_AXIS_SGIX', 'GL_SPRITE_TRANSLATION_SGIX', 'GL_SPRITE_AXIAL_SGIX',
'GL_SPRITE_OBJECT_ALIGNED_SGIX', 'GL_SPRITE_EYE_ALIGNED_SGIX',
'GL_TEXTURE_MULTI_BUFFER_HINT_SGIX', 'GL_POINT_SIZE_MIN_EXT',
'GL_POINT_SIZE_MAX_EXT', 'GL_POINT_FADE_THRESHOLD_SIZE_EXT',
'GL_DISTANCE_ATTENUATION_EXT', 'GL_POINT_SIZE_MIN_SGIS',
'GL_POINT_SIZE_MAX_SGIS', 'GL_POINT_FADE_THRESHOLD_SIZE_SGIS',
'GL_DISTANCE_ATTENUATION_SGIS', 'GL_INSTRUMENT_BUFFER_POINTER_SGIX',
'GL_INSTRUMENT_MEASUREMENTS_SGIX', 'GL_POST_TEXTURE_FILTER_BIAS_SGIX',
'GL_POST_TEXTURE_FILTER_SCALE_SGIX', 'GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX',
'GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX', 'GL_FRAMEZOOM_SGIX',
'GL_FRAMEZOOM_FACTOR_SGIX', 'GL_MAX_FRAMEZOOM_FACTOR_SGIX',
'GL_TEXTURE_DEFORMATION_BIT_SGIX', 'GL_GEOMETRY_DEFORMATION_BIT_SGIX',
'GL_GEOMETRY_DEFORMATION_SGIX', 'GL_TEXTURE_DEFORMATION_SGIX',
'GL_DEFORMATIONS_MASK_SGIX', 'GL_MAX_DEFORMATION_ORDER_SGIX',
'GL_REFERENCE_PLANE_SGIX', 'GL_REFERENCE_PLANE_EQUATION_SGIX',
'GL_DEPTH_COMPONENT16_SGIX', 'GL_DEPTH_COMPONENT24_SGIX',
'GL_DEPTH_COMPONENT32_SGIX', 'GL_FOG_FUNC_SGIS', 'GL_FOG_FUNC_POINTS_SGIS',
'GL_MAX_FOG_FUNC_POINTS_SGIS', 'GL_FOG_OFFSET_SGIX',
'GL_FOG_OFFSET_VALUE_SGIX', 'GL_IMAGE_SCALE_X_HP', 'GL_IMAGE_SCALE_Y_HP',
'GL_IMAGE_TRANSLATE_X_HP', 'GL_IMAGE_TRANSLATE_Y_HP',
'GL_IMAGE_ROTATE_ANGLE_HP', 'GL_IMAGE_ROTATE_ORIGIN_X_HP',
'GL_IMAGE_ROTATE_ORIGIN_Y_HP', 'GL_IMAGE_MAG_FILTER_HP',
'GL_IMAGE_MIN_FILTER_HP', 'GL_IMAGE_CUBIC_WEIGHT_HP', 'GL_CUBIC_HP',
'GL_AVERAGE_HP', 'GL_IMAGE_TRANSFORM_2D_HP',
'GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP',
'GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP', 'GL_IGNORE_BORDER_HP',
'GL_CONSTANT_BORDER_HP', 'GL_REPLICATE_BORDER_HP',
'GL_CONVOLUTION_BORDER_COLOR_HP', 'GL_TEXTURE_ENV_BIAS_SGIX',
'GL_VERTEX_DATA_HINT_PGI', 'GL_VERTEX_CONSISTENT_HINT_PGI',
'GL_MATERIAL_SIDE_HINT_PGI', 'GL_MAX_VERTEX_HINT_PGI', 'GL_COLOR3_BIT_PGI',
'GL_COLOR4_BIT_PGI', 'GL_EDGEFLAG_BIT_PGI', 'GL_INDEX_BIT_PGI',
'GL_MAT_AMBIENT_BIT_PGI', 'GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI',
'GL_MAT_DIFFUSE_BIT_PGI', 'GL_MAT_EMISSION_BIT_PGI',
'GL_MAT_COLOR_INDEXES_BIT_PGI', 'GL_MAT_SHININESS_BIT_PGI',
'GL_MAT_SPECULAR_BIT_PGI', 'GL_NORMAL_BIT_PGI', 'GL_TEXCOORD1_BIT_PGI',
'GL_TEXCOORD2_BIT_PGI', 'GL_TEXCOORD3_BIT_PGI', 'GL_TEXCOORD4_BIT_PGI',
'GL_VERTEX23_BIT_PGI', 'GL_VERTEX4_BIT_PGI',
'GL_PREFER_DOUBLEBUFFER_HINT_PGI', 'GL_CONSERVE_MEMORY_HINT_PGI',
'GL_RECLAIM_MEMORY_HINT_PGI', 'GL_NATIVE_GRAPHICS_HANDLE_PGI',
'GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI', 'GL_NATIVE_GRAPHICS_END_HINT_PGI',
'GL_ALWAYS_FAST_HINT_PGI', 'GL_ALWAYS_SOFT_HINT_PGI',
'GL_ALLOW_DRAW_OBJ_HINT_PGI', 'GL_ALLOW_DRAW_WIN_HINT_PGI',
'GL_ALLOW_DRAW_FRG_HINT_PGI', 'GL_ALLOW_DRAW_MEM_HINT_PGI',
'GL_STRICT_DEPTHFUNC_HINT_PGI', 'GL_STRICT_LIGHTING_HINT_PGI',
'GL_STRICT_SCISSOR_HINT_PGI', 'GL_FULL_STIPPLE_HINT_PGI',
'GL_CLIP_NEAR_HINT_PGI', 'GL_CLIP_FAR_HINT_PGI', 'GL_WIDE_LINE_HINT_PGI',
'GL_BACK_NORMALS_HINT_PGI', 'GL_COLOR_INDEX1_EXT', 'GL_COLOR_INDEX2_EXT',
'GL_COLOR_INDEX4_EXT', 'GL_COLOR_INDEX8_EXT', 'GL_COLOR_INDEX12_EXT',
'GL_COLOR_INDEX16_EXT', 'GL_TEXTURE_INDEX_SIZE_EXT',
'GL_CLIP_VOLUME_CLIPPING_HINT_EXT', 'GL_LIST_PRIORITY_SGIX',
'GL_IR_INSTRUMENT1_SGIX', 'GL_CALLIGRAPHIC_FRAGMENT_SGIX',
'GL_TEXTURE_LOD_BIAS_S_SGIX', 'GL_TEXTURE_LOD_BIAS_T_SGIX',
'GL_TEXTURE_LOD_BIAS_R_SGIX', 'GL_SHADOW_AMBIENT_SGIX',
'GL_INDEX_MATERIAL_EXT', 'GL_INDEX_MATERIAL_PARAMETER_EXT',
'GL_INDEX_MATERIAL_FACE_EXT', 'GL_INDEX_TEST_EXT', 'GL_INDEX_TEST_FUNC_EXT',
'GL_INDEX_TEST_REF_EXT', 'GL_IUI_V2F_EXT', 'GL_IUI_V3F_EXT',
'GL_IUI_N3F_V2F_EXT', 'GL_IUI_N3F_V3F_EXT', 'GL_T2F_IUI_V2F_EXT',
'GL_T2F_IUI_V3F_EXT', 'GL_T2F_IUI_N3F_V2F_EXT', 'GL_T2F_IUI_N3F_V3F_EXT',
'GL_ARRAY_ELEMENT_LOCK_FIRST_EXT', 'GL_ARRAY_ELEMENT_LOCK_COUNT_EXT',
'GL_CULL_VERTEX_EXT', 'GL_CULL_VERTEX_EYE_POSITION_EXT',
'GL_CULL_VERTEX_OBJECT_POSITION_EXT', 'GL_YCRCB_422_SGIX',
'GL_YCRCB_444_SGIX', 'GL_FRAGMENT_LIGHTING_SGIX',
'GL_FRAGMENT_COLOR_MATERIAL_SGIX', 'GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX',
'GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX', 'GL_MAX_FRAGMENT_LIGHTS_SGIX',
'GL_MAX_ACTIVE_LIGHTS_SGIX', 'GL_CURRENT_RASTER_NORMAL_SGIX',
'GL_LIGHT_ENV_MODE_SGIX', 'GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX',
'GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX',
'GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX',
'GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX',
'GL_FRAGMENT_LIGHT0_SGIX', 'GL_FRAGMENT_LIGHT1_SGIX',
'GL_FRAGMENT_LIGHT2_SGIX', 'GL_FRAGMENT_LIGHT3_SGIX',
'GL_FRAGMENT_LIGHT4_SGIX', 'GL_FRAGMENT_LIGHT5_SGIX',
'GL_FRAGMENT_LIGHT6_SGIX', 'GL_FRAGMENT_LIGHT7_SGIX',
'GL_RASTER_POSITION_UNCLIPPED_IBM', 'GL_TEXTURE_LIGHTING_MODE_HP',
'GL_TEXTURE_POST_SPECULAR_HP', 'GL_TEXTURE_PRE_SPECULAR_HP',
'GL_MAX_ELEMENTS_VERTICES_EXT', 'GL_MAX_ELEMENTS_INDICES_EXT', 'GL_PHONG_WIN',
'GL_PHONG_HINT_WIN', 'GL_FOG_SPECULAR_TEXTURE_WIN',
'GL_FRAGMENT_MATERIAL_EXT', 'GL_FRAGMENT_NORMAL_EXT', 'GL_FRAGMENT_COLOR_EXT',
'GL_ATTENUATION_EXT', 'GL_SHADOW_ATTENUATION_EXT',
'GL_TEXTURE_APPLICATION_MODE_EXT', 'GL_TEXTURE_LIGHT_EXT',
'GL_TEXTURE_MATERIAL_FACE_EXT', 'GL_TEXTURE_MATERIAL_PARAMETER_EXT',
'GL_ALPHA_MIN_SGIX', 'GL_ALPHA_MAX_SGIX', 'GL_PIXEL_TEX_GEN_Q_CEILING_SGIX',
'GL_PIXEL_TEX_GEN_Q_ROUND_SGIX', 'GL_PIXEL_TEX_GEN_Q_FLOOR_SGIX',
'GL_PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX',
'GL_PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX', 'GL_PIXEL_TEX_GEN_ALPHA_LS_SGIX',
'GL_PIXEL_TEX_GEN_ALPHA_MS_SGIX', 'GL_BGR_EXT', 'GL_BGRA_EXT',
'GL_ASYNC_MARKER_SGIX', 'GL_ASYNC_TEX_IMAGE_SGIX',
'GL_ASYNC_DRAW_PIXELS_SGIX', 'GL_ASYNC_READ_PIXELS_SGIX',
'GL_MAX_ASYNC_TEX_IMAGE_SGIX', 'GL_MAX_ASYNC_DRAW_PIXELS_SGIX',
'GL_MAX_ASYNC_READ_PIXELS_SGIX', 'GL_ASYNC_HISTOGRAM_SGIX',
'GL_MAX_ASYNC_HISTOGRAM_SGIX', 'GL_PARALLEL_ARRAYS_INTEL',
'GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL',
'GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL',
'GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL',
'GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL', 'GL_OCCLUSION_TEST_HP',
'GL_OCCLUSION_TEST_RESULT_HP', 'GL_PIXEL_TRANSFORM_2D_EXT',
'GL_PIXEL_MAG_FILTER_EXT', 'GL_PIXEL_MIN_FILTER_EXT',
'GL_PIXEL_CUBIC_WEIGHT_EXT', 'GL_CUBIC_EXT', 'GL_AVERAGE_EXT',
'GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT',
'GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT',
'GL_PIXEL_TRANSFORM_2D_MATRIX_EXT', 'GL_SHARED_TEXTURE_PALETTE_EXT',
'GL_LIGHT_MODEL_COLOR_CONTROL_EXT', 'GL_SINGLE_COLOR_EXT',
'GL_SEPARATE_SPECULAR_COLOR_EXT', 'GL_COLOR_SUM_EXT',
'GL_CURRENT_SECONDARY_COLOR_EXT', 'GL_SECONDARY_COLOR_ARRAY_SIZE_EXT',
'GL_SECONDARY_COLOR_ARRAY_TYPE_EXT', 'GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT',
'GL_SECONDARY_COLOR_ARRAY_POINTER_EXT', 'GL_SECONDARY_COLOR_ARRAY_EXT',
'GL_PERTURB_EXT', 'GL_TEXTURE_NORMAL_EXT', 'GL_FOG_COORDINATE_SOURCE_EXT',
'GL_FOG_COORDINATE_EXT', 'GL_FRAGMENT_DEPTH_EXT',
'GL_CURRENT_FOG_COORDINATE_EXT', 'GL_FOG_COORDINATE_ARRAY_TYPE_EXT',
'GL_FOG_COORDINATE_ARRAY_STRIDE_EXT', 'GL_FOG_COORDINATE_ARRAY_POINTER_EXT',
'GL_FOG_COORDINATE_ARRAY_EXT', 'GL_SCREEN_COORDINATES_REND',
'GL_INVERTED_SCREEN_W_REND', 'GL_TANGENT_ARRAY_EXT', 'GL_BINORMAL_ARRAY_EXT',
'GL_CURRENT_TANGENT_EXT', 'GL_CURRENT_BINORMAL_EXT',
'GL_TANGENT_ARRAY_TYPE_EXT', 'GL_TANGENT_ARRAY_STRIDE_EXT',
'GL_BINORMAL_ARRAY_TYPE_EXT', 'GL_BINORMAL_ARRAY_STRIDE_EXT',
'GL_TANGENT_ARRAY_POINTER_EXT', 'GL_BINORMAL_ARRAY_POINTER_EXT',
'GL_MAP1_TANGENT_EXT', 'GL_MAP2_TANGENT_EXT', 'GL_MAP1_BINORMAL_EXT',
'GL_MAP2_BINORMAL_EXT', 'GL_COMBINE_EXT', 'GL_COMBINE_RGB_EXT',
'GL_COMBINE_ALPHA_EXT', 'GL_RGB_SCALE_EXT', 'GL_ADD_SIGNED_EXT',
'GL_INTERPOLATE_EXT', 'GL_CONSTANT_EXT', 'GL_PRIMARY_COLOR_EXT',
'GL_PREVIOUS_EXT', 'GL_SOURCE0_RGB_EXT', 'GL_SOURCE1_RGB_EXT',
'GL_SOURCE2_RGB_EXT', 'GL_SOURCE0_ALPHA_EXT', 'GL_SOURCE1_ALPHA_EXT',
'GL_SOURCE2_ALPHA_EXT', 'GL_OPERAND0_RGB_EXT', 'GL_OPERAND1_RGB_EXT',
'GL_OPERAND2_RGB_EXT', 'GL_OPERAND0_ALPHA_EXT', 'GL_OPERAND1_ALPHA_EXT',
'GL_OPERAND2_ALPHA_EXT', 'GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE',
'GL_TRANSFORM_HINT_APPLE', 'GL_FOG_SCALE_SGIX', 'GL_FOG_SCALE_VALUE_SGIX',
'GL_UNPACK_CONSTANT_DATA_SUNX', 'GL_TEXTURE_CONSTANT_DATA_SUNX',
'GL_GLOBAL_ALPHA_SUN', 'GL_GLOBAL_ALPHA_FACTOR_SUN', 'GL_RESTART_SUN',
'GL_REPLACE_MIDDLE_SUN', 'GL_REPLACE_OLDEST_SUN', 'GL_TRIANGLE_LIST_SUN',
'GL_REPLACEMENT_CODE_SUN', 'GL_REPLACEMENT_CODE_ARRAY_SUN',
'GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN', 'GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN',
'GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN', 'GL_R1UI_V3F_SUN',
'GL_R1UI_C4UB_V3F_SUN', 'GL_R1UI_C3F_V3F_SUN', 'GL_R1UI_N3F_V3F_SUN',
'GL_R1UI_C4F_N3F_V3F_SUN', 'GL_R1UI_T2F_V3F_SUN', 'GL_R1UI_T2F_N3F_V3F_SUN',
'GL_R1UI_T2F_C4F_N3F_V3F_SUN', 'GL_BLEND_DST_RGB_EXT', 'GL_BLEND_SRC_RGB_EXT',
'GL_BLEND_DST_ALPHA_EXT', 'GL_BLEND_SRC_ALPHA_EXT', 'GL_RED_MIN_CLAMP_INGR',
'GL_GREEN_MIN_CLAMP_INGR', 'GL_BLUE_MIN_CLAMP_INGR',
'GL_ALPHA_MIN_CLAMP_INGR', 'GL_RED_MAX_CLAMP_INGR', 'GL_GREEN_MAX_CLAMP_INGR',
'GL_BLUE_MAX_CLAMP_INGR', 'GL_ALPHA_MAX_CLAMP_INGR', 'GL_INTERLACE_READ_INGR',
'GL_INCR_WRAP_EXT', 'GL_DECR_WRAP_EXT', 'GL_422_EXT', 'GL_422_REV_EXT',
'GL_422_AVERAGE_EXT', 'GL_422_REV_AVERAGE_EXT', 'GL_NORMAL_MAP_NV',
'GL_REFLECTION_MAP_NV', 'GL_NORMAL_MAP_EXT', 'GL_REFLECTION_MAP_EXT',
'GL_TEXTURE_CUBE_MAP_EXT', 'GL_TEXTURE_BINDING_CUBE_MAP_EXT',
'GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT',
'GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT',
'GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT',
'GL_PROXY_TEXTURE_CUBE_MAP_EXT', 'GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT',
'GL_WRAP_BORDER_SUN', 'GL_MAX_TEXTURE_LOD_BIAS_EXT',
'GL_TEXTURE_FILTER_CONTROL_EXT', 'GL_TEXTURE_LOD_BIAS_EXT',
'GL_TEXTURE_MAX_ANISOTROPY_EXT', 'GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT',
'GL_MODELVIEW0_STACK_DEPTH_EXT', 'GL_MODELVIEW1_STACK_DEPTH_EXT',
'GL_MODELVIEW0_MATRIX_EXT', 'GL_MODELVIEW1_MATRIX_EXT',
'GL_VERTEX_WEIGHTING_EXT', 'GL_MODELVIEW0_EXT', 'GL_MODELVIEW1_EXT',
'GL_CURRENT_VERTEX_WEIGHT_EXT', 'GL_VERTEX_WEIGHT_ARRAY_EXT',
'GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT', 'GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT',
'GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT', 'GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT',
'GL_MAX_SHININESS_NV', 'GL_MAX_SPOT_EXPONENT_NV', 'GL_VERTEX_ARRAY_RANGE_NV',
'GL_VERTEX_ARRAY_RANGE_LENGTH_NV', 'GL_VERTEX_ARRAY_RANGE_VALID_NV',
'GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV', 'GL_VERTEX_ARRAY_RANGE_POINTER_NV',
'GL_REGISTER_COMBINERS_NV', 'GL_VARIABLE_A_NV', 'GL_VARIABLE_B_NV',
'GL_VARIABLE_C_NV', 'GL_VARIABLE_D_NV', 'GL_VARIABLE_E_NV',
'GL_VARIABLE_F_NV', 'GL_VARIABLE_G_NV', 'GL_CONSTANT_COLOR0_NV',
'GL_CONSTANT_COLOR1_NV', 'GL_PRIMARY_COLOR_NV', 'GL_SECONDARY_COLOR_NV',
'GL_SPARE0_NV', 'GL_SPARE1_NV', 'GL_DISCARD_NV', 'GL_E_TIMES_F_NV',
'GL_SPARE0_PLUS_SECONDARY_COLOR_NV', 'GL_UNSIGNED_IDENTITY_NV',
'GL_UNSIGNED_INVERT_NV', 'GL_EXPAND_NORMAL_NV', 'GL_EXPAND_NEGATE_NV',
'GL_HALF_BIAS_NORMAL_NV', 'GL_HALF_BIAS_NEGATE_NV', 'GL_SIGNED_IDENTITY_NV',
'GL_SIGNED_NEGATE_NV', 'GL_SCALE_BY_TWO_NV', 'GL_SCALE_BY_FOUR_NV',
'GL_SCALE_BY_ONE_HALF_NV', 'GL_BIAS_BY_NEGATIVE_ONE_HALF_NV',
'GL_COMBINER_INPUT_NV', 'GL_COMBINER_MAPPING_NV',
'GL_COMBINER_COMPONENT_USAGE_NV', 'GL_COMBINER_AB_DOT_PRODUCT_NV',
'GL_COMBINER_CD_DOT_PRODUCT_NV', 'GL_COMBINER_MUX_SUM_NV',
'GL_COMBINER_SCALE_NV', 'GL_COMBINER_BIAS_NV', 'GL_COMBINER_AB_OUTPUT_NV',
'GL_COMBINER_CD_OUTPUT_NV', 'GL_COMBINER_SUM_OUTPUT_NV',
'GL_MAX_GENERAL_COMBINERS_NV', 'GL_NUM_GENERAL_COMBINERS_NV',
'GL_COLOR_SUM_CLAMP_NV', 'GL_COMBINER0_NV', 'GL_COMBINER1_NV',
'GL_COMBINER2_NV', 'GL_COMBINER3_NV', 'GL_COMBINER4_NV', 'GL_COMBINER5_NV',
'GL_COMBINER6_NV', 'GL_COMBINER7_NV', 'GL_FOG_DISTANCE_MODE_NV',
'GL_EYE_RADIAL_NV', 'GL_EYE_PLANE_ABSOLUTE_NV', 'GL_EMBOSS_LIGHT_NV',
'GL_EMBOSS_CONSTANT_NV', 'GL_EMBOSS_MAP_NV', 'GL_COMBINE4_NV',
'GL_SOURCE3_RGB_NV', 'GL_SOURCE3_ALPHA_NV', 'GL_OPERAND3_RGB_NV',
'GL_OPERAND3_ALPHA_NV', 'GL_COMPRESSED_RGB_S3TC_DXT1_EXT',
'GL_COMPRESSED_RGBA_S3TC_DXT1_EXT', 'GL_COMPRESSED_RGBA_S3TC_DXT3_EXT',
'GL_COMPRESSED_RGBA_S3TC_DXT5_EXT', 'GL_CULL_VERTEX_IBM',
'GL_VERTEX_ARRAY_LIST_IBM', 'GL_NORMAL_ARRAY_LIST_IBM',
'GL_COLOR_ARRAY_LIST_IBM', 'GL_INDEX_ARRAY_LIST_IBM',
'GL_TEXTURE_COORD_ARRAY_LIST_IBM', 'GL_EDGE_FLAG_ARRAY_LIST_IBM',
'GL_FOG_COORDINATE_ARRAY_LIST_IBM', 'GL_SECONDARY_COLOR_ARRAY_LIST_IBM',
'GL_VERTEX_ARRAY_LIST_STRIDE_IBM', 'GL_NORMAL_ARRAY_LIST_STRIDE_IBM',
'GL_COLOR_ARRAY_LIST_STRIDE_IBM', 'GL_INDEX_ARRAY_LIST_STRIDE_IBM',
'GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM',
'GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM',
'GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM',
'GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM', 'GL_PACK_SUBSAMPLE_RATE_SGIX',
'GL_UNPACK_SUBSAMPLE_RATE_SGIX', 'GL_PIXEL_SUBSAMPLE_4444_SGIX',
'GL_PIXEL_SUBSAMPLE_2424_SGIX', 'GL_PIXEL_SUBSAMPLE_4242_SGIX',
'GL_YCRCB_SGIX', 'GL_YCRCBA_SGIX', 'GL_DEPTH_PASS_INSTRUMENT_SGIX',
'GL_DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX', 'GL_DEPTH_PASS_INSTRUMENT_MAX_SGIX',
'GL_COMPRESSED_RGB_FXT1_3DFX', 'GL_COMPRESSED_RGBA_FXT1_3DFX',
'GL_MULTISAMPLE_3DFX', 'GL_SAMPLE_BUFFERS_3DFX', 'GL_SAMPLES_3DFX',
'GL_MULTISAMPLE_BIT_3DFX', 'GL_MULTISAMPLE_EXT',
'GL_SAMPLE_ALPHA_TO_MASK_EXT', 'GL_SAMPLE_ALPHA_TO_ONE_EXT',
'GL_SAMPLE_MASK_EXT', 'GL_1PASS_EXT', 'GL_2PASS_0_EXT', 'GL_2PASS_1_EXT',
'GL_4PASS_0_EXT', 'GL_4PASS_1_EXT', 'GL_4PASS_2_EXT', 'GL_4PASS_3_EXT',
'GL_SAMPLE_BUFFERS_EXT', 'GL_SAMPLES_EXT', 'GL_SAMPLE_MASK_VALUE_EXT',
'GL_SAMPLE_MASK_INVERT_EXT', 'GL_SAMPLE_PATTERN_EXT',
'GL_MULTISAMPLE_BIT_EXT', 'GL_VERTEX_PRECLIP_SGIX',
'GL_VERTEX_PRECLIP_HINT_SGIX', 'GL_CONVOLUTION_HINT_SGIX',
'GL_PACK_RESAMPLE_SGIX', 'GL_UNPACK_RESAMPLE_SGIX',
'GL_RESAMPLE_REPLICATE_SGIX', 'GL_RESAMPLE_ZERO_FILL_SGIX',
'GL_RESAMPLE_DECIMATE_SGIX', 'GL_EYE_DISTANCE_TO_POINT_SGIS',
'GL_OBJECT_DISTANCE_TO_POINT_SGIS', 'GL_EYE_DISTANCE_TO_LINE_SGIS',
'GL_OBJECT_DISTANCE_TO_LINE_SGIS', 'GL_EYE_POINT_SGIS',
'GL_OBJECT_POINT_SGIS', 'GL_EYE_LINE_SGIS', 'GL_OBJECT_LINE_SGIS',
'GL_TEXTURE_COLOR_WRITEMASK_SGIS', 'GL_DOT3_RGB_EXT', 'GL_DOT3_RGBA_EXT',
'GL_MIRROR_CLAMP_ATI', 'GL_MIRROR_CLAMP_TO_EDGE_ATI', 'GL_ALL_COMPLETED_NV',
'GL_FENCE_STATUS_NV', 'GL_FENCE_CONDITION_NV', 'GL_MIRRORED_REPEAT_IBM',
'GL_EVAL_2D_NV', 'GL_EVAL_TRIANGULAR_2D_NV', 'GL_MAP_TESSELLATION_NV',
'GL_MAP_ATTRIB_U_ORDER_NV', 'GL_MAP_ATTRIB_V_ORDER_NV',
'GL_EVAL_FRACTIONAL_TESSELLATION_NV', 'GL_EVAL_VERTEX_ATTRIB0_NV',
'GL_EVAL_VERTEX_ATTRIB1_NV', 'GL_EVAL_VERTEX_ATTRIB2_NV',
'GL_EVAL_VERTEX_ATTRIB3_NV', 'GL_EVAL_VERTEX_ATTRIB4_NV',
'GL_EVAL_VERTEX_ATTRIB5_NV', 'GL_EVAL_VERTEX_ATTRIB6_NV',
'GL_EVAL_VERTEX_ATTRIB7_NV', 'GL_EVAL_VERTEX_ATTRIB8_NV',
'GL_EVAL_VERTEX_ATTRIB9_NV', 'GL_EVAL_VERTEX_ATTRIB10_NV',
'GL_EVAL_VERTEX_ATTRIB11_NV', 'GL_EVAL_VERTEX_ATTRIB12_NV',
'GL_EVAL_VERTEX_ATTRIB13_NV', 'GL_EVAL_VERTEX_ATTRIB14_NV',
'GL_EVAL_VERTEX_ATTRIB15_NV', 'GL_MAX_MAP_TESSELLATION_NV',
'GL_MAX_RATIONAL_EVAL_ORDER_NV', 'GL_DEPTH_STENCIL_NV',
'GL_UNSIGNED_INT_24_8_NV', 'GL_PER_STAGE_CONSTANTS_NV',
'GL_TEXTURE_RECTANGLE_NV', 'GL_TEXTURE_BINDING_RECTANGLE_NV',
'GL_PROXY_TEXTURE_RECTANGLE_NV', 'GL_MAX_RECTANGLE_TEXTURE_SIZE_NV',
'GL_OFFSET_TEXTURE_RECTANGLE_NV', 'GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV',
'GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV',
'GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV', 'GL_UNSIGNED_INT_S8_S8_8_8_NV',
'GL_UNSIGNED_INT_8_8_S8_S8_REV_NV', 'GL_DSDT_MAG_INTENSITY_NV',
'GL_SHADER_CONSISTENT_NV', 'GL_TEXTURE_SHADER_NV', 'GL_SHADER_OPERATION_NV',
'GL_CULL_MODES_NV', 'GL_OFFSET_TEXTURE_MATRIX_NV',
'GL_OFFSET_TEXTURE_SCALE_NV', 'GL_OFFSET_TEXTURE_BIAS_NV',
'GL_OFFSET_TEXTURE_2D_MATRIX_NV', 'GL_OFFSET_TEXTURE_2D_SCALE_NV',
'GL_OFFSET_TEXTURE_2D_BIAS_NV', 'GL_PREVIOUS_TEXTURE_INPUT_NV',
'GL_CONST_EYE_NV', 'GL_PASS_THROUGH_NV', 'GL_CULL_FRAGMENT_NV',
'GL_OFFSET_TEXTURE_2D_NV', 'GL_DEPENDENT_AR_TEXTURE_2D_NV',
'GL_DEPENDENT_GB_TEXTURE_2D_NV', 'GL_DOT_PRODUCT_NV',
'GL_DOT_PRODUCT_DEPTH_REPLACE_NV', 'GL_DOT_PRODUCT_TEXTURE_2D_NV',
'GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV', 'GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV',
'GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV',
'GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV', 'GL_HILO_NV', 'GL_DSDT_NV',
'GL_DSDT_MAG_NV', 'GL_DSDT_MAG_VIB_NV', 'GL_HILO16_NV', 'GL_SIGNED_HILO_NV',
'GL_SIGNED_HILO16_NV', 'GL_SIGNED_RGBA_NV', 'GL_SIGNED_RGBA8_NV',
'GL_SIGNED_RGB_NV', 'GL_SIGNED_RGB8_NV', 'GL_SIGNED_LUMINANCE_NV',
'GL_SIGNED_LUMINANCE8_NV', 'GL_SIGNED_LUMINANCE_ALPHA_NV',
'GL_SIGNED_LUMINANCE8_ALPHA8_NV', 'GL_SIGNED_ALPHA_NV', 'GL_SIGNED_ALPHA8_NV',
'GL_SIGNED_INTENSITY_NV', 'GL_SIGNED_INTENSITY8_NV', 'GL_DSDT8_NV',
'GL_DSDT8_MAG8_NV', 'GL_DSDT8_MAG8_INTENSITY8_NV',
'GL_SIGNED_RGB_UNSIGNED_ALPHA_NV', 'GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV',
'GL_HI_SCALE_NV', 'GL_LO_SCALE_NV', 'GL_DS_SCALE_NV', 'GL_DT_SCALE_NV',
'GL_MAGNITUDE_SCALE_NV', 'GL_VIBRANCE_SCALE_NV', 'GL_HI_BIAS_NV',
'GL_LO_BIAS_NV', 'GL_DS_BIAS_NV', 'GL_DT_BIAS_NV', 'GL_MAGNITUDE_BIAS_NV',
'GL_VIBRANCE_BIAS_NV', 'GL_TEXTURE_BORDER_VALUES_NV', 'GL_TEXTURE_HI_SIZE_NV',
'GL_TEXTURE_LO_SIZE_NV', 'GL_TEXTURE_DS_SIZE_NV', 'GL_TEXTURE_DT_SIZE_NV',
'GL_TEXTURE_MAG_SIZE_NV', 'GL_DOT_PRODUCT_TEXTURE_3D_NV',
'GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV', 'GL_VERTEX_PROGRAM_NV',
'GL_VERTEX_STATE_PROGRAM_NV', 'GL_ATTRIB_ARRAY_SIZE_NV',
'GL_ATTRIB_ARRAY_STRIDE_NV', 'GL_ATTRIB_ARRAY_TYPE_NV',
'GL_CURRENT_ATTRIB_NV', 'GL_PROGRAM_LENGTH_NV', 'GL_PROGRAM_STRING_NV',
'GL_MODELVIEW_PROJECTION_NV', 'GL_IDENTITY_NV', 'GL_INVERSE_NV',
'GL_TRANSPOSE_NV', 'GL_INVERSE_TRANSPOSE_NV',
'GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV', 'GL_MAX_TRACK_MATRICES_NV',
'GL_MATRIX0_NV', 'GL_MATRIX1_NV', 'GL_MATRIX2_NV', 'GL_MATRIX3_NV',
'GL_MATRIX4_NV', 'GL_MATRIX5_NV', 'GL_MATRIX6_NV', 'GL_MATRIX7_NV',
'GL_CURRENT_MATRIX_STACK_DEPTH_NV', 'GL_CURRENT_MATRIX_NV',
'GL_VERTEX_PROGRAM_POINT_SIZE_NV', 'GL_VERTEX_PROGRAM_TWO_SIDE_NV',
'GL_PROGRAM_PARAMETER_NV', 'GL_ATTRIB_ARRAY_POINTER_NV',
'GL_PROGRAM_TARGET_NV', 'GL_PROGRAM_RESIDENT_NV', 'GL_TRACK_MATRIX_NV',
'GL_TRACK_MATRIX_TRANSFORM_NV', 'GL_VERTEX_PROGRAM_BINDING_NV',
'GL_PROGRAM_ERROR_POSITION_NV', 'GL_VERTEX_ATTRIB_ARRAY0_NV',
'GL_VERTEX_ATTRIB_ARRAY1_NV', 'GL_VERTEX_ATTRIB_ARRAY2_NV',
'GL_VERTEX_ATTRIB_ARRAY3_NV', 'GL_VERTEX_ATTRIB_ARRAY4_NV',
'GL_VERTEX_ATTRIB_ARRAY5_NV', 'GL_VERTEX_ATTRIB_ARRAY6_NV',
'GL_VERTEX_ATTRIB_ARRAY7_NV', 'GL_VERTEX_ATTRIB_ARRAY8_NV',
'GL_VERTEX_ATTRIB_ARRAY9_NV', 'GL_VERTEX_ATTRIB_ARRAY10_NV',
'GL_VERTEX_ATTRIB_ARRAY11_NV', 'GL_VERTEX_ATTRIB_ARRAY12_NV',
'GL_VERTEX_ATTRIB_ARRAY13_NV', 'GL_VERTEX_ATTRIB_ARRAY14_NV',
'GL_VERTEX_ATTRIB_ARRAY15_NV', 'GL_MAP1_VERTEX_ATTRIB0_4_NV',
'GL_MAP1_VERTEX_ATTRIB1_4_NV', 'GL_MAP1_VERTEX_ATTRIB2_4_NV',
'GL_MAP1_VERTEX_ATTRIB3_4_NV', 'GL_MAP1_VERTEX_ATTRIB4_4_NV',
'GL_MAP1_VERTEX_ATTRIB5_4_NV', 'GL_MAP1_VERTEX_ATTRIB6_4_NV',
'GL_MAP1_VERTEX_ATTRIB7_4_NV', 'GL_MAP1_VERTEX_ATTRIB8_4_NV',
'GL_MAP1_VERTEX_ATTRIB9_4_NV', 'GL_MAP1_VERTEX_ATTRIB10_4_NV',
'GL_MAP1_VERTEX_ATTRIB11_4_NV', 'GL_MAP1_VERTEX_ATTRIB12_4_NV',
'GL_MAP1_VERTEX_ATTRIB13_4_NV', 'GL_MAP1_VERTEX_ATTRIB14_4_NV',
'GL_MAP1_VERTEX_ATTRIB15_4_NV', 'GL_MAP2_VERTEX_ATTRIB0_4_NV',
'GL_MAP2_VERTEX_ATTRIB1_4_NV', 'GL_MAP2_VERTEX_ATTRIB2_4_NV',
'GL_MAP2_VERTEX_ATTRIB3_4_NV', 'GL_MAP2_VERTEX_ATTRIB4_4_NV',
'GL_MAP2_VERTEX_ATTRIB5_4_NV', 'GL_MAP2_VERTEX_ATTRIB6_4_NV',
'GL_MAP2_VERTEX_ATTRIB7_4_NV', 'GL_MAP2_VERTEX_ATTRIB8_4_NV',
'GL_MAP2_VERTEX_ATTRIB9_4_NV', 'GL_MAP2_VERTEX_ATTRIB10_4_NV',
'GL_MAP2_VERTEX_ATTRIB11_4_NV', 'GL_MAP2_VERTEX_ATTRIB12_4_NV',
'GL_MAP2_VERTEX_ATTRIB13_4_NV', 'GL_MAP2_VERTEX_ATTRIB14_4_NV',
'GL_MAP2_VERTEX_ATTRIB15_4_NV', 'GL_TEXTURE_MAX_CLAMP_S_SGIX',
'GL_TEXTURE_MAX_CLAMP_T_SGIX', 'GL_TEXTURE_MAX_CLAMP_R_SGIX',
'GL_SCALEBIAS_HINT_SGIX', 'GL_INTERLACE_OML', 'GL_INTERLACE_READ_OML',
'GL_FORMAT_SUBSAMPLE_24_24_OML', 'GL_FORMAT_SUBSAMPLE_244_244_OML',
'GL_PACK_RESAMPLE_OML', 'GL_UNPACK_RESAMPLE_OML', 'GL_RESAMPLE_REPLICATE_OML',
'GL_RESAMPLE_ZERO_FILL_OML', 'GL_RESAMPLE_AVERAGE_OML',
'GL_RESAMPLE_DECIMATE_OML', 'GL_DEPTH_STENCIL_TO_RGBA_NV',
'GL_DEPTH_STENCIL_TO_BGRA_NV', 'GL_BUMP_ROT_MATRIX_ATI',
'GL_BUMP_ROT_MATRIX_SIZE_ATI', 'GL_BUMP_NUM_TEX_UNITS_ATI',
'GL_BUMP_TEX_UNITS_ATI', 'GL_DUDV_ATI', 'GL_DU8DV8_ATI', 'GL_BUMP_ENVMAP_ATI',
'GL_BUMP_TARGET_ATI', 'GL_FRAGMENT_SHADER_ATI', 'GL_REG_0_ATI',
'GL_REG_1_ATI', 'GL_REG_2_ATI', 'GL_REG_3_ATI', 'GL_REG_4_ATI',
'GL_REG_5_ATI', 'GL_REG_6_ATI', 'GL_REG_7_ATI', 'GL_REG_8_ATI',
'GL_REG_9_ATI', 'GL_REG_10_ATI', 'GL_REG_11_ATI', 'GL_REG_12_ATI',
'GL_REG_13_ATI', 'GL_REG_14_ATI', 'GL_REG_15_ATI', 'GL_REG_16_ATI',
'GL_REG_17_ATI', 'GL_REG_18_ATI', 'GL_REG_19_ATI', 'GL_REG_20_ATI',
'GL_REG_21_ATI', 'GL_REG_22_ATI', 'GL_REG_23_ATI', 'GL_REG_24_ATI',
'GL_REG_25_ATI', 'GL_REG_26_ATI', 'GL_REG_27_ATI', 'GL_REG_28_ATI',
'GL_REG_29_ATI', 'GL_REG_30_ATI', 'GL_REG_31_ATI', 'GL_CON_0_ATI',
'GL_CON_1_ATI', 'GL_CON_2_ATI', 'GL_CON_3_ATI', 'GL_CON_4_ATI',
'GL_CON_5_ATI', 'GL_CON_6_ATI', 'GL_CON_7_ATI', 'GL_CON_8_ATI',
'GL_CON_9_ATI', 'GL_CON_10_ATI', 'GL_CON_11_ATI', 'GL_CON_12_ATI',
'GL_CON_13_ATI', 'GL_CON_14_ATI', 'GL_CON_15_ATI', 'GL_CON_16_ATI',
'GL_CON_17_ATI', 'GL_CON_18_ATI', 'GL_CON_19_ATI', 'GL_CON_20_ATI',
'GL_CON_21_ATI', 'GL_CON_22_ATI', 'GL_CON_23_ATI', 'GL_CON_24_ATI',
'GL_CON_25_ATI', 'GL_CON_26_ATI', 'GL_CON_27_ATI', 'GL_CON_28_ATI',
'GL_CON_29_ATI', 'GL_CON_30_ATI', 'GL_CON_31_ATI', 'GL_MOV_ATI', 'GL_ADD_ATI',
'GL_MUL_ATI', 'GL_SUB_ATI', 'GL_DOT3_ATI', 'GL_DOT4_ATI', 'GL_MAD_ATI',
'GL_LERP_ATI', 'GL_CND_ATI', 'GL_CND0_ATI', 'GL_DOT2_ADD_ATI',
'GL_SECONDARY_INTERPOLATOR_ATI', 'GL_NUM_FRAGMENT_REGISTERS_ATI',
'GL_NUM_FRAGMENT_CONSTANTS_ATI', 'GL_NUM_PASSES_ATI',
'GL_NUM_INSTRUCTIONS_PER_PASS_ATI', 'GL_NUM_INSTRUCTIONS_TOTAL_ATI',
'GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI', 'GL_NUM_LOOPBACK_COMPONENTS_ATI',
'GL_COLOR_ALPHA_PAIRING_ATI', 'GL_SWIZZLE_STR_ATI', 'GL_SWIZZLE_STQ_ATI',
'GL_SWIZZLE_STR_DR_ATI', 'GL_SWIZZLE_STQ_DQ_ATI', 'GL_SWIZZLE_STRQ_ATI',
'GL_SWIZZLE_STRQ_DQ_ATI', 'GL_RED_BIT_ATI', 'GL_GREEN_BIT_ATI',
'GL_BLUE_BIT_ATI', 'GL_2X_BIT_ATI', 'GL_4X_BIT_ATI', 'GL_8X_BIT_ATI',
'GL_HALF_BIT_ATI', 'GL_QUARTER_BIT_ATI', 'GL_EIGHTH_BIT_ATI',
'GL_SATURATE_BIT_ATI', 'GL_COMP_BIT_ATI', 'GL_NEGATE_BIT_ATI',
'GL_BIAS_BIT_ATI', 'GL_PN_TRIANGLES_ATI',
'GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI', 'GL_PN_TRIANGLES_POINT_MODE_ATI',
'GL_PN_TRIANGLES_NORMAL_MODE_ATI', 'GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI',
'GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI',
'GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI',
'GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI',
'GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI', 'GL_STATIC_ATI',
'GL_DYNAMIC_ATI', 'GL_PRESERVE_ATI', 'GL_DISCARD_ATI',
'GL_OBJECT_BUFFER_SIZE_ATI', 'GL_OBJECT_BUFFER_USAGE_ATI',
'GL_ARRAY_OBJECT_BUFFER_ATI', 'GL_ARRAY_OBJECT_OFFSET_ATI',
'GL_VERTEX_SHADER_EXT', 'GL_VERTEX_SHADER_BINDING_EXT', 'GL_OP_INDEX_EXT',
'GL_OP_NEGATE_EXT', 'GL_OP_DOT3_EXT', 'GL_OP_DOT4_EXT', 'GL_OP_MUL_EXT',
'GL_OP_ADD_EXT', 'GL_OP_MADD_EXT', 'GL_OP_FRAC_EXT', 'GL_OP_MAX_EXT',
'GL_OP_MIN_EXT', 'GL_OP_SET_GE_EXT', 'GL_OP_SET_LT_EXT', 'GL_OP_CLAMP_EXT',
'GL_OP_FLOOR_EXT', 'GL_OP_ROUND_EXT', 'GL_OP_EXP_BASE_2_EXT',
'GL_OP_LOG_BASE_2_EXT', 'GL_OP_POWER_EXT', 'GL_OP_RECIP_EXT',
'GL_OP_RECIP_SQRT_EXT', 'GL_OP_SUB_EXT', 'GL_OP_CROSS_PRODUCT_EXT',
'GL_OP_MULTIPLY_MATRIX_EXT', 'GL_OP_MOV_EXT', 'GL_OUTPUT_VERTEX_EXT',
'GL_OUTPUT_COLOR0_EXT', 'GL_OUTPUT_COLOR1_EXT',
'GL_OUTPUT_TEXTURE_COORD0_EXT', 'GL_OUTPUT_TEXTURE_COORD1_EXT',
'GL_OUTPUT_TEXTURE_COORD2_EXT', 'GL_OUTPUT_TEXTURE_COORD3_EXT',
'GL_OUTPUT_TEXTURE_COORD4_EXT', 'GL_OUTPUT_TEXTURE_COORD5_EXT',
'GL_OUTPUT_TEXTURE_COORD6_EXT', 'GL_OUTPUT_TEXTURE_COORD7_EXT',
'GL_OUTPUT_TEXTURE_COORD8_EXT', 'GL_OUTPUT_TEXTURE_COORD9_EXT',
'GL_OUTPUT_TEXTURE_COORD10_EXT', 'GL_OUTPUT_TEXTURE_COORD11_EXT',
'GL_OUTPUT_TEXTURE_COORD12_EXT', 'GL_OUTPUT_TEXTURE_COORD13_EXT',
'GL_OUTPUT_TEXTURE_COORD14_EXT', 'GL_OUTPUT_TEXTURE_COORD15_EXT',
'GL_OUTPUT_TEXTURE_COORD16_EXT', 'GL_OUTPUT_TEXTURE_COORD17_EXT',
'GL_OUTPUT_TEXTURE_COORD18_EXT', 'GL_OUTPUT_TEXTURE_COORD19_EXT',
'GL_OUTPUT_TEXTURE_COORD20_EXT', 'GL_OUTPUT_TEXTURE_COORD21_EXT',
'GL_OUTPUT_TEXTURE_COORD22_EXT', 'GL_OUTPUT_TEXTURE_COORD23_EXT',
'GL_OUTPUT_TEXTURE_COORD24_EXT', 'GL_OUTPUT_TEXTURE_COORD25_EXT',
'GL_OUTPUT_TEXTURE_COORD26_EXT', 'GL_OUTPUT_TEXTURE_COORD27_EXT',
'GL_OUTPUT_TEXTURE_COORD28_EXT', 'GL_OUTPUT_TEXTURE_COORD29_EXT',
'GL_OUTPUT_TEXTURE_COORD30_EXT', 'GL_OUTPUT_TEXTURE_COORD31_EXT',
'GL_OUTPUT_FOG_EXT', 'GL_SCALAR_EXT', 'GL_VECTOR_EXT', 'GL_MATRIX_EXT',
'GL_VARIANT_EXT', 'GL_INVARIANT_EXT', 'GL_LOCAL_CONSTANT_EXT', 'GL_LOCAL_EXT',
'GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT', 'GL_MAX_VERTEX_SHADER_VARIANTS_EXT',
'GL_MAX_VERTEX_SHADER_INVARIANTS_EXT',
'GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT', 'GL_MAX_VERTEX_SHADER_LOCALS_EXT',
'GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT',
'GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT',
'GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT',
'GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT',
'GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT',
'GL_VERTEX_SHADER_INSTRUCTIONS_EXT', 'GL_VERTEX_SHADER_VARIANTS_EXT',
'GL_VERTEX_SHADER_INVARIANTS_EXT', 'GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT',
'GL_VERTEX_SHADER_LOCALS_EXT', 'GL_VERTEX_SHADER_OPTIMIZED_EXT', 'GL_X_EXT',
'GL_Y_EXT', 'GL_Z_EXT', 'GL_W_EXT', 'GL_NEGATIVE_X_EXT', 'GL_NEGATIVE_Y_EXT',
'GL_NEGATIVE_Z_EXT', 'GL_NEGATIVE_W_EXT', 'GL_ZERO_EXT', 'GL_ONE_EXT',
'GL_NEGATIVE_ONE_EXT', 'GL_NORMALIZED_RANGE_EXT', 'GL_FULL_RANGE_EXT',
'GL_CURRENT_VERTEX_EXT', 'GL_MVP_MATRIX_EXT', 'GL_VARIANT_VALUE_EXT',
'GL_VARIANT_DATATYPE_EXT', 'GL_VARIANT_ARRAY_STRIDE_EXT',
'GL_VARIANT_ARRAY_TYPE_EXT', 'GL_VARIANT_ARRAY_EXT',
'GL_VARIANT_ARRAY_POINTER_EXT', 'GL_INVARIANT_VALUE_EXT',
'GL_INVARIANT_DATATYPE_EXT', 'GL_LOCAL_CONSTANT_VALUE_EXT',
'GL_LOCAL_CONSTANT_DATATYPE_EXT', 'GL_MAX_VERTEX_STREAMS_ATI',
'GL_VERTEX_STREAM0_ATI', 'GL_VERTEX_STREAM1_ATI', 'GL_VERTEX_STREAM2_ATI',
'GL_VERTEX_STREAM3_ATI', 'GL_VERTEX_STREAM4_ATI', 'GL_VERTEX_STREAM5_ATI',
'GL_VERTEX_STREAM6_ATI', 'GL_VERTEX_STREAM7_ATI', 'GL_VERTEX_SOURCE_ATI',
'GL_ELEMENT_ARRAY_ATI', 'GL_ELEMENT_ARRAY_TYPE_ATI',
'GL_ELEMENT_ARRAY_POINTER_ATI', 'GL_QUAD_MESH_SUN', 'GL_TRIANGLE_MESH_SUN',
'GL_SLICE_ACCUM_SUN', 'GL_MULTISAMPLE_FILTER_HINT_NV', 'GL_DEPTH_CLAMP_NV',
'GL_PIXEL_COUNTER_BITS_NV', 'GL_CURRENT_OCCLUSION_QUERY_ID_NV',
'GL_PIXEL_COUNT_NV', 'GL_PIXEL_COUNT_AVAILABLE_NV', 'GL_POINT_SPRITE_NV',
'GL_COORD_REPLACE_NV', 'GL_POINT_SPRITE_R_MODE_NV',
'GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV',
'GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV',
'GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV',
'GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV',
'GL_OFFSET_HILO_TEXTURE_2D_NV', 'GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV',
'GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV',
'GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV',
'GL_DEPENDENT_HILO_TEXTURE_2D_NV', 'GL_DEPENDENT_RGB_TEXTURE_3D_NV',
'GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV', 'GL_DOT_PRODUCT_PASS_THROUGH_NV',
'GL_DOT_PRODUCT_TEXTURE_1D_NV', 'GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV',
'GL_HILO8_NV', 'GL_SIGNED_HILO8_NV', 'GL_FORCE_BLUE_TO_ONE_NV',
'GL_STENCIL_TEST_TWO_SIDE_EXT', 'GL_ACTIVE_STENCIL_FACE_EXT',
'GL_TEXT_FRAGMENT_SHADER_ATI', 'GL_UNPACK_CLIENT_STORAGE_APPLE',
'GL_ELEMENT_ARRAY_APPLE', 'GL_ELEMENT_ARRAY_TYPE_APPLE',
'GL_ELEMENT_ARRAY_POINTER_APPLE', 'GL_DRAW_PIXELS_APPLE', 'GL_FENCE_APPLE',
'GL_VERTEX_ARRAY_BINDING_APPLE', 'GL_VERTEX_ARRAY_RANGE_APPLE',
'GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE', 'GL_VERTEX_ARRAY_STORAGE_HINT_APPLE',
'GL_VERTEX_ARRAY_RANGE_POINTER_APPLE', 'GL_STORAGE_CACHED_APPLE',
'GL_STORAGE_SHARED_APPLE', 'GL_YCBCR_422_APPLE',
'GL_UNSIGNED_SHORT_8_8_APPLE', 'GL_UNSIGNED_SHORT_8_8_REV_APPLE',
'GL_RGB_S3TC', 'GL_RGB4_S3TC', 'GL_RGBA_S3TC', 'GL_RGBA4_S3TC',
'GL_MAX_DRAW_BUFFERS_ATI', 'GL_DRAW_BUFFER0_ATI', 'GL_DRAW_BUFFER1_ATI',
'GL_DRAW_BUFFER2_ATI', 'GL_DRAW_BUFFER3_ATI', 'GL_DRAW_BUFFER4_ATI',
'GL_DRAW_BUFFER5_ATI', 'GL_DRAW_BUFFER6_ATI', 'GL_DRAW_BUFFER7_ATI',
'GL_DRAW_BUFFER8_ATI', 'GL_DRAW_BUFFER9_ATI', 'GL_DRAW_BUFFER10_ATI',
'GL_DRAW_BUFFER11_ATI', 'GL_DRAW_BUFFER12_ATI', 'GL_DRAW_BUFFER13_ATI',
'GL_DRAW_BUFFER14_ATI', 'GL_DRAW_BUFFER15_ATI', 'GL_TYPE_RGBA_FLOAT_ATI',
'GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI', 'GL_MODULATE_ADD_ATI',
'GL_MODULATE_SIGNED_ADD_ATI', 'GL_MODULATE_SUBTRACT_ATI',
'GL_RGBA_FLOAT32_ATI', 'GL_RGB_FLOAT32_ATI', 'GL_ALPHA_FLOAT32_ATI',
'GL_INTENSITY_FLOAT32_ATI', 'GL_LUMINANCE_FLOAT32_ATI',
'GL_LUMINANCE_ALPHA_FLOAT32_ATI', 'GL_RGBA_FLOAT16_ATI', 'GL_RGB_FLOAT16_ATI',
'GL_ALPHA_FLOAT16_ATI', 'GL_INTENSITY_FLOAT16_ATI',
'GL_LUMINANCE_FLOAT16_ATI', 'GL_LUMINANCE_ALPHA_FLOAT16_ATI', 'GL_FLOAT_R_NV',
'GL_FLOAT_RG_NV', 'GL_FLOAT_RGB_NV', 'GL_FLOAT_RGBA_NV', 'GL_FLOAT_R16_NV',
'GL_FLOAT_R32_NV', 'GL_FLOAT_RG16_NV', 'GL_FLOAT_RG32_NV',
'GL_FLOAT_RGB16_NV', 'GL_FLOAT_RGB32_NV', 'GL_FLOAT_RGBA16_NV',
'GL_FLOAT_RGBA32_NV', 'GL_TEXTURE_FLOAT_COMPONENTS_NV',
'GL_FLOAT_CLEAR_COLOR_VALUE_NV', 'GL_FLOAT_RGBA_MODE_NV',
'GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV', 'GL_FRAGMENT_PROGRAM_NV',
'GL_MAX_TEXTURE_COORDS_NV', 'GL_MAX_TEXTURE_IMAGE_UNITS_NV',
'GL_FRAGMENT_PROGRAM_BINDING_NV', 'GL_PROGRAM_ERROR_STRING_NV',
'GL_HALF_FLOAT_NV', 'GL_WRITE_PIXEL_DATA_RANGE_NV',
'GL_READ_PIXEL_DATA_RANGE_NV', 'GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV',
'GL_READ_PIXEL_DATA_RANGE_LENGTH_NV', 'GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV',
'GL_READ_PIXEL_DATA_RANGE_POINTER_NV', 'GL_PRIMITIVE_RESTART_NV',
'GL_PRIMITIVE_RESTART_INDEX_NV', 'GL_TEXTURE_UNSIGNED_REMAP_MODE_NV',
'GL_STENCIL_BACK_FUNC_ATI', 'GL_STENCIL_BACK_FAIL_ATI',
'GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI', 'GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI',
'GL_IMPLEMENTATION_COLOR_READ_TYPE_OES',
'GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES', 'GL_DEPTH_BOUNDS_TEST_EXT',
'GL_DEPTH_BOUNDS_EXT', 'GL_MIRROR_CLAMP_EXT', 'GL_MIRROR_CLAMP_TO_EDGE_EXT',
'GL_MIRROR_CLAMP_TO_BORDER_EXT', 'GL_BLEND_EQUATION_RGB_EXT',
'GL_BLEND_EQUATION_ALPHA_EXT', 'GL_PACK_INVERT_MESA',
'GL_UNSIGNED_SHORT_8_8_MESA', 'GL_UNSIGNED_SHORT_8_8_REV_MESA',
'GL_YCBCR_MESA', 'GL_PIXEL_PACK_BUFFER_EXT', 'GL_PIXEL_UNPACK_BUFFER_EXT',
'GL_PIXEL_PACK_BUFFER_BINDING_EXT', 'GL_PIXEL_UNPACK_BUFFER_BINDING_EXT',
'GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV', 'GL_MAX_PROGRAM_CALL_DEPTH_NV',
'GL_MAX_PROGRAM_IF_DEPTH_NV', 'GL_MAX_PROGRAM_LOOP_DEPTH_NV',
'GL_MAX_PROGRAM_LOOP_COUNT_NV', 'GL_INVALID_FRAMEBUFFER_OPERATION_EXT',
'GL_MAX_RENDERBUFFER_SIZE_EXT', 'GL_FRAMEBUFFER_BINDING_EXT',
'GL_RENDERBUFFER_BINDING_EXT', 'GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT',
'GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT',
'GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT',
'GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT',
'GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT',
'GL_FRAMEBUFFER_COMPLETE_EXT', 'GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT',
'GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT',
'GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT_EXT',
'GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT',
'GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT',
'GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT',
'GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT', 'GL_FRAMEBUFFER_UNSUPPORTED_EXT',
'GL_MAX_COLOR_ATTACHMENTS_EXT', 'GL_COLOR_ATTACHMENT0_EXT',
'GL_COLOR_ATTACHMENT1_EXT', 'GL_COLOR_ATTACHMENT2_EXT',
'GL_COLOR_ATTACHMENT3_EXT', 'GL_COLOR_ATTACHMENT4_EXT',
'GL_COLOR_ATTACHMENT5_EXT', 'GL_COLOR_ATTACHMENT6_EXT',
'GL_COLOR_ATTACHMENT7_EXT', 'GL_COLOR_ATTACHMENT8_EXT',
'GL_COLOR_ATTACHMENT9_EXT', 'GL_COLOR_ATTACHMENT10_EXT',
'GL_COLOR_ATTACHMENT11_EXT', 'GL_COLOR_ATTACHMENT12_EXT',
'GL_COLOR_ATTACHMENT13_EXT', 'GL_COLOR_ATTACHMENT14_EXT',
'GL_COLOR_ATTACHMENT15_EXT', 'GL_DEPTH_ATTACHMENT_EXT',
'GL_STENCIL_ATTACHMENT_EXT', 'GL_FRAMEBUFFER_EXT', 'GL_RENDERBUFFER_EXT',
'GL_RENDERBUFFER_WIDTH_EXT', 'GL_RENDERBUFFER_HEIGHT_EXT',
'GL_RENDERBUFFER_INTERNAL_FORMAT_EXT', 'GL_STENCIL_INDEX1_EXT',
'GL_STENCIL_INDEX4_EXT', 'GL_STENCIL_INDEX8_EXT', 'GL_STENCIL_INDEX16_EXT',
'GL_RENDERBUFFER_RED_SIZE_EXT', 'GL_RENDERBUFFER_GREEN_SIZE_EXT',
'GL_RENDERBUFFER_BLUE_SIZE_EXT', 'GL_RENDERBUFFER_ALPHA_SIZE_EXT',
'GL_RENDERBUFFER_DEPTH_SIZE_EXT', 'GL_RENDERBUFFER_STENCIL_SIZE_EXT',
'GLchar', 'GLintptr', 'GLsizeiptr', 'GLintptrARB', 'GLsizeiptrARB',
'GLcharARB', 'GLhandleARB', 'GLhalfARB', 'GLhalfNV', 'GL_VERSION_1_2',
'glBlendColor', 'glBlendEquation', 'glDrawRangeElements', 'glColorTable',
'glColorTableParameterfv', 'glColorTableParameteriv', 'glCopyColorTable',
'glGetColorTable', 'glGetColorTableParameterfv', 'glGetColorTableParameteriv',
'glColorSubTable', 'glCopyColorSubTable', 'glConvolutionFilter1D',
'glConvolutionFilter2D', 'glConvolutionParameterf',
'glConvolutionParameterfv', 'glConvolutionParameteri',
'glConvolutionParameteriv', 'glCopyConvolutionFilter1D',
'glCopyConvolutionFilter2D', 'glGetConvolutionFilter',
'glGetConvolutionParameterfv', 'glGetConvolutionParameteriv',
'glGetSeparableFilter', 'glSeparableFilter2D', 'glGetHistogram',
'glGetHistogramParameterfv', 'glGetHistogramParameteriv', 'glGetMinmax',
'glGetMinmaxParameterfv', 'glGetMinmaxParameteriv', 'glHistogram', 'glMinmax',
'glResetHistogram', 'glResetMinmax', 'glTexImage3D', 'glTexSubImage3D',
'glCopyTexSubImage3D', 'PFNGLBLENDCOLORPROC', 'PFNGLBLENDEQUATIONPROC',
'PFNGLDRAWRANGEELEMENTSPROC', 'PFNGLCOLORTABLEPROC',
'PFNGLCOLORTABLEPARAMETERFVPROC', 'PFNGLCOLORTABLEPARAMETERIVPROC',
'PFNGLCOPYCOLORTABLEPROC', 'PFNGLGETCOLORTABLEPROC',
'PFNGLGETCOLORTABLEPARAMETERFVPROC', 'PFNGLGETCOLORTABLEPARAMETERIVPROC',
'PFNGLCOLORSUBTABLEPROC', 'PFNGLCOPYCOLORSUBTABLEPROC',
'PFNGLCONVOLUTIONFILTER1DPROC', 'PFNGLCONVOLUTIONFILTER2DPROC',
'PFNGLCONVOLUTIONPARAMETERFPROC', 'PFNGLCONVOLUTIONPARAMETERFVPROC',
'PFNGLCONVOLUTIONPARAMETERIPROC', 'PFNGLCONVOLUTIONPARAMETERIVPROC',
'PFNGLCOPYCONVOLUTIONFILTER1DPROC', 'PFNGLCOPYCONVOLUTIONFILTER2DPROC',
'PFNGLGETCONVOLUTIONFILTERPROC', 'PFNGLGETCONVOLUTIONPARAMETERFVPROC',
'PFNGLGETCONVOLUTIONPARAMETERIVPROC', 'PFNGLGETSEPARABLEFILTERPROC',
'PFNGLSEPARABLEFILTER2DPROC', 'PFNGLGETHISTOGRAMPROC',
'PFNGLGETHISTOGRAMPARAMETERFVPROC', 'PFNGLGETHISTOGRAMPARAMETERIVPROC',
'PFNGLGETMINMAXPROC', 'PFNGLGETMINMAXPARAMETERFVPROC',
'PFNGLGETMINMAXPARAMETERIVPROC', 'PFNGLHISTOGRAMPROC', 'PFNGLMINMAXPROC',
'PFNGLRESETHISTOGRAMPROC', 'PFNGLRESETMINMAXPROC', 'PFNGLTEXIMAGE3DPROC',
'PFNGLTEXSUBIMAGE3DPROC', 'PFNGLCOPYTEXSUBIMAGE3DPROC', 'GL_VERSION_1_3',
'glActiveTexture', 'glClientActiveTexture', 'glMultiTexCoord1d',
'glMultiTexCoord1dv', 'glMultiTexCoord1f', 'glMultiTexCoord1fv',
'glMultiTexCoord1i', 'glMultiTexCoord1iv', 'glMultiTexCoord1s',
'glMultiTexCoord1sv', 'glMultiTexCoord2d', 'glMultiTexCoord2dv',
'glMultiTexCoord2f', 'glMultiTexCoord2fv', 'glMultiTexCoord2i',
'glMultiTexCoord2iv', 'glMultiTexCoord2s', 'glMultiTexCoord2sv',
'glMultiTexCoord3d', 'glMultiTexCoord3dv', 'glMultiTexCoord3f',
'glMultiTexCoord3fv', 'glMultiTexCoord3i', 'glMultiTexCoord3iv',
'glMultiTexCoord3s', 'glMultiTexCoord3sv', 'glMultiTexCoord4d',
'glMultiTexCoord4dv', 'glMultiTexCoord4f', 'glMultiTexCoord4fv',
'glMultiTexCoord4i', 'glMultiTexCoord4iv', 'glMultiTexCoord4s',
'glMultiTexCoord4sv', 'glLoadTransposeMatrixf', 'glLoadTransposeMatrixd',
'glMultTransposeMatrixf', 'glMultTransposeMatrixd', 'glSampleCoverage',
'glCompressedTexImage3D', 'glCompressedTexImage2D', 'glCompressedTexImage1D',
'glCompressedTexSubImage3D', 'glCompressedTexSubImage2D',
'glCompressedTexSubImage1D', 'glGetCompressedTexImage',
'PFNGLACTIVETEXTUREPROC', 'PFNGLCLIENTACTIVETEXTUREPROC',
'PFNGLMULTITEXCOORD1DPROC', 'PFNGLMULTITEXCOORD1DVPROC',
'PFNGLMULTITEXCOORD1FPROC', 'PFNGLMULTITEXCOORD1FVPROC',
'PFNGLMULTITEXCOORD1IPROC', 'PFNGLMULTITEXCOORD1IVPROC',
'PFNGLMULTITEXCOORD1SPROC', 'PFNGLMULTITEXCOORD1SVPROC',
'PFNGLMULTITEXCOORD2DPROC', 'PFNGLMULTITEXCOORD2DVPROC',
'PFNGLMULTITEXCOORD2FPROC', 'PFNGLMULTITEXCOORD2FVPROC',
'PFNGLMULTITEXCOORD2IPROC', 'PFNGLMULTITEXCOORD2IVPROC',
'PFNGLMULTITEXCOORD2SPROC', 'PFNGLMULTITEXCOORD2SVPROC',
'PFNGLMULTITEXCOORD3DPROC', 'PFNGLMULTITEXCOORD3DVPROC',
'PFNGLMULTITEXCOORD3FPROC', 'PFNGLMULTITEXCOORD3FVPROC',
'PFNGLMULTITEXCOORD3IPROC', 'PFNGLMULTITEXCOORD3IVPROC',
'PFNGLMULTITEXCOORD3SPROC', 'PFNGLMULTITEXCOORD3SVPROC',
'PFNGLMULTITEXCOORD4DPROC', 'PFNGLMULTITEXCOORD4DVPROC',
'PFNGLMULTITEXCOORD4FPROC', 'PFNGLMULTITEXCOORD4FVPROC',
'PFNGLMULTITEXCOORD4IPROC', 'PFNGLMULTITEXCOORD4IVPROC',
'PFNGLMULTITEXCOORD4SPROC', 'PFNGLMULTITEXCOORD4SVPROC',
'PFNGLLOADTRANSPOSEMATRIXFPROC', 'PFNGLLOADTRANSPOSEMATRIXDPROC',
'PFNGLMULTTRANSPOSEMATRIXFPROC', 'PFNGLMULTTRANSPOSEMATRIXDPROC',
'PFNGLSAMPLECOVERAGEPROC', 'PFNGLCOMPRESSEDTEXIMAGE3DPROC',
'PFNGLCOMPRESSEDTEXIMAGE2DPROC', 'PFNGLCOMPRESSEDTEXIMAGE1DPROC',
'PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC', 'PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC',
'PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC', 'PFNGLGETCOMPRESSEDTEXIMAGEPROC',
'GL_VERSION_1_4', 'glBlendFuncSeparate', 'glFogCoordf', 'glFogCoordfv',
'glFogCoordd', 'glFogCoorddv', 'glFogCoordPointer', 'glMultiDrawArrays',
'glMultiDrawElements', 'glPointParameterf', 'glPointParameterfv',
'glPointParameteri', 'glPointParameteriv', 'glSecondaryColor3b',
'glSecondaryColor3bv', 'glSecondaryColor3d', 'glSecondaryColor3dv',
'glSecondaryColor3f', 'glSecondaryColor3fv', 'glSecondaryColor3i',
'glSecondaryColor3iv', 'glSecondaryColor3s', 'glSecondaryColor3sv',
'glSecondaryColor3ub', 'glSecondaryColor3ubv', 'glSecondaryColor3ui',
'glSecondaryColor3uiv', 'glSecondaryColor3us', 'glSecondaryColor3usv',
'glSecondaryColorPointer', 'glWindowPos2d', 'glWindowPos2dv', 'glWindowPos2f',
'glWindowPos2fv', 'glWindowPos2i', 'glWindowPos2iv', 'glWindowPos2s',
'glWindowPos2sv', 'glWindowPos3d', 'glWindowPos3dv', 'glWindowPos3f',
'glWindowPos3fv', 'glWindowPos3i', 'glWindowPos3iv', 'glWindowPos3s',
'glWindowPos3sv', 'PFNGLBLENDFUNCSEPARATEPROC', 'PFNGLFOGCOORDFPROC',
'PFNGLFOGCOORDFVPROC', 'PFNGLFOGCOORDDPROC', 'PFNGLFOGCOORDDVPROC',
'PFNGLFOGCOORDPOINTERPROC', 'PFNGLMULTIDRAWARRAYSPROC',
'PFNGLMULTIDRAWELEMENTSPROC', 'PFNGLPOINTPARAMETERFPROC',
'PFNGLPOINTPARAMETERFVPROC', 'PFNGLPOINTPARAMETERIPROC',
'PFNGLPOINTPARAMETERIVPROC', 'PFNGLSECONDARYCOLOR3BPROC',
'PFNGLSECONDARYCOLOR3BVPROC', 'PFNGLSECONDARYCOLOR3DPROC',
'PFNGLSECONDARYCOLOR3DVPROC', 'PFNGLSECONDARYCOLOR3FPROC',
'PFNGLSECONDARYCOLOR3FVPROC', 'PFNGLSECONDARYCOLOR3IPROC',
'PFNGLSECONDARYCOLOR3IVPROC', 'PFNGLSECONDARYCOLOR3SPROC',
'PFNGLSECONDARYCOLOR3SVPROC', 'PFNGLSECONDARYCOLOR3UBPROC',
'PFNGLSECONDARYCOLOR3UBVPROC', 'PFNGLSECONDARYCOLOR3UIPROC',
'PFNGLSECONDARYCOLOR3UIVPROC', 'PFNGLSECONDARYCOLOR3USPROC',
'PFNGLSECONDARYCOLOR3USVPROC', 'PFNGLSECONDARYCOLORPOINTERPROC',
'PFNGLWINDOWPOS2DPROC', 'PFNGLWINDOWPOS2DVPROC', 'PFNGLWINDOWPOS2FPROC',
'PFNGLWINDOWPOS2FVPROC', 'PFNGLWINDOWPOS2IPROC', 'PFNGLWINDOWPOS2IVPROC',
'PFNGLWINDOWPOS2SPROC', 'PFNGLWINDOWPOS2SVPROC', 'PFNGLWINDOWPOS3DPROC',
'PFNGLWINDOWPOS3DVPROC', 'PFNGLWINDOWPOS3FPROC', 'PFNGLWINDOWPOS3FVPROC',
'PFNGLWINDOWPOS3IPROC', 'PFNGLWINDOWPOS3IVPROC', 'PFNGLWINDOWPOS3SPROC',
'PFNGLWINDOWPOS3SVPROC', 'GL_VERSION_1_5', 'glGenQueries', 'glDeleteQueries',
'glIsQuery', 'glBeginQuery', 'glEndQuery', 'glGetQueryiv',
'glGetQueryObjectiv', 'glGetQueryObjectuiv', 'glBindBuffer',
'glDeleteBuffers', 'glGenBuffers', 'glIsBuffer', 'glBufferData',
'glBufferSubData', 'glGetBufferSubData', 'glMapBuffer', 'glUnmapBuffer',
'glGetBufferParameteriv', 'glGetBufferPointerv', 'PFNGLGENQUERIESPROC',
'PFNGLDELETEQUERIESPROC', 'PFNGLISQUERYPROC', 'PFNGLBEGINQUERYPROC',
'PFNGLENDQUERYPROC', 'PFNGLGETQUERYIVPROC', 'PFNGLGETQUERYOBJECTIVPROC',
'PFNGLGETQUERYOBJECTUIVPROC', 'PFNGLBINDBUFFERPROC', 'PFNGLDELETEBUFFERSPROC',
'PFNGLGENBUFFERSPROC', 'PFNGLISBUFFERPROC', 'PFNGLBUFFERDATAPROC',
'PFNGLBUFFERSUBDATAPROC', 'PFNGLGETBUFFERSUBDATAPROC', 'PFNGLMAPBUFFERPROC',
'PFNGLUNMAPBUFFERPROC', 'PFNGLGETBUFFERPARAMETERIVPROC',
'PFNGLGETBUFFERPOINTERVPROC', 'GL_VERSION_2_0', 'glBlendEquationSeparate',
'glDrawBuffers', 'glStencilOpSeparate', 'glStencilFuncSeparate',
'glStencilMaskSeparate', 'glAttachShader', 'glBindAttribLocation',
'glCompileShader', 'glCreateProgram', 'glCreateShader', 'glDeleteProgram',
'glDeleteShader', 'glDetachShader', 'glDisableVertexAttribArray',
'glEnableVertexAttribArray', 'glGetActiveAttrib', 'glGetActiveUniform',
'glGetAttachedShaders', 'glGetAttribLocation', 'glGetProgramiv',
'glGetProgramInfoLog', 'glGetShaderiv', 'glGetShaderInfoLog',
'glGetShaderSource', 'glGetUniformLocation', 'glGetUniformfv',
'glGetUniformiv', 'glGetVertexAttribdv', 'glGetVertexAttribfv',
'glGetVertexAttribiv', 'glGetVertexAttribPointerv', 'glIsProgram',
'glIsShader', 'glLinkProgram', 'glShaderSource', 'glUseProgram',
'glUniform1f', 'glUniform2f', 'glUniform3f', 'glUniform4f', 'glUniform1i',
'glUniform2i', 'glUniform3i', 'glUniform4i', 'glUniform1fv', 'glUniform2fv',
'glUniform3fv', 'glUniform4fv', 'glUniform1iv', 'glUniform2iv',
'glUniform3iv', 'glUniform4iv', 'glUniformMatrix2fv', 'glUniformMatrix3fv',
'glUniformMatrix4fv', 'glValidateProgram', 'glVertexAttrib1d',
'glVertexAttrib1dv', 'glVertexAttrib1f', 'glVertexAttrib1fv',
'glVertexAttrib1s', 'glVertexAttrib1sv', 'glVertexAttrib2d',
'glVertexAttrib2dv', 'glVertexAttrib2f', 'glVertexAttrib2fv',
'glVertexAttrib2s', 'glVertexAttrib2sv', 'glVertexAttrib3d',
'glVertexAttrib3dv', 'glVertexAttrib3f', 'glVertexAttrib3fv',
'glVertexAttrib3s', 'glVertexAttrib3sv', 'glVertexAttrib4Nbv',
'glVertexAttrib4Niv', 'glVertexAttrib4Nsv', 'glVertexAttrib4Nub',
'glVertexAttrib4Nubv', 'glVertexAttrib4Nuiv', 'glVertexAttrib4Nusv',
'glVertexAttrib4bv', 'glVertexAttrib4d', 'glVertexAttrib4dv',
'glVertexAttrib4f', 'glVertexAttrib4fv', 'glVertexAttrib4iv',
'glVertexAttrib4s', 'glVertexAttrib4sv', 'glVertexAttrib4ubv',
'glVertexAttrib4uiv', 'glVertexAttrib4usv', 'glVertexAttribPointer',
'PFNGLBLENDEQUATIONSEPARATEPROC', 'PFNGLDRAWBUFFERSPROC',
'PFNGLSTENCILOPSEPARATEPROC', 'PFNGLSTENCILFUNCSEPARATEPROC',
'PFNGLSTENCILMASKSEPARATEPROC', 'PFNGLATTACHSHADERPROC',
'PFNGLBINDATTRIBLOCATIONPROC', 'PFNGLCOMPILESHADERPROC',
'PFNGLCREATEPROGRAMPROC', 'PFNGLCREATESHADERPROC', 'PFNGLDELETEPROGRAMPROC',
'PFNGLDELETESHADERPROC', 'PFNGLDETACHSHADERPROC',
'PFNGLDISABLEVERTEXATTRIBARRAYPROC', 'PFNGLENABLEVERTEXATTRIBARRAYPROC',
'PFNGLGETACTIVEATTRIBPROC', 'PFNGLGETACTIVEUNIFORMPROC',
'PFNGLGETATTACHEDSHADERSPROC', 'PFNGLGETATTRIBLOCATIONPROC',
'PFNGLGETPROGRAMIVPROC', 'PFNGLGETPROGRAMINFOLOGPROC', 'PFNGLGETSHADERIVPROC',
'PFNGLGETSHADERINFOLOGPROC', 'PFNGLGETSHADERSOURCEPROC',
'PFNGLGETUNIFORMLOCATIONPROC', 'PFNGLGETUNIFORMFVPROC',
'PFNGLGETUNIFORMIVPROC', 'PFNGLGETVERTEXATTRIBDVPROC',
'PFNGLGETVERTEXATTRIBFVPROC', 'PFNGLGETVERTEXATTRIBIVPROC',
'PFNGLGETVERTEXATTRIBPOINTERVPROC', 'PFNGLISPROGRAMPROC', 'PFNGLISSHADERPROC',
'PFNGLLINKPROGRAMPROC', 'PFNGLSHADERSOURCEPROC', 'PFNGLUSEPROGRAMPROC',
'PFNGLUNIFORM1FPROC', 'PFNGLUNIFORM2FPROC', 'PFNGLUNIFORM3FPROC',
'PFNGLUNIFORM4FPROC', 'PFNGLUNIFORM1IPROC', 'PFNGLUNIFORM2IPROC',
'PFNGLUNIFORM3IPROC', 'PFNGLUNIFORM4IPROC', 'PFNGLUNIFORM1FVPROC',
'PFNGLUNIFORM2FVPROC', 'PFNGLUNIFORM3FVPROC', 'PFNGLUNIFORM4FVPROC',
'PFNGLUNIFORM1IVPROC', 'PFNGLUNIFORM2IVPROC', 'PFNGLUNIFORM3IVPROC',
'PFNGLUNIFORM4IVPROC', 'PFNGLUNIFORMMATRIX2FVPROC',
'PFNGLUNIFORMMATRIX3FVPROC', 'PFNGLUNIFORMMATRIX4FVPROC',
'PFNGLVALIDATEPROGRAMPROC', 'PFNGLVERTEXATTRIB1DPROC',
'PFNGLVERTEXATTRIB1DVPROC', 'PFNGLVERTEXATTRIB1FPROC',
'PFNGLVERTEXATTRIB1FVPROC', 'PFNGLVERTEXATTRIB1SPROC',
'PFNGLVERTEXATTRIB1SVPROC', 'PFNGLVERTEXATTRIB2DPROC',
'PFNGLVERTEXATTRIB2DVPROC', 'PFNGLVERTEXATTRIB2FPROC',
'PFNGLVERTEXATTRIB2FVPROC', 'PFNGLVERTEXATTRIB2SPROC',
'PFNGLVERTEXATTRIB2SVPROC', 'PFNGLVERTEXATTRIB3DPROC',
'PFNGLVERTEXATTRIB3DVPROC', 'PFNGLVERTEXATTRIB3FPROC',
'PFNGLVERTEXATTRIB3FVPROC', 'PFNGLVERTEXATTRIB3SPROC',
'PFNGLVERTEXATTRIB3SVPROC', 'PFNGLVERTEXATTRIB4NBVPROC',
'PFNGLVERTEXATTRIB4NIVPROC', 'PFNGLVERTEXATTRIB4NSVPROC',
'PFNGLVERTEXATTRIB4NUBPROC', 'PFNGLVERTEXATTRIB4NUBVPROC',
'PFNGLVERTEXATTRIB4NUIVPROC', 'PFNGLVERTEXATTRIB4NUSVPROC',
'PFNGLVERTEXATTRIB4BVPROC', 'PFNGLVERTEXATTRIB4DPROC',
'PFNGLVERTEXATTRIB4DVPROC', 'PFNGLVERTEXATTRIB4FPROC',
'PFNGLVERTEXATTRIB4FVPROC', 'PFNGLVERTEXATTRIB4IVPROC',
'PFNGLVERTEXATTRIB4SPROC', 'PFNGLVERTEXATTRIB4SVPROC',
'PFNGLVERTEXATTRIB4UBVPROC', 'PFNGLVERTEXATTRIB4UIVPROC',
'PFNGLVERTEXATTRIB4USVPROC', 'PFNGLVERTEXATTRIBPOINTERPROC',
'GL_ARB_multitexture', 'glActiveTextureARB', 'glClientActiveTextureARB',
'glMultiTexCoord1dARB', 'glMultiTexCoord1dvARB', 'glMultiTexCoord1fARB',
'glMultiTexCoord1fvARB', 'glMultiTexCoord1iARB', 'glMultiTexCoord1ivARB',
'glMultiTexCoord1sARB', 'glMultiTexCoord1svARB', 'glMultiTexCoord2dARB',
'glMultiTexCoord2dvARB', 'glMultiTexCoord2fARB', 'glMultiTexCoord2fvARB',
'glMultiTexCoord2iARB', 'glMultiTexCoord2ivARB', 'glMultiTexCoord2sARB',
'glMultiTexCoord2svARB', 'glMultiTexCoord3dARB', 'glMultiTexCoord3dvARB',
'glMultiTexCoord3fARB', 'glMultiTexCoord3fvARB', 'glMultiTexCoord3iARB',
'glMultiTexCoord3ivARB', 'glMultiTexCoord3sARB', 'glMultiTexCoord3svARB',
'glMultiTexCoord4dARB', 'glMultiTexCoord4dvARB', 'glMultiTexCoord4fARB',
'glMultiTexCoord4fvARB', 'glMultiTexCoord4iARB', 'glMultiTexCoord4ivARB',
'glMultiTexCoord4sARB', 'glMultiTexCoord4svARB', 'PFNGLACTIVETEXTUREARBPROC',
'PFNGLCLIENTACTIVETEXTUREARBPROC', 'PFNGLMULTITEXCOORD1DARBPROC',
'PFNGLMULTITEXCOORD1DVARBPROC', 'PFNGLMULTITEXCOORD1FARBPROC',
'PFNGLMULTITEXCOORD1FVARBPROC', 'PFNGLMULTITEXCOORD1IARBPROC',
'PFNGLMULTITEXCOORD1IVARBPROC', 'PFNGLMULTITEXCOORD1SARBPROC',
'PFNGLMULTITEXCOORD1SVARBPROC', 'PFNGLMULTITEXCOORD2DARBPROC',
'PFNGLMULTITEXCOORD2DVARBPROC', 'PFNGLMULTITEXCOORD2FARBPROC',
'PFNGLMULTITEXCOORD2FVARBPROC', 'PFNGLMULTITEXCOORD2IARBPROC',
'PFNGLMULTITEXCOORD2IVARBPROC', 'PFNGLMULTITEXCOORD2SARBPROC',
'PFNGLMULTITEXCOORD2SVARBPROC', 'PFNGLMULTITEXCOORD3DARBPROC',
'PFNGLMULTITEXCOORD3DVARBPROC', 'PFNGLMULTITEXCOORD3FARBPROC',
'PFNGLMULTITEXCOORD3FVARBPROC', 'PFNGLMULTITEXCOORD3IARBPROC',
'PFNGLMULTITEXCOORD3IVARBPROC', 'PFNGLMULTITEXCOORD3SARBPROC',
'PFNGLMULTITEXCOORD3SVARBPROC', 'PFNGLMULTITEXCOORD4DARBPROC',
'PFNGLMULTITEXCOORD4DVARBPROC', 'PFNGLMULTITEXCOORD4FARBPROC',
'PFNGLMULTITEXCOORD4FVARBPROC', 'PFNGLMULTITEXCOORD4IARBPROC',
'PFNGLMULTITEXCOORD4IVARBPROC', 'PFNGLMULTITEXCOORD4SARBPROC',
'PFNGLMULTITEXCOORD4SVARBPROC', 'GL_ARB_transpose_matrix',
'glLoadTransposeMatrixfARB', 'glLoadTransposeMatrixdARB',
'glMultTransposeMatrixfARB', 'glMultTransposeMatrixdARB',
'PFNGLLOADTRANSPOSEMATRIXFARBPROC', 'PFNGLLOADTRANSPOSEMATRIXDARBPROC',
'PFNGLMULTTRANSPOSEMATRIXFARBPROC', 'PFNGLMULTTRANSPOSEMATRIXDARBPROC',
'GL_ARB_multisample', 'glSampleCoverageARB', 'PFNGLSAMPLECOVERAGEARBPROC',
'GL_ARB_texture_env_add', 'GL_ARB_texture_cube_map',
'GL_ARB_texture_compression', 'glCompressedTexImage3DARB',
'glCompressedTexImage2DARB', 'glCompressedTexImage1DARB',
'glCompressedTexSubImage3DARB', 'glCompressedTexSubImage2DARB',
'glCompressedTexSubImage1DARB', 'glGetCompressedTexImageARB',
'PFNGLCOMPRESSEDTEXIMAGE3DARBPROC', 'PFNGLCOMPRESSEDTEXIMAGE2DARBPROC',
'PFNGLCOMPRESSEDTEXIMAGE1DARBPROC', 'PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC',
'PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC', 'PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC',
'PFNGLGETCOMPRESSEDTEXIMAGEARBPROC', 'GL_ARB_texture_border_clamp',
'GL_ARB_point_parameters', 'glPointParameterfARB', 'glPointParameterfvARB',
'PFNGLPOINTPARAMETERFARBPROC', 'PFNGLPOINTPARAMETERFVARBPROC',
'GL_ARB_vertex_blend', 'glWeightbvARB', 'glWeightsvARB', 'glWeightivARB',
'glWeightfvARB', 'glWeightdvARB', 'glWeightubvARB', 'glWeightusvARB',
'glWeightuivARB', 'glWeightPointerARB', 'glVertexBlendARB',
'PFNGLWEIGHTBVARBPROC', 'PFNGLWEIGHTSVARBPROC', 'PFNGLWEIGHTIVARBPROC',
'PFNGLWEIGHTFVARBPROC', 'PFNGLWEIGHTDVARBPROC', 'PFNGLWEIGHTUBVARBPROC',
'PFNGLWEIGHTUSVARBPROC', 'PFNGLWEIGHTUIVARBPROC', 'PFNGLWEIGHTPOINTERARBPROC',
'PFNGLVERTEXBLENDARBPROC', 'GL_ARB_matrix_palette',
'glCurrentPaletteMatrixARB', 'glMatrixIndexubvARB', 'glMatrixIndexusvARB',
'glMatrixIndexuivARB', 'glMatrixIndexPointerARB',
'PFNGLCURRENTPALETTEMATRIXARBPROC', 'PFNGLMATRIXINDEXUBVARBPROC',
'PFNGLMATRIXINDEXUSVARBPROC', 'PFNGLMATRIXINDEXUIVARBPROC',
'PFNGLMATRIXINDEXPOINTERARBPROC', 'GL_ARB_texture_env_combine',
'GL_ARB_texture_env_crossbar', 'GL_ARB_texture_env_dot3',
'GL_ARB_texture_mirrored_repeat', 'GL_ARB_depth_texture', 'GL_ARB_shadow',
'GL_ARB_shadow_ambient', 'GL_ARB_window_pos', 'glWindowPos2dARB',
'glWindowPos2dvARB', 'glWindowPos2fARB', 'glWindowPos2fvARB',
'glWindowPos2iARB', 'glWindowPos2ivARB', 'glWindowPos2sARB',
'glWindowPos2svARB', 'glWindowPos3dARB', 'glWindowPos3dvARB',
'glWindowPos3fARB', 'glWindowPos3fvARB', 'glWindowPos3iARB',
'glWindowPos3ivARB', 'glWindowPos3sARB', 'glWindowPos3svARB',
'PFNGLWINDOWPOS2DARBPROC', 'PFNGLWINDOWPOS2DVARBPROC',
'PFNGLWINDOWPOS2FARBPROC', 'PFNGLWINDOWPOS2FVARBPROC',
'PFNGLWINDOWPOS2IARBPROC', 'PFNGLWINDOWPOS2IVARBPROC',
'PFNGLWINDOWPOS2SARBPROC', 'PFNGLWINDOWPOS2SVARBPROC',
'PFNGLWINDOWPOS3DARBPROC', 'PFNGLWINDOWPOS3DVARBPROC',
'PFNGLWINDOWPOS3FARBPROC', 'PFNGLWINDOWPOS3FVARBPROC',
'PFNGLWINDOWPOS3IARBPROC', 'PFNGLWINDOWPOS3IVARBPROC',
'PFNGLWINDOWPOS3SARBPROC', 'PFNGLWINDOWPOS3SVARBPROC',
'GL_ARB_vertex_program', 'glVertexAttrib1dARB', 'glVertexAttrib1dvARB',
'glVertexAttrib1fARB', 'glVertexAttrib1fvARB', 'glVertexAttrib1sARB',
'glVertexAttrib1svARB', 'glVertexAttrib2dARB', 'glVertexAttrib2dvARB',
'glVertexAttrib2fARB', 'glVertexAttrib2fvARB', 'glVertexAttrib2sARB',
'glVertexAttrib2svARB', 'glVertexAttrib3dARB', 'glVertexAttrib3dvARB',
'glVertexAttrib3fARB', 'glVertexAttrib3fvARB', 'glVertexAttrib3sARB',
'glVertexAttrib3svARB', 'glVertexAttrib4NbvARB', 'glVertexAttrib4NivARB',
'glVertexAttrib4NsvARB', 'glVertexAttrib4NubARB', 'glVertexAttrib4NubvARB',
'glVertexAttrib4NuivARB', 'glVertexAttrib4NusvARB', 'glVertexAttrib4bvARB',
'glVertexAttrib4dARB', 'glVertexAttrib4dvARB', 'glVertexAttrib4fARB',
'glVertexAttrib4fvARB', 'glVertexAttrib4ivARB', 'glVertexAttrib4sARB',
'glVertexAttrib4svARB', 'glVertexAttrib4ubvARB', 'glVertexAttrib4uivARB',
'glVertexAttrib4usvARB', 'glVertexAttribPointerARB',
'glEnableVertexAttribArrayARB', 'glDisableVertexAttribArrayARB',
'glProgramStringARB', 'glBindProgramARB', 'glDeleteProgramsARB',
'glGenProgramsARB', 'glProgramEnvParameter4dARB',
'glProgramEnvParameter4dvARB', 'glProgramEnvParameter4fARB',
'glProgramEnvParameter4fvARB', 'glProgramLocalParameter4dARB',
'glProgramLocalParameter4dvARB', 'glProgramLocalParameter4fARB',
'glProgramLocalParameter4fvARB', 'glGetProgramEnvParameterdvARB',
'glGetProgramEnvParameterfvARB', 'glGetProgramLocalParameterdvARB',
'glGetProgramLocalParameterfvARB', 'glGetProgramivARB',
'glGetProgramStringARB', 'glGetVertexAttribdvARB', 'glGetVertexAttribfvARB',
'glGetVertexAttribivARB', 'glGetVertexAttribPointervARB', 'glIsProgramARB',
'PFNGLVERTEXATTRIB1DARBPROC', 'PFNGLVERTEXATTRIB1DVARBPROC',
'PFNGLVERTEXATTRIB1FARBPROC', 'PFNGLVERTEXATTRIB1FVARBPROC',
'PFNGLVERTEXATTRIB1SARBPROC', 'PFNGLVERTEXATTRIB1SVARBPROC',
'PFNGLVERTEXATTRIB2DARBPROC', 'PFNGLVERTEXATTRIB2DVARBPROC',
'PFNGLVERTEXATTRIB2FARBPROC', 'PFNGLVERTEXATTRIB2FVARBPROC',
'PFNGLVERTEXATTRIB2SARBPROC', 'PFNGLVERTEXATTRIB2SVARBPROC',
'PFNGLVERTEXATTRIB3DARBPROC', 'PFNGLVERTEXATTRIB3DVARBPROC',
'PFNGLVERTEXATTRIB3FARBPROC', 'PFNGLVERTEXATTRIB3FVARBPROC',
'PFNGLVERTEXATTRIB3SARBPROC', 'PFNGLVERTEXATTRIB3SVARBPROC',
'PFNGLVERTEXATTRIB4NBVARBPROC', 'PFNGLVERTEXATTRIB4NIVARBPROC',
'PFNGLVERTEXATTRIB4NSVARBPROC', 'PFNGLVERTEXATTRIB4NUBARBPROC',
'PFNGLVERTEXATTRIB4NUBVARBPROC', 'PFNGLVERTEXATTRIB4NUIVARBPROC',
'PFNGLVERTEXATTRIB4NUSVARBPROC', 'PFNGLVERTEXATTRIB4BVARBPROC',
'PFNGLVERTEXATTRIB4DARBPROC', 'PFNGLVERTEXATTRIB4DVARBPROC',
'PFNGLVERTEXATTRIB4FARBPROC', 'PFNGLVERTEXATTRIB4FVARBPROC',
'PFNGLVERTEXATTRIB4IVARBPROC', 'PFNGLVERTEXATTRIB4SARBPROC',
'PFNGLVERTEXATTRIB4SVARBPROC', 'PFNGLVERTEXATTRIB4UBVARBPROC',
'PFNGLVERTEXATTRIB4UIVARBPROC', 'PFNGLVERTEXATTRIB4USVARBPROC',
'PFNGLVERTEXATTRIBPOINTERARBPROC', 'PFNGLENABLEVERTEXATTRIBARRAYARBPROC',
'PFNGLDISABLEVERTEXATTRIBARRAYARBPROC', 'PFNGLPROGRAMSTRINGARBPROC',
'PFNGLBINDPROGRAMARBPROC', 'PFNGLDELETEPROGRAMSARBPROC',
'PFNGLGENPROGRAMSARBPROC', 'PFNGLPROGRAMENVPARAMETER4DARBPROC',
'PFNGLPROGRAMENVPARAMETER4DVARBPROC', 'PFNGLPROGRAMENVPARAMETER4FARBPROC',
'PFNGLPROGRAMENVPARAMETER4FVARBPROC', 'PFNGLPROGRAMLOCALPARAMETER4DARBPROC',
'PFNGLPROGRAMLOCALPARAMETER4DVARBPROC', 'PFNGLPROGRAMLOCALPARAMETER4FARBPROC',
'PFNGLPROGRAMLOCALPARAMETER4FVARBPROC',
'PFNGLGETPROGRAMENVPARAMETERDVARBPROC',
'PFNGLGETPROGRAMENVPARAMETERFVARBPROC',
'PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC',
'PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC', 'PFNGLGETPROGRAMIVARBPROC',
'PFNGLGETPROGRAMSTRINGARBPROC', 'PFNGLGETVERTEXATTRIBDVARBPROC',
'PFNGLGETVERTEXATTRIBFVARBPROC', 'PFNGLGETVERTEXATTRIBIVARBPROC',
'PFNGLGETVERTEXATTRIBPOINTERVARBPROC', 'PFNGLISPROGRAMARBPROC',
'GL_ARB_fragment_program', 'GL_ARB_vertex_buffer_object', 'glBindBufferARB',
'glDeleteBuffersARB', 'glGenBuffersARB', 'glIsBufferARB', 'glBufferDataARB',
'glBufferSubDataARB', 'glGetBufferSubDataARB', 'glMapBufferARB',
'glUnmapBufferARB', 'glGetBufferParameterivARB', 'glGetBufferPointervARB',
'PFNGLBINDBUFFERARBPROC', 'PFNGLDELETEBUFFERSARBPROC',
'PFNGLGENBUFFERSARBPROC', 'PFNGLISBUFFERARBPROC', 'PFNGLBUFFERDATAARBPROC',
'PFNGLBUFFERSUBDATAARBPROC', 'PFNGLGETBUFFERSUBDATAARBPROC',
'PFNGLMAPBUFFERARBPROC', 'PFNGLUNMAPBUFFERARBPROC',
'PFNGLGETBUFFERPARAMETERIVARBPROC', 'PFNGLGETBUFFERPOINTERVARBPROC',
'GL_ARB_occlusion_query', 'glGenQueriesARB', 'glDeleteQueriesARB',
'glIsQueryARB', 'glBeginQueryARB', 'glEndQueryARB', 'glGetQueryivARB',
'glGetQueryObjectivARB', 'glGetQueryObjectuivARB', 'PFNGLGENQUERIESARBPROC',
'PFNGLDELETEQUERIESARBPROC', 'PFNGLISQUERYARBPROC', 'PFNGLBEGINQUERYARBPROC',
'PFNGLENDQUERYARBPROC', 'PFNGLGETQUERYIVARBPROC',
'PFNGLGETQUERYOBJECTIVARBPROC', 'PFNGLGETQUERYOBJECTUIVARBPROC',
'GL_ARB_shader_objects', 'glDeleteObjectARB', 'glGetHandleARB',
'glDetachObjectARB', 'glCreateShaderObjectARB', 'glShaderSourceARB',
'glCompileShaderARB', 'glCreateProgramObjectARB', 'glAttachObjectARB',
'glLinkProgramARB', 'glUseProgramObjectARB', 'glValidateProgramARB',
'glUniform1fARB', 'glUniform2fARB', 'glUniform3fARB', 'glUniform4fARB',
'glUniform1iARB', 'glUniform2iARB', 'glUniform3iARB', 'glUniform4iARB',
'glUniform1fvARB', 'glUniform2fvARB', 'glUniform3fvARB', 'glUniform4fvARB',
'glUniform1ivARB', 'glUniform2ivARB', 'glUniform3ivARB', 'glUniform4ivARB',
'glUniformMatrix2fvARB', 'glUniformMatrix3fvARB', 'glUniformMatrix4fvARB',
'glGetObjectParameterfvARB', 'glGetObjectParameterivARB', 'glGetInfoLogARB',
'glGetAttachedObjectsARB', 'glGetUniformLocationARB', 'glGetActiveUniformARB',
'glGetUniformfvARB', 'glGetUniformivARB', 'glGetShaderSourceARB',
'PFNGLDELETEOBJECTARBPROC', 'PFNGLGETHANDLEARBPROC',
'PFNGLDETACHOBJECTARBPROC', 'PFNGLCREATESHADEROBJECTARBPROC',
'PFNGLSHADERSOURCEARBPROC', 'PFNGLCOMPILESHADERARBPROC',
'PFNGLCREATEPROGRAMOBJECTARBPROC', 'PFNGLATTACHOBJECTARBPROC',
'PFNGLLINKPROGRAMARBPROC', 'PFNGLUSEPROGRAMOBJECTARBPROC',
'PFNGLVALIDATEPROGRAMARBPROC', 'PFNGLUNIFORM1FARBPROC',
'PFNGLUNIFORM2FARBPROC', 'PFNGLUNIFORM3FARBPROC', 'PFNGLUNIFORM4FARBPROC',
'PFNGLUNIFORM1IARBPROC', 'PFNGLUNIFORM2IARBPROC', 'PFNGLUNIFORM3IARBPROC',
'PFNGLUNIFORM4IARBPROC', 'PFNGLUNIFORM1FVARBPROC', 'PFNGLUNIFORM2FVARBPROC',
'PFNGLUNIFORM3FVARBPROC', 'PFNGLUNIFORM4FVARBPROC', 'PFNGLUNIFORM1IVARBPROC',
'PFNGLUNIFORM2IVARBPROC', 'PFNGLUNIFORM3IVARBPROC', 'PFNGLUNIFORM4IVARBPROC',
'PFNGLUNIFORMMATRIX2FVARBPROC', 'PFNGLUNIFORMMATRIX3FVARBPROC',
'PFNGLUNIFORMMATRIX4FVARBPROC', 'PFNGLGETOBJECTPARAMETERFVARBPROC',
'PFNGLGETOBJECTPARAMETERIVARBPROC', 'PFNGLGETINFOLOGARBPROC',
'PFNGLGETATTACHEDOBJECTSARBPROC', 'PFNGLGETUNIFORMLOCATIONARBPROC',
'PFNGLGETACTIVEUNIFORMARBPROC', 'PFNGLGETUNIFORMFVARBPROC',
'PFNGLGETUNIFORMIVARBPROC', 'PFNGLGETSHADERSOURCEARBPROC',
'GL_ARB_vertex_shader', 'glBindAttribLocationARB', 'glGetActiveAttribARB',
'glGetAttribLocationARB', 'PFNGLBINDATTRIBLOCATIONARBPROC',
'PFNGLGETACTIVEATTRIBARBPROC', 'PFNGLGETATTRIBLOCATIONARBPROC',
'GL_ARB_fragment_shader', 'GL_ARB_shading_language_100',
'GL_ARB_texture_non_power_of_two', 'GL_ARB_point_sprite',
'GL_ARB_fragment_program_shadow', 'GL_ARB_draw_buffers', 'glDrawBuffersARB',
'PFNGLDRAWBUFFERSARBPROC', 'GL_ARB_texture_rectangle',
'GL_ARB_color_buffer_float', 'glClampColorARB', 'PFNGLCLAMPCOLORARBPROC',
'GL_ARB_half_float_pixel', 'GL_ARB_texture_float',
'GL_ARB_pixel_buffer_object', 'GL_EXT_abgr', 'GL_EXT_blend_color',
'glBlendColorEXT', 'PFNGLBLENDCOLOREXTPROC', 'GL_EXT_polygon_offset',
'glPolygonOffsetEXT', 'PFNGLPOLYGONOFFSETEXTPROC', 'GL_EXT_texture',
'GL_EXT_texture3D', 'glTexImage3DEXT', 'glTexSubImage3DEXT',
'PFNGLTEXIMAGE3DEXTPROC', 'PFNGLTEXSUBIMAGE3DEXTPROC',
'GL_SGIS_texture_filter4', 'glGetTexFilterFuncSGIS', 'glTexFilterFuncSGIS',
'PFNGLGETTEXFILTERFUNCSGISPROC', 'PFNGLTEXFILTERFUNCSGISPROC',
'GL_EXT_subtexture', 'glTexSubImage1DEXT', 'glTexSubImage2DEXT',
'PFNGLTEXSUBIMAGE1DEXTPROC', 'PFNGLTEXSUBIMAGE2DEXTPROC',
'GL_EXT_copy_texture', 'glCopyTexImage1DEXT', 'glCopyTexImage2DEXT',
'glCopyTexSubImage1DEXT', 'glCopyTexSubImage2DEXT', 'glCopyTexSubImage3DEXT',
'PFNGLCOPYTEXIMAGE1DEXTPROC', 'PFNGLCOPYTEXIMAGE2DEXTPROC',
'PFNGLCOPYTEXSUBIMAGE1DEXTPROC', 'PFNGLCOPYTEXSUBIMAGE2DEXTPROC',
'PFNGLCOPYTEXSUBIMAGE3DEXTPROC', 'GL_EXT_histogram', 'glGetHistogramEXT',
'glGetHistogramParameterfvEXT', 'glGetHistogramParameterivEXT',
'glGetMinmaxEXT', 'glGetMinmaxParameterfvEXT', 'glGetMinmaxParameterivEXT',
'glHistogramEXT', 'glMinmaxEXT', 'glResetHistogramEXT', 'glResetMinmaxEXT',
'PFNGLGETHISTOGRAMEXTPROC', 'PFNGLGETHISTOGRAMPARAMETERFVEXTPROC',
'PFNGLGETHISTOGRAMPARAMETERIVEXTPROC', 'PFNGLGETMINMAXEXTPROC',
'PFNGLGETMINMAXPARAMETERFVEXTPROC', 'PFNGLGETMINMAXPARAMETERIVEXTPROC',
'PFNGLHISTOGRAMEXTPROC', 'PFNGLMINMAXEXTPROC', 'PFNGLRESETHISTOGRAMEXTPROC',
'PFNGLRESETMINMAXEXTPROC', 'GL_EXT_convolution', 'glConvolutionFilter1DEXT',
'glConvolutionFilter2DEXT', 'glConvolutionParameterfEXT',
'glConvolutionParameterfvEXT', 'glConvolutionParameteriEXT',
'glConvolutionParameterivEXT', 'glCopyConvolutionFilter1DEXT',
'glCopyConvolutionFilter2DEXT', 'glGetConvolutionFilterEXT',
'glGetConvolutionParameterfvEXT', 'glGetConvolutionParameterivEXT',
'glGetSeparableFilterEXT', 'glSeparableFilter2DEXT',
'PFNGLCONVOLUTIONFILTER1DEXTPROC', 'PFNGLCONVOLUTIONFILTER2DEXTPROC',
'PFNGLCONVOLUTIONPARAMETERFEXTPROC', 'PFNGLCONVOLUTIONPARAMETERFVEXTPROC',
'PFNGLCONVOLUTIONPARAMETERIEXTPROC', 'PFNGLCONVOLUTIONPARAMETERIVEXTPROC',
'PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC', 'PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC',
'PFNGLGETCONVOLUTIONFILTEREXTPROC', 'PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC',
'PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC', 'PFNGLGETSEPARABLEFILTEREXTPROC',
'PFNGLSEPARABLEFILTER2DEXTPROC', 'GL_EXT_color_matrix', 'GL_SGI_color_table',
'glColorTableSGI', 'glColorTableParameterfvSGI', 'glColorTableParameterivSGI',
'glCopyColorTableSGI', 'glGetColorTableSGI', 'glGetColorTableParameterfvSGI',
'glGetColorTableParameterivSGI', 'PFNGLCOLORTABLESGIPROC',
'PFNGLCOLORTABLEPARAMETERFVSGIPROC', 'PFNGLCOLORTABLEPARAMETERIVSGIPROC',
'PFNGLCOPYCOLORTABLESGIPROC', 'PFNGLGETCOLORTABLESGIPROC',
'PFNGLGETCOLORTABLEPARAMETERFVSGIPROC',
'PFNGLGETCOLORTABLEPARAMETERIVSGIPROC', 'GL_SGIX_pixel_texture',
'glPixelTexGenSGIX', 'PFNGLPIXELTEXGENSGIXPROC', 'GL_SGIS_pixel_texture',
'glPixelTexGenParameteriSGIS', 'glPixelTexGenParameterivSGIS',
'glPixelTexGenParameterfSGIS', 'glPixelTexGenParameterfvSGIS',
'glGetPixelTexGenParameterivSGIS', 'glGetPixelTexGenParameterfvSGIS',
'PFNGLPIXELTEXGENPARAMETERISGISPROC', 'PFNGLPIXELTEXGENPARAMETERIVSGISPROC',
'PFNGLPIXELTEXGENPARAMETERFSGISPROC', 'PFNGLPIXELTEXGENPARAMETERFVSGISPROC',
'PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC',
'PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC', 'GL_SGIS_texture4D',
'glTexImage4DSGIS', 'glTexSubImage4DSGIS', 'PFNGLTEXIMAGE4DSGISPROC',
'PFNGLTEXSUBIMAGE4DSGISPROC', 'GL_SGI_texture_color_table', 'GL_EXT_cmyka',
'GL_EXT_texture_object', 'glAreTexturesResidentEXT', 'glBindTextureEXT',
'glDeleteTexturesEXT', 'glGenTexturesEXT', 'glIsTextureEXT',
'glPrioritizeTexturesEXT', 'PFNGLARETEXTURESRESIDENTEXTPROC',
'PFNGLBINDTEXTUREEXTPROC', 'PFNGLDELETETEXTURESEXTPROC',
'PFNGLGENTEXTURESEXTPROC', 'PFNGLISTEXTUREEXTPROC',
'PFNGLPRIORITIZETEXTURESEXTPROC', 'GL_SGIS_detail_texture',
'glDetailTexFuncSGIS', 'glGetDetailTexFuncSGIS', 'PFNGLDETAILTEXFUNCSGISPROC',
'PFNGLGETDETAILTEXFUNCSGISPROC', 'GL_SGIS_sharpen_texture',
'glSharpenTexFuncSGIS', 'glGetSharpenTexFuncSGIS',
'PFNGLSHARPENTEXFUNCSGISPROC', 'PFNGLGETSHARPENTEXFUNCSGISPROC',
'GL_EXT_packed_pixels', 'GL_SGIS_texture_lod', 'GL_SGIS_multisample',
'glSampleMaskSGIS', 'glSamplePatternSGIS', 'PFNGLSAMPLEMASKSGISPROC',
'PFNGLSAMPLEPATTERNSGISPROC', 'GL_EXT_rescale_normal', 'GL_EXT_vertex_array',
'glArrayElementEXT', 'glColorPointerEXT', 'glDrawArraysEXT',
'glEdgeFlagPointerEXT', 'glGetPointervEXT', 'glIndexPointerEXT',
'glNormalPointerEXT', 'glTexCoordPointerEXT', 'glVertexPointerEXT',
'PFNGLARRAYELEMENTEXTPROC', 'PFNGLCOLORPOINTEREXTPROC',
'PFNGLDRAWARRAYSEXTPROC', 'PFNGLEDGEFLAGPOINTEREXTPROC',
'PFNGLGETPOINTERVEXTPROC', 'PFNGLINDEXPOINTEREXTPROC',
'PFNGLNORMALPOINTEREXTPROC', 'PFNGLTEXCOORDPOINTEREXTPROC',
'PFNGLVERTEXPOINTEREXTPROC', 'GL_EXT_misc_attribute',
'GL_SGIS_generate_mipmap', 'GL_SGIX_clipmap', 'GL_SGIX_shadow',
'GL_SGIS_texture_edge_clamp', 'GL_SGIS_texture_border_clamp',
'GL_EXT_blend_minmax', 'glBlendEquationEXT', 'PFNGLBLENDEQUATIONEXTPROC',
'GL_EXT_blend_subtract', 'GL_EXT_blend_logic_op', 'GL_SGIX_interlace',
'GL_SGIX_pixel_tiles', 'GL_SGIX_texture_select', 'GL_SGIX_sprite',
'glSpriteParameterfSGIX', 'glSpriteParameterfvSGIX', 'glSpriteParameteriSGIX',
'glSpriteParameterivSGIX', 'PFNGLSPRITEPARAMETERFSGIXPROC',
'PFNGLSPRITEPARAMETERFVSGIXPROC', 'PFNGLSPRITEPARAMETERISGIXPROC',
'PFNGLSPRITEPARAMETERIVSGIXPROC', 'GL_SGIX_texture_multi_buffer',
'GL_EXT_point_parameters', 'glPointParameterfEXT', 'glPointParameterfvEXT',
'PFNGLPOINTPARAMETERFEXTPROC', 'PFNGLPOINTPARAMETERFVEXTPROC',
'GL_SGIS_point_parameters', 'glPointParameterfSGIS', 'glPointParameterfvSGIS',
'PFNGLPOINTPARAMETERFSGISPROC', 'PFNGLPOINTPARAMETERFVSGISPROC',
'GL_SGIX_instruments', 'glGetInstrumentsSGIX', 'glInstrumentsBufferSGIX',
'glPollInstrumentsSGIX', 'glReadInstrumentsSGIX', 'glStartInstrumentsSGIX',
'glStopInstrumentsSGIX', 'PFNGLGETINSTRUMENTSSGIXPROC',
'PFNGLINSTRUMENTSBUFFERSGIXPROC', 'PFNGLPOLLINSTRUMENTSSGIXPROC',
'PFNGLREADINSTRUMENTSSGIXPROC', 'PFNGLSTARTINSTRUMENTSSGIXPROC',
'PFNGLSTOPINSTRUMENTSSGIXPROC', 'GL_SGIX_texture_scale_bias',
'GL_SGIX_framezoom', 'glFrameZoomSGIX', 'PFNGLFRAMEZOOMSGIXPROC',
'GL_SGIX_tag_sample_buffer', 'glTagSampleBufferSGIX',
'PFNGLTAGSAMPLEBUFFERSGIXPROC', 'GL_SGIX_polynomial_ffd',
'glDeformationMap3dSGIX', 'glDeformationMap3fSGIX', 'glDeformSGIX',
'glLoadIdentityDeformationMapSGIX', 'PFNGLDEFORMATIONMAP3DSGIXPROC',
'PFNGLDEFORMATIONMAP3FSGIXPROC', 'PFNGLDEFORMSGIXPROC',
'PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC', 'GL_SGIX_reference_plane',
'glReferencePlaneSGIX', 'PFNGLREFERENCEPLANESGIXPROC', 'GL_SGIX_flush_raster',
'glFlushRasterSGIX', 'PFNGLFLUSHRASTERSGIXPROC', 'GL_SGIX_depth_texture',
'GL_SGIS_fog_function', 'glFogFuncSGIS', 'glGetFogFuncSGIS',
'PFNGLFOGFUNCSGISPROC', 'PFNGLGETFOGFUNCSGISPROC', 'GL_SGIX_fog_offset',
'GL_HP_image_transform', 'glImageTransformParameteriHP',
'glImageTransformParameterfHP', 'glImageTransformParameterivHP',
'glImageTransformParameterfvHP', 'glGetImageTransformParameterivHP',
'glGetImageTransformParameterfvHP', 'PFNGLIMAGETRANSFORMPARAMETERIHPPROC',
'PFNGLIMAGETRANSFORMPARAMETERFHPPROC', 'PFNGLIMAGETRANSFORMPARAMETERIVHPPROC',
'PFNGLIMAGETRANSFORMPARAMETERFVHPPROC',
'PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC',
'PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC', 'GL_HP_convolution_border_modes',
'GL_SGIX_texture_add_env', 'GL_EXT_color_subtable', 'glColorSubTableEXT',
'glCopyColorSubTableEXT', 'PFNGLCOLORSUBTABLEEXTPROC',
'PFNGLCOPYCOLORSUBTABLEEXTPROC', 'GL_PGI_vertex_hints', 'GL_PGI_misc_hints',
'glHintPGI', 'PFNGLHINTPGIPROC', 'GL_EXT_paletted_texture', 'glColorTableEXT',
'glGetColorTableEXT', 'glGetColorTableParameterivEXT',
'glGetColorTableParameterfvEXT', 'PFNGLCOLORTABLEEXTPROC',
'PFNGLGETCOLORTABLEEXTPROC', 'PFNGLGETCOLORTABLEPARAMETERIVEXTPROC',
'PFNGLGETCOLORTABLEPARAMETERFVEXTPROC', 'GL_EXT_clip_volume_hint',
'GL_SGIX_list_priority', 'glGetListParameterfvSGIX',
'glGetListParameterivSGIX', 'glListParameterfSGIX', 'glListParameterfvSGIX',
'glListParameteriSGIX', 'glListParameterivSGIX',
'PFNGLGETLISTPARAMETERFVSGIXPROC', 'PFNGLGETLISTPARAMETERIVSGIXPROC',
'PFNGLLISTPARAMETERFSGIXPROC', 'PFNGLLISTPARAMETERFVSGIXPROC',
'PFNGLLISTPARAMETERISGIXPROC', 'PFNGLLISTPARAMETERIVSGIXPROC',
'GL_SGIX_ir_instrument1', 'GL_SGIX_calligraphic_fragment',
'GL_SGIX_texture_lod_bias', 'GL_SGIX_shadow_ambient', 'GL_EXT_index_texture',
'GL_EXT_index_material', 'glIndexMaterialEXT', 'PFNGLINDEXMATERIALEXTPROC',
'GL_EXT_index_func', 'glIndexFuncEXT', 'PFNGLINDEXFUNCEXTPROC',
'GL_EXT_index_array_formats', 'GL_EXT_compiled_vertex_array',
'glLockArraysEXT', 'glUnlockArraysEXT', 'PFNGLLOCKARRAYSEXTPROC',
'PFNGLUNLOCKARRAYSEXTPROC', 'GL_EXT_cull_vertex', 'glCullParameterdvEXT',
'glCullParameterfvEXT', 'PFNGLCULLPARAMETERDVEXTPROC',
'PFNGLCULLPARAMETERFVEXTPROC', 'GL_SGIX_ycrcb', 'GL_SGIX_fragment_lighting',
'glFragmentColorMaterialSGIX', 'glFragmentLightfSGIX',
'glFragmentLightfvSGIX', 'glFragmentLightiSGIX', 'glFragmentLightivSGIX',
'glFragmentLightModelfSGIX', 'glFragmentLightModelfvSGIX',
'glFragmentLightModeliSGIX', 'glFragmentLightModelivSGIX',
'glFragmentMaterialfSGIX', 'glFragmentMaterialfvSGIX',
'glFragmentMaterialiSGIX', 'glFragmentMaterialivSGIX',
'glGetFragmentLightfvSGIX', 'glGetFragmentLightivSGIX',
'glGetFragmentMaterialfvSGIX', 'glGetFragmentMaterialivSGIX',
'glLightEnviSGIX', 'PFNGLFRAGMENTCOLORMATERIALSGIXPROC',
'PFNGLFRAGMENTLIGHTFSGIXPROC', 'PFNGLFRAGMENTLIGHTFVSGIXPROC',
'PFNGLFRAGMENTLIGHTISGIXPROC', 'PFNGLFRAGMENTLIGHTIVSGIXPROC',
'PFNGLFRAGMENTLIGHTMODELFSGIXPROC', 'PFNGLFRAGMENTLIGHTMODELFVSGIXPROC',
'PFNGLFRAGMENTLIGHTMODELISGIXPROC', 'PFNGLFRAGMENTLIGHTMODELIVSGIXPROC',
'PFNGLFRAGMENTMATERIALFSGIXPROC', 'PFNGLFRAGMENTMATERIALFVSGIXPROC',
'PFNGLFRAGMENTMATERIALISGIXPROC', 'PFNGLFRAGMENTMATERIALIVSGIXPROC',
'PFNGLGETFRAGMENTLIGHTFVSGIXPROC', 'PFNGLGETFRAGMENTLIGHTIVSGIXPROC',
'PFNGLGETFRAGMENTMATERIALFVSGIXPROC', 'PFNGLGETFRAGMENTMATERIALIVSGIXPROC',
'PFNGLLIGHTENVISGIXPROC', 'GL_IBM_rasterpos_clip', 'GL_HP_texture_lighting',
'GL_EXT_draw_range_elements', 'glDrawRangeElementsEXT',
'PFNGLDRAWRANGEELEMENTSEXTPROC', 'GL_WIN_phong_shading',
'GL_WIN_specular_fog', 'GL_EXT_light_texture', 'glApplyTextureEXT',
'glTextureLightEXT', 'glTextureMaterialEXT', 'PFNGLAPPLYTEXTUREEXTPROC',
'PFNGLTEXTURELIGHTEXTPROC', 'PFNGLTEXTUREMATERIALEXTPROC',
'GL_SGIX_blend_alpha_minmax', 'GL_EXT_bgra', 'GL_SGIX_async',
'glAsyncMarkerSGIX', 'glFinishAsyncSGIX', 'glPollAsyncSGIX',
'glGenAsyncMarkersSGIX', 'glDeleteAsyncMarkersSGIX', 'glIsAsyncMarkerSGIX',
'PFNGLASYNCMARKERSGIXPROC', 'PFNGLFINISHASYNCSGIXPROC',
'PFNGLPOLLASYNCSGIXPROC', 'PFNGLGENASYNCMARKERSSGIXPROC',
'PFNGLDELETEASYNCMARKERSSGIXPROC', 'PFNGLISASYNCMARKERSGIXPROC',
'GL_SGIX_async_pixel', 'GL_SGIX_async_histogram', 'GL_INTEL_parallel_arrays',
'glVertexPointervINTEL', 'glNormalPointervINTEL', 'glColorPointervINTEL',
'glTexCoordPointervINTEL', 'PFNGLVERTEXPOINTERVINTELPROC',
'PFNGLNORMALPOINTERVINTELPROC', 'PFNGLCOLORPOINTERVINTELPROC',
'PFNGLTEXCOORDPOINTERVINTELPROC', 'GL_HP_occlusion_test',
'GL_EXT_pixel_transform', 'glPixelTransformParameteriEXT',
'glPixelTransformParameterfEXT', 'glPixelTransformParameterivEXT',
'glPixelTransformParameterfvEXT', 'PFNGLPIXELTRANSFORMPARAMETERIEXTPROC',
'PFNGLPIXELTRANSFORMPARAMETERFEXTPROC',
'PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC',
'PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC', 'GL_EXT_pixel_transform_color_table',
'GL_EXT_shared_texture_palette', 'GL_EXT_separate_specular_color',
'GL_EXT_secondary_color', 'glSecondaryColor3bEXT', 'glSecondaryColor3bvEXT',
'glSecondaryColor3dEXT', 'glSecondaryColor3dvEXT', 'glSecondaryColor3fEXT',
'glSecondaryColor3fvEXT', 'glSecondaryColor3iEXT', 'glSecondaryColor3ivEXT',
'glSecondaryColor3sEXT', 'glSecondaryColor3svEXT', 'glSecondaryColor3ubEXT',
'glSecondaryColor3ubvEXT', 'glSecondaryColor3uiEXT',
'glSecondaryColor3uivEXT', 'glSecondaryColor3usEXT',
'glSecondaryColor3usvEXT', 'glSecondaryColorPointerEXT',
'PFNGLSECONDARYCOLOR3BEXTPROC', 'PFNGLSECONDARYCOLOR3BVEXTPROC',
'PFNGLSECONDARYCOLOR3DEXTPROC', 'PFNGLSECONDARYCOLOR3DVEXTPROC',
'PFNGLSECONDARYCOLOR3FEXTPROC', 'PFNGLSECONDARYCOLOR3FVEXTPROC',
'PFNGLSECONDARYCOLOR3IEXTPROC', 'PFNGLSECONDARYCOLOR3IVEXTPROC',
'PFNGLSECONDARYCOLOR3SEXTPROC', 'PFNGLSECONDARYCOLOR3SVEXTPROC',
'PFNGLSECONDARYCOLOR3UBEXTPROC', 'PFNGLSECONDARYCOLOR3UBVEXTPROC',
'PFNGLSECONDARYCOLOR3UIEXTPROC', 'PFNGLSECONDARYCOLOR3UIVEXTPROC',
'PFNGLSECONDARYCOLOR3USEXTPROC', 'PFNGLSECONDARYCOLOR3USVEXTPROC',
'PFNGLSECONDARYCOLORPOINTEREXTPROC', 'GL_EXT_texture_perturb_normal',
'glTextureNormalEXT', 'PFNGLTEXTURENORMALEXTPROC', 'GL_EXT_multi_draw_arrays',
'glMultiDrawArraysEXT', 'glMultiDrawElementsEXT',
'PFNGLMULTIDRAWARRAYSEXTPROC', 'PFNGLMULTIDRAWELEMENTSEXTPROC',
'GL_EXT_fog_coord', 'glFogCoordfEXT', 'glFogCoordfvEXT', 'glFogCoorddEXT',
'glFogCoorddvEXT', 'glFogCoordPointerEXT', 'PFNGLFOGCOORDFEXTPROC',
'PFNGLFOGCOORDFVEXTPROC', 'PFNGLFOGCOORDDEXTPROC', 'PFNGLFOGCOORDDVEXTPROC',
'PFNGLFOGCOORDPOINTEREXTPROC', 'GL_REND_screen_coordinates',
'GL_EXT_coordinate_frame', 'glTangent3bEXT', 'glTangent3bvEXT',
'glTangent3dEXT', 'glTangent3dvEXT', 'glTangent3fEXT', 'glTangent3fvEXT',
'glTangent3iEXT', 'glTangent3ivEXT', 'glTangent3sEXT', 'glTangent3svEXT',
'glBinormal3bEXT', 'glBinormal3bvEXT', 'glBinormal3dEXT', 'glBinormal3dvEXT',
'glBinormal3fEXT', 'glBinormal3fvEXT', 'glBinormal3iEXT', 'glBinormal3ivEXT',
'glBinormal3sEXT', 'glBinormal3svEXT', 'glTangentPointerEXT',
'glBinormalPointerEXT', 'PFNGLTANGENT3BEXTPROC', 'PFNGLTANGENT3BVEXTPROC',
'PFNGLTANGENT3DEXTPROC', 'PFNGLTANGENT3DVEXTPROC', 'PFNGLTANGENT3FEXTPROC',
'PFNGLTANGENT3FVEXTPROC', 'PFNGLTANGENT3IEXTPROC', 'PFNGLTANGENT3IVEXTPROC',
'PFNGLTANGENT3SEXTPROC', 'PFNGLTANGENT3SVEXTPROC', 'PFNGLBINORMAL3BEXTPROC',
'PFNGLBINORMAL3BVEXTPROC', 'PFNGLBINORMAL3DEXTPROC',
'PFNGLBINORMAL3DVEXTPROC', 'PFNGLBINORMAL3FEXTPROC',
'PFNGLBINORMAL3FVEXTPROC', 'PFNGLBINORMAL3IEXTPROC',
'PFNGLBINORMAL3IVEXTPROC', 'PFNGLBINORMAL3SEXTPROC',
'PFNGLBINORMAL3SVEXTPROC', 'PFNGLTANGENTPOINTEREXTPROC',
'PFNGLBINORMALPOINTEREXTPROC', 'GL_EXT_texture_env_combine',
'GL_APPLE_specular_vector', 'GL_APPLE_transform_hint', 'GL_SGIX_fog_scale',
'GL_SUNX_constant_data', 'glFinishTextureSUNX', 'PFNGLFINISHTEXTURESUNXPROC',
'GL_SUN_global_alpha', 'glGlobalAlphaFactorbSUN', 'glGlobalAlphaFactorsSUN',
'glGlobalAlphaFactoriSUN', 'glGlobalAlphaFactorfSUN',
'glGlobalAlphaFactordSUN', 'glGlobalAlphaFactorubSUN',
'glGlobalAlphaFactorusSUN', 'glGlobalAlphaFactoruiSUN',
'PFNGLGLOBALALPHAFACTORBSUNPROC', 'PFNGLGLOBALALPHAFACTORSSUNPROC',
'PFNGLGLOBALALPHAFACTORISUNPROC', 'PFNGLGLOBALALPHAFACTORFSUNPROC',
'PFNGLGLOBALALPHAFACTORDSUNPROC', 'PFNGLGLOBALALPHAFACTORUBSUNPROC',
'PFNGLGLOBALALPHAFACTORUSSUNPROC', 'PFNGLGLOBALALPHAFACTORUISUNPROC',
'GL_SUN_triangle_list', 'glReplacementCodeuiSUN', 'glReplacementCodeusSUN',
'glReplacementCodeubSUN', 'glReplacementCodeuivSUN',
'glReplacementCodeusvSUN', 'glReplacementCodeubvSUN',
'glReplacementCodePointerSUN', 'PFNGLREPLACEMENTCODEUISUNPROC',
'PFNGLREPLACEMENTCODEUSSUNPROC', 'PFNGLREPLACEMENTCODEUBSUNPROC',
'PFNGLREPLACEMENTCODEUIVSUNPROC', 'PFNGLREPLACEMENTCODEUSVSUNPROC',
'PFNGLREPLACEMENTCODEUBVSUNPROC', 'PFNGLREPLACEMENTCODEPOINTERSUNPROC',
'GL_SUN_vertex', 'glColor4ubVertex2fSUN', 'glColor4ubVertex2fvSUN',
'glColor4ubVertex3fSUN', 'glColor4ubVertex3fvSUN', 'glColor3fVertex3fSUN',
'glColor3fVertex3fvSUN', 'glNormal3fVertex3fSUN', 'glNormal3fVertex3fvSUN',
'glColor4fNormal3fVertex3fSUN', 'glColor4fNormal3fVertex3fvSUN',
'glTexCoord2fVertex3fSUN', 'glTexCoord2fVertex3fvSUN',
'glTexCoord4fVertex4fSUN', 'glTexCoord4fVertex4fvSUN',
'glTexCoord2fColor4ubVertex3fSUN', 'glTexCoord2fColor4ubVertex3fvSUN',
'glTexCoord2fColor3fVertex3fSUN', 'glTexCoord2fColor3fVertex3fvSUN',
'glTexCoord2fNormal3fVertex3fSUN', 'glTexCoord2fNormal3fVertex3fvSUN',
'glTexCoord2fColor4fNormal3fVertex3fSUN',
'glTexCoord2fColor4fNormal3fVertex3fvSUN',
'glTexCoord4fColor4fNormal3fVertex4fSUN',
'glTexCoord4fColor4fNormal3fVertex4fvSUN', 'glReplacementCodeuiVertex3fSUN',
'glReplacementCodeuiVertex3fvSUN', 'glReplacementCodeuiColor4ubVertex3fSUN',
'glReplacementCodeuiColor4ubVertex3fvSUN',
'glReplacementCodeuiColor3fVertex3fSUN',
'glReplacementCodeuiColor3fVertex3fvSUN',
'glReplacementCodeuiNormal3fVertex3fSUN',
'glReplacementCodeuiNormal3fVertex3fvSUN',
'glReplacementCodeuiColor4fNormal3fVertex3fSUN',
'glReplacementCodeuiColor4fNormal3fVertex3fvSUN',
'glReplacementCodeuiTexCoord2fVertex3fSUN',
'glReplacementCodeuiTexCoord2fVertex3fvSUN',
'glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN',
'glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN',
'glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN',
'glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN',
'PFNGLCOLOR4UBVERTEX2FSUNPROC', 'PFNGLCOLOR4UBVERTEX2FVSUNPROC',
'PFNGLCOLOR4UBVERTEX3FSUNPROC', 'PFNGLCOLOR4UBVERTEX3FVSUNPROC',
'PFNGLCOLOR3FVERTEX3FSUNPROC', 'PFNGLCOLOR3FVERTEX3FVSUNPROC',
'PFNGLNORMAL3FVERTEX3FSUNPROC', 'PFNGLNORMAL3FVERTEX3FVSUNPROC',
'PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC', 'PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC',
'PFNGLTEXCOORD2FVERTEX3FSUNPROC', 'PFNGLTEXCOORD2FVERTEX3FVSUNPROC',
'PFNGLTEXCOORD4FVERTEX4FSUNPROC', 'PFNGLTEXCOORD4FVERTEX4FVSUNPROC',
'PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC',
'PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC',
'PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC',
'PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC',
'PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC',
'PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC',
'PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC',
'PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC',
'PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC',
'PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC',
'PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC',
'PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC',
'PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC',
'PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC',
'PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC',
'PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC',
'PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC',
'PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC',
'GL_EXT_blend_func_separate', 'glBlendFuncSeparateEXT',
'PFNGLBLENDFUNCSEPARATEEXTPROC', 'GL_INGR_blend_func_separate',
'glBlendFuncSeparateINGR', 'PFNGLBLENDFUNCSEPARATEINGRPROC',
'GL_INGR_color_clamp', 'GL_INGR_interlace_read', 'GL_EXT_stencil_wrap',
'GL_EXT_422_pixels', 'GL_NV_texgen_reflection',
'GL_SUN_convolution_border_modes', 'GL_EXT_texture_env_add',
'GL_EXT_texture_lod_bias', 'GL_EXT_texture_filter_anisotropic',
'GL_EXT_vertex_weighting', 'glVertexWeightfEXT', 'glVertexWeightfvEXT',
'glVertexWeightPointerEXT', 'PFNGLVERTEXWEIGHTFEXTPROC',
'PFNGLVERTEXWEIGHTFVEXTPROC', 'PFNGLVERTEXWEIGHTPOINTEREXTPROC',
'GL_NV_light_max_exponent', 'GL_NV_vertex_array_range',
'glFlushVertexArrayRangeNV', 'glVertexArrayRangeNV',
'PFNGLFLUSHVERTEXARRAYRANGENVPROC', 'PFNGLVERTEXARRAYRANGENVPROC',
'GL_NV_register_combiners', 'glCombinerParameterfvNV',
'glCombinerParameterfNV', 'glCombinerParameterivNV', 'glCombinerParameteriNV',
'glCombinerInputNV', 'glCombinerOutputNV', 'glFinalCombinerInputNV',
'glGetCombinerInputParameterfvNV', 'glGetCombinerInputParameterivNV',
'glGetCombinerOutputParameterfvNV', 'glGetCombinerOutputParameterivNV',
'glGetFinalCombinerInputParameterfvNV',
'glGetFinalCombinerInputParameterivNV', 'PFNGLCOMBINERPARAMETERFVNVPROC',
'PFNGLCOMBINERPARAMETERFNVPROC', 'PFNGLCOMBINERPARAMETERIVNVPROC',
'PFNGLCOMBINERPARAMETERINVPROC', 'PFNGLCOMBINERINPUTNVPROC',
'PFNGLCOMBINEROUTPUTNVPROC', 'PFNGLFINALCOMBINERINPUTNVPROC',
'PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC',
'PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC',
'PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC',
'PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC',
'PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC',
'PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC', 'GL_NV_fog_distance',
'GL_NV_texgen_emboss', 'GL_NV_blend_square', 'GL_NV_texture_env_combine4',
'GL_MESA_resize_buffers', 'glResizeBuffersMESA', 'PFNGLRESIZEBUFFERSMESAPROC',
'GL_MESA_window_pos', 'glWindowPos2dMESA', 'glWindowPos2dvMESA',
'glWindowPos2fMESA', 'glWindowPos2fvMESA', 'glWindowPos2iMESA',
'glWindowPos2ivMESA', 'glWindowPos2sMESA', 'glWindowPos2svMESA',
'glWindowPos3dMESA', 'glWindowPos3dvMESA', 'glWindowPos3fMESA',
'glWindowPos3fvMESA', 'glWindowPos3iMESA', 'glWindowPos3ivMESA',
'glWindowPos3sMESA', 'glWindowPos3svMESA', 'glWindowPos4dMESA',
'glWindowPos4dvMESA', 'glWindowPos4fMESA', 'glWindowPos4fvMESA',
'glWindowPos4iMESA', 'glWindowPos4ivMESA', 'glWindowPos4sMESA',
'glWindowPos4svMESA', 'PFNGLWINDOWPOS2DMESAPROC', 'PFNGLWINDOWPOS2DVMESAPROC',
'PFNGLWINDOWPOS2FMESAPROC', 'PFNGLWINDOWPOS2FVMESAPROC',
'PFNGLWINDOWPOS2IMESAPROC', 'PFNGLWINDOWPOS2IVMESAPROC',
'PFNGLWINDOWPOS2SMESAPROC', 'PFNGLWINDOWPOS2SVMESAPROC',
'PFNGLWINDOWPOS3DMESAPROC', 'PFNGLWINDOWPOS3DVMESAPROC',
'PFNGLWINDOWPOS3FMESAPROC', 'PFNGLWINDOWPOS3FVMESAPROC',
'PFNGLWINDOWPOS3IMESAPROC', 'PFNGLWINDOWPOS3IVMESAPROC',
'PFNGLWINDOWPOS3SMESAPROC', 'PFNGLWINDOWPOS3SVMESAPROC',
'PFNGLWINDOWPOS4DMESAPROC', 'PFNGLWINDOWPOS4DVMESAPROC',
'PFNGLWINDOWPOS4FMESAPROC', 'PFNGLWINDOWPOS4FVMESAPROC',
'PFNGLWINDOWPOS4IMESAPROC', 'PFNGLWINDOWPOS4IVMESAPROC',
'PFNGLWINDOWPOS4SMESAPROC', 'PFNGLWINDOWPOS4SVMESAPROC', 'GL_IBM_cull_vertex',
'GL_IBM_multimode_draw_arrays', 'glMultiModeDrawArraysIBM',
'glMultiModeDrawElementsIBM', 'PFNGLMULTIMODEDRAWARRAYSIBMPROC',
'PFNGLMULTIMODEDRAWELEMENTSIBMPROC', 'GL_IBM_vertex_array_lists',
'glColorPointerListIBM', 'glSecondaryColorPointerListIBM',
'glEdgeFlagPointerListIBM', 'glFogCoordPointerListIBM',
'glIndexPointerListIBM', 'glNormalPointerListIBM', 'glTexCoordPointerListIBM',
'glVertexPointerListIBM', 'PFNGLCOLORPOINTERLISTIBMPROC',
'PFNGLSECONDARYCOLORPOINTERLISTIBMPROC', 'PFNGLEDGEFLAGPOINTERLISTIBMPROC',
'PFNGLFOGCOORDPOINTERLISTIBMPROC', 'PFNGLINDEXPOINTERLISTIBMPROC',
'PFNGLNORMALPOINTERLISTIBMPROC', 'PFNGLTEXCOORDPOINTERLISTIBMPROC',
'PFNGLVERTEXPOINTERLISTIBMPROC', 'GL_SGIX_subsample', 'GL_SGIX_ycrcba',
'GL_SGIX_ycrcb_subsample', 'GL_SGIX_depth_pass_instrument',
'GL_3DFX_texture_compression_FXT1', 'GL_3DFX_multisample', 'GL_3DFX_tbuffer',
'glTbufferMask3DFX', 'PFNGLTBUFFERMASK3DFXPROC', 'GL_EXT_multisample',
'glSampleMaskEXT', 'glSamplePatternEXT', 'PFNGLSAMPLEMASKEXTPROC',
'PFNGLSAMPLEPATTERNEXTPROC', 'GL_SGIX_vertex_preclip',
'GL_SGIX_convolution_accuracy', 'GL_SGIX_resample',
'GL_SGIS_point_line_texgen', 'GL_SGIS_texture_color_mask',
'glTextureColorMaskSGIS', 'PFNGLTEXTURECOLORMASKSGISPROC',
'GL_SGIX_igloo_interface', 'glIglooInterfaceSGIX',
'PFNGLIGLOOINTERFACESGIXPROC', 'GL_EXT_texture_env_dot3',
'GL_ATI_texture_mirror_once', 'GL_NV_fence', 'glDeleteFencesNV',
'glGenFencesNV', 'glIsFenceNV', 'glTestFenceNV', 'glGetFenceivNV',
'glFinishFenceNV', 'glSetFenceNV', 'PFNGLDELETEFENCESNVPROC',
'PFNGLGENFENCESNVPROC', 'PFNGLISFENCENVPROC', 'PFNGLTESTFENCENVPROC',
'PFNGLGETFENCEIVNVPROC', 'PFNGLFINISHFENCENVPROC', 'PFNGLSETFENCENVPROC',
'GL_NV_evaluators', 'glMapControlPointsNV', 'glMapParameterivNV',
'glMapParameterfvNV', 'glGetMapControlPointsNV', 'glGetMapParameterivNV',
'glGetMapParameterfvNV', 'glGetMapAttribParameterivNV',
'glGetMapAttribParameterfvNV', 'glEvalMapsNV', 'PFNGLMAPCONTROLPOINTSNVPROC',
'PFNGLMAPPARAMETERIVNVPROC', 'PFNGLMAPPARAMETERFVNVPROC',
'PFNGLGETMAPCONTROLPOINTSNVPROC', 'PFNGLGETMAPPARAMETERIVNVPROC',
'PFNGLGETMAPPARAMETERFVNVPROC', 'PFNGLGETMAPATTRIBPARAMETERIVNVPROC',
'PFNGLGETMAPATTRIBPARAMETERFVNVPROC', 'PFNGLEVALMAPSNVPROC',
'GL_NV_packed_depth_stencil', 'GL_NV_register_combiners2',
'glCombinerStageParameterfvNV', 'glGetCombinerStageParameterfvNV',
'PFNGLCOMBINERSTAGEPARAMETERFVNVPROC',
'PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC', 'GL_NV_texture_compression_vtc',
'GL_NV_texture_rectangle', 'GL_NV_texture_shader', 'GL_NV_texture_shader2',
'GL_NV_vertex_array_range2', 'GL_NV_vertex_program',
'glAreProgramsResidentNV', 'glBindProgramNV', 'glDeleteProgramsNV',
'glExecuteProgramNV', 'glGenProgramsNV', 'glGetProgramParameterdvNV',
'glGetProgramParameterfvNV', 'glGetProgramivNV', 'glGetProgramStringNV',
'glGetTrackMatrixivNV', 'glGetVertexAttribdvNV', 'glGetVertexAttribfvNV',
'glGetVertexAttribivNV', 'glGetVertexAttribPointervNV', 'glIsProgramNV',
'glLoadProgramNV', 'glProgramParameter4dNV', 'glProgramParameter4dvNV',
'glProgramParameter4fNV', 'glProgramParameter4fvNV',
'glProgramParameters4dvNV', 'glProgramParameters4fvNV',
'glRequestResidentProgramsNV', 'glTrackMatrixNV', 'glVertexAttribPointerNV',
'glVertexAttrib1dNV', 'glVertexAttrib1dvNV', 'glVertexAttrib1fNV',
'glVertexAttrib1fvNV', 'glVertexAttrib1sNV', 'glVertexAttrib1svNV',
'glVertexAttrib2dNV', 'glVertexAttrib2dvNV', 'glVertexAttrib2fNV',
'glVertexAttrib2fvNV', 'glVertexAttrib2sNV', 'glVertexAttrib2svNV',
'glVertexAttrib3dNV', 'glVertexAttrib3dvNV', 'glVertexAttrib3fNV',
'glVertexAttrib3fvNV', 'glVertexAttrib3sNV', 'glVertexAttrib3svNV',
'glVertexAttrib4dNV', 'glVertexAttrib4dvNV', 'glVertexAttrib4fNV',
'glVertexAttrib4fvNV', 'glVertexAttrib4sNV', 'glVertexAttrib4svNV',
'glVertexAttrib4ubNV', 'glVertexAttrib4ubvNV', 'glVertexAttribs1dvNV',
'glVertexAttribs1fvNV', 'glVertexAttribs1svNV', 'glVertexAttribs2dvNV',
'glVertexAttribs2fvNV', 'glVertexAttribs2svNV', 'glVertexAttribs3dvNV',
'glVertexAttribs3fvNV', 'glVertexAttribs3svNV', 'glVertexAttribs4dvNV',
'glVertexAttribs4fvNV', 'glVertexAttribs4svNV', 'glVertexAttribs4ubvNV',
'PFNGLAREPROGRAMSRESIDENTNVPROC', 'PFNGLBINDPROGRAMNVPROC',
'PFNGLDELETEPROGRAMSNVPROC', 'PFNGLEXECUTEPROGRAMNVPROC',
'PFNGLGENPROGRAMSNVPROC', 'PFNGLGETPROGRAMPARAMETERDVNVPROC',
'PFNGLGETPROGRAMPARAMETERFVNVPROC', 'PFNGLGETPROGRAMIVNVPROC',
'PFNGLGETPROGRAMSTRINGNVPROC', 'PFNGLGETTRACKMATRIXIVNVPROC',
'PFNGLGETVERTEXATTRIBDVNVPROC', 'PFNGLGETVERTEXATTRIBFVNVPROC',
'PFNGLGETVERTEXATTRIBIVNVPROC', 'PFNGLGETVERTEXATTRIBPOINTERVNVPROC',
'PFNGLISPROGRAMNVPROC', 'PFNGLLOADPROGRAMNVPROC',
'PFNGLPROGRAMPARAMETER4DNVPROC', 'PFNGLPROGRAMPARAMETER4DVNVPROC',
'PFNGLPROGRAMPARAMETER4FNVPROC', 'PFNGLPROGRAMPARAMETER4FVNVPROC',
'PFNGLPROGRAMPARAMETERS4DVNVPROC', 'PFNGLPROGRAMPARAMETERS4FVNVPROC',
'PFNGLREQUESTRESIDENTPROGRAMSNVPROC', 'PFNGLTRACKMATRIXNVPROC',
'PFNGLVERTEXATTRIBPOINTERNVPROC', 'PFNGLVERTEXATTRIB1DNVPROC',
'PFNGLVERTEXATTRIB1DVNVPROC', 'PFNGLVERTEXATTRIB1FNVPROC',
'PFNGLVERTEXATTRIB1FVNVPROC', 'PFNGLVERTEXATTRIB1SNVPROC',
'PFNGLVERTEXATTRIB1SVNVPROC', 'PFNGLVERTEXATTRIB2DNVPROC',
'PFNGLVERTEXATTRIB2DVNVPROC', 'PFNGLVERTEXATTRIB2FNVPROC',
'PFNGLVERTEXATTRIB2FVNVPROC', 'PFNGLVERTEXATTRIB2SNVPROC',
'PFNGLVERTEXATTRIB2SVNVPROC', 'PFNGLVERTEXATTRIB3DNVPROC',
'PFNGLVERTEXATTRIB3DVNVPROC', 'PFNGLVERTEXATTRIB3FNVPROC',
'PFNGLVERTEXATTRIB3FVNVPROC', 'PFNGLVERTEXATTRIB3SNVPROC',
'PFNGLVERTEXATTRIB3SVNVPROC', 'PFNGLVERTEXATTRIB4DNVPROC',
'PFNGLVERTEXATTRIB4DVNVPROC', 'PFNGLVERTEXATTRIB4FNVPROC',
'PFNGLVERTEXATTRIB4FVNVPROC', 'PFNGLVERTEXATTRIB4SNVPROC',
'PFNGLVERTEXATTRIB4SVNVPROC', 'PFNGLVERTEXATTRIB4UBNVPROC',
'PFNGLVERTEXATTRIB4UBVNVPROC', 'PFNGLVERTEXATTRIBS1DVNVPROC',
'PFNGLVERTEXATTRIBS1FVNVPROC', 'PFNGLVERTEXATTRIBS1SVNVPROC',
'PFNGLVERTEXATTRIBS2DVNVPROC', 'PFNGLVERTEXATTRIBS2FVNVPROC',
'PFNGLVERTEXATTRIBS2SVNVPROC', 'PFNGLVERTEXATTRIBS3DVNVPROC',
'PFNGLVERTEXATTRIBS3FVNVPROC', 'PFNGLVERTEXATTRIBS3SVNVPROC',
'PFNGLVERTEXATTRIBS4DVNVPROC', 'PFNGLVERTEXATTRIBS4FVNVPROC',
'PFNGLVERTEXATTRIBS4SVNVPROC', 'PFNGLVERTEXATTRIBS4UBVNVPROC',
'GL_SGIX_texture_coordinate_clamp', 'GL_SGIX_scalebias_hint',
'GL_OML_interlace', 'GL_OML_subsample', 'GL_OML_resample',
'GL_NV_copy_depth_to_color', 'GL_ATI_envmap_bumpmap',
'glTexBumpParameterivATI', 'glTexBumpParameterfvATI',
'glGetTexBumpParameterivATI', 'glGetTexBumpParameterfvATI',
'PFNGLTEXBUMPPARAMETERIVATIPROC', 'PFNGLTEXBUMPPARAMETERFVATIPROC',
'PFNGLGETTEXBUMPPARAMETERIVATIPROC', 'PFNGLGETTEXBUMPPARAMETERFVATIPROC',
'GL_ATI_fragment_shader', 'glGenFragmentShadersATI',
'glBindFragmentShaderATI', 'glDeleteFragmentShaderATI',
'glBeginFragmentShaderATI', 'glEndFragmentShaderATI', 'glPassTexCoordATI',
'glSampleMapATI', 'glColorFragmentOp1ATI', 'glColorFragmentOp2ATI',
'glColorFragmentOp3ATI', 'glAlphaFragmentOp1ATI', 'glAlphaFragmentOp2ATI',
'glAlphaFragmentOp3ATI', 'glSetFragmentShaderConstantATI',
'PFNGLGENFRAGMENTSHADERSATIPROC', 'PFNGLBINDFRAGMENTSHADERATIPROC',
'PFNGLDELETEFRAGMENTSHADERATIPROC', 'PFNGLBEGINFRAGMENTSHADERATIPROC',
'PFNGLENDFRAGMENTSHADERATIPROC', 'PFNGLPASSTEXCOORDATIPROC',
'PFNGLSAMPLEMAPATIPROC', 'PFNGLCOLORFRAGMENTOP1ATIPROC',
'PFNGLCOLORFRAGMENTOP2ATIPROC', 'PFNGLCOLORFRAGMENTOP3ATIPROC',
'PFNGLALPHAFRAGMENTOP1ATIPROC', 'PFNGLALPHAFRAGMENTOP2ATIPROC',
'PFNGLALPHAFRAGMENTOP3ATIPROC', 'PFNGLSETFRAGMENTSHADERCONSTANTATIPROC',
'GL_ATI_pn_triangles', 'glPNTrianglesiATI', 'glPNTrianglesfATI',
'PFNGLPNTRIANGLESIATIPROC', 'PFNGLPNTRIANGLESFATIPROC',
'GL_ATI_vertex_array_object', 'glNewObjectBufferATI', 'glIsObjectBufferATI',
'glUpdateObjectBufferATI', 'glGetObjectBufferfvATI', 'glGetObjectBufferivATI',
'glFreeObjectBufferATI', 'glArrayObjectATI', 'glGetArrayObjectfvATI',
'glGetArrayObjectivATI', 'glVariantArrayObjectATI',
'glGetVariantArrayObjectfvATI', 'glGetVariantArrayObjectivATI',
'PFNGLNEWOBJECTBUFFERATIPROC', 'PFNGLISOBJECTBUFFERATIPROC',
'PFNGLUPDATEOBJECTBUFFERATIPROC', 'PFNGLGETOBJECTBUFFERFVATIPROC',
'PFNGLGETOBJECTBUFFERIVATIPROC', 'PFNGLFREEOBJECTBUFFERATIPROC',
'PFNGLARRAYOBJECTATIPROC', 'PFNGLGETARRAYOBJECTFVATIPROC',
'PFNGLGETARRAYOBJECTIVATIPROC', 'PFNGLVARIANTARRAYOBJECTATIPROC',
'PFNGLGETVARIANTARRAYOBJECTFVATIPROC', 'PFNGLGETVARIANTARRAYOBJECTIVATIPROC',
'GL_EXT_vertex_shader', 'glBeginVertexShaderEXT', 'glEndVertexShaderEXT',
'glBindVertexShaderEXT', 'glGenVertexShadersEXT', 'glDeleteVertexShaderEXT',
'glShaderOp1EXT', 'glShaderOp2EXT', 'glShaderOp3EXT', 'glSwizzleEXT',
'glWriteMaskEXT', 'glInsertComponentEXT', 'glExtractComponentEXT',
'glGenSymbolsEXT', 'glSetInvariantEXT', 'glSetLocalConstantEXT',
'glVariantbvEXT', 'glVariantsvEXT', 'glVariantivEXT', 'glVariantfvEXT',
'glVariantdvEXT', 'glVariantubvEXT', 'glVariantusvEXT', 'glVariantuivEXT',
'glVariantPointerEXT', 'glEnableVariantClientStateEXT',
'glDisableVariantClientStateEXT', 'glBindLightParameterEXT',
'glBindMaterialParameterEXT', 'glBindTexGenParameterEXT',
'glBindTextureUnitParameterEXT', 'glBindParameterEXT',
'glIsVariantEnabledEXT', 'glGetVariantBooleanvEXT', 'glGetVariantIntegervEXT',
'glGetVariantFloatvEXT', 'glGetVariantPointervEXT',
'glGetInvariantBooleanvEXT', 'glGetInvariantIntegervEXT',
'glGetInvariantFloatvEXT', 'glGetLocalConstantBooleanvEXT',
'glGetLocalConstantIntegervEXT', 'glGetLocalConstantFloatvEXT',
'PFNGLBEGINVERTEXSHADEREXTPROC', 'PFNGLENDVERTEXSHADEREXTPROC',
'PFNGLBINDVERTEXSHADEREXTPROC', 'PFNGLGENVERTEXSHADERSEXTPROC',
'PFNGLDELETEVERTEXSHADEREXTPROC', 'PFNGLSHADEROP1EXTPROC',
'PFNGLSHADEROP2EXTPROC', 'PFNGLSHADEROP3EXTPROC', 'PFNGLSWIZZLEEXTPROC',
'PFNGLWRITEMASKEXTPROC', 'PFNGLINSERTCOMPONENTEXTPROC',
'PFNGLEXTRACTCOMPONENTEXTPROC', 'PFNGLGENSYMBOLSEXTPROC',
'PFNGLSETINVARIANTEXTPROC', 'PFNGLSETLOCALCONSTANTEXTPROC',
'PFNGLVARIANTBVEXTPROC', 'PFNGLVARIANTSVEXTPROC', 'PFNGLVARIANTIVEXTPROC',
'PFNGLVARIANTFVEXTPROC', 'PFNGLVARIANTDVEXTPROC', 'PFNGLVARIANTUBVEXTPROC',
'PFNGLVARIANTUSVEXTPROC', 'PFNGLVARIANTUIVEXTPROC',
'PFNGLVARIANTPOINTEREXTPROC', 'PFNGLENABLEVARIANTCLIENTSTATEEXTPROC',
'PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC', 'PFNGLBINDLIGHTPARAMETEREXTPROC',
'PFNGLBINDMATERIALPARAMETEREXTPROC', 'PFNGLBINDTEXGENPARAMETEREXTPROC',
'PFNGLBINDTEXTUREUNITPARAMETEREXTPROC', 'PFNGLBINDPARAMETEREXTPROC',
'PFNGLISVARIANTENABLEDEXTPROC', 'PFNGLGETVARIANTBOOLEANVEXTPROC',
'PFNGLGETVARIANTINTEGERVEXTPROC', 'PFNGLGETVARIANTFLOATVEXTPROC',
'PFNGLGETVARIANTPOINTERVEXTPROC', 'PFNGLGETINVARIANTBOOLEANVEXTPROC',
'PFNGLGETINVARIANTINTEGERVEXTPROC', 'PFNGLGETINVARIANTFLOATVEXTPROC',
'PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC',
'PFNGLGETLOCALCONSTANTINTEGERVEXTPROC', 'PFNGLGETLOCALCONSTANTFLOATVEXTPROC',
'GL_ATI_vertex_streams', 'glVertexStream1sATI', 'glVertexStream1svATI',
'glVertexStream1iATI', 'glVertexStream1ivATI', 'glVertexStream1fATI',
'glVertexStream1fvATI', 'glVertexStream1dATI', 'glVertexStream1dvATI',
'glVertexStream2sATI', 'glVertexStream2svATI', 'glVertexStream2iATI',
'glVertexStream2ivATI', 'glVertexStream2fATI', 'glVertexStream2fvATI',
'glVertexStream2dATI', 'glVertexStream2dvATI', 'glVertexStream3sATI',
'glVertexStream3svATI', 'glVertexStream3iATI', 'glVertexStream3ivATI',
'glVertexStream3fATI', 'glVertexStream3fvATI', 'glVertexStream3dATI',
'glVertexStream3dvATI', 'glVertexStream4sATI', 'glVertexStream4svATI',
'glVertexStream4iATI', 'glVertexStream4ivATI', 'glVertexStream4fATI',
'glVertexStream4fvATI', 'glVertexStream4dATI', 'glVertexStream4dvATI',
'glNormalStream3bATI', 'glNormalStream3bvATI', 'glNormalStream3sATI',
'glNormalStream3svATI', 'glNormalStream3iATI', 'glNormalStream3ivATI',
'glNormalStream3fATI', 'glNormalStream3fvATI', 'glNormalStream3dATI',
'glNormalStream3dvATI', 'glClientActiveVertexStreamATI',
'glVertexBlendEnviATI', 'glVertexBlendEnvfATI', 'PFNGLVERTEXSTREAM1SATIPROC',
'PFNGLVERTEXSTREAM1SVATIPROC', 'PFNGLVERTEXSTREAM1IATIPROC',
'PFNGLVERTEXSTREAM1IVATIPROC', 'PFNGLVERTEXSTREAM1FATIPROC',
'PFNGLVERTEXSTREAM1FVATIPROC', 'PFNGLVERTEXSTREAM1DATIPROC',
'PFNGLVERTEXSTREAM1DVATIPROC', 'PFNGLVERTEXSTREAM2SATIPROC',
'PFNGLVERTEXSTREAM2SVATIPROC', 'PFNGLVERTEXSTREAM2IATIPROC',
'PFNGLVERTEXSTREAM2IVATIPROC', 'PFNGLVERTEXSTREAM2FATIPROC',
'PFNGLVERTEXSTREAM2FVATIPROC', 'PFNGLVERTEXSTREAM2DATIPROC',
'PFNGLVERTEXSTREAM2DVATIPROC', 'PFNGLVERTEXSTREAM3SATIPROC',
'PFNGLVERTEXSTREAM3SVATIPROC', 'PFNGLVERTEXSTREAM3IATIPROC',
'PFNGLVERTEXSTREAM3IVATIPROC', 'PFNGLVERTEXSTREAM3FATIPROC',
'PFNGLVERTEXSTREAM3FVATIPROC', 'PFNGLVERTEXSTREAM3DATIPROC',
'PFNGLVERTEXSTREAM3DVATIPROC', 'PFNGLVERTEXSTREAM4SATIPROC',
'PFNGLVERTEXSTREAM4SVATIPROC', 'PFNGLVERTEXSTREAM4IATIPROC',
'PFNGLVERTEXSTREAM4IVATIPROC', 'PFNGLVERTEXSTREAM4FATIPROC',
'PFNGLVERTEXSTREAM4FVATIPROC', 'PFNGLVERTEXSTREAM4DATIPROC',
'PFNGLVERTEXSTREAM4DVATIPROC', 'PFNGLNORMALSTREAM3BATIPROC',
'PFNGLNORMALSTREAM3BVATIPROC', 'PFNGLNORMALSTREAM3SATIPROC',
'PFNGLNORMALSTREAM3SVATIPROC', 'PFNGLNORMALSTREAM3IATIPROC',
'PFNGLNORMALSTREAM3IVATIPROC', 'PFNGLNORMALSTREAM3FATIPROC',
'PFNGLNORMALSTREAM3FVATIPROC', 'PFNGLNORMALSTREAM3DATIPROC',
'PFNGLNORMALSTREAM3DVATIPROC', 'PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC',
'PFNGLVERTEXBLENDENVIATIPROC', 'PFNGLVERTEXBLENDENVFATIPROC',
'GL_ATI_element_array', 'glElementPointerATI', 'glDrawElementArrayATI',
'glDrawRangeElementArrayATI', 'PFNGLELEMENTPOINTERATIPROC',
'PFNGLDRAWELEMENTARRAYATIPROC', 'PFNGLDRAWRANGEELEMENTARRAYATIPROC',
'GL_SUN_mesh_array', 'glDrawMeshArraysSUN', 'PFNGLDRAWMESHARRAYSSUNPROC',
'GL_SUN_slice_accum', 'GL_NV_multisample_filter_hint', 'GL_NV_depth_clamp',
'GL_NV_occlusion_query', 'glGenOcclusionQueriesNV',
'glDeleteOcclusionQueriesNV', 'glIsOcclusionQueryNV',
'glBeginOcclusionQueryNV', 'glEndOcclusionQueryNV', 'glGetOcclusionQueryivNV',
'glGetOcclusionQueryuivNV', 'PFNGLGENOCCLUSIONQUERIESNVPROC',
'PFNGLDELETEOCCLUSIONQUERIESNVPROC', 'PFNGLISOCCLUSIONQUERYNVPROC',
'PFNGLBEGINOCCLUSIONQUERYNVPROC', 'PFNGLENDOCCLUSIONQUERYNVPROC',
'PFNGLGETOCCLUSIONQUERYIVNVPROC', 'PFNGLGETOCCLUSIONQUERYUIVNVPROC',
'GL_NV_point_sprite', 'glPointParameteriNV', 'glPointParameterivNV',
'PFNGLPOINTPARAMETERINVPROC', 'PFNGLPOINTPARAMETERIVNVPROC',
'GL_NV_texture_shader3', 'GL_NV_vertex_program1_1', 'GL_EXT_shadow_funcs',
'GL_EXT_stencil_two_side', 'glActiveStencilFaceEXT',
'PFNGLACTIVESTENCILFACEEXTPROC', 'GL_ATI_text_fragment_shader',
'GL_APPLE_client_storage', 'GL_APPLE_element_array', 'glElementPointerAPPLE',
'glDrawElementArrayAPPLE', 'glDrawRangeElementArrayAPPLE',
'glMultiDrawElementArrayAPPLE', 'glMultiDrawRangeElementArrayAPPLE',
'PFNGLELEMENTPOINTERAPPLEPROC', 'PFNGLDRAWELEMENTARRAYAPPLEPROC',
'PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC', 'PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC',
'PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC', 'GL_APPLE_fence',
'glGenFencesAPPLE', 'glDeleteFencesAPPLE', 'glSetFenceAPPLE',
'glIsFenceAPPLE', 'glTestFenceAPPLE', 'glFinishFenceAPPLE',
'glTestObjectAPPLE', 'glFinishObjectAPPLE', 'PFNGLGENFENCESAPPLEPROC',
'PFNGLDELETEFENCESAPPLEPROC', 'PFNGLSETFENCEAPPLEPROC',
'PFNGLISFENCEAPPLEPROC', 'PFNGLTESTFENCEAPPLEPROC',
'PFNGLFINISHFENCEAPPLEPROC', 'PFNGLTESTOBJECTAPPLEPROC',
'PFNGLFINISHOBJECTAPPLEPROC', 'GL_APPLE_vertex_array_object',
'glBindVertexArrayAPPLE', 'glDeleteVertexArraysAPPLE',
'glGenVertexArraysAPPLE', 'glIsVertexArrayAPPLE',
'PFNGLBINDVERTEXARRAYAPPLEPROC', 'PFNGLDELETEVERTEXARRAYSAPPLEPROC',
'PFNGLGENVERTEXARRAYSAPPLEPROC', 'PFNGLISVERTEXARRAYAPPLEPROC',
'GL_APPLE_vertex_array_range', 'glVertexArrayRangeAPPLE',
'glFlushVertexArrayRangeAPPLE', 'glVertexArrayParameteriAPPLE',
'PFNGLVERTEXARRAYRANGEAPPLEPROC', 'PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC',
'PFNGLVERTEXARRAYPARAMETERIAPPLEPROC', 'GL_APPLE_ycbcr_422', 'GL_S3_s3tc',
'GL_ATI_draw_buffers', 'glDrawBuffersATI', 'PFNGLDRAWBUFFERSATIPROC',
'GL_ATI_pixel_format_float', 'GL_ATI_texture_env_combine3',
'GL_ATI_texture_float', 'GL_NV_float_buffer', 'GL_NV_fragment_program',
'glProgramNamedParameter4fNV', 'glProgramNamedParameter4dNV',
'glProgramNamedParameter4fvNV', 'glProgramNamedParameter4dvNV',
'glGetProgramNamedParameterfvNV', 'glGetProgramNamedParameterdvNV',
'PFNGLPROGRAMNAMEDPARAMETER4FNVPROC', 'PFNGLPROGRAMNAMEDPARAMETER4DNVPROC',
'PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC', 'PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC',
'PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC',
'PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC', 'GL_NV_half_float', 'glVertex2hNV',
'glVertex2hvNV', 'glVertex3hNV', 'glVertex3hvNV', 'glVertex4hNV',
'glVertex4hvNV', 'glNormal3hNV', 'glNormal3hvNV', 'glColor3hNV',
'glColor3hvNV', 'glColor4hNV', 'glColor4hvNV', 'glTexCoord1hNV',
'glTexCoord1hvNV', 'glTexCoord2hNV', 'glTexCoord2hvNV', 'glTexCoord3hNV',
'glTexCoord3hvNV', 'glTexCoord4hNV', 'glTexCoord4hvNV', 'glMultiTexCoord1hNV',
'glMultiTexCoord1hvNV', 'glMultiTexCoord2hNV', 'glMultiTexCoord2hvNV',
'glMultiTexCoord3hNV', 'glMultiTexCoord3hvNV', 'glMultiTexCoord4hNV',
'glMultiTexCoord4hvNV', 'glFogCoordhNV', 'glFogCoordhvNV',
'glSecondaryColor3hNV', 'glSecondaryColor3hvNV', 'glVertexWeighthNV',
'glVertexWeighthvNV', 'glVertexAttrib1hNV', 'glVertexAttrib1hvNV',
'glVertexAttrib2hNV', 'glVertexAttrib2hvNV', 'glVertexAttrib3hNV',
'glVertexAttrib3hvNV', 'glVertexAttrib4hNV', 'glVertexAttrib4hvNV',
'glVertexAttribs1hvNV', 'glVertexAttribs2hvNV', 'glVertexAttribs3hvNV',
'glVertexAttribs4hvNV', 'PFNGLVERTEX2HNVPROC', 'PFNGLVERTEX2HVNVPROC',
'PFNGLVERTEX3HNVPROC', 'PFNGLVERTEX3HVNVPROC', 'PFNGLVERTEX4HNVPROC',
'PFNGLVERTEX4HVNVPROC', 'PFNGLNORMAL3HNVPROC', 'PFNGLNORMAL3HVNVPROC',
'PFNGLCOLOR3HNVPROC', 'PFNGLCOLOR3HVNVPROC', 'PFNGLCOLOR4HNVPROC',
'PFNGLCOLOR4HVNVPROC', 'PFNGLTEXCOORD1HNVPROC', 'PFNGLTEXCOORD1HVNVPROC',
'PFNGLTEXCOORD2HNVPROC', 'PFNGLTEXCOORD2HVNVPROC', 'PFNGLTEXCOORD3HNVPROC',
'PFNGLTEXCOORD3HVNVPROC', 'PFNGLTEXCOORD4HNVPROC', 'PFNGLTEXCOORD4HVNVPROC',
'PFNGLMULTITEXCOORD1HNVPROC', 'PFNGLMULTITEXCOORD1HVNVPROC',
'PFNGLMULTITEXCOORD2HNVPROC', 'PFNGLMULTITEXCOORD2HVNVPROC',
'PFNGLMULTITEXCOORD3HNVPROC', 'PFNGLMULTITEXCOORD3HVNVPROC',
'PFNGLMULTITEXCOORD4HNVPROC', 'PFNGLMULTITEXCOORD4HVNVPROC',
'PFNGLFOGCOORDHNVPROC', 'PFNGLFOGCOORDHVNVPROC',
'PFNGLSECONDARYCOLOR3HNVPROC', 'PFNGLSECONDARYCOLOR3HVNVPROC',
'PFNGLVERTEXWEIGHTHNVPROC', 'PFNGLVERTEXWEIGHTHVNVPROC',
'PFNGLVERTEXATTRIB1HNVPROC', 'PFNGLVERTEXATTRIB1HVNVPROC',
'PFNGLVERTEXATTRIB2HNVPROC', 'PFNGLVERTEXATTRIB2HVNVPROC',
'PFNGLVERTEXATTRIB3HNVPROC', 'PFNGLVERTEXATTRIB3HVNVPROC',
'PFNGLVERTEXATTRIB4HNVPROC', 'PFNGLVERTEXATTRIB4HVNVPROC',
'PFNGLVERTEXATTRIBS1HVNVPROC', 'PFNGLVERTEXATTRIBS2HVNVPROC',
'PFNGLVERTEXATTRIBS3HVNVPROC', 'PFNGLVERTEXATTRIBS4HVNVPROC',
'GL_NV_pixel_data_range', 'glPixelDataRangeNV', 'glFlushPixelDataRangeNV',
'PFNGLPIXELDATARANGENVPROC', 'PFNGLFLUSHPIXELDATARANGENVPROC',
'GL_NV_primitive_restart', 'glPrimitiveRestartNV',
'glPrimitiveRestartIndexNV', 'PFNGLPRIMITIVERESTARTNVPROC',
'PFNGLPRIMITIVERESTARTINDEXNVPROC', 'GL_NV_texture_expand_normal',
'GL_NV_vertex_program2', 'GL_ATI_map_object_buffer', 'glMapObjectBufferATI',
'glUnmapObjectBufferATI', 'PFNGLMAPOBJECTBUFFERATIPROC',
'PFNGLUNMAPOBJECTBUFFERATIPROC', 'GL_ATI_separate_stencil',
'glStencilOpSeparateATI', 'glStencilFuncSeparateATI',
'PFNGLSTENCILOPSEPARATEATIPROC', 'PFNGLSTENCILFUNCSEPARATEATIPROC',
'GL_ATI_vertex_attrib_array_object', 'glVertexAttribArrayObjectATI',
'glGetVertexAttribArrayObjectfvATI', 'glGetVertexAttribArrayObjectivATI',
'PFNGLVERTEXATTRIBARRAYOBJECTATIPROC',
'PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC',
'PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC', 'GL_OES_read_format',
'GL_EXT_depth_bounds_test', 'glDepthBoundsEXT', 'PFNGLDEPTHBOUNDSEXTPROC',
'GL_EXT_texture_mirror_clamp', 'GL_EXT_blend_equation_separate',
'glBlendEquationSeparateEXT', 'PFNGLBLENDEQUATIONSEPARATEEXTPROC',
'GL_MESA_pack_invert', 'GL_MESA_ycbcr_texture', 'GL_EXT_pixel_buffer_object',
'GL_NV_fragment_program_option', 'GL_NV_fragment_program2',
'GL_NV_vertex_program2_option', 'GL_NV_vertex_program3',
'GL_EXT_framebuffer_object', 'glIsRenderbufferEXT', 'glBindRenderbufferEXT',
'glDeleteRenderbuffersEXT', 'glGenRenderbuffersEXT',
'glRenderbufferStorageEXT', 'glGetRenderbufferParameterivEXT',
'glIsFramebufferEXT', 'glBindFramebufferEXT', 'glDeleteFramebuffersEXT',
'glGenFramebuffersEXT', 'glCheckFramebufferStatusEXT',
'glFramebufferTexture1DEXT', 'glFramebufferTexture2DEXT',
'glFramebufferTexture3DEXT', 'glFramebufferRenderbufferEXT',
'glGetFramebufferAttachmentParameterivEXT', 'glGenerateMipmapEXT',
'PFNGLISRENDERBUFFEREXTPROC', 'PFNGLBINDRENDERBUFFEREXTPROC',
'PFNGLDELETERENDERBUFFERSEXTPROC', 'PFNGLGENRENDERBUFFERSEXTPROC',
'PFNGLRENDERBUFFERSTORAGEEXTPROC', 'PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC',
'PFNGLISFRAMEBUFFEREXTPROC', 'PFNGLBINDFRAMEBUFFEREXTPROC',
'PFNGLDELETEFRAMEBUFFERSEXTPROC', 'PFNGLGENFRAMEBUFFERSEXTPROC',
'PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC', 'PFNGLFRAMEBUFFERTEXTURE1DEXTPROC',
'PFNGLFRAMEBUFFERTEXTURE2DEXTPROC', 'PFNGLFRAMEBUFFERTEXTURE3DEXTPROC',
'PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC',
'PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC',
'PFNGLGENERATEMIPMAPEXTPROC', 'GL_GREMEDY_string_marker',
'glStringMarkerGREMEDY', 'PFNGLSTRINGMARKERGREMEDYPROC']
# END GENERATED CONTENT (do not edit above this line)




########NEW FILE########
__FILENAME__ = glext_missing
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Additional hand-coded GL extensions.

These are hand-wrapped extension tokens and functions that are in
the OpenGL Extension Registry but have not yet been added to either
the registry's glext.h or nVidia's glext.h.  Remove wraps from here
when the headers are updated (and glext_arb.py or glext_nv.py are
regenerated).

When adding an extension here, include the name and URL, and any tokens and
functions appearing under "New Tokens" and "New Procedures" headings.  Don't
forget to add the GL_/gl prefix.

Unnumbered extensions in the registry are not included.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: glext_missing.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

from ctypes import *
from pyglet.gl.lib import link_GL as _link_function
from pyglet.gl.lib import c_ptrdiff_t

# At time of writing, ABI glext.h was last updated 2005/06/20, so numbered
# non-ARB extensions from 312 on must be included here.

# GL_EXT_packed_depth_stencil
# http://oss.sgi.com/projects/ogl-sample/registry/EXT/packed_depth_stencil.txt

GL_DEPTH_STENCIL_EXT                 = 0x84F9
GL_UNSIGNED_INT_24_8_EXT             = 0x84FA
GL_DEPTH24_STENCIL8_EXT              = 0x88F0
GL_TEXTURE_STENCIL_SIZE_EXT          = 0x88F1

# GL_EXT_texture_sRGB
# http://oss.sgi.com/projects/ogl-sample/registry/EXT/texture_sRGB.txt

GL_SRGB_EXT                                 = 0x8C40
GL_SRGB8_EXT                                = 0x8C41
GL_SRGB_ALPHA_EXT                           = 0x8C42
GL_SRGB8_ALPHA8_EXT                         = 0x8C43
GL_SLUMINANCE_ALPHA_EXT                     = 0x8C44
GL_SLUMINANCE8_ALPHA8_EXT                   = 0x8C45
GL_SLUMINANCE_EXT                           = 0x8C46
GL_SLUMINANCE8_EXT                          = 0x8C47
GL_COMPRESSED_SRGB_EXT                      = 0x8C48
GL_COMPRESSED_SRGB_ALPHA_EXT                = 0x8C49
GL_COMPRESSED_SLUMINANCE_EXT                = 0x8C4A
GL_COMPRESSED_SLUMINANCE_ALPHA_EXT          = 0x8C4B
GL_COMPRESSED_SRGB_S3TC_DXT1_EXT            = 0x8C4C
GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT      = 0x8C4D
GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT      = 0x8C4E
GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT      = 0x8C4F

# GL_EXT_stencil_clear_tag
# http://oss.sgi.com/projects/ogl-sample/registry/EXT/stencil_clear_tag.txt

GLuint = c_uint 	# /usr/include/GL/gl.h:62
GLsizei = c_int 	# /usr/include/GL/gl.h:59
glStencilClearTagEXT = _link_function(
    'glStencilClearTagEXT', None, [GLsizei, GLuint])

GL_STENCIL_TAG_BITS_EXT              = 0x88F2
GL_STENCIL_CLEAR_TAG_VALUE_EXT       = 0x88F3

# GL_EXT_framebuffer_blit
# http://oss.sgi.com/projects/ogl-sample/registry/EXT/framebuffer_blit.txt

GLenum = c_uint 	# /usr/include/GL/gl.h:53
GLint = c_int 	# /usr/include/GL/gl.h:58
glBlitFramebufferEXT = _link_function(
    'glBlitFramebufferEXT', None, [GLint, GLint, GLint, GLint,
                                   GLint, GLint, GLint, GLint,
                                   GLuint, GLenum])

GL_READ_FRAMEBUFFER_EXT              = 0x8CA8
GL_DRAW_FRAMEBUFFER_EXT              = 0x8CA9
GL_DRAW_FRAMEBUFFER_BINDING_EXT      = 0x8CA6
GL_READ_FRAMEBUFFER_BINDING_EXT      = 0x8CAA

# GL_EXT_framebuffer_multisample
# http://oss.sgi.com/projects/ogl-sample/registry/EXT/framebuffer_multisample.txt

GL_RENDERBUFFER_SAMPLES_EXT          = 0x8CAB

# GL_MESAX_texture_stack
# http://oss.sgi.com/projects/ogl-sample/registry/MESAX/texture_stack.txt

GL_TEXTURE_1D_STACK_MESAX            = 0x8759
GL_TEXTURE_2D_STACK_MESAX            = 0x875A
GL_PROXY_TEXTURE_1D_STACK_MESAX      = 0x875B
GL_PROXY_TEXTURE_2D_STACK_MESAX      = 0x875C
GL_TEXTURE_1D_STACK_BINDING_MESAX    = 0x875D
GL_TEXTURE_2D_STACK_BINDING_MESAX    = 0x875E

########NEW FILE########
__FILENAME__ = glext_nv
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for http://developer.download.nvidia.com/opengl/includes/glext.h

Generated by tools/gengl.py.
Do not modify this file.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: glext_nv.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

from ctypes import *
from pyglet.gl.lib import link_GL as _link_function
from pyglet.gl.lib import c_ptrdiff_t

# BEGIN GENERATED CONTENT (do not edit below this line)

# This content is generated by tools/gengl.py.
# Wrapper for http://developer.download.nvidia.com/opengl/includes/glext.h


# GLEXT_LEGACY (/usr/include/GL/gl.h:70)
GL_GLEXT_VERSION = 28 	# GL/glext.h:74
# VERSION_1_2 (GL/glext.h:76)
GL_UNSIGNED_BYTE_3_3_2 = 32818 	# GL/glext.h:77
GL_UNSIGNED_SHORT_4_4_4_4 = 32819 	# GL/glext.h:78
GL_UNSIGNED_SHORT_5_5_5_1 = 32820 	# GL/glext.h:79
GL_UNSIGNED_INT_8_8_8_8 = 32821 	# GL/glext.h:80
GL_UNSIGNED_INT_10_10_10_2 = 32822 	# GL/glext.h:81
GL_RESCALE_NORMAL = 32826 	# GL/glext.h:82
GL_TEXTURE_BINDING_3D = 32874 	# GL/glext.h:83
GL_PACK_SKIP_IMAGES = 32875 	# GL/glext.h:84
GL_PACK_IMAGE_HEIGHT = 32876 	# GL/glext.h:85
GL_UNPACK_SKIP_IMAGES = 32877 	# GL/glext.h:86
GL_UNPACK_IMAGE_HEIGHT = 32878 	# GL/glext.h:87
GL_TEXTURE_3D = 32879 	# GL/glext.h:88
GL_PROXY_TEXTURE_3D = 32880 	# GL/glext.h:89
GL_TEXTURE_DEPTH = 32881 	# GL/glext.h:90
GL_TEXTURE_WRAP_R = 32882 	# GL/glext.h:91
GL_MAX_3D_TEXTURE_SIZE = 32883 	# GL/glext.h:92
GL_UNSIGNED_BYTE_2_3_3_REV = 33634 	# GL/glext.h:93
GL_UNSIGNED_SHORT_5_6_5 = 33635 	# GL/glext.h:94
GL_UNSIGNED_SHORT_5_6_5_REV = 33636 	# GL/glext.h:95
GL_UNSIGNED_SHORT_4_4_4_4_REV = 33637 	# GL/glext.h:96
GL_UNSIGNED_SHORT_1_5_5_5_REV = 33638 	# GL/glext.h:97
GL_UNSIGNED_INT_8_8_8_8_REV = 33639 	# GL/glext.h:98
GL_UNSIGNED_INT_2_10_10_10_REV = 33640 	# GL/glext.h:99
GL_BGR = 32992 	# GL/glext.h:100
GL_BGRA = 32993 	# GL/glext.h:101
GL_MAX_ELEMENTS_VERTICES = 33000 	# GL/glext.h:102
GL_MAX_ELEMENTS_INDICES = 33001 	# GL/glext.h:103
GL_CLAMP_TO_EDGE = 33071 	# GL/glext.h:104
GL_TEXTURE_MIN_LOD = 33082 	# GL/glext.h:105
GL_TEXTURE_MAX_LOD = 33083 	# GL/glext.h:106
GL_TEXTURE_BASE_LEVEL = 33084 	# GL/glext.h:107
GL_TEXTURE_MAX_LEVEL = 33085 	# GL/glext.h:108
GL_LIGHT_MODEL_COLOR_CONTROL = 33272 	# GL/glext.h:109
GL_SINGLE_COLOR = 33273 	# GL/glext.h:110
GL_SEPARATE_SPECULAR_COLOR = 33274 	# GL/glext.h:111
GL_SMOOTH_POINT_SIZE_RANGE = 2834 	# GL/glext.h:112
GL_SMOOTH_POINT_SIZE_GRANULARITY = 2835 	# GL/glext.h:113
GL_SMOOTH_LINE_WIDTH_RANGE = 2850 	# GL/glext.h:114
GL_SMOOTH_LINE_WIDTH_GRANULARITY = 2851 	# GL/glext.h:115
GL_ALIASED_POINT_SIZE_RANGE = 33901 	# GL/glext.h:116
GL_ALIASED_LINE_WIDTH_RANGE = 33902 	# GL/glext.h:117
# ARB_imaging (GL/glext.h:120)
GL_CONSTANT_COLOR = 32769 	# GL/glext.h:121
GL_ONE_MINUS_CONSTANT_COLOR = 32770 	# GL/glext.h:122
GL_CONSTANT_ALPHA = 32771 	# GL/glext.h:123
GL_ONE_MINUS_CONSTANT_ALPHA = 32772 	# GL/glext.h:124
GL_BLEND_COLOR = 32773 	# GL/glext.h:125
GL_FUNC_ADD = 32774 	# GL/glext.h:126
GL_MIN = 32775 	# GL/glext.h:127
GL_MAX = 32776 	# GL/glext.h:128
GL_BLEND_EQUATION = 32777 	# GL/glext.h:129
GL_FUNC_SUBTRACT = 32778 	# GL/glext.h:130
GL_FUNC_REVERSE_SUBTRACT = 32779 	# GL/glext.h:131
GL_CONVOLUTION_1D = 32784 	# GL/glext.h:132
GL_CONVOLUTION_2D = 32785 	# GL/glext.h:133
GL_SEPARABLE_2D = 32786 	# GL/glext.h:134
GL_CONVOLUTION_BORDER_MODE = 32787 	# GL/glext.h:135
GL_CONVOLUTION_FILTER_SCALE = 32788 	# GL/glext.h:136
GL_CONVOLUTION_FILTER_BIAS = 32789 	# GL/glext.h:137
GL_REDUCE = 32790 	# GL/glext.h:138
GL_CONVOLUTION_FORMAT = 32791 	# GL/glext.h:139
GL_CONVOLUTION_WIDTH = 32792 	# GL/glext.h:140
GL_CONVOLUTION_HEIGHT = 32793 	# GL/glext.h:141
GL_MAX_CONVOLUTION_WIDTH = 32794 	# GL/glext.h:142
GL_MAX_CONVOLUTION_HEIGHT = 32795 	# GL/glext.h:143
GL_POST_CONVOLUTION_RED_SCALE = 32796 	# GL/glext.h:144
GL_POST_CONVOLUTION_GREEN_SCALE = 32797 	# GL/glext.h:145
GL_POST_CONVOLUTION_BLUE_SCALE = 32798 	# GL/glext.h:146
GL_POST_CONVOLUTION_ALPHA_SCALE = 32799 	# GL/glext.h:147
GL_POST_CONVOLUTION_RED_BIAS = 32800 	# GL/glext.h:148
GL_POST_CONVOLUTION_GREEN_BIAS = 32801 	# GL/glext.h:149
GL_POST_CONVOLUTION_BLUE_BIAS = 32802 	# GL/glext.h:150
GL_POST_CONVOLUTION_ALPHA_BIAS = 32803 	# GL/glext.h:151
GL_HISTOGRAM = 32804 	# GL/glext.h:152
GL_PROXY_HISTOGRAM = 32805 	# GL/glext.h:153
GL_HISTOGRAM_WIDTH = 32806 	# GL/glext.h:154
GL_HISTOGRAM_FORMAT = 32807 	# GL/glext.h:155
GL_HISTOGRAM_RED_SIZE = 32808 	# GL/glext.h:156
GL_HISTOGRAM_GREEN_SIZE = 32809 	# GL/glext.h:157
GL_HISTOGRAM_BLUE_SIZE = 32810 	# GL/glext.h:158
GL_HISTOGRAM_ALPHA_SIZE = 32811 	# GL/glext.h:159
GL_HISTOGRAM_LUMINANCE_SIZE = 32812 	# GL/glext.h:160
GL_HISTOGRAM_SINK = 32813 	# GL/glext.h:161
GL_MINMAX = 32814 	# GL/glext.h:162
GL_MINMAX_FORMAT = 32815 	# GL/glext.h:163
GL_MINMAX_SINK = 32816 	# GL/glext.h:164
GL_TABLE_TOO_LARGE = 32817 	# GL/glext.h:165
GL_COLOR_MATRIX = 32945 	# GL/glext.h:166
GL_COLOR_MATRIX_STACK_DEPTH = 32946 	# GL/glext.h:167
GL_MAX_COLOR_MATRIX_STACK_DEPTH = 32947 	# GL/glext.h:168
GL_POST_COLOR_MATRIX_RED_SCALE = 32948 	# GL/glext.h:169
GL_POST_COLOR_MATRIX_GREEN_SCALE = 32949 	# GL/glext.h:170
GL_POST_COLOR_MATRIX_BLUE_SCALE = 32950 	# GL/glext.h:171
GL_POST_COLOR_MATRIX_ALPHA_SCALE = 32951 	# GL/glext.h:172
GL_POST_COLOR_MATRIX_RED_BIAS = 32952 	# GL/glext.h:173
GL_POST_COLOR_MATRIX_GREEN_BIAS = 32953 	# GL/glext.h:174
GL_POST_COLOR_MATRIX_BLUE_BIAS = 32954 	# GL/glext.h:175
GL_POST_COLOR_MATRIX_ALPHA_BIAS = 32955 	# GL/glext.h:176
GL_COLOR_TABLE = 32976 	# GL/glext.h:177
GL_POST_CONVOLUTION_COLOR_TABLE = 32977 	# GL/glext.h:178
GL_POST_COLOR_MATRIX_COLOR_TABLE = 32978 	# GL/glext.h:179
GL_PROXY_COLOR_TABLE = 32979 	# GL/glext.h:180
GL_PROXY_POST_CONVOLUTION_COLOR_TABLE = 32980 	# GL/glext.h:181
GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE = 32981 	# GL/glext.h:182
GL_COLOR_TABLE_SCALE = 32982 	# GL/glext.h:183
GL_COLOR_TABLE_BIAS = 32983 	# GL/glext.h:184
GL_COLOR_TABLE_FORMAT = 32984 	# GL/glext.h:185
GL_COLOR_TABLE_WIDTH = 32985 	# GL/glext.h:186
GL_COLOR_TABLE_RED_SIZE = 32986 	# GL/glext.h:187
GL_COLOR_TABLE_GREEN_SIZE = 32987 	# GL/glext.h:188
GL_COLOR_TABLE_BLUE_SIZE = 32988 	# GL/glext.h:189
GL_COLOR_TABLE_ALPHA_SIZE = 32989 	# GL/glext.h:190
GL_COLOR_TABLE_LUMINANCE_SIZE = 32990 	# GL/glext.h:191
GL_COLOR_TABLE_INTENSITY_SIZE = 32991 	# GL/glext.h:192
GL_CONSTANT_BORDER = 33105 	# GL/glext.h:193
GL_REPLICATE_BORDER = 33107 	# GL/glext.h:194
GL_CONVOLUTION_BORDER_COLOR = 33108 	# GL/glext.h:195
# VERSION_1_3 (GL/glext.h:198)
GL_TEXTURE0 = 33984 	# GL/glext.h:199
GL_TEXTURE1 = 33985 	# GL/glext.h:200
GL_TEXTURE2 = 33986 	# GL/glext.h:201
GL_TEXTURE3 = 33987 	# GL/glext.h:202
GL_TEXTURE4 = 33988 	# GL/glext.h:203
GL_TEXTURE5 = 33989 	# GL/glext.h:204
GL_TEXTURE6 = 33990 	# GL/glext.h:205
GL_TEXTURE7 = 33991 	# GL/glext.h:206
GL_TEXTURE8 = 33992 	# GL/glext.h:207
GL_TEXTURE9 = 33993 	# GL/glext.h:208
GL_TEXTURE10 = 33994 	# GL/glext.h:209
GL_TEXTURE11 = 33995 	# GL/glext.h:210
GL_TEXTURE12 = 33996 	# GL/glext.h:211
GL_TEXTURE13 = 33997 	# GL/glext.h:212
GL_TEXTURE14 = 33998 	# GL/glext.h:213
GL_TEXTURE15 = 33999 	# GL/glext.h:214
GL_TEXTURE16 = 34000 	# GL/glext.h:215
GL_TEXTURE17 = 34001 	# GL/glext.h:216
GL_TEXTURE18 = 34002 	# GL/glext.h:217
GL_TEXTURE19 = 34003 	# GL/glext.h:218
GL_TEXTURE20 = 34004 	# GL/glext.h:219
GL_TEXTURE21 = 34005 	# GL/glext.h:220
GL_TEXTURE22 = 34006 	# GL/glext.h:221
GL_TEXTURE23 = 34007 	# GL/glext.h:222
GL_TEXTURE24 = 34008 	# GL/glext.h:223
GL_TEXTURE25 = 34009 	# GL/glext.h:224
GL_TEXTURE26 = 34010 	# GL/glext.h:225
GL_TEXTURE27 = 34011 	# GL/glext.h:226
GL_TEXTURE28 = 34012 	# GL/glext.h:227
GL_TEXTURE29 = 34013 	# GL/glext.h:228
GL_TEXTURE30 = 34014 	# GL/glext.h:229
GL_TEXTURE31 = 34015 	# GL/glext.h:230
GL_ACTIVE_TEXTURE = 34016 	# GL/glext.h:231
GL_CLIENT_ACTIVE_TEXTURE = 34017 	# GL/glext.h:232
GL_MAX_TEXTURE_UNITS = 34018 	# GL/glext.h:233
GL_TRANSPOSE_MODELVIEW_MATRIX = 34019 	# GL/glext.h:234
GL_TRANSPOSE_PROJECTION_MATRIX = 34020 	# GL/glext.h:235
GL_TRANSPOSE_TEXTURE_MATRIX = 34021 	# GL/glext.h:236
GL_TRANSPOSE_COLOR_MATRIX = 34022 	# GL/glext.h:237
GL_MULTISAMPLE = 32925 	# GL/glext.h:238
GL_SAMPLE_ALPHA_TO_COVERAGE = 32926 	# GL/glext.h:239
GL_SAMPLE_ALPHA_TO_ONE = 32927 	# GL/glext.h:240
GL_SAMPLE_COVERAGE = 32928 	# GL/glext.h:241
GL_SAMPLE_BUFFERS = 32936 	# GL/glext.h:242
GL_SAMPLES = 32937 	# GL/glext.h:243
GL_SAMPLE_COVERAGE_VALUE = 32938 	# GL/glext.h:244
GL_SAMPLE_COVERAGE_INVERT = 32939 	# GL/glext.h:245
GL_MULTISAMPLE_BIT = 536870912 	# GL/glext.h:246
GL_NORMAL_MAP = 34065 	# GL/glext.h:247
GL_REFLECTION_MAP = 34066 	# GL/glext.h:248
GL_TEXTURE_CUBE_MAP = 34067 	# GL/glext.h:249
GL_TEXTURE_BINDING_CUBE_MAP = 34068 	# GL/glext.h:250
GL_TEXTURE_CUBE_MAP_POSITIVE_X = 34069 	# GL/glext.h:251
GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 34070 	# GL/glext.h:252
GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 34071 	# GL/glext.h:253
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072 	# GL/glext.h:254
GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 34073 	# GL/glext.h:255
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074 	# GL/glext.h:256
GL_PROXY_TEXTURE_CUBE_MAP = 34075 	# GL/glext.h:257
GL_MAX_CUBE_MAP_TEXTURE_SIZE = 34076 	# GL/glext.h:258
GL_COMPRESSED_ALPHA = 34025 	# GL/glext.h:259
GL_COMPRESSED_LUMINANCE = 34026 	# GL/glext.h:260
GL_COMPRESSED_LUMINANCE_ALPHA = 34027 	# GL/glext.h:261
GL_COMPRESSED_INTENSITY = 34028 	# GL/glext.h:262
GL_COMPRESSED_RGB = 34029 	# GL/glext.h:263
GL_COMPRESSED_RGBA = 34030 	# GL/glext.h:264
GL_TEXTURE_COMPRESSION_HINT = 34031 	# GL/glext.h:265
GL_TEXTURE_COMPRESSED_IMAGE_SIZE = 34464 	# GL/glext.h:266
GL_TEXTURE_COMPRESSED = 34465 	# GL/glext.h:267
GL_NUM_COMPRESSED_TEXTURE_FORMATS = 34466 	# GL/glext.h:268
GL_COMPRESSED_TEXTURE_FORMATS = 34467 	# GL/glext.h:269
GL_CLAMP_TO_BORDER = 33069 	# GL/glext.h:270
GL_COMBINE = 34160 	# GL/glext.h:271
GL_COMBINE_RGB = 34161 	# GL/glext.h:272
GL_COMBINE_ALPHA = 34162 	# GL/glext.h:273
GL_SOURCE0_RGB = 34176 	# GL/glext.h:274
GL_SOURCE1_RGB = 34177 	# GL/glext.h:275
GL_SOURCE2_RGB = 34178 	# GL/glext.h:276
GL_SOURCE0_ALPHA = 34184 	# GL/glext.h:277
GL_SOURCE1_ALPHA = 34185 	# GL/glext.h:278
GL_SOURCE2_ALPHA = 34186 	# GL/glext.h:279
GL_OPERAND0_RGB = 34192 	# GL/glext.h:280
GL_OPERAND1_RGB = 34193 	# GL/glext.h:281
GL_OPERAND2_RGB = 34194 	# GL/glext.h:282
GL_OPERAND0_ALPHA = 34200 	# GL/glext.h:283
GL_OPERAND1_ALPHA = 34201 	# GL/glext.h:284
GL_OPERAND2_ALPHA = 34202 	# GL/glext.h:285
GL_RGB_SCALE = 34163 	# GL/glext.h:286
GL_ADD_SIGNED = 34164 	# GL/glext.h:287
GL_INTERPOLATE = 34165 	# GL/glext.h:288
GL_SUBTRACT = 34023 	# GL/glext.h:289
GL_CONSTANT = 34166 	# GL/glext.h:290
GL_PRIMARY_COLOR = 34167 	# GL/glext.h:291
GL_PREVIOUS = 34168 	# GL/glext.h:292
GL_DOT3_RGB = 34478 	# GL/glext.h:293
GL_DOT3_RGBA = 34479 	# GL/glext.h:294
# VERSION_1_4 (GL/glext.h:297)
GL_BLEND_DST_RGB = 32968 	# GL/glext.h:298
GL_BLEND_SRC_RGB = 32969 	# GL/glext.h:299
GL_BLEND_DST_ALPHA = 32970 	# GL/glext.h:300
GL_BLEND_SRC_ALPHA = 32971 	# GL/glext.h:301
GL_POINT_SIZE_MIN = 33062 	# GL/glext.h:302
GL_POINT_SIZE_MAX = 33063 	# GL/glext.h:303
GL_POINT_FADE_THRESHOLD_SIZE = 33064 	# GL/glext.h:304
GL_POINT_DISTANCE_ATTENUATION = 33065 	# GL/glext.h:305
GL_GENERATE_MIPMAP = 33169 	# GL/glext.h:306
GL_GENERATE_MIPMAP_HINT = 33170 	# GL/glext.h:307
GL_DEPTH_COMPONENT16 = 33189 	# GL/glext.h:308
GL_DEPTH_COMPONENT24 = 33190 	# GL/glext.h:309
GL_DEPTH_COMPONENT32 = 33191 	# GL/glext.h:310
GL_MIRRORED_REPEAT = 33648 	# GL/glext.h:311
GL_FOG_COORDINATE_SOURCE = 33872 	# GL/glext.h:312
GL_FOG_COORDINATE = 33873 	# GL/glext.h:313
GL_FRAGMENT_DEPTH = 33874 	# GL/glext.h:314
GL_CURRENT_FOG_COORDINATE = 33875 	# GL/glext.h:315
GL_FOG_COORDINATE_ARRAY_TYPE = 33876 	# GL/glext.h:316
GL_FOG_COORDINATE_ARRAY_STRIDE = 33877 	# GL/glext.h:317
GL_FOG_COORDINATE_ARRAY_POINTER = 33878 	# GL/glext.h:318
GL_FOG_COORDINATE_ARRAY = 33879 	# GL/glext.h:319
GL_COLOR_SUM = 33880 	# GL/glext.h:320
GL_CURRENT_SECONDARY_COLOR = 33881 	# GL/glext.h:321
GL_SECONDARY_COLOR_ARRAY_SIZE = 33882 	# GL/glext.h:322
GL_SECONDARY_COLOR_ARRAY_TYPE = 33883 	# GL/glext.h:323
GL_SECONDARY_COLOR_ARRAY_STRIDE = 33884 	# GL/glext.h:324
GL_SECONDARY_COLOR_ARRAY_POINTER = 33885 	# GL/glext.h:325
GL_SECONDARY_COLOR_ARRAY = 33886 	# GL/glext.h:326
GL_MAX_TEXTURE_LOD_BIAS = 34045 	# GL/glext.h:327
GL_TEXTURE_FILTER_CONTROL = 34048 	# GL/glext.h:328
GL_TEXTURE_LOD_BIAS = 34049 	# GL/glext.h:329
GL_INCR_WRAP = 34055 	# GL/glext.h:330
GL_DECR_WRAP = 34056 	# GL/glext.h:331
GL_TEXTURE_DEPTH_SIZE = 34890 	# GL/glext.h:332
GL_DEPTH_TEXTURE_MODE = 34891 	# GL/glext.h:333
GL_TEXTURE_COMPARE_MODE = 34892 	# GL/glext.h:334
GL_TEXTURE_COMPARE_FUNC = 34893 	# GL/glext.h:335
GL_COMPARE_R_TO_TEXTURE = 34894 	# GL/glext.h:336
# VERSION_1_5 (GL/glext.h:339)
GL_BUFFER_SIZE = 34660 	# GL/glext.h:340
GL_BUFFER_USAGE = 34661 	# GL/glext.h:341
GL_QUERY_COUNTER_BITS = 34916 	# GL/glext.h:342
GL_CURRENT_QUERY = 34917 	# GL/glext.h:343
GL_QUERY_RESULT = 34918 	# GL/glext.h:344
GL_QUERY_RESULT_AVAILABLE = 34919 	# GL/glext.h:345
GL_ARRAY_BUFFER = 34962 	# GL/glext.h:346
GL_ELEMENT_ARRAY_BUFFER = 34963 	# GL/glext.h:347
GL_ARRAY_BUFFER_BINDING = 34964 	# GL/glext.h:348
GL_ELEMENT_ARRAY_BUFFER_BINDING = 34965 	# GL/glext.h:349
GL_VERTEX_ARRAY_BUFFER_BINDING = 34966 	# GL/glext.h:350
GL_NORMAL_ARRAY_BUFFER_BINDING = 34967 	# GL/glext.h:351
GL_COLOR_ARRAY_BUFFER_BINDING = 34968 	# GL/glext.h:352
GL_INDEX_ARRAY_BUFFER_BINDING = 34969 	# GL/glext.h:353
GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING = 34970 	# GL/glext.h:354
GL_EDGE_FLAG_ARRAY_BUFFER_BINDING = 34971 	# GL/glext.h:355
GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING = 34972 	# GL/glext.h:356
GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING = 34973 	# GL/glext.h:357
GL_WEIGHT_ARRAY_BUFFER_BINDING = 34974 	# GL/glext.h:358
GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975 	# GL/glext.h:359
GL_READ_ONLY = 35000 	# GL/glext.h:360
GL_WRITE_ONLY = 35001 	# GL/glext.h:361
GL_READ_WRITE = 35002 	# GL/glext.h:362
GL_BUFFER_ACCESS = 35003 	# GL/glext.h:363
GL_BUFFER_MAPPED = 35004 	# GL/glext.h:364
GL_BUFFER_MAP_POINTER = 35005 	# GL/glext.h:365
GL_STREAM_DRAW = 35040 	# GL/glext.h:366
GL_STREAM_READ = 35041 	# GL/glext.h:367
GL_STREAM_COPY = 35042 	# GL/glext.h:368
GL_STATIC_DRAW = 35044 	# GL/glext.h:369
GL_STATIC_READ = 35045 	# GL/glext.h:370
GL_STATIC_COPY = 35046 	# GL/glext.h:371
GL_DYNAMIC_DRAW = 35048 	# GL/glext.h:372
GL_DYNAMIC_READ = 35049 	# GL/glext.h:373
GL_DYNAMIC_COPY = 35050 	# GL/glext.h:374
GL_SAMPLES_PASSED = 35092 	# GL/glext.h:375
GL_FOG_COORD_SRC = 33872 	# GL/glext.h:376
GL_FOG_COORD = 33873 	# GL/glext.h:377
GL_CURRENT_FOG_COORD = 33875 	# GL/glext.h:378
GL_FOG_COORD_ARRAY_TYPE = 33876 	# GL/glext.h:379
GL_FOG_COORD_ARRAY_STRIDE = 33877 	# GL/glext.h:380
GL_FOG_COORD_ARRAY_POINTER = 33878 	# GL/glext.h:381
GL_FOG_COORD_ARRAY = 33879 	# GL/glext.h:382
GL_FOG_COORD_ARRAY_BUFFER_BINDING = 34973 	# GL/glext.h:383
GL_SRC0_RGB = 34176 	# GL/glext.h:384
GL_SRC1_RGB = 34177 	# GL/glext.h:385
GL_SRC2_RGB = 34178 	# GL/glext.h:386
GL_SRC0_ALPHA = 34184 	# GL/glext.h:387
GL_SRC1_ALPHA = 34185 	# GL/glext.h:388
GL_SRC2_ALPHA = 34186 	# GL/glext.h:389
# VERSION_2_0 (GL/glext.h:392)
GL_BLEND_EQUATION_RGB = 32777 	# GL/glext.h:393
GL_VERTEX_ATTRIB_ARRAY_ENABLED = 34338 	# GL/glext.h:394
GL_VERTEX_ATTRIB_ARRAY_SIZE = 34339 	# GL/glext.h:395
GL_VERTEX_ATTRIB_ARRAY_STRIDE = 34340 	# GL/glext.h:396
GL_VERTEX_ATTRIB_ARRAY_TYPE = 34341 	# GL/glext.h:397
GL_CURRENT_VERTEX_ATTRIB = 34342 	# GL/glext.h:398
GL_VERTEX_PROGRAM_POINT_SIZE = 34370 	# GL/glext.h:399
GL_VERTEX_PROGRAM_TWO_SIDE = 34371 	# GL/glext.h:400
GL_VERTEX_ATTRIB_ARRAY_POINTER = 34373 	# GL/glext.h:401
GL_STENCIL_BACK_FUNC = 34816 	# GL/glext.h:402
GL_STENCIL_BACK_FAIL = 34817 	# GL/glext.h:403
GL_STENCIL_BACK_PASS_DEPTH_FAIL = 34818 	# GL/glext.h:404
GL_STENCIL_BACK_PASS_DEPTH_PASS = 34819 	# GL/glext.h:405
GL_MAX_DRAW_BUFFERS = 34852 	# GL/glext.h:406
GL_DRAW_BUFFER0 = 34853 	# GL/glext.h:407
GL_DRAW_BUFFER1 = 34854 	# GL/glext.h:408
GL_DRAW_BUFFER2 = 34855 	# GL/glext.h:409
GL_DRAW_BUFFER3 = 34856 	# GL/glext.h:410
GL_DRAW_BUFFER4 = 34857 	# GL/glext.h:411
GL_DRAW_BUFFER5 = 34858 	# GL/glext.h:412
GL_DRAW_BUFFER6 = 34859 	# GL/glext.h:413
GL_DRAW_BUFFER7 = 34860 	# GL/glext.h:414
GL_DRAW_BUFFER8 = 34861 	# GL/glext.h:415
GL_DRAW_BUFFER9 = 34862 	# GL/glext.h:416
GL_DRAW_BUFFER10 = 34863 	# GL/glext.h:417
GL_DRAW_BUFFER11 = 34864 	# GL/glext.h:418
GL_DRAW_BUFFER12 = 34865 	# GL/glext.h:419
GL_DRAW_BUFFER13 = 34866 	# GL/glext.h:420
GL_DRAW_BUFFER14 = 34867 	# GL/glext.h:421
GL_DRAW_BUFFER15 = 34868 	# GL/glext.h:422
GL_BLEND_EQUATION_ALPHA = 34877 	# GL/glext.h:423
GL_POINT_SPRITE = 34913 	# GL/glext.h:424
GL_COORD_REPLACE = 34914 	# GL/glext.h:425
GL_MAX_VERTEX_ATTRIBS = 34921 	# GL/glext.h:426
GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922 	# GL/glext.h:427
GL_MAX_TEXTURE_COORDS = 34929 	# GL/glext.h:428
GL_MAX_TEXTURE_IMAGE_UNITS = 34930 	# GL/glext.h:429
GL_FRAGMENT_SHADER = 35632 	# GL/glext.h:430
GL_VERTEX_SHADER = 35633 	# GL/glext.h:431
GL_MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657 	# GL/glext.h:432
GL_MAX_VERTEX_UNIFORM_COMPONENTS = 35658 	# GL/glext.h:433
GL_MAX_VARYING_FLOATS = 35659 	# GL/glext.h:434
GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660 	# GL/glext.h:435
GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661 	# GL/glext.h:436
GL_SHADER_TYPE = 35663 	# GL/glext.h:437
GL_FLOAT_VEC2 = 35664 	# GL/glext.h:438
GL_FLOAT_VEC3 = 35665 	# GL/glext.h:439
GL_FLOAT_VEC4 = 35666 	# GL/glext.h:440
GL_INT_VEC2 = 35667 	# GL/glext.h:441
GL_INT_VEC3 = 35668 	# GL/glext.h:442
GL_INT_VEC4 = 35669 	# GL/glext.h:443
GL_BOOL = 35670 	# GL/glext.h:444
GL_BOOL_VEC2 = 35671 	# GL/glext.h:445
GL_BOOL_VEC3 = 35672 	# GL/glext.h:446
GL_BOOL_VEC4 = 35673 	# GL/glext.h:447
GL_FLOAT_MAT2 = 35674 	# GL/glext.h:448
GL_FLOAT_MAT3 = 35675 	# GL/glext.h:449
GL_FLOAT_MAT4 = 35676 	# GL/glext.h:450
GL_SAMPLER_1D = 35677 	# GL/glext.h:451
GL_SAMPLER_2D = 35678 	# GL/glext.h:452
GL_SAMPLER_3D = 35679 	# GL/glext.h:453
GL_SAMPLER_CUBE = 35680 	# GL/glext.h:454
GL_SAMPLER_1D_SHADOW = 35681 	# GL/glext.h:455
GL_SAMPLER_2D_SHADOW = 35682 	# GL/glext.h:456
GL_DELETE_STATUS = 35712 	# GL/glext.h:457
GL_COMPILE_STATUS = 35713 	# GL/glext.h:458
GL_LINK_STATUS = 35714 	# GL/glext.h:459
GL_VALIDATE_STATUS = 35715 	# GL/glext.h:460
GL_INFO_LOG_LENGTH = 35716 	# GL/glext.h:461
GL_ATTACHED_SHADERS = 35717 	# GL/glext.h:462
GL_ACTIVE_UNIFORMS = 35718 	# GL/glext.h:463
GL_ACTIVE_UNIFORM_MAX_LENGTH = 35719 	# GL/glext.h:464
GL_SHADER_SOURCE_LENGTH = 35720 	# GL/glext.h:465
GL_ACTIVE_ATTRIBUTES = 35721 	# GL/glext.h:466
GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = 35722 	# GL/glext.h:467
GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723 	# GL/glext.h:468
GL_SHADING_LANGUAGE_VERSION = 35724 	# GL/glext.h:469
GL_CURRENT_PROGRAM = 35725 	# GL/glext.h:470
GL_POINT_SPRITE_COORD_ORIGIN = 36000 	# GL/glext.h:471
GL_LOWER_LEFT = 36001 	# GL/glext.h:472
GL_UPPER_LEFT = 36002 	# GL/glext.h:473
GL_STENCIL_BACK_REF = 36003 	# GL/glext.h:474
GL_STENCIL_BACK_VALUE_MASK = 36004 	# GL/glext.h:475
GL_STENCIL_BACK_WRITEMASK = 36005 	# GL/glext.h:476
# VERSION_2_1 (GL/glext.h:479)
GL_PIXEL_PACK_BUFFER = 35051 	# GL/glext.h:480
GL_PIXEL_UNPACK_BUFFER = 35052 	# GL/glext.h:481
GL_PIXEL_PACK_BUFFER_BINDING = 35053 	# GL/glext.h:482
GL_PIXEL_UNPACK_BUFFER_BINDING = 35055 	# GL/glext.h:483
GL_SRGB = 35904 	# GL/glext.h:484
GL_SRGB8 = 35905 	# GL/glext.h:485
GL_SRGB_ALPHA = 35906 	# GL/glext.h:486
GL_SRGB8_ALPHA8 = 35907 	# GL/glext.h:487
GL_SLUMINANCE_ALPHA = 35908 	# GL/glext.h:488
GL_SLUMINANCE8_ALPHA8 = 35909 	# GL/glext.h:489
GL_SLUMINANCE = 35910 	# GL/glext.h:490
GL_SLUMINANCE8 = 35911 	# GL/glext.h:491
GL_COMPRESSED_SRGB = 35912 	# GL/glext.h:492
GL_COMPRESSED_SRGB_ALPHA = 35913 	# GL/glext.h:493
GL_COMPRESSED_SLUMINANCE = 35914 	# GL/glext.h:494
GL_COMPRESSED_SLUMINANCE_ALPHA = 35915 	# GL/glext.h:495
GL_FLOAT_MAT2x3 = 35685 	# GL/glext.h:496
GL_FLOAT_MAT2x4 = 35686 	# GL/glext.h:497
GL_FLOAT_MAT3x2 = 35687 	# GL/glext.h:498
GL_FLOAT_MAT3x4 = 35688 	# GL/glext.h:499
GL_FLOAT_MAT4x2 = 35689 	# GL/glext.h:500
GL_FLOAT_MAT4x3 = 35690 	# GL/glext.h:501
GL_CURRENT_RASTER_SECONDARY_COLOR = 33887 	# GL/glext.h:502
# ARB_multitexture (GL/glext.h:505)
GL_TEXTURE0_ARB = 33984 	# GL/glext.h:506
GL_TEXTURE1_ARB = 33985 	# GL/glext.h:507
GL_TEXTURE2_ARB = 33986 	# GL/glext.h:508
GL_TEXTURE3_ARB = 33987 	# GL/glext.h:509
GL_TEXTURE4_ARB = 33988 	# GL/glext.h:510
GL_TEXTURE5_ARB = 33989 	# GL/glext.h:511
GL_TEXTURE6_ARB = 33990 	# GL/glext.h:512
GL_TEXTURE7_ARB = 33991 	# GL/glext.h:513
GL_TEXTURE8_ARB = 33992 	# GL/glext.h:514
GL_TEXTURE9_ARB = 33993 	# GL/glext.h:515
GL_TEXTURE10_ARB = 33994 	# GL/glext.h:516
GL_TEXTURE11_ARB = 33995 	# GL/glext.h:517
GL_TEXTURE12_ARB = 33996 	# GL/glext.h:518
GL_TEXTURE13_ARB = 33997 	# GL/glext.h:519
GL_TEXTURE14_ARB = 33998 	# GL/glext.h:520
GL_TEXTURE15_ARB = 33999 	# GL/glext.h:521
GL_TEXTURE16_ARB = 34000 	# GL/glext.h:522
GL_TEXTURE17_ARB = 34001 	# GL/glext.h:523
GL_TEXTURE18_ARB = 34002 	# GL/glext.h:524
GL_TEXTURE19_ARB = 34003 	# GL/glext.h:525
GL_TEXTURE20_ARB = 34004 	# GL/glext.h:526
GL_TEXTURE21_ARB = 34005 	# GL/glext.h:527
GL_TEXTURE22_ARB = 34006 	# GL/glext.h:528
GL_TEXTURE23_ARB = 34007 	# GL/glext.h:529
GL_TEXTURE24_ARB = 34008 	# GL/glext.h:530
GL_TEXTURE25_ARB = 34009 	# GL/glext.h:531
GL_TEXTURE26_ARB = 34010 	# GL/glext.h:532
GL_TEXTURE27_ARB = 34011 	# GL/glext.h:533
GL_TEXTURE28_ARB = 34012 	# GL/glext.h:534
GL_TEXTURE29_ARB = 34013 	# GL/glext.h:535
GL_TEXTURE30_ARB = 34014 	# GL/glext.h:536
GL_TEXTURE31_ARB = 34015 	# GL/glext.h:537
GL_ACTIVE_TEXTURE_ARB = 34016 	# GL/glext.h:538
GL_CLIENT_ACTIVE_TEXTURE_ARB = 34017 	# GL/glext.h:539
GL_MAX_TEXTURE_UNITS_ARB = 34018 	# GL/glext.h:540
# ARB_transpose_matrix (GL/glext.h:543)
GL_TRANSPOSE_MODELVIEW_MATRIX_ARB = 34019 	# GL/glext.h:544
GL_TRANSPOSE_PROJECTION_MATRIX_ARB = 34020 	# GL/glext.h:545
GL_TRANSPOSE_TEXTURE_MATRIX_ARB = 34021 	# GL/glext.h:546
GL_TRANSPOSE_COLOR_MATRIX_ARB = 34022 	# GL/glext.h:547
# ARB_multisample (GL/glext.h:550)
GL_MULTISAMPLE_ARB = 32925 	# GL/glext.h:551
GL_SAMPLE_ALPHA_TO_COVERAGE_ARB = 32926 	# GL/glext.h:552
GL_SAMPLE_ALPHA_TO_ONE_ARB = 32927 	# GL/glext.h:553
GL_SAMPLE_COVERAGE_ARB = 32928 	# GL/glext.h:554
GL_SAMPLE_BUFFERS_ARB = 32936 	# GL/glext.h:555
GL_SAMPLES_ARB = 32937 	# GL/glext.h:556
GL_SAMPLE_COVERAGE_VALUE_ARB = 32938 	# GL/glext.h:557
GL_SAMPLE_COVERAGE_INVERT_ARB = 32939 	# GL/glext.h:558
GL_MULTISAMPLE_BIT_ARB = 536870912 	# GL/glext.h:559
# ARB_texture_env_add (GL/glext.h:562)
# ARB_texture_cube_map (GL/glext.h:565)
GL_NORMAL_MAP_ARB = 34065 	# GL/glext.h:566
GL_REFLECTION_MAP_ARB = 34066 	# GL/glext.h:567
GL_TEXTURE_CUBE_MAP_ARB = 34067 	# GL/glext.h:568
GL_TEXTURE_BINDING_CUBE_MAP_ARB = 34068 	# GL/glext.h:569
GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB = 34069 	# GL/glext.h:570
GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB = 34070 	# GL/glext.h:571
GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB = 34071 	# GL/glext.h:572
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB = 34072 	# GL/glext.h:573
GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB = 34073 	# GL/glext.h:574
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB = 34074 	# GL/glext.h:575
GL_PROXY_TEXTURE_CUBE_MAP_ARB = 34075 	# GL/glext.h:576
GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB = 34076 	# GL/glext.h:577
# ARB_texture_compression (GL/glext.h:580)
GL_COMPRESSED_ALPHA_ARB = 34025 	# GL/glext.h:581
GL_COMPRESSED_LUMINANCE_ARB = 34026 	# GL/glext.h:582
GL_COMPRESSED_LUMINANCE_ALPHA_ARB = 34027 	# GL/glext.h:583
GL_COMPRESSED_INTENSITY_ARB = 34028 	# GL/glext.h:584
GL_COMPRESSED_RGB_ARB = 34029 	# GL/glext.h:585
GL_COMPRESSED_RGBA_ARB = 34030 	# GL/glext.h:586
GL_TEXTURE_COMPRESSION_HINT_ARB = 34031 	# GL/glext.h:587
GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB = 34464 	# GL/glext.h:588
GL_TEXTURE_COMPRESSED_ARB = 34465 	# GL/glext.h:589
GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB = 34466 	# GL/glext.h:590
GL_COMPRESSED_TEXTURE_FORMATS_ARB = 34467 	# GL/glext.h:591
# ARB_texture_border_clamp (GL/glext.h:594)
GL_CLAMP_TO_BORDER_ARB = 33069 	# GL/glext.h:595
# ARB_point_parameters (GL/glext.h:598)
GL_POINT_SIZE_MIN_ARB = 33062 	# GL/glext.h:599
GL_POINT_SIZE_MAX_ARB = 33063 	# GL/glext.h:600
GL_POINT_FADE_THRESHOLD_SIZE_ARB = 33064 	# GL/glext.h:601
GL_POINT_DISTANCE_ATTENUATION_ARB = 33065 	# GL/glext.h:602
# ARB_vertex_blend (GL/glext.h:605)
GL_MAX_VERTEX_UNITS_ARB = 34468 	# GL/glext.h:606
GL_ACTIVE_VERTEX_UNITS_ARB = 34469 	# GL/glext.h:607
GL_WEIGHT_SUM_UNITY_ARB = 34470 	# GL/glext.h:608
GL_VERTEX_BLEND_ARB = 34471 	# GL/glext.h:609
GL_CURRENT_WEIGHT_ARB = 34472 	# GL/glext.h:610
GL_WEIGHT_ARRAY_TYPE_ARB = 34473 	# GL/glext.h:611
GL_WEIGHT_ARRAY_STRIDE_ARB = 34474 	# GL/glext.h:612
GL_WEIGHT_ARRAY_SIZE_ARB = 34475 	# GL/glext.h:613
GL_WEIGHT_ARRAY_POINTER_ARB = 34476 	# GL/glext.h:614
GL_WEIGHT_ARRAY_ARB = 34477 	# GL/glext.h:615
GL_MODELVIEW0_ARB = 5888 	# GL/glext.h:616
GL_MODELVIEW1_ARB = 34058 	# GL/glext.h:617
GL_MODELVIEW2_ARB = 34594 	# GL/glext.h:618
GL_MODELVIEW3_ARB = 34595 	# GL/glext.h:619
GL_MODELVIEW4_ARB = 34596 	# GL/glext.h:620
GL_MODELVIEW5_ARB = 34597 	# GL/glext.h:621
GL_MODELVIEW6_ARB = 34598 	# GL/glext.h:622
GL_MODELVIEW7_ARB = 34599 	# GL/glext.h:623
GL_MODELVIEW8_ARB = 34600 	# GL/glext.h:624
GL_MODELVIEW9_ARB = 34601 	# GL/glext.h:625
GL_MODELVIEW10_ARB = 34602 	# GL/glext.h:626
GL_MODELVIEW11_ARB = 34603 	# GL/glext.h:627
GL_MODELVIEW12_ARB = 34604 	# GL/glext.h:628
GL_MODELVIEW13_ARB = 34605 	# GL/glext.h:629
GL_MODELVIEW14_ARB = 34606 	# GL/glext.h:630
GL_MODELVIEW15_ARB = 34607 	# GL/glext.h:631
GL_MODELVIEW16_ARB = 34608 	# GL/glext.h:632
GL_MODELVIEW17_ARB = 34609 	# GL/glext.h:633
GL_MODELVIEW18_ARB = 34610 	# GL/glext.h:634
GL_MODELVIEW19_ARB = 34611 	# GL/glext.h:635
GL_MODELVIEW20_ARB = 34612 	# GL/glext.h:636
GL_MODELVIEW21_ARB = 34613 	# GL/glext.h:637
GL_MODELVIEW22_ARB = 34614 	# GL/glext.h:638
GL_MODELVIEW23_ARB = 34615 	# GL/glext.h:639
GL_MODELVIEW24_ARB = 34616 	# GL/glext.h:640
GL_MODELVIEW25_ARB = 34617 	# GL/glext.h:641
GL_MODELVIEW26_ARB = 34618 	# GL/glext.h:642
GL_MODELVIEW27_ARB = 34619 	# GL/glext.h:643
GL_MODELVIEW28_ARB = 34620 	# GL/glext.h:644
GL_MODELVIEW29_ARB = 34621 	# GL/glext.h:645
GL_MODELVIEW30_ARB = 34622 	# GL/glext.h:646
GL_MODELVIEW31_ARB = 34623 	# GL/glext.h:647
# ARB_matrix_palette (GL/glext.h:650)
GL_MATRIX_PALETTE_ARB = 34880 	# GL/glext.h:651
GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB = 34881 	# GL/glext.h:652
GL_MAX_PALETTE_MATRICES_ARB = 34882 	# GL/glext.h:653
GL_CURRENT_PALETTE_MATRIX_ARB = 34883 	# GL/glext.h:654
GL_MATRIX_INDEX_ARRAY_ARB = 34884 	# GL/glext.h:655
GL_CURRENT_MATRIX_INDEX_ARB = 34885 	# GL/glext.h:656
GL_MATRIX_INDEX_ARRAY_SIZE_ARB = 34886 	# GL/glext.h:657
GL_MATRIX_INDEX_ARRAY_TYPE_ARB = 34887 	# GL/glext.h:658
GL_MATRIX_INDEX_ARRAY_STRIDE_ARB = 34888 	# GL/glext.h:659
GL_MATRIX_INDEX_ARRAY_POINTER_ARB = 34889 	# GL/glext.h:660
# ARB_texture_env_combine (GL/glext.h:663)
GL_COMBINE_ARB = 34160 	# GL/glext.h:664
GL_COMBINE_RGB_ARB = 34161 	# GL/glext.h:665
GL_COMBINE_ALPHA_ARB = 34162 	# GL/glext.h:666
GL_SOURCE0_RGB_ARB = 34176 	# GL/glext.h:667
GL_SOURCE1_RGB_ARB = 34177 	# GL/glext.h:668
GL_SOURCE2_RGB_ARB = 34178 	# GL/glext.h:669
GL_SOURCE0_ALPHA_ARB = 34184 	# GL/glext.h:670
GL_SOURCE1_ALPHA_ARB = 34185 	# GL/glext.h:671
GL_SOURCE2_ALPHA_ARB = 34186 	# GL/glext.h:672
GL_OPERAND0_RGB_ARB = 34192 	# GL/glext.h:673
GL_OPERAND1_RGB_ARB = 34193 	# GL/glext.h:674
GL_OPERAND2_RGB_ARB = 34194 	# GL/glext.h:675
GL_OPERAND0_ALPHA_ARB = 34200 	# GL/glext.h:676
GL_OPERAND1_ALPHA_ARB = 34201 	# GL/glext.h:677
GL_OPERAND2_ALPHA_ARB = 34202 	# GL/glext.h:678
GL_RGB_SCALE_ARB = 34163 	# GL/glext.h:679
GL_ADD_SIGNED_ARB = 34164 	# GL/glext.h:680
GL_INTERPOLATE_ARB = 34165 	# GL/glext.h:681
GL_SUBTRACT_ARB = 34023 	# GL/glext.h:682
GL_CONSTANT_ARB = 34166 	# GL/glext.h:683
GL_PRIMARY_COLOR_ARB = 34167 	# GL/glext.h:684
GL_PREVIOUS_ARB = 34168 	# GL/glext.h:685
# ARB_texture_env_crossbar (GL/glext.h:688)
# ARB_texture_env_dot3 (GL/glext.h:691)
GL_DOT3_RGB_ARB = 34478 	# GL/glext.h:692
GL_DOT3_RGBA_ARB = 34479 	# GL/glext.h:693
# ARB_texture_mirrored_repeat (GL/glext.h:696)
GL_MIRRORED_REPEAT_ARB = 33648 	# GL/glext.h:697
# ARB_depth_texture (GL/glext.h:700)
GL_DEPTH_COMPONENT16_ARB = 33189 	# GL/glext.h:701
GL_DEPTH_COMPONENT24_ARB = 33190 	# GL/glext.h:702
GL_DEPTH_COMPONENT32_ARB = 33191 	# GL/glext.h:703
GL_TEXTURE_DEPTH_SIZE_ARB = 34890 	# GL/glext.h:704
GL_DEPTH_TEXTURE_MODE_ARB = 34891 	# GL/glext.h:705
# ARB_shadow (GL/glext.h:708)
GL_TEXTURE_COMPARE_MODE_ARB = 34892 	# GL/glext.h:709
GL_TEXTURE_COMPARE_FUNC_ARB = 34893 	# GL/glext.h:710
GL_COMPARE_R_TO_TEXTURE_ARB = 34894 	# GL/glext.h:711
# ARB_shadow_ambient (GL/glext.h:714)
GL_TEXTURE_COMPARE_FAIL_VALUE_ARB = 32959 	# GL/glext.h:715
# ARB_window_pos (GL/glext.h:718)
# ARB_vertex_program (GL/glext.h:721)
GL_COLOR_SUM_ARB = 33880 	# GL/glext.h:722
GL_VERTEX_PROGRAM_ARB = 34336 	# GL/glext.h:723
GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB = 34338 	# GL/glext.h:724
GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB = 34339 	# GL/glext.h:725
GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB = 34340 	# GL/glext.h:726
GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB = 34341 	# GL/glext.h:727
GL_CURRENT_VERTEX_ATTRIB_ARB = 34342 	# GL/glext.h:728
GL_PROGRAM_LENGTH_ARB = 34343 	# GL/glext.h:729
GL_PROGRAM_STRING_ARB = 34344 	# GL/glext.h:730
GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB = 34350 	# GL/glext.h:731
GL_MAX_PROGRAM_MATRICES_ARB = 34351 	# GL/glext.h:732
GL_CURRENT_MATRIX_STACK_DEPTH_ARB = 34368 	# GL/glext.h:733
GL_CURRENT_MATRIX_ARB = 34369 	# GL/glext.h:734
GL_VERTEX_PROGRAM_POINT_SIZE_ARB = 34370 	# GL/glext.h:735
GL_VERTEX_PROGRAM_TWO_SIDE_ARB = 34371 	# GL/glext.h:736
GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB = 34373 	# GL/glext.h:737
GL_PROGRAM_ERROR_POSITION_ARB = 34379 	# GL/glext.h:738
GL_PROGRAM_BINDING_ARB = 34423 	# GL/glext.h:739
GL_MAX_VERTEX_ATTRIBS_ARB = 34921 	# GL/glext.h:740
GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB = 34922 	# GL/glext.h:741
GL_PROGRAM_ERROR_STRING_ARB = 34932 	# GL/glext.h:742
GL_PROGRAM_FORMAT_ASCII_ARB = 34933 	# GL/glext.h:743
GL_PROGRAM_FORMAT_ARB = 34934 	# GL/glext.h:744
GL_PROGRAM_INSTRUCTIONS_ARB = 34976 	# GL/glext.h:745
GL_MAX_PROGRAM_INSTRUCTIONS_ARB = 34977 	# GL/glext.h:746
GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB = 34978 	# GL/glext.h:747
GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB = 34979 	# GL/glext.h:748
GL_PROGRAM_TEMPORARIES_ARB = 34980 	# GL/glext.h:749
GL_MAX_PROGRAM_TEMPORARIES_ARB = 34981 	# GL/glext.h:750
GL_PROGRAM_NATIVE_TEMPORARIES_ARB = 34982 	# GL/glext.h:751
GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB = 34983 	# GL/glext.h:752
GL_PROGRAM_PARAMETERS_ARB = 34984 	# GL/glext.h:753
GL_MAX_PROGRAM_PARAMETERS_ARB = 34985 	# GL/glext.h:754
GL_PROGRAM_NATIVE_PARAMETERS_ARB = 34986 	# GL/glext.h:755
GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB = 34987 	# GL/glext.h:756
GL_PROGRAM_ATTRIBS_ARB = 34988 	# GL/glext.h:757
GL_MAX_PROGRAM_ATTRIBS_ARB = 34989 	# GL/glext.h:758
GL_PROGRAM_NATIVE_ATTRIBS_ARB = 34990 	# GL/glext.h:759
GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB = 34991 	# GL/glext.h:760
GL_PROGRAM_ADDRESS_REGISTERS_ARB = 34992 	# GL/glext.h:761
GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB = 34993 	# GL/glext.h:762
GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = 34994 	# GL/glext.h:763
GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = 34995 	# GL/glext.h:764
GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB = 34996 	# GL/glext.h:765
GL_MAX_PROGRAM_ENV_PARAMETERS_ARB = 34997 	# GL/glext.h:766
GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB = 34998 	# GL/glext.h:767
GL_TRANSPOSE_CURRENT_MATRIX_ARB = 34999 	# GL/glext.h:768
GL_MATRIX0_ARB = 35008 	# GL/glext.h:769
GL_MATRIX1_ARB = 35009 	# GL/glext.h:770
GL_MATRIX2_ARB = 35010 	# GL/glext.h:771
GL_MATRIX3_ARB = 35011 	# GL/glext.h:772
GL_MATRIX4_ARB = 35012 	# GL/glext.h:773
GL_MATRIX5_ARB = 35013 	# GL/glext.h:774
GL_MATRIX6_ARB = 35014 	# GL/glext.h:775
GL_MATRIX7_ARB = 35015 	# GL/glext.h:776
GL_MATRIX8_ARB = 35016 	# GL/glext.h:777
GL_MATRIX9_ARB = 35017 	# GL/glext.h:778
GL_MATRIX10_ARB = 35018 	# GL/glext.h:779
GL_MATRIX11_ARB = 35019 	# GL/glext.h:780
GL_MATRIX12_ARB = 35020 	# GL/glext.h:781
GL_MATRIX13_ARB = 35021 	# GL/glext.h:782
GL_MATRIX14_ARB = 35022 	# GL/glext.h:783
GL_MATRIX15_ARB = 35023 	# GL/glext.h:784
GL_MATRIX16_ARB = 35024 	# GL/glext.h:785
GL_MATRIX17_ARB = 35025 	# GL/glext.h:786
GL_MATRIX18_ARB = 35026 	# GL/glext.h:787
GL_MATRIX19_ARB = 35027 	# GL/glext.h:788
GL_MATRIX20_ARB = 35028 	# GL/glext.h:789
GL_MATRIX21_ARB = 35029 	# GL/glext.h:790
GL_MATRIX22_ARB = 35030 	# GL/glext.h:791
GL_MATRIX23_ARB = 35031 	# GL/glext.h:792
GL_MATRIX24_ARB = 35032 	# GL/glext.h:793
GL_MATRIX25_ARB = 35033 	# GL/glext.h:794
GL_MATRIX26_ARB = 35034 	# GL/glext.h:795
GL_MATRIX27_ARB = 35035 	# GL/glext.h:796
GL_MATRIX28_ARB = 35036 	# GL/glext.h:797
GL_MATRIX29_ARB = 35037 	# GL/glext.h:798
GL_MATRIX30_ARB = 35038 	# GL/glext.h:799
GL_MATRIX31_ARB = 35039 	# GL/glext.h:800
# ARB_fragment_program (GL/glext.h:803)
GL_FRAGMENT_PROGRAM_ARB = 34820 	# GL/glext.h:804
GL_PROGRAM_ALU_INSTRUCTIONS_ARB = 34821 	# GL/glext.h:805
GL_PROGRAM_TEX_INSTRUCTIONS_ARB = 34822 	# GL/glext.h:806
GL_PROGRAM_TEX_INDIRECTIONS_ARB = 34823 	# GL/glext.h:807
GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = 34824 	# GL/glext.h:808
GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = 34825 	# GL/glext.h:809
GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = 34826 	# GL/glext.h:810
GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB = 34827 	# GL/glext.h:811
GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB = 34828 	# GL/glext.h:812
GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB = 34829 	# GL/glext.h:813
GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = 34830 	# GL/glext.h:814
GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = 34831 	# GL/glext.h:815
GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = 34832 	# GL/glext.h:816
GL_MAX_TEXTURE_COORDS_ARB = 34929 	# GL/glext.h:817
GL_MAX_TEXTURE_IMAGE_UNITS_ARB = 34930 	# GL/glext.h:818
# ARB_vertex_buffer_object (GL/glext.h:821)
GL_BUFFER_SIZE_ARB = 34660 	# GL/glext.h:822
GL_BUFFER_USAGE_ARB = 34661 	# GL/glext.h:823
GL_ARRAY_BUFFER_ARB = 34962 	# GL/glext.h:824
GL_ELEMENT_ARRAY_BUFFER_ARB = 34963 	# GL/glext.h:825
GL_ARRAY_BUFFER_BINDING_ARB = 34964 	# GL/glext.h:826
GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB = 34965 	# GL/glext.h:827
GL_VERTEX_ARRAY_BUFFER_BINDING_ARB = 34966 	# GL/glext.h:828
GL_NORMAL_ARRAY_BUFFER_BINDING_ARB = 34967 	# GL/glext.h:829
GL_COLOR_ARRAY_BUFFER_BINDING_ARB = 34968 	# GL/glext.h:830
GL_INDEX_ARRAY_BUFFER_BINDING_ARB = 34969 	# GL/glext.h:831
GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB = 34970 	# GL/glext.h:832
GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB = 34971 	# GL/glext.h:833
GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB = 34972 	# GL/glext.h:834
GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB = 34973 	# GL/glext.h:835
GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB = 34974 	# GL/glext.h:836
GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB = 34975 	# GL/glext.h:837
GL_READ_ONLY_ARB = 35000 	# GL/glext.h:838
GL_WRITE_ONLY_ARB = 35001 	# GL/glext.h:839
GL_READ_WRITE_ARB = 35002 	# GL/glext.h:840
GL_BUFFER_ACCESS_ARB = 35003 	# GL/glext.h:841
GL_BUFFER_MAPPED_ARB = 35004 	# GL/glext.h:842
GL_BUFFER_MAP_POINTER_ARB = 35005 	# GL/glext.h:843
GL_STREAM_DRAW_ARB = 35040 	# GL/glext.h:844
GL_STREAM_READ_ARB = 35041 	# GL/glext.h:845
GL_STREAM_COPY_ARB = 35042 	# GL/glext.h:846
GL_STATIC_DRAW_ARB = 35044 	# GL/glext.h:847
GL_STATIC_READ_ARB = 35045 	# GL/glext.h:848
GL_STATIC_COPY_ARB = 35046 	# GL/glext.h:849
GL_DYNAMIC_DRAW_ARB = 35048 	# GL/glext.h:850
GL_DYNAMIC_READ_ARB = 35049 	# GL/glext.h:851
GL_DYNAMIC_COPY_ARB = 35050 	# GL/glext.h:852
# ARB_occlusion_query (GL/glext.h:855)
GL_QUERY_COUNTER_BITS_ARB = 34916 	# GL/glext.h:856
GL_CURRENT_QUERY_ARB = 34917 	# GL/glext.h:857
GL_QUERY_RESULT_ARB = 34918 	# GL/glext.h:858
GL_QUERY_RESULT_AVAILABLE_ARB = 34919 	# GL/glext.h:859
GL_SAMPLES_PASSED_ARB = 35092 	# GL/glext.h:860
# ARB_shader_objects (GL/glext.h:863)
GL_PROGRAM_OBJECT_ARB = 35648 	# GL/glext.h:864
GL_SHADER_OBJECT_ARB = 35656 	# GL/glext.h:865
GL_OBJECT_TYPE_ARB = 35662 	# GL/glext.h:866
GL_OBJECT_SUBTYPE_ARB = 35663 	# GL/glext.h:867
GL_FLOAT_VEC2_ARB = 35664 	# GL/glext.h:868
GL_FLOAT_VEC3_ARB = 35665 	# GL/glext.h:869
GL_FLOAT_VEC4_ARB = 35666 	# GL/glext.h:870
GL_INT_VEC2_ARB = 35667 	# GL/glext.h:871
GL_INT_VEC3_ARB = 35668 	# GL/glext.h:872
GL_INT_VEC4_ARB = 35669 	# GL/glext.h:873
GL_BOOL_ARB = 35670 	# GL/glext.h:874
GL_BOOL_VEC2_ARB = 35671 	# GL/glext.h:875
GL_BOOL_VEC3_ARB = 35672 	# GL/glext.h:876
GL_BOOL_VEC4_ARB = 35673 	# GL/glext.h:877
GL_FLOAT_MAT2_ARB = 35674 	# GL/glext.h:878
GL_FLOAT_MAT3_ARB = 35675 	# GL/glext.h:879
GL_FLOAT_MAT4_ARB = 35676 	# GL/glext.h:880
GL_SAMPLER_1D_ARB = 35677 	# GL/glext.h:881
GL_SAMPLER_2D_ARB = 35678 	# GL/glext.h:882
GL_SAMPLER_3D_ARB = 35679 	# GL/glext.h:883
GL_SAMPLER_CUBE_ARB = 35680 	# GL/glext.h:884
GL_SAMPLER_1D_SHADOW_ARB = 35681 	# GL/glext.h:885
GL_SAMPLER_2D_SHADOW_ARB = 35682 	# GL/glext.h:886
GL_SAMPLER_2D_RECT_ARB = 35683 	# GL/glext.h:887
GL_SAMPLER_2D_RECT_SHADOW_ARB = 35684 	# GL/glext.h:888
GL_OBJECT_DELETE_STATUS_ARB = 35712 	# GL/glext.h:889
GL_OBJECT_COMPILE_STATUS_ARB = 35713 	# GL/glext.h:890
GL_OBJECT_LINK_STATUS_ARB = 35714 	# GL/glext.h:891
GL_OBJECT_VALIDATE_STATUS_ARB = 35715 	# GL/glext.h:892
GL_OBJECT_INFO_LOG_LENGTH_ARB = 35716 	# GL/glext.h:893
GL_OBJECT_ATTACHED_OBJECTS_ARB = 35717 	# GL/glext.h:894
GL_OBJECT_ACTIVE_UNIFORMS_ARB = 35718 	# GL/glext.h:895
GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB = 35719 	# GL/glext.h:896
GL_OBJECT_SHADER_SOURCE_LENGTH_ARB = 35720 	# GL/glext.h:897
# ARB_vertex_shader (GL/glext.h:900)
GL_VERTEX_SHADER_ARB = 35633 	# GL/glext.h:901
GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB = 35658 	# GL/glext.h:902
GL_MAX_VARYING_FLOATS_ARB = 35659 	# GL/glext.h:903
GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB = 35660 	# GL/glext.h:904
GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB = 35661 	# GL/glext.h:905
GL_OBJECT_ACTIVE_ATTRIBUTES_ARB = 35721 	# GL/glext.h:906
GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB = 35722 	# GL/glext.h:907
# ARB_fragment_shader (GL/glext.h:910)
GL_FRAGMENT_SHADER_ARB = 35632 	# GL/glext.h:911
GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB = 35657 	# GL/glext.h:912
GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB = 35723 	# GL/glext.h:913
# ARB_shading_language_100 (GL/glext.h:916)
GL_SHADING_LANGUAGE_VERSION_ARB = 35724 	# GL/glext.h:917
# ARB_texture_non_power_of_two (GL/glext.h:920)
# ARB_point_sprite (GL/glext.h:923)
GL_POINT_SPRITE_ARB = 34913 	# GL/glext.h:924
GL_COORD_REPLACE_ARB = 34914 	# GL/glext.h:925
# ARB_fragment_program_shadow (GL/glext.h:928)
# ARB_draw_buffers (GL/glext.h:931)
GL_MAX_DRAW_BUFFERS_ARB = 34852 	# GL/glext.h:932
GL_DRAW_BUFFER0_ARB = 34853 	# GL/glext.h:933
GL_DRAW_BUFFER1_ARB = 34854 	# GL/glext.h:934
GL_DRAW_BUFFER2_ARB = 34855 	# GL/glext.h:935
GL_DRAW_BUFFER3_ARB = 34856 	# GL/glext.h:936
GL_DRAW_BUFFER4_ARB = 34857 	# GL/glext.h:937
GL_DRAW_BUFFER5_ARB = 34858 	# GL/glext.h:938
GL_DRAW_BUFFER6_ARB = 34859 	# GL/glext.h:939
GL_DRAW_BUFFER7_ARB = 34860 	# GL/glext.h:940
GL_DRAW_BUFFER8_ARB = 34861 	# GL/glext.h:941
GL_DRAW_BUFFER9_ARB = 34862 	# GL/glext.h:942
GL_DRAW_BUFFER10_ARB = 34863 	# GL/glext.h:943
GL_DRAW_BUFFER11_ARB = 34864 	# GL/glext.h:944
GL_DRAW_BUFFER12_ARB = 34865 	# GL/glext.h:945
GL_DRAW_BUFFER13_ARB = 34866 	# GL/glext.h:946
GL_DRAW_BUFFER14_ARB = 34867 	# GL/glext.h:947
GL_DRAW_BUFFER15_ARB = 34868 	# GL/glext.h:948
# ARB_texture_rectangle (GL/glext.h:951)
GL_TEXTURE_RECTANGLE_ARB = 34037 	# GL/glext.h:952
GL_TEXTURE_BINDING_RECTANGLE_ARB = 34038 	# GL/glext.h:953
GL_PROXY_TEXTURE_RECTANGLE_ARB = 34039 	# GL/glext.h:954
GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB = 34040 	# GL/glext.h:955
# ARB_color_buffer_float (GL/glext.h:958)
GL_RGBA_FLOAT_MODE_ARB = 34848 	# GL/glext.h:959
GL_CLAMP_VERTEX_COLOR_ARB = 35098 	# GL/glext.h:960
GL_CLAMP_FRAGMENT_COLOR_ARB = 35099 	# GL/glext.h:961
GL_CLAMP_READ_COLOR_ARB = 35100 	# GL/glext.h:962
GL_FIXED_ONLY_ARB = 35101 	# GL/glext.h:963
# ARB_half_float_pixel (GL/glext.h:966)
GL_HALF_FLOAT_ARB = 5131 	# GL/glext.h:967
# ARB_texture_float (GL/glext.h:970)
GL_TEXTURE_RED_TYPE_ARB = 35856 	# GL/glext.h:971
GL_TEXTURE_GREEN_TYPE_ARB = 35857 	# GL/glext.h:972
GL_TEXTURE_BLUE_TYPE_ARB = 35858 	# GL/glext.h:973
GL_TEXTURE_ALPHA_TYPE_ARB = 35859 	# GL/glext.h:974
GL_TEXTURE_LUMINANCE_TYPE_ARB = 35860 	# GL/glext.h:975
GL_TEXTURE_INTENSITY_TYPE_ARB = 35861 	# GL/glext.h:976
GL_TEXTURE_DEPTH_TYPE_ARB = 35862 	# GL/glext.h:977
GL_UNSIGNED_NORMALIZED_ARB = 35863 	# GL/glext.h:978
GL_RGBA32F_ARB = 34836 	# GL/glext.h:979
GL_RGB32F_ARB = 34837 	# GL/glext.h:980
GL_ALPHA32F_ARB = 34838 	# GL/glext.h:981
GL_INTENSITY32F_ARB = 34839 	# GL/glext.h:982
GL_LUMINANCE32F_ARB = 34840 	# GL/glext.h:983
GL_LUMINANCE_ALPHA32F_ARB = 34841 	# GL/glext.h:984
GL_RGBA16F_ARB = 34842 	# GL/glext.h:985
GL_RGB16F_ARB = 34843 	# GL/glext.h:986
GL_ALPHA16F_ARB = 34844 	# GL/glext.h:987
GL_INTENSITY16F_ARB = 34845 	# GL/glext.h:988
GL_LUMINANCE16F_ARB = 34846 	# GL/glext.h:989
GL_LUMINANCE_ALPHA16F_ARB = 34847 	# GL/glext.h:990
# ARB_pixel_buffer_object (GL/glext.h:993)
GL_PIXEL_PACK_BUFFER_ARB = 35051 	# GL/glext.h:994
GL_PIXEL_UNPACK_BUFFER_ARB = 35052 	# GL/glext.h:995
GL_PIXEL_PACK_BUFFER_BINDING_ARB = 35053 	# GL/glext.h:996
GL_PIXEL_UNPACK_BUFFER_BINDING_ARB = 35055 	# GL/glext.h:997
# EXT_abgr (GL/glext.h:1000)
GL_ABGR_EXT = 32768 	# GL/glext.h:1001
# EXT_blend_color (GL/glext.h:1004)
GL_CONSTANT_COLOR_EXT = 32769 	# GL/glext.h:1005
GL_ONE_MINUS_CONSTANT_COLOR_EXT = 32770 	# GL/glext.h:1006
GL_CONSTANT_ALPHA_EXT = 32771 	# GL/glext.h:1007
GL_ONE_MINUS_CONSTANT_ALPHA_EXT = 32772 	# GL/glext.h:1008
GL_BLEND_COLOR_EXT = 32773 	# GL/glext.h:1009
# EXT_polygon_offset (GL/glext.h:1012)
GL_POLYGON_OFFSET_EXT = 32823 	# GL/glext.h:1013
GL_POLYGON_OFFSET_FACTOR_EXT = 32824 	# GL/glext.h:1014
GL_POLYGON_OFFSET_BIAS_EXT = 32825 	# GL/glext.h:1015
# EXT_texture (GL/glext.h:1018)
GL_ALPHA4_EXT = 32827 	# GL/glext.h:1019
GL_ALPHA8_EXT = 32828 	# GL/glext.h:1020
GL_ALPHA12_EXT = 32829 	# GL/glext.h:1021
GL_ALPHA16_EXT = 32830 	# GL/glext.h:1022
GL_LUMINANCE4_EXT = 32831 	# GL/glext.h:1023
GL_LUMINANCE8_EXT = 32832 	# GL/glext.h:1024
GL_LUMINANCE12_EXT = 32833 	# GL/glext.h:1025
GL_LUMINANCE16_EXT = 32834 	# GL/glext.h:1026
GL_LUMINANCE4_ALPHA4_EXT = 32835 	# GL/glext.h:1027
GL_LUMINANCE6_ALPHA2_EXT = 32836 	# GL/glext.h:1028
GL_LUMINANCE8_ALPHA8_EXT = 32837 	# GL/glext.h:1029
GL_LUMINANCE12_ALPHA4_EXT = 32838 	# GL/glext.h:1030
GL_LUMINANCE12_ALPHA12_EXT = 32839 	# GL/glext.h:1031
GL_LUMINANCE16_ALPHA16_EXT = 32840 	# GL/glext.h:1032
GL_INTENSITY_EXT = 32841 	# GL/glext.h:1033
GL_INTENSITY4_EXT = 32842 	# GL/glext.h:1034
GL_INTENSITY8_EXT = 32843 	# GL/glext.h:1035
GL_INTENSITY12_EXT = 32844 	# GL/glext.h:1036
GL_INTENSITY16_EXT = 32845 	# GL/glext.h:1037
GL_RGB2_EXT = 32846 	# GL/glext.h:1038
GL_RGB4_EXT = 32847 	# GL/glext.h:1039
GL_RGB5_EXT = 32848 	# GL/glext.h:1040
GL_RGB8_EXT = 32849 	# GL/glext.h:1041
GL_RGB10_EXT = 32850 	# GL/glext.h:1042
GL_RGB12_EXT = 32851 	# GL/glext.h:1043
GL_RGB16_EXT = 32852 	# GL/glext.h:1044
GL_RGBA2_EXT = 32853 	# GL/glext.h:1045
GL_RGBA4_EXT = 32854 	# GL/glext.h:1046
GL_RGB5_A1_EXT = 32855 	# GL/glext.h:1047
GL_RGBA8_EXT = 32856 	# GL/glext.h:1048
GL_RGB10_A2_EXT = 32857 	# GL/glext.h:1049
GL_RGBA12_EXT = 32858 	# GL/glext.h:1050
GL_RGBA16_EXT = 32859 	# GL/glext.h:1051
GL_TEXTURE_RED_SIZE_EXT = 32860 	# GL/glext.h:1052
GL_TEXTURE_GREEN_SIZE_EXT = 32861 	# GL/glext.h:1053
GL_TEXTURE_BLUE_SIZE_EXT = 32862 	# GL/glext.h:1054
GL_TEXTURE_ALPHA_SIZE_EXT = 32863 	# GL/glext.h:1055
GL_TEXTURE_LUMINANCE_SIZE_EXT = 32864 	# GL/glext.h:1056
GL_TEXTURE_INTENSITY_SIZE_EXT = 32865 	# GL/glext.h:1057
GL_REPLACE_EXT = 32866 	# GL/glext.h:1058
GL_PROXY_TEXTURE_1D_EXT = 32867 	# GL/glext.h:1059
GL_PROXY_TEXTURE_2D_EXT = 32868 	# GL/glext.h:1060
GL_TEXTURE_TOO_LARGE_EXT = 32869 	# GL/glext.h:1061
# EXT_texture3D (GL/glext.h:1064)
GL_PACK_SKIP_IMAGES_EXT = 32875 	# GL/glext.h:1065
GL_PACK_IMAGE_HEIGHT_EXT = 32876 	# GL/glext.h:1066
GL_UNPACK_SKIP_IMAGES_EXT = 32877 	# GL/glext.h:1067
GL_UNPACK_IMAGE_HEIGHT_EXT = 32878 	# GL/glext.h:1068
GL_TEXTURE_3D_EXT = 32879 	# GL/glext.h:1069
GL_PROXY_TEXTURE_3D_EXT = 32880 	# GL/glext.h:1070
GL_TEXTURE_DEPTH_EXT = 32881 	# GL/glext.h:1071
GL_TEXTURE_WRAP_R_EXT = 32882 	# GL/glext.h:1072
GL_MAX_3D_TEXTURE_SIZE_EXT = 32883 	# GL/glext.h:1073
# SGIS_texture_filter4 (GL/glext.h:1076)
GL_FILTER4_SGIS = 33094 	# GL/glext.h:1077
GL_TEXTURE_FILTER4_SIZE_SGIS = 33095 	# GL/glext.h:1078
# EXT_subtexture (GL/glext.h:1081)
# EXT_copy_texture (GL/glext.h:1084)
# EXT_histogram (GL/glext.h:1087)
GL_HISTOGRAM_EXT = 32804 	# GL/glext.h:1088
GL_PROXY_HISTOGRAM_EXT = 32805 	# GL/glext.h:1089
GL_HISTOGRAM_WIDTH_EXT = 32806 	# GL/glext.h:1090
GL_HISTOGRAM_FORMAT_EXT = 32807 	# GL/glext.h:1091
GL_HISTOGRAM_RED_SIZE_EXT = 32808 	# GL/glext.h:1092
GL_HISTOGRAM_GREEN_SIZE_EXT = 32809 	# GL/glext.h:1093
GL_HISTOGRAM_BLUE_SIZE_EXT = 32810 	# GL/glext.h:1094
GL_HISTOGRAM_ALPHA_SIZE_EXT = 32811 	# GL/glext.h:1095
GL_HISTOGRAM_LUMINANCE_SIZE_EXT = 32812 	# GL/glext.h:1096
GL_HISTOGRAM_SINK_EXT = 32813 	# GL/glext.h:1097
GL_MINMAX_EXT = 32814 	# GL/glext.h:1098
GL_MINMAX_FORMAT_EXT = 32815 	# GL/glext.h:1099
GL_MINMAX_SINK_EXT = 32816 	# GL/glext.h:1100
GL_TABLE_TOO_LARGE_EXT = 32817 	# GL/glext.h:1101
# EXT_convolution (GL/glext.h:1104)
GL_CONVOLUTION_1D_EXT = 32784 	# GL/glext.h:1105
GL_CONVOLUTION_2D_EXT = 32785 	# GL/glext.h:1106
GL_SEPARABLE_2D_EXT = 32786 	# GL/glext.h:1107
GL_CONVOLUTION_BORDER_MODE_EXT = 32787 	# GL/glext.h:1108
GL_CONVOLUTION_FILTER_SCALE_EXT = 32788 	# GL/glext.h:1109
GL_CONVOLUTION_FILTER_BIAS_EXT = 32789 	# GL/glext.h:1110
GL_REDUCE_EXT = 32790 	# GL/glext.h:1111
GL_CONVOLUTION_FORMAT_EXT = 32791 	# GL/glext.h:1112
GL_CONVOLUTION_WIDTH_EXT = 32792 	# GL/glext.h:1113
GL_CONVOLUTION_HEIGHT_EXT = 32793 	# GL/glext.h:1114
GL_MAX_CONVOLUTION_WIDTH_EXT = 32794 	# GL/glext.h:1115
GL_MAX_CONVOLUTION_HEIGHT_EXT = 32795 	# GL/glext.h:1116
GL_POST_CONVOLUTION_RED_SCALE_EXT = 32796 	# GL/glext.h:1117
GL_POST_CONVOLUTION_GREEN_SCALE_EXT = 32797 	# GL/glext.h:1118
GL_POST_CONVOLUTION_BLUE_SCALE_EXT = 32798 	# GL/glext.h:1119
GL_POST_CONVOLUTION_ALPHA_SCALE_EXT = 32799 	# GL/glext.h:1120
GL_POST_CONVOLUTION_RED_BIAS_EXT = 32800 	# GL/glext.h:1121
GL_POST_CONVOLUTION_GREEN_BIAS_EXT = 32801 	# GL/glext.h:1122
GL_POST_CONVOLUTION_BLUE_BIAS_EXT = 32802 	# GL/glext.h:1123
GL_POST_CONVOLUTION_ALPHA_BIAS_EXT = 32803 	# GL/glext.h:1124
# SGI_color_matrix (GL/glext.h:1127)
GL_COLOR_MATRIX_SGI = 32945 	# GL/glext.h:1128
GL_COLOR_MATRIX_STACK_DEPTH_SGI = 32946 	# GL/glext.h:1129
GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI = 32947 	# GL/glext.h:1130
GL_POST_COLOR_MATRIX_RED_SCALE_SGI = 32948 	# GL/glext.h:1131
GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI = 32949 	# GL/glext.h:1132
GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI = 32950 	# GL/glext.h:1133
GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI = 32951 	# GL/glext.h:1134
GL_POST_COLOR_MATRIX_RED_BIAS_SGI = 32952 	# GL/glext.h:1135
GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI = 32953 	# GL/glext.h:1136
GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI = 32954 	# GL/glext.h:1137
GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI = 32955 	# GL/glext.h:1138
# SGI_color_table (GL/glext.h:1141)
GL_COLOR_TABLE_SGI = 32976 	# GL/glext.h:1142
GL_POST_CONVOLUTION_COLOR_TABLE_SGI = 32977 	# GL/glext.h:1143
GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI = 32978 	# GL/glext.h:1144
GL_PROXY_COLOR_TABLE_SGI = 32979 	# GL/glext.h:1145
GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI = 32980 	# GL/glext.h:1146
GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI = 32981 	# GL/glext.h:1147
GL_COLOR_TABLE_SCALE_SGI = 32982 	# GL/glext.h:1148
GL_COLOR_TABLE_BIAS_SGI = 32983 	# GL/glext.h:1149
GL_COLOR_TABLE_FORMAT_SGI = 32984 	# GL/glext.h:1150
GL_COLOR_TABLE_WIDTH_SGI = 32985 	# GL/glext.h:1151
GL_COLOR_TABLE_RED_SIZE_SGI = 32986 	# GL/glext.h:1152
GL_COLOR_TABLE_GREEN_SIZE_SGI = 32987 	# GL/glext.h:1153
GL_COLOR_TABLE_BLUE_SIZE_SGI = 32988 	# GL/glext.h:1154
GL_COLOR_TABLE_ALPHA_SIZE_SGI = 32989 	# GL/glext.h:1155
GL_COLOR_TABLE_LUMINANCE_SIZE_SGI = 32990 	# GL/glext.h:1156
GL_COLOR_TABLE_INTENSITY_SIZE_SGI = 32991 	# GL/glext.h:1157
# SGIS_pixel_texture (GL/glext.h:1160)
GL_PIXEL_TEXTURE_SGIS = 33619 	# GL/glext.h:1161
GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS = 33620 	# GL/glext.h:1162
GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS = 33621 	# GL/glext.h:1163
GL_PIXEL_GROUP_COLOR_SGIS = 33622 	# GL/glext.h:1164
# SGIX_pixel_texture (GL/glext.h:1167)
GL_PIXEL_TEX_GEN_SGIX = 33081 	# GL/glext.h:1168
GL_PIXEL_TEX_GEN_MODE_SGIX = 33579 	# GL/glext.h:1169
# SGIS_texture4D (GL/glext.h:1172)
GL_PACK_SKIP_VOLUMES_SGIS = 33072 	# GL/glext.h:1173
GL_PACK_IMAGE_DEPTH_SGIS = 33073 	# GL/glext.h:1174
GL_UNPACK_SKIP_VOLUMES_SGIS = 33074 	# GL/glext.h:1175
GL_UNPACK_IMAGE_DEPTH_SGIS = 33075 	# GL/glext.h:1176
GL_TEXTURE_4D_SGIS = 33076 	# GL/glext.h:1177
GL_PROXY_TEXTURE_4D_SGIS = 33077 	# GL/glext.h:1178
GL_TEXTURE_4DSIZE_SGIS = 33078 	# GL/glext.h:1179
GL_TEXTURE_WRAP_Q_SGIS = 33079 	# GL/glext.h:1180
GL_MAX_4D_TEXTURE_SIZE_SGIS = 33080 	# GL/glext.h:1181
GL_TEXTURE_4D_BINDING_SGIS = 33103 	# GL/glext.h:1182
# SGI_texture_color_table (GL/glext.h:1185)
GL_TEXTURE_COLOR_TABLE_SGI = 32956 	# GL/glext.h:1186
GL_PROXY_TEXTURE_COLOR_TABLE_SGI = 32957 	# GL/glext.h:1187
# EXT_cmyka (GL/glext.h:1190)
GL_CMYK_EXT = 32780 	# GL/glext.h:1191
GL_CMYKA_EXT = 32781 	# GL/glext.h:1192
GL_PACK_CMYK_HINT_EXT = 32782 	# GL/glext.h:1193
GL_UNPACK_CMYK_HINT_EXT = 32783 	# GL/glext.h:1194
# EXT_texture_object (GL/glext.h:1197)
GL_TEXTURE_PRIORITY_EXT = 32870 	# GL/glext.h:1198
GL_TEXTURE_RESIDENT_EXT = 32871 	# GL/glext.h:1199
GL_TEXTURE_1D_BINDING_EXT = 32872 	# GL/glext.h:1200
GL_TEXTURE_2D_BINDING_EXT = 32873 	# GL/glext.h:1201
GL_TEXTURE_3D_BINDING_EXT = 32874 	# GL/glext.h:1202
# SGIS_detail_texture (GL/glext.h:1205)
GL_DETAIL_TEXTURE_2D_SGIS = 32917 	# GL/glext.h:1206
GL_DETAIL_TEXTURE_2D_BINDING_SGIS = 32918 	# GL/glext.h:1207
GL_LINEAR_DETAIL_SGIS = 32919 	# GL/glext.h:1208
GL_LINEAR_DETAIL_ALPHA_SGIS = 32920 	# GL/glext.h:1209
GL_LINEAR_DETAIL_COLOR_SGIS = 32921 	# GL/glext.h:1210
GL_DETAIL_TEXTURE_LEVEL_SGIS = 32922 	# GL/glext.h:1211
GL_DETAIL_TEXTURE_MODE_SGIS = 32923 	# GL/glext.h:1212
GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS = 32924 	# GL/glext.h:1213
# SGIS_sharpen_texture (GL/glext.h:1216)
GL_LINEAR_SHARPEN_SGIS = 32941 	# GL/glext.h:1217
GL_LINEAR_SHARPEN_ALPHA_SGIS = 32942 	# GL/glext.h:1218
GL_LINEAR_SHARPEN_COLOR_SGIS = 32943 	# GL/glext.h:1219
GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS = 32944 	# GL/glext.h:1220
# EXT_packed_pixels (GL/glext.h:1223)
GL_UNSIGNED_BYTE_3_3_2_EXT = 32818 	# GL/glext.h:1224
GL_UNSIGNED_SHORT_4_4_4_4_EXT = 32819 	# GL/glext.h:1225
GL_UNSIGNED_SHORT_5_5_5_1_EXT = 32820 	# GL/glext.h:1226
GL_UNSIGNED_INT_8_8_8_8_EXT = 32821 	# GL/glext.h:1227
GL_UNSIGNED_INT_10_10_10_2_EXT = 32822 	# GL/glext.h:1228
# SGIS_texture_lod (GL/glext.h:1231)
GL_TEXTURE_MIN_LOD_SGIS = 33082 	# GL/glext.h:1232
GL_TEXTURE_MAX_LOD_SGIS = 33083 	# GL/glext.h:1233
GL_TEXTURE_BASE_LEVEL_SGIS = 33084 	# GL/glext.h:1234
GL_TEXTURE_MAX_LEVEL_SGIS = 33085 	# GL/glext.h:1235
# SGIS_multisample (GL/glext.h:1238)
GL_MULTISAMPLE_SGIS = 32925 	# GL/glext.h:1239
GL_SAMPLE_ALPHA_TO_MASK_SGIS = 32926 	# GL/glext.h:1240
GL_SAMPLE_ALPHA_TO_ONE_SGIS = 32927 	# GL/glext.h:1241
GL_SAMPLE_MASK_SGIS = 32928 	# GL/glext.h:1242
GL_1PASS_SGIS = 32929 	# GL/glext.h:1243
GL_2PASS_0_SGIS = 32930 	# GL/glext.h:1244
GL_2PASS_1_SGIS = 32931 	# GL/glext.h:1245
GL_4PASS_0_SGIS = 32932 	# GL/glext.h:1246
GL_4PASS_1_SGIS = 32933 	# GL/glext.h:1247
GL_4PASS_2_SGIS = 32934 	# GL/glext.h:1248
GL_4PASS_3_SGIS = 32935 	# GL/glext.h:1249
GL_SAMPLE_BUFFERS_SGIS = 32936 	# GL/glext.h:1250
GL_SAMPLES_SGIS = 32937 	# GL/glext.h:1251
GL_SAMPLE_MASK_VALUE_SGIS = 32938 	# GL/glext.h:1252
GL_SAMPLE_MASK_INVERT_SGIS = 32939 	# GL/glext.h:1253
GL_SAMPLE_PATTERN_SGIS = 32940 	# GL/glext.h:1254
# EXT_rescale_normal (GL/glext.h:1257)
GL_RESCALE_NORMAL_EXT = 32826 	# GL/glext.h:1258
# EXT_vertex_array (GL/glext.h:1261)
GL_VERTEX_ARRAY_EXT = 32884 	# GL/glext.h:1262
GL_NORMAL_ARRAY_EXT = 32885 	# GL/glext.h:1263
GL_COLOR_ARRAY_EXT = 32886 	# GL/glext.h:1264
GL_INDEX_ARRAY_EXT = 32887 	# GL/glext.h:1265
GL_TEXTURE_COORD_ARRAY_EXT = 32888 	# GL/glext.h:1266
GL_EDGE_FLAG_ARRAY_EXT = 32889 	# GL/glext.h:1267
GL_VERTEX_ARRAY_SIZE_EXT = 32890 	# GL/glext.h:1268
GL_VERTEX_ARRAY_TYPE_EXT = 32891 	# GL/glext.h:1269
GL_VERTEX_ARRAY_STRIDE_EXT = 32892 	# GL/glext.h:1270
GL_VERTEX_ARRAY_COUNT_EXT = 32893 	# GL/glext.h:1271
GL_NORMAL_ARRAY_TYPE_EXT = 32894 	# GL/glext.h:1272
GL_NORMAL_ARRAY_STRIDE_EXT = 32895 	# GL/glext.h:1273
GL_NORMAL_ARRAY_COUNT_EXT = 32896 	# GL/glext.h:1274
GL_COLOR_ARRAY_SIZE_EXT = 32897 	# GL/glext.h:1275
GL_COLOR_ARRAY_TYPE_EXT = 32898 	# GL/glext.h:1276
GL_COLOR_ARRAY_STRIDE_EXT = 32899 	# GL/glext.h:1277
GL_COLOR_ARRAY_COUNT_EXT = 32900 	# GL/glext.h:1278
GL_INDEX_ARRAY_TYPE_EXT = 32901 	# GL/glext.h:1279
GL_INDEX_ARRAY_STRIDE_EXT = 32902 	# GL/glext.h:1280
GL_INDEX_ARRAY_COUNT_EXT = 32903 	# GL/glext.h:1281
GL_TEXTURE_COORD_ARRAY_SIZE_EXT = 32904 	# GL/glext.h:1282
GL_TEXTURE_COORD_ARRAY_TYPE_EXT = 32905 	# GL/glext.h:1283
GL_TEXTURE_COORD_ARRAY_STRIDE_EXT = 32906 	# GL/glext.h:1284
GL_TEXTURE_COORD_ARRAY_COUNT_EXT = 32907 	# GL/glext.h:1285
GL_EDGE_FLAG_ARRAY_STRIDE_EXT = 32908 	# GL/glext.h:1286
GL_EDGE_FLAG_ARRAY_COUNT_EXT = 32909 	# GL/glext.h:1287
GL_VERTEX_ARRAY_POINTER_EXT = 32910 	# GL/glext.h:1288
GL_NORMAL_ARRAY_POINTER_EXT = 32911 	# GL/glext.h:1289
GL_COLOR_ARRAY_POINTER_EXT = 32912 	# GL/glext.h:1290
GL_INDEX_ARRAY_POINTER_EXT = 32913 	# GL/glext.h:1291
GL_TEXTURE_COORD_ARRAY_POINTER_EXT = 32914 	# GL/glext.h:1292
GL_EDGE_FLAG_ARRAY_POINTER_EXT = 32915 	# GL/glext.h:1293
# EXT_misc_attribute (GL/glext.h:1296)
# SGIS_generate_mipmap (GL/glext.h:1299)
GL_GENERATE_MIPMAP_SGIS = 33169 	# GL/glext.h:1300
GL_GENERATE_MIPMAP_HINT_SGIS = 33170 	# GL/glext.h:1301
# SGIX_clipmap (GL/glext.h:1304)
GL_LINEAR_CLIPMAP_LINEAR_SGIX = 33136 	# GL/glext.h:1305
GL_TEXTURE_CLIPMAP_CENTER_SGIX = 33137 	# GL/glext.h:1306
GL_TEXTURE_CLIPMAP_FRAME_SGIX = 33138 	# GL/glext.h:1307
GL_TEXTURE_CLIPMAP_OFFSET_SGIX = 33139 	# GL/glext.h:1308
GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX = 33140 	# GL/glext.h:1309
GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX = 33141 	# GL/glext.h:1310
GL_TEXTURE_CLIPMAP_DEPTH_SGIX = 33142 	# GL/glext.h:1311
GL_MAX_CLIPMAP_DEPTH_SGIX = 33143 	# GL/glext.h:1312
GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX = 33144 	# GL/glext.h:1313
GL_NEAREST_CLIPMAP_NEAREST_SGIX = 33869 	# GL/glext.h:1314
GL_NEAREST_CLIPMAP_LINEAR_SGIX = 33870 	# GL/glext.h:1315
GL_LINEAR_CLIPMAP_NEAREST_SGIX = 33871 	# GL/glext.h:1316
# SGIX_shadow (GL/glext.h:1319)
GL_TEXTURE_COMPARE_SGIX = 33178 	# GL/glext.h:1320
GL_TEXTURE_COMPARE_OPERATOR_SGIX = 33179 	# GL/glext.h:1321
GL_TEXTURE_LEQUAL_R_SGIX = 33180 	# GL/glext.h:1322
GL_TEXTURE_GEQUAL_R_SGIX = 33181 	# GL/glext.h:1323
# SGIS_texture_edge_clamp (GL/glext.h:1326)
GL_CLAMP_TO_EDGE_SGIS = 33071 	# GL/glext.h:1327
# SGIS_texture_border_clamp (GL/glext.h:1330)
GL_CLAMP_TO_BORDER_SGIS = 33069 	# GL/glext.h:1331
# EXT_blend_minmax (GL/glext.h:1334)
GL_FUNC_ADD_EXT = 32774 	# GL/glext.h:1335
GL_MIN_EXT = 32775 	# GL/glext.h:1336
GL_MAX_EXT = 32776 	# GL/glext.h:1337
GL_BLEND_EQUATION_EXT = 32777 	# GL/glext.h:1338
# EXT_blend_subtract (GL/glext.h:1341)
GL_FUNC_SUBTRACT_EXT = 32778 	# GL/glext.h:1342
GL_FUNC_REVERSE_SUBTRACT_EXT = 32779 	# GL/glext.h:1343
# EXT_blend_logic_op (GL/glext.h:1346)
# SGIX_interlace (GL/glext.h:1349)
GL_INTERLACE_SGIX = 32916 	# GL/glext.h:1350
# SGIX_pixel_tiles (GL/glext.h:1353)
GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX = 33086 	# GL/glext.h:1354
GL_PIXEL_TILE_CACHE_INCREMENT_SGIX = 33087 	# GL/glext.h:1355
GL_PIXEL_TILE_WIDTH_SGIX = 33088 	# GL/glext.h:1356
GL_PIXEL_TILE_HEIGHT_SGIX = 33089 	# GL/glext.h:1357
GL_PIXEL_TILE_GRID_WIDTH_SGIX = 33090 	# GL/glext.h:1358
GL_PIXEL_TILE_GRID_HEIGHT_SGIX = 33091 	# GL/glext.h:1359
GL_PIXEL_TILE_GRID_DEPTH_SGIX = 33092 	# GL/glext.h:1360
GL_PIXEL_TILE_CACHE_SIZE_SGIX = 33093 	# GL/glext.h:1361
# SGIS_texture_select (GL/glext.h:1364)
GL_DUAL_ALPHA4_SGIS = 33040 	# GL/glext.h:1365
GL_DUAL_ALPHA8_SGIS = 33041 	# GL/glext.h:1366
GL_DUAL_ALPHA12_SGIS = 33042 	# GL/glext.h:1367
GL_DUAL_ALPHA16_SGIS = 33043 	# GL/glext.h:1368
GL_DUAL_LUMINANCE4_SGIS = 33044 	# GL/glext.h:1369
GL_DUAL_LUMINANCE8_SGIS = 33045 	# GL/glext.h:1370
GL_DUAL_LUMINANCE12_SGIS = 33046 	# GL/glext.h:1371
GL_DUAL_LUMINANCE16_SGIS = 33047 	# GL/glext.h:1372
GL_DUAL_INTENSITY4_SGIS = 33048 	# GL/glext.h:1373
GL_DUAL_INTENSITY8_SGIS = 33049 	# GL/glext.h:1374
GL_DUAL_INTENSITY12_SGIS = 33050 	# GL/glext.h:1375
GL_DUAL_INTENSITY16_SGIS = 33051 	# GL/glext.h:1376
GL_DUAL_LUMINANCE_ALPHA4_SGIS = 33052 	# GL/glext.h:1377
GL_DUAL_LUMINANCE_ALPHA8_SGIS = 33053 	# GL/glext.h:1378
GL_QUAD_ALPHA4_SGIS = 33054 	# GL/glext.h:1379
GL_QUAD_ALPHA8_SGIS = 33055 	# GL/glext.h:1380
GL_QUAD_LUMINANCE4_SGIS = 33056 	# GL/glext.h:1381
GL_QUAD_LUMINANCE8_SGIS = 33057 	# GL/glext.h:1382
GL_QUAD_INTENSITY4_SGIS = 33058 	# GL/glext.h:1383
GL_QUAD_INTENSITY8_SGIS = 33059 	# GL/glext.h:1384
GL_DUAL_TEXTURE_SELECT_SGIS = 33060 	# GL/glext.h:1385
GL_QUAD_TEXTURE_SELECT_SGIS = 33061 	# GL/glext.h:1386
# SGIX_sprite (GL/glext.h:1389)
GL_SPRITE_SGIX = 33096 	# GL/glext.h:1390
GL_SPRITE_MODE_SGIX = 33097 	# GL/glext.h:1391
GL_SPRITE_AXIS_SGIX = 33098 	# GL/glext.h:1392
GL_SPRITE_TRANSLATION_SGIX = 33099 	# GL/glext.h:1393
GL_SPRITE_AXIAL_SGIX = 33100 	# GL/glext.h:1394
GL_SPRITE_OBJECT_ALIGNED_SGIX = 33101 	# GL/glext.h:1395
GL_SPRITE_EYE_ALIGNED_SGIX = 33102 	# GL/glext.h:1396
# SGIX_texture_multi_buffer (GL/glext.h:1399)
GL_TEXTURE_MULTI_BUFFER_HINT_SGIX = 33070 	# GL/glext.h:1400
# EXT_point_parameters (GL/glext.h:1403)
GL_POINT_SIZE_MIN_EXT = 33062 	# GL/glext.h:1404
GL_POINT_SIZE_MAX_EXT = 33063 	# GL/glext.h:1405
GL_POINT_FADE_THRESHOLD_SIZE_EXT = 33064 	# GL/glext.h:1406
GL_DISTANCE_ATTENUATION_EXT = 33065 	# GL/glext.h:1407
# SGIS_point_parameters (GL/glext.h:1410)
GL_POINT_SIZE_MIN_SGIS = 33062 	# GL/glext.h:1411
GL_POINT_SIZE_MAX_SGIS = 33063 	# GL/glext.h:1412
GL_POINT_FADE_THRESHOLD_SIZE_SGIS = 33064 	# GL/glext.h:1413
GL_DISTANCE_ATTENUATION_SGIS = 33065 	# GL/glext.h:1414
# SGIX_instruments (GL/glext.h:1417)
GL_INSTRUMENT_BUFFER_POINTER_SGIX = 33152 	# GL/glext.h:1418
GL_INSTRUMENT_MEASUREMENTS_SGIX = 33153 	# GL/glext.h:1419
# SGIX_texture_scale_bias (GL/glext.h:1422)
GL_POST_TEXTURE_FILTER_BIAS_SGIX = 33145 	# GL/glext.h:1423
GL_POST_TEXTURE_FILTER_SCALE_SGIX = 33146 	# GL/glext.h:1424
GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX = 33147 	# GL/glext.h:1425
GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX = 33148 	# GL/glext.h:1426
# SGIX_framezoom (GL/glext.h:1429)
GL_FRAMEZOOM_SGIX = 33163 	# GL/glext.h:1430
GL_FRAMEZOOM_FACTOR_SGIX = 33164 	# GL/glext.h:1431
GL_MAX_FRAMEZOOM_FACTOR_SGIX = 33165 	# GL/glext.h:1432
# SGIX_tag_sample_buffer (GL/glext.h:1435)
# FfdMaskSGIX (GL/glext.h:1438)
GL_TEXTURE_DEFORMATION_BIT_SGIX = 1 	# GL/glext.h:1439
GL_GEOMETRY_DEFORMATION_BIT_SGIX = 2 	# GL/glext.h:1440
# SGIX_polynomial_ffd (GL/glext.h:1443)
GL_GEOMETRY_DEFORMATION_SGIX = 33172 	# GL/glext.h:1444
GL_TEXTURE_DEFORMATION_SGIX = 33173 	# GL/glext.h:1445
GL_DEFORMATIONS_MASK_SGIX = 33174 	# GL/glext.h:1446
GL_MAX_DEFORMATION_ORDER_SGIX = 33175 	# GL/glext.h:1447
# SGIX_reference_plane (GL/glext.h:1450)
GL_REFERENCE_PLANE_SGIX = 33149 	# GL/glext.h:1451
GL_REFERENCE_PLANE_EQUATION_SGIX = 33150 	# GL/glext.h:1452
# SGIX_flush_raster (GL/glext.h:1455)
# SGIX_depth_texture (GL/glext.h:1458)
GL_DEPTH_COMPONENT16_SGIX = 33189 	# GL/glext.h:1459
GL_DEPTH_COMPONENT24_SGIX = 33190 	# GL/glext.h:1460
GL_DEPTH_COMPONENT32_SGIX = 33191 	# GL/glext.h:1461
# SGIS_fog_function (GL/glext.h:1464)
GL_FOG_FUNC_SGIS = 33066 	# GL/glext.h:1465
GL_FOG_FUNC_POINTS_SGIS = 33067 	# GL/glext.h:1466
GL_MAX_FOG_FUNC_POINTS_SGIS = 33068 	# GL/glext.h:1467
# SGIX_fog_offset (GL/glext.h:1470)
GL_FOG_OFFSET_SGIX = 33176 	# GL/glext.h:1471
GL_FOG_OFFSET_VALUE_SGIX = 33177 	# GL/glext.h:1472
# HP_image_transform (GL/glext.h:1475)
GL_IMAGE_SCALE_X_HP = 33109 	# GL/glext.h:1476
GL_IMAGE_SCALE_Y_HP = 33110 	# GL/glext.h:1477
GL_IMAGE_TRANSLATE_X_HP = 33111 	# GL/glext.h:1478
GL_IMAGE_TRANSLATE_Y_HP = 33112 	# GL/glext.h:1479
GL_IMAGE_ROTATE_ANGLE_HP = 33113 	# GL/glext.h:1480
GL_IMAGE_ROTATE_ORIGIN_X_HP = 33114 	# GL/glext.h:1481
GL_IMAGE_ROTATE_ORIGIN_Y_HP = 33115 	# GL/glext.h:1482
GL_IMAGE_MAG_FILTER_HP = 33116 	# GL/glext.h:1483
GL_IMAGE_MIN_FILTER_HP = 33117 	# GL/glext.h:1484
GL_IMAGE_CUBIC_WEIGHT_HP = 33118 	# GL/glext.h:1485
GL_CUBIC_HP = 33119 	# GL/glext.h:1486
GL_AVERAGE_HP = 33120 	# GL/glext.h:1487
GL_IMAGE_TRANSFORM_2D_HP = 33121 	# GL/glext.h:1488
GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = 33122 	# GL/glext.h:1489
GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = 33123 	# GL/glext.h:1490
# HP_convolution_border_modes (GL/glext.h:1493)
GL_IGNORE_BORDER_HP = 33104 	# GL/glext.h:1494
GL_CONSTANT_BORDER_HP = 33105 	# GL/glext.h:1495
GL_REPLICATE_BORDER_HP = 33107 	# GL/glext.h:1496
GL_CONVOLUTION_BORDER_COLOR_HP = 33108 	# GL/glext.h:1497
# INGR_palette_buffer (GL/glext.h:1500)
# SGIX_texture_add_env (GL/glext.h:1503)
GL_TEXTURE_ENV_BIAS_SGIX = 32958 	# GL/glext.h:1504
# EXT_color_subtable (GL/glext.h:1507)
# PGI_vertex_hints (GL/glext.h:1510)
GL_VERTEX_DATA_HINT_PGI = 107050 	# GL/glext.h:1511
GL_VERTEX_CONSISTENT_HINT_PGI = 107051 	# GL/glext.h:1512
GL_MATERIAL_SIDE_HINT_PGI = 107052 	# GL/glext.h:1513
GL_MAX_VERTEX_HINT_PGI = 107053 	# GL/glext.h:1514
GL_COLOR3_BIT_PGI = 65536 	# GL/glext.h:1515
GL_COLOR4_BIT_PGI = 131072 	# GL/glext.h:1516
GL_EDGEFLAG_BIT_PGI = 262144 	# GL/glext.h:1517
GL_INDEX_BIT_PGI = 524288 	# GL/glext.h:1518
GL_MAT_AMBIENT_BIT_PGI = 1048576 	# GL/glext.h:1519
GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI = 2097152 	# GL/glext.h:1520
GL_MAT_DIFFUSE_BIT_PGI = 4194304 	# GL/glext.h:1521
GL_MAT_EMISSION_BIT_PGI = 8388608 	# GL/glext.h:1522
GL_MAT_COLOR_INDEXES_BIT_PGI = 16777216 	# GL/glext.h:1523
GL_MAT_SHININESS_BIT_PGI = 33554432 	# GL/glext.h:1524
GL_MAT_SPECULAR_BIT_PGI = 67108864 	# GL/glext.h:1525
GL_NORMAL_BIT_PGI = 134217728 	# GL/glext.h:1526
GL_TEXCOORD1_BIT_PGI = 268435456 	# GL/glext.h:1527
GL_TEXCOORD2_BIT_PGI = 536870912 	# GL/glext.h:1528
GL_TEXCOORD3_BIT_PGI = 1073741824 	# GL/glext.h:1529
GL_TEXCOORD4_BIT_PGI = 2147483648 	# GL/glext.h:1530
GL_VERTEX23_BIT_PGI = 4 	# GL/glext.h:1531
GL_VERTEX4_BIT_PGI = 8 	# GL/glext.h:1532
# PGI_misc_hints (GL/glext.h:1535)
GL_PREFER_DOUBLEBUFFER_HINT_PGI = 107000 	# GL/glext.h:1536
GL_CONSERVE_MEMORY_HINT_PGI = 107005 	# GL/glext.h:1537
GL_RECLAIM_MEMORY_HINT_PGI = 107006 	# GL/glext.h:1538
GL_NATIVE_GRAPHICS_HANDLE_PGI = 107010 	# GL/glext.h:1539
GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI = 107011 	# GL/glext.h:1540
GL_NATIVE_GRAPHICS_END_HINT_PGI = 107012 	# GL/glext.h:1541
GL_ALWAYS_FAST_HINT_PGI = 107020 	# GL/glext.h:1542
GL_ALWAYS_SOFT_HINT_PGI = 107021 	# GL/glext.h:1543
GL_ALLOW_DRAW_OBJ_HINT_PGI = 107022 	# GL/glext.h:1544
GL_ALLOW_DRAW_WIN_HINT_PGI = 107023 	# GL/glext.h:1545
GL_ALLOW_DRAW_FRG_HINT_PGI = 107024 	# GL/glext.h:1546
GL_ALLOW_DRAW_MEM_HINT_PGI = 107025 	# GL/glext.h:1547
GL_STRICT_DEPTHFUNC_HINT_PGI = 107030 	# GL/glext.h:1548
GL_STRICT_LIGHTING_HINT_PGI = 107031 	# GL/glext.h:1549
GL_STRICT_SCISSOR_HINT_PGI = 107032 	# GL/glext.h:1550
GL_FULL_STIPPLE_HINT_PGI = 107033 	# GL/glext.h:1551
GL_CLIP_NEAR_HINT_PGI = 107040 	# GL/glext.h:1552
GL_CLIP_FAR_HINT_PGI = 107041 	# GL/glext.h:1553
GL_WIDE_LINE_HINT_PGI = 107042 	# GL/glext.h:1554
GL_BACK_NORMALS_HINT_PGI = 107043 	# GL/glext.h:1555
# EXT_paletted_texture (GL/glext.h:1558)
GL_COLOR_INDEX1_EXT = 32994 	# GL/glext.h:1559
GL_COLOR_INDEX2_EXT = 32995 	# GL/glext.h:1560
GL_COLOR_INDEX4_EXT = 32996 	# GL/glext.h:1561
GL_COLOR_INDEX8_EXT = 32997 	# GL/glext.h:1562
GL_COLOR_INDEX12_EXT = 32998 	# GL/glext.h:1563
GL_COLOR_INDEX16_EXT = 32999 	# GL/glext.h:1564
GL_TEXTURE_INDEX_SIZE_EXT = 33005 	# GL/glext.h:1565
# EXT_clip_volume_hint (GL/glext.h:1568)
GL_CLIP_VOLUME_CLIPPING_HINT_EXT = 33008 	# GL/glext.h:1569
# SGIX_list_priority (GL/glext.h:1572)
GL_LIST_PRIORITY_SGIX = 33154 	# GL/glext.h:1573
# SGIX_ir_instrument1 (GL/glext.h:1576)
GL_IR_INSTRUMENT1_SGIX = 33151 	# GL/glext.h:1577
# SGIX_calligraphic_fragment (GL/glext.h:1580)
GL_CALLIGRAPHIC_FRAGMENT_SGIX = 33155 	# GL/glext.h:1581
# SGIX_texture_lod_bias (GL/glext.h:1584)
GL_TEXTURE_LOD_BIAS_S_SGIX = 33166 	# GL/glext.h:1585
GL_TEXTURE_LOD_BIAS_T_SGIX = 33167 	# GL/glext.h:1586
GL_TEXTURE_LOD_BIAS_R_SGIX = 33168 	# GL/glext.h:1587
# SGIX_shadow_ambient (GL/glext.h:1590)
GL_SHADOW_AMBIENT_SGIX = 32959 	# GL/glext.h:1591
# EXT_index_texture (GL/glext.h:1594)
# EXT_index_material (GL/glext.h:1597)
GL_INDEX_MATERIAL_EXT = 33208 	# GL/glext.h:1598
GL_INDEX_MATERIAL_PARAMETER_EXT = 33209 	# GL/glext.h:1599
GL_INDEX_MATERIAL_FACE_EXT = 33210 	# GL/glext.h:1600
# EXT_index_func (GL/glext.h:1603)
GL_INDEX_TEST_EXT = 33205 	# GL/glext.h:1604
GL_INDEX_TEST_FUNC_EXT = 33206 	# GL/glext.h:1605
GL_INDEX_TEST_REF_EXT = 33207 	# GL/glext.h:1606
# EXT_index_array_formats (GL/glext.h:1609)
GL_IUI_V2F_EXT = 33197 	# GL/glext.h:1610
GL_IUI_V3F_EXT = 33198 	# GL/glext.h:1611
GL_IUI_N3F_V2F_EXT = 33199 	# GL/glext.h:1612
GL_IUI_N3F_V3F_EXT = 33200 	# GL/glext.h:1613
GL_T2F_IUI_V2F_EXT = 33201 	# GL/glext.h:1614
GL_T2F_IUI_V3F_EXT = 33202 	# GL/glext.h:1615
GL_T2F_IUI_N3F_V2F_EXT = 33203 	# GL/glext.h:1616
GL_T2F_IUI_N3F_V3F_EXT = 33204 	# GL/glext.h:1617
# EXT_compiled_vertex_array (GL/glext.h:1620)
GL_ARRAY_ELEMENT_LOCK_FIRST_EXT = 33192 	# GL/glext.h:1621
GL_ARRAY_ELEMENT_LOCK_COUNT_EXT = 33193 	# GL/glext.h:1622
# EXT_cull_vertex (GL/glext.h:1625)
GL_CULL_VERTEX_EXT = 33194 	# GL/glext.h:1626
GL_CULL_VERTEX_EYE_POSITION_EXT = 33195 	# GL/glext.h:1627
GL_CULL_VERTEX_OBJECT_POSITION_EXT = 33196 	# GL/glext.h:1628
# SGIX_ycrcb (GL/glext.h:1631)
GL_YCRCB_422_SGIX = 33211 	# GL/glext.h:1632
GL_YCRCB_444_SGIX = 33212 	# GL/glext.h:1633
# SGIX_fragment_lighting (GL/glext.h:1636)
GL_FRAGMENT_LIGHTING_SGIX = 33792 	# GL/glext.h:1637
GL_FRAGMENT_COLOR_MATERIAL_SGIX = 33793 	# GL/glext.h:1638
GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX = 33794 	# GL/glext.h:1639
GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX = 33795 	# GL/glext.h:1640
GL_MAX_FRAGMENT_LIGHTS_SGIX = 33796 	# GL/glext.h:1641
GL_MAX_ACTIVE_LIGHTS_SGIX = 33797 	# GL/glext.h:1642
GL_CURRENT_RASTER_NORMAL_SGIX = 33798 	# GL/glext.h:1643
GL_LIGHT_ENV_MODE_SGIX = 33799 	# GL/glext.h:1644
GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX = 33800 	# GL/glext.h:1645
GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX = 33801 	# GL/glext.h:1646
GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX = 33802 	# GL/glext.h:1647
GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX = 33803 	# GL/glext.h:1648
GL_FRAGMENT_LIGHT0_SGIX = 33804 	# GL/glext.h:1649
GL_FRAGMENT_LIGHT1_SGIX = 33805 	# GL/glext.h:1650
GL_FRAGMENT_LIGHT2_SGIX = 33806 	# GL/glext.h:1651
GL_FRAGMENT_LIGHT3_SGIX = 33807 	# GL/glext.h:1652
GL_FRAGMENT_LIGHT4_SGIX = 33808 	# GL/glext.h:1653
GL_FRAGMENT_LIGHT5_SGIX = 33809 	# GL/glext.h:1654
GL_FRAGMENT_LIGHT6_SGIX = 33810 	# GL/glext.h:1655
GL_FRAGMENT_LIGHT7_SGIX = 33811 	# GL/glext.h:1656
# IBM_rasterpos_clip (GL/glext.h:1659)
GL_RASTER_POSITION_UNCLIPPED_IBM = 103010 	# GL/glext.h:1660
# HP_texture_lighting (GL/glext.h:1663)
GL_TEXTURE_LIGHTING_MODE_HP = 33127 	# GL/glext.h:1664
GL_TEXTURE_POST_SPECULAR_HP = 33128 	# GL/glext.h:1665
GL_TEXTURE_PRE_SPECULAR_HP = 33129 	# GL/glext.h:1666
# EXT_draw_range_elements (GL/glext.h:1669)
GL_MAX_ELEMENTS_VERTICES_EXT = 33000 	# GL/glext.h:1670
GL_MAX_ELEMENTS_INDICES_EXT = 33001 	# GL/glext.h:1671
# WIN_phong_shading (GL/glext.h:1674)
GL_PHONG_WIN = 33002 	# GL/glext.h:1675
GL_PHONG_HINT_WIN = 33003 	# GL/glext.h:1676
# WIN_specular_fog (GL/glext.h:1679)
GL_FOG_SPECULAR_TEXTURE_WIN = 33004 	# GL/glext.h:1680
# EXT_light_texture (GL/glext.h:1683)
GL_FRAGMENT_MATERIAL_EXT = 33609 	# GL/glext.h:1684
GL_FRAGMENT_NORMAL_EXT = 33610 	# GL/glext.h:1685
GL_FRAGMENT_COLOR_EXT = 33612 	# GL/glext.h:1686
GL_ATTENUATION_EXT = 33613 	# GL/glext.h:1687
GL_SHADOW_ATTENUATION_EXT = 33614 	# GL/glext.h:1688
GL_TEXTURE_APPLICATION_MODE_EXT = 33615 	# GL/glext.h:1689
GL_TEXTURE_LIGHT_EXT = 33616 	# GL/glext.h:1690
GL_TEXTURE_MATERIAL_FACE_EXT = 33617 	# GL/glext.h:1691
GL_TEXTURE_MATERIAL_PARAMETER_EXT = 33618 	# GL/glext.h:1692
# SGIX_blend_alpha_minmax (GL/glext.h:1696)
GL_ALPHA_MIN_SGIX = 33568 	# GL/glext.h:1697
GL_ALPHA_MAX_SGIX = 33569 	# GL/glext.h:1698
# SGIX_impact_pixel_texture (GL/glext.h:1701)
GL_PIXEL_TEX_GEN_Q_CEILING_SGIX = 33156 	# GL/glext.h:1702
GL_PIXEL_TEX_GEN_Q_ROUND_SGIX = 33157 	# GL/glext.h:1703
GL_PIXEL_TEX_GEN_Q_FLOOR_SGIX = 33158 	# GL/glext.h:1704
GL_PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX = 33159 	# GL/glext.h:1705
GL_PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX = 33160 	# GL/glext.h:1706
GL_PIXEL_TEX_GEN_ALPHA_LS_SGIX = 33161 	# GL/glext.h:1707
GL_PIXEL_TEX_GEN_ALPHA_MS_SGIX = 33162 	# GL/glext.h:1708
# EXT_bgra (GL/glext.h:1711)
GL_BGR_EXT = 32992 	# GL/glext.h:1712
GL_BGRA_EXT = 32993 	# GL/glext.h:1713
# SGIX_async (GL/glext.h:1716)
GL_ASYNC_MARKER_SGIX = 33577 	# GL/glext.h:1717
# SGIX_async_pixel (GL/glext.h:1720)
GL_ASYNC_TEX_IMAGE_SGIX = 33628 	# GL/glext.h:1721
GL_ASYNC_DRAW_PIXELS_SGIX = 33629 	# GL/glext.h:1722
GL_ASYNC_READ_PIXELS_SGIX = 33630 	# GL/glext.h:1723
GL_MAX_ASYNC_TEX_IMAGE_SGIX = 33631 	# GL/glext.h:1724
GL_MAX_ASYNC_DRAW_PIXELS_SGIX = 33632 	# GL/glext.h:1725
GL_MAX_ASYNC_READ_PIXELS_SGIX = 33633 	# GL/glext.h:1726
# SGIX_async_histogram (GL/glext.h:1729)
GL_ASYNC_HISTOGRAM_SGIX = 33580 	# GL/glext.h:1730
GL_MAX_ASYNC_HISTOGRAM_SGIX = 33581 	# GL/glext.h:1731
# INTEL_texture_scissor (GL/glext.h:1734)
# INTEL_parallel_arrays (GL/glext.h:1737)
GL_PARALLEL_ARRAYS_INTEL = 33780 	# GL/glext.h:1738
GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL = 33781 	# GL/glext.h:1739
GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL = 33782 	# GL/glext.h:1740
GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL = 33783 	# GL/glext.h:1741
GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL = 33784 	# GL/glext.h:1742
# HP_occlusion_test (GL/glext.h:1745)
GL_OCCLUSION_TEST_HP = 33125 	# GL/glext.h:1746
GL_OCCLUSION_TEST_RESULT_HP = 33126 	# GL/glext.h:1747
# EXT_pixel_transform (GL/glext.h:1750)
GL_PIXEL_TRANSFORM_2D_EXT = 33584 	# GL/glext.h:1751
GL_PIXEL_MAG_FILTER_EXT = 33585 	# GL/glext.h:1752
GL_PIXEL_MIN_FILTER_EXT = 33586 	# GL/glext.h:1753
GL_PIXEL_CUBIC_WEIGHT_EXT = 33587 	# GL/glext.h:1754
GL_CUBIC_EXT = 33588 	# GL/glext.h:1755
GL_AVERAGE_EXT = 33589 	# GL/glext.h:1756
GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = 33590 	# GL/glext.h:1757
GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = 33591 	# GL/glext.h:1758
GL_PIXEL_TRANSFORM_2D_MATRIX_EXT = 33592 	# GL/glext.h:1759
# EXT_pixel_transform_color_table (GL/glext.h:1762)
# EXT_shared_texture_palette (GL/glext.h:1765)
GL_SHARED_TEXTURE_PALETTE_EXT = 33275 	# GL/glext.h:1766
# EXT_separate_specular_color (GL/glext.h:1769)
GL_LIGHT_MODEL_COLOR_CONTROL_EXT = 33272 	# GL/glext.h:1770
GL_SINGLE_COLOR_EXT = 33273 	# GL/glext.h:1771
GL_SEPARATE_SPECULAR_COLOR_EXT = 33274 	# GL/glext.h:1772
# EXT_secondary_color (GL/glext.h:1775)
GL_COLOR_SUM_EXT = 33880 	# GL/glext.h:1776
GL_CURRENT_SECONDARY_COLOR_EXT = 33881 	# GL/glext.h:1777
GL_SECONDARY_COLOR_ARRAY_SIZE_EXT = 33882 	# GL/glext.h:1778
GL_SECONDARY_COLOR_ARRAY_TYPE_EXT = 33883 	# GL/glext.h:1779
GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT = 33884 	# GL/glext.h:1780
GL_SECONDARY_COLOR_ARRAY_POINTER_EXT = 33885 	# GL/glext.h:1781
GL_SECONDARY_COLOR_ARRAY_EXT = 33886 	# GL/glext.h:1782
# EXT_texture_perturb_normal (GL/glext.h:1785)
GL_PERTURB_EXT = 34222 	# GL/glext.h:1786
GL_TEXTURE_NORMAL_EXT = 34223 	# GL/glext.h:1787
# EXT_multi_draw_arrays (GL/glext.h:1790)
# EXT_fog_coord (GL/glext.h:1793)
GL_FOG_COORDINATE_SOURCE_EXT = 33872 	# GL/glext.h:1794
GL_FOG_COORDINATE_EXT = 33873 	# GL/glext.h:1795
GL_FRAGMENT_DEPTH_EXT = 33874 	# GL/glext.h:1796
GL_CURRENT_FOG_COORDINATE_EXT = 33875 	# GL/glext.h:1797
GL_FOG_COORDINATE_ARRAY_TYPE_EXT = 33876 	# GL/glext.h:1798
GL_FOG_COORDINATE_ARRAY_STRIDE_EXT = 33877 	# GL/glext.h:1799
GL_FOG_COORDINATE_ARRAY_POINTER_EXT = 33878 	# GL/glext.h:1800
GL_FOG_COORDINATE_ARRAY_EXT = 33879 	# GL/glext.h:1801
# REND_screen_coordinates (GL/glext.h:1804)
GL_SCREEN_COORDINATES_REND = 33936 	# GL/glext.h:1805
GL_INVERTED_SCREEN_W_REND = 33937 	# GL/glext.h:1806
# EXT_coordinate_frame (GL/glext.h:1809)
GL_TANGENT_ARRAY_EXT = 33849 	# GL/glext.h:1810
GL_BINORMAL_ARRAY_EXT = 33850 	# GL/glext.h:1811
GL_CURRENT_TANGENT_EXT = 33851 	# GL/glext.h:1812
GL_CURRENT_BINORMAL_EXT = 33852 	# GL/glext.h:1813
GL_TANGENT_ARRAY_TYPE_EXT = 33854 	# GL/glext.h:1814
GL_TANGENT_ARRAY_STRIDE_EXT = 33855 	# GL/glext.h:1815
GL_BINORMAL_ARRAY_TYPE_EXT = 33856 	# GL/glext.h:1816
GL_BINORMAL_ARRAY_STRIDE_EXT = 33857 	# GL/glext.h:1817
GL_TANGENT_ARRAY_POINTER_EXT = 33858 	# GL/glext.h:1818
GL_BINORMAL_ARRAY_POINTER_EXT = 33859 	# GL/glext.h:1819
GL_MAP1_TANGENT_EXT = 33860 	# GL/glext.h:1820
GL_MAP2_TANGENT_EXT = 33861 	# GL/glext.h:1821
GL_MAP1_BINORMAL_EXT = 33862 	# GL/glext.h:1822
GL_MAP2_BINORMAL_EXT = 33863 	# GL/glext.h:1823
# EXT_texture_env_combine (GL/glext.h:1826)
GL_COMBINE_EXT = 34160 	# GL/glext.h:1827
GL_COMBINE_RGB_EXT = 34161 	# GL/glext.h:1828
GL_COMBINE_ALPHA_EXT = 34162 	# GL/glext.h:1829
GL_RGB_SCALE_EXT = 34163 	# GL/glext.h:1830
GL_ADD_SIGNED_EXT = 34164 	# GL/glext.h:1831
GL_INTERPOLATE_EXT = 34165 	# GL/glext.h:1832
GL_CONSTANT_EXT = 34166 	# GL/glext.h:1833
GL_PRIMARY_COLOR_EXT = 34167 	# GL/glext.h:1834
GL_PREVIOUS_EXT = 34168 	# GL/glext.h:1835
GL_SOURCE0_RGB_EXT = 34176 	# GL/glext.h:1836
GL_SOURCE1_RGB_EXT = 34177 	# GL/glext.h:1837
GL_SOURCE2_RGB_EXT = 34178 	# GL/glext.h:1838
GL_SOURCE0_ALPHA_EXT = 34184 	# GL/glext.h:1839
GL_SOURCE1_ALPHA_EXT = 34185 	# GL/glext.h:1840
GL_SOURCE2_ALPHA_EXT = 34186 	# GL/glext.h:1841
GL_OPERAND0_RGB_EXT = 34192 	# GL/glext.h:1842
GL_OPERAND1_RGB_EXT = 34193 	# GL/glext.h:1843
GL_OPERAND2_RGB_EXT = 34194 	# GL/glext.h:1844
GL_OPERAND0_ALPHA_EXT = 34200 	# GL/glext.h:1845
GL_OPERAND1_ALPHA_EXT = 34201 	# GL/glext.h:1846
GL_OPERAND2_ALPHA_EXT = 34202 	# GL/glext.h:1847
# APPLE_specular_vector (GL/glext.h:1850)
GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE = 34224 	# GL/glext.h:1851
# APPLE_transform_hint (GL/glext.h:1854)
GL_TRANSFORM_HINT_APPLE = 34225 	# GL/glext.h:1855
# SGIX_fog_scale (GL/glext.h:1858)
GL_FOG_SCALE_SGIX = 33276 	# GL/glext.h:1859
GL_FOG_SCALE_VALUE_SGIX = 33277 	# GL/glext.h:1860
# SUNX_constant_data (GL/glext.h:1863)
GL_UNPACK_CONSTANT_DATA_SUNX = 33237 	# GL/glext.h:1864
GL_TEXTURE_CONSTANT_DATA_SUNX = 33238 	# GL/glext.h:1865
# SUN_global_alpha (GL/glext.h:1868)
GL_GLOBAL_ALPHA_SUN = 33241 	# GL/glext.h:1869
GL_GLOBAL_ALPHA_FACTOR_SUN = 33242 	# GL/glext.h:1870
# SUN_triangle_list (GL/glext.h:1873)
GL_RESTART_SUN = 1 	# GL/glext.h:1874
GL_REPLACE_MIDDLE_SUN = 2 	# GL/glext.h:1875
GL_REPLACE_OLDEST_SUN = 3 	# GL/glext.h:1876
GL_TRIANGLE_LIST_SUN = 33239 	# GL/glext.h:1877
GL_REPLACEMENT_CODE_SUN = 33240 	# GL/glext.h:1878
GL_REPLACEMENT_CODE_ARRAY_SUN = 34240 	# GL/glext.h:1879
GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN = 34241 	# GL/glext.h:1880
GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN = 34242 	# GL/glext.h:1881
GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN = 34243 	# GL/glext.h:1882
GL_R1UI_V3F_SUN = 34244 	# GL/glext.h:1883
GL_R1UI_C4UB_V3F_SUN = 34245 	# GL/glext.h:1884
GL_R1UI_C3F_V3F_SUN = 34246 	# GL/glext.h:1885
GL_R1UI_N3F_V3F_SUN = 34247 	# GL/glext.h:1886
GL_R1UI_C4F_N3F_V3F_SUN = 34248 	# GL/glext.h:1887
GL_R1UI_T2F_V3F_SUN = 34249 	# GL/glext.h:1888
GL_R1UI_T2F_N3F_V3F_SUN = 34250 	# GL/glext.h:1889
GL_R1UI_T2F_C4F_N3F_V3F_SUN = 34251 	# GL/glext.h:1890
# SUN_vertex (GL/glext.h:1893)
# EXT_blend_func_separate (GL/glext.h:1896)
GL_BLEND_DST_RGB_EXT = 32968 	# GL/glext.h:1897
GL_BLEND_SRC_RGB_EXT = 32969 	# GL/glext.h:1898
GL_BLEND_DST_ALPHA_EXT = 32970 	# GL/glext.h:1899
GL_BLEND_SRC_ALPHA_EXT = 32971 	# GL/glext.h:1900
# INGR_color_clamp (GL/glext.h:1903)
GL_RED_MIN_CLAMP_INGR = 34144 	# GL/glext.h:1904
GL_GREEN_MIN_CLAMP_INGR = 34145 	# GL/glext.h:1905
GL_BLUE_MIN_CLAMP_INGR = 34146 	# GL/glext.h:1906
GL_ALPHA_MIN_CLAMP_INGR = 34147 	# GL/glext.h:1907
GL_RED_MAX_CLAMP_INGR = 34148 	# GL/glext.h:1908
GL_GREEN_MAX_CLAMP_INGR = 34149 	# GL/glext.h:1909
GL_BLUE_MAX_CLAMP_INGR = 34150 	# GL/glext.h:1910
GL_ALPHA_MAX_CLAMP_INGR = 34151 	# GL/glext.h:1911
# INGR_interlace_read (GL/glext.h:1914)
GL_INTERLACE_READ_INGR = 34152 	# GL/glext.h:1915
# EXT_stencil_wrap (GL/glext.h:1918)
GL_INCR_WRAP_EXT = 34055 	# GL/glext.h:1919
GL_DECR_WRAP_EXT = 34056 	# GL/glext.h:1920
# EXT_422_pixels (GL/glext.h:1923)
GL_422_EXT = 32972 	# GL/glext.h:1924
GL_422_REV_EXT = 32973 	# GL/glext.h:1925
GL_422_AVERAGE_EXT = 32974 	# GL/glext.h:1926
GL_422_REV_AVERAGE_EXT = 32975 	# GL/glext.h:1927
# NV_texgen_reflection (GL/glext.h:1930)
GL_NORMAL_MAP_NV = 34065 	# GL/glext.h:1931
GL_REFLECTION_MAP_NV = 34066 	# GL/glext.h:1932
# EXT_texture_cube_map (GL/glext.h:1935)
GL_NORMAL_MAP_EXT = 34065 	# GL/glext.h:1936
GL_REFLECTION_MAP_EXT = 34066 	# GL/glext.h:1937
GL_TEXTURE_CUBE_MAP_EXT = 34067 	# GL/glext.h:1938
GL_TEXTURE_BINDING_CUBE_MAP_EXT = 34068 	# GL/glext.h:1939
GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT = 34069 	# GL/glext.h:1940
GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT = 34070 	# GL/glext.h:1941
GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT = 34071 	# GL/glext.h:1942
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT = 34072 	# GL/glext.h:1943
GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT = 34073 	# GL/glext.h:1944
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT = 34074 	# GL/glext.h:1945
GL_PROXY_TEXTURE_CUBE_MAP_EXT = 34075 	# GL/glext.h:1946
GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT = 34076 	# GL/glext.h:1947
# SUN_convolution_border_modes (GL/glext.h:1950)
GL_WRAP_BORDER_SUN = 33236 	# GL/glext.h:1951
# EXT_texture_env_add (GL/glext.h:1954)
# EXT_texture_lod_bias (GL/glext.h:1957)
GL_MAX_TEXTURE_LOD_BIAS_EXT = 34045 	# GL/glext.h:1958
GL_TEXTURE_FILTER_CONTROL_EXT = 34048 	# GL/glext.h:1959
GL_TEXTURE_LOD_BIAS_EXT = 34049 	# GL/glext.h:1960
# EXT_texture_filter_anisotropic (GL/glext.h:1963)
GL_TEXTURE_MAX_ANISOTROPY_EXT = 34046 	# GL/glext.h:1964
GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047 	# GL/glext.h:1965
# EXT_vertex_weighting (GL/glext.h:1968)
GL_MODELVIEW0_STACK_DEPTH_EXT = 0 	# GL/glext.h:1969
GL_MODELVIEW1_STACK_DEPTH_EXT = 34050 	# GL/glext.h:1970
GL_MODELVIEW0_MATRIX_EXT = 0 	# GL/glext.h:1971
GL_MODELVIEW1_MATRIX_EXT = 34054 	# GL/glext.h:1972
GL_VERTEX_WEIGHTING_EXT = 34057 	# GL/glext.h:1973
GL_MODELVIEW0_EXT = 0 	# GL/glext.h:1974
GL_MODELVIEW1_EXT = 34058 	# GL/glext.h:1975
GL_CURRENT_VERTEX_WEIGHT_EXT = 34059 	# GL/glext.h:1976
GL_VERTEX_WEIGHT_ARRAY_EXT = 34060 	# GL/glext.h:1977
GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT = 34061 	# GL/glext.h:1978
GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT = 34062 	# GL/glext.h:1979
GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT = 34063 	# GL/glext.h:1980
GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT = 34064 	# GL/glext.h:1981
# NV_light_max_exponent (GL/glext.h:1984)
GL_MAX_SHININESS_NV = 34052 	# GL/glext.h:1985
GL_MAX_SPOT_EXPONENT_NV = 34053 	# GL/glext.h:1986
# NV_vertex_array_range (GL/glext.h:1989)
GL_VERTEX_ARRAY_RANGE_NV = 34077 	# GL/glext.h:1990
GL_VERTEX_ARRAY_RANGE_LENGTH_NV = 34078 	# GL/glext.h:1991
GL_VERTEX_ARRAY_RANGE_VALID_NV = 34079 	# GL/glext.h:1992
GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV = 34080 	# GL/glext.h:1993
GL_VERTEX_ARRAY_RANGE_POINTER_NV = 34081 	# GL/glext.h:1994
# NV_register_combiners (GL/glext.h:1997)
GL_REGISTER_COMBINERS_NV = 34082 	# GL/glext.h:1998
GL_VARIABLE_A_NV = 34083 	# GL/glext.h:1999
GL_VARIABLE_B_NV = 34084 	# GL/glext.h:2000
GL_VARIABLE_C_NV = 34085 	# GL/glext.h:2001
GL_VARIABLE_D_NV = 34086 	# GL/glext.h:2002
GL_VARIABLE_E_NV = 34087 	# GL/glext.h:2003
GL_VARIABLE_F_NV = 34088 	# GL/glext.h:2004
GL_VARIABLE_G_NV = 34089 	# GL/glext.h:2005
GL_CONSTANT_COLOR0_NV = 34090 	# GL/glext.h:2006
GL_CONSTANT_COLOR1_NV = 34091 	# GL/glext.h:2007
GL_PRIMARY_COLOR_NV = 34092 	# GL/glext.h:2008
GL_SECONDARY_COLOR_NV = 34093 	# GL/glext.h:2009
GL_SPARE0_NV = 34094 	# GL/glext.h:2010
GL_SPARE1_NV = 34095 	# GL/glext.h:2011
GL_DISCARD_NV = 34096 	# GL/glext.h:2012
GL_E_TIMES_F_NV = 34097 	# GL/glext.h:2013
GL_SPARE0_PLUS_SECONDARY_COLOR_NV = 34098 	# GL/glext.h:2014
GL_UNSIGNED_IDENTITY_NV = 34102 	# GL/glext.h:2015
GL_UNSIGNED_INVERT_NV = 34103 	# GL/glext.h:2016
GL_EXPAND_NORMAL_NV = 34104 	# GL/glext.h:2017
GL_EXPAND_NEGATE_NV = 34105 	# GL/glext.h:2018
GL_HALF_BIAS_NORMAL_NV = 34106 	# GL/glext.h:2019
GL_HALF_BIAS_NEGATE_NV = 34107 	# GL/glext.h:2020
GL_SIGNED_IDENTITY_NV = 34108 	# GL/glext.h:2021
GL_SIGNED_NEGATE_NV = 34109 	# GL/glext.h:2022
GL_SCALE_BY_TWO_NV = 34110 	# GL/glext.h:2023
GL_SCALE_BY_FOUR_NV = 34111 	# GL/glext.h:2024
GL_SCALE_BY_ONE_HALF_NV = 34112 	# GL/glext.h:2025
GL_BIAS_BY_NEGATIVE_ONE_HALF_NV = 34113 	# GL/glext.h:2026
GL_COMBINER_INPUT_NV = 34114 	# GL/glext.h:2027
GL_COMBINER_MAPPING_NV = 34115 	# GL/glext.h:2028
GL_COMBINER_COMPONENT_USAGE_NV = 34116 	# GL/glext.h:2029
GL_COMBINER_AB_DOT_PRODUCT_NV = 34117 	# GL/glext.h:2030
GL_COMBINER_CD_DOT_PRODUCT_NV = 34118 	# GL/glext.h:2031
GL_COMBINER_MUX_SUM_NV = 34119 	# GL/glext.h:2032
GL_COMBINER_SCALE_NV = 34120 	# GL/glext.h:2033
GL_COMBINER_BIAS_NV = 34121 	# GL/glext.h:2034
GL_COMBINER_AB_OUTPUT_NV = 34122 	# GL/glext.h:2035
GL_COMBINER_CD_OUTPUT_NV = 34123 	# GL/glext.h:2036
GL_COMBINER_SUM_OUTPUT_NV = 34124 	# GL/glext.h:2037
GL_MAX_GENERAL_COMBINERS_NV = 34125 	# GL/glext.h:2038
GL_NUM_GENERAL_COMBINERS_NV = 34126 	# GL/glext.h:2039
GL_COLOR_SUM_CLAMP_NV = 34127 	# GL/glext.h:2040
GL_COMBINER0_NV = 34128 	# GL/glext.h:2041
GL_COMBINER1_NV = 34129 	# GL/glext.h:2042
GL_COMBINER2_NV = 34130 	# GL/glext.h:2043
GL_COMBINER3_NV = 34131 	# GL/glext.h:2044
GL_COMBINER4_NV = 34132 	# GL/glext.h:2045
GL_COMBINER5_NV = 34133 	# GL/glext.h:2046
GL_COMBINER6_NV = 34134 	# GL/glext.h:2047
GL_COMBINER7_NV = 34135 	# GL/glext.h:2048
# NV_fog_distance (GL/glext.h:2056)
GL_FOG_DISTANCE_MODE_NV = 34138 	# GL/glext.h:2057
GL_EYE_RADIAL_NV = 34139 	# GL/glext.h:2058
GL_EYE_PLANE_ABSOLUTE_NV = 34140 	# GL/glext.h:2059
# NV_texgen_emboss (GL/glext.h:2063)
GL_EMBOSS_LIGHT_NV = 34141 	# GL/glext.h:2064
GL_EMBOSS_CONSTANT_NV = 34142 	# GL/glext.h:2065
GL_EMBOSS_MAP_NV = 34143 	# GL/glext.h:2066
# NV_blend_square (GL/glext.h:2069)
# NV_texture_env_combine4 (GL/glext.h:2072)
GL_COMBINE4_NV = 34051 	# GL/glext.h:2073
GL_SOURCE3_RGB_NV = 34179 	# GL/glext.h:2074
GL_SOURCE3_ALPHA_NV = 34187 	# GL/glext.h:2075
GL_OPERAND3_RGB_NV = 34195 	# GL/glext.h:2076
GL_OPERAND3_ALPHA_NV = 34203 	# GL/glext.h:2077
# MESA_resize_buffers (GL/glext.h:2080)
# MESA_window_pos (GL/glext.h:2083)
# EXT_texture_compression_s3tc (GL/glext.h:2086)
GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 33776 	# GL/glext.h:2087
GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777 	# GL/glext.h:2088
GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778 	# GL/glext.h:2089
GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779 	# GL/glext.h:2090
# IBM_cull_vertex (GL/glext.h:2093)
GL_CULL_VERTEX_IBM = 103050 	# GL/glext.h:2094
# IBM_multimode_draw_arrays (GL/glext.h:2097)
# IBM_vertex_array_lists (GL/glext.h:2100)
GL_VERTEX_ARRAY_LIST_IBM = 103070 	# GL/glext.h:2101
GL_NORMAL_ARRAY_LIST_IBM = 103071 	# GL/glext.h:2102
GL_COLOR_ARRAY_LIST_IBM = 103072 	# GL/glext.h:2103
GL_INDEX_ARRAY_LIST_IBM = 103073 	# GL/glext.h:2104
GL_TEXTURE_COORD_ARRAY_LIST_IBM = 103074 	# GL/glext.h:2105
GL_EDGE_FLAG_ARRAY_LIST_IBM = 103075 	# GL/glext.h:2106
GL_FOG_COORDINATE_ARRAY_LIST_IBM = 103076 	# GL/glext.h:2107
GL_SECONDARY_COLOR_ARRAY_LIST_IBM = 103077 	# GL/glext.h:2108
GL_VERTEX_ARRAY_LIST_STRIDE_IBM = 103080 	# GL/glext.h:2109
GL_NORMAL_ARRAY_LIST_STRIDE_IBM = 103081 	# GL/glext.h:2110
GL_COLOR_ARRAY_LIST_STRIDE_IBM = 103082 	# GL/glext.h:2111
GL_INDEX_ARRAY_LIST_STRIDE_IBM = 103083 	# GL/glext.h:2112
GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM = 103084 	# GL/glext.h:2113
GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM = 103085 	# GL/glext.h:2114
GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM = 103086 	# GL/glext.h:2115
GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM = 103087 	# GL/glext.h:2116
# SGIX_subsample (GL/glext.h:2119)
GL_PACK_SUBSAMPLE_RATE_SGIX = 34208 	# GL/glext.h:2120
GL_UNPACK_SUBSAMPLE_RATE_SGIX = 34209 	# GL/glext.h:2121
GL_PIXEL_SUBSAMPLE_4444_SGIX = 34210 	# GL/glext.h:2122
GL_PIXEL_SUBSAMPLE_2424_SGIX = 34211 	# GL/glext.h:2123
GL_PIXEL_SUBSAMPLE_4242_SGIX = 34212 	# GL/glext.h:2124
# SGIX_ycrcb_subsample (GL/glext.h:2127)
# SGIX_ycrcba (GL/glext.h:2130)
GL_YCRCB_SGIX = 33560 	# GL/glext.h:2131
GL_YCRCBA_SGIX = 33561 	# GL/glext.h:2132
# SGI_depth_pass_instrument (GL/glext.h:2135)
GL_DEPTH_PASS_INSTRUMENT_SGIX = 33552 	# GL/glext.h:2136
GL_DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX = 33553 	# GL/glext.h:2137
GL_DEPTH_PASS_INSTRUMENT_MAX_SGIX = 33554 	# GL/glext.h:2138
# 3DFX_texture_compression_FXT1 (GL/glext.h:2141)
GL_COMPRESSED_RGB_FXT1_3DFX = 34480 	# GL/glext.h:2142
GL_COMPRESSED_RGBA_FXT1_3DFX = 34481 	# GL/glext.h:2143
# 3DFX_multisample (GL/glext.h:2146)
GL_MULTISAMPLE_3DFX = 34482 	# GL/glext.h:2147
GL_SAMPLE_BUFFERS_3DFX = 34483 	# GL/glext.h:2148
GL_SAMPLES_3DFX = 34484 	# GL/glext.h:2149
GL_MULTISAMPLE_BIT_3DFX = 536870912 	# GL/glext.h:2150
# 3DFX_tbuffer (GL/glext.h:2153)
# EXT_multisample (GL/glext.h:2156)
GL_MULTISAMPLE_EXT = 32925 	# GL/glext.h:2157
GL_SAMPLE_ALPHA_TO_MASK_EXT = 32926 	# GL/glext.h:2158
GL_SAMPLE_ALPHA_TO_ONE_EXT = 32927 	# GL/glext.h:2159
GL_SAMPLE_MASK_EXT = 32928 	# GL/glext.h:2160
GL_1PASS_EXT = 32929 	# GL/glext.h:2161
GL_2PASS_0_EXT = 32930 	# GL/glext.h:2162
GL_2PASS_1_EXT = 32931 	# GL/glext.h:2163
GL_4PASS_0_EXT = 32932 	# GL/glext.h:2164
GL_4PASS_1_EXT = 32933 	# GL/glext.h:2165
GL_4PASS_2_EXT = 32934 	# GL/glext.h:2166
GL_4PASS_3_EXT = 32935 	# GL/glext.h:2167
GL_SAMPLE_BUFFERS_EXT = 32936 	# GL/glext.h:2168
GL_SAMPLES_EXT = 32937 	# GL/glext.h:2169
GL_SAMPLE_MASK_VALUE_EXT = 32938 	# GL/glext.h:2170
GL_SAMPLE_MASK_INVERT_EXT = 32939 	# GL/glext.h:2171
GL_SAMPLE_PATTERN_EXT = 32940 	# GL/glext.h:2172
GL_MULTISAMPLE_BIT_EXT = 536870912 	# GL/glext.h:2173
# SGIX_vertex_preclip (GL/glext.h:2176)
GL_VERTEX_PRECLIP_SGIX = 33774 	# GL/glext.h:2177
GL_VERTEX_PRECLIP_HINT_SGIX = 33775 	# GL/glext.h:2178
# SGIX_convolution_accuracy (GL/glext.h:2181)
GL_CONVOLUTION_HINT_SGIX = 33558 	# GL/glext.h:2182
# SGIX_resample (GL/glext.h:2185)
GL_PACK_RESAMPLE_SGIX = 33836 	# GL/glext.h:2186
GL_UNPACK_RESAMPLE_SGIX = 33837 	# GL/glext.h:2187
GL_RESAMPLE_REPLICATE_SGIX = 33838 	# GL/glext.h:2188
GL_RESAMPLE_ZERO_FILL_SGIX = 33839 	# GL/glext.h:2189
GL_RESAMPLE_DECIMATE_SGIX = 33840 	# GL/glext.h:2190
# SGIS_point_line_texgen (GL/glext.h:2193)
GL_EYE_DISTANCE_TO_POINT_SGIS = 33264 	# GL/glext.h:2194
GL_OBJECT_DISTANCE_TO_POINT_SGIS = 33265 	# GL/glext.h:2195
GL_EYE_DISTANCE_TO_LINE_SGIS = 33266 	# GL/glext.h:2196
GL_OBJECT_DISTANCE_TO_LINE_SGIS = 33267 	# GL/glext.h:2197
GL_EYE_POINT_SGIS = 33268 	# GL/glext.h:2198
GL_OBJECT_POINT_SGIS = 33269 	# GL/glext.h:2199
GL_EYE_LINE_SGIS = 33270 	# GL/glext.h:2200
GL_OBJECT_LINE_SGIS = 33271 	# GL/glext.h:2201
# SGIS_texture_color_mask (GL/glext.h:2204)
GL_TEXTURE_COLOR_WRITEMASK_SGIS = 33263 	# GL/glext.h:2205
# EXT_texture_env_dot3 (GL/glext.h:2208)
GL_DOT3_RGB_EXT = 34624 	# GL/glext.h:2209
GL_DOT3_RGBA_EXT = 34625 	# GL/glext.h:2210
# ATI_texture_mirror_once (GL/glext.h:2213)
GL_MIRROR_CLAMP_ATI = 34626 	# GL/glext.h:2214
GL_MIRROR_CLAMP_TO_EDGE_ATI = 34627 	# GL/glext.h:2215
# NV_fence (GL/glext.h:2218)
GL_ALL_COMPLETED_NV = 34034 	# GL/glext.h:2219
GL_FENCE_STATUS_NV = 34035 	# GL/glext.h:2220
GL_FENCE_CONDITION_NV = 34036 	# GL/glext.h:2221
# IBM_texture_mirrored_repeat (GL/glext.h:2224)
GL_MIRRORED_REPEAT_IBM = 33648 	# GL/glext.h:2225
# NV_evaluators (GL/glext.h:2228)
GL_EVAL_2D_NV = 34496 	# GL/glext.h:2229
GL_EVAL_TRIANGULAR_2D_NV = 34497 	# GL/glext.h:2230
GL_MAP_TESSELLATION_NV = 34498 	# GL/glext.h:2231
GL_MAP_ATTRIB_U_ORDER_NV = 34499 	# GL/glext.h:2232
GL_MAP_ATTRIB_V_ORDER_NV = 34500 	# GL/glext.h:2233
GL_EVAL_FRACTIONAL_TESSELLATION_NV = 34501 	# GL/glext.h:2234
GL_EVAL_VERTEX_ATTRIB0_NV = 34502 	# GL/glext.h:2235
GL_EVAL_VERTEX_ATTRIB1_NV = 34503 	# GL/glext.h:2236
GL_EVAL_VERTEX_ATTRIB2_NV = 34504 	# GL/glext.h:2237
GL_EVAL_VERTEX_ATTRIB3_NV = 34505 	# GL/glext.h:2238
GL_EVAL_VERTEX_ATTRIB4_NV = 34506 	# GL/glext.h:2239
GL_EVAL_VERTEX_ATTRIB5_NV = 34507 	# GL/glext.h:2240
GL_EVAL_VERTEX_ATTRIB6_NV = 34508 	# GL/glext.h:2241
GL_EVAL_VERTEX_ATTRIB7_NV = 34509 	# GL/glext.h:2242
GL_EVAL_VERTEX_ATTRIB8_NV = 34510 	# GL/glext.h:2243
GL_EVAL_VERTEX_ATTRIB9_NV = 34511 	# GL/glext.h:2244
GL_EVAL_VERTEX_ATTRIB10_NV = 34512 	# GL/glext.h:2245
GL_EVAL_VERTEX_ATTRIB11_NV = 34513 	# GL/glext.h:2246
GL_EVAL_VERTEX_ATTRIB12_NV = 34514 	# GL/glext.h:2247
GL_EVAL_VERTEX_ATTRIB13_NV = 34515 	# GL/glext.h:2248
GL_EVAL_VERTEX_ATTRIB14_NV = 34516 	# GL/glext.h:2249
GL_EVAL_VERTEX_ATTRIB15_NV = 34517 	# GL/glext.h:2250
GL_MAX_MAP_TESSELLATION_NV = 34518 	# GL/glext.h:2251
GL_MAX_RATIONAL_EVAL_ORDER_NV = 34519 	# GL/glext.h:2252
# NV_packed_depth_stencil (GL/glext.h:2255)
GL_DEPTH_STENCIL_NV = 34041 	# GL/glext.h:2256
GL_UNSIGNED_INT_24_8_NV = 34042 	# GL/glext.h:2257
# NV_register_combiners2 (GL/glext.h:2260)
GL_PER_STAGE_CONSTANTS_NV = 34101 	# GL/glext.h:2261
# NV_texture_compression_vtc (GL/glext.h:2264)
# NV_texture_rectangle (GL/glext.h:2267)
GL_TEXTURE_RECTANGLE_NV = 34037 	# GL/glext.h:2268
GL_TEXTURE_BINDING_RECTANGLE_NV = 34038 	# GL/glext.h:2269
GL_PROXY_TEXTURE_RECTANGLE_NV = 34039 	# GL/glext.h:2270
GL_MAX_RECTANGLE_TEXTURE_SIZE_NV = 34040 	# GL/glext.h:2271
# NV_texture_shader (GL/glext.h:2274)
GL_OFFSET_TEXTURE_RECTANGLE_NV = 34380 	# GL/glext.h:2275
GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV = 34381 	# GL/glext.h:2276
GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV = 34382 	# GL/glext.h:2277
GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV = 34521 	# GL/glext.h:2278
GL_UNSIGNED_INT_S8_S8_8_8_NV = 34522 	# GL/glext.h:2279
GL_UNSIGNED_INT_8_8_S8_S8_REV_NV = 34523 	# GL/glext.h:2280
GL_DSDT_MAG_INTENSITY_NV = 34524 	# GL/glext.h:2281
GL_SHADER_CONSISTENT_NV = 34525 	# GL/glext.h:2282
GL_TEXTURE_SHADER_NV = 34526 	# GL/glext.h:2283
GL_SHADER_OPERATION_NV = 34527 	# GL/glext.h:2284
GL_CULL_MODES_NV = 34528 	# GL/glext.h:2285
GL_OFFSET_TEXTURE_MATRIX_NV = 34529 	# GL/glext.h:2286
GL_OFFSET_TEXTURE_SCALE_NV = 34530 	# GL/glext.h:2287
GL_OFFSET_TEXTURE_BIAS_NV = 34531 	# GL/glext.h:2288
GL_OFFSET_TEXTURE_2D_MATRIX_NV = 34529 	# GL/glext.h:2289
GL_OFFSET_TEXTURE_2D_SCALE_NV = 34530 	# GL/glext.h:2290
GL_OFFSET_TEXTURE_2D_BIAS_NV = 34531 	# GL/glext.h:2291
GL_PREVIOUS_TEXTURE_INPUT_NV = 34532 	# GL/glext.h:2292
GL_CONST_EYE_NV = 34533 	# GL/glext.h:2293
GL_PASS_THROUGH_NV = 34534 	# GL/glext.h:2294
GL_CULL_FRAGMENT_NV = 34535 	# GL/glext.h:2295
GL_OFFSET_TEXTURE_2D_NV = 34536 	# GL/glext.h:2296
GL_DEPENDENT_AR_TEXTURE_2D_NV = 34537 	# GL/glext.h:2297
GL_DEPENDENT_GB_TEXTURE_2D_NV = 34538 	# GL/glext.h:2298
GL_DOT_PRODUCT_NV = 34540 	# GL/glext.h:2299
GL_DOT_PRODUCT_DEPTH_REPLACE_NV = 34541 	# GL/glext.h:2300
GL_DOT_PRODUCT_TEXTURE_2D_NV = 34542 	# GL/glext.h:2301
GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV = 34544 	# GL/glext.h:2302
GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV = 34545 	# GL/glext.h:2303
GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV = 34546 	# GL/glext.h:2304
GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV = 34547 	# GL/glext.h:2305
GL_HILO_NV = 34548 	# GL/glext.h:2306
GL_DSDT_NV = 34549 	# GL/glext.h:2307
GL_DSDT_MAG_NV = 34550 	# GL/glext.h:2308
GL_DSDT_MAG_VIB_NV = 34551 	# GL/glext.h:2309
GL_HILO16_NV = 34552 	# GL/glext.h:2310
GL_SIGNED_HILO_NV = 34553 	# GL/glext.h:2311
GL_SIGNED_HILO16_NV = 34554 	# GL/glext.h:2312
GL_SIGNED_RGBA_NV = 34555 	# GL/glext.h:2313
GL_SIGNED_RGBA8_NV = 34556 	# GL/glext.h:2314
GL_SIGNED_RGB_NV = 34558 	# GL/glext.h:2315
GL_SIGNED_RGB8_NV = 34559 	# GL/glext.h:2316
GL_SIGNED_LUMINANCE_NV = 34561 	# GL/glext.h:2317
GL_SIGNED_LUMINANCE8_NV = 34562 	# GL/glext.h:2318
GL_SIGNED_LUMINANCE_ALPHA_NV = 34563 	# GL/glext.h:2319
GL_SIGNED_LUMINANCE8_ALPHA8_NV = 34564 	# GL/glext.h:2320
GL_SIGNED_ALPHA_NV = 34565 	# GL/glext.h:2321
GL_SIGNED_ALPHA8_NV = 34566 	# GL/glext.h:2322
GL_SIGNED_INTENSITY_NV = 34567 	# GL/glext.h:2323
GL_SIGNED_INTENSITY8_NV = 34568 	# GL/glext.h:2324
GL_DSDT8_NV = 34569 	# GL/glext.h:2325
GL_DSDT8_MAG8_NV = 34570 	# GL/glext.h:2326
GL_DSDT8_MAG8_INTENSITY8_NV = 34571 	# GL/glext.h:2327
GL_SIGNED_RGB_UNSIGNED_ALPHA_NV = 34572 	# GL/glext.h:2328
GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV = 34573 	# GL/glext.h:2329
GL_HI_SCALE_NV = 34574 	# GL/glext.h:2330
GL_LO_SCALE_NV = 34575 	# GL/glext.h:2331
GL_DS_SCALE_NV = 34576 	# GL/glext.h:2332
GL_DT_SCALE_NV = 34577 	# GL/glext.h:2333
GL_MAGNITUDE_SCALE_NV = 34578 	# GL/glext.h:2334
GL_VIBRANCE_SCALE_NV = 34579 	# GL/glext.h:2335
GL_HI_BIAS_NV = 34580 	# GL/glext.h:2336
GL_LO_BIAS_NV = 34581 	# GL/glext.h:2337
GL_DS_BIAS_NV = 34582 	# GL/glext.h:2338
GL_DT_BIAS_NV = 34583 	# GL/glext.h:2339
GL_MAGNITUDE_BIAS_NV = 34584 	# GL/glext.h:2340
GL_VIBRANCE_BIAS_NV = 34585 	# GL/glext.h:2341
GL_TEXTURE_BORDER_VALUES_NV = 34586 	# GL/glext.h:2342
GL_TEXTURE_HI_SIZE_NV = 34587 	# GL/glext.h:2343
GL_TEXTURE_LO_SIZE_NV = 34588 	# GL/glext.h:2344
GL_TEXTURE_DS_SIZE_NV = 34589 	# GL/glext.h:2345
GL_TEXTURE_DT_SIZE_NV = 34590 	# GL/glext.h:2346
GL_TEXTURE_MAG_SIZE_NV = 34591 	# GL/glext.h:2347
# NV_texture_shader2 (GL/glext.h:2350)
GL_DOT_PRODUCT_TEXTURE_3D_NV = 34543 	# GL/glext.h:2351
# NV_vertex_array_range2 (GL/glext.h:2354)
GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV = 34099 	# GL/glext.h:2355
# NV_vertex_program (GL/glext.h:2358)
GL_VERTEX_PROGRAM_NV = 34336 	# GL/glext.h:2359
GL_VERTEX_STATE_PROGRAM_NV = 34337 	# GL/glext.h:2360
GL_ATTRIB_ARRAY_SIZE_NV = 34339 	# GL/glext.h:2361
GL_ATTRIB_ARRAY_STRIDE_NV = 34340 	# GL/glext.h:2362
GL_ATTRIB_ARRAY_TYPE_NV = 34341 	# GL/glext.h:2363
GL_CURRENT_ATTRIB_NV = 34342 	# GL/glext.h:2364
GL_PROGRAM_LENGTH_NV = 34343 	# GL/glext.h:2365
GL_PROGRAM_STRING_NV = 34344 	# GL/glext.h:2366
GL_MODELVIEW_PROJECTION_NV = 34345 	# GL/glext.h:2367
GL_IDENTITY_NV = 34346 	# GL/glext.h:2368
GL_INVERSE_NV = 34347 	# GL/glext.h:2369
GL_TRANSPOSE_NV = 34348 	# GL/glext.h:2370
GL_INVERSE_TRANSPOSE_NV = 34349 	# GL/glext.h:2371
GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV = 34350 	# GL/glext.h:2372
GL_MAX_TRACK_MATRICES_NV = 34351 	# GL/glext.h:2373
GL_MATRIX0_NV = 34352 	# GL/glext.h:2374
GL_MATRIX1_NV = 34353 	# GL/glext.h:2375
GL_MATRIX2_NV = 34354 	# GL/glext.h:2376
GL_MATRIX3_NV = 34355 	# GL/glext.h:2377
GL_MATRIX4_NV = 34356 	# GL/glext.h:2378
GL_MATRIX5_NV = 34357 	# GL/glext.h:2379
GL_MATRIX6_NV = 34358 	# GL/glext.h:2380
GL_MATRIX7_NV = 34359 	# GL/glext.h:2381
GL_CURRENT_MATRIX_STACK_DEPTH_NV = 34368 	# GL/glext.h:2382
GL_CURRENT_MATRIX_NV = 34369 	# GL/glext.h:2383
GL_VERTEX_PROGRAM_POINT_SIZE_NV = 34370 	# GL/glext.h:2384
GL_VERTEX_PROGRAM_TWO_SIDE_NV = 34371 	# GL/glext.h:2385
GL_PROGRAM_PARAMETER_NV = 34372 	# GL/glext.h:2386
GL_ATTRIB_ARRAY_POINTER_NV = 34373 	# GL/glext.h:2387
GL_PROGRAM_TARGET_NV = 34374 	# GL/glext.h:2388
GL_PROGRAM_RESIDENT_NV = 34375 	# GL/glext.h:2389
GL_TRACK_MATRIX_NV = 34376 	# GL/glext.h:2390
GL_TRACK_MATRIX_TRANSFORM_NV = 34377 	# GL/glext.h:2391
GL_VERTEX_PROGRAM_BINDING_NV = 34378 	# GL/glext.h:2392
GL_PROGRAM_ERROR_POSITION_NV = 34379 	# GL/glext.h:2393
GL_VERTEX_ATTRIB_ARRAY0_NV = 34384 	# GL/glext.h:2394
GL_VERTEX_ATTRIB_ARRAY1_NV = 34385 	# GL/glext.h:2395
GL_VERTEX_ATTRIB_ARRAY2_NV = 34386 	# GL/glext.h:2396
GL_VERTEX_ATTRIB_ARRAY3_NV = 34387 	# GL/glext.h:2397
GL_VERTEX_ATTRIB_ARRAY4_NV = 34388 	# GL/glext.h:2398
GL_VERTEX_ATTRIB_ARRAY5_NV = 34389 	# GL/glext.h:2399
GL_VERTEX_ATTRIB_ARRAY6_NV = 34390 	# GL/glext.h:2400
GL_VERTEX_ATTRIB_ARRAY7_NV = 34391 	# GL/glext.h:2401
GL_VERTEX_ATTRIB_ARRAY8_NV = 34392 	# GL/glext.h:2402
GL_VERTEX_ATTRIB_ARRAY9_NV = 34393 	# GL/glext.h:2403
GL_VERTEX_ATTRIB_ARRAY10_NV = 34394 	# GL/glext.h:2404
GL_VERTEX_ATTRIB_ARRAY11_NV = 34395 	# GL/glext.h:2405
GL_VERTEX_ATTRIB_ARRAY12_NV = 34396 	# GL/glext.h:2406
GL_VERTEX_ATTRIB_ARRAY13_NV = 34397 	# GL/glext.h:2407
GL_VERTEX_ATTRIB_ARRAY14_NV = 34398 	# GL/glext.h:2408
GL_VERTEX_ATTRIB_ARRAY15_NV = 34399 	# GL/glext.h:2409
GL_MAP1_VERTEX_ATTRIB0_4_NV = 34400 	# GL/glext.h:2410
GL_MAP1_VERTEX_ATTRIB1_4_NV = 34401 	# GL/glext.h:2411
GL_MAP1_VERTEX_ATTRIB2_4_NV = 34402 	# GL/glext.h:2412
GL_MAP1_VERTEX_ATTRIB3_4_NV = 34403 	# GL/glext.h:2413
GL_MAP1_VERTEX_ATTRIB4_4_NV = 34404 	# GL/glext.h:2414
GL_MAP1_VERTEX_ATTRIB5_4_NV = 34405 	# GL/glext.h:2415
GL_MAP1_VERTEX_ATTRIB6_4_NV = 34406 	# GL/glext.h:2416
GL_MAP1_VERTEX_ATTRIB7_4_NV = 34407 	# GL/glext.h:2417
GL_MAP1_VERTEX_ATTRIB8_4_NV = 34408 	# GL/glext.h:2418
GL_MAP1_VERTEX_ATTRIB9_4_NV = 34409 	# GL/glext.h:2419
GL_MAP1_VERTEX_ATTRIB10_4_NV = 34410 	# GL/glext.h:2420
GL_MAP1_VERTEX_ATTRIB11_4_NV = 34411 	# GL/glext.h:2421
GL_MAP1_VERTEX_ATTRIB12_4_NV = 34412 	# GL/glext.h:2422
GL_MAP1_VERTEX_ATTRIB13_4_NV = 34413 	# GL/glext.h:2423
GL_MAP1_VERTEX_ATTRIB14_4_NV = 34414 	# GL/glext.h:2424
GL_MAP1_VERTEX_ATTRIB15_4_NV = 34415 	# GL/glext.h:2425
GL_MAP2_VERTEX_ATTRIB0_4_NV = 34416 	# GL/glext.h:2426
GL_MAP2_VERTEX_ATTRIB1_4_NV = 34417 	# GL/glext.h:2427
GL_MAP2_VERTEX_ATTRIB2_4_NV = 34418 	# GL/glext.h:2428
GL_MAP2_VERTEX_ATTRIB3_4_NV = 34419 	# GL/glext.h:2429
GL_MAP2_VERTEX_ATTRIB4_4_NV = 34420 	# GL/glext.h:2430
GL_MAP2_VERTEX_ATTRIB5_4_NV = 34421 	# GL/glext.h:2431
GL_MAP2_VERTEX_ATTRIB6_4_NV = 34422 	# GL/glext.h:2432
GL_MAP2_VERTEX_ATTRIB7_4_NV = 34423 	# GL/glext.h:2433
GL_MAP2_VERTEX_ATTRIB8_4_NV = 34424 	# GL/glext.h:2434
GL_MAP2_VERTEX_ATTRIB9_4_NV = 34425 	# GL/glext.h:2435
GL_MAP2_VERTEX_ATTRIB10_4_NV = 34426 	# GL/glext.h:2436
GL_MAP2_VERTEX_ATTRIB11_4_NV = 34427 	# GL/glext.h:2437
GL_MAP2_VERTEX_ATTRIB12_4_NV = 34428 	# GL/glext.h:2438
GL_MAP2_VERTEX_ATTRIB13_4_NV = 34429 	# GL/glext.h:2439
GL_MAP2_VERTEX_ATTRIB14_4_NV = 34430 	# GL/glext.h:2440
GL_MAP2_VERTEX_ATTRIB15_4_NV = 34431 	# GL/glext.h:2441
# SGIX_texture_coordinate_clamp (GL/glext.h:2444)
GL_TEXTURE_MAX_CLAMP_S_SGIX = 33641 	# GL/glext.h:2445
GL_TEXTURE_MAX_CLAMP_T_SGIX = 33642 	# GL/glext.h:2446
GL_TEXTURE_MAX_CLAMP_R_SGIX = 33643 	# GL/glext.h:2447
# SGIX_scalebias_hint (GL/glext.h:2450)
GL_SCALEBIAS_HINT_SGIX = 33570 	# GL/glext.h:2451
# OML_interlace (GL/glext.h:2454)
GL_INTERLACE_OML = 35200 	# GL/glext.h:2455
GL_INTERLACE_READ_OML = 35201 	# GL/glext.h:2456
# OML_subsample (GL/glext.h:2459)
GL_FORMAT_SUBSAMPLE_24_24_OML = 35202 	# GL/glext.h:2460
GL_FORMAT_SUBSAMPLE_244_244_OML = 35203 	# GL/glext.h:2461
# OML_resample (GL/glext.h:2464)
GL_PACK_RESAMPLE_OML = 35204 	# GL/glext.h:2465
GL_UNPACK_RESAMPLE_OML = 35205 	# GL/glext.h:2466
GL_RESAMPLE_REPLICATE_OML = 35206 	# GL/glext.h:2467
GL_RESAMPLE_ZERO_FILL_OML = 35207 	# GL/glext.h:2468
GL_RESAMPLE_AVERAGE_OML = 35208 	# GL/glext.h:2469
GL_RESAMPLE_DECIMATE_OML = 35209 	# GL/glext.h:2470
# NV_copy_depth_to_color (GL/glext.h:2473)
GL_DEPTH_STENCIL_TO_RGBA_NV = 34926 	# GL/glext.h:2474
GL_DEPTH_STENCIL_TO_BGRA_NV = 34927 	# GL/glext.h:2475
# ATI_envmap_bumpmap (GL/glext.h:2478)
GL_BUMP_ROT_MATRIX_ATI = 34677 	# GL/glext.h:2479
GL_BUMP_ROT_MATRIX_SIZE_ATI = 34678 	# GL/glext.h:2480
GL_BUMP_NUM_TEX_UNITS_ATI = 34679 	# GL/glext.h:2481
GL_BUMP_TEX_UNITS_ATI = 34680 	# GL/glext.h:2482
GL_DUDV_ATI = 34681 	# GL/glext.h:2483
GL_DU8DV8_ATI = 34682 	# GL/glext.h:2484
GL_BUMP_ENVMAP_ATI = 34683 	# GL/glext.h:2485
GL_BUMP_TARGET_ATI = 34684 	# GL/glext.h:2486
# ATI_fragment_shader (GL/glext.h:2489)
GL_FRAGMENT_SHADER_ATI = 35104 	# GL/glext.h:2490
GL_REG_0_ATI = 35105 	# GL/glext.h:2491
GL_REG_1_ATI = 35106 	# GL/glext.h:2492
GL_REG_2_ATI = 35107 	# GL/glext.h:2493
GL_REG_3_ATI = 35108 	# GL/glext.h:2494
GL_REG_4_ATI = 35109 	# GL/glext.h:2495
GL_REG_5_ATI = 35110 	# GL/glext.h:2496
GL_REG_6_ATI = 35111 	# GL/glext.h:2497
GL_REG_7_ATI = 35112 	# GL/glext.h:2498
GL_REG_8_ATI = 35113 	# GL/glext.h:2499
GL_REG_9_ATI = 35114 	# GL/glext.h:2500
GL_REG_10_ATI = 35115 	# GL/glext.h:2501
GL_REG_11_ATI = 35116 	# GL/glext.h:2502
GL_REG_12_ATI = 35117 	# GL/glext.h:2503
GL_REG_13_ATI = 35118 	# GL/glext.h:2504
GL_REG_14_ATI = 35119 	# GL/glext.h:2505
GL_REG_15_ATI = 35120 	# GL/glext.h:2506
GL_REG_16_ATI = 35121 	# GL/glext.h:2507
GL_REG_17_ATI = 35122 	# GL/glext.h:2508
GL_REG_18_ATI = 35123 	# GL/glext.h:2509
GL_REG_19_ATI = 35124 	# GL/glext.h:2510
GL_REG_20_ATI = 35125 	# GL/glext.h:2511
GL_REG_21_ATI = 35126 	# GL/glext.h:2512
GL_REG_22_ATI = 35127 	# GL/glext.h:2513
GL_REG_23_ATI = 35128 	# GL/glext.h:2514
GL_REG_24_ATI = 35129 	# GL/glext.h:2515
GL_REG_25_ATI = 35130 	# GL/glext.h:2516
GL_REG_26_ATI = 35131 	# GL/glext.h:2517
GL_REG_27_ATI = 35132 	# GL/glext.h:2518
GL_REG_28_ATI = 35133 	# GL/glext.h:2519
GL_REG_29_ATI = 35134 	# GL/glext.h:2520
GL_REG_30_ATI = 35135 	# GL/glext.h:2521
GL_REG_31_ATI = 35136 	# GL/glext.h:2522
GL_CON_0_ATI = 35137 	# GL/glext.h:2523
GL_CON_1_ATI = 35138 	# GL/glext.h:2524
GL_CON_2_ATI = 35139 	# GL/glext.h:2525
GL_CON_3_ATI = 35140 	# GL/glext.h:2526
GL_CON_4_ATI = 35141 	# GL/glext.h:2527
GL_CON_5_ATI = 35142 	# GL/glext.h:2528
GL_CON_6_ATI = 35143 	# GL/glext.h:2529
GL_CON_7_ATI = 35144 	# GL/glext.h:2530
GL_CON_8_ATI = 35145 	# GL/glext.h:2531
GL_CON_9_ATI = 35146 	# GL/glext.h:2532
GL_CON_10_ATI = 35147 	# GL/glext.h:2533
GL_CON_11_ATI = 35148 	# GL/glext.h:2534
GL_CON_12_ATI = 35149 	# GL/glext.h:2535
GL_CON_13_ATI = 35150 	# GL/glext.h:2536
GL_CON_14_ATI = 35151 	# GL/glext.h:2537
GL_CON_15_ATI = 35152 	# GL/glext.h:2538
GL_CON_16_ATI = 35153 	# GL/glext.h:2539
GL_CON_17_ATI = 35154 	# GL/glext.h:2540
GL_CON_18_ATI = 35155 	# GL/glext.h:2541
GL_CON_19_ATI = 35156 	# GL/glext.h:2542
GL_CON_20_ATI = 35157 	# GL/glext.h:2543
GL_CON_21_ATI = 35158 	# GL/glext.h:2544
GL_CON_22_ATI = 35159 	# GL/glext.h:2545
GL_CON_23_ATI = 35160 	# GL/glext.h:2546
GL_CON_24_ATI = 35161 	# GL/glext.h:2547
GL_CON_25_ATI = 35162 	# GL/glext.h:2548
GL_CON_26_ATI = 35163 	# GL/glext.h:2549
GL_CON_27_ATI = 35164 	# GL/glext.h:2550
GL_CON_28_ATI = 35165 	# GL/glext.h:2551
GL_CON_29_ATI = 35166 	# GL/glext.h:2552
GL_CON_30_ATI = 35167 	# GL/glext.h:2553
GL_CON_31_ATI = 35168 	# GL/glext.h:2554
GL_MOV_ATI = 35169 	# GL/glext.h:2555
GL_ADD_ATI = 35171 	# GL/glext.h:2556
GL_MUL_ATI = 35172 	# GL/glext.h:2557
GL_SUB_ATI = 35173 	# GL/glext.h:2558
GL_DOT3_ATI = 35174 	# GL/glext.h:2559
GL_DOT4_ATI = 35175 	# GL/glext.h:2560
GL_MAD_ATI = 35176 	# GL/glext.h:2561
GL_LERP_ATI = 35177 	# GL/glext.h:2562
GL_CND_ATI = 35178 	# GL/glext.h:2563
GL_CND0_ATI = 35179 	# GL/glext.h:2564
GL_DOT2_ADD_ATI = 35180 	# GL/glext.h:2565
GL_SECONDARY_INTERPOLATOR_ATI = 35181 	# GL/glext.h:2566
GL_NUM_FRAGMENT_REGISTERS_ATI = 35182 	# GL/glext.h:2567
GL_NUM_FRAGMENT_CONSTANTS_ATI = 35183 	# GL/glext.h:2568
GL_NUM_PASSES_ATI = 35184 	# GL/glext.h:2569
GL_NUM_INSTRUCTIONS_PER_PASS_ATI = 35185 	# GL/glext.h:2570
GL_NUM_INSTRUCTIONS_TOTAL_ATI = 35186 	# GL/glext.h:2571
GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI = 35187 	# GL/glext.h:2572
GL_NUM_LOOPBACK_COMPONENTS_ATI = 35188 	# GL/glext.h:2573
GL_COLOR_ALPHA_PAIRING_ATI = 35189 	# GL/glext.h:2574
GL_SWIZZLE_STR_ATI = 35190 	# GL/glext.h:2575
GL_SWIZZLE_STQ_ATI = 35191 	# GL/glext.h:2576
GL_SWIZZLE_STR_DR_ATI = 35192 	# GL/glext.h:2577
GL_SWIZZLE_STQ_DQ_ATI = 35193 	# GL/glext.h:2578
GL_SWIZZLE_STRQ_ATI = 35194 	# GL/glext.h:2579
GL_SWIZZLE_STRQ_DQ_ATI = 35195 	# GL/glext.h:2580
GL_RED_BIT_ATI = 1 	# GL/glext.h:2581
GL_GREEN_BIT_ATI = 2 	# GL/glext.h:2582
GL_BLUE_BIT_ATI = 4 	# GL/glext.h:2583
GL_2X_BIT_ATI = 1 	# GL/glext.h:2584
GL_4X_BIT_ATI = 2 	# GL/glext.h:2585
GL_8X_BIT_ATI = 4 	# GL/glext.h:2586
GL_HALF_BIT_ATI = 8 	# GL/glext.h:2587
GL_QUARTER_BIT_ATI = 16 	# GL/glext.h:2588
GL_EIGHTH_BIT_ATI = 32 	# GL/glext.h:2589
GL_SATURATE_BIT_ATI = 64 	# GL/glext.h:2590
GL_COMP_BIT_ATI = 2 	# GL/glext.h:2591
GL_NEGATE_BIT_ATI = 4 	# GL/glext.h:2592
GL_BIAS_BIT_ATI = 8 	# GL/glext.h:2593
# ATI_pn_triangles (GL/glext.h:2596)
GL_PN_TRIANGLES_ATI = 34800 	# GL/glext.h:2597
GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI = 34801 	# GL/glext.h:2598
GL_PN_TRIANGLES_POINT_MODE_ATI = 34802 	# GL/glext.h:2599
GL_PN_TRIANGLES_NORMAL_MODE_ATI = 34803 	# GL/glext.h:2600
GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI = 34804 	# GL/glext.h:2601
GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI = 34805 	# GL/glext.h:2602
GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI = 34806 	# GL/glext.h:2603
GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI = 34807 	# GL/glext.h:2604
GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI = 34808 	# GL/glext.h:2605
# ATI_vertex_array_object (GL/glext.h:2608)
GL_STATIC_ATI = 34656 	# GL/glext.h:2609
GL_DYNAMIC_ATI = 34657 	# GL/glext.h:2610
GL_PRESERVE_ATI = 34658 	# GL/glext.h:2611
GL_DISCARD_ATI = 34659 	# GL/glext.h:2612
GL_OBJECT_BUFFER_SIZE_ATI = 34660 	# GL/glext.h:2613
GL_OBJECT_BUFFER_USAGE_ATI = 34661 	# GL/glext.h:2614
GL_ARRAY_OBJECT_BUFFER_ATI = 34662 	# GL/glext.h:2615
GL_ARRAY_OBJECT_OFFSET_ATI = 34663 	# GL/glext.h:2616
# EXT_vertex_shader (GL/glext.h:2619)
GL_VERTEX_SHADER_EXT = 34688 	# GL/glext.h:2620
GL_VERTEX_SHADER_BINDING_EXT = 34689 	# GL/glext.h:2621
GL_OP_INDEX_EXT = 34690 	# GL/glext.h:2622
GL_OP_NEGATE_EXT = 34691 	# GL/glext.h:2623
GL_OP_DOT3_EXT = 34692 	# GL/glext.h:2624
GL_OP_DOT4_EXT = 34693 	# GL/glext.h:2625
GL_OP_MUL_EXT = 34694 	# GL/glext.h:2626
GL_OP_ADD_EXT = 34695 	# GL/glext.h:2627
GL_OP_MADD_EXT = 34696 	# GL/glext.h:2628
GL_OP_FRAC_EXT = 34697 	# GL/glext.h:2629
GL_OP_MAX_EXT = 34698 	# GL/glext.h:2630
GL_OP_MIN_EXT = 34699 	# GL/glext.h:2631
GL_OP_SET_GE_EXT = 34700 	# GL/glext.h:2632
GL_OP_SET_LT_EXT = 34701 	# GL/glext.h:2633
GL_OP_CLAMP_EXT = 34702 	# GL/glext.h:2634
GL_OP_FLOOR_EXT = 34703 	# GL/glext.h:2635
GL_OP_ROUND_EXT = 34704 	# GL/glext.h:2636
GL_OP_EXP_BASE_2_EXT = 34705 	# GL/glext.h:2637
GL_OP_LOG_BASE_2_EXT = 34706 	# GL/glext.h:2638
GL_OP_POWER_EXT = 34707 	# GL/glext.h:2639
GL_OP_RECIP_EXT = 34708 	# GL/glext.h:2640
GL_OP_RECIP_SQRT_EXT = 34709 	# GL/glext.h:2641
GL_OP_SUB_EXT = 34710 	# GL/glext.h:2642
GL_OP_CROSS_PRODUCT_EXT = 34711 	# GL/glext.h:2643
GL_OP_MULTIPLY_MATRIX_EXT = 34712 	# GL/glext.h:2644
GL_OP_MOV_EXT = 34713 	# GL/glext.h:2645
GL_OUTPUT_VERTEX_EXT = 34714 	# GL/glext.h:2646
GL_OUTPUT_COLOR0_EXT = 34715 	# GL/glext.h:2647
GL_OUTPUT_COLOR1_EXT = 34716 	# GL/glext.h:2648
GL_OUTPUT_TEXTURE_COORD0_EXT = 34717 	# GL/glext.h:2649
GL_OUTPUT_TEXTURE_COORD1_EXT = 34718 	# GL/glext.h:2650
GL_OUTPUT_TEXTURE_COORD2_EXT = 34719 	# GL/glext.h:2651
GL_OUTPUT_TEXTURE_COORD3_EXT = 34720 	# GL/glext.h:2652
GL_OUTPUT_TEXTURE_COORD4_EXT = 34721 	# GL/glext.h:2653
GL_OUTPUT_TEXTURE_COORD5_EXT = 34722 	# GL/glext.h:2654
GL_OUTPUT_TEXTURE_COORD6_EXT = 34723 	# GL/glext.h:2655
GL_OUTPUT_TEXTURE_COORD7_EXT = 34724 	# GL/glext.h:2656
GL_OUTPUT_TEXTURE_COORD8_EXT = 34725 	# GL/glext.h:2657
GL_OUTPUT_TEXTURE_COORD9_EXT = 34726 	# GL/glext.h:2658
GL_OUTPUT_TEXTURE_COORD10_EXT = 34727 	# GL/glext.h:2659
GL_OUTPUT_TEXTURE_COORD11_EXT = 34728 	# GL/glext.h:2660
GL_OUTPUT_TEXTURE_COORD12_EXT = 34729 	# GL/glext.h:2661
GL_OUTPUT_TEXTURE_COORD13_EXT = 34730 	# GL/glext.h:2662
GL_OUTPUT_TEXTURE_COORD14_EXT = 34731 	# GL/glext.h:2663
GL_OUTPUT_TEXTURE_COORD15_EXT = 34732 	# GL/glext.h:2664
GL_OUTPUT_TEXTURE_COORD16_EXT = 34733 	# GL/glext.h:2665
GL_OUTPUT_TEXTURE_COORD17_EXT = 34734 	# GL/glext.h:2666
GL_OUTPUT_TEXTURE_COORD18_EXT = 34735 	# GL/glext.h:2667
GL_OUTPUT_TEXTURE_COORD19_EXT = 34736 	# GL/glext.h:2668
GL_OUTPUT_TEXTURE_COORD20_EXT = 34737 	# GL/glext.h:2669
GL_OUTPUT_TEXTURE_COORD21_EXT = 34738 	# GL/glext.h:2670
GL_OUTPUT_TEXTURE_COORD22_EXT = 34739 	# GL/glext.h:2671
GL_OUTPUT_TEXTURE_COORD23_EXT = 34740 	# GL/glext.h:2672
GL_OUTPUT_TEXTURE_COORD24_EXT = 34741 	# GL/glext.h:2673
GL_OUTPUT_TEXTURE_COORD25_EXT = 34742 	# GL/glext.h:2674
GL_OUTPUT_TEXTURE_COORD26_EXT = 34743 	# GL/glext.h:2675
GL_OUTPUT_TEXTURE_COORD27_EXT = 34744 	# GL/glext.h:2676
GL_OUTPUT_TEXTURE_COORD28_EXT = 34745 	# GL/glext.h:2677
GL_OUTPUT_TEXTURE_COORD29_EXT = 34746 	# GL/glext.h:2678
GL_OUTPUT_TEXTURE_COORD30_EXT = 34747 	# GL/glext.h:2679
GL_OUTPUT_TEXTURE_COORD31_EXT = 34748 	# GL/glext.h:2680
GL_OUTPUT_FOG_EXT = 34749 	# GL/glext.h:2681
GL_SCALAR_EXT = 34750 	# GL/glext.h:2682
GL_VECTOR_EXT = 34751 	# GL/glext.h:2683
GL_MATRIX_EXT = 34752 	# GL/glext.h:2684
GL_VARIANT_EXT = 34753 	# GL/glext.h:2685
GL_INVARIANT_EXT = 34754 	# GL/glext.h:2686
GL_LOCAL_CONSTANT_EXT = 34755 	# GL/glext.h:2687
GL_LOCAL_EXT = 34756 	# GL/glext.h:2688
GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT = 34757 	# GL/glext.h:2689
GL_MAX_VERTEX_SHADER_VARIANTS_EXT = 34758 	# GL/glext.h:2690
GL_MAX_VERTEX_SHADER_INVARIANTS_EXT = 34759 	# GL/glext.h:2691
GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 34760 	# GL/glext.h:2692
GL_MAX_VERTEX_SHADER_LOCALS_EXT = 34761 	# GL/glext.h:2693
GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT = 34762 	# GL/glext.h:2694
GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT = 34763 	# GL/glext.h:2695
GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 34764 	# GL/glext.h:2696
GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT = 34765 	# GL/glext.h:2697
GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT = 34766 	# GL/glext.h:2698
GL_VERTEX_SHADER_INSTRUCTIONS_EXT = 34767 	# GL/glext.h:2699
GL_VERTEX_SHADER_VARIANTS_EXT = 34768 	# GL/glext.h:2700
GL_VERTEX_SHADER_INVARIANTS_EXT = 34769 	# GL/glext.h:2701
GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 34770 	# GL/glext.h:2702
GL_VERTEX_SHADER_LOCALS_EXT = 34771 	# GL/glext.h:2703
GL_VERTEX_SHADER_OPTIMIZED_EXT = 34772 	# GL/glext.h:2704
GL_X_EXT = 34773 	# GL/glext.h:2705
GL_Y_EXT = 34774 	# GL/glext.h:2706
GL_Z_EXT = 34775 	# GL/glext.h:2707
GL_W_EXT = 34776 	# GL/glext.h:2708
GL_NEGATIVE_X_EXT = 34777 	# GL/glext.h:2709
GL_NEGATIVE_Y_EXT = 34778 	# GL/glext.h:2710
GL_NEGATIVE_Z_EXT = 34779 	# GL/glext.h:2711
GL_NEGATIVE_W_EXT = 34780 	# GL/glext.h:2712
GL_ZERO_EXT = 34781 	# GL/glext.h:2713
GL_ONE_EXT = 34782 	# GL/glext.h:2714
GL_NEGATIVE_ONE_EXT = 34783 	# GL/glext.h:2715
GL_NORMALIZED_RANGE_EXT = 34784 	# GL/glext.h:2716
GL_FULL_RANGE_EXT = 34785 	# GL/glext.h:2717
GL_CURRENT_VERTEX_EXT = 34786 	# GL/glext.h:2718
GL_MVP_MATRIX_EXT = 34787 	# GL/glext.h:2719
GL_VARIANT_VALUE_EXT = 34788 	# GL/glext.h:2720
GL_VARIANT_DATATYPE_EXT = 34789 	# GL/glext.h:2721
GL_VARIANT_ARRAY_STRIDE_EXT = 34790 	# GL/glext.h:2722
GL_VARIANT_ARRAY_TYPE_EXT = 34791 	# GL/glext.h:2723
GL_VARIANT_ARRAY_EXT = 34792 	# GL/glext.h:2724
GL_VARIANT_ARRAY_POINTER_EXT = 34793 	# GL/glext.h:2725
GL_INVARIANT_VALUE_EXT = 34794 	# GL/glext.h:2726
GL_INVARIANT_DATATYPE_EXT = 34795 	# GL/glext.h:2727
GL_LOCAL_CONSTANT_VALUE_EXT = 34796 	# GL/glext.h:2728
GL_LOCAL_CONSTANT_DATATYPE_EXT = 34797 	# GL/glext.h:2729
# ATI_vertex_streams (GL/glext.h:2732)
GL_MAX_VERTEX_STREAMS_ATI = 34667 	# GL/glext.h:2733
GL_VERTEX_STREAM0_ATI = 34668 	# GL/glext.h:2734
GL_VERTEX_STREAM1_ATI = 34669 	# GL/glext.h:2735
GL_VERTEX_STREAM2_ATI = 34670 	# GL/glext.h:2736
GL_VERTEX_STREAM3_ATI = 34671 	# GL/glext.h:2737
GL_VERTEX_STREAM4_ATI = 34672 	# GL/glext.h:2738
GL_VERTEX_STREAM5_ATI = 34673 	# GL/glext.h:2739
GL_VERTEX_STREAM6_ATI = 34674 	# GL/glext.h:2740
GL_VERTEX_STREAM7_ATI = 34675 	# GL/glext.h:2741
GL_VERTEX_SOURCE_ATI = 34676 	# GL/glext.h:2742
# ATI_element_array (GL/glext.h:2745)
GL_ELEMENT_ARRAY_ATI = 34664 	# GL/glext.h:2746
GL_ELEMENT_ARRAY_TYPE_ATI = 34665 	# GL/glext.h:2747
GL_ELEMENT_ARRAY_POINTER_ATI = 34666 	# GL/glext.h:2748
# SUN_mesh_array (GL/glext.h:2751)
GL_QUAD_MESH_SUN = 34324 	# GL/glext.h:2752
GL_TRIANGLE_MESH_SUN = 34325 	# GL/glext.h:2753
# SUN_slice_accum (GL/glext.h:2756)
GL_SLICE_ACCUM_SUN = 34252 	# GL/glext.h:2757
# NV_multisample_filter_hint (GL/glext.h:2760)
GL_MULTISAMPLE_FILTER_HINT_NV = 34100 	# GL/glext.h:2761
# NV_depth_clamp (GL/glext.h:2764)
GL_DEPTH_CLAMP_NV = 34383 	# GL/glext.h:2765
# NV_occlusion_query (GL/glext.h:2768)
GL_PIXEL_COUNTER_BITS_NV = 34916 	# GL/glext.h:2769
GL_CURRENT_OCCLUSION_QUERY_ID_NV = 34917 	# GL/glext.h:2770
GL_PIXEL_COUNT_NV = 34918 	# GL/glext.h:2771
GL_PIXEL_COUNT_AVAILABLE_NV = 34919 	# GL/glext.h:2772
# NV_point_sprite (GL/glext.h:2775)
GL_POINT_SPRITE_NV = 34913 	# GL/glext.h:2776
GL_COORD_REPLACE_NV = 34914 	# GL/glext.h:2777
GL_POINT_SPRITE_R_MODE_NV = 34915 	# GL/glext.h:2778
# NV_texture_shader3 (GL/glext.h:2781)
GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV = 34896 	# GL/glext.h:2782
GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV = 34897 	# GL/glext.h:2783
GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV = 34898 	# GL/glext.h:2784
GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV = 34899 	# GL/glext.h:2785
GL_OFFSET_HILO_TEXTURE_2D_NV = 34900 	# GL/glext.h:2786
GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV = 34901 	# GL/glext.h:2787
GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV = 34902 	# GL/glext.h:2788
GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV = 34903 	# GL/glext.h:2789
GL_DEPENDENT_HILO_TEXTURE_2D_NV = 34904 	# GL/glext.h:2790
GL_DEPENDENT_RGB_TEXTURE_3D_NV = 34905 	# GL/glext.h:2791
GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV = 34906 	# GL/glext.h:2792
GL_DOT_PRODUCT_PASS_THROUGH_NV = 34907 	# GL/glext.h:2793
GL_DOT_PRODUCT_TEXTURE_1D_NV = 34908 	# GL/glext.h:2794
GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV = 34909 	# GL/glext.h:2795
GL_HILO8_NV = 34910 	# GL/glext.h:2796
GL_SIGNED_HILO8_NV = 34911 	# GL/glext.h:2797
GL_FORCE_BLUE_TO_ONE_NV = 34912 	# GL/glext.h:2798
# NV_vertex_program1_1 (GL/glext.h:2801)
# EXT_shadow_funcs (GL/glext.h:2804)
# EXT_stencil_two_side (GL/glext.h:2807)
GL_STENCIL_TEST_TWO_SIDE_EXT = 35088 	# GL/glext.h:2808
GL_ACTIVE_STENCIL_FACE_EXT = 35089 	# GL/glext.h:2809
# ATI_text_fragment_shader (GL/glext.h:2812)
GL_TEXT_FRAGMENT_SHADER_ATI = 33280 	# GL/glext.h:2813
# APPLE_client_storage (GL/glext.h:2816)
GL_UNPACK_CLIENT_STORAGE_APPLE = 34226 	# GL/glext.h:2817
# APPLE_element_array (GL/glext.h:2820)
GL_ELEMENT_ARRAY_APPLE = 34664 	# GL/glext.h:2821
GL_ELEMENT_ARRAY_TYPE_APPLE = 34665 	# GL/glext.h:2822
GL_ELEMENT_ARRAY_POINTER_APPLE = 34666 	# GL/glext.h:2823
# APPLE_fence (GL/glext.h:2826)
GL_DRAW_PIXELS_APPLE = 35338 	# GL/glext.h:2827
GL_FENCE_APPLE = 35339 	# GL/glext.h:2828
# APPLE_vertex_array_object (GL/glext.h:2831)
GL_VERTEX_ARRAY_BINDING_APPLE = 34229 	# GL/glext.h:2832
# APPLE_vertex_array_range (GL/glext.h:2835)
GL_VERTEX_ARRAY_RANGE_APPLE = 34077 	# GL/glext.h:2836
GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE = 34078 	# GL/glext.h:2837
GL_VERTEX_ARRAY_STORAGE_HINT_APPLE = 34079 	# GL/glext.h:2838
GL_VERTEX_ARRAY_RANGE_POINTER_APPLE = 34081 	# GL/glext.h:2839
GL_STORAGE_CACHED_APPLE = 34238 	# GL/glext.h:2840
GL_STORAGE_SHARED_APPLE = 34239 	# GL/glext.h:2841
# APPLE_ycbcr_422 (GL/glext.h:2844)
GL_YCBCR_422_APPLE = 34233 	# GL/glext.h:2845
GL_UNSIGNED_SHORT_8_8_APPLE = 34234 	# GL/glext.h:2846
GL_UNSIGNED_SHORT_8_8_REV_APPLE = 34235 	# GL/glext.h:2847
# S3_s3tc (GL/glext.h:2850)
GL_RGB_S3TC = 33696 	# GL/glext.h:2851
GL_RGB4_S3TC = 33697 	# GL/glext.h:2852
GL_RGBA_S3TC = 33698 	# GL/glext.h:2853
GL_RGBA4_S3TC = 33699 	# GL/glext.h:2854
# ATI_draw_buffers (GL/glext.h:2857)
GL_MAX_DRAW_BUFFERS_ATI = 34852 	# GL/glext.h:2858
GL_DRAW_BUFFER0_ATI = 34853 	# GL/glext.h:2859
GL_DRAW_BUFFER1_ATI = 34854 	# GL/glext.h:2860
GL_DRAW_BUFFER2_ATI = 34855 	# GL/glext.h:2861
GL_DRAW_BUFFER3_ATI = 34856 	# GL/glext.h:2862
GL_DRAW_BUFFER4_ATI = 34857 	# GL/glext.h:2863
GL_DRAW_BUFFER5_ATI = 34858 	# GL/glext.h:2864
GL_DRAW_BUFFER6_ATI = 34859 	# GL/glext.h:2865
GL_DRAW_BUFFER7_ATI = 34860 	# GL/glext.h:2866
GL_DRAW_BUFFER8_ATI = 34861 	# GL/glext.h:2867
GL_DRAW_BUFFER9_ATI = 34862 	# GL/glext.h:2868
GL_DRAW_BUFFER10_ATI = 34863 	# GL/glext.h:2869
GL_DRAW_BUFFER11_ATI = 34864 	# GL/glext.h:2870
GL_DRAW_BUFFER12_ATI = 34865 	# GL/glext.h:2871
GL_DRAW_BUFFER13_ATI = 34866 	# GL/glext.h:2872
GL_DRAW_BUFFER14_ATI = 34867 	# GL/glext.h:2873
GL_DRAW_BUFFER15_ATI = 34868 	# GL/glext.h:2874
# ATI_pixel_format_float (GL/glext.h:2877)
GL_TYPE_RGBA_FLOAT_ATI = 34848 	# GL/glext.h:2878
GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI = 34869 	# GL/glext.h:2879
# ATI_texture_env_combine3 (GL/glext.h:2882)
GL_MODULATE_ADD_ATI = 34628 	# GL/glext.h:2883
GL_MODULATE_SIGNED_ADD_ATI = 34629 	# GL/glext.h:2884
GL_MODULATE_SUBTRACT_ATI = 34630 	# GL/glext.h:2885
# ATI_texture_float (GL/glext.h:2888)
GL_RGBA_FLOAT32_ATI = 34836 	# GL/glext.h:2889
GL_RGB_FLOAT32_ATI = 34837 	# GL/glext.h:2890
GL_ALPHA_FLOAT32_ATI = 34838 	# GL/glext.h:2891
GL_INTENSITY_FLOAT32_ATI = 34839 	# GL/glext.h:2892
GL_LUMINANCE_FLOAT32_ATI = 34840 	# GL/glext.h:2893
GL_LUMINANCE_ALPHA_FLOAT32_ATI = 34841 	# GL/glext.h:2894
GL_RGBA_FLOAT16_ATI = 34842 	# GL/glext.h:2895
GL_RGB_FLOAT16_ATI = 34843 	# GL/glext.h:2896
GL_ALPHA_FLOAT16_ATI = 34844 	# GL/glext.h:2897
GL_INTENSITY_FLOAT16_ATI = 34845 	# GL/glext.h:2898
GL_LUMINANCE_FLOAT16_ATI = 34846 	# GL/glext.h:2899
GL_LUMINANCE_ALPHA_FLOAT16_ATI = 34847 	# GL/glext.h:2900
# NV_float_buffer (GL/glext.h:2903)
GL_FLOAT_R_NV = 34944 	# GL/glext.h:2904
GL_FLOAT_RG_NV = 34945 	# GL/glext.h:2905
GL_FLOAT_RGB_NV = 34946 	# GL/glext.h:2906
GL_FLOAT_RGBA_NV = 34947 	# GL/glext.h:2907
GL_FLOAT_R16_NV = 34948 	# GL/glext.h:2908
GL_FLOAT_R32_NV = 34949 	# GL/glext.h:2909
GL_FLOAT_RG16_NV = 34950 	# GL/glext.h:2910
GL_FLOAT_RG32_NV = 34951 	# GL/glext.h:2911
GL_FLOAT_RGB16_NV = 34952 	# GL/glext.h:2912
GL_FLOAT_RGB32_NV = 34953 	# GL/glext.h:2913
GL_FLOAT_RGBA16_NV = 34954 	# GL/glext.h:2914
GL_FLOAT_RGBA32_NV = 34955 	# GL/glext.h:2915
GL_TEXTURE_FLOAT_COMPONENTS_NV = 34956 	# GL/glext.h:2916
GL_FLOAT_CLEAR_COLOR_VALUE_NV = 34957 	# GL/glext.h:2917
GL_FLOAT_RGBA_MODE_NV = 34958 	# GL/glext.h:2918
# NV_fragment_program (GL/glext.h:2921)
GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV = 34920 	# GL/glext.h:2922
GL_FRAGMENT_PROGRAM_NV = 34928 	# GL/glext.h:2923
GL_MAX_TEXTURE_COORDS_NV = 34929 	# GL/glext.h:2924
GL_MAX_TEXTURE_IMAGE_UNITS_NV = 34930 	# GL/glext.h:2925
GL_FRAGMENT_PROGRAM_BINDING_NV = 34931 	# GL/glext.h:2926
GL_PROGRAM_ERROR_STRING_NV = 34932 	# GL/glext.h:2927
# NV_half_float (GL/glext.h:2930)
GL_HALF_FLOAT_NV = 5131 	# GL/glext.h:2931
# NV_pixel_data_range (GL/glext.h:2934)
GL_WRITE_PIXEL_DATA_RANGE_NV = 34936 	# GL/glext.h:2935
GL_READ_PIXEL_DATA_RANGE_NV = 34937 	# GL/glext.h:2936
GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV = 34938 	# GL/glext.h:2937
GL_READ_PIXEL_DATA_RANGE_LENGTH_NV = 34939 	# GL/glext.h:2938
GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV = 34940 	# GL/glext.h:2939
GL_READ_PIXEL_DATA_RANGE_POINTER_NV = 34941 	# GL/glext.h:2940
# NV_primitive_restart (GL/glext.h:2943)
GL_PRIMITIVE_RESTART_NV = 34136 	# GL/glext.h:2944
GL_PRIMITIVE_RESTART_INDEX_NV = 34137 	# GL/glext.h:2945
# NV_texture_expand_normal (GL/glext.h:2948)
GL_TEXTURE_UNSIGNED_REMAP_MODE_NV = 34959 	# GL/glext.h:2949
# NV_vertex_program2 (GL/glext.h:2952)
# ATI_map_object_buffer (GL/glext.h:2955)
# ATI_separate_stencil (GL/glext.h:2958)
GL_STENCIL_BACK_FUNC_ATI = 34816 	# GL/glext.h:2959
GL_STENCIL_BACK_FAIL_ATI = 34817 	# GL/glext.h:2960
GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI = 34818 	# GL/glext.h:2961
GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI = 34819 	# GL/glext.h:2962
# ATI_vertex_attrib_array_object (GL/glext.h:2965)
# OES_read_format (GL/glext.h:2968)
GL_IMPLEMENTATION_COLOR_READ_TYPE_OES = 35738 	# GL/glext.h:2969
GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES = 35739 	# GL/glext.h:2970
# EXT_depth_bounds_test (GL/glext.h:2973)
GL_DEPTH_BOUNDS_TEST_EXT = 34960 	# GL/glext.h:2974
GL_DEPTH_BOUNDS_EXT = 34961 	# GL/glext.h:2975
# EXT_texture_mirror_clamp (GL/glext.h:2978)
GL_MIRROR_CLAMP_EXT = 34626 	# GL/glext.h:2979
GL_MIRROR_CLAMP_TO_EDGE_EXT = 34627 	# GL/glext.h:2980
GL_MIRROR_CLAMP_TO_BORDER_EXT = 35090 	# GL/glext.h:2981
# EXT_blend_equation_separate (GL/glext.h:2984)
GL_BLEND_EQUATION_RGB_EXT = 32777 	# GL/glext.h:2985
GL_BLEND_EQUATION_ALPHA_EXT = 34877 	# GL/glext.h:2986
# MESA_pack_invert (GL/glext.h:2989)
GL_PACK_INVERT_MESA = 34648 	# GL/glext.h:2990
# MESA_ycbcr_texture (GL/glext.h:2993)
GL_UNSIGNED_SHORT_8_8_MESA = 34234 	# GL/glext.h:2994
GL_UNSIGNED_SHORT_8_8_REV_MESA = 34235 	# GL/glext.h:2995
GL_YCBCR_MESA = 34647 	# GL/glext.h:2996
# EXT_pixel_buffer_object (GL/glext.h:2999)
GL_PIXEL_PACK_BUFFER_EXT = 35051 	# GL/glext.h:3000
GL_PIXEL_UNPACK_BUFFER_EXT = 35052 	# GL/glext.h:3001
GL_PIXEL_PACK_BUFFER_BINDING_EXT = 35053 	# GL/glext.h:3002
GL_PIXEL_UNPACK_BUFFER_BINDING_EXT = 35055 	# GL/glext.h:3003
# NV_fragment_program_option (GL/glext.h:3006)
# NV_fragment_program2 (GL/glext.h:3009)
GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV = 35060 	# GL/glext.h:3010
GL_MAX_PROGRAM_CALL_DEPTH_NV = 35061 	# GL/glext.h:3011
GL_MAX_PROGRAM_IF_DEPTH_NV = 35062 	# GL/glext.h:3012
GL_MAX_PROGRAM_LOOP_DEPTH_NV = 35063 	# GL/glext.h:3013
GL_MAX_PROGRAM_LOOP_COUNT_NV = 35064 	# GL/glext.h:3014
# NV_vertex_program2_option (GL/glext.h:3017)
# NV_vertex_program3 (GL/glext.h:3022)
# EXT_framebuffer_object (GL/glext.h:3026)
GL_INVALID_FRAMEBUFFER_OPERATION_EXT = 1286 	# GL/glext.h:3027
GL_MAX_RENDERBUFFER_SIZE_EXT = 34024 	# GL/glext.h:3028
GL_FRAMEBUFFER_BINDING_EXT = 36006 	# GL/glext.h:3029
GL_RENDERBUFFER_BINDING_EXT = 36007 	# GL/glext.h:3030
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT = 36048 	# GL/glext.h:3031
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT = 36049 	# GL/glext.h:3032
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT = 36050 	# GL/glext.h:3033
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT = 36051 	# GL/glext.h:3034
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT = 36052 	# GL/glext.h:3035
GL_FRAMEBUFFER_COMPLETE_EXT = 36053 	# GL/glext.h:3036
GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT = 36054 	# GL/glext.h:3037
GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT = 36055 	# GL/glext.h:3038
GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT_EXT = 36056 	# GL/glext.h:3039
GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT = 36057 	# GL/glext.h:3040
GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT = 36058 	# GL/glext.h:3041
GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT = 36059 	# GL/glext.h:3042
GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT = 36060 	# GL/glext.h:3043
GL_FRAMEBUFFER_UNSUPPORTED_EXT = 36061 	# GL/glext.h:3044
GL_MAX_COLOR_ATTACHMENTS_EXT = 36063 	# GL/glext.h:3045
GL_COLOR_ATTACHMENT0_EXT = 36064 	# GL/glext.h:3046
GL_COLOR_ATTACHMENT1_EXT = 36065 	# GL/glext.h:3047
GL_COLOR_ATTACHMENT2_EXT = 36066 	# GL/glext.h:3048
GL_COLOR_ATTACHMENT3_EXT = 36067 	# GL/glext.h:3049
GL_COLOR_ATTACHMENT4_EXT = 36068 	# GL/glext.h:3050
GL_COLOR_ATTACHMENT5_EXT = 36069 	# GL/glext.h:3051
GL_COLOR_ATTACHMENT6_EXT = 36070 	# GL/glext.h:3052
GL_COLOR_ATTACHMENT7_EXT = 36071 	# GL/glext.h:3053
GL_COLOR_ATTACHMENT8_EXT = 36072 	# GL/glext.h:3054
GL_COLOR_ATTACHMENT9_EXT = 36073 	# GL/glext.h:3055
GL_COLOR_ATTACHMENT10_EXT = 36074 	# GL/glext.h:3056
GL_COLOR_ATTACHMENT11_EXT = 36075 	# GL/glext.h:3057
GL_COLOR_ATTACHMENT12_EXT = 36076 	# GL/glext.h:3058
GL_COLOR_ATTACHMENT13_EXT = 36077 	# GL/glext.h:3059
GL_COLOR_ATTACHMENT14_EXT = 36078 	# GL/glext.h:3060
GL_COLOR_ATTACHMENT15_EXT = 36079 	# GL/glext.h:3061
GL_DEPTH_ATTACHMENT_EXT = 36096 	# GL/glext.h:3062
GL_STENCIL_ATTACHMENT_EXT = 36128 	# GL/glext.h:3063
GL_FRAMEBUFFER_EXT = 36160 	# GL/glext.h:3064
GL_RENDERBUFFER_EXT = 36161 	# GL/glext.h:3065
GL_RENDERBUFFER_WIDTH_EXT = 36162 	# GL/glext.h:3066
GL_RENDERBUFFER_HEIGHT_EXT = 36163 	# GL/glext.h:3067
GL_RENDERBUFFER_INTERNAL_FORMAT_EXT = 36164 	# GL/glext.h:3068
GL_STENCIL_INDEX_EXT = 36165 	# GL/glext.h:3069
GL_STENCIL_INDEX1_EXT = 36166 	# GL/glext.h:3070
GL_STENCIL_INDEX4_EXT = 36167 	# GL/glext.h:3071
GL_STENCIL_INDEX8_EXT = 36168 	# GL/glext.h:3072
GL_STENCIL_INDEX16_EXT = 36169 	# GL/glext.h:3073
GL_RENDERBUFFER_RED_SIZE_EXT = 36176 	# GL/glext.h:3074
GL_RENDERBUFFER_GREEN_SIZE_EXT = 36177 	# GL/glext.h:3075
GL_RENDERBUFFER_BLUE_SIZE_EXT = 36178 	# GL/glext.h:3076
GL_RENDERBUFFER_ALPHA_SIZE_EXT = 36179 	# GL/glext.h:3077
GL_RENDERBUFFER_DEPTH_SIZE_EXT = 36180 	# GL/glext.h:3078
GL_RENDERBUFFER_STENCIL_SIZE_EXT = 36181 	# GL/glext.h:3079
# GREMEDY_string_marker (GL/glext.h:3082)
# EXT_Cg_shader (GL/glext.h:3085)
GL_CG_VERTEX_SHADER_EXT = 35086 	# GL/glext.h:3086
GL_CG_FRAGMENT_SHADER_EXT = 35087 	# GL/glext.h:3087
# EXT_timer_query (GL/glext.h:3090)
GL_TIME_ELAPSED_EXT = 35007 	# GL/glext.h:3091
# EXT_texture_buffer_object (GL/glext.h:3094)
GL_TEXTURE_BUFFER_EXT = 35882 	# GL/glext.h:3095
GL_MAX_TEXTURE_BUFFER_SIZE_EXT = 35883 	# GL/glext.h:3096
GL_TEXTURE_BINDING_BUFFER_EXT = 35884 	# GL/glext.h:3097
GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT = 35885 	# GL/glext.h:3098
GL_TEXTURE_BUFFER_FORMAT_EXT = 35886 	# GL/glext.h:3099
# EXT_gpu_shader4 (GL/glext.h:3102)
GL_SAMPLER_1D_ARRAY_EXT = 36288 	# GL/glext.h:3103
GL_SAMPLER_2D_ARRAY_EXT = 36289 	# GL/glext.h:3104
GL_SAMPLER_BUFFER_EXT = 36290 	# GL/glext.h:3105
GL_SAMPLER_1D_ARRAY_SHADOW_EXT = 36291 	# GL/glext.h:3106
GL_SAMPLER_2D_ARRAY_SHADOW_EXT = 36292 	# GL/glext.h:3107
GL_SAMPLER_CUBE_SHADOW_EXT = 36293 	# GL/glext.h:3108
GL_UNSIGNED_INT_VEC2_EXT = 36294 	# GL/glext.h:3109
GL_UNSIGNED_INT_VEC3_EXT = 36295 	# GL/glext.h:3110
GL_UNSIGNED_INT_VEC4_EXT = 36296 	# GL/glext.h:3111
GL_INT_SAMPLER_1D_EXT = 36297 	# GL/glext.h:3112
GL_INT_SAMPLER_2D_EXT = 36298 	# GL/glext.h:3113
GL_INT_SAMPLER_3D_EXT = 36299 	# GL/glext.h:3114
GL_INT_SAMPLER_CUBE_EXT = 36300 	# GL/glext.h:3115
GL_INT_SAMPLER_2D_RECT_EXT = 36301 	# GL/glext.h:3116
GL_INT_SAMPLER_1D_ARRAY_EXT = 36302 	# GL/glext.h:3117
GL_INT_SAMPLER_2D_ARRAY_EXT = 36303 	# GL/glext.h:3118
GL_INT_SAMPLER_BUFFER_EXT = 36304 	# GL/glext.h:3119
GL_UNSIGNED_INT_SAMPLER_1D_EXT = 36305 	# GL/glext.h:3120
GL_UNSIGNED_INT_SAMPLER_2D_EXT = 36306 	# GL/glext.h:3121
GL_UNSIGNED_INT_SAMPLER_3D_EXT = 36307 	# GL/glext.h:3122
GL_UNSIGNED_INT_SAMPLER_CUBE_EXT = 36308 	# GL/glext.h:3123
GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT = 36309 	# GL/glext.h:3124
GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT = 36310 	# GL/glext.h:3125
GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT = 36311 	# GL/glext.h:3126
GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT = 36312 	# GL/glext.h:3127
GL_VERTEX_ATTRIB_ARRAY_INTEGER_EXT = 35069 	# GL/glext.h:3128
# EXT_geometry_shader4 (GL/glext.h:3131)
GL_GEOMETRY_SHADER_EXT = 36313 	# GL/glext.h:3132
GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT = 36317 	# GL/glext.h:3133
GL_MAX_VERTEX_VARYING_COMPONENTS_EXT = 36318 	# GL/glext.h:3134
GL_MAX_VARYING_COMPONENTS_EXT = 35659 	# GL/glext.h:3135
GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT = 36319 	# GL/glext.h:3136
GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT = 36320 	# GL/glext.h:3137
GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT = 36321 	# GL/glext.h:3138
GL_GEOMETRY_VERTICES_OUT_EXT = 36314 	# GL/glext.h:3139
GL_GEOMETRY_INPUT_TYPE_EXT = 36315 	# GL/glext.h:3140
GL_GEOMETRY_OUTPUT_TYPE_EXT = 36316 	# GL/glext.h:3141
GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT = 35881 	# GL/glext.h:3142
GL_LINES_ADJACENCY_EXT = 10 	# GL/glext.h:3143
GL_LINE_STRIP_ADJACENCY_EXT = 11 	# GL/glext.h:3144
GL_TRIANGLES_ADJACENCY_EXT = 12 	# GL/glext.h:3145
GL_TRIANGLE_STRIP_ADJACENCY_EXT = 13 	# GL/glext.h:3146
GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT = 36263 	# GL/glext.h:3147
GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT = 36264 	# GL/glext.h:3148
GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT = 36265 	# GL/glext.h:3149
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT = 36052 	# GL/glext.h:3150
GL_PROGRAM_POINT_SIZE_EXT = 34370 	# GL/glext.h:3151
# EXT_bindable_uniform (GL/glext.h:3154)
GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT = 36322 	# GL/glext.h:3155
GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT = 36323 	# GL/glext.h:3156
GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT = 36324 	# GL/glext.h:3157
GL_MAX_BINDABLE_UNIFORM_SIZE_EXT = 36333 	# GL/glext.h:3158
GL_UNIFORM_BUFFER_EXT = 36334 	# GL/glext.h:3159
GL_UNIFORM_BUFFER_BINDING_EXT = 36335 	# GL/glext.h:3160
# EXT_framebuffer_sRGB (GL/glext.h:3163)
GL_FRAMEBUFFER_SRGB_EXT = 36281 	# GL/glext.h:3164
GL_FRAMEBUFFER_SRGB_CAPABLE_EXT = 36282 	# GL/glext.h:3165
# EXT_texture_shared_exponent (GL/glext.h:3168)
GL_RGB9_E5_EXT = 35901 	# GL/glext.h:3169
GL_UNSIGNED_INT_5_9_9_9_REV_EXT = 35902 	# GL/glext.h:3170
GL_TEXTURE_SHARED_SIZE_EXT = 35903 	# GL/glext.h:3171
# EXT_packed_float (GL/glext.h:3174)
GL_R11F_G11F_B10F_EXT = 35898 	# GL/glext.h:3175
GL_UNSIGNED_INT_10F_11F_11F_REV_EXT = 35899 	# GL/glext.h:3176
GL_RGBA_SIGNED_COMPONENTS_EXT = 35900 	# GL/glext.h:3177
# EXT_texture_array (GL/glext.h:3180)
GL_TEXTURE_1D_ARRAY_EXT = 35864 	# GL/glext.h:3181
GL_PROXY_TEXTURE_1D_ARRAY_EXT = 35865 	# GL/glext.h:3182
GL_TEXTURE_2D_ARRAY_EXT = 35866 	# GL/glext.h:3183
GL_PROXY_TEXTURE_2D_ARRAY_EXT = 35867 	# GL/glext.h:3184
GL_TEXTURE_BINDING_1D_ARRAY_EXT = 35868 	# GL/glext.h:3185
GL_TEXTURE_BINDING_2D_ARRAY_EXT = 35869 	# GL/glext.h:3186
GL_MAX_ARRAY_TEXTURE_LAYERS_EXT = 35071 	# GL/glext.h:3187
GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT = 34894 	# GL/glext.h:3188
# EXT_texture_integer (GL/glext.h:3192)
GL_RGBA32UI_EXT = 36208 	# GL/glext.h:3193
GL_RGB32UI_EXT = 36209 	# GL/glext.h:3194
GL_ALPHA32UI_EXT = 36210 	# GL/glext.h:3195
GL_INTENSITY32UI_EXT = 36211 	# GL/glext.h:3196
GL_LUMINANCE32UI_EXT = 36212 	# GL/glext.h:3197
GL_LUMINANCE_ALPHA32UI_EXT = 36213 	# GL/glext.h:3198
GL_RGBA16UI_EXT = 36214 	# GL/glext.h:3199
GL_RGB16UI_EXT = 36215 	# GL/glext.h:3200
GL_ALPHA16UI_EXT = 36216 	# GL/glext.h:3201
GL_INTENSITY16UI_EXT = 36217 	# GL/glext.h:3202
GL_LUMINANCE16UI_EXT = 36218 	# GL/glext.h:3203
GL_LUMINANCE_ALPHA16UI_EXT = 36219 	# GL/glext.h:3204
GL_RGBA8UI_EXT = 36220 	# GL/glext.h:3205
GL_RGB8UI_EXT = 36221 	# GL/glext.h:3206
GL_ALPHA8UI_EXT = 36222 	# GL/glext.h:3207
GL_INTENSITY8UI_EXT = 36223 	# GL/glext.h:3208
GL_LUMINANCE8UI_EXT = 36224 	# GL/glext.h:3209
GL_LUMINANCE_ALPHA8UI_EXT = 36225 	# GL/glext.h:3210
GL_RGBA32I_EXT = 36226 	# GL/glext.h:3211
GL_RGB32I_EXT = 36227 	# GL/glext.h:3212
GL_ALPHA32I_EXT = 36228 	# GL/glext.h:3213
GL_INTENSITY32I_EXT = 36229 	# GL/glext.h:3214
GL_LUMINANCE32I_EXT = 36230 	# GL/glext.h:3215
GL_LUMINANCE_ALPHA32I_EXT = 36231 	# GL/glext.h:3216
GL_RGBA16I_EXT = 36232 	# GL/glext.h:3217
GL_RGB16I_EXT = 36233 	# GL/glext.h:3218
GL_ALPHA16I_EXT = 36234 	# GL/glext.h:3219
GL_INTENSITY16I_EXT = 36235 	# GL/glext.h:3220
GL_LUMINANCE16I_EXT = 36236 	# GL/glext.h:3221
GL_LUMINANCE_ALPHA16I_EXT = 36237 	# GL/glext.h:3222
GL_RGBA8I_EXT = 36238 	# GL/glext.h:3223
GL_RGB8I_EXT = 36239 	# GL/glext.h:3224
GL_ALPHA8I_EXT = 36240 	# GL/glext.h:3225
GL_INTENSITY8I_EXT = 36241 	# GL/glext.h:3226
GL_LUMINANCE8I_EXT = 36242 	# GL/glext.h:3227
GL_LUMINANCE_ALPHA8I_EXT = 36243 	# GL/glext.h:3228
GL_RED_INTEGER_EXT = 36244 	# GL/glext.h:3229
GL_GREEN_INTEGER_EXT = 36245 	# GL/glext.h:3230
GL_BLUE_INTEGER_EXT = 36246 	# GL/glext.h:3231
GL_ALPHA_INTEGER_EXT = 36247 	# GL/glext.h:3232
GL_RGB_INTEGER_EXT = 36248 	# GL/glext.h:3233
GL_RGBA_INTEGER_EXT = 36249 	# GL/glext.h:3234
GL_BGR_INTEGER_EXT = 36250 	# GL/glext.h:3235
GL_BGRA_INTEGER_EXT = 36251 	# GL/glext.h:3236
GL_LUMINANCE_INTEGER_EXT = 36252 	# GL/glext.h:3237
GL_LUMINANCE_ALPHA_INTEGER_EXT = 36253 	# GL/glext.h:3238
GL_RGBA_INTEGER_MODE_EXT = 36254 	# GL/glext.h:3239
# NV_depth_buffer_float (GL/glext.h:3242)
GL_DEPTH_COMPONENT32F_NV = 36267 	# GL/glext.h:3243
GL_DEPTH32F_STENCIL8_NV = 36268 	# GL/glext.h:3244
GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV = 36269 	# GL/glext.h:3245
GL_DEPTH_BUFFER_FLOAT_MODE_NV = 36271 	# GL/glext.h:3246
# EXT_texture_compression_latc (GL/glext.h:3249)
GL_COMPRESSED_LUMINANCE_LATC1_EXT = 35952 	# GL/glext.h:3250
GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT = 35953 	# GL/glext.h:3251
GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT = 35954 	# GL/glext.h:3252
GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT = 35955 	# GL/glext.h:3253
# NV_transform_feedback (GL/glext.h:3256)
GL_BACK_PRIMARY_COLOR_NV = 35959 	# GL/glext.h:3257
GL_BACK_SECONDARY_COLOR_NV = 35960 	# GL/glext.h:3258
GL_TEXTURE_COORD_NV = 35961 	# GL/glext.h:3259
GL_CLIP_DISTANCE_NV = 35962 	# GL/glext.h:3260
GL_VERTEX_ID_NV = 35963 	# GL/glext.h:3261
GL_PRIMITIVE_ID_NV = 35964 	# GL/glext.h:3262
GL_GENERIC_ATTRIB_NV = 35965 	# GL/glext.h:3263
GL_TRANSFORM_FEEDBACK_ATTRIBS_NV = 35966 	# GL/glext.h:3264
GL_TRANSFORM_FEEDBACK_BUFFER_MODE_NV = 35967 	# GL/glext.h:3265
GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV = 35968 	# GL/glext.h:3266
GL_ACTIVE_VARYINGS_NV = 35969 	# GL/glext.h:3267
GL_ACTIVE_VARYING_MAX_LENGTH_NV = 35970 	# GL/glext.h:3268
GL_TRANSFORM_FEEDBACK_VARYINGS_NV = 35971 	# GL/glext.h:3269
GL_TRANSFORM_FEEDBACK_BUFFER_START_NV = 35972 	# GL/glext.h:3270
GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_NV = 35973 	# GL/glext.h:3271
GL_TRANSFORM_FEEDBACK_RECORD_NV = 35974 	# GL/glext.h:3272
GL_PRIMITIVES_GENERATED_NV = 35975 	# GL/glext.h:3273
GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV = 35976 	# GL/glext.h:3274
GL_RASTERIZER_DISCARD_NV = 35977 	# GL/glext.h:3275
GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_ATTRIBS_NV = 35978 	# GL/glext.h:3276
GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV = 35979 	# GL/glext.h:3277
GL_INTERLEAVED_ATTRIBS_NV = 35980 	# GL/glext.h:3278
GL_SEPARATE_ATTRIBS_NV = 35981 	# GL/glext.h:3279
GL_TRANSFORM_FEEDBACK_BUFFER_NV = 35982 	# GL/glext.h:3280
GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_NV = 35983 	# GL/glext.h:3281
# NV_geometry_program4 (GL/glext.h:3284)
GL_GEOMETRY_PROGRAM_NV = 35878 	# GL/glext.h:3285
GL_MAX_PROGRAM_OUTPUT_VERTICES_NV = 35879 	# GL/glext.h:3286
GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV = 35880 	# GL/glext.h:3287
# NV_gpu_program4 (GL/glext.h:3290)
GL_MIN_PROGRAM_TEXEL_OFFSET_NV = 35076 	# GL/glext.h:3291
GL_MAX_PROGRAM_TEXEL_OFFSET_NV = 35077 	# GL/glext.h:3292
GL_PROGRAM_ATTRIB_COMPONENTS_NV = 35078 	# GL/glext.h:3293
GL_PROGRAM_RESULT_COMPONENTS_NV = 35079 	# GL/glext.h:3294
GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV = 35080 	# GL/glext.h:3295
GL_MAX_PROGRAM_RESULT_COMPONENTS_NV = 35081 	# GL/glext.h:3296
GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV = 36261 	# GL/glext.h:3297
GL_MAX_PROGRAM_GENERIC_RESULTS_NV = 36262 	# GL/glext.h:3298
# NV_framebuffer_multisample_coverage (GL/glext.h:3301)
GL_RENDERBUFFER_COVERAGE_SAMPLES_NV = 36011 	# GL/glext.h:3302
GL_RENDERBUFFER_COLOR_SAMPLES_NV = 36368 	# GL/glext.h:3303
GL_MAX_RENDERBUFFER_COVERAGE_SAMPLES_NV = 36183 	# GL/glext.h:3304
GL_MAX_RENDERBUFFER_COLOR_SAMPLES_NV = 36369 	# GL/glext.h:3305
GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV = 36370 	# GL/glext.h:3306
GL_MULTISAMPLE_COVERAGE_MODES_NV = 36371 	# GL/glext.h:3307
# EXT_framebuffer_multisample (GL/glext.h:3310)
GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT = 36182 	# GL/glext.h:3311
GL_MAX_SAMPLES_EXT = 36183 	# GL/glext.h:3312
GL_RENDERBUFFER_SAMPLES_EXT = 36011 	# GL/glext.h:3313
# EXT_framebuffer_blit (GL/glext.h:3316)
GL_READ_FRAMEBUFFER_EXT = 36008 	# GL/glext.h:3317
GL_DRAW_FRAMEBUFFER_EXT = 36009 	# GL/glext.h:3318
GL_DRAW_FRAMEBUFFER_BINDING_EXT = 36006 	# GL/glext.h:3319
GL_READ_FRAMEBUFFER_BINDING_EXT = 36010 	# GL/glext.h:3320
# EXT_texture_compression_rgtc (GL/glext.h:3323)
GL_COMPRESSED_RED_RGTC1_EXT = 36283 	# GL/glext.h:3324
GL_COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284 	# GL/glext.h:3325
GL_COMPRESSED_RED_GREEN_RGTC2_EXT = 36285 	# GL/glext.h:3326
GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286 	# GL/glext.h:3327
# VERSION_2_0 (GL/glext.h:3333)
GLchar = c_char 	# GL/glext.h:3335
# VERSION_1_5 (GL/glext.h:3338)
GLintptr = c_ptrdiff_t 	# GL/glext.h:3340
GLsizeiptr = c_ptrdiff_t 	# GL/glext.h:3341
# ARB_vertex_buffer_object (GL/glext.h:3344)
GLintptrARB = c_ptrdiff_t 	# GL/glext.h:3346
GLsizeiptrARB = c_ptrdiff_t 	# GL/glext.h:3347
# ARB_shader_objects (GL/glext.h:3350)
GLcharARB = c_char 	# GL/glext.h:3352
GLhandleARB = c_uint 	# GL/glext.h:3353
# ARB_half_float_pixel (GL/glext.h:3357)
GLhalfARB = c_ushort 	# GL/glext.h:3358
# NV_half_float (GL/glext.h:3361)
GLhalfNV = c_ushort 	# GL/glext.h:3362
# EXT_timer_query (GL/glext.h:3365)
GLint64EXT = c_longlong 	# GL/glext.h:3366
GLuint64EXT = c_ulonglong 	# GL/glext.h:3367
# VERSION_1_2 (GL/glext.h:3370)
GL_VERSION_1_2 = 1 	# GL/glext.h:3371
GLclampf = c_float 	# /usr/include/GL/gl.h:64
# GL/glext.h:3373
glBlendColor = _link_function('glBlendColor', None, [GLclampf, GLclampf, GLclampf, GLclampf], 'VERSION_1_2')

GLenum = c_uint 	# /usr/include/GL/gl.h:53
# GL/glext.h:3374
glBlendEquation = _link_function('glBlendEquation', None, [GLenum], 'VERSION_1_2')

GLuint = c_uint 	# /usr/include/GL/gl.h:62
GLsizei = c_int 	# /usr/include/GL/gl.h:59
GLvoid = None 	# /usr/include/GL/gl.h:67
# GL/glext.h:3375
glDrawRangeElements = _link_function('glDrawRangeElements', None, [GLenum, GLuint, GLuint, GLsizei, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3376
glColorTable = _link_function('glColorTable', None, [GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

GLfloat = c_float 	# /usr/include/GL/gl.h:63
# GL/glext.h:3377
glColorTableParameterfv = _link_function('glColorTableParameterfv', None, [GLenum, GLenum, POINTER(GLfloat)], 'VERSION_1_2')

GLint = c_int 	# /usr/include/GL/gl.h:58
# GL/glext.h:3378
glColorTableParameteriv = _link_function('glColorTableParameteriv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_2')

# GL/glext.h:3379
glCopyColorTable = _link_function('glCopyColorTable', None, [GLenum, GLenum, GLint, GLint, GLsizei], 'VERSION_1_2')

# GL/glext.h:3380
glGetColorTable = _link_function('glGetColorTable', None, [GLenum, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3381
glGetColorTableParameterfv = _link_function('glGetColorTableParameterfv', None, [GLenum, GLenum, POINTER(GLfloat)], 'VERSION_1_2')

# GL/glext.h:3382
glGetColorTableParameteriv = _link_function('glGetColorTableParameteriv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_2')

# GL/glext.h:3383
glColorSubTable = _link_function('glColorSubTable', None, [GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3384
glCopyColorSubTable = _link_function('glCopyColorSubTable', None, [GLenum, GLsizei, GLint, GLint, GLsizei], 'VERSION_1_2')

# GL/glext.h:3385
glConvolutionFilter1D = _link_function('glConvolutionFilter1D', None, [GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3386
glConvolutionFilter2D = _link_function('glConvolutionFilter2D', None, [GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3387
glConvolutionParameterf = _link_function('glConvolutionParameterf', None, [GLenum, GLenum, GLfloat], 'VERSION_1_2')

# GL/glext.h:3388
glConvolutionParameterfv = _link_function('glConvolutionParameterfv', None, [GLenum, GLenum, POINTER(GLfloat)], 'VERSION_1_2')

# GL/glext.h:3389
glConvolutionParameteri = _link_function('glConvolutionParameteri', None, [GLenum, GLenum, GLint], 'VERSION_1_2')

# GL/glext.h:3390
glConvolutionParameteriv = _link_function('glConvolutionParameteriv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_2')

# GL/glext.h:3391
glCopyConvolutionFilter1D = _link_function('glCopyConvolutionFilter1D', None, [GLenum, GLenum, GLint, GLint, GLsizei], 'VERSION_1_2')

# GL/glext.h:3392
glCopyConvolutionFilter2D = _link_function('glCopyConvolutionFilter2D', None, [GLenum, GLenum, GLint, GLint, GLsizei, GLsizei], 'VERSION_1_2')

# GL/glext.h:3393
glGetConvolutionFilter = _link_function('glGetConvolutionFilter', None, [GLenum, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3394
glGetConvolutionParameterfv = _link_function('glGetConvolutionParameterfv', None, [GLenum, GLenum, POINTER(GLfloat)], 'VERSION_1_2')

# GL/glext.h:3395
glGetConvolutionParameteriv = _link_function('glGetConvolutionParameteriv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_2')

# GL/glext.h:3396
glGetSeparableFilter = _link_function('glGetSeparableFilter', None, [GLenum, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid), POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3397
glSeparableFilter2D = _link_function('glSeparableFilter2D', None, [GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid)], 'VERSION_1_2')

GLboolean = c_ubyte 	# /usr/include/GL/gl.h:54
# GL/glext.h:3398
glGetHistogram = _link_function('glGetHistogram', None, [GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3399
glGetHistogramParameterfv = _link_function('glGetHistogramParameterfv', None, [GLenum, GLenum, POINTER(GLfloat)], 'VERSION_1_2')

# GL/glext.h:3400
glGetHistogramParameteriv = _link_function('glGetHistogramParameteriv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_2')

# GL/glext.h:3401
glGetMinmax = _link_function('glGetMinmax', None, [GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3402
glGetMinmaxParameterfv = _link_function('glGetMinmaxParameterfv', None, [GLenum, GLenum, POINTER(GLfloat)], 'VERSION_1_2')

# GL/glext.h:3403
glGetMinmaxParameteriv = _link_function('glGetMinmaxParameteriv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_2')

# GL/glext.h:3404
glHistogram = _link_function('glHistogram', None, [GLenum, GLsizei, GLenum, GLboolean], 'VERSION_1_2')

# GL/glext.h:3405
glMinmax = _link_function('glMinmax', None, [GLenum, GLenum, GLboolean], 'VERSION_1_2')

# GL/glext.h:3406
glResetHistogram = _link_function('glResetHistogram', None, [GLenum], 'VERSION_1_2')

# GL/glext.h:3407
glResetMinmax = _link_function('glResetMinmax', None, [GLenum], 'VERSION_1_2')

# GL/glext.h:3408
glTexImage3D = _link_function('glTexImage3D', None, [GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3409
glTexSubImage3D = _link_function('glTexSubImage3D', None, [GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'VERSION_1_2')

# GL/glext.h:3410
glCopyTexSubImage3D = _link_function('glCopyTexSubImage3D', None, [GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei], 'VERSION_1_2')

PFNGLBLENDCOLORPROC = CFUNCTYPE(None, GLclampf, GLclampf, GLclampf, GLclampf) 	# GL/glext.h:3412
PFNGLBLENDEQUATIONPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3413
PFNGLDRAWRANGEELEMENTSPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLsizei, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3414
PFNGLCOLORTABLEPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3415
PFNGLCOLORTABLEPARAMETERFVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3416
PFNGLCOLORTABLEPARAMETERIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3417
PFNGLCOPYCOLORTABLEPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLint, GLsizei) 	# GL/glext.h:3418
PFNGLGETCOLORTABLEPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3419
PFNGLGETCOLORTABLEPARAMETERFVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3420
PFNGLGETCOLORTABLEPARAMETERIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3421
PFNGLCOLORSUBTABLEPROC = CFUNCTYPE(None, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3422
PFNGLCOPYCOLORSUBTABLEPROC = CFUNCTYPE(None, GLenum, GLsizei, GLint, GLint, GLsizei) 	# GL/glext.h:3423
PFNGLCONVOLUTIONFILTER1DPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3424
PFNGLCONVOLUTIONFILTER2DPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3425
PFNGLCONVOLUTIONPARAMETERFPROC = CFUNCTYPE(None, GLenum, GLenum, GLfloat) 	# GL/glext.h:3426
PFNGLCONVOLUTIONPARAMETERFVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3427
PFNGLCONVOLUTIONPARAMETERIPROC = CFUNCTYPE(None, GLenum, GLenum, GLint) 	# GL/glext.h:3428
PFNGLCONVOLUTIONPARAMETERIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3429
PFNGLCOPYCONVOLUTIONFILTER1DPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLint, GLsizei) 	# GL/glext.h:3430
PFNGLCOPYCONVOLUTIONFILTER2DPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLint, GLsizei, GLsizei) 	# GL/glext.h:3431
PFNGLGETCONVOLUTIONFILTERPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3432
PFNGLGETCONVOLUTIONPARAMETERFVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3433
PFNGLGETCONVOLUTIONPARAMETERIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3434
PFNGLGETSEPARABLEFILTERPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid), POINTER(GLvoid)) 	# GL/glext.h:3435
PFNGLSEPARABLEFILTER2DPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid)) 	# GL/glext.h:3436
PFNGLGETHISTOGRAMPROC = CFUNCTYPE(None, GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3437
PFNGLGETHISTOGRAMPARAMETERFVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3438
PFNGLGETHISTOGRAMPARAMETERIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3439
PFNGLGETMINMAXPROC = CFUNCTYPE(None, GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3440
PFNGLGETMINMAXPARAMETERFVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3441
PFNGLGETMINMAXPARAMETERIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3442
PFNGLHISTOGRAMPROC = CFUNCTYPE(None, GLenum, GLsizei, GLenum, GLboolean) 	# GL/glext.h:3443
PFNGLMINMAXPROC = CFUNCTYPE(None, GLenum, GLenum, GLboolean) 	# GL/glext.h:3444
PFNGLRESETHISTOGRAMPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3445
PFNGLRESETMINMAXPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3446
PFNGLTEXIMAGE3DPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3447
PFNGLTEXSUBIMAGE3DPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:3448
PFNGLCOPYTEXSUBIMAGE3DPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei) 	# GL/glext.h:3449
# VERSION_1_3 (GL/glext.h:3452)
GL_VERSION_1_3 = 1 	# GL/glext.h:3453
# GL/glext.h:3455
glActiveTexture = _link_function('glActiveTexture', None, [GLenum], 'VERSION_1_3')

# GL/glext.h:3456
glClientActiveTexture = _link_function('glClientActiveTexture', None, [GLenum], 'VERSION_1_3')

GLdouble = c_double 	# /usr/include/GL/gl.h:65
# GL/glext.h:3457
glMultiTexCoord1d = _link_function('glMultiTexCoord1d', None, [GLenum, GLdouble], 'VERSION_1_3')

# GL/glext.h:3458
glMultiTexCoord1dv = _link_function('glMultiTexCoord1dv', None, [GLenum, POINTER(GLdouble)], 'VERSION_1_3')

# GL/glext.h:3459
glMultiTexCoord1f = _link_function('glMultiTexCoord1f', None, [GLenum, GLfloat], 'VERSION_1_3')

# GL/glext.h:3460
glMultiTexCoord1fv = _link_function('glMultiTexCoord1fv', None, [GLenum, POINTER(GLfloat)], 'VERSION_1_3')

# GL/glext.h:3461
glMultiTexCoord1i = _link_function('glMultiTexCoord1i', None, [GLenum, GLint], 'VERSION_1_3')

# GL/glext.h:3462
glMultiTexCoord1iv = _link_function('glMultiTexCoord1iv', None, [GLenum, POINTER(GLint)], 'VERSION_1_3')

GLshort = c_short 	# /usr/include/GL/gl.h:57
# GL/glext.h:3463
glMultiTexCoord1s = _link_function('glMultiTexCoord1s', None, [GLenum, GLshort], 'VERSION_1_3')

# GL/glext.h:3464
glMultiTexCoord1sv = _link_function('glMultiTexCoord1sv', None, [GLenum, POINTER(GLshort)], 'VERSION_1_3')

# GL/glext.h:3465
glMultiTexCoord2d = _link_function('glMultiTexCoord2d', None, [GLenum, GLdouble, GLdouble], 'VERSION_1_3')

# GL/glext.h:3466
glMultiTexCoord2dv = _link_function('glMultiTexCoord2dv', None, [GLenum, POINTER(GLdouble)], 'VERSION_1_3')

# GL/glext.h:3467
glMultiTexCoord2f = _link_function('glMultiTexCoord2f', None, [GLenum, GLfloat, GLfloat], 'VERSION_1_3')

# GL/glext.h:3468
glMultiTexCoord2fv = _link_function('glMultiTexCoord2fv', None, [GLenum, POINTER(GLfloat)], 'VERSION_1_3')

# GL/glext.h:3469
glMultiTexCoord2i = _link_function('glMultiTexCoord2i', None, [GLenum, GLint, GLint], 'VERSION_1_3')

# GL/glext.h:3470
glMultiTexCoord2iv = _link_function('glMultiTexCoord2iv', None, [GLenum, POINTER(GLint)], 'VERSION_1_3')

# GL/glext.h:3471
glMultiTexCoord2s = _link_function('glMultiTexCoord2s', None, [GLenum, GLshort, GLshort], 'VERSION_1_3')

# GL/glext.h:3472
glMultiTexCoord2sv = _link_function('glMultiTexCoord2sv', None, [GLenum, POINTER(GLshort)], 'VERSION_1_3')

# GL/glext.h:3473
glMultiTexCoord3d = _link_function('glMultiTexCoord3d', None, [GLenum, GLdouble, GLdouble, GLdouble], 'VERSION_1_3')

# GL/glext.h:3474
glMultiTexCoord3dv = _link_function('glMultiTexCoord3dv', None, [GLenum, POINTER(GLdouble)], 'VERSION_1_3')

# GL/glext.h:3475
glMultiTexCoord3f = _link_function('glMultiTexCoord3f', None, [GLenum, GLfloat, GLfloat, GLfloat], 'VERSION_1_3')

# GL/glext.h:3476
glMultiTexCoord3fv = _link_function('glMultiTexCoord3fv', None, [GLenum, POINTER(GLfloat)], 'VERSION_1_3')

# GL/glext.h:3477
glMultiTexCoord3i = _link_function('glMultiTexCoord3i', None, [GLenum, GLint, GLint, GLint], 'VERSION_1_3')

# GL/glext.h:3478
glMultiTexCoord3iv = _link_function('glMultiTexCoord3iv', None, [GLenum, POINTER(GLint)], 'VERSION_1_3')

# GL/glext.h:3479
glMultiTexCoord3s = _link_function('glMultiTexCoord3s', None, [GLenum, GLshort, GLshort, GLshort], 'VERSION_1_3')

# GL/glext.h:3480
glMultiTexCoord3sv = _link_function('glMultiTexCoord3sv', None, [GLenum, POINTER(GLshort)], 'VERSION_1_3')

# GL/glext.h:3481
glMultiTexCoord4d = _link_function('glMultiTexCoord4d', None, [GLenum, GLdouble, GLdouble, GLdouble, GLdouble], 'VERSION_1_3')

# GL/glext.h:3482
glMultiTexCoord4dv = _link_function('glMultiTexCoord4dv', None, [GLenum, POINTER(GLdouble)], 'VERSION_1_3')

# GL/glext.h:3483
glMultiTexCoord4f = _link_function('glMultiTexCoord4f', None, [GLenum, GLfloat, GLfloat, GLfloat, GLfloat], 'VERSION_1_3')

# GL/glext.h:3484
glMultiTexCoord4fv = _link_function('glMultiTexCoord4fv', None, [GLenum, POINTER(GLfloat)], 'VERSION_1_3')

# GL/glext.h:3485
glMultiTexCoord4i = _link_function('glMultiTexCoord4i', None, [GLenum, GLint, GLint, GLint, GLint], 'VERSION_1_3')

# GL/glext.h:3486
glMultiTexCoord4iv = _link_function('glMultiTexCoord4iv', None, [GLenum, POINTER(GLint)], 'VERSION_1_3')

# GL/glext.h:3487
glMultiTexCoord4s = _link_function('glMultiTexCoord4s', None, [GLenum, GLshort, GLshort, GLshort, GLshort], 'VERSION_1_3')

# GL/glext.h:3488
glMultiTexCoord4sv = _link_function('glMultiTexCoord4sv', None, [GLenum, POINTER(GLshort)], 'VERSION_1_3')

# GL/glext.h:3489
glLoadTransposeMatrixf = _link_function('glLoadTransposeMatrixf', None, [POINTER(GLfloat)], 'VERSION_1_3')

# GL/glext.h:3490
glLoadTransposeMatrixd = _link_function('glLoadTransposeMatrixd', None, [POINTER(GLdouble)], 'VERSION_1_3')

# GL/glext.h:3491
glMultTransposeMatrixf = _link_function('glMultTransposeMatrixf', None, [POINTER(GLfloat)], 'VERSION_1_3')

# GL/glext.h:3492
glMultTransposeMatrixd = _link_function('glMultTransposeMatrixd', None, [POINTER(GLdouble)], 'VERSION_1_3')

# GL/glext.h:3493
glSampleCoverage = _link_function('glSampleCoverage', None, [GLclampf, GLboolean], 'VERSION_1_3')

# GL/glext.h:3494
glCompressedTexImage3D = _link_function('glCompressedTexImage3D', None, [GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)], 'VERSION_1_3')

# GL/glext.h:3495
glCompressedTexImage2D = _link_function('glCompressedTexImage2D', None, [GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)], 'VERSION_1_3')

# GL/glext.h:3496
glCompressedTexImage1D = _link_function('glCompressedTexImage1D', None, [GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, POINTER(GLvoid)], 'VERSION_1_3')

# GL/glext.h:3497
glCompressedTexSubImage3D = _link_function('glCompressedTexSubImage3D', None, [GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)], 'VERSION_1_3')

# GL/glext.h:3498
glCompressedTexSubImage2D = _link_function('glCompressedTexSubImage2D', None, [GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)], 'VERSION_1_3')

# GL/glext.h:3499
glCompressedTexSubImage1D = _link_function('glCompressedTexSubImage1D', None, [GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, POINTER(GLvoid)], 'VERSION_1_3')

# GL/glext.h:3500
glGetCompressedTexImage = _link_function('glGetCompressedTexImage', None, [GLenum, GLint, POINTER(GLvoid)], 'VERSION_1_3')

PFNGLACTIVETEXTUREPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3502
PFNGLCLIENTACTIVETEXTUREPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3503
PFNGLMULTITEXCOORD1DPROC = CFUNCTYPE(None, GLenum, GLdouble) 	# GL/glext.h:3504
PFNGLMULTITEXCOORD1DVPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3505
PFNGLMULTITEXCOORD1FPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:3506
PFNGLMULTITEXCOORD1FVPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3507
PFNGLMULTITEXCOORD1IPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:3508
PFNGLMULTITEXCOORD1IVPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3509
PFNGLMULTITEXCOORD1SPROC = CFUNCTYPE(None, GLenum, GLshort) 	# GL/glext.h:3510
PFNGLMULTITEXCOORD1SVPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3511
PFNGLMULTITEXCOORD2DPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble) 	# GL/glext.h:3512
PFNGLMULTITEXCOORD2DVPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3513
PFNGLMULTITEXCOORD2FPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat) 	# GL/glext.h:3514
PFNGLMULTITEXCOORD2FVPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3515
PFNGLMULTITEXCOORD2IPROC = CFUNCTYPE(None, GLenum, GLint, GLint) 	# GL/glext.h:3516
PFNGLMULTITEXCOORD2IVPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3517
PFNGLMULTITEXCOORD2SPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort) 	# GL/glext.h:3518
PFNGLMULTITEXCOORD2SVPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3519
PFNGLMULTITEXCOORD3DPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3520
PFNGLMULTITEXCOORD3DVPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3521
PFNGLMULTITEXCOORD3FPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3522
PFNGLMULTITEXCOORD3FVPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3523
PFNGLMULTITEXCOORD3IPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint) 	# GL/glext.h:3524
PFNGLMULTITEXCOORD3IVPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3525
PFNGLMULTITEXCOORD3SPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort, GLshort) 	# GL/glext.h:3526
PFNGLMULTITEXCOORD3SVPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3527
PFNGLMULTITEXCOORD4DPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3528
PFNGLMULTITEXCOORD4DVPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3529
PFNGLMULTITEXCOORD4FPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3530
PFNGLMULTITEXCOORD4FVPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3531
PFNGLMULTITEXCOORD4IPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint) 	# GL/glext.h:3532
PFNGLMULTITEXCOORD4IVPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3533
PFNGLMULTITEXCOORD4SPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort, GLshort, GLshort) 	# GL/glext.h:3534
PFNGLMULTITEXCOORD4SVPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3535
PFNGLLOADTRANSPOSEMATRIXFPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3536
PFNGLLOADTRANSPOSEMATRIXDPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3537
PFNGLMULTTRANSPOSEMATRIXFPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3538
PFNGLMULTTRANSPOSEMATRIXDPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3539
PFNGLSAMPLECOVERAGEPROC = CFUNCTYPE(None, GLclampf, GLboolean) 	# GL/glext.h:3540
PFNGLCOMPRESSEDTEXIMAGE3DPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3541
PFNGLCOMPRESSEDTEXIMAGE2DPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3542
PFNGLCOMPRESSEDTEXIMAGE1DPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3543
PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3544
PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3545
PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3546
PFNGLGETCOMPRESSEDTEXIMAGEPROC = CFUNCTYPE(None, GLenum, GLint, POINTER(GLvoid)) 	# GL/glext.h:3547
# VERSION_1_4 (GL/glext.h:3550)
GL_VERSION_1_4 = 1 	# GL/glext.h:3551
# GL/glext.h:3553
glBlendFuncSeparate = _link_function('glBlendFuncSeparate', None, [GLenum, GLenum, GLenum, GLenum], 'VERSION_1_4')

# GL/glext.h:3554
glFogCoordf = _link_function('glFogCoordf', None, [GLfloat], 'VERSION_1_4')

# GL/glext.h:3555
glFogCoordfv = _link_function('glFogCoordfv', None, [POINTER(GLfloat)], 'VERSION_1_4')

# GL/glext.h:3556
glFogCoordd = _link_function('glFogCoordd', None, [GLdouble], 'VERSION_1_4')

# GL/glext.h:3557
glFogCoorddv = _link_function('glFogCoorddv', None, [POINTER(GLdouble)], 'VERSION_1_4')

# GL/glext.h:3558
glFogCoordPointer = _link_function('glFogCoordPointer', None, [GLenum, GLsizei, POINTER(GLvoid)], 'VERSION_1_4')

# GL/glext.h:3559
glMultiDrawArrays = _link_function('glMultiDrawArrays', None, [GLenum, POINTER(GLint), POINTER(GLsizei), GLsizei], 'VERSION_1_4')

# GL/glext.h:3560
glMultiDrawElements = _link_function('glMultiDrawElements', None, [GLenum, POINTER(GLsizei), GLenum, POINTER(POINTER(GLvoid)), GLsizei], 'VERSION_1_4')

# GL/glext.h:3561
glPointParameterf = _link_function('glPointParameterf', None, [GLenum, GLfloat], 'VERSION_1_4')

# GL/glext.h:3562
glPointParameterfv = _link_function('glPointParameterfv', None, [GLenum, POINTER(GLfloat)], 'VERSION_1_4')

# GL/glext.h:3563
glPointParameteri = _link_function('glPointParameteri', None, [GLenum, GLint], 'VERSION_1_4')

# GL/glext.h:3564
glPointParameteriv = _link_function('glPointParameteriv', None, [GLenum, POINTER(GLint)], 'VERSION_1_4')

GLbyte = c_char 	# /usr/include/GL/gl.h:56
# GL/glext.h:3565
glSecondaryColor3b = _link_function('glSecondaryColor3b', None, [GLbyte, GLbyte, GLbyte], 'VERSION_1_4')

# GL/glext.h:3566
glSecondaryColor3bv = _link_function('glSecondaryColor3bv', None, [POINTER(GLbyte)], 'VERSION_1_4')

# GL/glext.h:3567
glSecondaryColor3d = _link_function('glSecondaryColor3d', None, [GLdouble, GLdouble, GLdouble], 'VERSION_1_4')

# GL/glext.h:3568
glSecondaryColor3dv = _link_function('glSecondaryColor3dv', None, [POINTER(GLdouble)], 'VERSION_1_4')

# GL/glext.h:3569
glSecondaryColor3f = _link_function('glSecondaryColor3f', None, [GLfloat, GLfloat, GLfloat], 'VERSION_1_4')

# GL/glext.h:3570
glSecondaryColor3fv = _link_function('glSecondaryColor3fv', None, [POINTER(GLfloat)], 'VERSION_1_4')

# GL/glext.h:3571
glSecondaryColor3i = _link_function('glSecondaryColor3i', None, [GLint, GLint, GLint], 'VERSION_1_4')

# GL/glext.h:3572
glSecondaryColor3iv = _link_function('glSecondaryColor3iv', None, [POINTER(GLint)], 'VERSION_1_4')

# GL/glext.h:3573
glSecondaryColor3s = _link_function('glSecondaryColor3s', None, [GLshort, GLshort, GLshort], 'VERSION_1_4')

# GL/glext.h:3574
glSecondaryColor3sv = _link_function('glSecondaryColor3sv', None, [POINTER(GLshort)], 'VERSION_1_4')

GLubyte = c_ubyte 	# /usr/include/GL/gl.h:60
# GL/glext.h:3575
glSecondaryColor3ub = _link_function('glSecondaryColor3ub', None, [GLubyte, GLubyte, GLubyte], 'VERSION_1_4')

# GL/glext.h:3576
glSecondaryColor3ubv = _link_function('glSecondaryColor3ubv', None, [POINTER(GLubyte)], 'VERSION_1_4')

# GL/glext.h:3577
glSecondaryColor3ui = _link_function('glSecondaryColor3ui', None, [GLuint, GLuint, GLuint], 'VERSION_1_4')

# GL/glext.h:3578
glSecondaryColor3uiv = _link_function('glSecondaryColor3uiv', None, [POINTER(GLuint)], 'VERSION_1_4')

GLushort = c_ushort 	# /usr/include/GL/gl.h:61
# GL/glext.h:3579
glSecondaryColor3us = _link_function('glSecondaryColor3us', None, [GLushort, GLushort, GLushort], 'VERSION_1_4')

# GL/glext.h:3580
glSecondaryColor3usv = _link_function('glSecondaryColor3usv', None, [POINTER(GLushort)], 'VERSION_1_4')

# GL/glext.h:3581
glSecondaryColorPointer = _link_function('glSecondaryColorPointer', None, [GLint, GLenum, GLsizei, POINTER(GLvoid)], 'VERSION_1_4')

# GL/glext.h:3582
glWindowPos2d = _link_function('glWindowPos2d', None, [GLdouble, GLdouble], 'VERSION_1_4')

# GL/glext.h:3583
glWindowPos2dv = _link_function('glWindowPos2dv', None, [POINTER(GLdouble)], 'VERSION_1_4')

# GL/glext.h:3584
glWindowPos2f = _link_function('glWindowPos2f', None, [GLfloat, GLfloat], 'VERSION_1_4')

# GL/glext.h:3585
glWindowPos2fv = _link_function('glWindowPos2fv', None, [POINTER(GLfloat)], 'VERSION_1_4')

# GL/glext.h:3586
glWindowPos2i = _link_function('glWindowPos2i', None, [GLint, GLint], 'VERSION_1_4')

# GL/glext.h:3587
glWindowPos2iv = _link_function('glWindowPos2iv', None, [POINTER(GLint)], 'VERSION_1_4')

# GL/glext.h:3588
glWindowPos2s = _link_function('glWindowPos2s', None, [GLshort, GLshort], 'VERSION_1_4')

# GL/glext.h:3589
glWindowPos2sv = _link_function('glWindowPos2sv', None, [POINTER(GLshort)], 'VERSION_1_4')

# GL/glext.h:3590
glWindowPos3d = _link_function('glWindowPos3d', None, [GLdouble, GLdouble, GLdouble], 'VERSION_1_4')

# GL/glext.h:3591
glWindowPos3dv = _link_function('glWindowPos3dv', None, [POINTER(GLdouble)], 'VERSION_1_4')

# GL/glext.h:3592
glWindowPos3f = _link_function('glWindowPos3f', None, [GLfloat, GLfloat, GLfloat], 'VERSION_1_4')

# GL/glext.h:3593
glWindowPos3fv = _link_function('glWindowPos3fv', None, [POINTER(GLfloat)], 'VERSION_1_4')

# GL/glext.h:3594
glWindowPos3i = _link_function('glWindowPos3i', None, [GLint, GLint, GLint], 'VERSION_1_4')

# GL/glext.h:3595
glWindowPos3iv = _link_function('glWindowPos3iv', None, [POINTER(GLint)], 'VERSION_1_4')

# GL/glext.h:3596
glWindowPos3s = _link_function('glWindowPos3s', None, [GLshort, GLshort, GLshort], 'VERSION_1_4')

# GL/glext.h:3597
glWindowPos3sv = _link_function('glWindowPos3sv', None, [POINTER(GLshort)], 'VERSION_1_4')

PFNGLBLENDFUNCSEPARATEPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:3599
PFNGLFOGCOORDFPROC = CFUNCTYPE(None, GLfloat) 	# GL/glext.h:3600
PFNGLFOGCOORDFVPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3601
PFNGLFOGCOORDDPROC = CFUNCTYPE(None, GLdouble) 	# GL/glext.h:3602
PFNGLFOGCOORDDVPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3603
PFNGLFOGCOORDPOINTERPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3604
PFNGLMULTIDRAWARRAYSPROC = CFUNCTYPE(None, GLenum, POINTER(GLint), POINTER(GLsizei), GLsizei) 	# GL/glext.h:3605
PFNGLMULTIDRAWELEMENTSPROC = CFUNCTYPE(None, GLenum, POINTER(GLsizei), GLenum, POINTER(POINTER(GLvoid)), GLsizei) 	# GL/glext.h:3606
PFNGLPOINTPARAMETERFPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:3607
PFNGLPOINTPARAMETERFVPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3608
PFNGLPOINTPARAMETERIPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:3609
PFNGLPOINTPARAMETERIVPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3610
PFNGLSECONDARYCOLOR3BPROC = CFUNCTYPE(None, GLbyte, GLbyte, GLbyte) 	# GL/glext.h:3611
PFNGLSECONDARYCOLOR3BVPROC = CFUNCTYPE(None, POINTER(GLbyte)) 	# GL/glext.h:3612
PFNGLSECONDARYCOLOR3DPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3613
PFNGLSECONDARYCOLOR3DVPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3614
PFNGLSECONDARYCOLOR3FPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3615
PFNGLSECONDARYCOLOR3FVPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3616
PFNGLSECONDARYCOLOR3IPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:3617
PFNGLSECONDARYCOLOR3IVPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:3618
PFNGLSECONDARYCOLOR3SPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort) 	# GL/glext.h:3619
PFNGLSECONDARYCOLOR3SVPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:3620
PFNGLSECONDARYCOLOR3UBPROC = CFUNCTYPE(None, GLubyte, GLubyte, GLubyte) 	# GL/glext.h:3621
PFNGLSECONDARYCOLOR3UBVPROC = CFUNCTYPE(None, POINTER(GLubyte)) 	# GL/glext.h:3622
PFNGLSECONDARYCOLOR3UIPROC = CFUNCTYPE(None, GLuint, GLuint, GLuint) 	# GL/glext.h:3623
PFNGLSECONDARYCOLOR3UIVPROC = CFUNCTYPE(None, POINTER(GLuint)) 	# GL/glext.h:3624
PFNGLSECONDARYCOLOR3USPROC = CFUNCTYPE(None, GLushort, GLushort, GLushort) 	# GL/glext.h:3625
PFNGLSECONDARYCOLOR3USVPROC = CFUNCTYPE(None, POINTER(GLushort)) 	# GL/glext.h:3626
PFNGLSECONDARYCOLORPOINTERPROC = CFUNCTYPE(None, GLint, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3627
PFNGLWINDOWPOS2DPROC = CFUNCTYPE(None, GLdouble, GLdouble) 	# GL/glext.h:3628
PFNGLWINDOWPOS2DVPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3629
PFNGLWINDOWPOS2FPROC = CFUNCTYPE(None, GLfloat, GLfloat) 	# GL/glext.h:3630
PFNGLWINDOWPOS2FVPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3631
PFNGLWINDOWPOS2IPROC = CFUNCTYPE(None, GLint, GLint) 	# GL/glext.h:3632
PFNGLWINDOWPOS2IVPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:3633
PFNGLWINDOWPOS2SPROC = CFUNCTYPE(None, GLshort, GLshort) 	# GL/glext.h:3634
PFNGLWINDOWPOS2SVPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:3635
PFNGLWINDOWPOS3DPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3636
PFNGLWINDOWPOS3DVPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3637
PFNGLWINDOWPOS3FPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3638
PFNGLWINDOWPOS3FVPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3639
PFNGLWINDOWPOS3IPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:3640
PFNGLWINDOWPOS3IVPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:3641
PFNGLWINDOWPOS3SPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort) 	# GL/glext.h:3642
PFNGLWINDOWPOS3SVPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:3643
# VERSION_1_5 (GL/glext.h:3646)
GL_VERSION_1_5 = 1 	# GL/glext.h:3647
# GL/glext.h:3649
glGenQueries = _link_function('glGenQueries', None, [GLsizei, POINTER(GLuint)], 'VERSION_1_5')

# GL/glext.h:3650
glDeleteQueries = _link_function('glDeleteQueries', None, [GLsizei, POINTER(GLuint)], 'VERSION_1_5')

# GL/glext.h:3651
glIsQuery = _link_function('glIsQuery', GLboolean, [GLuint], 'VERSION_1_5')

# GL/glext.h:3652
glBeginQuery = _link_function('glBeginQuery', None, [GLenum, GLuint], 'VERSION_1_5')

# GL/glext.h:3653
glEndQuery = _link_function('glEndQuery', None, [GLenum], 'VERSION_1_5')

# GL/glext.h:3654
glGetQueryiv = _link_function('glGetQueryiv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_5')

# GL/glext.h:3655
glGetQueryObjectiv = _link_function('glGetQueryObjectiv', None, [GLuint, GLenum, POINTER(GLint)], 'VERSION_1_5')

# GL/glext.h:3656
glGetQueryObjectuiv = _link_function('glGetQueryObjectuiv', None, [GLuint, GLenum, POINTER(GLuint)], 'VERSION_1_5')

# GL/glext.h:3657
glBindBuffer = _link_function('glBindBuffer', None, [GLenum, GLuint], 'VERSION_1_5')

# GL/glext.h:3658
glDeleteBuffers = _link_function('glDeleteBuffers', None, [GLsizei, POINTER(GLuint)], 'VERSION_1_5')

# GL/glext.h:3659
glGenBuffers = _link_function('glGenBuffers', None, [GLsizei, POINTER(GLuint)], 'VERSION_1_5')

# GL/glext.h:3660
glIsBuffer = _link_function('glIsBuffer', GLboolean, [GLuint], 'VERSION_1_5')

# GL/glext.h:3661
glBufferData = _link_function('glBufferData', None, [GLenum, GLsizeiptr, POINTER(GLvoid), GLenum], 'VERSION_1_5')

# GL/glext.h:3662
glBufferSubData = _link_function('glBufferSubData', None, [GLenum, GLintptr, GLsizeiptr, POINTER(GLvoid)], 'VERSION_1_5')

# GL/glext.h:3663
glGetBufferSubData = _link_function('glGetBufferSubData', None, [GLenum, GLintptr, GLsizeiptr, POINTER(GLvoid)], 'VERSION_1_5')

# GL/glext.h:3664
glMapBuffer = _link_function('glMapBuffer', POINTER(GLvoid), [GLenum, GLenum], 'VERSION_1_5')

# GL/glext.h:3665
glUnmapBuffer = _link_function('glUnmapBuffer', GLboolean, [GLenum], 'VERSION_1_5')

# GL/glext.h:3666
glGetBufferParameteriv = _link_function('glGetBufferParameteriv', None, [GLenum, GLenum, POINTER(GLint)], 'VERSION_1_5')

# GL/glext.h:3667
glGetBufferPointerv = _link_function('glGetBufferPointerv', None, [GLenum, GLenum, POINTER(POINTER(GLvoid))], 'VERSION_1_5')

PFNGLGENQUERIESPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:3669
PFNGLDELETEQUERIESPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:3670
PFNGLISQUERYPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:3671
PFNGLBEGINQUERYPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:3672
PFNGLENDQUERYPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3673
PFNGLGETQUERYIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3674
PFNGLGETQUERYOBJECTIVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:3675
PFNGLGETQUERYOBJECTUIVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLuint)) 	# GL/glext.h:3676
PFNGLBINDBUFFERPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:3677
PFNGLDELETEBUFFERSPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:3678
PFNGLGENBUFFERSPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:3679
PFNGLISBUFFERPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:3680
PFNGLBUFFERDATAPROC = CFUNCTYPE(None, GLenum, GLsizeiptr, POINTER(GLvoid), GLenum) 	# GL/glext.h:3681
PFNGLBUFFERSUBDATAPROC = CFUNCTYPE(None, GLenum, GLintptr, GLsizeiptr, POINTER(GLvoid)) 	# GL/glext.h:3682
PFNGLGETBUFFERSUBDATAPROC = CFUNCTYPE(None, GLenum, GLintptr, GLsizeiptr, POINTER(GLvoid)) 	# GL/glext.h:3683
PFNGLMAPBUFFERPROC = CFUNCTYPE(POINTER(GLvoid), GLenum, GLenum) 	# GL/glext.h:3684
PFNGLUNMAPBUFFERPROC = CFUNCTYPE(GLboolean, GLenum) 	# GL/glext.h:3685
PFNGLGETBUFFERPARAMETERIVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:3686
PFNGLGETBUFFERPOINTERVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:3687
# VERSION_2_0 (GL/glext.h:3690)
GL_VERSION_2_0 = 1 	# GL/glext.h:3691
# GL/glext.h:3693
glBlendEquationSeparate = _link_function('glBlendEquationSeparate', None, [GLenum, GLenum], 'VERSION_2_0')

# GL/glext.h:3694
glDrawBuffers = _link_function('glDrawBuffers', None, [GLsizei, POINTER(GLenum)], 'VERSION_2_0')

# GL/glext.h:3695
glStencilOpSeparate = _link_function('glStencilOpSeparate', None, [GLenum, GLenum, GLenum, GLenum], 'VERSION_2_0')

# GL/glext.h:3696
glStencilFuncSeparate = _link_function('glStencilFuncSeparate', None, [GLenum, GLenum, GLint, GLuint], 'VERSION_2_0')

# GL/glext.h:3697
glStencilMaskSeparate = _link_function('glStencilMaskSeparate', None, [GLenum, GLuint], 'VERSION_2_0')

# GL/glext.h:3698
glAttachShader = _link_function('glAttachShader', None, [GLuint, GLuint], 'VERSION_2_0')

# GL/glext.h:3699
glBindAttribLocation = _link_function('glBindAttribLocation', None, [GLuint, GLuint, POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3700
glCompileShader = _link_function('glCompileShader', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3701
glCreateProgram = _link_function('glCreateProgram', GLuint, [], 'VERSION_2_0')

# GL/glext.h:3702
glCreateShader = _link_function('glCreateShader', GLuint, [GLenum], 'VERSION_2_0')

# GL/glext.h:3703
glDeleteProgram = _link_function('glDeleteProgram', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3704
glDeleteShader = _link_function('glDeleteShader', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3705
glDetachShader = _link_function('glDetachShader', None, [GLuint, GLuint], 'VERSION_2_0')

# GL/glext.h:3706
glDisableVertexAttribArray = _link_function('glDisableVertexAttribArray', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3707
glEnableVertexAttribArray = _link_function('glEnableVertexAttribArray', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3708
glGetActiveAttrib = _link_function('glGetActiveAttrib', None, [GLuint, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3709
glGetActiveUniform = _link_function('glGetActiveUniform', None, [GLuint, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3710
glGetAttachedShaders = _link_function('glGetAttachedShaders', None, [GLuint, GLsizei, POINTER(GLsizei), POINTER(GLuint)], 'VERSION_2_0')

# GL/glext.h:3711
glGetAttribLocation = _link_function('glGetAttribLocation', GLint, [GLuint, POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3712
glGetProgramiv = _link_function('glGetProgramiv', None, [GLuint, GLenum, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3713
glGetProgramInfoLog = _link_function('glGetProgramInfoLog', None, [GLuint, GLsizei, POINTER(GLsizei), POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3714
glGetShaderiv = _link_function('glGetShaderiv', None, [GLuint, GLenum, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3715
glGetShaderInfoLog = _link_function('glGetShaderInfoLog', None, [GLuint, GLsizei, POINTER(GLsizei), POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3716
glGetShaderSource = _link_function('glGetShaderSource', None, [GLuint, GLsizei, POINTER(GLsizei), POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3717
glGetUniformLocation = _link_function('glGetUniformLocation', GLint, [GLuint, POINTER(GLchar)], 'VERSION_2_0')

# GL/glext.h:3718
glGetUniformfv = _link_function('glGetUniformfv', None, [GLuint, GLint, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3719
glGetUniformiv = _link_function('glGetUniformiv', None, [GLuint, GLint, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3720
glGetVertexAttribdv = _link_function('glGetVertexAttribdv', None, [GLuint, GLenum, POINTER(GLdouble)], 'VERSION_2_0')

# GL/glext.h:3721
glGetVertexAttribfv = _link_function('glGetVertexAttribfv', None, [GLuint, GLenum, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3722
glGetVertexAttribiv = _link_function('glGetVertexAttribiv', None, [GLuint, GLenum, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3723
glGetVertexAttribPointerv = _link_function('glGetVertexAttribPointerv', None, [GLuint, GLenum, POINTER(POINTER(GLvoid))], 'VERSION_2_0')

# GL/glext.h:3724
glIsProgram = _link_function('glIsProgram', GLboolean, [GLuint], 'VERSION_2_0')

# GL/glext.h:3725
glIsShader = _link_function('glIsShader', GLboolean, [GLuint], 'VERSION_2_0')

# GL/glext.h:3726
glLinkProgram = _link_function('glLinkProgram', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3727
glShaderSource = _link_function('glShaderSource', None, [GLuint, GLsizei, POINTER(POINTER(GLchar)), POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3728
glUseProgram = _link_function('glUseProgram', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3729
glUniform1f = _link_function('glUniform1f', None, [GLint, GLfloat], 'VERSION_2_0')

# GL/glext.h:3730
glUniform2f = _link_function('glUniform2f', None, [GLint, GLfloat, GLfloat], 'VERSION_2_0')

# GL/glext.h:3731
glUniform3f = _link_function('glUniform3f', None, [GLint, GLfloat, GLfloat, GLfloat], 'VERSION_2_0')

# GL/glext.h:3732
glUniform4f = _link_function('glUniform4f', None, [GLint, GLfloat, GLfloat, GLfloat, GLfloat], 'VERSION_2_0')

# GL/glext.h:3733
glUniform1i = _link_function('glUniform1i', None, [GLint, GLint], 'VERSION_2_0')

# GL/glext.h:3734
glUniform2i = _link_function('glUniform2i', None, [GLint, GLint, GLint], 'VERSION_2_0')

# GL/glext.h:3735
glUniform3i = _link_function('glUniform3i', None, [GLint, GLint, GLint, GLint], 'VERSION_2_0')

# GL/glext.h:3736
glUniform4i = _link_function('glUniform4i', None, [GLint, GLint, GLint, GLint, GLint], 'VERSION_2_0')

# GL/glext.h:3737
glUniform1fv = _link_function('glUniform1fv', None, [GLint, GLsizei, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3738
glUniform2fv = _link_function('glUniform2fv', None, [GLint, GLsizei, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3739
glUniform3fv = _link_function('glUniform3fv', None, [GLint, GLsizei, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3740
glUniform4fv = _link_function('glUniform4fv', None, [GLint, GLsizei, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3741
glUniform1iv = _link_function('glUniform1iv', None, [GLint, GLsizei, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3742
glUniform2iv = _link_function('glUniform2iv', None, [GLint, GLsizei, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3743
glUniform3iv = _link_function('glUniform3iv', None, [GLint, GLsizei, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3744
glUniform4iv = _link_function('glUniform4iv', None, [GLint, GLsizei, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3745
glUniformMatrix2fv = _link_function('glUniformMatrix2fv', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3746
glUniformMatrix3fv = _link_function('glUniformMatrix3fv', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3747
glUniformMatrix4fv = _link_function('glUniformMatrix4fv', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3748
glValidateProgram = _link_function('glValidateProgram', None, [GLuint], 'VERSION_2_0')

# GL/glext.h:3749
glVertexAttrib1d = _link_function('glVertexAttrib1d', None, [GLuint, GLdouble], 'VERSION_2_0')

# GL/glext.h:3750
glVertexAttrib1dv = _link_function('glVertexAttrib1dv', None, [GLuint, POINTER(GLdouble)], 'VERSION_2_0')

# GL/glext.h:3751
glVertexAttrib1f = _link_function('glVertexAttrib1f', None, [GLuint, GLfloat], 'VERSION_2_0')

# GL/glext.h:3752
glVertexAttrib1fv = _link_function('glVertexAttrib1fv', None, [GLuint, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3753
glVertexAttrib1s = _link_function('glVertexAttrib1s', None, [GLuint, GLshort], 'VERSION_2_0')

# GL/glext.h:3754
glVertexAttrib1sv = _link_function('glVertexAttrib1sv', None, [GLuint, POINTER(GLshort)], 'VERSION_2_0')

# GL/glext.h:3755
glVertexAttrib2d = _link_function('glVertexAttrib2d', None, [GLuint, GLdouble, GLdouble], 'VERSION_2_0')

# GL/glext.h:3756
glVertexAttrib2dv = _link_function('glVertexAttrib2dv', None, [GLuint, POINTER(GLdouble)], 'VERSION_2_0')

# GL/glext.h:3757
glVertexAttrib2f = _link_function('glVertexAttrib2f', None, [GLuint, GLfloat, GLfloat], 'VERSION_2_0')

# GL/glext.h:3758
glVertexAttrib2fv = _link_function('glVertexAttrib2fv', None, [GLuint, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3759
glVertexAttrib2s = _link_function('glVertexAttrib2s', None, [GLuint, GLshort, GLshort], 'VERSION_2_0')

# GL/glext.h:3760
glVertexAttrib2sv = _link_function('glVertexAttrib2sv', None, [GLuint, POINTER(GLshort)], 'VERSION_2_0')

# GL/glext.h:3761
glVertexAttrib3d = _link_function('glVertexAttrib3d', None, [GLuint, GLdouble, GLdouble, GLdouble], 'VERSION_2_0')

# GL/glext.h:3762
glVertexAttrib3dv = _link_function('glVertexAttrib3dv', None, [GLuint, POINTER(GLdouble)], 'VERSION_2_0')

# GL/glext.h:3763
glVertexAttrib3f = _link_function('glVertexAttrib3f', None, [GLuint, GLfloat, GLfloat, GLfloat], 'VERSION_2_0')

# GL/glext.h:3764
glVertexAttrib3fv = _link_function('glVertexAttrib3fv', None, [GLuint, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3765
glVertexAttrib3s = _link_function('glVertexAttrib3s', None, [GLuint, GLshort, GLshort, GLshort], 'VERSION_2_0')

# GL/glext.h:3766
glVertexAttrib3sv = _link_function('glVertexAttrib3sv', None, [GLuint, POINTER(GLshort)], 'VERSION_2_0')

# GL/glext.h:3767
glVertexAttrib4Nbv = _link_function('glVertexAttrib4Nbv', None, [GLuint, POINTER(GLbyte)], 'VERSION_2_0')

# GL/glext.h:3768
glVertexAttrib4Niv = _link_function('glVertexAttrib4Niv', None, [GLuint, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3769
glVertexAttrib4Nsv = _link_function('glVertexAttrib4Nsv', None, [GLuint, POINTER(GLshort)], 'VERSION_2_0')

# GL/glext.h:3770
glVertexAttrib4Nub = _link_function('glVertexAttrib4Nub', None, [GLuint, GLubyte, GLubyte, GLubyte, GLubyte], 'VERSION_2_0')

# GL/glext.h:3771
glVertexAttrib4Nubv = _link_function('glVertexAttrib4Nubv', None, [GLuint, POINTER(GLubyte)], 'VERSION_2_0')

# GL/glext.h:3772
glVertexAttrib4Nuiv = _link_function('glVertexAttrib4Nuiv', None, [GLuint, POINTER(GLuint)], 'VERSION_2_0')

# GL/glext.h:3773
glVertexAttrib4Nusv = _link_function('glVertexAttrib4Nusv', None, [GLuint, POINTER(GLushort)], 'VERSION_2_0')

# GL/glext.h:3774
glVertexAttrib4bv = _link_function('glVertexAttrib4bv', None, [GLuint, POINTER(GLbyte)], 'VERSION_2_0')

# GL/glext.h:3775
glVertexAttrib4d = _link_function('glVertexAttrib4d', None, [GLuint, GLdouble, GLdouble, GLdouble, GLdouble], 'VERSION_2_0')

# GL/glext.h:3776
glVertexAttrib4dv = _link_function('glVertexAttrib4dv', None, [GLuint, POINTER(GLdouble)], 'VERSION_2_0')

# GL/glext.h:3777
glVertexAttrib4f = _link_function('glVertexAttrib4f', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat], 'VERSION_2_0')

# GL/glext.h:3778
glVertexAttrib4fv = _link_function('glVertexAttrib4fv', None, [GLuint, POINTER(GLfloat)], 'VERSION_2_0')

# GL/glext.h:3779
glVertexAttrib4iv = _link_function('glVertexAttrib4iv', None, [GLuint, POINTER(GLint)], 'VERSION_2_0')

# GL/glext.h:3780
glVertexAttrib4s = _link_function('glVertexAttrib4s', None, [GLuint, GLshort, GLshort, GLshort, GLshort], 'VERSION_2_0')

# GL/glext.h:3781
glVertexAttrib4sv = _link_function('glVertexAttrib4sv', None, [GLuint, POINTER(GLshort)], 'VERSION_2_0')

# GL/glext.h:3782
glVertexAttrib4ubv = _link_function('glVertexAttrib4ubv', None, [GLuint, POINTER(GLubyte)], 'VERSION_2_0')

# GL/glext.h:3783
glVertexAttrib4uiv = _link_function('glVertexAttrib4uiv', None, [GLuint, POINTER(GLuint)], 'VERSION_2_0')

# GL/glext.h:3784
glVertexAttrib4usv = _link_function('glVertexAttrib4usv', None, [GLuint, POINTER(GLushort)], 'VERSION_2_0')

# GL/glext.h:3785
glVertexAttribPointer = _link_function('glVertexAttribPointer', None, [GLuint, GLint, GLenum, GLboolean, GLsizei, POINTER(GLvoid)], 'VERSION_2_0')

PFNGLBLENDEQUATIONSEPARATEPROC = CFUNCTYPE(None, GLenum, GLenum) 	# GL/glext.h:3787
PFNGLDRAWBUFFERSPROC = CFUNCTYPE(None, GLsizei, POINTER(GLenum)) 	# GL/glext.h:3788
PFNGLSTENCILOPSEPARATEPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:3789
PFNGLSTENCILFUNCSEPARATEPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLuint) 	# GL/glext.h:3790
PFNGLSTENCILMASKSEPARATEPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:3791
PFNGLATTACHSHADERPROC = CFUNCTYPE(None, GLuint, GLuint) 	# GL/glext.h:3792
PFNGLBINDATTRIBLOCATIONPROC = CFUNCTYPE(None, GLuint, GLuint, POINTER(GLchar)) 	# GL/glext.h:3793
PFNGLCOMPILESHADERPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3794
PFNGLCREATEPROGRAMPROC = CFUNCTYPE(GLuint) 	# GL/glext.h:3795
PFNGLCREATESHADERPROC = CFUNCTYPE(GLuint, GLenum) 	# GL/glext.h:3796
PFNGLDELETEPROGRAMPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3797
PFNGLDELETESHADERPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3798
PFNGLDETACHSHADERPROC = CFUNCTYPE(None, GLuint, GLuint) 	# GL/glext.h:3799
PFNGLDISABLEVERTEXATTRIBARRAYPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3800
PFNGLENABLEVERTEXATTRIBARRAYPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3801
PFNGLGETACTIVEATTRIBPROC = CFUNCTYPE(None, GLuint, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLchar)) 	# GL/glext.h:3802
PFNGLGETACTIVEUNIFORMPROC = CFUNCTYPE(None, GLuint, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLchar)) 	# GL/glext.h:3803
PFNGLGETATTACHEDSHADERSPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLuint)) 	# GL/glext.h:3804
PFNGLGETATTRIBLOCATIONPROC = CFUNCTYPE(GLint, GLuint, POINTER(GLchar)) 	# GL/glext.h:3805
PFNGLGETPROGRAMIVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:3806
PFNGLGETPROGRAMINFOLOGPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLchar)) 	# GL/glext.h:3807
PFNGLGETSHADERIVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:3808
PFNGLGETSHADERINFOLOGPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLchar)) 	# GL/glext.h:3809
PFNGLGETSHADERSOURCEPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLchar)) 	# GL/glext.h:3810
PFNGLGETUNIFORMLOCATIONPROC = CFUNCTYPE(GLint, GLuint, POINTER(GLchar)) 	# GL/glext.h:3811
PFNGLGETUNIFORMFVPROC = CFUNCTYPE(None, GLuint, GLint, POINTER(GLfloat)) 	# GL/glext.h:3812
PFNGLGETUNIFORMIVPROC = CFUNCTYPE(None, GLuint, GLint, POINTER(GLint)) 	# GL/glext.h:3813
PFNGLGETVERTEXATTRIBDVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3814
PFNGLGETVERTEXATTRIBFVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3815
PFNGLGETVERTEXATTRIBIVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:3816
PFNGLGETVERTEXATTRIBPOINTERVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:3817
PFNGLISPROGRAMPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:3818
PFNGLISSHADERPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:3819
PFNGLLINKPROGRAMPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3820
PFNGLSHADERSOURCEPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(POINTER(GLchar)), POINTER(GLint)) 	# GL/glext.h:3821
PFNGLUSEPROGRAMPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3822
PFNGLUNIFORM1FPROC = CFUNCTYPE(None, GLint, GLfloat) 	# GL/glext.h:3823
PFNGLUNIFORM2FPROC = CFUNCTYPE(None, GLint, GLfloat, GLfloat) 	# GL/glext.h:3824
PFNGLUNIFORM3FPROC = CFUNCTYPE(None, GLint, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3825
PFNGLUNIFORM4FPROC = CFUNCTYPE(None, GLint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3826
PFNGLUNIFORM1IPROC = CFUNCTYPE(None, GLint, GLint) 	# GL/glext.h:3827
PFNGLUNIFORM2IPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:3828
PFNGLUNIFORM3IPROC = CFUNCTYPE(None, GLint, GLint, GLint, GLint) 	# GL/glext.h:3829
PFNGLUNIFORM4IPROC = CFUNCTYPE(None, GLint, GLint, GLint, GLint, GLint) 	# GL/glext.h:3830
PFNGLUNIFORM1FVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:3831
PFNGLUNIFORM2FVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:3832
PFNGLUNIFORM3FVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:3833
PFNGLUNIFORM4FVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:3834
PFNGLUNIFORM1IVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:3835
PFNGLUNIFORM2IVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:3836
PFNGLUNIFORM3IVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:3837
PFNGLUNIFORM4IVPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:3838
PFNGLUNIFORMMATRIX2FVPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:3839
PFNGLUNIFORMMATRIX3FVPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:3840
PFNGLUNIFORMMATRIX4FVPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:3841
PFNGLVALIDATEPROGRAMPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:3842
PFNGLVERTEXATTRIB1DPROC = CFUNCTYPE(None, GLuint, GLdouble) 	# GL/glext.h:3843
PFNGLVERTEXATTRIB1DVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3844
PFNGLVERTEXATTRIB1FPROC = CFUNCTYPE(None, GLuint, GLfloat) 	# GL/glext.h:3845
PFNGLVERTEXATTRIB1FVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3846
PFNGLVERTEXATTRIB1SPROC = CFUNCTYPE(None, GLuint, GLshort) 	# GL/glext.h:3847
PFNGLVERTEXATTRIB1SVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:3848
PFNGLVERTEXATTRIB2DPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble) 	# GL/glext.h:3849
PFNGLVERTEXATTRIB2DVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3850
PFNGLVERTEXATTRIB2FPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat) 	# GL/glext.h:3851
PFNGLVERTEXATTRIB2FVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3852
PFNGLVERTEXATTRIB2SPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort) 	# GL/glext.h:3853
PFNGLVERTEXATTRIB2SVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:3854
PFNGLVERTEXATTRIB3DPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3855
PFNGLVERTEXATTRIB3DVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3856
PFNGLVERTEXATTRIB3FPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3857
PFNGLVERTEXATTRIB3FVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3858
PFNGLVERTEXATTRIB3SPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort, GLshort) 	# GL/glext.h:3859
PFNGLVERTEXATTRIB3SVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:3860
PFNGLVERTEXATTRIB4NBVPROC = CFUNCTYPE(None, GLuint, POINTER(GLbyte)) 	# GL/glext.h:3861
PFNGLVERTEXATTRIB4NIVPROC = CFUNCTYPE(None, GLuint, POINTER(GLint)) 	# GL/glext.h:3862
PFNGLVERTEXATTRIB4NSVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:3863
PFNGLVERTEXATTRIB4NUBPROC = CFUNCTYPE(None, GLuint, GLubyte, GLubyte, GLubyte, GLubyte) 	# GL/glext.h:3864
PFNGLVERTEXATTRIB4NUBVPROC = CFUNCTYPE(None, GLuint, POINTER(GLubyte)) 	# GL/glext.h:3865
PFNGLVERTEXATTRIB4NUIVPROC = CFUNCTYPE(None, GLuint, POINTER(GLuint)) 	# GL/glext.h:3866
PFNGLVERTEXATTRIB4NUSVPROC = CFUNCTYPE(None, GLuint, POINTER(GLushort)) 	# GL/glext.h:3867
PFNGLVERTEXATTRIB4BVPROC = CFUNCTYPE(None, GLuint, POINTER(GLbyte)) 	# GL/glext.h:3868
PFNGLVERTEXATTRIB4DPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3869
PFNGLVERTEXATTRIB4DVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:3870
PFNGLVERTEXATTRIB4FPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3871
PFNGLVERTEXATTRIB4FVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:3872
PFNGLVERTEXATTRIB4IVPROC = CFUNCTYPE(None, GLuint, POINTER(GLint)) 	# GL/glext.h:3873
PFNGLVERTEXATTRIB4SPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort, GLshort, GLshort) 	# GL/glext.h:3874
PFNGLVERTEXATTRIB4SVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:3875
PFNGLVERTEXATTRIB4UBVPROC = CFUNCTYPE(None, GLuint, POINTER(GLubyte)) 	# GL/glext.h:3876
PFNGLVERTEXATTRIB4UIVPROC = CFUNCTYPE(None, GLuint, POINTER(GLuint)) 	# GL/glext.h:3877
PFNGLVERTEXATTRIB4USVPROC = CFUNCTYPE(None, GLuint, POINTER(GLushort)) 	# GL/glext.h:3878
PFNGLVERTEXATTRIBPOINTERPROC = CFUNCTYPE(None, GLuint, GLint, GLenum, GLboolean, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:3879
# VERSION_2_1 (GL/glext.h:3882)
GL_VERSION_2_1 = 1 	# GL/glext.h:3883
# GL/glext.h:3885
glUniformMatrix2x3fv = _link_function('glUniformMatrix2x3fv', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'VERSION_2_1')

# GL/glext.h:3886
glUniformMatrix3x2fv = _link_function('glUniformMatrix3x2fv', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'VERSION_2_1')

# GL/glext.h:3887
glUniformMatrix2x4fv = _link_function('glUniformMatrix2x4fv', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'VERSION_2_1')

# GL/glext.h:3888
glUniformMatrix4x2fv = _link_function('glUniformMatrix4x2fv', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'VERSION_2_1')

# GL/glext.h:3889
glUniformMatrix3x4fv = _link_function('glUniformMatrix3x4fv', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'VERSION_2_1')

# GL/glext.h:3890
glUniformMatrix4x3fv = _link_function('glUniformMatrix4x3fv', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'VERSION_2_1')

PFNGLUNIFORMMATRIX2X3FVPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:3892
PFNGLUNIFORMMATRIX3X2FVPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:3893
PFNGLUNIFORMMATRIX2X4FVPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:3894
PFNGLUNIFORMMATRIX4X2FVPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:3895
PFNGLUNIFORMMATRIX3X4FVPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:3896
PFNGLUNIFORMMATRIX4X3FVPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:3897
# ARB_multitexture (GL/glext.h:3900)
GL_ARB_multitexture = 1 	# GL/glext.h:3901
# GL/glext.h:3903
glActiveTextureARB = _link_function('glActiveTextureARB', None, [GLenum], 'ARB_multitexture')

# GL/glext.h:3904
glClientActiveTextureARB = _link_function('glClientActiveTextureARB', None, [GLenum], 'ARB_multitexture')

# GL/glext.h:3905
glMultiTexCoord1dARB = _link_function('glMultiTexCoord1dARB', None, [GLenum, GLdouble], 'ARB_multitexture')

# GL/glext.h:3906
glMultiTexCoord1dvARB = _link_function('glMultiTexCoord1dvARB', None, [GLenum, POINTER(GLdouble)], 'ARB_multitexture')

# GL/glext.h:3907
glMultiTexCoord1fARB = _link_function('glMultiTexCoord1fARB', None, [GLenum, GLfloat], 'ARB_multitexture')

# GL/glext.h:3908
glMultiTexCoord1fvARB = _link_function('glMultiTexCoord1fvARB', None, [GLenum, POINTER(GLfloat)], 'ARB_multitexture')

# GL/glext.h:3909
glMultiTexCoord1iARB = _link_function('glMultiTexCoord1iARB', None, [GLenum, GLint], 'ARB_multitexture')

# GL/glext.h:3910
glMultiTexCoord1ivARB = _link_function('glMultiTexCoord1ivARB', None, [GLenum, POINTER(GLint)], 'ARB_multitexture')

# GL/glext.h:3911
glMultiTexCoord1sARB = _link_function('glMultiTexCoord1sARB', None, [GLenum, GLshort], 'ARB_multitexture')

# GL/glext.h:3912
glMultiTexCoord1svARB = _link_function('glMultiTexCoord1svARB', None, [GLenum, POINTER(GLshort)], 'ARB_multitexture')

# GL/glext.h:3913
glMultiTexCoord2dARB = _link_function('glMultiTexCoord2dARB', None, [GLenum, GLdouble, GLdouble], 'ARB_multitexture')

# GL/glext.h:3914
glMultiTexCoord2dvARB = _link_function('glMultiTexCoord2dvARB', None, [GLenum, POINTER(GLdouble)], 'ARB_multitexture')

# GL/glext.h:3915
glMultiTexCoord2fARB = _link_function('glMultiTexCoord2fARB', None, [GLenum, GLfloat, GLfloat], 'ARB_multitexture')

# GL/glext.h:3916
glMultiTexCoord2fvARB = _link_function('glMultiTexCoord2fvARB', None, [GLenum, POINTER(GLfloat)], 'ARB_multitexture')

# GL/glext.h:3917
glMultiTexCoord2iARB = _link_function('glMultiTexCoord2iARB', None, [GLenum, GLint, GLint], 'ARB_multitexture')

# GL/glext.h:3918
glMultiTexCoord2ivARB = _link_function('glMultiTexCoord2ivARB', None, [GLenum, POINTER(GLint)], 'ARB_multitexture')

# GL/glext.h:3919
glMultiTexCoord2sARB = _link_function('glMultiTexCoord2sARB', None, [GLenum, GLshort, GLshort], 'ARB_multitexture')

# GL/glext.h:3920
glMultiTexCoord2svARB = _link_function('glMultiTexCoord2svARB', None, [GLenum, POINTER(GLshort)], 'ARB_multitexture')

# GL/glext.h:3921
glMultiTexCoord3dARB = _link_function('glMultiTexCoord3dARB', None, [GLenum, GLdouble, GLdouble, GLdouble], 'ARB_multitexture')

# GL/glext.h:3922
glMultiTexCoord3dvARB = _link_function('glMultiTexCoord3dvARB', None, [GLenum, POINTER(GLdouble)], 'ARB_multitexture')

# GL/glext.h:3923
glMultiTexCoord3fARB = _link_function('glMultiTexCoord3fARB', None, [GLenum, GLfloat, GLfloat, GLfloat], 'ARB_multitexture')

# GL/glext.h:3924
glMultiTexCoord3fvARB = _link_function('glMultiTexCoord3fvARB', None, [GLenum, POINTER(GLfloat)], 'ARB_multitexture')

# GL/glext.h:3925
glMultiTexCoord3iARB = _link_function('glMultiTexCoord3iARB', None, [GLenum, GLint, GLint, GLint], 'ARB_multitexture')

# GL/glext.h:3926
glMultiTexCoord3ivARB = _link_function('glMultiTexCoord3ivARB', None, [GLenum, POINTER(GLint)], 'ARB_multitexture')

# GL/glext.h:3927
glMultiTexCoord3sARB = _link_function('glMultiTexCoord3sARB', None, [GLenum, GLshort, GLshort, GLshort], 'ARB_multitexture')

# GL/glext.h:3928
glMultiTexCoord3svARB = _link_function('glMultiTexCoord3svARB', None, [GLenum, POINTER(GLshort)], 'ARB_multitexture')

# GL/glext.h:3929
glMultiTexCoord4dARB = _link_function('glMultiTexCoord4dARB', None, [GLenum, GLdouble, GLdouble, GLdouble, GLdouble], 'ARB_multitexture')

# GL/glext.h:3930
glMultiTexCoord4dvARB = _link_function('glMultiTexCoord4dvARB', None, [GLenum, POINTER(GLdouble)], 'ARB_multitexture')

# GL/glext.h:3931
glMultiTexCoord4fARB = _link_function('glMultiTexCoord4fARB', None, [GLenum, GLfloat, GLfloat, GLfloat, GLfloat], 'ARB_multitexture')

# GL/glext.h:3932
glMultiTexCoord4fvARB = _link_function('glMultiTexCoord4fvARB', None, [GLenum, POINTER(GLfloat)], 'ARB_multitexture')

# GL/glext.h:3933
glMultiTexCoord4iARB = _link_function('glMultiTexCoord4iARB', None, [GLenum, GLint, GLint, GLint, GLint], 'ARB_multitexture')

# GL/glext.h:3934
glMultiTexCoord4ivARB = _link_function('glMultiTexCoord4ivARB', None, [GLenum, POINTER(GLint)], 'ARB_multitexture')

# GL/glext.h:3935
glMultiTexCoord4sARB = _link_function('glMultiTexCoord4sARB', None, [GLenum, GLshort, GLshort, GLshort, GLshort], 'ARB_multitexture')

# GL/glext.h:3936
glMultiTexCoord4svARB = _link_function('glMultiTexCoord4svARB', None, [GLenum, POINTER(GLshort)], 'ARB_multitexture')

PFNGLACTIVETEXTUREARBPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3938
PFNGLCLIENTACTIVETEXTUREARBPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:3939
PFNGLMULTITEXCOORD1DARBPROC = CFUNCTYPE(None, GLenum, GLdouble) 	# GL/glext.h:3940
PFNGLMULTITEXCOORD1DVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3941
PFNGLMULTITEXCOORD1FARBPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:3942
PFNGLMULTITEXCOORD1FVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3943
PFNGLMULTITEXCOORD1IARBPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:3944
PFNGLMULTITEXCOORD1IVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3945
PFNGLMULTITEXCOORD1SARBPROC = CFUNCTYPE(None, GLenum, GLshort) 	# GL/glext.h:3946
PFNGLMULTITEXCOORD1SVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3947
PFNGLMULTITEXCOORD2DARBPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble) 	# GL/glext.h:3948
PFNGLMULTITEXCOORD2DVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3949
PFNGLMULTITEXCOORD2FARBPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat) 	# GL/glext.h:3950
PFNGLMULTITEXCOORD2FVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3951
PFNGLMULTITEXCOORD2IARBPROC = CFUNCTYPE(None, GLenum, GLint, GLint) 	# GL/glext.h:3952
PFNGLMULTITEXCOORD2IVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3953
PFNGLMULTITEXCOORD2SARBPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort) 	# GL/glext.h:3954
PFNGLMULTITEXCOORD2SVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3955
PFNGLMULTITEXCOORD3DARBPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3956
PFNGLMULTITEXCOORD3DVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3957
PFNGLMULTITEXCOORD3FARBPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3958
PFNGLMULTITEXCOORD3FVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3959
PFNGLMULTITEXCOORD3IARBPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint) 	# GL/glext.h:3960
PFNGLMULTITEXCOORD3IVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3961
PFNGLMULTITEXCOORD3SARBPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort, GLshort) 	# GL/glext.h:3962
PFNGLMULTITEXCOORD3SVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3963
PFNGLMULTITEXCOORD4DARBPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:3964
PFNGLMULTITEXCOORD4DVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:3965
PFNGLMULTITEXCOORD4FARBPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:3966
PFNGLMULTITEXCOORD4FVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:3967
PFNGLMULTITEXCOORD4IARBPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint) 	# GL/glext.h:3968
PFNGLMULTITEXCOORD4IVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:3969
PFNGLMULTITEXCOORD4SARBPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort, GLshort, GLshort) 	# GL/glext.h:3970
PFNGLMULTITEXCOORD4SVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:3971
# ARB_transpose_matrix (GL/glext.h:3974)
GL_ARB_transpose_matrix = 1 	# GL/glext.h:3975
# GL/glext.h:3977
glLoadTransposeMatrixfARB = _link_function('glLoadTransposeMatrixfARB', None, [POINTER(GLfloat)], 'ARB_transpose_matrix')

# GL/glext.h:3978
glLoadTransposeMatrixdARB = _link_function('glLoadTransposeMatrixdARB', None, [POINTER(GLdouble)], 'ARB_transpose_matrix')

# GL/glext.h:3979
glMultTransposeMatrixfARB = _link_function('glMultTransposeMatrixfARB', None, [POINTER(GLfloat)], 'ARB_transpose_matrix')

# GL/glext.h:3980
glMultTransposeMatrixdARB = _link_function('glMultTransposeMatrixdARB', None, [POINTER(GLdouble)], 'ARB_transpose_matrix')

PFNGLLOADTRANSPOSEMATRIXFARBPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3982
PFNGLLOADTRANSPOSEMATRIXDARBPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3983
PFNGLMULTTRANSPOSEMATRIXFARBPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:3984
PFNGLMULTTRANSPOSEMATRIXDARBPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:3985
# ARB_multisample (GL/glext.h:3988)
GL_ARB_multisample = 1 	# GL/glext.h:3989
# GL/glext.h:3991
glSampleCoverageARB = _link_function('glSampleCoverageARB', None, [GLclampf, GLboolean], 'ARB_multisample')

PFNGLSAMPLECOVERAGEARBPROC = CFUNCTYPE(None, GLclampf, GLboolean) 	# GL/glext.h:3993
# ARB_texture_env_add (GL/glext.h:3996)
GL_ARB_texture_env_add = 1 	# GL/glext.h:3997
# ARB_texture_cube_map (GL/glext.h:4000)
GL_ARB_texture_cube_map = 1 	# GL/glext.h:4001
# ARB_texture_compression (GL/glext.h:4004)
GL_ARB_texture_compression = 1 	# GL/glext.h:4005
# GL/glext.h:4007
glCompressedTexImage3DARB = _link_function('glCompressedTexImage3DARB', None, [GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)], 'ARB_texture_compression')

# GL/glext.h:4008
glCompressedTexImage2DARB = _link_function('glCompressedTexImage2DARB', None, [GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)], 'ARB_texture_compression')

# GL/glext.h:4009
glCompressedTexImage1DARB = _link_function('glCompressedTexImage1DARB', None, [GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, POINTER(GLvoid)], 'ARB_texture_compression')

# GL/glext.h:4010
glCompressedTexSubImage3DARB = _link_function('glCompressedTexSubImage3DARB', None, [GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)], 'ARB_texture_compression')

# GL/glext.h:4011
glCompressedTexSubImage2DARB = _link_function('glCompressedTexSubImage2DARB', None, [GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)], 'ARB_texture_compression')

# GL/glext.h:4012
glCompressedTexSubImage1DARB = _link_function('glCompressedTexSubImage1DARB', None, [GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, POINTER(GLvoid)], 'ARB_texture_compression')

# GL/glext.h:4013
glGetCompressedTexImageARB = _link_function('glGetCompressedTexImageARB', None, [GLenum, GLint, POINTER(GLvoid)], 'ARB_texture_compression')

PFNGLCOMPRESSEDTEXIMAGE3DARBPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4015
PFNGLCOMPRESSEDTEXIMAGE2DARBPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4016
PFNGLCOMPRESSEDTEXIMAGE1DARBPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4017
PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4018
PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4019
PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4020
PFNGLGETCOMPRESSEDTEXIMAGEARBPROC = CFUNCTYPE(None, GLenum, GLint, POINTER(GLvoid)) 	# GL/glext.h:4021
# ARB_texture_border_clamp (GL/glext.h:4024)
GL_ARB_texture_border_clamp = 1 	# GL/glext.h:4025
# ARB_point_parameters (GL/glext.h:4028)
GL_ARB_point_parameters = 1 	# GL/glext.h:4029
# GL/glext.h:4031
glPointParameterfARB = _link_function('glPointParameterfARB', None, [GLenum, GLfloat], 'ARB_point_parameters')

# GL/glext.h:4032
glPointParameterfvARB = _link_function('glPointParameterfvARB', None, [GLenum, POINTER(GLfloat)], 'ARB_point_parameters')

PFNGLPOINTPARAMETERFARBPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:4034
PFNGLPOINTPARAMETERFVARBPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4035
# ARB_vertex_blend (GL/glext.h:4038)
GL_ARB_vertex_blend = 1 	# GL/glext.h:4039
# GL/glext.h:4041
glWeightbvARB = _link_function('glWeightbvARB', None, [GLint, POINTER(GLbyte)], 'ARB_vertex_blend')

# GL/glext.h:4042
glWeightsvARB = _link_function('glWeightsvARB', None, [GLint, POINTER(GLshort)], 'ARB_vertex_blend')

# GL/glext.h:4043
glWeightivARB = _link_function('glWeightivARB', None, [GLint, POINTER(GLint)], 'ARB_vertex_blend')

# GL/glext.h:4044
glWeightfvARB = _link_function('glWeightfvARB', None, [GLint, POINTER(GLfloat)], 'ARB_vertex_blend')

# GL/glext.h:4045
glWeightdvARB = _link_function('glWeightdvARB', None, [GLint, POINTER(GLdouble)], 'ARB_vertex_blend')

# GL/glext.h:4046
glWeightubvARB = _link_function('glWeightubvARB', None, [GLint, POINTER(GLubyte)], 'ARB_vertex_blend')

# GL/glext.h:4047
glWeightusvARB = _link_function('glWeightusvARB', None, [GLint, POINTER(GLushort)], 'ARB_vertex_blend')

# GL/glext.h:4048
glWeightuivARB = _link_function('glWeightuivARB', None, [GLint, POINTER(GLuint)], 'ARB_vertex_blend')

# GL/glext.h:4049
glWeightPointerARB = _link_function('glWeightPointerARB', None, [GLint, GLenum, GLsizei, POINTER(GLvoid)], 'ARB_vertex_blend')

# GL/glext.h:4050
glVertexBlendARB = _link_function('glVertexBlendARB', None, [GLint], 'ARB_vertex_blend')

PFNGLWEIGHTBVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLbyte)) 	# GL/glext.h:4052
PFNGLWEIGHTSVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLshort)) 	# GL/glext.h:4053
PFNGLWEIGHTIVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLint)) 	# GL/glext.h:4054
PFNGLWEIGHTFVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLfloat)) 	# GL/glext.h:4055
PFNGLWEIGHTDVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLdouble)) 	# GL/glext.h:4056
PFNGLWEIGHTUBVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLubyte)) 	# GL/glext.h:4057
PFNGLWEIGHTUSVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLushort)) 	# GL/glext.h:4058
PFNGLWEIGHTUIVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLuint)) 	# GL/glext.h:4059
PFNGLWEIGHTPOINTERARBPROC = CFUNCTYPE(None, GLint, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4060
PFNGLVERTEXBLENDARBPROC = CFUNCTYPE(None, GLint) 	# GL/glext.h:4061
# ARB_matrix_palette (GL/glext.h:4064)
GL_ARB_matrix_palette = 1 	# GL/glext.h:4065
# GL/glext.h:4067
glCurrentPaletteMatrixARB = _link_function('glCurrentPaletteMatrixARB', None, [GLint], 'ARB_matrix_palette')

# GL/glext.h:4068
glMatrixIndexubvARB = _link_function('glMatrixIndexubvARB', None, [GLint, POINTER(GLubyte)], 'ARB_matrix_palette')

# GL/glext.h:4069
glMatrixIndexusvARB = _link_function('glMatrixIndexusvARB', None, [GLint, POINTER(GLushort)], 'ARB_matrix_palette')

# GL/glext.h:4070
glMatrixIndexuivARB = _link_function('glMatrixIndexuivARB', None, [GLint, POINTER(GLuint)], 'ARB_matrix_palette')

# GL/glext.h:4071
glMatrixIndexPointerARB = _link_function('glMatrixIndexPointerARB', None, [GLint, GLenum, GLsizei, POINTER(GLvoid)], 'ARB_matrix_palette')

PFNGLCURRENTPALETTEMATRIXARBPROC = CFUNCTYPE(None, GLint) 	# GL/glext.h:4073
PFNGLMATRIXINDEXUBVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLubyte)) 	# GL/glext.h:4074
PFNGLMATRIXINDEXUSVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLushort)) 	# GL/glext.h:4075
PFNGLMATRIXINDEXUIVARBPROC = CFUNCTYPE(None, GLint, POINTER(GLuint)) 	# GL/glext.h:4076
PFNGLMATRIXINDEXPOINTERARBPROC = CFUNCTYPE(None, GLint, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4077
# ARB_texture_env_combine (GL/glext.h:4080)
GL_ARB_texture_env_combine = 1 	# GL/glext.h:4081
# ARB_texture_env_crossbar (GL/glext.h:4084)
GL_ARB_texture_env_crossbar = 1 	# GL/glext.h:4085
# ARB_texture_env_dot3 (GL/glext.h:4088)
GL_ARB_texture_env_dot3 = 1 	# GL/glext.h:4089
# ARB_texture_mirrored_repeat (GL/glext.h:4092)
GL_ARB_texture_mirrored_repeat = 1 	# GL/glext.h:4093
# ARB_depth_texture (GL/glext.h:4096)
GL_ARB_depth_texture = 1 	# GL/glext.h:4097
# ARB_shadow (GL/glext.h:4100)
GL_ARB_shadow = 1 	# GL/glext.h:4101
# ARB_shadow_ambient (GL/glext.h:4104)
GL_ARB_shadow_ambient = 1 	# GL/glext.h:4105
# ARB_window_pos (GL/glext.h:4108)
GL_ARB_window_pos = 1 	# GL/glext.h:4109
# GL/glext.h:4111
glWindowPos2dARB = _link_function('glWindowPos2dARB', None, [GLdouble, GLdouble], 'ARB_window_pos')

# GL/glext.h:4112
glWindowPos2dvARB = _link_function('glWindowPos2dvARB', None, [POINTER(GLdouble)], 'ARB_window_pos')

# GL/glext.h:4113
glWindowPos2fARB = _link_function('glWindowPos2fARB', None, [GLfloat, GLfloat], 'ARB_window_pos')

# GL/glext.h:4114
glWindowPos2fvARB = _link_function('glWindowPos2fvARB', None, [POINTER(GLfloat)], 'ARB_window_pos')

# GL/glext.h:4115
glWindowPos2iARB = _link_function('glWindowPos2iARB', None, [GLint, GLint], 'ARB_window_pos')

# GL/glext.h:4116
glWindowPos2ivARB = _link_function('glWindowPos2ivARB', None, [POINTER(GLint)], 'ARB_window_pos')

# GL/glext.h:4117
glWindowPos2sARB = _link_function('glWindowPos2sARB', None, [GLshort, GLshort], 'ARB_window_pos')

# GL/glext.h:4118
glWindowPos2svARB = _link_function('glWindowPos2svARB', None, [POINTER(GLshort)], 'ARB_window_pos')

# GL/glext.h:4119
glWindowPos3dARB = _link_function('glWindowPos3dARB', None, [GLdouble, GLdouble, GLdouble], 'ARB_window_pos')

# GL/glext.h:4120
glWindowPos3dvARB = _link_function('glWindowPos3dvARB', None, [POINTER(GLdouble)], 'ARB_window_pos')

# GL/glext.h:4121
glWindowPos3fARB = _link_function('glWindowPos3fARB', None, [GLfloat, GLfloat, GLfloat], 'ARB_window_pos')

# GL/glext.h:4122
glWindowPos3fvARB = _link_function('glWindowPos3fvARB', None, [POINTER(GLfloat)], 'ARB_window_pos')

# GL/glext.h:4123
glWindowPos3iARB = _link_function('glWindowPos3iARB', None, [GLint, GLint, GLint], 'ARB_window_pos')

# GL/glext.h:4124
glWindowPos3ivARB = _link_function('glWindowPos3ivARB', None, [POINTER(GLint)], 'ARB_window_pos')

# GL/glext.h:4125
glWindowPos3sARB = _link_function('glWindowPos3sARB', None, [GLshort, GLshort, GLshort], 'ARB_window_pos')

# GL/glext.h:4126
glWindowPos3svARB = _link_function('glWindowPos3svARB', None, [POINTER(GLshort)], 'ARB_window_pos')

PFNGLWINDOWPOS2DARBPROC = CFUNCTYPE(None, GLdouble, GLdouble) 	# GL/glext.h:4128
PFNGLWINDOWPOS2DVARBPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:4129
PFNGLWINDOWPOS2FARBPROC = CFUNCTYPE(None, GLfloat, GLfloat) 	# GL/glext.h:4130
PFNGLWINDOWPOS2FVARBPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:4131
PFNGLWINDOWPOS2IARBPROC = CFUNCTYPE(None, GLint, GLint) 	# GL/glext.h:4132
PFNGLWINDOWPOS2IVARBPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:4133
PFNGLWINDOWPOS2SARBPROC = CFUNCTYPE(None, GLshort, GLshort) 	# GL/glext.h:4134
PFNGLWINDOWPOS2SVARBPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:4135
PFNGLWINDOWPOS3DARBPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:4136
PFNGLWINDOWPOS3DVARBPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:4137
PFNGLWINDOWPOS3FARBPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:4138
PFNGLWINDOWPOS3FVARBPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:4139
PFNGLWINDOWPOS3IARBPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:4140
PFNGLWINDOWPOS3IVARBPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:4141
PFNGLWINDOWPOS3SARBPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort) 	# GL/glext.h:4142
PFNGLWINDOWPOS3SVARBPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:4143
# ARB_vertex_program (GL/glext.h:4146)
GL_ARB_vertex_program = 1 	# GL/glext.h:4147
# GL/glext.h:4149
glVertexAttrib1dARB = _link_function('glVertexAttrib1dARB', None, [GLuint, GLdouble], 'ARB_vertex_program')

# GL/glext.h:4150
glVertexAttrib1dvARB = _link_function('glVertexAttrib1dvARB', None, [GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:4151
glVertexAttrib1fARB = _link_function('glVertexAttrib1fARB', None, [GLuint, GLfloat], 'ARB_vertex_program')

# GL/glext.h:4152
glVertexAttrib1fvARB = _link_function('glVertexAttrib1fvARB', None, [GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:4153
glVertexAttrib1sARB = _link_function('glVertexAttrib1sARB', None, [GLuint, GLshort], 'ARB_vertex_program')

# GL/glext.h:4154
glVertexAttrib1svARB = _link_function('glVertexAttrib1svARB', None, [GLuint, POINTER(GLshort)], 'ARB_vertex_program')

# GL/glext.h:4155
glVertexAttrib2dARB = _link_function('glVertexAttrib2dARB', None, [GLuint, GLdouble, GLdouble], 'ARB_vertex_program')

# GL/glext.h:4156
glVertexAttrib2dvARB = _link_function('glVertexAttrib2dvARB', None, [GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:4157
glVertexAttrib2fARB = _link_function('glVertexAttrib2fARB', None, [GLuint, GLfloat, GLfloat], 'ARB_vertex_program')

# GL/glext.h:4158
glVertexAttrib2fvARB = _link_function('glVertexAttrib2fvARB', None, [GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:4159
glVertexAttrib2sARB = _link_function('glVertexAttrib2sARB', None, [GLuint, GLshort, GLshort], 'ARB_vertex_program')

# GL/glext.h:4160
glVertexAttrib2svARB = _link_function('glVertexAttrib2svARB', None, [GLuint, POINTER(GLshort)], 'ARB_vertex_program')

# GL/glext.h:4161
glVertexAttrib3dARB = _link_function('glVertexAttrib3dARB', None, [GLuint, GLdouble, GLdouble, GLdouble], 'ARB_vertex_program')

# GL/glext.h:4162
glVertexAttrib3dvARB = _link_function('glVertexAttrib3dvARB', None, [GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:4163
glVertexAttrib3fARB = _link_function('glVertexAttrib3fARB', None, [GLuint, GLfloat, GLfloat, GLfloat], 'ARB_vertex_program')

# GL/glext.h:4164
glVertexAttrib3fvARB = _link_function('glVertexAttrib3fvARB', None, [GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:4165
glVertexAttrib3sARB = _link_function('glVertexAttrib3sARB', None, [GLuint, GLshort, GLshort, GLshort], 'ARB_vertex_program')

# GL/glext.h:4166
glVertexAttrib3svARB = _link_function('glVertexAttrib3svARB', None, [GLuint, POINTER(GLshort)], 'ARB_vertex_program')

# GL/glext.h:4167
glVertexAttrib4NbvARB = _link_function('glVertexAttrib4NbvARB', None, [GLuint, POINTER(GLbyte)], 'ARB_vertex_program')

# GL/glext.h:4168
glVertexAttrib4NivARB = _link_function('glVertexAttrib4NivARB', None, [GLuint, POINTER(GLint)], 'ARB_vertex_program')

# GL/glext.h:4169
glVertexAttrib4NsvARB = _link_function('glVertexAttrib4NsvARB', None, [GLuint, POINTER(GLshort)], 'ARB_vertex_program')

# GL/glext.h:4170
glVertexAttrib4NubARB = _link_function('glVertexAttrib4NubARB', None, [GLuint, GLubyte, GLubyte, GLubyte, GLubyte], 'ARB_vertex_program')

# GL/glext.h:4171
glVertexAttrib4NubvARB = _link_function('glVertexAttrib4NubvARB', None, [GLuint, POINTER(GLubyte)], 'ARB_vertex_program')

# GL/glext.h:4172
glVertexAttrib4NuivARB = _link_function('glVertexAttrib4NuivARB', None, [GLuint, POINTER(GLuint)], 'ARB_vertex_program')

# GL/glext.h:4173
glVertexAttrib4NusvARB = _link_function('glVertexAttrib4NusvARB', None, [GLuint, POINTER(GLushort)], 'ARB_vertex_program')

# GL/glext.h:4174
glVertexAttrib4bvARB = _link_function('glVertexAttrib4bvARB', None, [GLuint, POINTER(GLbyte)], 'ARB_vertex_program')

# GL/glext.h:4175
glVertexAttrib4dARB = _link_function('glVertexAttrib4dARB', None, [GLuint, GLdouble, GLdouble, GLdouble, GLdouble], 'ARB_vertex_program')

# GL/glext.h:4176
glVertexAttrib4dvARB = _link_function('glVertexAttrib4dvARB', None, [GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:4177
glVertexAttrib4fARB = _link_function('glVertexAttrib4fARB', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat], 'ARB_vertex_program')

# GL/glext.h:4178
glVertexAttrib4fvARB = _link_function('glVertexAttrib4fvARB', None, [GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:4179
glVertexAttrib4ivARB = _link_function('glVertexAttrib4ivARB', None, [GLuint, POINTER(GLint)], 'ARB_vertex_program')

# GL/glext.h:4180
glVertexAttrib4sARB = _link_function('glVertexAttrib4sARB', None, [GLuint, GLshort, GLshort, GLshort, GLshort], 'ARB_vertex_program')

# GL/glext.h:4181
glVertexAttrib4svARB = _link_function('glVertexAttrib4svARB', None, [GLuint, POINTER(GLshort)], 'ARB_vertex_program')

# GL/glext.h:4182
glVertexAttrib4ubvARB = _link_function('glVertexAttrib4ubvARB', None, [GLuint, POINTER(GLubyte)], 'ARB_vertex_program')

# GL/glext.h:4183
glVertexAttrib4uivARB = _link_function('glVertexAttrib4uivARB', None, [GLuint, POINTER(GLuint)], 'ARB_vertex_program')

# GL/glext.h:4184
glVertexAttrib4usvARB = _link_function('glVertexAttrib4usvARB', None, [GLuint, POINTER(GLushort)], 'ARB_vertex_program')

# GL/glext.h:4185
glVertexAttribPointerARB = _link_function('glVertexAttribPointerARB', None, [GLuint, GLint, GLenum, GLboolean, GLsizei, POINTER(GLvoid)], 'ARB_vertex_program')

# GL/glext.h:4186
glEnableVertexAttribArrayARB = _link_function('glEnableVertexAttribArrayARB', None, [GLuint], 'ARB_vertex_program')

# GL/glext.h:4187
glDisableVertexAttribArrayARB = _link_function('glDisableVertexAttribArrayARB', None, [GLuint], 'ARB_vertex_program')

# GL/glext.h:4188
glProgramStringARB = _link_function('glProgramStringARB', None, [GLenum, GLenum, GLsizei, POINTER(GLvoid)], 'ARB_vertex_program')

# GL/glext.h:4189
glBindProgramARB = _link_function('glBindProgramARB', None, [GLenum, GLuint], 'ARB_vertex_program')

# GL/glext.h:4190
glDeleteProgramsARB = _link_function('glDeleteProgramsARB', None, [GLsizei, POINTER(GLuint)], 'ARB_vertex_program')

# GL/glext.h:4191
glGenProgramsARB = _link_function('glGenProgramsARB', None, [GLsizei, POINTER(GLuint)], 'ARB_vertex_program')

# GL/glext.h:4192
glProgramEnvParameter4dARB = _link_function('glProgramEnvParameter4dARB', None, [GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble], 'ARB_vertex_program')

# GL/glext.h:4193
glProgramEnvParameter4dvARB = _link_function('glProgramEnvParameter4dvARB', None, [GLenum, GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:4194
glProgramEnvParameter4fARB = _link_function('glProgramEnvParameter4fARB', None, [GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat], 'ARB_vertex_program')

# GL/glext.h:4195
glProgramEnvParameter4fvARB = _link_function('glProgramEnvParameter4fvARB', None, [GLenum, GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:4196
glProgramLocalParameter4dARB = _link_function('glProgramLocalParameter4dARB', None, [GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble], 'ARB_vertex_program')

# GL/glext.h:4197
glProgramLocalParameter4dvARB = _link_function('glProgramLocalParameter4dvARB', None, [GLenum, GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:4198
glProgramLocalParameter4fARB = _link_function('glProgramLocalParameter4fARB', None, [GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat], 'ARB_vertex_program')

# GL/glext.h:4199
glProgramLocalParameter4fvARB = _link_function('glProgramLocalParameter4fvARB', None, [GLenum, GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:4200
glGetProgramEnvParameterdvARB = _link_function('glGetProgramEnvParameterdvARB', None, [GLenum, GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:4201
glGetProgramEnvParameterfvARB = _link_function('glGetProgramEnvParameterfvARB', None, [GLenum, GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:4202
glGetProgramLocalParameterdvARB = _link_function('glGetProgramLocalParameterdvARB', None, [GLenum, GLuint, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:4203
glGetProgramLocalParameterfvARB = _link_function('glGetProgramLocalParameterfvARB', None, [GLenum, GLuint, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:4204
glGetProgramivARB = _link_function('glGetProgramivARB', None, [GLenum, GLenum, POINTER(GLint)], 'ARB_vertex_program')

# GL/glext.h:4205
glGetProgramStringARB = _link_function('glGetProgramStringARB', None, [GLenum, GLenum, POINTER(GLvoid)], 'ARB_vertex_program')

# GL/glext.h:4206
glGetVertexAttribdvARB = _link_function('glGetVertexAttribdvARB', None, [GLuint, GLenum, POINTER(GLdouble)], 'ARB_vertex_program')

# GL/glext.h:4207
glGetVertexAttribfvARB = _link_function('glGetVertexAttribfvARB', None, [GLuint, GLenum, POINTER(GLfloat)], 'ARB_vertex_program')

# GL/glext.h:4208
glGetVertexAttribivARB = _link_function('glGetVertexAttribivARB', None, [GLuint, GLenum, POINTER(GLint)], 'ARB_vertex_program')

# GL/glext.h:4209
glGetVertexAttribPointervARB = _link_function('glGetVertexAttribPointervARB', None, [GLuint, GLenum, POINTER(POINTER(GLvoid))], 'ARB_vertex_program')

# GL/glext.h:4210
glIsProgramARB = _link_function('glIsProgramARB', GLboolean, [GLuint], 'ARB_vertex_program')

PFNGLVERTEXATTRIB1DARBPROC = CFUNCTYPE(None, GLuint, GLdouble) 	# GL/glext.h:4212
PFNGLVERTEXATTRIB1DVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:4213
PFNGLVERTEXATTRIB1FARBPROC = CFUNCTYPE(None, GLuint, GLfloat) 	# GL/glext.h:4214
PFNGLVERTEXATTRIB1FVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:4215
PFNGLVERTEXATTRIB1SARBPROC = CFUNCTYPE(None, GLuint, GLshort) 	# GL/glext.h:4216
PFNGLVERTEXATTRIB1SVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:4217
PFNGLVERTEXATTRIB2DARBPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble) 	# GL/glext.h:4218
PFNGLVERTEXATTRIB2DVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:4219
PFNGLVERTEXATTRIB2FARBPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat) 	# GL/glext.h:4220
PFNGLVERTEXATTRIB2FVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:4221
PFNGLVERTEXATTRIB2SARBPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort) 	# GL/glext.h:4222
PFNGLVERTEXATTRIB2SVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:4223
PFNGLVERTEXATTRIB3DARBPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:4224
PFNGLVERTEXATTRIB3DVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:4225
PFNGLVERTEXATTRIB3FARBPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:4226
PFNGLVERTEXATTRIB3FVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:4227
PFNGLVERTEXATTRIB3SARBPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort, GLshort) 	# GL/glext.h:4228
PFNGLVERTEXATTRIB3SVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:4229
PFNGLVERTEXATTRIB4NBVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLbyte)) 	# GL/glext.h:4230
PFNGLVERTEXATTRIB4NIVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLint)) 	# GL/glext.h:4231
PFNGLVERTEXATTRIB4NSVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:4232
PFNGLVERTEXATTRIB4NUBARBPROC = CFUNCTYPE(None, GLuint, GLubyte, GLubyte, GLubyte, GLubyte) 	# GL/glext.h:4233
PFNGLVERTEXATTRIB4NUBVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLubyte)) 	# GL/glext.h:4234
PFNGLVERTEXATTRIB4NUIVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLuint)) 	# GL/glext.h:4235
PFNGLVERTEXATTRIB4NUSVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLushort)) 	# GL/glext.h:4236
PFNGLVERTEXATTRIB4BVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLbyte)) 	# GL/glext.h:4237
PFNGLVERTEXATTRIB4DARBPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:4238
PFNGLVERTEXATTRIB4DVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:4239
PFNGLVERTEXATTRIB4FARBPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:4240
PFNGLVERTEXATTRIB4FVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:4241
PFNGLVERTEXATTRIB4IVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLint)) 	# GL/glext.h:4242
PFNGLVERTEXATTRIB4SARBPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort, GLshort, GLshort) 	# GL/glext.h:4243
PFNGLVERTEXATTRIB4SVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:4244
PFNGLVERTEXATTRIB4UBVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLubyte)) 	# GL/glext.h:4245
PFNGLVERTEXATTRIB4UIVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLuint)) 	# GL/glext.h:4246
PFNGLVERTEXATTRIB4USVARBPROC = CFUNCTYPE(None, GLuint, POINTER(GLushort)) 	# GL/glext.h:4247
PFNGLVERTEXATTRIBPOINTERARBPROC = CFUNCTYPE(None, GLuint, GLint, GLenum, GLboolean, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4248
PFNGLENABLEVERTEXATTRIBARRAYARBPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:4249
PFNGLDISABLEVERTEXATTRIBARRAYARBPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:4250
PFNGLPROGRAMSTRINGARBPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4251
PFNGLBINDPROGRAMARBPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:4252
PFNGLDELETEPROGRAMSARBPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:4253
PFNGLGENPROGRAMSARBPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:4254
PFNGLPROGRAMENVPARAMETER4DARBPROC = CFUNCTYPE(None, GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:4255
PFNGLPROGRAMENVPARAMETER4DVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLdouble)) 	# GL/glext.h:4256
PFNGLPROGRAMENVPARAMETER4FARBPROC = CFUNCTYPE(None, GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:4257
PFNGLPROGRAMENVPARAMETER4FVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLfloat)) 	# GL/glext.h:4258
PFNGLPROGRAMLOCALPARAMETER4DARBPROC = CFUNCTYPE(None, GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:4259
PFNGLPROGRAMLOCALPARAMETER4DVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLdouble)) 	# GL/glext.h:4260
PFNGLPROGRAMLOCALPARAMETER4FARBPROC = CFUNCTYPE(None, GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:4261
PFNGLPROGRAMLOCALPARAMETER4FVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLfloat)) 	# GL/glext.h:4262
PFNGLGETPROGRAMENVPARAMETERDVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLdouble)) 	# GL/glext.h:4263
PFNGLGETPROGRAMENVPARAMETERFVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLfloat)) 	# GL/glext.h:4264
PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLdouble)) 	# GL/glext.h:4265
PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLfloat)) 	# GL/glext.h:4266
PFNGLGETPROGRAMIVARBPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4267
PFNGLGETPROGRAMSTRINGARBPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4268
PFNGLGETVERTEXATTRIBDVARBPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLdouble)) 	# GL/glext.h:4269
PFNGLGETVERTEXATTRIBFVARBPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4270
PFNGLGETVERTEXATTRIBIVARBPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:4271
PFNGLGETVERTEXATTRIBPOINTERVARBPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:4272
PFNGLISPROGRAMARBPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:4273
# ARB_fragment_program (GL/glext.h:4276)
GL_ARB_fragment_program = 1 	# GL/glext.h:4277
# ARB_vertex_buffer_object (GL/glext.h:4281)
GL_ARB_vertex_buffer_object = 1 	# GL/glext.h:4282
# GL/glext.h:4284
glBindBufferARB = _link_function('glBindBufferARB', None, [GLenum, GLuint], 'ARB_vertex_buffer_object')

# GL/glext.h:4285
glDeleteBuffersARB = _link_function('glDeleteBuffersARB', None, [GLsizei, POINTER(GLuint)], 'ARB_vertex_buffer_object')

# GL/glext.h:4286
glGenBuffersARB = _link_function('glGenBuffersARB', None, [GLsizei, POINTER(GLuint)], 'ARB_vertex_buffer_object')

# GL/glext.h:4287
glIsBufferARB = _link_function('glIsBufferARB', GLboolean, [GLuint], 'ARB_vertex_buffer_object')

# GL/glext.h:4288
glBufferDataARB = _link_function('glBufferDataARB', None, [GLenum, GLsizeiptrARB, POINTER(GLvoid), GLenum], 'ARB_vertex_buffer_object')

# GL/glext.h:4289
glBufferSubDataARB = _link_function('glBufferSubDataARB', None, [GLenum, GLintptrARB, GLsizeiptrARB, POINTER(GLvoid)], 'ARB_vertex_buffer_object')

# GL/glext.h:4290
glGetBufferSubDataARB = _link_function('glGetBufferSubDataARB', None, [GLenum, GLintptrARB, GLsizeiptrARB, POINTER(GLvoid)], 'ARB_vertex_buffer_object')

# GL/glext.h:4291
glMapBufferARB = _link_function('glMapBufferARB', POINTER(GLvoid), [GLenum, GLenum], 'ARB_vertex_buffer_object')

# GL/glext.h:4292
glUnmapBufferARB = _link_function('glUnmapBufferARB', GLboolean, [GLenum], 'ARB_vertex_buffer_object')

# GL/glext.h:4293
glGetBufferParameterivARB = _link_function('glGetBufferParameterivARB', None, [GLenum, GLenum, POINTER(GLint)], 'ARB_vertex_buffer_object')

# GL/glext.h:4294
glGetBufferPointervARB = _link_function('glGetBufferPointervARB', None, [GLenum, GLenum, POINTER(POINTER(GLvoid))], 'ARB_vertex_buffer_object')

PFNGLBINDBUFFERARBPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:4296
PFNGLDELETEBUFFERSARBPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:4297
PFNGLGENBUFFERSARBPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:4298
PFNGLISBUFFERARBPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:4299
PFNGLBUFFERDATAARBPROC = CFUNCTYPE(None, GLenum, GLsizeiptrARB, POINTER(GLvoid), GLenum) 	# GL/glext.h:4300
PFNGLBUFFERSUBDATAARBPROC = CFUNCTYPE(None, GLenum, GLintptrARB, GLsizeiptrARB, POINTER(GLvoid)) 	# GL/glext.h:4301
PFNGLGETBUFFERSUBDATAARBPROC = CFUNCTYPE(None, GLenum, GLintptrARB, GLsizeiptrARB, POINTER(GLvoid)) 	# GL/glext.h:4302
PFNGLMAPBUFFERARBPROC = CFUNCTYPE(POINTER(GLvoid), GLenum, GLenum) 	# GL/glext.h:4303
PFNGLUNMAPBUFFERARBPROC = CFUNCTYPE(GLboolean, GLenum) 	# GL/glext.h:4304
PFNGLGETBUFFERPARAMETERIVARBPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4305
PFNGLGETBUFFERPOINTERVARBPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:4306
# ARB_occlusion_query (GL/glext.h:4309)
GL_ARB_occlusion_query = 1 	# GL/glext.h:4310
# GL/glext.h:4312
glGenQueriesARB = _link_function('glGenQueriesARB', None, [GLsizei, POINTER(GLuint)], 'ARB_occlusion_query')

# GL/glext.h:4313
glDeleteQueriesARB = _link_function('glDeleteQueriesARB', None, [GLsizei, POINTER(GLuint)], 'ARB_occlusion_query')

# GL/glext.h:4314
glIsQueryARB = _link_function('glIsQueryARB', GLboolean, [GLuint], 'ARB_occlusion_query')

# GL/glext.h:4315
glBeginQueryARB = _link_function('glBeginQueryARB', None, [GLenum, GLuint], 'ARB_occlusion_query')

# GL/glext.h:4316
glEndQueryARB = _link_function('glEndQueryARB', None, [GLenum], 'ARB_occlusion_query')

# GL/glext.h:4317
glGetQueryivARB = _link_function('glGetQueryivARB', None, [GLenum, GLenum, POINTER(GLint)], 'ARB_occlusion_query')

# GL/glext.h:4318
glGetQueryObjectivARB = _link_function('glGetQueryObjectivARB', None, [GLuint, GLenum, POINTER(GLint)], 'ARB_occlusion_query')

# GL/glext.h:4319
glGetQueryObjectuivARB = _link_function('glGetQueryObjectuivARB', None, [GLuint, GLenum, POINTER(GLuint)], 'ARB_occlusion_query')

PFNGLGENQUERIESARBPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:4321
PFNGLDELETEQUERIESARBPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:4322
PFNGLISQUERYARBPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:4323
PFNGLBEGINQUERYARBPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:4324
PFNGLENDQUERYARBPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:4325
PFNGLGETQUERYIVARBPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4326
PFNGLGETQUERYOBJECTIVARBPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:4327
PFNGLGETQUERYOBJECTUIVARBPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLuint)) 	# GL/glext.h:4328
# ARB_shader_objects (GL/glext.h:4331)
GL_ARB_shader_objects = 1 	# GL/glext.h:4332
# GL/glext.h:4334
glDeleteObjectARB = _link_function('glDeleteObjectARB', None, [GLhandleARB], 'ARB_shader_objects')

# GL/glext.h:4335
glGetHandleARB = _link_function('glGetHandleARB', GLhandleARB, [GLenum], 'ARB_shader_objects')

# GL/glext.h:4336
glDetachObjectARB = _link_function('glDetachObjectARB', None, [GLhandleARB, GLhandleARB], 'ARB_shader_objects')

# GL/glext.h:4337
glCreateShaderObjectARB = _link_function('glCreateShaderObjectARB', GLhandleARB, [GLenum], 'ARB_shader_objects')

# GL/glext.h:4338
glShaderSourceARB = _link_function('glShaderSourceARB', None, [GLhandleARB, GLsizei, POINTER(POINTER(GLcharARB)), POINTER(GLint)], 'ARB_shader_objects')

# GL/glext.h:4339
glCompileShaderARB = _link_function('glCompileShaderARB', None, [GLhandleARB], 'ARB_shader_objects')

# GL/glext.h:4340
glCreateProgramObjectARB = _link_function('glCreateProgramObjectARB', GLhandleARB, [], 'ARB_shader_objects')

# GL/glext.h:4341
glAttachObjectARB = _link_function('glAttachObjectARB', None, [GLhandleARB, GLhandleARB], 'ARB_shader_objects')

# GL/glext.h:4342
glLinkProgramARB = _link_function('glLinkProgramARB', None, [GLhandleARB], 'ARB_shader_objects')

# GL/glext.h:4343
glUseProgramObjectARB = _link_function('glUseProgramObjectARB', None, [GLhandleARB], 'ARB_shader_objects')

# GL/glext.h:4344
glValidateProgramARB = _link_function('glValidateProgramARB', None, [GLhandleARB], 'ARB_shader_objects')

# GL/glext.h:4345
glUniform1fARB = _link_function('glUniform1fARB', None, [GLint, GLfloat], 'ARB_shader_objects')

# GL/glext.h:4346
glUniform2fARB = _link_function('glUniform2fARB', None, [GLint, GLfloat, GLfloat], 'ARB_shader_objects')

# GL/glext.h:4347
glUniform3fARB = _link_function('glUniform3fARB', None, [GLint, GLfloat, GLfloat, GLfloat], 'ARB_shader_objects')

# GL/glext.h:4348
glUniform4fARB = _link_function('glUniform4fARB', None, [GLint, GLfloat, GLfloat, GLfloat, GLfloat], 'ARB_shader_objects')

# GL/glext.h:4349
glUniform1iARB = _link_function('glUniform1iARB', None, [GLint, GLint], 'ARB_shader_objects')

# GL/glext.h:4350
glUniform2iARB = _link_function('glUniform2iARB', None, [GLint, GLint, GLint], 'ARB_shader_objects')

# GL/glext.h:4351
glUniform3iARB = _link_function('glUniform3iARB', None, [GLint, GLint, GLint, GLint], 'ARB_shader_objects')

# GL/glext.h:4352
glUniform4iARB = _link_function('glUniform4iARB', None, [GLint, GLint, GLint, GLint, GLint], 'ARB_shader_objects')

# GL/glext.h:4353
glUniform1fvARB = _link_function('glUniform1fvARB', None, [GLint, GLsizei, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4354
glUniform2fvARB = _link_function('glUniform2fvARB', None, [GLint, GLsizei, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4355
glUniform3fvARB = _link_function('glUniform3fvARB', None, [GLint, GLsizei, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4356
glUniform4fvARB = _link_function('glUniform4fvARB', None, [GLint, GLsizei, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4357
glUniform1ivARB = _link_function('glUniform1ivARB', None, [GLint, GLsizei, POINTER(GLint)], 'ARB_shader_objects')

# GL/glext.h:4358
glUniform2ivARB = _link_function('glUniform2ivARB', None, [GLint, GLsizei, POINTER(GLint)], 'ARB_shader_objects')

# GL/glext.h:4359
glUniform3ivARB = _link_function('glUniform3ivARB', None, [GLint, GLsizei, POINTER(GLint)], 'ARB_shader_objects')

# GL/glext.h:4360
glUniform4ivARB = _link_function('glUniform4ivARB', None, [GLint, GLsizei, POINTER(GLint)], 'ARB_shader_objects')

# GL/glext.h:4361
glUniformMatrix2fvARB = _link_function('glUniformMatrix2fvARB', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4362
glUniformMatrix3fvARB = _link_function('glUniformMatrix3fvARB', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4363
glUniformMatrix4fvARB = _link_function('glUniformMatrix4fvARB', None, [GLint, GLsizei, GLboolean, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4364
glGetObjectParameterfvARB = _link_function('glGetObjectParameterfvARB', None, [GLhandleARB, GLenum, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4365
glGetObjectParameterivARB = _link_function('glGetObjectParameterivARB', None, [GLhandleARB, GLenum, POINTER(GLint)], 'ARB_shader_objects')

# GL/glext.h:4366
glGetInfoLogARB = _link_function('glGetInfoLogARB', None, [GLhandleARB, GLsizei, POINTER(GLsizei), POINTER(GLcharARB)], 'ARB_shader_objects')

# GL/glext.h:4367
glGetAttachedObjectsARB = _link_function('glGetAttachedObjectsARB', None, [GLhandleARB, GLsizei, POINTER(GLsizei), POINTER(GLhandleARB)], 'ARB_shader_objects')

# GL/glext.h:4368
glGetUniformLocationARB = _link_function('glGetUniformLocationARB', GLint, [GLhandleARB, POINTER(GLcharARB)], 'ARB_shader_objects')

# GL/glext.h:4369
glGetActiveUniformARB = _link_function('glGetActiveUniformARB', None, [GLhandleARB, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLcharARB)], 'ARB_shader_objects')

# GL/glext.h:4370
glGetUniformfvARB = _link_function('glGetUniformfvARB', None, [GLhandleARB, GLint, POINTER(GLfloat)], 'ARB_shader_objects')

# GL/glext.h:4371
glGetUniformivARB = _link_function('glGetUniformivARB', None, [GLhandleARB, GLint, POINTER(GLint)], 'ARB_shader_objects')

# GL/glext.h:4372
glGetShaderSourceARB = _link_function('glGetShaderSourceARB', None, [GLhandleARB, GLsizei, POINTER(GLsizei), POINTER(GLcharARB)], 'ARB_shader_objects')

PFNGLDELETEOBJECTARBPROC = CFUNCTYPE(None, GLhandleARB) 	# GL/glext.h:4374
PFNGLGETHANDLEARBPROC = CFUNCTYPE(GLhandleARB, GLenum) 	# GL/glext.h:4375
PFNGLDETACHOBJECTARBPROC = CFUNCTYPE(None, GLhandleARB, GLhandleARB) 	# GL/glext.h:4376
PFNGLCREATESHADEROBJECTARBPROC = CFUNCTYPE(GLhandleARB, GLenum) 	# GL/glext.h:4377
PFNGLSHADERSOURCEARBPROC = CFUNCTYPE(None, GLhandleARB, GLsizei, POINTER(POINTER(GLcharARB)), POINTER(GLint)) 	# GL/glext.h:4378
PFNGLCOMPILESHADERARBPROC = CFUNCTYPE(None, GLhandleARB) 	# GL/glext.h:4379
PFNGLCREATEPROGRAMOBJECTARBPROC = CFUNCTYPE(GLhandleARB) 	# GL/glext.h:4380
PFNGLATTACHOBJECTARBPROC = CFUNCTYPE(None, GLhandleARB, GLhandleARB) 	# GL/glext.h:4381
PFNGLLINKPROGRAMARBPROC = CFUNCTYPE(None, GLhandleARB) 	# GL/glext.h:4382
PFNGLUSEPROGRAMOBJECTARBPROC = CFUNCTYPE(None, GLhandleARB) 	# GL/glext.h:4383
PFNGLVALIDATEPROGRAMARBPROC = CFUNCTYPE(None, GLhandleARB) 	# GL/glext.h:4384
PFNGLUNIFORM1FARBPROC = CFUNCTYPE(None, GLint, GLfloat) 	# GL/glext.h:4385
PFNGLUNIFORM2FARBPROC = CFUNCTYPE(None, GLint, GLfloat, GLfloat) 	# GL/glext.h:4386
PFNGLUNIFORM3FARBPROC = CFUNCTYPE(None, GLint, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:4387
PFNGLUNIFORM4FARBPROC = CFUNCTYPE(None, GLint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:4388
PFNGLUNIFORM1IARBPROC = CFUNCTYPE(None, GLint, GLint) 	# GL/glext.h:4389
PFNGLUNIFORM2IARBPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:4390
PFNGLUNIFORM3IARBPROC = CFUNCTYPE(None, GLint, GLint, GLint, GLint) 	# GL/glext.h:4391
PFNGLUNIFORM4IARBPROC = CFUNCTYPE(None, GLint, GLint, GLint, GLint, GLint) 	# GL/glext.h:4392
PFNGLUNIFORM1FVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4393
PFNGLUNIFORM2FVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4394
PFNGLUNIFORM3FVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4395
PFNGLUNIFORM4FVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4396
PFNGLUNIFORM1IVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:4397
PFNGLUNIFORM2IVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:4398
PFNGLUNIFORM3IVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:4399
PFNGLUNIFORM4IVARBPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLint)) 	# GL/glext.h:4400
PFNGLUNIFORMMATRIX2FVARBPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:4401
PFNGLUNIFORMMATRIX3FVARBPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:4402
PFNGLUNIFORMMATRIX4FVARBPROC = CFUNCTYPE(None, GLint, GLsizei, GLboolean, POINTER(GLfloat)) 	# GL/glext.h:4403
PFNGLGETOBJECTPARAMETERFVARBPROC = CFUNCTYPE(None, GLhandleARB, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4404
PFNGLGETOBJECTPARAMETERIVARBPROC = CFUNCTYPE(None, GLhandleARB, GLenum, POINTER(GLint)) 	# GL/glext.h:4405
PFNGLGETINFOLOGARBPROC = CFUNCTYPE(None, GLhandleARB, GLsizei, POINTER(GLsizei), POINTER(GLcharARB)) 	# GL/glext.h:4406
PFNGLGETATTACHEDOBJECTSARBPROC = CFUNCTYPE(None, GLhandleARB, GLsizei, POINTER(GLsizei), POINTER(GLhandleARB)) 	# GL/glext.h:4407
PFNGLGETUNIFORMLOCATIONARBPROC = CFUNCTYPE(GLint, GLhandleARB, POINTER(GLcharARB)) 	# GL/glext.h:4408
PFNGLGETACTIVEUNIFORMARBPROC = CFUNCTYPE(None, GLhandleARB, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLcharARB)) 	# GL/glext.h:4409
PFNGLGETUNIFORMFVARBPROC = CFUNCTYPE(None, GLhandleARB, GLint, POINTER(GLfloat)) 	# GL/glext.h:4410
PFNGLGETUNIFORMIVARBPROC = CFUNCTYPE(None, GLhandleARB, GLint, POINTER(GLint)) 	# GL/glext.h:4411
PFNGLGETSHADERSOURCEARBPROC = CFUNCTYPE(None, GLhandleARB, GLsizei, POINTER(GLsizei), POINTER(GLcharARB)) 	# GL/glext.h:4412
# ARB_vertex_shader (GL/glext.h:4415)
GL_ARB_vertex_shader = 1 	# GL/glext.h:4416
# GL/glext.h:4418
glBindAttribLocationARB = _link_function('glBindAttribLocationARB', None, [GLhandleARB, GLuint, POINTER(GLcharARB)], 'ARB_vertex_shader')

# GL/glext.h:4419
glGetActiveAttribARB = _link_function('glGetActiveAttribARB', None, [GLhandleARB, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLcharARB)], 'ARB_vertex_shader')

# GL/glext.h:4420
glGetAttribLocationARB = _link_function('glGetAttribLocationARB', GLint, [GLhandleARB, POINTER(GLcharARB)], 'ARB_vertex_shader')

PFNGLBINDATTRIBLOCATIONARBPROC = CFUNCTYPE(None, GLhandleARB, GLuint, POINTER(GLcharARB)) 	# GL/glext.h:4422
PFNGLGETACTIVEATTRIBARBPROC = CFUNCTYPE(None, GLhandleARB, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLint), POINTER(GLenum), POINTER(GLcharARB)) 	# GL/glext.h:4423
PFNGLGETATTRIBLOCATIONARBPROC = CFUNCTYPE(GLint, GLhandleARB, POINTER(GLcharARB)) 	# GL/glext.h:4424
# ARB_fragment_shader (GL/glext.h:4427)
GL_ARB_fragment_shader = 1 	# GL/glext.h:4428
# ARB_shading_language_100 (GL/glext.h:4431)
GL_ARB_shading_language_100 = 1 	# GL/glext.h:4432
# ARB_texture_non_power_of_two (GL/glext.h:4435)
GL_ARB_texture_non_power_of_two = 1 	# GL/glext.h:4436
# ARB_point_sprite (GL/glext.h:4439)
GL_ARB_point_sprite = 1 	# GL/glext.h:4440
# ARB_fragment_program_shadow (GL/glext.h:4443)
GL_ARB_fragment_program_shadow = 1 	# GL/glext.h:4444
# ARB_draw_buffers (GL/glext.h:4447)
GL_ARB_draw_buffers = 1 	# GL/glext.h:4448
# GL/glext.h:4450
glDrawBuffersARB = _link_function('glDrawBuffersARB', None, [GLsizei, POINTER(GLenum)], 'ARB_draw_buffers')

PFNGLDRAWBUFFERSARBPROC = CFUNCTYPE(None, GLsizei, POINTER(GLenum)) 	# GL/glext.h:4452
# ARB_texture_rectangle (GL/glext.h:4455)
GL_ARB_texture_rectangle = 1 	# GL/glext.h:4456
# ARB_color_buffer_float (GL/glext.h:4459)
GL_ARB_color_buffer_float = 1 	# GL/glext.h:4460
# GL/glext.h:4462
glClampColorARB = _link_function('glClampColorARB', None, [GLenum, GLenum], 'ARB_color_buffer_float')

PFNGLCLAMPCOLORARBPROC = CFUNCTYPE(None, GLenum, GLenum) 	# GL/glext.h:4464
# ARB_half_float_pixel (GL/glext.h:4467)
GL_ARB_half_float_pixel = 1 	# GL/glext.h:4468
# ARB_texture_float (GL/glext.h:4471)
GL_ARB_texture_float = 1 	# GL/glext.h:4472
# ARB_pixel_buffer_object (GL/glext.h:4475)
GL_ARB_pixel_buffer_object = 1 	# GL/glext.h:4476
# EXT_abgr (GL/glext.h:4479)
GL_EXT_abgr = 1 	# GL/glext.h:4480
# EXT_blend_color (GL/glext.h:4483)
GL_EXT_blend_color = 1 	# GL/glext.h:4484
# GL/glext.h:4486
glBlendColorEXT = _link_function('glBlendColorEXT', None, [GLclampf, GLclampf, GLclampf, GLclampf], 'EXT_blend_color')

PFNGLBLENDCOLOREXTPROC = CFUNCTYPE(None, GLclampf, GLclampf, GLclampf, GLclampf) 	# GL/glext.h:4488
# EXT_polygon_offset (GL/glext.h:4491)
GL_EXT_polygon_offset = 1 	# GL/glext.h:4492
# GL/glext.h:4494
glPolygonOffsetEXT = _link_function('glPolygonOffsetEXT', None, [GLfloat, GLfloat], 'EXT_polygon_offset')

PFNGLPOLYGONOFFSETEXTPROC = CFUNCTYPE(None, GLfloat, GLfloat) 	# GL/glext.h:4496
# EXT_texture (GL/glext.h:4499)
GL_EXT_texture = 1 	# GL/glext.h:4500
# EXT_texture3D (GL/glext.h:4503)
GL_EXT_texture3D = 1 	# GL/glext.h:4504
# GL/glext.h:4506
glTexImage3DEXT = _link_function('glTexImage3DEXT', None, [GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, POINTER(GLvoid)], 'EXT_texture3D')

# GL/glext.h:4507
glTexSubImage3DEXT = _link_function('glTexSubImage3DEXT', None, [GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'EXT_texture3D')

PFNGLTEXIMAGE3DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4509
PFNGLTEXSUBIMAGE3DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4510
# SGIS_texture_filter4 (GL/glext.h:4513)
GL_SGIS_texture_filter4 = 1 	# GL/glext.h:4514
# GL/glext.h:4516
glGetTexFilterFuncSGIS = _link_function('glGetTexFilterFuncSGIS', None, [GLenum, GLenum, POINTER(GLfloat)], 'SGIS_texture_filter4')

# GL/glext.h:4517
glTexFilterFuncSGIS = _link_function('glTexFilterFuncSGIS', None, [GLenum, GLenum, GLsizei, POINTER(GLfloat)], 'SGIS_texture_filter4')

PFNGLGETTEXFILTERFUNCSGISPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4519
PFNGLTEXFILTERFUNCSGISPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4520
# EXT_subtexture (GL/glext.h:4523)
GL_EXT_subtexture = 1 	# GL/glext.h:4524
# GL/glext.h:4526
glTexSubImage1DEXT = _link_function('glTexSubImage1DEXT', None, [GLenum, GLint, GLint, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'EXT_subtexture')

# GL/glext.h:4527
glTexSubImage2DEXT = _link_function('glTexSubImage2DEXT', None, [GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'EXT_subtexture')

PFNGLTEXSUBIMAGE1DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4529
PFNGLTEXSUBIMAGE2DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4530
# EXT_copy_texture (GL/glext.h:4533)
GL_EXT_copy_texture = 1 	# GL/glext.h:4534
# GL/glext.h:4536
glCopyTexImage1DEXT = _link_function('glCopyTexImage1DEXT', None, [GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint], 'EXT_copy_texture')

# GL/glext.h:4537
glCopyTexImage2DEXT = _link_function('glCopyTexImage2DEXT', None, [GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint], 'EXT_copy_texture')

# GL/glext.h:4538
glCopyTexSubImage1DEXT = _link_function('glCopyTexSubImage1DEXT', None, [GLenum, GLint, GLint, GLint, GLint, GLsizei], 'EXT_copy_texture')

# GL/glext.h:4539
glCopyTexSubImage2DEXT = _link_function('glCopyTexSubImage2DEXT', None, [GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei], 'EXT_copy_texture')

# GL/glext.h:4540
glCopyTexSubImage3DEXT = _link_function('glCopyTexSubImage3DEXT', None, [GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei], 'EXT_copy_texture')

PFNGLCOPYTEXIMAGE1DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint) 	# GL/glext.h:4542
PFNGLCOPYTEXIMAGE2DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint) 	# GL/glext.h:4543
PFNGLCOPYTEXSUBIMAGE1DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLsizei) 	# GL/glext.h:4544
PFNGLCOPYTEXSUBIMAGE2DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei) 	# GL/glext.h:4545
PFNGLCOPYTEXSUBIMAGE3DEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei) 	# GL/glext.h:4546
# EXT_histogram (GL/glext.h:4549)
GL_EXT_histogram = 1 	# GL/glext.h:4550
# GL/glext.h:4552
glGetHistogramEXT = _link_function('glGetHistogramEXT', None, [GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)], 'EXT_histogram')

# GL/glext.h:4553
glGetHistogramParameterfvEXT = _link_function('glGetHistogramParameterfvEXT', None, [GLenum, GLenum, POINTER(GLfloat)], 'EXT_histogram')

# GL/glext.h:4554
glGetHistogramParameterivEXT = _link_function('glGetHistogramParameterivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_histogram')

# GL/glext.h:4555
glGetMinmaxEXT = _link_function('glGetMinmaxEXT', None, [GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)], 'EXT_histogram')

# GL/glext.h:4556
glGetMinmaxParameterfvEXT = _link_function('glGetMinmaxParameterfvEXT', None, [GLenum, GLenum, POINTER(GLfloat)], 'EXT_histogram')

# GL/glext.h:4557
glGetMinmaxParameterivEXT = _link_function('glGetMinmaxParameterivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_histogram')

# GL/glext.h:4558
glHistogramEXT = _link_function('glHistogramEXT', None, [GLenum, GLsizei, GLenum, GLboolean], 'EXT_histogram')

# GL/glext.h:4559
glMinmaxEXT = _link_function('glMinmaxEXT', None, [GLenum, GLenum, GLboolean], 'EXT_histogram')

# GL/glext.h:4560
glResetHistogramEXT = _link_function('glResetHistogramEXT', None, [GLenum], 'EXT_histogram')

# GL/glext.h:4561
glResetMinmaxEXT = _link_function('glResetMinmaxEXT', None, [GLenum], 'EXT_histogram')

PFNGLGETHISTOGRAMEXTPROC = CFUNCTYPE(None, GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4563
PFNGLGETHISTOGRAMPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4564
PFNGLGETHISTOGRAMPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4565
PFNGLGETMINMAXEXTPROC = CFUNCTYPE(None, GLenum, GLboolean, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4566
PFNGLGETMINMAXPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4567
PFNGLGETMINMAXPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4568
PFNGLHISTOGRAMEXTPROC = CFUNCTYPE(None, GLenum, GLsizei, GLenum, GLboolean) 	# GL/glext.h:4569
PFNGLMINMAXEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLboolean) 	# GL/glext.h:4570
PFNGLRESETHISTOGRAMEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:4571
PFNGLRESETMINMAXEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:4572
# EXT_convolution (GL/glext.h:4575)
GL_EXT_convolution = 1 	# GL/glext.h:4576
# GL/glext.h:4578
glConvolutionFilter1DEXT = _link_function('glConvolutionFilter1DEXT', None, [GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'EXT_convolution')

# GL/glext.h:4579
glConvolutionFilter2DEXT = _link_function('glConvolutionFilter2DEXT', None, [GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'EXT_convolution')

# GL/glext.h:4580
glConvolutionParameterfEXT = _link_function('glConvolutionParameterfEXT', None, [GLenum, GLenum, GLfloat], 'EXT_convolution')

# GL/glext.h:4581
glConvolutionParameterfvEXT = _link_function('glConvolutionParameterfvEXT', None, [GLenum, GLenum, POINTER(GLfloat)], 'EXT_convolution')

# GL/glext.h:4582
glConvolutionParameteriEXT = _link_function('glConvolutionParameteriEXT', None, [GLenum, GLenum, GLint], 'EXT_convolution')

# GL/glext.h:4583
glConvolutionParameterivEXT = _link_function('glConvolutionParameterivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_convolution')

# GL/glext.h:4584
glCopyConvolutionFilter1DEXT = _link_function('glCopyConvolutionFilter1DEXT', None, [GLenum, GLenum, GLint, GLint, GLsizei], 'EXT_convolution')

# GL/glext.h:4585
glCopyConvolutionFilter2DEXT = _link_function('glCopyConvolutionFilter2DEXT', None, [GLenum, GLenum, GLint, GLint, GLsizei, GLsizei], 'EXT_convolution')

# GL/glext.h:4586
glGetConvolutionFilterEXT = _link_function('glGetConvolutionFilterEXT', None, [GLenum, GLenum, GLenum, POINTER(GLvoid)], 'EXT_convolution')

# GL/glext.h:4587
glGetConvolutionParameterfvEXT = _link_function('glGetConvolutionParameterfvEXT', None, [GLenum, GLenum, POINTER(GLfloat)], 'EXT_convolution')

# GL/glext.h:4588
glGetConvolutionParameterivEXT = _link_function('glGetConvolutionParameterivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_convolution')

# GL/glext.h:4589
glGetSeparableFilterEXT = _link_function('glGetSeparableFilterEXT', None, [GLenum, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid), POINTER(GLvoid)], 'EXT_convolution')

# GL/glext.h:4590
glSeparableFilter2DEXT = _link_function('glSeparableFilter2DEXT', None, [GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid)], 'EXT_convolution')

PFNGLCONVOLUTIONFILTER1DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4592
PFNGLCONVOLUTIONFILTER2DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4593
PFNGLCONVOLUTIONPARAMETERFEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLfloat) 	# GL/glext.h:4594
PFNGLCONVOLUTIONPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4595
PFNGLCONVOLUTIONPARAMETERIEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLint) 	# GL/glext.h:4596
PFNGLCONVOLUTIONPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4597
PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLint, GLsizei) 	# GL/glext.h:4598
PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLint, GLsizei, GLsizei) 	# GL/glext.h:4599
PFNGLGETCONVOLUTIONFILTEREXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4600
PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4601
PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4602
PFNGLGETSEPARABLEFILTEREXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid), POINTER(GLvoid)) 	# GL/glext.h:4603
PFNGLSEPARABLEFILTER2DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid), POINTER(GLvoid)) 	# GL/glext.h:4604
# EXT_color_matrix (GL/glext.h:4607)
GL_EXT_color_matrix = 1 	# GL/glext.h:4608
# SGI_color_table (GL/glext.h:4611)
GL_SGI_color_table = 1 	# GL/glext.h:4612
# GL/glext.h:4614
glColorTableSGI = _link_function('glColorTableSGI', None, [GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'SGI_color_table')

# GL/glext.h:4615
glColorTableParameterfvSGI = _link_function('glColorTableParameterfvSGI', None, [GLenum, GLenum, POINTER(GLfloat)], 'SGI_color_table')

# GL/glext.h:4616
glColorTableParameterivSGI = _link_function('glColorTableParameterivSGI', None, [GLenum, GLenum, POINTER(GLint)], 'SGI_color_table')

# GL/glext.h:4617
glCopyColorTableSGI = _link_function('glCopyColorTableSGI', None, [GLenum, GLenum, GLint, GLint, GLsizei], 'SGI_color_table')

# GL/glext.h:4618
glGetColorTableSGI = _link_function('glGetColorTableSGI', None, [GLenum, GLenum, GLenum, POINTER(GLvoid)], 'SGI_color_table')

# GL/glext.h:4619
glGetColorTableParameterfvSGI = _link_function('glGetColorTableParameterfvSGI', None, [GLenum, GLenum, POINTER(GLfloat)], 'SGI_color_table')

# GL/glext.h:4620
glGetColorTableParameterivSGI = _link_function('glGetColorTableParameterivSGI', None, [GLenum, GLenum, POINTER(GLint)], 'SGI_color_table')

PFNGLCOLORTABLESGIPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4622
PFNGLCOLORTABLEPARAMETERFVSGIPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4623
PFNGLCOLORTABLEPARAMETERIVSGIPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4624
PFNGLCOPYCOLORTABLESGIPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLint, GLsizei) 	# GL/glext.h:4625
PFNGLGETCOLORTABLESGIPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4626
PFNGLGETCOLORTABLEPARAMETERFVSGIPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4627
PFNGLGETCOLORTABLEPARAMETERIVSGIPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4628
# SGIX_pixel_texture (GL/glext.h:4631)
GL_SGIX_pixel_texture = 1 	# GL/glext.h:4632
# GL/glext.h:4634
glPixelTexGenSGIX = _link_function('glPixelTexGenSGIX', None, [GLenum], 'SGIX_pixel_texture')

PFNGLPIXELTEXGENSGIXPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:4636
# SGIS_pixel_texture (GL/glext.h:4639)
GL_SGIS_pixel_texture = 1 	# GL/glext.h:4640
# GL/glext.h:4642
glPixelTexGenParameteriSGIS = _link_function('glPixelTexGenParameteriSGIS', None, [GLenum, GLint], 'SGIS_pixel_texture')

# GL/glext.h:4643
glPixelTexGenParameterivSGIS = _link_function('glPixelTexGenParameterivSGIS', None, [GLenum, POINTER(GLint)], 'SGIS_pixel_texture')

# GL/glext.h:4644
glPixelTexGenParameterfSGIS = _link_function('glPixelTexGenParameterfSGIS', None, [GLenum, GLfloat], 'SGIS_pixel_texture')

# GL/glext.h:4645
glPixelTexGenParameterfvSGIS = _link_function('glPixelTexGenParameterfvSGIS', None, [GLenum, POINTER(GLfloat)], 'SGIS_pixel_texture')

# GL/glext.h:4646
glGetPixelTexGenParameterivSGIS = _link_function('glGetPixelTexGenParameterivSGIS', None, [GLenum, POINTER(GLint)], 'SGIS_pixel_texture')

# GL/glext.h:4647
glGetPixelTexGenParameterfvSGIS = _link_function('glGetPixelTexGenParameterfvSGIS', None, [GLenum, POINTER(GLfloat)], 'SGIS_pixel_texture')

PFNGLPIXELTEXGENPARAMETERISGISPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:4649
PFNGLPIXELTEXGENPARAMETERIVSGISPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:4650
PFNGLPIXELTEXGENPARAMETERFSGISPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:4651
PFNGLPIXELTEXGENPARAMETERFVSGISPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4652
PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:4653
PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4654
# SGIS_texture4D (GL/glext.h:4657)
GL_SGIS_texture4D = 1 	# GL/glext.h:4658
# GL/glext.h:4660
glTexImage4DSGIS = _link_function('glTexImage4DSGIS', None, [GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, POINTER(GLvoid)], 'SGIS_texture4D')

# GL/glext.h:4661
glTexSubImage4DSGIS = _link_function('glTexSubImage4DSGIS', None, [GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'SGIS_texture4D')

PFNGLTEXIMAGE4DSGISPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4663
PFNGLTEXSUBIMAGE4DSGISPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4664
# SGI_texture_color_table (GL/glext.h:4667)
GL_SGI_texture_color_table = 1 	# GL/glext.h:4668
# EXT_cmyka (GL/glext.h:4671)
GL_EXT_cmyka = 1 	# GL/glext.h:4672
# EXT_texture_object (GL/glext.h:4675)
GL_EXT_texture_object = 1 	# GL/glext.h:4676
# GL/glext.h:4678
glAreTexturesResidentEXT = _link_function('glAreTexturesResidentEXT', GLboolean, [GLsizei, POINTER(GLuint), POINTER(GLboolean)], 'EXT_texture_object')

# GL/glext.h:4679
glBindTextureEXT = _link_function('glBindTextureEXT', None, [GLenum, GLuint], 'EXT_texture_object')

# GL/glext.h:4680
glDeleteTexturesEXT = _link_function('glDeleteTexturesEXT', None, [GLsizei, POINTER(GLuint)], 'EXT_texture_object')

# GL/glext.h:4681
glGenTexturesEXT = _link_function('glGenTexturesEXT', None, [GLsizei, POINTER(GLuint)], 'EXT_texture_object')

# GL/glext.h:4682
glIsTextureEXT = _link_function('glIsTextureEXT', GLboolean, [GLuint], 'EXT_texture_object')

# GL/glext.h:4683
glPrioritizeTexturesEXT = _link_function('glPrioritizeTexturesEXT', None, [GLsizei, POINTER(GLuint), POINTER(GLclampf)], 'EXT_texture_object')

PFNGLARETEXTURESRESIDENTEXTPROC = CFUNCTYPE(GLboolean, GLsizei, POINTER(GLuint), POINTER(GLboolean)) 	# GL/glext.h:4685
PFNGLBINDTEXTUREEXTPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:4686
PFNGLDELETETEXTURESEXTPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:4687
PFNGLGENTEXTURESEXTPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:4688
PFNGLISTEXTUREEXTPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:4689
PFNGLPRIORITIZETEXTURESEXTPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint), POINTER(GLclampf)) 	# GL/glext.h:4690
# SGIS_detail_texture (GL/glext.h:4693)
GL_SGIS_detail_texture = 1 	# GL/glext.h:4694
# GL/glext.h:4696
glDetailTexFuncSGIS = _link_function('glDetailTexFuncSGIS', None, [GLenum, GLsizei, POINTER(GLfloat)], 'SGIS_detail_texture')

# GL/glext.h:4697
glGetDetailTexFuncSGIS = _link_function('glGetDetailTexFuncSGIS', None, [GLenum, POINTER(GLfloat)], 'SGIS_detail_texture')

PFNGLDETAILTEXFUNCSGISPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4699
PFNGLGETDETAILTEXFUNCSGISPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4700
# SGIS_sharpen_texture (GL/glext.h:4703)
GL_SGIS_sharpen_texture = 1 	# GL/glext.h:4704
# GL/glext.h:4706
glSharpenTexFuncSGIS = _link_function('glSharpenTexFuncSGIS', None, [GLenum, GLsizei, POINTER(GLfloat)], 'SGIS_sharpen_texture')

# GL/glext.h:4707
glGetSharpenTexFuncSGIS = _link_function('glGetSharpenTexFuncSGIS', None, [GLenum, POINTER(GLfloat)], 'SGIS_sharpen_texture')

PFNGLSHARPENTEXFUNCSGISPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4709
PFNGLGETSHARPENTEXFUNCSGISPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4710
# EXT_packed_pixels (GL/glext.h:4713)
GL_EXT_packed_pixels = 1 	# GL/glext.h:4714
# SGIS_texture_lod (GL/glext.h:4717)
GL_SGIS_texture_lod = 1 	# GL/glext.h:4718
# SGIS_multisample (GL/glext.h:4721)
GL_SGIS_multisample = 1 	# GL/glext.h:4722
# GL/glext.h:4724
glSampleMaskSGIS = _link_function('glSampleMaskSGIS', None, [GLclampf, GLboolean], 'SGIS_multisample')

# GL/glext.h:4725
glSamplePatternSGIS = _link_function('glSamplePatternSGIS', None, [GLenum], 'SGIS_multisample')

PFNGLSAMPLEMASKSGISPROC = CFUNCTYPE(None, GLclampf, GLboolean) 	# GL/glext.h:4727
PFNGLSAMPLEPATTERNSGISPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:4728
# EXT_rescale_normal (GL/glext.h:4731)
GL_EXT_rescale_normal = 1 	# GL/glext.h:4732
# EXT_vertex_array (GL/glext.h:4735)
GL_EXT_vertex_array = 1 	# GL/glext.h:4736
# GL/glext.h:4738
glArrayElementEXT = _link_function('glArrayElementEXT', None, [GLint], 'EXT_vertex_array')

# GL/glext.h:4739
glColorPointerEXT = _link_function('glColorPointerEXT', None, [GLint, GLenum, GLsizei, GLsizei, POINTER(GLvoid)], 'EXT_vertex_array')

# GL/glext.h:4740
glDrawArraysEXT = _link_function('glDrawArraysEXT', None, [GLenum, GLint, GLsizei], 'EXT_vertex_array')

# GL/glext.h:4741
glEdgeFlagPointerEXT = _link_function('glEdgeFlagPointerEXT', None, [GLsizei, GLsizei, POINTER(GLboolean)], 'EXT_vertex_array')

# GL/glext.h:4742
glGetPointervEXT = _link_function('glGetPointervEXT', None, [GLenum, POINTER(POINTER(GLvoid))], 'EXT_vertex_array')

# GL/glext.h:4743
glIndexPointerEXT = _link_function('glIndexPointerEXT', None, [GLenum, GLsizei, GLsizei, POINTER(GLvoid)], 'EXT_vertex_array')

# GL/glext.h:4744
glNormalPointerEXT = _link_function('glNormalPointerEXT', None, [GLenum, GLsizei, GLsizei, POINTER(GLvoid)], 'EXT_vertex_array')

# GL/glext.h:4745
glTexCoordPointerEXT = _link_function('glTexCoordPointerEXT', None, [GLint, GLenum, GLsizei, GLsizei, POINTER(GLvoid)], 'EXT_vertex_array')

# GL/glext.h:4746
glVertexPointerEXT = _link_function('glVertexPointerEXT', None, [GLint, GLenum, GLsizei, GLsizei, POINTER(GLvoid)], 'EXT_vertex_array')

PFNGLARRAYELEMENTEXTPROC = CFUNCTYPE(None, GLint) 	# GL/glext.h:4748
PFNGLCOLORPOINTEREXTPROC = CFUNCTYPE(None, GLint, GLenum, GLsizei, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4749
PFNGLDRAWARRAYSEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLsizei) 	# GL/glext.h:4750
PFNGLEDGEFLAGPOINTEREXTPROC = CFUNCTYPE(None, GLsizei, GLsizei, POINTER(GLboolean)) 	# GL/glext.h:4751
PFNGLGETPOINTERVEXTPROC = CFUNCTYPE(None, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:4752
PFNGLINDEXPOINTEREXTPROC = CFUNCTYPE(None, GLenum, GLsizei, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4753
PFNGLNORMALPOINTEREXTPROC = CFUNCTYPE(None, GLenum, GLsizei, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4754
PFNGLTEXCOORDPOINTEREXTPROC = CFUNCTYPE(None, GLint, GLenum, GLsizei, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4755
PFNGLVERTEXPOINTEREXTPROC = CFUNCTYPE(None, GLint, GLenum, GLsizei, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:4756
# EXT_misc_attribute (GL/glext.h:4759)
GL_EXT_misc_attribute = 1 	# GL/glext.h:4760
# SGIS_generate_mipmap (GL/glext.h:4763)
GL_SGIS_generate_mipmap = 1 	# GL/glext.h:4764
# SGIX_clipmap (GL/glext.h:4767)
GL_SGIX_clipmap = 1 	# GL/glext.h:4768
# SGIX_shadow (GL/glext.h:4771)
GL_SGIX_shadow = 1 	# GL/glext.h:4772
# SGIS_texture_edge_clamp (GL/glext.h:4775)
GL_SGIS_texture_edge_clamp = 1 	# GL/glext.h:4776
# SGIS_texture_border_clamp (GL/glext.h:4779)
GL_SGIS_texture_border_clamp = 1 	# GL/glext.h:4780
# EXT_blend_minmax (GL/glext.h:4783)
GL_EXT_blend_minmax = 1 	# GL/glext.h:4784
# GL/glext.h:4786
glBlendEquationEXT = _link_function('glBlendEquationEXT', None, [GLenum], 'EXT_blend_minmax')

PFNGLBLENDEQUATIONEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:4788
# EXT_blend_subtract (GL/glext.h:4791)
GL_EXT_blend_subtract = 1 	# GL/glext.h:4792
# EXT_blend_logic_op (GL/glext.h:4795)
GL_EXT_blend_logic_op = 1 	# GL/glext.h:4796
# SGIX_interlace (GL/glext.h:4799)
GL_SGIX_interlace = 1 	# GL/glext.h:4800
# SGIX_pixel_tiles (GL/glext.h:4803)
GL_SGIX_pixel_tiles = 1 	# GL/glext.h:4804
# SGIX_texture_select (GL/glext.h:4807)
GL_SGIX_texture_select = 1 	# GL/glext.h:4808
# SGIX_sprite (GL/glext.h:4811)
GL_SGIX_sprite = 1 	# GL/glext.h:4812
# GL/glext.h:4814
glSpriteParameterfSGIX = _link_function('glSpriteParameterfSGIX', None, [GLenum, GLfloat], 'SGIX_sprite')

# GL/glext.h:4815
glSpriteParameterfvSGIX = _link_function('glSpriteParameterfvSGIX', None, [GLenum, POINTER(GLfloat)], 'SGIX_sprite')

# GL/glext.h:4816
glSpriteParameteriSGIX = _link_function('glSpriteParameteriSGIX', None, [GLenum, GLint], 'SGIX_sprite')

# GL/glext.h:4817
glSpriteParameterivSGIX = _link_function('glSpriteParameterivSGIX', None, [GLenum, POINTER(GLint)], 'SGIX_sprite')

PFNGLSPRITEPARAMETERFSGIXPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:4819
PFNGLSPRITEPARAMETERFVSGIXPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4820
PFNGLSPRITEPARAMETERISGIXPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:4821
PFNGLSPRITEPARAMETERIVSGIXPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:4822
# SGIX_texture_multi_buffer (GL/glext.h:4825)
GL_SGIX_texture_multi_buffer = 1 	# GL/glext.h:4826
# EXT_point_parameters (GL/glext.h:4829)
GL_EXT_point_parameters = 1 	# GL/glext.h:4830
# GL/glext.h:4832
glPointParameterfEXT = _link_function('glPointParameterfEXT', None, [GLenum, GLfloat], 'EXT_point_parameters')

# GL/glext.h:4833
glPointParameterfvEXT = _link_function('glPointParameterfvEXT', None, [GLenum, POINTER(GLfloat)], 'EXT_point_parameters')

PFNGLPOINTPARAMETERFEXTPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:4835
PFNGLPOINTPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4836
# SGIS_point_parameters (GL/glext.h:4839)
GL_SGIS_point_parameters = 1 	# GL/glext.h:4840
# GL/glext.h:4842
glPointParameterfSGIS = _link_function('glPointParameterfSGIS', None, [GLenum, GLfloat], 'SGIS_point_parameters')

# GL/glext.h:4843
glPointParameterfvSGIS = _link_function('glPointParameterfvSGIS', None, [GLenum, POINTER(GLfloat)], 'SGIS_point_parameters')

PFNGLPOINTPARAMETERFSGISPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:4845
PFNGLPOINTPARAMETERFVSGISPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4846
# SGIX_instruments (GL/glext.h:4849)
GL_SGIX_instruments = 1 	# GL/glext.h:4850
# GL/glext.h:4852
glGetInstrumentsSGIX = _link_function('glGetInstrumentsSGIX', GLint, [], 'SGIX_instruments')

# GL/glext.h:4853
glInstrumentsBufferSGIX = _link_function('glInstrumentsBufferSGIX', None, [GLsizei, POINTER(GLint)], 'SGIX_instruments')

# GL/glext.h:4854
glPollInstrumentsSGIX = _link_function('glPollInstrumentsSGIX', GLint, [POINTER(GLint)], 'SGIX_instruments')

# GL/glext.h:4855
glReadInstrumentsSGIX = _link_function('glReadInstrumentsSGIX', None, [GLint], 'SGIX_instruments')

# GL/glext.h:4856
glStartInstrumentsSGIX = _link_function('glStartInstrumentsSGIX', None, [], 'SGIX_instruments')

# GL/glext.h:4857
glStopInstrumentsSGIX = _link_function('glStopInstrumentsSGIX', None, [GLint], 'SGIX_instruments')

PFNGLGETINSTRUMENTSSGIXPROC = CFUNCTYPE(GLint) 	# GL/glext.h:4859
PFNGLINSTRUMENTSBUFFERSGIXPROC = CFUNCTYPE(None, GLsizei, POINTER(GLint)) 	# GL/glext.h:4860
PFNGLPOLLINSTRUMENTSSGIXPROC = CFUNCTYPE(GLint, POINTER(GLint)) 	# GL/glext.h:4861
PFNGLREADINSTRUMENTSSGIXPROC = CFUNCTYPE(None, GLint) 	# GL/glext.h:4862
PFNGLSTARTINSTRUMENTSSGIXPROC = CFUNCTYPE(None) 	# GL/glext.h:4863
PFNGLSTOPINSTRUMENTSSGIXPROC = CFUNCTYPE(None, GLint) 	# GL/glext.h:4864
# SGIX_texture_scale_bias (GL/glext.h:4867)
GL_SGIX_texture_scale_bias = 1 	# GL/glext.h:4868
# SGIX_framezoom (GL/glext.h:4871)
GL_SGIX_framezoom = 1 	# GL/glext.h:4872
# GL/glext.h:4874
glFrameZoomSGIX = _link_function('glFrameZoomSGIX', None, [GLint], 'SGIX_framezoom')

PFNGLFRAMEZOOMSGIXPROC = CFUNCTYPE(None, GLint) 	# GL/glext.h:4876
# SGIX_tag_sample_buffer (GL/glext.h:4879)
GL_SGIX_tag_sample_buffer = 1 	# GL/glext.h:4880
# GL/glext.h:4882
glTagSampleBufferSGIX = _link_function('glTagSampleBufferSGIX', None, [], 'SGIX_tag_sample_buffer')

PFNGLTAGSAMPLEBUFFERSGIXPROC = CFUNCTYPE(None) 	# GL/glext.h:4884
# SGIX_polynomial_ffd (GL/glext.h:4887)
GL_SGIX_polynomial_ffd = 1 	# GL/glext.h:4888
# GL/glext.h:4890
glDeformationMap3dSGIX = _link_function('glDeformationMap3dSGIX', None, [GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, POINTER(GLdouble)], 'SGIX_polynomial_ffd')

# GL/glext.h:4891
glDeformationMap3fSGIX = _link_function('glDeformationMap3fSGIX', None, [GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, POINTER(GLfloat)], 'SGIX_polynomial_ffd')

GLbitfield = c_uint 	# /usr/include/GL/gl.h:55
# GL/glext.h:4892
glDeformSGIX = _link_function('glDeformSGIX', None, [GLbitfield], 'SGIX_polynomial_ffd')

# GL/glext.h:4893
glLoadIdentityDeformationMapSGIX = _link_function('glLoadIdentityDeformationMapSGIX', None, [GLbitfield], 'SGIX_polynomial_ffd')

PFNGLDEFORMATIONMAP3DSGIXPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, POINTER(GLdouble)) 	# GL/glext.h:4895
PFNGLDEFORMATIONMAP3FSGIXPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, POINTER(GLfloat)) 	# GL/glext.h:4896
PFNGLDEFORMSGIXPROC = CFUNCTYPE(None, GLbitfield) 	# GL/glext.h:4897
PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC = CFUNCTYPE(None, GLbitfield) 	# GL/glext.h:4898
# SGIX_reference_plane (GL/glext.h:4901)
GL_SGIX_reference_plane = 1 	# GL/glext.h:4902
# GL/glext.h:4904
glReferencePlaneSGIX = _link_function('glReferencePlaneSGIX', None, [POINTER(GLdouble)], 'SGIX_reference_plane')

PFNGLREFERENCEPLANESGIXPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:4906
# SGIX_flush_raster (GL/glext.h:4909)
GL_SGIX_flush_raster = 1 	# GL/glext.h:4910
# GL/glext.h:4912
glFlushRasterSGIX = _link_function('glFlushRasterSGIX', None, [], 'SGIX_flush_raster')

PFNGLFLUSHRASTERSGIXPROC = CFUNCTYPE(None) 	# GL/glext.h:4914
# SGIX_depth_texture (GL/glext.h:4917)
GL_SGIX_depth_texture = 1 	# GL/glext.h:4918
# SGIS_fog_function (GL/glext.h:4921)
GL_SGIS_fog_function = 1 	# GL/glext.h:4922
# GL/glext.h:4924
glFogFuncSGIS = _link_function('glFogFuncSGIS', None, [GLsizei, POINTER(GLfloat)], 'SGIS_fog_function')

# GL/glext.h:4925
glGetFogFuncSGIS = _link_function('glGetFogFuncSGIS', None, [POINTER(GLfloat)], 'SGIS_fog_function')

PFNGLFOGFUNCSGISPROC = CFUNCTYPE(None, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:4927
PFNGLGETFOGFUNCSGISPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:4928
# SGIX_fog_offset (GL/glext.h:4931)
GL_SGIX_fog_offset = 1 	# GL/glext.h:4932
# HP_image_transform (GL/glext.h:4935)
GL_HP_image_transform = 1 	# GL/glext.h:4936
# GL/glext.h:4938
glImageTransformParameteriHP = _link_function('glImageTransformParameteriHP', None, [GLenum, GLenum, GLint], 'HP_image_transform')

# GL/glext.h:4939
glImageTransformParameterfHP = _link_function('glImageTransformParameterfHP', None, [GLenum, GLenum, GLfloat], 'HP_image_transform')

# GL/glext.h:4940
glImageTransformParameterivHP = _link_function('glImageTransformParameterivHP', None, [GLenum, GLenum, POINTER(GLint)], 'HP_image_transform')

# GL/glext.h:4941
glImageTransformParameterfvHP = _link_function('glImageTransformParameterfvHP', None, [GLenum, GLenum, POINTER(GLfloat)], 'HP_image_transform')

# GL/glext.h:4942
glGetImageTransformParameterivHP = _link_function('glGetImageTransformParameterivHP', None, [GLenum, GLenum, POINTER(GLint)], 'HP_image_transform')

# GL/glext.h:4943
glGetImageTransformParameterfvHP = _link_function('glGetImageTransformParameterfvHP', None, [GLenum, GLenum, POINTER(GLfloat)], 'HP_image_transform')

PFNGLIMAGETRANSFORMPARAMETERIHPPROC = CFUNCTYPE(None, GLenum, GLenum, GLint) 	# GL/glext.h:4945
PFNGLIMAGETRANSFORMPARAMETERFHPPROC = CFUNCTYPE(None, GLenum, GLenum, GLfloat) 	# GL/glext.h:4946
PFNGLIMAGETRANSFORMPARAMETERIVHPPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4947
PFNGLIMAGETRANSFORMPARAMETERFVHPPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4948
PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4949
PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4950
# HP_convolution_border_modes (GL/glext.h:4953)
GL_HP_convolution_border_modes = 1 	# GL/glext.h:4954
# SGIX_texture_add_env (GL/glext.h:4957)
GL_SGIX_texture_add_env = 1 	# GL/glext.h:4958
# EXT_color_subtable (GL/glext.h:4961)
GL_EXT_color_subtable = 1 	# GL/glext.h:4962
# GL/glext.h:4964
glColorSubTableEXT = _link_function('glColorSubTableEXT', None, [GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'EXT_color_subtable')

# GL/glext.h:4965
glCopyColorSubTableEXT = _link_function('glCopyColorSubTableEXT', None, [GLenum, GLsizei, GLint, GLint, GLsizei], 'EXT_color_subtable')

PFNGLCOLORSUBTABLEEXTPROC = CFUNCTYPE(None, GLenum, GLsizei, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4967
PFNGLCOPYCOLORSUBTABLEEXTPROC = CFUNCTYPE(None, GLenum, GLsizei, GLint, GLint, GLsizei) 	# GL/glext.h:4968
# PGI_vertex_hints (GL/glext.h:4971)
GL_PGI_vertex_hints = 1 	# GL/glext.h:4972
# PGI_misc_hints (GL/glext.h:4975)
GL_PGI_misc_hints = 1 	# GL/glext.h:4976
# GL/glext.h:4978
glHintPGI = _link_function('glHintPGI', None, [GLenum, GLint], 'PGI_misc_hints')

PFNGLHINTPGIPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:4980
# EXT_paletted_texture (GL/glext.h:4983)
GL_EXT_paletted_texture = 1 	# GL/glext.h:4984
# GL/glext.h:4986
glColorTableEXT = _link_function('glColorTableEXT', None, [GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)], 'EXT_paletted_texture')

# GL/glext.h:4987
glGetColorTableEXT = _link_function('glGetColorTableEXT', None, [GLenum, GLenum, GLenum, POINTER(GLvoid)], 'EXT_paletted_texture')

# GL/glext.h:4988
glGetColorTableParameterivEXT = _link_function('glGetColorTableParameterivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_paletted_texture')

# GL/glext.h:4989
glGetColorTableParameterfvEXT = _link_function('glGetColorTableParameterfvEXT', None, [GLenum, GLenum, POINTER(GLfloat)], 'EXT_paletted_texture')

PFNGLCOLORTABLEEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4991
PFNGLGETCOLORTABLEEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLvoid)) 	# GL/glext.h:4992
PFNGLGETCOLORTABLEPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:4993
PFNGLGETCOLORTABLEPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:4994
# EXT_clip_volume_hint (GL/glext.h:4997)
GL_EXT_clip_volume_hint = 1 	# GL/glext.h:4998
# SGIX_list_priority (GL/glext.h:5001)
GL_SGIX_list_priority = 1 	# GL/glext.h:5002
# GL/glext.h:5004
glGetListParameterfvSGIX = _link_function('glGetListParameterfvSGIX', None, [GLuint, GLenum, POINTER(GLfloat)], 'SGIX_list_priority')

# GL/glext.h:5005
glGetListParameterivSGIX = _link_function('glGetListParameterivSGIX', None, [GLuint, GLenum, POINTER(GLint)], 'SGIX_list_priority')

# GL/glext.h:5006
glListParameterfSGIX = _link_function('glListParameterfSGIX', None, [GLuint, GLenum, GLfloat], 'SGIX_list_priority')

# GL/glext.h:5007
glListParameterfvSGIX = _link_function('glListParameterfvSGIX', None, [GLuint, GLenum, POINTER(GLfloat)], 'SGIX_list_priority')

# GL/glext.h:5008
glListParameteriSGIX = _link_function('glListParameteriSGIX', None, [GLuint, GLenum, GLint], 'SGIX_list_priority')

# GL/glext.h:5009
glListParameterivSGIX = _link_function('glListParameterivSGIX', None, [GLuint, GLenum, POINTER(GLint)], 'SGIX_list_priority')

PFNGLGETLISTPARAMETERFVSGIXPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5011
PFNGLGETLISTPARAMETERIVSGIXPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5012
PFNGLLISTPARAMETERFSGIXPROC = CFUNCTYPE(None, GLuint, GLenum, GLfloat) 	# GL/glext.h:5013
PFNGLLISTPARAMETERFVSGIXPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5014
PFNGLLISTPARAMETERISGIXPROC = CFUNCTYPE(None, GLuint, GLenum, GLint) 	# GL/glext.h:5015
PFNGLLISTPARAMETERIVSGIXPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5016
# SGIX_ir_instrument1 (GL/glext.h:5019)
GL_SGIX_ir_instrument1 = 1 	# GL/glext.h:5020
# SGIX_calligraphic_fragment (GL/glext.h:5023)
GL_SGIX_calligraphic_fragment = 1 	# GL/glext.h:5024
# SGIX_texture_lod_bias (GL/glext.h:5027)
GL_SGIX_texture_lod_bias = 1 	# GL/glext.h:5028
# SGIX_shadow_ambient (GL/glext.h:5031)
GL_SGIX_shadow_ambient = 1 	# GL/glext.h:5032
# EXT_index_texture (GL/glext.h:5035)
GL_EXT_index_texture = 1 	# GL/glext.h:5036
# EXT_index_material (GL/glext.h:5039)
GL_EXT_index_material = 1 	# GL/glext.h:5040
# GL/glext.h:5042
glIndexMaterialEXT = _link_function('glIndexMaterialEXT', None, [GLenum, GLenum], 'EXT_index_material')

PFNGLINDEXMATERIALEXTPROC = CFUNCTYPE(None, GLenum, GLenum) 	# GL/glext.h:5044
# EXT_index_func (GL/glext.h:5047)
GL_EXT_index_func = 1 	# GL/glext.h:5048
# GL/glext.h:5050
glIndexFuncEXT = _link_function('glIndexFuncEXT', None, [GLenum, GLclampf], 'EXT_index_func')

PFNGLINDEXFUNCEXTPROC = CFUNCTYPE(None, GLenum, GLclampf) 	# GL/glext.h:5052
# EXT_index_array_formats (GL/glext.h:5055)
GL_EXT_index_array_formats = 1 	# GL/glext.h:5056
# EXT_compiled_vertex_array (GL/glext.h:5059)
GL_EXT_compiled_vertex_array = 1 	# GL/glext.h:5060
# GL/glext.h:5062
glLockArraysEXT = _link_function('glLockArraysEXT', None, [GLint, GLsizei], 'EXT_compiled_vertex_array')

# GL/glext.h:5063
glUnlockArraysEXT = _link_function('glUnlockArraysEXT', None, [], 'EXT_compiled_vertex_array')

PFNGLLOCKARRAYSEXTPROC = CFUNCTYPE(None, GLint, GLsizei) 	# GL/glext.h:5065
PFNGLUNLOCKARRAYSEXTPROC = CFUNCTYPE(None) 	# GL/glext.h:5066
# EXT_cull_vertex (GL/glext.h:5069)
GL_EXT_cull_vertex = 1 	# GL/glext.h:5070
# GL/glext.h:5072
glCullParameterdvEXT = _link_function('glCullParameterdvEXT', None, [GLenum, POINTER(GLdouble)], 'EXT_cull_vertex')

# GL/glext.h:5073
glCullParameterfvEXT = _link_function('glCullParameterfvEXT', None, [GLenum, POINTER(GLfloat)], 'EXT_cull_vertex')

PFNGLCULLPARAMETERDVEXTPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:5075
PFNGLCULLPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5076
# SGIX_ycrcb (GL/glext.h:5079)
GL_SGIX_ycrcb = 1 	# GL/glext.h:5080
# SGIX_fragment_lighting (GL/glext.h:5083)
GL_SGIX_fragment_lighting = 1 	# GL/glext.h:5084
# GL/glext.h:5086
glFragmentColorMaterialSGIX = _link_function('glFragmentColorMaterialSGIX', None, [GLenum, GLenum], 'SGIX_fragment_lighting')

# GL/glext.h:5087
glFragmentLightfSGIX = _link_function('glFragmentLightfSGIX', None, [GLenum, GLenum, GLfloat], 'SGIX_fragment_lighting')

# GL/glext.h:5088
glFragmentLightfvSGIX = _link_function('glFragmentLightfvSGIX', None, [GLenum, GLenum, POINTER(GLfloat)], 'SGIX_fragment_lighting')

# GL/glext.h:5089
glFragmentLightiSGIX = _link_function('glFragmentLightiSGIX', None, [GLenum, GLenum, GLint], 'SGIX_fragment_lighting')

# GL/glext.h:5090
glFragmentLightivSGIX = _link_function('glFragmentLightivSGIX', None, [GLenum, GLenum, POINTER(GLint)], 'SGIX_fragment_lighting')

# GL/glext.h:5091
glFragmentLightModelfSGIX = _link_function('glFragmentLightModelfSGIX', None, [GLenum, GLfloat], 'SGIX_fragment_lighting')

# GL/glext.h:5092
glFragmentLightModelfvSGIX = _link_function('glFragmentLightModelfvSGIX', None, [GLenum, POINTER(GLfloat)], 'SGIX_fragment_lighting')

# GL/glext.h:5093
glFragmentLightModeliSGIX = _link_function('glFragmentLightModeliSGIX', None, [GLenum, GLint], 'SGIX_fragment_lighting')

# GL/glext.h:5094
glFragmentLightModelivSGIX = _link_function('glFragmentLightModelivSGIX', None, [GLenum, POINTER(GLint)], 'SGIX_fragment_lighting')

# GL/glext.h:5095
glFragmentMaterialfSGIX = _link_function('glFragmentMaterialfSGIX', None, [GLenum, GLenum, GLfloat], 'SGIX_fragment_lighting')

# GL/glext.h:5096
glFragmentMaterialfvSGIX = _link_function('glFragmentMaterialfvSGIX', None, [GLenum, GLenum, POINTER(GLfloat)], 'SGIX_fragment_lighting')

# GL/glext.h:5097
glFragmentMaterialiSGIX = _link_function('glFragmentMaterialiSGIX', None, [GLenum, GLenum, GLint], 'SGIX_fragment_lighting')

# GL/glext.h:5098
glFragmentMaterialivSGIX = _link_function('glFragmentMaterialivSGIX', None, [GLenum, GLenum, POINTER(GLint)], 'SGIX_fragment_lighting')

# GL/glext.h:5099
glGetFragmentLightfvSGIX = _link_function('glGetFragmentLightfvSGIX', None, [GLenum, GLenum, POINTER(GLfloat)], 'SGIX_fragment_lighting')

# GL/glext.h:5100
glGetFragmentLightivSGIX = _link_function('glGetFragmentLightivSGIX', None, [GLenum, GLenum, POINTER(GLint)], 'SGIX_fragment_lighting')

# GL/glext.h:5101
glGetFragmentMaterialfvSGIX = _link_function('glGetFragmentMaterialfvSGIX', None, [GLenum, GLenum, POINTER(GLfloat)], 'SGIX_fragment_lighting')

# GL/glext.h:5102
glGetFragmentMaterialivSGIX = _link_function('glGetFragmentMaterialivSGIX', None, [GLenum, GLenum, POINTER(GLint)], 'SGIX_fragment_lighting')

# GL/glext.h:5103
glLightEnviSGIX = _link_function('glLightEnviSGIX', None, [GLenum, GLint], 'SGIX_fragment_lighting')

PFNGLFRAGMENTCOLORMATERIALSGIXPROC = CFUNCTYPE(None, GLenum, GLenum) 	# GL/glext.h:5105
PFNGLFRAGMENTLIGHTFSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, GLfloat) 	# GL/glext.h:5106
PFNGLFRAGMENTLIGHTFVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5107
PFNGLFRAGMENTLIGHTISGIXPROC = CFUNCTYPE(None, GLenum, GLenum, GLint) 	# GL/glext.h:5108
PFNGLFRAGMENTLIGHTIVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5109
PFNGLFRAGMENTLIGHTMODELFSGIXPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:5110
PFNGLFRAGMENTLIGHTMODELFVSGIXPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5111
PFNGLFRAGMENTLIGHTMODELISGIXPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:5112
PFNGLFRAGMENTLIGHTMODELIVSGIXPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:5113
PFNGLFRAGMENTMATERIALFSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, GLfloat) 	# GL/glext.h:5114
PFNGLFRAGMENTMATERIALFVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5115
PFNGLFRAGMENTMATERIALISGIXPROC = CFUNCTYPE(None, GLenum, GLenum, GLint) 	# GL/glext.h:5116
PFNGLFRAGMENTMATERIALIVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5117
PFNGLGETFRAGMENTLIGHTFVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5118
PFNGLGETFRAGMENTLIGHTIVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5119
PFNGLGETFRAGMENTMATERIALFVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5120
PFNGLGETFRAGMENTMATERIALIVSGIXPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5121
PFNGLLIGHTENVISGIXPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:5122
# IBM_rasterpos_clip (GL/glext.h:5125)
GL_IBM_rasterpos_clip = 1 	# GL/glext.h:5126
# HP_texture_lighting (GL/glext.h:5129)
GL_HP_texture_lighting = 1 	# GL/glext.h:5130
# EXT_draw_range_elements (GL/glext.h:5133)
GL_EXT_draw_range_elements = 1 	# GL/glext.h:5134
# GL/glext.h:5136
glDrawRangeElementsEXT = _link_function('glDrawRangeElementsEXT', None, [GLenum, GLuint, GLuint, GLsizei, GLenum, POINTER(GLvoid)], 'EXT_draw_range_elements')

PFNGLDRAWRANGEELEMENTSEXTPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLsizei, GLenum, POINTER(GLvoid)) 	# GL/glext.h:5138
# WIN_phong_shading (GL/glext.h:5141)
GL_WIN_phong_shading = 1 	# GL/glext.h:5142
# WIN_specular_fog (GL/glext.h:5145)
GL_WIN_specular_fog = 1 	# GL/glext.h:5146
# EXT_light_texture (GL/glext.h:5149)
GL_EXT_light_texture = 1 	# GL/glext.h:5150
# GL/glext.h:5152
glApplyTextureEXT = _link_function('glApplyTextureEXT', None, [GLenum], 'EXT_light_texture')

# GL/glext.h:5153
glTextureLightEXT = _link_function('glTextureLightEXT', None, [GLenum], 'EXT_light_texture')

# GL/glext.h:5154
glTextureMaterialEXT = _link_function('glTextureMaterialEXT', None, [GLenum, GLenum], 'EXT_light_texture')

PFNGLAPPLYTEXTUREEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:5156
PFNGLTEXTURELIGHTEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:5157
PFNGLTEXTUREMATERIALEXTPROC = CFUNCTYPE(None, GLenum, GLenum) 	# GL/glext.h:5158
# SGIX_blend_alpha_minmax (GL/glext.h:5161)
GL_SGIX_blend_alpha_minmax = 1 	# GL/glext.h:5162
# EXT_bgra (GL/glext.h:5165)
GL_EXT_bgra = 1 	# GL/glext.h:5166
# SGIX_async (GL/glext.h:5169)
GL_SGIX_async = 1 	# GL/glext.h:5170
# GL/glext.h:5172
glAsyncMarkerSGIX = _link_function('glAsyncMarkerSGIX', None, [GLuint], 'SGIX_async')

# GL/glext.h:5173
glFinishAsyncSGIX = _link_function('glFinishAsyncSGIX', GLint, [POINTER(GLuint)], 'SGIX_async')

# GL/glext.h:5174
glPollAsyncSGIX = _link_function('glPollAsyncSGIX', GLint, [POINTER(GLuint)], 'SGIX_async')

# GL/glext.h:5175
glGenAsyncMarkersSGIX = _link_function('glGenAsyncMarkersSGIX', GLuint, [GLsizei], 'SGIX_async')

# GL/glext.h:5176
glDeleteAsyncMarkersSGIX = _link_function('glDeleteAsyncMarkersSGIX', None, [GLuint, GLsizei], 'SGIX_async')

# GL/glext.h:5177
glIsAsyncMarkerSGIX = _link_function('glIsAsyncMarkerSGIX', GLboolean, [GLuint], 'SGIX_async')

PFNGLASYNCMARKERSGIXPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5179
PFNGLFINISHASYNCSGIXPROC = CFUNCTYPE(GLint, POINTER(GLuint)) 	# GL/glext.h:5180
PFNGLPOLLASYNCSGIXPROC = CFUNCTYPE(GLint, POINTER(GLuint)) 	# GL/glext.h:5181
PFNGLGENASYNCMARKERSSGIXPROC = CFUNCTYPE(GLuint, GLsizei) 	# GL/glext.h:5182
PFNGLDELETEASYNCMARKERSSGIXPROC = CFUNCTYPE(None, GLuint, GLsizei) 	# GL/glext.h:5183
PFNGLISASYNCMARKERSGIXPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:5184
# SGIX_async_pixel (GL/glext.h:5187)
GL_SGIX_async_pixel = 1 	# GL/glext.h:5188
# SGIX_async_histogram (GL/glext.h:5191)
GL_SGIX_async_histogram = 1 	# GL/glext.h:5192
# INTEL_parallel_arrays (GL/glext.h:5195)
GL_INTEL_parallel_arrays = 1 	# GL/glext.h:5196
# GL/glext.h:5198
glVertexPointervINTEL = _link_function('glVertexPointervINTEL', None, [GLint, GLenum, POINTER(POINTER(GLvoid))], 'INTEL_parallel_arrays')

# GL/glext.h:5199
glNormalPointervINTEL = _link_function('glNormalPointervINTEL', None, [GLenum, POINTER(POINTER(GLvoid))], 'INTEL_parallel_arrays')

# GL/glext.h:5200
glColorPointervINTEL = _link_function('glColorPointervINTEL', None, [GLint, GLenum, POINTER(POINTER(GLvoid))], 'INTEL_parallel_arrays')

# GL/glext.h:5201
glTexCoordPointervINTEL = _link_function('glTexCoordPointervINTEL', None, [GLint, GLenum, POINTER(POINTER(GLvoid))], 'INTEL_parallel_arrays')

PFNGLVERTEXPOINTERVINTELPROC = CFUNCTYPE(None, GLint, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:5203
PFNGLNORMALPOINTERVINTELPROC = CFUNCTYPE(None, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:5204
PFNGLCOLORPOINTERVINTELPROC = CFUNCTYPE(None, GLint, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:5205
PFNGLTEXCOORDPOINTERVINTELPROC = CFUNCTYPE(None, GLint, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:5206
# HP_occlusion_test (GL/glext.h:5209)
GL_HP_occlusion_test = 1 	# GL/glext.h:5210
# EXT_pixel_transform (GL/glext.h:5213)
GL_EXT_pixel_transform = 1 	# GL/glext.h:5214
# GL/glext.h:5216
glPixelTransformParameteriEXT = _link_function('glPixelTransformParameteriEXT', None, [GLenum, GLenum, GLint], 'EXT_pixel_transform')

# GL/glext.h:5217
glPixelTransformParameterfEXT = _link_function('glPixelTransformParameterfEXT', None, [GLenum, GLenum, GLfloat], 'EXT_pixel_transform')

# GL/glext.h:5218
glPixelTransformParameterivEXT = _link_function('glPixelTransformParameterivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_pixel_transform')

# GL/glext.h:5219
glPixelTransformParameterfvEXT = _link_function('glPixelTransformParameterfvEXT', None, [GLenum, GLenum, POINTER(GLfloat)], 'EXT_pixel_transform')

PFNGLPIXELTRANSFORMPARAMETERIEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLint) 	# GL/glext.h:5221
PFNGLPIXELTRANSFORMPARAMETERFEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLfloat) 	# GL/glext.h:5222
PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5223
PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5224
# EXT_pixel_transform_color_table (GL/glext.h:5227)
GL_EXT_pixel_transform_color_table = 1 	# GL/glext.h:5228
# EXT_shared_texture_palette (GL/glext.h:5231)
GL_EXT_shared_texture_palette = 1 	# GL/glext.h:5232
# EXT_separate_specular_color (GL/glext.h:5235)
GL_EXT_separate_specular_color = 1 	# GL/glext.h:5236
# EXT_secondary_color (GL/glext.h:5239)
GL_EXT_secondary_color = 1 	# GL/glext.h:5240
# GL/glext.h:5242
glSecondaryColor3bEXT = _link_function('glSecondaryColor3bEXT', None, [GLbyte, GLbyte, GLbyte], 'EXT_secondary_color')

# GL/glext.h:5243
glSecondaryColor3bvEXT = _link_function('glSecondaryColor3bvEXT', None, [POINTER(GLbyte)], 'EXT_secondary_color')

# GL/glext.h:5244
glSecondaryColor3dEXT = _link_function('glSecondaryColor3dEXT', None, [GLdouble, GLdouble, GLdouble], 'EXT_secondary_color')

# GL/glext.h:5245
glSecondaryColor3dvEXT = _link_function('glSecondaryColor3dvEXT', None, [POINTER(GLdouble)], 'EXT_secondary_color')

# GL/glext.h:5246
glSecondaryColor3fEXT = _link_function('glSecondaryColor3fEXT', None, [GLfloat, GLfloat, GLfloat], 'EXT_secondary_color')

# GL/glext.h:5247
glSecondaryColor3fvEXT = _link_function('glSecondaryColor3fvEXT', None, [POINTER(GLfloat)], 'EXT_secondary_color')

# GL/glext.h:5248
glSecondaryColor3iEXT = _link_function('glSecondaryColor3iEXT', None, [GLint, GLint, GLint], 'EXT_secondary_color')

# GL/glext.h:5249
glSecondaryColor3ivEXT = _link_function('glSecondaryColor3ivEXT', None, [POINTER(GLint)], 'EXT_secondary_color')

# GL/glext.h:5250
glSecondaryColor3sEXT = _link_function('glSecondaryColor3sEXT', None, [GLshort, GLshort, GLshort], 'EXT_secondary_color')

# GL/glext.h:5251
glSecondaryColor3svEXT = _link_function('glSecondaryColor3svEXT', None, [POINTER(GLshort)], 'EXT_secondary_color')

# GL/glext.h:5252
glSecondaryColor3ubEXT = _link_function('glSecondaryColor3ubEXT', None, [GLubyte, GLubyte, GLubyte], 'EXT_secondary_color')

# GL/glext.h:5253
glSecondaryColor3ubvEXT = _link_function('glSecondaryColor3ubvEXT', None, [POINTER(GLubyte)], 'EXT_secondary_color')

# GL/glext.h:5254
glSecondaryColor3uiEXT = _link_function('glSecondaryColor3uiEXT', None, [GLuint, GLuint, GLuint], 'EXT_secondary_color')

# GL/glext.h:5255
glSecondaryColor3uivEXT = _link_function('glSecondaryColor3uivEXT', None, [POINTER(GLuint)], 'EXT_secondary_color')

# GL/glext.h:5256
glSecondaryColor3usEXT = _link_function('glSecondaryColor3usEXT', None, [GLushort, GLushort, GLushort], 'EXT_secondary_color')

# GL/glext.h:5257
glSecondaryColor3usvEXT = _link_function('glSecondaryColor3usvEXT', None, [POINTER(GLushort)], 'EXT_secondary_color')

# GL/glext.h:5258
glSecondaryColorPointerEXT = _link_function('glSecondaryColorPointerEXT', None, [GLint, GLenum, GLsizei, POINTER(GLvoid)], 'EXT_secondary_color')

PFNGLSECONDARYCOLOR3BEXTPROC = CFUNCTYPE(None, GLbyte, GLbyte, GLbyte) 	# GL/glext.h:5260
PFNGLSECONDARYCOLOR3BVEXTPROC = CFUNCTYPE(None, POINTER(GLbyte)) 	# GL/glext.h:5261
PFNGLSECONDARYCOLOR3DEXTPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:5262
PFNGLSECONDARYCOLOR3DVEXTPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:5263
PFNGLSECONDARYCOLOR3FEXTPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5264
PFNGLSECONDARYCOLOR3FVEXTPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:5265
PFNGLSECONDARYCOLOR3IEXTPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:5266
PFNGLSECONDARYCOLOR3IVEXTPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:5267
PFNGLSECONDARYCOLOR3SEXTPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort) 	# GL/glext.h:5268
PFNGLSECONDARYCOLOR3SVEXTPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:5269
PFNGLSECONDARYCOLOR3UBEXTPROC = CFUNCTYPE(None, GLubyte, GLubyte, GLubyte) 	# GL/glext.h:5270
PFNGLSECONDARYCOLOR3UBVEXTPROC = CFUNCTYPE(None, POINTER(GLubyte)) 	# GL/glext.h:5271
PFNGLSECONDARYCOLOR3UIEXTPROC = CFUNCTYPE(None, GLuint, GLuint, GLuint) 	# GL/glext.h:5272
PFNGLSECONDARYCOLOR3UIVEXTPROC = CFUNCTYPE(None, POINTER(GLuint)) 	# GL/glext.h:5273
PFNGLSECONDARYCOLOR3USEXTPROC = CFUNCTYPE(None, GLushort, GLushort, GLushort) 	# GL/glext.h:5274
PFNGLSECONDARYCOLOR3USVEXTPROC = CFUNCTYPE(None, POINTER(GLushort)) 	# GL/glext.h:5275
PFNGLSECONDARYCOLORPOINTEREXTPROC = CFUNCTYPE(None, GLint, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:5276
# EXT_texture_perturb_normal (GL/glext.h:5279)
GL_EXT_texture_perturb_normal = 1 	# GL/glext.h:5280
# GL/glext.h:5282
glTextureNormalEXT = _link_function('glTextureNormalEXT', None, [GLenum], 'EXT_texture_perturb_normal')

PFNGLTEXTURENORMALEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:5284
# EXT_multi_draw_arrays (GL/glext.h:5287)
GL_EXT_multi_draw_arrays = 1 	# GL/glext.h:5288
# GL/glext.h:5290
glMultiDrawArraysEXT = _link_function('glMultiDrawArraysEXT', None, [GLenum, POINTER(GLint), POINTER(GLsizei), GLsizei], 'EXT_multi_draw_arrays')

# GL/glext.h:5291
glMultiDrawElementsEXT = _link_function('glMultiDrawElementsEXT', None, [GLenum, POINTER(GLsizei), GLenum, POINTER(POINTER(GLvoid)), GLsizei], 'EXT_multi_draw_arrays')

PFNGLMULTIDRAWARRAYSEXTPROC = CFUNCTYPE(None, GLenum, POINTER(GLint), POINTER(GLsizei), GLsizei) 	# GL/glext.h:5293
PFNGLMULTIDRAWELEMENTSEXTPROC = CFUNCTYPE(None, GLenum, POINTER(GLsizei), GLenum, POINTER(POINTER(GLvoid)), GLsizei) 	# GL/glext.h:5294
# EXT_fog_coord (GL/glext.h:5297)
GL_EXT_fog_coord = 1 	# GL/glext.h:5298
# GL/glext.h:5300
glFogCoordfEXT = _link_function('glFogCoordfEXT', None, [GLfloat], 'EXT_fog_coord')

# GL/glext.h:5301
glFogCoordfvEXT = _link_function('glFogCoordfvEXT', None, [POINTER(GLfloat)], 'EXT_fog_coord')

# GL/glext.h:5302
glFogCoorddEXT = _link_function('glFogCoorddEXT', None, [GLdouble], 'EXT_fog_coord')

# GL/glext.h:5303
glFogCoorddvEXT = _link_function('glFogCoorddvEXT', None, [POINTER(GLdouble)], 'EXT_fog_coord')

# GL/glext.h:5304
glFogCoordPointerEXT = _link_function('glFogCoordPointerEXT', None, [GLenum, GLsizei, POINTER(GLvoid)], 'EXT_fog_coord')

PFNGLFOGCOORDFEXTPROC = CFUNCTYPE(None, GLfloat) 	# GL/glext.h:5306
PFNGLFOGCOORDFVEXTPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:5307
PFNGLFOGCOORDDEXTPROC = CFUNCTYPE(None, GLdouble) 	# GL/glext.h:5308
PFNGLFOGCOORDDVEXTPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:5309
PFNGLFOGCOORDPOINTEREXTPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:5310
# REND_screen_coordinates (GL/glext.h:5313)
GL_REND_screen_coordinates = 1 	# GL/glext.h:5314
# EXT_coordinate_frame (GL/glext.h:5317)
GL_EXT_coordinate_frame = 1 	# GL/glext.h:5318
# GL/glext.h:5320
glTangent3bEXT = _link_function('glTangent3bEXT', None, [GLbyte, GLbyte, GLbyte], 'EXT_coordinate_frame')

# GL/glext.h:5321
glTangent3bvEXT = _link_function('glTangent3bvEXT', None, [POINTER(GLbyte)], 'EXT_coordinate_frame')

# GL/glext.h:5322
glTangent3dEXT = _link_function('glTangent3dEXT', None, [GLdouble, GLdouble, GLdouble], 'EXT_coordinate_frame')

# GL/glext.h:5323
glTangent3dvEXT = _link_function('glTangent3dvEXT', None, [POINTER(GLdouble)], 'EXT_coordinate_frame')

# GL/glext.h:5324
glTangent3fEXT = _link_function('glTangent3fEXT', None, [GLfloat, GLfloat, GLfloat], 'EXT_coordinate_frame')

# GL/glext.h:5325
glTangent3fvEXT = _link_function('glTangent3fvEXT', None, [POINTER(GLfloat)], 'EXT_coordinate_frame')

# GL/glext.h:5326
glTangent3iEXT = _link_function('glTangent3iEXT', None, [GLint, GLint, GLint], 'EXT_coordinate_frame')

# GL/glext.h:5327
glTangent3ivEXT = _link_function('glTangent3ivEXT', None, [POINTER(GLint)], 'EXT_coordinate_frame')

# GL/glext.h:5328
glTangent3sEXT = _link_function('glTangent3sEXT', None, [GLshort, GLshort, GLshort], 'EXT_coordinate_frame')

# GL/glext.h:5329
glTangent3svEXT = _link_function('glTangent3svEXT', None, [POINTER(GLshort)], 'EXT_coordinate_frame')

# GL/glext.h:5330
glBinormal3bEXT = _link_function('glBinormal3bEXT', None, [GLbyte, GLbyte, GLbyte], 'EXT_coordinate_frame')

# GL/glext.h:5331
glBinormal3bvEXT = _link_function('glBinormal3bvEXT', None, [POINTER(GLbyte)], 'EXT_coordinate_frame')

# GL/glext.h:5332
glBinormal3dEXT = _link_function('glBinormal3dEXT', None, [GLdouble, GLdouble, GLdouble], 'EXT_coordinate_frame')

# GL/glext.h:5333
glBinormal3dvEXT = _link_function('glBinormal3dvEXT', None, [POINTER(GLdouble)], 'EXT_coordinate_frame')

# GL/glext.h:5334
glBinormal3fEXT = _link_function('glBinormal3fEXT', None, [GLfloat, GLfloat, GLfloat], 'EXT_coordinate_frame')

# GL/glext.h:5335
glBinormal3fvEXT = _link_function('glBinormal3fvEXT', None, [POINTER(GLfloat)], 'EXT_coordinate_frame')

# GL/glext.h:5336
glBinormal3iEXT = _link_function('glBinormal3iEXT', None, [GLint, GLint, GLint], 'EXT_coordinate_frame')

# GL/glext.h:5337
glBinormal3ivEXT = _link_function('glBinormal3ivEXT', None, [POINTER(GLint)], 'EXT_coordinate_frame')

# GL/glext.h:5338
glBinormal3sEXT = _link_function('glBinormal3sEXT', None, [GLshort, GLshort, GLshort], 'EXT_coordinate_frame')

# GL/glext.h:5339
glBinormal3svEXT = _link_function('glBinormal3svEXT', None, [POINTER(GLshort)], 'EXT_coordinate_frame')

# GL/glext.h:5340
glTangentPointerEXT = _link_function('glTangentPointerEXT', None, [GLenum, GLsizei, POINTER(GLvoid)], 'EXT_coordinate_frame')

# GL/glext.h:5341
glBinormalPointerEXT = _link_function('glBinormalPointerEXT', None, [GLenum, GLsizei, POINTER(GLvoid)], 'EXT_coordinate_frame')

PFNGLTANGENT3BEXTPROC = CFUNCTYPE(None, GLbyte, GLbyte, GLbyte) 	# GL/glext.h:5343
PFNGLTANGENT3BVEXTPROC = CFUNCTYPE(None, POINTER(GLbyte)) 	# GL/glext.h:5344
PFNGLTANGENT3DEXTPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:5345
PFNGLTANGENT3DVEXTPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:5346
PFNGLTANGENT3FEXTPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5347
PFNGLTANGENT3FVEXTPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:5348
PFNGLTANGENT3IEXTPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:5349
PFNGLTANGENT3IVEXTPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:5350
PFNGLTANGENT3SEXTPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort) 	# GL/glext.h:5351
PFNGLTANGENT3SVEXTPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:5352
PFNGLBINORMAL3BEXTPROC = CFUNCTYPE(None, GLbyte, GLbyte, GLbyte) 	# GL/glext.h:5353
PFNGLBINORMAL3BVEXTPROC = CFUNCTYPE(None, POINTER(GLbyte)) 	# GL/glext.h:5354
PFNGLBINORMAL3DEXTPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:5355
PFNGLBINORMAL3DVEXTPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:5356
PFNGLBINORMAL3FEXTPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5357
PFNGLBINORMAL3FVEXTPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:5358
PFNGLBINORMAL3IEXTPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:5359
PFNGLBINORMAL3IVEXTPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:5360
PFNGLBINORMAL3SEXTPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort) 	# GL/glext.h:5361
PFNGLBINORMAL3SVEXTPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:5362
PFNGLTANGENTPOINTEREXTPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:5363
PFNGLBINORMALPOINTEREXTPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:5364
# EXT_texture_env_combine (GL/glext.h:5367)
GL_EXT_texture_env_combine = 1 	# GL/glext.h:5368
# APPLE_specular_vector (GL/glext.h:5371)
GL_APPLE_specular_vector = 1 	# GL/glext.h:5372
# APPLE_transform_hint (GL/glext.h:5375)
GL_APPLE_transform_hint = 1 	# GL/glext.h:5376
# SGIX_fog_scale (GL/glext.h:5379)
GL_SGIX_fog_scale = 1 	# GL/glext.h:5380
# SUNX_constant_data (GL/glext.h:5383)
GL_SUNX_constant_data = 1 	# GL/glext.h:5384
# GL/glext.h:5386
glFinishTextureSUNX = _link_function('glFinishTextureSUNX', None, [], 'SUNX_constant_data')

PFNGLFINISHTEXTURESUNXPROC = CFUNCTYPE(None) 	# GL/glext.h:5388
# SUN_global_alpha (GL/glext.h:5391)
GL_SUN_global_alpha = 1 	# GL/glext.h:5392
# GL/glext.h:5394
glGlobalAlphaFactorbSUN = _link_function('glGlobalAlphaFactorbSUN', None, [GLbyte], 'SUN_global_alpha')

# GL/glext.h:5395
glGlobalAlphaFactorsSUN = _link_function('glGlobalAlphaFactorsSUN', None, [GLshort], 'SUN_global_alpha')

# GL/glext.h:5396
glGlobalAlphaFactoriSUN = _link_function('glGlobalAlphaFactoriSUN', None, [GLint], 'SUN_global_alpha')

# GL/glext.h:5397
glGlobalAlphaFactorfSUN = _link_function('glGlobalAlphaFactorfSUN', None, [GLfloat], 'SUN_global_alpha')

# GL/glext.h:5398
glGlobalAlphaFactordSUN = _link_function('glGlobalAlphaFactordSUN', None, [GLdouble], 'SUN_global_alpha')

# GL/glext.h:5399
glGlobalAlphaFactorubSUN = _link_function('glGlobalAlphaFactorubSUN', None, [GLubyte], 'SUN_global_alpha')

# GL/glext.h:5400
glGlobalAlphaFactorusSUN = _link_function('glGlobalAlphaFactorusSUN', None, [GLushort], 'SUN_global_alpha')

# GL/glext.h:5401
glGlobalAlphaFactoruiSUN = _link_function('glGlobalAlphaFactoruiSUN', None, [GLuint], 'SUN_global_alpha')

PFNGLGLOBALALPHAFACTORBSUNPROC = CFUNCTYPE(None, GLbyte) 	# GL/glext.h:5403
PFNGLGLOBALALPHAFACTORSSUNPROC = CFUNCTYPE(None, GLshort) 	# GL/glext.h:5404
PFNGLGLOBALALPHAFACTORISUNPROC = CFUNCTYPE(None, GLint) 	# GL/glext.h:5405
PFNGLGLOBALALPHAFACTORFSUNPROC = CFUNCTYPE(None, GLfloat) 	# GL/glext.h:5406
PFNGLGLOBALALPHAFACTORDSUNPROC = CFUNCTYPE(None, GLdouble) 	# GL/glext.h:5407
PFNGLGLOBALALPHAFACTORUBSUNPROC = CFUNCTYPE(None, GLubyte) 	# GL/glext.h:5408
PFNGLGLOBALALPHAFACTORUSSUNPROC = CFUNCTYPE(None, GLushort) 	# GL/glext.h:5409
PFNGLGLOBALALPHAFACTORUISUNPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5410
# SUN_triangle_list (GL/glext.h:5413)
GL_SUN_triangle_list = 1 	# GL/glext.h:5414
# GL/glext.h:5416
glReplacementCodeuiSUN = _link_function('glReplacementCodeuiSUN', None, [GLuint], 'SUN_triangle_list')

# GL/glext.h:5417
glReplacementCodeusSUN = _link_function('glReplacementCodeusSUN', None, [GLushort], 'SUN_triangle_list')

# GL/glext.h:5418
glReplacementCodeubSUN = _link_function('glReplacementCodeubSUN', None, [GLubyte], 'SUN_triangle_list')

# GL/glext.h:5419
glReplacementCodeuivSUN = _link_function('glReplacementCodeuivSUN', None, [POINTER(GLuint)], 'SUN_triangle_list')

# GL/glext.h:5420
glReplacementCodeusvSUN = _link_function('glReplacementCodeusvSUN', None, [POINTER(GLushort)], 'SUN_triangle_list')

# GL/glext.h:5421
glReplacementCodeubvSUN = _link_function('glReplacementCodeubvSUN', None, [POINTER(GLubyte)], 'SUN_triangle_list')

# GL/glext.h:5422
glReplacementCodePointerSUN = _link_function('glReplacementCodePointerSUN', None, [GLenum, GLsizei, POINTER(POINTER(GLvoid))], 'SUN_triangle_list')

PFNGLREPLACEMENTCODEUISUNPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5424
PFNGLREPLACEMENTCODEUSSUNPROC = CFUNCTYPE(None, GLushort) 	# GL/glext.h:5425
PFNGLREPLACEMENTCODEUBSUNPROC = CFUNCTYPE(None, GLubyte) 	# GL/glext.h:5426
PFNGLREPLACEMENTCODEUIVSUNPROC = CFUNCTYPE(None, POINTER(GLuint)) 	# GL/glext.h:5427
PFNGLREPLACEMENTCODEUSVSUNPROC = CFUNCTYPE(None, POINTER(GLushort)) 	# GL/glext.h:5428
PFNGLREPLACEMENTCODEUBVSUNPROC = CFUNCTYPE(None, POINTER(GLubyte)) 	# GL/glext.h:5429
PFNGLREPLACEMENTCODEPOINTERSUNPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(POINTER(GLvoid))) 	# GL/glext.h:5430
# SUN_vertex (GL/glext.h:5433)
GL_SUN_vertex = 1 	# GL/glext.h:5434
# GL/glext.h:5436
glColor4ubVertex2fSUN = _link_function('glColor4ubVertex2fSUN', None, [GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5437
glColor4ubVertex2fvSUN = _link_function('glColor4ubVertex2fvSUN', None, [POINTER(GLubyte), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5438
glColor4ubVertex3fSUN = _link_function('glColor4ubVertex3fSUN', None, [GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5439
glColor4ubVertex3fvSUN = _link_function('glColor4ubVertex3fvSUN', None, [POINTER(GLubyte), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5440
glColor3fVertex3fSUN = _link_function('glColor3fVertex3fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5441
glColor3fVertex3fvSUN = _link_function('glColor3fVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5442
glNormal3fVertex3fSUN = _link_function('glNormal3fVertex3fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5443
glNormal3fVertex3fvSUN = _link_function('glNormal3fVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5444
glColor4fNormal3fVertex3fSUN = _link_function('glColor4fNormal3fVertex3fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5445
glColor4fNormal3fVertex3fvSUN = _link_function('glColor4fNormal3fVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5446
glTexCoord2fVertex3fSUN = _link_function('glTexCoord2fVertex3fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5447
glTexCoord2fVertex3fvSUN = _link_function('glTexCoord2fVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5448
glTexCoord4fVertex4fSUN = _link_function('glTexCoord4fVertex4fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5449
glTexCoord4fVertex4fvSUN = _link_function('glTexCoord4fVertex4fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5450
glTexCoord2fColor4ubVertex3fSUN = _link_function('glTexCoord2fColor4ubVertex3fSUN', None, [GLfloat, GLfloat, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5451
glTexCoord2fColor4ubVertex3fvSUN = _link_function('glTexCoord2fColor4ubVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLubyte), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5452
glTexCoord2fColor3fVertex3fSUN = _link_function('glTexCoord2fColor3fVertex3fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5453
glTexCoord2fColor3fVertex3fvSUN = _link_function('glTexCoord2fColor3fVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5454
glTexCoord2fNormal3fVertex3fSUN = _link_function('glTexCoord2fNormal3fVertex3fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5455
glTexCoord2fNormal3fVertex3fvSUN = _link_function('glTexCoord2fNormal3fVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5456
glTexCoord2fColor4fNormal3fVertex3fSUN = _link_function('glTexCoord2fColor4fNormal3fVertex3fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5457
glTexCoord2fColor4fNormal3fVertex3fvSUN = _link_function('glTexCoord2fColor4fNormal3fVertex3fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5458
glTexCoord4fColor4fNormal3fVertex4fSUN = _link_function('glTexCoord4fColor4fNormal3fVertex4fSUN', None, [GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5459
glTexCoord4fColor4fNormal3fVertex4fvSUN = _link_function('glTexCoord4fColor4fNormal3fVertex4fvSUN', None, [POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5460
glReplacementCodeuiVertex3fSUN = _link_function('glReplacementCodeuiVertex3fSUN', None, [GLuint, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5461
glReplacementCodeuiVertex3fvSUN = _link_function('glReplacementCodeuiVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5462
glReplacementCodeuiColor4ubVertex3fSUN = _link_function('glReplacementCodeuiColor4ubVertex3fSUN', None, [GLuint, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5463
glReplacementCodeuiColor4ubVertex3fvSUN = _link_function('glReplacementCodeuiColor4ubVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLubyte), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5464
glReplacementCodeuiColor3fVertex3fSUN = _link_function('glReplacementCodeuiColor3fVertex3fSUN', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5465
glReplacementCodeuiColor3fVertex3fvSUN = _link_function('glReplacementCodeuiColor3fVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5466
glReplacementCodeuiNormal3fVertex3fSUN = _link_function('glReplacementCodeuiNormal3fVertex3fSUN', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5467
glReplacementCodeuiNormal3fVertex3fvSUN = _link_function('glReplacementCodeuiNormal3fVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5468
glReplacementCodeuiColor4fNormal3fVertex3fSUN = _link_function('glReplacementCodeuiColor4fNormal3fVertex3fSUN', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5469
glReplacementCodeuiColor4fNormal3fVertex3fvSUN = _link_function('glReplacementCodeuiColor4fNormal3fVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5470
glReplacementCodeuiTexCoord2fVertex3fSUN = _link_function('glReplacementCodeuiTexCoord2fVertex3fSUN', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5471
glReplacementCodeuiTexCoord2fVertex3fvSUN = _link_function('glReplacementCodeuiTexCoord2fVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5472
glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = _link_function('glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5473
glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = _link_function('glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

# GL/glext.h:5474
glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = _link_function('glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat], 'SUN_vertex')

# GL/glext.h:5475
glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = _link_function('glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN', None, [POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)], 'SUN_vertex')

PFNGLCOLOR4UBVERTEX2FSUNPROC = CFUNCTYPE(None, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat) 	# GL/glext.h:5477
PFNGLCOLOR4UBVERTEX2FVSUNPROC = CFUNCTYPE(None, POINTER(GLubyte), POINTER(GLfloat)) 	# GL/glext.h:5478
PFNGLCOLOR4UBVERTEX3FSUNPROC = CFUNCTYPE(None, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5479
PFNGLCOLOR4UBVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLubyte), POINTER(GLfloat)) 	# GL/glext.h:5480
PFNGLCOLOR3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5481
PFNGLCOLOR3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5482
PFNGLNORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5483
PFNGLNORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5484
PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5485
PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5486
PFNGLTEXCOORD2FVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5487
PFNGLTEXCOORD2FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5488
PFNGLTEXCOORD4FVERTEX4FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5489
PFNGLTEXCOORD4FVERTEX4FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5490
PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5491
PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLubyte), POINTER(GLfloat)) 	# GL/glext.h:5492
PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5493
PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5494
PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5495
PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5496
PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5497
PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5498
PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5499
PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC = CFUNCTYPE(None, POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5500
PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5501
PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLfloat)) 	# GL/glext.h:5502
PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5503
PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLubyte), POINTER(GLfloat)) 	# GL/glext.h:5504
PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5505
PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5506
PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5507
PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5508
PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5509
PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5510
PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5511
PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5512
PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5513
PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5514
PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5515
PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC = CFUNCTYPE(None, POINTER(GLuint), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLfloat)) 	# GL/glext.h:5516
# EXT_blend_func_separate (GL/glext.h:5519)
GL_EXT_blend_func_separate = 1 	# GL/glext.h:5520
# GL/glext.h:5522
glBlendFuncSeparateEXT = _link_function('glBlendFuncSeparateEXT', None, [GLenum, GLenum, GLenum, GLenum], 'EXT_blend_func_separate')

PFNGLBLENDFUNCSEPARATEEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:5524
# INGR_blend_func_separate (GL/glext.h:5527)
GL_INGR_blend_func_separate = 1 	# GL/glext.h:5528
# GL/glext.h:5530
glBlendFuncSeparateINGR = _link_function('glBlendFuncSeparateINGR', None, [GLenum, GLenum, GLenum, GLenum], 'INGR_blend_func_separate')

PFNGLBLENDFUNCSEPARATEINGRPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:5532
# INGR_color_clamp (GL/glext.h:5535)
GL_INGR_color_clamp = 1 	# GL/glext.h:5536
# INGR_interlace_read (GL/glext.h:5539)
GL_INGR_interlace_read = 1 	# GL/glext.h:5540
# EXT_stencil_wrap (GL/glext.h:5543)
GL_EXT_stencil_wrap = 1 	# GL/glext.h:5544
# EXT_422_pixels (GL/glext.h:5547)
GL_EXT_422_pixels = 1 	# GL/glext.h:5548
# NV_texgen_reflection (GL/glext.h:5551)
GL_NV_texgen_reflection = 1 	# GL/glext.h:5552
# SUN_convolution_border_modes (GL/glext.h:5555)
GL_SUN_convolution_border_modes = 1 	# GL/glext.h:5556
# EXT_texture_env_add (GL/glext.h:5559)
GL_EXT_texture_env_add = 1 	# GL/glext.h:5560
# EXT_texture_lod_bias (GL/glext.h:5563)
GL_EXT_texture_lod_bias = 1 	# GL/glext.h:5564
# EXT_texture_filter_anisotropic (GL/glext.h:5567)
GL_EXT_texture_filter_anisotropic = 1 	# GL/glext.h:5568
# EXT_vertex_weighting (GL/glext.h:5571)
GL_EXT_vertex_weighting = 1 	# GL/glext.h:5572
# GL/glext.h:5574
glVertexWeightfEXT = _link_function('glVertexWeightfEXT', None, [GLfloat], 'EXT_vertex_weighting')

# GL/glext.h:5575
glVertexWeightfvEXT = _link_function('glVertexWeightfvEXT', None, [POINTER(GLfloat)], 'EXT_vertex_weighting')

# GL/glext.h:5576
glVertexWeightPointerEXT = _link_function('glVertexWeightPointerEXT', None, [GLsizei, GLenum, GLsizei, POINTER(GLvoid)], 'EXT_vertex_weighting')

PFNGLVERTEXWEIGHTFEXTPROC = CFUNCTYPE(None, GLfloat) 	# GL/glext.h:5578
PFNGLVERTEXWEIGHTFVEXTPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:5579
PFNGLVERTEXWEIGHTPOINTEREXTPROC = CFUNCTYPE(None, GLsizei, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:5580
# NV_light_max_exponent (GL/glext.h:5583)
GL_NV_light_max_exponent = 1 	# GL/glext.h:5584
# NV_vertex_array_range (GL/glext.h:5587)
GL_NV_vertex_array_range = 1 	# GL/glext.h:5588
# GL/glext.h:5590
glFlushVertexArrayRangeNV = _link_function('glFlushVertexArrayRangeNV', None, [], 'NV_vertex_array_range')

# GL/glext.h:5591
glVertexArrayRangeNV = _link_function('glVertexArrayRangeNV', None, [GLsizei, POINTER(GLvoid)], 'NV_vertex_array_range')

PFNGLFLUSHVERTEXARRAYRANGENVPROC = CFUNCTYPE(None) 	# GL/glext.h:5593
PFNGLVERTEXARRAYRANGENVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:5594
# NV_register_combiners (GL/glext.h:5597)
GL_NV_register_combiners = 1 	# GL/glext.h:5598
# GL/glext.h:5600
glCombinerParameterfvNV = _link_function('glCombinerParameterfvNV', None, [GLenum, POINTER(GLfloat)], 'NV_register_combiners')

# GL/glext.h:5601
glCombinerParameterfNV = _link_function('glCombinerParameterfNV', None, [GLenum, GLfloat], 'NV_register_combiners')

# GL/glext.h:5602
glCombinerParameterivNV = _link_function('glCombinerParameterivNV', None, [GLenum, POINTER(GLint)], 'NV_register_combiners')

# GL/glext.h:5603
glCombinerParameteriNV = _link_function('glCombinerParameteriNV', None, [GLenum, GLint], 'NV_register_combiners')

# GL/glext.h:5604
glCombinerInputNV = _link_function('glCombinerInputNV', None, [GLenum, GLenum, GLenum, GLenum, GLenum, GLenum], 'NV_register_combiners')

# GL/glext.h:5605
glCombinerOutputNV = _link_function('glCombinerOutputNV', None, [GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLboolean, GLboolean, GLboolean], 'NV_register_combiners')

# GL/glext.h:5606
glFinalCombinerInputNV = _link_function('glFinalCombinerInputNV', None, [GLenum, GLenum, GLenum, GLenum], 'NV_register_combiners')

# GL/glext.h:5607
glGetCombinerInputParameterfvNV = _link_function('glGetCombinerInputParameterfvNV', None, [GLenum, GLenum, GLenum, GLenum, POINTER(GLfloat)], 'NV_register_combiners')

# GL/glext.h:5608
glGetCombinerInputParameterivNV = _link_function('glGetCombinerInputParameterivNV', None, [GLenum, GLenum, GLenum, GLenum, POINTER(GLint)], 'NV_register_combiners')

# GL/glext.h:5609
glGetCombinerOutputParameterfvNV = _link_function('glGetCombinerOutputParameterfvNV', None, [GLenum, GLenum, GLenum, POINTER(GLfloat)], 'NV_register_combiners')

# GL/glext.h:5610
glGetCombinerOutputParameterivNV = _link_function('glGetCombinerOutputParameterivNV', None, [GLenum, GLenum, GLenum, POINTER(GLint)], 'NV_register_combiners')

# GL/glext.h:5611
glGetFinalCombinerInputParameterfvNV = _link_function('glGetFinalCombinerInputParameterfvNV', None, [GLenum, GLenum, POINTER(GLfloat)], 'NV_register_combiners')

# GL/glext.h:5612
glGetFinalCombinerInputParameterivNV = _link_function('glGetFinalCombinerInputParameterivNV', None, [GLenum, GLenum, POINTER(GLint)], 'NV_register_combiners')

PFNGLCOMBINERPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5614
PFNGLCOMBINERPARAMETERFNVPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:5615
PFNGLCOMBINERPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:5616
PFNGLCOMBINERPARAMETERINVPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:5617
PFNGLCOMBINERINPUTNVPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:5618
PFNGLCOMBINEROUTPUTNVPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLboolean, GLboolean, GLboolean) 	# GL/glext.h:5619
PFNGLFINALCOMBINERINPUTNVPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:5620
PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5621
PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5622
PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5623
PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5624
PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5625
PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5626
# NV_fog_distance (GL/glext.h:5629)
GL_NV_fog_distance = 1 	# GL/glext.h:5630
# NV_texgen_emboss (GL/glext.h:5633)
GL_NV_texgen_emboss = 1 	# GL/glext.h:5634
# NV_blend_square (GL/glext.h:5637)
GL_NV_blend_square = 1 	# GL/glext.h:5638
# NV_texture_env_combine4 (GL/glext.h:5641)
GL_NV_texture_env_combine4 = 1 	# GL/glext.h:5642
# MESA_resize_buffers (GL/glext.h:5645)
GL_MESA_resize_buffers = 1 	# GL/glext.h:5646
# GL/glext.h:5648
glResizeBuffersMESA = _link_function('glResizeBuffersMESA', None, [], 'MESA_resize_buffers')

PFNGLRESIZEBUFFERSMESAPROC = CFUNCTYPE(None) 	# GL/glext.h:5650
# MESA_window_pos (GL/glext.h:5653)
GL_MESA_window_pos = 1 	# GL/glext.h:5654
# GL/glext.h:5656
glWindowPos2dMESA = _link_function('glWindowPos2dMESA', None, [GLdouble, GLdouble], 'MESA_window_pos')

# GL/glext.h:5657
glWindowPos2dvMESA = _link_function('glWindowPos2dvMESA', None, [POINTER(GLdouble)], 'MESA_window_pos')

# GL/glext.h:5658
glWindowPos2fMESA = _link_function('glWindowPos2fMESA', None, [GLfloat, GLfloat], 'MESA_window_pos')

# GL/glext.h:5659
glWindowPos2fvMESA = _link_function('glWindowPos2fvMESA', None, [POINTER(GLfloat)], 'MESA_window_pos')

# GL/glext.h:5660
glWindowPos2iMESA = _link_function('glWindowPos2iMESA', None, [GLint, GLint], 'MESA_window_pos')

# GL/glext.h:5661
glWindowPos2ivMESA = _link_function('glWindowPos2ivMESA', None, [POINTER(GLint)], 'MESA_window_pos')

# GL/glext.h:5662
glWindowPos2sMESA = _link_function('glWindowPos2sMESA', None, [GLshort, GLshort], 'MESA_window_pos')

# GL/glext.h:5663
glWindowPos2svMESA = _link_function('glWindowPos2svMESA', None, [POINTER(GLshort)], 'MESA_window_pos')

# GL/glext.h:5664
glWindowPos3dMESA = _link_function('glWindowPos3dMESA', None, [GLdouble, GLdouble, GLdouble], 'MESA_window_pos')

# GL/glext.h:5665
glWindowPos3dvMESA = _link_function('glWindowPos3dvMESA', None, [POINTER(GLdouble)], 'MESA_window_pos')

# GL/glext.h:5666
glWindowPos3fMESA = _link_function('glWindowPos3fMESA', None, [GLfloat, GLfloat, GLfloat], 'MESA_window_pos')

# GL/glext.h:5667
glWindowPos3fvMESA = _link_function('glWindowPos3fvMESA', None, [POINTER(GLfloat)], 'MESA_window_pos')

# GL/glext.h:5668
glWindowPos3iMESA = _link_function('glWindowPos3iMESA', None, [GLint, GLint, GLint], 'MESA_window_pos')

# GL/glext.h:5669
glWindowPos3ivMESA = _link_function('glWindowPos3ivMESA', None, [POINTER(GLint)], 'MESA_window_pos')

# GL/glext.h:5670
glWindowPos3sMESA = _link_function('glWindowPos3sMESA', None, [GLshort, GLshort, GLshort], 'MESA_window_pos')

# GL/glext.h:5671
glWindowPos3svMESA = _link_function('glWindowPos3svMESA', None, [POINTER(GLshort)], 'MESA_window_pos')

# GL/glext.h:5672
glWindowPos4dMESA = _link_function('glWindowPos4dMESA', None, [GLdouble, GLdouble, GLdouble, GLdouble], 'MESA_window_pos')

# GL/glext.h:5673
glWindowPos4dvMESA = _link_function('glWindowPos4dvMESA', None, [POINTER(GLdouble)], 'MESA_window_pos')

# GL/glext.h:5674
glWindowPos4fMESA = _link_function('glWindowPos4fMESA', None, [GLfloat, GLfloat, GLfloat, GLfloat], 'MESA_window_pos')

# GL/glext.h:5675
glWindowPos4fvMESA = _link_function('glWindowPos4fvMESA', None, [POINTER(GLfloat)], 'MESA_window_pos')

# GL/glext.h:5676
glWindowPos4iMESA = _link_function('glWindowPos4iMESA', None, [GLint, GLint, GLint, GLint], 'MESA_window_pos')

# GL/glext.h:5677
glWindowPos4ivMESA = _link_function('glWindowPos4ivMESA', None, [POINTER(GLint)], 'MESA_window_pos')

# GL/glext.h:5678
glWindowPos4sMESA = _link_function('glWindowPos4sMESA', None, [GLshort, GLshort, GLshort, GLshort], 'MESA_window_pos')

# GL/glext.h:5679
glWindowPos4svMESA = _link_function('glWindowPos4svMESA', None, [POINTER(GLshort)], 'MESA_window_pos')

PFNGLWINDOWPOS2DMESAPROC = CFUNCTYPE(None, GLdouble, GLdouble) 	# GL/glext.h:5681
PFNGLWINDOWPOS2DVMESAPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:5682
PFNGLWINDOWPOS2FMESAPROC = CFUNCTYPE(None, GLfloat, GLfloat) 	# GL/glext.h:5683
PFNGLWINDOWPOS2FVMESAPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:5684
PFNGLWINDOWPOS2IMESAPROC = CFUNCTYPE(None, GLint, GLint) 	# GL/glext.h:5685
PFNGLWINDOWPOS2IVMESAPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:5686
PFNGLWINDOWPOS2SMESAPROC = CFUNCTYPE(None, GLshort, GLshort) 	# GL/glext.h:5687
PFNGLWINDOWPOS2SVMESAPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:5688
PFNGLWINDOWPOS3DMESAPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:5689
PFNGLWINDOWPOS3DVMESAPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:5690
PFNGLWINDOWPOS3FMESAPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5691
PFNGLWINDOWPOS3FVMESAPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:5692
PFNGLWINDOWPOS3IMESAPROC = CFUNCTYPE(None, GLint, GLint, GLint) 	# GL/glext.h:5693
PFNGLWINDOWPOS3IVMESAPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:5694
PFNGLWINDOWPOS3SMESAPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort) 	# GL/glext.h:5695
PFNGLWINDOWPOS3SVMESAPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:5696
PFNGLWINDOWPOS4DMESAPROC = CFUNCTYPE(None, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:5697
PFNGLWINDOWPOS4DVMESAPROC = CFUNCTYPE(None, POINTER(GLdouble)) 	# GL/glext.h:5698
PFNGLWINDOWPOS4FMESAPROC = CFUNCTYPE(None, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5699
PFNGLWINDOWPOS4FVMESAPROC = CFUNCTYPE(None, POINTER(GLfloat)) 	# GL/glext.h:5700
PFNGLWINDOWPOS4IMESAPROC = CFUNCTYPE(None, GLint, GLint, GLint, GLint) 	# GL/glext.h:5701
PFNGLWINDOWPOS4IVMESAPROC = CFUNCTYPE(None, POINTER(GLint)) 	# GL/glext.h:5702
PFNGLWINDOWPOS4SMESAPROC = CFUNCTYPE(None, GLshort, GLshort, GLshort, GLshort) 	# GL/glext.h:5703
PFNGLWINDOWPOS4SVMESAPROC = CFUNCTYPE(None, POINTER(GLshort)) 	# GL/glext.h:5704
# EXT_texture_compression_s3tc (GL/glext.h:5707)
GL_EXT_texture_compression_s3tc = 1 	# GL/glext.h:5708
# IBM_cull_vertex (GL/glext.h:5711)
GL_IBM_cull_vertex = 1 	# GL/glext.h:5712
# IBM_multimode_draw_arrays (GL/glext.h:5715)
GL_IBM_multimode_draw_arrays = 1 	# GL/glext.h:5716
# GL/glext.h:5718
glMultiModeDrawArraysIBM = _link_function('glMultiModeDrawArraysIBM', None, [POINTER(GLenum), POINTER(GLint), POINTER(GLsizei), GLsizei, GLint], 'IBM_multimode_draw_arrays')

# GL/glext.h:5719
glMultiModeDrawElementsIBM = _link_function('glMultiModeDrawElementsIBM', None, [POINTER(GLenum), POINTER(GLsizei), GLenum, POINTER(POINTER(GLvoid)), GLsizei, GLint], 'IBM_multimode_draw_arrays')

PFNGLMULTIMODEDRAWARRAYSIBMPROC = CFUNCTYPE(None, POINTER(GLenum), POINTER(GLint), POINTER(GLsizei), GLsizei, GLint) 	# GL/glext.h:5721
PFNGLMULTIMODEDRAWELEMENTSIBMPROC = CFUNCTYPE(None, POINTER(GLenum), POINTER(GLsizei), GLenum, POINTER(POINTER(GLvoid)), GLsizei, GLint) 	# GL/glext.h:5722
# IBM_vertex_array_lists (GL/glext.h:5725)
GL_IBM_vertex_array_lists = 1 	# GL/glext.h:5726
# GL/glext.h:5728
glColorPointerListIBM = _link_function('glColorPointerListIBM', None, [GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint], 'IBM_vertex_array_lists')

# GL/glext.h:5729
glSecondaryColorPointerListIBM = _link_function('glSecondaryColorPointerListIBM', None, [GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint], 'IBM_vertex_array_lists')

# GL/glext.h:5730
glEdgeFlagPointerListIBM = _link_function('glEdgeFlagPointerListIBM', None, [GLint, POINTER(POINTER(GLboolean)), GLint], 'IBM_vertex_array_lists')

# GL/glext.h:5731
glFogCoordPointerListIBM = _link_function('glFogCoordPointerListIBM', None, [GLenum, GLint, POINTER(POINTER(GLvoid)), GLint], 'IBM_vertex_array_lists')

# GL/glext.h:5732
glIndexPointerListIBM = _link_function('glIndexPointerListIBM', None, [GLenum, GLint, POINTER(POINTER(GLvoid)), GLint], 'IBM_vertex_array_lists')

# GL/glext.h:5733
glNormalPointerListIBM = _link_function('glNormalPointerListIBM', None, [GLenum, GLint, POINTER(POINTER(GLvoid)), GLint], 'IBM_vertex_array_lists')

# GL/glext.h:5734
glTexCoordPointerListIBM = _link_function('glTexCoordPointerListIBM', None, [GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint], 'IBM_vertex_array_lists')

# GL/glext.h:5735
glVertexPointerListIBM = _link_function('glVertexPointerListIBM', None, [GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint], 'IBM_vertex_array_lists')

PFNGLCOLORPOINTERLISTIBMPROC = CFUNCTYPE(None, GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint) 	# GL/glext.h:5737
PFNGLSECONDARYCOLORPOINTERLISTIBMPROC = CFUNCTYPE(None, GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint) 	# GL/glext.h:5738
PFNGLEDGEFLAGPOINTERLISTIBMPROC = CFUNCTYPE(None, GLint, POINTER(POINTER(GLboolean)), GLint) 	# GL/glext.h:5739
PFNGLFOGCOORDPOINTERLISTIBMPROC = CFUNCTYPE(None, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint) 	# GL/glext.h:5740
PFNGLINDEXPOINTERLISTIBMPROC = CFUNCTYPE(None, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint) 	# GL/glext.h:5741
PFNGLNORMALPOINTERLISTIBMPROC = CFUNCTYPE(None, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint) 	# GL/glext.h:5742
PFNGLTEXCOORDPOINTERLISTIBMPROC = CFUNCTYPE(None, GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint) 	# GL/glext.h:5743
PFNGLVERTEXPOINTERLISTIBMPROC = CFUNCTYPE(None, GLint, GLenum, GLint, POINTER(POINTER(GLvoid)), GLint) 	# GL/glext.h:5744
# SGIX_subsample (GL/glext.h:5747)
GL_SGIX_subsample = 1 	# GL/glext.h:5748
# SGIX_ycrcba (GL/glext.h:5751)
GL_SGIX_ycrcba = 1 	# GL/glext.h:5752
# SGIX_ycrcb_subsample (GL/glext.h:5755)
GL_SGIX_ycrcb_subsample = 1 	# GL/glext.h:5756
# SGIX_depth_pass_instrument (GL/glext.h:5759)
GL_SGIX_depth_pass_instrument = 1 	# GL/glext.h:5760
# 3DFX_texture_compression_FXT1 (GL/glext.h:5763)
GL_3DFX_texture_compression_FXT1 = 1 	# GL/glext.h:5764
# 3DFX_multisample (GL/glext.h:5767)
GL_3DFX_multisample = 1 	# GL/glext.h:5768
# 3DFX_tbuffer (GL/glext.h:5771)
GL_3DFX_tbuffer = 1 	# GL/glext.h:5772
# GL/glext.h:5774
glTbufferMask3DFX = _link_function('glTbufferMask3DFX', None, [GLuint], '3DFX_tbuffer')

PFNGLTBUFFERMASK3DFXPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5776
# EXT_multisample (GL/glext.h:5779)
GL_EXT_multisample = 1 	# GL/glext.h:5780
# GL/glext.h:5782
glSampleMaskEXT = _link_function('glSampleMaskEXT', None, [GLclampf, GLboolean], 'EXT_multisample')

# GL/glext.h:5783
glSamplePatternEXT = _link_function('glSamplePatternEXT', None, [GLenum], 'EXT_multisample')

PFNGLSAMPLEMASKEXTPROC = CFUNCTYPE(None, GLclampf, GLboolean) 	# GL/glext.h:5785
PFNGLSAMPLEPATTERNEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:5786
# SGIX_vertex_preclip (GL/glext.h:5789)
GL_SGIX_vertex_preclip = 1 	# GL/glext.h:5790
# SGIX_convolution_accuracy (GL/glext.h:5793)
GL_SGIX_convolution_accuracy = 1 	# GL/glext.h:5794
# SGIX_resample (GL/glext.h:5797)
GL_SGIX_resample = 1 	# GL/glext.h:5798
# SGIS_point_line_texgen (GL/glext.h:5801)
GL_SGIS_point_line_texgen = 1 	# GL/glext.h:5802
# SGIS_texture_color_mask (GL/glext.h:5805)
GL_SGIS_texture_color_mask = 1 	# GL/glext.h:5806
# GL/glext.h:5808
glTextureColorMaskSGIS = _link_function('glTextureColorMaskSGIS', None, [GLboolean, GLboolean, GLboolean, GLboolean], 'SGIS_texture_color_mask')

PFNGLTEXTURECOLORMASKSGISPROC = CFUNCTYPE(None, GLboolean, GLboolean, GLboolean, GLboolean) 	# GL/glext.h:5810
# SGIX_igloo_interface (GL/glext.h:5813)
GL_SGIX_igloo_interface = 1 	# GL/glext.h:5814
# GL/glext.h:5816
glIglooInterfaceSGIX = _link_function('glIglooInterfaceSGIX', None, [GLenum, POINTER(GLvoid)], 'SGIX_igloo_interface')

PFNGLIGLOOINTERFACESGIXPROC = CFUNCTYPE(None, GLenum, POINTER(GLvoid)) 	# GL/glext.h:5818
# EXT_texture_env_dot3 (GL/glext.h:5821)
GL_EXT_texture_env_dot3 = 1 	# GL/glext.h:5822
# ATI_texture_mirror_once (GL/glext.h:5825)
GL_ATI_texture_mirror_once = 1 	# GL/glext.h:5826
# NV_fence (GL/glext.h:5829)
GL_NV_fence = 1 	# GL/glext.h:5830
# GL/glext.h:5832
glDeleteFencesNV = _link_function('glDeleteFencesNV', None, [GLsizei, POINTER(GLuint)], 'NV_fence')

# GL/glext.h:5833
glGenFencesNV = _link_function('glGenFencesNV', None, [GLsizei, POINTER(GLuint)], 'NV_fence')

# GL/glext.h:5834
glIsFenceNV = _link_function('glIsFenceNV', GLboolean, [GLuint], 'NV_fence')

# GL/glext.h:5835
glTestFenceNV = _link_function('glTestFenceNV', GLboolean, [GLuint], 'NV_fence')

# GL/glext.h:5836
glGetFenceivNV = _link_function('glGetFenceivNV', None, [GLuint, GLenum, POINTER(GLint)], 'NV_fence')

# GL/glext.h:5837
glFinishFenceNV = _link_function('glFinishFenceNV', None, [GLuint], 'NV_fence')

# GL/glext.h:5838
glSetFenceNV = _link_function('glSetFenceNV', None, [GLuint, GLenum], 'NV_fence')

PFNGLDELETEFENCESNVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:5840
PFNGLGENFENCESNVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:5841
PFNGLISFENCENVPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:5842
PFNGLTESTFENCENVPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:5843
PFNGLGETFENCEIVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5844
PFNGLFINISHFENCENVPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:5845
PFNGLSETFENCENVPROC = CFUNCTYPE(None, GLuint, GLenum) 	# GL/glext.h:5846
# NV_evaluators (GL/glext.h:5849)
GL_NV_evaluators = 1 	# GL/glext.h:5850
# GL/glext.h:5852
glMapControlPointsNV = _link_function('glMapControlPointsNV', None, [GLenum, GLuint, GLenum, GLsizei, GLsizei, GLint, GLint, GLboolean, POINTER(GLvoid)], 'NV_evaluators')

# GL/glext.h:5853
glMapParameterivNV = _link_function('glMapParameterivNV', None, [GLenum, GLenum, POINTER(GLint)], 'NV_evaluators')

# GL/glext.h:5854
glMapParameterfvNV = _link_function('glMapParameterfvNV', None, [GLenum, GLenum, POINTER(GLfloat)], 'NV_evaluators')

# GL/glext.h:5855
glGetMapControlPointsNV = _link_function('glGetMapControlPointsNV', None, [GLenum, GLuint, GLenum, GLsizei, GLsizei, GLboolean, POINTER(GLvoid)], 'NV_evaluators')

# GL/glext.h:5856
glGetMapParameterivNV = _link_function('glGetMapParameterivNV', None, [GLenum, GLenum, POINTER(GLint)], 'NV_evaluators')

# GL/glext.h:5857
glGetMapParameterfvNV = _link_function('glGetMapParameterfvNV', None, [GLenum, GLenum, POINTER(GLfloat)], 'NV_evaluators')

# GL/glext.h:5858
glGetMapAttribParameterivNV = _link_function('glGetMapAttribParameterivNV', None, [GLenum, GLuint, GLenum, POINTER(GLint)], 'NV_evaluators')

# GL/glext.h:5859
glGetMapAttribParameterfvNV = _link_function('glGetMapAttribParameterfvNV', None, [GLenum, GLuint, GLenum, POINTER(GLfloat)], 'NV_evaluators')

# GL/glext.h:5860
glEvalMapsNV = _link_function('glEvalMapsNV', None, [GLenum, GLenum], 'NV_evaluators')

PFNGLMAPCONTROLPOINTSNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, GLsizei, GLsizei, GLint, GLint, GLboolean, POINTER(GLvoid)) 	# GL/glext.h:5862
PFNGLMAPPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5863
PFNGLMAPPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5864
PFNGLGETMAPCONTROLPOINTSNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, GLsizei, GLsizei, GLboolean, POINTER(GLvoid)) 	# GL/glext.h:5865
PFNGLGETMAPPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:5866
PFNGLGETMAPPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5867
PFNGLGETMAPATTRIBPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5868
PFNGLGETMAPATTRIBPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5869
PFNGLEVALMAPSNVPROC = CFUNCTYPE(None, GLenum, GLenum) 	# GL/glext.h:5870
# NV_packed_depth_stencil (GL/glext.h:5873)
GL_NV_packed_depth_stencil = 1 	# GL/glext.h:5874
# NV_register_combiners2 (GL/glext.h:5877)
GL_NV_register_combiners2 = 1 	# GL/glext.h:5878
# GL/glext.h:5880
glCombinerStageParameterfvNV = _link_function('glCombinerStageParameterfvNV', None, [GLenum, GLenum, POINTER(GLfloat)], 'NV_register_combiners2')

# GL/glext.h:5881
glGetCombinerStageParameterfvNV = _link_function('glGetCombinerStageParameterfvNV', None, [GLenum, GLenum, POINTER(GLfloat)], 'NV_register_combiners2')

PFNGLCOMBINERSTAGEPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5883
PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5884
# NV_texture_compression_vtc (GL/glext.h:5887)
GL_NV_texture_compression_vtc = 1 	# GL/glext.h:5888
# NV_texture_rectangle (GL/glext.h:5891)
GL_NV_texture_rectangle = 1 	# GL/glext.h:5892
# NV_texture_shader (GL/glext.h:5895)
GL_NV_texture_shader = 1 	# GL/glext.h:5896
# NV_texture_shader2 (GL/glext.h:5899)
GL_NV_texture_shader2 = 1 	# GL/glext.h:5900
# NV_vertex_array_range2 (GL/glext.h:5903)
GL_NV_vertex_array_range2 = 1 	# GL/glext.h:5904
# NV_vertex_program (GL/glext.h:5907)
GL_NV_vertex_program = 1 	# GL/glext.h:5908
# GL/glext.h:5910
glAreProgramsResidentNV = _link_function('glAreProgramsResidentNV', GLboolean, [GLsizei, POINTER(GLuint), POINTER(GLboolean)], 'NV_vertex_program')

# GL/glext.h:5911
glBindProgramNV = _link_function('glBindProgramNV', None, [GLenum, GLuint], 'NV_vertex_program')

# GL/glext.h:5912
glDeleteProgramsNV = _link_function('glDeleteProgramsNV', None, [GLsizei, POINTER(GLuint)], 'NV_vertex_program')

# GL/glext.h:5913
glExecuteProgramNV = _link_function('glExecuteProgramNV', None, [GLenum, GLuint, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5914
glGenProgramsNV = _link_function('glGenProgramsNV', None, [GLsizei, POINTER(GLuint)], 'NV_vertex_program')

# GL/glext.h:5915
glGetProgramParameterdvNV = _link_function('glGetProgramParameterdvNV', None, [GLenum, GLuint, GLenum, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5916
glGetProgramParameterfvNV = _link_function('glGetProgramParameterfvNV', None, [GLenum, GLuint, GLenum, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5917
glGetProgramivNV = _link_function('glGetProgramivNV', None, [GLuint, GLenum, POINTER(GLint)], 'NV_vertex_program')

# GL/glext.h:5918
glGetProgramStringNV = _link_function('glGetProgramStringNV', None, [GLuint, GLenum, POINTER(GLubyte)], 'NV_vertex_program')

# GL/glext.h:5919
glGetTrackMatrixivNV = _link_function('glGetTrackMatrixivNV', None, [GLenum, GLuint, GLenum, POINTER(GLint)], 'NV_vertex_program')

# GL/glext.h:5920
glGetVertexAttribdvNV = _link_function('glGetVertexAttribdvNV', None, [GLuint, GLenum, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5921
glGetVertexAttribfvNV = _link_function('glGetVertexAttribfvNV', None, [GLuint, GLenum, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5922
glGetVertexAttribivNV = _link_function('glGetVertexAttribivNV', None, [GLuint, GLenum, POINTER(GLint)], 'NV_vertex_program')

# GL/glext.h:5923
glGetVertexAttribPointervNV = _link_function('glGetVertexAttribPointervNV', None, [GLuint, GLenum, POINTER(POINTER(GLvoid))], 'NV_vertex_program')

# GL/glext.h:5924
glIsProgramNV = _link_function('glIsProgramNV', GLboolean, [GLuint], 'NV_vertex_program')

# GL/glext.h:5925
glLoadProgramNV = _link_function('glLoadProgramNV', None, [GLenum, GLuint, GLsizei, POINTER(GLubyte)], 'NV_vertex_program')

# GL/glext.h:5926
glProgramParameter4dNV = _link_function('glProgramParameter4dNV', None, [GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble], 'NV_vertex_program')

# GL/glext.h:5927
glProgramParameter4dvNV = _link_function('glProgramParameter4dvNV', None, [GLenum, GLuint, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5928
glProgramParameter4fNV = _link_function('glProgramParameter4fNV', None, [GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat], 'NV_vertex_program')

# GL/glext.h:5929
glProgramParameter4fvNV = _link_function('glProgramParameter4fvNV', None, [GLenum, GLuint, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5930
glProgramParameters4dvNV = _link_function('glProgramParameters4dvNV', None, [GLenum, GLuint, GLuint, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5931
glProgramParameters4fvNV = _link_function('glProgramParameters4fvNV', None, [GLenum, GLuint, GLuint, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5932
glRequestResidentProgramsNV = _link_function('glRequestResidentProgramsNV', None, [GLsizei, POINTER(GLuint)], 'NV_vertex_program')

# GL/glext.h:5933
glTrackMatrixNV = _link_function('glTrackMatrixNV', None, [GLenum, GLuint, GLenum, GLenum], 'NV_vertex_program')

# GL/glext.h:5934
glVertexAttribPointerNV = _link_function('glVertexAttribPointerNV', None, [GLuint, GLint, GLenum, GLsizei, POINTER(GLvoid)], 'NV_vertex_program')

# GL/glext.h:5935
glVertexAttrib1dNV = _link_function('glVertexAttrib1dNV', None, [GLuint, GLdouble], 'NV_vertex_program')

# GL/glext.h:5936
glVertexAttrib1dvNV = _link_function('glVertexAttrib1dvNV', None, [GLuint, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5937
glVertexAttrib1fNV = _link_function('glVertexAttrib1fNV', None, [GLuint, GLfloat], 'NV_vertex_program')

# GL/glext.h:5938
glVertexAttrib1fvNV = _link_function('glVertexAttrib1fvNV', None, [GLuint, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5939
glVertexAttrib1sNV = _link_function('glVertexAttrib1sNV', None, [GLuint, GLshort], 'NV_vertex_program')

# GL/glext.h:5940
glVertexAttrib1svNV = _link_function('glVertexAttrib1svNV', None, [GLuint, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5941
glVertexAttrib2dNV = _link_function('glVertexAttrib2dNV', None, [GLuint, GLdouble, GLdouble], 'NV_vertex_program')

# GL/glext.h:5942
glVertexAttrib2dvNV = _link_function('glVertexAttrib2dvNV', None, [GLuint, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5943
glVertexAttrib2fNV = _link_function('glVertexAttrib2fNV', None, [GLuint, GLfloat, GLfloat], 'NV_vertex_program')

# GL/glext.h:5944
glVertexAttrib2fvNV = _link_function('glVertexAttrib2fvNV', None, [GLuint, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5945
glVertexAttrib2sNV = _link_function('glVertexAttrib2sNV', None, [GLuint, GLshort, GLshort], 'NV_vertex_program')

# GL/glext.h:5946
glVertexAttrib2svNV = _link_function('glVertexAttrib2svNV', None, [GLuint, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5947
glVertexAttrib3dNV = _link_function('glVertexAttrib3dNV', None, [GLuint, GLdouble, GLdouble, GLdouble], 'NV_vertex_program')

# GL/glext.h:5948
glVertexAttrib3dvNV = _link_function('glVertexAttrib3dvNV', None, [GLuint, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5949
glVertexAttrib3fNV = _link_function('glVertexAttrib3fNV', None, [GLuint, GLfloat, GLfloat, GLfloat], 'NV_vertex_program')

# GL/glext.h:5950
glVertexAttrib3fvNV = _link_function('glVertexAttrib3fvNV', None, [GLuint, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5951
glVertexAttrib3sNV = _link_function('glVertexAttrib3sNV', None, [GLuint, GLshort, GLshort, GLshort], 'NV_vertex_program')

# GL/glext.h:5952
glVertexAttrib3svNV = _link_function('glVertexAttrib3svNV', None, [GLuint, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5953
glVertexAttrib4dNV = _link_function('glVertexAttrib4dNV', None, [GLuint, GLdouble, GLdouble, GLdouble, GLdouble], 'NV_vertex_program')

# GL/glext.h:5954
glVertexAttrib4dvNV = _link_function('glVertexAttrib4dvNV', None, [GLuint, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5955
glVertexAttrib4fNV = _link_function('glVertexAttrib4fNV', None, [GLuint, GLfloat, GLfloat, GLfloat, GLfloat], 'NV_vertex_program')

# GL/glext.h:5956
glVertexAttrib4fvNV = _link_function('glVertexAttrib4fvNV', None, [GLuint, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5957
glVertexAttrib4sNV = _link_function('glVertexAttrib4sNV', None, [GLuint, GLshort, GLshort, GLshort, GLshort], 'NV_vertex_program')

# GL/glext.h:5958
glVertexAttrib4svNV = _link_function('glVertexAttrib4svNV', None, [GLuint, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5959
glVertexAttrib4ubNV = _link_function('glVertexAttrib4ubNV', None, [GLuint, GLubyte, GLubyte, GLubyte, GLubyte], 'NV_vertex_program')

# GL/glext.h:5960
glVertexAttrib4ubvNV = _link_function('glVertexAttrib4ubvNV', None, [GLuint, POINTER(GLubyte)], 'NV_vertex_program')

# GL/glext.h:5961
glVertexAttribs1dvNV = _link_function('glVertexAttribs1dvNV', None, [GLuint, GLsizei, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5962
glVertexAttribs1fvNV = _link_function('glVertexAttribs1fvNV', None, [GLuint, GLsizei, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5963
glVertexAttribs1svNV = _link_function('glVertexAttribs1svNV', None, [GLuint, GLsizei, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5964
glVertexAttribs2dvNV = _link_function('glVertexAttribs2dvNV', None, [GLuint, GLsizei, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5965
glVertexAttribs2fvNV = _link_function('glVertexAttribs2fvNV', None, [GLuint, GLsizei, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5966
glVertexAttribs2svNV = _link_function('glVertexAttribs2svNV', None, [GLuint, GLsizei, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5967
glVertexAttribs3dvNV = _link_function('glVertexAttribs3dvNV', None, [GLuint, GLsizei, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5968
glVertexAttribs3fvNV = _link_function('glVertexAttribs3fvNV', None, [GLuint, GLsizei, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5969
glVertexAttribs3svNV = _link_function('glVertexAttribs3svNV', None, [GLuint, GLsizei, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5970
glVertexAttribs4dvNV = _link_function('glVertexAttribs4dvNV', None, [GLuint, GLsizei, POINTER(GLdouble)], 'NV_vertex_program')

# GL/glext.h:5971
glVertexAttribs4fvNV = _link_function('glVertexAttribs4fvNV', None, [GLuint, GLsizei, POINTER(GLfloat)], 'NV_vertex_program')

# GL/glext.h:5972
glVertexAttribs4svNV = _link_function('glVertexAttribs4svNV', None, [GLuint, GLsizei, POINTER(GLshort)], 'NV_vertex_program')

# GL/glext.h:5973
glVertexAttribs4ubvNV = _link_function('glVertexAttribs4ubvNV', None, [GLuint, GLsizei, POINTER(GLubyte)], 'NV_vertex_program')

PFNGLAREPROGRAMSRESIDENTNVPROC = CFUNCTYPE(GLboolean, GLsizei, POINTER(GLuint), POINTER(GLboolean)) 	# GL/glext.h:5975
PFNGLBINDPROGRAMNVPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:5976
PFNGLDELETEPROGRAMSNVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:5977
PFNGLEXECUTEPROGRAMNVPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLfloat)) 	# GL/glext.h:5978
PFNGLGENPROGRAMSNVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:5979
PFNGLGETPROGRAMPARAMETERDVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, POINTER(GLdouble)) 	# GL/glext.h:5980
PFNGLGETPROGRAMPARAMETERFVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5981
PFNGLGETPROGRAMIVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5982
PFNGLGETPROGRAMSTRINGNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLubyte)) 	# GL/glext.h:5983
PFNGLGETTRACKMATRIXIVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5984
PFNGLGETVERTEXATTRIBDVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLdouble)) 	# GL/glext.h:5985
PFNGLGETVERTEXATTRIBFVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:5986
PFNGLGETVERTEXATTRIBIVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:5987
PFNGLGETVERTEXATTRIBPOINTERVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:5988
PFNGLISPROGRAMNVPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:5989
PFNGLLOADPROGRAMNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLsizei, POINTER(GLubyte)) 	# GL/glext.h:5990
PFNGLPROGRAMPARAMETER4DNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:5991
PFNGLPROGRAMPARAMETER4DVNVPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLdouble)) 	# GL/glext.h:5992
PFNGLPROGRAMPARAMETER4FNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:5993
PFNGLPROGRAMPARAMETER4FVNVPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLfloat)) 	# GL/glext.h:5994
PFNGLPROGRAMPARAMETERS4DVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, POINTER(GLdouble)) 	# GL/glext.h:5995
PFNGLPROGRAMPARAMETERS4FVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, POINTER(GLfloat)) 	# GL/glext.h:5996
PFNGLREQUESTRESIDENTPROGRAMSNVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:5997
PFNGLTRACKMATRIXNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLenum, GLenum) 	# GL/glext.h:5998
PFNGLVERTEXATTRIBPOINTERNVPROC = CFUNCTYPE(None, GLuint, GLint, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:5999
PFNGLVERTEXATTRIB1DNVPROC = CFUNCTYPE(None, GLuint, GLdouble) 	# GL/glext.h:6000
PFNGLVERTEXATTRIB1DVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:6001
PFNGLVERTEXATTRIB1FNVPROC = CFUNCTYPE(None, GLuint, GLfloat) 	# GL/glext.h:6002
PFNGLVERTEXATTRIB1FVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:6003
PFNGLVERTEXATTRIB1SNVPROC = CFUNCTYPE(None, GLuint, GLshort) 	# GL/glext.h:6004
PFNGLVERTEXATTRIB1SVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:6005
PFNGLVERTEXATTRIB2DNVPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble) 	# GL/glext.h:6006
PFNGLVERTEXATTRIB2DVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:6007
PFNGLVERTEXATTRIB2FNVPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat) 	# GL/glext.h:6008
PFNGLVERTEXATTRIB2FVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:6009
PFNGLVERTEXATTRIB2SNVPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort) 	# GL/glext.h:6010
PFNGLVERTEXATTRIB2SVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:6011
PFNGLVERTEXATTRIB3DNVPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:6012
PFNGLVERTEXATTRIB3DVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:6013
PFNGLVERTEXATTRIB3FNVPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:6014
PFNGLVERTEXATTRIB3FVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:6015
PFNGLVERTEXATTRIB3SNVPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort, GLshort) 	# GL/glext.h:6016
PFNGLVERTEXATTRIB3SVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:6017
PFNGLVERTEXATTRIB4DNVPROC = CFUNCTYPE(None, GLuint, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:6018
PFNGLVERTEXATTRIB4DVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:6019
PFNGLVERTEXATTRIB4FNVPROC = CFUNCTYPE(None, GLuint, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:6020
PFNGLVERTEXATTRIB4FVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:6021
PFNGLVERTEXATTRIB4SNVPROC = CFUNCTYPE(None, GLuint, GLshort, GLshort, GLshort, GLshort) 	# GL/glext.h:6022
PFNGLVERTEXATTRIB4SVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:6023
PFNGLVERTEXATTRIB4UBNVPROC = CFUNCTYPE(None, GLuint, GLubyte, GLubyte, GLubyte, GLubyte) 	# GL/glext.h:6024
PFNGLVERTEXATTRIB4UBVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLubyte)) 	# GL/glext.h:6025
PFNGLVERTEXATTRIBS1DVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLdouble)) 	# GL/glext.h:6026
PFNGLVERTEXATTRIBS1FVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:6027
PFNGLVERTEXATTRIBS1SVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLshort)) 	# GL/glext.h:6028
PFNGLVERTEXATTRIBS2DVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLdouble)) 	# GL/glext.h:6029
PFNGLVERTEXATTRIBS2FVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:6030
PFNGLVERTEXATTRIBS2SVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLshort)) 	# GL/glext.h:6031
PFNGLVERTEXATTRIBS3DVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLdouble)) 	# GL/glext.h:6032
PFNGLVERTEXATTRIBS3FVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:6033
PFNGLVERTEXATTRIBS3SVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLshort)) 	# GL/glext.h:6034
PFNGLVERTEXATTRIBS4DVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLdouble)) 	# GL/glext.h:6035
PFNGLVERTEXATTRIBS4FVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:6036
PFNGLVERTEXATTRIBS4SVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLshort)) 	# GL/glext.h:6037
PFNGLVERTEXATTRIBS4UBVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLubyte)) 	# GL/glext.h:6038
# SGIX_texture_coordinate_clamp (GL/glext.h:6041)
GL_SGIX_texture_coordinate_clamp = 1 	# GL/glext.h:6042
# SGIX_scalebias_hint (GL/glext.h:6045)
GL_SGIX_scalebias_hint = 1 	# GL/glext.h:6046
# OML_interlace (GL/glext.h:6049)
GL_OML_interlace = 1 	# GL/glext.h:6050
# OML_subsample (GL/glext.h:6053)
GL_OML_subsample = 1 	# GL/glext.h:6054
# OML_resample (GL/glext.h:6057)
GL_OML_resample = 1 	# GL/glext.h:6058
# NV_copy_depth_to_color (GL/glext.h:6061)
GL_NV_copy_depth_to_color = 1 	# GL/glext.h:6062
# ATI_envmap_bumpmap (GL/glext.h:6065)
GL_ATI_envmap_bumpmap = 1 	# GL/glext.h:6066
# GL/glext.h:6068
glTexBumpParameterivATI = _link_function('glTexBumpParameterivATI', None, [GLenum, POINTER(GLint)], 'ATI_envmap_bumpmap')

# GL/glext.h:6069
glTexBumpParameterfvATI = _link_function('glTexBumpParameterfvATI', None, [GLenum, POINTER(GLfloat)], 'ATI_envmap_bumpmap')

# GL/glext.h:6070
glGetTexBumpParameterivATI = _link_function('glGetTexBumpParameterivATI', None, [GLenum, POINTER(GLint)], 'ATI_envmap_bumpmap')

# GL/glext.h:6071
glGetTexBumpParameterfvATI = _link_function('glGetTexBumpParameterfvATI', None, [GLenum, POINTER(GLfloat)], 'ATI_envmap_bumpmap')

PFNGLTEXBUMPPARAMETERIVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:6073
PFNGLTEXBUMPPARAMETERFVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6074
PFNGLGETTEXBUMPPARAMETERIVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:6075
PFNGLGETTEXBUMPPARAMETERFVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6076
# ATI_fragment_shader (GL/glext.h:6079)
GL_ATI_fragment_shader = 1 	# GL/glext.h:6080
# GL/glext.h:6082
glGenFragmentShadersATI = _link_function('glGenFragmentShadersATI', GLuint, [GLuint], 'ATI_fragment_shader')

# GL/glext.h:6083
glBindFragmentShaderATI = _link_function('glBindFragmentShaderATI', None, [GLuint], 'ATI_fragment_shader')

# GL/glext.h:6084
glDeleteFragmentShaderATI = _link_function('glDeleteFragmentShaderATI', None, [GLuint], 'ATI_fragment_shader')

# GL/glext.h:6085
glBeginFragmentShaderATI = _link_function('glBeginFragmentShaderATI', None, [], 'ATI_fragment_shader')

# GL/glext.h:6086
glEndFragmentShaderATI = _link_function('glEndFragmentShaderATI', None, [], 'ATI_fragment_shader')

# GL/glext.h:6087
glPassTexCoordATI = _link_function('glPassTexCoordATI', None, [GLuint, GLuint, GLenum], 'ATI_fragment_shader')

# GL/glext.h:6088
glSampleMapATI = _link_function('glSampleMapATI', None, [GLuint, GLuint, GLenum], 'ATI_fragment_shader')

# GL/glext.h:6089
glColorFragmentOp1ATI = _link_function('glColorFragmentOp1ATI', None, [GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint], 'ATI_fragment_shader')

# GL/glext.h:6090
glColorFragmentOp2ATI = _link_function('glColorFragmentOp2ATI', None, [GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint], 'ATI_fragment_shader')

# GL/glext.h:6091
glColorFragmentOp3ATI = _link_function('glColorFragmentOp3ATI', None, [GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint], 'ATI_fragment_shader')

# GL/glext.h:6092
glAlphaFragmentOp1ATI = _link_function('glAlphaFragmentOp1ATI', None, [GLenum, GLuint, GLuint, GLuint, GLuint, GLuint], 'ATI_fragment_shader')

# GL/glext.h:6093
glAlphaFragmentOp2ATI = _link_function('glAlphaFragmentOp2ATI', None, [GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint], 'ATI_fragment_shader')

# GL/glext.h:6094
glAlphaFragmentOp3ATI = _link_function('glAlphaFragmentOp3ATI', None, [GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint], 'ATI_fragment_shader')

# GL/glext.h:6095
glSetFragmentShaderConstantATI = _link_function('glSetFragmentShaderConstantATI', None, [GLuint, POINTER(GLfloat)], 'ATI_fragment_shader')

PFNGLGENFRAGMENTSHADERSATIPROC = CFUNCTYPE(GLuint, GLuint) 	# GL/glext.h:6097
PFNGLBINDFRAGMENTSHADERATIPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6098
PFNGLDELETEFRAGMENTSHADERATIPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6099
PFNGLBEGINFRAGMENTSHADERATIPROC = CFUNCTYPE(None) 	# GL/glext.h:6100
PFNGLENDFRAGMENTSHADERATIPROC = CFUNCTYPE(None) 	# GL/glext.h:6101
PFNGLPASSTEXCOORDATIPROC = CFUNCTYPE(None, GLuint, GLuint, GLenum) 	# GL/glext.h:6102
PFNGLSAMPLEMAPATIPROC = CFUNCTYPE(None, GLuint, GLuint, GLenum) 	# GL/glext.h:6103
PFNGLCOLORFRAGMENTOP1ATIPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:6104
PFNGLCOLORFRAGMENTOP2ATIPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:6105
PFNGLCOLORFRAGMENTOP3ATIPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:6106
PFNGLALPHAFRAGMENTOP1ATIPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:6107
PFNGLALPHAFRAGMENTOP2ATIPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:6108
PFNGLALPHAFRAGMENTOP3ATIPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:6109
PFNGLSETFRAGMENTSHADERCONSTANTATIPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:6110
# ATI_pn_triangles (GL/glext.h:6113)
GL_ATI_pn_triangles = 1 	# GL/glext.h:6114
# GL/glext.h:6116
glPNTrianglesiATI = _link_function('glPNTrianglesiATI', None, [GLenum, GLint], 'ATI_pn_triangles')

# GL/glext.h:6117
glPNTrianglesfATI = _link_function('glPNTrianglesfATI', None, [GLenum, GLfloat], 'ATI_pn_triangles')

PFNGLPNTRIANGLESIATIPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:6119
PFNGLPNTRIANGLESFATIPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:6120
# ATI_vertex_array_object (GL/glext.h:6123)
GL_ATI_vertex_array_object = 1 	# GL/glext.h:6124
# GL/glext.h:6126
glNewObjectBufferATI = _link_function('glNewObjectBufferATI', GLuint, [GLsizei, POINTER(GLvoid), GLenum], 'ATI_vertex_array_object')

# GL/glext.h:6127
glIsObjectBufferATI = _link_function('glIsObjectBufferATI', GLboolean, [GLuint], 'ATI_vertex_array_object')

# GL/glext.h:6128
glUpdateObjectBufferATI = _link_function('glUpdateObjectBufferATI', None, [GLuint, GLuint, GLsizei, POINTER(GLvoid), GLenum], 'ATI_vertex_array_object')

# GL/glext.h:6129
glGetObjectBufferfvATI = _link_function('glGetObjectBufferfvATI', None, [GLuint, GLenum, POINTER(GLfloat)], 'ATI_vertex_array_object')

# GL/glext.h:6130
glGetObjectBufferivATI = _link_function('glGetObjectBufferivATI', None, [GLuint, GLenum, POINTER(GLint)], 'ATI_vertex_array_object')

# GL/glext.h:6131
glFreeObjectBufferATI = _link_function('glFreeObjectBufferATI', None, [GLuint], 'ATI_vertex_array_object')

# GL/glext.h:6132
glArrayObjectATI = _link_function('glArrayObjectATI', None, [GLenum, GLint, GLenum, GLsizei, GLuint, GLuint], 'ATI_vertex_array_object')

# GL/glext.h:6133
glGetArrayObjectfvATI = _link_function('glGetArrayObjectfvATI', None, [GLenum, GLenum, POINTER(GLfloat)], 'ATI_vertex_array_object')

# GL/glext.h:6134
glGetArrayObjectivATI = _link_function('glGetArrayObjectivATI', None, [GLenum, GLenum, POINTER(GLint)], 'ATI_vertex_array_object')

# GL/glext.h:6135
glVariantArrayObjectATI = _link_function('glVariantArrayObjectATI', None, [GLuint, GLenum, GLsizei, GLuint, GLuint], 'ATI_vertex_array_object')

# GL/glext.h:6136
glGetVariantArrayObjectfvATI = _link_function('glGetVariantArrayObjectfvATI', None, [GLuint, GLenum, POINTER(GLfloat)], 'ATI_vertex_array_object')

# GL/glext.h:6137
glGetVariantArrayObjectivATI = _link_function('glGetVariantArrayObjectivATI', None, [GLuint, GLenum, POINTER(GLint)], 'ATI_vertex_array_object')

PFNGLNEWOBJECTBUFFERATIPROC = CFUNCTYPE(GLuint, GLsizei, POINTER(GLvoid), GLenum) 	# GL/glext.h:6139
PFNGLISOBJECTBUFFERATIPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:6140
PFNGLUPDATEOBJECTBUFFERATIPROC = CFUNCTYPE(None, GLuint, GLuint, GLsizei, POINTER(GLvoid), GLenum) 	# GL/glext.h:6141
PFNGLGETOBJECTBUFFERFVATIPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6142
PFNGLGETOBJECTBUFFERIVATIPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:6143
PFNGLFREEOBJECTBUFFERATIPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6144
PFNGLARRAYOBJECTATIPROC = CFUNCTYPE(None, GLenum, GLint, GLenum, GLsizei, GLuint, GLuint) 	# GL/glext.h:6145
PFNGLGETARRAYOBJECTFVATIPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6146
PFNGLGETARRAYOBJECTIVATIPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:6147
PFNGLVARIANTARRAYOBJECTATIPROC = CFUNCTYPE(None, GLuint, GLenum, GLsizei, GLuint, GLuint) 	# GL/glext.h:6148
PFNGLGETVARIANTARRAYOBJECTFVATIPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6149
PFNGLGETVARIANTARRAYOBJECTIVATIPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:6150
# EXT_vertex_shader (GL/glext.h:6153)
GL_EXT_vertex_shader = 1 	# GL/glext.h:6154
# GL/glext.h:6156
glBeginVertexShaderEXT = _link_function('glBeginVertexShaderEXT', None, [], 'EXT_vertex_shader')

# GL/glext.h:6157
glEndVertexShaderEXT = _link_function('glEndVertexShaderEXT', None, [], 'EXT_vertex_shader')

# GL/glext.h:6158
glBindVertexShaderEXT = _link_function('glBindVertexShaderEXT', None, [GLuint], 'EXT_vertex_shader')

# GL/glext.h:6159
glGenVertexShadersEXT = _link_function('glGenVertexShadersEXT', GLuint, [GLuint], 'EXT_vertex_shader')

# GL/glext.h:6160
glDeleteVertexShaderEXT = _link_function('glDeleteVertexShaderEXT', None, [GLuint], 'EXT_vertex_shader')

# GL/glext.h:6161
glShaderOp1EXT = _link_function('glShaderOp1EXT', None, [GLenum, GLuint, GLuint], 'EXT_vertex_shader')

# GL/glext.h:6162
glShaderOp2EXT = _link_function('glShaderOp2EXT', None, [GLenum, GLuint, GLuint, GLuint], 'EXT_vertex_shader')

# GL/glext.h:6163
glShaderOp3EXT = _link_function('glShaderOp3EXT', None, [GLenum, GLuint, GLuint, GLuint, GLuint], 'EXT_vertex_shader')

# GL/glext.h:6164
glSwizzleEXT = _link_function('glSwizzleEXT', None, [GLuint, GLuint, GLenum, GLenum, GLenum, GLenum], 'EXT_vertex_shader')

# GL/glext.h:6165
glWriteMaskEXT = _link_function('glWriteMaskEXT', None, [GLuint, GLuint, GLenum, GLenum, GLenum, GLenum], 'EXT_vertex_shader')

# GL/glext.h:6166
glInsertComponentEXT = _link_function('glInsertComponentEXT', None, [GLuint, GLuint, GLuint], 'EXT_vertex_shader')

# GL/glext.h:6167
glExtractComponentEXT = _link_function('glExtractComponentEXT', None, [GLuint, GLuint, GLuint], 'EXT_vertex_shader')

# GL/glext.h:6168
glGenSymbolsEXT = _link_function('glGenSymbolsEXT', GLuint, [GLenum, GLenum, GLenum, GLuint], 'EXT_vertex_shader')

# GL/glext.h:6169
glSetInvariantEXT = _link_function('glSetInvariantEXT', None, [GLuint, GLenum, POINTER(GLvoid)], 'EXT_vertex_shader')

# GL/glext.h:6170
glSetLocalConstantEXT = _link_function('glSetLocalConstantEXT', None, [GLuint, GLenum, POINTER(GLvoid)], 'EXT_vertex_shader')

# GL/glext.h:6171
glVariantbvEXT = _link_function('glVariantbvEXT', None, [GLuint, POINTER(GLbyte)], 'EXT_vertex_shader')

# GL/glext.h:6172
glVariantsvEXT = _link_function('glVariantsvEXT', None, [GLuint, POINTER(GLshort)], 'EXT_vertex_shader')

# GL/glext.h:6173
glVariantivEXT = _link_function('glVariantivEXT', None, [GLuint, POINTER(GLint)], 'EXT_vertex_shader')

# GL/glext.h:6174
glVariantfvEXT = _link_function('glVariantfvEXT', None, [GLuint, POINTER(GLfloat)], 'EXT_vertex_shader')

# GL/glext.h:6175
glVariantdvEXT = _link_function('glVariantdvEXT', None, [GLuint, POINTER(GLdouble)], 'EXT_vertex_shader')

# GL/glext.h:6176
glVariantubvEXT = _link_function('glVariantubvEXT', None, [GLuint, POINTER(GLubyte)], 'EXT_vertex_shader')

# GL/glext.h:6177
glVariantusvEXT = _link_function('glVariantusvEXT', None, [GLuint, POINTER(GLushort)], 'EXT_vertex_shader')

# GL/glext.h:6178
glVariantuivEXT = _link_function('glVariantuivEXT', None, [GLuint, POINTER(GLuint)], 'EXT_vertex_shader')

# GL/glext.h:6179
glVariantPointerEXT = _link_function('glVariantPointerEXT', None, [GLuint, GLenum, GLuint, POINTER(GLvoid)], 'EXT_vertex_shader')

# GL/glext.h:6180
glEnableVariantClientStateEXT = _link_function('glEnableVariantClientStateEXT', None, [GLuint], 'EXT_vertex_shader')

# GL/glext.h:6181
glDisableVariantClientStateEXT = _link_function('glDisableVariantClientStateEXT', None, [GLuint], 'EXT_vertex_shader')

# GL/glext.h:6182
glBindLightParameterEXT = _link_function('glBindLightParameterEXT', GLuint, [GLenum, GLenum], 'EXT_vertex_shader')

# GL/glext.h:6183
glBindMaterialParameterEXT = _link_function('glBindMaterialParameterEXT', GLuint, [GLenum, GLenum], 'EXT_vertex_shader')

# GL/glext.h:6184
glBindTexGenParameterEXT = _link_function('glBindTexGenParameterEXT', GLuint, [GLenum, GLenum, GLenum], 'EXT_vertex_shader')

# GL/glext.h:6185
glBindTextureUnitParameterEXT = _link_function('glBindTextureUnitParameterEXT', GLuint, [GLenum, GLenum], 'EXT_vertex_shader')

# GL/glext.h:6186
glBindParameterEXT = _link_function('glBindParameterEXT', GLuint, [GLenum], 'EXT_vertex_shader')

# GL/glext.h:6187
glIsVariantEnabledEXT = _link_function('glIsVariantEnabledEXT', GLboolean, [GLuint, GLenum], 'EXT_vertex_shader')

# GL/glext.h:6188
glGetVariantBooleanvEXT = _link_function('glGetVariantBooleanvEXT', None, [GLuint, GLenum, POINTER(GLboolean)], 'EXT_vertex_shader')

# GL/glext.h:6189
glGetVariantIntegervEXT = _link_function('glGetVariantIntegervEXT', None, [GLuint, GLenum, POINTER(GLint)], 'EXT_vertex_shader')

# GL/glext.h:6190
glGetVariantFloatvEXT = _link_function('glGetVariantFloatvEXT', None, [GLuint, GLenum, POINTER(GLfloat)], 'EXT_vertex_shader')

# GL/glext.h:6191
glGetVariantPointervEXT = _link_function('glGetVariantPointervEXT', None, [GLuint, GLenum, POINTER(POINTER(GLvoid))], 'EXT_vertex_shader')

# GL/glext.h:6192
glGetInvariantBooleanvEXT = _link_function('glGetInvariantBooleanvEXT', None, [GLuint, GLenum, POINTER(GLboolean)], 'EXT_vertex_shader')

# GL/glext.h:6193
glGetInvariantIntegervEXT = _link_function('glGetInvariantIntegervEXT', None, [GLuint, GLenum, POINTER(GLint)], 'EXT_vertex_shader')

# GL/glext.h:6194
glGetInvariantFloatvEXT = _link_function('glGetInvariantFloatvEXT', None, [GLuint, GLenum, POINTER(GLfloat)], 'EXT_vertex_shader')

# GL/glext.h:6195
glGetLocalConstantBooleanvEXT = _link_function('glGetLocalConstantBooleanvEXT', None, [GLuint, GLenum, POINTER(GLboolean)], 'EXT_vertex_shader')

# GL/glext.h:6196
glGetLocalConstantIntegervEXT = _link_function('glGetLocalConstantIntegervEXT', None, [GLuint, GLenum, POINTER(GLint)], 'EXT_vertex_shader')

# GL/glext.h:6197
glGetLocalConstantFloatvEXT = _link_function('glGetLocalConstantFloatvEXT', None, [GLuint, GLenum, POINTER(GLfloat)], 'EXT_vertex_shader')

PFNGLBEGINVERTEXSHADEREXTPROC = CFUNCTYPE(None) 	# GL/glext.h:6199
PFNGLENDVERTEXSHADEREXTPROC = CFUNCTYPE(None) 	# GL/glext.h:6200
PFNGLBINDVERTEXSHADEREXTPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6201
PFNGLGENVERTEXSHADERSEXTPROC = CFUNCTYPE(GLuint, GLuint) 	# GL/glext.h:6202
PFNGLDELETEVERTEXSHADEREXTPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6203
PFNGLSHADEROP1EXTPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint) 	# GL/glext.h:6204
PFNGLSHADEROP2EXTPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint) 	# GL/glext.h:6205
PFNGLSHADEROP3EXTPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:6206
PFNGLSWIZZLEEXTPROC = CFUNCTYPE(None, GLuint, GLuint, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:6207
PFNGLWRITEMASKEXTPROC = CFUNCTYPE(None, GLuint, GLuint, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:6208
PFNGLINSERTCOMPONENTEXTPROC = CFUNCTYPE(None, GLuint, GLuint, GLuint) 	# GL/glext.h:6209
PFNGLEXTRACTCOMPONENTEXTPROC = CFUNCTYPE(None, GLuint, GLuint, GLuint) 	# GL/glext.h:6210
PFNGLGENSYMBOLSEXTPROC = CFUNCTYPE(GLuint, GLenum, GLenum, GLenum, GLuint) 	# GL/glext.h:6211
PFNGLSETINVARIANTEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLvoid)) 	# GL/glext.h:6212
PFNGLSETLOCALCONSTANTEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLvoid)) 	# GL/glext.h:6213
PFNGLVARIANTBVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLbyte)) 	# GL/glext.h:6214
PFNGLVARIANTSVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:6215
PFNGLVARIANTIVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLint)) 	# GL/glext.h:6216
PFNGLVARIANTFVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLfloat)) 	# GL/glext.h:6217
PFNGLVARIANTDVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLdouble)) 	# GL/glext.h:6218
PFNGLVARIANTUBVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLubyte)) 	# GL/glext.h:6219
PFNGLVARIANTUSVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLushort)) 	# GL/glext.h:6220
PFNGLVARIANTUIVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLuint)) 	# GL/glext.h:6221
PFNGLVARIANTPOINTEREXTPROC = CFUNCTYPE(None, GLuint, GLenum, GLuint, POINTER(GLvoid)) 	# GL/glext.h:6222
PFNGLENABLEVARIANTCLIENTSTATEEXTPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6223
PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6224
PFNGLBINDLIGHTPARAMETEREXTPROC = CFUNCTYPE(GLuint, GLenum, GLenum) 	# GL/glext.h:6225
PFNGLBINDMATERIALPARAMETEREXTPROC = CFUNCTYPE(GLuint, GLenum, GLenum) 	# GL/glext.h:6226
PFNGLBINDTEXGENPARAMETEREXTPROC = CFUNCTYPE(GLuint, GLenum, GLenum, GLenum) 	# GL/glext.h:6227
PFNGLBINDTEXTUREUNITPARAMETEREXTPROC = CFUNCTYPE(GLuint, GLenum, GLenum) 	# GL/glext.h:6228
PFNGLBINDPARAMETEREXTPROC = CFUNCTYPE(GLuint, GLenum) 	# GL/glext.h:6229
PFNGLISVARIANTENABLEDEXTPROC = CFUNCTYPE(GLboolean, GLuint, GLenum) 	# GL/glext.h:6230
PFNGLGETVARIANTBOOLEANVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLboolean)) 	# GL/glext.h:6231
PFNGLGETVARIANTINTEGERVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:6232
PFNGLGETVARIANTFLOATVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6233
PFNGLGETVARIANTPOINTERVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(POINTER(GLvoid))) 	# GL/glext.h:6234
PFNGLGETINVARIANTBOOLEANVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLboolean)) 	# GL/glext.h:6235
PFNGLGETINVARIANTINTEGERVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:6236
PFNGLGETINVARIANTFLOATVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6237
PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLboolean)) 	# GL/glext.h:6238
PFNGLGETLOCALCONSTANTINTEGERVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:6239
PFNGLGETLOCALCONSTANTFLOATVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6240
# ATI_vertex_streams (GL/glext.h:6243)
GL_ATI_vertex_streams = 1 	# GL/glext.h:6244
# GL/glext.h:6246
glVertexStream1sATI = _link_function('glVertexStream1sATI', None, [GLenum, GLshort], 'ATI_vertex_streams')

# GL/glext.h:6247
glVertexStream1svATI = _link_function('glVertexStream1svATI', None, [GLenum, POINTER(GLshort)], 'ATI_vertex_streams')

# GL/glext.h:6248
glVertexStream1iATI = _link_function('glVertexStream1iATI', None, [GLenum, GLint], 'ATI_vertex_streams')

# GL/glext.h:6249
glVertexStream1ivATI = _link_function('glVertexStream1ivATI', None, [GLenum, POINTER(GLint)], 'ATI_vertex_streams')

# GL/glext.h:6250
glVertexStream1fATI = _link_function('glVertexStream1fATI', None, [GLenum, GLfloat], 'ATI_vertex_streams')

# GL/glext.h:6251
glVertexStream1fvATI = _link_function('glVertexStream1fvATI', None, [GLenum, POINTER(GLfloat)], 'ATI_vertex_streams')

# GL/glext.h:6252
glVertexStream1dATI = _link_function('glVertexStream1dATI', None, [GLenum, GLdouble], 'ATI_vertex_streams')

# GL/glext.h:6253
glVertexStream1dvATI = _link_function('glVertexStream1dvATI', None, [GLenum, POINTER(GLdouble)], 'ATI_vertex_streams')

# GL/glext.h:6254
glVertexStream2sATI = _link_function('glVertexStream2sATI', None, [GLenum, GLshort, GLshort], 'ATI_vertex_streams')

# GL/glext.h:6255
glVertexStream2svATI = _link_function('glVertexStream2svATI', None, [GLenum, POINTER(GLshort)], 'ATI_vertex_streams')

# GL/glext.h:6256
glVertexStream2iATI = _link_function('glVertexStream2iATI', None, [GLenum, GLint, GLint], 'ATI_vertex_streams')

# GL/glext.h:6257
glVertexStream2ivATI = _link_function('glVertexStream2ivATI', None, [GLenum, POINTER(GLint)], 'ATI_vertex_streams')

# GL/glext.h:6258
glVertexStream2fATI = _link_function('glVertexStream2fATI', None, [GLenum, GLfloat, GLfloat], 'ATI_vertex_streams')

# GL/glext.h:6259
glVertexStream2fvATI = _link_function('glVertexStream2fvATI', None, [GLenum, POINTER(GLfloat)], 'ATI_vertex_streams')

# GL/glext.h:6260
glVertexStream2dATI = _link_function('glVertexStream2dATI', None, [GLenum, GLdouble, GLdouble], 'ATI_vertex_streams')

# GL/glext.h:6261
glVertexStream2dvATI = _link_function('glVertexStream2dvATI', None, [GLenum, POINTER(GLdouble)], 'ATI_vertex_streams')

# GL/glext.h:6262
glVertexStream3sATI = _link_function('glVertexStream3sATI', None, [GLenum, GLshort, GLshort, GLshort], 'ATI_vertex_streams')

# GL/glext.h:6263
glVertexStream3svATI = _link_function('glVertexStream3svATI', None, [GLenum, POINTER(GLshort)], 'ATI_vertex_streams')

# GL/glext.h:6264
glVertexStream3iATI = _link_function('glVertexStream3iATI', None, [GLenum, GLint, GLint, GLint], 'ATI_vertex_streams')

# GL/glext.h:6265
glVertexStream3ivATI = _link_function('glVertexStream3ivATI', None, [GLenum, POINTER(GLint)], 'ATI_vertex_streams')

# GL/glext.h:6266
glVertexStream3fATI = _link_function('glVertexStream3fATI', None, [GLenum, GLfloat, GLfloat, GLfloat], 'ATI_vertex_streams')

# GL/glext.h:6267
glVertexStream3fvATI = _link_function('glVertexStream3fvATI', None, [GLenum, POINTER(GLfloat)], 'ATI_vertex_streams')

# GL/glext.h:6268
glVertexStream3dATI = _link_function('glVertexStream3dATI', None, [GLenum, GLdouble, GLdouble, GLdouble], 'ATI_vertex_streams')

# GL/glext.h:6269
glVertexStream3dvATI = _link_function('glVertexStream3dvATI', None, [GLenum, POINTER(GLdouble)], 'ATI_vertex_streams')

# GL/glext.h:6270
glVertexStream4sATI = _link_function('glVertexStream4sATI', None, [GLenum, GLshort, GLshort, GLshort, GLshort], 'ATI_vertex_streams')

# GL/glext.h:6271
glVertexStream4svATI = _link_function('glVertexStream4svATI', None, [GLenum, POINTER(GLshort)], 'ATI_vertex_streams')

# GL/glext.h:6272
glVertexStream4iATI = _link_function('glVertexStream4iATI', None, [GLenum, GLint, GLint, GLint, GLint], 'ATI_vertex_streams')

# GL/glext.h:6273
glVertexStream4ivATI = _link_function('glVertexStream4ivATI', None, [GLenum, POINTER(GLint)], 'ATI_vertex_streams')

# GL/glext.h:6274
glVertexStream4fATI = _link_function('glVertexStream4fATI', None, [GLenum, GLfloat, GLfloat, GLfloat, GLfloat], 'ATI_vertex_streams')

# GL/glext.h:6275
glVertexStream4fvATI = _link_function('glVertexStream4fvATI', None, [GLenum, POINTER(GLfloat)], 'ATI_vertex_streams')

# GL/glext.h:6276
glVertexStream4dATI = _link_function('glVertexStream4dATI', None, [GLenum, GLdouble, GLdouble, GLdouble, GLdouble], 'ATI_vertex_streams')

# GL/glext.h:6277
glVertexStream4dvATI = _link_function('glVertexStream4dvATI', None, [GLenum, POINTER(GLdouble)], 'ATI_vertex_streams')

# GL/glext.h:6278
glNormalStream3bATI = _link_function('glNormalStream3bATI', None, [GLenum, GLbyte, GLbyte, GLbyte], 'ATI_vertex_streams')

# GL/glext.h:6279
glNormalStream3bvATI = _link_function('glNormalStream3bvATI', None, [GLenum, POINTER(GLbyte)], 'ATI_vertex_streams')

# GL/glext.h:6280
glNormalStream3sATI = _link_function('glNormalStream3sATI', None, [GLenum, GLshort, GLshort, GLshort], 'ATI_vertex_streams')

# GL/glext.h:6281
glNormalStream3svATI = _link_function('glNormalStream3svATI', None, [GLenum, POINTER(GLshort)], 'ATI_vertex_streams')

# GL/glext.h:6282
glNormalStream3iATI = _link_function('glNormalStream3iATI', None, [GLenum, GLint, GLint, GLint], 'ATI_vertex_streams')

# GL/glext.h:6283
glNormalStream3ivATI = _link_function('glNormalStream3ivATI', None, [GLenum, POINTER(GLint)], 'ATI_vertex_streams')

# GL/glext.h:6284
glNormalStream3fATI = _link_function('glNormalStream3fATI', None, [GLenum, GLfloat, GLfloat, GLfloat], 'ATI_vertex_streams')

# GL/glext.h:6285
glNormalStream3fvATI = _link_function('glNormalStream3fvATI', None, [GLenum, POINTER(GLfloat)], 'ATI_vertex_streams')

# GL/glext.h:6286
glNormalStream3dATI = _link_function('glNormalStream3dATI', None, [GLenum, GLdouble, GLdouble, GLdouble], 'ATI_vertex_streams')

# GL/glext.h:6287
glNormalStream3dvATI = _link_function('glNormalStream3dvATI', None, [GLenum, POINTER(GLdouble)], 'ATI_vertex_streams')

# GL/glext.h:6288
glClientActiveVertexStreamATI = _link_function('glClientActiveVertexStreamATI', None, [GLenum], 'ATI_vertex_streams')

# GL/glext.h:6289
glVertexBlendEnviATI = _link_function('glVertexBlendEnviATI', None, [GLenum, GLint], 'ATI_vertex_streams')

# GL/glext.h:6290
glVertexBlendEnvfATI = _link_function('glVertexBlendEnvfATI', None, [GLenum, GLfloat], 'ATI_vertex_streams')

PFNGLVERTEXSTREAM1SATIPROC = CFUNCTYPE(None, GLenum, GLshort) 	# GL/glext.h:6292
PFNGLVERTEXSTREAM1SVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:6293
PFNGLVERTEXSTREAM1IATIPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:6294
PFNGLVERTEXSTREAM1IVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:6295
PFNGLVERTEXSTREAM1FATIPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:6296
PFNGLVERTEXSTREAM1FVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6297
PFNGLVERTEXSTREAM1DATIPROC = CFUNCTYPE(None, GLenum, GLdouble) 	# GL/glext.h:6298
PFNGLVERTEXSTREAM1DVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:6299
PFNGLVERTEXSTREAM2SATIPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort) 	# GL/glext.h:6300
PFNGLVERTEXSTREAM2SVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:6301
PFNGLVERTEXSTREAM2IATIPROC = CFUNCTYPE(None, GLenum, GLint, GLint) 	# GL/glext.h:6302
PFNGLVERTEXSTREAM2IVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:6303
PFNGLVERTEXSTREAM2FATIPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat) 	# GL/glext.h:6304
PFNGLVERTEXSTREAM2FVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6305
PFNGLVERTEXSTREAM2DATIPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble) 	# GL/glext.h:6306
PFNGLVERTEXSTREAM2DVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:6307
PFNGLVERTEXSTREAM3SATIPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort, GLshort) 	# GL/glext.h:6308
PFNGLVERTEXSTREAM3SVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:6309
PFNGLVERTEXSTREAM3IATIPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint) 	# GL/glext.h:6310
PFNGLVERTEXSTREAM3IVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:6311
PFNGLVERTEXSTREAM3FATIPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:6312
PFNGLVERTEXSTREAM3FVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6313
PFNGLVERTEXSTREAM3DATIPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:6314
PFNGLVERTEXSTREAM3DVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:6315
PFNGLVERTEXSTREAM4SATIPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort, GLshort, GLshort) 	# GL/glext.h:6316
PFNGLVERTEXSTREAM4SVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:6317
PFNGLVERTEXSTREAM4IATIPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint, GLint) 	# GL/glext.h:6318
PFNGLVERTEXSTREAM4IVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:6319
PFNGLVERTEXSTREAM4FATIPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:6320
PFNGLVERTEXSTREAM4FVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6321
PFNGLVERTEXSTREAM4DATIPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:6322
PFNGLVERTEXSTREAM4DVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:6323
PFNGLNORMALSTREAM3BATIPROC = CFUNCTYPE(None, GLenum, GLbyte, GLbyte, GLbyte) 	# GL/glext.h:6324
PFNGLNORMALSTREAM3BVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLbyte)) 	# GL/glext.h:6325
PFNGLNORMALSTREAM3SATIPROC = CFUNCTYPE(None, GLenum, GLshort, GLshort, GLshort) 	# GL/glext.h:6326
PFNGLNORMALSTREAM3SVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLshort)) 	# GL/glext.h:6327
PFNGLNORMALSTREAM3IATIPROC = CFUNCTYPE(None, GLenum, GLint, GLint, GLint) 	# GL/glext.h:6328
PFNGLNORMALSTREAM3IVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:6329
PFNGLNORMALSTREAM3FATIPROC = CFUNCTYPE(None, GLenum, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:6330
PFNGLNORMALSTREAM3FVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6331
PFNGLNORMALSTREAM3DATIPROC = CFUNCTYPE(None, GLenum, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:6332
PFNGLNORMALSTREAM3DVATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLdouble)) 	# GL/glext.h:6333
PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:6334
PFNGLVERTEXBLENDENVIATIPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:6335
PFNGLVERTEXBLENDENVFATIPROC = CFUNCTYPE(None, GLenum, GLfloat) 	# GL/glext.h:6336
# ATI_element_array (GL/glext.h:6339)
GL_ATI_element_array = 1 	# GL/glext.h:6340
# GL/glext.h:6342
glElementPointerATI = _link_function('glElementPointerATI', None, [GLenum, POINTER(GLvoid)], 'ATI_element_array')

# GL/glext.h:6343
glDrawElementArrayATI = _link_function('glDrawElementArrayATI', None, [GLenum, GLsizei], 'ATI_element_array')

# GL/glext.h:6344
glDrawRangeElementArrayATI = _link_function('glDrawRangeElementArrayATI', None, [GLenum, GLuint, GLuint, GLsizei], 'ATI_element_array')

PFNGLELEMENTPOINTERATIPROC = CFUNCTYPE(None, GLenum, POINTER(GLvoid)) 	# GL/glext.h:6346
PFNGLDRAWELEMENTARRAYATIPROC = CFUNCTYPE(None, GLenum, GLsizei) 	# GL/glext.h:6347
PFNGLDRAWRANGEELEMENTARRAYATIPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLsizei) 	# GL/glext.h:6348
# SUN_mesh_array (GL/glext.h:6351)
GL_SUN_mesh_array = 1 	# GL/glext.h:6352
# GL/glext.h:6354
glDrawMeshArraysSUN = _link_function('glDrawMeshArraysSUN', None, [GLenum, GLint, GLsizei, GLsizei], 'SUN_mesh_array')

PFNGLDRAWMESHARRAYSSUNPROC = CFUNCTYPE(None, GLenum, GLint, GLsizei, GLsizei) 	# GL/glext.h:6356
# SUN_slice_accum (GL/glext.h:6359)
GL_SUN_slice_accum = 1 	# GL/glext.h:6360
# NV_multisample_filter_hint (GL/glext.h:6363)
GL_NV_multisample_filter_hint = 1 	# GL/glext.h:6364
# NV_depth_clamp (GL/glext.h:6367)
GL_NV_depth_clamp = 1 	# GL/glext.h:6368
# NV_occlusion_query (GL/glext.h:6371)
GL_NV_occlusion_query = 1 	# GL/glext.h:6372
# GL/glext.h:6374
glGenOcclusionQueriesNV = _link_function('glGenOcclusionQueriesNV', None, [GLsizei, POINTER(GLuint)], 'NV_occlusion_query')

# GL/glext.h:6375
glDeleteOcclusionQueriesNV = _link_function('glDeleteOcclusionQueriesNV', None, [GLsizei, POINTER(GLuint)], 'NV_occlusion_query')

# GL/glext.h:6376
glIsOcclusionQueryNV = _link_function('glIsOcclusionQueryNV', GLboolean, [GLuint], 'NV_occlusion_query')

# GL/glext.h:6377
glBeginOcclusionQueryNV = _link_function('glBeginOcclusionQueryNV', None, [GLuint], 'NV_occlusion_query')

# GL/glext.h:6378
glEndOcclusionQueryNV = _link_function('glEndOcclusionQueryNV', None, [], 'NV_occlusion_query')

# GL/glext.h:6379
glGetOcclusionQueryivNV = _link_function('glGetOcclusionQueryivNV', None, [GLuint, GLenum, POINTER(GLint)], 'NV_occlusion_query')

# GL/glext.h:6380
glGetOcclusionQueryuivNV = _link_function('glGetOcclusionQueryuivNV', None, [GLuint, GLenum, POINTER(GLuint)], 'NV_occlusion_query')

PFNGLGENOCCLUSIONQUERIESNVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6382
PFNGLDELETEOCCLUSIONQUERIESNVPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6383
PFNGLISOCCLUSIONQUERYNVPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:6384
PFNGLBEGINOCCLUSIONQUERYNVPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6385
PFNGLENDOCCLUSIONQUERYNVPROC = CFUNCTYPE(None) 	# GL/glext.h:6386
PFNGLGETOCCLUSIONQUERYIVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:6387
PFNGLGETOCCLUSIONQUERYUIVNVPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLuint)) 	# GL/glext.h:6388
# NV_point_sprite (GL/glext.h:6391)
GL_NV_point_sprite = 1 	# GL/glext.h:6392
# GL/glext.h:6394
glPointParameteriNV = _link_function('glPointParameteriNV', None, [GLenum, GLint], 'NV_point_sprite')

# GL/glext.h:6395
glPointParameterivNV = _link_function('glPointParameterivNV', None, [GLenum, POINTER(GLint)], 'NV_point_sprite')

PFNGLPOINTPARAMETERINVPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:6397
PFNGLPOINTPARAMETERIVNVPROC = CFUNCTYPE(None, GLenum, POINTER(GLint)) 	# GL/glext.h:6398
# NV_texture_shader3 (GL/glext.h:6401)
GL_NV_texture_shader3 = 1 	# GL/glext.h:6402
# NV_vertex_program1_1 (GL/glext.h:6405)
GL_NV_vertex_program1_1 = 1 	# GL/glext.h:6406
# EXT_shadow_funcs (GL/glext.h:6409)
GL_EXT_shadow_funcs = 1 	# GL/glext.h:6410
# EXT_stencil_two_side (GL/glext.h:6413)
GL_EXT_stencil_two_side = 1 	# GL/glext.h:6414
# GL/glext.h:6416
glActiveStencilFaceEXT = _link_function('glActiveStencilFaceEXT', None, [GLenum], 'EXT_stencil_two_side')

PFNGLACTIVESTENCILFACEEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:6418
# ATI_text_fragment_shader (GL/glext.h:6421)
GL_ATI_text_fragment_shader = 1 	# GL/glext.h:6422
# APPLE_client_storage (GL/glext.h:6425)
GL_APPLE_client_storage = 1 	# GL/glext.h:6426
# APPLE_element_array (GL/glext.h:6429)
GL_APPLE_element_array = 1 	# GL/glext.h:6430
# GL/glext.h:6432
glElementPointerAPPLE = _link_function('glElementPointerAPPLE', None, [GLenum, POINTER(GLvoid)], 'APPLE_element_array')

# GL/glext.h:6433
glDrawElementArrayAPPLE = _link_function('glDrawElementArrayAPPLE', None, [GLenum, GLint, GLsizei], 'APPLE_element_array')

# GL/glext.h:6434
glDrawRangeElementArrayAPPLE = _link_function('glDrawRangeElementArrayAPPLE', None, [GLenum, GLuint, GLuint, GLint, GLsizei], 'APPLE_element_array')

# GL/glext.h:6435
glMultiDrawElementArrayAPPLE = _link_function('glMultiDrawElementArrayAPPLE', None, [GLenum, POINTER(GLint), POINTER(GLsizei), GLsizei], 'APPLE_element_array')

# GL/glext.h:6436
glMultiDrawRangeElementArrayAPPLE = _link_function('glMultiDrawRangeElementArrayAPPLE', None, [GLenum, GLuint, GLuint, POINTER(GLint), POINTER(GLsizei), GLsizei], 'APPLE_element_array')

PFNGLELEMENTPOINTERAPPLEPROC = CFUNCTYPE(None, GLenum, POINTER(GLvoid)) 	# GL/glext.h:6438
PFNGLDRAWELEMENTARRAYAPPLEPROC = CFUNCTYPE(None, GLenum, GLint, GLsizei) 	# GL/glext.h:6439
PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLint, GLsizei) 	# GL/glext.h:6440
PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC = CFUNCTYPE(None, GLenum, POINTER(GLint), POINTER(GLsizei), GLsizei) 	# GL/glext.h:6441
PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, POINTER(GLint), POINTER(GLsizei), GLsizei) 	# GL/glext.h:6442
# APPLE_fence (GL/glext.h:6445)
GL_APPLE_fence = 1 	# GL/glext.h:6446
# GL/glext.h:6448
glGenFencesAPPLE = _link_function('glGenFencesAPPLE', None, [GLsizei, POINTER(GLuint)], 'APPLE_fence')

# GL/glext.h:6449
glDeleteFencesAPPLE = _link_function('glDeleteFencesAPPLE', None, [GLsizei, POINTER(GLuint)], 'APPLE_fence')

# GL/glext.h:6450
glSetFenceAPPLE = _link_function('glSetFenceAPPLE', None, [GLuint], 'APPLE_fence')

# GL/glext.h:6451
glIsFenceAPPLE = _link_function('glIsFenceAPPLE', GLboolean, [GLuint], 'APPLE_fence')

# GL/glext.h:6452
glTestFenceAPPLE = _link_function('glTestFenceAPPLE', GLboolean, [GLuint], 'APPLE_fence')

# GL/glext.h:6453
glFinishFenceAPPLE = _link_function('glFinishFenceAPPLE', None, [GLuint], 'APPLE_fence')

# GL/glext.h:6454
glTestObjectAPPLE = _link_function('glTestObjectAPPLE', GLboolean, [GLenum, GLuint], 'APPLE_fence')

# GL/glext.h:6455
glFinishObjectAPPLE = _link_function('glFinishObjectAPPLE', None, [GLenum, GLint], 'APPLE_fence')

PFNGLGENFENCESAPPLEPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6457
PFNGLDELETEFENCESAPPLEPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6458
PFNGLSETFENCEAPPLEPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6459
PFNGLISFENCEAPPLEPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:6460
PFNGLTESTFENCEAPPLEPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:6461
PFNGLFINISHFENCEAPPLEPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6462
PFNGLTESTOBJECTAPPLEPROC = CFUNCTYPE(GLboolean, GLenum, GLuint) 	# GL/glext.h:6463
PFNGLFINISHOBJECTAPPLEPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:6464
# APPLE_vertex_array_object (GL/glext.h:6467)
GL_APPLE_vertex_array_object = 1 	# GL/glext.h:6468
# GL/glext.h:6470
glBindVertexArrayAPPLE = _link_function('glBindVertexArrayAPPLE', None, [GLuint], 'APPLE_vertex_array_object')

# GL/glext.h:6471
glDeleteVertexArraysAPPLE = _link_function('glDeleteVertexArraysAPPLE', None, [GLsizei, POINTER(GLuint)], 'APPLE_vertex_array_object')

# GL/glext.h:6472
glGenVertexArraysAPPLE = _link_function('glGenVertexArraysAPPLE', None, [GLsizei, POINTER(GLuint)], 'APPLE_vertex_array_object')

# GL/glext.h:6473
glIsVertexArrayAPPLE = _link_function('glIsVertexArrayAPPLE', GLboolean, [GLuint], 'APPLE_vertex_array_object')

PFNGLBINDVERTEXARRAYAPPLEPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6475
PFNGLDELETEVERTEXARRAYSAPPLEPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6476
PFNGLGENVERTEXARRAYSAPPLEPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6477
PFNGLISVERTEXARRAYAPPLEPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:6478
# APPLE_vertex_array_range (GL/glext.h:6481)
GL_APPLE_vertex_array_range = 1 	# GL/glext.h:6482
# GL/glext.h:6484
glVertexArrayRangeAPPLE = _link_function('glVertexArrayRangeAPPLE', None, [GLsizei, POINTER(GLvoid)], 'APPLE_vertex_array_range')

# GL/glext.h:6485
glFlushVertexArrayRangeAPPLE = _link_function('glFlushVertexArrayRangeAPPLE', None, [GLsizei, POINTER(GLvoid)], 'APPLE_vertex_array_range')

# GL/glext.h:6486
glVertexArrayParameteriAPPLE = _link_function('glVertexArrayParameteriAPPLE', None, [GLenum, GLint], 'APPLE_vertex_array_range')

PFNGLVERTEXARRAYRANGEAPPLEPROC = CFUNCTYPE(None, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:6488
PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC = CFUNCTYPE(None, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:6489
PFNGLVERTEXARRAYPARAMETERIAPPLEPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:6490
# APPLE_ycbcr_422 (GL/glext.h:6493)
GL_APPLE_ycbcr_422 = 1 	# GL/glext.h:6494
# S3_s3tc (GL/glext.h:6497)
GL_S3_s3tc = 1 	# GL/glext.h:6498
# ATI_draw_buffers (GL/glext.h:6501)
GL_ATI_draw_buffers = 1 	# GL/glext.h:6502
# GL/glext.h:6504
glDrawBuffersATI = _link_function('glDrawBuffersATI', None, [GLsizei, POINTER(GLenum)], 'ATI_draw_buffers')

PFNGLDRAWBUFFERSATIPROC = CFUNCTYPE(None, GLsizei, POINTER(GLenum)) 	# GL/glext.h:6506
# ATI_pixel_format_float (GL/glext.h:6509)
GL_ATI_pixel_format_float = 1 	# GL/glext.h:6510
# ATI_texture_env_combine3 (GL/glext.h:6516)
GL_ATI_texture_env_combine3 = 1 	# GL/glext.h:6517
# ATI_texture_float (GL/glext.h:6520)
GL_ATI_texture_float = 1 	# GL/glext.h:6521
# NV_float_buffer (GL/glext.h:6524)
GL_NV_float_buffer = 1 	# GL/glext.h:6525
# NV_fragment_program (GL/glext.h:6528)
GL_NV_fragment_program = 1 	# GL/glext.h:6529
# GL/glext.h:6532
glProgramNamedParameter4fNV = _link_function('glProgramNamedParameter4fNV', None, [GLuint, GLsizei, POINTER(GLubyte), GLfloat, GLfloat, GLfloat, GLfloat], 'NV_fragment_program')

# GL/glext.h:6533
glProgramNamedParameter4dNV = _link_function('glProgramNamedParameter4dNV', None, [GLuint, GLsizei, POINTER(GLubyte), GLdouble, GLdouble, GLdouble, GLdouble], 'NV_fragment_program')

# GL/glext.h:6534
glProgramNamedParameter4fvNV = _link_function('glProgramNamedParameter4fvNV', None, [GLuint, GLsizei, POINTER(GLubyte), POINTER(GLfloat)], 'NV_fragment_program')

# GL/glext.h:6535
glProgramNamedParameter4dvNV = _link_function('glProgramNamedParameter4dvNV', None, [GLuint, GLsizei, POINTER(GLubyte), POINTER(GLdouble)], 'NV_fragment_program')

# GL/glext.h:6536
glGetProgramNamedParameterfvNV = _link_function('glGetProgramNamedParameterfvNV', None, [GLuint, GLsizei, POINTER(GLubyte), POINTER(GLfloat)], 'NV_fragment_program')

# GL/glext.h:6537
glGetProgramNamedParameterdvNV = _link_function('glGetProgramNamedParameterdvNV', None, [GLuint, GLsizei, POINTER(GLubyte), POINTER(GLdouble)], 'NV_fragment_program')

PFNGLPROGRAMNAMEDPARAMETER4FNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLubyte), GLfloat, GLfloat, GLfloat, GLfloat) 	# GL/glext.h:6539
PFNGLPROGRAMNAMEDPARAMETER4DNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLubyte), GLdouble, GLdouble, GLdouble, GLdouble) 	# GL/glext.h:6540
PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLubyte), POINTER(GLfloat)) 	# GL/glext.h:6541
PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLubyte), POINTER(GLdouble)) 	# GL/glext.h:6542
PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLubyte), POINTER(GLfloat)) 	# GL/glext.h:6543
PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLubyte), POINTER(GLdouble)) 	# GL/glext.h:6544
# NV_half_float (GL/glext.h:6547)
GL_NV_half_float = 1 	# GL/glext.h:6548
# GL/glext.h:6550
glVertex2hNV = _link_function('glVertex2hNV', None, [GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6551
glVertex2hvNV = _link_function('glVertex2hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6552
glVertex3hNV = _link_function('glVertex3hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6553
glVertex3hvNV = _link_function('glVertex3hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6554
glVertex4hNV = _link_function('glVertex4hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6555
glVertex4hvNV = _link_function('glVertex4hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6556
glNormal3hNV = _link_function('glNormal3hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6557
glNormal3hvNV = _link_function('glNormal3hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6558
glColor3hNV = _link_function('glColor3hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6559
glColor3hvNV = _link_function('glColor3hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6560
glColor4hNV = _link_function('glColor4hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6561
glColor4hvNV = _link_function('glColor4hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6562
glTexCoord1hNV = _link_function('glTexCoord1hNV', None, [GLhalfNV], 'NV_half_float')

# GL/glext.h:6563
glTexCoord1hvNV = _link_function('glTexCoord1hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6564
glTexCoord2hNV = _link_function('glTexCoord2hNV', None, [GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6565
glTexCoord2hvNV = _link_function('glTexCoord2hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6566
glTexCoord3hNV = _link_function('glTexCoord3hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6567
glTexCoord3hvNV = _link_function('glTexCoord3hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6568
glTexCoord4hNV = _link_function('glTexCoord4hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6569
glTexCoord4hvNV = _link_function('glTexCoord4hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6570
glMultiTexCoord1hNV = _link_function('glMultiTexCoord1hNV', None, [GLenum, GLhalfNV], 'NV_half_float')

# GL/glext.h:6571
glMultiTexCoord1hvNV = _link_function('glMultiTexCoord1hvNV', None, [GLenum, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6572
glMultiTexCoord2hNV = _link_function('glMultiTexCoord2hNV', None, [GLenum, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6573
glMultiTexCoord2hvNV = _link_function('glMultiTexCoord2hvNV', None, [GLenum, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6574
glMultiTexCoord3hNV = _link_function('glMultiTexCoord3hNV', None, [GLenum, GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6575
glMultiTexCoord3hvNV = _link_function('glMultiTexCoord3hvNV', None, [GLenum, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6576
glMultiTexCoord4hNV = _link_function('glMultiTexCoord4hNV', None, [GLenum, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6577
glMultiTexCoord4hvNV = _link_function('glMultiTexCoord4hvNV', None, [GLenum, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6578
glFogCoordhNV = _link_function('glFogCoordhNV', None, [GLhalfNV], 'NV_half_float')

# GL/glext.h:6579
glFogCoordhvNV = _link_function('glFogCoordhvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6580
glSecondaryColor3hNV = _link_function('glSecondaryColor3hNV', None, [GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6581
glSecondaryColor3hvNV = _link_function('glSecondaryColor3hvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6582
glVertexWeighthNV = _link_function('glVertexWeighthNV', None, [GLhalfNV], 'NV_half_float')

# GL/glext.h:6583
glVertexWeighthvNV = _link_function('glVertexWeighthvNV', None, [POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6584
glVertexAttrib1hNV = _link_function('glVertexAttrib1hNV', None, [GLuint, GLhalfNV], 'NV_half_float')

# GL/glext.h:6585
glVertexAttrib1hvNV = _link_function('glVertexAttrib1hvNV', None, [GLuint, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6586
glVertexAttrib2hNV = _link_function('glVertexAttrib2hNV', None, [GLuint, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6587
glVertexAttrib2hvNV = _link_function('glVertexAttrib2hvNV', None, [GLuint, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6588
glVertexAttrib3hNV = _link_function('glVertexAttrib3hNV', None, [GLuint, GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6589
glVertexAttrib3hvNV = _link_function('glVertexAttrib3hvNV', None, [GLuint, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6590
glVertexAttrib4hNV = _link_function('glVertexAttrib4hNV', None, [GLuint, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV], 'NV_half_float')

# GL/glext.h:6591
glVertexAttrib4hvNV = _link_function('glVertexAttrib4hvNV', None, [GLuint, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6592
glVertexAttribs1hvNV = _link_function('glVertexAttribs1hvNV', None, [GLuint, GLsizei, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6593
glVertexAttribs2hvNV = _link_function('glVertexAttribs2hvNV', None, [GLuint, GLsizei, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6594
glVertexAttribs3hvNV = _link_function('glVertexAttribs3hvNV', None, [GLuint, GLsizei, POINTER(GLhalfNV)], 'NV_half_float')

# GL/glext.h:6595
glVertexAttribs4hvNV = _link_function('glVertexAttribs4hvNV', None, [GLuint, GLsizei, POINTER(GLhalfNV)], 'NV_half_float')

PFNGLVERTEX2HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV) 	# GL/glext.h:6597
PFNGLVERTEX2HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6598
PFNGLVERTEX3HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6599
PFNGLVERTEX3HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6600
PFNGLVERTEX4HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6601
PFNGLVERTEX4HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6602
PFNGLNORMAL3HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6603
PFNGLNORMAL3HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6604
PFNGLCOLOR3HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6605
PFNGLCOLOR3HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6606
PFNGLCOLOR4HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6607
PFNGLCOLOR4HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6608
PFNGLTEXCOORD1HNVPROC = CFUNCTYPE(None, GLhalfNV) 	# GL/glext.h:6609
PFNGLTEXCOORD1HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6610
PFNGLTEXCOORD2HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV) 	# GL/glext.h:6611
PFNGLTEXCOORD2HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6612
PFNGLTEXCOORD3HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6613
PFNGLTEXCOORD3HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6614
PFNGLTEXCOORD4HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6615
PFNGLTEXCOORD4HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6616
PFNGLMULTITEXCOORD1HNVPROC = CFUNCTYPE(None, GLenum, GLhalfNV) 	# GL/glext.h:6617
PFNGLMULTITEXCOORD1HVNVPROC = CFUNCTYPE(None, GLenum, POINTER(GLhalfNV)) 	# GL/glext.h:6618
PFNGLMULTITEXCOORD2HNVPROC = CFUNCTYPE(None, GLenum, GLhalfNV, GLhalfNV) 	# GL/glext.h:6619
PFNGLMULTITEXCOORD2HVNVPROC = CFUNCTYPE(None, GLenum, POINTER(GLhalfNV)) 	# GL/glext.h:6620
PFNGLMULTITEXCOORD3HNVPROC = CFUNCTYPE(None, GLenum, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6621
PFNGLMULTITEXCOORD3HVNVPROC = CFUNCTYPE(None, GLenum, POINTER(GLhalfNV)) 	# GL/glext.h:6622
PFNGLMULTITEXCOORD4HNVPROC = CFUNCTYPE(None, GLenum, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6623
PFNGLMULTITEXCOORD4HVNVPROC = CFUNCTYPE(None, GLenum, POINTER(GLhalfNV)) 	# GL/glext.h:6624
PFNGLFOGCOORDHNVPROC = CFUNCTYPE(None, GLhalfNV) 	# GL/glext.h:6625
PFNGLFOGCOORDHVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6626
PFNGLSECONDARYCOLOR3HNVPROC = CFUNCTYPE(None, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6627
PFNGLSECONDARYCOLOR3HVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6628
PFNGLVERTEXWEIGHTHNVPROC = CFUNCTYPE(None, GLhalfNV) 	# GL/glext.h:6629
PFNGLVERTEXWEIGHTHVNVPROC = CFUNCTYPE(None, POINTER(GLhalfNV)) 	# GL/glext.h:6630
PFNGLVERTEXATTRIB1HNVPROC = CFUNCTYPE(None, GLuint, GLhalfNV) 	# GL/glext.h:6631
PFNGLVERTEXATTRIB1HVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLhalfNV)) 	# GL/glext.h:6632
PFNGLVERTEXATTRIB2HNVPROC = CFUNCTYPE(None, GLuint, GLhalfNV, GLhalfNV) 	# GL/glext.h:6633
PFNGLVERTEXATTRIB2HVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLhalfNV)) 	# GL/glext.h:6634
PFNGLVERTEXATTRIB3HNVPROC = CFUNCTYPE(None, GLuint, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6635
PFNGLVERTEXATTRIB3HVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLhalfNV)) 	# GL/glext.h:6636
PFNGLVERTEXATTRIB4HNVPROC = CFUNCTYPE(None, GLuint, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV) 	# GL/glext.h:6637
PFNGLVERTEXATTRIB4HVNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLhalfNV)) 	# GL/glext.h:6638
PFNGLVERTEXATTRIBS1HVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLhalfNV)) 	# GL/glext.h:6639
PFNGLVERTEXATTRIBS2HVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLhalfNV)) 	# GL/glext.h:6640
PFNGLVERTEXATTRIBS3HVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLhalfNV)) 	# GL/glext.h:6641
PFNGLVERTEXATTRIBS4HVNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLhalfNV)) 	# GL/glext.h:6642
# NV_pixel_data_range (GL/glext.h:6645)
GL_NV_pixel_data_range = 1 	# GL/glext.h:6646
# GL/glext.h:6648
glPixelDataRangeNV = _link_function('glPixelDataRangeNV', None, [GLenum, GLsizei, POINTER(GLvoid)], 'NV_pixel_data_range')

# GL/glext.h:6649
glFlushPixelDataRangeNV = _link_function('glFlushPixelDataRangeNV', None, [GLenum], 'NV_pixel_data_range')

PFNGLPIXELDATARANGENVPROC = CFUNCTYPE(None, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:6651
PFNGLFLUSHPIXELDATARANGENVPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:6652
# NV_primitive_restart (GL/glext.h:6655)
GL_NV_primitive_restart = 1 	# GL/glext.h:6656
# GL/glext.h:6658
glPrimitiveRestartNV = _link_function('glPrimitiveRestartNV', None, [], 'NV_primitive_restart')

# GL/glext.h:6659
glPrimitiveRestartIndexNV = _link_function('glPrimitiveRestartIndexNV', None, [GLuint], 'NV_primitive_restart')

PFNGLPRIMITIVERESTARTNVPROC = CFUNCTYPE(None) 	# GL/glext.h:6661
PFNGLPRIMITIVERESTARTINDEXNVPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6662
# NV_texture_expand_normal (GL/glext.h:6665)
GL_NV_texture_expand_normal = 1 	# GL/glext.h:6666
# NV_vertex_program2 (GL/glext.h:6669)
GL_NV_vertex_program2 = 1 	# GL/glext.h:6670
# ATI_map_object_buffer (GL/glext.h:6673)
GL_ATI_map_object_buffer = 1 	# GL/glext.h:6674
# GL/glext.h:6676
glMapObjectBufferATI = _link_function('glMapObjectBufferATI', POINTER(GLvoid), [GLuint], 'ATI_map_object_buffer')

# GL/glext.h:6677
glUnmapObjectBufferATI = _link_function('glUnmapObjectBufferATI', None, [GLuint], 'ATI_map_object_buffer')

PFNGLMAPOBJECTBUFFERATIPROC = CFUNCTYPE(POINTER(GLvoid), GLuint) 	# GL/glext.h:6679
PFNGLUNMAPOBJECTBUFFERATIPROC = CFUNCTYPE(None, GLuint) 	# GL/glext.h:6680
# ATI_separate_stencil (GL/glext.h:6683)
GL_ATI_separate_stencil = 1 	# GL/glext.h:6684
# GL/glext.h:6686
glStencilOpSeparateATI = _link_function('glStencilOpSeparateATI', None, [GLenum, GLenum, GLenum, GLenum], 'ATI_separate_stencil')

# GL/glext.h:6687
glStencilFuncSeparateATI = _link_function('glStencilFuncSeparateATI', None, [GLenum, GLenum, GLint, GLuint], 'ATI_separate_stencil')

PFNGLSTENCILOPSEPARATEATIPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLenum) 	# GL/glext.h:6689
PFNGLSTENCILFUNCSEPARATEATIPROC = CFUNCTYPE(None, GLenum, GLenum, GLint, GLuint) 	# GL/glext.h:6690
# ATI_vertex_attrib_array_object (GL/glext.h:6693)
GL_ATI_vertex_attrib_array_object = 1 	# GL/glext.h:6694
# GL/glext.h:6696
glVertexAttribArrayObjectATI = _link_function('glVertexAttribArrayObjectATI', None, [GLuint, GLint, GLenum, GLboolean, GLsizei, GLuint, GLuint], 'ATI_vertex_attrib_array_object')

# GL/glext.h:6697
glGetVertexAttribArrayObjectfvATI = _link_function('glGetVertexAttribArrayObjectfvATI', None, [GLuint, GLenum, POINTER(GLfloat)], 'ATI_vertex_attrib_array_object')

# GL/glext.h:6698
glGetVertexAttribArrayObjectivATI = _link_function('glGetVertexAttribArrayObjectivATI', None, [GLuint, GLenum, POINTER(GLint)], 'ATI_vertex_attrib_array_object')

PFNGLVERTEXATTRIBARRAYOBJECTATIPROC = CFUNCTYPE(None, GLuint, GLint, GLenum, GLboolean, GLsizei, GLuint, GLuint) 	# GL/glext.h:6700
PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLfloat)) 	# GL/glext.h:6701
PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:6702
# OES_read_format (GL/glext.h:6705)
GL_OES_read_format = 1 	# GL/glext.h:6706
# EXT_depth_bounds_test (GL/glext.h:6709)
GL_EXT_depth_bounds_test = 1 	# GL/glext.h:6710
GLclampd = c_double 	# /usr/include/GL/gl.h:66
# GL/glext.h:6712
glDepthBoundsEXT = _link_function('glDepthBoundsEXT', None, [GLclampd, GLclampd], 'EXT_depth_bounds_test')

PFNGLDEPTHBOUNDSEXTPROC = CFUNCTYPE(None, GLclampd, GLclampd) 	# GL/glext.h:6714
# EXT_texture_mirror_clamp (GL/glext.h:6717)
GL_EXT_texture_mirror_clamp = 1 	# GL/glext.h:6718
# EXT_blend_equation_separate (GL/glext.h:6721)
GL_EXT_blend_equation_separate = 1 	# GL/glext.h:6722
# GL/glext.h:6724
glBlendEquationSeparateEXT = _link_function('glBlendEquationSeparateEXT', None, [GLenum, GLenum], 'EXT_blend_equation_separate')

PFNGLBLENDEQUATIONSEPARATEEXTPROC = CFUNCTYPE(None, GLenum, GLenum) 	# GL/glext.h:6726
# MESA_pack_invert (GL/glext.h:6729)
GL_MESA_pack_invert = 1 	# GL/glext.h:6730
# MESA_ycbcr_texture (GL/glext.h:6733)
GL_MESA_ycbcr_texture = 1 	# GL/glext.h:6734
# EXT_pixel_buffer_object (GL/glext.h:6737)
GL_EXT_pixel_buffer_object = 1 	# GL/glext.h:6738
# NV_fragment_program_option (GL/glext.h:6741)
GL_NV_fragment_program_option = 1 	# GL/glext.h:6742
# NV_fragment_program2 (GL/glext.h:6745)
GL_NV_fragment_program2 = 1 	# GL/glext.h:6746
# NV_vertex_program2_option (GL/glext.h:6749)
GL_NV_vertex_program2_option = 1 	# GL/glext.h:6750
# NV_vertex_program3 (GL/glext.h:6753)
GL_NV_vertex_program3 = 1 	# GL/glext.h:6754
# EXT_framebuffer_object (GL/glext.h:6757)
GL_EXT_framebuffer_object = 1 	# GL/glext.h:6758
# GL/glext.h:6760
glIsRenderbufferEXT = _link_function('glIsRenderbufferEXT', GLboolean, [GLuint], 'EXT_framebuffer_object')

# GL/glext.h:6761
glBindRenderbufferEXT = _link_function('glBindRenderbufferEXT', None, [GLenum, GLuint], 'EXT_framebuffer_object')

# GL/glext.h:6762
glDeleteRenderbuffersEXT = _link_function('glDeleteRenderbuffersEXT', None, [GLsizei, POINTER(GLuint)], 'EXT_framebuffer_object')

# GL/glext.h:6763
glGenRenderbuffersEXT = _link_function('glGenRenderbuffersEXT', None, [GLsizei, POINTER(GLuint)], 'EXT_framebuffer_object')

# GL/glext.h:6764
glRenderbufferStorageEXT = _link_function('glRenderbufferStorageEXT', None, [GLenum, GLenum, GLsizei, GLsizei], 'EXT_framebuffer_object')

# GL/glext.h:6765
glGetRenderbufferParameterivEXT = _link_function('glGetRenderbufferParameterivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_framebuffer_object')

# GL/glext.h:6766
glIsFramebufferEXT = _link_function('glIsFramebufferEXT', GLboolean, [GLuint], 'EXT_framebuffer_object')

# GL/glext.h:6767
glBindFramebufferEXT = _link_function('glBindFramebufferEXT', None, [GLenum, GLuint], 'EXT_framebuffer_object')

# GL/glext.h:6768
glDeleteFramebuffersEXT = _link_function('glDeleteFramebuffersEXT', None, [GLsizei, POINTER(GLuint)], 'EXT_framebuffer_object')

# GL/glext.h:6769
glGenFramebuffersEXT = _link_function('glGenFramebuffersEXT', None, [GLsizei, POINTER(GLuint)], 'EXT_framebuffer_object')

# GL/glext.h:6770
glCheckFramebufferStatusEXT = _link_function('glCheckFramebufferStatusEXT', GLenum, [GLenum], 'EXT_framebuffer_object')

# GL/glext.h:6771
glFramebufferTexture1DEXT = _link_function('glFramebufferTexture1DEXT', None, [GLenum, GLenum, GLenum, GLuint, GLint], 'EXT_framebuffer_object')

# GL/glext.h:6772
glFramebufferTexture2DEXT = _link_function('glFramebufferTexture2DEXT', None, [GLenum, GLenum, GLenum, GLuint, GLint], 'EXT_framebuffer_object')

# GL/glext.h:6773
glFramebufferTexture3DEXT = _link_function('glFramebufferTexture3DEXT', None, [GLenum, GLenum, GLenum, GLuint, GLint, GLint], 'EXT_framebuffer_object')

# GL/glext.h:6774
glFramebufferRenderbufferEXT = _link_function('glFramebufferRenderbufferEXT', None, [GLenum, GLenum, GLenum, GLuint], 'EXT_framebuffer_object')

# GL/glext.h:6775
glGetFramebufferAttachmentParameterivEXT = _link_function('glGetFramebufferAttachmentParameterivEXT', None, [GLenum, GLenum, GLenum, POINTER(GLint)], 'EXT_framebuffer_object')

# GL/glext.h:6776
glGenerateMipmapEXT = _link_function('glGenerateMipmapEXT', None, [GLenum], 'EXT_framebuffer_object')

PFNGLISRENDERBUFFEREXTPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:6778
PFNGLBINDRENDERBUFFEREXTPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:6779
PFNGLDELETERENDERBUFFERSEXTPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6780
PFNGLGENRENDERBUFFERSEXTPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6781
PFNGLRENDERBUFFERSTORAGEEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLsizei, GLsizei) 	# GL/glext.h:6782
PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:6783
PFNGLISFRAMEBUFFEREXTPROC = CFUNCTYPE(GLboolean, GLuint) 	# GL/glext.h:6784
PFNGLBINDFRAMEBUFFEREXTPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:6785
PFNGLDELETEFRAMEBUFFERSEXTPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6786
PFNGLGENFRAMEBUFFERSEXTPROC = CFUNCTYPE(None, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6787
PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC = CFUNCTYPE(GLenum, GLenum) 	# GL/glext.h:6788
PFNGLFRAMEBUFFERTEXTURE1DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLuint, GLint) 	# GL/glext.h:6789
PFNGLFRAMEBUFFERTEXTURE2DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLuint, GLint) 	# GL/glext.h:6790
PFNGLFRAMEBUFFERTEXTURE3DEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLuint, GLint, GLint) 	# GL/glext.h:6791
PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, GLuint) 	# GL/glext.h:6792
PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:6793
PFNGLGENERATEMIPMAPEXTPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:6794
# GREMEDY_string_marker (GL/glext.h:6797)
GL_GREMEDY_string_marker = 1 	# GL/glext.h:6798
# GL/glext.h:6800
glStringMarkerGREMEDY = _link_function('glStringMarkerGREMEDY', None, [GLsizei, POINTER(GLvoid)], 'GREMEDY_string_marker')

PFNGLSTRINGMARKERGREMEDYPROC = CFUNCTYPE(None, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:6802
# EXT_Cg_shader (GL/glext.h:6805)
GL_EXT_Cg_shader = 1 	# GL/glext.h:6806
# EXT_timer_query (GL/glext.h:6809)
GL_EXT_timer_query = 1 	# GL/glext.h:6810
# GL/glext.h:6812
glGetQueryObjecti64vEXT = _link_function('glGetQueryObjecti64vEXT', None, [GLuint, GLenum, POINTER(GLint64EXT)], 'EXT_timer_query')

# GL/glext.h:6813
glGetQueryObjectui64vEXT = _link_function('glGetQueryObjectui64vEXT', None, [GLuint, GLenum, POINTER(GLuint64EXT)], 'EXT_timer_query')

PFNGLGETQUERYOBJECTI64VEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint64EXT)) 	# GL/glext.h:6815
PFNGLGETQUERYOBJECTUI64VEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLuint64EXT)) 	# GL/glext.h:6816
# EXT_texture_buffer_object (GL/glext.h:6819)
GL_EXT_texture_buffer_object = 1 	# GL/glext.h:6820
# GL/glext.h:6822
glTexBufferEXT = _link_function('glTexBufferEXT', None, [GLenum, GLenum, GLuint], 'EXT_texture_buffer_object')

PFNGLTEXBUFFEREXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLuint) 	# GL/glext.h:6824
# NV_transform_feedback (GL/glext.h:6827)
GL_NV_transform_feedback = 1 	# GL/glext.h:6828
# GL/glext.h:6830
glBeginTransformFeedbackNV = _link_function('glBeginTransformFeedbackNV', None, [GLenum], 'NV_transform_feedback')

# GL/glext.h:6831
glEndTransformFeedbackNV = _link_function('glEndTransformFeedbackNV', None, [], 'NV_transform_feedback')

# GL/glext.h:6832
glTransformFeedbackAttribsNV = _link_function('glTransformFeedbackAttribsNV', None, [GLuint, POINTER(GLint), GLenum], 'NV_transform_feedback')

# GL/glext.h:6833
glBindBufferRangeNV = _link_function('glBindBufferRangeNV', None, [GLenum, GLuint, GLuint, GLintptr, GLsizeiptr], 'NV_transform_feedback')

# GL/glext.h:6834
glBindBufferOffsetNV = _link_function('glBindBufferOffsetNV', None, [GLenum, GLuint, GLuint, GLintptr], 'NV_transform_feedback')

# GL/glext.h:6835
glBindBufferBaseNV = _link_function('glBindBufferBaseNV', None, [GLenum, GLuint, GLuint], 'NV_transform_feedback')

# GL/glext.h:6836
glTransformFeedbackVaryingsNV = _link_function('glTransformFeedbackVaryingsNV', None, [GLuint, GLsizei, POINTER(GLint), GLenum], 'NV_transform_feedback')

# GL/glext.h:6837
glActiveVaryingNV = _link_function('glActiveVaryingNV', None, [GLuint, POINTER(GLchar)], 'NV_transform_feedback')

# GL/glext.h:6838
glGetVaryingLocationNV = _link_function('glGetVaryingLocationNV', GLint, [GLuint, POINTER(GLchar)], 'NV_transform_feedback')

# GL/glext.h:6839
glGetActiveVaryingNV = _link_function('glGetActiveVaryingNV', None, [GLuint, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLsizei), POINTER(GLenum), POINTER(GLchar)], 'NV_transform_feedback')

# GL/glext.h:6840
glGetTransformFeedbackVaryingNV = _link_function('glGetTransformFeedbackVaryingNV', None, [GLuint, GLuint, POINTER(GLint)], 'NV_transform_feedback')

PFNGLBEGINTRANSFORMFEEDBACKNVPROC = CFUNCTYPE(None, GLenum) 	# GL/glext.h:6842
PFNGLENDTRANSFORMFEEDBACKNVPROC = CFUNCTYPE(None) 	# GL/glext.h:6843
PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLint), GLenum) 	# GL/glext.h:6844
PFNGLBINDBUFFERRANGENVPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLintptr, GLsizeiptr) 	# GL/glext.h:6845
PFNGLBINDBUFFEROFFSETNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLintptr) 	# GL/glext.h:6846
PFNGLBINDBUFFERBASENVPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint) 	# GL/glext.h:6847
PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC = CFUNCTYPE(None, GLuint, GLsizei, POINTER(GLint), GLenum) 	# GL/glext.h:6848
PFNGLACTIVEVARYINGNVPROC = CFUNCTYPE(None, GLuint, POINTER(GLchar)) 	# GL/glext.h:6849
PFNGLGETVARYINGLOCATIONNVPROC = CFUNCTYPE(GLint, GLuint, POINTER(GLchar)) 	# GL/glext.h:6850
PFNGLGETACTIVEVARYINGNVPROC = CFUNCTYPE(None, GLuint, GLuint, GLsizei, POINTER(GLsizei), POINTER(GLsizei), POINTER(GLenum), POINTER(GLchar)) 	# GL/glext.h:6851
PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC = CFUNCTYPE(None, GLuint, GLuint, POINTER(GLint)) 	# GL/glext.h:6852
# NV_depth_buffer_float (GL/glext.h:6856)
GL_NV_depth_buffer_float = 1 	# GL/glext.h:6857
# GL/glext.h:6859
glDepthRangedNV = _link_function('glDepthRangedNV', None, [GLdouble, GLdouble], 'NV_depth_buffer_float')

# GL/glext.h:6860
glClearDepthdNV = _link_function('glClearDepthdNV', None, [GLdouble], 'NV_depth_buffer_float')

# GL/glext.h:6861
glDepthBoundsdNV = _link_function('glDepthBoundsdNV', None, [GLdouble, GLdouble], 'NV_depth_buffer_float')

PFNGLDEPTHRANGEDNVPROC = CFUNCTYPE(None, GLdouble, GLdouble) 	# GL/glext.h:6863
PFNGLCLEARDEPTHDNVPROC = CFUNCTYPE(None, GLdouble) 	# GL/glext.h:6864
PFNGLDEPTHBOUNDSDNVPROC = CFUNCTYPE(None, GLdouble, GLdouble) 	# GL/glext.h:6865
# EXT_texture_compression_latc (GL/glext.h:6868)
GL_EXT_texture_compression_latc = 1 	# GL/glext.h:6869
# EXT_framebuffer_sRGB (GL/glext.h:6872)
GL_EXT_framebuffer_sRGB = 1 	# GL/glext.h:6873
# EXT_texture_shared_exponent (GL/glext.h:6876)
GL_EXT_texture_shared_exponent = 1 	# GL/glext.h:6877
# EXT_packed_float (GL/glext.h:6880)
GL_EXT_packed_float = 1 	# GL/glext.h:6881
# EXT_texture_array (GL/glext.h:6884)
GL_EXT_texture_array = 1 	# GL/glext.h:6885
# EXT_draw_buffers2 (GL/glext.h:6888)
GL_EXT_draw_buffers2 = 1 	# GL/glext.h:6889
# GL/glext.h:6891
glColorMaskIndexedEXT = _link_function('glColorMaskIndexedEXT', None, [GLuint, GLboolean, GLboolean, GLboolean, GLboolean], 'EXT_draw_buffers2')

# GL/glext.h:6892
glGetBooleanIndexedvEXT = _link_function('glGetBooleanIndexedvEXT', None, [GLenum, GLuint, POINTER(GLboolean)], 'EXT_draw_buffers2')

# GL/glext.h:6893
glGetIntegerIndexedvEXT = _link_function('glGetIntegerIndexedvEXT', None, [GLenum, GLuint, POINTER(GLint)], 'EXT_draw_buffers2')

# GL/glext.h:6894
glEnableIndexedEXT = _link_function('glEnableIndexedEXT', None, [GLenum, GLuint], 'EXT_draw_buffers2')

# GL/glext.h:6895
glDisableIndexedEXT = _link_function('glDisableIndexedEXT', None, [GLenum, GLuint], 'EXT_draw_buffers2')

# GL/glext.h:6896
glIsEnabledIndexedEXT = _link_function('glIsEnabledIndexedEXT', GLboolean, [GLenum, GLuint], 'EXT_draw_buffers2')

PFNGLCOLORMASKINDEXEDEXTPROC = CFUNCTYPE(None, GLuint, GLboolean, GLboolean, GLboolean, GLboolean) 	# GL/glext.h:6898
PFNGLGETBOOLEANINDEXEDVEXTPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLboolean)) 	# GL/glext.h:6899
PFNGLGETINTEGERINDEXEDVEXTPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLint)) 	# GL/glext.h:6900
PFNGLENABLEINDEXEDEXTPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:6901
PFNGLDISABLEINDEXEDEXTPROC = CFUNCTYPE(None, GLenum, GLuint) 	# GL/glext.h:6902
PFNGLISENABLEDINDEXEDEXTPROC = CFUNCTYPE(GLboolean, GLenum, GLuint) 	# GL/glext.h:6903
# EXT_texture_integer (GL/glext.h:6906)
GL_EXT_texture_integer = 1 	# GL/glext.h:6907
# GL/glext.h:6909
glTexParameterIivEXT = _link_function('glTexParameterIivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_texture_integer')

# GL/glext.h:6910
glTexParameterIuivEXT = _link_function('glTexParameterIuivEXT', None, [GLenum, GLenum, POINTER(GLuint)], 'EXT_texture_integer')

# GL/glext.h:6911
glGetTexParameterIivEXT = _link_function('glGetTexParameterIivEXT', None, [GLenum, GLenum, POINTER(GLint)], 'EXT_texture_integer')

# GL/glext.h:6912
glGetTexParameterIuivEXT = _link_function('glGetTexParameterIuivEXT', None, [GLenum, GLenum, POINTER(GLuint)], 'EXT_texture_integer')

# GL/glext.h:6913
glClearColorIiEXT = _link_function('glClearColorIiEXT', None, [GLint, GLint, GLint, GLint], 'EXT_texture_integer')

# GL/glext.h:6914
glClearColorIuiEXT = _link_function('glClearColorIuiEXT', None, [GLuint, GLuint, GLuint, GLuint], 'EXT_texture_integer')

PFNGLTEXPARAMETERIIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:6916
PFNGLTEXPARAMETERIUIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLuint)) 	# GL/glext.h:6917
PFNGLGETTEXPARAMETERIIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLint)) 	# GL/glext.h:6918
PFNGLGETTEXPARAMETERIUIVEXTPROC = CFUNCTYPE(None, GLenum, GLenum, POINTER(GLuint)) 	# GL/glext.h:6919
PFNGLCLEARCOLORIIEXTPROC = CFUNCTYPE(None, GLint, GLint, GLint, GLint) 	# GL/glext.h:6920
PFNGLCLEARCOLORIUIEXTPROC = CFUNCTYPE(None, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:6921
# EXT_bindable_uniform (GL/glext.h:6924)
GL_EXT_bindable_uniform = 1 	# GL/glext.h:6925
# GL/glext.h:6927
glUniformBufferEXT = _link_function('glUniformBufferEXT', None, [GLuint, GLint, GLuint], 'EXT_bindable_uniform')

# GL/glext.h:6928
glGetUniformBufferSizeEXT = _link_function('glGetUniformBufferSizeEXT', GLint, [GLuint, GLint], 'EXT_bindable_uniform')

# GL/glext.h:6929
glGetUniformOffsetEXT = _link_function('glGetUniformOffsetEXT', GLintptr, [GLuint, GLint], 'EXT_bindable_uniform')

PFNGLUNIFORMBUFFEREXTPROC = CFUNCTYPE(None, GLuint, GLint, GLuint) 	# GL/glext.h:6931
PFNGLGETUNIFORMBUFFERSIZEEXTPROC = CFUNCTYPE(GLint, GLuint, GLint) 	# GL/glext.h:6932
PFNGLGETUNIFORMOFFSETEXTPROC = CFUNCTYPE(GLintptr, GLuint, GLint) 	# GL/glext.h:6933
# EXT_gpu_shader4 (GL/glext.h:6936)
GL_EXT_gpu_shader4 = 1 	# GL/glext.h:6937
# GL/glext.h:6939
glGetUniformuivEXT = _link_function('glGetUniformuivEXT', None, [GLuint, GLint, POINTER(GLuint)], 'EXT_gpu_shader4')

# GL/glext.h:6940
glBindFragDataLocationEXT = _link_function('glBindFragDataLocationEXT', None, [GLuint, GLuint, POINTER(GLchar)], 'EXT_gpu_shader4')

# GL/glext.h:6941
glGetFragDataLocationEXT = _link_function('glGetFragDataLocationEXT', GLint, [GLuint, POINTER(GLchar)], 'EXT_gpu_shader4')

# GL/glext.h:6942
glUniform1uiEXT = _link_function('glUniform1uiEXT', None, [GLint, GLuint], 'EXT_gpu_shader4')

# GL/glext.h:6943
glUniform2uiEXT = _link_function('glUniform2uiEXT', None, [GLint, GLuint, GLuint], 'EXT_gpu_shader4')

# GL/glext.h:6944
glUniform3uiEXT = _link_function('glUniform3uiEXT', None, [GLint, GLuint, GLuint, GLuint], 'EXT_gpu_shader4')

# GL/glext.h:6945
glUniform4uiEXT = _link_function('glUniform4uiEXT', None, [GLint, GLuint, GLuint, GLuint, GLuint], 'EXT_gpu_shader4')

# GL/glext.h:6946
glUniform1uivEXT = _link_function('glUniform1uivEXT', None, [GLint, GLsizei, POINTER(GLuint)], 'EXT_gpu_shader4')

# GL/glext.h:6947
glUniform2uivEXT = _link_function('glUniform2uivEXT', None, [GLint, GLsizei, POINTER(GLuint)], 'EXT_gpu_shader4')

# GL/glext.h:6948
glUniform3uivEXT = _link_function('glUniform3uivEXT', None, [GLint, GLsizei, POINTER(GLuint)], 'EXT_gpu_shader4')

# GL/glext.h:6949
glUniform4uivEXT = _link_function('glUniform4uivEXT', None, [GLint, GLsizei, POINTER(GLuint)], 'EXT_gpu_shader4')

# GL/glext.h:6950
glVertexAttribI1iEXT = _link_function('glVertexAttribI1iEXT', None, [GLuint, GLint], 'EXT_gpu_shader4')

# GL/glext.h:6951
glVertexAttribI2iEXT = _link_function('glVertexAttribI2iEXT', None, [GLuint, GLint, GLint], 'EXT_gpu_shader4')

# GL/glext.h:6952
glVertexAttribI3iEXT = _link_function('glVertexAttribI3iEXT', None, [GLuint, GLint, GLint, GLint], 'EXT_gpu_shader4')

# GL/glext.h:6953
glVertexAttribI4iEXT = _link_function('glVertexAttribI4iEXT', None, [GLuint, GLint, GLint, GLint, GLint], 'EXT_gpu_shader4')

# GL/glext.h:6954
glVertexAttribI1uiEXT = _link_function('glVertexAttribI1uiEXT', None, [GLuint, GLuint], 'EXT_gpu_shader4')

# GL/glext.h:6955
glVertexAttribI2uiEXT = _link_function('glVertexAttribI2uiEXT', None, [GLuint, GLuint, GLuint], 'EXT_gpu_shader4')

# GL/glext.h:6956
glVertexAttribI3uiEXT = _link_function('glVertexAttribI3uiEXT', None, [GLuint, GLuint, GLuint, GLuint], 'EXT_gpu_shader4')

# GL/glext.h:6957
glVertexAttribI4uiEXT = _link_function('glVertexAttribI4uiEXT', None, [GLuint, GLuint, GLuint, GLuint, GLuint], 'EXT_gpu_shader4')

# GL/glext.h:6958
glVertexAttribI1ivEXT = _link_function('glVertexAttribI1ivEXT', None, [GLuint, POINTER(GLint)], 'EXT_gpu_shader4')

# GL/glext.h:6959
glVertexAttribI2ivEXT = _link_function('glVertexAttribI2ivEXT', None, [GLuint, POINTER(GLint)], 'EXT_gpu_shader4')

# GL/glext.h:6960
glVertexAttribI3ivEXT = _link_function('glVertexAttribI3ivEXT', None, [GLuint, POINTER(GLint)], 'EXT_gpu_shader4')

# GL/glext.h:6961
glVertexAttribI4ivEXT = _link_function('glVertexAttribI4ivEXT', None, [GLuint, POINTER(GLint)], 'EXT_gpu_shader4')

# GL/glext.h:6962
glVertexAttribI1uivEXT = _link_function('glVertexAttribI1uivEXT', None, [GLuint, POINTER(GLuint)], 'EXT_gpu_shader4')

# GL/glext.h:6963
glVertexAttribI2uivEXT = _link_function('glVertexAttribI2uivEXT', None, [GLuint, POINTER(GLuint)], 'EXT_gpu_shader4')

# GL/glext.h:6964
glVertexAttribI3uivEXT = _link_function('glVertexAttribI3uivEXT', None, [GLuint, POINTER(GLuint)], 'EXT_gpu_shader4')

# GL/glext.h:6965
glVertexAttribI4uivEXT = _link_function('glVertexAttribI4uivEXT', None, [GLuint, POINTER(GLuint)], 'EXT_gpu_shader4')

# GL/glext.h:6966
glVertexAttribI4bvEXT = _link_function('glVertexAttribI4bvEXT', None, [GLuint, POINTER(GLbyte)], 'EXT_gpu_shader4')

# GL/glext.h:6967
glVertexAttribI4svEXT = _link_function('glVertexAttribI4svEXT', None, [GLuint, POINTER(GLshort)], 'EXT_gpu_shader4')

# GL/glext.h:6968
glVertexAttribI4ubvEXT = _link_function('glVertexAttribI4ubvEXT', None, [GLuint, POINTER(GLubyte)], 'EXT_gpu_shader4')

# GL/glext.h:6969
glVertexAttribI4usvEXT = _link_function('glVertexAttribI4usvEXT', None, [GLuint, POINTER(GLushort)], 'EXT_gpu_shader4')

# GL/glext.h:6970
glVertexAttribIPointerEXT = _link_function('glVertexAttribIPointerEXT', None, [GLuint, GLint, GLenum, GLsizei, POINTER(GLvoid)], 'EXT_gpu_shader4')

# GL/glext.h:6971
glGetVertexAttribIivEXT = _link_function('glGetVertexAttribIivEXT', None, [GLuint, GLenum, POINTER(GLint)], 'EXT_gpu_shader4')

# GL/glext.h:6972
glGetVertexAttribIuivEXT = _link_function('glGetVertexAttribIuivEXT', None, [GLuint, GLenum, POINTER(GLuint)], 'EXT_gpu_shader4')

PFNGLGETUNIFORMUIVEXTPROC = CFUNCTYPE(None, GLuint, GLint, POINTER(GLuint)) 	# GL/glext.h:6974
PFNGLBINDFRAGDATALOCATIONEXTPROC = CFUNCTYPE(None, GLuint, GLuint, POINTER(GLchar)) 	# GL/glext.h:6975
PFNGLGETFRAGDATALOCATIONEXTPROC = CFUNCTYPE(GLint, GLuint, POINTER(GLchar)) 	# GL/glext.h:6976
PFNGLUNIFORM1UIEXTPROC = CFUNCTYPE(None, GLint, GLuint) 	# GL/glext.h:6977
PFNGLUNIFORM2UIEXTPROC = CFUNCTYPE(None, GLint, GLuint, GLuint) 	# GL/glext.h:6978
PFNGLUNIFORM3UIEXTPROC = CFUNCTYPE(None, GLint, GLuint, GLuint, GLuint) 	# GL/glext.h:6979
PFNGLUNIFORM4UIEXTPROC = CFUNCTYPE(None, GLint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:6980
PFNGLUNIFORM1UIVEXTPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6981
PFNGLUNIFORM2UIVEXTPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6982
PFNGLUNIFORM3UIVEXTPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6983
PFNGLUNIFORM4UIVEXTPROC = CFUNCTYPE(None, GLint, GLsizei, POINTER(GLuint)) 	# GL/glext.h:6984
PFNGLVERTEXATTRIBI1IEXTPROC = CFUNCTYPE(None, GLuint, GLint) 	# GL/glext.h:6985
PFNGLVERTEXATTRIBI2IEXTPROC = CFUNCTYPE(None, GLuint, GLint, GLint) 	# GL/glext.h:6986
PFNGLVERTEXATTRIBI3IEXTPROC = CFUNCTYPE(None, GLuint, GLint, GLint, GLint) 	# GL/glext.h:6987
PFNGLVERTEXATTRIBI4IEXTPROC = CFUNCTYPE(None, GLuint, GLint, GLint, GLint, GLint) 	# GL/glext.h:6988
PFNGLVERTEXATTRIBI1UIEXTPROC = CFUNCTYPE(None, GLuint, GLuint) 	# GL/glext.h:6989
PFNGLVERTEXATTRIBI2UIEXTPROC = CFUNCTYPE(None, GLuint, GLuint, GLuint) 	# GL/glext.h:6990
PFNGLVERTEXATTRIBI3UIEXTPROC = CFUNCTYPE(None, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:6991
PFNGLVERTEXATTRIBI4UIEXTPROC = CFUNCTYPE(None, GLuint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:6992
PFNGLVERTEXATTRIBI1IVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLint)) 	# GL/glext.h:6993
PFNGLVERTEXATTRIBI2IVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLint)) 	# GL/glext.h:6994
PFNGLVERTEXATTRIBI3IVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLint)) 	# GL/glext.h:6995
PFNGLVERTEXATTRIBI4IVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLint)) 	# GL/glext.h:6996
PFNGLVERTEXATTRIBI1UIVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLuint)) 	# GL/glext.h:6997
PFNGLVERTEXATTRIBI2UIVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLuint)) 	# GL/glext.h:6998
PFNGLVERTEXATTRIBI3UIVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLuint)) 	# GL/glext.h:6999
PFNGLVERTEXATTRIBI4UIVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLuint)) 	# GL/glext.h:7000
PFNGLVERTEXATTRIBI4BVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLbyte)) 	# GL/glext.h:7001
PFNGLVERTEXATTRIBI4SVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLshort)) 	# GL/glext.h:7002
PFNGLVERTEXATTRIBI4UBVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLubyte)) 	# GL/glext.h:7003
PFNGLVERTEXATTRIBI4USVEXTPROC = CFUNCTYPE(None, GLuint, POINTER(GLushort)) 	# GL/glext.h:7004
PFNGLVERTEXATTRIBIPOINTEREXTPROC = CFUNCTYPE(None, GLuint, GLint, GLenum, GLsizei, POINTER(GLvoid)) 	# GL/glext.h:7005
PFNGLGETVERTEXATTRIBIIVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLint)) 	# GL/glext.h:7006
PFNGLGETVERTEXATTRIBIUIVEXTPROC = CFUNCTYPE(None, GLuint, GLenum, POINTER(GLuint)) 	# GL/glext.h:7007
# EXT_geometry_shader4 (GL/glext.h:7011)
GL_EXT_geometry_shader4 = 1 	# GL/glext.h:7012
# GL/glext.h:7014
glProgramParameteriEXT = _link_function('glProgramParameteriEXT', None, [GLuint, GLenum, GLint], 'EXT_geometry_shader4')

# GL/glext.h:7015
glFramebufferTextureEXT = _link_function('glFramebufferTextureEXT', None, [GLenum, GLenum, GLuint, GLint], 'EXT_geometry_shader4')

# GL/glext.h:7016
glFramebufferTextureLayerEXT = _link_function('glFramebufferTextureLayerEXT', None, [GLenum, GLenum, GLuint, GLint, GLint], 'EXT_geometry_shader4')

# GL/glext.h:7017
glFramebufferTextureFaceEXT = _link_function('glFramebufferTextureFaceEXT', None, [GLenum, GLenum, GLuint, GLint, GLenum], 'EXT_geometry_shader4')

PFNGLPROGRAMPARAMETERIEXTPROC = CFUNCTYPE(None, GLuint, GLenum, GLint) 	# GL/glext.h:7019
PFNGLFRAMEBUFFERTEXTUREEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLuint, GLint) 	# GL/glext.h:7020
PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLuint, GLint, GLint) 	# GL/glext.h:7021
PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC = CFUNCTYPE(None, GLenum, GLenum, GLuint, GLint, GLenum) 	# GL/glext.h:7022
# NV_geometry_program4 (GL/glext.h:7025)
GL_NV_geometry_program4 = 1 	# GL/glext.h:7026
# GL/glext.h:7028
glProgramVertexLimitNV = _link_function('glProgramVertexLimitNV', None, [GLenum, GLint], 'NV_geometry_program4')

PFNGLPROGRAMVERTEXLIMITNVPROC = CFUNCTYPE(None, GLenum, GLint) 	# GL/glext.h:7030
# NV_gpu_program4 (GL/glext.h:7033)
GL_NV_gpu_program4 = 1 	# GL/glext.h:7034
# GL/glext.h:7036
glProgramLocalParameterI4iNV = _link_function('glProgramLocalParameterI4iNV', None, [GLenum, GLuint, GLint, GLint, GLint, GLint], 'NV_gpu_program4')

# GL/glext.h:7037
glProgramLocalParameterI4ivNV = _link_function('glProgramLocalParameterI4ivNV', None, [GLenum, GLuint, POINTER(GLint)], 'NV_gpu_program4')

# GL/glext.h:7038
glProgramLocalParametersI4ivNV = _link_function('glProgramLocalParametersI4ivNV', None, [GLenum, GLuint, GLsizei, POINTER(GLint)], 'NV_gpu_program4')

# GL/glext.h:7039
glProgramLocalParameterI4uiNV = _link_function('glProgramLocalParameterI4uiNV', None, [GLenum, GLuint, GLuint, GLuint, GLuint, GLuint], 'NV_gpu_program4')

# GL/glext.h:7040
glProgramLocalParameterI4uivNV = _link_function('glProgramLocalParameterI4uivNV', None, [GLenum, GLuint, POINTER(GLuint)], 'NV_gpu_program4')

# GL/glext.h:7041
glProgramLocalParametersI4uivNV = _link_function('glProgramLocalParametersI4uivNV', None, [GLenum, GLuint, GLsizei, POINTER(GLuint)], 'NV_gpu_program4')

# GL/glext.h:7042
glProgramEnvParameterI4iNV = _link_function('glProgramEnvParameterI4iNV', None, [GLenum, GLuint, GLint, GLint, GLint, GLint], 'NV_gpu_program4')

# GL/glext.h:7043
glProgramEnvParameterI4ivNV = _link_function('glProgramEnvParameterI4ivNV', None, [GLenum, GLuint, POINTER(GLint)], 'NV_gpu_program4')

# GL/glext.h:7044
glProgramEnvParametersI4ivNV = _link_function('glProgramEnvParametersI4ivNV', None, [GLenum, GLuint, GLsizei, POINTER(GLint)], 'NV_gpu_program4')

# GL/glext.h:7045
glProgramEnvParameterI4uiNV = _link_function('glProgramEnvParameterI4uiNV', None, [GLenum, GLuint, GLuint, GLuint, GLuint, GLuint], 'NV_gpu_program4')

# GL/glext.h:7046
glProgramEnvParameterI4uivNV = _link_function('glProgramEnvParameterI4uivNV', None, [GLenum, GLuint, POINTER(GLuint)], 'NV_gpu_program4')

# GL/glext.h:7047
glProgramEnvParametersI4uivNV = _link_function('glProgramEnvParametersI4uivNV', None, [GLenum, GLuint, GLsizei, POINTER(GLuint)], 'NV_gpu_program4')

# GL/glext.h:7048
glGetProgramLocalParameterIivNV = _link_function('glGetProgramLocalParameterIivNV', None, [GLenum, GLuint, POINTER(GLint)], 'NV_gpu_program4')

# GL/glext.h:7049
glGetProgramLocalParameterIuivNV = _link_function('glGetProgramLocalParameterIuivNV', None, [GLenum, GLuint, POINTER(GLuint)], 'NV_gpu_program4')

# GL/glext.h:7050
glGetProgramEnvParameterIivNV = _link_function('glGetProgramEnvParameterIivNV', None, [GLenum, GLuint, POINTER(GLint)], 'NV_gpu_program4')

# GL/glext.h:7051
glGetProgramEnvParameterIuivNV = _link_function('glGetProgramEnvParameterIuivNV', None, [GLenum, GLuint, POINTER(GLuint)], 'NV_gpu_program4')

PFNGLPROGRAMLOCALPARAMETERI4INVPROC = CFUNCTYPE(None, GLenum, GLuint, GLint, GLint, GLint, GLint) 	# GL/glext.h:7053
PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLint)) 	# GL/glext.h:7054
PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLsizei, POINTER(GLint)) 	# GL/glext.h:7055
PFNGLPROGRAMLOCALPARAMETERI4UINVPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:7056
PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLuint)) 	# GL/glext.h:7057
PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLsizei, POINTER(GLuint)) 	# GL/glext.h:7058
PFNGLPROGRAMENVPARAMETERI4INVPROC = CFUNCTYPE(None, GLenum, GLuint, GLint, GLint, GLint, GLint) 	# GL/glext.h:7059
PFNGLPROGRAMENVPARAMETERI4IVNVPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLint)) 	# GL/glext.h:7060
PFNGLPROGRAMENVPARAMETERSI4IVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLsizei, POINTER(GLint)) 	# GL/glext.h:7061
PFNGLPROGRAMENVPARAMETERI4UINVPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLuint, GLuint, GLuint) 	# GL/glext.h:7062
PFNGLPROGRAMENVPARAMETERI4UIVNVPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLuint)) 	# GL/glext.h:7063
PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLsizei, POINTER(GLuint)) 	# GL/glext.h:7064
PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLint)) 	# GL/glext.h:7065
PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLuint)) 	# GL/glext.h:7066
PFNGLGETPROGRAMENVPARAMETERIIVNVPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLint)) 	# GL/glext.h:7067
PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC = CFUNCTYPE(None, GLenum, GLuint, POINTER(GLuint)) 	# GL/glext.h:7068
# NV_parameter_buffer_object (GL/glext.h:7071)
GL_NV_parameter_buffer_object = 1 	# GL/glext.h:7072
# GL/glext.h:7074
glProgramBufferParametersfvNV = _link_function('glProgramBufferParametersfvNV', None, [GLenum, GLuint, GLuint, GLsizei, POINTER(GLfloat)], 'NV_parameter_buffer_object')

# GL/glext.h:7075
glProgramBufferParametersIivNV = _link_function('glProgramBufferParametersIivNV', None, [GLenum, GLuint, GLuint, GLsizei, POINTER(GLint)], 'NV_parameter_buffer_object')

# GL/glext.h:7076
glProgramBufferParametersIuivNV = _link_function('glProgramBufferParametersIuivNV', None, [GLenum, GLuint, GLuint, GLsizei, POINTER(GLuint)], 'NV_parameter_buffer_object')

PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLsizei, POINTER(GLfloat)) 	# GL/glext.h:7078
PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLsizei, POINTER(GLint)) 	# GL/glext.h:7079
PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC = CFUNCTYPE(None, GLenum, GLuint, GLuint, GLsizei, POINTER(GLuint)) 	# GL/glext.h:7080
# EXT_framebuffer_multisample (GL/glext.h:7083)
GL_EXT_framebuffer_multisample = 1 	# GL/glext.h:7084
# GL/glext.h:7086
glRenderbufferStorageMultisampleEXT = _link_function('glRenderbufferStorageMultisampleEXT', None, [GLenum, GLsizei, GLenum, GLsizei, GLsizei], 'EXT_framebuffer_multisample')

PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC = CFUNCTYPE(None, GLenum, GLsizei, GLenum, GLsizei, GLsizei) 	# GL/glext.h:7088
# NV_framebuffer_multisample_coverage (GL/glext.h:7091)
GL_NV_framebuffer_multisample_coverage = 1 	# GL/glext.h:7092
# GL/glext.h:7094
glRenderbufferStorageMultisampleCoverageNV = _link_function('glRenderbufferStorageMultisampleCoverageNV', None, [GLenum, GLsizei, GLsizei, GLenum, GLsizei, GLsizei], 'NV_framebuffer_multisample_coverage')

PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC = CFUNCTYPE(None, GLenum, GLsizei, GLsizei, GLenum, GLsizei, GLsizei) 	# GL/glext.h:7096
# EXT_framebuffer_blit (GL/glext.h:7099)
GL_EXT_framebuffer_blit = 1 	# GL/glext.h:7100
# GL/glext.h:7102
glBlitFramebufferEXT = _link_function('glBlitFramebufferEXT', None, [GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum], 'EXT_framebuffer_blit')

PFNGLBLITFRAMEBUFFEREXTPROC = CFUNCTYPE(None, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum) 	# GL/glext.h:7104
# EXT_draw_instanced (GL/glext.h:7107)
GL_EXT_draw_instanced = 1 	# GL/glext.h:7108
# GL/glext.h:7110
glDrawArraysInstancedEXT = _link_function('glDrawArraysInstancedEXT', None, [GLenum, GLint, GLsizei, GLsizei], 'EXT_draw_instanced')

# GL/glext.h:7111
glDrawElementsInstancedEXT = _link_function('glDrawElementsInstancedEXT', None, [GLenum, GLsizei, GLenum, POINTER(GLvoid), GLsizei], 'EXT_draw_instanced')

PFNGLDRAWARRAYSINSTANCEDEXTPROC = CFUNCTYPE(None, GLenum, GLint, GLsizei, GLsizei) 	# GL/glext.h:7113
PFNGLDRAWELEMENTSINSTANCEDEXTPROC = CFUNCTYPE(None, GLenum, GLsizei, GLenum, POINTER(GLvoid), GLsizei) 	# GL/glext.h:7114
# EXT_texture_compression_rgtc (GL/glext.h:7117)
GL_EXT_texture_compression_rgtc = 1 	# GL/glext.h:7118
# GLEXT_LEGACY (/usr/include/GL/gl.h:1633)

__all__ = ['GL_GLEXT_VERSION', 'GL_UNSIGNED_BYTE_3_3_2',
'GL_UNSIGNED_SHORT_4_4_4_4', 'GL_UNSIGNED_SHORT_5_5_5_1',
'GL_UNSIGNED_INT_8_8_8_8', 'GL_UNSIGNED_INT_10_10_10_2', 'GL_RESCALE_NORMAL',
'GL_TEXTURE_BINDING_3D', 'GL_PACK_SKIP_IMAGES', 'GL_PACK_IMAGE_HEIGHT',
'GL_UNPACK_SKIP_IMAGES', 'GL_UNPACK_IMAGE_HEIGHT', 'GL_TEXTURE_3D',
'GL_PROXY_TEXTURE_3D', 'GL_TEXTURE_DEPTH', 'GL_TEXTURE_WRAP_R',
'GL_MAX_3D_TEXTURE_SIZE', 'GL_UNSIGNED_BYTE_2_3_3_REV',
'GL_UNSIGNED_SHORT_5_6_5', 'GL_UNSIGNED_SHORT_5_6_5_REV',
'GL_UNSIGNED_SHORT_4_4_4_4_REV', 'GL_UNSIGNED_SHORT_1_5_5_5_REV',
'GL_UNSIGNED_INT_8_8_8_8_REV', 'GL_UNSIGNED_INT_2_10_10_10_REV', 'GL_BGR',
'GL_BGRA', 'GL_MAX_ELEMENTS_VERTICES', 'GL_MAX_ELEMENTS_INDICES',
'GL_CLAMP_TO_EDGE', 'GL_TEXTURE_MIN_LOD', 'GL_TEXTURE_MAX_LOD',
'GL_TEXTURE_BASE_LEVEL', 'GL_TEXTURE_MAX_LEVEL',
'GL_LIGHT_MODEL_COLOR_CONTROL', 'GL_SINGLE_COLOR',
'GL_SEPARATE_SPECULAR_COLOR', 'GL_SMOOTH_POINT_SIZE_RANGE',
'GL_SMOOTH_POINT_SIZE_GRANULARITY', 'GL_SMOOTH_LINE_WIDTH_RANGE',
'GL_SMOOTH_LINE_WIDTH_GRANULARITY', 'GL_ALIASED_POINT_SIZE_RANGE',
'GL_ALIASED_LINE_WIDTH_RANGE', 'GL_CONSTANT_COLOR',
'GL_ONE_MINUS_CONSTANT_COLOR', 'GL_CONSTANT_ALPHA',
'GL_ONE_MINUS_CONSTANT_ALPHA', 'GL_BLEND_COLOR', 'GL_FUNC_ADD', 'GL_MIN',
'GL_MAX', 'GL_BLEND_EQUATION', 'GL_FUNC_SUBTRACT', 'GL_FUNC_REVERSE_SUBTRACT',
'GL_CONVOLUTION_1D', 'GL_CONVOLUTION_2D', 'GL_SEPARABLE_2D',
'GL_CONVOLUTION_BORDER_MODE', 'GL_CONVOLUTION_FILTER_SCALE',
'GL_CONVOLUTION_FILTER_BIAS', 'GL_REDUCE', 'GL_CONVOLUTION_FORMAT',
'GL_CONVOLUTION_WIDTH', 'GL_CONVOLUTION_HEIGHT', 'GL_MAX_CONVOLUTION_WIDTH',
'GL_MAX_CONVOLUTION_HEIGHT', 'GL_POST_CONVOLUTION_RED_SCALE',
'GL_POST_CONVOLUTION_GREEN_SCALE', 'GL_POST_CONVOLUTION_BLUE_SCALE',
'GL_POST_CONVOLUTION_ALPHA_SCALE', 'GL_POST_CONVOLUTION_RED_BIAS',
'GL_POST_CONVOLUTION_GREEN_BIAS', 'GL_POST_CONVOLUTION_BLUE_BIAS',
'GL_POST_CONVOLUTION_ALPHA_BIAS', 'GL_HISTOGRAM', 'GL_PROXY_HISTOGRAM',
'GL_HISTOGRAM_WIDTH', 'GL_HISTOGRAM_FORMAT', 'GL_HISTOGRAM_RED_SIZE',
'GL_HISTOGRAM_GREEN_SIZE', 'GL_HISTOGRAM_BLUE_SIZE',
'GL_HISTOGRAM_ALPHA_SIZE', 'GL_HISTOGRAM_LUMINANCE_SIZE', 'GL_HISTOGRAM_SINK',
'GL_MINMAX', 'GL_MINMAX_FORMAT', 'GL_MINMAX_SINK', 'GL_TABLE_TOO_LARGE',
'GL_COLOR_MATRIX', 'GL_COLOR_MATRIX_STACK_DEPTH',
'GL_MAX_COLOR_MATRIX_STACK_DEPTH', 'GL_POST_COLOR_MATRIX_RED_SCALE',
'GL_POST_COLOR_MATRIX_GREEN_SCALE', 'GL_POST_COLOR_MATRIX_BLUE_SCALE',
'GL_POST_COLOR_MATRIX_ALPHA_SCALE', 'GL_POST_COLOR_MATRIX_RED_BIAS',
'GL_POST_COLOR_MATRIX_GREEN_BIAS', 'GL_POST_COLOR_MATRIX_BLUE_BIAS',
'GL_POST_COLOR_MATRIX_ALPHA_BIAS', 'GL_COLOR_TABLE',
'GL_POST_CONVOLUTION_COLOR_TABLE', 'GL_POST_COLOR_MATRIX_COLOR_TABLE',
'GL_PROXY_COLOR_TABLE', 'GL_PROXY_POST_CONVOLUTION_COLOR_TABLE',
'GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE', 'GL_COLOR_TABLE_SCALE',
'GL_COLOR_TABLE_BIAS', 'GL_COLOR_TABLE_FORMAT', 'GL_COLOR_TABLE_WIDTH',
'GL_COLOR_TABLE_RED_SIZE', 'GL_COLOR_TABLE_GREEN_SIZE',
'GL_COLOR_TABLE_BLUE_SIZE', 'GL_COLOR_TABLE_ALPHA_SIZE',
'GL_COLOR_TABLE_LUMINANCE_SIZE', 'GL_COLOR_TABLE_INTENSITY_SIZE',
'GL_CONSTANT_BORDER', 'GL_REPLICATE_BORDER', 'GL_CONVOLUTION_BORDER_COLOR',
'GL_TEXTURE0', 'GL_TEXTURE1', 'GL_TEXTURE2', 'GL_TEXTURE3', 'GL_TEXTURE4',
'GL_TEXTURE5', 'GL_TEXTURE6', 'GL_TEXTURE7', 'GL_TEXTURE8', 'GL_TEXTURE9',
'GL_TEXTURE10', 'GL_TEXTURE11', 'GL_TEXTURE12', 'GL_TEXTURE13',
'GL_TEXTURE14', 'GL_TEXTURE15', 'GL_TEXTURE16', 'GL_TEXTURE17',
'GL_TEXTURE18', 'GL_TEXTURE19', 'GL_TEXTURE20', 'GL_TEXTURE21',
'GL_TEXTURE22', 'GL_TEXTURE23', 'GL_TEXTURE24', 'GL_TEXTURE25',
'GL_TEXTURE26', 'GL_TEXTURE27', 'GL_TEXTURE28', 'GL_TEXTURE29',
'GL_TEXTURE30', 'GL_TEXTURE31', 'GL_ACTIVE_TEXTURE',
'GL_CLIENT_ACTIVE_TEXTURE', 'GL_MAX_TEXTURE_UNITS',
'GL_TRANSPOSE_MODELVIEW_MATRIX', 'GL_TRANSPOSE_PROJECTION_MATRIX',
'GL_TRANSPOSE_TEXTURE_MATRIX', 'GL_TRANSPOSE_COLOR_MATRIX', 'GL_MULTISAMPLE',
'GL_SAMPLE_ALPHA_TO_COVERAGE', 'GL_SAMPLE_ALPHA_TO_ONE', 'GL_SAMPLE_COVERAGE',
'GL_SAMPLE_BUFFERS', 'GL_SAMPLES', 'GL_SAMPLE_COVERAGE_VALUE',
'GL_SAMPLE_COVERAGE_INVERT', 'GL_MULTISAMPLE_BIT', 'GL_NORMAL_MAP',
'GL_REFLECTION_MAP', 'GL_TEXTURE_CUBE_MAP', 'GL_TEXTURE_BINDING_CUBE_MAP',
'GL_TEXTURE_CUBE_MAP_POSITIVE_X', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_X',
'GL_TEXTURE_CUBE_MAP_POSITIVE_Y', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_Y',
'GL_TEXTURE_CUBE_MAP_POSITIVE_Z', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_Z',
'GL_PROXY_TEXTURE_CUBE_MAP', 'GL_MAX_CUBE_MAP_TEXTURE_SIZE',
'GL_COMPRESSED_ALPHA', 'GL_COMPRESSED_LUMINANCE',
'GL_COMPRESSED_LUMINANCE_ALPHA', 'GL_COMPRESSED_INTENSITY',
'GL_COMPRESSED_RGB', 'GL_COMPRESSED_RGBA', 'GL_TEXTURE_COMPRESSION_HINT',
'GL_TEXTURE_COMPRESSED_IMAGE_SIZE', 'GL_TEXTURE_COMPRESSED',
'GL_NUM_COMPRESSED_TEXTURE_FORMATS', 'GL_COMPRESSED_TEXTURE_FORMATS',
'GL_CLAMP_TO_BORDER', 'GL_COMBINE', 'GL_COMBINE_RGB', 'GL_COMBINE_ALPHA',
'GL_SOURCE0_RGB', 'GL_SOURCE1_RGB', 'GL_SOURCE2_RGB', 'GL_SOURCE0_ALPHA',
'GL_SOURCE1_ALPHA', 'GL_SOURCE2_ALPHA', 'GL_OPERAND0_RGB', 'GL_OPERAND1_RGB',
'GL_OPERAND2_RGB', 'GL_OPERAND0_ALPHA', 'GL_OPERAND1_ALPHA',
'GL_OPERAND2_ALPHA', 'GL_RGB_SCALE', 'GL_ADD_SIGNED', 'GL_INTERPOLATE',
'GL_SUBTRACT', 'GL_CONSTANT', 'GL_PRIMARY_COLOR', 'GL_PREVIOUS',
'GL_DOT3_RGB', 'GL_DOT3_RGBA', 'GL_BLEND_DST_RGB', 'GL_BLEND_SRC_RGB',
'GL_BLEND_DST_ALPHA', 'GL_BLEND_SRC_ALPHA', 'GL_POINT_SIZE_MIN',
'GL_POINT_SIZE_MAX', 'GL_POINT_FADE_THRESHOLD_SIZE',
'GL_POINT_DISTANCE_ATTENUATION', 'GL_GENERATE_MIPMAP',
'GL_GENERATE_MIPMAP_HINT', 'GL_DEPTH_COMPONENT16', 'GL_DEPTH_COMPONENT24',
'GL_DEPTH_COMPONENT32', 'GL_MIRRORED_REPEAT', 'GL_FOG_COORDINATE_SOURCE',
'GL_FOG_COORDINATE', 'GL_FRAGMENT_DEPTH', 'GL_CURRENT_FOG_COORDINATE',
'GL_FOG_COORDINATE_ARRAY_TYPE', 'GL_FOG_COORDINATE_ARRAY_STRIDE',
'GL_FOG_COORDINATE_ARRAY_POINTER', 'GL_FOG_COORDINATE_ARRAY', 'GL_COLOR_SUM',
'GL_CURRENT_SECONDARY_COLOR', 'GL_SECONDARY_COLOR_ARRAY_SIZE',
'GL_SECONDARY_COLOR_ARRAY_TYPE', 'GL_SECONDARY_COLOR_ARRAY_STRIDE',
'GL_SECONDARY_COLOR_ARRAY_POINTER', 'GL_SECONDARY_COLOR_ARRAY',
'GL_MAX_TEXTURE_LOD_BIAS', 'GL_TEXTURE_FILTER_CONTROL', 'GL_TEXTURE_LOD_BIAS',
'GL_INCR_WRAP', 'GL_DECR_WRAP', 'GL_TEXTURE_DEPTH_SIZE',
'GL_DEPTH_TEXTURE_MODE', 'GL_TEXTURE_COMPARE_MODE', 'GL_TEXTURE_COMPARE_FUNC',
'GL_COMPARE_R_TO_TEXTURE', 'GL_BUFFER_SIZE', 'GL_BUFFER_USAGE',
'GL_QUERY_COUNTER_BITS', 'GL_CURRENT_QUERY', 'GL_QUERY_RESULT',
'GL_QUERY_RESULT_AVAILABLE', 'GL_ARRAY_BUFFER', 'GL_ELEMENT_ARRAY_BUFFER',
'GL_ARRAY_BUFFER_BINDING', 'GL_ELEMENT_ARRAY_BUFFER_BINDING',
'GL_VERTEX_ARRAY_BUFFER_BINDING', 'GL_NORMAL_ARRAY_BUFFER_BINDING',
'GL_COLOR_ARRAY_BUFFER_BINDING', 'GL_INDEX_ARRAY_BUFFER_BINDING',
'GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING', 'GL_EDGE_FLAG_ARRAY_BUFFER_BINDING',
'GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING',
'GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING', 'GL_WEIGHT_ARRAY_BUFFER_BINDING',
'GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING', 'GL_READ_ONLY', 'GL_WRITE_ONLY',
'GL_READ_WRITE', 'GL_BUFFER_ACCESS', 'GL_BUFFER_MAPPED',
'GL_BUFFER_MAP_POINTER', 'GL_STREAM_DRAW', 'GL_STREAM_READ', 'GL_STREAM_COPY',
'GL_STATIC_DRAW', 'GL_STATIC_READ', 'GL_STATIC_COPY', 'GL_DYNAMIC_DRAW',
'GL_DYNAMIC_READ', 'GL_DYNAMIC_COPY', 'GL_SAMPLES_PASSED', 'GL_FOG_COORD_SRC',
'GL_FOG_COORD', 'GL_CURRENT_FOG_COORD', 'GL_FOG_COORD_ARRAY_TYPE',
'GL_FOG_COORD_ARRAY_STRIDE', 'GL_FOG_COORD_ARRAY_POINTER',
'GL_FOG_COORD_ARRAY', 'GL_FOG_COORD_ARRAY_BUFFER_BINDING', 'GL_SRC0_RGB',
'GL_SRC1_RGB', 'GL_SRC2_RGB', 'GL_SRC0_ALPHA', 'GL_SRC1_ALPHA',
'GL_SRC2_ALPHA', 'GL_BLEND_EQUATION_RGB', 'GL_VERTEX_ATTRIB_ARRAY_ENABLED',
'GL_VERTEX_ATTRIB_ARRAY_SIZE', 'GL_VERTEX_ATTRIB_ARRAY_STRIDE',
'GL_VERTEX_ATTRIB_ARRAY_TYPE', 'GL_CURRENT_VERTEX_ATTRIB',
'GL_VERTEX_PROGRAM_POINT_SIZE', 'GL_VERTEX_PROGRAM_TWO_SIDE',
'GL_VERTEX_ATTRIB_ARRAY_POINTER', 'GL_STENCIL_BACK_FUNC',
'GL_STENCIL_BACK_FAIL', 'GL_STENCIL_BACK_PASS_DEPTH_FAIL',
'GL_STENCIL_BACK_PASS_DEPTH_PASS', 'GL_MAX_DRAW_BUFFERS', 'GL_DRAW_BUFFER0',
'GL_DRAW_BUFFER1', 'GL_DRAW_BUFFER2', 'GL_DRAW_BUFFER3', 'GL_DRAW_BUFFER4',
'GL_DRAW_BUFFER5', 'GL_DRAW_BUFFER6', 'GL_DRAW_BUFFER7', 'GL_DRAW_BUFFER8',
'GL_DRAW_BUFFER9', 'GL_DRAW_BUFFER10', 'GL_DRAW_BUFFER11', 'GL_DRAW_BUFFER12',
'GL_DRAW_BUFFER13', 'GL_DRAW_BUFFER14', 'GL_DRAW_BUFFER15',
'GL_BLEND_EQUATION_ALPHA', 'GL_POINT_SPRITE', 'GL_COORD_REPLACE',
'GL_MAX_VERTEX_ATTRIBS', 'GL_VERTEX_ATTRIB_ARRAY_NORMALIZED',
'GL_MAX_TEXTURE_COORDS', 'GL_MAX_TEXTURE_IMAGE_UNITS', 'GL_FRAGMENT_SHADER',
'GL_VERTEX_SHADER', 'GL_MAX_FRAGMENT_UNIFORM_COMPONENTS',
'GL_MAX_VERTEX_UNIFORM_COMPONENTS', 'GL_MAX_VARYING_FLOATS',
'GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS', 'GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS',
'GL_SHADER_TYPE', 'GL_FLOAT_VEC2', 'GL_FLOAT_VEC3', 'GL_FLOAT_VEC4',
'GL_INT_VEC2', 'GL_INT_VEC3', 'GL_INT_VEC4', 'GL_BOOL', 'GL_BOOL_VEC2',
'GL_BOOL_VEC3', 'GL_BOOL_VEC4', 'GL_FLOAT_MAT2', 'GL_FLOAT_MAT3',
'GL_FLOAT_MAT4', 'GL_SAMPLER_1D', 'GL_SAMPLER_2D', 'GL_SAMPLER_3D',
'GL_SAMPLER_CUBE', 'GL_SAMPLER_1D_SHADOW', 'GL_SAMPLER_2D_SHADOW',
'GL_DELETE_STATUS', 'GL_COMPILE_STATUS', 'GL_LINK_STATUS',
'GL_VALIDATE_STATUS', 'GL_INFO_LOG_LENGTH', 'GL_ATTACHED_SHADERS',
'GL_ACTIVE_UNIFORMS', 'GL_ACTIVE_UNIFORM_MAX_LENGTH',
'GL_SHADER_SOURCE_LENGTH', 'GL_ACTIVE_ATTRIBUTES',
'GL_ACTIVE_ATTRIBUTE_MAX_LENGTH', 'GL_FRAGMENT_SHADER_DERIVATIVE_HINT',
'GL_SHADING_LANGUAGE_VERSION', 'GL_CURRENT_PROGRAM',
'GL_POINT_SPRITE_COORD_ORIGIN', 'GL_LOWER_LEFT', 'GL_UPPER_LEFT',
'GL_STENCIL_BACK_REF', 'GL_STENCIL_BACK_VALUE_MASK',
'GL_STENCIL_BACK_WRITEMASK', 'GL_PIXEL_PACK_BUFFER', 'GL_PIXEL_UNPACK_BUFFER',
'GL_PIXEL_PACK_BUFFER_BINDING', 'GL_PIXEL_UNPACK_BUFFER_BINDING', 'GL_SRGB',
'GL_SRGB8', 'GL_SRGB_ALPHA', 'GL_SRGB8_ALPHA8', 'GL_SLUMINANCE_ALPHA',
'GL_SLUMINANCE8_ALPHA8', 'GL_SLUMINANCE', 'GL_SLUMINANCE8',
'GL_COMPRESSED_SRGB', 'GL_COMPRESSED_SRGB_ALPHA', 'GL_COMPRESSED_SLUMINANCE',
'GL_COMPRESSED_SLUMINANCE_ALPHA', 'GL_FLOAT_MAT2x3', 'GL_FLOAT_MAT2x4',
'GL_FLOAT_MAT3x2', 'GL_FLOAT_MAT3x4', 'GL_FLOAT_MAT4x2', 'GL_FLOAT_MAT4x3',
'GL_CURRENT_RASTER_SECONDARY_COLOR', 'GL_TEXTURE0_ARB', 'GL_TEXTURE1_ARB',
'GL_TEXTURE2_ARB', 'GL_TEXTURE3_ARB', 'GL_TEXTURE4_ARB', 'GL_TEXTURE5_ARB',
'GL_TEXTURE6_ARB', 'GL_TEXTURE7_ARB', 'GL_TEXTURE8_ARB', 'GL_TEXTURE9_ARB',
'GL_TEXTURE10_ARB', 'GL_TEXTURE11_ARB', 'GL_TEXTURE12_ARB',
'GL_TEXTURE13_ARB', 'GL_TEXTURE14_ARB', 'GL_TEXTURE15_ARB',
'GL_TEXTURE16_ARB', 'GL_TEXTURE17_ARB', 'GL_TEXTURE18_ARB',
'GL_TEXTURE19_ARB', 'GL_TEXTURE20_ARB', 'GL_TEXTURE21_ARB',
'GL_TEXTURE22_ARB', 'GL_TEXTURE23_ARB', 'GL_TEXTURE24_ARB',
'GL_TEXTURE25_ARB', 'GL_TEXTURE26_ARB', 'GL_TEXTURE27_ARB',
'GL_TEXTURE28_ARB', 'GL_TEXTURE29_ARB', 'GL_TEXTURE30_ARB',
'GL_TEXTURE31_ARB', 'GL_ACTIVE_TEXTURE_ARB', 'GL_CLIENT_ACTIVE_TEXTURE_ARB',
'GL_MAX_TEXTURE_UNITS_ARB', 'GL_TRANSPOSE_MODELVIEW_MATRIX_ARB',
'GL_TRANSPOSE_PROJECTION_MATRIX_ARB', 'GL_TRANSPOSE_TEXTURE_MATRIX_ARB',
'GL_TRANSPOSE_COLOR_MATRIX_ARB', 'GL_MULTISAMPLE_ARB',
'GL_SAMPLE_ALPHA_TO_COVERAGE_ARB', 'GL_SAMPLE_ALPHA_TO_ONE_ARB',
'GL_SAMPLE_COVERAGE_ARB', 'GL_SAMPLE_BUFFERS_ARB', 'GL_SAMPLES_ARB',
'GL_SAMPLE_COVERAGE_VALUE_ARB', 'GL_SAMPLE_COVERAGE_INVERT_ARB',
'GL_MULTISAMPLE_BIT_ARB', 'GL_NORMAL_MAP_ARB', 'GL_REFLECTION_MAP_ARB',
'GL_TEXTURE_CUBE_MAP_ARB', 'GL_TEXTURE_BINDING_CUBE_MAP_ARB',
'GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB',
'GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB',
'GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB',
'GL_PROXY_TEXTURE_CUBE_MAP_ARB', 'GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB',
'GL_COMPRESSED_ALPHA_ARB', 'GL_COMPRESSED_LUMINANCE_ARB',
'GL_COMPRESSED_LUMINANCE_ALPHA_ARB', 'GL_COMPRESSED_INTENSITY_ARB',
'GL_COMPRESSED_RGB_ARB', 'GL_COMPRESSED_RGBA_ARB',
'GL_TEXTURE_COMPRESSION_HINT_ARB', 'GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB',
'GL_TEXTURE_COMPRESSED_ARB', 'GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB',
'GL_COMPRESSED_TEXTURE_FORMATS_ARB', 'GL_CLAMP_TO_BORDER_ARB',
'GL_POINT_SIZE_MIN_ARB', 'GL_POINT_SIZE_MAX_ARB',
'GL_POINT_FADE_THRESHOLD_SIZE_ARB', 'GL_POINT_DISTANCE_ATTENUATION_ARB',
'GL_MAX_VERTEX_UNITS_ARB', 'GL_ACTIVE_VERTEX_UNITS_ARB',
'GL_WEIGHT_SUM_UNITY_ARB', 'GL_VERTEX_BLEND_ARB', 'GL_CURRENT_WEIGHT_ARB',
'GL_WEIGHT_ARRAY_TYPE_ARB', 'GL_WEIGHT_ARRAY_STRIDE_ARB',
'GL_WEIGHT_ARRAY_SIZE_ARB', 'GL_WEIGHT_ARRAY_POINTER_ARB',
'GL_WEIGHT_ARRAY_ARB', 'GL_MODELVIEW0_ARB', 'GL_MODELVIEW1_ARB',
'GL_MODELVIEW2_ARB', 'GL_MODELVIEW3_ARB', 'GL_MODELVIEW4_ARB',
'GL_MODELVIEW5_ARB', 'GL_MODELVIEW6_ARB', 'GL_MODELVIEW7_ARB',
'GL_MODELVIEW8_ARB', 'GL_MODELVIEW9_ARB', 'GL_MODELVIEW10_ARB',
'GL_MODELVIEW11_ARB', 'GL_MODELVIEW12_ARB', 'GL_MODELVIEW13_ARB',
'GL_MODELVIEW14_ARB', 'GL_MODELVIEW15_ARB', 'GL_MODELVIEW16_ARB',
'GL_MODELVIEW17_ARB', 'GL_MODELVIEW18_ARB', 'GL_MODELVIEW19_ARB',
'GL_MODELVIEW20_ARB', 'GL_MODELVIEW21_ARB', 'GL_MODELVIEW22_ARB',
'GL_MODELVIEW23_ARB', 'GL_MODELVIEW24_ARB', 'GL_MODELVIEW25_ARB',
'GL_MODELVIEW26_ARB', 'GL_MODELVIEW27_ARB', 'GL_MODELVIEW28_ARB',
'GL_MODELVIEW29_ARB', 'GL_MODELVIEW30_ARB', 'GL_MODELVIEW31_ARB',
'GL_MATRIX_PALETTE_ARB', 'GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB',
'GL_MAX_PALETTE_MATRICES_ARB', 'GL_CURRENT_PALETTE_MATRIX_ARB',
'GL_MATRIX_INDEX_ARRAY_ARB', 'GL_CURRENT_MATRIX_INDEX_ARB',
'GL_MATRIX_INDEX_ARRAY_SIZE_ARB', 'GL_MATRIX_INDEX_ARRAY_TYPE_ARB',
'GL_MATRIX_INDEX_ARRAY_STRIDE_ARB', 'GL_MATRIX_INDEX_ARRAY_POINTER_ARB',
'GL_COMBINE_ARB', 'GL_COMBINE_RGB_ARB', 'GL_COMBINE_ALPHA_ARB',
'GL_SOURCE0_RGB_ARB', 'GL_SOURCE1_RGB_ARB', 'GL_SOURCE2_RGB_ARB',
'GL_SOURCE0_ALPHA_ARB', 'GL_SOURCE1_ALPHA_ARB', 'GL_SOURCE2_ALPHA_ARB',
'GL_OPERAND0_RGB_ARB', 'GL_OPERAND1_RGB_ARB', 'GL_OPERAND2_RGB_ARB',
'GL_OPERAND0_ALPHA_ARB', 'GL_OPERAND1_ALPHA_ARB', 'GL_OPERAND2_ALPHA_ARB',
'GL_RGB_SCALE_ARB', 'GL_ADD_SIGNED_ARB', 'GL_INTERPOLATE_ARB',
'GL_SUBTRACT_ARB', 'GL_CONSTANT_ARB', 'GL_PRIMARY_COLOR_ARB',
'GL_PREVIOUS_ARB', 'GL_DOT3_RGB_ARB', 'GL_DOT3_RGBA_ARB',
'GL_MIRRORED_REPEAT_ARB', 'GL_DEPTH_COMPONENT16_ARB',
'GL_DEPTH_COMPONENT24_ARB', 'GL_DEPTH_COMPONENT32_ARB',
'GL_TEXTURE_DEPTH_SIZE_ARB', 'GL_DEPTH_TEXTURE_MODE_ARB',
'GL_TEXTURE_COMPARE_MODE_ARB', 'GL_TEXTURE_COMPARE_FUNC_ARB',
'GL_COMPARE_R_TO_TEXTURE_ARB', 'GL_TEXTURE_COMPARE_FAIL_VALUE_ARB',
'GL_COLOR_SUM_ARB', 'GL_VERTEX_PROGRAM_ARB',
'GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB', 'GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB',
'GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB', 'GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB',
'GL_CURRENT_VERTEX_ATTRIB_ARB', 'GL_PROGRAM_LENGTH_ARB',
'GL_PROGRAM_STRING_ARB', 'GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB',
'GL_MAX_PROGRAM_MATRICES_ARB', 'GL_CURRENT_MATRIX_STACK_DEPTH_ARB',
'GL_CURRENT_MATRIX_ARB', 'GL_VERTEX_PROGRAM_POINT_SIZE_ARB',
'GL_VERTEX_PROGRAM_TWO_SIDE_ARB', 'GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB',
'GL_PROGRAM_ERROR_POSITION_ARB', 'GL_PROGRAM_BINDING_ARB',
'GL_MAX_VERTEX_ATTRIBS_ARB', 'GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB',
'GL_PROGRAM_ERROR_STRING_ARB', 'GL_PROGRAM_FORMAT_ASCII_ARB',
'GL_PROGRAM_FORMAT_ARB', 'GL_PROGRAM_INSTRUCTIONS_ARB',
'GL_MAX_PROGRAM_INSTRUCTIONS_ARB', 'GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB',
'GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB', 'GL_PROGRAM_TEMPORARIES_ARB',
'GL_MAX_PROGRAM_TEMPORARIES_ARB', 'GL_PROGRAM_NATIVE_TEMPORARIES_ARB',
'GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB', 'GL_PROGRAM_PARAMETERS_ARB',
'GL_MAX_PROGRAM_PARAMETERS_ARB', 'GL_PROGRAM_NATIVE_PARAMETERS_ARB',
'GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB', 'GL_PROGRAM_ATTRIBS_ARB',
'GL_MAX_PROGRAM_ATTRIBS_ARB', 'GL_PROGRAM_NATIVE_ATTRIBS_ARB',
'GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB', 'GL_PROGRAM_ADDRESS_REGISTERS_ARB',
'GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB',
'GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB',
'GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB',
'GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB', 'GL_MAX_PROGRAM_ENV_PARAMETERS_ARB',
'GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB', 'GL_TRANSPOSE_CURRENT_MATRIX_ARB',
'GL_MATRIX0_ARB', 'GL_MATRIX1_ARB', 'GL_MATRIX2_ARB', 'GL_MATRIX3_ARB',
'GL_MATRIX4_ARB', 'GL_MATRIX5_ARB', 'GL_MATRIX6_ARB', 'GL_MATRIX7_ARB',
'GL_MATRIX8_ARB', 'GL_MATRIX9_ARB', 'GL_MATRIX10_ARB', 'GL_MATRIX11_ARB',
'GL_MATRIX12_ARB', 'GL_MATRIX13_ARB', 'GL_MATRIX14_ARB', 'GL_MATRIX15_ARB',
'GL_MATRIX16_ARB', 'GL_MATRIX17_ARB', 'GL_MATRIX18_ARB', 'GL_MATRIX19_ARB',
'GL_MATRIX20_ARB', 'GL_MATRIX21_ARB', 'GL_MATRIX22_ARB', 'GL_MATRIX23_ARB',
'GL_MATRIX24_ARB', 'GL_MATRIX25_ARB', 'GL_MATRIX26_ARB', 'GL_MATRIX27_ARB',
'GL_MATRIX28_ARB', 'GL_MATRIX29_ARB', 'GL_MATRIX30_ARB', 'GL_MATRIX31_ARB',
'GL_FRAGMENT_PROGRAM_ARB', 'GL_PROGRAM_ALU_INSTRUCTIONS_ARB',
'GL_PROGRAM_TEX_INSTRUCTIONS_ARB', 'GL_PROGRAM_TEX_INDIRECTIONS_ARB',
'GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB',
'GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB',
'GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB',
'GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB', 'GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB',
'GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB',
'GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB',
'GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB',
'GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB', 'GL_MAX_TEXTURE_COORDS_ARB',
'GL_MAX_TEXTURE_IMAGE_UNITS_ARB', 'GL_BUFFER_SIZE_ARB', 'GL_BUFFER_USAGE_ARB',
'GL_ARRAY_BUFFER_ARB', 'GL_ELEMENT_ARRAY_BUFFER_ARB',
'GL_ARRAY_BUFFER_BINDING_ARB', 'GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB',
'GL_VERTEX_ARRAY_BUFFER_BINDING_ARB', 'GL_NORMAL_ARRAY_BUFFER_BINDING_ARB',
'GL_COLOR_ARRAY_BUFFER_BINDING_ARB', 'GL_INDEX_ARRAY_BUFFER_BINDING_ARB',
'GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB',
'GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB',
'GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB',
'GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB',
'GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB',
'GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB', 'GL_READ_ONLY_ARB',
'GL_WRITE_ONLY_ARB', 'GL_READ_WRITE_ARB', 'GL_BUFFER_ACCESS_ARB',
'GL_BUFFER_MAPPED_ARB', 'GL_BUFFER_MAP_POINTER_ARB', 'GL_STREAM_DRAW_ARB',
'GL_STREAM_READ_ARB', 'GL_STREAM_COPY_ARB', 'GL_STATIC_DRAW_ARB',
'GL_STATIC_READ_ARB', 'GL_STATIC_COPY_ARB', 'GL_DYNAMIC_DRAW_ARB',
'GL_DYNAMIC_READ_ARB', 'GL_DYNAMIC_COPY_ARB', 'GL_QUERY_COUNTER_BITS_ARB',
'GL_CURRENT_QUERY_ARB', 'GL_QUERY_RESULT_ARB',
'GL_QUERY_RESULT_AVAILABLE_ARB', 'GL_SAMPLES_PASSED_ARB',
'GL_PROGRAM_OBJECT_ARB', 'GL_SHADER_OBJECT_ARB', 'GL_OBJECT_TYPE_ARB',
'GL_OBJECT_SUBTYPE_ARB', 'GL_FLOAT_VEC2_ARB', 'GL_FLOAT_VEC3_ARB',
'GL_FLOAT_VEC4_ARB', 'GL_INT_VEC2_ARB', 'GL_INT_VEC3_ARB', 'GL_INT_VEC4_ARB',
'GL_BOOL_ARB', 'GL_BOOL_VEC2_ARB', 'GL_BOOL_VEC3_ARB', 'GL_BOOL_VEC4_ARB',
'GL_FLOAT_MAT2_ARB', 'GL_FLOAT_MAT3_ARB', 'GL_FLOAT_MAT4_ARB',
'GL_SAMPLER_1D_ARB', 'GL_SAMPLER_2D_ARB', 'GL_SAMPLER_3D_ARB',
'GL_SAMPLER_CUBE_ARB', 'GL_SAMPLER_1D_SHADOW_ARB', 'GL_SAMPLER_2D_SHADOW_ARB',
'GL_SAMPLER_2D_RECT_ARB', 'GL_SAMPLER_2D_RECT_SHADOW_ARB',
'GL_OBJECT_DELETE_STATUS_ARB', 'GL_OBJECT_COMPILE_STATUS_ARB',
'GL_OBJECT_LINK_STATUS_ARB', 'GL_OBJECT_VALIDATE_STATUS_ARB',
'GL_OBJECT_INFO_LOG_LENGTH_ARB', 'GL_OBJECT_ATTACHED_OBJECTS_ARB',
'GL_OBJECT_ACTIVE_UNIFORMS_ARB', 'GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB',
'GL_OBJECT_SHADER_SOURCE_LENGTH_ARB', 'GL_VERTEX_SHADER_ARB',
'GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB', 'GL_MAX_VARYING_FLOATS_ARB',
'GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB',
'GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB', 'GL_OBJECT_ACTIVE_ATTRIBUTES_ARB',
'GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB', 'GL_FRAGMENT_SHADER_ARB',
'GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB',
'GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB', 'GL_SHADING_LANGUAGE_VERSION_ARB',
'GL_POINT_SPRITE_ARB', 'GL_COORD_REPLACE_ARB', 'GL_MAX_DRAW_BUFFERS_ARB',
'GL_DRAW_BUFFER0_ARB', 'GL_DRAW_BUFFER1_ARB', 'GL_DRAW_BUFFER2_ARB',
'GL_DRAW_BUFFER3_ARB', 'GL_DRAW_BUFFER4_ARB', 'GL_DRAW_BUFFER5_ARB',
'GL_DRAW_BUFFER6_ARB', 'GL_DRAW_BUFFER7_ARB', 'GL_DRAW_BUFFER8_ARB',
'GL_DRAW_BUFFER9_ARB', 'GL_DRAW_BUFFER10_ARB', 'GL_DRAW_BUFFER11_ARB',
'GL_DRAW_BUFFER12_ARB', 'GL_DRAW_BUFFER13_ARB', 'GL_DRAW_BUFFER14_ARB',
'GL_DRAW_BUFFER15_ARB', 'GL_TEXTURE_RECTANGLE_ARB',
'GL_TEXTURE_BINDING_RECTANGLE_ARB', 'GL_PROXY_TEXTURE_RECTANGLE_ARB',
'GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB', 'GL_RGBA_FLOAT_MODE_ARB',
'GL_CLAMP_VERTEX_COLOR_ARB', 'GL_CLAMP_FRAGMENT_COLOR_ARB',
'GL_CLAMP_READ_COLOR_ARB', 'GL_FIXED_ONLY_ARB', 'GL_HALF_FLOAT_ARB',
'GL_TEXTURE_RED_TYPE_ARB', 'GL_TEXTURE_GREEN_TYPE_ARB',
'GL_TEXTURE_BLUE_TYPE_ARB', 'GL_TEXTURE_ALPHA_TYPE_ARB',
'GL_TEXTURE_LUMINANCE_TYPE_ARB', 'GL_TEXTURE_INTENSITY_TYPE_ARB',
'GL_TEXTURE_DEPTH_TYPE_ARB', 'GL_UNSIGNED_NORMALIZED_ARB', 'GL_RGBA32F_ARB',
'GL_RGB32F_ARB', 'GL_ALPHA32F_ARB', 'GL_INTENSITY32F_ARB',
'GL_LUMINANCE32F_ARB', 'GL_LUMINANCE_ALPHA32F_ARB', 'GL_RGBA16F_ARB',
'GL_RGB16F_ARB', 'GL_ALPHA16F_ARB', 'GL_INTENSITY16F_ARB',
'GL_LUMINANCE16F_ARB', 'GL_LUMINANCE_ALPHA16F_ARB',
'GL_PIXEL_PACK_BUFFER_ARB', 'GL_PIXEL_UNPACK_BUFFER_ARB',
'GL_PIXEL_PACK_BUFFER_BINDING_ARB', 'GL_PIXEL_UNPACK_BUFFER_BINDING_ARB',
'GL_ABGR_EXT', 'GL_CONSTANT_COLOR_EXT', 'GL_ONE_MINUS_CONSTANT_COLOR_EXT',
'GL_CONSTANT_ALPHA_EXT', 'GL_ONE_MINUS_CONSTANT_ALPHA_EXT',
'GL_BLEND_COLOR_EXT', 'GL_POLYGON_OFFSET_EXT', 'GL_POLYGON_OFFSET_FACTOR_EXT',
'GL_POLYGON_OFFSET_BIAS_EXT', 'GL_ALPHA4_EXT', 'GL_ALPHA8_EXT',
'GL_ALPHA12_EXT', 'GL_ALPHA16_EXT', 'GL_LUMINANCE4_EXT', 'GL_LUMINANCE8_EXT',
'GL_LUMINANCE12_EXT', 'GL_LUMINANCE16_EXT', 'GL_LUMINANCE4_ALPHA4_EXT',
'GL_LUMINANCE6_ALPHA2_EXT', 'GL_LUMINANCE8_ALPHA8_EXT',
'GL_LUMINANCE12_ALPHA4_EXT', 'GL_LUMINANCE12_ALPHA12_EXT',
'GL_LUMINANCE16_ALPHA16_EXT', 'GL_INTENSITY_EXT', 'GL_INTENSITY4_EXT',
'GL_INTENSITY8_EXT', 'GL_INTENSITY12_EXT', 'GL_INTENSITY16_EXT',
'GL_RGB2_EXT', 'GL_RGB4_EXT', 'GL_RGB5_EXT', 'GL_RGB8_EXT', 'GL_RGB10_EXT',
'GL_RGB12_EXT', 'GL_RGB16_EXT', 'GL_RGBA2_EXT', 'GL_RGBA4_EXT',
'GL_RGB5_A1_EXT', 'GL_RGBA8_EXT', 'GL_RGB10_A2_EXT', 'GL_RGBA12_EXT',
'GL_RGBA16_EXT', 'GL_TEXTURE_RED_SIZE_EXT', 'GL_TEXTURE_GREEN_SIZE_EXT',
'GL_TEXTURE_BLUE_SIZE_EXT', 'GL_TEXTURE_ALPHA_SIZE_EXT',
'GL_TEXTURE_LUMINANCE_SIZE_EXT', 'GL_TEXTURE_INTENSITY_SIZE_EXT',
'GL_REPLACE_EXT', 'GL_PROXY_TEXTURE_1D_EXT', 'GL_PROXY_TEXTURE_2D_EXT',
'GL_TEXTURE_TOO_LARGE_EXT', 'GL_PACK_SKIP_IMAGES_EXT',
'GL_PACK_IMAGE_HEIGHT_EXT', 'GL_UNPACK_SKIP_IMAGES_EXT',
'GL_UNPACK_IMAGE_HEIGHT_EXT', 'GL_TEXTURE_3D_EXT', 'GL_PROXY_TEXTURE_3D_EXT',
'GL_TEXTURE_DEPTH_EXT', 'GL_TEXTURE_WRAP_R_EXT', 'GL_MAX_3D_TEXTURE_SIZE_EXT',
'GL_FILTER4_SGIS', 'GL_TEXTURE_FILTER4_SIZE_SGIS', 'GL_HISTOGRAM_EXT',
'GL_PROXY_HISTOGRAM_EXT', 'GL_HISTOGRAM_WIDTH_EXT', 'GL_HISTOGRAM_FORMAT_EXT',
'GL_HISTOGRAM_RED_SIZE_EXT', 'GL_HISTOGRAM_GREEN_SIZE_EXT',
'GL_HISTOGRAM_BLUE_SIZE_EXT', 'GL_HISTOGRAM_ALPHA_SIZE_EXT',
'GL_HISTOGRAM_LUMINANCE_SIZE_EXT', 'GL_HISTOGRAM_SINK_EXT', 'GL_MINMAX_EXT',
'GL_MINMAX_FORMAT_EXT', 'GL_MINMAX_SINK_EXT', 'GL_TABLE_TOO_LARGE_EXT',
'GL_CONVOLUTION_1D_EXT', 'GL_CONVOLUTION_2D_EXT', 'GL_SEPARABLE_2D_EXT',
'GL_CONVOLUTION_BORDER_MODE_EXT', 'GL_CONVOLUTION_FILTER_SCALE_EXT',
'GL_CONVOLUTION_FILTER_BIAS_EXT', 'GL_REDUCE_EXT',
'GL_CONVOLUTION_FORMAT_EXT', 'GL_CONVOLUTION_WIDTH_EXT',
'GL_CONVOLUTION_HEIGHT_EXT', 'GL_MAX_CONVOLUTION_WIDTH_EXT',
'GL_MAX_CONVOLUTION_HEIGHT_EXT', 'GL_POST_CONVOLUTION_RED_SCALE_EXT',
'GL_POST_CONVOLUTION_GREEN_SCALE_EXT', 'GL_POST_CONVOLUTION_BLUE_SCALE_EXT',
'GL_POST_CONVOLUTION_ALPHA_SCALE_EXT', 'GL_POST_CONVOLUTION_RED_BIAS_EXT',
'GL_POST_CONVOLUTION_GREEN_BIAS_EXT', 'GL_POST_CONVOLUTION_BLUE_BIAS_EXT',
'GL_POST_CONVOLUTION_ALPHA_BIAS_EXT', 'GL_COLOR_MATRIX_SGI',
'GL_COLOR_MATRIX_STACK_DEPTH_SGI', 'GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI',
'GL_POST_COLOR_MATRIX_RED_SCALE_SGI', 'GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI',
'GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI', 'GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI',
'GL_POST_COLOR_MATRIX_RED_BIAS_SGI', 'GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI',
'GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI', 'GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI',
'GL_COLOR_TABLE_SGI', 'GL_POST_CONVOLUTION_COLOR_TABLE_SGI',
'GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI', 'GL_PROXY_COLOR_TABLE_SGI',
'GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI',
'GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI', 'GL_COLOR_TABLE_SCALE_SGI',
'GL_COLOR_TABLE_BIAS_SGI', 'GL_COLOR_TABLE_FORMAT_SGI',
'GL_COLOR_TABLE_WIDTH_SGI', 'GL_COLOR_TABLE_RED_SIZE_SGI',
'GL_COLOR_TABLE_GREEN_SIZE_SGI', 'GL_COLOR_TABLE_BLUE_SIZE_SGI',
'GL_COLOR_TABLE_ALPHA_SIZE_SGI', 'GL_COLOR_TABLE_LUMINANCE_SIZE_SGI',
'GL_COLOR_TABLE_INTENSITY_SIZE_SGI', 'GL_PIXEL_TEXTURE_SGIS',
'GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS', 'GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS',
'GL_PIXEL_GROUP_COLOR_SGIS', 'GL_PIXEL_TEX_GEN_SGIX',
'GL_PIXEL_TEX_GEN_MODE_SGIX', 'GL_PACK_SKIP_VOLUMES_SGIS',
'GL_PACK_IMAGE_DEPTH_SGIS', 'GL_UNPACK_SKIP_VOLUMES_SGIS',
'GL_UNPACK_IMAGE_DEPTH_SGIS', 'GL_TEXTURE_4D_SGIS',
'GL_PROXY_TEXTURE_4D_SGIS', 'GL_TEXTURE_4DSIZE_SGIS',
'GL_TEXTURE_WRAP_Q_SGIS', 'GL_MAX_4D_TEXTURE_SIZE_SGIS',
'GL_TEXTURE_4D_BINDING_SGIS', 'GL_TEXTURE_COLOR_TABLE_SGI',
'GL_PROXY_TEXTURE_COLOR_TABLE_SGI', 'GL_CMYK_EXT', 'GL_CMYKA_EXT',
'GL_PACK_CMYK_HINT_EXT', 'GL_UNPACK_CMYK_HINT_EXT', 'GL_TEXTURE_PRIORITY_EXT',
'GL_TEXTURE_RESIDENT_EXT', 'GL_TEXTURE_1D_BINDING_EXT',
'GL_TEXTURE_2D_BINDING_EXT', 'GL_TEXTURE_3D_BINDING_EXT',
'GL_DETAIL_TEXTURE_2D_SGIS', 'GL_DETAIL_TEXTURE_2D_BINDING_SGIS',
'GL_LINEAR_DETAIL_SGIS', 'GL_LINEAR_DETAIL_ALPHA_SGIS',
'GL_LINEAR_DETAIL_COLOR_SGIS', 'GL_DETAIL_TEXTURE_LEVEL_SGIS',
'GL_DETAIL_TEXTURE_MODE_SGIS', 'GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS',
'GL_LINEAR_SHARPEN_SGIS', 'GL_LINEAR_SHARPEN_ALPHA_SGIS',
'GL_LINEAR_SHARPEN_COLOR_SGIS', 'GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS',
'GL_UNSIGNED_BYTE_3_3_2_EXT', 'GL_UNSIGNED_SHORT_4_4_4_4_EXT',
'GL_UNSIGNED_SHORT_5_5_5_1_EXT', 'GL_UNSIGNED_INT_8_8_8_8_EXT',
'GL_UNSIGNED_INT_10_10_10_2_EXT', 'GL_TEXTURE_MIN_LOD_SGIS',
'GL_TEXTURE_MAX_LOD_SGIS', 'GL_TEXTURE_BASE_LEVEL_SGIS',
'GL_TEXTURE_MAX_LEVEL_SGIS', 'GL_MULTISAMPLE_SGIS',
'GL_SAMPLE_ALPHA_TO_MASK_SGIS', 'GL_SAMPLE_ALPHA_TO_ONE_SGIS',
'GL_SAMPLE_MASK_SGIS', 'GL_1PASS_SGIS', 'GL_2PASS_0_SGIS', 'GL_2PASS_1_SGIS',
'GL_4PASS_0_SGIS', 'GL_4PASS_1_SGIS', 'GL_4PASS_2_SGIS', 'GL_4PASS_3_SGIS',
'GL_SAMPLE_BUFFERS_SGIS', 'GL_SAMPLES_SGIS', 'GL_SAMPLE_MASK_VALUE_SGIS',
'GL_SAMPLE_MASK_INVERT_SGIS', 'GL_SAMPLE_PATTERN_SGIS',
'GL_RESCALE_NORMAL_EXT', 'GL_VERTEX_ARRAY_EXT', 'GL_NORMAL_ARRAY_EXT',
'GL_COLOR_ARRAY_EXT', 'GL_INDEX_ARRAY_EXT', 'GL_TEXTURE_COORD_ARRAY_EXT',
'GL_EDGE_FLAG_ARRAY_EXT', 'GL_VERTEX_ARRAY_SIZE_EXT',
'GL_VERTEX_ARRAY_TYPE_EXT', 'GL_VERTEX_ARRAY_STRIDE_EXT',
'GL_VERTEX_ARRAY_COUNT_EXT', 'GL_NORMAL_ARRAY_TYPE_EXT',
'GL_NORMAL_ARRAY_STRIDE_EXT', 'GL_NORMAL_ARRAY_COUNT_EXT',
'GL_COLOR_ARRAY_SIZE_EXT', 'GL_COLOR_ARRAY_TYPE_EXT',
'GL_COLOR_ARRAY_STRIDE_EXT', 'GL_COLOR_ARRAY_COUNT_EXT',
'GL_INDEX_ARRAY_TYPE_EXT', 'GL_INDEX_ARRAY_STRIDE_EXT',
'GL_INDEX_ARRAY_COUNT_EXT', 'GL_TEXTURE_COORD_ARRAY_SIZE_EXT',
'GL_TEXTURE_COORD_ARRAY_TYPE_EXT', 'GL_TEXTURE_COORD_ARRAY_STRIDE_EXT',
'GL_TEXTURE_COORD_ARRAY_COUNT_EXT', 'GL_EDGE_FLAG_ARRAY_STRIDE_EXT',
'GL_EDGE_FLAG_ARRAY_COUNT_EXT', 'GL_VERTEX_ARRAY_POINTER_EXT',
'GL_NORMAL_ARRAY_POINTER_EXT', 'GL_COLOR_ARRAY_POINTER_EXT',
'GL_INDEX_ARRAY_POINTER_EXT', 'GL_TEXTURE_COORD_ARRAY_POINTER_EXT',
'GL_EDGE_FLAG_ARRAY_POINTER_EXT', 'GL_GENERATE_MIPMAP_SGIS',
'GL_GENERATE_MIPMAP_HINT_SGIS', 'GL_LINEAR_CLIPMAP_LINEAR_SGIX',
'GL_TEXTURE_CLIPMAP_CENTER_SGIX', 'GL_TEXTURE_CLIPMAP_FRAME_SGIX',
'GL_TEXTURE_CLIPMAP_OFFSET_SGIX', 'GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX',
'GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX', 'GL_TEXTURE_CLIPMAP_DEPTH_SGIX',
'GL_MAX_CLIPMAP_DEPTH_SGIX', 'GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX',
'GL_NEAREST_CLIPMAP_NEAREST_SGIX', 'GL_NEAREST_CLIPMAP_LINEAR_SGIX',
'GL_LINEAR_CLIPMAP_NEAREST_SGIX', 'GL_TEXTURE_COMPARE_SGIX',
'GL_TEXTURE_COMPARE_OPERATOR_SGIX', 'GL_TEXTURE_LEQUAL_R_SGIX',
'GL_TEXTURE_GEQUAL_R_SGIX', 'GL_CLAMP_TO_EDGE_SGIS',
'GL_CLAMP_TO_BORDER_SGIS', 'GL_FUNC_ADD_EXT', 'GL_MIN_EXT', 'GL_MAX_EXT',
'GL_BLEND_EQUATION_EXT', 'GL_FUNC_SUBTRACT_EXT',
'GL_FUNC_REVERSE_SUBTRACT_EXT', 'GL_INTERLACE_SGIX',
'GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX', 'GL_PIXEL_TILE_CACHE_INCREMENT_SGIX',
'GL_PIXEL_TILE_WIDTH_SGIX', 'GL_PIXEL_TILE_HEIGHT_SGIX',
'GL_PIXEL_TILE_GRID_WIDTH_SGIX', 'GL_PIXEL_TILE_GRID_HEIGHT_SGIX',
'GL_PIXEL_TILE_GRID_DEPTH_SGIX', 'GL_PIXEL_TILE_CACHE_SIZE_SGIX',
'GL_DUAL_ALPHA4_SGIS', 'GL_DUAL_ALPHA8_SGIS', 'GL_DUAL_ALPHA12_SGIS',
'GL_DUAL_ALPHA16_SGIS', 'GL_DUAL_LUMINANCE4_SGIS', 'GL_DUAL_LUMINANCE8_SGIS',
'GL_DUAL_LUMINANCE12_SGIS', 'GL_DUAL_LUMINANCE16_SGIS',
'GL_DUAL_INTENSITY4_SGIS', 'GL_DUAL_INTENSITY8_SGIS',
'GL_DUAL_INTENSITY12_SGIS', 'GL_DUAL_INTENSITY16_SGIS',
'GL_DUAL_LUMINANCE_ALPHA4_SGIS', 'GL_DUAL_LUMINANCE_ALPHA8_SGIS',
'GL_QUAD_ALPHA4_SGIS', 'GL_QUAD_ALPHA8_SGIS', 'GL_QUAD_LUMINANCE4_SGIS',
'GL_QUAD_LUMINANCE8_SGIS', 'GL_QUAD_INTENSITY4_SGIS',
'GL_QUAD_INTENSITY8_SGIS', 'GL_DUAL_TEXTURE_SELECT_SGIS',
'GL_QUAD_TEXTURE_SELECT_SGIS', 'GL_SPRITE_SGIX', 'GL_SPRITE_MODE_SGIX',
'GL_SPRITE_AXIS_SGIX', 'GL_SPRITE_TRANSLATION_SGIX', 'GL_SPRITE_AXIAL_SGIX',
'GL_SPRITE_OBJECT_ALIGNED_SGIX', 'GL_SPRITE_EYE_ALIGNED_SGIX',
'GL_TEXTURE_MULTI_BUFFER_HINT_SGIX', 'GL_POINT_SIZE_MIN_EXT',
'GL_POINT_SIZE_MAX_EXT', 'GL_POINT_FADE_THRESHOLD_SIZE_EXT',
'GL_DISTANCE_ATTENUATION_EXT', 'GL_POINT_SIZE_MIN_SGIS',
'GL_POINT_SIZE_MAX_SGIS', 'GL_POINT_FADE_THRESHOLD_SIZE_SGIS',
'GL_DISTANCE_ATTENUATION_SGIS', 'GL_INSTRUMENT_BUFFER_POINTER_SGIX',
'GL_INSTRUMENT_MEASUREMENTS_SGIX', 'GL_POST_TEXTURE_FILTER_BIAS_SGIX',
'GL_POST_TEXTURE_FILTER_SCALE_SGIX', 'GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX',
'GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX', 'GL_FRAMEZOOM_SGIX',
'GL_FRAMEZOOM_FACTOR_SGIX', 'GL_MAX_FRAMEZOOM_FACTOR_SGIX',
'GL_TEXTURE_DEFORMATION_BIT_SGIX', 'GL_GEOMETRY_DEFORMATION_BIT_SGIX',
'GL_GEOMETRY_DEFORMATION_SGIX', 'GL_TEXTURE_DEFORMATION_SGIX',
'GL_DEFORMATIONS_MASK_SGIX', 'GL_MAX_DEFORMATION_ORDER_SGIX',
'GL_REFERENCE_PLANE_SGIX', 'GL_REFERENCE_PLANE_EQUATION_SGIX',
'GL_DEPTH_COMPONENT16_SGIX', 'GL_DEPTH_COMPONENT24_SGIX',
'GL_DEPTH_COMPONENT32_SGIX', 'GL_FOG_FUNC_SGIS', 'GL_FOG_FUNC_POINTS_SGIS',
'GL_MAX_FOG_FUNC_POINTS_SGIS', 'GL_FOG_OFFSET_SGIX',
'GL_FOG_OFFSET_VALUE_SGIX', 'GL_IMAGE_SCALE_X_HP', 'GL_IMAGE_SCALE_Y_HP',
'GL_IMAGE_TRANSLATE_X_HP', 'GL_IMAGE_TRANSLATE_Y_HP',
'GL_IMAGE_ROTATE_ANGLE_HP', 'GL_IMAGE_ROTATE_ORIGIN_X_HP',
'GL_IMAGE_ROTATE_ORIGIN_Y_HP', 'GL_IMAGE_MAG_FILTER_HP',
'GL_IMAGE_MIN_FILTER_HP', 'GL_IMAGE_CUBIC_WEIGHT_HP', 'GL_CUBIC_HP',
'GL_AVERAGE_HP', 'GL_IMAGE_TRANSFORM_2D_HP',
'GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP',
'GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP', 'GL_IGNORE_BORDER_HP',
'GL_CONSTANT_BORDER_HP', 'GL_REPLICATE_BORDER_HP',
'GL_CONVOLUTION_BORDER_COLOR_HP', 'GL_TEXTURE_ENV_BIAS_SGIX',
'GL_VERTEX_DATA_HINT_PGI', 'GL_VERTEX_CONSISTENT_HINT_PGI',
'GL_MATERIAL_SIDE_HINT_PGI', 'GL_MAX_VERTEX_HINT_PGI', 'GL_COLOR3_BIT_PGI',
'GL_COLOR4_BIT_PGI', 'GL_EDGEFLAG_BIT_PGI', 'GL_INDEX_BIT_PGI',
'GL_MAT_AMBIENT_BIT_PGI', 'GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI',
'GL_MAT_DIFFUSE_BIT_PGI', 'GL_MAT_EMISSION_BIT_PGI',
'GL_MAT_COLOR_INDEXES_BIT_PGI', 'GL_MAT_SHININESS_BIT_PGI',
'GL_MAT_SPECULAR_BIT_PGI', 'GL_NORMAL_BIT_PGI', 'GL_TEXCOORD1_BIT_PGI',
'GL_TEXCOORD2_BIT_PGI', 'GL_TEXCOORD3_BIT_PGI', 'GL_TEXCOORD4_BIT_PGI',
'GL_VERTEX23_BIT_PGI', 'GL_VERTEX4_BIT_PGI',
'GL_PREFER_DOUBLEBUFFER_HINT_PGI', 'GL_CONSERVE_MEMORY_HINT_PGI',
'GL_RECLAIM_MEMORY_HINT_PGI', 'GL_NATIVE_GRAPHICS_HANDLE_PGI',
'GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI', 'GL_NATIVE_GRAPHICS_END_HINT_PGI',
'GL_ALWAYS_FAST_HINT_PGI', 'GL_ALWAYS_SOFT_HINT_PGI',
'GL_ALLOW_DRAW_OBJ_HINT_PGI', 'GL_ALLOW_DRAW_WIN_HINT_PGI',
'GL_ALLOW_DRAW_FRG_HINT_PGI', 'GL_ALLOW_DRAW_MEM_HINT_PGI',
'GL_STRICT_DEPTHFUNC_HINT_PGI', 'GL_STRICT_LIGHTING_HINT_PGI',
'GL_STRICT_SCISSOR_HINT_PGI', 'GL_FULL_STIPPLE_HINT_PGI',
'GL_CLIP_NEAR_HINT_PGI', 'GL_CLIP_FAR_HINT_PGI', 'GL_WIDE_LINE_HINT_PGI',
'GL_BACK_NORMALS_HINT_PGI', 'GL_COLOR_INDEX1_EXT', 'GL_COLOR_INDEX2_EXT',
'GL_COLOR_INDEX4_EXT', 'GL_COLOR_INDEX8_EXT', 'GL_COLOR_INDEX12_EXT',
'GL_COLOR_INDEX16_EXT', 'GL_TEXTURE_INDEX_SIZE_EXT',
'GL_CLIP_VOLUME_CLIPPING_HINT_EXT', 'GL_LIST_PRIORITY_SGIX',
'GL_IR_INSTRUMENT1_SGIX', 'GL_CALLIGRAPHIC_FRAGMENT_SGIX',
'GL_TEXTURE_LOD_BIAS_S_SGIX', 'GL_TEXTURE_LOD_BIAS_T_SGIX',
'GL_TEXTURE_LOD_BIAS_R_SGIX', 'GL_SHADOW_AMBIENT_SGIX',
'GL_INDEX_MATERIAL_EXT', 'GL_INDEX_MATERIAL_PARAMETER_EXT',
'GL_INDEX_MATERIAL_FACE_EXT', 'GL_INDEX_TEST_EXT', 'GL_INDEX_TEST_FUNC_EXT',
'GL_INDEX_TEST_REF_EXT', 'GL_IUI_V2F_EXT', 'GL_IUI_V3F_EXT',
'GL_IUI_N3F_V2F_EXT', 'GL_IUI_N3F_V3F_EXT', 'GL_T2F_IUI_V2F_EXT',
'GL_T2F_IUI_V3F_EXT', 'GL_T2F_IUI_N3F_V2F_EXT', 'GL_T2F_IUI_N3F_V3F_EXT',
'GL_ARRAY_ELEMENT_LOCK_FIRST_EXT', 'GL_ARRAY_ELEMENT_LOCK_COUNT_EXT',
'GL_CULL_VERTEX_EXT', 'GL_CULL_VERTEX_EYE_POSITION_EXT',
'GL_CULL_VERTEX_OBJECT_POSITION_EXT', 'GL_YCRCB_422_SGIX',
'GL_YCRCB_444_SGIX', 'GL_FRAGMENT_LIGHTING_SGIX',
'GL_FRAGMENT_COLOR_MATERIAL_SGIX', 'GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX',
'GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX', 'GL_MAX_FRAGMENT_LIGHTS_SGIX',
'GL_MAX_ACTIVE_LIGHTS_SGIX', 'GL_CURRENT_RASTER_NORMAL_SGIX',
'GL_LIGHT_ENV_MODE_SGIX', 'GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX',
'GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX',
'GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX',
'GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX',
'GL_FRAGMENT_LIGHT0_SGIX', 'GL_FRAGMENT_LIGHT1_SGIX',
'GL_FRAGMENT_LIGHT2_SGIX', 'GL_FRAGMENT_LIGHT3_SGIX',
'GL_FRAGMENT_LIGHT4_SGIX', 'GL_FRAGMENT_LIGHT5_SGIX',
'GL_FRAGMENT_LIGHT6_SGIX', 'GL_FRAGMENT_LIGHT7_SGIX',
'GL_RASTER_POSITION_UNCLIPPED_IBM', 'GL_TEXTURE_LIGHTING_MODE_HP',
'GL_TEXTURE_POST_SPECULAR_HP', 'GL_TEXTURE_PRE_SPECULAR_HP',
'GL_MAX_ELEMENTS_VERTICES_EXT', 'GL_MAX_ELEMENTS_INDICES_EXT', 'GL_PHONG_WIN',
'GL_PHONG_HINT_WIN', 'GL_FOG_SPECULAR_TEXTURE_WIN',
'GL_FRAGMENT_MATERIAL_EXT', 'GL_FRAGMENT_NORMAL_EXT', 'GL_FRAGMENT_COLOR_EXT',
'GL_ATTENUATION_EXT', 'GL_SHADOW_ATTENUATION_EXT',
'GL_TEXTURE_APPLICATION_MODE_EXT', 'GL_TEXTURE_LIGHT_EXT',
'GL_TEXTURE_MATERIAL_FACE_EXT', 'GL_TEXTURE_MATERIAL_PARAMETER_EXT',
'GL_ALPHA_MIN_SGIX', 'GL_ALPHA_MAX_SGIX', 'GL_PIXEL_TEX_GEN_Q_CEILING_SGIX',
'GL_PIXEL_TEX_GEN_Q_ROUND_SGIX', 'GL_PIXEL_TEX_GEN_Q_FLOOR_SGIX',
'GL_PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX',
'GL_PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX', 'GL_PIXEL_TEX_GEN_ALPHA_LS_SGIX',
'GL_PIXEL_TEX_GEN_ALPHA_MS_SGIX', 'GL_BGR_EXT', 'GL_BGRA_EXT',
'GL_ASYNC_MARKER_SGIX', 'GL_ASYNC_TEX_IMAGE_SGIX',
'GL_ASYNC_DRAW_PIXELS_SGIX', 'GL_ASYNC_READ_PIXELS_SGIX',
'GL_MAX_ASYNC_TEX_IMAGE_SGIX', 'GL_MAX_ASYNC_DRAW_PIXELS_SGIX',
'GL_MAX_ASYNC_READ_PIXELS_SGIX', 'GL_ASYNC_HISTOGRAM_SGIX',
'GL_MAX_ASYNC_HISTOGRAM_SGIX', 'GL_PARALLEL_ARRAYS_INTEL',
'GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL',
'GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL',
'GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL',
'GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL', 'GL_OCCLUSION_TEST_HP',
'GL_OCCLUSION_TEST_RESULT_HP', 'GL_PIXEL_TRANSFORM_2D_EXT',
'GL_PIXEL_MAG_FILTER_EXT', 'GL_PIXEL_MIN_FILTER_EXT',
'GL_PIXEL_CUBIC_WEIGHT_EXT', 'GL_CUBIC_EXT', 'GL_AVERAGE_EXT',
'GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT',
'GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT',
'GL_PIXEL_TRANSFORM_2D_MATRIX_EXT', 'GL_SHARED_TEXTURE_PALETTE_EXT',
'GL_LIGHT_MODEL_COLOR_CONTROL_EXT', 'GL_SINGLE_COLOR_EXT',
'GL_SEPARATE_SPECULAR_COLOR_EXT', 'GL_COLOR_SUM_EXT',
'GL_CURRENT_SECONDARY_COLOR_EXT', 'GL_SECONDARY_COLOR_ARRAY_SIZE_EXT',
'GL_SECONDARY_COLOR_ARRAY_TYPE_EXT', 'GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT',
'GL_SECONDARY_COLOR_ARRAY_POINTER_EXT', 'GL_SECONDARY_COLOR_ARRAY_EXT',
'GL_PERTURB_EXT', 'GL_TEXTURE_NORMAL_EXT', 'GL_FOG_COORDINATE_SOURCE_EXT',
'GL_FOG_COORDINATE_EXT', 'GL_FRAGMENT_DEPTH_EXT',
'GL_CURRENT_FOG_COORDINATE_EXT', 'GL_FOG_COORDINATE_ARRAY_TYPE_EXT',
'GL_FOG_COORDINATE_ARRAY_STRIDE_EXT', 'GL_FOG_COORDINATE_ARRAY_POINTER_EXT',
'GL_FOG_COORDINATE_ARRAY_EXT', 'GL_SCREEN_COORDINATES_REND',
'GL_INVERTED_SCREEN_W_REND', 'GL_TANGENT_ARRAY_EXT', 'GL_BINORMAL_ARRAY_EXT',
'GL_CURRENT_TANGENT_EXT', 'GL_CURRENT_BINORMAL_EXT',
'GL_TANGENT_ARRAY_TYPE_EXT', 'GL_TANGENT_ARRAY_STRIDE_EXT',
'GL_BINORMAL_ARRAY_TYPE_EXT', 'GL_BINORMAL_ARRAY_STRIDE_EXT',
'GL_TANGENT_ARRAY_POINTER_EXT', 'GL_BINORMAL_ARRAY_POINTER_EXT',
'GL_MAP1_TANGENT_EXT', 'GL_MAP2_TANGENT_EXT', 'GL_MAP1_BINORMAL_EXT',
'GL_MAP2_BINORMAL_EXT', 'GL_COMBINE_EXT', 'GL_COMBINE_RGB_EXT',
'GL_COMBINE_ALPHA_EXT', 'GL_RGB_SCALE_EXT', 'GL_ADD_SIGNED_EXT',
'GL_INTERPOLATE_EXT', 'GL_CONSTANT_EXT', 'GL_PRIMARY_COLOR_EXT',
'GL_PREVIOUS_EXT', 'GL_SOURCE0_RGB_EXT', 'GL_SOURCE1_RGB_EXT',
'GL_SOURCE2_RGB_EXT', 'GL_SOURCE0_ALPHA_EXT', 'GL_SOURCE1_ALPHA_EXT',
'GL_SOURCE2_ALPHA_EXT', 'GL_OPERAND0_RGB_EXT', 'GL_OPERAND1_RGB_EXT',
'GL_OPERAND2_RGB_EXT', 'GL_OPERAND0_ALPHA_EXT', 'GL_OPERAND1_ALPHA_EXT',
'GL_OPERAND2_ALPHA_EXT', 'GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE',
'GL_TRANSFORM_HINT_APPLE', 'GL_FOG_SCALE_SGIX', 'GL_FOG_SCALE_VALUE_SGIX',
'GL_UNPACK_CONSTANT_DATA_SUNX', 'GL_TEXTURE_CONSTANT_DATA_SUNX',
'GL_GLOBAL_ALPHA_SUN', 'GL_GLOBAL_ALPHA_FACTOR_SUN', 'GL_RESTART_SUN',
'GL_REPLACE_MIDDLE_SUN', 'GL_REPLACE_OLDEST_SUN', 'GL_TRIANGLE_LIST_SUN',
'GL_REPLACEMENT_CODE_SUN', 'GL_REPLACEMENT_CODE_ARRAY_SUN',
'GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN', 'GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN',
'GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN', 'GL_R1UI_V3F_SUN',
'GL_R1UI_C4UB_V3F_SUN', 'GL_R1UI_C3F_V3F_SUN', 'GL_R1UI_N3F_V3F_SUN',
'GL_R1UI_C4F_N3F_V3F_SUN', 'GL_R1UI_T2F_V3F_SUN', 'GL_R1UI_T2F_N3F_V3F_SUN',
'GL_R1UI_T2F_C4F_N3F_V3F_SUN', 'GL_BLEND_DST_RGB_EXT', 'GL_BLEND_SRC_RGB_EXT',
'GL_BLEND_DST_ALPHA_EXT', 'GL_BLEND_SRC_ALPHA_EXT', 'GL_RED_MIN_CLAMP_INGR',
'GL_GREEN_MIN_CLAMP_INGR', 'GL_BLUE_MIN_CLAMP_INGR',
'GL_ALPHA_MIN_CLAMP_INGR', 'GL_RED_MAX_CLAMP_INGR', 'GL_GREEN_MAX_CLAMP_INGR',
'GL_BLUE_MAX_CLAMP_INGR', 'GL_ALPHA_MAX_CLAMP_INGR', 'GL_INTERLACE_READ_INGR',
'GL_INCR_WRAP_EXT', 'GL_DECR_WRAP_EXT', 'GL_422_EXT', 'GL_422_REV_EXT',
'GL_422_AVERAGE_EXT', 'GL_422_REV_AVERAGE_EXT', 'GL_NORMAL_MAP_NV',
'GL_REFLECTION_MAP_NV', 'GL_NORMAL_MAP_EXT', 'GL_REFLECTION_MAP_EXT',
'GL_TEXTURE_CUBE_MAP_EXT', 'GL_TEXTURE_BINDING_CUBE_MAP_EXT',
'GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT',
'GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT',
'GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT', 'GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT',
'GL_PROXY_TEXTURE_CUBE_MAP_EXT', 'GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT',
'GL_WRAP_BORDER_SUN', 'GL_MAX_TEXTURE_LOD_BIAS_EXT',
'GL_TEXTURE_FILTER_CONTROL_EXT', 'GL_TEXTURE_LOD_BIAS_EXT',
'GL_TEXTURE_MAX_ANISOTROPY_EXT', 'GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT',
'GL_MODELVIEW0_STACK_DEPTH_EXT', 'GL_MODELVIEW1_STACK_DEPTH_EXT',
'GL_MODELVIEW0_MATRIX_EXT', 'GL_MODELVIEW1_MATRIX_EXT',
'GL_VERTEX_WEIGHTING_EXT', 'GL_MODELVIEW0_EXT', 'GL_MODELVIEW1_EXT',
'GL_CURRENT_VERTEX_WEIGHT_EXT', 'GL_VERTEX_WEIGHT_ARRAY_EXT',
'GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT', 'GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT',
'GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT', 'GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT',
'GL_MAX_SHININESS_NV', 'GL_MAX_SPOT_EXPONENT_NV', 'GL_VERTEX_ARRAY_RANGE_NV',
'GL_VERTEX_ARRAY_RANGE_LENGTH_NV', 'GL_VERTEX_ARRAY_RANGE_VALID_NV',
'GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV', 'GL_VERTEX_ARRAY_RANGE_POINTER_NV',
'GL_REGISTER_COMBINERS_NV', 'GL_VARIABLE_A_NV', 'GL_VARIABLE_B_NV',
'GL_VARIABLE_C_NV', 'GL_VARIABLE_D_NV', 'GL_VARIABLE_E_NV',
'GL_VARIABLE_F_NV', 'GL_VARIABLE_G_NV', 'GL_CONSTANT_COLOR0_NV',
'GL_CONSTANT_COLOR1_NV', 'GL_PRIMARY_COLOR_NV', 'GL_SECONDARY_COLOR_NV',
'GL_SPARE0_NV', 'GL_SPARE1_NV', 'GL_DISCARD_NV', 'GL_E_TIMES_F_NV',
'GL_SPARE0_PLUS_SECONDARY_COLOR_NV', 'GL_UNSIGNED_IDENTITY_NV',
'GL_UNSIGNED_INVERT_NV', 'GL_EXPAND_NORMAL_NV', 'GL_EXPAND_NEGATE_NV',
'GL_HALF_BIAS_NORMAL_NV', 'GL_HALF_BIAS_NEGATE_NV', 'GL_SIGNED_IDENTITY_NV',
'GL_SIGNED_NEGATE_NV', 'GL_SCALE_BY_TWO_NV', 'GL_SCALE_BY_FOUR_NV',
'GL_SCALE_BY_ONE_HALF_NV', 'GL_BIAS_BY_NEGATIVE_ONE_HALF_NV',
'GL_COMBINER_INPUT_NV', 'GL_COMBINER_MAPPING_NV',
'GL_COMBINER_COMPONENT_USAGE_NV', 'GL_COMBINER_AB_DOT_PRODUCT_NV',
'GL_COMBINER_CD_DOT_PRODUCT_NV', 'GL_COMBINER_MUX_SUM_NV',
'GL_COMBINER_SCALE_NV', 'GL_COMBINER_BIAS_NV', 'GL_COMBINER_AB_OUTPUT_NV',
'GL_COMBINER_CD_OUTPUT_NV', 'GL_COMBINER_SUM_OUTPUT_NV',
'GL_MAX_GENERAL_COMBINERS_NV', 'GL_NUM_GENERAL_COMBINERS_NV',
'GL_COLOR_SUM_CLAMP_NV', 'GL_COMBINER0_NV', 'GL_COMBINER1_NV',
'GL_COMBINER2_NV', 'GL_COMBINER3_NV', 'GL_COMBINER4_NV', 'GL_COMBINER5_NV',
'GL_COMBINER6_NV', 'GL_COMBINER7_NV', 'GL_FOG_DISTANCE_MODE_NV',
'GL_EYE_RADIAL_NV', 'GL_EYE_PLANE_ABSOLUTE_NV', 'GL_EMBOSS_LIGHT_NV',
'GL_EMBOSS_CONSTANT_NV', 'GL_EMBOSS_MAP_NV', 'GL_COMBINE4_NV',
'GL_SOURCE3_RGB_NV', 'GL_SOURCE3_ALPHA_NV', 'GL_OPERAND3_RGB_NV',
'GL_OPERAND3_ALPHA_NV', 'GL_COMPRESSED_RGB_S3TC_DXT1_EXT',
'GL_COMPRESSED_RGBA_S3TC_DXT1_EXT', 'GL_COMPRESSED_RGBA_S3TC_DXT3_EXT',
'GL_COMPRESSED_RGBA_S3TC_DXT5_EXT', 'GL_CULL_VERTEX_IBM',
'GL_VERTEX_ARRAY_LIST_IBM', 'GL_NORMAL_ARRAY_LIST_IBM',
'GL_COLOR_ARRAY_LIST_IBM', 'GL_INDEX_ARRAY_LIST_IBM',
'GL_TEXTURE_COORD_ARRAY_LIST_IBM', 'GL_EDGE_FLAG_ARRAY_LIST_IBM',
'GL_FOG_COORDINATE_ARRAY_LIST_IBM', 'GL_SECONDARY_COLOR_ARRAY_LIST_IBM',
'GL_VERTEX_ARRAY_LIST_STRIDE_IBM', 'GL_NORMAL_ARRAY_LIST_STRIDE_IBM',
'GL_COLOR_ARRAY_LIST_STRIDE_IBM', 'GL_INDEX_ARRAY_LIST_STRIDE_IBM',
'GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM',
'GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM',
'GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM',
'GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM', 'GL_PACK_SUBSAMPLE_RATE_SGIX',
'GL_UNPACK_SUBSAMPLE_RATE_SGIX', 'GL_PIXEL_SUBSAMPLE_4444_SGIX',
'GL_PIXEL_SUBSAMPLE_2424_SGIX', 'GL_PIXEL_SUBSAMPLE_4242_SGIX',
'GL_YCRCB_SGIX', 'GL_YCRCBA_SGIX', 'GL_DEPTH_PASS_INSTRUMENT_SGIX',
'GL_DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX', 'GL_DEPTH_PASS_INSTRUMENT_MAX_SGIX',
'GL_COMPRESSED_RGB_FXT1_3DFX', 'GL_COMPRESSED_RGBA_FXT1_3DFX',
'GL_MULTISAMPLE_3DFX', 'GL_SAMPLE_BUFFERS_3DFX', 'GL_SAMPLES_3DFX',
'GL_MULTISAMPLE_BIT_3DFX', 'GL_MULTISAMPLE_EXT',
'GL_SAMPLE_ALPHA_TO_MASK_EXT', 'GL_SAMPLE_ALPHA_TO_ONE_EXT',
'GL_SAMPLE_MASK_EXT', 'GL_1PASS_EXT', 'GL_2PASS_0_EXT', 'GL_2PASS_1_EXT',
'GL_4PASS_0_EXT', 'GL_4PASS_1_EXT', 'GL_4PASS_2_EXT', 'GL_4PASS_3_EXT',
'GL_SAMPLE_BUFFERS_EXT', 'GL_SAMPLES_EXT', 'GL_SAMPLE_MASK_VALUE_EXT',
'GL_SAMPLE_MASK_INVERT_EXT', 'GL_SAMPLE_PATTERN_EXT',
'GL_MULTISAMPLE_BIT_EXT', 'GL_VERTEX_PRECLIP_SGIX',
'GL_VERTEX_PRECLIP_HINT_SGIX', 'GL_CONVOLUTION_HINT_SGIX',
'GL_PACK_RESAMPLE_SGIX', 'GL_UNPACK_RESAMPLE_SGIX',
'GL_RESAMPLE_REPLICATE_SGIX', 'GL_RESAMPLE_ZERO_FILL_SGIX',
'GL_RESAMPLE_DECIMATE_SGIX', 'GL_EYE_DISTANCE_TO_POINT_SGIS',
'GL_OBJECT_DISTANCE_TO_POINT_SGIS', 'GL_EYE_DISTANCE_TO_LINE_SGIS',
'GL_OBJECT_DISTANCE_TO_LINE_SGIS', 'GL_EYE_POINT_SGIS',
'GL_OBJECT_POINT_SGIS', 'GL_EYE_LINE_SGIS', 'GL_OBJECT_LINE_SGIS',
'GL_TEXTURE_COLOR_WRITEMASK_SGIS', 'GL_DOT3_RGB_EXT', 'GL_DOT3_RGBA_EXT',
'GL_MIRROR_CLAMP_ATI', 'GL_MIRROR_CLAMP_TO_EDGE_ATI', 'GL_ALL_COMPLETED_NV',
'GL_FENCE_STATUS_NV', 'GL_FENCE_CONDITION_NV', 'GL_MIRRORED_REPEAT_IBM',
'GL_EVAL_2D_NV', 'GL_EVAL_TRIANGULAR_2D_NV', 'GL_MAP_TESSELLATION_NV',
'GL_MAP_ATTRIB_U_ORDER_NV', 'GL_MAP_ATTRIB_V_ORDER_NV',
'GL_EVAL_FRACTIONAL_TESSELLATION_NV', 'GL_EVAL_VERTEX_ATTRIB0_NV',
'GL_EVAL_VERTEX_ATTRIB1_NV', 'GL_EVAL_VERTEX_ATTRIB2_NV',
'GL_EVAL_VERTEX_ATTRIB3_NV', 'GL_EVAL_VERTEX_ATTRIB4_NV',
'GL_EVAL_VERTEX_ATTRIB5_NV', 'GL_EVAL_VERTEX_ATTRIB6_NV',
'GL_EVAL_VERTEX_ATTRIB7_NV', 'GL_EVAL_VERTEX_ATTRIB8_NV',
'GL_EVAL_VERTEX_ATTRIB9_NV', 'GL_EVAL_VERTEX_ATTRIB10_NV',
'GL_EVAL_VERTEX_ATTRIB11_NV', 'GL_EVAL_VERTEX_ATTRIB12_NV',
'GL_EVAL_VERTEX_ATTRIB13_NV', 'GL_EVAL_VERTEX_ATTRIB14_NV',
'GL_EVAL_VERTEX_ATTRIB15_NV', 'GL_MAX_MAP_TESSELLATION_NV',
'GL_MAX_RATIONAL_EVAL_ORDER_NV', 'GL_DEPTH_STENCIL_NV',
'GL_UNSIGNED_INT_24_8_NV', 'GL_PER_STAGE_CONSTANTS_NV',
'GL_TEXTURE_RECTANGLE_NV', 'GL_TEXTURE_BINDING_RECTANGLE_NV',
'GL_PROXY_TEXTURE_RECTANGLE_NV', 'GL_MAX_RECTANGLE_TEXTURE_SIZE_NV',
'GL_OFFSET_TEXTURE_RECTANGLE_NV', 'GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV',
'GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV',
'GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV', 'GL_UNSIGNED_INT_S8_S8_8_8_NV',
'GL_UNSIGNED_INT_8_8_S8_S8_REV_NV', 'GL_DSDT_MAG_INTENSITY_NV',
'GL_SHADER_CONSISTENT_NV', 'GL_TEXTURE_SHADER_NV', 'GL_SHADER_OPERATION_NV',
'GL_CULL_MODES_NV', 'GL_OFFSET_TEXTURE_MATRIX_NV',
'GL_OFFSET_TEXTURE_SCALE_NV', 'GL_OFFSET_TEXTURE_BIAS_NV',
'GL_OFFSET_TEXTURE_2D_MATRIX_NV', 'GL_OFFSET_TEXTURE_2D_SCALE_NV',
'GL_OFFSET_TEXTURE_2D_BIAS_NV', 'GL_PREVIOUS_TEXTURE_INPUT_NV',
'GL_CONST_EYE_NV', 'GL_PASS_THROUGH_NV', 'GL_CULL_FRAGMENT_NV',
'GL_OFFSET_TEXTURE_2D_NV', 'GL_DEPENDENT_AR_TEXTURE_2D_NV',
'GL_DEPENDENT_GB_TEXTURE_2D_NV', 'GL_DOT_PRODUCT_NV',
'GL_DOT_PRODUCT_DEPTH_REPLACE_NV', 'GL_DOT_PRODUCT_TEXTURE_2D_NV',
'GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV', 'GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV',
'GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV',
'GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV', 'GL_HILO_NV', 'GL_DSDT_NV',
'GL_DSDT_MAG_NV', 'GL_DSDT_MAG_VIB_NV', 'GL_HILO16_NV', 'GL_SIGNED_HILO_NV',
'GL_SIGNED_HILO16_NV', 'GL_SIGNED_RGBA_NV', 'GL_SIGNED_RGBA8_NV',
'GL_SIGNED_RGB_NV', 'GL_SIGNED_RGB8_NV', 'GL_SIGNED_LUMINANCE_NV',
'GL_SIGNED_LUMINANCE8_NV', 'GL_SIGNED_LUMINANCE_ALPHA_NV',
'GL_SIGNED_LUMINANCE8_ALPHA8_NV', 'GL_SIGNED_ALPHA_NV', 'GL_SIGNED_ALPHA8_NV',
'GL_SIGNED_INTENSITY_NV', 'GL_SIGNED_INTENSITY8_NV', 'GL_DSDT8_NV',
'GL_DSDT8_MAG8_NV', 'GL_DSDT8_MAG8_INTENSITY8_NV',
'GL_SIGNED_RGB_UNSIGNED_ALPHA_NV', 'GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV',
'GL_HI_SCALE_NV', 'GL_LO_SCALE_NV', 'GL_DS_SCALE_NV', 'GL_DT_SCALE_NV',
'GL_MAGNITUDE_SCALE_NV', 'GL_VIBRANCE_SCALE_NV', 'GL_HI_BIAS_NV',
'GL_LO_BIAS_NV', 'GL_DS_BIAS_NV', 'GL_DT_BIAS_NV', 'GL_MAGNITUDE_BIAS_NV',
'GL_VIBRANCE_BIAS_NV', 'GL_TEXTURE_BORDER_VALUES_NV', 'GL_TEXTURE_HI_SIZE_NV',
'GL_TEXTURE_LO_SIZE_NV', 'GL_TEXTURE_DS_SIZE_NV', 'GL_TEXTURE_DT_SIZE_NV',
'GL_TEXTURE_MAG_SIZE_NV', 'GL_DOT_PRODUCT_TEXTURE_3D_NV',
'GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV', 'GL_VERTEX_PROGRAM_NV',
'GL_VERTEX_STATE_PROGRAM_NV', 'GL_ATTRIB_ARRAY_SIZE_NV',
'GL_ATTRIB_ARRAY_STRIDE_NV', 'GL_ATTRIB_ARRAY_TYPE_NV',
'GL_CURRENT_ATTRIB_NV', 'GL_PROGRAM_LENGTH_NV', 'GL_PROGRAM_STRING_NV',
'GL_MODELVIEW_PROJECTION_NV', 'GL_IDENTITY_NV', 'GL_INVERSE_NV',
'GL_TRANSPOSE_NV', 'GL_INVERSE_TRANSPOSE_NV',
'GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV', 'GL_MAX_TRACK_MATRICES_NV',
'GL_MATRIX0_NV', 'GL_MATRIX1_NV', 'GL_MATRIX2_NV', 'GL_MATRIX3_NV',
'GL_MATRIX4_NV', 'GL_MATRIX5_NV', 'GL_MATRIX6_NV', 'GL_MATRIX7_NV',
'GL_CURRENT_MATRIX_STACK_DEPTH_NV', 'GL_CURRENT_MATRIX_NV',
'GL_VERTEX_PROGRAM_POINT_SIZE_NV', 'GL_VERTEX_PROGRAM_TWO_SIDE_NV',
'GL_PROGRAM_PARAMETER_NV', 'GL_ATTRIB_ARRAY_POINTER_NV',
'GL_PROGRAM_TARGET_NV', 'GL_PROGRAM_RESIDENT_NV', 'GL_TRACK_MATRIX_NV',
'GL_TRACK_MATRIX_TRANSFORM_NV', 'GL_VERTEX_PROGRAM_BINDING_NV',
'GL_PROGRAM_ERROR_POSITION_NV', 'GL_VERTEX_ATTRIB_ARRAY0_NV',
'GL_VERTEX_ATTRIB_ARRAY1_NV', 'GL_VERTEX_ATTRIB_ARRAY2_NV',
'GL_VERTEX_ATTRIB_ARRAY3_NV', 'GL_VERTEX_ATTRIB_ARRAY4_NV',
'GL_VERTEX_ATTRIB_ARRAY5_NV', 'GL_VERTEX_ATTRIB_ARRAY6_NV',
'GL_VERTEX_ATTRIB_ARRAY7_NV', 'GL_VERTEX_ATTRIB_ARRAY8_NV',
'GL_VERTEX_ATTRIB_ARRAY9_NV', 'GL_VERTEX_ATTRIB_ARRAY10_NV',
'GL_VERTEX_ATTRIB_ARRAY11_NV', 'GL_VERTEX_ATTRIB_ARRAY12_NV',
'GL_VERTEX_ATTRIB_ARRAY13_NV', 'GL_VERTEX_ATTRIB_ARRAY14_NV',
'GL_VERTEX_ATTRIB_ARRAY15_NV', 'GL_MAP1_VERTEX_ATTRIB0_4_NV',
'GL_MAP1_VERTEX_ATTRIB1_4_NV', 'GL_MAP1_VERTEX_ATTRIB2_4_NV',
'GL_MAP1_VERTEX_ATTRIB3_4_NV', 'GL_MAP1_VERTEX_ATTRIB4_4_NV',
'GL_MAP1_VERTEX_ATTRIB5_4_NV', 'GL_MAP1_VERTEX_ATTRIB6_4_NV',
'GL_MAP1_VERTEX_ATTRIB7_4_NV', 'GL_MAP1_VERTEX_ATTRIB8_4_NV',
'GL_MAP1_VERTEX_ATTRIB9_4_NV', 'GL_MAP1_VERTEX_ATTRIB10_4_NV',
'GL_MAP1_VERTEX_ATTRIB11_4_NV', 'GL_MAP1_VERTEX_ATTRIB12_4_NV',
'GL_MAP1_VERTEX_ATTRIB13_4_NV', 'GL_MAP1_VERTEX_ATTRIB14_4_NV',
'GL_MAP1_VERTEX_ATTRIB15_4_NV', 'GL_MAP2_VERTEX_ATTRIB0_4_NV',
'GL_MAP2_VERTEX_ATTRIB1_4_NV', 'GL_MAP2_VERTEX_ATTRIB2_4_NV',
'GL_MAP2_VERTEX_ATTRIB3_4_NV', 'GL_MAP2_VERTEX_ATTRIB4_4_NV',
'GL_MAP2_VERTEX_ATTRIB5_4_NV', 'GL_MAP2_VERTEX_ATTRIB6_4_NV',
'GL_MAP2_VERTEX_ATTRIB7_4_NV', 'GL_MAP2_VERTEX_ATTRIB8_4_NV',
'GL_MAP2_VERTEX_ATTRIB9_4_NV', 'GL_MAP2_VERTEX_ATTRIB10_4_NV',
'GL_MAP2_VERTEX_ATTRIB11_4_NV', 'GL_MAP2_VERTEX_ATTRIB12_4_NV',
'GL_MAP2_VERTEX_ATTRIB13_4_NV', 'GL_MAP2_VERTEX_ATTRIB14_4_NV',
'GL_MAP2_VERTEX_ATTRIB15_4_NV', 'GL_TEXTURE_MAX_CLAMP_S_SGIX',
'GL_TEXTURE_MAX_CLAMP_T_SGIX', 'GL_TEXTURE_MAX_CLAMP_R_SGIX',
'GL_SCALEBIAS_HINT_SGIX', 'GL_INTERLACE_OML', 'GL_INTERLACE_READ_OML',
'GL_FORMAT_SUBSAMPLE_24_24_OML', 'GL_FORMAT_SUBSAMPLE_244_244_OML',
'GL_PACK_RESAMPLE_OML', 'GL_UNPACK_RESAMPLE_OML', 'GL_RESAMPLE_REPLICATE_OML',
'GL_RESAMPLE_ZERO_FILL_OML', 'GL_RESAMPLE_AVERAGE_OML',
'GL_RESAMPLE_DECIMATE_OML', 'GL_DEPTH_STENCIL_TO_RGBA_NV',
'GL_DEPTH_STENCIL_TO_BGRA_NV', 'GL_BUMP_ROT_MATRIX_ATI',
'GL_BUMP_ROT_MATRIX_SIZE_ATI', 'GL_BUMP_NUM_TEX_UNITS_ATI',
'GL_BUMP_TEX_UNITS_ATI', 'GL_DUDV_ATI', 'GL_DU8DV8_ATI', 'GL_BUMP_ENVMAP_ATI',
'GL_BUMP_TARGET_ATI', 'GL_FRAGMENT_SHADER_ATI', 'GL_REG_0_ATI',
'GL_REG_1_ATI', 'GL_REG_2_ATI', 'GL_REG_3_ATI', 'GL_REG_4_ATI',
'GL_REG_5_ATI', 'GL_REG_6_ATI', 'GL_REG_7_ATI', 'GL_REG_8_ATI',
'GL_REG_9_ATI', 'GL_REG_10_ATI', 'GL_REG_11_ATI', 'GL_REG_12_ATI',
'GL_REG_13_ATI', 'GL_REG_14_ATI', 'GL_REG_15_ATI', 'GL_REG_16_ATI',
'GL_REG_17_ATI', 'GL_REG_18_ATI', 'GL_REG_19_ATI', 'GL_REG_20_ATI',
'GL_REG_21_ATI', 'GL_REG_22_ATI', 'GL_REG_23_ATI', 'GL_REG_24_ATI',
'GL_REG_25_ATI', 'GL_REG_26_ATI', 'GL_REG_27_ATI', 'GL_REG_28_ATI',
'GL_REG_29_ATI', 'GL_REG_30_ATI', 'GL_REG_31_ATI', 'GL_CON_0_ATI',
'GL_CON_1_ATI', 'GL_CON_2_ATI', 'GL_CON_3_ATI', 'GL_CON_4_ATI',
'GL_CON_5_ATI', 'GL_CON_6_ATI', 'GL_CON_7_ATI', 'GL_CON_8_ATI',
'GL_CON_9_ATI', 'GL_CON_10_ATI', 'GL_CON_11_ATI', 'GL_CON_12_ATI',
'GL_CON_13_ATI', 'GL_CON_14_ATI', 'GL_CON_15_ATI', 'GL_CON_16_ATI',
'GL_CON_17_ATI', 'GL_CON_18_ATI', 'GL_CON_19_ATI', 'GL_CON_20_ATI',
'GL_CON_21_ATI', 'GL_CON_22_ATI', 'GL_CON_23_ATI', 'GL_CON_24_ATI',
'GL_CON_25_ATI', 'GL_CON_26_ATI', 'GL_CON_27_ATI', 'GL_CON_28_ATI',
'GL_CON_29_ATI', 'GL_CON_30_ATI', 'GL_CON_31_ATI', 'GL_MOV_ATI', 'GL_ADD_ATI',
'GL_MUL_ATI', 'GL_SUB_ATI', 'GL_DOT3_ATI', 'GL_DOT4_ATI', 'GL_MAD_ATI',
'GL_LERP_ATI', 'GL_CND_ATI', 'GL_CND0_ATI', 'GL_DOT2_ADD_ATI',
'GL_SECONDARY_INTERPOLATOR_ATI', 'GL_NUM_FRAGMENT_REGISTERS_ATI',
'GL_NUM_FRAGMENT_CONSTANTS_ATI', 'GL_NUM_PASSES_ATI',
'GL_NUM_INSTRUCTIONS_PER_PASS_ATI', 'GL_NUM_INSTRUCTIONS_TOTAL_ATI',
'GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI', 'GL_NUM_LOOPBACK_COMPONENTS_ATI',
'GL_COLOR_ALPHA_PAIRING_ATI', 'GL_SWIZZLE_STR_ATI', 'GL_SWIZZLE_STQ_ATI',
'GL_SWIZZLE_STR_DR_ATI', 'GL_SWIZZLE_STQ_DQ_ATI', 'GL_SWIZZLE_STRQ_ATI',
'GL_SWIZZLE_STRQ_DQ_ATI', 'GL_RED_BIT_ATI', 'GL_GREEN_BIT_ATI',
'GL_BLUE_BIT_ATI', 'GL_2X_BIT_ATI', 'GL_4X_BIT_ATI', 'GL_8X_BIT_ATI',
'GL_HALF_BIT_ATI', 'GL_QUARTER_BIT_ATI', 'GL_EIGHTH_BIT_ATI',
'GL_SATURATE_BIT_ATI', 'GL_COMP_BIT_ATI', 'GL_NEGATE_BIT_ATI',
'GL_BIAS_BIT_ATI', 'GL_PN_TRIANGLES_ATI',
'GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI', 'GL_PN_TRIANGLES_POINT_MODE_ATI',
'GL_PN_TRIANGLES_NORMAL_MODE_ATI', 'GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI',
'GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI',
'GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI',
'GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI',
'GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI', 'GL_STATIC_ATI',
'GL_DYNAMIC_ATI', 'GL_PRESERVE_ATI', 'GL_DISCARD_ATI',
'GL_OBJECT_BUFFER_SIZE_ATI', 'GL_OBJECT_BUFFER_USAGE_ATI',
'GL_ARRAY_OBJECT_BUFFER_ATI', 'GL_ARRAY_OBJECT_OFFSET_ATI',
'GL_VERTEX_SHADER_EXT', 'GL_VERTEX_SHADER_BINDING_EXT', 'GL_OP_INDEX_EXT',
'GL_OP_NEGATE_EXT', 'GL_OP_DOT3_EXT', 'GL_OP_DOT4_EXT', 'GL_OP_MUL_EXT',
'GL_OP_ADD_EXT', 'GL_OP_MADD_EXT', 'GL_OP_FRAC_EXT', 'GL_OP_MAX_EXT',
'GL_OP_MIN_EXT', 'GL_OP_SET_GE_EXT', 'GL_OP_SET_LT_EXT', 'GL_OP_CLAMP_EXT',
'GL_OP_FLOOR_EXT', 'GL_OP_ROUND_EXT', 'GL_OP_EXP_BASE_2_EXT',
'GL_OP_LOG_BASE_2_EXT', 'GL_OP_POWER_EXT', 'GL_OP_RECIP_EXT',
'GL_OP_RECIP_SQRT_EXT', 'GL_OP_SUB_EXT', 'GL_OP_CROSS_PRODUCT_EXT',
'GL_OP_MULTIPLY_MATRIX_EXT', 'GL_OP_MOV_EXT', 'GL_OUTPUT_VERTEX_EXT',
'GL_OUTPUT_COLOR0_EXT', 'GL_OUTPUT_COLOR1_EXT',
'GL_OUTPUT_TEXTURE_COORD0_EXT', 'GL_OUTPUT_TEXTURE_COORD1_EXT',
'GL_OUTPUT_TEXTURE_COORD2_EXT', 'GL_OUTPUT_TEXTURE_COORD3_EXT',
'GL_OUTPUT_TEXTURE_COORD4_EXT', 'GL_OUTPUT_TEXTURE_COORD5_EXT',
'GL_OUTPUT_TEXTURE_COORD6_EXT', 'GL_OUTPUT_TEXTURE_COORD7_EXT',
'GL_OUTPUT_TEXTURE_COORD8_EXT', 'GL_OUTPUT_TEXTURE_COORD9_EXT',
'GL_OUTPUT_TEXTURE_COORD10_EXT', 'GL_OUTPUT_TEXTURE_COORD11_EXT',
'GL_OUTPUT_TEXTURE_COORD12_EXT', 'GL_OUTPUT_TEXTURE_COORD13_EXT',
'GL_OUTPUT_TEXTURE_COORD14_EXT', 'GL_OUTPUT_TEXTURE_COORD15_EXT',
'GL_OUTPUT_TEXTURE_COORD16_EXT', 'GL_OUTPUT_TEXTURE_COORD17_EXT',
'GL_OUTPUT_TEXTURE_COORD18_EXT', 'GL_OUTPUT_TEXTURE_COORD19_EXT',
'GL_OUTPUT_TEXTURE_COORD20_EXT', 'GL_OUTPUT_TEXTURE_COORD21_EXT',
'GL_OUTPUT_TEXTURE_COORD22_EXT', 'GL_OUTPUT_TEXTURE_COORD23_EXT',
'GL_OUTPUT_TEXTURE_COORD24_EXT', 'GL_OUTPUT_TEXTURE_COORD25_EXT',
'GL_OUTPUT_TEXTURE_COORD26_EXT', 'GL_OUTPUT_TEXTURE_COORD27_EXT',
'GL_OUTPUT_TEXTURE_COORD28_EXT', 'GL_OUTPUT_TEXTURE_COORD29_EXT',
'GL_OUTPUT_TEXTURE_COORD30_EXT', 'GL_OUTPUT_TEXTURE_COORD31_EXT',
'GL_OUTPUT_FOG_EXT', 'GL_SCALAR_EXT', 'GL_VECTOR_EXT', 'GL_MATRIX_EXT',
'GL_VARIANT_EXT', 'GL_INVARIANT_EXT', 'GL_LOCAL_CONSTANT_EXT', 'GL_LOCAL_EXT',
'GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT', 'GL_MAX_VERTEX_SHADER_VARIANTS_EXT',
'GL_MAX_VERTEX_SHADER_INVARIANTS_EXT',
'GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT', 'GL_MAX_VERTEX_SHADER_LOCALS_EXT',
'GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT',
'GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT',
'GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT',
'GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT',
'GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT',
'GL_VERTEX_SHADER_INSTRUCTIONS_EXT', 'GL_VERTEX_SHADER_VARIANTS_EXT',
'GL_VERTEX_SHADER_INVARIANTS_EXT', 'GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT',
'GL_VERTEX_SHADER_LOCALS_EXT', 'GL_VERTEX_SHADER_OPTIMIZED_EXT', 'GL_X_EXT',
'GL_Y_EXT', 'GL_Z_EXT', 'GL_W_EXT', 'GL_NEGATIVE_X_EXT', 'GL_NEGATIVE_Y_EXT',
'GL_NEGATIVE_Z_EXT', 'GL_NEGATIVE_W_EXT', 'GL_ZERO_EXT', 'GL_ONE_EXT',
'GL_NEGATIVE_ONE_EXT', 'GL_NORMALIZED_RANGE_EXT', 'GL_FULL_RANGE_EXT',
'GL_CURRENT_VERTEX_EXT', 'GL_MVP_MATRIX_EXT', 'GL_VARIANT_VALUE_EXT',
'GL_VARIANT_DATATYPE_EXT', 'GL_VARIANT_ARRAY_STRIDE_EXT',
'GL_VARIANT_ARRAY_TYPE_EXT', 'GL_VARIANT_ARRAY_EXT',
'GL_VARIANT_ARRAY_POINTER_EXT', 'GL_INVARIANT_VALUE_EXT',
'GL_INVARIANT_DATATYPE_EXT', 'GL_LOCAL_CONSTANT_VALUE_EXT',
'GL_LOCAL_CONSTANT_DATATYPE_EXT', 'GL_MAX_VERTEX_STREAMS_ATI',
'GL_VERTEX_STREAM0_ATI', 'GL_VERTEX_STREAM1_ATI', 'GL_VERTEX_STREAM2_ATI',
'GL_VERTEX_STREAM3_ATI', 'GL_VERTEX_STREAM4_ATI', 'GL_VERTEX_STREAM5_ATI',
'GL_VERTEX_STREAM6_ATI', 'GL_VERTEX_STREAM7_ATI', 'GL_VERTEX_SOURCE_ATI',
'GL_ELEMENT_ARRAY_ATI', 'GL_ELEMENT_ARRAY_TYPE_ATI',
'GL_ELEMENT_ARRAY_POINTER_ATI', 'GL_QUAD_MESH_SUN', 'GL_TRIANGLE_MESH_SUN',
'GL_SLICE_ACCUM_SUN', 'GL_MULTISAMPLE_FILTER_HINT_NV', 'GL_DEPTH_CLAMP_NV',
'GL_PIXEL_COUNTER_BITS_NV', 'GL_CURRENT_OCCLUSION_QUERY_ID_NV',
'GL_PIXEL_COUNT_NV', 'GL_PIXEL_COUNT_AVAILABLE_NV', 'GL_POINT_SPRITE_NV',
'GL_COORD_REPLACE_NV', 'GL_POINT_SPRITE_R_MODE_NV',
'GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV',
'GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV',
'GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV',
'GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV',
'GL_OFFSET_HILO_TEXTURE_2D_NV', 'GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV',
'GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV',
'GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV',
'GL_DEPENDENT_HILO_TEXTURE_2D_NV', 'GL_DEPENDENT_RGB_TEXTURE_3D_NV',
'GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV', 'GL_DOT_PRODUCT_PASS_THROUGH_NV',
'GL_DOT_PRODUCT_TEXTURE_1D_NV', 'GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV',
'GL_HILO8_NV', 'GL_SIGNED_HILO8_NV', 'GL_FORCE_BLUE_TO_ONE_NV',
'GL_STENCIL_TEST_TWO_SIDE_EXT', 'GL_ACTIVE_STENCIL_FACE_EXT',
'GL_TEXT_FRAGMENT_SHADER_ATI', 'GL_UNPACK_CLIENT_STORAGE_APPLE',
'GL_ELEMENT_ARRAY_APPLE', 'GL_ELEMENT_ARRAY_TYPE_APPLE',
'GL_ELEMENT_ARRAY_POINTER_APPLE', 'GL_DRAW_PIXELS_APPLE', 'GL_FENCE_APPLE',
'GL_VERTEX_ARRAY_BINDING_APPLE', 'GL_VERTEX_ARRAY_RANGE_APPLE',
'GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE', 'GL_VERTEX_ARRAY_STORAGE_HINT_APPLE',
'GL_VERTEX_ARRAY_RANGE_POINTER_APPLE', 'GL_STORAGE_CACHED_APPLE',
'GL_STORAGE_SHARED_APPLE', 'GL_YCBCR_422_APPLE',
'GL_UNSIGNED_SHORT_8_8_APPLE', 'GL_UNSIGNED_SHORT_8_8_REV_APPLE',
'GL_RGB_S3TC', 'GL_RGB4_S3TC', 'GL_RGBA_S3TC', 'GL_RGBA4_S3TC',
'GL_MAX_DRAW_BUFFERS_ATI', 'GL_DRAW_BUFFER0_ATI', 'GL_DRAW_BUFFER1_ATI',
'GL_DRAW_BUFFER2_ATI', 'GL_DRAW_BUFFER3_ATI', 'GL_DRAW_BUFFER4_ATI',
'GL_DRAW_BUFFER5_ATI', 'GL_DRAW_BUFFER6_ATI', 'GL_DRAW_BUFFER7_ATI',
'GL_DRAW_BUFFER8_ATI', 'GL_DRAW_BUFFER9_ATI', 'GL_DRAW_BUFFER10_ATI',
'GL_DRAW_BUFFER11_ATI', 'GL_DRAW_BUFFER12_ATI', 'GL_DRAW_BUFFER13_ATI',
'GL_DRAW_BUFFER14_ATI', 'GL_DRAW_BUFFER15_ATI', 'GL_TYPE_RGBA_FLOAT_ATI',
'GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI', 'GL_MODULATE_ADD_ATI',
'GL_MODULATE_SIGNED_ADD_ATI', 'GL_MODULATE_SUBTRACT_ATI',
'GL_RGBA_FLOAT32_ATI', 'GL_RGB_FLOAT32_ATI', 'GL_ALPHA_FLOAT32_ATI',
'GL_INTENSITY_FLOAT32_ATI', 'GL_LUMINANCE_FLOAT32_ATI',
'GL_LUMINANCE_ALPHA_FLOAT32_ATI', 'GL_RGBA_FLOAT16_ATI', 'GL_RGB_FLOAT16_ATI',
'GL_ALPHA_FLOAT16_ATI', 'GL_INTENSITY_FLOAT16_ATI',
'GL_LUMINANCE_FLOAT16_ATI', 'GL_LUMINANCE_ALPHA_FLOAT16_ATI', 'GL_FLOAT_R_NV',
'GL_FLOAT_RG_NV', 'GL_FLOAT_RGB_NV', 'GL_FLOAT_RGBA_NV', 'GL_FLOAT_R16_NV',
'GL_FLOAT_R32_NV', 'GL_FLOAT_RG16_NV', 'GL_FLOAT_RG32_NV',
'GL_FLOAT_RGB16_NV', 'GL_FLOAT_RGB32_NV', 'GL_FLOAT_RGBA16_NV',
'GL_FLOAT_RGBA32_NV', 'GL_TEXTURE_FLOAT_COMPONENTS_NV',
'GL_FLOAT_CLEAR_COLOR_VALUE_NV', 'GL_FLOAT_RGBA_MODE_NV',
'GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV', 'GL_FRAGMENT_PROGRAM_NV',
'GL_MAX_TEXTURE_COORDS_NV', 'GL_MAX_TEXTURE_IMAGE_UNITS_NV',
'GL_FRAGMENT_PROGRAM_BINDING_NV', 'GL_PROGRAM_ERROR_STRING_NV',
'GL_HALF_FLOAT_NV', 'GL_WRITE_PIXEL_DATA_RANGE_NV',
'GL_READ_PIXEL_DATA_RANGE_NV', 'GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV',
'GL_READ_PIXEL_DATA_RANGE_LENGTH_NV', 'GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV',
'GL_READ_PIXEL_DATA_RANGE_POINTER_NV', 'GL_PRIMITIVE_RESTART_NV',
'GL_PRIMITIVE_RESTART_INDEX_NV', 'GL_TEXTURE_UNSIGNED_REMAP_MODE_NV',
'GL_STENCIL_BACK_FUNC_ATI', 'GL_STENCIL_BACK_FAIL_ATI',
'GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI', 'GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI',
'GL_IMPLEMENTATION_COLOR_READ_TYPE_OES',
'GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES', 'GL_DEPTH_BOUNDS_TEST_EXT',
'GL_DEPTH_BOUNDS_EXT', 'GL_MIRROR_CLAMP_EXT', 'GL_MIRROR_CLAMP_TO_EDGE_EXT',
'GL_MIRROR_CLAMP_TO_BORDER_EXT', 'GL_BLEND_EQUATION_RGB_EXT',
'GL_BLEND_EQUATION_ALPHA_EXT', 'GL_PACK_INVERT_MESA',
'GL_UNSIGNED_SHORT_8_8_MESA', 'GL_UNSIGNED_SHORT_8_8_REV_MESA',
'GL_YCBCR_MESA', 'GL_PIXEL_PACK_BUFFER_EXT', 'GL_PIXEL_UNPACK_BUFFER_EXT',
'GL_PIXEL_PACK_BUFFER_BINDING_EXT', 'GL_PIXEL_UNPACK_BUFFER_BINDING_EXT',
'GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV', 'GL_MAX_PROGRAM_CALL_DEPTH_NV',
'GL_MAX_PROGRAM_IF_DEPTH_NV', 'GL_MAX_PROGRAM_LOOP_DEPTH_NV',
'GL_MAX_PROGRAM_LOOP_COUNT_NV', 'GL_INVALID_FRAMEBUFFER_OPERATION_EXT',
'GL_MAX_RENDERBUFFER_SIZE_EXT', 'GL_FRAMEBUFFER_BINDING_EXT',
'GL_RENDERBUFFER_BINDING_EXT', 'GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT',
'GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT',
'GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT',
'GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT',
'GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT',
'GL_FRAMEBUFFER_COMPLETE_EXT', 'GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT',
'GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT',
'GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT_EXT',
'GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT',
'GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT',
'GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT',
'GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT', 'GL_FRAMEBUFFER_UNSUPPORTED_EXT',
'GL_MAX_COLOR_ATTACHMENTS_EXT', 'GL_COLOR_ATTACHMENT0_EXT',
'GL_COLOR_ATTACHMENT1_EXT', 'GL_COLOR_ATTACHMENT2_EXT',
'GL_COLOR_ATTACHMENT3_EXT', 'GL_COLOR_ATTACHMENT4_EXT',
'GL_COLOR_ATTACHMENT5_EXT', 'GL_COLOR_ATTACHMENT6_EXT',
'GL_COLOR_ATTACHMENT7_EXT', 'GL_COLOR_ATTACHMENT8_EXT',
'GL_COLOR_ATTACHMENT9_EXT', 'GL_COLOR_ATTACHMENT10_EXT',
'GL_COLOR_ATTACHMENT11_EXT', 'GL_COLOR_ATTACHMENT12_EXT',
'GL_COLOR_ATTACHMENT13_EXT', 'GL_COLOR_ATTACHMENT14_EXT',
'GL_COLOR_ATTACHMENT15_EXT', 'GL_DEPTH_ATTACHMENT_EXT',
'GL_STENCIL_ATTACHMENT_EXT', 'GL_FRAMEBUFFER_EXT', 'GL_RENDERBUFFER_EXT',
'GL_RENDERBUFFER_WIDTH_EXT', 'GL_RENDERBUFFER_HEIGHT_EXT',
'GL_RENDERBUFFER_INTERNAL_FORMAT_EXT', 'GL_STENCIL_INDEX_EXT',
'GL_STENCIL_INDEX1_EXT', 'GL_STENCIL_INDEX4_EXT', 'GL_STENCIL_INDEX8_EXT',
'GL_STENCIL_INDEX16_EXT', 'GL_RENDERBUFFER_RED_SIZE_EXT',
'GL_RENDERBUFFER_GREEN_SIZE_EXT', 'GL_RENDERBUFFER_BLUE_SIZE_EXT',
'GL_RENDERBUFFER_ALPHA_SIZE_EXT', 'GL_RENDERBUFFER_DEPTH_SIZE_EXT',
'GL_RENDERBUFFER_STENCIL_SIZE_EXT', 'GL_CG_VERTEX_SHADER_EXT',
'GL_CG_FRAGMENT_SHADER_EXT', 'GL_TIME_ELAPSED_EXT', 'GL_TEXTURE_BUFFER_EXT',
'GL_MAX_TEXTURE_BUFFER_SIZE_EXT', 'GL_TEXTURE_BINDING_BUFFER_EXT',
'GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT', 'GL_TEXTURE_BUFFER_FORMAT_EXT',
'GL_SAMPLER_1D_ARRAY_EXT', 'GL_SAMPLER_2D_ARRAY_EXT', 'GL_SAMPLER_BUFFER_EXT',
'GL_SAMPLER_1D_ARRAY_SHADOW_EXT', 'GL_SAMPLER_2D_ARRAY_SHADOW_EXT',
'GL_SAMPLER_CUBE_SHADOW_EXT', 'GL_UNSIGNED_INT_VEC2_EXT',
'GL_UNSIGNED_INT_VEC3_EXT', 'GL_UNSIGNED_INT_VEC4_EXT',
'GL_INT_SAMPLER_1D_EXT', 'GL_INT_SAMPLER_2D_EXT', 'GL_INT_SAMPLER_3D_EXT',
'GL_INT_SAMPLER_CUBE_EXT', 'GL_INT_SAMPLER_2D_RECT_EXT',
'GL_INT_SAMPLER_1D_ARRAY_EXT', 'GL_INT_SAMPLER_2D_ARRAY_EXT',
'GL_INT_SAMPLER_BUFFER_EXT', 'GL_UNSIGNED_INT_SAMPLER_1D_EXT',
'GL_UNSIGNED_INT_SAMPLER_2D_EXT', 'GL_UNSIGNED_INT_SAMPLER_3D_EXT',
'GL_UNSIGNED_INT_SAMPLER_CUBE_EXT', 'GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT',
'GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT',
'GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT', 'GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT',
'GL_VERTEX_ATTRIB_ARRAY_INTEGER_EXT', 'GL_GEOMETRY_SHADER_EXT',
'GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT',
'GL_MAX_VERTEX_VARYING_COMPONENTS_EXT', 'GL_MAX_VARYING_COMPONENTS_EXT',
'GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT',
'GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT',
'GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT', 'GL_GEOMETRY_VERTICES_OUT_EXT',
'GL_GEOMETRY_INPUT_TYPE_EXT', 'GL_GEOMETRY_OUTPUT_TYPE_EXT',
'GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT', 'GL_LINES_ADJACENCY_EXT',
'GL_LINE_STRIP_ADJACENCY_EXT', 'GL_TRIANGLES_ADJACENCY_EXT',
'GL_TRIANGLE_STRIP_ADJACENCY_EXT', 'GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT',
'GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT',
'GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT',
'GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT', 'GL_PROGRAM_POINT_SIZE_EXT',
'GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT',
'GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT',
'GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT', 'GL_MAX_BINDABLE_UNIFORM_SIZE_EXT',
'GL_UNIFORM_BUFFER_EXT', 'GL_UNIFORM_BUFFER_BINDING_EXT',
'GL_FRAMEBUFFER_SRGB_EXT', 'GL_FRAMEBUFFER_SRGB_CAPABLE_EXT',
'GL_RGB9_E5_EXT', 'GL_UNSIGNED_INT_5_9_9_9_REV_EXT',
'GL_TEXTURE_SHARED_SIZE_EXT', 'GL_R11F_G11F_B10F_EXT',
'GL_UNSIGNED_INT_10F_11F_11F_REV_EXT', 'GL_RGBA_SIGNED_COMPONENTS_EXT',
'GL_TEXTURE_1D_ARRAY_EXT', 'GL_PROXY_TEXTURE_1D_ARRAY_EXT',
'GL_TEXTURE_2D_ARRAY_EXT', 'GL_PROXY_TEXTURE_2D_ARRAY_EXT',
'GL_TEXTURE_BINDING_1D_ARRAY_EXT', 'GL_TEXTURE_BINDING_2D_ARRAY_EXT',
'GL_MAX_ARRAY_TEXTURE_LAYERS_EXT', 'GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT',
'GL_RGBA32UI_EXT', 'GL_RGB32UI_EXT', 'GL_ALPHA32UI_EXT',
'GL_INTENSITY32UI_EXT', 'GL_LUMINANCE32UI_EXT', 'GL_LUMINANCE_ALPHA32UI_EXT',
'GL_RGBA16UI_EXT', 'GL_RGB16UI_EXT', 'GL_ALPHA16UI_EXT',
'GL_INTENSITY16UI_EXT', 'GL_LUMINANCE16UI_EXT', 'GL_LUMINANCE_ALPHA16UI_EXT',
'GL_RGBA8UI_EXT', 'GL_RGB8UI_EXT', 'GL_ALPHA8UI_EXT', 'GL_INTENSITY8UI_EXT',
'GL_LUMINANCE8UI_EXT', 'GL_LUMINANCE_ALPHA8UI_EXT', 'GL_RGBA32I_EXT',
'GL_RGB32I_EXT', 'GL_ALPHA32I_EXT', 'GL_INTENSITY32I_EXT',
'GL_LUMINANCE32I_EXT', 'GL_LUMINANCE_ALPHA32I_EXT', 'GL_RGBA16I_EXT',
'GL_RGB16I_EXT', 'GL_ALPHA16I_EXT', 'GL_INTENSITY16I_EXT',
'GL_LUMINANCE16I_EXT', 'GL_LUMINANCE_ALPHA16I_EXT', 'GL_RGBA8I_EXT',
'GL_RGB8I_EXT', 'GL_ALPHA8I_EXT', 'GL_INTENSITY8I_EXT', 'GL_LUMINANCE8I_EXT',
'GL_LUMINANCE_ALPHA8I_EXT', 'GL_RED_INTEGER_EXT', 'GL_GREEN_INTEGER_EXT',
'GL_BLUE_INTEGER_EXT', 'GL_ALPHA_INTEGER_EXT', 'GL_RGB_INTEGER_EXT',
'GL_RGBA_INTEGER_EXT', 'GL_BGR_INTEGER_EXT', 'GL_BGRA_INTEGER_EXT',
'GL_LUMINANCE_INTEGER_EXT', 'GL_LUMINANCE_ALPHA_INTEGER_EXT',
'GL_RGBA_INTEGER_MODE_EXT', 'GL_DEPTH_COMPONENT32F_NV',
'GL_DEPTH32F_STENCIL8_NV', 'GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV',
'GL_DEPTH_BUFFER_FLOAT_MODE_NV', 'GL_COMPRESSED_LUMINANCE_LATC1_EXT',
'GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT',
'GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT',
'GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT', 'GL_BACK_PRIMARY_COLOR_NV',
'GL_BACK_SECONDARY_COLOR_NV', 'GL_TEXTURE_COORD_NV', 'GL_CLIP_DISTANCE_NV',
'GL_VERTEX_ID_NV', 'GL_PRIMITIVE_ID_NV', 'GL_GENERIC_ATTRIB_NV',
'GL_TRANSFORM_FEEDBACK_ATTRIBS_NV', 'GL_TRANSFORM_FEEDBACK_BUFFER_MODE_NV',
'GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV', 'GL_ACTIVE_VARYINGS_NV',
'GL_ACTIVE_VARYING_MAX_LENGTH_NV', 'GL_TRANSFORM_FEEDBACK_VARYINGS_NV',
'GL_TRANSFORM_FEEDBACK_BUFFER_START_NV',
'GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_NV', 'GL_TRANSFORM_FEEDBACK_RECORD_NV',
'GL_PRIMITIVES_GENERATED_NV', 'GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV',
'GL_RASTERIZER_DISCARD_NV',
'GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_ATTRIBS_NV',
'GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV', 'GL_INTERLEAVED_ATTRIBS_NV',
'GL_SEPARATE_ATTRIBS_NV', 'GL_TRANSFORM_FEEDBACK_BUFFER_NV',
'GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_NV', 'GL_GEOMETRY_PROGRAM_NV',
'GL_MAX_PROGRAM_OUTPUT_VERTICES_NV',
'GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV', 'GL_MIN_PROGRAM_TEXEL_OFFSET_NV',
'GL_MAX_PROGRAM_TEXEL_OFFSET_NV', 'GL_PROGRAM_ATTRIB_COMPONENTS_NV',
'GL_PROGRAM_RESULT_COMPONENTS_NV', 'GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV',
'GL_MAX_PROGRAM_RESULT_COMPONENTS_NV', 'GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV',
'GL_MAX_PROGRAM_GENERIC_RESULTS_NV', 'GL_RENDERBUFFER_COVERAGE_SAMPLES_NV',
'GL_RENDERBUFFER_COLOR_SAMPLES_NV', 'GL_MAX_RENDERBUFFER_COVERAGE_SAMPLES_NV',
'GL_MAX_RENDERBUFFER_COLOR_SAMPLES_NV',
'GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV', 'GL_MULTISAMPLE_COVERAGE_MODES_NV',
'GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT', 'GL_MAX_SAMPLES_EXT',
'GL_RENDERBUFFER_SAMPLES_EXT', 'GL_READ_FRAMEBUFFER_EXT',
'GL_DRAW_FRAMEBUFFER_EXT', 'GL_DRAW_FRAMEBUFFER_BINDING_EXT',
'GL_READ_FRAMEBUFFER_BINDING_EXT', 'GL_COMPRESSED_RED_RGTC1_EXT',
'GL_COMPRESSED_SIGNED_RED_RGTC1_EXT', 'GL_COMPRESSED_RED_GREEN_RGTC2_EXT',
'GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT', 'GLchar', 'GLintptr',
'GLsizeiptr', 'GLintptrARB', 'GLsizeiptrARB', 'GLcharARB', 'GLhandleARB',
'GLhalfARB', 'GLhalfNV', 'GLint64EXT', 'GLuint64EXT', 'GL_VERSION_1_2',
'glBlendColor', 'glBlendEquation', 'glDrawRangeElements', 'glColorTable',
'glColorTableParameterfv', 'glColorTableParameteriv', 'glCopyColorTable',
'glGetColorTable', 'glGetColorTableParameterfv', 'glGetColorTableParameteriv',
'glColorSubTable', 'glCopyColorSubTable', 'glConvolutionFilter1D',
'glConvolutionFilter2D', 'glConvolutionParameterf',
'glConvolutionParameterfv', 'glConvolutionParameteri',
'glConvolutionParameteriv', 'glCopyConvolutionFilter1D',
'glCopyConvolutionFilter2D', 'glGetConvolutionFilter',
'glGetConvolutionParameterfv', 'glGetConvolutionParameteriv',
'glGetSeparableFilter', 'glSeparableFilter2D', 'glGetHistogram',
'glGetHistogramParameterfv', 'glGetHistogramParameteriv', 'glGetMinmax',
'glGetMinmaxParameterfv', 'glGetMinmaxParameteriv', 'glHistogram', 'glMinmax',
'glResetHistogram', 'glResetMinmax', 'glTexImage3D', 'glTexSubImage3D',
'glCopyTexSubImage3D', 'PFNGLBLENDCOLORPROC', 'PFNGLBLENDEQUATIONPROC',
'PFNGLDRAWRANGEELEMENTSPROC', 'PFNGLCOLORTABLEPROC',
'PFNGLCOLORTABLEPARAMETERFVPROC', 'PFNGLCOLORTABLEPARAMETERIVPROC',
'PFNGLCOPYCOLORTABLEPROC', 'PFNGLGETCOLORTABLEPROC',
'PFNGLGETCOLORTABLEPARAMETERFVPROC', 'PFNGLGETCOLORTABLEPARAMETERIVPROC',
'PFNGLCOLORSUBTABLEPROC', 'PFNGLCOPYCOLORSUBTABLEPROC',
'PFNGLCONVOLUTIONFILTER1DPROC', 'PFNGLCONVOLUTIONFILTER2DPROC',
'PFNGLCONVOLUTIONPARAMETERFPROC', 'PFNGLCONVOLUTIONPARAMETERFVPROC',
'PFNGLCONVOLUTIONPARAMETERIPROC', 'PFNGLCONVOLUTIONPARAMETERIVPROC',
'PFNGLCOPYCONVOLUTIONFILTER1DPROC', 'PFNGLCOPYCONVOLUTIONFILTER2DPROC',
'PFNGLGETCONVOLUTIONFILTERPROC', 'PFNGLGETCONVOLUTIONPARAMETERFVPROC',
'PFNGLGETCONVOLUTIONPARAMETERIVPROC', 'PFNGLGETSEPARABLEFILTERPROC',
'PFNGLSEPARABLEFILTER2DPROC', 'PFNGLGETHISTOGRAMPROC',
'PFNGLGETHISTOGRAMPARAMETERFVPROC', 'PFNGLGETHISTOGRAMPARAMETERIVPROC',
'PFNGLGETMINMAXPROC', 'PFNGLGETMINMAXPARAMETERFVPROC',
'PFNGLGETMINMAXPARAMETERIVPROC', 'PFNGLHISTOGRAMPROC', 'PFNGLMINMAXPROC',
'PFNGLRESETHISTOGRAMPROC', 'PFNGLRESETMINMAXPROC', 'PFNGLTEXIMAGE3DPROC',
'PFNGLTEXSUBIMAGE3DPROC', 'PFNGLCOPYTEXSUBIMAGE3DPROC', 'GL_VERSION_1_3',
'glActiveTexture', 'glClientActiveTexture', 'glMultiTexCoord1d',
'glMultiTexCoord1dv', 'glMultiTexCoord1f', 'glMultiTexCoord1fv',
'glMultiTexCoord1i', 'glMultiTexCoord1iv', 'glMultiTexCoord1s',
'glMultiTexCoord1sv', 'glMultiTexCoord2d', 'glMultiTexCoord2dv',
'glMultiTexCoord2f', 'glMultiTexCoord2fv', 'glMultiTexCoord2i',
'glMultiTexCoord2iv', 'glMultiTexCoord2s', 'glMultiTexCoord2sv',
'glMultiTexCoord3d', 'glMultiTexCoord3dv', 'glMultiTexCoord3f',
'glMultiTexCoord3fv', 'glMultiTexCoord3i', 'glMultiTexCoord3iv',
'glMultiTexCoord3s', 'glMultiTexCoord3sv', 'glMultiTexCoord4d',
'glMultiTexCoord4dv', 'glMultiTexCoord4f', 'glMultiTexCoord4fv',
'glMultiTexCoord4i', 'glMultiTexCoord4iv', 'glMultiTexCoord4s',
'glMultiTexCoord4sv', 'glLoadTransposeMatrixf', 'glLoadTransposeMatrixd',
'glMultTransposeMatrixf', 'glMultTransposeMatrixd', 'glSampleCoverage',
'glCompressedTexImage3D', 'glCompressedTexImage2D', 'glCompressedTexImage1D',
'glCompressedTexSubImage3D', 'glCompressedTexSubImage2D',
'glCompressedTexSubImage1D', 'glGetCompressedTexImage',
'PFNGLACTIVETEXTUREPROC', 'PFNGLCLIENTACTIVETEXTUREPROC',
'PFNGLMULTITEXCOORD1DPROC', 'PFNGLMULTITEXCOORD1DVPROC',
'PFNGLMULTITEXCOORD1FPROC', 'PFNGLMULTITEXCOORD1FVPROC',
'PFNGLMULTITEXCOORD1IPROC', 'PFNGLMULTITEXCOORD1IVPROC',
'PFNGLMULTITEXCOORD1SPROC', 'PFNGLMULTITEXCOORD1SVPROC',
'PFNGLMULTITEXCOORD2DPROC', 'PFNGLMULTITEXCOORD2DVPROC',
'PFNGLMULTITEXCOORD2FPROC', 'PFNGLMULTITEXCOORD2FVPROC',
'PFNGLMULTITEXCOORD2IPROC', 'PFNGLMULTITEXCOORD2IVPROC',
'PFNGLMULTITEXCOORD2SPROC', 'PFNGLMULTITEXCOORD2SVPROC',
'PFNGLMULTITEXCOORD3DPROC', 'PFNGLMULTITEXCOORD3DVPROC',
'PFNGLMULTITEXCOORD3FPROC', 'PFNGLMULTITEXCOORD3FVPROC',
'PFNGLMULTITEXCOORD3IPROC', 'PFNGLMULTITEXCOORD3IVPROC',
'PFNGLMULTITEXCOORD3SPROC', 'PFNGLMULTITEXCOORD3SVPROC',
'PFNGLMULTITEXCOORD4DPROC', 'PFNGLMULTITEXCOORD4DVPROC',
'PFNGLMULTITEXCOORD4FPROC', 'PFNGLMULTITEXCOORD4FVPROC',
'PFNGLMULTITEXCOORD4IPROC', 'PFNGLMULTITEXCOORD4IVPROC',
'PFNGLMULTITEXCOORD4SPROC', 'PFNGLMULTITEXCOORD4SVPROC',
'PFNGLLOADTRANSPOSEMATRIXFPROC', 'PFNGLLOADTRANSPOSEMATRIXDPROC',
'PFNGLMULTTRANSPOSEMATRIXFPROC', 'PFNGLMULTTRANSPOSEMATRIXDPROC',
'PFNGLSAMPLECOVERAGEPROC', 'PFNGLCOMPRESSEDTEXIMAGE3DPROC',
'PFNGLCOMPRESSEDTEXIMAGE2DPROC', 'PFNGLCOMPRESSEDTEXIMAGE1DPROC',
'PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC', 'PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC',
'PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC', 'PFNGLGETCOMPRESSEDTEXIMAGEPROC',
'GL_VERSION_1_4', 'glBlendFuncSeparate', 'glFogCoordf', 'glFogCoordfv',
'glFogCoordd', 'glFogCoorddv', 'glFogCoordPointer', 'glMultiDrawArrays',
'glMultiDrawElements', 'glPointParameterf', 'glPointParameterfv',
'glPointParameteri', 'glPointParameteriv', 'glSecondaryColor3b',
'glSecondaryColor3bv', 'glSecondaryColor3d', 'glSecondaryColor3dv',
'glSecondaryColor3f', 'glSecondaryColor3fv', 'glSecondaryColor3i',
'glSecondaryColor3iv', 'glSecondaryColor3s', 'glSecondaryColor3sv',
'glSecondaryColor3ub', 'glSecondaryColor3ubv', 'glSecondaryColor3ui',
'glSecondaryColor3uiv', 'glSecondaryColor3us', 'glSecondaryColor3usv',
'glSecondaryColorPointer', 'glWindowPos2d', 'glWindowPos2dv', 'glWindowPos2f',
'glWindowPos2fv', 'glWindowPos2i', 'glWindowPos2iv', 'glWindowPos2s',
'glWindowPos2sv', 'glWindowPos3d', 'glWindowPos3dv', 'glWindowPos3f',
'glWindowPos3fv', 'glWindowPos3i', 'glWindowPos3iv', 'glWindowPos3s',
'glWindowPos3sv', 'PFNGLBLENDFUNCSEPARATEPROC', 'PFNGLFOGCOORDFPROC',
'PFNGLFOGCOORDFVPROC', 'PFNGLFOGCOORDDPROC', 'PFNGLFOGCOORDDVPROC',
'PFNGLFOGCOORDPOINTERPROC', 'PFNGLMULTIDRAWARRAYSPROC',
'PFNGLMULTIDRAWELEMENTSPROC', 'PFNGLPOINTPARAMETERFPROC',
'PFNGLPOINTPARAMETERFVPROC', 'PFNGLPOINTPARAMETERIPROC',
'PFNGLPOINTPARAMETERIVPROC', 'PFNGLSECONDARYCOLOR3BPROC',
'PFNGLSECONDARYCOLOR3BVPROC', 'PFNGLSECONDARYCOLOR3DPROC',
'PFNGLSECONDARYCOLOR3DVPROC', 'PFNGLSECONDARYCOLOR3FPROC',
'PFNGLSECONDARYCOLOR3FVPROC', 'PFNGLSECONDARYCOLOR3IPROC',
'PFNGLSECONDARYCOLOR3IVPROC', 'PFNGLSECONDARYCOLOR3SPROC',
'PFNGLSECONDARYCOLOR3SVPROC', 'PFNGLSECONDARYCOLOR3UBPROC',
'PFNGLSECONDARYCOLOR3UBVPROC', 'PFNGLSECONDARYCOLOR3UIPROC',
'PFNGLSECONDARYCOLOR3UIVPROC', 'PFNGLSECONDARYCOLOR3USPROC',
'PFNGLSECONDARYCOLOR3USVPROC', 'PFNGLSECONDARYCOLORPOINTERPROC',
'PFNGLWINDOWPOS2DPROC', 'PFNGLWINDOWPOS2DVPROC', 'PFNGLWINDOWPOS2FPROC',
'PFNGLWINDOWPOS2FVPROC', 'PFNGLWINDOWPOS2IPROC', 'PFNGLWINDOWPOS2IVPROC',
'PFNGLWINDOWPOS2SPROC', 'PFNGLWINDOWPOS2SVPROC', 'PFNGLWINDOWPOS3DPROC',
'PFNGLWINDOWPOS3DVPROC', 'PFNGLWINDOWPOS3FPROC', 'PFNGLWINDOWPOS3FVPROC',
'PFNGLWINDOWPOS3IPROC', 'PFNGLWINDOWPOS3IVPROC', 'PFNGLWINDOWPOS3SPROC',
'PFNGLWINDOWPOS3SVPROC', 'GL_VERSION_1_5', 'glGenQueries', 'glDeleteQueries',
'glIsQuery', 'glBeginQuery', 'glEndQuery', 'glGetQueryiv',
'glGetQueryObjectiv', 'glGetQueryObjectuiv', 'glBindBuffer',
'glDeleteBuffers', 'glGenBuffers', 'glIsBuffer', 'glBufferData',
'glBufferSubData', 'glGetBufferSubData', 'glMapBuffer', 'glUnmapBuffer',
'glGetBufferParameteriv', 'glGetBufferPointerv', 'PFNGLGENQUERIESPROC',
'PFNGLDELETEQUERIESPROC', 'PFNGLISQUERYPROC', 'PFNGLBEGINQUERYPROC',
'PFNGLENDQUERYPROC', 'PFNGLGETQUERYIVPROC', 'PFNGLGETQUERYOBJECTIVPROC',
'PFNGLGETQUERYOBJECTUIVPROC', 'PFNGLBINDBUFFERPROC', 'PFNGLDELETEBUFFERSPROC',
'PFNGLGENBUFFERSPROC', 'PFNGLISBUFFERPROC', 'PFNGLBUFFERDATAPROC',
'PFNGLBUFFERSUBDATAPROC', 'PFNGLGETBUFFERSUBDATAPROC', 'PFNGLMAPBUFFERPROC',
'PFNGLUNMAPBUFFERPROC', 'PFNGLGETBUFFERPARAMETERIVPROC',
'PFNGLGETBUFFERPOINTERVPROC', 'GL_VERSION_2_0', 'glBlendEquationSeparate',
'glDrawBuffers', 'glStencilOpSeparate', 'glStencilFuncSeparate',
'glStencilMaskSeparate', 'glAttachShader', 'glBindAttribLocation',
'glCompileShader', 'glCreateProgram', 'glCreateShader', 'glDeleteProgram',
'glDeleteShader', 'glDetachShader', 'glDisableVertexAttribArray',
'glEnableVertexAttribArray', 'glGetActiveAttrib', 'glGetActiveUniform',
'glGetAttachedShaders', 'glGetAttribLocation', 'glGetProgramiv',
'glGetProgramInfoLog', 'glGetShaderiv', 'glGetShaderInfoLog',
'glGetShaderSource', 'glGetUniformLocation', 'glGetUniformfv',
'glGetUniformiv', 'glGetVertexAttribdv', 'glGetVertexAttribfv',
'glGetVertexAttribiv', 'glGetVertexAttribPointerv', 'glIsProgram',
'glIsShader', 'glLinkProgram', 'glShaderSource', 'glUseProgram',
'glUniform1f', 'glUniform2f', 'glUniform3f', 'glUniform4f', 'glUniform1i',
'glUniform2i', 'glUniform3i', 'glUniform4i', 'glUniform1fv', 'glUniform2fv',
'glUniform3fv', 'glUniform4fv', 'glUniform1iv', 'glUniform2iv',
'glUniform3iv', 'glUniform4iv', 'glUniformMatrix2fv', 'glUniformMatrix3fv',
'glUniformMatrix4fv', 'glValidateProgram', 'glVertexAttrib1d',
'glVertexAttrib1dv', 'glVertexAttrib1f', 'glVertexAttrib1fv',
'glVertexAttrib1s', 'glVertexAttrib1sv', 'glVertexAttrib2d',
'glVertexAttrib2dv', 'glVertexAttrib2f', 'glVertexAttrib2fv',
'glVertexAttrib2s', 'glVertexAttrib2sv', 'glVertexAttrib3d',
'glVertexAttrib3dv', 'glVertexAttrib3f', 'glVertexAttrib3fv',
'glVertexAttrib3s', 'glVertexAttrib3sv', 'glVertexAttrib4Nbv',
'glVertexAttrib4Niv', 'glVertexAttrib4Nsv', 'glVertexAttrib4Nub',
'glVertexAttrib4Nubv', 'glVertexAttrib4Nuiv', 'glVertexAttrib4Nusv',
'glVertexAttrib4bv', 'glVertexAttrib4d', 'glVertexAttrib4dv',
'glVertexAttrib4f', 'glVertexAttrib4fv', 'glVertexAttrib4iv',
'glVertexAttrib4s', 'glVertexAttrib4sv', 'glVertexAttrib4ubv',
'glVertexAttrib4uiv', 'glVertexAttrib4usv', 'glVertexAttribPointer',
'PFNGLBLENDEQUATIONSEPARATEPROC', 'PFNGLDRAWBUFFERSPROC',
'PFNGLSTENCILOPSEPARATEPROC', 'PFNGLSTENCILFUNCSEPARATEPROC',
'PFNGLSTENCILMASKSEPARATEPROC', 'PFNGLATTACHSHADERPROC',
'PFNGLBINDATTRIBLOCATIONPROC', 'PFNGLCOMPILESHADERPROC',
'PFNGLCREATEPROGRAMPROC', 'PFNGLCREATESHADERPROC', 'PFNGLDELETEPROGRAMPROC',
'PFNGLDELETESHADERPROC', 'PFNGLDETACHSHADERPROC',
'PFNGLDISABLEVERTEXATTRIBARRAYPROC', 'PFNGLENABLEVERTEXATTRIBARRAYPROC',
'PFNGLGETACTIVEATTRIBPROC', 'PFNGLGETACTIVEUNIFORMPROC',
'PFNGLGETATTACHEDSHADERSPROC', 'PFNGLGETATTRIBLOCATIONPROC',
'PFNGLGETPROGRAMIVPROC', 'PFNGLGETPROGRAMINFOLOGPROC', 'PFNGLGETSHADERIVPROC',
'PFNGLGETSHADERINFOLOGPROC', 'PFNGLGETSHADERSOURCEPROC',
'PFNGLGETUNIFORMLOCATIONPROC', 'PFNGLGETUNIFORMFVPROC',
'PFNGLGETUNIFORMIVPROC', 'PFNGLGETVERTEXATTRIBDVPROC',
'PFNGLGETVERTEXATTRIBFVPROC', 'PFNGLGETVERTEXATTRIBIVPROC',
'PFNGLGETVERTEXATTRIBPOINTERVPROC', 'PFNGLISPROGRAMPROC', 'PFNGLISSHADERPROC',
'PFNGLLINKPROGRAMPROC', 'PFNGLSHADERSOURCEPROC', 'PFNGLUSEPROGRAMPROC',
'PFNGLUNIFORM1FPROC', 'PFNGLUNIFORM2FPROC', 'PFNGLUNIFORM3FPROC',
'PFNGLUNIFORM4FPROC', 'PFNGLUNIFORM1IPROC', 'PFNGLUNIFORM2IPROC',
'PFNGLUNIFORM3IPROC', 'PFNGLUNIFORM4IPROC', 'PFNGLUNIFORM1FVPROC',
'PFNGLUNIFORM2FVPROC', 'PFNGLUNIFORM3FVPROC', 'PFNGLUNIFORM4FVPROC',
'PFNGLUNIFORM1IVPROC', 'PFNGLUNIFORM2IVPROC', 'PFNGLUNIFORM3IVPROC',
'PFNGLUNIFORM4IVPROC', 'PFNGLUNIFORMMATRIX2FVPROC',
'PFNGLUNIFORMMATRIX3FVPROC', 'PFNGLUNIFORMMATRIX4FVPROC',
'PFNGLVALIDATEPROGRAMPROC', 'PFNGLVERTEXATTRIB1DPROC',
'PFNGLVERTEXATTRIB1DVPROC', 'PFNGLVERTEXATTRIB1FPROC',
'PFNGLVERTEXATTRIB1FVPROC', 'PFNGLVERTEXATTRIB1SPROC',
'PFNGLVERTEXATTRIB1SVPROC', 'PFNGLVERTEXATTRIB2DPROC',
'PFNGLVERTEXATTRIB2DVPROC', 'PFNGLVERTEXATTRIB2FPROC',
'PFNGLVERTEXATTRIB2FVPROC', 'PFNGLVERTEXATTRIB2SPROC',
'PFNGLVERTEXATTRIB2SVPROC', 'PFNGLVERTEXATTRIB3DPROC',
'PFNGLVERTEXATTRIB3DVPROC', 'PFNGLVERTEXATTRIB3FPROC',
'PFNGLVERTEXATTRIB3FVPROC', 'PFNGLVERTEXATTRIB3SPROC',
'PFNGLVERTEXATTRIB3SVPROC', 'PFNGLVERTEXATTRIB4NBVPROC',
'PFNGLVERTEXATTRIB4NIVPROC', 'PFNGLVERTEXATTRIB4NSVPROC',
'PFNGLVERTEXATTRIB4NUBPROC', 'PFNGLVERTEXATTRIB4NUBVPROC',
'PFNGLVERTEXATTRIB4NUIVPROC', 'PFNGLVERTEXATTRIB4NUSVPROC',
'PFNGLVERTEXATTRIB4BVPROC', 'PFNGLVERTEXATTRIB4DPROC',
'PFNGLVERTEXATTRIB4DVPROC', 'PFNGLVERTEXATTRIB4FPROC',
'PFNGLVERTEXATTRIB4FVPROC', 'PFNGLVERTEXATTRIB4IVPROC',
'PFNGLVERTEXATTRIB4SPROC', 'PFNGLVERTEXATTRIB4SVPROC',
'PFNGLVERTEXATTRIB4UBVPROC', 'PFNGLVERTEXATTRIB4UIVPROC',
'PFNGLVERTEXATTRIB4USVPROC', 'PFNGLVERTEXATTRIBPOINTERPROC', 'GL_VERSION_2_1',
'glUniformMatrix2x3fv', 'glUniformMatrix3x2fv', 'glUniformMatrix2x4fv',
'glUniformMatrix4x2fv', 'glUniformMatrix3x4fv', 'glUniformMatrix4x3fv',
'PFNGLUNIFORMMATRIX2X3FVPROC', 'PFNGLUNIFORMMATRIX3X2FVPROC',
'PFNGLUNIFORMMATRIX2X4FVPROC', 'PFNGLUNIFORMMATRIX4X2FVPROC',
'PFNGLUNIFORMMATRIX3X4FVPROC', 'PFNGLUNIFORMMATRIX4X3FVPROC',
'GL_ARB_multitexture', 'glActiveTextureARB', 'glClientActiveTextureARB',
'glMultiTexCoord1dARB', 'glMultiTexCoord1dvARB', 'glMultiTexCoord1fARB',
'glMultiTexCoord1fvARB', 'glMultiTexCoord1iARB', 'glMultiTexCoord1ivARB',
'glMultiTexCoord1sARB', 'glMultiTexCoord1svARB', 'glMultiTexCoord2dARB',
'glMultiTexCoord2dvARB', 'glMultiTexCoord2fARB', 'glMultiTexCoord2fvARB',
'glMultiTexCoord2iARB', 'glMultiTexCoord2ivARB', 'glMultiTexCoord2sARB',
'glMultiTexCoord2svARB', 'glMultiTexCoord3dARB', 'glMultiTexCoord3dvARB',
'glMultiTexCoord3fARB', 'glMultiTexCoord3fvARB', 'glMultiTexCoord3iARB',
'glMultiTexCoord3ivARB', 'glMultiTexCoord3sARB', 'glMultiTexCoord3svARB',
'glMultiTexCoord4dARB', 'glMultiTexCoord4dvARB', 'glMultiTexCoord4fARB',
'glMultiTexCoord4fvARB', 'glMultiTexCoord4iARB', 'glMultiTexCoord4ivARB',
'glMultiTexCoord4sARB', 'glMultiTexCoord4svARB', 'PFNGLACTIVETEXTUREARBPROC',
'PFNGLCLIENTACTIVETEXTUREARBPROC', 'PFNGLMULTITEXCOORD1DARBPROC',
'PFNGLMULTITEXCOORD1DVARBPROC', 'PFNGLMULTITEXCOORD1FARBPROC',
'PFNGLMULTITEXCOORD1FVARBPROC', 'PFNGLMULTITEXCOORD1IARBPROC',
'PFNGLMULTITEXCOORD1IVARBPROC', 'PFNGLMULTITEXCOORD1SARBPROC',
'PFNGLMULTITEXCOORD1SVARBPROC', 'PFNGLMULTITEXCOORD2DARBPROC',
'PFNGLMULTITEXCOORD2DVARBPROC', 'PFNGLMULTITEXCOORD2FARBPROC',
'PFNGLMULTITEXCOORD2FVARBPROC', 'PFNGLMULTITEXCOORD2IARBPROC',
'PFNGLMULTITEXCOORD2IVARBPROC', 'PFNGLMULTITEXCOORD2SARBPROC',
'PFNGLMULTITEXCOORD2SVARBPROC', 'PFNGLMULTITEXCOORD3DARBPROC',
'PFNGLMULTITEXCOORD3DVARBPROC', 'PFNGLMULTITEXCOORD3FARBPROC',
'PFNGLMULTITEXCOORD3FVARBPROC', 'PFNGLMULTITEXCOORD3IARBPROC',
'PFNGLMULTITEXCOORD3IVARBPROC', 'PFNGLMULTITEXCOORD3SARBPROC',
'PFNGLMULTITEXCOORD3SVARBPROC', 'PFNGLMULTITEXCOORD4DARBPROC',
'PFNGLMULTITEXCOORD4DVARBPROC', 'PFNGLMULTITEXCOORD4FARBPROC',
'PFNGLMULTITEXCOORD4FVARBPROC', 'PFNGLMULTITEXCOORD4IARBPROC',
'PFNGLMULTITEXCOORD4IVARBPROC', 'PFNGLMULTITEXCOORD4SARBPROC',
'PFNGLMULTITEXCOORD4SVARBPROC', 'GL_ARB_transpose_matrix',
'glLoadTransposeMatrixfARB', 'glLoadTransposeMatrixdARB',
'glMultTransposeMatrixfARB', 'glMultTransposeMatrixdARB',
'PFNGLLOADTRANSPOSEMATRIXFARBPROC', 'PFNGLLOADTRANSPOSEMATRIXDARBPROC',
'PFNGLMULTTRANSPOSEMATRIXFARBPROC', 'PFNGLMULTTRANSPOSEMATRIXDARBPROC',
'GL_ARB_multisample', 'glSampleCoverageARB', 'PFNGLSAMPLECOVERAGEARBPROC',
'GL_ARB_texture_env_add', 'GL_ARB_texture_cube_map',
'GL_ARB_texture_compression', 'glCompressedTexImage3DARB',
'glCompressedTexImage2DARB', 'glCompressedTexImage1DARB',
'glCompressedTexSubImage3DARB', 'glCompressedTexSubImage2DARB',
'glCompressedTexSubImage1DARB', 'glGetCompressedTexImageARB',
'PFNGLCOMPRESSEDTEXIMAGE3DARBPROC', 'PFNGLCOMPRESSEDTEXIMAGE2DARBPROC',
'PFNGLCOMPRESSEDTEXIMAGE1DARBPROC', 'PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC',
'PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC', 'PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC',
'PFNGLGETCOMPRESSEDTEXIMAGEARBPROC', 'GL_ARB_texture_border_clamp',
'GL_ARB_point_parameters', 'glPointParameterfARB', 'glPointParameterfvARB',
'PFNGLPOINTPARAMETERFARBPROC', 'PFNGLPOINTPARAMETERFVARBPROC',
'GL_ARB_vertex_blend', 'glWeightbvARB', 'glWeightsvARB', 'glWeightivARB',
'glWeightfvARB', 'glWeightdvARB', 'glWeightubvARB', 'glWeightusvARB',
'glWeightuivARB', 'glWeightPointerARB', 'glVertexBlendARB',
'PFNGLWEIGHTBVARBPROC', 'PFNGLWEIGHTSVARBPROC', 'PFNGLWEIGHTIVARBPROC',
'PFNGLWEIGHTFVARBPROC', 'PFNGLWEIGHTDVARBPROC', 'PFNGLWEIGHTUBVARBPROC',
'PFNGLWEIGHTUSVARBPROC', 'PFNGLWEIGHTUIVARBPROC', 'PFNGLWEIGHTPOINTERARBPROC',
'PFNGLVERTEXBLENDARBPROC', 'GL_ARB_matrix_palette',
'glCurrentPaletteMatrixARB', 'glMatrixIndexubvARB', 'glMatrixIndexusvARB',
'glMatrixIndexuivARB', 'glMatrixIndexPointerARB',
'PFNGLCURRENTPALETTEMATRIXARBPROC', 'PFNGLMATRIXINDEXUBVARBPROC',
'PFNGLMATRIXINDEXUSVARBPROC', 'PFNGLMATRIXINDEXUIVARBPROC',
'PFNGLMATRIXINDEXPOINTERARBPROC', 'GL_ARB_texture_env_combine',
'GL_ARB_texture_env_crossbar', 'GL_ARB_texture_env_dot3',
'GL_ARB_texture_mirrored_repeat', 'GL_ARB_depth_texture', 'GL_ARB_shadow',
'GL_ARB_shadow_ambient', 'GL_ARB_window_pos', 'glWindowPos2dARB',
'glWindowPos2dvARB', 'glWindowPos2fARB', 'glWindowPos2fvARB',
'glWindowPos2iARB', 'glWindowPos2ivARB', 'glWindowPos2sARB',
'glWindowPos2svARB', 'glWindowPos3dARB', 'glWindowPos3dvARB',
'glWindowPos3fARB', 'glWindowPos3fvARB', 'glWindowPos3iARB',
'glWindowPos3ivARB', 'glWindowPos3sARB', 'glWindowPos3svARB',
'PFNGLWINDOWPOS2DARBPROC', 'PFNGLWINDOWPOS2DVARBPROC',
'PFNGLWINDOWPOS2FARBPROC', 'PFNGLWINDOWPOS2FVARBPROC',
'PFNGLWINDOWPOS2IARBPROC', 'PFNGLWINDOWPOS2IVARBPROC',
'PFNGLWINDOWPOS2SARBPROC', 'PFNGLWINDOWPOS2SVARBPROC',
'PFNGLWINDOWPOS3DARBPROC', 'PFNGLWINDOWPOS3DVARBPROC',
'PFNGLWINDOWPOS3FARBPROC', 'PFNGLWINDOWPOS3FVARBPROC',
'PFNGLWINDOWPOS3IARBPROC', 'PFNGLWINDOWPOS3IVARBPROC',
'PFNGLWINDOWPOS3SARBPROC', 'PFNGLWINDOWPOS3SVARBPROC',
'GL_ARB_vertex_program', 'glVertexAttrib1dARB', 'glVertexAttrib1dvARB',
'glVertexAttrib1fARB', 'glVertexAttrib1fvARB', 'glVertexAttrib1sARB',
'glVertexAttrib1svARB', 'glVertexAttrib2dARB', 'glVertexAttrib2dvARB',
'glVertexAttrib2fARB', 'glVertexAttrib2fvARB', 'glVertexAttrib2sARB',
'glVertexAttrib2svARB', 'glVertexAttrib3dARB', 'glVertexAttrib3dvARB',
'glVertexAttrib3fARB', 'glVertexAttrib3fvARB', 'glVertexAttrib3sARB',
'glVertexAttrib3svARB', 'glVertexAttrib4NbvARB', 'glVertexAttrib4NivARB',
'glVertexAttrib4NsvARB', 'glVertexAttrib4NubARB', 'glVertexAttrib4NubvARB',
'glVertexAttrib4NuivARB', 'glVertexAttrib4NusvARB', 'glVertexAttrib4bvARB',
'glVertexAttrib4dARB', 'glVertexAttrib4dvARB', 'glVertexAttrib4fARB',
'glVertexAttrib4fvARB', 'glVertexAttrib4ivARB', 'glVertexAttrib4sARB',
'glVertexAttrib4svARB', 'glVertexAttrib4ubvARB', 'glVertexAttrib4uivARB',
'glVertexAttrib4usvARB', 'glVertexAttribPointerARB',
'glEnableVertexAttribArrayARB', 'glDisableVertexAttribArrayARB',
'glProgramStringARB', 'glBindProgramARB', 'glDeleteProgramsARB',
'glGenProgramsARB', 'glProgramEnvParameter4dARB',
'glProgramEnvParameter4dvARB', 'glProgramEnvParameter4fARB',
'glProgramEnvParameter4fvARB', 'glProgramLocalParameter4dARB',
'glProgramLocalParameter4dvARB', 'glProgramLocalParameter4fARB',
'glProgramLocalParameter4fvARB', 'glGetProgramEnvParameterdvARB',
'glGetProgramEnvParameterfvARB', 'glGetProgramLocalParameterdvARB',
'glGetProgramLocalParameterfvARB', 'glGetProgramivARB',
'glGetProgramStringARB', 'glGetVertexAttribdvARB', 'glGetVertexAttribfvARB',
'glGetVertexAttribivARB', 'glGetVertexAttribPointervARB', 'glIsProgramARB',
'PFNGLVERTEXATTRIB1DARBPROC', 'PFNGLVERTEXATTRIB1DVARBPROC',
'PFNGLVERTEXATTRIB1FARBPROC', 'PFNGLVERTEXATTRIB1FVARBPROC',
'PFNGLVERTEXATTRIB1SARBPROC', 'PFNGLVERTEXATTRIB1SVARBPROC',
'PFNGLVERTEXATTRIB2DARBPROC', 'PFNGLVERTEXATTRIB2DVARBPROC',
'PFNGLVERTEXATTRIB2FARBPROC', 'PFNGLVERTEXATTRIB2FVARBPROC',
'PFNGLVERTEXATTRIB2SARBPROC', 'PFNGLVERTEXATTRIB2SVARBPROC',
'PFNGLVERTEXATTRIB3DARBPROC', 'PFNGLVERTEXATTRIB3DVARBPROC',
'PFNGLVERTEXATTRIB3FARBPROC', 'PFNGLVERTEXATTRIB3FVARBPROC',
'PFNGLVERTEXATTRIB3SARBPROC', 'PFNGLVERTEXATTRIB3SVARBPROC',
'PFNGLVERTEXATTRIB4NBVARBPROC', 'PFNGLVERTEXATTRIB4NIVARBPROC',
'PFNGLVERTEXATTRIB4NSVARBPROC', 'PFNGLVERTEXATTRIB4NUBARBPROC',
'PFNGLVERTEXATTRIB4NUBVARBPROC', 'PFNGLVERTEXATTRIB4NUIVARBPROC',
'PFNGLVERTEXATTRIB4NUSVARBPROC', 'PFNGLVERTEXATTRIB4BVARBPROC',
'PFNGLVERTEXATTRIB4DARBPROC', 'PFNGLVERTEXATTRIB4DVARBPROC',
'PFNGLVERTEXATTRIB4FARBPROC', 'PFNGLVERTEXATTRIB4FVARBPROC',
'PFNGLVERTEXATTRIB4IVARBPROC', 'PFNGLVERTEXATTRIB4SARBPROC',
'PFNGLVERTEXATTRIB4SVARBPROC', 'PFNGLVERTEXATTRIB4UBVARBPROC',
'PFNGLVERTEXATTRIB4UIVARBPROC', 'PFNGLVERTEXATTRIB4USVARBPROC',
'PFNGLVERTEXATTRIBPOINTERARBPROC', 'PFNGLENABLEVERTEXATTRIBARRAYARBPROC',
'PFNGLDISABLEVERTEXATTRIBARRAYARBPROC', 'PFNGLPROGRAMSTRINGARBPROC',
'PFNGLBINDPROGRAMARBPROC', 'PFNGLDELETEPROGRAMSARBPROC',
'PFNGLGENPROGRAMSARBPROC', 'PFNGLPROGRAMENVPARAMETER4DARBPROC',
'PFNGLPROGRAMENVPARAMETER4DVARBPROC', 'PFNGLPROGRAMENVPARAMETER4FARBPROC',
'PFNGLPROGRAMENVPARAMETER4FVARBPROC', 'PFNGLPROGRAMLOCALPARAMETER4DARBPROC',
'PFNGLPROGRAMLOCALPARAMETER4DVARBPROC', 'PFNGLPROGRAMLOCALPARAMETER4FARBPROC',
'PFNGLPROGRAMLOCALPARAMETER4FVARBPROC',
'PFNGLGETPROGRAMENVPARAMETERDVARBPROC',
'PFNGLGETPROGRAMENVPARAMETERFVARBPROC',
'PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC',
'PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC', 'PFNGLGETPROGRAMIVARBPROC',
'PFNGLGETPROGRAMSTRINGARBPROC', 'PFNGLGETVERTEXATTRIBDVARBPROC',
'PFNGLGETVERTEXATTRIBFVARBPROC', 'PFNGLGETVERTEXATTRIBIVARBPROC',
'PFNGLGETVERTEXATTRIBPOINTERVARBPROC', 'PFNGLISPROGRAMARBPROC',
'GL_ARB_fragment_program', 'GL_ARB_vertex_buffer_object', 'glBindBufferARB',
'glDeleteBuffersARB', 'glGenBuffersARB', 'glIsBufferARB', 'glBufferDataARB',
'glBufferSubDataARB', 'glGetBufferSubDataARB', 'glMapBufferARB',
'glUnmapBufferARB', 'glGetBufferParameterivARB', 'glGetBufferPointervARB',
'PFNGLBINDBUFFERARBPROC', 'PFNGLDELETEBUFFERSARBPROC',
'PFNGLGENBUFFERSARBPROC', 'PFNGLISBUFFERARBPROC', 'PFNGLBUFFERDATAARBPROC',
'PFNGLBUFFERSUBDATAARBPROC', 'PFNGLGETBUFFERSUBDATAARBPROC',
'PFNGLMAPBUFFERARBPROC', 'PFNGLUNMAPBUFFERARBPROC',
'PFNGLGETBUFFERPARAMETERIVARBPROC', 'PFNGLGETBUFFERPOINTERVARBPROC',
'GL_ARB_occlusion_query', 'glGenQueriesARB', 'glDeleteQueriesARB',
'glIsQueryARB', 'glBeginQueryARB', 'glEndQueryARB', 'glGetQueryivARB',
'glGetQueryObjectivARB', 'glGetQueryObjectuivARB', 'PFNGLGENQUERIESARBPROC',
'PFNGLDELETEQUERIESARBPROC', 'PFNGLISQUERYARBPROC', 'PFNGLBEGINQUERYARBPROC',
'PFNGLENDQUERYARBPROC', 'PFNGLGETQUERYIVARBPROC',
'PFNGLGETQUERYOBJECTIVARBPROC', 'PFNGLGETQUERYOBJECTUIVARBPROC',
'GL_ARB_shader_objects', 'glDeleteObjectARB', 'glGetHandleARB',
'glDetachObjectARB', 'glCreateShaderObjectARB', 'glShaderSourceARB',
'glCompileShaderARB', 'glCreateProgramObjectARB', 'glAttachObjectARB',
'glLinkProgramARB', 'glUseProgramObjectARB', 'glValidateProgramARB',
'glUniform1fARB', 'glUniform2fARB', 'glUniform3fARB', 'glUniform4fARB',
'glUniform1iARB', 'glUniform2iARB', 'glUniform3iARB', 'glUniform4iARB',
'glUniform1fvARB', 'glUniform2fvARB', 'glUniform3fvARB', 'glUniform4fvARB',
'glUniform1ivARB', 'glUniform2ivARB', 'glUniform3ivARB', 'glUniform4ivARB',
'glUniformMatrix2fvARB', 'glUniformMatrix3fvARB', 'glUniformMatrix4fvARB',
'glGetObjectParameterfvARB', 'glGetObjectParameterivARB', 'glGetInfoLogARB',
'glGetAttachedObjectsARB', 'glGetUniformLocationARB', 'glGetActiveUniformARB',
'glGetUniformfvARB', 'glGetUniformivARB', 'glGetShaderSourceARB',
'PFNGLDELETEOBJECTARBPROC', 'PFNGLGETHANDLEARBPROC',
'PFNGLDETACHOBJECTARBPROC', 'PFNGLCREATESHADEROBJECTARBPROC',
'PFNGLSHADERSOURCEARBPROC', 'PFNGLCOMPILESHADERARBPROC',
'PFNGLCREATEPROGRAMOBJECTARBPROC', 'PFNGLATTACHOBJECTARBPROC',
'PFNGLLINKPROGRAMARBPROC', 'PFNGLUSEPROGRAMOBJECTARBPROC',
'PFNGLVALIDATEPROGRAMARBPROC', 'PFNGLUNIFORM1FARBPROC',
'PFNGLUNIFORM2FARBPROC', 'PFNGLUNIFORM3FARBPROC', 'PFNGLUNIFORM4FARBPROC',
'PFNGLUNIFORM1IARBPROC', 'PFNGLUNIFORM2IARBPROC', 'PFNGLUNIFORM3IARBPROC',
'PFNGLUNIFORM4IARBPROC', 'PFNGLUNIFORM1FVARBPROC', 'PFNGLUNIFORM2FVARBPROC',
'PFNGLUNIFORM3FVARBPROC', 'PFNGLUNIFORM4FVARBPROC', 'PFNGLUNIFORM1IVARBPROC',
'PFNGLUNIFORM2IVARBPROC', 'PFNGLUNIFORM3IVARBPROC', 'PFNGLUNIFORM4IVARBPROC',
'PFNGLUNIFORMMATRIX2FVARBPROC', 'PFNGLUNIFORMMATRIX3FVARBPROC',
'PFNGLUNIFORMMATRIX4FVARBPROC', 'PFNGLGETOBJECTPARAMETERFVARBPROC',
'PFNGLGETOBJECTPARAMETERIVARBPROC', 'PFNGLGETINFOLOGARBPROC',
'PFNGLGETATTACHEDOBJECTSARBPROC', 'PFNGLGETUNIFORMLOCATIONARBPROC',
'PFNGLGETACTIVEUNIFORMARBPROC', 'PFNGLGETUNIFORMFVARBPROC',
'PFNGLGETUNIFORMIVARBPROC', 'PFNGLGETSHADERSOURCEARBPROC',
'GL_ARB_vertex_shader', 'glBindAttribLocationARB', 'glGetActiveAttribARB',
'glGetAttribLocationARB', 'PFNGLBINDATTRIBLOCATIONARBPROC',
'PFNGLGETACTIVEATTRIBARBPROC', 'PFNGLGETATTRIBLOCATIONARBPROC',
'GL_ARB_fragment_shader', 'GL_ARB_shading_language_100',
'GL_ARB_texture_non_power_of_two', 'GL_ARB_point_sprite',
'GL_ARB_fragment_program_shadow', 'GL_ARB_draw_buffers', 'glDrawBuffersARB',
'PFNGLDRAWBUFFERSARBPROC', 'GL_ARB_texture_rectangle',
'GL_ARB_color_buffer_float', 'glClampColorARB', 'PFNGLCLAMPCOLORARBPROC',
'GL_ARB_half_float_pixel', 'GL_ARB_texture_float',
'GL_ARB_pixel_buffer_object', 'GL_EXT_abgr', 'GL_EXT_blend_color',
'glBlendColorEXT', 'PFNGLBLENDCOLOREXTPROC', 'GL_EXT_polygon_offset',
'glPolygonOffsetEXT', 'PFNGLPOLYGONOFFSETEXTPROC', 'GL_EXT_texture',
'GL_EXT_texture3D', 'glTexImage3DEXT', 'glTexSubImage3DEXT',
'PFNGLTEXIMAGE3DEXTPROC', 'PFNGLTEXSUBIMAGE3DEXTPROC',
'GL_SGIS_texture_filter4', 'glGetTexFilterFuncSGIS', 'glTexFilterFuncSGIS',
'PFNGLGETTEXFILTERFUNCSGISPROC', 'PFNGLTEXFILTERFUNCSGISPROC',
'GL_EXT_subtexture', 'glTexSubImage1DEXT', 'glTexSubImage2DEXT',
'PFNGLTEXSUBIMAGE1DEXTPROC', 'PFNGLTEXSUBIMAGE2DEXTPROC',
'GL_EXT_copy_texture', 'glCopyTexImage1DEXT', 'glCopyTexImage2DEXT',
'glCopyTexSubImage1DEXT', 'glCopyTexSubImage2DEXT', 'glCopyTexSubImage3DEXT',
'PFNGLCOPYTEXIMAGE1DEXTPROC', 'PFNGLCOPYTEXIMAGE2DEXTPROC',
'PFNGLCOPYTEXSUBIMAGE1DEXTPROC', 'PFNGLCOPYTEXSUBIMAGE2DEXTPROC',
'PFNGLCOPYTEXSUBIMAGE3DEXTPROC', 'GL_EXT_histogram', 'glGetHistogramEXT',
'glGetHistogramParameterfvEXT', 'glGetHistogramParameterivEXT',
'glGetMinmaxEXT', 'glGetMinmaxParameterfvEXT', 'glGetMinmaxParameterivEXT',
'glHistogramEXT', 'glMinmaxEXT', 'glResetHistogramEXT', 'glResetMinmaxEXT',
'PFNGLGETHISTOGRAMEXTPROC', 'PFNGLGETHISTOGRAMPARAMETERFVEXTPROC',
'PFNGLGETHISTOGRAMPARAMETERIVEXTPROC', 'PFNGLGETMINMAXEXTPROC',
'PFNGLGETMINMAXPARAMETERFVEXTPROC', 'PFNGLGETMINMAXPARAMETERIVEXTPROC',
'PFNGLHISTOGRAMEXTPROC', 'PFNGLMINMAXEXTPROC', 'PFNGLRESETHISTOGRAMEXTPROC',
'PFNGLRESETMINMAXEXTPROC', 'GL_EXT_convolution', 'glConvolutionFilter1DEXT',
'glConvolutionFilter2DEXT', 'glConvolutionParameterfEXT',
'glConvolutionParameterfvEXT', 'glConvolutionParameteriEXT',
'glConvolutionParameterivEXT', 'glCopyConvolutionFilter1DEXT',
'glCopyConvolutionFilter2DEXT', 'glGetConvolutionFilterEXT',
'glGetConvolutionParameterfvEXT', 'glGetConvolutionParameterivEXT',
'glGetSeparableFilterEXT', 'glSeparableFilter2DEXT',
'PFNGLCONVOLUTIONFILTER1DEXTPROC', 'PFNGLCONVOLUTIONFILTER2DEXTPROC',
'PFNGLCONVOLUTIONPARAMETERFEXTPROC', 'PFNGLCONVOLUTIONPARAMETERFVEXTPROC',
'PFNGLCONVOLUTIONPARAMETERIEXTPROC', 'PFNGLCONVOLUTIONPARAMETERIVEXTPROC',
'PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC', 'PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC',
'PFNGLGETCONVOLUTIONFILTEREXTPROC', 'PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC',
'PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC', 'PFNGLGETSEPARABLEFILTEREXTPROC',
'PFNGLSEPARABLEFILTER2DEXTPROC', 'GL_EXT_color_matrix', 'GL_SGI_color_table',
'glColorTableSGI', 'glColorTableParameterfvSGI', 'glColorTableParameterivSGI',
'glCopyColorTableSGI', 'glGetColorTableSGI', 'glGetColorTableParameterfvSGI',
'glGetColorTableParameterivSGI', 'PFNGLCOLORTABLESGIPROC',
'PFNGLCOLORTABLEPARAMETERFVSGIPROC', 'PFNGLCOLORTABLEPARAMETERIVSGIPROC',
'PFNGLCOPYCOLORTABLESGIPROC', 'PFNGLGETCOLORTABLESGIPROC',
'PFNGLGETCOLORTABLEPARAMETERFVSGIPROC',
'PFNGLGETCOLORTABLEPARAMETERIVSGIPROC', 'GL_SGIX_pixel_texture',
'glPixelTexGenSGIX', 'PFNGLPIXELTEXGENSGIXPROC', 'GL_SGIS_pixel_texture',
'glPixelTexGenParameteriSGIS', 'glPixelTexGenParameterivSGIS',
'glPixelTexGenParameterfSGIS', 'glPixelTexGenParameterfvSGIS',
'glGetPixelTexGenParameterivSGIS', 'glGetPixelTexGenParameterfvSGIS',
'PFNGLPIXELTEXGENPARAMETERISGISPROC', 'PFNGLPIXELTEXGENPARAMETERIVSGISPROC',
'PFNGLPIXELTEXGENPARAMETERFSGISPROC', 'PFNGLPIXELTEXGENPARAMETERFVSGISPROC',
'PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC',
'PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC', 'GL_SGIS_texture4D',
'glTexImage4DSGIS', 'glTexSubImage4DSGIS', 'PFNGLTEXIMAGE4DSGISPROC',
'PFNGLTEXSUBIMAGE4DSGISPROC', 'GL_SGI_texture_color_table', 'GL_EXT_cmyka',
'GL_EXT_texture_object', 'glAreTexturesResidentEXT', 'glBindTextureEXT',
'glDeleteTexturesEXT', 'glGenTexturesEXT', 'glIsTextureEXT',
'glPrioritizeTexturesEXT', 'PFNGLARETEXTURESRESIDENTEXTPROC',
'PFNGLBINDTEXTUREEXTPROC', 'PFNGLDELETETEXTURESEXTPROC',
'PFNGLGENTEXTURESEXTPROC', 'PFNGLISTEXTUREEXTPROC',
'PFNGLPRIORITIZETEXTURESEXTPROC', 'GL_SGIS_detail_texture',
'glDetailTexFuncSGIS', 'glGetDetailTexFuncSGIS', 'PFNGLDETAILTEXFUNCSGISPROC',
'PFNGLGETDETAILTEXFUNCSGISPROC', 'GL_SGIS_sharpen_texture',
'glSharpenTexFuncSGIS', 'glGetSharpenTexFuncSGIS',
'PFNGLSHARPENTEXFUNCSGISPROC', 'PFNGLGETSHARPENTEXFUNCSGISPROC',
'GL_EXT_packed_pixels', 'GL_SGIS_texture_lod', 'GL_SGIS_multisample',
'glSampleMaskSGIS', 'glSamplePatternSGIS', 'PFNGLSAMPLEMASKSGISPROC',
'PFNGLSAMPLEPATTERNSGISPROC', 'GL_EXT_rescale_normal', 'GL_EXT_vertex_array',
'glArrayElementEXT', 'glColorPointerEXT', 'glDrawArraysEXT',
'glEdgeFlagPointerEXT', 'glGetPointervEXT', 'glIndexPointerEXT',
'glNormalPointerEXT', 'glTexCoordPointerEXT', 'glVertexPointerEXT',
'PFNGLARRAYELEMENTEXTPROC', 'PFNGLCOLORPOINTEREXTPROC',
'PFNGLDRAWARRAYSEXTPROC', 'PFNGLEDGEFLAGPOINTEREXTPROC',
'PFNGLGETPOINTERVEXTPROC', 'PFNGLINDEXPOINTEREXTPROC',
'PFNGLNORMALPOINTEREXTPROC', 'PFNGLTEXCOORDPOINTEREXTPROC',
'PFNGLVERTEXPOINTEREXTPROC', 'GL_EXT_misc_attribute',
'GL_SGIS_generate_mipmap', 'GL_SGIX_clipmap', 'GL_SGIX_shadow',
'GL_SGIS_texture_edge_clamp', 'GL_SGIS_texture_border_clamp',
'GL_EXT_blend_minmax', 'glBlendEquationEXT', 'PFNGLBLENDEQUATIONEXTPROC',
'GL_EXT_blend_subtract', 'GL_EXT_blend_logic_op', 'GL_SGIX_interlace',
'GL_SGIX_pixel_tiles', 'GL_SGIX_texture_select', 'GL_SGIX_sprite',
'glSpriteParameterfSGIX', 'glSpriteParameterfvSGIX', 'glSpriteParameteriSGIX',
'glSpriteParameterivSGIX', 'PFNGLSPRITEPARAMETERFSGIXPROC',
'PFNGLSPRITEPARAMETERFVSGIXPROC', 'PFNGLSPRITEPARAMETERISGIXPROC',
'PFNGLSPRITEPARAMETERIVSGIXPROC', 'GL_SGIX_texture_multi_buffer',
'GL_EXT_point_parameters', 'glPointParameterfEXT', 'glPointParameterfvEXT',
'PFNGLPOINTPARAMETERFEXTPROC', 'PFNGLPOINTPARAMETERFVEXTPROC',
'GL_SGIS_point_parameters', 'glPointParameterfSGIS', 'glPointParameterfvSGIS',
'PFNGLPOINTPARAMETERFSGISPROC', 'PFNGLPOINTPARAMETERFVSGISPROC',
'GL_SGIX_instruments', 'glGetInstrumentsSGIX', 'glInstrumentsBufferSGIX',
'glPollInstrumentsSGIX', 'glReadInstrumentsSGIX', 'glStartInstrumentsSGIX',
'glStopInstrumentsSGIX', 'PFNGLGETINSTRUMENTSSGIXPROC',
'PFNGLINSTRUMENTSBUFFERSGIXPROC', 'PFNGLPOLLINSTRUMENTSSGIXPROC',
'PFNGLREADINSTRUMENTSSGIXPROC', 'PFNGLSTARTINSTRUMENTSSGIXPROC',
'PFNGLSTOPINSTRUMENTSSGIXPROC', 'GL_SGIX_texture_scale_bias',
'GL_SGIX_framezoom', 'glFrameZoomSGIX', 'PFNGLFRAMEZOOMSGIXPROC',
'GL_SGIX_tag_sample_buffer', 'glTagSampleBufferSGIX',
'PFNGLTAGSAMPLEBUFFERSGIXPROC', 'GL_SGIX_polynomial_ffd',
'glDeformationMap3dSGIX', 'glDeformationMap3fSGIX', 'glDeformSGIX',
'glLoadIdentityDeformationMapSGIX', 'PFNGLDEFORMATIONMAP3DSGIXPROC',
'PFNGLDEFORMATIONMAP3FSGIXPROC', 'PFNGLDEFORMSGIXPROC',
'PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC', 'GL_SGIX_reference_plane',
'glReferencePlaneSGIX', 'PFNGLREFERENCEPLANESGIXPROC', 'GL_SGIX_flush_raster',
'glFlushRasterSGIX', 'PFNGLFLUSHRASTERSGIXPROC', 'GL_SGIX_depth_texture',
'GL_SGIS_fog_function', 'glFogFuncSGIS', 'glGetFogFuncSGIS',
'PFNGLFOGFUNCSGISPROC', 'PFNGLGETFOGFUNCSGISPROC', 'GL_SGIX_fog_offset',
'GL_HP_image_transform', 'glImageTransformParameteriHP',
'glImageTransformParameterfHP', 'glImageTransformParameterivHP',
'glImageTransformParameterfvHP', 'glGetImageTransformParameterivHP',
'glGetImageTransformParameterfvHP', 'PFNGLIMAGETRANSFORMPARAMETERIHPPROC',
'PFNGLIMAGETRANSFORMPARAMETERFHPPROC', 'PFNGLIMAGETRANSFORMPARAMETERIVHPPROC',
'PFNGLIMAGETRANSFORMPARAMETERFVHPPROC',
'PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC',
'PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC', 'GL_HP_convolution_border_modes',
'GL_SGIX_texture_add_env', 'GL_EXT_color_subtable', 'glColorSubTableEXT',
'glCopyColorSubTableEXT', 'PFNGLCOLORSUBTABLEEXTPROC',
'PFNGLCOPYCOLORSUBTABLEEXTPROC', 'GL_PGI_vertex_hints', 'GL_PGI_misc_hints',
'glHintPGI', 'PFNGLHINTPGIPROC', 'GL_EXT_paletted_texture', 'glColorTableEXT',
'glGetColorTableEXT', 'glGetColorTableParameterivEXT',
'glGetColorTableParameterfvEXT', 'PFNGLCOLORTABLEEXTPROC',
'PFNGLGETCOLORTABLEEXTPROC', 'PFNGLGETCOLORTABLEPARAMETERIVEXTPROC',
'PFNGLGETCOLORTABLEPARAMETERFVEXTPROC', 'GL_EXT_clip_volume_hint',
'GL_SGIX_list_priority', 'glGetListParameterfvSGIX',
'glGetListParameterivSGIX', 'glListParameterfSGIX', 'glListParameterfvSGIX',
'glListParameteriSGIX', 'glListParameterivSGIX',
'PFNGLGETLISTPARAMETERFVSGIXPROC', 'PFNGLGETLISTPARAMETERIVSGIXPROC',
'PFNGLLISTPARAMETERFSGIXPROC', 'PFNGLLISTPARAMETERFVSGIXPROC',
'PFNGLLISTPARAMETERISGIXPROC', 'PFNGLLISTPARAMETERIVSGIXPROC',
'GL_SGIX_ir_instrument1', 'GL_SGIX_calligraphic_fragment',
'GL_SGIX_texture_lod_bias', 'GL_SGIX_shadow_ambient', 'GL_EXT_index_texture',
'GL_EXT_index_material', 'glIndexMaterialEXT', 'PFNGLINDEXMATERIALEXTPROC',
'GL_EXT_index_func', 'glIndexFuncEXT', 'PFNGLINDEXFUNCEXTPROC',
'GL_EXT_index_array_formats', 'GL_EXT_compiled_vertex_array',
'glLockArraysEXT', 'glUnlockArraysEXT', 'PFNGLLOCKARRAYSEXTPROC',
'PFNGLUNLOCKARRAYSEXTPROC', 'GL_EXT_cull_vertex', 'glCullParameterdvEXT',
'glCullParameterfvEXT', 'PFNGLCULLPARAMETERDVEXTPROC',
'PFNGLCULLPARAMETERFVEXTPROC', 'GL_SGIX_ycrcb', 'GL_SGIX_fragment_lighting',
'glFragmentColorMaterialSGIX', 'glFragmentLightfSGIX',
'glFragmentLightfvSGIX', 'glFragmentLightiSGIX', 'glFragmentLightivSGIX',
'glFragmentLightModelfSGIX', 'glFragmentLightModelfvSGIX',
'glFragmentLightModeliSGIX', 'glFragmentLightModelivSGIX',
'glFragmentMaterialfSGIX', 'glFragmentMaterialfvSGIX',
'glFragmentMaterialiSGIX', 'glFragmentMaterialivSGIX',
'glGetFragmentLightfvSGIX', 'glGetFragmentLightivSGIX',
'glGetFragmentMaterialfvSGIX', 'glGetFragmentMaterialivSGIX',
'glLightEnviSGIX', 'PFNGLFRAGMENTCOLORMATERIALSGIXPROC',
'PFNGLFRAGMENTLIGHTFSGIXPROC', 'PFNGLFRAGMENTLIGHTFVSGIXPROC',
'PFNGLFRAGMENTLIGHTISGIXPROC', 'PFNGLFRAGMENTLIGHTIVSGIXPROC',
'PFNGLFRAGMENTLIGHTMODELFSGIXPROC', 'PFNGLFRAGMENTLIGHTMODELFVSGIXPROC',
'PFNGLFRAGMENTLIGHTMODELISGIXPROC', 'PFNGLFRAGMENTLIGHTMODELIVSGIXPROC',
'PFNGLFRAGMENTMATERIALFSGIXPROC', 'PFNGLFRAGMENTMATERIALFVSGIXPROC',
'PFNGLFRAGMENTMATERIALISGIXPROC', 'PFNGLFRAGMENTMATERIALIVSGIXPROC',
'PFNGLGETFRAGMENTLIGHTFVSGIXPROC', 'PFNGLGETFRAGMENTLIGHTIVSGIXPROC',
'PFNGLGETFRAGMENTMATERIALFVSGIXPROC', 'PFNGLGETFRAGMENTMATERIALIVSGIXPROC',
'PFNGLLIGHTENVISGIXPROC', 'GL_IBM_rasterpos_clip', 'GL_HP_texture_lighting',
'GL_EXT_draw_range_elements', 'glDrawRangeElementsEXT',
'PFNGLDRAWRANGEELEMENTSEXTPROC', 'GL_WIN_phong_shading',
'GL_WIN_specular_fog', 'GL_EXT_light_texture', 'glApplyTextureEXT',
'glTextureLightEXT', 'glTextureMaterialEXT', 'PFNGLAPPLYTEXTUREEXTPROC',
'PFNGLTEXTURELIGHTEXTPROC', 'PFNGLTEXTUREMATERIALEXTPROC',
'GL_SGIX_blend_alpha_minmax', 'GL_EXT_bgra', 'GL_SGIX_async',
'glAsyncMarkerSGIX', 'glFinishAsyncSGIX', 'glPollAsyncSGIX',
'glGenAsyncMarkersSGIX', 'glDeleteAsyncMarkersSGIX', 'glIsAsyncMarkerSGIX',
'PFNGLASYNCMARKERSGIXPROC', 'PFNGLFINISHASYNCSGIXPROC',
'PFNGLPOLLASYNCSGIXPROC', 'PFNGLGENASYNCMARKERSSGIXPROC',
'PFNGLDELETEASYNCMARKERSSGIXPROC', 'PFNGLISASYNCMARKERSGIXPROC',
'GL_SGIX_async_pixel', 'GL_SGIX_async_histogram', 'GL_INTEL_parallel_arrays',
'glVertexPointervINTEL', 'glNormalPointervINTEL', 'glColorPointervINTEL',
'glTexCoordPointervINTEL', 'PFNGLVERTEXPOINTERVINTELPROC',
'PFNGLNORMALPOINTERVINTELPROC', 'PFNGLCOLORPOINTERVINTELPROC',
'PFNGLTEXCOORDPOINTERVINTELPROC', 'GL_HP_occlusion_test',
'GL_EXT_pixel_transform', 'glPixelTransformParameteriEXT',
'glPixelTransformParameterfEXT', 'glPixelTransformParameterivEXT',
'glPixelTransformParameterfvEXT', 'PFNGLPIXELTRANSFORMPARAMETERIEXTPROC',
'PFNGLPIXELTRANSFORMPARAMETERFEXTPROC',
'PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC',
'PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC', 'GL_EXT_pixel_transform_color_table',
'GL_EXT_shared_texture_palette', 'GL_EXT_separate_specular_color',
'GL_EXT_secondary_color', 'glSecondaryColor3bEXT', 'glSecondaryColor3bvEXT',
'glSecondaryColor3dEXT', 'glSecondaryColor3dvEXT', 'glSecondaryColor3fEXT',
'glSecondaryColor3fvEXT', 'glSecondaryColor3iEXT', 'glSecondaryColor3ivEXT',
'glSecondaryColor3sEXT', 'glSecondaryColor3svEXT', 'glSecondaryColor3ubEXT',
'glSecondaryColor3ubvEXT', 'glSecondaryColor3uiEXT',
'glSecondaryColor3uivEXT', 'glSecondaryColor3usEXT',
'glSecondaryColor3usvEXT', 'glSecondaryColorPointerEXT',
'PFNGLSECONDARYCOLOR3BEXTPROC', 'PFNGLSECONDARYCOLOR3BVEXTPROC',
'PFNGLSECONDARYCOLOR3DEXTPROC', 'PFNGLSECONDARYCOLOR3DVEXTPROC',
'PFNGLSECONDARYCOLOR3FEXTPROC', 'PFNGLSECONDARYCOLOR3FVEXTPROC',
'PFNGLSECONDARYCOLOR3IEXTPROC', 'PFNGLSECONDARYCOLOR3IVEXTPROC',
'PFNGLSECONDARYCOLOR3SEXTPROC', 'PFNGLSECONDARYCOLOR3SVEXTPROC',
'PFNGLSECONDARYCOLOR3UBEXTPROC', 'PFNGLSECONDARYCOLOR3UBVEXTPROC',
'PFNGLSECONDARYCOLOR3UIEXTPROC', 'PFNGLSECONDARYCOLOR3UIVEXTPROC',
'PFNGLSECONDARYCOLOR3USEXTPROC', 'PFNGLSECONDARYCOLOR3USVEXTPROC',
'PFNGLSECONDARYCOLORPOINTEREXTPROC', 'GL_EXT_texture_perturb_normal',
'glTextureNormalEXT', 'PFNGLTEXTURENORMALEXTPROC', 'GL_EXT_multi_draw_arrays',
'glMultiDrawArraysEXT', 'glMultiDrawElementsEXT',
'PFNGLMULTIDRAWARRAYSEXTPROC', 'PFNGLMULTIDRAWELEMENTSEXTPROC',
'GL_EXT_fog_coord', 'glFogCoordfEXT', 'glFogCoordfvEXT', 'glFogCoorddEXT',
'glFogCoorddvEXT', 'glFogCoordPointerEXT', 'PFNGLFOGCOORDFEXTPROC',
'PFNGLFOGCOORDFVEXTPROC', 'PFNGLFOGCOORDDEXTPROC', 'PFNGLFOGCOORDDVEXTPROC',
'PFNGLFOGCOORDPOINTEREXTPROC', 'GL_REND_screen_coordinates',
'GL_EXT_coordinate_frame', 'glTangent3bEXT', 'glTangent3bvEXT',
'glTangent3dEXT', 'glTangent3dvEXT', 'glTangent3fEXT', 'glTangent3fvEXT',
'glTangent3iEXT', 'glTangent3ivEXT', 'glTangent3sEXT', 'glTangent3svEXT',
'glBinormal3bEXT', 'glBinormal3bvEXT', 'glBinormal3dEXT', 'glBinormal3dvEXT',
'glBinormal3fEXT', 'glBinormal3fvEXT', 'glBinormal3iEXT', 'glBinormal3ivEXT',
'glBinormal3sEXT', 'glBinormal3svEXT', 'glTangentPointerEXT',
'glBinormalPointerEXT', 'PFNGLTANGENT3BEXTPROC', 'PFNGLTANGENT3BVEXTPROC',
'PFNGLTANGENT3DEXTPROC', 'PFNGLTANGENT3DVEXTPROC', 'PFNGLTANGENT3FEXTPROC',
'PFNGLTANGENT3FVEXTPROC', 'PFNGLTANGENT3IEXTPROC', 'PFNGLTANGENT3IVEXTPROC',
'PFNGLTANGENT3SEXTPROC', 'PFNGLTANGENT3SVEXTPROC', 'PFNGLBINORMAL3BEXTPROC',
'PFNGLBINORMAL3BVEXTPROC', 'PFNGLBINORMAL3DEXTPROC',
'PFNGLBINORMAL3DVEXTPROC', 'PFNGLBINORMAL3FEXTPROC',
'PFNGLBINORMAL3FVEXTPROC', 'PFNGLBINORMAL3IEXTPROC',
'PFNGLBINORMAL3IVEXTPROC', 'PFNGLBINORMAL3SEXTPROC',
'PFNGLBINORMAL3SVEXTPROC', 'PFNGLTANGENTPOINTEREXTPROC',
'PFNGLBINORMALPOINTEREXTPROC', 'GL_EXT_texture_env_combine',
'GL_APPLE_specular_vector', 'GL_APPLE_transform_hint', 'GL_SGIX_fog_scale',
'GL_SUNX_constant_data', 'glFinishTextureSUNX', 'PFNGLFINISHTEXTURESUNXPROC',
'GL_SUN_global_alpha', 'glGlobalAlphaFactorbSUN', 'glGlobalAlphaFactorsSUN',
'glGlobalAlphaFactoriSUN', 'glGlobalAlphaFactorfSUN',
'glGlobalAlphaFactordSUN', 'glGlobalAlphaFactorubSUN',
'glGlobalAlphaFactorusSUN', 'glGlobalAlphaFactoruiSUN',
'PFNGLGLOBALALPHAFACTORBSUNPROC', 'PFNGLGLOBALALPHAFACTORSSUNPROC',
'PFNGLGLOBALALPHAFACTORISUNPROC', 'PFNGLGLOBALALPHAFACTORFSUNPROC',
'PFNGLGLOBALALPHAFACTORDSUNPROC', 'PFNGLGLOBALALPHAFACTORUBSUNPROC',
'PFNGLGLOBALALPHAFACTORUSSUNPROC', 'PFNGLGLOBALALPHAFACTORUISUNPROC',
'GL_SUN_triangle_list', 'glReplacementCodeuiSUN', 'glReplacementCodeusSUN',
'glReplacementCodeubSUN', 'glReplacementCodeuivSUN',
'glReplacementCodeusvSUN', 'glReplacementCodeubvSUN',
'glReplacementCodePointerSUN', 'PFNGLREPLACEMENTCODEUISUNPROC',
'PFNGLREPLACEMENTCODEUSSUNPROC', 'PFNGLREPLACEMENTCODEUBSUNPROC',
'PFNGLREPLACEMENTCODEUIVSUNPROC', 'PFNGLREPLACEMENTCODEUSVSUNPROC',
'PFNGLREPLACEMENTCODEUBVSUNPROC', 'PFNGLREPLACEMENTCODEPOINTERSUNPROC',
'GL_SUN_vertex', 'glColor4ubVertex2fSUN', 'glColor4ubVertex2fvSUN',
'glColor4ubVertex3fSUN', 'glColor4ubVertex3fvSUN', 'glColor3fVertex3fSUN',
'glColor3fVertex3fvSUN', 'glNormal3fVertex3fSUN', 'glNormal3fVertex3fvSUN',
'glColor4fNormal3fVertex3fSUN', 'glColor4fNormal3fVertex3fvSUN',
'glTexCoord2fVertex3fSUN', 'glTexCoord2fVertex3fvSUN',
'glTexCoord4fVertex4fSUN', 'glTexCoord4fVertex4fvSUN',
'glTexCoord2fColor4ubVertex3fSUN', 'glTexCoord2fColor4ubVertex3fvSUN',
'glTexCoord2fColor3fVertex3fSUN', 'glTexCoord2fColor3fVertex3fvSUN',
'glTexCoord2fNormal3fVertex3fSUN', 'glTexCoord2fNormal3fVertex3fvSUN',
'glTexCoord2fColor4fNormal3fVertex3fSUN',
'glTexCoord2fColor4fNormal3fVertex3fvSUN',
'glTexCoord4fColor4fNormal3fVertex4fSUN',
'glTexCoord4fColor4fNormal3fVertex4fvSUN', 'glReplacementCodeuiVertex3fSUN',
'glReplacementCodeuiVertex3fvSUN', 'glReplacementCodeuiColor4ubVertex3fSUN',
'glReplacementCodeuiColor4ubVertex3fvSUN',
'glReplacementCodeuiColor3fVertex3fSUN',
'glReplacementCodeuiColor3fVertex3fvSUN',
'glReplacementCodeuiNormal3fVertex3fSUN',
'glReplacementCodeuiNormal3fVertex3fvSUN',
'glReplacementCodeuiColor4fNormal3fVertex3fSUN',
'glReplacementCodeuiColor4fNormal3fVertex3fvSUN',
'glReplacementCodeuiTexCoord2fVertex3fSUN',
'glReplacementCodeuiTexCoord2fVertex3fvSUN',
'glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN',
'glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN',
'glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN',
'glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN',
'PFNGLCOLOR4UBVERTEX2FSUNPROC', 'PFNGLCOLOR4UBVERTEX2FVSUNPROC',
'PFNGLCOLOR4UBVERTEX3FSUNPROC', 'PFNGLCOLOR4UBVERTEX3FVSUNPROC',
'PFNGLCOLOR3FVERTEX3FSUNPROC', 'PFNGLCOLOR3FVERTEX3FVSUNPROC',
'PFNGLNORMAL3FVERTEX3FSUNPROC', 'PFNGLNORMAL3FVERTEX3FVSUNPROC',
'PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC', 'PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC',
'PFNGLTEXCOORD2FVERTEX3FSUNPROC', 'PFNGLTEXCOORD2FVERTEX3FVSUNPROC',
'PFNGLTEXCOORD4FVERTEX4FSUNPROC', 'PFNGLTEXCOORD4FVERTEX4FVSUNPROC',
'PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC',
'PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC',
'PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC',
'PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC',
'PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC',
'PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC',
'PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC',
'PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC',
'PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC',
'PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC',
'PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC',
'PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC',
'PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC',
'PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC',
'PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC',
'PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC',
'PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC',
'PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC',
'PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC',
'GL_EXT_blend_func_separate', 'glBlendFuncSeparateEXT',
'PFNGLBLENDFUNCSEPARATEEXTPROC', 'GL_INGR_blend_func_separate',
'glBlendFuncSeparateINGR', 'PFNGLBLENDFUNCSEPARATEINGRPROC',
'GL_INGR_color_clamp', 'GL_INGR_interlace_read', 'GL_EXT_stencil_wrap',
'GL_EXT_422_pixels', 'GL_NV_texgen_reflection',
'GL_SUN_convolution_border_modes', 'GL_EXT_texture_env_add',
'GL_EXT_texture_lod_bias', 'GL_EXT_texture_filter_anisotropic',
'GL_EXT_vertex_weighting', 'glVertexWeightfEXT', 'glVertexWeightfvEXT',
'glVertexWeightPointerEXT', 'PFNGLVERTEXWEIGHTFEXTPROC',
'PFNGLVERTEXWEIGHTFVEXTPROC', 'PFNGLVERTEXWEIGHTPOINTEREXTPROC',
'GL_NV_light_max_exponent', 'GL_NV_vertex_array_range',
'glFlushVertexArrayRangeNV', 'glVertexArrayRangeNV',
'PFNGLFLUSHVERTEXARRAYRANGENVPROC', 'PFNGLVERTEXARRAYRANGENVPROC',
'GL_NV_register_combiners', 'glCombinerParameterfvNV',
'glCombinerParameterfNV', 'glCombinerParameterivNV', 'glCombinerParameteriNV',
'glCombinerInputNV', 'glCombinerOutputNV', 'glFinalCombinerInputNV',
'glGetCombinerInputParameterfvNV', 'glGetCombinerInputParameterivNV',
'glGetCombinerOutputParameterfvNV', 'glGetCombinerOutputParameterivNV',
'glGetFinalCombinerInputParameterfvNV',
'glGetFinalCombinerInputParameterivNV', 'PFNGLCOMBINERPARAMETERFVNVPROC',
'PFNGLCOMBINERPARAMETERFNVPROC', 'PFNGLCOMBINERPARAMETERIVNVPROC',
'PFNGLCOMBINERPARAMETERINVPROC', 'PFNGLCOMBINERINPUTNVPROC',
'PFNGLCOMBINEROUTPUTNVPROC', 'PFNGLFINALCOMBINERINPUTNVPROC',
'PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC',
'PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC',
'PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC',
'PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC',
'PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC',
'PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC', 'GL_NV_fog_distance',
'GL_NV_texgen_emboss', 'GL_NV_blend_square', 'GL_NV_texture_env_combine4',
'GL_MESA_resize_buffers', 'glResizeBuffersMESA', 'PFNGLRESIZEBUFFERSMESAPROC',
'GL_MESA_window_pos', 'glWindowPos2dMESA', 'glWindowPos2dvMESA',
'glWindowPos2fMESA', 'glWindowPos2fvMESA', 'glWindowPos2iMESA',
'glWindowPos2ivMESA', 'glWindowPos2sMESA', 'glWindowPos2svMESA',
'glWindowPos3dMESA', 'glWindowPos3dvMESA', 'glWindowPos3fMESA',
'glWindowPos3fvMESA', 'glWindowPos3iMESA', 'glWindowPos3ivMESA',
'glWindowPos3sMESA', 'glWindowPos3svMESA', 'glWindowPos4dMESA',
'glWindowPos4dvMESA', 'glWindowPos4fMESA', 'glWindowPos4fvMESA',
'glWindowPos4iMESA', 'glWindowPos4ivMESA', 'glWindowPos4sMESA',
'glWindowPos4svMESA', 'PFNGLWINDOWPOS2DMESAPROC', 'PFNGLWINDOWPOS2DVMESAPROC',
'PFNGLWINDOWPOS2FMESAPROC', 'PFNGLWINDOWPOS2FVMESAPROC',
'PFNGLWINDOWPOS2IMESAPROC', 'PFNGLWINDOWPOS2IVMESAPROC',
'PFNGLWINDOWPOS2SMESAPROC', 'PFNGLWINDOWPOS2SVMESAPROC',
'PFNGLWINDOWPOS3DMESAPROC', 'PFNGLWINDOWPOS3DVMESAPROC',
'PFNGLWINDOWPOS3FMESAPROC', 'PFNGLWINDOWPOS3FVMESAPROC',
'PFNGLWINDOWPOS3IMESAPROC', 'PFNGLWINDOWPOS3IVMESAPROC',
'PFNGLWINDOWPOS3SMESAPROC', 'PFNGLWINDOWPOS3SVMESAPROC',
'PFNGLWINDOWPOS4DMESAPROC', 'PFNGLWINDOWPOS4DVMESAPROC',
'PFNGLWINDOWPOS4FMESAPROC', 'PFNGLWINDOWPOS4FVMESAPROC',
'PFNGLWINDOWPOS4IMESAPROC', 'PFNGLWINDOWPOS4IVMESAPROC',
'PFNGLWINDOWPOS4SMESAPROC', 'PFNGLWINDOWPOS4SVMESAPROC',
'GL_EXT_texture_compression_s3tc', 'GL_IBM_cull_vertex',
'GL_IBM_multimode_draw_arrays', 'glMultiModeDrawArraysIBM',
'glMultiModeDrawElementsIBM', 'PFNGLMULTIMODEDRAWARRAYSIBMPROC',
'PFNGLMULTIMODEDRAWELEMENTSIBMPROC', 'GL_IBM_vertex_array_lists',
'glColorPointerListIBM', 'glSecondaryColorPointerListIBM',
'glEdgeFlagPointerListIBM', 'glFogCoordPointerListIBM',
'glIndexPointerListIBM', 'glNormalPointerListIBM', 'glTexCoordPointerListIBM',
'glVertexPointerListIBM', 'PFNGLCOLORPOINTERLISTIBMPROC',
'PFNGLSECONDARYCOLORPOINTERLISTIBMPROC', 'PFNGLEDGEFLAGPOINTERLISTIBMPROC',
'PFNGLFOGCOORDPOINTERLISTIBMPROC', 'PFNGLINDEXPOINTERLISTIBMPROC',
'PFNGLNORMALPOINTERLISTIBMPROC', 'PFNGLTEXCOORDPOINTERLISTIBMPROC',
'PFNGLVERTEXPOINTERLISTIBMPROC', 'GL_SGIX_subsample', 'GL_SGIX_ycrcba',
'GL_SGIX_ycrcb_subsample', 'GL_SGIX_depth_pass_instrument',
'GL_3DFX_texture_compression_FXT1', 'GL_3DFX_multisample', 'GL_3DFX_tbuffer',
'glTbufferMask3DFX', 'PFNGLTBUFFERMASK3DFXPROC', 'GL_EXT_multisample',
'glSampleMaskEXT', 'glSamplePatternEXT', 'PFNGLSAMPLEMASKEXTPROC',
'PFNGLSAMPLEPATTERNEXTPROC', 'GL_SGIX_vertex_preclip',
'GL_SGIX_convolution_accuracy', 'GL_SGIX_resample',
'GL_SGIS_point_line_texgen', 'GL_SGIS_texture_color_mask',
'glTextureColorMaskSGIS', 'PFNGLTEXTURECOLORMASKSGISPROC',
'GL_SGIX_igloo_interface', 'glIglooInterfaceSGIX',
'PFNGLIGLOOINTERFACESGIXPROC', 'GL_EXT_texture_env_dot3',
'GL_ATI_texture_mirror_once', 'GL_NV_fence', 'glDeleteFencesNV',
'glGenFencesNV', 'glIsFenceNV', 'glTestFenceNV', 'glGetFenceivNV',
'glFinishFenceNV', 'glSetFenceNV', 'PFNGLDELETEFENCESNVPROC',
'PFNGLGENFENCESNVPROC', 'PFNGLISFENCENVPROC', 'PFNGLTESTFENCENVPROC',
'PFNGLGETFENCEIVNVPROC', 'PFNGLFINISHFENCENVPROC', 'PFNGLSETFENCENVPROC',
'GL_NV_evaluators', 'glMapControlPointsNV', 'glMapParameterivNV',
'glMapParameterfvNV', 'glGetMapControlPointsNV', 'glGetMapParameterivNV',
'glGetMapParameterfvNV', 'glGetMapAttribParameterivNV',
'glGetMapAttribParameterfvNV', 'glEvalMapsNV', 'PFNGLMAPCONTROLPOINTSNVPROC',
'PFNGLMAPPARAMETERIVNVPROC', 'PFNGLMAPPARAMETERFVNVPROC',
'PFNGLGETMAPCONTROLPOINTSNVPROC', 'PFNGLGETMAPPARAMETERIVNVPROC',
'PFNGLGETMAPPARAMETERFVNVPROC', 'PFNGLGETMAPATTRIBPARAMETERIVNVPROC',
'PFNGLGETMAPATTRIBPARAMETERFVNVPROC', 'PFNGLEVALMAPSNVPROC',
'GL_NV_packed_depth_stencil', 'GL_NV_register_combiners2',
'glCombinerStageParameterfvNV', 'glGetCombinerStageParameterfvNV',
'PFNGLCOMBINERSTAGEPARAMETERFVNVPROC',
'PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC', 'GL_NV_texture_compression_vtc',
'GL_NV_texture_rectangle', 'GL_NV_texture_shader', 'GL_NV_texture_shader2',
'GL_NV_vertex_array_range2', 'GL_NV_vertex_program',
'glAreProgramsResidentNV', 'glBindProgramNV', 'glDeleteProgramsNV',
'glExecuteProgramNV', 'glGenProgramsNV', 'glGetProgramParameterdvNV',
'glGetProgramParameterfvNV', 'glGetProgramivNV', 'glGetProgramStringNV',
'glGetTrackMatrixivNV', 'glGetVertexAttribdvNV', 'glGetVertexAttribfvNV',
'glGetVertexAttribivNV', 'glGetVertexAttribPointervNV', 'glIsProgramNV',
'glLoadProgramNV', 'glProgramParameter4dNV', 'glProgramParameter4dvNV',
'glProgramParameter4fNV', 'glProgramParameter4fvNV',
'glProgramParameters4dvNV', 'glProgramParameters4fvNV',
'glRequestResidentProgramsNV', 'glTrackMatrixNV', 'glVertexAttribPointerNV',
'glVertexAttrib1dNV', 'glVertexAttrib1dvNV', 'glVertexAttrib1fNV',
'glVertexAttrib1fvNV', 'glVertexAttrib1sNV', 'glVertexAttrib1svNV',
'glVertexAttrib2dNV', 'glVertexAttrib2dvNV', 'glVertexAttrib2fNV',
'glVertexAttrib2fvNV', 'glVertexAttrib2sNV', 'glVertexAttrib2svNV',
'glVertexAttrib3dNV', 'glVertexAttrib3dvNV', 'glVertexAttrib3fNV',
'glVertexAttrib3fvNV', 'glVertexAttrib3sNV', 'glVertexAttrib3svNV',
'glVertexAttrib4dNV', 'glVertexAttrib4dvNV', 'glVertexAttrib4fNV',
'glVertexAttrib4fvNV', 'glVertexAttrib4sNV', 'glVertexAttrib4svNV',
'glVertexAttrib4ubNV', 'glVertexAttrib4ubvNV', 'glVertexAttribs1dvNV',
'glVertexAttribs1fvNV', 'glVertexAttribs1svNV', 'glVertexAttribs2dvNV',
'glVertexAttribs2fvNV', 'glVertexAttribs2svNV', 'glVertexAttribs3dvNV',
'glVertexAttribs3fvNV', 'glVertexAttribs3svNV', 'glVertexAttribs4dvNV',
'glVertexAttribs4fvNV', 'glVertexAttribs4svNV', 'glVertexAttribs4ubvNV',
'PFNGLAREPROGRAMSRESIDENTNVPROC', 'PFNGLBINDPROGRAMNVPROC',
'PFNGLDELETEPROGRAMSNVPROC', 'PFNGLEXECUTEPROGRAMNVPROC',
'PFNGLGENPROGRAMSNVPROC', 'PFNGLGETPROGRAMPARAMETERDVNVPROC',
'PFNGLGETPROGRAMPARAMETERFVNVPROC', 'PFNGLGETPROGRAMIVNVPROC',
'PFNGLGETPROGRAMSTRINGNVPROC', 'PFNGLGETTRACKMATRIXIVNVPROC',
'PFNGLGETVERTEXATTRIBDVNVPROC', 'PFNGLGETVERTEXATTRIBFVNVPROC',
'PFNGLGETVERTEXATTRIBIVNVPROC', 'PFNGLGETVERTEXATTRIBPOINTERVNVPROC',
'PFNGLISPROGRAMNVPROC', 'PFNGLLOADPROGRAMNVPROC',
'PFNGLPROGRAMPARAMETER4DNVPROC', 'PFNGLPROGRAMPARAMETER4DVNVPROC',
'PFNGLPROGRAMPARAMETER4FNVPROC', 'PFNGLPROGRAMPARAMETER4FVNVPROC',
'PFNGLPROGRAMPARAMETERS4DVNVPROC', 'PFNGLPROGRAMPARAMETERS4FVNVPROC',
'PFNGLREQUESTRESIDENTPROGRAMSNVPROC', 'PFNGLTRACKMATRIXNVPROC',
'PFNGLVERTEXATTRIBPOINTERNVPROC', 'PFNGLVERTEXATTRIB1DNVPROC',
'PFNGLVERTEXATTRIB1DVNVPROC', 'PFNGLVERTEXATTRIB1FNVPROC',
'PFNGLVERTEXATTRIB1FVNVPROC', 'PFNGLVERTEXATTRIB1SNVPROC',
'PFNGLVERTEXATTRIB1SVNVPROC', 'PFNGLVERTEXATTRIB2DNVPROC',
'PFNGLVERTEXATTRIB2DVNVPROC', 'PFNGLVERTEXATTRIB2FNVPROC',
'PFNGLVERTEXATTRIB2FVNVPROC', 'PFNGLVERTEXATTRIB2SNVPROC',
'PFNGLVERTEXATTRIB2SVNVPROC', 'PFNGLVERTEXATTRIB3DNVPROC',
'PFNGLVERTEXATTRIB3DVNVPROC', 'PFNGLVERTEXATTRIB3FNVPROC',
'PFNGLVERTEXATTRIB3FVNVPROC', 'PFNGLVERTEXATTRIB3SNVPROC',
'PFNGLVERTEXATTRIB3SVNVPROC', 'PFNGLVERTEXATTRIB4DNVPROC',
'PFNGLVERTEXATTRIB4DVNVPROC', 'PFNGLVERTEXATTRIB4FNVPROC',
'PFNGLVERTEXATTRIB4FVNVPROC', 'PFNGLVERTEXATTRIB4SNVPROC',
'PFNGLVERTEXATTRIB4SVNVPROC', 'PFNGLVERTEXATTRIB4UBNVPROC',
'PFNGLVERTEXATTRIB4UBVNVPROC', 'PFNGLVERTEXATTRIBS1DVNVPROC',
'PFNGLVERTEXATTRIBS1FVNVPROC', 'PFNGLVERTEXATTRIBS1SVNVPROC',
'PFNGLVERTEXATTRIBS2DVNVPROC', 'PFNGLVERTEXATTRIBS2FVNVPROC',
'PFNGLVERTEXATTRIBS2SVNVPROC', 'PFNGLVERTEXATTRIBS3DVNVPROC',
'PFNGLVERTEXATTRIBS3FVNVPROC', 'PFNGLVERTEXATTRIBS3SVNVPROC',
'PFNGLVERTEXATTRIBS4DVNVPROC', 'PFNGLVERTEXATTRIBS4FVNVPROC',
'PFNGLVERTEXATTRIBS4SVNVPROC', 'PFNGLVERTEXATTRIBS4UBVNVPROC',
'GL_SGIX_texture_coordinate_clamp', 'GL_SGIX_scalebias_hint',
'GL_OML_interlace', 'GL_OML_subsample', 'GL_OML_resample',
'GL_NV_copy_depth_to_color', 'GL_ATI_envmap_bumpmap',
'glTexBumpParameterivATI', 'glTexBumpParameterfvATI',
'glGetTexBumpParameterivATI', 'glGetTexBumpParameterfvATI',
'PFNGLTEXBUMPPARAMETERIVATIPROC', 'PFNGLTEXBUMPPARAMETERFVATIPROC',
'PFNGLGETTEXBUMPPARAMETERIVATIPROC', 'PFNGLGETTEXBUMPPARAMETERFVATIPROC',
'GL_ATI_fragment_shader', 'glGenFragmentShadersATI',
'glBindFragmentShaderATI', 'glDeleteFragmentShaderATI',
'glBeginFragmentShaderATI', 'glEndFragmentShaderATI', 'glPassTexCoordATI',
'glSampleMapATI', 'glColorFragmentOp1ATI', 'glColorFragmentOp2ATI',
'glColorFragmentOp3ATI', 'glAlphaFragmentOp1ATI', 'glAlphaFragmentOp2ATI',
'glAlphaFragmentOp3ATI', 'glSetFragmentShaderConstantATI',
'PFNGLGENFRAGMENTSHADERSATIPROC', 'PFNGLBINDFRAGMENTSHADERATIPROC',
'PFNGLDELETEFRAGMENTSHADERATIPROC', 'PFNGLBEGINFRAGMENTSHADERATIPROC',
'PFNGLENDFRAGMENTSHADERATIPROC', 'PFNGLPASSTEXCOORDATIPROC',
'PFNGLSAMPLEMAPATIPROC', 'PFNGLCOLORFRAGMENTOP1ATIPROC',
'PFNGLCOLORFRAGMENTOP2ATIPROC', 'PFNGLCOLORFRAGMENTOP3ATIPROC',
'PFNGLALPHAFRAGMENTOP1ATIPROC', 'PFNGLALPHAFRAGMENTOP2ATIPROC',
'PFNGLALPHAFRAGMENTOP3ATIPROC', 'PFNGLSETFRAGMENTSHADERCONSTANTATIPROC',
'GL_ATI_pn_triangles', 'glPNTrianglesiATI', 'glPNTrianglesfATI',
'PFNGLPNTRIANGLESIATIPROC', 'PFNGLPNTRIANGLESFATIPROC',
'GL_ATI_vertex_array_object', 'glNewObjectBufferATI', 'glIsObjectBufferATI',
'glUpdateObjectBufferATI', 'glGetObjectBufferfvATI', 'glGetObjectBufferivATI',
'glFreeObjectBufferATI', 'glArrayObjectATI', 'glGetArrayObjectfvATI',
'glGetArrayObjectivATI', 'glVariantArrayObjectATI',
'glGetVariantArrayObjectfvATI', 'glGetVariantArrayObjectivATI',
'PFNGLNEWOBJECTBUFFERATIPROC', 'PFNGLISOBJECTBUFFERATIPROC',
'PFNGLUPDATEOBJECTBUFFERATIPROC', 'PFNGLGETOBJECTBUFFERFVATIPROC',
'PFNGLGETOBJECTBUFFERIVATIPROC', 'PFNGLFREEOBJECTBUFFERATIPROC',
'PFNGLARRAYOBJECTATIPROC', 'PFNGLGETARRAYOBJECTFVATIPROC',
'PFNGLGETARRAYOBJECTIVATIPROC', 'PFNGLVARIANTARRAYOBJECTATIPROC',
'PFNGLGETVARIANTARRAYOBJECTFVATIPROC', 'PFNGLGETVARIANTARRAYOBJECTIVATIPROC',
'GL_EXT_vertex_shader', 'glBeginVertexShaderEXT', 'glEndVertexShaderEXT',
'glBindVertexShaderEXT', 'glGenVertexShadersEXT', 'glDeleteVertexShaderEXT',
'glShaderOp1EXT', 'glShaderOp2EXT', 'glShaderOp3EXT', 'glSwizzleEXT',
'glWriteMaskEXT', 'glInsertComponentEXT', 'glExtractComponentEXT',
'glGenSymbolsEXT', 'glSetInvariantEXT', 'glSetLocalConstantEXT',
'glVariantbvEXT', 'glVariantsvEXT', 'glVariantivEXT', 'glVariantfvEXT',
'glVariantdvEXT', 'glVariantubvEXT', 'glVariantusvEXT', 'glVariantuivEXT',
'glVariantPointerEXT', 'glEnableVariantClientStateEXT',
'glDisableVariantClientStateEXT', 'glBindLightParameterEXT',
'glBindMaterialParameterEXT', 'glBindTexGenParameterEXT',
'glBindTextureUnitParameterEXT', 'glBindParameterEXT',
'glIsVariantEnabledEXT', 'glGetVariantBooleanvEXT', 'glGetVariantIntegervEXT',
'glGetVariantFloatvEXT', 'glGetVariantPointervEXT',
'glGetInvariantBooleanvEXT', 'glGetInvariantIntegervEXT',
'glGetInvariantFloatvEXT', 'glGetLocalConstantBooleanvEXT',
'glGetLocalConstantIntegervEXT', 'glGetLocalConstantFloatvEXT',
'PFNGLBEGINVERTEXSHADEREXTPROC', 'PFNGLENDVERTEXSHADEREXTPROC',
'PFNGLBINDVERTEXSHADEREXTPROC', 'PFNGLGENVERTEXSHADERSEXTPROC',
'PFNGLDELETEVERTEXSHADEREXTPROC', 'PFNGLSHADEROP1EXTPROC',
'PFNGLSHADEROP2EXTPROC', 'PFNGLSHADEROP3EXTPROC', 'PFNGLSWIZZLEEXTPROC',
'PFNGLWRITEMASKEXTPROC', 'PFNGLINSERTCOMPONENTEXTPROC',
'PFNGLEXTRACTCOMPONENTEXTPROC', 'PFNGLGENSYMBOLSEXTPROC',
'PFNGLSETINVARIANTEXTPROC', 'PFNGLSETLOCALCONSTANTEXTPROC',
'PFNGLVARIANTBVEXTPROC', 'PFNGLVARIANTSVEXTPROC', 'PFNGLVARIANTIVEXTPROC',
'PFNGLVARIANTFVEXTPROC', 'PFNGLVARIANTDVEXTPROC', 'PFNGLVARIANTUBVEXTPROC',
'PFNGLVARIANTUSVEXTPROC', 'PFNGLVARIANTUIVEXTPROC',
'PFNGLVARIANTPOINTEREXTPROC', 'PFNGLENABLEVARIANTCLIENTSTATEEXTPROC',
'PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC', 'PFNGLBINDLIGHTPARAMETEREXTPROC',
'PFNGLBINDMATERIALPARAMETEREXTPROC', 'PFNGLBINDTEXGENPARAMETEREXTPROC',
'PFNGLBINDTEXTUREUNITPARAMETEREXTPROC', 'PFNGLBINDPARAMETEREXTPROC',
'PFNGLISVARIANTENABLEDEXTPROC', 'PFNGLGETVARIANTBOOLEANVEXTPROC',
'PFNGLGETVARIANTINTEGERVEXTPROC', 'PFNGLGETVARIANTFLOATVEXTPROC',
'PFNGLGETVARIANTPOINTERVEXTPROC', 'PFNGLGETINVARIANTBOOLEANVEXTPROC',
'PFNGLGETINVARIANTINTEGERVEXTPROC', 'PFNGLGETINVARIANTFLOATVEXTPROC',
'PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC',
'PFNGLGETLOCALCONSTANTINTEGERVEXTPROC', 'PFNGLGETLOCALCONSTANTFLOATVEXTPROC',
'GL_ATI_vertex_streams', 'glVertexStream1sATI', 'glVertexStream1svATI',
'glVertexStream1iATI', 'glVertexStream1ivATI', 'glVertexStream1fATI',
'glVertexStream1fvATI', 'glVertexStream1dATI', 'glVertexStream1dvATI',
'glVertexStream2sATI', 'glVertexStream2svATI', 'glVertexStream2iATI',
'glVertexStream2ivATI', 'glVertexStream2fATI', 'glVertexStream2fvATI',
'glVertexStream2dATI', 'glVertexStream2dvATI', 'glVertexStream3sATI',
'glVertexStream3svATI', 'glVertexStream3iATI', 'glVertexStream3ivATI',
'glVertexStream3fATI', 'glVertexStream3fvATI', 'glVertexStream3dATI',
'glVertexStream3dvATI', 'glVertexStream4sATI', 'glVertexStream4svATI',
'glVertexStream4iATI', 'glVertexStream4ivATI', 'glVertexStream4fATI',
'glVertexStream4fvATI', 'glVertexStream4dATI', 'glVertexStream4dvATI',
'glNormalStream3bATI', 'glNormalStream3bvATI', 'glNormalStream3sATI',
'glNormalStream3svATI', 'glNormalStream3iATI', 'glNormalStream3ivATI',
'glNormalStream3fATI', 'glNormalStream3fvATI', 'glNormalStream3dATI',
'glNormalStream3dvATI', 'glClientActiveVertexStreamATI',
'glVertexBlendEnviATI', 'glVertexBlendEnvfATI', 'PFNGLVERTEXSTREAM1SATIPROC',
'PFNGLVERTEXSTREAM1SVATIPROC', 'PFNGLVERTEXSTREAM1IATIPROC',
'PFNGLVERTEXSTREAM1IVATIPROC', 'PFNGLVERTEXSTREAM1FATIPROC',
'PFNGLVERTEXSTREAM1FVATIPROC', 'PFNGLVERTEXSTREAM1DATIPROC',
'PFNGLVERTEXSTREAM1DVATIPROC', 'PFNGLVERTEXSTREAM2SATIPROC',
'PFNGLVERTEXSTREAM2SVATIPROC', 'PFNGLVERTEXSTREAM2IATIPROC',
'PFNGLVERTEXSTREAM2IVATIPROC', 'PFNGLVERTEXSTREAM2FATIPROC',
'PFNGLVERTEXSTREAM2FVATIPROC', 'PFNGLVERTEXSTREAM2DATIPROC',
'PFNGLVERTEXSTREAM2DVATIPROC', 'PFNGLVERTEXSTREAM3SATIPROC',
'PFNGLVERTEXSTREAM3SVATIPROC', 'PFNGLVERTEXSTREAM3IATIPROC',
'PFNGLVERTEXSTREAM3IVATIPROC', 'PFNGLVERTEXSTREAM3FATIPROC',
'PFNGLVERTEXSTREAM3FVATIPROC', 'PFNGLVERTEXSTREAM3DATIPROC',
'PFNGLVERTEXSTREAM3DVATIPROC', 'PFNGLVERTEXSTREAM4SATIPROC',
'PFNGLVERTEXSTREAM4SVATIPROC', 'PFNGLVERTEXSTREAM4IATIPROC',
'PFNGLVERTEXSTREAM4IVATIPROC', 'PFNGLVERTEXSTREAM4FATIPROC',
'PFNGLVERTEXSTREAM4FVATIPROC', 'PFNGLVERTEXSTREAM4DATIPROC',
'PFNGLVERTEXSTREAM4DVATIPROC', 'PFNGLNORMALSTREAM3BATIPROC',
'PFNGLNORMALSTREAM3BVATIPROC', 'PFNGLNORMALSTREAM3SATIPROC',
'PFNGLNORMALSTREAM3SVATIPROC', 'PFNGLNORMALSTREAM3IATIPROC',
'PFNGLNORMALSTREAM3IVATIPROC', 'PFNGLNORMALSTREAM3FATIPROC',
'PFNGLNORMALSTREAM3FVATIPROC', 'PFNGLNORMALSTREAM3DATIPROC',
'PFNGLNORMALSTREAM3DVATIPROC', 'PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC',
'PFNGLVERTEXBLENDENVIATIPROC', 'PFNGLVERTEXBLENDENVFATIPROC',
'GL_ATI_element_array', 'glElementPointerATI', 'glDrawElementArrayATI',
'glDrawRangeElementArrayATI', 'PFNGLELEMENTPOINTERATIPROC',
'PFNGLDRAWELEMENTARRAYATIPROC', 'PFNGLDRAWRANGEELEMENTARRAYATIPROC',
'GL_SUN_mesh_array', 'glDrawMeshArraysSUN', 'PFNGLDRAWMESHARRAYSSUNPROC',
'GL_SUN_slice_accum', 'GL_NV_multisample_filter_hint', 'GL_NV_depth_clamp',
'GL_NV_occlusion_query', 'glGenOcclusionQueriesNV',
'glDeleteOcclusionQueriesNV', 'glIsOcclusionQueryNV',
'glBeginOcclusionQueryNV', 'glEndOcclusionQueryNV', 'glGetOcclusionQueryivNV',
'glGetOcclusionQueryuivNV', 'PFNGLGENOCCLUSIONQUERIESNVPROC',
'PFNGLDELETEOCCLUSIONQUERIESNVPROC', 'PFNGLISOCCLUSIONQUERYNVPROC',
'PFNGLBEGINOCCLUSIONQUERYNVPROC', 'PFNGLENDOCCLUSIONQUERYNVPROC',
'PFNGLGETOCCLUSIONQUERYIVNVPROC', 'PFNGLGETOCCLUSIONQUERYUIVNVPROC',
'GL_NV_point_sprite', 'glPointParameteriNV', 'glPointParameterivNV',
'PFNGLPOINTPARAMETERINVPROC', 'PFNGLPOINTPARAMETERIVNVPROC',
'GL_NV_texture_shader3', 'GL_NV_vertex_program1_1', 'GL_EXT_shadow_funcs',
'GL_EXT_stencil_two_side', 'glActiveStencilFaceEXT',
'PFNGLACTIVESTENCILFACEEXTPROC', 'GL_ATI_text_fragment_shader',
'GL_APPLE_client_storage', 'GL_APPLE_element_array', 'glElementPointerAPPLE',
'glDrawElementArrayAPPLE', 'glDrawRangeElementArrayAPPLE',
'glMultiDrawElementArrayAPPLE', 'glMultiDrawRangeElementArrayAPPLE',
'PFNGLELEMENTPOINTERAPPLEPROC', 'PFNGLDRAWELEMENTARRAYAPPLEPROC',
'PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC', 'PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC',
'PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC', 'GL_APPLE_fence',
'glGenFencesAPPLE', 'glDeleteFencesAPPLE', 'glSetFenceAPPLE',
'glIsFenceAPPLE', 'glTestFenceAPPLE', 'glFinishFenceAPPLE',
'glTestObjectAPPLE', 'glFinishObjectAPPLE', 'PFNGLGENFENCESAPPLEPROC',
'PFNGLDELETEFENCESAPPLEPROC', 'PFNGLSETFENCEAPPLEPROC',
'PFNGLISFENCEAPPLEPROC', 'PFNGLTESTFENCEAPPLEPROC',
'PFNGLFINISHFENCEAPPLEPROC', 'PFNGLTESTOBJECTAPPLEPROC',
'PFNGLFINISHOBJECTAPPLEPROC', 'GL_APPLE_vertex_array_object',
'glBindVertexArrayAPPLE', 'glDeleteVertexArraysAPPLE',
'glGenVertexArraysAPPLE', 'glIsVertexArrayAPPLE',
'PFNGLBINDVERTEXARRAYAPPLEPROC', 'PFNGLDELETEVERTEXARRAYSAPPLEPROC',
'PFNGLGENVERTEXARRAYSAPPLEPROC', 'PFNGLISVERTEXARRAYAPPLEPROC',
'GL_APPLE_vertex_array_range', 'glVertexArrayRangeAPPLE',
'glFlushVertexArrayRangeAPPLE', 'glVertexArrayParameteriAPPLE',
'PFNGLVERTEXARRAYRANGEAPPLEPROC', 'PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC',
'PFNGLVERTEXARRAYPARAMETERIAPPLEPROC', 'GL_APPLE_ycbcr_422', 'GL_S3_s3tc',
'GL_ATI_draw_buffers', 'glDrawBuffersATI', 'PFNGLDRAWBUFFERSATIPROC',
'GL_ATI_pixel_format_float', 'GL_ATI_texture_env_combine3',
'GL_ATI_texture_float', 'GL_NV_float_buffer', 'GL_NV_fragment_program',
'glProgramNamedParameter4fNV', 'glProgramNamedParameter4dNV',
'glProgramNamedParameter4fvNV', 'glProgramNamedParameter4dvNV',
'glGetProgramNamedParameterfvNV', 'glGetProgramNamedParameterdvNV',
'PFNGLPROGRAMNAMEDPARAMETER4FNVPROC', 'PFNGLPROGRAMNAMEDPARAMETER4DNVPROC',
'PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC', 'PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC',
'PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC',
'PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC', 'GL_NV_half_float', 'glVertex2hNV',
'glVertex2hvNV', 'glVertex3hNV', 'glVertex3hvNV', 'glVertex4hNV',
'glVertex4hvNV', 'glNormal3hNV', 'glNormal3hvNV', 'glColor3hNV',
'glColor3hvNV', 'glColor4hNV', 'glColor4hvNV', 'glTexCoord1hNV',
'glTexCoord1hvNV', 'glTexCoord2hNV', 'glTexCoord2hvNV', 'glTexCoord3hNV',
'glTexCoord3hvNV', 'glTexCoord4hNV', 'glTexCoord4hvNV', 'glMultiTexCoord1hNV',
'glMultiTexCoord1hvNV', 'glMultiTexCoord2hNV', 'glMultiTexCoord2hvNV',
'glMultiTexCoord3hNV', 'glMultiTexCoord3hvNV', 'glMultiTexCoord4hNV',
'glMultiTexCoord4hvNV', 'glFogCoordhNV', 'glFogCoordhvNV',
'glSecondaryColor3hNV', 'glSecondaryColor3hvNV', 'glVertexWeighthNV',
'glVertexWeighthvNV', 'glVertexAttrib1hNV', 'glVertexAttrib1hvNV',
'glVertexAttrib2hNV', 'glVertexAttrib2hvNV', 'glVertexAttrib3hNV',
'glVertexAttrib3hvNV', 'glVertexAttrib4hNV', 'glVertexAttrib4hvNV',
'glVertexAttribs1hvNV', 'glVertexAttribs2hvNV', 'glVertexAttribs3hvNV',
'glVertexAttribs4hvNV', 'PFNGLVERTEX2HNVPROC', 'PFNGLVERTEX2HVNVPROC',
'PFNGLVERTEX3HNVPROC', 'PFNGLVERTEX3HVNVPROC', 'PFNGLVERTEX4HNVPROC',
'PFNGLVERTEX4HVNVPROC', 'PFNGLNORMAL3HNVPROC', 'PFNGLNORMAL3HVNVPROC',
'PFNGLCOLOR3HNVPROC', 'PFNGLCOLOR3HVNVPROC', 'PFNGLCOLOR4HNVPROC',
'PFNGLCOLOR4HVNVPROC', 'PFNGLTEXCOORD1HNVPROC', 'PFNGLTEXCOORD1HVNVPROC',
'PFNGLTEXCOORD2HNVPROC', 'PFNGLTEXCOORD2HVNVPROC', 'PFNGLTEXCOORD3HNVPROC',
'PFNGLTEXCOORD3HVNVPROC', 'PFNGLTEXCOORD4HNVPROC', 'PFNGLTEXCOORD4HVNVPROC',
'PFNGLMULTITEXCOORD1HNVPROC', 'PFNGLMULTITEXCOORD1HVNVPROC',
'PFNGLMULTITEXCOORD2HNVPROC', 'PFNGLMULTITEXCOORD2HVNVPROC',
'PFNGLMULTITEXCOORD3HNVPROC', 'PFNGLMULTITEXCOORD3HVNVPROC',
'PFNGLMULTITEXCOORD4HNVPROC', 'PFNGLMULTITEXCOORD4HVNVPROC',
'PFNGLFOGCOORDHNVPROC', 'PFNGLFOGCOORDHVNVPROC',
'PFNGLSECONDARYCOLOR3HNVPROC', 'PFNGLSECONDARYCOLOR3HVNVPROC',
'PFNGLVERTEXWEIGHTHNVPROC', 'PFNGLVERTEXWEIGHTHVNVPROC',
'PFNGLVERTEXATTRIB1HNVPROC', 'PFNGLVERTEXATTRIB1HVNVPROC',
'PFNGLVERTEXATTRIB2HNVPROC', 'PFNGLVERTEXATTRIB2HVNVPROC',
'PFNGLVERTEXATTRIB3HNVPROC', 'PFNGLVERTEXATTRIB3HVNVPROC',
'PFNGLVERTEXATTRIB4HNVPROC', 'PFNGLVERTEXATTRIB4HVNVPROC',
'PFNGLVERTEXATTRIBS1HVNVPROC', 'PFNGLVERTEXATTRIBS2HVNVPROC',
'PFNGLVERTEXATTRIBS3HVNVPROC', 'PFNGLVERTEXATTRIBS4HVNVPROC',
'GL_NV_pixel_data_range', 'glPixelDataRangeNV', 'glFlushPixelDataRangeNV',
'PFNGLPIXELDATARANGENVPROC', 'PFNGLFLUSHPIXELDATARANGENVPROC',
'GL_NV_primitive_restart', 'glPrimitiveRestartNV',
'glPrimitiveRestartIndexNV', 'PFNGLPRIMITIVERESTARTNVPROC',
'PFNGLPRIMITIVERESTARTINDEXNVPROC', 'GL_NV_texture_expand_normal',
'GL_NV_vertex_program2', 'GL_ATI_map_object_buffer', 'glMapObjectBufferATI',
'glUnmapObjectBufferATI', 'PFNGLMAPOBJECTBUFFERATIPROC',
'PFNGLUNMAPOBJECTBUFFERATIPROC', 'GL_ATI_separate_stencil',
'glStencilOpSeparateATI', 'glStencilFuncSeparateATI',
'PFNGLSTENCILOPSEPARATEATIPROC', 'PFNGLSTENCILFUNCSEPARATEATIPROC',
'GL_ATI_vertex_attrib_array_object', 'glVertexAttribArrayObjectATI',
'glGetVertexAttribArrayObjectfvATI', 'glGetVertexAttribArrayObjectivATI',
'PFNGLVERTEXATTRIBARRAYOBJECTATIPROC',
'PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC',
'PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC', 'GL_OES_read_format',
'GL_EXT_depth_bounds_test', 'glDepthBoundsEXT', 'PFNGLDEPTHBOUNDSEXTPROC',
'GL_EXT_texture_mirror_clamp', 'GL_EXT_blend_equation_separate',
'glBlendEquationSeparateEXT', 'PFNGLBLENDEQUATIONSEPARATEEXTPROC',
'GL_MESA_pack_invert', 'GL_MESA_ycbcr_texture', 'GL_EXT_pixel_buffer_object',
'GL_NV_fragment_program_option', 'GL_NV_fragment_program2',
'GL_NV_vertex_program2_option', 'GL_NV_vertex_program3',
'GL_EXT_framebuffer_object', 'glIsRenderbufferEXT', 'glBindRenderbufferEXT',
'glDeleteRenderbuffersEXT', 'glGenRenderbuffersEXT',
'glRenderbufferStorageEXT', 'glGetRenderbufferParameterivEXT',
'glIsFramebufferEXT', 'glBindFramebufferEXT', 'glDeleteFramebuffersEXT',
'glGenFramebuffersEXT', 'glCheckFramebufferStatusEXT',
'glFramebufferTexture1DEXT', 'glFramebufferTexture2DEXT',
'glFramebufferTexture3DEXT', 'glFramebufferRenderbufferEXT',
'glGetFramebufferAttachmentParameterivEXT', 'glGenerateMipmapEXT',
'PFNGLISRENDERBUFFEREXTPROC', 'PFNGLBINDRENDERBUFFEREXTPROC',
'PFNGLDELETERENDERBUFFERSEXTPROC', 'PFNGLGENRENDERBUFFERSEXTPROC',
'PFNGLRENDERBUFFERSTORAGEEXTPROC', 'PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC',
'PFNGLISFRAMEBUFFEREXTPROC', 'PFNGLBINDFRAMEBUFFEREXTPROC',
'PFNGLDELETEFRAMEBUFFERSEXTPROC', 'PFNGLGENFRAMEBUFFERSEXTPROC',
'PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC', 'PFNGLFRAMEBUFFERTEXTURE1DEXTPROC',
'PFNGLFRAMEBUFFERTEXTURE2DEXTPROC', 'PFNGLFRAMEBUFFERTEXTURE3DEXTPROC',
'PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC',
'PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC',
'PFNGLGENERATEMIPMAPEXTPROC', 'GL_GREMEDY_string_marker',
'glStringMarkerGREMEDY', 'PFNGLSTRINGMARKERGREMEDYPROC', 'GL_EXT_Cg_shader',
'GL_EXT_timer_query', 'glGetQueryObjecti64vEXT', 'glGetQueryObjectui64vEXT',
'PFNGLGETQUERYOBJECTI64VEXTPROC', 'PFNGLGETQUERYOBJECTUI64VEXTPROC',
'GL_EXT_texture_buffer_object', 'glTexBufferEXT', 'PFNGLTEXBUFFEREXTPROC',
'GL_NV_transform_feedback', 'glBeginTransformFeedbackNV',
'glEndTransformFeedbackNV', 'glTransformFeedbackAttribsNV',
'glBindBufferRangeNV', 'glBindBufferOffsetNV', 'glBindBufferBaseNV',
'glTransformFeedbackVaryingsNV', 'glActiveVaryingNV',
'glGetVaryingLocationNV', 'glGetActiveVaryingNV',
'glGetTransformFeedbackVaryingNV', 'PFNGLBEGINTRANSFORMFEEDBACKNVPROC',
'PFNGLENDTRANSFORMFEEDBACKNVPROC', 'PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC',
'PFNGLBINDBUFFERRANGENVPROC', 'PFNGLBINDBUFFEROFFSETNVPROC',
'PFNGLBINDBUFFERBASENVPROC', 'PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC',
'PFNGLACTIVEVARYINGNVPROC', 'PFNGLGETVARYINGLOCATIONNVPROC',
'PFNGLGETACTIVEVARYINGNVPROC', 'PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC',
'GL_NV_depth_buffer_float', 'glDepthRangedNV', 'glClearDepthdNV',
'glDepthBoundsdNV', 'PFNGLDEPTHRANGEDNVPROC', 'PFNGLCLEARDEPTHDNVPROC',
'PFNGLDEPTHBOUNDSDNVPROC', 'GL_EXT_texture_compression_latc',
'GL_EXT_framebuffer_sRGB', 'GL_EXT_texture_shared_exponent',
'GL_EXT_packed_float', 'GL_EXT_texture_array', 'GL_EXT_draw_buffers2',
'glColorMaskIndexedEXT', 'glGetBooleanIndexedvEXT', 'glGetIntegerIndexedvEXT',
'glEnableIndexedEXT', 'glDisableIndexedEXT', 'glIsEnabledIndexedEXT',
'PFNGLCOLORMASKINDEXEDEXTPROC', 'PFNGLGETBOOLEANINDEXEDVEXTPROC',
'PFNGLGETINTEGERINDEXEDVEXTPROC', 'PFNGLENABLEINDEXEDEXTPROC',
'PFNGLDISABLEINDEXEDEXTPROC', 'PFNGLISENABLEDINDEXEDEXTPROC',
'GL_EXT_texture_integer', 'glTexParameterIivEXT', 'glTexParameterIuivEXT',
'glGetTexParameterIivEXT', 'glGetTexParameterIuivEXT', 'glClearColorIiEXT',
'glClearColorIuiEXT', 'PFNGLTEXPARAMETERIIVEXTPROC',
'PFNGLTEXPARAMETERIUIVEXTPROC', 'PFNGLGETTEXPARAMETERIIVEXTPROC',
'PFNGLGETTEXPARAMETERIUIVEXTPROC', 'PFNGLCLEARCOLORIIEXTPROC',
'PFNGLCLEARCOLORIUIEXTPROC', 'GL_EXT_bindable_uniform', 'glUniformBufferEXT',
'glGetUniformBufferSizeEXT', 'glGetUniformOffsetEXT',
'PFNGLUNIFORMBUFFEREXTPROC', 'PFNGLGETUNIFORMBUFFERSIZEEXTPROC',
'PFNGLGETUNIFORMOFFSETEXTPROC', 'GL_EXT_gpu_shader4', 'glGetUniformuivEXT',
'glBindFragDataLocationEXT', 'glGetFragDataLocationEXT', 'glUniform1uiEXT',
'glUniform2uiEXT', 'glUniform3uiEXT', 'glUniform4uiEXT', 'glUniform1uivEXT',
'glUniform2uivEXT', 'glUniform3uivEXT', 'glUniform4uivEXT',
'glVertexAttribI1iEXT', 'glVertexAttribI2iEXT', 'glVertexAttribI3iEXT',
'glVertexAttribI4iEXT', 'glVertexAttribI1uiEXT', 'glVertexAttribI2uiEXT',
'glVertexAttribI3uiEXT', 'glVertexAttribI4uiEXT', 'glVertexAttribI1ivEXT',
'glVertexAttribI2ivEXT', 'glVertexAttribI3ivEXT', 'glVertexAttribI4ivEXT',
'glVertexAttribI1uivEXT', 'glVertexAttribI2uivEXT', 'glVertexAttribI3uivEXT',
'glVertexAttribI4uivEXT', 'glVertexAttribI4bvEXT', 'glVertexAttribI4svEXT',
'glVertexAttribI4ubvEXT', 'glVertexAttribI4usvEXT',
'glVertexAttribIPointerEXT', 'glGetVertexAttribIivEXT',
'glGetVertexAttribIuivEXT', 'PFNGLGETUNIFORMUIVEXTPROC',
'PFNGLBINDFRAGDATALOCATIONEXTPROC', 'PFNGLGETFRAGDATALOCATIONEXTPROC',
'PFNGLUNIFORM1UIEXTPROC', 'PFNGLUNIFORM2UIEXTPROC', 'PFNGLUNIFORM3UIEXTPROC',
'PFNGLUNIFORM4UIEXTPROC', 'PFNGLUNIFORM1UIVEXTPROC',
'PFNGLUNIFORM2UIVEXTPROC', 'PFNGLUNIFORM3UIVEXTPROC',
'PFNGLUNIFORM4UIVEXTPROC', 'PFNGLVERTEXATTRIBI1IEXTPROC',
'PFNGLVERTEXATTRIBI2IEXTPROC', 'PFNGLVERTEXATTRIBI3IEXTPROC',
'PFNGLVERTEXATTRIBI4IEXTPROC', 'PFNGLVERTEXATTRIBI1UIEXTPROC',
'PFNGLVERTEXATTRIBI2UIEXTPROC', 'PFNGLVERTEXATTRIBI3UIEXTPROC',
'PFNGLVERTEXATTRIBI4UIEXTPROC', 'PFNGLVERTEXATTRIBI1IVEXTPROC',
'PFNGLVERTEXATTRIBI2IVEXTPROC', 'PFNGLVERTEXATTRIBI3IVEXTPROC',
'PFNGLVERTEXATTRIBI4IVEXTPROC', 'PFNGLVERTEXATTRIBI1UIVEXTPROC',
'PFNGLVERTEXATTRIBI2UIVEXTPROC', 'PFNGLVERTEXATTRIBI3UIVEXTPROC',
'PFNGLVERTEXATTRIBI4UIVEXTPROC', 'PFNGLVERTEXATTRIBI4BVEXTPROC',
'PFNGLVERTEXATTRIBI4SVEXTPROC', 'PFNGLVERTEXATTRIBI4UBVEXTPROC',
'PFNGLVERTEXATTRIBI4USVEXTPROC', 'PFNGLVERTEXATTRIBIPOINTEREXTPROC',
'PFNGLGETVERTEXATTRIBIIVEXTPROC', 'PFNGLGETVERTEXATTRIBIUIVEXTPROC',
'GL_EXT_geometry_shader4', 'glProgramParameteriEXT',
'glFramebufferTextureEXT', 'glFramebufferTextureLayerEXT',
'glFramebufferTextureFaceEXT', 'PFNGLPROGRAMPARAMETERIEXTPROC',
'PFNGLFRAMEBUFFERTEXTUREEXTPROC', 'PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC',
'PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC', 'GL_NV_geometry_program4',
'glProgramVertexLimitNV', 'PFNGLPROGRAMVERTEXLIMITNVPROC',
'GL_NV_gpu_program4', 'glProgramLocalParameterI4iNV',
'glProgramLocalParameterI4ivNV', 'glProgramLocalParametersI4ivNV',
'glProgramLocalParameterI4uiNV', 'glProgramLocalParameterI4uivNV',
'glProgramLocalParametersI4uivNV', 'glProgramEnvParameterI4iNV',
'glProgramEnvParameterI4ivNV', 'glProgramEnvParametersI4ivNV',
'glProgramEnvParameterI4uiNV', 'glProgramEnvParameterI4uivNV',
'glProgramEnvParametersI4uivNV', 'glGetProgramLocalParameterIivNV',
'glGetProgramLocalParameterIuivNV', 'glGetProgramEnvParameterIivNV',
'glGetProgramEnvParameterIuivNV', 'PFNGLPROGRAMLOCALPARAMETERI4INVPROC',
'PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC',
'PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC',
'PFNGLPROGRAMLOCALPARAMETERI4UINVPROC',
'PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC',
'PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC', 'PFNGLPROGRAMENVPARAMETERI4INVPROC',
'PFNGLPROGRAMENVPARAMETERI4IVNVPROC', 'PFNGLPROGRAMENVPARAMETERSI4IVNVPROC',
'PFNGLPROGRAMENVPARAMETERI4UINVPROC', 'PFNGLPROGRAMENVPARAMETERI4UIVNVPROC',
'PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC',
'PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC',
'PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC',
'PFNGLGETPROGRAMENVPARAMETERIIVNVPROC',
'PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC', 'GL_NV_parameter_buffer_object',
'glProgramBufferParametersfvNV', 'glProgramBufferParametersIivNV',
'glProgramBufferParametersIuivNV', 'PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC',
'PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC',
'PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC', 'GL_EXT_framebuffer_multisample',
'glRenderbufferStorageMultisampleEXT',
'PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC',
'GL_NV_framebuffer_multisample_coverage',
'glRenderbufferStorageMultisampleCoverageNV',
'PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC',
'GL_EXT_framebuffer_blit', 'glBlitFramebufferEXT',
'PFNGLBLITFRAMEBUFFEREXTPROC', 'GL_EXT_draw_instanced',
'glDrawArraysInstancedEXT', 'glDrawElementsInstancedEXT',
'PFNGLDRAWARRAYSINSTANCEDEXTPROC', 'PFNGLDRAWELEMENTSINSTANCEDEXTPROC',
'GL_EXT_texture_compression_rgtc']
# END GENERATED CONTENT (do not edit above this line)




########NEW FILE########
__FILENAME__ = glu
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for /usr/include/GL/glu.h

Generated by tools/gengl.py.
Do not modify this file.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: glu.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

from ctypes import *
from pyglet.gl.lib import link_GLU as _link_function
from pyglet.gl.lib import c_ptrdiff_t

# BEGIN GENERATED CONTENT (do not edit below this line)

# This content is generated by tools/gengl.py.
# Wrapper for /usr/include/GL/glu.h


GLU_EXT_object_space_tess = 1 	# /usr/include/GL/glu.h:58
GLU_EXT_nurbs_tessellator = 1 	# /usr/include/GL/glu.h:59
GLU_FALSE = 0 	# /usr/include/GL/glu.h:62
GLU_TRUE = 1 	# /usr/include/GL/glu.h:63
GLU_VERSION_1_1 = 1 	# /usr/include/GL/glu.h:66
GLU_VERSION_1_2 = 1 	# /usr/include/GL/glu.h:67
GLU_VERSION_1_3 = 1 	# /usr/include/GL/glu.h:68
GLU_VERSION = 100800 	# /usr/include/GL/glu.h:71
GLU_EXTENSIONS = 100801 	# /usr/include/GL/glu.h:72
GLU_INVALID_ENUM = 100900 	# /usr/include/GL/glu.h:75
GLU_INVALID_VALUE = 100901 	# /usr/include/GL/glu.h:76
GLU_OUT_OF_MEMORY = 100902 	# /usr/include/GL/glu.h:77
GLU_INCOMPATIBLE_GL_VERSION = 100903 	# /usr/include/GL/glu.h:78
GLU_INVALID_OPERATION = 100904 	# /usr/include/GL/glu.h:79
GLU_OUTLINE_POLYGON = 100240 	# /usr/include/GL/glu.h:83
GLU_OUTLINE_PATCH = 100241 	# /usr/include/GL/glu.h:84
GLU_NURBS_ERROR = 100103 	# /usr/include/GL/glu.h:87
GLU_ERROR = 100103 	# /usr/include/GL/glu.h:88
GLU_NURBS_BEGIN = 100164 	# /usr/include/GL/glu.h:89
GLU_NURBS_BEGIN_EXT = 100164 	# /usr/include/GL/glu.h:90
GLU_NURBS_VERTEX = 100165 	# /usr/include/GL/glu.h:91
GLU_NURBS_VERTEX_EXT = 100165 	# /usr/include/GL/glu.h:92
GLU_NURBS_NORMAL = 100166 	# /usr/include/GL/glu.h:93
GLU_NURBS_NORMAL_EXT = 100166 	# /usr/include/GL/glu.h:94
GLU_NURBS_COLOR = 100167 	# /usr/include/GL/glu.h:95
GLU_NURBS_COLOR_EXT = 100167 	# /usr/include/GL/glu.h:96
GLU_NURBS_TEXTURE_COORD = 100168 	# /usr/include/GL/glu.h:97
GLU_NURBS_TEX_COORD_EXT = 100168 	# /usr/include/GL/glu.h:98
GLU_NURBS_END = 100169 	# /usr/include/GL/glu.h:99
GLU_NURBS_END_EXT = 100169 	# /usr/include/GL/glu.h:100
GLU_NURBS_BEGIN_DATA = 100170 	# /usr/include/GL/glu.h:101
GLU_NURBS_BEGIN_DATA_EXT = 100170 	# /usr/include/GL/glu.h:102
GLU_NURBS_VERTEX_DATA = 100171 	# /usr/include/GL/glu.h:103
GLU_NURBS_VERTEX_DATA_EXT = 100171 	# /usr/include/GL/glu.h:104
GLU_NURBS_NORMAL_DATA = 100172 	# /usr/include/GL/glu.h:105
GLU_NURBS_NORMAL_DATA_EXT = 100172 	# /usr/include/GL/glu.h:106
GLU_NURBS_COLOR_DATA = 100173 	# /usr/include/GL/glu.h:107
GLU_NURBS_COLOR_DATA_EXT = 100173 	# /usr/include/GL/glu.h:108
GLU_NURBS_TEXTURE_COORD_DATA = 100174 	# /usr/include/GL/glu.h:109
GLU_NURBS_TEX_COORD_DATA_EXT = 100174 	# /usr/include/GL/glu.h:110
GLU_NURBS_END_DATA = 100175 	# /usr/include/GL/glu.h:111
GLU_NURBS_END_DATA_EXT = 100175 	# /usr/include/GL/glu.h:112
GLU_NURBS_ERROR1 = 100251 	# /usr/include/GL/glu.h:115
GLU_NURBS_ERROR2 = 100252 	# /usr/include/GL/glu.h:116
GLU_NURBS_ERROR3 = 100253 	# /usr/include/GL/glu.h:117
GLU_NURBS_ERROR4 = 100254 	# /usr/include/GL/glu.h:118
GLU_NURBS_ERROR5 = 100255 	# /usr/include/GL/glu.h:119
GLU_NURBS_ERROR6 = 100256 	# /usr/include/GL/glu.h:120
GLU_NURBS_ERROR7 = 100257 	# /usr/include/GL/glu.h:121
GLU_NURBS_ERROR8 = 100258 	# /usr/include/GL/glu.h:122
GLU_NURBS_ERROR9 = 100259 	# /usr/include/GL/glu.h:123
GLU_NURBS_ERROR10 = 100260 	# /usr/include/GL/glu.h:124
GLU_NURBS_ERROR11 = 100261 	# /usr/include/GL/glu.h:125
GLU_NURBS_ERROR12 = 100262 	# /usr/include/GL/glu.h:126
GLU_NURBS_ERROR13 = 100263 	# /usr/include/GL/glu.h:127
GLU_NURBS_ERROR14 = 100264 	# /usr/include/GL/glu.h:128
GLU_NURBS_ERROR15 = 100265 	# /usr/include/GL/glu.h:129
GLU_NURBS_ERROR16 = 100266 	# /usr/include/GL/glu.h:130
GLU_NURBS_ERROR17 = 100267 	# /usr/include/GL/glu.h:131
GLU_NURBS_ERROR18 = 100268 	# /usr/include/GL/glu.h:132
GLU_NURBS_ERROR19 = 100269 	# /usr/include/GL/glu.h:133
GLU_NURBS_ERROR20 = 100270 	# /usr/include/GL/glu.h:134
GLU_NURBS_ERROR21 = 100271 	# /usr/include/GL/glu.h:135
GLU_NURBS_ERROR22 = 100272 	# /usr/include/GL/glu.h:136
GLU_NURBS_ERROR23 = 100273 	# /usr/include/GL/glu.h:137
GLU_NURBS_ERROR24 = 100274 	# /usr/include/GL/glu.h:138
GLU_NURBS_ERROR25 = 100275 	# /usr/include/GL/glu.h:139
GLU_NURBS_ERROR26 = 100276 	# /usr/include/GL/glu.h:140
GLU_NURBS_ERROR27 = 100277 	# /usr/include/GL/glu.h:141
GLU_NURBS_ERROR28 = 100278 	# /usr/include/GL/glu.h:142
GLU_NURBS_ERROR29 = 100279 	# /usr/include/GL/glu.h:143
GLU_NURBS_ERROR30 = 100280 	# /usr/include/GL/glu.h:144
GLU_NURBS_ERROR31 = 100281 	# /usr/include/GL/glu.h:145
GLU_NURBS_ERROR32 = 100282 	# /usr/include/GL/glu.h:146
GLU_NURBS_ERROR33 = 100283 	# /usr/include/GL/glu.h:147
GLU_NURBS_ERROR34 = 100284 	# /usr/include/GL/glu.h:148
GLU_NURBS_ERROR35 = 100285 	# /usr/include/GL/glu.h:149
GLU_NURBS_ERROR36 = 100286 	# /usr/include/GL/glu.h:150
GLU_NURBS_ERROR37 = 100287 	# /usr/include/GL/glu.h:151
GLU_AUTO_LOAD_MATRIX = 100200 	# /usr/include/GL/glu.h:154
GLU_CULLING = 100201 	# /usr/include/GL/glu.h:155
GLU_SAMPLING_TOLERANCE = 100203 	# /usr/include/GL/glu.h:156
GLU_DISPLAY_MODE = 100204 	# /usr/include/GL/glu.h:157
GLU_PARAMETRIC_TOLERANCE = 100202 	# /usr/include/GL/glu.h:158
GLU_SAMPLING_METHOD = 100205 	# /usr/include/GL/glu.h:159
GLU_U_STEP = 100206 	# /usr/include/GL/glu.h:160
GLU_V_STEP = 100207 	# /usr/include/GL/glu.h:161
GLU_NURBS_MODE = 100160 	# /usr/include/GL/glu.h:162
GLU_NURBS_MODE_EXT = 100160 	# /usr/include/GL/glu.h:163
GLU_NURBS_TESSELLATOR = 100161 	# /usr/include/GL/glu.h:164
GLU_NURBS_TESSELLATOR_EXT = 100161 	# /usr/include/GL/glu.h:165
GLU_NURBS_RENDERER = 100162 	# /usr/include/GL/glu.h:166
GLU_NURBS_RENDERER_EXT = 100162 	# /usr/include/GL/glu.h:167
GLU_OBJECT_PARAMETRIC_ERROR = 100208 	# /usr/include/GL/glu.h:170
GLU_OBJECT_PARAMETRIC_ERROR_EXT = 100208 	# /usr/include/GL/glu.h:171
GLU_OBJECT_PATH_LENGTH = 100209 	# /usr/include/GL/glu.h:172
GLU_OBJECT_PATH_LENGTH_EXT = 100209 	# /usr/include/GL/glu.h:173
GLU_PATH_LENGTH = 100215 	# /usr/include/GL/glu.h:174
GLU_PARAMETRIC_ERROR = 100216 	# /usr/include/GL/glu.h:175
GLU_DOMAIN_DISTANCE = 100217 	# /usr/include/GL/glu.h:176
GLU_MAP1_TRIM_2 = 100210 	# /usr/include/GL/glu.h:179
GLU_MAP1_TRIM_3 = 100211 	# /usr/include/GL/glu.h:180
GLU_POINT = 100010 	# /usr/include/GL/glu.h:183
GLU_LINE = 100011 	# /usr/include/GL/glu.h:184
GLU_FILL = 100012 	# /usr/include/GL/glu.h:185
GLU_SILHOUETTE = 100013 	# /usr/include/GL/glu.h:186
GLU_SMOOTH = 100000 	# /usr/include/GL/glu.h:192
GLU_FLAT = 100001 	# /usr/include/GL/glu.h:193
GLU_NONE = 100002 	# /usr/include/GL/glu.h:194
GLU_OUTSIDE = 100020 	# /usr/include/GL/glu.h:197
GLU_INSIDE = 100021 	# /usr/include/GL/glu.h:198
GLU_TESS_BEGIN = 100100 	# /usr/include/GL/glu.h:201
GLU_BEGIN = 100100 	# /usr/include/GL/glu.h:202
GLU_TESS_VERTEX = 100101 	# /usr/include/GL/glu.h:203
GLU_VERTEX = 100101 	# /usr/include/GL/glu.h:204
GLU_TESS_END = 100102 	# /usr/include/GL/glu.h:205
GLU_END = 100102 	# /usr/include/GL/glu.h:206
GLU_TESS_ERROR = 100103 	# /usr/include/GL/glu.h:207
GLU_TESS_EDGE_FLAG = 100104 	# /usr/include/GL/glu.h:208
GLU_EDGE_FLAG = 100104 	# /usr/include/GL/glu.h:209
GLU_TESS_COMBINE = 100105 	# /usr/include/GL/glu.h:210
GLU_TESS_BEGIN_DATA = 100106 	# /usr/include/GL/glu.h:211
GLU_TESS_VERTEX_DATA = 100107 	# /usr/include/GL/glu.h:212
GLU_TESS_END_DATA = 100108 	# /usr/include/GL/glu.h:213
GLU_TESS_ERROR_DATA = 100109 	# /usr/include/GL/glu.h:214
GLU_TESS_EDGE_FLAG_DATA = 100110 	# /usr/include/GL/glu.h:215
GLU_TESS_COMBINE_DATA = 100111 	# /usr/include/GL/glu.h:216
GLU_CW = 100120 	# /usr/include/GL/glu.h:219
GLU_CCW = 100121 	# /usr/include/GL/glu.h:220
GLU_INTERIOR = 100122 	# /usr/include/GL/glu.h:221
GLU_EXTERIOR = 100123 	# /usr/include/GL/glu.h:222
GLU_UNKNOWN = 100124 	# /usr/include/GL/glu.h:223
GLU_TESS_WINDING_RULE = 100140 	# /usr/include/GL/glu.h:226
GLU_TESS_BOUNDARY_ONLY = 100141 	# /usr/include/GL/glu.h:227
GLU_TESS_TOLERANCE = 100142 	# /usr/include/GL/glu.h:228
GLU_TESS_ERROR1 = 100151 	# /usr/include/GL/glu.h:231
GLU_TESS_ERROR2 = 100152 	# /usr/include/GL/glu.h:232
GLU_TESS_ERROR3 = 100153 	# /usr/include/GL/glu.h:233
GLU_TESS_ERROR4 = 100154 	# /usr/include/GL/glu.h:234
GLU_TESS_ERROR5 = 100155 	# /usr/include/GL/glu.h:235
GLU_TESS_ERROR6 = 100156 	# /usr/include/GL/glu.h:236
GLU_TESS_ERROR7 = 100157 	# /usr/include/GL/glu.h:237
GLU_TESS_ERROR8 = 100158 	# /usr/include/GL/glu.h:238
GLU_TESS_MISSING_BEGIN_POLYGON = 100151 	# /usr/include/GL/glu.h:239
GLU_TESS_MISSING_BEGIN_CONTOUR = 100152 	# /usr/include/GL/glu.h:240
GLU_TESS_MISSING_END_POLYGON = 100153 	# /usr/include/GL/glu.h:241
GLU_TESS_MISSING_END_CONTOUR = 100154 	# /usr/include/GL/glu.h:242
GLU_TESS_COORD_TOO_LARGE = 100155 	# /usr/include/GL/glu.h:243
GLU_TESS_NEED_COMBINE_CALLBACK = 100156 	# /usr/include/GL/glu.h:244
GLU_TESS_WINDING_ODD = 100130 	# /usr/include/GL/glu.h:247
GLU_TESS_WINDING_NONZERO = 100131 	# /usr/include/GL/glu.h:248
GLU_TESS_WINDING_POSITIVE = 100132 	# /usr/include/GL/glu.h:249
GLU_TESS_WINDING_NEGATIVE = 100133 	# /usr/include/GL/glu.h:250
GLU_TESS_WINDING_ABS_GEQ_TWO = 100134 	# /usr/include/GL/glu.h:251
class struct_GLUnurbs(Structure):
    __slots__ = [
    ]
struct_GLUnurbs._fields_ = [
    ('_opaque_struct', c_int)
]

GLUnurbs = struct_GLUnurbs 	# /usr/include/GL/glu.h:261
class struct_GLUquadric(Structure):
    __slots__ = [
    ]
struct_GLUquadric._fields_ = [
    ('_opaque_struct', c_int)
]

GLUquadric = struct_GLUquadric 	# /usr/include/GL/glu.h:262
class struct_GLUtesselator(Structure):
    __slots__ = [
    ]
struct_GLUtesselator._fields_ = [
    ('_opaque_struct', c_int)
]

GLUtesselator = struct_GLUtesselator 	# /usr/include/GL/glu.h:263
GLUnurbsObj = GLUnurbs 	# /usr/include/GL/glu.h:266
GLUquadricObj = GLUquadric 	# /usr/include/GL/glu.h:267
GLUtesselatorObj = GLUtesselator 	# /usr/include/GL/glu.h:268
GLUtriangulatorObj = GLUtesselator 	# /usr/include/GL/glu.h:269
GLU_TESS_MAX_COORD = 9.9999999999999998e+149 	# /usr/include/GL/glu.h:271
_GLUfuncptr = CFUNCTYPE(None) 	# /usr/include/GL/glu.h:274
# /usr/include/GL/glu.h:276
gluBeginCurve = _link_function('gluBeginCurve', None, [POINTER(GLUnurbs)], None)

# /usr/include/GL/glu.h:277
gluBeginPolygon = _link_function('gluBeginPolygon', None, [POINTER(GLUtesselator)], None)

# /usr/include/GL/glu.h:278
gluBeginSurface = _link_function('gluBeginSurface', None, [POINTER(GLUnurbs)], None)

# /usr/include/GL/glu.h:279
gluBeginTrim = _link_function('gluBeginTrim', None, [POINTER(GLUnurbs)], None)

GLint = c_int 	# /usr/include/GL/gl.h:58
GLenum = c_uint 	# /usr/include/GL/gl.h:53
GLsizei = c_int 	# /usr/include/GL/gl.h:59
# /usr/include/GL/glu.h:280
gluBuild1DMipmapLevels = _link_function('gluBuild1DMipmapLevels', GLint, [GLenum, GLint, GLsizei, GLenum, GLenum, GLint, GLint, GLint, POINTER(None)], None)

# /usr/include/GL/glu.h:281
gluBuild1DMipmaps = _link_function('gluBuild1DMipmaps', GLint, [GLenum, GLint, GLsizei, GLenum, GLenum, POINTER(None)], None)

# /usr/include/GL/glu.h:282
gluBuild2DMipmapLevels = _link_function('gluBuild2DMipmapLevels', GLint, [GLenum, GLint, GLsizei, GLsizei, GLenum, GLenum, GLint, GLint, GLint, POINTER(None)], None)

# /usr/include/GL/glu.h:283
gluBuild2DMipmaps = _link_function('gluBuild2DMipmaps', GLint, [GLenum, GLint, GLsizei, GLsizei, GLenum, GLenum, POINTER(None)], None)

# /usr/include/GL/glu.h:284
gluBuild3DMipmapLevels = _link_function('gluBuild3DMipmapLevels', GLint, [GLenum, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, GLint, GLint, GLint, POINTER(None)], None)

# /usr/include/GL/glu.h:285
gluBuild3DMipmaps = _link_function('gluBuild3DMipmaps', GLint, [GLenum, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, POINTER(None)], None)

GLboolean = c_ubyte 	# /usr/include/GL/gl.h:54
GLubyte = c_ubyte 	# /usr/include/GL/gl.h:60
# /usr/include/GL/glu.h:286
gluCheckExtension = _link_function('gluCheckExtension', GLboolean, [POINTER(GLubyte), POINTER(GLubyte)], None)

GLdouble = c_double 	# /usr/include/GL/gl.h:65
# /usr/include/GL/glu.h:287
gluCylinder = _link_function('gluCylinder', None, [POINTER(GLUquadric), GLdouble, GLdouble, GLdouble, GLint, GLint], None)

# /usr/include/GL/glu.h:288
gluDeleteNurbsRenderer = _link_function('gluDeleteNurbsRenderer', None, [POINTER(GLUnurbs)], None)

# /usr/include/GL/glu.h:289
gluDeleteQuadric = _link_function('gluDeleteQuadric', None, [POINTER(GLUquadric)], None)

# /usr/include/GL/glu.h:290
gluDeleteTess = _link_function('gluDeleteTess', None, [POINTER(GLUtesselator)], None)

# /usr/include/GL/glu.h:291
gluDisk = _link_function('gluDisk', None, [POINTER(GLUquadric), GLdouble, GLdouble, GLint, GLint], None)

# /usr/include/GL/glu.h:292
gluEndCurve = _link_function('gluEndCurve', None, [POINTER(GLUnurbs)], None)

# /usr/include/GL/glu.h:293
gluEndPolygon = _link_function('gluEndPolygon', None, [POINTER(GLUtesselator)], None)

# /usr/include/GL/glu.h:294
gluEndSurface = _link_function('gluEndSurface', None, [POINTER(GLUnurbs)], None)

# /usr/include/GL/glu.h:295
gluEndTrim = _link_function('gluEndTrim', None, [POINTER(GLUnurbs)], None)

# /usr/include/GL/glu.h:296
gluErrorString = _link_function('gluErrorString', POINTER(GLubyte), [GLenum], None)

GLfloat = c_float 	# /usr/include/GL/gl.h:63
# /usr/include/GL/glu.h:297
gluGetNurbsProperty = _link_function('gluGetNurbsProperty', None, [POINTER(GLUnurbs), GLenum, POINTER(GLfloat)], None)

# /usr/include/GL/glu.h:298
gluGetString = _link_function('gluGetString', POINTER(GLubyte), [GLenum], None)

# /usr/include/GL/glu.h:299
gluGetTessProperty = _link_function('gluGetTessProperty', None, [POINTER(GLUtesselator), GLenum, POINTER(GLdouble)], None)

# /usr/include/GL/glu.h:300
gluLoadSamplingMatrices = _link_function('gluLoadSamplingMatrices', None, [POINTER(GLUnurbs), POINTER(GLfloat), POINTER(GLfloat), POINTER(GLint)], None)

# /usr/include/GL/glu.h:301
gluLookAt = _link_function('gluLookAt', None, [GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/glu.h:302
gluNewNurbsRenderer = _link_function('gluNewNurbsRenderer', POINTER(GLUnurbs), [], None)

# /usr/include/GL/glu.h:303
gluNewQuadric = _link_function('gluNewQuadric', POINTER(GLUquadric), [], None)

# /usr/include/GL/glu.h:304
gluNewTess = _link_function('gluNewTess', POINTER(GLUtesselator), [], None)

# /usr/include/GL/glu.h:305
gluNextContour = _link_function('gluNextContour', None, [POINTER(GLUtesselator), GLenum], None)

# /usr/include/GL/glu.h:306
gluNurbsCallback = _link_function('gluNurbsCallback', None, [POINTER(GLUnurbs), GLenum, _GLUfuncptr], None)

GLvoid = None 	# /usr/include/GL/gl.h:67
# /usr/include/GL/glu.h:307
gluNurbsCallbackData = _link_function('gluNurbsCallbackData', None, [POINTER(GLUnurbs), POINTER(GLvoid)], None)

# /usr/include/GL/glu.h:308
gluNurbsCallbackDataEXT = _link_function('gluNurbsCallbackDataEXT', None, [POINTER(GLUnurbs), POINTER(GLvoid)], None)

# /usr/include/GL/glu.h:309
gluNurbsCurve = _link_function('gluNurbsCurve', None, [POINTER(GLUnurbs), GLint, POINTER(GLfloat), GLint, POINTER(GLfloat), GLint, GLenum], None)

# /usr/include/GL/glu.h:310
gluNurbsProperty = _link_function('gluNurbsProperty', None, [POINTER(GLUnurbs), GLenum, GLfloat], None)

# /usr/include/GL/glu.h:311
gluNurbsSurface = _link_function('gluNurbsSurface', None, [POINTER(GLUnurbs), GLint, POINTER(GLfloat), GLint, POINTER(GLfloat), GLint, GLint, POINTER(GLfloat), GLint, GLint, GLenum], None)

# /usr/include/GL/glu.h:312
gluOrtho2D = _link_function('gluOrtho2D', None, [GLdouble, GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/glu.h:313
gluPartialDisk = _link_function('gluPartialDisk', None, [POINTER(GLUquadric), GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble], None)

# /usr/include/GL/glu.h:314
gluPerspective = _link_function('gluPerspective', None, [GLdouble, GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/glu.h:315
gluPickMatrix = _link_function('gluPickMatrix', None, [GLdouble, GLdouble, GLdouble, GLdouble, POINTER(GLint)], None)

# /usr/include/GL/glu.h:316
gluProject = _link_function('gluProject', GLint, [GLdouble, GLdouble, GLdouble, POINTER(GLdouble), POINTER(GLdouble), POINTER(GLint), POINTER(GLdouble), POINTER(GLdouble), POINTER(GLdouble)], None)

# /usr/include/GL/glu.h:317
gluPwlCurve = _link_function('gluPwlCurve', None, [POINTER(GLUnurbs), GLint, POINTER(GLfloat), GLint, GLenum], None)

# /usr/include/GL/glu.h:318
gluQuadricCallback = _link_function('gluQuadricCallback', None, [POINTER(GLUquadric), GLenum, _GLUfuncptr], None)

# /usr/include/GL/glu.h:319
gluQuadricDrawStyle = _link_function('gluQuadricDrawStyle', None, [POINTER(GLUquadric), GLenum], None)

# /usr/include/GL/glu.h:320
gluQuadricNormals = _link_function('gluQuadricNormals', None, [POINTER(GLUquadric), GLenum], None)

# /usr/include/GL/glu.h:321
gluQuadricOrientation = _link_function('gluQuadricOrientation', None, [POINTER(GLUquadric), GLenum], None)

# /usr/include/GL/glu.h:322
gluQuadricTexture = _link_function('gluQuadricTexture', None, [POINTER(GLUquadric), GLboolean], None)

# /usr/include/GL/glu.h:323
gluScaleImage = _link_function('gluScaleImage', GLint, [GLenum, GLsizei, GLsizei, GLenum, POINTER(None), GLsizei, GLsizei, GLenum, POINTER(GLvoid)], None)

# /usr/include/GL/glu.h:324
gluSphere = _link_function('gluSphere', None, [POINTER(GLUquadric), GLdouble, GLint, GLint], None)

# /usr/include/GL/glu.h:325
gluTessBeginContour = _link_function('gluTessBeginContour', None, [POINTER(GLUtesselator)], None)

# /usr/include/GL/glu.h:326
gluTessBeginPolygon = _link_function('gluTessBeginPolygon', None, [POINTER(GLUtesselator), POINTER(GLvoid)], None)

# /usr/include/GL/glu.h:327
gluTessCallback = _link_function('gluTessCallback', None, [POINTER(GLUtesselator), GLenum, _GLUfuncptr], None)

# /usr/include/GL/glu.h:328
gluTessEndContour = _link_function('gluTessEndContour', None, [POINTER(GLUtesselator)], None)

# /usr/include/GL/glu.h:329
gluTessEndPolygon = _link_function('gluTessEndPolygon', None, [POINTER(GLUtesselator)], None)

# /usr/include/GL/glu.h:330
gluTessNormal = _link_function('gluTessNormal', None, [POINTER(GLUtesselator), GLdouble, GLdouble, GLdouble], None)

# /usr/include/GL/glu.h:331
gluTessProperty = _link_function('gluTessProperty', None, [POINTER(GLUtesselator), GLenum, GLdouble], None)

# /usr/include/GL/glu.h:332
gluTessVertex = _link_function('gluTessVertex', None, [POINTER(GLUtesselator), POINTER(GLdouble), POINTER(GLvoid)], None)

# /usr/include/GL/glu.h:333
gluUnProject = _link_function('gluUnProject', GLint, [GLdouble, GLdouble, GLdouble, POINTER(GLdouble), POINTER(GLdouble), POINTER(GLint), POINTER(GLdouble), POINTER(GLdouble), POINTER(GLdouble)], None)

# /usr/include/GL/glu.h:334
gluUnProject4 = _link_function('gluUnProject4', GLint, [GLdouble, GLdouble, GLdouble, GLdouble, POINTER(GLdouble), POINTER(GLdouble), POINTER(GLint), GLdouble, GLdouble, POINTER(GLdouble), POINTER(GLdouble), POINTER(GLdouble), POINTER(GLdouble)], None)


__all__ = ['GLU_EXT_object_space_tess', 'GLU_EXT_nurbs_tessellator',
'GLU_FALSE', 'GLU_TRUE', 'GLU_VERSION_1_1', 'GLU_VERSION_1_2',
'GLU_VERSION_1_3', 'GLU_VERSION', 'GLU_EXTENSIONS', 'GLU_INVALID_ENUM',
'GLU_INVALID_VALUE', 'GLU_OUT_OF_MEMORY', 'GLU_INCOMPATIBLE_GL_VERSION',
'GLU_INVALID_OPERATION', 'GLU_OUTLINE_POLYGON', 'GLU_OUTLINE_PATCH',
'GLU_NURBS_ERROR', 'GLU_ERROR', 'GLU_NURBS_BEGIN', 'GLU_NURBS_BEGIN_EXT',
'GLU_NURBS_VERTEX', 'GLU_NURBS_VERTEX_EXT', 'GLU_NURBS_NORMAL',
'GLU_NURBS_NORMAL_EXT', 'GLU_NURBS_COLOR', 'GLU_NURBS_COLOR_EXT',
'GLU_NURBS_TEXTURE_COORD', 'GLU_NURBS_TEX_COORD_EXT', 'GLU_NURBS_END',
'GLU_NURBS_END_EXT', 'GLU_NURBS_BEGIN_DATA', 'GLU_NURBS_BEGIN_DATA_EXT',
'GLU_NURBS_VERTEX_DATA', 'GLU_NURBS_VERTEX_DATA_EXT', 'GLU_NURBS_NORMAL_DATA',
'GLU_NURBS_NORMAL_DATA_EXT', 'GLU_NURBS_COLOR_DATA',
'GLU_NURBS_COLOR_DATA_EXT', 'GLU_NURBS_TEXTURE_COORD_DATA',
'GLU_NURBS_TEX_COORD_DATA_EXT', 'GLU_NURBS_END_DATA',
'GLU_NURBS_END_DATA_EXT', 'GLU_NURBS_ERROR1', 'GLU_NURBS_ERROR2',
'GLU_NURBS_ERROR3', 'GLU_NURBS_ERROR4', 'GLU_NURBS_ERROR5',
'GLU_NURBS_ERROR6', 'GLU_NURBS_ERROR7', 'GLU_NURBS_ERROR8',
'GLU_NURBS_ERROR9', 'GLU_NURBS_ERROR10', 'GLU_NURBS_ERROR11',
'GLU_NURBS_ERROR12', 'GLU_NURBS_ERROR13', 'GLU_NURBS_ERROR14',
'GLU_NURBS_ERROR15', 'GLU_NURBS_ERROR16', 'GLU_NURBS_ERROR17',
'GLU_NURBS_ERROR18', 'GLU_NURBS_ERROR19', 'GLU_NURBS_ERROR20',
'GLU_NURBS_ERROR21', 'GLU_NURBS_ERROR22', 'GLU_NURBS_ERROR23',
'GLU_NURBS_ERROR24', 'GLU_NURBS_ERROR25', 'GLU_NURBS_ERROR26',
'GLU_NURBS_ERROR27', 'GLU_NURBS_ERROR28', 'GLU_NURBS_ERROR29',
'GLU_NURBS_ERROR30', 'GLU_NURBS_ERROR31', 'GLU_NURBS_ERROR32',
'GLU_NURBS_ERROR33', 'GLU_NURBS_ERROR34', 'GLU_NURBS_ERROR35',
'GLU_NURBS_ERROR36', 'GLU_NURBS_ERROR37', 'GLU_AUTO_LOAD_MATRIX',
'GLU_CULLING', 'GLU_SAMPLING_TOLERANCE', 'GLU_DISPLAY_MODE',
'GLU_PARAMETRIC_TOLERANCE', 'GLU_SAMPLING_METHOD', 'GLU_U_STEP', 'GLU_V_STEP',
'GLU_NURBS_MODE', 'GLU_NURBS_MODE_EXT', 'GLU_NURBS_TESSELLATOR',
'GLU_NURBS_TESSELLATOR_EXT', 'GLU_NURBS_RENDERER', 'GLU_NURBS_RENDERER_EXT',
'GLU_OBJECT_PARAMETRIC_ERROR', 'GLU_OBJECT_PARAMETRIC_ERROR_EXT',
'GLU_OBJECT_PATH_LENGTH', 'GLU_OBJECT_PATH_LENGTH_EXT', 'GLU_PATH_LENGTH',
'GLU_PARAMETRIC_ERROR', 'GLU_DOMAIN_DISTANCE', 'GLU_MAP1_TRIM_2',
'GLU_MAP1_TRIM_3', 'GLU_POINT', 'GLU_LINE', 'GLU_FILL', 'GLU_SILHOUETTE',
'GLU_SMOOTH', 'GLU_FLAT', 'GLU_NONE', 'GLU_OUTSIDE', 'GLU_INSIDE',
'GLU_TESS_BEGIN', 'GLU_BEGIN', 'GLU_TESS_VERTEX', 'GLU_VERTEX',
'GLU_TESS_END', 'GLU_END', 'GLU_TESS_ERROR', 'GLU_TESS_EDGE_FLAG',
'GLU_EDGE_FLAG', 'GLU_TESS_COMBINE', 'GLU_TESS_BEGIN_DATA',
'GLU_TESS_VERTEX_DATA', 'GLU_TESS_END_DATA', 'GLU_TESS_ERROR_DATA',
'GLU_TESS_EDGE_FLAG_DATA', 'GLU_TESS_COMBINE_DATA', 'GLU_CW', 'GLU_CCW',
'GLU_INTERIOR', 'GLU_EXTERIOR', 'GLU_UNKNOWN', 'GLU_TESS_WINDING_RULE',
'GLU_TESS_BOUNDARY_ONLY', 'GLU_TESS_TOLERANCE', 'GLU_TESS_ERROR1',
'GLU_TESS_ERROR2', 'GLU_TESS_ERROR3', 'GLU_TESS_ERROR4', 'GLU_TESS_ERROR5',
'GLU_TESS_ERROR6', 'GLU_TESS_ERROR7', 'GLU_TESS_ERROR8',
'GLU_TESS_MISSING_BEGIN_POLYGON', 'GLU_TESS_MISSING_BEGIN_CONTOUR',
'GLU_TESS_MISSING_END_POLYGON', 'GLU_TESS_MISSING_END_CONTOUR',
'GLU_TESS_COORD_TOO_LARGE', 'GLU_TESS_NEED_COMBINE_CALLBACK',
'GLU_TESS_WINDING_ODD', 'GLU_TESS_WINDING_NONZERO',
'GLU_TESS_WINDING_POSITIVE', 'GLU_TESS_WINDING_NEGATIVE',
'GLU_TESS_WINDING_ABS_GEQ_TWO', 'GLUnurbs', 'GLUquadric', 'GLUtesselator',
'GLUnurbsObj', 'GLUquadricObj', 'GLUtesselatorObj', 'GLUtriangulatorObj',
'GLU_TESS_MAX_COORD', '_GLUfuncptr', 'gluBeginCurve', 'gluBeginPolygon',
'gluBeginSurface', 'gluBeginTrim', 'gluBuild1DMipmapLevels',
'gluBuild1DMipmaps', 'gluBuild2DMipmapLevels', 'gluBuild2DMipmaps',
'gluBuild3DMipmapLevels', 'gluBuild3DMipmaps', 'gluCheckExtension',
'gluCylinder', 'gluDeleteNurbsRenderer', 'gluDeleteQuadric', 'gluDeleteTess',
'gluDisk', 'gluEndCurve', 'gluEndPolygon', 'gluEndSurface', 'gluEndTrim',
'gluErrorString', 'gluGetNurbsProperty', 'gluGetString', 'gluGetTessProperty',
'gluLoadSamplingMatrices', 'gluLookAt', 'gluNewNurbsRenderer',
'gluNewQuadric', 'gluNewTess', 'gluNextContour', 'gluNurbsCallback',
'gluNurbsCallbackData', 'gluNurbsCallbackDataEXT', 'gluNurbsCurve',
'gluNurbsProperty', 'gluNurbsSurface', 'gluOrtho2D', 'gluPartialDisk',
'gluPerspective', 'gluPickMatrix', 'gluProject', 'gluPwlCurve',
'gluQuadricCallback', 'gluQuadricDrawStyle', 'gluQuadricNormals',
'gluQuadricOrientation', 'gluQuadricTexture', 'gluScaleImage', 'gluSphere',
'gluTessBeginContour', 'gluTessBeginPolygon', 'gluTessCallback',
'gluTessEndContour', 'gluTessEndPolygon', 'gluTessNormal', 'gluTessProperty',
'gluTessVertex', 'gluUnProject', 'gluUnProject4']
# END GENERATED CONTENT (do not edit above this line)



########NEW FILE########
__FILENAME__ = glu_info
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Information about version and extensions of current GLU implementation.

Usage::

    from pyglet.gl import glu_info

    if glu_info.have_extension('GLU_EXT_nurbs_tessellator'):
        # ...

If multiple contexts are in use you can use a separate GLUInfo object for each
context.  Call `set_active_context` after switching to the desired context for
each GLUInfo::

    from pyglet.gl.glu_info import GLUInfo

    info = GLUInfo()
    info.set_active_context()
    if info.have_version(1, 3):
        # ...

Note that GLUInfo only returns meaningful information if a context has been
created.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: glu_info.py 1979 2008-03-28 15:23:51Z Alex.Holkner $'

from ctypes import *
import warnings

from pyglet.gl.glu import *

class GLUInfo(object):
    '''Information interface for the GLU library.

    A default instance is created automatically when the first OpenGL context
    is created.  You can use the module functions as a convenience for
    this default instance's methods.

    If you are using more than one context, you must call `set_active_context`
    when the context is active for this `GLUInfo` instance.
    '''
    have_context = False
    version = '0.0.0'
    extensions = []

    _have_info = False

    def set_active_context(self):
        '''Store information for the currently active context.

        This method is called automatically for the default context.
        '''
        self.have_context = True
        if not self._have_info:
            self.extensions = \
                cast(gluGetString(GLU_EXTENSIONS), c_char_p).value.split()
            self.version = cast(gluGetString(GLU_VERSION), c_char_p).value
            self._have_info = True

    def have_version(self, major, minor=0, release=0):
        '''Determine if a version of GLU is supported.

        :Parameters:
            `major` : int
                The major revision number (typically 1).
            `minor` : int
                The minor revision number.
            `release` : int
                The release number.

        :rtype: bool
        :return: True if the requested or a later version is supported.
        '''
        if not self.have_context:
            warnings.warn('No GL context created yet.')
        ver = '%s.0.0' % self.version.split(' ', 1)[0]
        imajor, iminor, irelease = [int(v) for v in ver.split('.', 3)[:3]]
        return imajor > major or \
           (imajor == major and iminor > minor) or \
           (imajor == major and iminor == minor and irelease >= release)

    def get_version(self):
        '''Get the current GLU version.

        :return: the GLU version
        :rtype: str
        '''
        if not self.have_context:
            warnings.warn('No GL context created yet.')
        return self.version

    def have_extension(self, extension):
        '''Determine if a GLU extension is available.

        :Parameters:
            `extension` : str
                The name of the extension to test for, including its
                ``GLU_`` prefix.

        :return: True if the extension is provided by the implementation.
        :rtype: bool
        '''
        if not self.have_context:
            warnings.warn('No GL context created yet.')
        return extension in self.extensions

    def get_extensions(self):
        '''Get a list of available GLU extensions.

        :return: a list of the available extensions.
        :rtype: list of str
        '''
        if not self.have_context:
            warnings.warn('No GL context created yet.')
        return self.extensions

# Single instance useful for apps with only a single context (or all contexts
# have same GLU driver, common case).
_glu_info = GLUInfo()

set_active_context = _glu_info.set_active_context
have_version = _glu_info.have_version
get_version = _glu_info.get_version
have_extension = _glu_info.have_extension
get_extensions = _glu_info.get_extensions

########NEW FILE########
__FILENAME__ = glx
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for /usr/include/GL/glx.h

Do not modify generated portions of this file.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: glx.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

from ctypes import *
from pyglet.gl.lib import link_GLX as _link_function
from pyglet.gl.lib import c_ptrdiff_t, c_void

if not _link_function:
    raise ImportError('libGL.so is not available.')

# BEGIN GENERATED CONTENT (do not edit below this line)

# This content is generated by tools/gengl.py.
# Wrapper for /usr/include/GL/glx.h


GLX_USE_GL = 1 	# /usr/include/GL/glx.h:36
GLX_BUFFER_SIZE = 2 	# /usr/include/GL/glx.h:37
GLX_LEVEL = 3 	# /usr/include/GL/glx.h:38
GLX_RGBA = 4 	# /usr/include/GL/glx.h:39
GLX_DOUBLEBUFFER = 5 	# /usr/include/GL/glx.h:40
GLX_STEREO = 6 	# /usr/include/GL/glx.h:41
GLX_AUX_BUFFERS = 7 	# /usr/include/GL/glx.h:42
GLX_RED_SIZE = 8 	# /usr/include/GL/glx.h:43
GLX_GREEN_SIZE = 9 	# /usr/include/GL/glx.h:44
GLX_BLUE_SIZE = 10 	# /usr/include/GL/glx.h:45
GLX_ALPHA_SIZE = 11 	# /usr/include/GL/glx.h:46
GLX_DEPTH_SIZE = 12 	# /usr/include/GL/glx.h:47
GLX_STENCIL_SIZE = 13 	# /usr/include/GL/glx.h:48
GLX_ACCUM_RED_SIZE = 14 	# /usr/include/GL/glx.h:49
GLX_ACCUM_GREEN_SIZE = 15 	# /usr/include/GL/glx.h:50
GLX_ACCUM_BLUE_SIZE = 16 	# /usr/include/GL/glx.h:51
GLX_ACCUM_ALPHA_SIZE = 17 	# /usr/include/GL/glx.h:52
GLX_BAD_SCREEN = 1 	# /usr/include/GL/glx.h:58
GLX_BAD_ATTRIBUTE = 2 	# /usr/include/GL/glx.h:59
GLX_NO_EXTENSION = 3 	# /usr/include/GL/glx.h:60
GLX_BAD_VISUAL = 4 	# /usr/include/GL/glx.h:61
GLX_BAD_CONTEXT = 5 	# /usr/include/GL/glx.h:62
GLX_BAD_VALUE = 6 	# /usr/include/GL/glx.h:63
GLX_BAD_ENUM = 7 	# /usr/include/GL/glx.h:64
GLX_VENDOR = 1 	# /usr/include/GL/glx.h:69
GLX_VERSION = 2 	# /usr/include/GL/glx.h:70
GLX_EXTENSIONS = 3 	# /usr/include/GL/glx.h:71
# VERSION_1_3 (/usr/include/GL/glx.h:73)
GLX_WINDOW_BIT = 1 	# /usr/include/GL/glx.h:74
GLX_PIXMAP_BIT = 2 	# /usr/include/GL/glx.h:75
GLX_PBUFFER_BIT = 4 	# /usr/include/GL/glx.h:76
GLX_RGBA_BIT = 1 	# /usr/include/GL/glx.h:77
GLX_COLOR_INDEX_BIT = 2 	# /usr/include/GL/glx.h:78
GLX_PBUFFER_CLOBBER_MASK = 134217728 	# /usr/include/GL/glx.h:79
GLX_FRONT_LEFT_BUFFER_BIT = 1 	# /usr/include/GL/glx.h:80
GLX_FRONT_RIGHT_BUFFER_BIT = 2 	# /usr/include/GL/glx.h:81
GLX_BACK_LEFT_BUFFER_BIT = 4 	# /usr/include/GL/glx.h:82
GLX_BACK_RIGHT_BUFFER_BIT = 8 	# /usr/include/GL/glx.h:83
GLX_AUX_BUFFERS_BIT = 16 	# /usr/include/GL/glx.h:84
GLX_DEPTH_BUFFER_BIT = 32 	# /usr/include/GL/glx.h:85
GLX_STENCIL_BUFFER_BIT = 64 	# /usr/include/GL/glx.h:86
GLX_ACCUM_BUFFER_BIT = 128 	# /usr/include/GL/glx.h:87
GLX_CONFIG_CAVEAT = 32 	# /usr/include/GL/glx.h:88
GLX_X_VISUAL_TYPE = 34 	# /usr/include/GL/glx.h:89
GLX_TRANSPARENT_TYPE = 35 	# /usr/include/GL/glx.h:90
GLX_TRANSPARENT_INDEX_VALUE = 36 	# /usr/include/GL/glx.h:91
GLX_TRANSPARENT_RED_VALUE = 37 	# /usr/include/GL/glx.h:92
GLX_TRANSPARENT_GREEN_VALUE = 38 	# /usr/include/GL/glx.h:93
GLX_TRANSPARENT_BLUE_VALUE = 39 	# /usr/include/GL/glx.h:94
GLX_TRANSPARENT_ALPHA_VALUE = 40 	# /usr/include/GL/glx.h:95
GLX_DONT_CARE = 4294967295 	# /usr/include/GL/glx.h:96
GLX_NONE = 32768 	# /usr/include/GL/glx.h:97
GLX_SLOW_CONFIG = 32769 	# /usr/include/GL/glx.h:98
GLX_TRUE_COLOR = 32770 	# /usr/include/GL/glx.h:99
GLX_DIRECT_COLOR = 32771 	# /usr/include/GL/glx.h:100
GLX_PSEUDO_COLOR = 32772 	# /usr/include/GL/glx.h:101
GLX_STATIC_COLOR = 32773 	# /usr/include/GL/glx.h:102
GLX_GRAY_SCALE = 32774 	# /usr/include/GL/glx.h:103
GLX_STATIC_GRAY = 32775 	# /usr/include/GL/glx.h:104
GLX_TRANSPARENT_RGB = 32776 	# /usr/include/GL/glx.h:105
GLX_TRANSPARENT_INDEX = 32777 	# /usr/include/GL/glx.h:106
GLX_VISUAL_ID = 32779 	# /usr/include/GL/glx.h:107
GLX_SCREEN = 32780 	# /usr/include/GL/glx.h:108
GLX_NON_CONFORMANT_CONFIG = 32781 	# /usr/include/GL/glx.h:109
GLX_DRAWABLE_TYPE = 32784 	# /usr/include/GL/glx.h:110
GLX_RENDER_TYPE = 32785 	# /usr/include/GL/glx.h:111
GLX_X_RENDERABLE = 32786 	# /usr/include/GL/glx.h:112
GLX_FBCONFIG_ID = 32787 	# /usr/include/GL/glx.h:113
GLX_RGBA_TYPE = 32788 	# /usr/include/GL/glx.h:114
GLX_COLOR_INDEX_TYPE = 32789 	# /usr/include/GL/glx.h:115
GLX_MAX_PBUFFER_WIDTH = 32790 	# /usr/include/GL/glx.h:116
GLX_MAX_PBUFFER_HEIGHT = 32791 	# /usr/include/GL/glx.h:117
GLX_MAX_PBUFFER_PIXELS = 32792 	# /usr/include/GL/glx.h:118
GLX_PRESERVED_CONTENTS = 32795 	# /usr/include/GL/glx.h:119
GLX_LARGEST_PBUFFER = 32796 	# /usr/include/GL/glx.h:120
GLX_WIDTH = 32797 	# /usr/include/GL/glx.h:121
GLX_HEIGHT = 32798 	# /usr/include/GL/glx.h:122
GLX_EVENT_MASK = 32799 	# /usr/include/GL/glx.h:123
GLX_DAMAGED = 32800 	# /usr/include/GL/glx.h:124
GLX_SAVED = 32801 	# /usr/include/GL/glx.h:125
GLX_WINDOW = 32802 	# /usr/include/GL/glx.h:126
GLX_PBUFFER = 32803 	# /usr/include/GL/glx.h:127
GLX_PBUFFER_HEIGHT = 32832 	# /usr/include/GL/glx.h:128
GLX_PBUFFER_WIDTH = 32833 	# /usr/include/GL/glx.h:129
# VERSION_1_4 (/usr/include/GL/glx.h:132)
GLX_SAMPLE_BUFFERS = 100000 	# /usr/include/GL/glx.h:133
GLX_SAMPLES = 100001 	# /usr/include/GL/glx.h:134
# ARB_get_proc_address (/usr/include/GL/glx.h:137)
__GLXextFuncPtr = CFUNCTYPE(None) 	# /usr/include/GL/glx.h:138
XID = c_ulong 	# /usr/include/X11/X.h:71
GLXContextID = XID 	# /usr/include/GL/glx.h:144
GLXPixmap = XID 	# /usr/include/GL/glx.h:145
GLXDrawable = XID 	# /usr/include/GL/glx.h:146
GLXPbuffer = XID 	# /usr/include/GL/glx.h:147
GLXPbufferSGIX = XID 	# /usr/include/GL/glx.h:148
GLXWindow = XID 	# /usr/include/GL/glx.h:149
GLXFBConfigID = XID 	# /usr/include/GL/glx.h:150
class struct___GLXcontextRec(Structure):
    __slots__ = [
    ]
struct___GLXcontextRec._fields_ = [
    ('_opaque_struct', c_int)
]

GLXContext = POINTER(struct___GLXcontextRec) 	# /usr/include/GL/glx.h:155
class struct___GLXFBConfigRec(Structure):
    __slots__ = [
    ]
struct___GLXFBConfigRec._fields_ = [
    ('_opaque_struct', c_int)
]

GLXFBConfig = POINTER(struct___GLXFBConfigRec) 	# /usr/include/GL/glx.h:160
class struct_anon_94(Structure):
    __slots__ = [
        'visual',
        'visualid',
        'screen',
        'depth',
        'class',
        'red_mask',
        'green_mask',
        'blue_mask',
        'colormap_size',
        'bits_per_rgb',
    ]
class struct_anon_11(Structure):
    __slots__ = [
        'ext_data',
        'visualid',
        'class',
        'red_mask',
        'green_mask',
        'blue_mask',
        'bits_per_rgb',
        'map_entries',
    ]
class struct__XExtData(Structure):
    __slots__ = [
        'number',
        'next',
        'free_private',
        'private_data',
    ]
XPointer = c_char_p 	# /usr/include/X11/Xlib.h:108
struct__XExtData._fields_ = [
    ('number', c_int),
    ('next', POINTER(struct__XExtData)),
    ('free_private', POINTER(CFUNCTYPE(c_int, POINTER(struct__XExtData)))),
    ('private_data', XPointer),
]

XExtData = struct__XExtData 	# /usr/include/X11/Xlib.h:187
VisualID = c_ulong 	# /usr/include/X11/X.h:81
struct_anon_11._fields_ = [
    ('ext_data', POINTER(XExtData)),
    ('visualid', VisualID),
    ('class', c_int),
    ('red_mask', c_ulong),
    ('green_mask', c_ulong),
    ('blue_mask', c_ulong),
    ('bits_per_rgb', c_int),
    ('map_entries', c_int),
]

Visual = struct_anon_11 	# /usr/include/X11/Xlib.h:270
struct_anon_94._fields_ = [
    ('visual', POINTER(Visual)),
    ('visualid', VisualID),
    ('screen', c_int),
    ('depth', c_int),
    ('class', c_int),
    ('red_mask', c_ulong),
    ('green_mask', c_ulong),
    ('blue_mask', c_ulong),
    ('colormap_size', c_int),
    ('bits_per_rgb', c_int),
]

XVisualInfo = struct_anon_94 	# /usr/include/X11/Xutil.h:296
class struct__XDisplay(Structure):
    __slots__ = [
    ]
struct__XDisplay._fields_ = [
    ('_opaque_struct', c_int)
]

Display = struct__XDisplay 	# /usr/include/X11/Xlib.h:519
# /usr/include/GL/glx.h:168
glXChooseVisual = _link_function('glXChooseVisual', POINTER(XVisualInfo), [POINTER(Display), c_int, POINTER(c_int)], 'ARB_get_proc_address')

# /usr/include/GL/glx.h:171
glXCopyContext = _link_function('glXCopyContext', None, [POINTER(Display), GLXContext, GLXContext, c_ulong], 'ARB_get_proc_address')

# /usr/include/GL/glx.h:174
glXCreateContext = _link_function('glXCreateContext', GLXContext, [POINTER(Display), POINTER(XVisualInfo), GLXContext, c_int], 'ARB_get_proc_address')

Pixmap = XID 	# /usr/include/X11/X.h:107
# /usr/include/GL/glx.h:177
glXCreateGLXPixmap = _link_function('glXCreateGLXPixmap', GLXPixmap, [POINTER(Display), POINTER(XVisualInfo), Pixmap], 'ARB_get_proc_address')

# /usr/include/GL/glx.h:180
glXDestroyContext = _link_function('glXDestroyContext', None, [POINTER(Display), GLXContext], 'ARB_get_proc_address')

# /usr/include/GL/glx.h:182
glXDestroyGLXPixmap = _link_function('glXDestroyGLXPixmap', None, [POINTER(Display), GLXPixmap], 'ARB_get_proc_address')

# /usr/include/GL/glx.h:184
glXGetConfig = _link_function('glXGetConfig', c_int, [POINTER(Display), POINTER(XVisualInfo), c_int, POINTER(c_int)], 'ARB_get_proc_address')

# /usr/include/GL/glx.h:187
glXGetCurrentContext = _link_function('glXGetCurrentContext', GLXContext, [], 'ARB_get_proc_address')

# /usr/include/GL/glx.h:189
glXGetCurrentDrawable = _link_function('glXGetCurrentDrawable', GLXDrawable, [], 'ARB_get_proc_address')

# /usr/include/GL/glx.h:191
glXIsDirect = _link_function('glXIsDirect', c_int, [POINTER(Display), GLXContext], 'ARB_get_proc_address')

# /usr/include/GL/glx.h:193
glXMakeCurrent = _link_function('glXMakeCurrent', c_int, [POINTER(Display), GLXDrawable, GLXContext], 'ARB_get_proc_address')

# /usr/include/GL/glx.h:196
glXQueryExtension = _link_function('glXQueryExtension', c_int, [POINTER(Display), POINTER(c_int), POINTER(c_int)], 'ARB_get_proc_address')

# /usr/include/GL/glx.h:198
glXQueryVersion = _link_function('glXQueryVersion', c_int, [POINTER(Display), POINTER(c_int), POINTER(c_int)], 'ARB_get_proc_address')

# /usr/include/GL/glx.h:200
glXSwapBuffers = _link_function('glXSwapBuffers', None, [POINTER(Display), GLXDrawable], 'ARB_get_proc_address')

Font = XID 	# /usr/include/X11/X.h:105
# /usr/include/GL/glx.h:202
glXUseXFont = _link_function('glXUseXFont', None, [Font, c_int, c_int, c_int], 'ARB_get_proc_address')

# /usr/include/GL/glx.h:204
glXWaitGL = _link_function('glXWaitGL', None, [], 'ARB_get_proc_address')

# /usr/include/GL/glx.h:206
glXWaitX = _link_function('glXWaitX', None, [], 'ARB_get_proc_address')

# VERSION_1_1 (/usr/include/GL/glx.h:209)
GLX_VERSION_1_1 = 1 	# /usr/include/GL/glx.h:210
# /usr/include/GL/glx.h:214
glXGetClientString = _link_function('glXGetClientString', c_char_p, [POINTER(Display), c_int], 'VERSION_1_1')

# /usr/include/GL/glx.h:216
glXQueryServerString = _link_function('glXQueryServerString', c_char_p, [POINTER(Display), c_int, c_int], 'VERSION_1_1')

# /usr/include/GL/glx.h:218
glXQueryExtensionsString = _link_function('glXQueryExtensionsString', c_char_p, [POINTER(Display), c_int], 'VERSION_1_1')

# VERSION_1_2 (/usr/include/GL/glx.h:222)
GLX_VERSION_1_2 = 1 	# /usr/include/GL/glx.h:223
# /usr/include/GL/glx.h:227
glXGetCurrentDisplay = _link_function('glXGetCurrentDisplay', POINTER(Display), [], 'VERSION_1_2')

# VERSION_1_3 (/usr/include/GL/glx.h:230)
GLX_VERSION_1_3 = 1 	# /usr/include/GL/glx.h:231
# /usr/include/GL/glx.h:235
glXChooseFBConfig = _link_function('glXChooseFBConfig', POINTER(GLXFBConfig), [POINTER(Display), c_int, POINTER(c_int), POINTER(c_int)], 'VERSION_1_3')

# /usr/include/GL/glx.h:238
glXCreateNewContext = _link_function('glXCreateNewContext', GLXContext, [POINTER(Display), GLXFBConfig, c_int, GLXContext, c_int], 'VERSION_1_3')

# /usr/include/GL/glx.h:242
glXCreatePbuffer = _link_function('glXCreatePbuffer', GLXPbuffer, [POINTER(Display), GLXFBConfig, POINTER(c_int)], 'VERSION_1_3')

# /usr/include/GL/glx.h:245
glXCreatePixmap = _link_function('glXCreatePixmap', GLXPixmap, [POINTER(Display), GLXFBConfig, Pixmap, POINTER(c_int)], 'VERSION_1_3')

Window = XID 	# /usr/include/X11/X.h:101
# /usr/include/GL/glx.h:248
glXCreateWindow = _link_function('glXCreateWindow', GLXWindow, [POINTER(Display), GLXFBConfig, Window, POINTER(c_int)], 'VERSION_1_3')

# /usr/include/GL/glx.h:251
glXDestroyPbuffer = _link_function('glXDestroyPbuffer', None, [POINTER(Display), GLXPbuffer], 'VERSION_1_3')

# /usr/include/GL/glx.h:253
glXDestroyPixmap = _link_function('glXDestroyPixmap', None, [POINTER(Display), GLXPixmap], 'VERSION_1_3')

# /usr/include/GL/glx.h:255
glXDestroyWindow = _link_function('glXDestroyWindow', None, [POINTER(Display), GLXWindow], 'VERSION_1_3')

# /usr/include/GL/glx.h:257
glXGetCurrentReadDrawable = _link_function('glXGetCurrentReadDrawable', GLXDrawable, [], 'VERSION_1_3')

# /usr/include/GL/glx.h:259
glXGetFBConfigAttrib = _link_function('glXGetFBConfigAttrib', c_int, [POINTER(Display), GLXFBConfig, c_int, POINTER(c_int)], 'VERSION_1_3')

# /usr/include/GL/glx.h:262
glXGetFBConfigs = _link_function('glXGetFBConfigs', POINTER(GLXFBConfig), [POINTER(Display), c_int, POINTER(c_int)], 'VERSION_1_3')

# /usr/include/GL/glx.h:264
glXGetSelectedEvent = _link_function('glXGetSelectedEvent', None, [POINTER(Display), GLXDrawable, POINTER(c_ulong)], 'VERSION_1_3')

# /usr/include/GL/glx.h:267
glXGetVisualFromFBConfig = _link_function('glXGetVisualFromFBConfig', POINTER(XVisualInfo), [POINTER(Display), GLXFBConfig], 'VERSION_1_3')

# /usr/include/GL/glx.h:269
glXMakeContextCurrent = _link_function('glXMakeContextCurrent', c_int, [POINTER(Display), GLXDrawable, GLXDrawable, GLXContext], 'VERSION_1_3')

# /usr/include/GL/glx.h:272
glXQueryContext = _link_function('glXQueryContext', c_int, [POINTER(Display), GLXContext, c_int, POINTER(c_int)], 'VERSION_1_3')

# /usr/include/GL/glx.h:275
glXQueryDrawable = _link_function('glXQueryDrawable', None, [POINTER(Display), GLXDrawable, c_int, POINTER(c_uint)], 'VERSION_1_3')

# /usr/include/GL/glx.h:278
glXSelectEvent = _link_function('glXSelectEvent', None, [POINTER(Display), GLXDrawable, c_ulong], 'VERSION_1_3')

PFNGLXGETFBCONFIGSPROC = CFUNCTYPE(POINTER(GLXFBConfig), POINTER(Display), c_int, POINTER(c_int)) 	# /usr/include/GL/glx.h:281
PFNGLXCHOOSEFBCONFIGPROC = CFUNCTYPE(POINTER(GLXFBConfig), POINTER(Display), c_int, POINTER(c_int), POINTER(c_int)) 	# /usr/include/GL/glx.h:282
PFNGLXGETFBCONFIGATTRIBPROC = CFUNCTYPE(c_int, POINTER(Display), GLXFBConfig, c_int, POINTER(c_int)) 	# /usr/include/GL/glx.h:283
PFNGLXGETVISUALFROMFBCONFIGPROC = CFUNCTYPE(POINTER(XVisualInfo), POINTER(Display), GLXFBConfig) 	# /usr/include/GL/glx.h:284
PFNGLXCREATEWINDOWPROC = CFUNCTYPE(GLXWindow, POINTER(Display), GLXFBConfig, Window, POINTER(c_int)) 	# /usr/include/GL/glx.h:285
PFNGLXDESTROYWINDOWPROC = CFUNCTYPE(None, POINTER(Display), GLXWindow) 	# /usr/include/GL/glx.h:286
PFNGLXCREATEPIXMAPPROC = CFUNCTYPE(GLXPixmap, POINTER(Display), GLXFBConfig, Pixmap, POINTER(c_int)) 	# /usr/include/GL/glx.h:287
PFNGLXDESTROYPIXMAPPROC = CFUNCTYPE(None, POINTER(Display), GLXPixmap) 	# /usr/include/GL/glx.h:288
PFNGLXCREATEPBUFFERPROC = CFUNCTYPE(GLXPbuffer, POINTER(Display), GLXFBConfig, POINTER(c_int)) 	# /usr/include/GL/glx.h:289
PFNGLXDESTROYPBUFFERPROC = CFUNCTYPE(None, POINTER(Display), GLXPbuffer) 	# /usr/include/GL/glx.h:290
PFNGLXQUERYDRAWABLEPROC = CFUNCTYPE(None, POINTER(Display), GLXDrawable, c_int, POINTER(c_uint)) 	# /usr/include/GL/glx.h:291
PFNGLXCREATENEWCONTEXTPROC = CFUNCTYPE(GLXContext, POINTER(Display), GLXFBConfig, c_int, GLXContext, c_int) 	# /usr/include/GL/glx.h:292
PFNGLXMAKECONTEXTCURRENTPROC = CFUNCTYPE(c_int, POINTER(Display), GLXDrawable, GLXDrawable, GLXContext) 	# /usr/include/GL/glx.h:293
PFNGLXGETCURRENTREADDRAWABLEPROC = CFUNCTYPE(GLXDrawable) 	# /usr/include/GL/glx.h:294
PFNGLXGETCURRENTDISPLAYPROC = CFUNCTYPE(POINTER(Display)) 	# /usr/include/GL/glx.h:295
PFNGLXQUERYCONTEXTPROC = CFUNCTYPE(c_int, POINTER(Display), GLXContext, c_int, POINTER(c_int)) 	# /usr/include/GL/glx.h:296
PFNGLXSELECTEVENTPROC = CFUNCTYPE(None, POINTER(Display), GLXDrawable, c_ulong) 	# /usr/include/GL/glx.h:297
PFNGLXGETSELECTEDEVENTPROC = CFUNCTYPE(None, POINTER(Display), GLXDrawable, POINTER(c_ulong)) 	# /usr/include/GL/glx.h:298
# VERSION_1_4 (/usr/include/GL/glx.h:302)
GLX_VERSION_1_4 = 1 	# /usr/include/GL/glx.h:303
GLubyte = c_ubyte 	# /usr/include/GL/gl.h:60
# /usr/include/GL/glx.h:307
glXGetProcAddress = _link_function('glXGetProcAddress', __GLXextFuncPtr, [POINTER(GLubyte)], 'VERSION_1_4')

PFNGLXGETPROCADDRESSPROC = CFUNCTYPE(__GLXextFuncPtr, POINTER(GLubyte)) 	# /usr/include/GL/glx.h:308
# ARB_get_proc_address (/usr/include/GL/glx.h:318)
GLX_ARB_get_proc_address = 1 	# /usr/include/GL/glx.h:319
# /usr/include/GL/glx.h:321
glXGetProcAddressARB = _link_function('glXGetProcAddressARB', POINTER(CFUNCTYPE(None)), [POINTER(GLubyte)], 'ARB_get_proc_address')

PFNGLXGETPROCADDRESSARBPROC = CFUNCTYPE(__GLXextFuncPtr, POINTER(GLubyte)) 	# /usr/include/GL/glx.h:322
class struct_anon_96(Structure):
    __slots__ = [
        'event_type',
        'draw_type',
        'serial',
        'send_event',
        'display',
        'drawable',
        'buffer_mask',
        'aux_buffer',
        'x',
        'y',
        'width',
        'height',
        'count',
    ]
struct_anon_96._fields_ = [
    ('event_type', c_int),
    ('draw_type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('drawable', GLXDrawable),
    ('buffer_mask', c_uint),
    ('aux_buffer', c_uint),
    ('x', c_int),
    ('y', c_int),
    ('width', c_int),
    ('height', c_int),
    ('count', c_int),
]

GLXPbufferClobberEvent = struct_anon_96 	# /usr/include/GL/glx.h:343
class struct___GLXEvent(Union):
    __slots__ = [
        'glxpbufferclobber',
        'pad',
    ]
struct___GLXEvent._fields_ = [
    ('glxpbufferclobber', GLXPbufferClobberEvent),
    ('pad', c_long * 24),
]

GLXEvent = struct___GLXEvent 	# /usr/include/GL/glx.h:348
# GLXEXT_LEGACY (/usr/include/GL/glx.h:350)
# VERSION_1_3 (/usr/include/GL/glxext.h:59)
# VERSION_1_4 (/usr/include/GL/glxext.h:118)
# ARB_get_proc_address (/usr/include/GL/glxext.h:123)
# ARB_multisample (/usr/include/GL/glxext.h:126)
# ARB_fbconfig_float (/usr/include/GL/glxext.h:131)
# SGIS_multisample (/usr/include/GL/glxext.h:136)
# EXT_visual_info (/usr/include/GL/glxext.h:141)
# SGI_swap_control (/usr/include/GL/glxext.h:160)
# SGI_video_sync (/usr/include/GL/glxext.h:163)
# SGI_make_current_read (/usr/include/GL/glxext.h:166)
# SGIX_video_source (/usr/include/GL/glxext.h:169)
# EXT_visual_rating (/usr/include/GL/glxext.h:172)
# EXT_import_context (/usr/include/GL/glxext.h:179)
# SGIX_fbconfig (/usr/include/GL/glxext.h:185)
# SGIX_pbuffer (/usr/include/GL/glxext.h:199)
# SGI_cushion (/usr/include/GL/glxext.h:227)
# SGIX_video_resize (/usr/include/GL/glxext.h:230)
# SGIX_dmbuffer (/usr/include/GL/glxext.h:235)
# SGIX_swap_group (/usr/include/GL/glxext.h:239)
# SGIX_swap_barrier (/usr/include/GL/glxext.h:242)
# SGIS_blended_overlay (/usr/include/GL/glxext.h:245)
# SGIS_shared_multisample (/usr/include/GL/glxext.h:249)
# SUN_get_transparent_index (/usr/include/GL/glxext.h:254)
# 3DFX_multisample (/usr/include/GL/glxext.h:257)
# MESA_copy_sub_buffer (/usr/include/GL/glxext.h:262)
# MESA_pixmap_colormap (/usr/include/GL/glxext.h:265)
# MESA_release_buffers (/usr/include/GL/glxext.h:268)
# MESA_set_3dfx_mode (/usr/include/GL/glxext.h:271)
# SGIX_visual_select_group (/usr/include/GL/glxext.h:276)
# OML_swap_method (/usr/include/GL/glxext.h:280)
# OML_sync_control (/usr/include/GL/glxext.h:287)
# NV_float_buffer (/usr/include/GL/glxext.h:290)
# SGIX_hyperpipe (/usr/include/GL/glxext.h:294)
# MESA_agp_offset (/usr/include/GL/glxext.h:307)
# ARB_get_proc_address (/usr/include/GL/glxext.h:313)
# SGIX_video_source (/usr/include/GL/glxext.h:317)
# SGIX_fbconfig (/usr/include/GL/glxext.h:321)
# SGIX_pbuffer (/usr/include/GL/glxext.h:326)
# VERSION_1_3 (/usr/include/GL/glxext.h:358)
# VERSION_1_4 (/usr/include/GL/glxext.h:400)
# ARB_get_proc_address (/usr/include/GL/glxext.h:408)
# ARB_multisample (/usr/include/GL/glxext.h:416)
# ARB_fbconfig_float (/usr/include/GL/glxext.h:420)
# SGIS_multisample (/usr/include/GL/glxext.h:424)
# EXT_visual_info (/usr/include/GL/glxext.h:428)
# SGI_swap_control (/usr/include/GL/glxext.h:432)
# SGI_video_sync (/usr/include/GL/glxext.h:440)
# SGI_make_current_read (/usr/include/GL/glxext.h:450)
# SGIX_video_source (/usr/include/GL/glxext.h:460)
# EXT_visual_rating (/usr/include/GL/glxext.h:472)
# EXT_import_context (/usr/include/GL/glxext.h:476)
# SGIX_fbconfig (/usr/include/GL/glxext.h:492)
# SGIX_pbuffer (/usr/include/GL/glxext.h:510)
# SGI_cushion (/usr/include/GL/glxext.h:526)
# SGIX_video_resize (/usr/include/GL/glxext.h:534)
# SGIX_dmbuffer (/usr/include/GL/glxext.h:550)
# SGIX_swap_group (/usr/include/GL/glxext.h:560)
# SGIX_swap_barrier (/usr/include/GL/glxext.h:568)
# SUN_get_transparent_index (/usr/include/GL/glxext.h:578)
# MESA_copy_sub_buffer (/usr/include/GL/glxext.h:586)
# MESA_pixmap_colormap (/usr/include/GL/glxext.h:594)
# MESA_release_buffers (/usr/include/GL/glxext.h:602)
# MESA_set_3dfx_mode (/usr/include/GL/glxext.h:610)
# SGIX_visual_select_group (/usr/include/GL/glxext.h:618)
# OML_swap_method (/usr/include/GL/glxext.h:622)
# OML_sync_control (/usr/include/GL/glxext.h:626)
# NV_float_buffer (/usr/include/GL/glxext.h:642)
# SGIX_hyperpipe (/usr/include/GL/glxext.h:646)
# MESA_agp_offset (/usr/include/GL/glxext.h:693)

__all__ = ['GLX_USE_GL', 'GLX_BUFFER_SIZE', 'GLX_LEVEL', 'GLX_RGBA',
'GLX_DOUBLEBUFFER', 'GLX_STEREO', 'GLX_AUX_BUFFERS', 'GLX_RED_SIZE',
'GLX_GREEN_SIZE', 'GLX_BLUE_SIZE', 'GLX_ALPHA_SIZE', 'GLX_DEPTH_SIZE',
'GLX_STENCIL_SIZE', 'GLX_ACCUM_RED_SIZE', 'GLX_ACCUM_GREEN_SIZE',
'GLX_ACCUM_BLUE_SIZE', 'GLX_ACCUM_ALPHA_SIZE', 'GLX_BAD_SCREEN',
'GLX_BAD_ATTRIBUTE', 'GLX_NO_EXTENSION', 'GLX_BAD_VISUAL', 'GLX_BAD_CONTEXT',
'GLX_BAD_VALUE', 'GLX_BAD_ENUM', 'GLX_VENDOR', 'GLX_VERSION',
'GLX_EXTENSIONS', 'GLX_WINDOW_BIT', 'GLX_PIXMAP_BIT', 'GLX_PBUFFER_BIT',
'GLX_RGBA_BIT', 'GLX_COLOR_INDEX_BIT', 'GLX_PBUFFER_CLOBBER_MASK',
'GLX_FRONT_LEFT_BUFFER_BIT', 'GLX_FRONT_RIGHT_BUFFER_BIT',
'GLX_BACK_LEFT_BUFFER_BIT', 'GLX_BACK_RIGHT_BUFFER_BIT',
'GLX_AUX_BUFFERS_BIT', 'GLX_DEPTH_BUFFER_BIT', 'GLX_STENCIL_BUFFER_BIT',
'GLX_ACCUM_BUFFER_BIT', 'GLX_CONFIG_CAVEAT', 'GLX_X_VISUAL_TYPE',
'GLX_TRANSPARENT_TYPE', 'GLX_TRANSPARENT_INDEX_VALUE',
'GLX_TRANSPARENT_RED_VALUE', 'GLX_TRANSPARENT_GREEN_VALUE',
'GLX_TRANSPARENT_BLUE_VALUE', 'GLX_TRANSPARENT_ALPHA_VALUE', 'GLX_DONT_CARE',
'GLX_NONE', 'GLX_SLOW_CONFIG', 'GLX_TRUE_COLOR', 'GLX_DIRECT_COLOR',
'GLX_PSEUDO_COLOR', 'GLX_STATIC_COLOR', 'GLX_GRAY_SCALE', 'GLX_STATIC_GRAY',
'GLX_TRANSPARENT_RGB', 'GLX_TRANSPARENT_INDEX', 'GLX_VISUAL_ID', 'GLX_SCREEN',
'GLX_NON_CONFORMANT_CONFIG', 'GLX_DRAWABLE_TYPE', 'GLX_RENDER_TYPE',
'GLX_X_RENDERABLE', 'GLX_FBCONFIG_ID', 'GLX_RGBA_TYPE',
'GLX_COLOR_INDEX_TYPE', 'GLX_MAX_PBUFFER_WIDTH', 'GLX_MAX_PBUFFER_HEIGHT',
'GLX_MAX_PBUFFER_PIXELS', 'GLX_PRESERVED_CONTENTS', 'GLX_LARGEST_PBUFFER',
'GLX_WIDTH', 'GLX_HEIGHT', 'GLX_EVENT_MASK', 'GLX_DAMAGED', 'GLX_SAVED',
'GLX_WINDOW', 'GLX_PBUFFER', 'GLX_PBUFFER_HEIGHT', 'GLX_PBUFFER_WIDTH',
'GLX_SAMPLE_BUFFERS', 'GLX_SAMPLES', '__GLXextFuncPtr', 'GLXContextID',
'GLXPixmap', 'GLXDrawable', 'GLXPbuffer', 'GLXPbufferSGIX', 'GLXWindow',
'GLXFBConfigID', 'GLXContext', 'GLXFBConfig', 'glXChooseVisual',
'glXCopyContext', 'glXCreateContext', 'glXCreateGLXPixmap',
'glXDestroyContext', 'glXDestroyGLXPixmap', 'glXGetConfig',
'glXGetCurrentContext', 'glXGetCurrentDrawable', 'glXIsDirect',
'glXMakeCurrent', 'glXQueryExtension', 'glXQueryVersion', 'glXSwapBuffers',
'glXUseXFont', 'glXWaitGL', 'glXWaitX', 'GLX_VERSION_1_1',
'glXGetClientString', 'glXQueryServerString', 'glXQueryExtensionsString',
'GLX_VERSION_1_2', 'glXGetCurrentDisplay', 'GLX_VERSION_1_3',
'glXChooseFBConfig', 'glXCreateNewContext', 'glXCreatePbuffer',
'glXCreatePixmap', 'glXCreateWindow', 'glXDestroyPbuffer', 'glXDestroyPixmap',
'glXDestroyWindow', 'glXGetCurrentReadDrawable', 'glXGetFBConfigAttrib',
'glXGetFBConfigs', 'glXGetSelectedEvent', 'glXGetVisualFromFBConfig',
'glXMakeContextCurrent', 'glXQueryContext', 'glXQueryDrawable',
'glXSelectEvent', 'PFNGLXGETFBCONFIGSPROC', 'PFNGLXCHOOSEFBCONFIGPROC',
'PFNGLXGETFBCONFIGATTRIBPROC', 'PFNGLXGETVISUALFROMFBCONFIGPROC',
'PFNGLXCREATEWINDOWPROC', 'PFNGLXDESTROYWINDOWPROC', 'PFNGLXCREATEPIXMAPPROC',
'PFNGLXDESTROYPIXMAPPROC', 'PFNGLXCREATEPBUFFERPROC',
'PFNGLXDESTROYPBUFFERPROC', 'PFNGLXQUERYDRAWABLEPROC',
'PFNGLXCREATENEWCONTEXTPROC', 'PFNGLXMAKECONTEXTCURRENTPROC',
'PFNGLXGETCURRENTREADDRAWABLEPROC', 'PFNGLXGETCURRENTDISPLAYPROC',
'PFNGLXQUERYCONTEXTPROC', 'PFNGLXSELECTEVENTPROC',
'PFNGLXGETSELECTEDEVENTPROC', 'GLX_VERSION_1_4', 'glXGetProcAddress',
'PFNGLXGETPROCADDRESSPROC', 'GLX_ARB_get_proc_address',
'glXGetProcAddressARB', 'PFNGLXGETPROCADDRESSARBPROC',
'GLXPbufferClobberEvent', 'GLXEvent']
# END GENERATED CONTENT (do not edit above this line)

# From glxproto.h
GLXBadContext = 0
GLXBadContextState = 1
GLXBadDrawable = 2
GLXBadPixmap = 3
GLXBadContextTag = 4
GLXBadCurrentWindow = 5
GLXBadRenderRequest = 6
GLXBadLargeRequest = 7
GLXUnsupportedPrivateRequest = 8
GLXBadFBConfig = 9
GLXBadPbuffer = 10
GLXBadCurrentDrawable = 11
GLXBadWindow = 12

__all__ += ['GLXBadContext', 'GLXBadContextState', 'GLXBadDrawable',
'GLXBadPixmap', 'GLXBadContextTag', 'GLXBadCurrentWindow',
'GLXBadRenderRequest', 'GLXBadLargeRequest', 'GLXUnsupportedPrivateRequest',
'GLXBadFBConfig', 'GLXBadPbuffer', 'GLXBadCurrentDrawable', 'GLXBadWindow']




########NEW FILE########
__FILENAME__ = glxext_arb
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for http://oss.sgi.com/projects/ogl-sample/ABI/glxext.h

Generated by tools/gengl.py.
Do not modify this file.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: glxext_arb.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

import ctypes
from ctypes import *
from pyglet.gl.lib import link_GLX as _link_function
from pyglet.gl.lib import c_ptrdiff_t

if not hasattr(ctypes, 'c_int64'):
    # XXX TODO completely wrong, but at least can import.
    # Can c_longlong still be used?
    c_int64 = c_long
    c_uint64 = c_ulong

# BEGIN GENERATED CONTENT (do not edit below this line)

# This content is generated by tools/gengl.py.
# Wrapper for http://oss.sgi.com/projects/ogl-sample/ABI/glxext.h


# VERSION_1_3 (/usr/include/GL/glx.h:73)
# VERSION_1_4 (/usr/include/GL/glx.h:132)
# ARB_get_proc_address (/usr/include/GL/glx.h:137)
# VERSION_1_1 (/usr/include/GL/glx.h:209)
# VERSION_1_2 (/usr/include/GL/glx.h:222)
# VERSION_1_3 (/usr/include/GL/glx.h:230)
# VERSION_1_4 (/usr/include/GL/glx.h:302)
# ARB_get_proc_address (/usr/include/GL/glx.h:318)
# GLXEXT_LEGACY (/usr/include/GL/glx.h:350)
GLAPI = 0 	# GL/glxext.h:49
GLX_GLXEXT_VERSION = 11 	# GL/glxext.h:57
# VERSION_1_3 (GL/glxext.h:59)
# VERSION_1_4 (GL/glxext.h:118)
# ARB_get_proc_address (GL/glxext.h:123)
# ARB_multisample (GL/glxext.h:126)
GLX_SAMPLE_BUFFERS_ARB = 100000 	# GL/glxext.h:127
GLX_SAMPLES_ARB = 100001 	# GL/glxext.h:128
# ARB_fbconfig_float (GL/glxext.h:131)
GLX_RGBA_FLOAT_TYPE_ARB = 8377 	# GL/glxext.h:132
GLX_RGBA_FLOAT_BIT_ARB = 4 	# GL/glxext.h:133
# SGIS_multisample (GL/glxext.h:136)
GLX_SAMPLE_BUFFERS_SGIS = 100000 	# GL/glxext.h:137
GLX_SAMPLES_SGIS = 100001 	# GL/glxext.h:138
# EXT_visual_info (GL/glxext.h:141)
GLX_X_VISUAL_TYPE_EXT = 34 	# GL/glxext.h:142
GLX_TRANSPARENT_TYPE_EXT = 35 	# GL/glxext.h:143
GLX_TRANSPARENT_INDEX_VALUE_EXT = 36 	# GL/glxext.h:144
GLX_TRANSPARENT_RED_VALUE_EXT = 37 	# GL/glxext.h:145
GLX_TRANSPARENT_GREEN_VALUE_EXT = 38 	# GL/glxext.h:146
GLX_TRANSPARENT_BLUE_VALUE_EXT = 39 	# GL/glxext.h:147
GLX_TRANSPARENT_ALPHA_VALUE_EXT = 40 	# GL/glxext.h:148
GLX_NONE_EXT = 32768 	# GL/glxext.h:149
GLX_TRUE_COLOR_EXT = 32770 	# GL/glxext.h:150
GLX_DIRECT_COLOR_EXT = 32771 	# GL/glxext.h:151
GLX_PSEUDO_COLOR_EXT = 32772 	# GL/glxext.h:152
GLX_STATIC_COLOR_EXT = 32773 	# GL/glxext.h:153
GLX_GRAY_SCALE_EXT = 32774 	# GL/glxext.h:154
GLX_STATIC_GRAY_EXT = 32775 	# GL/glxext.h:155
GLX_TRANSPARENT_RGB_EXT = 32776 	# GL/glxext.h:156
GLX_TRANSPARENT_INDEX_EXT = 32777 	# GL/glxext.h:157
# SGI_swap_control (GL/glxext.h:160)
# SGI_video_sync (GL/glxext.h:163)
# SGI_make_current_read (GL/glxext.h:166)
# SGIX_video_source (GL/glxext.h:169)
# EXT_visual_rating (GL/glxext.h:172)
GLX_VISUAL_CAVEAT_EXT = 32 	# GL/glxext.h:173
GLX_SLOW_VISUAL_EXT = 32769 	# GL/glxext.h:174
GLX_NON_CONFORMANT_VISUAL_EXT = 32781 	# GL/glxext.h:175
# EXT_import_context (GL/glxext.h:179)
GLX_SHARE_CONTEXT_EXT = 32778 	# GL/glxext.h:180
GLX_VISUAL_ID_EXT = 32779 	# GL/glxext.h:181
GLX_SCREEN_EXT = 32780 	# GL/glxext.h:182
# SGIX_fbconfig (GL/glxext.h:185)
GLX_WINDOW_BIT_SGIX = 1 	# GL/glxext.h:186
GLX_PIXMAP_BIT_SGIX = 2 	# GL/glxext.h:187
GLX_RGBA_BIT_SGIX = 1 	# GL/glxext.h:188
GLX_COLOR_INDEX_BIT_SGIX = 2 	# GL/glxext.h:189
GLX_DRAWABLE_TYPE_SGIX = 32784 	# GL/glxext.h:190
GLX_RENDER_TYPE_SGIX = 32785 	# GL/glxext.h:191
GLX_X_RENDERABLE_SGIX = 32786 	# GL/glxext.h:192
GLX_FBCONFIG_ID_SGIX = 32787 	# GL/glxext.h:193
GLX_RGBA_TYPE_SGIX = 32788 	# GL/glxext.h:194
GLX_COLOR_INDEX_TYPE_SGIX = 32789 	# GL/glxext.h:195
# SGIX_pbuffer (GL/glxext.h:199)
GLX_PBUFFER_BIT_SGIX = 4 	# GL/glxext.h:200
GLX_BUFFER_CLOBBER_MASK_SGIX = 134217728 	# GL/glxext.h:201
GLX_FRONT_LEFT_BUFFER_BIT_SGIX = 1 	# GL/glxext.h:202
GLX_FRONT_RIGHT_BUFFER_BIT_SGIX = 2 	# GL/glxext.h:203
GLX_BACK_LEFT_BUFFER_BIT_SGIX = 4 	# GL/glxext.h:204
GLX_BACK_RIGHT_BUFFER_BIT_SGIX = 8 	# GL/glxext.h:205
GLX_AUX_BUFFERS_BIT_SGIX = 16 	# GL/glxext.h:206
GLX_DEPTH_BUFFER_BIT_SGIX = 32 	# GL/glxext.h:207
GLX_STENCIL_BUFFER_BIT_SGIX = 64 	# GL/glxext.h:208
GLX_ACCUM_BUFFER_BIT_SGIX = 128 	# GL/glxext.h:209
GLX_SAMPLE_BUFFERS_BIT_SGIX = 256 	# GL/glxext.h:210
GLX_MAX_PBUFFER_WIDTH_SGIX = 32790 	# GL/glxext.h:211
GLX_MAX_PBUFFER_HEIGHT_SGIX = 32791 	# GL/glxext.h:212
GLX_MAX_PBUFFER_PIXELS_SGIX = 32792 	# GL/glxext.h:213
GLX_OPTIMAL_PBUFFER_WIDTH_SGIX = 32793 	# GL/glxext.h:214
GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX = 32794 	# GL/glxext.h:215
GLX_PRESERVED_CONTENTS_SGIX = 32795 	# GL/glxext.h:216
GLX_LARGEST_PBUFFER_SGIX = 32796 	# GL/glxext.h:217
GLX_WIDTH_SGIX = 32797 	# GL/glxext.h:218
GLX_HEIGHT_SGIX = 32798 	# GL/glxext.h:219
GLX_EVENT_MASK_SGIX = 32799 	# GL/glxext.h:220
GLX_DAMAGED_SGIX = 32800 	# GL/glxext.h:221
GLX_SAVED_SGIX = 32801 	# GL/glxext.h:222
GLX_WINDOW_SGIX = 32802 	# GL/glxext.h:223
GLX_PBUFFER_SGIX = 32803 	# GL/glxext.h:224
# SGI_cushion (GL/glxext.h:227)
# SGIX_video_resize (GL/glxext.h:230)
GLX_SYNC_FRAME_SGIX = 0 	# GL/glxext.h:231
GLX_SYNC_SWAP_SGIX = 1 	# GL/glxext.h:232
# SGIX_dmbuffer (GL/glxext.h:235)
GLX_DIGITAL_MEDIA_PBUFFER_SGIX = 32804 	# GL/glxext.h:236
# SGIX_swap_group (GL/glxext.h:239)
# SGIX_swap_barrier (GL/glxext.h:242)
# SGIS_blended_overlay (GL/glxext.h:245)
GLX_BLENDED_RGBA_SGIS = 32805 	# GL/glxext.h:246
# SGIS_shared_multisample (GL/glxext.h:249)
GLX_MULTISAMPLE_SUB_RECT_WIDTH_SGIS = 32806 	# GL/glxext.h:250
GLX_MULTISAMPLE_SUB_RECT_HEIGHT_SGIS = 32807 	# GL/glxext.h:251
# SUN_get_transparent_index (GL/glxext.h:254)
# 3DFX_multisample (GL/glxext.h:257)
GLX_SAMPLE_BUFFERS_3DFX = 32848 	# GL/glxext.h:258
GLX_SAMPLES_3DFX = 32849 	# GL/glxext.h:259
# MESA_copy_sub_buffer (GL/glxext.h:262)
# MESA_pixmap_colormap (GL/glxext.h:265)
# MESA_release_buffers (GL/glxext.h:268)
# MESA_set_3dfx_mode (GL/glxext.h:271)
GLX_3DFX_WINDOW_MODE_MESA = 1 	# GL/glxext.h:272
GLX_3DFX_FULLSCREEN_MODE_MESA = 2 	# GL/glxext.h:273
# SGIX_visual_select_group (GL/glxext.h:276)
GLX_VISUAL_SELECT_GROUP_SGIX = 32808 	# GL/glxext.h:277
# OML_swap_method (GL/glxext.h:280)
GLX_SWAP_METHOD_OML = 32864 	# GL/glxext.h:281
GLX_SWAP_EXCHANGE_OML = 32865 	# GL/glxext.h:282
GLX_SWAP_COPY_OML = 32866 	# GL/glxext.h:283
GLX_SWAP_UNDEFINED_OML = 32867 	# GL/glxext.h:284
# OML_sync_control (GL/glxext.h:287)
# NV_float_buffer (GL/glxext.h:290)
GLX_FLOAT_COMPONENTS_NV = 8368 	# GL/glxext.h:291
# SGIX_hyperpipe (GL/glxext.h:294)
GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX = 80 	# GL/glxext.h:295
GLX_BAD_HYPERPIPE_CONFIG_SGIX = 91 	# GL/glxext.h:296
GLX_BAD_HYPERPIPE_SGIX = 92 	# GL/glxext.h:297
GLX_HYPERPIPE_DISPLAY_PIPE_SGIX = 1 	# GL/glxext.h:298
GLX_HYPERPIPE_RENDER_PIPE_SGIX = 2 	# GL/glxext.h:299
GLX_PIPE_RECT_SGIX = 1 	# GL/glxext.h:300
GLX_PIPE_RECT_LIMITS_SGIX = 2 	# GL/glxext.h:301
GLX_HYPERPIPE_STEREO_SGIX = 3 	# GL/glxext.h:302
GLX_HYPERPIPE_PIXEL_AVERAGE_SGIX = 4 	# GL/glxext.h:303
GLX_HYPERPIPE_ID_SGIX = 32816 	# GL/glxext.h:304
# MESA_agp_offset (GL/glxext.h:307)
# ARB_get_proc_address (GL/glxext.h:313)
# SGIX_video_source (GL/glxext.h:317)
XID = c_ulong 	# /usr/include/X11/X.h:71
GLXVideoSourceSGIX = XID 	# GL/glxext.h:318
# SGIX_fbconfig (GL/glxext.h:321)
GLXFBConfigIDSGIX = XID 	# GL/glxext.h:322
class struct___GLXFBConfigRec(Structure):
    __slots__ = [
    ]
struct___GLXFBConfigRec._fields_ = [
    ('_opaque_struct', c_int)
]

GLXFBConfigSGIX = POINTER(struct___GLXFBConfigRec) 	# GL/glxext.h:323
# SGIX_pbuffer (GL/glxext.h:326)
class struct_anon_199(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'drawable',
        'event_type',
        'draw_type',
        'mask',
        'x',
        'y',
        'width',
        'height',
        'count',
    ]
class struct__XDisplay(Structure):
    __slots__ = [
    ]
struct__XDisplay._fields_ = [
    ('_opaque_struct', c_int)
]

Display = struct__XDisplay 	# /usr/include/X11/Xlib.h:519
GLXDrawable = XID 	# /usr/include/GL/glx.h:146
struct_anon_199._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('drawable', GLXDrawable),
    ('event_type', c_int),
    ('draw_type', c_int),
    ('mask', c_uint),
    ('x', c_int),
    ('y', c_int),
    ('width', c_int),
    ('height', c_int),
    ('count', c_int),
]

GLXBufferClobberEventSGIX = struct_anon_199 	# GL/glxext.h:340
# VERSION_1_3 (GL/glxext.h:358)
# VERSION_1_4 (GL/glxext.h:400)
# ARB_get_proc_address (GL/glxext.h:408)
# ARB_multisample (GL/glxext.h:416)
GLX_ARB_multisample = 1 	# GL/glxext.h:417
# ARB_fbconfig_float (GL/glxext.h:420)
GLX_ARB_fbconfig_float = 1 	# GL/glxext.h:421
# SGIS_multisample (GL/glxext.h:424)
GLX_SGIS_multisample = 1 	# GL/glxext.h:425
# EXT_visual_info (GL/glxext.h:428)
GLX_EXT_visual_info = 1 	# GL/glxext.h:429
# SGI_swap_control (GL/glxext.h:432)
GLX_SGI_swap_control = 1 	# GL/glxext.h:433
# GL/glxext.h:435
glXSwapIntervalSGI = _link_function('glXSwapIntervalSGI', c_int, [c_int], 'SGI_swap_control')

PFNGLXSWAPINTERVALSGIPROC = CFUNCTYPE(c_int, c_int) 	# GL/glxext.h:437
# SGI_video_sync (GL/glxext.h:440)
GLX_SGI_video_sync = 1 	# GL/glxext.h:441
# GL/glxext.h:443
glXGetVideoSyncSGI = _link_function('glXGetVideoSyncSGI', c_int, [POINTER(c_uint)], 'SGI_video_sync')

# GL/glxext.h:444
glXWaitVideoSyncSGI = _link_function('glXWaitVideoSyncSGI', c_int, [c_int, c_int, POINTER(c_uint)], 'SGI_video_sync')

PFNGLXGETVIDEOSYNCSGIPROC = CFUNCTYPE(c_int, POINTER(c_uint)) 	# GL/glxext.h:446
PFNGLXWAITVIDEOSYNCSGIPROC = CFUNCTYPE(c_int, c_int, c_int, POINTER(c_uint)) 	# GL/glxext.h:447
# SGI_make_current_read (GL/glxext.h:450)
GLX_SGI_make_current_read = 1 	# GL/glxext.h:451
class struct___GLXcontextRec(Structure):
    __slots__ = [
    ]
struct___GLXcontextRec._fields_ = [
    ('_opaque_struct', c_int)
]

GLXContext = POINTER(struct___GLXcontextRec) 	# /usr/include/GL/glx.h:155
# GL/glxext.h:453
glXMakeCurrentReadSGI = _link_function('glXMakeCurrentReadSGI', c_int, [POINTER(Display), GLXDrawable, GLXDrawable, GLXContext], 'SGI_make_current_read')

# GL/glxext.h:454
glXGetCurrentReadDrawableSGI = _link_function('glXGetCurrentReadDrawableSGI', GLXDrawable, [], 'SGI_make_current_read')

PFNGLXMAKECURRENTREADSGIPROC = CFUNCTYPE(c_int, POINTER(Display), GLXDrawable, GLXDrawable, GLXContext) 	# GL/glxext.h:456
PFNGLXGETCURRENTREADDRAWABLESGIPROC = CFUNCTYPE(GLXDrawable) 	# GL/glxext.h:457
# SGIX_video_source (GL/glxext.h:460)
GLX_SGIX_video_source = 1 	# GL/glxext.h:461
# EXT_visual_rating (GL/glxext.h:472)
GLX_EXT_visual_rating = 1 	# GL/glxext.h:473
# EXT_import_context (GL/glxext.h:476)
GLX_EXT_import_context = 1 	# GL/glxext.h:477
# GL/glxext.h:479
glXGetCurrentDisplayEXT = _link_function('glXGetCurrentDisplayEXT', POINTER(Display), [], 'EXT_import_context')

# GL/glxext.h:480
glXQueryContextInfoEXT = _link_function('glXQueryContextInfoEXT', c_int, [POINTER(Display), GLXContext, c_int, POINTER(c_int)], 'EXT_import_context')

GLXContextID = XID 	# /usr/include/GL/glx.h:144
# GL/glxext.h:481
glXGetContextIDEXT = _link_function('glXGetContextIDEXT', GLXContextID, [GLXContext], 'EXT_import_context')

# GL/glxext.h:482
glXImportContextEXT = _link_function('glXImportContextEXT', GLXContext, [POINTER(Display), GLXContextID], 'EXT_import_context')

# GL/glxext.h:483
glXFreeContextEXT = _link_function('glXFreeContextEXT', None, [POINTER(Display), GLXContext], 'EXT_import_context')

PFNGLXGETCURRENTDISPLAYEXTPROC = CFUNCTYPE(POINTER(Display)) 	# GL/glxext.h:485
PFNGLXQUERYCONTEXTINFOEXTPROC = CFUNCTYPE(c_int, POINTER(Display), GLXContext, c_int, POINTER(c_int)) 	# GL/glxext.h:486
PFNGLXGETCONTEXTIDEXTPROC = CFUNCTYPE(GLXContextID, GLXContext) 	# GL/glxext.h:487
PFNGLXIMPORTCONTEXTEXTPROC = CFUNCTYPE(GLXContext, POINTER(Display), GLXContextID) 	# GL/glxext.h:488
PFNGLXFREECONTEXTEXTPROC = CFUNCTYPE(None, POINTER(Display), GLXContext) 	# GL/glxext.h:489
# SGIX_fbconfig (GL/glxext.h:492)
GLX_SGIX_fbconfig = 1 	# GL/glxext.h:493
# GL/glxext.h:495
glXGetFBConfigAttribSGIX = _link_function('glXGetFBConfigAttribSGIX', c_int, [POINTER(Display), GLXFBConfigSGIX, c_int, POINTER(c_int)], 'SGIX_fbconfig')

# GL/glxext.h:496
glXChooseFBConfigSGIX = _link_function('glXChooseFBConfigSGIX', POINTER(GLXFBConfigSGIX), [POINTER(Display), c_int, POINTER(c_int), POINTER(c_int)], 'SGIX_fbconfig')

GLXPixmap = XID 	# /usr/include/GL/glx.h:145
Pixmap = XID 	# /usr/include/X11/X.h:107
# GL/glxext.h:497
glXCreateGLXPixmapWithConfigSGIX = _link_function('glXCreateGLXPixmapWithConfigSGIX', GLXPixmap, [POINTER(Display), GLXFBConfigSGIX, Pixmap], 'SGIX_fbconfig')

# GL/glxext.h:498
glXCreateContextWithConfigSGIX = _link_function('glXCreateContextWithConfigSGIX', GLXContext, [POINTER(Display), GLXFBConfigSGIX, c_int, GLXContext, c_int], 'SGIX_fbconfig')

class struct_anon_196(Structure):
    __slots__ = [
        'visual',
        'visualid',
        'screen',
        'depth',
        'class',
        'red_mask',
        'green_mask',
        'blue_mask',
        'colormap_size',
        'bits_per_rgb',
    ]
class struct_anon_113(Structure):
    __slots__ = [
        'ext_data',
        'visualid',
        'class',
        'red_mask',
        'green_mask',
        'blue_mask',
        'bits_per_rgb',
        'map_entries',
    ]
class struct__XExtData(Structure):
    __slots__ = [
        'number',
        'next',
        'free_private',
        'private_data',
    ]
XPointer = c_char_p 	# /usr/include/X11/Xlib.h:108
struct__XExtData._fields_ = [
    ('number', c_int),
    ('next', POINTER(struct__XExtData)),
    ('free_private', POINTER(CFUNCTYPE(c_int, POINTER(struct__XExtData)))),
    ('private_data', XPointer),
]

XExtData = struct__XExtData 	# /usr/include/X11/Xlib.h:187
VisualID = c_ulong 	# /usr/include/X11/X.h:81
struct_anon_113._fields_ = [
    ('ext_data', POINTER(XExtData)),
    ('visualid', VisualID),
    ('class', c_int),
    ('red_mask', c_ulong),
    ('green_mask', c_ulong),
    ('blue_mask', c_ulong),
    ('bits_per_rgb', c_int),
    ('map_entries', c_int),
]

Visual = struct_anon_113 	# /usr/include/X11/Xlib.h:270
struct_anon_196._fields_ = [
    ('visual', POINTER(Visual)),
    ('visualid', VisualID),
    ('screen', c_int),
    ('depth', c_int),
    ('class', c_int),
    ('red_mask', c_ulong),
    ('green_mask', c_ulong),
    ('blue_mask', c_ulong),
    ('colormap_size', c_int),
    ('bits_per_rgb', c_int),
]

XVisualInfo = struct_anon_196 	# /usr/include/X11/Xutil.h:296
# GL/glxext.h:499
glXGetVisualFromFBConfigSGIX = _link_function('glXGetVisualFromFBConfigSGIX', POINTER(XVisualInfo), [POINTER(Display), GLXFBConfigSGIX], 'SGIX_fbconfig')

# GL/glxext.h:500
glXGetFBConfigFromVisualSGIX = _link_function('glXGetFBConfigFromVisualSGIX', GLXFBConfigSGIX, [POINTER(Display), POINTER(XVisualInfo)], 'SGIX_fbconfig')

PFNGLXGETFBCONFIGATTRIBSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), GLXFBConfigSGIX, c_int, POINTER(c_int)) 	# GL/glxext.h:502
PFNGLXCHOOSEFBCONFIGSGIXPROC = CFUNCTYPE(POINTER(GLXFBConfigSGIX), POINTER(Display), c_int, POINTER(c_int), POINTER(c_int)) 	# GL/glxext.h:503
PFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC = CFUNCTYPE(GLXPixmap, POINTER(Display), GLXFBConfigSGIX, Pixmap) 	# GL/glxext.h:504
PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC = CFUNCTYPE(GLXContext, POINTER(Display), GLXFBConfigSGIX, c_int, GLXContext, c_int) 	# GL/glxext.h:505
PFNGLXGETVISUALFROMFBCONFIGSGIXPROC = CFUNCTYPE(POINTER(XVisualInfo), POINTER(Display), GLXFBConfigSGIX) 	# GL/glxext.h:506
PFNGLXGETFBCONFIGFROMVISUALSGIXPROC = CFUNCTYPE(GLXFBConfigSGIX, POINTER(Display), POINTER(XVisualInfo)) 	# GL/glxext.h:507
# SGIX_pbuffer (GL/glxext.h:510)
GLX_SGIX_pbuffer = 1 	# GL/glxext.h:511
GLXPbufferSGIX = XID 	# /usr/include/GL/glx.h:148
# GL/glxext.h:513
glXCreateGLXPbufferSGIX = _link_function('glXCreateGLXPbufferSGIX', GLXPbufferSGIX, [POINTER(Display), GLXFBConfigSGIX, c_uint, c_uint, POINTER(c_int)], 'SGIX_pbuffer')

# GL/glxext.h:514
glXDestroyGLXPbufferSGIX = _link_function('glXDestroyGLXPbufferSGIX', None, [POINTER(Display), GLXPbufferSGIX], 'SGIX_pbuffer')

# GL/glxext.h:515
glXQueryGLXPbufferSGIX = _link_function('glXQueryGLXPbufferSGIX', c_int, [POINTER(Display), GLXPbufferSGIX, c_int, POINTER(c_uint)], 'SGIX_pbuffer')

# GL/glxext.h:516
glXSelectEventSGIX = _link_function('glXSelectEventSGIX', None, [POINTER(Display), GLXDrawable, c_ulong], 'SGIX_pbuffer')

# GL/glxext.h:517
glXGetSelectedEventSGIX = _link_function('glXGetSelectedEventSGIX', None, [POINTER(Display), GLXDrawable, POINTER(c_ulong)], 'SGIX_pbuffer')

PFNGLXCREATEGLXPBUFFERSGIXPROC = CFUNCTYPE(GLXPbufferSGIX, POINTER(Display), GLXFBConfigSGIX, c_uint, c_uint, POINTER(c_int)) 	# GL/glxext.h:519
PFNGLXDESTROYGLXPBUFFERSGIXPROC = CFUNCTYPE(None, POINTER(Display), GLXPbufferSGIX) 	# GL/glxext.h:520
PFNGLXQUERYGLXPBUFFERSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), GLXPbufferSGIX, c_int, POINTER(c_uint)) 	# GL/glxext.h:521
PFNGLXSELECTEVENTSGIXPROC = CFUNCTYPE(None, POINTER(Display), GLXDrawable, c_ulong) 	# GL/glxext.h:522
PFNGLXGETSELECTEDEVENTSGIXPROC = CFUNCTYPE(None, POINTER(Display), GLXDrawable, POINTER(c_ulong)) 	# GL/glxext.h:523
# SGI_cushion (GL/glxext.h:526)
GLX_SGI_cushion = 1 	# GL/glxext.h:527
Window = XID 	# /usr/include/X11/X.h:101
# GL/glxext.h:529
glXCushionSGI = _link_function('glXCushionSGI', None, [POINTER(Display), Window, c_float], 'SGI_cushion')

PFNGLXCUSHIONSGIPROC = CFUNCTYPE(None, POINTER(Display), Window, c_float) 	# GL/glxext.h:531
# SGIX_video_resize (GL/glxext.h:534)
GLX_SGIX_video_resize = 1 	# GL/glxext.h:535
# GL/glxext.h:537
glXBindChannelToWindowSGIX = _link_function('glXBindChannelToWindowSGIX', c_int, [POINTER(Display), c_int, c_int, Window], 'SGIX_video_resize')

# GL/glxext.h:538
glXChannelRectSGIX = _link_function('glXChannelRectSGIX', c_int, [POINTER(Display), c_int, c_int, c_int, c_int, c_int, c_int], 'SGIX_video_resize')

# GL/glxext.h:539
glXQueryChannelRectSGIX = _link_function('glXQueryChannelRectSGIX', c_int, [POINTER(Display), c_int, c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int)], 'SGIX_video_resize')

# GL/glxext.h:540
glXQueryChannelDeltasSGIX = _link_function('glXQueryChannelDeltasSGIX', c_int, [POINTER(Display), c_int, c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int)], 'SGIX_video_resize')

GLenum = c_uint 	# /usr/include/GL/gl.h:53
# GL/glxext.h:541
glXChannelRectSyncSGIX = _link_function('glXChannelRectSyncSGIX', c_int, [POINTER(Display), c_int, c_int, GLenum], 'SGIX_video_resize')

PFNGLXBINDCHANNELTOWINDOWSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, Window) 	# GL/glxext.h:543
PFNGLXCHANNELRECTSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, c_int, c_int, c_int, c_int) 	# GL/glxext.h:544
PFNGLXQUERYCHANNELRECTSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int)) 	# GL/glxext.h:545
PFNGLXQUERYCHANNELDELTASSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int)) 	# GL/glxext.h:546
PFNGLXCHANNELRECTSYNCSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, GLenum) 	# GL/glxext.h:547
# SGIX_dmbuffer (GL/glxext.h:550)
GLX_SGIX_dmbuffer = 1 	# GL/glxext.h:551
# SGIX_swap_group (GL/glxext.h:560)
GLX_SGIX_swap_group = 1 	# GL/glxext.h:561
# GL/glxext.h:563
glXJoinSwapGroupSGIX = _link_function('glXJoinSwapGroupSGIX', None, [POINTER(Display), GLXDrawable, GLXDrawable], 'SGIX_swap_group')

PFNGLXJOINSWAPGROUPSGIXPROC = CFUNCTYPE(None, POINTER(Display), GLXDrawable, GLXDrawable) 	# GL/glxext.h:565
# SGIX_swap_barrier (GL/glxext.h:568)
GLX_SGIX_swap_barrier = 1 	# GL/glxext.h:569
# GL/glxext.h:571
glXBindSwapBarrierSGIX = _link_function('glXBindSwapBarrierSGIX', None, [POINTER(Display), GLXDrawable, c_int], 'SGIX_swap_barrier')

# GL/glxext.h:572
glXQueryMaxSwapBarriersSGIX = _link_function('glXQueryMaxSwapBarriersSGIX', c_int, [POINTER(Display), c_int, POINTER(c_int)], 'SGIX_swap_barrier')

PFNGLXBINDSWAPBARRIERSGIXPROC = CFUNCTYPE(None, POINTER(Display), GLXDrawable, c_int) 	# GL/glxext.h:574
PFNGLXQUERYMAXSWAPBARRIERSSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, POINTER(c_int)) 	# GL/glxext.h:575
# SUN_get_transparent_index (GL/glxext.h:578)
GLX_SUN_get_transparent_index = 1 	# GL/glxext.h:579
# GL/glxext.h:581
glXGetTransparentIndexSUN = _link_function('glXGetTransparentIndexSUN', c_int, [POINTER(Display), Window, Window, POINTER(c_long)], 'SUN_get_transparent_index')

PFNGLXGETTRANSPARENTINDEXSUNPROC = CFUNCTYPE(c_int, POINTER(Display), Window, Window, POINTER(c_long)) 	# GL/glxext.h:583
# MESA_copy_sub_buffer (GL/glxext.h:586)
GLX_MESA_copy_sub_buffer = 1 	# GL/glxext.h:587
# GL/glxext.h:589
glXCopySubBufferMESA = _link_function('glXCopySubBufferMESA', None, [POINTER(Display), GLXDrawable, c_int, c_int, c_int, c_int], 'MESA_copy_sub_buffer')

PFNGLXCOPYSUBBUFFERMESAPROC = CFUNCTYPE(None, POINTER(Display), GLXDrawable, c_int, c_int, c_int, c_int) 	# GL/glxext.h:591
# MESA_pixmap_colormap (GL/glxext.h:594)
GLX_MESA_pixmap_colormap = 1 	# GL/glxext.h:595
Colormap = XID 	# /usr/include/X11/X.h:109
# GL/glxext.h:597
glXCreateGLXPixmapMESA = _link_function('glXCreateGLXPixmapMESA', GLXPixmap, [POINTER(Display), POINTER(XVisualInfo), Pixmap, Colormap], 'MESA_pixmap_colormap')

PFNGLXCREATEGLXPIXMAPMESAPROC = CFUNCTYPE(GLXPixmap, POINTER(Display), POINTER(XVisualInfo), Pixmap, Colormap) 	# GL/glxext.h:599
# MESA_release_buffers (GL/glxext.h:602)
GLX_MESA_release_buffers = 1 	# GL/glxext.h:603
# GL/glxext.h:605
glXReleaseBuffersMESA = _link_function('glXReleaseBuffersMESA', c_int, [POINTER(Display), GLXDrawable], 'MESA_release_buffers')

PFNGLXRELEASEBUFFERSMESAPROC = CFUNCTYPE(c_int, POINTER(Display), GLXDrawable) 	# GL/glxext.h:607
# MESA_set_3dfx_mode (GL/glxext.h:610)
GLX_MESA_set_3dfx_mode = 1 	# GL/glxext.h:611
# GL/glxext.h:613
glXSet3DfxModeMESA = _link_function('glXSet3DfxModeMESA', c_int, [c_int], 'MESA_set_3dfx_mode')

PFNGLXSET3DFXMODEMESAPROC = CFUNCTYPE(c_int, c_int) 	# GL/glxext.h:615
# SGIX_visual_select_group (GL/glxext.h:618)
GLX_SGIX_visual_select_group = 1 	# GL/glxext.h:619
# OML_swap_method (GL/glxext.h:622)
GLX_OML_swap_method = 1 	# GL/glxext.h:623
# OML_sync_control (GL/glxext.h:626)
GLX_OML_sync_control = 1 	# GL/glxext.h:627
# GL/glxext.h:629
glXGetSyncValuesOML = _link_function('glXGetSyncValuesOML', c_int, [POINTER(Display), GLXDrawable, POINTER(c_int64), POINTER(c_int64), POINTER(c_int64)], 'OML_sync_control')

# GL/glxext.h:630
glXGetMscRateOML = _link_function('glXGetMscRateOML', c_int, [POINTER(Display), GLXDrawable, POINTER(c_int32), POINTER(c_int32)], 'OML_sync_control')

# GL/glxext.h:631
glXSwapBuffersMscOML = _link_function('glXSwapBuffersMscOML', c_int64, [POINTER(Display), GLXDrawable, c_int64, c_int64, c_int64], 'OML_sync_control')

# GL/glxext.h:632
glXWaitForMscOML = _link_function('glXWaitForMscOML', c_int, [POINTER(Display), GLXDrawable, c_int64, c_int64, c_int64, POINTER(c_int64), POINTER(c_int64), POINTER(c_int64)], 'OML_sync_control')

# GL/glxext.h:633
glXWaitForSbcOML = _link_function('glXWaitForSbcOML', c_int, [POINTER(Display), GLXDrawable, c_int64, POINTER(c_int64), POINTER(c_int64), POINTER(c_int64)], 'OML_sync_control')

PFNGLXGETSYNCVALUESOMLPROC = CFUNCTYPE(c_int, POINTER(Display), GLXDrawable, POINTER(c_int64), POINTER(c_int64), POINTER(c_int64)) 	# GL/glxext.h:635
PFNGLXGETMSCRATEOMLPROC = CFUNCTYPE(c_int, POINTER(Display), GLXDrawable, POINTER(c_int32), POINTER(c_int32)) 	# GL/glxext.h:636
PFNGLXSWAPBUFFERSMSCOMLPROC = CFUNCTYPE(c_int64, POINTER(Display), GLXDrawable, c_int64, c_int64, c_int64) 	# GL/glxext.h:637
PFNGLXWAITFORMSCOMLPROC = CFUNCTYPE(c_int, POINTER(Display), GLXDrawable, c_int64, c_int64, c_int64, POINTER(c_int64), POINTER(c_int64), POINTER(c_int64)) 	# GL/glxext.h:638
PFNGLXWAITFORSBCOMLPROC = CFUNCTYPE(c_int, POINTER(Display), GLXDrawable, c_int64, POINTER(c_int64), POINTER(c_int64), POINTER(c_int64)) 	# GL/glxext.h:639
# NV_float_buffer (GL/glxext.h:642)
GLX_NV_float_buffer = 1 	# GL/glxext.h:643
# SGIX_hyperpipe (GL/glxext.h:646)
GLX_SGIX_hyperpipe = 1 	# GL/glxext.h:647
class struct_anon_201(Structure):
    __slots__ = [
        'pipeName',
        'networkId',
    ]
struct_anon_201._fields_ = [
    ('pipeName', c_char * 80),
    ('networkId', c_int),
]

GLXHyperpipeNetworkSGIX = struct_anon_201 	# GL/glxext.h:652
class struct_anon_202(Structure):
    __slots__ = [
        'pipeName',
        'channel',
        'participationType',
        'timeSlice',
    ]
struct_anon_202._fields_ = [
    ('pipeName', c_char * 80),
    ('channel', c_int),
    ('participationType', c_uint),
    ('timeSlice', c_int),
]

GLXHyperpipeConfigSGIX = struct_anon_202 	# GL/glxext.h:660
class struct_anon_203(Structure):
    __slots__ = [
        'pipeName',
        'srcXOrigin',
        'srcYOrigin',
        'srcWidth',
        'srcHeight',
        'destXOrigin',
        'destYOrigin',
        'destWidth',
        'destHeight',
    ]
struct_anon_203._fields_ = [
    ('pipeName', c_char * 80),
    ('srcXOrigin', c_int),
    ('srcYOrigin', c_int),
    ('srcWidth', c_int),
    ('srcHeight', c_int),
    ('destXOrigin', c_int),
    ('destYOrigin', c_int),
    ('destWidth', c_int),
    ('destHeight', c_int),
]

GLXPipeRect = struct_anon_203 	# GL/glxext.h:666
class struct_anon_204(Structure):
    __slots__ = [
        'pipeName',
        'XOrigin',
        'YOrigin',
        'maxHeight',
        'maxWidth',
    ]
struct_anon_204._fields_ = [
    ('pipeName', c_char * 80),
    ('XOrigin', c_int),
    ('YOrigin', c_int),
    ('maxHeight', c_int),
    ('maxWidth', c_int),
]

GLXPipeRectLimits = struct_anon_204 	# GL/glxext.h:671
# GL/glxext.h:674
glXQueryHyperpipeNetworkSGIX = _link_function('glXQueryHyperpipeNetworkSGIX', POINTER(GLXHyperpipeNetworkSGIX), [POINTER(Display), POINTER(c_int)], 'SGIX_hyperpipe')

# GL/glxext.h:675
glXHyperpipeConfigSGIX = _link_function('glXHyperpipeConfigSGIX', c_int, [POINTER(Display), c_int, c_int, POINTER(GLXHyperpipeConfigSGIX), POINTER(c_int)], 'SGIX_hyperpipe')

# GL/glxext.h:676
glXQueryHyperpipeConfigSGIX = _link_function('glXQueryHyperpipeConfigSGIX', POINTER(GLXHyperpipeConfigSGIX), [POINTER(Display), c_int, POINTER(c_int)], 'SGIX_hyperpipe')

# GL/glxext.h:677
glXDestroyHyperpipeConfigSGIX = _link_function('glXDestroyHyperpipeConfigSGIX', c_int, [POINTER(Display), c_int], 'SGIX_hyperpipe')

# GL/glxext.h:678
glXBindHyperpipeSGIX = _link_function('glXBindHyperpipeSGIX', c_int, [POINTER(Display), c_int], 'SGIX_hyperpipe')

# GL/glxext.h:679
glXQueryHyperpipeBestAttribSGIX = _link_function('glXQueryHyperpipeBestAttribSGIX', c_int, [POINTER(Display), c_int, c_int, c_int, POINTER(None), POINTER(None)], 'SGIX_hyperpipe')

# GL/glxext.h:680
glXHyperpipeAttribSGIX = _link_function('glXHyperpipeAttribSGIX', c_int, [POINTER(Display), c_int, c_int, c_int, POINTER(None)], 'SGIX_hyperpipe')

# GL/glxext.h:681
glXQueryHyperpipeAttribSGIX = _link_function('glXQueryHyperpipeAttribSGIX', c_int, [POINTER(Display), c_int, c_int, c_int, POINTER(None)], 'SGIX_hyperpipe')

PFNGLXQUERYHYPERPIPENETWORKSGIXPROC = CFUNCTYPE(POINTER(GLXHyperpipeNetworkSGIX), POINTER(Display), POINTER(c_int)) 	# GL/glxext.h:683
PFNGLXHYPERPIPECONFIGSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, POINTER(GLXHyperpipeConfigSGIX), POINTER(c_int)) 	# GL/glxext.h:684
PFNGLXQUERYHYPERPIPECONFIGSGIXPROC = CFUNCTYPE(POINTER(GLXHyperpipeConfigSGIX), POINTER(Display), c_int, POINTER(c_int)) 	# GL/glxext.h:685
PFNGLXDESTROYHYPERPIPECONFIGSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int) 	# GL/glxext.h:686
PFNGLXBINDHYPERPIPESGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int) 	# GL/glxext.h:687
PFNGLXQUERYHYPERPIPEBESTATTRIBSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, c_int, POINTER(None), POINTER(None)) 	# GL/glxext.h:688
PFNGLXHYPERPIPEATTRIBSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, c_int, POINTER(None)) 	# GL/glxext.h:689
PFNGLXQUERYHYPERPIPEATTRIBSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, c_int, POINTER(None)) 	# GL/glxext.h:690
# MESA_agp_offset (GL/glxext.h:693)
GLX_MESA_agp_offset = 1 	# GL/glxext.h:694
# GL/glxext.h:696
glXGetAGPOffsetMESA = _link_function('glXGetAGPOffsetMESA', c_uint, [POINTER(None)], 'MESA_agp_offset')

PFNGLXGETAGPOFFSETMESAPROC = CFUNCTYPE(c_uint, POINTER(None)) 	# GL/glxext.h:698

__all__ = ['GLAPI', 'GLX_GLXEXT_VERSION', 'GLX_SAMPLE_BUFFERS_ARB',
'GLX_SAMPLES_ARB', 'GLX_RGBA_FLOAT_TYPE_ARB', 'GLX_RGBA_FLOAT_BIT_ARB',
'GLX_SAMPLE_BUFFERS_SGIS', 'GLX_SAMPLES_SGIS', 'GLX_X_VISUAL_TYPE_EXT',
'GLX_TRANSPARENT_TYPE_EXT', 'GLX_TRANSPARENT_INDEX_VALUE_EXT',
'GLX_TRANSPARENT_RED_VALUE_EXT', 'GLX_TRANSPARENT_GREEN_VALUE_EXT',
'GLX_TRANSPARENT_BLUE_VALUE_EXT', 'GLX_TRANSPARENT_ALPHA_VALUE_EXT',
'GLX_NONE_EXT', 'GLX_TRUE_COLOR_EXT', 'GLX_DIRECT_COLOR_EXT',
'GLX_PSEUDO_COLOR_EXT', 'GLX_STATIC_COLOR_EXT', 'GLX_GRAY_SCALE_EXT',
'GLX_STATIC_GRAY_EXT', 'GLX_TRANSPARENT_RGB_EXT', 'GLX_TRANSPARENT_INDEX_EXT',
'GLX_VISUAL_CAVEAT_EXT', 'GLX_SLOW_VISUAL_EXT',
'GLX_NON_CONFORMANT_VISUAL_EXT', 'GLX_SHARE_CONTEXT_EXT', 'GLX_VISUAL_ID_EXT',
'GLX_SCREEN_EXT', 'GLX_WINDOW_BIT_SGIX', 'GLX_PIXMAP_BIT_SGIX',
'GLX_RGBA_BIT_SGIX', 'GLX_COLOR_INDEX_BIT_SGIX', 'GLX_DRAWABLE_TYPE_SGIX',
'GLX_RENDER_TYPE_SGIX', 'GLX_X_RENDERABLE_SGIX', 'GLX_FBCONFIG_ID_SGIX',
'GLX_RGBA_TYPE_SGIX', 'GLX_COLOR_INDEX_TYPE_SGIX', 'GLX_PBUFFER_BIT_SGIX',
'GLX_BUFFER_CLOBBER_MASK_SGIX', 'GLX_FRONT_LEFT_BUFFER_BIT_SGIX',
'GLX_FRONT_RIGHT_BUFFER_BIT_SGIX', 'GLX_BACK_LEFT_BUFFER_BIT_SGIX',
'GLX_BACK_RIGHT_BUFFER_BIT_SGIX', 'GLX_AUX_BUFFERS_BIT_SGIX',
'GLX_DEPTH_BUFFER_BIT_SGIX', 'GLX_STENCIL_BUFFER_BIT_SGIX',
'GLX_ACCUM_BUFFER_BIT_SGIX', 'GLX_SAMPLE_BUFFERS_BIT_SGIX',
'GLX_MAX_PBUFFER_WIDTH_SGIX', 'GLX_MAX_PBUFFER_HEIGHT_SGIX',
'GLX_MAX_PBUFFER_PIXELS_SGIX', 'GLX_OPTIMAL_PBUFFER_WIDTH_SGIX',
'GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX', 'GLX_PRESERVED_CONTENTS_SGIX',
'GLX_LARGEST_PBUFFER_SGIX', 'GLX_WIDTH_SGIX', 'GLX_HEIGHT_SGIX',
'GLX_EVENT_MASK_SGIX', 'GLX_DAMAGED_SGIX', 'GLX_SAVED_SGIX',
'GLX_WINDOW_SGIX', 'GLX_PBUFFER_SGIX', 'GLX_SYNC_FRAME_SGIX',
'GLX_SYNC_SWAP_SGIX', 'GLX_DIGITAL_MEDIA_PBUFFER_SGIX',
'GLX_BLENDED_RGBA_SGIS', 'GLX_MULTISAMPLE_SUB_RECT_WIDTH_SGIS',
'GLX_MULTISAMPLE_SUB_RECT_HEIGHT_SGIS', 'GLX_SAMPLE_BUFFERS_3DFX',
'GLX_SAMPLES_3DFX', 'GLX_3DFX_WINDOW_MODE_MESA',
'GLX_3DFX_FULLSCREEN_MODE_MESA', 'GLX_VISUAL_SELECT_GROUP_SGIX',
'GLX_SWAP_METHOD_OML', 'GLX_SWAP_EXCHANGE_OML', 'GLX_SWAP_COPY_OML',
'GLX_SWAP_UNDEFINED_OML', 'GLX_FLOAT_COMPONENTS_NV',
'GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX', 'GLX_BAD_HYPERPIPE_CONFIG_SGIX',
'GLX_BAD_HYPERPIPE_SGIX', 'GLX_HYPERPIPE_DISPLAY_PIPE_SGIX',
'GLX_HYPERPIPE_RENDER_PIPE_SGIX', 'GLX_PIPE_RECT_SGIX',
'GLX_PIPE_RECT_LIMITS_SGIX', 'GLX_HYPERPIPE_STEREO_SGIX',
'GLX_HYPERPIPE_PIXEL_AVERAGE_SGIX', 'GLX_HYPERPIPE_ID_SGIX',
'GLXVideoSourceSGIX', 'GLXFBConfigIDSGIX', 'GLXFBConfigSGIX',
'GLXBufferClobberEventSGIX', 'GLX_ARB_multisample', 'GLX_ARB_fbconfig_float',
'GLX_SGIS_multisample', 'GLX_EXT_visual_info', 'GLX_SGI_swap_control',
'glXSwapIntervalSGI', 'PFNGLXSWAPINTERVALSGIPROC', 'GLX_SGI_video_sync',
'glXGetVideoSyncSGI', 'glXWaitVideoSyncSGI', 'PFNGLXGETVIDEOSYNCSGIPROC',
'PFNGLXWAITVIDEOSYNCSGIPROC', 'GLX_SGI_make_current_read',
'glXMakeCurrentReadSGI', 'glXGetCurrentReadDrawableSGI',
'PFNGLXMAKECURRENTREADSGIPROC', 'PFNGLXGETCURRENTREADDRAWABLESGIPROC',
'GLX_SGIX_video_source', 'GLX_EXT_visual_rating', 'GLX_EXT_import_context',
'glXGetCurrentDisplayEXT', 'glXQueryContextInfoEXT', 'glXGetContextIDEXT',
'glXImportContextEXT', 'glXFreeContextEXT', 'PFNGLXGETCURRENTDISPLAYEXTPROC',
'PFNGLXQUERYCONTEXTINFOEXTPROC', 'PFNGLXGETCONTEXTIDEXTPROC',
'PFNGLXIMPORTCONTEXTEXTPROC', 'PFNGLXFREECONTEXTEXTPROC', 'GLX_SGIX_fbconfig',
'glXGetFBConfigAttribSGIX', 'glXChooseFBConfigSGIX',
'glXCreateGLXPixmapWithConfigSGIX', 'glXCreateContextWithConfigSGIX',
'glXGetVisualFromFBConfigSGIX', 'glXGetFBConfigFromVisualSGIX',
'PFNGLXGETFBCONFIGATTRIBSGIXPROC', 'PFNGLXCHOOSEFBCONFIGSGIXPROC',
'PFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC',
'PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC',
'PFNGLXGETVISUALFROMFBCONFIGSGIXPROC', 'PFNGLXGETFBCONFIGFROMVISUALSGIXPROC',
'GLX_SGIX_pbuffer', 'glXCreateGLXPbufferSGIX', 'glXDestroyGLXPbufferSGIX',
'glXQueryGLXPbufferSGIX', 'glXSelectEventSGIX', 'glXGetSelectedEventSGIX',
'PFNGLXCREATEGLXPBUFFERSGIXPROC', 'PFNGLXDESTROYGLXPBUFFERSGIXPROC',
'PFNGLXQUERYGLXPBUFFERSGIXPROC', 'PFNGLXSELECTEVENTSGIXPROC',
'PFNGLXGETSELECTEDEVENTSGIXPROC', 'GLX_SGI_cushion', 'glXCushionSGI',
'PFNGLXCUSHIONSGIPROC', 'GLX_SGIX_video_resize', 'glXBindChannelToWindowSGIX',
'glXChannelRectSGIX', 'glXQueryChannelRectSGIX', 'glXQueryChannelDeltasSGIX',
'glXChannelRectSyncSGIX', 'PFNGLXBINDCHANNELTOWINDOWSGIXPROC',
'PFNGLXCHANNELRECTSGIXPROC', 'PFNGLXQUERYCHANNELRECTSGIXPROC',
'PFNGLXQUERYCHANNELDELTASSGIXPROC', 'PFNGLXCHANNELRECTSYNCSGIXPROC',
'GLX_SGIX_dmbuffer', 'GLX_SGIX_swap_group', 'glXJoinSwapGroupSGIX',
'PFNGLXJOINSWAPGROUPSGIXPROC', 'GLX_SGIX_swap_barrier',
'glXBindSwapBarrierSGIX', 'glXQueryMaxSwapBarriersSGIX',
'PFNGLXBINDSWAPBARRIERSGIXPROC', 'PFNGLXQUERYMAXSWAPBARRIERSSGIXPROC',
'GLX_SUN_get_transparent_index', 'glXGetTransparentIndexSUN',
'PFNGLXGETTRANSPARENTINDEXSUNPROC', 'GLX_MESA_copy_sub_buffer',
'glXCopySubBufferMESA', 'PFNGLXCOPYSUBBUFFERMESAPROC',
'GLX_MESA_pixmap_colormap', 'glXCreateGLXPixmapMESA',
'PFNGLXCREATEGLXPIXMAPMESAPROC', 'GLX_MESA_release_buffers',
'glXReleaseBuffersMESA', 'PFNGLXRELEASEBUFFERSMESAPROC',
'GLX_MESA_set_3dfx_mode', 'glXSet3DfxModeMESA', 'PFNGLXSET3DFXMODEMESAPROC',
'GLX_SGIX_visual_select_group', 'GLX_OML_swap_method', 'GLX_OML_sync_control',
'glXGetSyncValuesOML', 'glXGetMscRateOML', 'glXSwapBuffersMscOML',
'glXWaitForMscOML', 'glXWaitForSbcOML', 'PFNGLXGETSYNCVALUESOMLPROC',
'PFNGLXGETMSCRATEOMLPROC', 'PFNGLXSWAPBUFFERSMSCOMLPROC',
'PFNGLXWAITFORMSCOMLPROC', 'PFNGLXWAITFORSBCOMLPROC', 'GLX_NV_float_buffer',
'GLX_SGIX_hyperpipe', 'GLXHyperpipeNetworkSGIX', 'GLXHyperpipeConfigSGIX',
'GLXPipeRect', 'GLXPipeRectLimits', 'glXQueryHyperpipeNetworkSGIX',
'glXHyperpipeConfigSGIX', 'glXQueryHyperpipeConfigSGIX',
'glXDestroyHyperpipeConfigSGIX', 'glXBindHyperpipeSGIX',
'glXQueryHyperpipeBestAttribSGIX', 'glXHyperpipeAttribSGIX',
'glXQueryHyperpipeAttribSGIX', 'PFNGLXQUERYHYPERPIPENETWORKSGIXPROC',
'PFNGLXHYPERPIPECONFIGSGIXPROC', 'PFNGLXQUERYHYPERPIPECONFIGSGIXPROC',
'PFNGLXDESTROYHYPERPIPECONFIGSGIXPROC', 'PFNGLXBINDHYPERPIPESGIXPROC',
'PFNGLXQUERYHYPERPIPEBESTATTRIBSGIXPROC', 'PFNGLXHYPERPIPEATTRIBSGIXPROC',
'PFNGLXQUERYHYPERPIPEATTRIBSGIXPROC', 'GLX_MESA_agp_offset',
'glXGetAGPOffsetMESA', 'PFNGLXGETAGPOFFSETMESAPROC']
# END GENERATED CONTENT (do not edit above this line)





########NEW FILE########
__FILENAME__ = glxext_mesa
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''This file is currently hand-coded; I don't have a MESA header file to build
off.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: glxext_mesa.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

import ctypes
from ctypes import *
from pyglet.gl.lib import link_GLX as _link_function

glXSwapIntervalMESA = _link_function('glXSwapIntervalMESA', c_int, [c_int], 'MESA_swap_control')

########NEW FILE########
__FILENAME__ = glxext_nv
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for http://developer.download.nvidia.com/opengl/includes/glxext.h

Generated by tools/gengl.py.
Do not modify this file.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: glxext_nv.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

from ctypes import *
from pyglet.gl.lib import link_GLX as _link_function
from pyglet.gl.lib import c_ptrdiff_t
# BEGIN GENERATED CONTENT (do not edit below this line)

# This content is generated by tools/gengl.py.
# Wrapper for http://developer.download.nvidia.com/opengl/includes/glxext.h


# VERSION_1_3 (/usr/include/GL/glx.h:73)
# VERSION_1_4 (/usr/include/GL/glx.h:132)
# ARB_get_proc_address (/usr/include/GL/glx.h:137)
# VERSION_1_1 (/usr/include/GL/glx.h:209)
# VERSION_1_2 (/usr/include/GL/glx.h:222)
# VERSION_1_3 (/usr/include/GL/glx.h:230)
# VERSION_1_4 (/usr/include/GL/glx.h:302)
# ARB_get_proc_address (/usr/include/GL/glx.h:318)
# GLXEXT_LEGACY (/usr/include/GL/glx.h:350)
GLAPI = 0 	# GL/glxext.h:49
GLX_GLXEXT_VERSION = 10 	# GL/glxext.h:57
# ARB_get_proc_address (GL/glxext.h:59)
# ARB_multisample (GL/glxext.h:62)
GLX_SAMPLE_BUFFERS_ARB = 100000 	# GL/glxext.h:63
GLX_SAMPLES_ARB = 100001 	# GL/glxext.h:64
# ARB_fbconfig_float (GL/glxext.h:67)
GLX_RGBA_FLOAT_TYPE_ARB = 8377 	# GL/glxext.h:68
GLX_RGBA_FLOAT_BIT_ARB = 4 	# GL/glxext.h:69
# SGIS_multisample (GL/glxext.h:72)
GLX_SAMPLE_BUFFERS_SGIS = 100000 	# GL/glxext.h:73
GLX_SAMPLES_SGIS = 100001 	# GL/glxext.h:74
# EXT_visual_info (GL/glxext.h:77)
GLX_X_VISUAL_TYPE_EXT = 34 	# GL/glxext.h:78
GLX_TRANSPARENT_TYPE_EXT = 35 	# GL/glxext.h:79
GLX_TRANSPARENT_INDEX_VALUE_EXT = 36 	# GL/glxext.h:80
GLX_TRANSPARENT_RED_VALUE_EXT = 37 	# GL/glxext.h:81
GLX_TRANSPARENT_GREEN_VALUE_EXT = 38 	# GL/glxext.h:82
GLX_TRANSPARENT_BLUE_VALUE_EXT = 39 	# GL/glxext.h:83
GLX_TRANSPARENT_ALPHA_VALUE_EXT = 40 	# GL/glxext.h:84
GLX_NONE_EXT = 32768 	# GL/glxext.h:85
GLX_TRUE_COLOR_EXT = 32770 	# GL/glxext.h:86
GLX_DIRECT_COLOR_EXT = 32771 	# GL/glxext.h:87
GLX_PSEUDO_COLOR_EXT = 32772 	# GL/glxext.h:88
GLX_STATIC_COLOR_EXT = 32773 	# GL/glxext.h:89
GLX_GRAY_SCALE_EXT = 32774 	# GL/glxext.h:90
GLX_STATIC_GRAY_EXT = 32775 	# GL/glxext.h:91
GLX_TRANSPARENT_RGB_EXT = 32776 	# GL/glxext.h:92
GLX_TRANSPARENT_INDEX_EXT = 32777 	# GL/glxext.h:93
# SGI_swap_control (GL/glxext.h:96)
# SGI_video_sync (GL/glxext.h:99)
# SGI_make_current_read (GL/glxext.h:102)
# SGIX_video_source (GL/glxext.h:105)
# EXT_visual_rating (GL/glxext.h:108)
GLX_VISUAL_CAVEAT_EXT = 32 	# GL/glxext.h:109
GLX_SLOW_VISUAL_EXT = 32769 	# GL/glxext.h:110
GLX_NON_CONFORMANT_VISUAL_EXT = 32781 	# GL/glxext.h:111
# EXT_import_context (GL/glxext.h:115)
GLX_SHARE_CONTEXT_EXT = 32778 	# GL/glxext.h:116
GLX_VISUAL_ID_EXT = 32779 	# GL/glxext.h:117
GLX_SCREEN_EXT = 32780 	# GL/glxext.h:118
# SGIX_fbconfig (GL/glxext.h:121)
GLX_WINDOW_BIT_SGIX = 1 	# GL/glxext.h:122
GLX_PIXMAP_BIT_SGIX = 2 	# GL/glxext.h:123
GLX_RGBA_BIT_SGIX = 1 	# GL/glxext.h:124
GLX_COLOR_INDEX_BIT_SGIX = 2 	# GL/glxext.h:125
GLX_DRAWABLE_TYPE_SGIX = 32784 	# GL/glxext.h:126
GLX_RENDER_TYPE_SGIX = 32785 	# GL/glxext.h:127
GLX_X_RENDERABLE_SGIX = 32786 	# GL/glxext.h:128
GLX_FBCONFIG_ID_SGIX = 32787 	# GL/glxext.h:129
GLX_RGBA_TYPE_SGIX = 32788 	# GL/glxext.h:130
GLX_COLOR_INDEX_TYPE_SGIX = 32789 	# GL/glxext.h:131
# SGIX_pbuffer (GL/glxext.h:135)
GLX_PBUFFER_BIT_SGIX = 4 	# GL/glxext.h:136
GLX_BUFFER_CLOBBER_MASK_SGIX = 134217728 	# GL/glxext.h:137
GLX_FRONT_LEFT_BUFFER_BIT_SGIX = 1 	# GL/glxext.h:138
GLX_FRONT_RIGHT_BUFFER_BIT_SGIX = 2 	# GL/glxext.h:139
GLX_BACK_LEFT_BUFFER_BIT_SGIX = 4 	# GL/glxext.h:140
GLX_BACK_RIGHT_BUFFER_BIT_SGIX = 8 	# GL/glxext.h:141
GLX_AUX_BUFFERS_BIT_SGIX = 16 	# GL/glxext.h:142
GLX_DEPTH_BUFFER_BIT_SGIX = 32 	# GL/glxext.h:143
GLX_STENCIL_BUFFER_BIT_SGIX = 64 	# GL/glxext.h:144
GLX_ACCUM_BUFFER_BIT_SGIX = 128 	# GL/glxext.h:145
GLX_SAMPLE_BUFFERS_BIT_SGIX = 256 	# GL/glxext.h:146
GLX_MAX_PBUFFER_WIDTH_SGIX = 32790 	# GL/glxext.h:147
GLX_MAX_PBUFFER_HEIGHT_SGIX = 32791 	# GL/glxext.h:148
GLX_MAX_PBUFFER_PIXELS_SGIX = 32792 	# GL/glxext.h:149
GLX_OPTIMAL_PBUFFER_WIDTH_SGIX = 32793 	# GL/glxext.h:150
GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX = 32794 	# GL/glxext.h:151
GLX_PRESERVED_CONTENTS_SGIX = 32795 	# GL/glxext.h:152
GLX_LARGEST_PBUFFER_SGIX = 32796 	# GL/glxext.h:153
GLX_WIDTH_SGIX = 32797 	# GL/glxext.h:154
GLX_HEIGHT_SGIX = 32798 	# GL/glxext.h:155
GLX_EVENT_MASK_SGIX = 32799 	# GL/glxext.h:156
GLX_DAMAGED_SGIX = 32800 	# GL/glxext.h:157
GLX_SAVED_SGIX = 32801 	# GL/glxext.h:158
GLX_WINDOW_SGIX = 32802 	# GL/glxext.h:159
GLX_PBUFFER_SGIX = 32803 	# GL/glxext.h:160
# SGI_cushion (GL/glxext.h:163)
# SGIX_video_resize (GL/glxext.h:166)
GLX_SYNC_FRAME_SGIX = 0 	# GL/glxext.h:167
GLX_SYNC_SWAP_SGIX = 1 	# GL/glxext.h:168
# SGIX_dmbuffer (GL/glxext.h:171)
GLX_DIGITAL_MEDIA_PBUFFER_SGIX = 32804 	# GL/glxext.h:172
# SGIX_swap_group (GL/glxext.h:175)
# SGIX_swap_barrier (GL/glxext.h:178)
# SGIS_blended_overlay (GL/glxext.h:181)
GLX_BLENDED_RGBA_SGIS = 32805 	# GL/glxext.h:182
# SGIS_shared_multisample (GL/glxext.h:185)
GLX_MULTISAMPLE_SUB_RECT_WIDTH_SGIS = 32806 	# GL/glxext.h:186
GLX_MULTISAMPLE_SUB_RECT_HEIGHT_SGIS = 32807 	# GL/glxext.h:187
# SUN_get_transparent_index (GL/glxext.h:190)
# 3DFX_multisample (GL/glxext.h:193)
GLX_SAMPLE_BUFFERS_3DFX = 32848 	# GL/glxext.h:194
GLX_SAMPLES_3DFX = 32849 	# GL/glxext.h:195
# MESA_copy_sub_buffer (GL/glxext.h:198)
# MESA_pixmap_colormap (GL/glxext.h:201)
# MESA_release_buffers (GL/glxext.h:204)
# MESA_set_3dfx_mode (GL/glxext.h:207)
GLX_3DFX_WINDOW_MODE_MESA = 1 	# GL/glxext.h:208
GLX_3DFX_FULLSCREEN_MODE_MESA = 2 	# GL/glxext.h:209
# SGIX_visual_select_group (GL/glxext.h:212)
GLX_VISUAL_SELECT_GROUP_SGIX = 32808 	# GL/glxext.h:213
# OML_swap_method (GL/glxext.h:216)
GLX_SWAP_METHOD_OML = 32864 	# GL/glxext.h:217
GLX_SWAP_EXCHANGE_OML = 32865 	# GL/glxext.h:218
GLX_SWAP_COPY_OML = 32866 	# GL/glxext.h:219
GLX_SWAP_UNDEFINED_OML = 32867 	# GL/glxext.h:220
# OML_sync_control (GL/glxext.h:223)
# NV_float_buffer (GL/glxext.h:226)
GLX_FLOAT_COMPONENTS_NV = 8368 	# GL/glxext.h:227
# SGIX_hyperpipe (GL/glxext.h:230)
GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX = 80 	# GL/glxext.h:231
GLX_BAD_HYPERPIPE_CONFIG_SGIX = 91 	# GL/glxext.h:232
GLX_BAD_HYPERPIPE_SGIX = 92 	# GL/glxext.h:233
GLX_HYPERPIPE_DISPLAY_PIPE_SGIX = 1 	# GL/glxext.h:234
GLX_HYPERPIPE_RENDER_PIPE_SGIX = 2 	# GL/glxext.h:235
GLX_PIPE_RECT_SGIX = 1 	# GL/glxext.h:236
GLX_PIPE_RECT_LIMITS_SGIX = 2 	# GL/glxext.h:237
GLX_HYPERPIPE_STEREO_SGIX = 3 	# GL/glxext.h:238
GLX_HYPERPIPE_PIXEL_AVERAGE_SGIX = 4 	# GL/glxext.h:239
GLX_HYPERPIPE_ID_SGIX = 32816 	# GL/glxext.h:240
# MESA_agp_offset (GL/glxext.h:243)
# ARB_get_proc_address (GL/glxext.h:249)
# SGIX_video_source (GL/glxext.h:256)
XID = c_ulong 	# /usr/include/X11/X.h:71
GLXVideoSourceSGIX = XID 	# GL/glxext.h:257
# SGIX_fbconfig (GL/glxext.h:260)
GLXFBConfigIDSGIX = XID 	# GL/glxext.h:261
class struct___GLXFBConfigRec(Structure):
    __slots__ = [
    ]
struct___GLXFBConfigRec._fields_ = [
    ('_opaque_struct', c_int)
]

GLXFBConfigSGIX = POINTER(struct___GLXFBConfigRec) 	# GL/glxext.h:262
# SGIX_pbuffer (GL/glxext.h:265)
class struct_anon_301(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'drawable',
        'event_type',
        'draw_type',
        'mask',
        'x',
        'y',
        'width',
        'height',
        'count',
    ]
class struct__XDisplay(Structure):
    __slots__ = [
    ]
struct__XDisplay._fields_ = [
    ('_opaque_struct', c_int)
]

Display = struct__XDisplay 	# /usr/include/X11/Xlib.h:519
GLXDrawable = XID 	# /usr/include/GL/glx.h:146
struct_anon_301._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('drawable', GLXDrawable),
    ('event_type', c_int),
    ('draw_type', c_int),
    ('mask', c_uint),
    ('x', c_int),
    ('y', c_int),
    ('width', c_int),
    ('height', c_int),
    ('count', c_int),
]

GLXBufferClobberEventSGIX = struct_anon_301 	# GL/glxext.h:279
# NV_swap_group (GL/glxext.h:282)
# NV_video_out (GL/glxext.h:285)
GLXVideoDeviceNV = c_uint 	# GL/glxext.h:290
GLX_VIDEO_OUT_COLOR_NV = 8387 	# GL/glxext.h:293
GLX_VIDEO_OUT_ALPHA_NV = 8388 	# GL/glxext.h:294
GLX_VIDEO_OUT_DEPTH_NV = 8389 	# GL/glxext.h:295
GLX_VIDEO_OUT_COLOR_AND_ALPHA_NV = 8390 	# GL/glxext.h:296
GLX_VIDEO_OUT_COLOR_AND_DEPTH_NV = 8391 	# GL/glxext.h:297
GLX_VIDEO_OUT_FRAME_NV = 8392 	# GL/glxext.h:300
GLX_VIDEO_OUT_FIELD_1_NV = 8393 	# GL/glxext.h:301
GLX_VIDEO_OUT_FIELD_2_NV = 8394 	# GL/glxext.h:302
# EXT_texture_from_pixmap (GL/glxext.h:305)
GLX_BIND_TO_TEXTURE_RGB_EXT = 8400 	# GL/glxext.h:307
GLX_BIND_TO_TEXTURE_RGBA_EXT = 8401 	# GL/glxext.h:308
GLX_BIND_TO_MIPMAP_TEXTURE_EXT = 8402 	# GL/glxext.h:309
GLX_BIND_TO_TEXTURE_TARGETS_EXT = 8403 	# GL/glxext.h:310
GLX_Y_INVERTED_EXT = 8404 	# GL/glxext.h:311
GLX_TEXTURE_FORMAT_EXT = 8405 	# GL/glxext.h:314
GLX_TEXTURE_TARGET_EXT = 8406 	# GL/glxext.h:315
GLX_MIPMAP_TEXTURE_EXT = 8407 	# GL/glxext.h:316
GLX_TEXTURE_FORMAT_NONE_EXT = 8408 	# GL/glxext.h:319
GLX_TEXTURE_FORMAT_RGB_EXT = 8409 	# GL/glxext.h:320
GLX_TEXTURE_FORMAT_RGBA_EXT = 8410 	# GL/glxext.h:321
GLX_TEXTURE_1D_BIT_EXT = 1 	# GL/glxext.h:324
GLX_TEXTURE_2D_BIT_EXT = 2 	# GL/glxext.h:325
GLX_TEXTURE_RECTANGLE_BIT_EXT = 4 	# GL/glxext.h:326
GLX_TEXTURE_1D_EXT = 8411 	# GL/glxext.h:329
GLX_TEXTURE_2D_EXT = 8412 	# GL/glxext.h:330
GLX_TEXTURE_RECTANGLE_EXT = 8413 	# GL/glxext.h:331
GLX_FRONT_LEFT_EXT = 8414 	# GL/glxext.h:337
GLX_FRONT_RIGHT_EXT = 8415 	# GL/glxext.h:338
GLX_BACK_LEFT_EXT = 8416 	# GL/glxext.h:339
GLX_BACK_RIGHT_EXT = 8417 	# GL/glxext.h:340
GLX_FRONT_EXT = 8414 	# GL/glxext.h:341
GLX_BACK_EXT = 8416 	# GL/glxext.h:342
GLX_AUX0_EXT = 8418 	# GL/glxext.h:343
GLX_AUX1_EXT = 8419 	# GL/glxext.h:344
GLX_AUX2_EXT = 8420 	# GL/glxext.h:345
GLX_AUX3_EXT = 8421 	# GL/glxext.h:346
GLX_AUX4_EXT = 8422 	# GL/glxext.h:347
GLX_AUX5_EXT = 8423 	# GL/glxext.h:348
GLX_AUX6_EXT = 8424 	# GL/glxext.h:349
GLX_AUX7_EXT = 8425 	# GL/glxext.h:350
GLX_AUX8_EXT = 8426 	# GL/glxext.h:351
GLX_AUX9_EXT = 8427 	# GL/glxext.h:352
# ARB_get_proc_address (GL/glxext.h:373)
# ARB_multisample (GL/glxext.h:377)
GLX_ARB_multisample = 1 	# GL/glxext.h:378
# ARB_fbconfig_float (GL/glxext.h:381)
GLX_ARB_fbconfig_float = 1 	# GL/glxext.h:382
# SGIS_multisample (GL/glxext.h:385)
GLX_SGIS_multisample = 1 	# GL/glxext.h:386
# EXT_visual_info (GL/glxext.h:389)
GLX_EXT_visual_info = 1 	# GL/glxext.h:390
# SGI_swap_control (GL/glxext.h:393)
GLX_SGI_swap_control = 1 	# GL/glxext.h:394
# GL/glxext.h:396
glXSwapIntervalSGI = _link_function('glXSwapIntervalSGI', c_int, [c_int], 'SGI_swap_control')

PFNGLXSWAPINTERVALSGIPROC = CFUNCTYPE(c_int, c_int) 	# GL/glxext.h:398
# SGI_video_sync (GL/glxext.h:401)
GLX_SGI_video_sync = 1 	# GL/glxext.h:402
# GL/glxext.h:404
glXGetVideoSyncSGI = _link_function('glXGetVideoSyncSGI', c_int, [POINTER(c_uint)], 'SGI_video_sync')

# GL/glxext.h:405
glXWaitVideoSyncSGI = _link_function('glXWaitVideoSyncSGI', c_int, [c_int, c_int, POINTER(c_uint)], 'SGI_video_sync')

# GL/glxext.h:406
glXGetRefreshRateSGI = _link_function('glXGetRefreshRateSGI', c_int, [POINTER(c_uint)], 'SGI_video_sync')

PFNGLXGETVIDEOSYNCSGIPROC = CFUNCTYPE(c_int, POINTER(c_uint)) 	# GL/glxext.h:408
PFNGLXWAITVIDEOSYNCSGIPROC = CFUNCTYPE(c_int, c_int, c_int, POINTER(c_uint)) 	# GL/glxext.h:409
PFNGLXGETREFRESHRATESGIPROC = CFUNCTYPE(c_int, POINTER(c_uint)) 	# GL/glxext.h:410
# SGI_make_current_read (GL/glxext.h:413)
GLX_SGI_make_current_read = 1 	# GL/glxext.h:414
class struct___GLXcontextRec(Structure):
    __slots__ = [
    ]
struct___GLXcontextRec._fields_ = [
    ('_opaque_struct', c_int)
]

GLXContext = POINTER(struct___GLXcontextRec) 	# /usr/include/GL/glx.h:155
# GL/glxext.h:416
glXMakeCurrentReadSGI = _link_function('glXMakeCurrentReadSGI', c_int, [POINTER(Display), GLXDrawable, GLXDrawable, GLXContext], 'SGI_make_current_read')

# GL/glxext.h:417
glXGetCurrentReadDrawableSGI = _link_function('glXGetCurrentReadDrawableSGI', GLXDrawable, [], 'SGI_make_current_read')

PFNGLXMAKECURRENTREADSGIPROC = CFUNCTYPE(c_int, POINTER(Display), GLXDrawable, GLXDrawable, GLXContext) 	# GL/glxext.h:419
PFNGLXGETCURRENTREADDRAWABLESGIPROC = CFUNCTYPE(GLXDrawable) 	# GL/glxext.h:420
# SGIX_video_source (GL/glxext.h:423)
GLX_SGIX_video_source = 1 	# GL/glxext.h:424
# EXT_visual_rating (GL/glxext.h:435)
GLX_EXT_visual_rating = 1 	# GL/glxext.h:436
# EXT_import_context (GL/glxext.h:439)
GLX_EXT_import_context = 1 	# GL/glxext.h:440
# GL/glxext.h:442
glXGetCurrentDisplayEXT = _link_function('glXGetCurrentDisplayEXT', POINTER(Display), [], 'EXT_import_context')

# GL/glxext.h:443
glXQueryContextInfoEXT = _link_function('glXQueryContextInfoEXT', c_int, [POINTER(Display), GLXContext, c_int, POINTER(c_int)], 'EXT_import_context')

GLXContextID = XID 	# /usr/include/GL/glx.h:144
# GL/glxext.h:444
glXGetContextIDEXT = _link_function('glXGetContextIDEXT', GLXContextID, [GLXContext], 'EXT_import_context')

# GL/glxext.h:445
glXImportContextEXT = _link_function('glXImportContextEXT', GLXContext, [POINTER(Display), GLXContextID], 'EXT_import_context')

# GL/glxext.h:446
glXFreeContextEXT = _link_function('glXFreeContextEXT', None, [POINTER(Display), GLXContext], 'EXT_import_context')

PFNGLXGETCURRENTDISPLAYEXTPROC = CFUNCTYPE(POINTER(Display)) 	# GL/glxext.h:448
PFNGLXQUERYCONTEXTINFOEXTPROC = CFUNCTYPE(c_int, POINTER(Display), GLXContext, c_int, POINTER(c_int)) 	# GL/glxext.h:449
PFNGLXGETCONTEXTIDEXTPROC = CFUNCTYPE(GLXContextID, GLXContext) 	# GL/glxext.h:450
PFNGLXIMPORTCONTEXTEXTPROC = CFUNCTYPE(GLXContext, POINTER(Display), GLXContextID) 	# GL/glxext.h:451
PFNGLXFREECONTEXTEXTPROC = CFUNCTYPE(None, POINTER(Display), GLXContext) 	# GL/glxext.h:452
# SGIX_fbconfig (GL/glxext.h:455)
GLX_SGIX_fbconfig = 1 	# GL/glxext.h:456
# GL/glxext.h:458
glXGetFBConfigAttribSGIX = _link_function('glXGetFBConfigAttribSGIX', c_int, [POINTER(Display), GLXFBConfigSGIX, c_int, POINTER(c_int)], 'SGIX_fbconfig')

# GL/glxext.h:459
glXChooseFBConfigSGIX = _link_function('glXChooseFBConfigSGIX', POINTER(GLXFBConfigSGIX), [POINTER(Display), c_int, POINTER(c_int), POINTER(c_int)], 'SGIX_fbconfig')

GLXPixmap = XID 	# /usr/include/GL/glx.h:145
Pixmap = XID 	# /usr/include/X11/X.h:107
# GL/glxext.h:460
glXCreateGLXPixmapWithConfigSGIX = _link_function('glXCreateGLXPixmapWithConfigSGIX', GLXPixmap, [POINTER(Display), GLXFBConfigSGIX, Pixmap], 'SGIX_fbconfig')

# GL/glxext.h:461
glXCreateContextWithConfigSGIX = _link_function('glXCreateContextWithConfigSGIX', GLXContext, [POINTER(Display), GLXFBConfigSGIX, c_int, GLXContext, c_int], 'SGIX_fbconfig')

class struct_anon_298(Structure):
    __slots__ = [
        'visual',
        'visualid',
        'screen',
        'depth',
        'class',
        'red_mask',
        'green_mask',
        'blue_mask',
        'colormap_size',
        'bits_per_rgb',
    ]
class struct_anon_215(Structure):
    __slots__ = [
        'ext_data',
        'visualid',
        'class',
        'red_mask',
        'green_mask',
        'blue_mask',
        'bits_per_rgb',
        'map_entries',
    ]
class struct__XExtData(Structure):
    __slots__ = [
        'number',
        'next',
        'free_private',
        'private_data',
    ]
XPointer = c_char_p 	# /usr/include/X11/Xlib.h:108
struct__XExtData._fields_ = [
    ('number', c_int),
    ('next', POINTER(struct__XExtData)),
    ('free_private', POINTER(CFUNCTYPE(c_int, POINTER(struct__XExtData)))),
    ('private_data', XPointer),
]

XExtData = struct__XExtData 	# /usr/include/X11/Xlib.h:187
VisualID = c_ulong 	# /usr/include/X11/X.h:81
struct_anon_215._fields_ = [
    ('ext_data', POINTER(XExtData)),
    ('visualid', VisualID),
    ('class', c_int),
    ('red_mask', c_ulong),
    ('green_mask', c_ulong),
    ('blue_mask', c_ulong),
    ('bits_per_rgb', c_int),
    ('map_entries', c_int),
]

Visual = struct_anon_215 	# /usr/include/X11/Xlib.h:270
struct_anon_298._fields_ = [
    ('visual', POINTER(Visual)),
    ('visualid', VisualID),
    ('screen', c_int),
    ('depth', c_int),
    ('class', c_int),
    ('red_mask', c_ulong),
    ('green_mask', c_ulong),
    ('blue_mask', c_ulong),
    ('colormap_size', c_int),
    ('bits_per_rgb', c_int),
]

XVisualInfo = struct_anon_298 	# /usr/include/X11/Xutil.h:296
# GL/glxext.h:462
glXGetVisualFromFBConfigSGIX = _link_function('glXGetVisualFromFBConfigSGIX', POINTER(XVisualInfo), [POINTER(Display), GLXFBConfigSGIX], 'SGIX_fbconfig')

# GL/glxext.h:463
glXGetFBConfigFromVisualSGIX = _link_function('glXGetFBConfigFromVisualSGIX', GLXFBConfigSGIX, [POINTER(Display), POINTER(XVisualInfo)], 'SGIX_fbconfig')

PFNGLXGETFBCONFIGATTRIBSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), GLXFBConfigSGIX, c_int, POINTER(c_int)) 	# GL/glxext.h:465
PFNGLXCHOOSEFBCONFIGSGIXPROC = CFUNCTYPE(POINTER(GLXFBConfigSGIX), POINTER(Display), c_int, POINTER(c_int), POINTER(c_int)) 	# GL/glxext.h:466
PFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC = CFUNCTYPE(GLXPixmap, POINTER(Display), GLXFBConfigSGIX, Pixmap) 	# GL/glxext.h:467
PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC = CFUNCTYPE(GLXContext, POINTER(Display), GLXFBConfigSGIX, c_int, GLXContext, c_int) 	# GL/glxext.h:468
PFNGLXGETVISUALFROMFBCONFIGSGIXPROC = CFUNCTYPE(POINTER(XVisualInfo), POINTER(Display), GLXFBConfigSGIX) 	# GL/glxext.h:469
PFNGLXGETFBCONFIGFROMVISUALSGIXPROC = CFUNCTYPE(GLXFBConfigSGIX, POINTER(Display), POINTER(XVisualInfo)) 	# GL/glxext.h:470
# SGIX_pbuffer (GL/glxext.h:473)
GLX_SGIX_pbuffer = 1 	# GL/glxext.h:474
GLXPbufferSGIX = XID 	# /usr/include/GL/glx.h:148
# GL/glxext.h:476
glXCreateGLXPbufferSGIX = _link_function('glXCreateGLXPbufferSGIX', GLXPbufferSGIX, [POINTER(Display), GLXFBConfigSGIX, c_uint, c_uint, POINTER(c_int)], 'SGIX_pbuffer')

# GL/glxext.h:477
glXDestroyGLXPbufferSGIX = _link_function('glXDestroyGLXPbufferSGIX', None, [POINTER(Display), GLXPbufferSGIX], 'SGIX_pbuffer')

# GL/glxext.h:478
glXQueryGLXPbufferSGIX = _link_function('glXQueryGLXPbufferSGIX', c_int, [POINTER(Display), GLXPbufferSGIX, c_int, POINTER(c_uint)], 'SGIX_pbuffer')

# GL/glxext.h:479
glXSelectEventSGIX = _link_function('glXSelectEventSGIX', None, [POINTER(Display), GLXDrawable, c_ulong], 'SGIX_pbuffer')

# GL/glxext.h:480
glXGetSelectedEventSGIX = _link_function('glXGetSelectedEventSGIX', None, [POINTER(Display), GLXDrawable, POINTER(c_ulong)], 'SGIX_pbuffer')

PFNGLXCREATEGLXPBUFFERSGIXPROC = CFUNCTYPE(GLXPbufferSGIX, POINTER(Display), GLXFBConfigSGIX, c_uint, c_uint, POINTER(c_int)) 	# GL/glxext.h:482
PFNGLXDESTROYGLXPBUFFERSGIXPROC = CFUNCTYPE(None, POINTER(Display), GLXPbufferSGIX) 	# GL/glxext.h:483
PFNGLXQUERYGLXPBUFFERSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), GLXPbufferSGIX, c_int, POINTER(c_uint)) 	# GL/glxext.h:484
PFNGLXSELECTEVENTSGIXPROC = CFUNCTYPE(None, POINTER(Display), GLXDrawable, c_ulong) 	# GL/glxext.h:485
PFNGLXGETSELECTEDEVENTSGIXPROC = CFUNCTYPE(None, POINTER(Display), GLXDrawable, POINTER(c_ulong)) 	# GL/glxext.h:486
# SGI_cushion (GL/glxext.h:489)
GLX_SGI_cushion = 1 	# GL/glxext.h:490
Window = XID 	# /usr/include/X11/X.h:101
# GL/glxext.h:492
glXCushionSGI = _link_function('glXCushionSGI', None, [POINTER(Display), Window, c_float], 'SGI_cushion')

PFNGLXCUSHIONSGIPROC = CFUNCTYPE(None, POINTER(Display), Window, c_float) 	# GL/glxext.h:494
# SGIX_video_resize (GL/glxext.h:497)
GLX_SGIX_video_resize = 1 	# GL/glxext.h:498
# GL/glxext.h:500
glXBindChannelToWindowSGIX = _link_function('glXBindChannelToWindowSGIX', c_int, [POINTER(Display), c_int, c_int, Window], 'SGIX_video_resize')

# GL/glxext.h:501
glXChannelRectSGIX = _link_function('glXChannelRectSGIX', c_int, [POINTER(Display), c_int, c_int, c_int, c_int, c_int, c_int], 'SGIX_video_resize')

# GL/glxext.h:502
glXQueryChannelRectSGIX = _link_function('glXQueryChannelRectSGIX', c_int, [POINTER(Display), c_int, c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int)], 'SGIX_video_resize')

# GL/glxext.h:503
glXQueryChannelDeltasSGIX = _link_function('glXQueryChannelDeltasSGIX', c_int, [POINTER(Display), c_int, c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int)], 'SGIX_video_resize')

GLenum = c_uint 	# /usr/include/GL/gl.h:53
# GL/glxext.h:504
glXChannelRectSyncSGIX = _link_function('glXChannelRectSyncSGIX', c_int, [POINTER(Display), c_int, c_int, GLenum], 'SGIX_video_resize')

PFNGLXBINDCHANNELTOWINDOWSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, Window) 	# GL/glxext.h:506
PFNGLXCHANNELRECTSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, c_int, c_int, c_int, c_int) 	# GL/glxext.h:507
PFNGLXQUERYCHANNELRECTSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int)) 	# GL/glxext.h:508
PFNGLXQUERYCHANNELDELTASSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int)) 	# GL/glxext.h:509
PFNGLXCHANNELRECTSYNCSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, GLenum) 	# GL/glxext.h:510
# SGIX_dmbuffer (GL/glxext.h:513)
GLX_SGIX_dmbuffer = 1 	# GL/glxext.h:514
# SGIX_swap_group (GL/glxext.h:523)
GLX_SGIX_swap_group = 1 	# GL/glxext.h:524
# GL/glxext.h:526
glXJoinSwapGroupSGIX = _link_function('glXJoinSwapGroupSGIX', None, [POINTER(Display), GLXDrawable, GLXDrawable], 'SGIX_swap_group')

PFNGLXJOINSWAPGROUPSGIXPROC = CFUNCTYPE(None, POINTER(Display), GLXDrawable, GLXDrawable) 	# GL/glxext.h:528
# SGIX_swap_barrier (GL/glxext.h:531)
GLX_SGIX_swap_barrier = 1 	# GL/glxext.h:532
# GL/glxext.h:534
glXBindSwapBarrierSGIX = _link_function('glXBindSwapBarrierSGIX', None, [POINTER(Display), GLXDrawable, c_int], 'SGIX_swap_barrier')

# GL/glxext.h:535
glXQueryMaxSwapBarriersSGIX = _link_function('glXQueryMaxSwapBarriersSGIX', c_int, [POINTER(Display), c_int, POINTER(c_int)], 'SGIX_swap_barrier')

PFNGLXBINDSWAPBARRIERSGIXPROC = CFUNCTYPE(None, POINTER(Display), GLXDrawable, c_int) 	# GL/glxext.h:537
PFNGLXQUERYMAXSWAPBARRIERSSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, POINTER(c_int)) 	# GL/glxext.h:538
# SUN_get_transparent_index (GL/glxext.h:541)
GLX_SUN_get_transparent_index = 1 	# GL/glxext.h:542
# GL/glxext.h:544
glXGetTransparentIndexSUN = _link_function('glXGetTransparentIndexSUN', c_int, [POINTER(Display), Window, Window, POINTER(c_long)], 'SUN_get_transparent_index')

PFNGLXGETTRANSPARENTINDEXSUNPROC = CFUNCTYPE(c_int, POINTER(Display), Window, Window, POINTER(c_long)) 	# GL/glxext.h:546
# MESA_copy_sub_buffer (GL/glxext.h:549)
GLX_MESA_copy_sub_buffer = 1 	# GL/glxext.h:550
# GL/glxext.h:552
glXCopySubBufferMESA = _link_function('glXCopySubBufferMESA', None, [POINTER(Display), GLXDrawable, c_int, c_int, c_int, c_int], 'MESA_copy_sub_buffer')

PFNGLXCOPYSUBBUFFERMESAPROC = CFUNCTYPE(None, POINTER(Display), GLXDrawable, c_int, c_int, c_int, c_int) 	# GL/glxext.h:554
# MESA_pixmap_colormap (GL/glxext.h:557)
GLX_MESA_pixmap_colormap = 1 	# GL/glxext.h:558
Colormap = XID 	# /usr/include/X11/X.h:109
# GL/glxext.h:560
glXCreateGLXPixmapMESA = _link_function('glXCreateGLXPixmapMESA', GLXPixmap, [POINTER(Display), POINTER(XVisualInfo), Pixmap, Colormap], 'MESA_pixmap_colormap')

PFNGLXCREATEGLXPIXMAPMESAPROC = CFUNCTYPE(GLXPixmap, POINTER(Display), POINTER(XVisualInfo), Pixmap, Colormap) 	# GL/glxext.h:562
# MESA_release_buffers (GL/glxext.h:565)
GLX_MESA_release_buffers = 1 	# GL/glxext.h:566
# GL/glxext.h:568
glXReleaseBuffersMESA = _link_function('glXReleaseBuffersMESA', c_int, [POINTER(Display), GLXDrawable], 'MESA_release_buffers')

PFNGLXRELEASEBUFFERSMESAPROC = CFUNCTYPE(c_int, POINTER(Display), GLXDrawable) 	# GL/glxext.h:570
# MESA_set_3dfx_mode (GL/glxext.h:573)
GLX_MESA_set_3dfx_mode = 1 	# GL/glxext.h:574
# GL/glxext.h:576
glXSet3DfxModeMESA = _link_function('glXSet3DfxModeMESA', c_int, [c_int], 'MESA_set_3dfx_mode')

PFNGLXSET3DFXMODEMESAPROC = CFUNCTYPE(c_int, c_int) 	# GL/glxext.h:578
# SGIX_visual_select_group (GL/glxext.h:581)
GLX_SGIX_visual_select_group = 1 	# GL/glxext.h:582
# OML_swap_method (GL/glxext.h:585)
GLX_OML_swap_method = 1 	# GL/glxext.h:586
# OML_sync_control (GL/glxext.h:589)
GLX_OML_sync_control = 1 	# GL/glxext.h:590
# GL/glxext.h:592
glXGetSyncValuesOML = _link_function('glXGetSyncValuesOML', c_int, [POINTER(Display), GLXDrawable, POINTER(c_int64), POINTER(c_int64), POINTER(c_int64)], 'OML_sync_control')

# GL/glxext.h:593
glXGetMscRateOML = _link_function('glXGetMscRateOML', c_int, [POINTER(Display), GLXDrawable, POINTER(c_int32), POINTER(c_int32)], 'OML_sync_control')

# GL/glxext.h:594
glXSwapBuffersMscOML = _link_function('glXSwapBuffersMscOML', c_int64, [POINTER(Display), GLXDrawable, c_int64, c_int64, c_int64], 'OML_sync_control')

# GL/glxext.h:595
glXWaitForMscOML = _link_function('glXWaitForMscOML', c_int, [POINTER(Display), GLXDrawable, c_int64, c_int64, c_int64, POINTER(c_int64), POINTER(c_int64), POINTER(c_int64)], 'OML_sync_control')

# GL/glxext.h:596
glXWaitForSbcOML = _link_function('glXWaitForSbcOML', c_int, [POINTER(Display), GLXDrawable, c_int64, POINTER(c_int64), POINTER(c_int64), POINTER(c_int64)], 'OML_sync_control')

PFNGLXGETSYNCVALUESOMLPROC = CFUNCTYPE(c_int, POINTER(Display), GLXDrawable, POINTER(c_int64), POINTER(c_int64), POINTER(c_int64)) 	# GL/glxext.h:598
PFNGLXGETMSCRATEOMLPROC = CFUNCTYPE(c_int, POINTER(Display), GLXDrawable, POINTER(c_int32), POINTER(c_int32)) 	# GL/glxext.h:599
PFNGLXSWAPBUFFERSMSCOMLPROC = CFUNCTYPE(c_int64, POINTER(Display), GLXDrawable, c_int64, c_int64, c_int64) 	# GL/glxext.h:600
PFNGLXWAITFORMSCOMLPROC = CFUNCTYPE(c_int, POINTER(Display), GLXDrawable, c_int64, c_int64, c_int64, POINTER(c_int64), POINTER(c_int64), POINTER(c_int64)) 	# GL/glxext.h:601
PFNGLXWAITFORSBCOMLPROC = CFUNCTYPE(c_int, POINTER(Display), GLXDrawable, c_int64, POINTER(c_int64), POINTER(c_int64), POINTER(c_int64)) 	# GL/glxext.h:602
# NV_float_buffer (GL/glxext.h:605)
GLX_NV_float_buffer = 1 	# GL/glxext.h:606
# SGIX_hyperpipe (GL/glxext.h:609)
GLX_SGIX_hyperpipe = 1 	# GL/glxext.h:610
class struct_anon_302(Structure):
    __slots__ = [
        'pipeName',
        'networkId',
    ]
struct_anon_302._fields_ = [
    ('pipeName', c_char * 80),
    ('networkId', c_int),
]

GLXHyperpipeNetworkSGIX = struct_anon_302 	# GL/glxext.h:615
class struct_anon_303(Structure):
    __slots__ = [
        'pipeName',
        'channel',
        'participationType',
        'timeSlice',
    ]
struct_anon_303._fields_ = [
    ('pipeName', c_char * 80),
    ('channel', c_int),
    ('participationType', c_uint),
    ('timeSlice', c_int),
]

GLXHyperpipeConfigSGIX = struct_anon_303 	# GL/glxext.h:623
class struct_anon_304(Structure):
    __slots__ = [
        'pipeName',
        'srcXOrigin',
        'srcYOrigin',
        'srcWidth',
        'srcHeight',
        'destXOrigin',
        'destYOrigin',
        'destWidth',
        'destHeight',
    ]
struct_anon_304._fields_ = [
    ('pipeName', c_char * 80),
    ('srcXOrigin', c_int),
    ('srcYOrigin', c_int),
    ('srcWidth', c_int),
    ('srcHeight', c_int),
    ('destXOrigin', c_int),
    ('destYOrigin', c_int),
    ('destWidth', c_int),
    ('destHeight', c_int),
]

GLXPipeRect = struct_anon_304 	# GL/glxext.h:629
class struct_anon_305(Structure):
    __slots__ = [
        'pipeName',
        'XOrigin',
        'YOrigin',
        'maxHeight',
        'maxWidth',
    ]
struct_anon_305._fields_ = [
    ('pipeName', c_char * 80),
    ('XOrigin', c_int),
    ('YOrigin', c_int),
    ('maxHeight', c_int),
    ('maxWidth', c_int),
]

GLXPipeRectLimits = struct_anon_305 	# GL/glxext.h:634
# GL/glxext.h:637
glXQueryHyperpipeNetworkSGIX = _link_function('glXQueryHyperpipeNetworkSGIX', POINTER(GLXHyperpipeNetworkSGIX), [POINTER(Display), POINTER(c_int)], 'SGIX_hyperpipe')

# GL/glxext.h:638
glXHyperpipeConfigSGIX = _link_function('glXHyperpipeConfigSGIX', c_int, [POINTER(Display), c_int, c_int, POINTER(GLXHyperpipeConfigSGIX), POINTER(c_int)], 'SGIX_hyperpipe')

# GL/glxext.h:639
glXQueryHyperpipeConfigSGIX = _link_function('glXQueryHyperpipeConfigSGIX', POINTER(GLXHyperpipeConfigSGIX), [POINTER(Display), c_int, POINTER(c_int)], 'SGIX_hyperpipe')

# GL/glxext.h:640
glXDestroyHyperpipeConfigSGIX = _link_function('glXDestroyHyperpipeConfigSGIX', c_int, [POINTER(Display), c_int], 'SGIX_hyperpipe')

# GL/glxext.h:641
glXBindHyperpipeSGIX = _link_function('glXBindHyperpipeSGIX', c_int, [POINTER(Display), c_int], 'SGIX_hyperpipe')

# GL/glxext.h:642
glXQueryHyperpipeBestAttribSGIX = _link_function('glXQueryHyperpipeBestAttribSGIX', c_int, [POINTER(Display), c_int, c_int, c_int, POINTER(None), POINTER(None)], 'SGIX_hyperpipe')

# GL/glxext.h:643
glXHyperpipeAttribSGIX = _link_function('glXHyperpipeAttribSGIX', c_int, [POINTER(Display), c_int, c_int, c_int, POINTER(None)], 'SGIX_hyperpipe')

# GL/glxext.h:644
glXQueryHyperpipeAttribSGIX = _link_function('glXQueryHyperpipeAttribSGIX', c_int, [POINTER(Display), c_int, c_int, c_int, POINTER(None)], 'SGIX_hyperpipe')

PFNGLXQUERYHYPERPIPENETWORKSGIXPROC = CFUNCTYPE(POINTER(GLXHyperpipeNetworkSGIX), POINTER(Display), POINTER(c_int)) 	# GL/glxext.h:646
PFNGLXHYPERPIPECONFIGSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, POINTER(GLXHyperpipeConfigSGIX), POINTER(c_int)) 	# GL/glxext.h:647
PFNGLXQUERYHYPERPIPECONFIGSGIXPROC = CFUNCTYPE(POINTER(GLXHyperpipeConfigSGIX), POINTER(Display), c_int, POINTER(c_int)) 	# GL/glxext.h:648
PFNGLXDESTROYHYPERPIPECONFIGSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int) 	# GL/glxext.h:649
PFNGLXBINDHYPERPIPESGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int) 	# GL/glxext.h:650
PFNGLXQUERYHYPERPIPEBESTATTRIBSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, c_int, POINTER(None), POINTER(None)) 	# GL/glxext.h:651
PFNGLXHYPERPIPEATTRIBSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, c_int, POINTER(None)) 	# GL/glxext.h:652
PFNGLXQUERYHYPERPIPEATTRIBSGIXPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, c_int, POINTER(None)) 	# GL/glxext.h:653
# MESA_agp_offset (GL/glxext.h:656)
GLX_MESA_agp_offset = 1 	# GL/glxext.h:657
# GL/glxext.h:659
glXGetAGPOffsetMESA = _link_function('glXGetAGPOffsetMESA', c_uint, [POINTER(None)], 'MESA_agp_offset')

PFNGLXGETAGPOFFSETMESAPROC = CFUNCTYPE(c_uint, POINTER(None)) 	# GL/glxext.h:661
# NV_vertex_array_range (GL/glxext.h:667)
GLX_NV_vertex_array_range = 1 	# GL/glxext.h:668
GLsizei = c_int 	# /usr/include/GL/gl.h:59
GLfloat = c_float 	# /usr/include/GL/gl.h:63
# GL/glxext.h:670
glXAllocateMemoryNV = _link_function('glXAllocateMemoryNV', POINTER(c_void), [GLsizei, GLfloat, GLfloat, GLfloat], 'NV_vertex_array_range')

GLvoid = None 	# /usr/include/GL/gl.h:67
# GL/glxext.h:673
glXFreeMemoryNV = _link_function('glXFreeMemoryNV', None, [POINTER(GLvoid)], 'NV_vertex_array_range')

PFNGLXALLOCATEMEMORYNVPROC = CFUNCTYPE(POINTER(c_void), GLsizei, GLfloat, GLfloat, GLfloat) 	# GL/glxext.h:675
PFNGLXFREEMEMORYNVPROC = CFUNCTYPE(None, POINTER(GLvoid)) 	# GL/glxext.h:680
# NV_swap_group (GL/glxext.h:683)
GLX_NV_swap_group = 1 	# GL/glxext.h:684
GLuint = c_uint 	# /usr/include/GL/gl.h:62
# GL/glxext.h:686
glXJoinSwapGroupNV = _link_function('glXJoinSwapGroupNV', c_int, [POINTER(Display), GLXDrawable, GLuint], 'NV_swap_group')

# GL/glxext.h:689
glXBindSwapBarrierNV = _link_function('glXBindSwapBarrierNV', c_int, [POINTER(Display), GLuint, GLuint], 'NV_swap_group')

# GL/glxext.h:691
glXQuerySwapGroupNV = _link_function('glXQuerySwapGroupNV', c_int, [POINTER(Display), GLXDrawable, POINTER(GLuint), POINTER(GLuint)], 'NV_swap_group')

# GL/glxext.h:694
glXQueryMaxSwapGroupsNV = _link_function('glXQueryMaxSwapGroupsNV', c_int, [POINTER(Display), c_int, POINTER(GLuint), POINTER(GLuint)], 'NV_swap_group')

# GL/glxext.h:697
glXQueryFrameCountNV = _link_function('glXQueryFrameCountNV', c_int, [POINTER(Display), c_int, POINTER(GLuint)], 'NV_swap_group')

# GL/glxext.h:699
glXResetFrameCountNV = _link_function('glXResetFrameCountNV', c_int, [POINTER(Display), c_int], 'NV_swap_group')

PFNGLXJOINSWAPGROUPNVPROC = CFUNCTYPE(c_int, POINTER(Display), GLXDrawable, GLuint) 	# GL/glxext.h:701
PFNGLXBINDSWAPBARRIERNVPROC = CFUNCTYPE(c_int, POINTER(Display), GLuint, GLuint) 	# GL/glxext.h:705
PFNGLXQUERYSWAPGROUPNVPROC = CFUNCTYPE(c_int, POINTER(Display), GLXDrawable, POINTER(GLuint), POINTER(GLuint)) 	# GL/glxext.h:709
PFNGLXQUERYMAXSWAPGROUPSNVPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, POINTER(GLuint), POINTER(GLuint)) 	# GL/glxext.h:714
PFNGLXQUERYFRAMECOUNTNVPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, POINTER(GLuint)) 	# GL/glxext.h:719
PFNGLXRESETFRAMECOUNTNVPROC = CFUNCTYPE(c_int, POINTER(Display), c_int) 	# GL/glxext.h:723
# NV_video_out (GL/glxext.h:726)
GLX_NV_video_out = 1 	# GL/glxext.h:727
# GL/glxext.h:729
glXGetVideoDeviceNV = _link_function('glXGetVideoDeviceNV', c_int, [POINTER(Display), c_int, c_int, POINTER(GLXVideoDeviceNV)], 'NV_video_out')

# GL/glxext.h:732
glXReleaseVideoDeviceNV = _link_function('glXReleaseVideoDeviceNV', c_int, [POINTER(Display), c_int, GLXVideoDeviceNV], 'NV_video_out')

GLXPbuffer = XID 	# /usr/include/GL/glx.h:147
# GL/glxext.h:735
glXBindVideoImageNV = _link_function('glXBindVideoImageNV', c_int, [POINTER(Display), GLXVideoDeviceNV, GLXPbuffer, c_int], 'NV_video_out')

# GL/glxext.h:738
glXReleaseVideoImageNV = _link_function('glXReleaseVideoImageNV', c_int, [POINTER(Display), GLXPbuffer], 'NV_video_out')

GLboolean = c_ubyte 	# /usr/include/GL/gl.h:54
# GL/glxext.h:740
glXSendPbufferToVideoNV = _link_function('glXSendPbufferToVideoNV', c_int, [POINTER(Display), GLXPbuffer, c_int, POINTER(c_ulong), GLboolean], 'NV_video_out')

# GL/glxext.h:745
glXGetVideoInfoNV = _link_function('glXGetVideoInfoNV', c_int, [POINTER(Display), c_int, GLXVideoDeviceNV, POINTER(c_ulong), POINTER(c_ulong)], 'NV_video_out')

PFNGLXGETVIDEODEVICENVPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, c_int, POINTER(GLXVideoDeviceNV)) 	# GL/glxext.h:750
PFNGLXRELEASEVIDEODEVICENVPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, GLXVideoDeviceNV) 	# GL/glxext.h:755
PFNGLXBINDVIDEOIMAGENVPROC = CFUNCTYPE(c_int, POINTER(Display), GLXVideoDeviceNV, GLXPbuffer, c_int) 	# GL/glxext.h:759
PFNGLXRELEASEVIDEOIMAGENVPROC = CFUNCTYPE(c_int, POINTER(Display), GLXPbuffer) 	# GL/glxext.h:764
PFNGLXSENDPBUFFERTOVIDEONVPROC = CFUNCTYPE(c_int, POINTER(Display), GLXPbuffer, c_int, POINTER(c_ulong), GLboolean) 	# GL/glxext.h:767
PFNGLXGETVIDEOINFONVPROC = CFUNCTYPE(c_int, POINTER(Display), c_int, GLXVideoDeviceNV, POINTER(c_ulong), POINTER(c_ulong)) 	# GL/glxext.h:773
# EXT_texture_from_pixmap (GL/glxext.h:779)
# GL/glxext.h:782
glXBindTexImageEXT = _link_function('glXBindTexImageEXT', None, [POINTER(Display), GLXDrawable, c_int, POINTER(c_int)], 'EXT_texture_from_pixmap')

# GL/glxext.h:784
glXReleaseTextImageEXT = _link_function('glXReleaseTextImageEXT', None, [POINTER(Display), GLXDrawable, c_int], 'EXT_texture_from_pixmap')

PFNGLXBINDTEXIMAGEEXTPROC = CFUNCTYPE(None, POINTER(Display), GLXDrawable, c_int, POINTER(c_int)) 	# GL/glxext.h:787
PFNGLXRELEASETEXIMAGEEXTPROC = CFUNCTYPE(None, POINTER(Display), GLXDrawable, c_int) 	# GL/glxext.h:791

__all__ = ['GLAPI', 'GLX_GLXEXT_VERSION', 'GLX_SAMPLE_BUFFERS_ARB',
'GLX_SAMPLES_ARB', 'GLX_RGBA_FLOAT_TYPE_ARB', 'GLX_RGBA_FLOAT_BIT_ARB',
'GLX_SAMPLE_BUFFERS_SGIS', 'GLX_SAMPLES_SGIS', 'GLX_X_VISUAL_TYPE_EXT',
'GLX_TRANSPARENT_TYPE_EXT', 'GLX_TRANSPARENT_INDEX_VALUE_EXT',
'GLX_TRANSPARENT_RED_VALUE_EXT', 'GLX_TRANSPARENT_GREEN_VALUE_EXT',
'GLX_TRANSPARENT_BLUE_VALUE_EXT', 'GLX_TRANSPARENT_ALPHA_VALUE_EXT',
'GLX_NONE_EXT', 'GLX_TRUE_COLOR_EXT', 'GLX_DIRECT_COLOR_EXT',
'GLX_PSEUDO_COLOR_EXT', 'GLX_STATIC_COLOR_EXT', 'GLX_GRAY_SCALE_EXT',
'GLX_STATIC_GRAY_EXT', 'GLX_TRANSPARENT_RGB_EXT', 'GLX_TRANSPARENT_INDEX_EXT',
'GLX_VISUAL_CAVEAT_EXT', 'GLX_SLOW_VISUAL_EXT',
'GLX_NON_CONFORMANT_VISUAL_EXT', 'GLX_SHARE_CONTEXT_EXT', 'GLX_VISUAL_ID_EXT',
'GLX_SCREEN_EXT', 'GLX_WINDOW_BIT_SGIX', 'GLX_PIXMAP_BIT_SGIX',
'GLX_RGBA_BIT_SGIX', 'GLX_COLOR_INDEX_BIT_SGIX', 'GLX_DRAWABLE_TYPE_SGIX',
'GLX_RENDER_TYPE_SGIX', 'GLX_X_RENDERABLE_SGIX', 'GLX_FBCONFIG_ID_SGIX',
'GLX_RGBA_TYPE_SGIX', 'GLX_COLOR_INDEX_TYPE_SGIX', 'GLX_PBUFFER_BIT_SGIX',
'GLX_BUFFER_CLOBBER_MASK_SGIX', 'GLX_FRONT_LEFT_BUFFER_BIT_SGIX',
'GLX_FRONT_RIGHT_BUFFER_BIT_SGIX', 'GLX_BACK_LEFT_BUFFER_BIT_SGIX',
'GLX_BACK_RIGHT_BUFFER_BIT_SGIX', 'GLX_AUX_BUFFERS_BIT_SGIX',
'GLX_DEPTH_BUFFER_BIT_SGIX', 'GLX_STENCIL_BUFFER_BIT_SGIX',
'GLX_ACCUM_BUFFER_BIT_SGIX', 'GLX_SAMPLE_BUFFERS_BIT_SGIX',
'GLX_MAX_PBUFFER_WIDTH_SGIX', 'GLX_MAX_PBUFFER_HEIGHT_SGIX',
'GLX_MAX_PBUFFER_PIXELS_SGIX', 'GLX_OPTIMAL_PBUFFER_WIDTH_SGIX',
'GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX', 'GLX_PRESERVED_CONTENTS_SGIX',
'GLX_LARGEST_PBUFFER_SGIX', 'GLX_WIDTH_SGIX', 'GLX_HEIGHT_SGIX',
'GLX_EVENT_MASK_SGIX', 'GLX_DAMAGED_SGIX', 'GLX_SAVED_SGIX',
'GLX_WINDOW_SGIX', 'GLX_PBUFFER_SGIX', 'GLX_SYNC_FRAME_SGIX',
'GLX_SYNC_SWAP_SGIX', 'GLX_DIGITAL_MEDIA_PBUFFER_SGIX',
'GLX_BLENDED_RGBA_SGIS', 'GLX_MULTISAMPLE_SUB_RECT_WIDTH_SGIS',
'GLX_MULTISAMPLE_SUB_RECT_HEIGHT_SGIS', 'GLX_SAMPLE_BUFFERS_3DFX',
'GLX_SAMPLES_3DFX', 'GLX_3DFX_WINDOW_MODE_MESA',
'GLX_3DFX_FULLSCREEN_MODE_MESA', 'GLX_VISUAL_SELECT_GROUP_SGIX',
'GLX_SWAP_METHOD_OML', 'GLX_SWAP_EXCHANGE_OML', 'GLX_SWAP_COPY_OML',
'GLX_SWAP_UNDEFINED_OML', 'GLX_FLOAT_COMPONENTS_NV',
'GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX', 'GLX_BAD_HYPERPIPE_CONFIG_SGIX',
'GLX_BAD_HYPERPIPE_SGIX', 'GLX_HYPERPIPE_DISPLAY_PIPE_SGIX',
'GLX_HYPERPIPE_RENDER_PIPE_SGIX', 'GLX_PIPE_RECT_SGIX',
'GLX_PIPE_RECT_LIMITS_SGIX', 'GLX_HYPERPIPE_STEREO_SGIX',
'GLX_HYPERPIPE_PIXEL_AVERAGE_SGIX', 'GLX_HYPERPIPE_ID_SGIX',
'GLXVideoSourceSGIX', 'GLXFBConfigIDSGIX', 'GLXFBConfigSGIX',
'GLXBufferClobberEventSGIX', 'GLXVideoDeviceNV', 'GLX_VIDEO_OUT_COLOR_NV',
'GLX_VIDEO_OUT_ALPHA_NV', 'GLX_VIDEO_OUT_DEPTH_NV',
'GLX_VIDEO_OUT_COLOR_AND_ALPHA_NV', 'GLX_VIDEO_OUT_COLOR_AND_DEPTH_NV',
'GLX_VIDEO_OUT_FRAME_NV', 'GLX_VIDEO_OUT_FIELD_1_NV',
'GLX_VIDEO_OUT_FIELD_2_NV', 'GLX_BIND_TO_TEXTURE_RGB_EXT',
'GLX_BIND_TO_TEXTURE_RGBA_EXT', 'GLX_BIND_TO_MIPMAP_TEXTURE_EXT',
'GLX_BIND_TO_TEXTURE_TARGETS_EXT', 'GLX_Y_INVERTED_EXT',
'GLX_TEXTURE_FORMAT_EXT', 'GLX_TEXTURE_TARGET_EXT', 'GLX_MIPMAP_TEXTURE_EXT',
'GLX_TEXTURE_FORMAT_NONE_EXT', 'GLX_TEXTURE_FORMAT_RGB_EXT',
'GLX_TEXTURE_FORMAT_RGBA_EXT', 'GLX_TEXTURE_1D_BIT_EXT',
'GLX_TEXTURE_2D_BIT_EXT', 'GLX_TEXTURE_RECTANGLE_BIT_EXT',
'GLX_TEXTURE_1D_EXT', 'GLX_TEXTURE_2D_EXT', 'GLX_TEXTURE_RECTANGLE_EXT',
'GLX_FRONT_LEFT_EXT', 'GLX_FRONT_RIGHT_EXT', 'GLX_BACK_LEFT_EXT',
'GLX_BACK_RIGHT_EXT', 'GLX_FRONT_EXT', 'GLX_BACK_EXT', 'GLX_AUX0_EXT',
'GLX_AUX1_EXT', 'GLX_AUX2_EXT', 'GLX_AUX3_EXT', 'GLX_AUX4_EXT',
'GLX_AUX5_EXT', 'GLX_AUX6_EXT', 'GLX_AUX7_EXT', 'GLX_AUX8_EXT',
'GLX_AUX9_EXT', 'GLX_ARB_multisample', 'GLX_ARB_fbconfig_float',
'GLX_SGIS_multisample', 'GLX_EXT_visual_info', 'GLX_SGI_swap_control',
'glXSwapIntervalSGI', 'PFNGLXSWAPINTERVALSGIPROC', 'GLX_SGI_video_sync',
'glXGetVideoSyncSGI', 'glXWaitVideoSyncSGI', 'glXGetRefreshRateSGI',
'PFNGLXGETVIDEOSYNCSGIPROC', 'PFNGLXWAITVIDEOSYNCSGIPROC',
'PFNGLXGETREFRESHRATESGIPROC', 'GLX_SGI_make_current_read',
'glXMakeCurrentReadSGI', 'glXGetCurrentReadDrawableSGI',
'PFNGLXMAKECURRENTREADSGIPROC', 'PFNGLXGETCURRENTREADDRAWABLESGIPROC',
'GLX_SGIX_video_source', 'GLX_EXT_visual_rating', 'GLX_EXT_import_context',
'glXGetCurrentDisplayEXT', 'glXQueryContextInfoEXT', 'glXGetContextIDEXT',
'glXImportContextEXT', 'glXFreeContextEXT', 'PFNGLXGETCURRENTDISPLAYEXTPROC',
'PFNGLXQUERYCONTEXTINFOEXTPROC', 'PFNGLXGETCONTEXTIDEXTPROC',
'PFNGLXIMPORTCONTEXTEXTPROC', 'PFNGLXFREECONTEXTEXTPROC', 'GLX_SGIX_fbconfig',
'glXGetFBConfigAttribSGIX', 'glXChooseFBConfigSGIX',
'glXCreateGLXPixmapWithConfigSGIX', 'glXCreateContextWithConfigSGIX',
'glXGetVisualFromFBConfigSGIX', 'glXGetFBConfigFromVisualSGIX',
'PFNGLXGETFBCONFIGATTRIBSGIXPROC', 'PFNGLXCHOOSEFBCONFIGSGIXPROC',
'PFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC',
'PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC',
'PFNGLXGETVISUALFROMFBCONFIGSGIXPROC', 'PFNGLXGETFBCONFIGFROMVISUALSGIXPROC',
'GLX_SGIX_pbuffer', 'glXCreateGLXPbufferSGIX', 'glXDestroyGLXPbufferSGIX',
'glXQueryGLXPbufferSGIX', 'glXSelectEventSGIX', 'glXGetSelectedEventSGIX',
'PFNGLXCREATEGLXPBUFFERSGIXPROC', 'PFNGLXDESTROYGLXPBUFFERSGIXPROC',
'PFNGLXQUERYGLXPBUFFERSGIXPROC', 'PFNGLXSELECTEVENTSGIXPROC',
'PFNGLXGETSELECTEDEVENTSGIXPROC', 'GLX_SGI_cushion', 'glXCushionSGI',
'PFNGLXCUSHIONSGIPROC', 'GLX_SGIX_video_resize', 'glXBindChannelToWindowSGIX',
'glXChannelRectSGIX', 'glXQueryChannelRectSGIX', 'glXQueryChannelDeltasSGIX',
'glXChannelRectSyncSGIX', 'PFNGLXBINDCHANNELTOWINDOWSGIXPROC',
'PFNGLXCHANNELRECTSGIXPROC', 'PFNGLXQUERYCHANNELRECTSGIXPROC',
'PFNGLXQUERYCHANNELDELTASSGIXPROC', 'PFNGLXCHANNELRECTSYNCSGIXPROC',
'GLX_SGIX_dmbuffer', 'GLX_SGIX_swap_group', 'glXJoinSwapGroupSGIX',
'PFNGLXJOINSWAPGROUPSGIXPROC', 'GLX_SGIX_swap_barrier',
'glXBindSwapBarrierSGIX', 'glXQueryMaxSwapBarriersSGIX',
'PFNGLXBINDSWAPBARRIERSGIXPROC', 'PFNGLXQUERYMAXSWAPBARRIERSSGIXPROC',
'GLX_SUN_get_transparent_index', 'glXGetTransparentIndexSUN',
'PFNGLXGETTRANSPARENTINDEXSUNPROC', 'GLX_MESA_copy_sub_buffer',
'glXCopySubBufferMESA', 'PFNGLXCOPYSUBBUFFERMESAPROC',
'GLX_MESA_pixmap_colormap', 'glXCreateGLXPixmapMESA',
'PFNGLXCREATEGLXPIXMAPMESAPROC', 'GLX_MESA_release_buffers',
'glXReleaseBuffersMESA', 'PFNGLXRELEASEBUFFERSMESAPROC',
'GLX_MESA_set_3dfx_mode', 'glXSet3DfxModeMESA', 'PFNGLXSET3DFXMODEMESAPROC',
'GLX_SGIX_visual_select_group', 'GLX_OML_swap_method', 'GLX_OML_sync_control',
'glXGetSyncValuesOML', 'glXGetMscRateOML', 'glXSwapBuffersMscOML',
'glXWaitForMscOML', 'glXWaitForSbcOML', 'PFNGLXGETSYNCVALUESOMLPROC',
'PFNGLXGETMSCRATEOMLPROC', 'PFNGLXSWAPBUFFERSMSCOMLPROC',
'PFNGLXWAITFORMSCOMLPROC', 'PFNGLXWAITFORSBCOMLPROC', 'GLX_NV_float_buffer',
'GLX_SGIX_hyperpipe', 'GLXHyperpipeNetworkSGIX', 'GLXHyperpipeConfigSGIX',
'GLXPipeRect', 'GLXPipeRectLimits', 'glXQueryHyperpipeNetworkSGIX',
'glXHyperpipeConfigSGIX', 'glXQueryHyperpipeConfigSGIX',
'glXDestroyHyperpipeConfigSGIX', 'glXBindHyperpipeSGIX',
'glXQueryHyperpipeBestAttribSGIX', 'glXHyperpipeAttribSGIX',
'glXQueryHyperpipeAttribSGIX', 'PFNGLXQUERYHYPERPIPENETWORKSGIXPROC',
'PFNGLXHYPERPIPECONFIGSGIXPROC', 'PFNGLXQUERYHYPERPIPECONFIGSGIXPROC',
'PFNGLXDESTROYHYPERPIPECONFIGSGIXPROC', 'PFNGLXBINDHYPERPIPESGIXPROC',
'PFNGLXQUERYHYPERPIPEBESTATTRIBSGIXPROC', 'PFNGLXHYPERPIPEATTRIBSGIXPROC',
'PFNGLXQUERYHYPERPIPEATTRIBSGIXPROC', 'GLX_MESA_agp_offset',
'glXGetAGPOffsetMESA', 'PFNGLXGETAGPOFFSETMESAPROC',
'GLX_NV_vertex_array_range', 'glXAllocateMemoryNV', 'glXFreeMemoryNV',
'PFNGLXALLOCATEMEMORYNVPROC', 'PFNGLXFREEMEMORYNVPROC', 'GLX_NV_swap_group',
'glXJoinSwapGroupNV', 'glXBindSwapBarrierNV', 'glXQuerySwapGroupNV',
'glXQueryMaxSwapGroupsNV', 'glXQueryFrameCountNV', 'glXResetFrameCountNV',
'PFNGLXJOINSWAPGROUPNVPROC', 'PFNGLXBINDSWAPBARRIERNVPROC',
'PFNGLXQUERYSWAPGROUPNVPROC', 'PFNGLXQUERYMAXSWAPGROUPSNVPROC',
'PFNGLXQUERYFRAMECOUNTNVPROC', 'PFNGLXRESETFRAMECOUNTNVPROC',
'GLX_NV_video_out', 'glXGetVideoDeviceNV', 'glXReleaseVideoDeviceNV',
'glXBindVideoImageNV', 'glXReleaseVideoImageNV', 'glXSendPbufferToVideoNV',
'glXGetVideoInfoNV', 'PFNGLXGETVIDEODEVICENVPROC',
'PFNGLXRELEASEVIDEODEVICENVPROC', 'PFNGLXBINDVIDEOIMAGENVPROC',
'PFNGLXRELEASEVIDEOIMAGENVPROC', 'PFNGLXSENDPBUFFERTOVIDEONVPROC',
'PFNGLXGETVIDEOINFONVPROC', 'glXBindTexImageEXT', 'glXReleaseTextImageEXT',
'PFNGLXBINDTEXIMAGEEXTPROC', 'PFNGLXRELEASETEXIMAGEEXTPROC']
# END GENERATED CONTENT (do not edit above this line)





########NEW FILE########
__FILENAME__ = glx_info
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Information about version and extensions of current GLX implementation.

Usage::

    from pyglet.gl import glx_info

    if glx_info.have_extension('GLX_NV_float_buffer'):
        # ...

Or, if using more than one display::

    from pyglet.gl.glx_info import GLXInfo

    info = GLXInfo(window._display)
    if info.get_server_vendor() == 'ATI':
        # ...

'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: glx_info.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

from ctypes import *

from pyglet.gl.glx import *
from pyglet.gl.glx import Display

class GLXInfoException(Exception):
    pass

class GLXInfo(object):
    def __init__(self, display=None):
        self.display = display

    def set_display(self, display):
        self.display = cast(pointer(display), POINTER(Display))

    def check_display(self):
        if not self.display:
            raise GLXInfoException('No X11 display has been set yet.')

    def have_version(self, major, minor=0):
        self.check_display()
        if not glXQueryExtension(self.display, None, None):
            raise GLXInfoException('pyglet requires an X server with GLX')

        server_version = self.get_server_version().split()[0]
        client_version = self.get_client_version().split()[0]

        server = [int(i) for i in server_version.split('.')]
        client = [int(i) for i in client_version.split('.')]
        return (tuple(server) >= (major, minor) and
                tuple(client) >= (major, minor))

    def get_server_vendor(self):
        self.check_display()
        return glXQueryServerString(self.display, 0, GLX_VENDOR)

    def get_server_version(self):
        # glXQueryServerString was introduced in GLX 1.1, so we need to use the
        # 1.0 function here which queries the server implementation for its
        # version.
        self.check_display()
        major = c_int()
        minor = c_int()
        if not glXQueryVersion(self.display, byref(major), byref(minor)):
            raise GLXInfoException('Could not determine GLX server version')
        return '%s.%s'%(major.value, minor.value)

    def get_server_extensions(self):
        self.check_display()
        return glXQueryServerString(self.display, 0, GLX_EXTENSIONS).split()

    def get_client_vendor(self):
        self.check_display()
        return glXGetClientString(self.display, GLX_VENDOR)

    def get_client_version(self):
        self.check_display()
        return glXGetClientString(self.display, GLX_VERSION)

    def get_client_extensions(self):
        self.check_display()
        return glXGetClientString(self.display, GLX_EXTENSIONS).split()

    def get_extensions(self):
        self.check_display()
        return glXQueryExtensionsString(self.display, 0).split()

    def have_extension(self, extension):
        self.check_display()
        if not self.have_version(1, 1):
            return False
        return extension in self.get_extensions()

# Single instance suitable for apps that use only a single display.
_glx_info = GLXInfo()

set_display = _glx_info.set_display
check_display = _glx_info.check_display
have_version = _glx_info.have_version
get_server_vendor = _glx_info.get_server_vendor
get_server_version = _glx_info.get_server_version
get_server_extensions = _glx_info.get_server_extensions
get_client_vendor = _glx_info.get_client_vendor
get_client_version = _glx_info.get_client_version
get_client_extensions = _glx_info.get_client_extensions
get_extensions = _glx_info.get_extensions
have_extension = _glx_info.have_extension

########NEW FILE########
__FILENAME__ = gl_info
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Information about version and extensions of current GL implementation.

Usage::

    from pyglet.gl import gl_info

    if gl_info.have_extension('GL_NV_register_combiners'):
        # ...

If you are using more than one context, you can set up a separate GLInfo
object for each context.  Call `set_active_context` after switching to the
context::

    from pyglet.gl.gl_info import GLInfo

    info = GLInfo()
    info.set_active_context()

    if info.have_version(2, 1):
        # ...

'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

from ctypes import *
import warnings

from pyglet.gl.gl import *

class GLInfo(object):
    '''Information interface for a single GL context.

    A default instance is created automatically when the first OpenGL context
    is created.  You can use the module functions as a convenience for
    this default instance's methods.

    If you are using more than one context, you must call `set_active_context`
    when the context is active for this `GLInfo` instance.
    '''
    have_context = False
    version = '0.0.0'
    vendor = ''
    renderer = ''
    extensions = set()

    _have_info = False

    def set_active_context(self):
        '''Store information for the currently active context.

        This method is called automatically for the default context.
        '''
        self.have_context = True
        if not self._have_info:
            self.vendor = cast(glGetString(GL_VENDOR), c_char_p).value
            self.renderer = cast(glGetString(GL_RENDERER), c_char_p).value
            self.extensions = cast(glGetString(GL_EXTENSIONS), c_char_p).value
            if self.extensions:
                self.extensions = set(self.extensions.split())
            self.version = cast(glGetString(GL_VERSION), c_char_p).value
            self._have_info = True

    def remove_active_context(self):
        self.have_context = False

    def have_extension(self, extension):
        '''Determine if an OpenGL extension is available.

        :Parameters:
            `extension` : str
                The name of the extension to test for, including its
                ``GL_`` prefix.

        :return: True if the extension is provided by the driver.
        :rtype: bool
        '''
        if not self.have_context:
            warnings.warn('No GL context created yet.')
        return extension in self.extensions

    def get_extensions(self):
        '''Get a list of available OpenGL extensions.

        :return: a list of the available extensions.
        :rtype: list of str
        '''
        if not self.have_context:
            warnings.warn('No GL context created yet.')
        return self.extensions

    def get_version(self):
        '''Get the current OpenGL version.

        :return: the OpenGL version
        :rtype: str
        '''
        if not self.have_context:
            warnings.warn('No GL context created yet.')
        return self.version

    def have_version(self, major, minor=0, release=0):
        '''Determine if a version of OpenGL is supported.

        :Parameters:
            `major` : int
                The major revision number (typically 1 or 2).
            `minor` : int
                The minor revision number.
            `release` : int
                The release number.

        :rtype: bool
        :return: True if the requested or a later version is supported.
        '''

        if not self.have_context:
            warnings.warn('No GL context created yet.')
        ver = '%s.0.0' % self.version.split(' ', 1)[0]
        imajor, iminor, irelease = [int(v) for v in ver.split('.', 3)[:3]]
        return imajor > major or \
           (imajor == major and iminor > minor) or \
           (imajor == major and iminor == minor and irelease >= release)

    def get_renderer(self):
        '''Determine the renderer string of the OpenGL context.

        :rtype: str
        '''
        if not self.have_context:
            warnings.warn('No GL context created yet.')
        return self.renderer

    def get_vendor(self):
        '''Determine the vendor string of the OpenGL context.

        :rtype: str
        '''
        if not self.have_context:
            warnings.warn('No GL context created yet.')
        return self.vendor

# Single instance useful for apps with only a single context (or all contexts
# have same GL driver, common case).
_gl_info = GLInfo()

set_active_context = _gl_info.set_active_context
remove_active_context = _gl_info.remove_active_context
have_extension = _gl_info.have_extension
get_extensions = _gl_info.get_extensions
get_version = _gl_info.get_version
have_version = _gl_info.have_version
get_renderer = _gl_info.get_renderer
get_vendor = _gl_info.get_vendor

def have_context():
    '''Determine if a default OpenGL context has been set yet.

    :rtype: bool
    '''
    return _gl_info.have_context

########NEW FILE########
__FILENAME__ = lib
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: lib.py 1978 2008-03-28 15:11:48Z Alex.Holkner $'

import sys
import ctypes

import pyglet

__all__ = ['link_GL', 'link_GLU', 'link_AGL', 'link_GLX', 'link_WGL']

_debug_gl = pyglet.options['debug_gl']
_debug_gl_trace = pyglet.options['debug_gl_trace']
_debug_gl_trace_args = pyglet.options['debug_gl_trace_args']

class MissingFunctionException(Exception):
    def __init__(self, name, requires=None, suggestions=None):
        msg = '%s is not exported by the available OpenGL driver.' % name
        if requires:
            msg += '  %s is required for this functionality.' % requires
        if suggestions:
            msg += '  Consider alternative(s) %s.' % ', '.join(suggestions)
        Exception.__init__(self, msg)

def missing_function(name, requires=None, suggestions=None):
    def MissingFunction(*args, **kwargs):
        raise MissingFunctionException(name, requires, suggestions)
    return MissingFunction

_int_types = (ctypes.c_int16, ctypes.c_int32)
if hasattr(ctypes, 'c_int64'):
    # Some builds of ctypes apparently do not have c_int64
    # defined; it's a pretty good bet that these builds do not
    # have 64-bit pointers.
    _int_types += (ctypes.c_int64,)
for t in _int_types:
    if ctypes.sizeof(t) == ctypes.sizeof(ctypes.c_size_t):
        c_ptrdiff_t = t

class c_void(ctypes.Structure):
    # c_void_p is a buggy return type, converting to int, so
    # POINTER(None) == c_void_p is actually written as
    # POINTER(c_void), so it can be treated as a real pointer.
    _fields_ = [('dummy', ctypes.c_int)]

class GLException(Exception):
    pass

def errcheck(result, func, arguments):
    if _debug_gl_trace:
        try:
            name = func.__name__
        except AttributeError:
            name = repr(func)
        if _debug_gl_trace_args:
            trace_args = ', '.join([repr(arg)[:20] for arg in arguments])
            print '%s(%s)' % (name, trace_args)
        else:
            print name

    from pyglet import gl
    context = gl.current_context
    if not context:
        raise GLException('No GL context; create a Window first')
    if not context._gl_begin:
        error = gl.glGetError()
        if error:
            msg = ctypes.cast(gl.gluErrorString(error), ctypes.c_char_p).value
            raise GLException(msg)
        return result

def errcheck_glbegin(result, func, arguments):
    from pyglet import gl
    context = gl.current_context
    if not context:
        raise GLException('No GL context; create a Window first')
    context._gl_begin = True
    return result

def errcheck_glend(result, func, arguments):
    from pyglet import gl
    context = gl.current_context
    if not context:
        raise GLException('No GL context; create a Window first')
    context._gl_begin = False
    return errcheck(result, func, arguments)

def decorate_function(func, name):
    if _debug_gl:
        if name == 'glBegin':
            func.errcheck = errcheck_glbegin
        elif name == 'glEnd':
            func.errcheck = errcheck_glend
        elif name not in ('glGetError', 'gluErrorString') and \
             name[:3] not in ('glX', 'agl', 'wgl'):
            func.errcheck = errcheck

link_AGL = None
link_GLX = None
link_WGL = None

if sys.platform in ('win32', 'cygwin'):
    from pyglet.gl.lib_wgl import link_GL, link_GLU, link_WGL
elif sys.platform == 'darwin':
    from pyglet.gl.lib_agl import link_GL, link_GLU, link_AGL
else:
    from pyglet.gl.lib_glx import link_GL, link_GLU, link_GLX


########NEW FILE########
__FILENAME__ = lib_agl
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

from ctypes import *

import pyglet.lib
from pyglet.gl.lib import missing_function, decorate_function

__all__ = ['link_GL', 'link_GLU', 'link_AGL']

gl_lib = pyglet.lib.load_library(
    framework='/System/Library/Frameworks/OpenGL.framework')
agl_lib = pyglet.lib.load_library(
    framework='/System/Library/Frameworks/AGL.framework')

def link_GL(name, restype, argtypes, requires=None, suggestions=None):
    try:
        func = getattr(gl_lib, name)
        func.restype = restype
        func.argtypes = argtypes
        decorate_function(func, name)
        return func
    except AttributeError, e:
        return missing_function(name, requires, suggestions)

link_GLU = link_GL

def link_AGL(name, restype, argtypes, requires=None, suggestions=None):
    try:
        func = getattr(agl_lib, name)
        func.restype = restype
        func.argtypes = argtypes
        decorate_function(func, name)
        return func
    except AttributeError, e:
        return missing_function(name, requires, suggestions)


########NEW FILE########
__FILENAME__ = lib_glx
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: lib_glx.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

from ctypes import *

import pyglet.lib
from pyglet.gl.lib import missing_function, decorate_function

__all__ = ['link_GL', 'link_GLU', 'link_GLX']

gl_lib = pyglet.lib.load_library('GL')
glu_lib = pyglet.lib.load_library('GLU')

# Look for glXGetProcAddressARB extension, use it as fallback (for
# ATI fglrx and DRI drivers).
try:
    glXGetProcAddressARB = getattr(gl_lib, 'glXGetProcAddressARB')
    glXGetProcAddressARB.restype = POINTER(CFUNCTYPE(None))
    glXGetProcAddressARB.argtypes = [POINTER(c_ubyte)]
    _have_getprocaddress = True
except AttributeError:
    _have_get_procaddress = False

def link_GL(name, restype, argtypes, requires=None, suggestions=None):
    try:
        func = getattr(gl_lib, name)
        func.restype = restype
        func.argtypes = argtypes
        decorate_function(func, name)
        return func
    except AttributeError, e:
        if _have_getprocaddress:
            # Fallback if implemented but not in ABI
            bname = cast(pointer(create_string_buffer(name)), POINTER(c_ubyte))
            addr = glXGetProcAddressARB(bname)
            if addr:
                ftype = CFUNCTYPE(*((restype,) + tuple(argtypes)))
                func = cast(addr, ftype)
                decorate_function(func, name)
                return func

    return missing_function(name, requires, suggestions)

link_GLX = link_GL

def link_GLU(name, restype, argtypes, requires=None, suggestions=None):
    try:
        func = getattr(glu_lib, name)
        func.restype = restype
        func.argtypes = argtypes
        decorate_function(func, name)
        return func
    except AttributeError, e:
        return missing_function(name, requires, suggestions)


########NEW FILE########
__FILENAME__ = lib_wgl
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: lib_glx.py 597 2007-02-03 16:13:07Z Alex.Holkner $'

import ctypes
from ctypes import *

import pyglet
from pyglet.gl.lib import missing_function, decorate_function

__all__ = ['link_GL', 'link_GLU', 'link_WGL']

_debug_trace = pyglet.options['debug_trace']

gl_lib = ctypes.windll.opengl32
glu_lib = ctypes.windll.glu32
wgl_lib = gl_lib

if _debug_trace:
    from pyglet.lib import _TraceLibrary
    gl_lib = _TraceLibrary(gl_lib)
    glu_lib = _TraceLibrary(glu_lib)
    wgl_lib = _TraceLibrary(wgl_lib)

try:
    wglGetProcAddress = wgl_lib.wglGetProcAddress
    wglGetProcAddress.restype = CFUNCTYPE(POINTER(c_int))
    wglGetProcAddress.argtypes = [c_char_p]
    _have_get_proc_address = True
except AttributeError:
    _have_get_proc_address = False

class WGLFunctionProxy(object):
    __slots__ = ['name', 'requires', 'suggestions', 'ftype', 'func']
    def __init__(self, name, ftype, requires, suggestions):
        assert _have_get_proc_address
        self.name = name
        self.ftype = ftype
        self.requires = requires
        self.suggestions = suggestions
        self.func = None

    def __call__(self, *args, **kwargs):
        if self.func:
            return self.func(*args, **kwargs)

        from pyglet.gl import current_context
        if not current_context:
            raise Exception(
                'Call to function "%s" before GL context created' % self.name)
        address = wglGetProcAddress(self.name)
        if cast(address, POINTER(c_int)):  # check cast because address is func
            self.func = cast(address, self.ftype)
            decorate_function(self.func, self.name)
        else:
            self.func = missing_function(
                self.name, self.requires, self.suggestions)
        result = self.func(*args, **kwargs)
        return result

def link_GL(name, restype, argtypes, requires=None, suggestions=None):
    try:
        func = getattr(gl_lib, name)
        func.restype = restype
        func.argtypes = argtypes
        decorate_function(func, name)
        return func
    except AttributeError, e:
        # Not in opengl32.dll. Try and get a pointer from WGL.
        try:
            fargs = (restype,) + tuple(argtypes)
            ftype = ctypes.WINFUNCTYPE(*fargs)
            if _have_get_proc_address:
                from pyglet.gl import gl_info
                if gl_info.have_context():
                    address = wglGetProcAddress(name)
                    if address:
                        func = cast(address, ftype)
                        decorate_function(func, name)
                        return func
                else:
                    # Insert proxy until we have a context
                    return WGLFunctionProxy(name, ftype, requires, suggestions)
        except:
            pass

        return missing_function(name, requires, suggestions)

def link_GLU(name, restype, argtypes, requires=None, suggestions=None):
    try:
        func = getattr(glu_lib, name)
        func.restype = restype
        func.argtypes = argtypes
        decorate_function(func, name)
        return func
    except AttributeError, e:
        # Not in glu32.dll. Try and get a pointer from WGL.
        try:
            fargs = (restype,) + tuple(argtypes)
            ftype = ctypes.WINFUNCTYPE(*fargs)
            if _have_get_proc_address:
                from pyglet.gl import gl_info
                if gl_info.have_context():
                    address = wglGetProcAddress(name)
                    if address:
                        func = cast(address, ftype)
                        decorate_function(func, name)
                        return func
                else:
                    # Insert proxy until we have a context
                    return WGLFunctionProxy(name, ftype, requires, suggestions)
        except:
            pass

        return missing_function(name, requires, suggestions)

link_WGL = link_GL

########NEW FILE########
__FILENAME__ = wgl
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for C:\cygwin\home\Alex\pyglet\tools\wgl.h

Generated by tools/gengl.py.
Do not modify this file.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: gengl.py 601 2007-02-04 05:36:59Z Alex.Holkner $'

from ctypes import *
from pyglet.gl.lib import link_WGL as _link_function
from pyglet.gl.lib import c_ptrdiff_t

if not _link_function:
    raise ImportError('opengl32.dll is not available.')

# BEGIN GENERATED CONTENT (do not edit below this line)

# This content is generated by tools/gengl.py.
# Wrapper for C:\cygwin\home\Alex\pyglet\tools\wgl.h


CONST = 0 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:14
GLenum = c_uint 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:17
GLboolean = c_ubyte 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:18
GLbitfield = c_uint 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:19
GLbyte = c_char 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:20
GLshort = c_short 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:21
GLint = c_int 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:22
GLsizei = c_int 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:23
GLubyte = c_ubyte 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:24
GLushort = c_ushort 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:25
GLuint = c_uint 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:26
GLfloat = c_float 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:27
GLclampf = c_float 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:28
GLdouble = c_double 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:29
GLclampd = c_double 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:30
GLvoid = None 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:31
INT8 = c_char 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:33
PINT8 = c_char_p 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:33
INT16 = c_short 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:34
PINT16 = POINTER(c_short) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:34
INT32 = c_int 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:35
PINT32 = POINTER(c_int) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:35
UINT8 = c_ubyte 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:36
PUINT8 = POINTER(c_ubyte) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:36
UINT16 = c_ushort 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:37
PUINT16 = POINTER(c_ushort) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:37
UINT32 = c_uint 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:38
PUINT32 = POINTER(c_uint) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:38
LONG32 = c_int 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:39
PLONG32 = POINTER(c_int) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:39
ULONG32 = c_uint 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:40
PULONG32 = POINTER(c_uint) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:40
DWORD32 = c_uint 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:41
PDWORD32 = POINTER(c_uint) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:41
INT64 = c_longlong 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:42
PINT64 = POINTER(c_longlong) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:42
UINT64 = c_ulonglong 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:43
PUINT64 = POINTER(c_ulonglong) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:43
VOID = None 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:45
LPVOID = POINTER(None) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:45
LPCSTR = c_char_p 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:46
CHAR = c_char 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:47
BYTE = c_ubyte 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:48
WORD = c_ushort 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:49
USHORT = c_ushort 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:49
UINT = c_uint 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:50
INT = c_int 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:51
INT_PTR = POINTER(c_int) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:51
BOOL = c_long 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:52
LONG = c_long 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:53
DWORD = c_ulong 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:54
FLOAT = c_float 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:55
COLORREF = DWORD 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:56
LPCOLORREF = POINTER(DWORD) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:56
HANDLE = POINTER(None) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:58
HGLRC = HANDLE 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:60
HDC = HANDLE 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:61
PROC = CFUNCTYPE(INT_PTR) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:63
# C:\cygwin\home\Alex\pyglet\tools\wgl.h:65
wglCopyContext = _link_function('wglCopyContext', BOOL, [HGLRC, HGLRC, UINT], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:66
wglCreateContext = _link_function('wglCreateContext', HGLRC, [HDC], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:67
wglCreateLayerContext = _link_function('wglCreateLayerContext', HGLRC, [HDC, c_int], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:68
wglDeleteContext = _link_function('wglDeleteContext', BOOL, [HGLRC], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:69
wglGetCurrentContext = _link_function('wglGetCurrentContext', HGLRC, [], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:70
wglGetCurrentDC = _link_function('wglGetCurrentDC', HDC, [], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:71
wglGetProcAddress = _link_function('wglGetProcAddress', PROC, [LPCSTR], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:72
wglMakeCurrent = _link_function('wglMakeCurrent', BOOL, [HDC, HGLRC], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:73
wglShareLists = _link_function('wglShareLists', BOOL, [HGLRC, HGLRC], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:74
wglUseFontBitmapsA = _link_function('wglUseFontBitmapsA', BOOL, [HDC, DWORD, DWORD, DWORD], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:75
wglUseFontBitmapsW = _link_function('wglUseFontBitmapsW', BOOL, [HDC, DWORD, DWORD, DWORD], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:76
SwapBuffers = _link_function('SwapBuffers', BOOL, [HDC], None)

class struct__POINTFLOAT(Structure):
    __slots__ = [
        'x',
        'y',
    ]
struct__POINTFLOAT._fields_ = [
    ('x', FLOAT),
    ('y', FLOAT),
]

POINTFLOAT = struct__POINTFLOAT 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:81
PPOINTFLOAT = POINTER(struct__POINTFLOAT) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:81
class struct__GLYPHMETRICSFLOAT(Structure):
    __slots__ = [
        'gmfBlackBoxX',
        'gmfBlackBoxY',
        'gmfptGlyphOrigin',
        'gmfCellIncX',
        'gmfCellIncY',
    ]
struct__GLYPHMETRICSFLOAT._fields_ = [
    ('gmfBlackBoxX', FLOAT),
    ('gmfBlackBoxY', FLOAT),
    ('gmfptGlyphOrigin', POINTFLOAT),
    ('gmfCellIncX', FLOAT),
    ('gmfCellIncY', FLOAT),
]

GLYPHMETRICSFLOAT = struct__GLYPHMETRICSFLOAT 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:89
PGLYPHMETRICSFLOAT = POINTER(struct__GLYPHMETRICSFLOAT) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:89
LPGLYPHMETRICSFLOAT = POINTER(struct__GLYPHMETRICSFLOAT) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:89
WGL_FONT_LINES = 0 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:91
WGL_FONT_POLYGONS = 1 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:92
# C:\cygwin\home\Alex\pyglet\tools\wgl.h:93
wglUseFontOutlinesA = _link_function('wglUseFontOutlinesA', BOOL, [HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, c_int, LPGLYPHMETRICSFLOAT], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:95
wglUseFontOutlinesW = _link_function('wglUseFontOutlinesW', BOOL, [HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, c_int, LPGLYPHMETRICSFLOAT], None)

class struct_tagLAYERPLANEDESCRIPTOR(Structure):
    __slots__ = [
        'nSize',
        'nVersion',
        'dwFlags',
        'iPixelType',
        'cColorBits',
        'cRedBits',
        'cRedShift',
        'cGreenBits',
        'cGreenShift',
        'cBlueBits',
        'cBlueShift',
        'cAlphaBits',
        'cAlphaShift',
        'cAccumBits',
        'cAccumRedBits',
        'cAccumGreenBits',
        'cAccumBlueBits',
        'cAccumAlphaBits',
        'cDepthBits',
        'cStencilBits',
        'cAuxBuffers',
        'iLayerPlane',
        'bReserved',
        'crTransparent',
    ]
struct_tagLAYERPLANEDESCRIPTOR._fields_ = [
    ('nSize', WORD),
    ('nVersion', WORD),
    ('dwFlags', DWORD),
    ('iPixelType', BYTE),
    ('cColorBits', BYTE),
    ('cRedBits', BYTE),
    ('cRedShift', BYTE),
    ('cGreenBits', BYTE),
    ('cGreenShift', BYTE),
    ('cBlueBits', BYTE),
    ('cBlueShift', BYTE),
    ('cAlphaBits', BYTE),
    ('cAlphaShift', BYTE),
    ('cAccumBits', BYTE),
    ('cAccumRedBits', BYTE),
    ('cAccumGreenBits', BYTE),
    ('cAccumBlueBits', BYTE),
    ('cAccumAlphaBits', BYTE),
    ('cDepthBits', BYTE),
    ('cStencilBits', BYTE),
    ('cAuxBuffers', BYTE),
    ('iLayerPlane', BYTE),
    ('bReserved', BYTE),
    ('crTransparent', COLORREF),
]

LAYERPLANEDESCRIPTOR = struct_tagLAYERPLANEDESCRIPTOR 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:125
PLAYERPLANEDESCRIPTOR = POINTER(struct_tagLAYERPLANEDESCRIPTOR) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:125
LPLAYERPLANEDESCRIPTOR = POINTER(struct_tagLAYERPLANEDESCRIPTOR) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:125
LPD_DOUBLEBUFFER = 1 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:128
LPD_STEREO = 2 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:129
LPD_SUPPORT_GDI = 16 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:130
LPD_SUPPORT_OPENGL = 32 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:131
LPD_SHARE_DEPTH = 64 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:132
LPD_SHARE_STENCIL = 128 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:133
LPD_SHARE_ACCUM = 256 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:134
LPD_SWAP_EXCHANGE = 512 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:135
LPD_SWAP_COPY = 1024 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:136
LPD_TRANSPARENT = 4096 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:137
LPD_TYPE_RGBA = 0 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:139
LPD_TYPE_COLORINDEX = 1 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:140
WGL_SWAP_MAIN_PLANE = 1 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:143
WGL_SWAP_OVERLAY1 = 2 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:144
WGL_SWAP_OVERLAY2 = 4 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:145
WGL_SWAP_OVERLAY3 = 8 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:146
WGL_SWAP_OVERLAY4 = 16 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:147
WGL_SWAP_OVERLAY5 = 32 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:148
WGL_SWAP_OVERLAY6 = 64 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:149
WGL_SWAP_OVERLAY7 = 128 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:150
WGL_SWAP_OVERLAY8 = 256 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:151
WGL_SWAP_OVERLAY9 = 512 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:152
WGL_SWAP_OVERLAY10 = 1024 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:153
WGL_SWAP_OVERLAY11 = 2048 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:154
WGL_SWAP_OVERLAY12 = 4096 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:155
WGL_SWAP_OVERLAY13 = 8192 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:156
WGL_SWAP_OVERLAY14 = 16384 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:157
WGL_SWAP_OVERLAY15 = 32768 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:158
WGL_SWAP_UNDERLAY1 = 65536 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:159
WGL_SWAP_UNDERLAY2 = 131072 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:160
WGL_SWAP_UNDERLAY3 = 262144 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:161
WGL_SWAP_UNDERLAY4 = 524288 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:162
WGL_SWAP_UNDERLAY5 = 1048576 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:163
WGL_SWAP_UNDERLAY6 = 2097152 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:164
WGL_SWAP_UNDERLAY7 = 4194304 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:165
WGL_SWAP_UNDERLAY8 = 8388608 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:166
WGL_SWAP_UNDERLAY9 = 16777216 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:167
WGL_SWAP_UNDERLAY10 = 33554432 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:168
WGL_SWAP_UNDERLAY11 = 67108864 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:169
WGL_SWAP_UNDERLAY12 = 134217728 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:170
WGL_SWAP_UNDERLAY13 = 268435456 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:171
WGL_SWAP_UNDERLAY14 = 536870912 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:172
WGL_SWAP_UNDERLAY15 = 1073741824 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:173
# C:\cygwin\home\Alex\pyglet\tools\wgl.h:175
wglDescribeLayerPlane = _link_function('wglDescribeLayerPlane', BOOL, [HDC, c_int, c_int, UINT, LPLAYERPLANEDESCRIPTOR], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:177
wglSetLayerPaletteEntries = _link_function('wglSetLayerPaletteEntries', c_int, [HDC, c_int, c_int, c_int, POINTER(COLORREF)], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:179
wglGetLayerPaletteEntries = _link_function('wglGetLayerPaletteEntries', c_int, [HDC, c_int, c_int, c_int, POINTER(COLORREF)], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:181
wglRealizeLayerPalette = _link_function('wglRealizeLayerPalette', BOOL, [HDC, c_int, BOOL], None)

# C:\cygwin\home\Alex\pyglet\tools\wgl.h:182
wglSwapLayerBuffers = _link_function('wglSwapLayerBuffers', BOOL, [HDC, UINT], None)

class struct__WGLSWAP(Structure):
    __slots__ = [
        'hdc',
        'uiFlags',
    ]
struct__WGLSWAP._fields_ = [
    ('hdc', HDC),
    ('uiFlags', UINT),
]

WGLSWAP = struct__WGLSWAP 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:188
PWGLSWAP = POINTER(struct__WGLSWAP) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:188
LPWGLSWAP = POINTER(struct__WGLSWAP) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:188
WGL_SWAPMULTIPLE_MAX = 16 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:190
# C:\cygwin\home\Alex\pyglet\tools\wgl.h:192
wglSwapMultipleBuffers = _link_function('wglSwapMultipleBuffers', DWORD, [UINT, POINTER(WGLSWAP)], None)

class struct_tagRECT(Structure):
    __slots__ = [
        'left',
        'top',
        'right',
        'bottom',
    ]
struct_tagRECT._fields_ = [
    ('left', LONG),
    ('top', LONG),
    ('right', LONG),
    ('bottom', LONG),
]

RECT = struct_tagRECT 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:200
PRECT = POINTER(struct_tagRECT) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:200
NPRECT = POINTER(struct_tagRECT) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:200
LPRECT = POINTER(struct_tagRECT) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:200

__all__ = ['CONST', 'GLenum', 'GLboolean', 'GLbitfield', 'GLbyte', 'GLshort',
'GLint', 'GLsizei', 'GLubyte', 'GLushort', 'GLuint', 'GLfloat', 'GLclampf',
'GLdouble', 'GLclampd', 'GLvoid', 'INT8', 'PINT8', 'INT16', 'PINT16', 'INT32',
'PINT32', 'UINT8', 'PUINT8', 'UINT16', 'PUINT16', 'UINT32', 'PUINT32',
'LONG32', 'PLONG32', 'ULONG32', 'PULONG32', 'DWORD32', 'PDWORD32', 'INT64',
'PINT64', 'UINT64', 'PUINT64', 'VOID', 'LPVOID', 'LPCSTR', 'CHAR', 'BYTE',
'WORD', 'USHORT', 'UINT', 'INT', 'INT_PTR', 'BOOL', 'LONG', 'DWORD', 'FLOAT',
'COLORREF', 'LPCOLORREF', 'HANDLE', 'HGLRC', 'HDC', 'PROC', 'wglCopyContext',
'wglCreateContext', 'wglCreateLayerContext', 'wglDeleteContext',
'wglGetCurrentContext', 'wglGetCurrentDC', 'wglGetProcAddress',
'wglMakeCurrent', 'wglShareLists', 'wglUseFontBitmapsA', 'wglUseFontBitmapsW',
'SwapBuffers', 'POINTFLOAT', 'PPOINTFLOAT', 'GLYPHMETRICSFLOAT',
'PGLYPHMETRICSFLOAT', 'LPGLYPHMETRICSFLOAT', 'WGL_FONT_LINES',
'WGL_FONT_POLYGONS', 'wglUseFontOutlinesA', 'wglUseFontOutlinesW',
'LAYERPLANEDESCRIPTOR', 'PLAYERPLANEDESCRIPTOR', 'LPLAYERPLANEDESCRIPTOR',
'LPD_DOUBLEBUFFER', 'LPD_STEREO', 'LPD_SUPPORT_GDI', 'LPD_SUPPORT_OPENGL',
'LPD_SHARE_DEPTH', 'LPD_SHARE_STENCIL', 'LPD_SHARE_ACCUM',
'LPD_SWAP_EXCHANGE', 'LPD_SWAP_COPY', 'LPD_TRANSPARENT', 'LPD_TYPE_RGBA',
'LPD_TYPE_COLORINDEX', 'WGL_SWAP_MAIN_PLANE', 'WGL_SWAP_OVERLAY1',
'WGL_SWAP_OVERLAY2', 'WGL_SWAP_OVERLAY3', 'WGL_SWAP_OVERLAY4',
'WGL_SWAP_OVERLAY5', 'WGL_SWAP_OVERLAY6', 'WGL_SWAP_OVERLAY7',
'WGL_SWAP_OVERLAY8', 'WGL_SWAP_OVERLAY9', 'WGL_SWAP_OVERLAY10',
'WGL_SWAP_OVERLAY11', 'WGL_SWAP_OVERLAY12', 'WGL_SWAP_OVERLAY13',
'WGL_SWAP_OVERLAY14', 'WGL_SWAP_OVERLAY15', 'WGL_SWAP_UNDERLAY1',
'WGL_SWAP_UNDERLAY2', 'WGL_SWAP_UNDERLAY3', 'WGL_SWAP_UNDERLAY4',
'WGL_SWAP_UNDERLAY5', 'WGL_SWAP_UNDERLAY6', 'WGL_SWAP_UNDERLAY7',
'WGL_SWAP_UNDERLAY8', 'WGL_SWAP_UNDERLAY9', 'WGL_SWAP_UNDERLAY10',
'WGL_SWAP_UNDERLAY11', 'WGL_SWAP_UNDERLAY12', 'WGL_SWAP_UNDERLAY13',
'WGL_SWAP_UNDERLAY14', 'WGL_SWAP_UNDERLAY15', 'wglDescribeLayerPlane',
'wglSetLayerPaletteEntries', 'wglGetLayerPaletteEntries',
'wglRealizeLayerPalette', 'wglSwapLayerBuffers', 'WGLSWAP', 'PWGLSWAP',
'LPWGLSWAP', 'WGL_SWAPMULTIPLE_MAX', 'wglSwapMultipleBuffers', 'RECT',
'PRECT', 'NPRECT', 'LPRECT']
# END GENERATED CONTENT (do not edit above this line)


########NEW FILE########
__FILENAME__ = wglext_arb
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h

Generated by tools/gengl.py.
Do not modify this file.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: gengl.py 601 2007-02-04 05:36:59Z Alex.Holkner $'

from ctypes import *
from pyglet.gl.lib import link_WGL as _link_function
from pyglet.gl.lib import c_ptrdiff_t, c_void



# BEGIN GENERATED CONTENT (do not edit below this line)

# This content is generated by tools/gengl.py.
# Wrapper for http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h


# H (C:\cygwin\home\Alex\pyglet\tools\wgl.h:7)
# H (C:\cygwin\home\Alex\pyglet\tools\wgl.h:7)
WIN32_LEAN_AND_MEAN = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:40
GLAPI = 0 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:51
WGL_WGLEXT_VERSION = 6 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:59
# ARB_buffer_region (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:61)
WGL_FRONT_COLOR_BUFFER_BIT_ARB = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:62
WGL_BACK_COLOR_BUFFER_BIT_ARB = 2 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:63
WGL_DEPTH_BUFFER_BIT_ARB = 4 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:64
WGL_STENCIL_BUFFER_BIT_ARB = 8 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:65
# ARB_multisample (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:68)
WGL_SAMPLE_BUFFERS_ARB = 8257 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:69
WGL_SAMPLES_ARB = 8258 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:70
# ARB_extensions_string (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:73)
# ARB_pixel_format (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:76)
WGL_NUMBER_PIXEL_FORMATS_ARB = 8192 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:77
WGL_DRAW_TO_WINDOW_ARB = 8193 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:78
WGL_DRAW_TO_BITMAP_ARB = 8194 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:79
WGL_ACCELERATION_ARB = 8195 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:80
WGL_NEED_PALETTE_ARB = 8196 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:81
WGL_NEED_SYSTEM_PALETTE_ARB = 8197 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:82
WGL_SWAP_LAYER_BUFFERS_ARB = 8198 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:83
WGL_SWAP_METHOD_ARB = 8199 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:84
WGL_NUMBER_OVERLAYS_ARB = 8200 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:85
WGL_NUMBER_UNDERLAYS_ARB = 8201 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:86
WGL_TRANSPARENT_ARB = 8202 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:87
WGL_TRANSPARENT_RED_VALUE_ARB = 8247 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:88
WGL_TRANSPARENT_GREEN_VALUE_ARB = 8248 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:89
WGL_TRANSPARENT_BLUE_VALUE_ARB = 8249 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:90
WGL_TRANSPARENT_ALPHA_VALUE_ARB = 8250 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:91
WGL_TRANSPARENT_INDEX_VALUE_ARB = 8251 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:92
WGL_SHARE_DEPTH_ARB = 8204 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:93
WGL_SHARE_STENCIL_ARB = 8205 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:94
WGL_SHARE_ACCUM_ARB = 512 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:95
WGL_SUPPORT_GDI_ARB = 512 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:96
WGL_SUPPORT_OPENGL_ARB = 8208 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:97
WGL_DOUBLE_BUFFER_ARB = 8209 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:98
WGL_STEREO_ARB = 8210 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:99
WGL_PIXEL_TYPE_ARB = 8211 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:100
WGL_COLOR_BITS_ARB = 8212 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:101
WGL_RED_BITS_ARB = 8213 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:102
WGL_RED_SHIFT_ARB = 8214 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:103
WGL_GREEN_BITS_ARB = 8215 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:104
WGL_GREEN_SHIFT_ARB = 8216 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:105
WGL_BLUE_BITS_ARB = 8217 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:106
WGL_BLUE_SHIFT_ARB = 8218 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:107
WGL_ALPHA_BITS_ARB = 8219 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:108
WGL_ALPHA_SHIFT_ARB = 8220 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:109
WGL_ACCUM_BITS_ARB = 8221 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:110
WGL_ACCUM_RED_BITS_ARB = 513 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:111
WGL_ACCUM_GREEN_BITS_ARB = 513 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:112
WGL_ACCUM_BLUE_BITS_ARB = 8224 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:113
WGL_ACCUM_ALPHA_BITS_ARB = 8225 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:114
WGL_DEPTH_BITS_ARB = 8226 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:115
WGL_STENCIL_BITS_ARB = 8227 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:116
WGL_AUX_BUFFERS_ARB = 8228 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:117
WGL_NO_ACCELERATION_ARB = 8229 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:118
WGL_GENERIC_ACCELERATION_ARB = 8230 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:119
WGL_FULL_ACCELERATION_ARB = 8231 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:120
WGL_SWAP_EXCHANGE_ARB = 8232 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:121
WGL_SWAP_COPY_ARB = 8233 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:122
WGL_SWAP_UNDEFINED_ARB = 8234 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:123
WGL_TYPE_RGBA_ARB = 8235 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:124
WGL_TYPE_COLORINDEX_ARB = 8236 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:125
# ARB_make_current_read (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:128)
ERROR_INVALID_PIXEL_TYPE_ARB = 8259 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:129
ERROR_INCOMPATIBLE_DEVICE_CONTEXTS_ARB = 8276 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:130
# ARB_pbuffer (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:133)
WGL_DRAW_TO_PBUFFER_ARB = 8237 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:134
WGL_MAX_PBUFFER_PIXELS_ARB = 514 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:135
WGL_MAX_PBUFFER_WIDTH_ARB = 514 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:136
WGL_MAX_PBUFFER_HEIGHT_ARB = 8240 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:137
WGL_PBUFFER_LARGEST_ARB = 8243 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:138
WGL_PBUFFER_WIDTH_ARB = 8244 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:139
WGL_PBUFFER_HEIGHT_ARB = 8245 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:140
WGL_PBUFFER_LOST_ARB = 8246 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:141
# ARB_render_texture (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:144)
WGL_BIND_TO_TEXTURE_RGB_ARB = 8304 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:145
WGL_BIND_TO_TEXTURE_RGBA_ARB = 8305 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:146
WGL_TEXTURE_FORMAT_ARB = 8306 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:147
WGL_TEXTURE_TARGET_ARB = 8307 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:148
WGL_MIPMAP_TEXTURE_ARB = 8308 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:149
WGL_TEXTURE_RGB_ARB = 8309 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:150
WGL_TEXTURE_RGBA_ARB = 8310 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:151
WGL_NO_TEXTURE_ARB = 8311 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:152
WGL_TEXTURE_CUBE_MAP_ARB = 8312 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:153
WGL_TEXTURE_1D_ARB = 8313 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:154
WGL_TEXTURE_2D_ARB = 8314 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:155
WGL_MIPMAP_LEVEL_ARB = 8315 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:156
WGL_CUBE_MAP_FACE_ARB = 8316 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:157
WGL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB = 8317 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:158
WGL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB = 519 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:159
WGL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB = 519 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:160
WGL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB = 8320 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:161
WGL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB = 8321 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:162
WGL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB = 8322 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:163
WGL_FRONT_LEFT_ARB = 8323 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:164
WGL_FRONT_RIGHT_ARB = 8324 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:165
WGL_BACK_LEFT_ARB = 8325 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:166
WGL_BACK_RIGHT_ARB = 8326 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:167
WGL_AUX0_ARB = 8327 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:168
WGL_AUX1_ARB = 8328 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:169
WGL_AUX2_ARB = 8329 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:170
WGL_AUX3_ARB = 8330 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:171
WGL_AUX4_ARB = 8331 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:172
WGL_AUX5_ARB = 8332 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:173
WGL_AUX6_ARB = 8333 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:174
WGL_AUX7_ARB = 520 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:175
WGL_AUX8_ARB = 520 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:176
WGL_AUX9_ARB = 8336 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:177
# ARB_pixel_format_float (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:180)
WGL_TYPE_RGBA_FLOAT_ARB = 8608 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:181
# EXT_make_current_read (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:184)
ERROR_INVALID_PIXEL_TYPE_EXT = 8259 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:185
# EXT_pixel_format (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:188)
WGL_NUMBER_PIXEL_FORMATS_EXT = 8192 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:189
WGL_DRAW_TO_WINDOW_EXT = 8193 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:190
WGL_DRAW_TO_BITMAP_EXT = 8194 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:191
WGL_ACCELERATION_EXT = 8195 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:192
WGL_NEED_PALETTE_EXT = 8196 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:193
WGL_NEED_SYSTEM_PALETTE_EXT = 8197 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:194
WGL_SWAP_LAYER_BUFFERS_EXT = 8198 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:195
WGL_SWAP_METHOD_EXT = 8199 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:196
WGL_NUMBER_OVERLAYS_EXT = 8200 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:197
WGL_NUMBER_UNDERLAYS_EXT = 8201 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:198
WGL_TRANSPARENT_EXT = 8202 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:199
WGL_TRANSPARENT_VALUE_EXT = 8203 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:200
WGL_SHARE_DEPTH_EXT = 8204 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:201
WGL_SHARE_STENCIL_EXT = 8205 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:202
WGL_SHARE_ACCUM_EXT = 512 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:203
WGL_SUPPORT_GDI_EXT = 512 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:204
WGL_SUPPORT_OPENGL_EXT = 8208 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:205
WGL_DOUBLE_BUFFER_EXT = 8209 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:206
WGL_STEREO_EXT = 8210 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:207
WGL_PIXEL_TYPE_EXT = 8211 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:208
WGL_COLOR_BITS_EXT = 8212 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:209
WGL_RED_BITS_EXT = 8213 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:210
WGL_RED_SHIFT_EXT = 8214 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:211
WGL_GREEN_BITS_EXT = 8215 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:212
WGL_GREEN_SHIFT_EXT = 8216 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:213
WGL_BLUE_BITS_EXT = 8217 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:214
WGL_BLUE_SHIFT_EXT = 8218 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:215
WGL_ALPHA_BITS_EXT = 8219 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:216
WGL_ALPHA_SHIFT_EXT = 8220 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:217
WGL_ACCUM_BITS_EXT = 8221 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:218
WGL_ACCUM_RED_BITS_EXT = 513 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:219
WGL_ACCUM_GREEN_BITS_EXT = 513 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:220
WGL_ACCUM_BLUE_BITS_EXT = 8224 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:221
WGL_ACCUM_ALPHA_BITS_EXT = 8225 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:222
WGL_DEPTH_BITS_EXT = 8226 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:223
WGL_STENCIL_BITS_EXT = 8227 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:224
WGL_AUX_BUFFERS_EXT = 8228 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:225
WGL_NO_ACCELERATION_EXT = 8229 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:226
WGL_GENERIC_ACCELERATION_EXT = 8230 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:227
WGL_FULL_ACCELERATION_EXT = 8231 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:228
WGL_SWAP_EXCHANGE_EXT = 8232 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:229
WGL_SWAP_COPY_EXT = 8233 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:230
WGL_SWAP_UNDEFINED_EXT = 8234 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:231
WGL_TYPE_RGBA_EXT = 8235 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:232
WGL_TYPE_COLORINDEX_EXT = 8236 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:233
# EXT_pbuffer (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:236)
WGL_DRAW_TO_PBUFFER_EXT = 8237 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:237
WGL_MAX_PBUFFER_PIXELS_EXT = 514 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:238
WGL_MAX_PBUFFER_WIDTH_EXT = 514 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:239
WGL_MAX_PBUFFER_HEIGHT_EXT = 8240 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:240
WGL_OPTIMAL_PBUFFER_WIDTH_EXT = 8241 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:241
WGL_OPTIMAL_PBUFFER_HEIGHT_EXT = 8242 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:242
WGL_PBUFFER_LARGEST_EXT = 8243 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:243
WGL_PBUFFER_WIDTH_EXT = 8244 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:244
WGL_PBUFFER_HEIGHT_EXT = 8245 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:245
# EXT_depth_float (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:248)
WGL_DEPTH_FLOAT_EXT = 8256 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:249
# 3DFX_multisample (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:252)
WGL_SAMPLE_BUFFERS_3DFX = 8288 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:253
WGL_SAMPLES_3DFX = 8289 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:254
# EXT_multisample (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:257)
WGL_SAMPLE_BUFFERS_EXT = 8257 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:258
WGL_SAMPLES_EXT = 8258 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:259
# I3D_digital_video_control (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:262)
WGL_DIGITAL_VIDEO_CURSOR_ALPHA_FRAMEBUFFER_I3D = 8272 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:263
WGL_DIGITAL_VIDEO_CURSOR_ALPHA_VALUE_I3D = 8273 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:264
WGL_DIGITAL_VIDEO_CURSOR_INCLUDED_I3D = 8274 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:265
WGL_DIGITAL_VIDEO_GAMMA_CORRECTED_I3D = 8275 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:266
# I3D_gamma (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:269)
WGL_GAMMA_TABLE_SIZE_I3D = 516 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:270
WGL_GAMMA_EXCLUDE_DESKTOP_I3D = 516 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:271
# I3D_genlock (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:274)
WGL_GENLOCK_SOURCE_MULTIVIEW_I3D = 8260 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:275
WGL_GENLOCK_SOURCE_EXTENAL_SYNC_I3D = 8261 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:276
WGL_GENLOCK_SOURCE_EXTENAL_FIELD_I3D = 8262 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:277
WGL_GENLOCK_SOURCE_EXTENAL_TTL_I3D = 8263 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:278
WGL_GENLOCK_SOURCE_DIGITAL_SYNC_I3D = 8264 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:279
WGL_GENLOCK_SOURCE_DIGITAL_FIELD_I3D = 8265 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:280
WGL_GENLOCK_SOURCE_EDGE_FALLING_I3D = 8266 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:281
WGL_GENLOCK_SOURCE_EDGE_RISING_I3D = 8267 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:282
WGL_GENLOCK_SOURCE_EDGE_BOTH_I3D = 8268 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:283
# I3D_image_buffer (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:286)
WGL_IMAGE_BUFFER_MIN_ACCESS_I3D = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:287
WGL_IMAGE_BUFFER_LOCK_I3D = 2 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:288
# I3D_swap_frame_lock (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:291)
# NV_render_depth_texture (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:294)
WGL_BIND_TO_TEXTURE_DEPTH_NV = 8355 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:295
WGL_BIND_TO_TEXTURE_RECTANGLE_DEPTH_NV = 8356 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:296
WGL_DEPTH_TEXTURE_FORMAT_NV = 8357 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:297
WGL_TEXTURE_DEPTH_COMPONENT_NV = 8358 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:298
WGL_DEPTH_COMPONENT_NV = 8359 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:299
# NV_render_texture_rectangle (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:302)
WGL_BIND_TO_TEXTURE_RECTANGLE_RGB_NV = 8352 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:303
WGL_BIND_TO_TEXTURE_RECTANGLE_RGBA_NV = 8353 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:304
WGL_TEXTURE_RECTANGLE_NV = 8354 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:305
# ATI_pixel_format_float (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:308)
WGL_TYPE_RGBA_FLOAT_ATI = 8608 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:309
# NV_float_buffer (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:312)
WGL_FLOAT_COMPONENTS_NV = 8368 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:313
WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_R_NV = 8369 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:314
WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RG_NV = 8370 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:315
WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGB_NV = 8371 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:316
WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGBA_NV = 8372 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:317
WGL_TEXTURE_FLOAT_R_NV = 8373 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:318
WGL_TEXTURE_FLOAT_RG_NV = 8374 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:319
WGL_TEXTURE_FLOAT_RGB_NV = 8375 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:320
WGL_TEXTURE_FLOAT_RGBA_NV = 8376 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:321
# ARB_pbuffer (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:327)
HANDLE = POINTER(None) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:58
HPBUFFERARB = HANDLE 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:328
# EXT_pbuffer (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:330)
HPBUFFEREXT = HANDLE 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:331
# ARB_buffer_region (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:334)
WGL_ARB_buffer_region = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:335
HDC = HANDLE 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:61
UINT = c_uint 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:50
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:337
wglCreateBufferRegionARB = _link_function('wglCreateBufferRegionARB', HANDLE, [HDC, c_int, UINT], 'ARB_buffer_region')

VOID = None 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:45
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:338
wglDeleteBufferRegionARB = _link_function('wglDeleteBufferRegionARB', VOID, [HANDLE], 'ARB_buffer_region')

BOOL = c_long 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:52
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:339
wglSaveBufferRegionARB = _link_function('wglSaveBufferRegionARB', BOOL, [HANDLE, c_int, c_int, c_int, c_int], 'ARB_buffer_region')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:340
wglRestoreBufferRegionARB = _link_function('wglRestoreBufferRegionARB', BOOL, [HANDLE, c_int, c_int, c_int, c_int, c_int, c_int], 'ARB_buffer_region')

PFNWGLCREATEBUFFERREGIONARBPROC = CFUNCTYPE(HANDLE, HDC, c_int, UINT) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:342
PFNWGLDELETEBUFFERREGIONARBPROC = CFUNCTYPE(VOID, HANDLE) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:343
PFNWGLSAVEBUFFERREGIONARBPROC = CFUNCTYPE(BOOL, HANDLE, c_int, c_int, c_int, c_int) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:344
PFNWGLRESTOREBUFFERREGIONARBPROC = CFUNCTYPE(BOOL, HANDLE, c_int, c_int, c_int, c_int, c_int, c_int) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:345
# ARB_multisample (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:348)
WGL_ARB_multisample = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:349
# ARB_extensions_string (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:352)
WGL_ARB_extensions_string = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:353
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:355
wglGetExtensionsStringARB = _link_function('wglGetExtensionsStringARB', c_char_p, [HDC], 'ARB_extensions_string')

PFNWGLGETEXTENSIONSSTRINGARBPROC = CFUNCTYPE(c_char_p, HDC) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:357
# ARB_pixel_format (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:360)
WGL_ARB_pixel_format = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:361
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:363
wglGetPixelFormatAttribivARB = _link_function('wglGetPixelFormatAttribivARB', BOOL, [HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(c_int)], 'ARB_pixel_format')

FLOAT = c_float 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:55
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:364
wglGetPixelFormatAttribfvARB = _link_function('wglGetPixelFormatAttribfvARB', BOOL, [HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(FLOAT)], 'ARB_pixel_format')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:365
wglChoosePixelFormatARB = _link_function('wglChoosePixelFormatARB', BOOL, [HDC, POINTER(c_int), POINTER(FLOAT), UINT, POINTER(c_int), POINTER(UINT)], 'ARB_pixel_format')

PFNWGLGETPIXELFORMATATTRIBIVARBPROC = CFUNCTYPE(BOOL, HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(c_int)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:367
PFNWGLGETPIXELFORMATATTRIBFVARBPROC = CFUNCTYPE(BOOL, HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(FLOAT)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:368
PFNWGLCHOOSEPIXELFORMATARBPROC = CFUNCTYPE(BOOL, HDC, POINTER(c_int), POINTER(FLOAT), UINT, POINTER(c_int), POINTER(UINT)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:369
# ARB_make_current_read (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:372)
WGL_ARB_make_current_read = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:373
HGLRC = HANDLE 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:60
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:375
wglMakeContextCurrentARB = _link_function('wglMakeContextCurrentARB', BOOL, [HDC, HDC, HGLRC], 'ARB_make_current_read')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:376
wglGetCurrentReadDCARB = _link_function('wglGetCurrentReadDCARB', HDC, [], 'ARB_make_current_read')

PFNWGLMAKECONTEXTCURRENTARBPROC = CFUNCTYPE(BOOL, HDC, HDC, HGLRC) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:378
PFNWGLGETCURRENTREADDCARBPROC = CFUNCTYPE(HDC) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:379
# ARB_pbuffer (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:382)
WGL_ARB_pbuffer = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:383
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:385
wglCreatePbufferARB = _link_function('wglCreatePbufferARB', HPBUFFERARB, [HDC, c_int, c_int, c_int, POINTER(c_int)], 'ARB_pbuffer')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:386
wglGetPbufferDCARB = _link_function('wglGetPbufferDCARB', HDC, [HPBUFFERARB], 'ARB_pbuffer')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:387
wglReleasePbufferDCARB = _link_function('wglReleasePbufferDCARB', c_int, [HPBUFFERARB, HDC], 'ARB_pbuffer')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:388
wglDestroyPbufferARB = _link_function('wglDestroyPbufferARB', BOOL, [HPBUFFERARB], 'ARB_pbuffer')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:389
wglQueryPbufferARB = _link_function('wglQueryPbufferARB', BOOL, [HPBUFFERARB, c_int, POINTER(c_int)], 'ARB_pbuffer')

PFNWGLCREATEPBUFFERARBPROC = CFUNCTYPE(HPBUFFERARB, HDC, c_int, c_int, c_int, POINTER(c_int)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:391
PFNWGLGETPBUFFERDCARBPROC = CFUNCTYPE(HDC, HPBUFFERARB) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:392
PFNWGLRELEASEPBUFFERDCARBPROC = CFUNCTYPE(c_int, HPBUFFERARB, HDC) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:393
PFNWGLDESTROYPBUFFERARBPROC = CFUNCTYPE(BOOL, HPBUFFERARB) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:394
PFNWGLQUERYPBUFFERARBPROC = CFUNCTYPE(BOOL, HPBUFFERARB, c_int, POINTER(c_int)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:395
# ARB_render_texture (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:398)
WGL_ARB_render_texture = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:399
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:401
wglBindTexImageARB = _link_function('wglBindTexImageARB', BOOL, [HPBUFFERARB, c_int], 'ARB_render_texture')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:402
wglReleaseTexImageARB = _link_function('wglReleaseTexImageARB', BOOL, [HPBUFFERARB, c_int], 'ARB_render_texture')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:403
wglSetPbufferAttribARB = _link_function('wglSetPbufferAttribARB', BOOL, [HPBUFFERARB, POINTER(c_int)], 'ARB_render_texture')

PFNWGLBINDTEXIMAGEARBPROC = CFUNCTYPE(BOOL, HPBUFFERARB, c_int) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:405
PFNWGLRELEASETEXIMAGEARBPROC = CFUNCTYPE(BOOL, HPBUFFERARB, c_int) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:406
PFNWGLSETPBUFFERATTRIBARBPROC = CFUNCTYPE(BOOL, HPBUFFERARB, POINTER(c_int)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:407
# ARB_pixel_format_float (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:410)
WGL_ARB_pixel_format_float = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:411
# EXT_display_color_table (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:414)
WGL_EXT_display_color_table = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:415
GLboolean = c_ubyte 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:18
GLushort = c_ushort 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:25
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:417
wglCreateDisplayColorTableEXT = _link_function('wglCreateDisplayColorTableEXT', GLboolean, [GLushort], 'EXT_display_color_table')

GLuint = c_uint 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:26
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:418
wglLoadDisplayColorTableEXT = _link_function('wglLoadDisplayColorTableEXT', GLboolean, [POINTER(GLushort), GLuint], 'EXT_display_color_table')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:419
wglBindDisplayColorTableEXT = _link_function('wglBindDisplayColorTableEXT', GLboolean, [GLushort], 'EXT_display_color_table')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:420
wglDestroyDisplayColorTableEXT = _link_function('wglDestroyDisplayColorTableEXT', VOID, [GLushort], 'EXT_display_color_table')

PFNWGLCREATEDISPLAYCOLORTABLEEXTPROC = CFUNCTYPE(GLboolean, GLushort) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:422
PFNWGLLOADDISPLAYCOLORTABLEEXTPROC = CFUNCTYPE(GLboolean, POINTER(GLushort), GLuint) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:423
PFNWGLBINDDISPLAYCOLORTABLEEXTPROC = CFUNCTYPE(GLboolean, GLushort) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:424
PFNWGLDESTROYDISPLAYCOLORTABLEEXTPROC = CFUNCTYPE(VOID, GLushort) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:425
# EXT_extensions_string (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:428)
WGL_EXT_extensions_string = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:429
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:431
wglGetExtensionsStringEXT = _link_function('wglGetExtensionsStringEXT', c_char_p, [], 'EXT_extensions_string')

PFNWGLGETEXTENSIONSSTRINGEXTPROC = CFUNCTYPE(c_char_p) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:433
# EXT_make_current_read (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:436)
WGL_EXT_make_current_read = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:437
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:439
wglMakeContextCurrentEXT = _link_function('wglMakeContextCurrentEXT', BOOL, [HDC, HDC, HGLRC], 'EXT_make_current_read')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:440
wglGetCurrentReadDCEXT = _link_function('wglGetCurrentReadDCEXT', HDC, [], 'EXT_make_current_read')

PFNWGLMAKECONTEXTCURRENTEXTPROC = CFUNCTYPE(BOOL, HDC, HDC, HGLRC) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:442
PFNWGLGETCURRENTREADDCEXTPROC = CFUNCTYPE(HDC) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:443
# EXT_pbuffer (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:446)
WGL_EXT_pbuffer = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:447
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:449
wglCreatePbufferEXT = _link_function('wglCreatePbufferEXT', HPBUFFEREXT, [HDC, c_int, c_int, c_int, POINTER(c_int)], 'EXT_pbuffer')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:450
wglGetPbufferDCEXT = _link_function('wglGetPbufferDCEXT', HDC, [HPBUFFEREXT], 'EXT_pbuffer')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:451
wglReleasePbufferDCEXT = _link_function('wglReleasePbufferDCEXT', c_int, [HPBUFFEREXT, HDC], 'EXT_pbuffer')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:452
wglDestroyPbufferEXT = _link_function('wglDestroyPbufferEXT', BOOL, [HPBUFFEREXT], 'EXT_pbuffer')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:453
wglQueryPbufferEXT = _link_function('wglQueryPbufferEXT', BOOL, [HPBUFFEREXT, c_int, POINTER(c_int)], 'EXT_pbuffer')

PFNWGLCREATEPBUFFEREXTPROC = CFUNCTYPE(HPBUFFEREXT, HDC, c_int, c_int, c_int, POINTER(c_int)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:455
PFNWGLGETPBUFFERDCEXTPROC = CFUNCTYPE(HDC, HPBUFFEREXT) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:456
PFNWGLRELEASEPBUFFERDCEXTPROC = CFUNCTYPE(c_int, HPBUFFEREXT, HDC) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:457
PFNWGLDESTROYPBUFFEREXTPROC = CFUNCTYPE(BOOL, HPBUFFEREXT) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:458
PFNWGLQUERYPBUFFEREXTPROC = CFUNCTYPE(BOOL, HPBUFFEREXT, c_int, POINTER(c_int)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:459
# EXT_pixel_format (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:462)
WGL_EXT_pixel_format = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:463
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:465
wglGetPixelFormatAttribivEXT = _link_function('wglGetPixelFormatAttribivEXT', BOOL, [HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(c_int)], 'EXT_pixel_format')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:466
wglGetPixelFormatAttribfvEXT = _link_function('wglGetPixelFormatAttribfvEXT', BOOL, [HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(FLOAT)], 'EXT_pixel_format')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:467
wglChoosePixelFormatEXT = _link_function('wglChoosePixelFormatEXT', BOOL, [HDC, POINTER(c_int), POINTER(FLOAT), UINT, POINTER(c_int), POINTER(UINT)], 'EXT_pixel_format')

PFNWGLGETPIXELFORMATATTRIBIVEXTPROC = CFUNCTYPE(BOOL, HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(c_int)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:469
PFNWGLGETPIXELFORMATATTRIBFVEXTPROC = CFUNCTYPE(BOOL, HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(FLOAT)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:470
PFNWGLCHOOSEPIXELFORMATEXTPROC = CFUNCTYPE(BOOL, HDC, POINTER(c_int), POINTER(FLOAT), UINT, POINTER(c_int), POINTER(UINT)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:471
# EXT_swap_control (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:474)
WGL_EXT_swap_control = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:475
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:477
wglSwapIntervalEXT = _link_function('wglSwapIntervalEXT', BOOL, [c_int], 'EXT_swap_control')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:478
wglGetSwapIntervalEXT = _link_function('wglGetSwapIntervalEXT', c_int, [], 'EXT_swap_control')

PFNWGLSWAPINTERVALEXTPROC = CFUNCTYPE(BOOL, c_int) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:480
PFNWGLGETSWAPINTERVALEXTPROC = CFUNCTYPE(c_int) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:481
# EXT_depth_float (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:484)
WGL_EXT_depth_float = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:485
# NV_vertex_array_range (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:488)
WGL_NV_vertex_array_range = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:489
GLsizei = c_int 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:23
GLfloat = c_float 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:27
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:491
wglAllocateMemoryNV = _link_function('wglAllocateMemoryNV', POINTER(c_void), [GLsizei, GLfloat, GLfloat, GLfloat], 'NV_vertex_array_range')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:492
wglFreeMemoryNV = _link_function('wglFreeMemoryNV', None, [POINTER(None)], 'NV_vertex_array_range')

PFNWGLALLOCATEMEMORYNVPROC = CFUNCTYPE(POINTER(c_void), GLsizei, GLfloat, GLfloat, GLfloat) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:494
PFNWGLFREEMEMORYNVPROC = CFUNCTYPE(None, POINTER(None)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:495
# 3DFX_multisample (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:498)
WGL_3DFX_multisample = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:499
# EXT_multisample (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:502)
WGL_EXT_multisample = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:503
# OML_sync_control (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:506)
WGL_OML_sync_control = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:507
INT64 = c_longlong 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:42
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:509
wglGetSyncValuesOML = _link_function('wglGetSyncValuesOML', BOOL, [HDC, POINTER(INT64), POINTER(INT64), POINTER(INT64)], 'OML_sync_control')

INT32 = c_int 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:35
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:510
wglGetMscRateOML = _link_function('wglGetMscRateOML', BOOL, [HDC, POINTER(INT32), POINTER(INT32)], 'OML_sync_control')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:511
wglSwapBuffersMscOML = _link_function('wglSwapBuffersMscOML', INT64, [HDC, INT64, INT64, INT64], 'OML_sync_control')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:512
wglSwapLayerBuffersMscOML = _link_function('wglSwapLayerBuffersMscOML', INT64, [HDC, c_int, INT64, INT64, INT64], 'OML_sync_control')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:513
wglWaitForMscOML = _link_function('wglWaitForMscOML', BOOL, [HDC, INT64, INT64, INT64, POINTER(INT64), POINTER(INT64), POINTER(INT64)], 'OML_sync_control')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:514
wglWaitForSbcOML = _link_function('wglWaitForSbcOML', BOOL, [HDC, INT64, POINTER(INT64), POINTER(INT64), POINTER(INT64)], 'OML_sync_control')

PFNWGLGETSYNCVALUESOMLPROC = CFUNCTYPE(BOOL, HDC, POINTER(INT64), POINTER(INT64), POINTER(INT64)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:516
PFNWGLGETMSCRATEOMLPROC = CFUNCTYPE(BOOL, HDC, POINTER(INT32), POINTER(INT32)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:517
PFNWGLSWAPBUFFERSMSCOMLPROC = CFUNCTYPE(INT64, HDC, INT64, INT64, INT64) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:518
PFNWGLSWAPLAYERBUFFERSMSCOMLPROC = CFUNCTYPE(INT64, HDC, c_int, INT64, INT64, INT64) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:519
PFNWGLWAITFORMSCOMLPROC = CFUNCTYPE(BOOL, HDC, INT64, INT64, INT64, POINTER(INT64), POINTER(INT64), POINTER(INT64)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:520
PFNWGLWAITFORSBCOMLPROC = CFUNCTYPE(BOOL, HDC, INT64, POINTER(INT64), POINTER(INT64), POINTER(INT64)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:521
# I3D_digital_video_control (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:524)
WGL_I3D_digital_video_control = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:525
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:527
wglGetDigitalVideoParametersI3D = _link_function('wglGetDigitalVideoParametersI3D', BOOL, [HDC, c_int, POINTER(c_int)], 'I3D_digital_video_control')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:528
wglSetDigitalVideoParametersI3D = _link_function('wglSetDigitalVideoParametersI3D', BOOL, [HDC, c_int, POINTER(c_int)], 'I3D_digital_video_control')

PFNWGLGETDIGITALVIDEOPARAMETERSI3DPROC = CFUNCTYPE(BOOL, HDC, c_int, POINTER(c_int)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:530
PFNWGLSETDIGITALVIDEOPARAMETERSI3DPROC = CFUNCTYPE(BOOL, HDC, c_int, POINTER(c_int)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:531
# I3D_gamma (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:534)
WGL_I3D_gamma = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:535
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:537
wglGetGammaTableParametersI3D = _link_function('wglGetGammaTableParametersI3D', BOOL, [HDC, c_int, POINTER(c_int)], 'I3D_gamma')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:538
wglSetGammaTableParametersI3D = _link_function('wglSetGammaTableParametersI3D', BOOL, [HDC, c_int, POINTER(c_int)], 'I3D_gamma')

USHORT = c_ushort 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:49
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:539
wglGetGammaTableI3D = _link_function('wglGetGammaTableI3D', BOOL, [HDC, c_int, POINTER(USHORT), POINTER(USHORT), POINTER(USHORT)], 'I3D_gamma')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:540
wglSetGammaTableI3D = _link_function('wglSetGammaTableI3D', BOOL, [HDC, c_int, POINTER(USHORT), POINTER(USHORT), POINTER(USHORT)], 'I3D_gamma')

PFNWGLGETGAMMATABLEPARAMETERSI3DPROC = CFUNCTYPE(BOOL, HDC, c_int, POINTER(c_int)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:542
PFNWGLSETGAMMATABLEPARAMETERSI3DPROC = CFUNCTYPE(BOOL, HDC, c_int, POINTER(c_int)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:543
PFNWGLGETGAMMATABLEI3DPROC = CFUNCTYPE(BOOL, HDC, c_int, POINTER(USHORT), POINTER(USHORT), POINTER(USHORT)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:544
PFNWGLSETGAMMATABLEI3DPROC = CFUNCTYPE(BOOL, HDC, c_int, POINTER(USHORT), POINTER(USHORT), POINTER(USHORT)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:545
# I3D_genlock (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:548)
WGL_I3D_genlock = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:549
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:551
wglEnableGenlockI3D = _link_function('wglEnableGenlockI3D', BOOL, [HDC], 'I3D_genlock')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:552
wglDisableGenlockI3D = _link_function('wglDisableGenlockI3D', BOOL, [HDC], 'I3D_genlock')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:553
wglIsEnabledGenlockI3D = _link_function('wglIsEnabledGenlockI3D', BOOL, [HDC, POINTER(BOOL)], 'I3D_genlock')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:554
wglGenlockSourceI3D = _link_function('wglGenlockSourceI3D', BOOL, [HDC, UINT], 'I3D_genlock')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:555
wglGetGenlockSourceI3D = _link_function('wglGetGenlockSourceI3D', BOOL, [HDC, POINTER(UINT)], 'I3D_genlock')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:556
wglGenlockSourceEdgeI3D = _link_function('wglGenlockSourceEdgeI3D', BOOL, [HDC, UINT], 'I3D_genlock')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:557
wglGetGenlockSourceEdgeI3D = _link_function('wglGetGenlockSourceEdgeI3D', BOOL, [HDC, POINTER(UINT)], 'I3D_genlock')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:558
wglGenlockSampleRateI3D = _link_function('wglGenlockSampleRateI3D', BOOL, [HDC, UINT], 'I3D_genlock')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:559
wglGetGenlockSampleRateI3D = _link_function('wglGetGenlockSampleRateI3D', BOOL, [HDC, POINTER(UINT)], 'I3D_genlock')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:560
wglGenlockSourceDelayI3D = _link_function('wglGenlockSourceDelayI3D', BOOL, [HDC, UINT], 'I3D_genlock')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:561
wglGetGenlockSourceDelayI3D = _link_function('wglGetGenlockSourceDelayI3D', BOOL, [HDC, POINTER(UINT)], 'I3D_genlock')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:562
wglQueryGenlockMaxSourceDelayI3D = _link_function('wglQueryGenlockMaxSourceDelayI3D', BOOL, [HDC, POINTER(UINT), POINTER(UINT)], 'I3D_genlock')

PFNWGLENABLEGENLOCKI3DPROC = CFUNCTYPE(BOOL, HDC) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:564
PFNWGLDISABLEGENLOCKI3DPROC = CFUNCTYPE(BOOL, HDC) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:565
PFNWGLISENABLEDGENLOCKI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(BOOL)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:566
PFNWGLGENLOCKSOURCEI3DPROC = CFUNCTYPE(BOOL, HDC, UINT) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:567
PFNWGLGETGENLOCKSOURCEI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(UINT)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:568
PFNWGLGENLOCKSOURCEEDGEI3DPROC = CFUNCTYPE(BOOL, HDC, UINT) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:569
PFNWGLGETGENLOCKSOURCEEDGEI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(UINT)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:570
PFNWGLGENLOCKSAMPLERATEI3DPROC = CFUNCTYPE(BOOL, HDC, UINT) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:571
PFNWGLGETGENLOCKSAMPLERATEI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(UINT)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:572
PFNWGLGENLOCKSOURCEDELAYI3DPROC = CFUNCTYPE(BOOL, HDC, UINT) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:573
PFNWGLGETGENLOCKSOURCEDELAYI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(UINT)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:574
PFNWGLQUERYGENLOCKMAXSOURCEDELAYI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(UINT), POINTER(UINT)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:575
# I3D_image_buffer (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:578)
WGL_I3D_image_buffer = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:579
LPVOID = POINTER(None) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:45
DWORD = c_ulong 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:54
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:581
wglCreateImageBufferI3D = _link_function('wglCreateImageBufferI3D', LPVOID, [HDC, DWORD, UINT], 'I3D_image_buffer')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:582
wglDestroyImageBufferI3D = _link_function('wglDestroyImageBufferI3D', BOOL, [HDC, LPVOID], 'I3D_image_buffer')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:583
wglAssociateImageBufferEventsI3D = _link_function('wglAssociateImageBufferEventsI3D', BOOL, [HDC, POINTER(HANDLE), POINTER(LPVOID), POINTER(DWORD), UINT], 'I3D_image_buffer')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:584
wglReleaseImageBufferEventsI3D = _link_function('wglReleaseImageBufferEventsI3D', BOOL, [HDC, POINTER(LPVOID), UINT], 'I3D_image_buffer')

PFNWGLCREATEIMAGEBUFFERI3DPROC = CFUNCTYPE(LPVOID, HDC, DWORD, UINT) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:586
PFNWGLDESTROYIMAGEBUFFERI3DPROC = CFUNCTYPE(BOOL, HDC, LPVOID) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:587
PFNWGLASSOCIATEIMAGEBUFFEREVENTSI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(HANDLE), POINTER(LPVOID), POINTER(DWORD), UINT) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:588
PFNWGLRELEASEIMAGEBUFFEREVENTSI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(LPVOID), UINT) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:589
# I3D_swap_frame_lock (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:592)
WGL_I3D_swap_frame_lock = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:593
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:595
wglEnableFrameLockI3D = _link_function('wglEnableFrameLockI3D', BOOL, [], 'I3D_swap_frame_lock')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:596
wglDisableFrameLockI3D = _link_function('wglDisableFrameLockI3D', BOOL, [], 'I3D_swap_frame_lock')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:597
wglIsEnabledFrameLockI3D = _link_function('wglIsEnabledFrameLockI3D', BOOL, [POINTER(BOOL)], 'I3D_swap_frame_lock')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:598
wglQueryFrameLockMasterI3D = _link_function('wglQueryFrameLockMasterI3D', BOOL, [POINTER(BOOL)], 'I3D_swap_frame_lock')

PFNWGLENABLEFRAMELOCKI3DPROC = CFUNCTYPE(BOOL) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:600
PFNWGLDISABLEFRAMELOCKI3DPROC = CFUNCTYPE(BOOL) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:601
PFNWGLISENABLEDFRAMELOCKI3DPROC = CFUNCTYPE(BOOL, POINTER(BOOL)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:602
PFNWGLQUERYFRAMELOCKMASTERI3DPROC = CFUNCTYPE(BOOL, POINTER(BOOL)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:603
# I3D_swap_frame_usage (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:606)
WGL_I3D_swap_frame_usage = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:607
# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:609
wglGetFrameUsageI3D = _link_function('wglGetFrameUsageI3D', BOOL, [POINTER(c_float)], 'I3D_swap_frame_usage')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:610
wglBeginFrameTrackingI3D = _link_function('wglBeginFrameTrackingI3D', BOOL, [], 'I3D_swap_frame_usage')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:611
wglEndFrameTrackingI3D = _link_function('wglEndFrameTrackingI3D', BOOL, [], 'I3D_swap_frame_usage')

# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:612
wglQueryFrameTrackingI3D = _link_function('wglQueryFrameTrackingI3D', BOOL, [POINTER(DWORD), POINTER(DWORD), POINTER(c_float)], 'I3D_swap_frame_usage')

PFNWGLGETFRAMEUSAGEI3DPROC = CFUNCTYPE(BOOL, POINTER(c_float)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:614
PFNWGLBEGINFRAMETRACKINGI3DPROC = CFUNCTYPE(BOOL) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:615
PFNWGLENDFRAMETRACKINGI3DPROC = CFUNCTYPE(BOOL) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:616
PFNWGLQUERYFRAMETRACKINGI3DPROC = CFUNCTYPE(BOOL, POINTER(DWORD), POINTER(DWORD), POINTER(c_float)) 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:617
# ATI_pixel_format_float (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:620)
WGL_ATI_pixel_format_float = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:621
# NV_float_buffer (http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:624)
WGL_NV_float_buffer = 1 	# http://oss.sgi.com/projects/ogl-sample/ABI/wglext.h:625

__all__ = ['WIN32_LEAN_AND_MEAN', 'GLAPI', 'WGL_WGLEXT_VERSION',
'WGL_FRONT_COLOR_BUFFER_BIT_ARB', 'WGL_BACK_COLOR_BUFFER_BIT_ARB',
'WGL_DEPTH_BUFFER_BIT_ARB', 'WGL_STENCIL_BUFFER_BIT_ARB',
'WGL_SAMPLE_BUFFERS_ARB', 'WGL_SAMPLES_ARB', 'WGL_NUMBER_PIXEL_FORMATS_ARB',
'WGL_DRAW_TO_WINDOW_ARB', 'WGL_DRAW_TO_BITMAP_ARB', 'WGL_ACCELERATION_ARB',
'WGL_NEED_PALETTE_ARB', 'WGL_NEED_SYSTEM_PALETTE_ARB',
'WGL_SWAP_LAYER_BUFFERS_ARB', 'WGL_SWAP_METHOD_ARB',
'WGL_NUMBER_OVERLAYS_ARB', 'WGL_NUMBER_UNDERLAYS_ARB', 'WGL_TRANSPARENT_ARB',
'WGL_TRANSPARENT_RED_VALUE_ARB', 'WGL_TRANSPARENT_GREEN_VALUE_ARB',
'WGL_TRANSPARENT_BLUE_VALUE_ARB', 'WGL_TRANSPARENT_ALPHA_VALUE_ARB',
'WGL_TRANSPARENT_INDEX_VALUE_ARB', 'WGL_SHARE_DEPTH_ARB',
'WGL_SHARE_STENCIL_ARB', 'WGL_SHARE_ACCUM_ARB', 'WGL_SUPPORT_GDI_ARB',
'WGL_SUPPORT_OPENGL_ARB', 'WGL_DOUBLE_BUFFER_ARB', 'WGL_STEREO_ARB',
'WGL_PIXEL_TYPE_ARB', 'WGL_COLOR_BITS_ARB', 'WGL_RED_BITS_ARB',
'WGL_RED_SHIFT_ARB', 'WGL_GREEN_BITS_ARB', 'WGL_GREEN_SHIFT_ARB',
'WGL_BLUE_BITS_ARB', 'WGL_BLUE_SHIFT_ARB', 'WGL_ALPHA_BITS_ARB',
'WGL_ALPHA_SHIFT_ARB', 'WGL_ACCUM_BITS_ARB', 'WGL_ACCUM_RED_BITS_ARB',
'WGL_ACCUM_GREEN_BITS_ARB', 'WGL_ACCUM_BLUE_BITS_ARB',
'WGL_ACCUM_ALPHA_BITS_ARB', 'WGL_DEPTH_BITS_ARB', 'WGL_STENCIL_BITS_ARB',
'WGL_AUX_BUFFERS_ARB', 'WGL_NO_ACCELERATION_ARB',
'WGL_GENERIC_ACCELERATION_ARB', 'WGL_FULL_ACCELERATION_ARB',
'WGL_SWAP_EXCHANGE_ARB', 'WGL_SWAP_COPY_ARB', 'WGL_SWAP_UNDEFINED_ARB',
'WGL_TYPE_RGBA_ARB', 'WGL_TYPE_COLORINDEX_ARB',
'ERROR_INVALID_PIXEL_TYPE_ARB', 'ERROR_INCOMPATIBLE_DEVICE_CONTEXTS_ARB',
'WGL_DRAW_TO_PBUFFER_ARB', 'WGL_MAX_PBUFFER_PIXELS_ARB',
'WGL_MAX_PBUFFER_WIDTH_ARB', 'WGL_MAX_PBUFFER_HEIGHT_ARB',
'WGL_PBUFFER_LARGEST_ARB', 'WGL_PBUFFER_WIDTH_ARB', 'WGL_PBUFFER_HEIGHT_ARB',
'WGL_PBUFFER_LOST_ARB', 'WGL_BIND_TO_TEXTURE_RGB_ARB',
'WGL_BIND_TO_TEXTURE_RGBA_ARB', 'WGL_TEXTURE_FORMAT_ARB',
'WGL_TEXTURE_TARGET_ARB', 'WGL_MIPMAP_TEXTURE_ARB', 'WGL_TEXTURE_RGB_ARB',
'WGL_TEXTURE_RGBA_ARB', 'WGL_NO_TEXTURE_ARB', 'WGL_TEXTURE_CUBE_MAP_ARB',
'WGL_TEXTURE_1D_ARB', 'WGL_TEXTURE_2D_ARB', 'WGL_MIPMAP_LEVEL_ARB',
'WGL_CUBE_MAP_FACE_ARB', 'WGL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB',
'WGL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB', 'WGL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB',
'WGL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB', 'WGL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB',
'WGL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB', 'WGL_FRONT_LEFT_ARB',
'WGL_FRONT_RIGHT_ARB', 'WGL_BACK_LEFT_ARB', 'WGL_BACK_RIGHT_ARB',
'WGL_AUX0_ARB', 'WGL_AUX1_ARB', 'WGL_AUX2_ARB', 'WGL_AUX3_ARB',
'WGL_AUX4_ARB', 'WGL_AUX5_ARB', 'WGL_AUX6_ARB', 'WGL_AUX7_ARB',
'WGL_AUX8_ARB', 'WGL_AUX9_ARB', 'WGL_TYPE_RGBA_FLOAT_ARB',
'ERROR_INVALID_PIXEL_TYPE_EXT', 'WGL_NUMBER_PIXEL_FORMATS_EXT',
'WGL_DRAW_TO_WINDOW_EXT', 'WGL_DRAW_TO_BITMAP_EXT', 'WGL_ACCELERATION_EXT',
'WGL_NEED_PALETTE_EXT', 'WGL_NEED_SYSTEM_PALETTE_EXT',
'WGL_SWAP_LAYER_BUFFERS_EXT', 'WGL_SWAP_METHOD_EXT',
'WGL_NUMBER_OVERLAYS_EXT', 'WGL_NUMBER_UNDERLAYS_EXT', 'WGL_TRANSPARENT_EXT',
'WGL_TRANSPARENT_VALUE_EXT', 'WGL_SHARE_DEPTH_EXT', 'WGL_SHARE_STENCIL_EXT',
'WGL_SHARE_ACCUM_EXT', 'WGL_SUPPORT_GDI_EXT', 'WGL_SUPPORT_OPENGL_EXT',
'WGL_DOUBLE_BUFFER_EXT', 'WGL_STEREO_EXT', 'WGL_PIXEL_TYPE_EXT',
'WGL_COLOR_BITS_EXT', 'WGL_RED_BITS_EXT', 'WGL_RED_SHIFT_EXT',
'WGL_GREEN_BITS_EXT', 'WGL_GREEN_SHIFT_EXT', 'WGL_BLUE_BITS_EXT',
'WGL_BLUE_SHIFT_EXT', 'WGL_ALPHA_BITS_EXT', 'WGL_ALPHA_SHIFT_EXT',
'WGL_ACCUM_BITS_EXT', 'WGL_ACCUM_RED_BITS_EXT', 'WGL_ACCUM_GREEN_BITS_EXT',
'WGL_ACCUM_BLUE_BITS_EXT', 'WGL_ACCUM_ALPHA_BITS_EXT', 'WGL_DEPTH_BITS_EXT',
'WGL_STENCIL_BITS_EXT', 'WGL_AUX_BUFFERS_EXT', 'WGL_NO_ACCELERATION_EXT',
'WGL_GENERIC_ACCELERATION_EXT', 'WGL_FULL_ACCELERATION_EXT',
'WGL_SWAP_EXCHANGE_EXT', 'WGL_SWAP_COPY_EXT', 'WGL_SWAP_UNDEFINED_EXT',
'WGL_TYPE_RGBA_EXT', 'WGL_TYPE_COLORINDEX_EXT', 'WGL_DRAW_TO_PBUFFER_EXT',
'WGL_MAX_PBUFFER_PIXELS_EXT', 'WGL_MAX_PBUFFER_WIDTH_EXT',
'WGL_MAX_PBUFFER_HEIGHT_EXT', 'WGL_OPTIMAL_PBUFFER_WIDTH_EXT',
'WGL_OPTIMAL_PBUFFER_HEIGHT_EXT', 'WGL_PBUFFER_LARGEST_EXT',
'WGL_PBUFFER_WIDTH_EXT', 'WGL_PBUFFER_HEIGHT_EXT', 'WGL_DEPTH_FLOAT_EXT',
'WGL_SAMPLE_BUFFERS_3DFX', 'WGL_SAMPLES_3DFX', 'WGL_SAMPLE_BUFFERS_EXT',
'WGL_SAMPLES_EXT', 'WGL_DIGITAL_VIDEO_CURSOR_ALPHA_FRAMEBUFFER_I3D',
'WGL_DIGITAL_VIDEO_CURSOR_ALPHA_VALUE_I3D',
'WGL_DIGITAL_VIDEO_CURSOR_INCLUDED_I3D',
'WGL_DIGITAL_VIDEO_GAMMA_CORRECTED_I3D', 'WGL_GAMMA_TABLE_SIZE_I3D',
'WGL_GAMMA_EXCLUDE_DESKTOP_I3D', 'WGL_GENLOCK_SOURCE_MULTIVIEW_I3D',
'WGL_GENLOCK_SOURCE_EXTENAL_SYNC_I3D', 'WGL_GENLOCK_SOURCE_EXTENAL_FIELD_I3D',
'WGL_GENLOCK_SOURCE_EXTENAL_TTL_I3D', 'WGL_GENLOCK_SOURCE_DIGITAL_SYNC_I3D',
'WGL_GENLOCK_SOURCE_DIGITAL_FIELD_I3D', 'WGL_GENLOCK_SOURCE_EDGE_FALLING_I3D',
'WGL_GENLOCK_SOURCE_EDGE_RISING_I3D', 'WGL_GENLOCK_SOURCE_EDGE_BOTH_I3D',
'WGL_IMAGE_BUFFER_MIN_ACCESS_I3D', 'WGL_IMAGE_BUFFER_LOCK_I3D',
'WGL_BIND_TO_TEXTURE_DEPTH_NV', 'WGL_BIND_TO_TEXTURE_RECTANGLE_DEPTH_NV',
'WGL_DEPTH_TEXTURE_FORMAT_NV', 'WGL_TEXTURE_DEPTH_COMPONENT_NV',
'WGL_DEPTH_COMPONENT_NV', 'WGL_BIND_TO_TEXTURE_RECTANGLE_RGB_NV',
'WGL_BIND_TO_TEXTURE_RECTANGLE_RGBA_NV', 'WGL_TEXTURE_RECTANGLE_NV',
'WGL_TYPE_RGBA_FLOAT_ATI', 'WGL_FLOAT_COMPONENTS_NV',
'WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_R_NV',
'WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RG_NV',
'WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGB_NV',
'WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGBA_NV', 'WGL_TEXTURE_FLOAT_R_NV',
'WGL_TEXTURE_FLOAT_RG_NV', 'WGL_TEXTURE_FLOAT_RGB_NV',
'WGL_TEXTURE_FLOAT_RGBA_NV', 'HPBUFFERARB', 'HPBUFFEREXT',
'WGL_ARB_buffer_region', 'wglCreateBufferRegionARB',
'wglDeleteBufferRegionARB', 'wglSaveBufferRegionARB',
'wglRestoreBufferRegionARB', 'PFNWGLCREATEBUFFERREGIONARBPROC',
'PFNWGLDELETEBUFFERREGIONARBPROC', 'PFNWGLSAVEBUFFERREGIONARBPROC',
'PFNWGLRESTOREBUFFERREGIONARBPROC', 'WGL_ARB_multisample',
'WGL_ARB_extensions_string', 'wglGetExtensionsStringARB',
'PFNWGLGETEXTENSIONSSTRINGARBPROC', 'WGL_ARB_pixel_format',
'wglGetPixelFormatAttribivARB', 'wglGetPixelFormatAttribfvARB',
'wglChoosePixelFormatARB', 'PFNWGLGETPIXELFORMATATTRIBIVARBPROC',
'PFNWGLGETPIXELFORMATATTRIBFVARBPROC', 'PFNWGLCHOOSEPIXELFORMATARBPROC',
'WGL_ARB_make_current_read', 'wglMakeContextCurrentARB',
'wglGetCurrentReadDCARB', 'PFNWGLMAKECONTEXTCURRENTARBPROC',
'PFNWGLGETCURRENTREADDCARBPROC', 'WGL_ARB_pbuffer', 'wglCreatePbufferARB',
'wglGetPbufferDCARB', 'wglReleasePbufferDCARB', 'wglDestroyPbufferARB',
'wglQueryPbufferARB', 'PFNWGLCREATEPBUFFERARBPROC',
'PFNWGLGETPBUFFERDCARBPROC', 'PFNWGLRELEASEPBUFFERDCARBPROC',
'PFNWGLDESTROYPBUFFERARBPROC', 'PFNWGLQUERYPBUFFERARBPROC',
'WGL_ARB_render_texture', 'wglBindTexImageARB', 'wglReleaseTexImageARB',
'wglSetPbufferAttribARB', 'PFNWGLBINDTEXIMAGEARBPROC',
'PFNWGLRELEASETEXIMAGEARBPROC', 'PFNWGLSETPBUFFERATTRIBARBPROC',
'WGL_ARB_pixel_format_float', 'WGL_EXT_display_color_table',
'wglCreateDisplayColorTableEXT', 'wglLoadDisplayColorTableEXT',
'wglBindDisplayColorTableEXT', 'wglDestroyDisplayColorTableEXT',
'PFNWGLCREATEDISPLAYCOLORTABLEEXTPROC', 'PFNWGLLOADDISPLAYCOLORTABLEEXTPROC',
'PFNWGLBINDDISPLAYCOLORTABLEEXTPROC', 'PFNWGLDESTROYDISPLAYCOLORTABLEEXTPROC',
'WGL_EXT_extensions_string', 'wglGetExtensionsStringEXT',
'PFNWGLGETEXTENSIONSSTRINGEXTPROC', 'WGL_EXT_make_current_read',
'wglMakeContextCurrentEXT', 'wglGetCurrentReadDCEXT',
'PFNWGLMAKECONTEXTCURRENTEXTPROC', 'PFNWGLGETCURRENTREADDCEXTPROC',
'WGL_EXT_pbuffer', 'wglCreatePbufferEXT', 'wglGetPbufferDCEXT',
'wglReleasePbufferDCEXT', 'wglDestroyPbufferEXT', 'wglQueryPbufferEXT',
'PFNWGLCREATEPBUFFEREXTPROC', 'PFNWGLGETPBUFFERDCEXTPROC',
'PFNWGLRELEASEPBUFFERDCEXTPROC', 'PFNWGLDESTROYPBUFFEREXTPROC',
'PFNWGLQUERYPBUFFEREXTPROC', 'WGL_EXT_pixel_format',
'wglGetPixelFormatAttribivEXT', 'wglGetPixelFormatAttribfvEXT',
'wglChoosePixelFormatEXT', 'PFNWGLGETPIXELFORMATATTRIBIVEXTPROC',
'PFNWGLGETPIXELFORMATATTRIBFVEXTPROC', 'PFNWGLCHOOSEPIXELFORMATEXTPROC',
'WGL_EXT_swap_control', 'wglSwapIntervalEXT', 'wglGetSwapIntervalEXT',
'PFNWGLSWAPINTERVALEXTPROC', 'PFNWGLGETSWAPINTERVALEXTPROC',
'WGL_EXT_depth_float', 'WGL_NV_vertex_array_range', 'wglAllocateMemoryNV',
'wglFreeMemoryNV', 'PFNWGLALLOCATEMEMORYNVPROC', 'PFNWGLFREEMEMORYNVPROC',
'WGL_3DFX_multisample', 'WGL_EXT_multisample', 'WGL_OML_sync_control',
'wglGetSyncValuesOML', 'wglGetMscRateOML', 'wglSwapBuffersMscOML',
'wglSwapLayerBuffersMscOML', 'wglWaitForMscOML', 'wglWaitForSbcOML',
'PFNWGLGETSYNCVALUESOMLPROC', 'PFNWGLGETMSCRATEOMLPROC',
'PFNWGLSWAPBUFFERSMSCOMLPROC', 'PFNWGLSWAPLAYERBUFFERSMSCOMLPROC',
'PFNWGLWAITFORMSCOMLPROC', 'PFNWGLWAITFORSBCOMLPROC',
'WGL_I3D_digital_video_control', 'wglGetDigitalVideoParametersI3D',
'wglSetDigitalVideoParametersI3D', 'PFNWGLGETDIGITALVIDEOPARAMETERSI3DPROC',
'PFNWGLSETDIGITALVIDEOPARAMETERSI3DPROC', 'WGL_I3D_gamma',
'wglGetGammaTableParametersI3D', 'wglSetGammaTableParametersI3D',
'wglGetGammaTableI3D', 'wglSetGammaTableI3D',
'PFNWGLGETGAMMATABLEPARAMETERSI3DPROC',
'PFNWGLSETGAMMATABLEPARAMETERSI3DPROC', 'PFNWGLGETGAMMATABLEI3DPROC',
'PFNWGLSETGAMMATABLEI3DPROC', 'WGL_I3D_genlock', 'wglEnableGenlockI3D',
'wglDisableGenlockI3D', 'wglIsEnabledGenlockI3D', 'wglGenlockSourceI3D',
'wglGetGenlockSourceI3D', 'wglGenlockSourceEdgeI3D',
'wglGetGenlockSourceEdgeI3D', 'wglGenlockSampleRateI3D',
'wglGetGenlockSampleRateI3D', 'wglGenlockSourceDelayI3D',
'wglGetGenlockSourceDelayI3D', 'wglQueryGenlockMaxSourceDelayI3D',
'PFNWGLENABLEGENLOCKI3DPROC', 'PFNWGLDISABLEGENLOCKI3DPROC',
'PFNWGLISENABLEDGENLOCKI3DPROC', 'PFNWGLGENLOCKSOURCEI3DPROC',
'PFNWGLGETGENLOCKSOURCEI3DPROC', 'PFNWGLGENLOCKSOURCEEDGEI3DPROC',
'PFNWGLGETGENLOCKSOURCEEDGEI3DPROC', 'PFNWGLGENLOCKSAMPLERATEI3DPROC',
'PFNWGLGETGENLOCKSAMPLERATEI3DPROC', 'PFNWGLGENLOCKSOURCEDELAYI3DPROC',
'PFNWGLGETGENLOCKSOURCEDELAYI3DPROC',
'PFNWGLQUERYGENLOCKMAXSOURCEDELAYI3DPROC', 'WGL_I3D_image_buffer',
'wglCreateImageBufferI3D', 'wglDestroyImageBufferI3D',
'wglAssociateImageBufferEventsI3D', 'wglReleaseImageBufferEventsI3D',
'PFNWGLCREATEIMAGEBUFFERI3DPROC', 'PFNWGLDESTROYIMAGEBUFFERI3DPROC',
'PFNWGLASSOCIATEIMAGEBUFFEREVENTSI3DPROC',
'PFNWGLRELEASEIMAGEBUFFEREVENTSI3DPROC', 'WGL_I3D_swap_frame_lock',
'wglEnableFrameLockI3D', 'wglDisableFrameLockI3D', 'wglIsEnabledFrameLockI3D',
'wglQueryFrameLockMasterI3D', 'PFNWGLENABLEFRAMELOCKI3DPROC',
'PFNWGLDISABLEFRAMELOCKI3DPROC', 'PFNWGLISENABLEDFRAMELOCKI3DPROC',
'PFNWGLQUERYFRAMELOCKMASTERI3DPROC', 'WGL_I3D_swap_frame_usage',
'wglGetFrameUsageI3D', 'wglBeginFrameTrackingI3D', 'wglEndFrameTrackingI3D',
'wglQueryFrameTrackingI3D', 'PFNWGLGETFRAMEUSAGEI3DPROC',
'PFNWGLBEGINFRAMETRACKINGI3DPROC', 'PFNWGLENDFRAMETRACKINGI3DPROC',
'PFNWGLQUERYFRAMETRACKINGI3DPROC', 'WGL_ATI_pixel_format_float',
'WGL_NV_float_buffer']
# END GENERATED CONTENT (do not edit above this line)



########NEW FILE########
__FILENAME__ = wglext_nv
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for http://developer.download.nvidia.com/opengl/includes/wglext.h

Generated by tools/gengl.py.
Do not modify this file.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: gengl.py 601 2007-02-04 05:36:59Z Alex.Holkner $'

from ctypes import *
from pyglet.gl.lib import link_WGL as _link_function
from pyglet.gl.lib import c_ptrdiff_t, c_void

# BEGIN GENERATED CONTENT (do not edit below this line)

# This content is generated by tools/gengl.py.
# Wrapper for http://developer.download.nvidia.com/opengl/includes/wglext.h


# H (C:\cygwin\home\Alex\pyglet\tools\wgl.h:7)
# H (C:\cygwin\home\Alex\pyglet\tools\wgl.h:7)
WIN32_LEAN_AND_MEAN = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:40
GLAPI = 0 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:51
WGL_WGLEXT_VERSION = 6 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:60
# ARB_buffer_region (http://developer.download.nvidia.com/opengl/includes/wglext.h:62)
WGL_FRONT_COLOR_BUFFER_BIT_ARB = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:63
WGL_BACK_COLOR_BUFFER_BIT_ARB = 2 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:64
WGL_DEPTH_BUFFER_BIT_ARB = 4 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:65
WGL_STENCIL_BUFFER_BIT_ARB = 8 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:66
# ARB_multisample (http://developer.download.nvidia.com/opengl/includes/wglext.h:69)
WGL_SAMPLE_BUFFERS_ARB = 8257 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:70
WGL_SAMPLES_ARB = 8258 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:71
# ARB_extensions_string (http://developer.download.nvidia.com/opengl/includes/wglext.h:74)
# ARB_pixel_format (http://developer.download.nvidia.com/opengl/includes/wglext.h:77)
WGL_NUMBER_PIXEL_FORMATS_ARB = 8192 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:78
WGL_DRAW_TO_WINDOW_ARB = 8193 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:79
WGL_DRAW_TO_BITMAP_ARB = 8194 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:80
WGL_ACCELERATION_ARB = 8195 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:81
WGL_NEED_PALETTE_ARB = 8196 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:82
WGL_NEED_SYSTEM_PALETTE_ARB = 8197 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:83
WGL_SWAP_LAYER_BUFFERS_ARB = 8198 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:84
WGL_SWAP_METHOD_ARB = 8199 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:85
WGL_NUMBER_OVERLAYS_ARB = 8200 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:86
WGL_NUMBER_UNDERLAYS_ARB = 8201 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:87
WGL_TRANSPARENT_ARB = 8202 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:88
WGL_TRANSPARENT_RED_VALUE_ARB = 8247 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:89
WGL_TRANSPARENT_GREEN_VALUE_ARB = 8248 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:90
WGL_TRANSPARENT_BLUE_VALUE_ARB = 8249 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:91
WGL_TRANSPARENT_ALPHA_VALUE_ARB = 8250 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:92
WGL_TRANSPARENT_INDEX_VALUE_ARB = 8251 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:93
WGL_SHARE_DEPTH_ARB = 8204 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:94
WGL_SHARE_STENCIL_ARB = 8205 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:95
WGL_SHARE_ACCUM_ARB = 512 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:96
WGL_SUPPORT_GDI_ARB = 512 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:97
WGL_SUPPORT_OPENGL_ARB = 8208 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:98
WGL_DOUBLE_BUFFER_ARB = 8209 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:99
WGL_STEREO_ARB = 8210 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:100
WGL_PIXEL_TYPE_ARB = 8211 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:101
WGL_COLOR_BITS_ARB = 8212 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:102
WGL_RED_BITS_ARB = 8213 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:103
WGL_RED_SHIFT_ARB = 8214 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:104
WGL_GREEN_BITS_ARB = 8215 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:105
WGL_GREEN_SHIFT_ARB = 8216 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:106
WGL_BLUE_BITS_ARB = 8217 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:107
WGL_BLUE_SHIFT_ARB = 8218 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:108
WGL_ALPHA_BITS_ARB = 8219 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:109
WGL_ALPHA_SHIFT_ARB = 8220 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:110
WGL_ACCUM_BITS_ARB = 8221 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:111
WGL_ACCUM_RED_BITS_ARB = 513 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:112
WGL_ACCUM_GREEN_BITS_ARB = 513 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:113
WGL_ACCUM_BLUE_BITS_ARB = 8224 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:114
WGL_ACCUM_ALPHA_BITS_ARB = 8225 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:115
WGL_DEPTH_BITS_ARB = 8226 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:116
WGL_STENCIL_BITS_ARB = 8227 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:117
WGL_AUX_BUFFERS_ARB = 8228 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:118
WGL_NO_ACCELERATION_ARB = 8229 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:119
WGL_GENERIC_ACCELERATION_ARB = 8230 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:120
WGL_FULL_ACCELERATION_ARB = 8231 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:121
WGL_SWAP_EXCHANGE_ARB = 8232 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:122
WGL_SWAP_COPY_ARB = 8233 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:123
WGL_SWAP_UNDEFINED_ARB = 8234 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:124
WGL_TYPE_RGBA_ARB = 8235 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:125
WGL_TYPE_COLORINDEX_ARB = 8236 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:126
# ARB_make_current_read (http://developer.download.nvidia.com/opengl/includes/wglext.h:129)
ERROR_INVALID_PIXEL_TYPE_ARB = 8259 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:130
ERROR_INCOMPATIBLE_DEVICE_CONTEXTS_ARB = 8276 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:131
# ARB_pbuffer (http://developer.download.nvidia.com/opengl/includes/wglext.h:134)
WGL_DRAW_TO_PBUFFER_ARB = 8237 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:135
WGL_MAX_PBUFFER_PIXELS_ARB = 514 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:136
WGL_MAX_PBUFFER_WIDTH_ARB = 514 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:137
WGL_MAX_PBUFFER_HEIGHT_ARB = 8240 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:138
WGL_PBUFFER_LARGEST_ARB = 8243 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:139
WGL_PBUFFER_WIDTH_ARB = 8244 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:140
WGL_PBUFFER_HEIGHT_ARB = 8245 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:141
WGL_PBUFFER_LOST_ARB = 8246 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:142
# ARB_render_texture (http://developer.download.nvidia.com/opengl/includes/wglext.h:145)
WGL_BIND_TO_TEXTURE_RGB_ARB = 8304 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:146
WGL_BIND_TO_TEXTURE_RGBA_ARB = 8305 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:147
WGL_TEXTURE_FORMAT_ARB = 8306 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:148
WGL_TEXTURE_TARGET_ARB = 8307 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:149
WGL_MIPMAP_TEXTURE_ARB = 8308 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:150
WGL_TEXTURE_RGB_ARB = 8309 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:151
WGL_TEXTURE_RGBA_ARB = 8310 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:152
WGL_NO_TEXTURE_ARB = 8311 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:153
WGL_TEXTURE_CUBE_MAP_ARB = 8312 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:154
WGL_TEXTURE_1D_ARB = 8313 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:155
WGL_TEXTURE_2D_ARB = 8314 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:156
WGL_MIPMAP_LEVEL_ARB = 8315 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:157
WGL_CUBE_MAP_FACE_ARB = 8316 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:158
WGL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB = 8317 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:159
WGL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB = 519 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:160
WGL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB = 519 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:161
WGL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB = 8320 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:162
WGL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB = 8321 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:163
WGL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB = 8322 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:164
WGL_FRONT_LEFT_ARB = 8323 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:165
WGL_FRONT_RIGHT_ARB = 8324 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:166
WGL_BACK_LEFT_ARB = 8325 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:167
WGL_BACK_RIGHT_ARB = 8326 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:168
WGL_AUX0_ARB = 8327 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:169
WGL_AUX1_ARB = 8328 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:170
WGL_AUX2_ARB = 8329 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:171
WGL_AUX3_ARB = 8330 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:172
WGL_AUX4_ARB = 8331 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:173
WGL_AUX5_ARB = 8332 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:174
WGL_AUX6_ARB = 8333 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:175
WGL_AUX7_ARB = 520 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:176
WGL_AUX8_ARB = 520 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:177
WGL_AUX9_ARB = 8336 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:178
# ARB_pixel_format_float (http://developer.download.nvidia.com/opengl/includes/wglext.h:181)
WGL_TYPE_RGBA_FLOAT_ARB = 8608 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:182
# EXT_make_current_read (http://developer.download.nvidia.com/opengl/includes/wglext.h:185)
ERROR_INVALID_PIXEL_TYPE_EXT = 8259 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:186
# EXT_pixel_format (http://developer.download.nvidia.com/opengl/includes/wglext.h:189)
WGL_NUMBER_PIXEL_FORMATS_EXT = 8192 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:190
WGL_DRAW_TO_WINDOW_EXT = 8193 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:191
WGL_DRAW_TO_BITMAP_EXT = 8194 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:192
WGL_ACCELERATION_EXT = 8195 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:193
WGL_NEED_PALETTE_EXT = 8196 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:194
WGL_NEED_SYSTEM_PALETTE_EXT = 8197 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:195
WGL_SWAP_LAYER_BUFFERS_EXT = 8198 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:196
WGL_SWAP_METHOD_EXT = 8199 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:197
WGL_NUMBER_OVERLAYS_EXT = 8200 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:198
WGL_NUMBER_UNDERLAYS_EXT = 8201 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:199
WGL_TRANSPARENT_EXT = 8202 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:200
WGL_TRANSPARENT_VALUE_EXT = 8203 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:201
WGL_SHARE_DEPTH_EXT = 8204 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:202
WGL_SHARE_STENCIL_EXT = 8205 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:203
WGL_SHARE_ACCUM_EXT = 512 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:204
WGL_SUPPORT_GDI_EXT = 512 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:205
WGL_SUPPORT_OPENGL_EXT = 8208 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:206
WGL_DOUBLE_BUFFER_EXT = 8209 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:207
WGL_STEREO_EXT = 8210 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:208
WGL_PIXEL_TYPE_EXT = 8211 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:209
WGL_COLOR_BITS_EXT = 8212 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:210
WGL_RED_BITS_EXT = 8213 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:211
WGL_RED_SHIFT_EXT = 8214 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:212
WGL_GREEN_BITS_EXT = 8215 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:213
WGL_GREEN_SHIFT_EXT = 8216 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:214
WGL_BLUE_BITS_EXT = 8217 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:215
WGL_BLUE_SHIFT_EXT = 8218 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:216
WGL_ALPHA_BITS_EXT = 8219 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:217
WGL_ALPHA_SHIFT_EXT = 8220 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:218
WGL_ACCUM_BITS_EXT = 8221 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:219
WGL_ACCUM_RED_BITS_EXT = 513 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:220
WGL_ACCUM_GREEN_BITS_EXT = 513 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:221
WGL_ACCUM_BLUE_BITS_EXT = 8224 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:222
WGL_ACCUM_ALPHA_BITS_EXT = 8225 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:223
WGL_DEPTH_BITS_EXT = 8226 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:224
WGL_STENCIL_BITS_EXT = 8227 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:225
WGL_AUX_BUFFERS_EXT = 8228 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:226
WGL_NO_ACCELERATION_EXT = 8229 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:227
WGL_GENERIC_ACCELERATION_EXT = 8230 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:228
WGL_FULL_ACCELERATION_EXT = 8231 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:229
WGL_SWAP_EXCHANGE_EXT = 8232 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:230
WGL_SWAP_COPY_EXT = 8233 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:231
WGL_SWAP_UNDEFINED_EXT = 8234 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:232
WGL_TYPE_RGBA_EXT = 8235 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:233
WGL_TYPE_COLORINDEX_EXT = 8236 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:234
# EXT_pbuffer (http://developer.download.nvidia.com/opengl/includes/wglext.h:237)
WGL_DRAW_TO_PBUFFER_EXT = 8237 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:238
WGL_MAX_PBUFFER_PIXELS_EXT = 514 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:239
WGL_MAX_PBUFFER_WIDTH_EXT = 514 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:240
WGL_MAX_PBUFFER_HEIGHT_EXT = 8240 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:241
WGL_OPTIMAL_PBUFFER_WIDTH_EXT = 8241 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:242
WGL_OPTIMAL_PBUFFER_HEIGHT_EXT = 8242 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:243
WGL_PBUFFER_LARGEST_EXT = 8243 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:244
WGL_PBUFFER_WIDTH_EXT = 8244 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:245
WGL_PBUFFER_HEIGHT_EXT = 8245 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:246
# EXT_depth_float (http://developer.download.nvidia.com/opengl/includes/wglext.h:249)
WGL_DEPTH_FLOAT_EXT = 8256 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:250
# 3DFX_multisample (http://developer.download.nvidia.com/opengl/includes/wglext.h:253)
WGL_SAMPLE_BUFFERS_3DFX = 8288 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:254
WGL_SAMPLES_3DFX = 8289 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:255
# EXT_multisample (http://developer.download.nvidia.com/opengl/includes/wglext.h:258)
WGL_SAMPLE_BUFFERS_EXT = 8257 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:259
WGL_SAMPLES_EXT = 8258 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:260
# I3D_digital_video_control (http://developer.download.nvidia.com/opengl/includes/wglext.h:263)
WGL_DIGITAL_VIDEO_CURSOR_ALPHA_FRAMEBUFFER_I3D = 8272 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:264
WGL_DIGITAL_VIDEO_CURSOR_ALPHA_VALUE_I3D = 8273 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:265
WGL_DIGITAL_VIDEO_CURSOR_INCLUDED_I3D = 8274 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:266
WGL_DIGITAL_VIDEO_GAMMA_CORRECTED_I3D = 8275 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:267
# I3D_gamma (http://developer.download.nvidia.com/opengl/includes/wglext.h:270)
WGL_GAMMA_TABLE_SIZE_I3D = 516 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:271
WGL_GAMMA_EXCLUDE_DESKTOP_I3D = 516 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:272
# I3D_genlock (http://developer.download.nvidia.com/opengl/includes/wglext.h:275)
WGL_GENLOCK_SOURCE_MULTIVIEW_I3D = 8260 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:276
WGL_GENLOCK_SOURCE_EXTENAL_SYNC_I3D = 8261 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:277
WGL_GENLOCK_SOURCE_EXTENAL_FIELD_I3D = 8262 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:278
WGL_GENLOCK_SOURCE_EXTENAL_TTL_I3D = 8263 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:279
WGL_GENLOCK_SOURCE_DIGITAL_SYNC_I3D = 8264 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:280
WGL_GENLOCK_SOURCE_DIGITAL_FIELD_I3D = 8265 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:281
WGL_GENLOCK_SOURCE_EDGE_FALLING_I3D = 8266 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:282
WGL_GENLOCK_SOURCE_EDGE_RISING_I3D = 8267 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:283
WGL_GENLOCK_SOURCE_EDGE_BOTH_I3D = 8268 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:284
# I3D_image_buffer (http://developer.download.nvidia.com/opengl/includes/wglext.h:287)
WGL_IMAGE_BUFFER_MIN_ACCESS_I3D = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:288
WGL_IMAGE_BUFFER_LOCK_I3D = 2 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:289
# I3D_swap_frame_lock (http://developer.download.nvidia.com/opengl/includes/wglext.h:292)
# NV_render_depth_texture (http://developer.download.nvidia.com/opengl/includes/wglext.h:295)
WGL_BIND_TO_TEXTURE_DEPTH_NV = 8355 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:296
WGL_BIND_TO_TEXTURE_RECTANGLE_DEPTH_NV = 8356 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:297
WGL_DEPTH_TEXTURE_FORMAT_NV = 8357 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:298
WGL_TEXTURE_DEPTH_COMPONENT_NV = 8358 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:299
WGL_DEPTH_COMPONENT_NV = 8359 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:300
# NV_render_texture_rectangle (http://developer.download.nvidia.com/opengl/includes/wglext.h:303)
WGL_BIND_TO_TEXTURE_RECTANGLE_RGB_NV = 8352 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:304
WGL_BIND_TO_TEXTURE_RECTANGLE_RGBA_NV = 8353 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:305
WGL_TEXTURE_RECTANGLE_NV = 8354 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:306
# ATI_pixel_format_float (http://developer.download.nvidia.com/opengl/includes/wglext.h:309)
WGL_TYPE_RGBA_FLOAT_ATI = 8608 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:310
WGL_RGBA_FLOAT_MODE_ATI = 34848 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:311
WGL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI = 34869 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:312
# NV_float_buffer (http://developer.download.nvidia.com/opengl/includes/wglext.h:315)
WGL_FLOAT_COMPONENTS_NV = 8368 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:316
WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_R_NV = 8369 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:317
WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RG_NV = 8370 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:318
WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGB_NV = 8371 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:319
WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGBA_NV = 8372 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:320
WGL_TEXTURE_FLOAT_R_NV = 8373 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:321
WGL_TEXTURE_FLOAT_RG_NV = 8374 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:322
WGL_TEXTURE_FLOAT_RGB_NV = 8375 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:323
WGL_TEXTURE_FLOAT_RGBA_NV = 8376 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:324
# NV_swap_group (http://developer.download.nvidia.com/opengl/includes/wglext.h:327)
# NV_gpu_affinity (http://developer.download.nvidia.com/opengl/includes/wglext.h:330)
WGL_ERROR_INCOMPATIBLE_AFFINITY_MASKS_NV = 8400 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:331
WGL_ERROR_MISSING_AFFINITY_MASK_NV = 8401 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:332
# ARB_pbuffer (http://developer.download.nvidia.com/opengl/includes/wglext.h:338)
HANDLE = POINTER(None) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:58
HPBUFFERARB = HANDLE 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:339
# EXT_pbuffer (http://developer.download.nvidia.com/opengl/includes/wglext.h:341)
HPBUFFEREXT = HANDLE 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:342
# NV_gpu_affinity (http://developer.download.nvidia.com/opengl/includes/wglext.h:345)
HGPUNV = HANDLE 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:346
class struct__GPU_DEVICE(Structure):
    __slots__ = [
        'cb',
        'DeviceName',
        'DeviceString',
        'Flags',
        'rcVirtualScreen',
    ]
DWORD = c_ulong 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:54
CHAR = c_char 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:47
class struct_tagRECT(Structure):
    __slots__ = [
        'left',
        'top',
        'right',
        'bottom',
    ]
LONG = c_long 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:53
struct_tagRECT._fields_ = [
    ('left', LONG),
    ('top', LONG),
    ('right', LONG),
    ('bottom', LONG),
]

RECT = struct_tagRECT 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:200
struct__GPU_DEVICE._fields_ = [
    ('cb', DWORD),
    ('DeviceName', CHAR * 32),
    ('DeviceString', CHAR * 128),
    ('Flags', DWORD),
    ('rcVirtualScreen', RECT),
]

GPU_DEVICE = struct__GPU_DEVICE 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:353
PGPU_DEVICE = POINTER(struct__GPU_DEVICE) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:353
# ARB_buffer_region (http://developer.download.nvidia.com/opengl/includes/wglext.h:356)
WGL_ARB_buffer_region = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:357
HDC = HANDLE 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:61
UINT = c_uint 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:50
# http://developer.download.nvidia.com/opengl/includes/wglext.h:359
wglCreateBufferRegionARB = _link_function('wglCreateBufferRegionARB', HANDLE, [HDC, c_int, UINT], 'ARB_buffer_region')

VOID = None 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:45
# http://developer.download.nvidia.com/opengl/includes/wglext.h:360
wglDeleteBufferRegionARB = _link_function('wglDeleteBufferRegionARB', VOID, [HANDLE], 'ARB_buffer_region')

BOOL = c_long 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:52
# http://developer.download.nvidia.com/opengl/includes/wglext.h:361
wglSaveBufferRegionARB = _link_function('wglSaveBufferRegionARB', BOOL, [HANDLE, c_int, c_int, c_int, c_int], 'ARB_buffer_region')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:362
wglRestoreBufferRegionARB = _link_function('wglRestoreBufferRegionARB', BOOL, [HANDLE, c_int, c_int, c_int, c_int, c_int, c_int], 'ARB_buffer_region')

PFNWGLCREATEBUFFERREGIONARBPROC = CFUNCTYPE(HANDLE, HDC, c_int, UINT) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:364
PFNWGLDELETEBUFFERREGIONARBPROC = CFUNCTYPE(VOID, HANDLE) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:365
PFNWGLSAVEBUFFERREGIONARBPROC = CFUNCTYPE(BOOL, HANDLE, c_int, c_int, c_int, c_int) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:366
PFNWGLRESTOREBUFFERREGIONARBPROC = CFUNCTYPE(BOOL, HANDLE, c_int, c_int, c_int, c_int, c_int, c_int) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:367
# ARB_multisample (http://developer.download.nvidia.com/opengl/includes/wglext.h:370)
WGL_ARB_multisample = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:371
# ARB_extensions_string (http://developer.download.nvidia.com/opengl/includes/wglext.h:374)
WGL_ARB_extensions_string = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:375
# http://developer.download.nvidia.com/opengl/includes/wglext.h:377
wglGetExtensionsStringARB = _link_function('wglGetExtensionsStringARB', c_char_p, [HDC], 'ARB_extensions_string')

PFNWGLGETEXTENSIONSSTRINGARBPROC = CFUNCTYPE(c_char_p, HDC) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:379
# ARB_pixel_format (http://developer.download.nvidia.com/opengl/includes/wglext.h:382)
WGL_ARB_pixel_format = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:383
# http://developer.download.nvidia.com/opengl/includes/wglext.h:385
wglGetPixelFormatAttribivARB = _link_function('wglGetPixelFormatAttribivARB', BOOL, [HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(c_int)], 'ARB_pixel_format')

FLOAT = c_float 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:55
# http://developer.download.nvidia.com/opengl/includes/wglext.h:386
wglGetPixelFormatAttribfvARB = _link_function('wglGetPixelFormatAttribfvARB', BOOL, [HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(FLOAT)], 'ARB_pixel_format')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:387
wglChoosePixelFormatARB = _link_function('wglChoosePixelFormatARB', BOOL, [HDC, POINTER(c_int), POINTER(FLOAT), UINT, POINTER(c_int), POINTER(UINT)], 'ARB_pixel_format')

PFNWGLGETPIXELFORMATATTRIBIVARBPROC = CFUNCTYPE(BOOL, HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(c_int)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:389
PFNWGLGETPIXELFORMATATTRIBFVARBPROC = CFUNCTYPE(BOOL, HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(FLOAT)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:390
PFNWGLCHOOSEPIXELFORMATARBPROC = CFUNCTYPE(BOOL, HDC, POINTER(c_int), POINTER(FLOAT), UINT, POINTER(c_int), POINTER(UINT)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:391
# ARB_make_current_read (http://developer.download.nvidia.com/opengl/includes/wglext.h:394)
WGL_ARB_make_current_read = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:395
HGLRC = HANDLE 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:60
# http://developer.download.nvidia.com/opengl/includes/wglext.h:397
wglMakeContextCurrentARB = _link_function('wglMakeContextCurrentARB', BOOL, [HDC, HDC, HGLRC], 'ARB_make_current_read')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:398
wglGetCurrentReadDCARB = _link_function('wglGetCurrentReadDCARB', HDC, [], 'ARB_make_current_read')

PFNWGLMAKECONTEXTCURRENTARBPROC = CFUNCTYPE(BOOL, HDC, HDC, HGLRC) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:400
PFNWGLGETCURRENTREADDCARBPROC = CFUNCTYPE(HDC) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:401
# ARB_pbuffer (http://developer.download.nvidia.com/opengl/includes/wglext.h:404)
WGL_ARB_pbuffer = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:405
# http://developer.download.nvidia.com/opengl/includes/wglext.h:407
wglCreatePbufferARB = _link_function('wglCreatePbufferARB', HPBUFFERARB, [HDC, c_int, c_int, c_int, POINTER(c_int)], 'ARB_pbuffer')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:408
wglGetPbufferDCARB = _link_function('wglGetPbufferDCARB', HDC, [HPBUFFERARB], 'ARB_pbuffer')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:409
wglReleasePbufferDCARB = _link_function('wglReleasePbufferDCARB', c_int, [HPBUFFERARB, HDC], 'ARB_pbuffer')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:410
wglDestroyPbufferARB = _link_function('wglDestroyPbufferARB', BOOL, [HPBUFFERARB], 'ARB_pbuffer')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:411
wglQueryPbufferARB = _link_function('wglQueryPbufferARB', BOOL, [HPBUFFERARB, c_int, POINTER(c_int)], 'ARB_pbuffer')

PFNWGLCREATEPBUFFERARBPROC = CFUNCTYPE(HPBUFFERARB, HDC, c_int, c_int, c_int, POINTER(c_int)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:413
PFNWGLGETPBUFFERDCARBPROC = CFUNCTYPE(HDC, HPBUFFERARB) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:414
PFNWGLRELEASEPBUFFERDCARBPROC = CFUNCTYPE(c_int, HPBUFFERARB, HDC) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:415
PFNWGLDESTROYPBUFFERARBPROC = CFUNCTYPE(BOOL, HPBUFFERARB) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:416
PFNWGLQUERYPBUFFERARBPROC = CFUNCTYPE(BOOL, HPBUFFERARB, c_int, POINTER(c_int)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:417
# ARB_render_texture (http://developer.download.nvidia.com/opengl/includes/wglext.h:420)
WGL_ARB_render_texture = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:421
# http://developer.download.nvidia.com/opengl/includes/wglext.h:423
wglBindTexImageARB = _link_function('wglBindTexImageARB', BOOL, [HPBUFFERARB, c_int], 'ARB_render_texture')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:424
wglReleaseTexImageARB = _link_function('wglReleaseTexImageARB', BOOL, [HPBUFFERARB, c_int], 'ARB_render_texture')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:425
wglSetPbufferAttribARB = _link_function('wglSetPbufferAttribARB', BOOL, [HPBUFFERARB, POINTER(c_int)], 'ARB_render_texture')

PFNWGLBINDTEXIMAGEARBPROC = CFUNCTYPE(BOOL, HPBUFFERARB, c_int) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:427
PFNWGLRELEASETEXIMAGEARBPROC = CFUNCTYPE(BOOL, HPBUFFERARB, c_int) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:428
PFNWGLSETPBUFFERATTRIBARBPROC = CFUNCTYPE(BOOL, HPBUFFERARB, POINTER(c_int)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:429
# ARB_pixel_format_float (http://developer.download.nvidia.com/opengl/includes/wglext.h:432)
WGL_ARB_pixel_format_float = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:433
# EXT_display_color_table (http://developer.download.nvidia.com/opengl/includes/wglext.h:436)
WGL_EXT_display_color_table = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:437
GLboolean = c_ubyte 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:18
GLushort = c_ushort 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:25
# http://developer.download.nvidia.com/opengl/includes/wglext.h:439
wglCreateDisplayColorTableEXT = _link_function('wglCreateDisplayColorTableEXT', GLboolean, [GLushort], 'EXT_display_color_table')

GLuint = c_uint 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:26
# http://developer.download.nvidia.com/opengl/includes/wglext.h:440
wglLoadDisplayColorTableEXT = _link_function('wglLoadDisplayColorTableEXT', GLboolean, [POINTER(GLushort), GLuint], 'EXT_display_color_table')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:441
wglBindDisplayColorTableEXT = _link_function('wglBindDisplayColorTableEXT', GLboolean, [GLushort], 'EXT_display_color_table')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:442
wglDestroyDisplayColorTableEXT = _link_function('wglDestroyDisplayColorTableEXT', VOID, [GLushort], 'EXT_display_color_table')

PFNWGLCREATEDISPLAYCOLORTABLEEXTPROC = CFUNCTYPE(GLboolean, GLushort) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:444
PFNWGLLOADDISPLAYCOLORTABLEEXTPROC = CFUNCTYPE(GLboolean, POINTER(GLushort), GLuint) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:445
PFNWGLBINDDISPLAYCOLORTABLEEXTPROC = CFUNCTYPE(GLboolean, GLushort) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:446
PFNWGLDESTROYDISPLAYCOLORTABLEEXTPROC = CFUNCTYPE(VOID, GLushort) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:447
# EXT_extensions_string (http://developer.download.nvidia.com/opengl/includes/wglext.h:450)
WGL_EXT_extensions_string = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:451
# http://developer.download.nvidia.com/opengl/includes/wglext.h:453
wglGetExtensionsStringEXT = _link_function('wglGetExtensionsStringEXT', c_char_p, [], 'EXT_extensions_string')

PFNWGLGETEXTENSIONSSTRINGEXTPROC = CFUNCTYPE(c_char_p) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:455
# EXT_make_current_read (http://developer.download.nvidia.com/opengl/includes/wglext.h:458)
WGL_EXT_make_current_read = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:459
# http://developer.download.nvidia.com/opengl/includes/wglext.h:461
wglMakeContextCurrentEXT = _link_function('wglMakeContextCurrentEXT', BOOL, [HDC, HDC, HGLRC], 'EXT_make_current_read')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:462
wglGetCurrentReadDCEXT = _link_function('wglGetCurrentReadDCEXT', HDC, [], 'EXT_make_current_read')

PFNWGLMAKECONTEXTCURRENTEXTPROC = CFUNCTYPE(BOOL, HDC, HDC, HGLRC) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:464
PFNWGLGETCURRENTREADDCEXTPROC = CFUNCTYPE(HDC) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:465
# EXT_pbuffer (http://developer.download.nvidia.com/opengl/includes/wglext.h:468)
WGL_EXT_pbuffer = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:469
# http://developer.download.nvidia.com/opengl/includes/wglext.h:471
wglCreatePbufferEXT = _link_function('wglCreatePbufferEXT', HPBUFFEREXT, [HDC, c_int, c_int, c_int, POINTER(c_int)], 'EXT_pbuffer')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:472
wglGetPbufferDCEXT = _link_function('wglGetPbufferDCEXT', HDC, [HPBUFFEREXT], 'EXT_pbuffer')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:473
wglReleasePbufferDCEXT = _link_function('wglReleasePbufferDCEXT', c_int, [HPBUFFEREXT, HDC], 'EXT_pbuffer')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:474
wglDestroyPbufferEXT = _link_function('wglDestroyPbufferEXT', BOOL, [HPBUFFEREXT], 'EXT_pbuffer')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:475
wglQueryPbufferEXT = _link_function('wglQueryPbufferEXT', BOOL, [HPBUFFEREXT, c_int, POINTER(c_int)], 'EXT_pbuffer')

PFNWGLCREATEPBUFFEREXTPROC = CFUNCTYPE(HPBUFFEREXT, HDC, c_int, c_int, c_int, POINTER(c_int)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:477
PFNWGLGETPBUFFERDCEXTPROC = CFUNCTYPE(HDC, HPBUFFEREXT) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:478
PFNWGLRELEASEPBUFFERDCEXTPROC = CFUNCTYPE(c_int, HPBUFFEREXT, HDC) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:479
PFNWGLDESTROYPBUFFEREXTPROC = CFUNCTYPE(BOOL, HPBUFFEREXT) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:480
PFNWGLQUERYPBUFFEREXTPROC = CFUNCTYPE(BOOL, HPBUFFEREXT, c_int, POINTER(c_int)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:481
# EXT_pixel_format (http://developer.download.nvidia.com/opengl/includes/wglext.h:484)
WGL_EXT_pixel_format = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:485
# http://developer.download.nvidia.com/opengl/includes/wglext.h:487
wglGetPixelFormatAttribivEXT = _link_function('wglGetPixelFormatAttribivEXT', BOOL, [HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(c_int)], 'EXT_pixel_format')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:488
wglGetPixelFormatAttribfvEXT = _link_function('wglGetPixelFormatAttribfvEXT', BOOL, [HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(FLOAT)], 'EXT_pixel_format')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:489
wglChoosePixelFormatEXT = _link_function('wglChoosePixelFormatEXT', BOOL, [HDC, POINTER(c_int), POINTER(FLOAT), UINT, POINTER(c_int), POINTER(UINT)], 'EXT_pixel_format')

PFNWGLGETPIXELFORMATATTRIBIVEXTPROC = CFUNCTYPE(BOOL, HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(c_int)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:491
PFNWGLGETPIXELFORMATATTRIBFVEXTPROC = CFUNCTYPE(BOOL, HDC, c_int, c_int, UINT, POINTER(c_int), POINTER(FLOAT)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:492
PFNWGLCHOOSEPIXELFORMATEXTPROC = CFUNCTYPE(BOOL, HDC, POINTER(c_int), POINTER(FLOAT), UINT, POINTER(c_int), POINTER(UINT)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:493
# EXT_swap_control (http://developer.download.nvidia.com/opengl/includes/wglext.h:496)
WGL_EXT_swap_control = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:497
# http://developer.download.nvidia.com/opengl/includes/wglext.h:499
wglSwapIntervalEXT = _link_function('wglSwapIntervalEXT', BOOL, [c_int], 'EXT_swap_control')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:500
wglGetSwapIntervalEXT = _link_function('wglGetSwapIntervalEXT', c_int, [], 'EXT_swap_control')

PFNWGLSWAPINTERVALEXTPROC = CFUNCTYPE(BOOL, c_int) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:502
PFNWGLGETSWAPINTERVALEXTPROC = CFUNCTYPE(c_int) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:503
# EXT_depth_float (http://developer.download.nvidia.com/opengl/includes/wglext.h:506)
WGL_EXT_depth_float = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:507
# NV_vertex_array_range (http://developer.download.nvidia.com/opengl/includes/wglext.h:510)
WGL_NV_vertex_array_range = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:511
GLsizei = c_int 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:23
GLfloat = c_float 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:27
# http://developer.download.nvidia.com/opengl/includes/wglext.h:513
wglAllocateMemoryNV = _link_function('wglAllocateMemoryNV', POINTER(c_void), [GLsizei, GLfloat, GLfloat, GLfloat], 'NV_vertex_array_range')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:514
wglFreeMemoryNV = _link_function('wglFreeMemoryNV', None, [POINTER(None)], 'NV_vertex_array_range')

PFNWGLALLOCATEMEMORYNVPROC = CFUNCTYPE(POINTER(c_void), GLsizei, GLfloat, GLfloat, GLfloat) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:516
PFNWGLFREEMEMORYNVPROC = CFUNCTYPE(None, POINTER(None)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:517
# 3DFX_multisample (http://developer.download.nvidia.com/opengl/includes/wglext.h:520)
WGL_3DFX_multisample = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:521
# EXT_multisample (http://developer.download.nvidia.com/opengl/includes/wglext.h:524)
WGL_EXT_multisample = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:525
# OML_sync_control (http://developer.download.nvidia.com/opengl/includes/wglext.h:528)
WGL_OML_sync_control = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:529
INT64 = c_longlong 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:42
# http://developer.download.nvidia.com/opengl/includes/wglext.h:531
wglGetSyncValuesOML = _link_function('wglGetSyncValuesOML', BOOL, [HDC, POINTER(INT64), POINTER(INT64), POINTER(INT64)], 'OML_sync_control')

INT32 = c_int 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:35
# http://developer.download.nvidia.com/opengl/includes/wglext.h:532
wglGetMscRateOML = _link_function('wglGetMscRateOML', BOOL, [HDC, POINTER(INT32), POINTER(INT32)], 'OML_sync_control')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:533
wglSwapBuffersMscOML = _link_function('wglSwapBuffersMscOML', INT64, [HDC, INT64, INT64, INT64], 'OML_sync_control')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:534
wglSwapLayerBuffersMscOML = _link_function('wglSwapLayerBuffersMscOML', INT64, [HDC, c_int, INT64, INT64, INT64], 'OML_sync_control')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:535
wglWaitForMscOML = _link_function('wglWaitForMscOML', BOOL, [HDC, INT64, INT64, INT64, POINTER(INT64), POINTER(INT64), POINTER(INT64)], 'OML_sync_control')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:536
wglWaitForSbcOML = _link_function('wglWaitForSbcOML', BOOL, [HDC, INT64, POINTER(INT64), POINTER(INT64), POINTER(INT64)], 'OML_sync_control')

PFNWGLGETSYNCVALUESOMLPROC = CFUNCTYPE(BOOL, HDC, POINTER(INT64), POINTER(INT64), POINTER(INT64)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:538
PFNWGLGETMSCRATEOMLPROC = CFUNCTYPE(BOOL, HDC, POINTER(INT32), POINTER(INT32)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:539
PFNWGLSWAPBUFFERSMSCOMLPROC = CFUNCTYPE(INT64, HDC, INT64, INT64, INT64) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:540
PFNWGLSWAPLAYERBUFFERSMSCOMLPROC = CFUNCTYPE(INT64, HDC, c_int, INT64, INT64, INT64) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:541
PFNWGLWAITFORMSCOMLPROC = CFUNCTYPE(BOOL, HDC, INT64, INT64, INT64, POINTER(INT64), POINTER(INT64), POINTER(INT64)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:542
PFNWGLWAITFORSBCOMLPROC = CFUNCTYPE(BOOL, HDC, INT64, POINTER(INT64), POINTER(INT64), POINTER(INT64)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:543
# I3D_digital_video_control (http://developer.download.nvidia.com/opengl/includes/wglext.h:546)
WGL_I3D_digital_video_control = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:547
# http://developer.download.nvidia.com/opengl/includes/wglext.h:549
wglGetDigitalVideoParametersI3D = _link_function('wglGetDigitalVideoParametersI3D', BOOL, [HDC, c_int, POINTER(c_int)], 'I3D_digital_video_control')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:550
wglSetDigitalVideoParametersI3D = _link_function('wglSetDigitalVideoParametersI3D', BOOL, [HDC, c_int, POINTER(c_int)], 'I3D_digital_video_control')

PFNWGLGETDIGITALVIDEOPARAMETERSI3DPROC = CFUNCTYPE(BOOL, HDC, c_int, POINTER(c_int)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:552
PFNWGLSETDIGITALVIDEOPARAMETERSI3DPROC = CFUNCTYPE(BOOL, HDC, c_int, POINTER(c_int)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:553
# I3D_gamma (http://developer.download.nvidia.com/opengl/includes/wglext.h:556)
WGL_I3D_gamma = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:557
# http://developer.download.nvidia.com/opengl/includes/wglext.h:559
wglGetGammaTableParametersI3D = _link_function('wglGetGammaTableParametersI3D', BOOL, [HDC, c_int, POINTER(c_int)], 'I3D_gamma')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:560
wglSetGammaTableParametersI3D = _link_function('wglSetGammaTableParametersI3D', BOOL, [HDC, c_int, POINTER(c_int)], 'I3D_gamma')

USHORT = c_ushort 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:49
# http://developer.download.nvidia.com/opengl/includes/wglext.h:561
wglGetGammaTableI3D = _link_function('wglGetGammaTableI3D', BOOL, [HDC, c_int, POINTER(USHORT), POINTER(USHORT), POINTER(USHORT)], 'I3D_gamma')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:562
wglSetGammaTableI3D = _link_function('wglSetGammaTableI3D', BOOL, [HDC, c_int, POINTER(USHORT), POINTER(USHORT), POINTER(USHORT)], 'I3D_gamma')

PFNWGLGETGAMMATABLEPARAMETERSI3DPROC = CFUNCTYPE(BOOL, HDC, c_int, POINTER(c_int)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:564
PFNWGLSETGAMMATABLEPARAMETERSI3DPROC = CFUNCTYPE(BOOL, HDC, c_int, POINTER(c_int)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:565
PFNWGLGETGAMMATABLEI3DPROC = CFUNCTYPE(BOOL, HDC, c_int, POINTER(USHORT), POINTER(USHORT), POINTER(USHORT)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:566
PFNWGLSETGAMMATABLEI3DPROC = CFUNCTYPE(BOOL, HDC, c_int, POINTER(USHORT), POINTER(USHORT), POINTER(USHORT)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:567
# I3D_genlock (http://developer.download.nvidia.com/opengl/includes/wglext.h:570)
WGL_I3D_genlock = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:571
# http://developer.download.nvidia.com/opengl/includes/wglext.h:573
wglEnableGenlockI3D = _link_function('wglEnableGenlockI3D', BOOL, [HDC], 'I3D_genlock')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:574
wglDisableGenlockI3D = _link_function('wglDisableGenlockI3D', BOOL, [HDC], 'I3D_genlock')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:575
wglIsEnabledGenlockI3D = _link_function('wglIsEnabledGenlockI3D', BOOL, [HDC, POINTER(BOOL)], 'I3D_genlock')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:576
wglGenlockSourceI3D = _link_function('wglGenlockSourceI3D', BOOL, [HDC, UINT], 'I3D_genlock')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:577
wglGetGenlockSourceI3D = _link_function('wglGetGenlockSourceI3D', BOOL, [HDC, POINTER(UINT)], 'I3D_genlock')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:578
wglGenlockSourceEdgeI3D = _link_function('wglGenlockSourceEdgeI3D', BOOL, [HDC, UINT], 'I3D_genlock')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:579
wglGetGenlockSourceEdgeI3D = _link_function('wglGetGenlockSourceEdgeI3D', BOOL, [HDC, POINTER(UINT)], 'I3D_genlock')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:580
wglGenlockSampleRateI3D = _link_function('wglGenlockSampleRateI3D', BOOL, [HDC, UINT], 'I3D_genlock')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:581
wglGetGenlockSampleRateI3D = _link_function('wglGetGenlockSampleRateI3D', BOOL, [HDC, POINTER(UINT)], 'I3D_genlock')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:582
wglGenlockSourceDelayI3D = _link_function('wglGenlockSourceDelayI3D', BOOL, [HDC, UINT], 'I3D_genlock')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:583
wglGetGenlockSourceDelayI3D = _link_function('wglGetGenlockSourceDelayI3D', BOOL, [HDC, POINTER(UINT)], 'I3D_genlock')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:584
wglQueryGenlockMaxSourceDelayI3D = _link_function('wglQueryGenlockMaxSourceDelayI3D', BOOL, [HDC, POINTER(UINT), POINTER(UINT)], 'I3D_genlock')

PFNWGLENABLEGENLOCKI3DPROC = CFUNCTYPE(BOOL, HDC) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:586
PFNWGLDISABLEGENLOCKI3DPROC = CFUNCTYPE(BOOL, HDC) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:587
PFNWGLISENABLEDGENLOCKI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(BOOL)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:588
PFNWGLGENLOCKSOURCEI3DPROC = CFUNCTYPE(BOOL, HDC, UINT) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:589
PFNWGLGETGENLOCKSOURCEI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(UINT)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:590
PFNWGLGENLOCKSOURCEEDGEI3DPROC = CFUNCTYPE(BOOL, HDC, UINT) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:591
PFNWGLGETGENLOCKSOURCEEDGEI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(UINT)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:592
PFNWGLGENLOCKSAMPLERATEI3DPROC = CFUNCTYPE(BOOL, HDC, UINT) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:593
PFNWGLGETGENLOCKSAMPLERATEI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(UINT)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:594
PFNWGLGENLOCKSOURCEDELAYI3DPROC = CFUNCTYPE(BOOL, HDC, UINT) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:595
PFNWGLGETGENLOCKSOURCEDELAYI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(UINT)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:596
PFNWGLQUERYGENLOCKMAXSOURCEDELAYI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(UINT), POINTER(UINT)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:597
# I3D_image_buffer (http://developer.download.nvidia.com/opengl/includes/wglext.h:600)
WGL_I3D_image_buffer = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:601
LPVOID = POINTER(None) 	# C:\cygwin\home\Alex\pyglet\tools\wgl.h:45
# http://developer.download.nvidia.com/opengl/includes/wglext.h:603
wglCreateImageBufferI3D = _link_function('wglCreateImageBufferI3D', LPVOID, [HDC, DWORD, UINT], 'I3D_image_buffer')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:604
wglDestroyImageBufferI3D = _link_function('wglDestroyImageBufferI3D', BOOL, [HDC, LPVOID], 'I3D_image_buffer')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:605
wglAssociateImageBufferEventsI3D = _link_function('wglAssociateImageBufferEventsI3D', BOOL, [HDC, POINTER(HANDLE), POINTER(LPVOID), POINTER(DWORD), UINT], 'I3D_image_buffer')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:606
wglReleaseImageBufferEventsI3D = _link_function('wglReleaseImageBufferEventsI3D', BOOL, [HDC, POINTER(LPVOID), UINT], 'I3D_image_buffer')

PFNWGLCREATEIMAGEBUFFERI3DPROC = CFUNCTYPE(LPVOID, HDC, DWORD, UINT) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:608
PFNWGLDESTROYIMAGEBUFFERI3DPROC = CFUNCTYPE(BOOL, HDC, LPVOID) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:609
PFNWGLASSOCIATEIMAGEBUFFEREVENTSI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(HANDLE), POINTER(LPVOID), POINTER(DWORD), UINT) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:610
PFNWGLRELEASEIMAGEBUFFEREVENTSI3DPROC = CFUNCTYPE(BOOL, HDC, POINTER(LPVOID), UINT) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:611
# I3D_swap_frame_lock (http://developer.download.nvidia.com/opengl/includes/wglext.h:614)
WGL_I3D_swap_frame_lock = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:615
# http://developer.download.nvidia.com/opengl/includes/wglext.h:617
wglEnableFrameLockI3D = _link_function('wglEnableFrameLockI3D', BOOL, [], 'I3D_swap_frame_lock')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:618
wglDisableFrameLockI3D = _link_function('wglDisableFrameLockI3D', BOOL, [], 'I3D_swap_frame_lock')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:619
wglIsEnabledFrameLockI3D = _link_function('wglIsEnabledFrameLockI3D', BOOL, [POINTER(BOOL)], 'I3D_swap_frame_lock')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:620
wglQueryFrameLockMasterI3D = _link_function('wglQueryFrameLockMasterI3D', BOOL, [POINTER(BOOL)], 'I3D_swap_frame_lock')

PFNWGLENABLEFRAMELOCKI3DPROC = CFUNCTYPE(BOOL) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:622
PFNWGLDISABLEFRAMELOCKI3DPROC = CFUNCTYPE(BOOL) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:623
PFNWGLISENABLEDFRAMELOCKI3DPROC = CFUNCTYPE(BOOL, POINTER(BOOL)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:624
PFNWGLQUERYFRAMELOCKMASTERI3DPROC = CFUNCTYPE(BOOL, POINTER(BOOL)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:625
# I3D_swap_frame_usage (http://developer.download.nvidia.com/opengl/includes/wglext.h:628)
WGL_I3D_swap_frame_usage = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:629
# http://developer.download.nvidia.com/opengl/includes/wglext.h:631
wglGetFrameUsageI3D = _link_function('wglGetFrameUsageI3D', BOOL, [POINTER(c_float)], 'I3D_swap_frame_usage')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:632
wglBeginFrameTrackingI3D = _link_function('wglBeginFrameTrackingI3D', BOOL, [], 'I3D_swap_frame_usage')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:633
wglEndFrameTrackingI3D = _link_function('wglEndFrameTrackingI3D', BOOL, [], 'I3D_swap_frame_usage')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:634
wglQueryFrameTrackingI3D = _link_function('wglQueryFrameTrackingI3D', BOOL, [POINTER(DWORD), POINTER(DWORD), POINTER(c_float)], 'I3D_swap_frame_usage')

PFNWGLGETFRAMEUSAGEI3DPROC = CFUNCTYPE(BOOL, POINTER(c_float)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:636
PFNWGLBEGINFRAMETRACKINGI3DPROC = CFUNCTYPE(BOOL) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:637
PFNWGLENDFRAMETRACKINGI3DPROC = CFUNCTYPE(BOOL) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:638
PFNWGLQUERYFRAMETRACKINGI3DPROC = CFUNCTYPE(BOOL, POINTER(DWORD), POINTER(DWORD), POINTER(c_float)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:639
# ATI_pixel_format_float (http://developer.download.nvidia.com/opengl/includes/wglext.h:642)
WGL_ATI_pixel_format_float = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:643
# NV_render_depth_texture (http://developer.download.nvidia.com/opengl/includes/wglext.h:646)
WGL_NV_render_depth_texture = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:647
# NV_render_texture_rectangle (http://developer.download.nvidia.com/opengl/includes/wglext.h:650)
WGL_NV_render_texture_rectangle = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:651
# NV_float_buffer (http://developer.download.nvidia.com/opengl/includes/wglext.h:654)
WGL_NV_float_buffer = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:655
# NV_swap_group (http://developer.download.nvidia.com/opengl/includes/wglext.h:658)
WGL_NV_swap_group = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:659
# http://developer.download.nvidia.com/opengl/includes/wglext.h:661
wglJoinSwapGroupNV = _link_function('wglJoinSwapGroupNV', BOOL, [HDC, GLuint], 'NV_swap_group')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:662
wglBindSwapBarrierNV = _link_function('wglBindSwapBarrierNV', BOOL, [GLuint, GLuint], 'NV_swap_group')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:663
wglQuerySwapGroupNV = _link_function('wglQuerySwapGroupNV', BOOL, [HDC, POINTER(GLuint), POINTER(GLuint)], 'NV_swap_group')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:664
wglQueryMaxSwapGroupsNV = _link_function('wglQueryMaxSwapGroupsNV', BOOL, [HDC, POINTER(GLuint), POINTER(GLuint)], 'NV_swap_group')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:665
wglQueryFrameCountNV = _link_function('wglQueryFrameCountNV', BOOL, [HDC, POINTER(GLuint)], 'NV_swap_group')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:666
wglResetFrameCountNV = _link_function('wglResetFrameCountNV', BOOL, [HDC], 'NV_swap_group')

PFNWGLJOINSWAPGROUPNVPROC = CFUNCTYPE(BOOL, HDC, GLuint) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:668
PFNWGLBINDSWAPBARRIERNVPROC = CFUNCTYPE(BOOL, GLuint, GLuint) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:669
PFNWGLQUERYSWAPGROUPNVPROC = CFUNCTYPE(BOOL, HDC, POINTER(GLuint), POINTER(GLuint)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:670
PFNWGLQUERYMAXSWAPGROUPSNVPROC = CFUNCTYPE(BOOL, HDC, POINTER(GLuint), POINTER(GLuint)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:671
PFNWGLQUERYFRAMECOUNTNVPROC = CFUNCTYPE(BOOL, HDC, POINTER(GLuint)) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:672
PFNWGLRESETFRAMECOUNTNVPROC = CFUNCTYPE(BOOL, HDC) 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:673
# NV_gpu_affinity (http://developer.download.nvidia.com/opengl/includes/wglext.h:676)
WGL_NV_gpu_affinity = 1 	# http://developer.download.nvidia.com/opengl/includes/wglext.h:677
# http://developer.download.nvidia.com/opengl/includes/wglext.h:679
wglEnumGpusNV = _link_function('wglEnumGpusNV', BOOL, [UINT, POINTER(HGPUNV)], 'NV_gpu_affinity')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:680
wglEnumGpuDevicesNV = _link_function('wglEnumGpuDevicesNV', BOOL, [HGPUNV, UINT, PGPU_DEVICE], 'NV_gpu_affinity')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:681
wglCreateAffinityDCNV = _link_function('wglCreateAffinityDCNV', HDC, [POINTER(HGPUNV)], 'NV_gpu_affinity')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:682
wglEnumGpusFromAffinityDCNV = _link_function('wglEnumGpusFromAffinityDCNV', BOOL, [HDC, UINT, POINTER(HGPUNV)], 'NV_gpu_affinity')

# http://developer.download.nvidia.com/opengl/includes/wglext.h:683
wglDeleteDCNV = _link_function('wglDeleteDCNV', BOOL, [HDC], 'NV_gpu_affinity')


__all__ = ['WIN32_LEAN_AND_MEAN', 'GLAPI', 'WGL_WGLEXT_VERSION',
'WGL_FRONT_COLOR_BUFFER_BIT_ARB', 'WGL_BACK_COLOR_BUFFER_BIT_ARB',
'WGL_DEPTH_BUFFER_BIT_ARB', 'WGL_STENCIL_BUFFER_BIT_ARB',
'WGL_SAMPLE_BUFFERS_ARB', 'WGL_SAMPLES_ARB', 'WGL_NUMBER_PIXEL_FORMATS_ARB',
'WGL_DRAW_TO_WINDOW_ARB', 'WGL_DRAW_TO_BITMAP_ARB', 'WGL_ACCELERATION_ARB',
'WGL_NEED_PALETTE_ARB', 'WGL_NEED_SYSTEM_PALETTE_ARB',
'WGL_SWAP_LAYER_BUFFERS_ARB', 'WGL_SWAP_METHOD_ARB',
'WGL_NUMBER_OVERLAYS_ARB', 'WGL_NUMBER_UNDERLAYS_ARB', 'WGL_TRANSPARENT_ARB',
'WGL_TRANSPARENT_RED_VALUE_ARB', 'WGL_TRANSPARENT_GREEN_VALUE_ARB',
'WGL_TRANSPARENT_BLUE_VALUE_ARB', 'WGL_TRANSPARENT_ALPHA_VALUE_ARB',
'WGL_TRANSPARENT_INDEX_VALUE_ARB', 'WGL_SHARE_DEPTH_ARB',
'WGL_SHARE_STENCIL_ARB', 'WGL_SHARE_ACCUM_ARB', 'WGL_SUPPORT_GDI_ARB',
'WGL_SUPPORT_OPENGL_ARB', 'WGL_DOUBLE_BUFFER_ARB', 'WGL_STEREO_ARB',
'WGL_PIXEL_TYPE_ARB', 'WGL_COLOR_BITS_ARB', 'WGL_RED_BITS_ARB',
'WGL_RED_SHIFT_ARB', 'WGL_GREEN_BITS_ARB', 'WGL_GREEN_SHIFT_ARB',
'WGL_BLUE_BITS_ARB', 'WGL_BLUE_SHIFT_ARB', 'WGL_ALPHA_BITS_ARB',
'WGL_ALPHA_SHIFT_ARB', 'WGL_ACCUM_BITS_ARB', 'WGL_ACCUM_RED_BITS_ARB',
'WGL_ACCUM_GREEN_BITS_ARB', 'WGL_ACCUM_BLUE_BITS_ARB',
'WGL_ACCUM_ALPHA_BITS_ARB', 'WGL_DEPTH_BITS_ARB', 'WGL_STENCIL_BITS_ARB',
'WGL_AUX_BUFFERS_ARB', 'WGL_NO_ACCELERATION_ARB',
'WGL_GENERIC_ACCELERATION_ARB', 'WGL_FULL_ACCELERATION_ARB',
'WGL_SWAP_EXCHANGE_ARB', 'WGL_SWAP_COPY_ARB', 'WGL_SWAP_UNDEFINED_ARB',
'WGL_TYPE_RGBA_ARB', 'WGL_TYPE_COLORINDEX_ARB',
'ERROR_INVALID_PIXEL_TYPE_ARB', 'ERROR_INCOMPATIBLE_DEVICE_CONTEXTS_ARB',
'WGL_DRAW_TO_PBUFFER_ARB', 'WGL_MAX_PBUFFER_PIXELS_ARB',
'WGL_MAX_PBUFFER_WIDTH_ARB', 'WGL_MAX_PBUFFER_HEIGHT_ARB',
'WGL_PBUFFER_LARGEST_ARB', 'WGL_PBUFFER_WIDTH_ARB', 'WGL_PBUFFER_HEIGHT_ARB',
'WGL_PBUFFER_LOST_ARB', 'WGL_BIND_TO_TEXTURE_RGB_ARB',
'WGL_BIND_TO_TEXTURE_RGBA_ARB', 'WGL_TEXTURE_FORMAT_ARB',
'WGL_TEXTURE_TARGET_ARB', 'WGL_MIPMAP_TEXTURE_ARB', 'WGL_TEXTURE_RGB_ARB',
'WGL_TEXTURE_RGBA_ARB', 'WGL_NO_TEXTURE_ARB', 'WGL_TEXTURE_CUBE_MAP_ARB',
'WGL_TEXTURE_1D_ARB', 'WGL_TEXTURE_2D_ARB', 'WGL_MIPMAP_LEVEL_ARB',
'WGL_CUBE_MAP_FACE_ARB', 'WGL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB',
'WGL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB', 'WGL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB',
'WGL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB', 'WGL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB',
'WGL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB', 'WGL_FRONT_LEFT_ARB',
'WGL_FRONT_RIGHT_ARB', 'WGL_BACK_LEFT_ARB', 'WGL_BACK_RIGHT_ARB',
'WGL_AUX0_ARB', 'WGL_AUX1_ARB', 'WGL_AUX2_ARB', 'WGL_AUX3_ARB',
'WGL_AUX4_ARB', 'WGL_AUX5_ARB', 'WGL_AUX6_ARB', 'WGL_AUX7_ARB',
'WGL_AUX8_ARB', 'WGL_AUX9_ARB', 'WGL_TYPE_RGBA_FLOAT_ARB',
'ERROR_INVALID_PIXEL_TYPE_EXT', 'WGL_NUMBER_PIXEL_FORMATS_EXT',
'WGL_DRAW_TO_WINDOW_EXT', 'WGL_DRAW_TO_BITMAP_EXT', 'WGL_ACCELERATION_EXT',
'WGL_NEED_PALETTE_EXT', 'WGL_NEED_SYSTEM_PALETTE_EXT',
'WGL_SWAP_LAYER_BUFFERS_EXT', 'WGL_SWAP_METHOD_EXT',
'WGL_NUMBER_OVERLAYS_EXT', 'WGL_NUMBER_UNDERLAYS_EXT', 'WGL_TRANSPARENT_EXT',
'WGL_TRANSPARENT_VALUE_EXT', 'WGL_SHARE_DEPTH_EXT', 'WGL_SHARE_STENCIL_EXT',
'WGL_SHARE_ACCUM_EXT', 'WGL_SUPPORT_GDI_EXT', 'WGL_SUPPORT_OPENGL_EXT',
'WGL_DOUBLE_BUFFER_EXT', 'WGL_STEREO_EXT', 'WGL_PIXEL_TYPE_EXT',
'WGL_COLOR_BITS_EXT', 'WGL_RED_BITS_EXT', 'WGL_RED_SHIFT_EXT',
'WGL_GREEN_BITS_EXT', 'WGL_GREEN_SHIFT_EXT', 'WGL_BLUE_BITS_EXT',
'WGL_BLUE_SHIFT_EXT', 'WGL_ALPHA_BITS_EXT', 'WGL_ALPHA_SHIFT_EXT',
'WGL_ACCUM_BITS_EXT', 'WGL_ACCUM_RED_BITS_EXT', 'WGL_ACCUM_GREEN_BITS_EXT',
'WGL_ACCUM_BLUE_BITS_EXT', 'WGL_ACCUM_ALPHA_BITS_EXT', 'WGL_DEPTH_BITS_EXT',
'WGL_STENCIL_BITS_EXT', 'WGL_AUX_BUFFERS_EXT', 'WGL_NO_ACCELERATION_EXT',
'WGL_GENERIC_ACCELERATION_EXT', 'WGL_FULL_ACCELERATION_EXT',
'WGL_SWAP_EXCHANGE_EXT', 'WGL_SWAP_COPY_EXT', 'WGL_SWAP_UNDEFINED_EXT',
'WGL_TYPE_RGBA_EXT', 'WGL_TYPE_COLORINDEX_EXT', 'WGL_DRAW_TO_PBUFFER_EXT',
'WGL_MAX_PBUFFER_PIXELS_EXT', 'WGL_MAX_PBUFFER_WIDTH_EXT',
'WGL_MAX_PBUFFER_HEIGHT_EXT', 'WGL_OPTIMAL_PBUFFER_WIDTH_EXT',
'WGL_OPTIMAL_PBUFFER_HEIGHT_EXT', 'WGL_PBUFFER_LARGEST_EXT',
'WGL_PBUFFER_WIDTH_EXT', 'WGL_PBUFFER_HEIGHT_EXT', 'WGL_DEPTH_FLOAT_EXT',
'WGL_SAMPLE_BUFFERS_3DFX', 'WGL_SAMPLES_3DFX', 'WGL_SAMPLE_BUFFERS_EXT',
'WGL_SAMPLES_EXT', 'WGL_DIGITAL_VIDEO_CURSOR_ALPHA_FRAMEBUFFER_I3D',
'WGL_DIGITAL_VIDEO_CURSOR_ALPHA_VALUE_I3D',
'WGL_DIGITAL_VIDEO_CURSOR_INCLUDED_I3D',
'WGL_DIGITAL_VIDEO_GAMMA_CORRECTED_I3D', 'WGL_GAMMA_TABLE_SIZE_I3D',
'WGL_GAMMA_EXCLUDE_DESKTOP_I3D', 'WGL_GENLOCK_SOURCE_MULTIVIEW_I3D',
'WGL_GENLOCK_SOURCE_EXTENAL_SYNC_I3D', 'WGL_GENLOCK_SOURCE_EXTENAL_FIELD_I3D',
'WGL_GENLOCK_SOURCE_EXTENAL_TTL_I3D', 'WGL_GENLOCK_SOURCE_DIGITAL_SYNC_I3D',
'WGL_GENLOCK_SOURCE_DIGITAL_FIELD_I3D', 'WGL_GENLOCK_SOURCE_EDGE_FALLING_I3D',
'WGL_GENLOCK_SOURCE_EDGE_RISING_I3D', 'WGL_GENLOCK_SOURCE_EDGE_BOTH_I3D',
'WGL_IMAGE_BUFFER_MIN_ACCESS_I3D', 'WGL_IMAGE_BUFFER_LOCK_I3D',
'WGL_BIND_TO_TEXTURE_DEPTH_NV', 'WGL_BIND_TO_TEXTURE_RECTANGLE_DEPTH_NV',
'WGL_DEPTH_TEXTURE_FORMAT_NV', 'WGL_TEXTURE_DEPTH_COMPONENT_NV',
'WGL_DEPTH_COMPONENT_NV', 'WGL_BIND_TO_TEXTURE_RECTANGLE_RGB_NV',
'WGL_BIND_TO_TEXTURE_RECTANGLE_RGBA_NV', 'WGL_TEXTURE_RECTANGLE_NV',
'WGL_TYPE_RGBA_FLOAT_ATI', 'WGL_RGBA_FLOAT_MODE_ATI',
'WGL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI', 'WGL_FLOAT_COMPONENTS_NV',
'WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_R_NV',
'WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RG_NV',
'WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGB_NV',
'WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGBA_NV', 'WGL_TEXTURE_FLOAT_R_NV',
'WGL_TEXTURE_FLOAT_RG_NV', 'WGL_TEXTURE_FLOAT_RGB_NV',
'WGL_TEXTURE_FLOAT_RGBA_NV', 'WGL_ERROR_INCOMPATIBLE_AFFINITY_MASKS_NV',
'WGL_ERROR_MISSING_AFFINITY_MASK_NV', 'HPBUFFERARB', 'HPBUFFEREXT', 'HGPUNV',
'GPU_DEVICE', 'PGPU_DEVICE', 'WGL_ARB_buffer_region',
'wglCreateBufferRegionARB', 'wglDeleteBufferRegionARB',
'wglSaveBufferRegionARB', 'wglRestoreBufferRegionARB',
'PFNWGLCREATEBUFFERREGIONARBPROC', 'PFNWGLDELETEBUFFERREGIONARBPROC',
'PFNWGLSAVEBUFFERREGIONARBPROC', 'PFNWGLRESTOREBUFFERREGIONARBPROC',
'WGL_ARB_multisample', 'WGL_ARB_extensions_string',
'wglGetExtensionsStringARB', 'PFNWGLGETEXTENSIONSSTRINGARBPROC',
'WGL_ARB_pixel_format', 'wglGetPixelFormatAttribivARB',
'wglGetPixelFormatAttribfvARB', 'wglChoosePixelFormatARB',
'PFNWGLGETPIXELFORMATATTRIBIVARBPROC', 'PFNWGLGETPIXELFORMATATTRIBFVARBPROC',
'PFNWGLCHOOSEPIXELFORMATARBPROC', 'WGL_ARB_make_current_read',
'wglMakeContextCurrentARB', 'wglGetCurrentReadDCARB',
'PFNWGLMAKECONTEXTCURRENTARBPROC', 'PFNWGLGETCURRENTREADDCARBPROC',
'WGL_ARB_pbuffer', 'wglCreatePbufferARB', 'wglGetPbufferDCARB',
'wglReleasePbufferDCARB', 'wglDestroyPbufferARB', 'wglQueryPbufferARB',
'PFNWGLCREATEPBUFFERARBPROC', 'PFNWGLGETPBUFFERDCARBPROC',
'PFNWGLRELEASEPBUFFERDCARBPROC', 'PFNWGLDESTROYPBUFFERARBPROC',
'PFNWGLQUERYPBUFFERARBPROC', 'WGL_ARB_render_texture', 'wglBindTexImageARB',
'wglReleaseTexImageARB', 'wglSetPbufferAttribARB',
'PFNWGLBINDTEXIMAGEARBPROC', 'PFNWGLRELEASETEXIMAGEARBPROC',
'PFNWGLSETPBUFFERATTRIBARBPROC', 'WGL_ARB_pixel_format_float',
'WGL_EXT_display_color_table', 'wglCreateDisplayColorTableEXT',
'wglLoadDisplayColorTableEXT', 'wglBindDisplayColorTableEXT',
'wglDestroyDisplayColorTableEXT', 'PFNWGLCREATEDISPLAYCOLORTABLEEXTPROC',
'PFNWGLLOADDISPLAYCOLORTABLEEXTPROC', 'PFNWGLBINDDISPLAYCOLORTABLEEXTPROC',
'PFNWGLDESTROYDISPLAYCOLORTABLEEXTPROC', 'WGL_EXT_extensions_string',
'wglGetExtensionsStringEXT', 'PFNWGLGETEXTENSIONSSTRINGEXTPROC',
'WGL_EXT_make_current_read', 'wglMakeContextCurrentEXT',
'wglGetCurrentReadDCEXT', 'PFNWGLMAKECONTEXTCURRENTEXTPROC',
'PFNWGLGETCURRENTREADDCEXTPROC', 'WGL_EXT_pbuffer', 'wglCreatePbufferEXT',
'wglGetPbufferDCEXT', 'wglReleasePbufferDCEXT', 'wglDestroyPbufferEXT',
'wglQueryPbufferEXT', 'PFNWGLCREATEPBUFFEREXTPROC',
'PFNWGLGETPBUFFERDCEXTPROC', 'PFNWGLRELEASEPBUFFERDCEXTPROC',
'PFNWGLDESTROYPBUFFEREXTPROC', 'PFNWGLQUERYPBUFFEREXTPROC',
'WGL_EXT_pixel_format', 'wglGetPixelFormatAttribivEXT',
'wglGetPixelFormatAttribfvEXT', 'wglChoosePixelFormatEXT',
'PFNWGLGETPIXELFORMATATTRIBIVEXTPROC', 'PFNWGLGETPIXELFORMATATTRIBFVEXTPROC',
'PFNWGLCHOOSEPIXELFORMATEXTPROC', 'WGL_EXT_swap_control',
'wglSwapIntervalEXT', 'wglGetSwapIntervalEXT', 'PFNWGLSWAPINTERVALEXTPROC',
'PFNWGLGETSWAPINTERVALEXTPROC', 'WGL_EXT_depth_float',
'WGL_NV_vertex_array_range', 'wglAllocateMemoryNV', 'wglFreeMemoryNV',
'PFNWGLALLOCATEMEMORYNVPROC', 'PFNWGLFREEMEMORYNVPROC',
'WGL_3DFX_multisample', 'WGL_EXT_multisample', 'WGL_OML_sync_control',
'wglGetSyncValuesOML', 'wglGetMscRateOML', 'wglSwapBuffersMscOML',
'wglSwapLayerBuffersMscOML', 'wglWaitForMscOML', 'wglWaitForSbcOML',
'PFNWGLGETSYNCVALUESOMLPROC', 'PFNWGLGETMSCRATEOMLPROC',
'PFNWGLSWAPBUFFERSMSCOMLPROC', 'PFNWGLSWAPLAYERBUFFERSMSCOMLPROC',
'PFNWGLWAITFORMSCOMLPROC', 'PFNWGLWAITFORSBCOMLPROC',
'WGL_I3D_digital_video_control', 'wglGetDigitalVideoParametersI3D',
'wglSetDigitalVideoParametersI3D', 'PFNWGLGETDIGITALVIDEOPARAMETERSI3DPROC',
'PFNWGLSETDIGITALVIDEOPARAMETERSI3DPROC', 'WGL_I3D_gamma',
'wglGetGammaTableParametersI3D', 'wglSetGammaTableParametersI3D',
'wglGetGammaTableI3D', 'wglSetGammaTableI3D',
'PFNWGLGETGAMMATABLEPARAMETERSI3DPROC',
'PFNWGLSETGAMMATABLEPARAMETERSI3DPROC', 'PFNWGLGETGAMMATABLEI3DPROC',
'PFNWGLSETGAMMATABLEI3DPROC', 'WGL_I3D_genlock', 'wglEnableGenlockI3D',
'wglDisableGenlockI3D', 'wglIsEnabledGenlockI3D', 'wglGenlockSourceI3D',
'wglGetGenlockSourceI3D', 'wglGenlockSourceEdgeI3D',
'wglGetGenlockSourceEdgeI3D', 'wglGenlockSampleRateI3D',
'wglGetGenlockSampleRateI3D', 'wglGenlockSourceDelayI3D',
'wglGetGenlockSourceDelayI3D', 'wglQueryGenlockMaxSourceDelayI3D',
'PFNWGLENABLEGENLOCKI3DPROC', 'PFNWGLDISABLEGENLOCKI3DPROC',
'PFNWGLISENABLEDGENLOCKI3DPROC', 'PFNWGLGENLOCKSOURCEI3DPROC',
'PFNWGLGETGENLOCKSOURCEI3DPROC', 'PFNWGLGENLOCKSOURCEEDGEI3DPROC',
'PFNWGLGETGENLOCKSOURCEEDGEI3DPROC', 'PFNWGLGENLOCKSAMPLERATEI3DPROC',
'PFNWGLGETGENLOCKSAMPLERATEI3DPROC', 'PFNWGLGENLOCKSOURCEDELAYI3DPROC',
'PFNWGLGETGENLOCKSOURCEDELAYI3DPROC',
'PFNWGLQUERYGENLOCKMAXSOURCEDELAYI3DPROC', 'WGL_I3D_image_buffer',
'wglCreateImageBufferI3D', 'wglDestroyImageBufferI3D',
'wglAssociateImageBufferEventsI3D', 'wglReleaseImageBufferEventsI3D',
'PFNWGLCREATEIMAGEBUFFERI3DPROC', 'PFNWGLDESTROYIMAGEBUFFERI3DPROC',
'PFNWGLASSOCIATEIMAGEBUFFEREVENTSI3DPROC',
'PFNWGLRELEASEIMAGEBUFFEREVENTSI3DPROC', 'WGL_I3D_swap_frame_lock',
'wglEnableFrameLockI3D', 'wglDisableFrameLockI3D', 'wglIsEnabledFrameLockI3D',
'wglQueryFrameLockMasterI3D', 'PFNWGLENABLEFRAMELOCKI3DPROC',
'PFNWGLDISABLEFRAMELOCKI3DPROC', 'PFNWGLISENABLEDFRAMELOCKI3DPROC',
'PFNWGLQUERYFRAMELOCKMASTERI3DPROC', 'WGL_I3D_swap_frame_usage',
'wglGetFrameUsageI3D', 'wglBeginFrameTrackingI3D', 'wglEndFrameTrackingI3D',
'wglQueryFrameTrackingI3D', 'PFNWGLGETFRAMEUSAGEI3DPROC',
'PFNWGLBEGINFRAMETRACKINGI3DPROC', 'PFNWGLENDFRAMETRACKINGI3DPROC',
'PFNWGLQUERYFRAMETRACKINGI3DPROC', 'WGL_ATI_pixel_format_float',
'WGL_NV_render_depth_texture', 'WGL_NV_render_texture_rectangle',
'WGL_NV_float_buffer', 'WGL_NV_swap_group', 'wglJoinSwapGroupNV',
'wglBindSwapBarrierNV', 'wglQuerySwapGroupNV', 'wglQueryMaxSwapGroupsNV',
'wglQueryFrameCountNV', 'wglResetFrameCountNV', 'PFNWGLJOINSWAPGROUPNVPROC',
'PFNWGLBINDSWAPBARRIERNVPROC', 'PFNWGLQUERYSWAPGROUPNVPROC',
'PFNWGLQUERYMAXSWAPGROUPSNVPROC', 'PFNWGLQUERYFRAMECOUNTNVPROC',
'PFNWGLRESETFRAMECOUNTNVPROC', 'WGL_NV_gpu_affinity', 'wglEnumGpusNV',
'wglEnumGpuDevicesNV', 'wglCreateAffinityDCNV', 'wglEnumGpusFromAffinityDCNV',
'wglDeleteDCNV']
# END GENERATED CONTENT (do not edit above this line)


########NEW FILE########
__FILENAME__ = wgl_info
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Cached information about version and extensions of current WGL
implementation.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: glx_info.py 615 2007-02-07 13:17:05Z Alex.Holkner $'

from ctypes import *
import warnings

from pyglet.gl.lib import MissingFunctionException
from pyglet.gl.gl import *
from pyglet.gl import gl_info
from pyglet.gl.wgl import *
from pyglet.gl.wglext_arb import *

class WGLInfoException(Exception):
    pass

class WGLInfo(object):
    def get_extensions(self):
        if not gl_info.have_context():
            warnings.warn("Can't query WGL until a context is created.")
            return []

        try:
            return wglGetExtensionsStringEXT().split()
        except MissingFunctionException:
            return cast(glGetString(GL_EXTENSIONS), c_char_p).value.split()

    def have_extension(self, extension):
        return extension in self.get_extensions()

_wgl_info = WGLInfo()

get_extensions = _wgl_info.get_extensions
have_extension = _wgl_info.have_extension

########NEW FILE########
__FILENAME__ = allocation
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
# $Id:$

'''Memory allocation algorithm for vertex arrays and buffers.

The region allocator is used to allocate vertex indices within a vertex
domain's  multiple buffers.  ("Buffer" refers to any abstract buffer presented
by `pyglet.graphics.vertexbuffer`.

The allocator will at times request more space from the buffers. The current
policy is to double the buffer size when there is not enough room to fulfil an
allocation.  The buffer is never resized smaller.

The allocator maintains references to free space only; it is the caller's
responsibility to maintain the allocated regions.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

# Common cases:
# -regions will be the same size (instances of same object, e.g. sprites)
# -regions will not usually be resized (only exception is text)
# -alignment of 4 vertices (glyphs, sprites, images, ...)
#
# Optimise for:
# -keeping regions adjacent, reduce the number of entries in glMultiDrawArrays
# -finding large blocks of allocated regions quickly (for drawing)
# -finding block of unallocated space is the _uncommon_ case!
#
# Decisions:
# -don't over-allocate regions to any alignment -- this would require more
#  work in finding the allocated spaces (for drawing) and would result in
#  more entries in glMultiDrawArrays
# -don't move blocks when they truncate themselves.  try not to allocate the
#  space they freed too soon (they will likely need grow back into it later,
#  and growing will usually require a reallocation).
# -allocator does not track individual allocated regions.  Trusts caller
#  to provide accurate (start, size) tuple, which completely describes
#  a region from the allocator's point of view.
# -this means that compacting is probably not feasible, or would be hideously
#  expensive

class AllocatorMemoryException(Exception):
    '''The buffer is not large enough to fulfil an allocation.

    Raised by `Allocator` methods when the operation failed due to lack of
    buffer space.  The buffer should be increased to at least
    requested_capacity and then the operation retried (guaranteed to
    pass second time).
    '''

    def __init__(self, requested_capacity):
        self.requested_capacity = requested_capacity

class Allocator(object):
    '''Buffer space allocation implementation.'''
    def __init__(self, capacity):
        '''Create an allocator for a buffer of the specified capacity.

        :Parameters:
            `capacity` : int
                Maximum size of the buffer.

        '''
        self.capacity = capacity

        # Allocated blocks.  Start index and size in parallel lists.
        #
        # # = allocated, - = free
        #
        #  0  3 5        15   20  24                    40
        # |###--##########-----####----------------------|
        #
        # starts = [0, 5, 20]
        # sizes = [3, 10, 4]
        #
        # To calculate free blocks:
        # for i in range(0, len(starts)):
        #   free_start[i] = starts[i] + sizes[i]
        #   free_size[i] =  starts[i+1] - free_start[i]
        # free_size[i+1] = self.capacity - free_start[-1]

        self.starts = []
        self.sizes = []

    def set_capacity(self, size):
        '''Resize the maximum buffer size.

        The capacity cannot be reduced.

        :Parameters:
            `size` : int
                New maximum size of the buffer.

        '''
        assert size > self.capacity
        self.capacity = size

    def alloc(self, size):
        '''Allocate memory in the buffer.

        Raises `AllocatorMemoryException` if the allocation cannot be
        fulfilled.

        :Parameters:
            `size` : int
                Size of region to allocate.

        :rtype: int
        :return: Starting index of the allocated region.
        '''
        assert size > 0

        # return start
        # or raise AllocatorMemoryException

        if not self.starts:
            if size <= self.capacity:
                self.starts.append(0)
                self.sizes.append(size)
                return 0
            else:
                raise AllocatorMemoryException(size)

        # Allocate in a free space
        free_start = self.starts[0] + self.sizes[0]
        for i, (alloc_start, alloc_size) in \
                enumerate(zip(self.starts[1:], self.sizes[1:])):
            # Danger!
            # i is actually index - 1 because of slicing above...
            # starts[i]   points to the block before this free space
            # starts[i+1] points to the block after this free space, and is
            #             always valid.
            free_size = alloc_start - free_start
            if free_size == size:
                # Merge previous block with this one (removing this free space)
                self.sizes[i] += free_size + alloc_size
                del self.starts[i+1]
                del self.sizes[i+1]
                return free_start
            elif free_size > size:
                # Increase size of previous block to intrude into this free
                # space.
                self.sizes[i] += size
                return free_start
            free_start = alloc_start + alloc_size

        # Allocate at end of capacity
        free_size = self.capacity - free_start
        if free_size >= size:
            self.sizes[-1] += size
            return free_start

        raise AllocatorMemoryException(self.capacity + size - free_size)

    def realloc(self, start, size, new_size):
        '''Reallocate a region of the buffer.

        This is more efficient than separate `dealloc` and `alloc` calls, as
        the region can often be resized in-place.

        Raises `AllocatorMemoryException` if the allocation cannot be
        fulfilled.

        :Parameters:
            `start` : int
                Current starting index of the region.
            `size` : int
                Current size of the region.
            `new_size` : int
                New size of the region.

        '''
        assert size > 0 and new_size > 0

        # return start
        # or raise AllocatorMemoryException

        # Truncation is the same as deallocating the tail cruft
        if new_size < size:
            self.dealloc(start + new_size, size - new_size)
            return start

        # Find which block it lives in
        for i, (alloc_start, alloc_size) in \
                enumerate(zip(*(self.starts, self.sizes))):
            p = start - alloc_start
            if p >= 0 and size <= alloc_size - p:
                break
        if not (p >= 0 and size <= alloc_size - p):
            print zip(self.starts, self.sizes)
            print start, size, new_size
            print p, alloc_start, alloc_size
        assert p >= 0 and size <= alloc_size - p, 'Region not allocated'

        if size == alloc_size - p:
            # Region is at end of block.  Find how much free space is after
            # it.
            is_final_block = i == len(self.starts) - 1
            if not is_final_block:
                free_size = self.starts[i + 1] - (start + size)
            else:
                free_size = self.capacity - (start + size)

            # TODO If region is an entire block being an island in free space,
            # can possibly extend in both directions.

            if free_size == new_size - size and not is_final_block:
                # Merge block with next (region is expanded in place to
                # exactly fill the free space)
                self.sizes[i] += free_size + self.sizes[i + 1]
                del self.starts[i + 1]
                del self.sizes[i + 1]
                return start
            elif free_size > new_size - size:
                # Expand region in place
                self.sizes[i] += new_size - size
                return start

        # The block must be repositioned.  Dealloc then alloc.

        # But don't do this!  If alloc fails, we've already silently dealloc'd
        # the original block.
        #   self.dealloc(start, size)
        #   return self.alloc(new_size)

        # It must be alloc'd first.  We're not missing an optimisation
        # here, because if freeing the block would've allowed for the block to
        # be placed in the resulting free space, one of the above in-place
        # checks would've found it.
        result = self.alloc(new_size)
        self.dealloc(start, size)
        return result

    def dealloc(self, start, size):
        '''Free a region of the buffer.

        :Parameters:
            `start` : int
                Starting index of the region.
            `size` : int
                Size of the region.

        '''
        assert size > 0
        assert self.starts

        # Find which block needs to be split
        for i, (alloc_start, alloc_size) in \
                enumerate(zip(*(self.starts, self.sizes))):
            p = start - alloc_start
            if p >= 0 and size <= alloc_size - p:
                break

        # Assert we left via the break
        assert p >= 0 and size <= alloc_size - p, 'Region not allocated'

        if p == 0 and size == alloc_size:
            # Remove entire block
            del self.starts[i]
            del self.sizes[i]
        elif p == 0:
            # Truncate beginning of block
            self.starts[i] += size
            self.sizes[i] -= size
        elif size == alloc_size - p:
            # Truncate end of block
            self.sizes[i] -= size
        else:
            # Reduce size of left side, insert block at right side
            #   $ = dealloc'd block, # = alloc'd region from same block
            #
            #   <------8------>
            #   <-5-><-6-><-7->
            #   1    2    3    4
            #   #####$$$$$#####
            #
            #   1 = alloc_start
            #   2 = start
            #   3 = start + size
            #   4 = alloc_start + alloc_size
            #   5 = start - alloc_start = p
            #   6 = size
            #   7 = {8} - ({5} + {6}) = alloc_size - (p + size)
            #   8 = alloc_size
            #
            self.sizes[i] = p
            self.starts.insert(i + 1, start + size)
            self.sizes.insert(i + 1, alloc_size - (p + size))

    def get_allocated_regions(self):
        '''Get a list of (aggregate) allocated regions.

        The result of this method is ``(starts, sizes)``, where ``starts`` is
        a list of starting indices of the regions and ``sizes`` their
        corresponding lengths.

        :rtype: (list, list)
        '''
        # return (starts, sizes); len(starts) == len(sizes)
        return (self.starts, self.sizes)

    def get_fragmented_free_size(self):
        '''Returns the amount of space unused, not including the final
        free block.

        :rtype: int
        '''
        if not self.starts:
            return 0

        # Variation of search for free block.
        total_free = 0
        free_start = self.starts[0] + self.sizes[0]
        for i, (alloc_start, alloc_size) in \
                enumerate(zip(self.starts[1:], self.sizes[1:])):
            total_free += alloc_start - free_start
            free_start = alloc_start + alloc_size

        return total_free

    def get_free_size(self):
        '''Return the amount of space unused.

        :rtype: int
        '''
        if not self.starts:
            return self.capacity

        free_end = self.capacity - (self.starts[-1] + self.sizes[-1])
        return self.get_fragmented_free_size() + free_end

    def get_usage(self):
        '''Return fraction of capacity currently allocated.

        :rtype: float
        '''
        return 1. - self.get_free_size() / float(self.capacity)

    def get_fragmentation(self):
        '''Return fraction of free space that is not expandable.

        :rtype: float
        '''
        free_size = self.get_free_size()
        if free_size == 0:
            return 0.
        return self.get_fragmented_free_size() / float(self.get_free_size())

    def _is_empty(self):
        return not self.starts

    def __str__(self):
        return 'allocs=' + repr(zip(self.starts, self.sizes))

    def __repr__(self):
        return '<%s %s>' % (self.__class__.__name__, str(self))

########NEW FILE########
__FILENAME__ = vertexattribute
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
# $Id:$

'''Access byte arrays as arrays of vertex attributes.

Use `create_attribute` to create an attribute accessor given a simple format
string.  Alternatively, the classes may be constructed directly.

Attribute format strings
========================

An attribute format string specifies the format of a vertex attribute.  Format
strings are accepted by the `create_attribute` function as well as most
methods in the `pyglet.graphics` module.

Format strings have the following (BNF) syntax::

    attribute ::= ( name | index 'g' 'n'? ) count type

``name`` describes the vertex attribute, and is one of the following
constants for the predefined attributes:

``c``
    Vertex color
``e``
    Edge flag
``f``
    Fog coordinate
``n``
    Normal vector
``s``
    Secondary color
``t``
    Texture coordinate
``v``
    Vertex coordinate

You can alternatively create a generic indexed vertex attribute by
specifying its index in decimal followed by the constant ``g``.  For
example, ``0g`` specifies the generic vertex attribute with index 0.
If the optional constant ``n`` is present after the ``g``, the
attribute is normalised to the range ``[0, 1]`` or ``[-1, 1]`` within
the range of the data type.

``count`` gives the number of data components in the attribute.  For
example, a 3D vertex position has a count of 3.  Some attributes
constrain the possible counts that can be used; for example, a normal
vector must have a count of 3.

``type`` gives the data type of each component of the attribute.  The
following types can be used:

``b``
    ``GLbyte``
``B``
    ``GLubyte``
``s``
    ``GLshort``
``S``
    ``GLushort``
``i``
    ``GLint``
``I``
    ``GLuint``
``f``
    ``GLfloat``
``d``
    ``GLdouble``

Some attributes constrain the possible data types; for example,
normal vectors must use one of the signed data types.  The use of
some data types, while not illegal, may have severe performance
concerns.  For example, the use of ``GLdouble`` is discouraged,
and colours should be specified with ``GLubyte``.

Whitespace is prohibited within the format string.

Some examples follow:

``v3f``
    3-float vertex position
``c4b``
    4-byte colour
``1eb``
    Edge flag
``0g3f``
    3-float generic vertex attribute 0
``1gn1i``
    Integer generic vertex attribute 1, normalized to [-1, 1]
``2gn4B``
    4-byte generic vertex attribute 2, normalized to [0, 1] (because
    the type is unsigned)

'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import ctypes
import re

from pyglet.gl import *
from pyglet.graphics import vertexbuffer

_c_types = {
    GL_BYTE: ctypes.c_byte,
    GL_UNSIGNED_BYTE: ctypes.c_ubyte,
    GL_SHORT: ctypes.c_short,
    GL_UNSIGNED_SHORT: ctypes.c_ushort,
    GL_INT: ctypes.c_int,
    GL_UNSIGNED_INT: ctypes.c_uint,
    GL_FLOAT: ctypes.c_float,
    GL_DOUBLE: ctypes.c_double,
}

_gl_types = {
    'b': GL_BYTE,
    'B': GL_UNSIGNED_BYTE,
    's': GL_SHORT,
    'S': GL_UNSIGNED_SHORT,
    'i': GL_INT,
    'I': GL_UNSIGNED_INT,
    'f': GL_FLOAT,
    'd': GL_DOUBLE,
}

_attribute_format_re = re.compile(r'''
    (?P<name>
       [cefnstv] |
       (?P<generic_index>[0-9]+) g
       (?P<generic_normalized>n?))
    (?P<count>[1234])
    (?P<type>[bBsSiIfd])
''', re.VERBOSE)

_attribute_cache = {}

def _align(v, align):
    return ((v - 1) & ~(align - 1)) + align

def interleave_attributes(attributes):
    '''Interleave attribute offsets.

    Adjusts the offsets and strides of the given attributes so that
    they are interleaved.  Alignment constraints are respected.

    :Parameters:
        `attributes` : sequence of `AbstractAttribute`
            Attributes to interleave in-place.

    '''
    stride = 0
    max_size = 0
    for attribute in attributes:
        stride = _align(stride, attribute.align)
        attribute.offset = stride
        stride += attribute.size
        max_size = max(max_size, attribute.size)
    stride = _align(stride, max_size)
    for attribute in attributes:
        attribute.stride = stride

def serialize_attributes(count, attributes):
    '''Serialize attribute offsets.

    Adjust the offsets of the given attributes so that they are
    packed serially against each other for `count` vertices.

    :Parameters:
        `count` : int
            Number of vertices.
        `attributes` : sequence of `AbstractAttribute`
            Attributes to serialize in-place.

    '''
    offset = 0
    for attribute in attributes:
        offset = _align(offset, attribute.align)
        attribute.offset = offset
        offset += count * attribute.stride

def create_attribute(format):
    '''Create a vertex attribute description from a format string.

    The initial stride and offset of the attribute will be 0.

    :Parameters:
        `format` : str
            Attribute format string.  See the module summary for details.

    :rtype: `AbstractAttribute`
    '''
    try:
        cls, args = _attribute_cache[format]
        return cls(*args)
    except KeyError:
        pass

    match = _attribute_format_re.match(format)
    assert match, 'Invalid attribute format %r' % format
    count = int(match.group('count'))
    gl_type = _gl_types[match.group('type')]
    generic_index = match.group('generic_index')
    if generic_index:
        normalized = match.group('generic_normalized')
        attr_class = GenericAttribute
        args = int(generic_index), normalized, count, gl_type
    else:
        name = match.group('name')
        attr_class = _attribute_classes[name]
        if attr_class._fixed_count:
            assert count == attr_class._fixed_count, \
                'Attributes named "%s" must have count of %d' % (
                    name, attr_class._fixed_count)
            args = (gl_type,)
        else:
            args = (count, gl_type)

    _attribute_cache[format] = attr_class, args
    return attr_class(*args)

class AbstractAttribute(object):
    '''Abstract accessor for an attribute in a mapped buffer.
    '''

    _fixed_count = None

    def __init__(self, count, gl_type):
        '''Create the attribute accessor.

        :Parameters:
            `count` : int
                Number of components in the attribute.
            `gl_type` : int
                OpenGL type enumerant; for example, ``GL_FLOAT``

        '''
        assert count in (1, 2, 3, 4), 'Component count out of range'
        self.gl_type = gl_type
        self.c_type = _c_types[gl_type]
        self.count = count
        self.align = ctypes.sizeof(self.c_type)
        self.size = count * self.align
        self.stride = self.size
        self.offset = 0

    def enable(self):
        '''Enable the attribute using ``glEnableClientState``.'''
        raise NotImplementedError('abstract')

    def set_pointer(self, offset):
        '''Setup this attribute to point to the currently bound buffer at
        the given offset.

        ``offset`` should be based on the currently bound buffer's ``ptr``
        member.

        :Parameters:
            `offset` : int
                Pointer offset to the currently bound buffer for this
                attribute.

        '''
        raise NotImplementedError('abstract')

    def get_region(self, buffer, start, count):
        '''Map a buffer region using this attribute as an accessor.

        The returned region can be modified as if the buffer was a contiguous
        array of this attribute (though it may actually be interleaved or
        otherwise non-contiguous).

        The returned region consists of a contiguous array of component
        data elements.  For example, if this attribute uses 3 floats per
        vertex, and the `count` parameter is 4, the number of floats mapped
        will be ``3 * 4 = 12``.

        :Parameters:
            `buffer` : `AbstractMappable`
                The buffer to map.
            `start` : int
                Offset of the first vertex to map.
            `count` : int
                Number of vertices to map

        :rtype: `AbstractBufferRegion`
        '''
        byte_start = self.stride * start
        byte_size = self.stride * count
        array_count = self.count * count
        if self.stride == self.size:
            # non-interleaved
            ptr_type = ctypes.POINTER(self.c_type * array_count)
            return buffer.get_region(byte_start, byte_size, ptr_type)
        else:
            # interleaved
            byte_start += self.offset
            byte_size -= self.offset
            elem_stride = self.stride // ctypes.sizeof(self.c_type)
            elem_offset = self.offset // ctypes.sizeof(self.c_type)
            ptr_type = ctypes.POINTER(
                self.c_type * (count * elem_stride - elem_offset))
            region = buffer.get_region(byte_start, byte_size, ptr_type)
            return vertexbuffer.IndirectArrayRegion(
                region, array_count, self.count, elem_stride)

    def set_region(self, buffer, start, count, data):
        '''Set the data over a region of the buffer.

        :Parameters:
            `buffer` : AbstractMappable`
                The buffer to modify.
            `start` : int
                Offset of the first vertex to set.
            `count` : int
                Number of vertices to set.
            `data` : sequence
                Sequence of data components.

        '''
        if self.stride == self.size:
            # non-interleaved
            byte_start = self.stride * start
            byte_size = self.stride * count
            array_count = self.count * count
            data = (self.c_type * array_count)(*data)
            buffer.set_data_region(data, byte_start, byte_size)
        else:
            # interleaved
            region = self.get_region(buffer, start, count)
            region[:] = data

class ColorAttribute(AbstractAttribute):
    '''Color vertex attribute.'''

    plural = 'colors'

    def __init__(self, count, gl_type):
        assert count in (3, 4), 'Color attributes must have count of 3 or 4'
        super(ColorAttribute, self).__init__(count, gl_type)

    def enable(self):
        glEnableClientState(GL_COLOR_ARRAY)

    def set_pointer(self, pointer):
        glColorPointer(self.count, self.gl_type, self.stride,
                       self.offset + pointer)

class EdgeFlagAttribute(AbstractAttribute):
    '''Edge flag attribute.'''

    plural = 'edge_flags'
    _fixed_count = 1

    def __init__(self, gl_type):
        assert gl_type in (GL_BYTE, GL_UNSIGNED_BYTE, GL_BOOL), \
            'Edge flag attribute must have boolean type'
        super(EdgeFlagAttribute, self).__init__(1, gl_type)

    def enable(self):
        glEnableClientState(GL_EDGE_FLAG_ARRAY)

    def set_pointer(self, pointer):
        glEdgeFlagPointer(self.stride, self.offset + pointer)

class FogCoordAttribute(AbstractAttribute):
    '''Fog coordinate attribute.'''

    plural = 'fog_coords'

    def __init__(self, count, gl_type):
        super(FogCoordAttribute, self).__init__(count, gl_type)

    def enable(self):
        glEnableClientState(GL_FOG_COORD_ARRAY)

    def set_pointer(self, pointer):
        glFogCoordPointer(self.count, self.gl_type, self.stride,
                          self.offset + pointer)

class NormalAttribute(AbstractAttribute):
    '''Normal vector attribute.'''

    plural = 'normals'
    _fixed_count = 3

    def __init__(self, gl_type):
        assert gl_type in (GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, GL_DOUBLE), \
            'Normal attribute must have signed type'
        super(NormalAttribute, self).__init__(3, gl_type)

    def enable(self):
        glEnableClientState(GL_NORMAL_ARRAY)

    def set_pointer(self, pointer):
        glNormalPointer(self.gl_type, self.stride, self.offset + pointer)

class SecondaryColorAttribute(AbstractAttribute):
    '''Secondary color attribute.'''

    plural = 'secondary_colors'
    _fixed_count = 3

    def __init__(self, gl_type):
        super(SecondaryColorAttribute, self).__init__(3, gl_type)

    def enable(self):
        glEnableClientState(GL_SECONDARY_COLOR_ARRAY)

    def set_pointer(self, pointer):
        glSecondaryColorPointer(3, self.gl_type, self.stride,
                                self.offset + pointer)

class TexCoordAttribute(AbstractAttribute):
    '''Texture coordinate attribute.'''

    plural = 'tex_coords'

    def __init__(self, count, gl_type):
        assert gl_type in (GL_SHORT, GL_INT, GL_INT, GL_FLOAT, GL_DOUBLE), \
            'Texture coord attribute must have non-byte signed type'
        super(TexCoordAttribute, self).__init__(count, gl_type)

    def enable(self):
        glEnableClientState(GL_TEXTURE_COORD_ARRAY)

    def set_pointer(self, pointer):
        glTexCoordPointer(self.count, self.gl_type, self.stride,
                       self.offset + pointer)

class VertexAttribute(AbstractAttribute):
    '''Vertex coordinate attribute.'''

    plural = 'vertices'

    def __init__(self, count, gl_type):
        assert count > 1, \
            'Vertex attribute must have count of 2, 3 or 4'
        assert gl_type in (GL_SHORT, GL_INT, GL_INT, GL_FLOAT, GL_DOUBLE), \
            'Vertex attribute must have signed type larger than byte'
        super(VertexAttribute, self).__init__(count, gl_type)

    def enable(self):
        glEnableClientState(GL_VERTEX_ARRAY)

    def set_pointer(self, pointer):
        glVertexPointer(self.count, self.gl_type, self.stride,
                        self.offset + pointer)

class GenericAttribute(AbstractAttribute):
    '''Generic vertex attribute, used by shader programs.'''

    def __init__(self, index, normalized, count, gl_type):
        self.normalized = bool(normalized)
        self.index = index
        super(GenericAttribute, self).__init__(count, gl_type)

    def enable(self):
        glEnableVertexAttribArray(self.index)

    def set_pointer(self, pointer):
        glVertexAttribPointer(self.index, self.count, self.gl_type,
                              self.normalized, self.stride,
                              self.offset + pointer)

_attribute_classes = {
    'c': ColorAttribute,
    'e': EdgeFlagAttribute,
    'f': FogCoordAttribute,
    'n': NormalAttribute,
    's': SecondaryColorAttribute,
    't': TexCoordAttribute,
    'v': VertexAttribute,
}

########NEW FILE########
__FILENAME__ = vertexbuffer
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
# $Id:$

'''Byte abstractions of Vertex Buffer Objects and vertex arrays.

Use `create_buffer` or `create_mappable_buffer` to create a Vertex Buffer
Object, or a vertex array if VBOs are not supported by the current context.

Buffers can optionally be created "mappable" (incorporating the
`AbstractMappable` mix-in).  In this case the buffer provides a ``get_region``
method which provides the most efficient path for updating partial data within
the buffer.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import ctypes
import sys

import pyglet
from pyglet.gl import *
from pyglet.gl import gl_info

_enable_vbo = pyglet.options['graphics_vbo']

# Enable workaround permanently if any VBO is created on a context that has
# this workaround.  (On systems with multiple contexts where one is
# unaffected, the workaround will be enabled unconditionally on all of the
# contexts anyway.  This is completely unlikely anyway).
_workaround_vbo_finish = False

def create_buffer(size,
                  target=GL_ARRAY_BUFFER,
                  usage=GL_DYNAMIC_DRAW,
                  vbo=True):
    '''Create a buffer of vertex data.

    :Parameters:
        `size` : int
            Size of the buffer, in bytes
        `target` : int
            OpenGL target buffer
        `usage` : int
            OpenGL usage constant
        `vbo` : bool
            True if a `VertexBufferObject` should be created if the driver
            supports it; otherwise only a `VertexArray` is created.

    :rtype: `AbstractBuffer`
    '''
    from pyglet import gl
    if (vbo and
        gl_info.have_version(1, 5) and
        _enable_vbo and
        not gl.current_context._workaround_vbo):
        return VertexBufferObject(size, target, usage)
    else:
        return VertexArray(size)

def create_mappable_buffer(size,
                           target=GL_ARRAY_BUFFER,
                           usage=GL_DYNAMIC_DRAW,
                           vbo=True):
    '''Create a mappable buffer of vertex data.

    :Parameters:
        `size` : int
            Size of the buffer, in bytes
        `target` : int
            OpenGL target buffer
        `usage` : int
            OpenGL usage constant
        `vbo` : bool
            True if a `VertexBufferObject` should be created if the driver
            supports it; otherwise only a `VertexArray` is created.

    :rtype: `AbstractBuffer` with `AbstractMappable`
    '''
    from pyglet import gl
    if (vbo and
        gl_info.have_version(1, 5) and
        _enable_vbo and
        not gl.current_context._workaround_vbo):
        return MappableVertexBufferObject(size, target, usage)
    else:
        return VertexArray(size)

class AbstractBuffer(object):
    '''Abstract buffer of byte data.

    :Ivariables:
        `size` : int
            Size of buffer, in bytes
        `ptr` : int
            Memory offset of the buffer, as used by the ``glVertexPointer``
            family of functions
        `target` : int
            OpenGL buffer target, for example ``GL_ARRAY_BUFFER``
        `usage` : int
            OpenGL buffer usage, for example ``GL_DYNAMIC_DRAW``

    '''

    ptr = 0
    size = 0

    def bind(self):
        '''Bind this buffer to its OpenGL target.'''
        raise NotImplementedError('abstract')

    def unbind(self):
        '''Reset the buffer's OpenGL target.'''
        raise NotImplementedError('abstract')

    def set_data(self, data):
        '''Set the entire contents of the buffer.

        :Parameters:
            `data` : sequence of int or ctypes pointer
                The byte array to set.

        '''
        raise NotImplementedError('abstract')

    def set_data_region(self, data, start, length):
        '''Set part of the buffer contents.

        :Parameters:
            `data` : sequence of int or ctypes pointer
                The byte array of data to set
            `start` : int
                Offset to start replacing data
            `length` : int
                Length of region to replace

        '''
        raise NotImplementedError('abstract')

    def map(self, invalidate=False):
        '''Map the entire buffer into system memory.

        The mapped region must be subsequently unmapped with `unmap` before
        performing any other operations on the buffer.

        :Parameters:
            `invalidate` : bool
                If True, the initial contents of the mapped block need not
                reflect the actual contents of the buffer.

        :rtype: ``POINTER(ctypes.c_ubyte)``
        :return: Pointer to the mapped block in memory
        '''
        raise NotImplementedError('abstract')

    def unmap(self):
        '''Unmap a previously mapped memory block.'''
        raise NotImplementedError('abstract')

    def resize(self, size):
        '''Resize the buffer to a new size.

        :Parameters:
            `size` : int
                New size of the buffer, in bytes

        '''

    def delete(self):
        '''Delete this buffer, reducing system resource usage.'''
        raise NotImplementedError('abstract')

class AbstractMappable(object):
    def get_region(self, start, size, ptr_type):
        '''Map a region of the buffer into a ctypes array of the desired
        type.  This region does not need to be unmapped, but will become
        invalid if the buffer is resized.

        Note that although a pointer type is required, an array is mapped.
        For example::

            get_region(0, ctypes.sizeof(c_int) * 20, ctypes.POINTER(c_int * 20))

        will map bytes 0 to 80 of the buffer to an array of 20 ints.

        Changes to the array may not be recognised until the region's
        `AbstractBufferRegion.invalidate` method is called.

        :Parameters:
            `start` : int
                Offset into the buffer to map from, in bytes
            `size` : int
                Size of the buffer region to map, in bytes
            `ptr_type` : ctypes pointer type
                Pointer type describing the array format to create

        :rtype: `AbstractBufferRegion`
        '''
        raise NotImplementedError('abstract')

class VertexArray(AbstractBuffer, AbstractMappable):
    '''A ctypes implementation of a vertex array.

    Many of the methods on this class are effectively no-op's, such as `bind`,
    `unbind`, `map`, `unmap` and `delete`; they exist in order to present
    a consistent interface with `VertexBufferObject`.

    This buffer type is also mappable, and so `get_region` can be used.
    '''

    def __init__(self, size):
        self.size = size

        self.array = (ctypes.c_byte * size)()
        self.ptr = ctypes.cast(self.array, ctypes.c_void_p).value

    def bind(self):
        pass

    def unbind(self):
        pass

    def set_data(self, data):
        ctypes.memmove(self.ptr, data, self.size)

    def set_data_region(self, data, start, length):
        ctypes.memmove(self.ptr + start, data, length)

    def map(self, invalidate=False):
        return self.array

    def unmap(self):
        pass

    def get_region(self, start, size, ptr_type):
        array = ctypes.cast(self.ptr + start, ptr_type).contents
        return VertexArrayRegion(array)

    def delete(self):
        pass

    def resize(self, size):
        array = (ctypes.c_byte * size)()
        ctypes.memmove(array, self.array, min(size, self.size))
        self.size = size
        self.array = array
        self.ptr = ctypes.cast(self.array, ctypes.c_void_p).value


class VertexBufferObject(AbstractBuffer):
    '''Lightweight representation of an OpenGL VBO.

    The data in the buffer is not replicated in any system memory (unless it
    is done so by the video driver).  While this can improve memory usage and
    possibly performance, updates to the buffer are relatively slow.

    This class does not implement `AbstractMappable`, and so has no
    ``get_region`` method.  See `MappableVertexBufferObject` for a VBO class
    that does implement ``get_region``.
    '''

    def __init__(self, size, target, usage):
        self.size = size
        self.target = target
        self.usage = usage
        self._context = pyglet.gl.current_context

        id = GLuint()
        glGenBuffers(1, id)
        self.id = id.value
        glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT)
        glBindBuffer(target, self.id)
        glBufferData(target, self.size, None, self.usage)
        glPopClientAttrib()

        global _workaround_vbo_finish
        if pyglet.gl.current_context._workaround_vbo_finish:
            _workaround_vbo_finish = True

    def bind(self):
        glBindBuffer(self.target, self.id)

    def unbind(self):
        glBindBuffer(self.target, 0)

    def set_data(self, data):
        glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT)
        glBindBuffer(self.target, self.id)
        glBufferData(self.target, self.size, data, self.usage)
        glPopClientAttrib()

    def set_data_region(self, data, start, length):
        glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT)
        glBindBuffer(self.target, self.id)
        glBufferSubData(self.target, start, length, data)
        glPopClientAttrib()

    def map(self, invalidate=False):
        glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT)
        glBindBuffer(self.target, self.id)
        if invalidate:
            glBufferData(self.target, self.size, None, self.usage)
        ptr = ctypes.cast(glMapBuffer(self.target, GL_WRITE_ONLY),
                          ctypes.POINTER(ctypes.c_byte * self.size)).contents
        glPopClientAttrib()
        return ptr

    def unmap(self):
        glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT)
        glUnmapBuffer(self.target)
        glPopClientAttrib()

    def __del__(self):
        try:
            if self.id is not None:
                self._context.delete_buffer(self.id)
        except:
            pass

    def delete(self):
        id = GLuint(self.id)
        glDeleteBuffers(1, id)
        self.id = None

    def resize(self, size):
        # Map, create a copy, then reinitialize.
        temp = (ctypes.c_byte * size)()

        glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT)
        glBindBuffer(self.target, self.id)
        data = glMapBuffer(self.target, GL_READ_ONLY)
        ctypes.memmove(temp, data, min(size, self.size))
        glUnmapBuffer(self.target)

        self.size = size
        glBufferData(self.target, self.size, temp, self.usage)
        glPopClientAttrib()

class MappableVertexBufferObject(VertexBufferObject, AbstractMappable):
    '''A VBO with system-memory backed store.

    Updates to the data via `set_data`, `set_data_region` and `map` will be
    held in local memory until `bind` is called.  The advantage is that fewer
    OpenGL calls are needed, increasing performance.

    There may also be less performance penalty for resizing this buffer.

    Updates to data via `map` are committed immediately.
    '''
    def __init__(self, size, target, usage):
        super(MappableVertexBufferObject, self).__init__(size, target, usage)
        self.data = (ctypes.c_byte * size)()
        self.data_ptr = ctypes.cast(self.data, ctypes.c_void_p).value
        self._dirty_min = sys.maxint
        self._dirty_max = 0

    def bind(self):
        # Commit pending data
        super(MappableVertexBufferObject, self).bind()
        size = self._dirty_max - self._dirty_min
        if size > 0:
            if size == self.size:
                glBufferData(self.target, self.size, self.data, self.usage)
            else:
                glBufferSubData(self.target, self._dirty_min, size,
                    self.data_ptr + self._dirty_min)
            self._dirty_min = sys.maxint
            self._dirty_max = 0

    def set_data(self, data):
        super(MappableVertexBufferObject, self).set_data(data)
        ctypes.memmove(self.data, data, self.size)
        self._dirty_min = 0
        self._dirty_max = self.size

    def set_data_region(self, data, start, length):
        ctypes.memmove(self.data_ptr + start, data, length)
        self._dirty_min = min(start, self._dirty_min)
        self._dirty_max = max(start + length, self._dirty_max)

    def map(self, invalidate=False):
        self._dirty_min = 0
        self._dirty_max = self.size
        return self.data

    def unmap(self):
        pass

    def get_region(self, start, size, ptr_type):
        array = ctypes.cast(self.data_ptr + start, ptr_type).contents
        return VertexBufferObjectRegion(self, start, start + size, array)

    def resize(self, size):
        data = (ctypes.c_byte * size)()
        ctypes.memmove(data, self.data, min(size, self.size))
        self.data = data
        self.data_ptr = ctypes.cast(self.data, ctypes.c_void_p).value

        self.size = size
        glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT)
        glBindBuffer(self.target, self.id)
        glBufferData(self.target, self.size, self.data, self.usage)
        glPopClientAttrib()

        self._dirty_min = sys.maxint
        self._dirty_max = 0

class AbstractBufferRegion(object):
    '''A mapped region of a buffer.

    Buffer regions are obtained using `AbstractMappable.get_region`.

    :Ivariables:
        `array` : ctypes array
            Array of data, of the type and count requested by ``get_region``.

    '''
    def invalidate(self):
        '''Mark this region as changed.

        The buffer may not be updated with the latest contents of the
        array until this method is called.  (However, it may not be updated
        until the next time the buffer is used, for efficiency).
        '''
        pass

class VertexBufferObjectRegion(AbstractBufferRegion):
    '''A mapped region of a VBO.'''
    def __init__(self, buffer, start, end, array):
        self.buffer = buffer
        self.start = start
        self.end = end
        self.array = array

    def invalidate(self):
        buffer = self.buffer
        buffer._dirty_min = min(buffer._dirty_min, self.start)
        buffer._dirty_max = max(buffer._dirty_max, self.end)

class VertexArrayRegion(AbstractBufferRegion):
    '''A mapped region of a vertex array.

    The `invalidate` method is a no-op but is provided in order to present
    a consistent interface with `VertexBufferObjectRegion`.
    '''
    def __init__(self, array):
        self.array = array

class IndirectArrayRegion(AbstractBufferRegion):
    '''A mapped region in which data elements are not necessarily contiguous.

    This region class is used to wrap buffer regions in which the data
    must be accessed with some stride.  For example, in an interleaved buffer
    this region can be used to access a single interleaved component as if the
    data was contiguous.
    '''
    def __init__(self, region, size, component_count, component_stride):
        '''Wrap a buffer region.

        Use the `component_count` and `component_stride` parameters to specify
        the data layout of the encapsulated region.  For example, if RGBA
        data is to be accessed as if it were packed RGB, ``component_count``
        would be set to 3 and ``component_stride`` to 4.  If the region
        contains 10 RGBA tuples, the ``size`` parameter is ``3 * 10 = 30``.

        :Parameters:
            `region` : `AbstractBufferRegion`
                The region with interleaved data
            `size` : int
                The number of elements that this region will provide access to.
            `component_count` : int
                The number of elements that are contiguous before some must
                be skipped.
            `component_stride` : int
                The number of elements of interleaved data separating
                the contiguous sections.

        '''
        self.region = region
        self.size = size
        self.count = component_count
        self.stride = component_stride
        self.array = self

    def __repr__(self):
        return 'IndirectArrayRegion(size=%d, count=%d, stride=%d)' % (
            self.size, self.count, self.stride)

    def __getitem__(self, index):
        count = self.count
        if not isinstance(index, slice):
            elem = index // count
            j = index % count
            return self.region.array[elem * self.stride + j]

        start = index.start or 0
        stop = index.stop
        step = index.step or 1
        if start < 0:
            start = self.size + start
        if stop is None:
            stop = self.size
        elif stop < 0:
            stop = self.size + stop

        assert step == 1 or step % count == 0, \
            'Step must be multiple of component count'

        data_start = (start // count) * self.stride + start % count
        data_stop = (stop // count) * self.stride + stop % count
        data_step = step * self.stride

        #  TODO stepped getitem is probably wrong, see setitem for correct.
        value_step = step * count

        # ctypes does not support stepped slicing, so do the work in a list
        # and copy it back.
        data = self.region.array[:]
        value = [0] * ((stop - start) // step)
        stride = self.stride
        for i in range(count):
            value[i::value_step] = \
                data[data_start + i:data_stop + i:data_step]
        return value

    def __setitem__(self, index, value):
        count = self.count
        if not isinstance(index, slice):
            elem = index // count
            j = index % count
            self.region.array[elem * self.stride + j] = value
            return

        start = index.start or 0
        stop = index.stop
        step = index.step or 1
        if start < 0:
            start = self.size + start
        if stop is None:
            stop = self.size
        elif stop < 0:
            stop = self.size + stop

        assert step == 1 or step % count == 0, \
            'Step must be multiple of component count'

        data_start = (start // count) * self.stride + start % count
        data_stop = (stop // count) * self.stride + stop % count

        # ctypes does not support stepped slicing, so do the work in a list
        # and copy it back.
        data = self.region.array[:]
        if step == 1:
            data_step = self.stride
            value_step = count
            for i in range(count):
                data[data_start + i:data_stop + i:data_step] = \
                    value[i::value_step]
        else:
            data_step = (step // count) * self.stride
            data[data_start:data_stop:data_step] = value
        self.region.array[:] = data

    def invalidate(self):
        self.region.invalidate()

########NEW FILE########
__FILENAME__ = vertexdomain
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
# $Id:$

'''Manage related vertex attributes within a single vertex domain.

A vertex "domain" consists of a set of attribute descriptions that together
describe the layout of one or more vertex buffers which are used together to
specify the vertices in a primitive.  Additionally, the domain manages the
buffers used to store the data and will resize them as necessary to accommodate
new vertices.

Domains can optionally be indexed, in which case they also manage a buffer
containing vertex indices.  This buffer is grown separately and has no size
relation to the attribute buffers.

Applications can create vertices (and optionally, indices) within a domain
with the `VertexDomain.create` method.  This returns a `VertexList`
representing the list of vertices created.  The vertex attribute data within
the group can be modified, and the changes will be made to the underlying
buffers automatically.

The entire domain can be efficiently drawn in one step with the
`VertexDomain.draw` method, assuming all the vertices comprise primitives of
the same OpenGL primitive mode.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import ctypes
import re

from pyglet.gl import *
from pyglet.graphics import allocation, vertexattribute, vertexbuffer

_usage_format_re = re.compile(r'''
    (?P<attribute>[^/]*)
    (/ (?P<usage> static|dynamic|stream|none))?
''', re.VERBOSE)

_gl_usages = {
    'static': GL_STATIC_DRAW,
    'dynamic': GL_DYNAMIC_DRAW,
    'stream': GL_STREAM_DRAW,
    'none': GL_STREAM_DRAW_ARB, # Force no VBO
}

def _nearest_pow2(v):
    # From http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
    # Credit: Sean Anderson
    v -= 1
    v |= v >> 1
    v |= v >> 2
    v |= v >> 4
    v |= v >> 8
    v |= v >> 16
    return v + 1

def create_attribute_usage(format):
    '''Create an attribute and usage pair from a format string.  The
    format string is as documented in `pyglet.graphics.vertexattribute`, with
    the addition of an optional usage component::

        usage ::= attribute ( '/' ('static' | 'dynamic' | 'stream' | 'none') )?

    If the usage is not given it defaults to 'dynamic'.  The usage corresponds
    to the OpenGL VBO usage hint, and for ``static`` also indicates a
    preference for interleaved arrays.  If ``none`` is specified a buffer
    object is not created, and vertex data is stored in system memory.

    Some examples:

    ``v3f/stream``
        3D vertex position using floats, for stream usage
    ``c4b/static``
        4-byte color attribute, for static usage

    :return: attribute, usage
    '''
    match = _usage_format_re.match(format)
    attribute_format = match.group('attribute')
    attribute = vertexattribute.create_attribute(attribute_format)
    usage = match.group('usage')
    if usage:
        vbo = not usage == 'none'
        usage = _gl_usages[usage]
    else:
        usage = GL_DYNAMIC_DRAW
        vbo = True

    return (attribute, usage, vbo)

def create_domain(*attribute_usage_formats):
    '''Create a vertex domain covering the given attribute usage formats.
    See documentation for `create_attribute_usage` and
    `pyglet.graphics.vertexattribute.create_attribute` for the grammar of
    these format strings.

    :rtype: `VertexDomain`
    '''
    attribute_usages = [create_attribute_usage(f) \
                        for f in attribute_usage_formats]
    return VertexDomain(attribute_usages)

def create_indexed_domain(*attribute_usage_formats):
    '''Create an indexed vertex domain covering the given attribute usage
    formats.  See documentation for `create_attribute_usage` and
    `pyglet.graphics.vertexattribute.create_attribute` for the grammar of
    these format strings.

    :rtype: `VertexDomain`
    '''
    attribute_usages = [create_attribute_usage(f) \
                        for f in attribute_usage_formats]
    return IndexedVertexDomain(attribute_usages)

class VertexDomain(object):
    '''Management of a set of vertex lists.

    Construction of a vertex domain is usually done with the `create_domain`
    function.
    '''
    _version = 0
    _initial_count = 16

    def __init__(self, attribute_usages):
        self.allocator = allocation.Allocator(self._initial_count)

        static_attributes = []
        attributes = []
        self.buffer_attributes = []   # list of (buffer, attributes)
        for attribute, usage, vbo in attribute_usages:
            if usage == GL_STATIC_DRAW:
                # Group attributes for interleaved buffer
                static_attributes.append(attribute)
                attributes.append(attribute)
            else:
                # Create non-interleaved buffer
                attributes.append(attribute)
                attribute.buffer = vertexbuffer.create_mappable_buffer(
                    attribute.stride * self.allocator.capacity,
                    usage=usage, vbo=vbo)
                attribute.buffer.element_size = attribute.stride
                attribute.buffer.attributes = (attribute,)
                self.buffer_attributes.append(
                    (attribute.buffer, (attribute,)))

        # Create buffer for interleaved data
        if static_attributes:
            vertexattribute.interleave_attributes(static_attributes)
            stride = static_attributes[0].stride
            buffer = vertexbuffer.create_mappable_buffer(
                stride * self.allocator.capacity, usage=GL_STATIC_DRAW)
            buffer.element_size = stride
            self.buffer_attributes.append(
                (buffer, static_attributes))

            for attribute in static_attributes:
                attribute.buffer = buffer

        # Create named attributes for each attribute
        self.attributes = attributes
        self.attribute_names = {}
        for attribute in attributes:
            if isinstance(attribute, vertexattribute.GenericAttribute):
                index = attribute.index
                if 'generic' not in self.attributes:
                    self.attribute_names['generic'] = {}
                assert index not in self.attribute_names['generic'], \
                    'More than one generic attribute with index %d' % index
                self.attribute_names['generic'][index] = attribute
            else:
                name = attribute.plural
                assert name not in self.attributes, \
                    'More than one "%s" attribute given' % name
                self.attribute_names[name] = attribute

    def __del__(self):
        # Break circular refs that Python GC seems to miss even when forced
        # collection.
        for attribute in self.attributes:
            del attribute.buffer

    def _safe_alloc(self, count):
        '''Allocate vertices, resizing the buffers if necessary.'''
        try:
            return self.allocator.alloc(count)
        except allocation.AllocatorMemoryException, e:
            capacity = _nearest_pow2(e.requested_capacity)
            self._version += 1
            for buffer, _ in self.buffer_attributes:
                buffer.resize(capacity * buffer.element_size)
            self.allocator.set_capacity(capacity)
            return self.allocator.alloc(count)

    def _safe_realloc(self, start, count, new_count):
        '''Reallocate vertices, resizing the buffers if necessary.'''
        try:
            return self.allocator.realloc(start, count, new_count)
        except allocation.AllocatorMemoryException, e:
            capacity = _nearest_pow2(e.requested_capacity)
            self._version += 1
            for buffer, _ in self.buffer_attributes:
                buffer.resize(capacity * buffer.element_size)
            self.allocator.set_capacity(capacity)
            return self.allocator.realloc(start, count, new_count)

    def create(self, count):
        '''Create a `VertexList` in this domain.

        :Parameters:
            `count` : int
                Number of vertices to create.

        :rtype: `VertexList`
        '''
        start = self._safe_alloc(count)
        return VertexList(self, start, count)

    def draw(self, mode, vertex_list=None):
        '''Draw vertices in the domain.

        If `vertex_list` is not specified, all vertices in the domain are
        drawn.  This is the most efficient way to render primitives.

        If `vertex_list` specifies a `VertexList`, only primitives in that
        list will be drawn.

        :Parameters:
            `mode` : int
                OpenGL drawing mode, e.g. ``GL_POINTS``, ``GL_LINES``, etc.
            `vertex_list` : `VertexList`
                Vertex list to draw, or ``None`` for all lists in this domain.

        '''
        glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT)
        for buffer, attributes in self.buffer_attributes:
            buffer.bind()
            for attribute in attributes:
                attribute.enable()
                attribute.set_pointer(attribute.buffer.ptr)
        if vertexbuffer._workaround_vbo_finish:
            glFinish()

        if vertex_list is not None:
            glDrawArrays(mode, vertex_list.start, vertex_list.count)
        else:
            starts, sizes = self.allocator.get_allocated_regions()
            primcount = len(starts)
            if primcount == 0:
                pass
            elif primcount == 1:
                # Common case
                glDrawArrays(mode, starts[0], sizes[0])
            elif gl_info.have_version(1, 4):
                starts = (GLint * primcount)(*starts)
                sizes = (GLsizei * primcount)(*sizes)
                glMultiDrawArrays(mode, starts, sizes, primcount)
            else:
                for start, size in zip(starts, sizes):
                    glDrawArrays(mode, start, size)

        for buffer, _ in self.buffer_attributes:
            buffer.unbind()
        glPopClientAttrib()

    def _is_empty(self):
        return not self.allocator.starts

    def __repr__(self):
        return '<%s@%x %s>' % (self.__class__.__name__, id(self),
                               self.allocator)

class VertexList(object):
    '''A list of vertices within a `VertexDomain`.  Use
    `VertexDomain.create` to construct this list.
    '''

    def __init__(self, domain, start, count):
        # TODO make private
        self.domain = domain
        self.start = start
        self.count = count

    def get_size(self):
        '''Get the number of vertices in the list.

        :rtype: int
        '''
        return self.count

    def get_domain(self):
        '''Get the domain this vertex list belongs to.

        :rtype: `VertexDomain`
        '''
        return self.domain

    def draw(self, mode):
        '''Draw this vertex list in the given OpenGL mode.

        :Parameters:
            `mode` : int
                OpenGL drawing mode, e.g. ``GL_POINTS``, ``GL_LINES``, etc.

        '''
        self.domain.draw(mode, self)

    def resize(self, count):
        '''Resize this group.

        :Parameters:
            `count` : int
                New number of vertices in the list.

        '''
        new_start = self.domain._safe_realloc(self.start, self.count, count)
        if new_start != self.start:
            # Copy contents to new location
            for attribute in self.domain.attributes:
                old = attribute.get_region(attribute.buffer,
                                           self.start, self.count)
                new = attribute.get_region(attribute.buffer,
                                           new_start, self.count)
                new.array[:] = old.array[:]
                new.invalidate()
        self.start = new_start
        self.count = count

        self._colors_cache_version = None
        self._fog_coords_cache_version = None
        self._edge_flags_cache_version = None
        self._normals_cache_version = None
        self._secondary_colors_cache_version = None
        self._tex_coords_cache_version = None
        self._vertices_cache_version = None

    def delete(self):
        '''Delete this group.'''
        self.domain.allocator.dealloc(self.start, self.count)

    def migrate(self, domain):
        '''Move this group from its current domain and add to the specified
        one.  Attributes on domains must match.  (In practice, used to change
        parent state of some vertices).

        :Parameters:
            `domain` : `VertexDomain`
                Domain to migrate this vertex list to.

        '''
        assert domain.attribute_names.keys() == \
            self.domain.attribute_names.keys(), 'Domain attributes must match.'

        new_start = domain._safe_alloc(self.count)
        for key, old_attribute in self.domain.attribute_names.items():
            old = old_attribute.get_region(old_attribute.buffer,
                                           self.start, self.count)
            new_attribute = domain.attribute_names[key]
            new = new_attribute.get_region(new_attribute.buffer,
                                           new_start, self.count)
            new.array[:] = old.array[:]
            new.invalidate()

        self.domain.allocator.dealloc(self.start, self.count)
        self.domain = domain
        self.start = new_start

        self._colors_cache_version = None
        self._fog_coords_cache_version = None
        self._edge_flags_cache_version = None
        self._normals_cache_version = None
        self._secondary_colors_cache_version = None
        self._tex_coords_cache_version = None
        self._vertices_cache_version = None

    def _set_attribute_data(self, i, data):
        attribute = self.domain.attributes[i]
        # TODO without region
        region = attribute.get_region(attribute.buffer, self.start, self.count)
        region.array[:] = data
        region.invalidate()

    # ---

    def _get_colors(self):
        if (self._colors_cache_version != self.domain._version):
            domain = self.domain
            attribute = domain.attribute_names['colors']
            self._colors_cache = attribute.get_region(
                attribute.buffer, self.start, self.count)
            self._colors_cache_version = domain._version

        region = self._colors_cache
        region.invalidate()
        return region.array

    def _set_colors(self, data):
        self._get_colors()[:] = data

    _colors_cache = None
    _colors_cache_version = None
    colors = property(_get_colors, _set_colors,
                      doc='''Array of color data.''')

    # ---

    def _get_fog_coords(self):
        if (self._fog_coords_cache_version != self.domain._version):
            domain = self.domain
            attribute = domain.attribute_names['fog_coords']
            self._fog_coords_cache = attribute.get_region(
                attribute.buffer, self.start, self.count)
            self._fog_coords_cache_version = domain._version

        region = self._fog_coords_cache
        region.invalidate()
        return region.array

    def _set_fog_coords(self, data):
        self._get_fog_coords()[:] = data

    _fog_coords_cache = None
    _fog_coords_cache_version = None
    fog_coords = property(_get_fog_coords, _set_fog_coords,
                          doc='''Array of fog coordinate data.''')

    # ---

    def _get_edge_flags(self):
        if (self._edge_flags_cache_version != self.domain._version):
            domain = self.domain
            attribute = domain.attribute_names['edge_flags']
            self._edge_flags_cache = attribute.get_region(
                attribute.buffer, self.start, self.count)
            self._edge_flags_cache_version = domain._version

        region = self._edge_flags_cache
        region.invalidate()
        return region.array

    def _set_edge_flags(self, data):
        self._get_edge_flags()[:] = data

    _edge_flags_cache = None
    _edge_flags_cache_version = None
    edge_flags = property(_get_edge_flags, _set_edge_flags,
                          doc='''Array of edge flag data.''')

    # ---

    def _get_normals(self):
        if (self._normals_cache_version != self.domain._version):
            domain = self.domain
            attribute = domain.attribute_names['normals']
            self._normals_cache = attribute.get_region(
                attribute.buffer, self.start, self.count)
            self._normals_cache_version = domain._version

        region = self._normals_cache
        region.invalidate()
        return region.array

    def _set_normals(self, data):
        self._get_normals()[:] = data

    _normals_cache = None
    _normals_cache_version = None
    normals = property(_get_normals, _set_normals,
                       doc='''Array of normal vector data.''')

    # ---

    def _get_secondary_colors(self):
        if (self._secondary_colors_cache_version != self.domain._version):
            domain = self.domain
            attribute = domain.attribute_names['secondary_colors']
            self._secondary_colors_cache = attribute.get_region(
                attribute.buffer, self.start, self.count)
            self._secondary_colors_cache_version = domain._version

        region = self._secondary_colors_cache
        region.invalidate()
        return region.array

    def _set_secondary_colors(self, data):
        self._get_secondary_colors()[:] = data

    _secondary_colors_cache = None
    _secondary_colors_cache_version = None
    secondary_colors = property(_get_secondary_colors, _set_secondary_colors,
                                doc='''Array of secondary color data.''')

    # ---

    _tex_coords_cache = None
    _tex_coords_cache_version = None

    def _get_tex_coords(self):
        if (self._tex_coords_cache_version != self.domain._version):
            domain = self.domain
            attribute = domain.attribute_names['tex_coords']
            self._tex_coords_cache = attribute.get_region(
                attribute.buffer, self.start, self.count)
            self._tex_coords_cache_version = domain._version

        region = self._tex_coords_cache
        region.invalidate()
        return region.array

    def _set_tex_coords(self, data):
        self._get_tex_coords()[:] = data

    tex_coords = property(_get_tex_coords, _set_tex_coords,
                          doc='''Array of texture coordinate data.''')

    # ---

    _vertices_cache = None
    _vertices_cache_version = None

    def _get_vertices(self):
        if (self._vertices_cache_version != self.domain._version):
            domain = self.domain
            attribute = domain.attribute_names['vertices']
            self._vertices_cache = attribute.get_region(
                attribute.buffer, self.start, self.count)
            self._vertices_cache_version = domain._version

        region = self._vertices_cache
        region.invalidate()
        return region.array

    def _set_vertices(self, data):
        self._get_vertices()[:] = data

    vertices = property(_get_vertices, _set_vertices,
                        doc='''Array of vertex coordinate data.''')

class IndexedVertexDomain(VertexDomain):
    '''Management of a set of indexed vertex lists.

    Construction of an indexed vertex domain is usually done with the
    `create_indexed_domain` function.
    '''
    _initial_index_count = 16

    def __init__(self, attribute_usages, index_gl_type=GL_UNSIGNED_INT):
        super(IndexedVertexDomain, self).__init__(attribute_usages)

        self.index_allocator = allocation.Allocator(self._initial_index_count)

        self.index_gl_type = index_gl_type
        self.index_c_type = vertexattribute._c_types[index_gl_type]
        self.index_element_size = ctypes.sizeof(self.index_c_type)
        self.index_buffer = vertexbuffer.create_mappable_buffer(
            self.index_allocator.capacity * self.index_element_size,
            target=GL_ELEMENT_ARRAY_BUFFER)

    def _safe_index_alloc(self, count):
        '''Allocate indices, resizing the buffers if necessary.'''
        try:
            return self.index_allocator.alloc(count)
        except allocation.AllocatorMemoryException, e:
            capacity = _nearest_pow2(e.requested_capacity)
            self._version += 1
            self.index_buffer.resize(capacity * self.index_element_size)
            self.index_allocator.set_capacity(capacity)
            return self.index_allocator.alloc(count)

    def _safe_index_realloc(self, start, count, new_count):
        '''Reallocate indices, resizing the buffers if necessary.'''
        try:
            return self.index_allocator.realloc(start, count, new_count)
        except allocation.AllocatorMemoryException, e:
            capacity = _nearest_pow2(e.requested_capacity)
            self._version += 1
            self.index_buffer.resize(capacity * self.index_element_size)
            self.index_allocator.set_capacity(capacity)
            return self.index_allocator.realloc(start, count, new_count)

    def create(self, count, index_count):
        '''Create an `IndexedVertexList` in this domain.

        :Parameters:
            `count` : int
                Number of vertices to create
            `index_count`
                Number of indices to create

        '''
        start = self._safe_alloc(count)
        index_start = self._safe_index_alloc(index_count)
        return IndexedVertexList(self, start, count, index_start, index_count)

    def get_index_region(self, start, count):
        '''Get a region of the index buffer.

        :Parameters:
            `start` : int
                Start of the region to map.
            `count` : int
                Number of indices to map.

        :rtype: Array of int
        '''
        byte_start = self.index_element_size * start
        byte_count = self.index_element_size * count
        ptr_type = ctypes.POINTER(self.index_c_type * count)
        return self.index_buffer.get_region(byte_start, byte_count, ptr_type)

    def draw(self, mode, vertex_list=None):
        '''Draw vertices in the domain.

        If `vertex_list` is not specified, all vertices in the domain are
        drawn.  This is the most efficient way to render primitives.

        If `vertex_list` specifies a `VertexList`, only primitives in that
        list will be drawn.

        :Parameters:
            `mode` : int
                OpenGL drawing mode, e.g. ``GL_POINTS``, ``GL_LINES``, etc.
            `vertex_list` : `IndexedVertexList`
                Vertex list to draw, or ``None`` for all lists in this domain.

        '''
        glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT)
        for buffer, attributes in self.buffer_attributes:
            buffer.bind()
            for attribute in attributes:
                attribute.enable()
                attribute.set_pointer(attribute.buffer.ptr)
        self.index_buffer.bind()
        if vertexbuffer._workaround_vbo_finish:
            glFinish()

        if vertex_list is not None:
            glDrawElements(mode, vertex_list.index_count, self.index_gl_type,
                self.index_buffer.ptr +
                    vertex_list.index_start * self.index_element_size)
        else:
            starts, sizes = self.index_allocator.get_allocated_regions()
            primcount = len(starts)
            if primcount == 0:
                pass
            elif primcount == 1:
                # Common case
                glDrawElements(mode, sizes[0], self.index_gl_type,
                    self.index_buffer.ptr + starts[0])
            elif gl_info.have_version(1, 4):
                starts = [s * self.index_element_size + self.index_buffer.ptr for s in starts]
                starts = cast((GLuint * primcount)(*starts), POINTER(c_void_p))
                sizes = (GLsizei * primcount)(*sizes)
                glMultiDrawElements(mode, sizes, GL_UNSIGNED_INT, starts,
                                    primcount)
            else:
                for start, size in zip(starts, sizes):
                    glDrawElements(mode, size, self.index_gl_type,
                        self.index_buffer.ptr +
                            start * self.index_element_size)

        self.index_buffer.unbind()
        for buffer, _ in self.buffer_attributes:
            buffer.unbind()
        glPopClientAttrib()

class IndexedVertexList(VertexList):
    '''A list of vertices within an `IndexedVertexDomain` that are indexed.
    Use `IndexedVertexDomain.create` to construct this list.
    '''
    def __init__(self, domain, start, count, index_start, index_count):
        super(IndexedVertexList, self).__init__(domain, start, count)

        self.index_start = index_start
        self.index_count = index_count

    def draw(self, mode):
        self.domain.draw(mode, self)

    def resize(self, count, index_count):
        '''Resize this group.

        :Parameters:
            `count` : int
                New number of vertices in the list.
            `index_count` : int
                New number of indices in the list.

        '''
        old_start = self.start
        super(IndexedVertexList, self).resize(count)

        # Change indices (because vertices moved)
        if old_start != self.start:
            diff = self.start - old_start
            self.indices[:] = map(lambda i: i + diff, self.indices)

        # Resize indices
        new_start = self.domain._safe_index_realloc(
            self.index_start, self.index_count, index_count)
        if new_start != self.index_start:
            old = self.domain.get_index_region(
                self.index_start, self.index_count)
            new = self.domain.get_index_region(
                self.index_start, self.index_count)
            new.array[:] = old.array[:]
            new.invalidate()
        self.index_start = new_start
        self.index_count = index_count
        self._indices_cache_version = None

    def delete(self):
        '''Delete this group.'''
        super(IndexedVertexList, self).delete()
        self.domain.index_allocator.dealloc(self.index_start, self.index_count)

    def _set_index_data(self, data):
        # TODO without region
        region = self.domain.get_index_region(
            self.index_start, self.index_count)
        region.array[:] = data
        region.invalidate()

    # ---

    def _get_indices(self):
        if self._indices_cache_version != self.domain._version:
            domain = self.domain
            self._indices_cache = domain.get_index_region(
                self.index_start, self.index_count)
            self._indices_cache_version = domain._version

        region = self._indices_cache
        region.invalidate()
        return region.array

    def _set_indices(self, data):
        self._get_indices()[:] = data

    _indices_cache = None
    _indices_cache_version = None
    indices = property(_get_indices, _set_indices,
                       doc='''Array of index data.''')

########NEW FILE########
__FILENAME__ = atlas
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Group multiple small images into larger textures.

This module is used by `pyglet.resource` to efficiently pack small images into
larger textures.  `TextureAtlas` maintains one texture; `TextureBin` manages a
collection of atlases of a given size.

Example usage::

    # Load images from disk
    car_image = pyglet.image.load('car.png')
    boat_image = pyglet.image.load('boat.png')

    # Pack these images into one or more textures
    bin = TextureBin()
    car_texture = bin.add(car_image)
    boat_texture = bin.add(boat_image)

The result of `TextureBin.add` is a `TextureRegion` containing the image.
Once added, an image cannot be removed from a bin (or an atlas); nor can a
list of images be obtained from a given bin or atlas -- it is the
application's responsibility to keep track of the regions returned by the
``add`` methods.

:since: pyglet 1.1
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import pyglet


class AllocatorException(Exception):
    '''The allocator does not have sufficient free space for the requested
    image size.'''
    pass


class _Strip(object):
    def __init__(self, y, max_height):
        self.x = 0
        self.y = y
        self.max_height = max_height
        self.y2 = y

    def add(self, width, height):
        assert width > 0 and height > 0
        assert height <= self.max_height

        x, y = self.x, self.y
        self.x += width
        self.y2 = max(self.y + height, self.y2)
        return x, y

    def compact(self):
        self.max_height = self.y2 - self.y


class Allocator(object):
    '''Rectangular area allocation algorithm.

    Initialise with a given ``width`` and ``height``, then repeatedly
    call `alloc` to retrieve free regions of the area and protect that
    area from future allocations.

    `Allocator` uses a fairly simple strips-based algorithm.  It performs best
    when rectangles are allocated in decreasing height order.
    '''
    def __init__(self, width, height):
        '''Create an `Allocator` of the given size.

        :Parameters:
            `width` : int
                Width of the allocation region.
            `height` : int
                Height of the allocation region.

        '''
        assert width > 0 and height > 0
        self.width = width
        self.height = height
        self.strips = [_Strip(0, height)]
        self.used_area = 0

    def alloc(self, width, height):
        '''Get a free area in the allocator of the given size.

        After calling `alloc`, the requested area will no longer be used.
        If there is not enough room to fit the given area `AllocatorException`
        is raised.

        :Parameters:
            `width` : int
                Width of the area to allocate.
            `height` : int
                Height of the area to allocate.

        :rtype: int, int
        :return: The X and Y coordinates of the bottom-left corner of the
            allocated region.
        '''
        for strip in self.strips:
            if self.width - strip.x >= width and strip.max_height >= height:
                self.used_area += width * height
                return strip.add(width, height)

        if self.width >= width and self.height - strip.y2 >= height:
            self.used_area += width * height
            strip.compact()
            newstrip = _Strip(strip.y2, self.height - strip.y2)
            self.strips.append(newstrip)
            return newstrip.add(width, height)

        raise AllocatorException('No more space in %r for box %dx%d' % (self, width, height))

    def get_usage(self):
        '''Get the fraction of area already allocated.

        This method is useful for debugging and profiling only.

        :rtype: float
        '''
        return self.used_area / float(self.width * self.height)

    def get_fragmentation(self):
        '''Get the fraction of area that's unlikely to ever be used, based on
        current allocation behaviour.

        This method is useful for debugging and profiling only.

        :rtype: float
        '''
        # The total unused area in each compacted strip is summed.
        if not self.strips:
            return 0.
        possible_area = self.strips[-1].y2 * self.width
        return 1.0 - self.used_area / float(possible_area)


class TextureAtlas(object):
    '''Collection of images within a texture.
    '''
    def __init__(self, width=256, height=256):
        '''Create a texture atlas of the given size.

        :Parameters:
            `width` : int
                Width of the underlying texture.
            `height` : int
                Height of the underlying texture.

        '''
        self.texture = pyglet.image.Texture.create(
            width, height, pyglet.gl.GL_RGBA, rectangle=False)
        self.allocator = Allocator(width, height)

    def add(self, img):
        '''Add an image to the atlas.

        This method will fail if the given image cannot be transferred
        directly to a texture (for example, if it is another texture).
        `ImageData` is the usual image type for this method.

        `AllocatorException` will be raised if there is no room in the atlas
        for the image.

        :Parameters:
            `img` : `AbstractImage`
                The image to add.

        :rtype: `TextureRegion`
        :return: The region of the atlas containing the newly added image.
        '''

        x, y = self.allocator.alloc(img.width, img.height)
        self.texture.blit_into(img, x, y, 0)
        region = self.texture.get_region(x, y, img.width, img.height)
        return region


class TextureBin(object):
    '''Collection of texture atlases.

    `TextureBin` maintains a collection of texture atlases, and creates new
    ones as necessary to accommodate images added to the bin.
    '''
    def __init__(self, texture_width=256, texture_height=256):
        '''Create a texture bin for holding atlases of the given size.

        :Parameters:
            `texture_width` : int
                Width of texture atlases to create.
            `texture_height` : int
                Height of texture atlases to create.

        '''
        self.atlases = []
        self.texture_width = texture_width
        self.texture_height = texture_height

    def add(self, img):
        '''Add an image into this texture bin.

        This method calls `TextureAtlas.add` for the first atlas that has room
        for the image.

        `AllocatorException` is raised if the image exceeds the dimensions of
        ``texture_width`` and ``texture_height``.

        :Parameters:
            `img` : `AbstractImage`
                The image to add.

        :rtype: `TextureRegion`
        :return: The region of an atlas containing the newly added image.
        '''
        for atlas in list(self.atlases):
            try:
                return atlas.add(img)
            except AllocatorException:
                # Remove atlases that are no longer useful (this is so their
                # textures can later be freed if the images inside them get
                # collected).
                if img.width < 64 and img.height < 64:
                    self.atlases.remove(atlas)

        atlas = TextureAtlas(self.texture_width, self.texture_height)
        self.atlases.append(atlas)
        return atlas.add(img)

########NEW FILE########
__FILENAME__ = bmp
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Decoder for BMP files.

Currently supports version 3 and 4 bitmaps with BI_RGB and BI_BITFIELDS
encoding.  Alpha channel is supported for 32-bit BI_RGB only.
'''

# Official docs are at
# http://msdn2.microsoft.com/en-us/library/ms532311.aspx
#
# But some details including alignment and bit/byte order are omitted; see
# http://www.fileformat.info/format/bmp/egff.htm

__docformat__ = 'restructuredtext'
__version__ = '$Id: bmp.py 2019 2008-04-18 14:30:48Z Alex.Holkner $'

import ctypes

from pyglet.image import ImageData
from pyglet.image.codecs import ImageDecoder, ImageDecodeException

BYTE = ctypes.c_ubyte
WORD = ctypes.c_uint16
DWORD = ctypes.c_uint32
LONG = ctypes.c_int32
FXPT2DOT30 = ctypes.c_uint32

BI_RGB = 0
BI_RLE8 = 1
BI_RLE4 = 2
BI_BITFIELDS = 3

class BITMAPFILEHEADER(ctypes.LittleEndianStructure):
    _pack_ = 1
    _fields_ = [
        ('bfType', WORD),
        ('bfSize', DWORD),
        ('bfReserved1', WORD),
        ('bfReserved2', WORD),
        ('bfOffBits', DWORD)
    ]

class BITMAPINFOHEADER(ctypes.LittleEndianStructure):
    _pack_ = 1
    _fields_ = [
        ('biSize', DWORD),
        ('biWidth', LONG),
        ('biHeight', LONG),
        ('biPlanes', WORD),
        ('biBitCount', WORD),
        ('biCompression', DWORD),
        ('biSizeImage', DWORD),
        ('biXPelsPerMeter', LONG),
        ('biYPelsPerMeter', LONG),
        ('biClrUsed', DWORD),
        ('biClrImportant', DWORD)
    ]

CIEXYZTRIPLE = FXPT2DOT30 * 9

class BITMAPV4HEADER(ctypes.LittleEndianStructure):
    _pack_ = 1
    _fields_ = [
        ('biSize', DWORD),
        ('biWidth', LONG),
        ('biHeight', LONG),
        ('biPlanes', WORD),
        ('biBitCount', WORD),
        ('biCompression', DWORD),
        ('biSizeImage', DWORD),
        ('biXPelsPerMeter', LONG),
        ('biYPelsPerMeter', LONG),
        ('biClrUsed', DWORD),
        ('biClrImportant', DWORD),
        ('bV4RedMask', DWORD),
        ('bV4GreenMask', DWORD),
        ('bV4BlueMask', DWORD),
        ('bV4AlphaMask', DWORD),
        ('bV4CSType', DWORD),
        ('bV4Endpoints', CIEXYZTRIPLE),
        ('bV4GammaRed', DWORD),
        ('bV4GammaGreen', DWORD),
        ('bV4GammaBlue', DWORD),
    ]

class RGBFields(ctypes.LittleEndianStructure):
    _pack_ = 1
    _fields_ = [
        ('red', DWORD),
        ('green', DWORD),
        ('blue', DWORD),
    ]


class RGBQUAD(ctypes.LittleEndianStructure):
    _pack_ = 1
    _fields_ = [
        ('rgbBlue', BYTE),
        ('rgbGreen', BYTE),
        ('rgbRed', BYTE),
        ('rgbReserved', BYTE)
    ]

    def __repr__(self):
        return '<%d, %d, %d>' % (self.rgbRed, self.rgbGreen, self.rgbBlue)

def ptr_add(ptr, offset):
    address = ctypes.addressof(ptr.contents) + offset
    return ctypes.pointer(type(ptr.contents).from_address(address))

def to_ctypes(buffer, offset, type):
    if offset + ctypes.sizeof(type) > len(buffer):
        raise ImageDecodeException('BMP file is truncated')
    ptr = ptr_add(ctypes.pointer(buffer), offset)
    return ctypes.cast(ptr, ctypes.POINTER(type)).contents

class BMPImageDecoder(ImageDecoder):
    def get_file_extensions(self):
        return ['.bmp']

    def decode(self, file, filename):
        if not file:
            file = open(filename, 'rb')
        bytes = file.read()
        buffer = ctypes.c_buffer(bytes)

        if bytes[:2] != 'BM':
            raise ImageDecodeException(
                'Not a Windows bitmap file: %r' % (filename or file))

        file_header = to_ctypes(buffer, 0, BITMAPFILEHEADER)
        bits_offset = file_header.bfOffBits
        info_header_offset = ctypes.sizeof(BITMAPFILEHEADER)
        info_header = to_ctypes(buffer, info_header_offset, BITMAPINFOHEADER)
        palette_offset = info_header_offset + info_header.biSize

        if info_header.biSize < ctypes.sizeof(BITMAPINFOHEADER):
            raise ImageDecodeException(
                'Unsupported BMP type: %r' % (filename or file))

        width = info_header.biWidth
        height = info_header.biHeight
        if width <= 0  or info_header.biPlanes != 1:
            raise ImageDecodeException(
                'BMP file has corrupt parameters: %r' % (filename or file))
        pitch_sign = height < 0 and -1 or 1
        height = abs(height)

        compression = info_header.biCompression
        if compression not in (BI_RGB, BI_BITFIELDS):
            raise ImageDecodeException(
                'Unsupported compression: %r' % (filename or file))

        clr_used = 0
        bitcount = info_header.biBitCount
        if bitcount == 1:
            pitch = (width + 7) // 8
            bits_type = ctypes.c_ubyte
            decoder = decode_1bit
        elif bitcount == 4:
            pitch = (width + 1) // 2
            bits_type = ctypes.c_ubyte
            decoder = decode_4bit
        elif bitcount == 8:
            bits_type = ctypes.c_ubyte
            pitch = width
            decoder = decode_8bit
        elif bitcount == 16:
            pitch = width * 2
            bits_type = ctypes.c_uint16
            decoder = decode_bitfields
        elif bitcount == 24:
            pitch = width * 3
            bits_type = ctypes.c_ubyte
            decoder = decode_24bit
        elif bitcount == 32:
            pitch = width * 4
            if compression == BI_RGB:
                decoder = decode_32bit_rgb
                bits_type = ctypes.c_ubyte
            elif compression == BI_BITFIELDS:
                decoder = decode_bitfields
                bits_type = ctypes.c_uint32
            else:
                raise ImageDecodeException(
                    'Unsupported compression: %r' % (filename or file))
        else:
            raise ImageDecodeException(
                'Unsupported bit count %d: %r' % (bitcount, filename or file))

        pitch = (pitch + 3) & ~3
        packed_width = pitch // ctypes.sizeof(bits_type)

        if bitcount < 16 and compression == BI_RGB:
            clr_used = info_header.biClrUsed or (1 <<  bitcount)
            palette = to_ctypes(buffer, palette_offset, RGBQUAD * clr_used)
            bits = to_ctypes(buffer, bits_offset,
                             bits_type * packed_width * height)
            return decoder(bits, palette, width, height, pitch, pitch_sign)
        elif bitcount >= 16 and compression == BI_RGB:
            bits = to_ctypes(buffer, bits_offset,
                             bits_type * (packed_width * height))
            return decoder(bits, None, width, height, pitch, pitch_sign)
        elif compression == BI_BITFIELDS:
            if info_header.biSize >= ctypes.sizeof(BITMAPV4HEADER):
                info_header = to_ctypes(buffer, info_header_offset,
                                        BITMAPV4HEADER)
                r_mask = info_header.bV4RedMask
                g_mask = info_header.bV4GreenMask
                b_mask = info_header.bV4BlueMask
            else:
                fields_offset = info_header_offset + \
                    ctypes.sizeof(BITMAPINFOHEADER)
                fields = to_ctypes(buffer, fields_offset, RGBFields)
                r_mask = fields.red
                g_mask = fields.green
                b_mask = fields.blue
            class _BitsArray(ctypes.LittleEndianStructure):
                _pack_ = 1
                _fields_ = [
                    ('data', bits_type * packed_width * height),
                ]
            bits = to_ctypes(buffer, bits_offset, _BitsArray).data
            return decoder(bits, r_mask, g_mask, b_mask,
                           width, height, pitch, pitch_sign)

def decode_1bit(bits, palette, width, height, pitch, pitch_sign):
    rgb_pitch = (((pitch << 3) + 7) & ~0x7) * 3
    buffer = (ctypes.c_ubyte * (height * rgb_pitch))()
    i = 0
    for row in bits:
        for packed in row:
            for _ in range(8):
                rgb = palette[(packed & 0x80) >> 7]
                buffer[i] = rgb.rgbRed
                buffer[i + 1] = rgb.rgbGreen
                buffer[i + 2] = rgb.rgbBlue
                i += 3
                packed <<= 1

    return ImageData(width, height, 'RGB', buffer, pitch_sign * rgb_pitch)

def decode_4bit(bits, palette, width, height, pitch, pitch_sign):
    rgb_pitch = (((pitch << 1) + 1) & ~0x1) * 3
    buffer = (ctypes.c_ubyte * (height * rgb_pitch))()
    i = 0
    for row in bits:
        for packed in row:
            for index in ((packed & 0xf0) >> 4, packed & 0xf):
                rgb = palette[index]
                buffer[i] = rgb.rgbRed
                buffer[i + 1] = rgb.rgbGreen
                buffer[i + 2] = rgb.rgbBlue
                i += 3

    return ImageData(width, height, 'RGB', buffer, pitch_sign * rgb_pitch)

def decode_8bit(bits, palette, width, height, pitch, pitch_sign):
    rgb_pitch = pitch * 3
    buffer = (ctypes.c_ubyte * (height * rgb_pitch))()
    i = 0
    for row in bits:
        for index in row:
            rgb = palette[index]
            buffer[i] = rgb.rgbRed
            buffer[i + 1] = rgb.rgbGreen
            buffer[i + 2] = rgb.rgbBlue
            i += 3

    return ImageData(width, height, 'RGB', buffer, pitch_sign * rgb_pitch)


def decode_24bit(bits, palette, width, height, pitch, pitch_sign):
    buffer = (ctypes.c_ubyte * (height * pitch))()
    ctypes.memmove(buffer, bits, len(buffer))
    return ImageData(width, height, 'BGR', buffer, pitch_sign * pitch)

def decode_32bit_rgb(bits, palette, width, height, pitch, pitch_sign):
    buffer = (ctypes.c_ubyte * (height * pitch))()
    ctypes.memmove(buffer, bits, len(buffer))
    return ImageData(width, height, 'BGRA', buffer, pitch_sign * pitch)

def get_shift(mask):
    if not mask:
        return 0

    # Shift down
    shift = 0
    while not (1 << shift) & mask:
        shift += 1

    # Shift up
    shift_up = 0
    while (mask >> shift) >> shift_up:
        shift_up += 1

    s = shift - (8 - shift_up)
    if s < 0:
        return 0, -s
    else:
        return s, 0

def decode_bitfields(bits, r_mask, g_mask, b_mask,
                     width, height, pitch, pitch_sign):
    r_shift1, r_shift2 = get_shift(r_mask)
    g_shift1, g_shift2 = get_shift(g_mask)
    b_shift1, b_shift2 = get_shift(b_mask)

    rgb_pitch = 3 * len(bits[0])
    buffer = (ctypes.c_ubyte * (height * rgb_pitch))()

    i = 0
    for row in bits:
        for packed in row:
            buffer[i] = (packed & r_mask) >> r_shift1 << r_shift2
            buffer[i+1] = (packed & g_mask) >> g_shift1 << g_shift2
            buffer[i+2] = (packed & b_mask) >> b_shift1 << b_shift2
            i += 3

    return ImageData(width, height, 'RGB', buffer, pitch_sign * rgb_pitch)

def get_decoders():
    return [BMPImageDecoder()]

def get_encoders():
    return []

########NEW FILE########
__FILENAME__ = dds
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''DDS texture loader.

Reference: http://msdn2.microsoft.com/en-us/library/bb172993.aspx
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: dds.py 2496 2009-08-19 01:17:30Z benjamin.coder.smith $'

from ctypes import *
import struct

from pyglet.gl import *
from pyglet.image import CompressedImageData
from pyglet.image import codecs
from pyglet.image.codecs import s3tc

class DDSException(codecs.ImageDecodeException):
    pass

# dwFlags of DDSURFACEDESC2
DDSD_CAPS           = 0x00000001
DDSD_HEIGHT         = 0x00000002
DDSD_WIDTH          = 0x00000004
DDSD_PITCH          = 0x00000008
DDSD_PIXELFORMAT    = 0x00001000
DDSD_MIPMAPCOUNT    = 0x00020000
DDSD_LINEARSIZE     = 0x00080000
DDSD_DEPTH          = 0x00800000

# ddpfPixelFormat of DDSURFACEDESC2
DDPF_ALPHAPIXELS  	= 0x00000001
DDPF_FOURCC 	    = 0x00000004
DDPF_RGB 	        = 0x00000040

# dwCaps1 of DDSCAPS2
DDSCAPS_COMPLEX  	= 0x00000008
DDSCAPS_TEXTURE 	= 0x00001000
DDSCAPS_MIPMAP 	    = 0x00400000

# dwCaps2 of DDSCAPS2
DDSCAPS2_CUBEMAP 	        = 0x00000200
DDSCAPS2_CUBEMAP_POSITIVEX  = 0x00000400
DDSCAPS2_CUBEMAP_NEGATIVEX  = 0x00000800
DDSCAPS2_CUBEMAP_POSITIVEY  = 0x00001000
DDSCAPS2_CUBEMAP_NEGATIVEY  = 0x00002000
DDSCAPS2_CUBEMAP_POSITIVEZ  = 0x00004000
DDSCAPS2_CUBEMAP_NEGATIVEZ  = 0x00008000
DDSCAPS2_VOLUME 	        = 0x00200000

class _filestruct(object):
    def __init__(self, data):
        if len(data) < self.get_size():
            raise DDSException('Not a DDS file')
        items = struct.unpack(self.get_format(), data)
        for field, value in map(None, self._fields, items):
            setattr(self, field[0], value)

    def __repr__(self):
        name = self.__class__.__name__
        return '%s(%s)' % \
            (name, (', \n%s' % (' ' * (len(name) + 1))).join( \
                      ['%s = %s' % (field[0], repr(getattr(self, field[0]))) \
                       for field in self._fields]))

    @classmethod
    def get_format(cls):
        return '<' + ''.join([f[1] for f in cls._fields])

    @classmethod
    def get_size(cls):
        return struct.calcsize(cls.get_format())

class DDSURFACEDESC2(_filestruct):
    _fields = [
        ('dwMagic', '4s'),
        ('dwSize', 'I'),
        ('dwFlags', 'I'),
        ('dwHeight', 'I'),
        ('dwWidth', 'I'),
        ('dwPitchOrLinearSize', 'I'),
        ('dwDepth', 'I'),
        ('dwMipMapCount', 'I'),
        ('dwReserved1', '44s'),
        ('ddpfPixelFormat', '32s'),
        ('dwCaps1', 'I'),
        ('dwCaps2', 'I'),
        ('dwCapsReserved', '8s'),
        ('dwReserved2', 'I')
    ]

    def __init__(self, data):
        super(DDSURFACEDESC2, self).__init__(data)
        self.ddpfPixelFormat = DDPIXELFORMAT(self.ddpfPixelFormat)


class DDPIXELFORMAT(_filestruct):
    _fields = [
        ('dwSize', 'I'),
        ('dwFlags', 'I'),
        ('dwFourCC', '4s'),
        ('dwRGBBitCount', 'I'),
        ('dwRBitMask', 'I'),
        ('dwGBitMask', 'I'),
        ('dwBBitMask', 'I'),
        ('dwRGBAlphaBitMask', 'I')
    ]

_compression_formats = {
    ('DXT1', False): (GL_COMPRESSED_RGB_S3TC_DXT1_EXT,  s3tc.decode_dxt1_rgb),
    ('DXT1', True):  (GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, s3tc.decode_dxt1_rgba),
    ('DXT3', False): (GL_COMPRESSED_RGBA_S3TC_DXT3_EXT, s3tc.decode_dxt3),
    ('DXT3', True):  (GL_COMPRESSED_RGBA_S3TC_DXT3_EXT, s3tc.decode_dxt3),
    ('DXT5', False): (GL_COMPRESSED_RGBA_S3TC_DXT5_EXT, s3tc.decode_dxt5),
    ('DXT5', True):  (GL_COMPRESSED_RGBA_S3TC_DXT5_EXT, s3tc.decode_dxt5),
}

def _check_error():
    e = glGetError()
    if e != 0:
        print 'GL error %d' % e

class DDSImageDecoder(codecs.ImageDecoder):
    def get_file_extensions(self):
        return ['.dds']

    def decode(self, file, filename):
        header = file.read(DDSURFACEDESC2.get_size())
        desc = DDSURFACEDESC2(header)
        if desc.dwMagic != 'DDS ' or desc.dwSize != 124:
            raise DDSException('Invalid DDS file (incorrect header).')

        width = desc.dwWidth
        height = desc.dwHeight
        mipmaps = 1


        if desc.dwFlags & DDSD_DEPTH:
            raise DDSException('Volume DDS files unsupported')

        if desc.dwFlags & DDSD_MIPMAPCOUNT:
            mipmaps = desc.dwMipMapCount

        if desc.ddpfPixelFormat.dwSize != 32:
            raise DDSException('Invalid DDS file (incorrect pixel format).')

        if desc.dwCaps2 & DDSCAPS2_CUBEMAP:
            raise DDSException('Cubemap DDS files unsupported')

        if not desc.ddpfPixelFormat.dwFlags & DDPF_FOURCC:
            raise DDSException('Uncompressed DDS textures not supported.')

        has_alpha = desc.ddpfPixelFormat.dwRGBAlphaBitMask != 0

        format, decoder = _compression_formats.get(
            (desc.ddpfPixelFormat.dwFourCC, has_alpha), None)
        if not format:
            raise DDSException('Unsupported texture compression %s' % \
                desc.ddpfPixelFormat.dwFourCC)

        if format == GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
            block_size = 8
        else:
            block_size = 16

        datas = []
        w, h = width, height
        for i in range(mipmaps):
            if not w and not h:
                break
            if not w:
                w = 1
            if not h:
                h = 1
            size = ((w + 3) / 4) * ((h + 3) / 4) * block_size
            data = file.read(size)
            datas.append(data)
            w >>= 1
            h >>= 1

        image = CompressedImageData(width, height, format, datas[0],
            'GL_EXT_texture_compression_s3tc', decoder)
        level = 0
        for data in datas[1:]:
            level += 1
            image.set_mipmap_data(level, data)

        return image

def get_decoders():
    return [DDSImageDecoder()]

def get_encoders():
    return []

########NEW FILE########
__FILENAME__ = gdiplus
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: pil.py 163 2006-11-13 04:15:46Z Alex.Holkner $'

from ctypes import *

from pyglet.gl import *
from pyglet.image import *
from pyglet.image.codecs import *
from pyglet.window.win32.constants import *
from pyglet.window.win32.types import *

ole32 = windll.ole32
kernel32 = windll.kernel32
gdiplus = windll.gdiplus

LPSTREAM = c_void_p
REAL = c_float

PixelFormat1bppIndexed    = 196865
PixelFormat4bppIndexed    = 197634
PixelFormat8bppIndexed    = 198659
PixelFormat16bppGrayScale = 1052676
PixelFormat16bppRGB555    = 135173
PixelFormat16bppRGB565    = 135174
PixelFormat16bppARGB1555  = 397319
PixelFormat24bppRGB       = 137224
PixelFormat32bppRGB       = 139273
PixelFormat32bppARGB      = 2498570
PixelFormat32bppPARGB     = 925707
PixelFormat48bppRGB       = 1060876
PixelFormat64bppARGB      = 3424269
PixelFormat64bppPARGB     = 29622286
PixelFormatMax            = 15

ImageLockModeRead = 1
ImageLockModeWrite = 2
ImageLockModeUserInputBuf = 4

class GdiplusStartupInput(Structure):
    _fields_ = [
        ('GdiplusVersion', c_uint32),
        ('DebugEventCallback', c_void_p),
        ('SuppressBackgroundThread', BOOL),
        ('SuppressExternalCodecs', BOOL)
    ]

class GdiplusStartupOutput(Structure):
    _fields = [
        ('NotificationHookProc', c_void_p),
        ('NotificationUnhookProc', c_void_p)
    ]

class BitmapData(Structure):
    _fields_ = [
        ('Width', c_uint),
        ('Height', c_uint),
        ('Stride', c_int),
        ('PixelFormat', c_int),
        ('Scan0', POINTER(c_byte)),
        ('Reserved', POINTER(c_uint))
    ]

class Rect(Structure):
    _fields_ = [
        ('X', c_int),
        ('Y', c_int),
        ('Width', c_int),
        ('Height', c_int)
    ]

kernel32.GlobalAlloc.restype = HGLOBAL
kernel32.GlobalLock.restype = c_void_p

PropertyTagFrameDelay = 0x5100

class PropertyItem(Structure):
    _fields_ = [
        ('id', c_uint),
        ('length', c_ulong),
        ('type', c_short),
        ('value', c_void_p)
    ]

class GDIPlusDecoder(ImageDecoder):
    def get_file_extensions(self):
        return ['.bmp', '.gif', '.jpg', '.jpeg', '.exif', '.png', '.tif',
                '.tiff']

    def get_animation_file_extensions(self):
        # TIFF also supported as a multi-page image; but that's not really an
        # animation, is it?
        return ['.gif']

    def _load_bitmap(self, file, filename):
        data = file.read()

        # Create a HGLOBAL with image data
        hglob = kernel32.GlobalAlloc(GMEM_MOVEABLE, len(data))
        ptr = kernel32.GlobalLock(hglob)
        memmove(ptr, data, len(data))
        kernel32.GlobalUnlock(hglob)

        # Create IStream for the HGLOBAL
        stream = LPSTREAM()
        ole32.CreateStreamOnHGlobal(hglob, True, byref(stream))

        # Load image from stream
        bitmap = c_void_p()
        status = gdiplus.GdipCreateBitmapFromStream(stream, byref(bitmap))
        if status != 0:
            # TODO release stream
            raise ImageDecodeException(
                'GDI+ cannot load %r' % (filename or file))

        return bitmap

    def _get_image(self, bitmap):
        # Get size of image (Bitmap subclasses Image)
        width = REAL()
        height = REAL()
        gdiplus.GdipGetImageDimension(bitmap, byref(width), byref(height))
        width = int(width.value)
        height = int(height.value)

        # Get image pixel format
        pf = c_int()
        gdiplus.GdipGetImagePixelFormat(bitmap, byref(pf))
        pf = pf.value

        # Reverse from what's documented because of Intel little-endianness.
        format = 'BGRA'
        if pf == PixelFormat24bppRGB:
            format = 'BGR'
        elif pf == PixelFormat32bppRGB:
            pass
        elif pf == PixelFormat32bppARGB:
            pass
        elif pf in (PixelFormat16bppARGB1555, PixelFormat32bppPARGB,
                    PixelFormat64bppARGB, PixelFormat64bppPARGB):
            pf = PixelFormat32bppARGB
        else:
            format = 'BGR'
            pf = PixelFormat24bppRGB

        # Lock pixel data in best format
        rect = Rect()
        rect.X = 0
        rect.Y = 0
        rect.Width = width
        rect.Height = height
        bitmap_data = BitmapData()
        gdiplus.GdipBitmapLockBits(bitmap,
            byref(rect), ImageLockModeRead, pf, byref(bitmap_data))

        # Create buffer for RawImage
        buffer = create_string_buffer(bitmap_data.Stride * height)
        memmove(buffer, bitmap_data.Scan0, len(buffer))

        # Unlock data
        gdiplus.GdipBitmapUnlockBits(bitmap, byref(bitmap_data))

        return ImageData(width, height, format, buffer, -bitmap_data.Stride)

    def _delete_bitmap(self, bitmap):
        # Release image and stream
        gdiplus.GdipDisposeImage(bitmap)
        # TODO: How to call IUnknown::Release on stream?

    def decode(self, file, filename):
        bitmap = self._load_bitmap(file, filename)
        image = self._get_image(bitmap)
        self._delete_bitmap(bitmap)
        return image

    def decode_animation(self, file, filename):
        bitmap = self._load_bitmap(file, filename)

        dimension_count = c_uint()
        gdiplus.GdipImageGetFrameDimensionsCount(bitmap, byref(dimension_count))
        if dimension_count.value < 1:
            self._delete_bitmap(bitmap)
            raise ImageDecodeException('Image has no frame dimensions')

        # XXX Make sure this dimension is time?
        dimensions = (c_void_p * dimension_count.value)()
        gdiplus.GdipImageGetFrameDimensionsList(bitmap, dimensions,
                                                dimension_count.value)

        frame_count = c_uint()
        gdiplus.GdipImageGetFrameCount(bitmap, dimensions, byref(frame_count))

        prop_id = PropertyTagFrameDelay
        prop_size = c_uint()
        gdiplus.GdipGetPropertyItemSize(bitmap, prop_id, byref(prop_size))

        prop_buffer = c_buffer(prop_size.value)
        prop_item = cast(prop_buffer, POINTER(PropertyItem)).contents
        gdiplus.GdipGetPropertyItem(bitmap, prop_id, prop_size.value,
            prop_buffer)

        # XXX Sure it's long?
        n_delays = prop_item.length / sizeof(c_long)
        delays = cast(prop_item.value, POINTER(c_long * n_delays)).contents

        frames = []

        for i in range(frame_count.value):
            gdiplus.GdipImageSelectActiveFrame(bitmap, dimensions, i)
            image = self._get_image(bitmap)

            delay = delays[i]
            if delay <= 1:
                delay = 10
            frames.append(AnimationFrame(image, delay/100.))

        self._delete_bitmap(bitmap)

        return Animation(frames)

def get_decoders():
    return [GDIPlusDecoder()]

def get_encoders():
    return []

def init():
    token = c_ulong()
    startup_in = GdiplusStartupInput()
    startup_in.GdiplusVersion = 1
    startup_out = GdiplusStartupOutput()
    gdiplus.GdiplusStartup(byref(token), byref(startup_in), byref(startup_out))

    # Shutdown later?
    # gdiplus.GdiplusShutdown(token)

init()

########NEW FILE########
__FILENAME__ = gdkpixbuf2
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: gdkpixbuf2.py 2496 2009-08-19 01:17:30Z benjamin.coder.smith $'

from ctypes import *

from pyglet.gl import *
from pyglet.image import *
from pyglet.image.codecs import *
from pyglet.image.codecs import gif

import pyglet.lib
import pyglet.window

gdk = pyglet.lib.load_library('gdk-x11-2.0')
gdkpixbuf = pyglet.lib.load_library('gdk_pixbuf-2.0')

GdkPixbufLoader = c_void_p
GdkPixbuf = c_void_p
gdkpixbuf.gdk_pixbuf_loader_new.restype = GdkPixbufLoader
gdkpixbuf.gdk_pixbuf_loader_get_pixbuf.restype = GdkPixbuf
gdkpixbuf.gdk_pixbuf_get_pixels.restype = c_void_p
gdkpixbuf.gdk_pixbuf_loader_get_animation.restype = c_void_p
gdkpixbuf.gdk_pixbuf_animation_get_iter.restype = c_void_p
gdkpixbuf.gdk_pixbuf_animation_iter_get_pixbuf.restype = GdkPixbuf

class GTimeVal(Structure):
    _fields_ = [
        ('tv_sec', c_long),
        ('tv_usec', c_long)
    ]

class GdkPixbuf2ImageDecoder(ImageDecoder):
    def get_file_extensions(self):
        return ['.png', '.xpm', '.jpg', '.jpeg', '.tif', '.tiff', '.pnm',
                '.ras', '.bmp', '.gif']

    def get_animation_file_extensions(self):
        return ['.gif', '.ani']

    def _load(self, file, filename, load_func):
        data = file.read()
        err = c_int()
        loader = gdkpixbuf.gdk_pixbuf_loader_new()
        gdkpixbuf.gdk_pixbuf_loader_write(loader, data, len(data), byref(err))
        result = load_func(loader)
        if not gdkpixbuf.gdk_pixbuf_loader_close(loader, byref(err)):
            raise ImageDecodeException(filename)
        if not result:
            raise ImageDecodeException('Unable to load: %s' % filename)
        return result

    def _pixbuf_to_image(self, pixbuf):
        # Get format and dimensions
        width = gdkpixbuf.gdk_pixbuf_get_width(pixbuf)
        height = gdkpixbuf.gdk_pixbuf_get_height(pixbuf)
        channels = gdkpixbuf.gdk_pixbuf_get_n_channels(pixbuf)
        rowstride = gdkpixbuf.gdk_pixbuf_get_rowstride(pixbuf)
        pixels = gdkpixbuf.gdk_pixbuf_get_pixels(pixbuf)

        # Copy pixel data.
        buffer = (c_ubyte * (rowstride * height))()
        memmove(buffer, pixels, rowstride * (height - 1) + width * channels)

        # Release pixbuf
        gdk.g_object_unref(pixbuf)

        # Determine appropriate GL type
        if channels == 3:
            format = 'RGB'
        else:
            format = 'RGBA'

        return ImageData(width, height, format, buffer, -rowstride)

    def decode(self, file, filename):
        pixbuf = self._load(file, filename,
                            gdkpixbuf.gdk_pixbuf_loader_get_pixbuf)

        return self._pixbuf_to_image(pixbuf)

    def decode_animation(self, file, filename):
        # Extract GIF control data.  If it's not a GIF, this method will
        # raise.
        gif_stream = gif.read(file)
        delays = [image.delay for image in gif_stream.images]

        # Get GDK animation iterator
        file.seek(0)
        anim = self._load(file, filename,
                          gdkpixbuf.gdk_pixbuf_loader_get_animation)
        time = GTimeVal(0, 0)
        iter = gdkpixbuf.gdk_pixbuf_animation_get_iter(anim, byref(time))

        frames = []

        # Extract each image
        for control_delay in delays:
            pixbuf = gdkpixbuf.gdk_pixbuf_animation_iter_get_pixbuf(iter)
            image = self._pixbuf_to_image(pixbuf)
            frames.append(AnimationFrame(image, control_delay))

            gdk_delay = gdkpixbuf.gdk_pixbuf_animation_iter_get_delay_time(iter)
            gdk_delay *= 1000 # milliseconds to microseconds
            # Compare gdk_delay to control_delay for interest only.
            #print control_delay, gdk_delay / 1000000.

            if gdk_delay == -1:
                break

            us = time.tv_usec + gdk_delay
            time.tv_sec += us // 1000000
            time.tv_usec = us % 1000000
            gdkpixbuf.gdk_pixbuf_animation_iter_advance(iter, byref(time))

        return Animation(frames)

def get_decoders():
    return [GdkPixbuf2ImageDecoder()]

def get_encoders():
    return []

def init():
    gdk.g_type_init()

init()


########NEW FILE########
__FILENAME__ = gif
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Read GIF control data.

http://www.w3.org/Graphics/GIF/spec-gif89a.txt
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: gif.py 2496 2009-08-19 01:17:30Z benjamin.coder.smith $'

import struct

from pyglet.image.codecs import ImageDecodeException

class GIFStream(object):
    def __init__(self):
        self.images = []

class GIFImage(object):
    delay = None

class GraphicsScope(object):
    delay = None

# Appendix A.
LABEL_EXTENSION_INTRODUCER = 0x21
LABEL_GRAPHIC_CONTROL_EXTENSION = 0xf9
LABEL_IMAGE_DESCRIPTOR = 0x2c
LABEL_TRAILER = 0x3b

def unpack(format, file):
    size = struct.calcsize(format)
    data = file.read(size)
    if len(data) < size:
        raise ImageDecodeException('Unexpected EOF')
    return struct.unpack(format, data)

def read_byte(file):
    data = file.read(1)
    if not len(data):
        raise ImageDecodeException('Unexpected EOF')
    return ord(data)

def read(file):
    '''Read a GIF file stream.

    :rtype: GIFStream
    '''
    # 17. Header
    signature = file.read(3)
    version = file.read(3)
    if signature != 'GIF':
        raise ImageDecodeException('Not a GIF stream')

    stream = GIFStream()

    # 18. Logical screen descriptor
    (logical_screen_width,
     logical_screen_height,
     fields,
     background_color_index,
     pixel_aspect_ratio) = unpack('HHBBB', file)
    global_color_table_flag = fields & 0x80
    global_color_table_size = fields & 0x7

    # 19. Global color table
    if global_color_table_flag:
        global_color_table = file.read(6 << global_color_table_size)

    # <Data>*
    graphics_scope = GraphicsScope()
    block_type = read_byte(file)

    while block_type != LABEL_TRAILER:
        if block_type == LABEL_IMAGE_DESCRIPTOR:
            read_table_based_image(file, stream, graphics_scope)
            graphics_scope = GraphicsScope()
        elif block_type == LABEL_EXTENSION_INTRODUCER:
            extension_block_type = read_byte(file)
            if extension_block_type == LABEL_GRAPHIC_CONTROL_EXTENSION:
                read_graphic_control_extension(file, stream, graphics_scope)
            else:
                skip_data_sub_blocks(file)
        else:
            # Skip bytes until a valid start character is found
            print block_type
            pass
        block_type = read_byte(file)

    return stream

def skip_data_sub_blocks(file):
    # 15. Data sub-blocks
    block_size = read_byte(file)
    while block_size != 0:
        data = file.read(block_size)
        block_size = read_byte(file)

def read_table_based_image(file, stream, graphics_scope):
    gif_image = GIFImage()
    stream.images.append(gif_image)
    gif_image.delay = graphics_scope.delay

    # 20. Image descriptor
    (image_left_position,
     image_top_position,
     image_width,
     image_height,
     fields) = unpack('HHHHB', file)

    local_color_table_flag = fields & 0x80
    local_color_table_size = fields & 0x7

    # 21. Local color table
    if local_color_table_flag:
        local_color_table = file.read(6 << local_color_table_size)

    # 22. Table based image data
    lzw_code_size = file.read(1)
    skip_data_sub_blocks(file)

def read_graphic_control_extension(file, stream, graphics_scope):
    # 23. Graphic control extension
    (block_size,
     fields,
     delay_time,
     transparent_color_index,
     terminator) = unpack('BBHBB', file)
    if block_size != 4:
        raise ImageDecodeException('Incorrect block size')

    if delay_time:
        # Follow Firefox/Mac behaviour: use 100ms delay for any delay
        # less than 10ms.
        if delay_time <= 1:
            delay_time = 10
        graphics_scope.delay = float(delay_time) / 100

########NEW FILE########
__FILENAME__ = pil
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: pil.py 1768 2008-02-17 12:45:54Z Alex.Holkner $'

import os.path

from pyglet.gl import *
from pyglet.image import *
from pyglet.image.codecs import *

from PIL import Image

class PILImageDecoder(ImageDecoder):
    def get_file_extensions(self):
        # Only most common ones shown here
        return ['.bmp', '.cur', '.gif', '.ico', '.jpg', '.jpeg', '.pcx', '.png',
                '.tga', '.tif', '.tiff', '.xbm', '.xpm']

    def decode(self, file, filename):
        try:
            image = Image.open(file)
        except Exception, e:
            raise ImageDecodeException(
                'PIL cannot read %r: %s' % (filename or file, e))

        image = image.transpose(Image.FLIP_TOP_BOTTOM)

        # Convert bitmap and palette images to component
        if image.mode in ('1', 'P'):
            image = image.convert()

        if image.mode not in ('L', 'LA', 'RGB', 'RGBA'):
            raise ImageDecodeException('Unsupported mode "%s"' % image.mode)
        type = GL_UNSIGNED_BYTE
        width, height = image.size

        return ImageData(width, height, image.mode, image.tostring())

class PILImageEncoder(ImageEncoder):
    def get_file_extensions(self):
        # Most common only
        return ['.bmp', '.eps', '.gif', '.jpg', '.jpeg',
                '.pcx', '.png', '.ppm', '.tiff', '.xbm']

    def encode(self, image, file, filename):
        # File format is guessed from filename extension, otherwise defaults
        # to PNG.
        pil_format = (filename and os.path.splitext(filename)[1][1:]) or 'png'

        if pil_format.lower() == 'jpg':
            pil_format = 'JPEG'

        image = image.get_image_data()
        format = image.format
        if format != 'RGB':
            # Only save in RGB or RGBA formats.
            format = 'RGBA'
        pitch = -(image.width * len(format))

        # Note: Don't try and use frombuffer(..); different versions of
        # PIL will orient the image differently.
        pil_image = Image.fromstring(
            format, (image.width, image.height), image.get_data(format, pitch))

        try:
            pil_image.save(file, pil_format)
        except Exception, e:
            raise ImageEncodeException(e)

def get_decoders():
    return [PILImageDecoder()]

def get_encoders():
    return [PILImageEncoder()]

########NEW FILE########
__FILENAME__ = png
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Encoder and decoder for PNG files, using PyPNG (pypng.py).
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import array

from pyglet.gl import *
from pyglet.image import *
from pyglet.image.codecs import *

import pyglet.image.codecs.pypng

class PNGImageDecoder(ImageDecoder):
    def get_file_extensions(self):
        return ['.png']

    def decode(self, file, filename):
        try:
            reader = pyglet.image.codecs.pypng.Reader(file=file)
            width, height, pixels, metadata = reader.read()
        except Exception, e:
            raise ImageDecodeException(
                'PyPNG cannot read %r: %s' % (filename or file, e))

        if metadata['greyscale']:
            if metadata['has_alpha']:
                format = 'LA'
            else:
                format = 'L'
        else:
            if metadata['has_alpha']:
                format = 'RGBA'
            else:
                format = 'RGB'
        pitch = len(format) * width
        return ImageData(width, height, format, pixels.tostring(), -pitch)

class PNGImageEncoder(ImageEncoder):
    def get_file_extensions(self):
        return ['.png']

    def encode(self, image, file, filename):
        image = image.get_image_data()

        has_alpha = 'A' in image.format
        greyscale = len(image.format) < 3
        if has_alpha:
            if greyscale:
                image.format = 'LA'
            else:
                image.format = 'RGBA'
        else:
            if greyscale:
                image.format = 'L'
            else:
                image.format = 'RGB'

        image.pitch = -(image.width * len(image.format))

        writer = pyglet.image.codecs.pypng.Writer(
            image.width, image.height,
            bytes_per_sample=1,
            greyscale=greyscale,
            has_alpha=has_alpha)

        data = array.array('B')
        data.fromstring(image.data)
        writer.write_array(file, data)

def get_decoders():
    return [PNGImageDecoder()]

def get_encoders():
    return [PNGImageEncoder()]

########NEW FILE########
__FILENAME__ = pypng
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
# png.py - PNG encoder in pure Python
# Copyright (C) 2006 Johann C. Rocholl <johann@browsershots.org>
# <ah> Modifications for pyglet by Alex Holkner <alex.holkner@gmail.com>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Contributors (alphabetical):
# Nicko van Someren <nicko@nicko.org>
#
# Changelog (recent first):
# 2006-06-17 Nicko: Reworked into a class, faster interlacing.
# 2006-06-17 Johann: Very simple prototype PNG decoder.
# 2006-06-17 Nicko: Test suite with various image generators.
# 2006-06-17 Nicko: Alpha-channel, grey-scale, 16-bit/plane support.
# 2006-06-15 Johann: Scanline iterator interface for large input files.
# 2006-06-09 Johann: Very simple prototype PNG encoder.


"""
Pure Python PNG Reader/Writer

This is an implementation of a subset of the PNG specification at
http://www.w3.org/TR/2003/REC-PNG-20031110 in pure Python. It reads
and writes PNG files with 8/16/24/32/48/64 bits per pixel (greyscale,
RGB, RGBA, with 8 or 16 bits per layer), with a number of options. For
help, type "import png; help(png)" in your python interpreter.

This file can also be used as a command-line utility to convert PNM
files to PNG. The interface is similar to that of the pnmtopng program
from the netpbm package. Type "python png.py --help" at the shell
prompt for usage and a list of options.
"""


__revision__ = '$Rev$'
__date__ = '$Date$'
__author__ = '$Author$'


import sys
import zlib
import struct
import math
from array import array


_adam7 = ((0, 0, 8, 8),
          (4, 0, 8, 8),
          (0, 4, 4, 8),
          (2, 0, 4, 4),
          (0, 2, 2, 4),
          (1, 0, 2, 2),
          (0, 1, 1, 2))


def interleave_planes(ipixels, apixels, ipsize, apsize):
    """
    Interleave color planes, e.g. RGB + A = RGBA.

    Return an array of pixels consisting of the ipsize bytes of data
    from each pixel in ipixels followed by the apsize bytes of data
    from each pixel in apixels, for an image of size width x height.
    """
    itotal = len(ipixels)
    atotal = len(apixels)
    newtotal = itotal + atotal
    newpsize = ipsize + apsize
    # Set up the output buffer
    out = array('B')
    # It's annoying that there is no cheap way to set the array size :-(
    out.extend(ipixels)
    out.extend(apixels)
    # Interleave in the pixel data
    for i in range(ipsize):
        out[i:newtotal:newpsize] = ipixels[i:itotal:ipsize]
    for i in range(apsize):
        out[i+ipsize:newtotal:newpsize] = apixels[i:atotal:apsize]
    return out

class Error(Exception):
    pass

class Writer:
    """
    PNG encoder in pure Python.
    """

    def __init__(self, width, height,
                 transparent=None,
                 background=None,
                 gamma=None,
                 greyscale=False,
                 has_alpha=False,
                 bytes_per_sample=1,
                 compression=None,
                 interlaced=False,
                 chunk_limit=2**20):
        """
        Create a PNG encoder object.

        Arguments:
        width, height - size of the image in pixels
        transparent - create a tRNS chunk
        background - create a bKGD chunk
        gamma - create a gAMA chunk
        greyscale - input data is greyscale, not RGB
        has_alpha - input data has alpha channel (RGBA)
        bytes_per_sample - 8-bit or 16-bit input data
        compression - zlib compression level (1-9)
        chunk_limit - write multiple IDAT chunks to save memory

        If specified, the transparent and background parameters must
        be a tuple with three integer values for red, green, blue, or
        a simple integer (or singleton tuple) for a greyscale image.

        If specified, the gamma parameter must be a float value.

        """
        if width <= 0 or height <= 0:
            raise ValueError("width and height must be greater than zero")

        if has_alpha and transparent is not None:
            raise ValueError(
                "transparent color not allowed with alpha channel")

        if bytes_per_sample < 1 or bytes_per_sample > 2:
            raise ValueError("bytes per sample must be 1 or 2")

        if transparent is not None:
            if greyscale:
                if type(transparent) is not int:
                    raise ValueError(
                        "transparent color for greyscale must be integer")
            else:
                if not (len(transparent) == 3 and
                        type(transparent[0]) is int and
                        type(transparent[1]) is int and
                        type(transparent[2]) is int):
                    raise ValueError(
                        "transparent color must be a triple of integers")

        if background is not None:
            if greyscale:
                if type(background) is not int:
                    raise ValueError(
                        "background color for greyscale must be integer")
            else:
                if not (len(background) == 3 and
                        type(background[0]) is int and
                        type(background[1]) is int and
                        type(background[2]) is int):
                    raise ValueError(
                        "background color must be a triple of integers")

        self.width = width
        self.height = height
        self.transparent = transparent
        self.background = background
        self.gamma = gamma
        self.greyscale = greyscale
        self.has_alpha = has_alpha
        self.bytes_per_sample = bytes_per_sample
        self.compression = compression
        self.chunk_limit = chunk_limit
        self.interlaced = interlaced

        if self.greyscale:
            self.color_depth = 1
            if self.has_alpha:
                self.color_type = 4
                self.psize = self.bytes_per_sample * 2
            else:
                self.color_type = 0
                self.psize = self.bytes_per_sample
        else:
            self.color_depth = 3
            if self.has_alpha:
                self.color_type = 6
                self.psize = self.bytes_per_sample * 4
            else:
                self.color_type = 2
                self.psize = self.bytes_per_sample * 3

    def write_chunk(self, outfile, tag, data):
        """
        Write a PNG chunk to the output file, including length and checksum.
        """
        # http://www.w3.org/TR/PNG/#5Chunk-layout
        outfile.write(struct.pack("!I", len(data)))
        outfile.write(tag)
        outfile.write(data)
        checksum = zlib.crc32(tag)
        checksum = zlib.crc32(data, checksum)
        # <ah> Avoid DeprecationWarning: struct integer overflow masking
        #      with Python2.5/Windows.
        checksum = checksum & 0xffffffff
        outfile.write(struct.pack("!I", checksum))

    def write(self, outfile, scanlines):
        """
        Write a PNG image to the output file.
        """
        # http://www.w3.org/TR/PNG/#5PNG-file-signature
        outfile.write(struct.pack("8B", 137, 80, 78, 71, 13, 10, 26, 10))

        # http://www.w3.org/TR/PNG/#11IHDR
        if self.interlaced:
            interlaced = 1
        else:
            interlaced = 0
        self.write_chunk(outfile, 'IHDR',
                         struct.pack("!2I5B", self.width, self.height,
                                     self.bytes_per_sample * 8,
                                     self.color_type, 0, 0, interlaced))

        # http://www.w3.org/TR/PNG/#11tRNS
        if self.transparent is not None:
            if self.greyscale:
                self.write_chunk(outfile, 'tRNS',
                                 struct.pack("!1H", *self.transparent))
            else:
                self.write_chunk(outfile, 'tRNS',
                                 struct.pack("!3H", *self.transparent))

        # http://www.w3.org/TR/PNG/#11bKGD
        if self.background is not None:
            if self.greyscale:
                self.write_chunk(outfile, 'bKGD',
                                 struct.pack("!1H", *self.background))
            else:
                self.write_chunk(outfile, 'bKGD',
                                 struct.pack("!3H", *self.background))

        # http://www.w3.org/TR/PNG/#11gAMA
        if self.gamma is not None:
            self.write_chunk(outfile, 'gAMA',
                             struct.pack("!L", int(self.gamma * 100000)))

        # http://www.w3.org/TR/PNG/#11IDAT
        if self.compression is not None:
            compressor = zlib.compressobj(self.compression)
        else:
            compressor = zlib.compressobj()

        data = array('B')
        for scanline in scanlines:
            data.append(0)
            data.extend(scanline)
            if len(data) > self.chunk_limit:
                compressed = compressor.compress(data.tostring())
                if len(compressed):
                    # print >> sys.stderr, len(data), len(compressed)
                    self.write_chunk(outfile, 'IDAT', compressed)
                data = array('B')
        if len(data):
            compressed = compressor.compress(data.tostring())
        else:
            compressed = ''
        flushed = compressor.flush()
        if len(compressed) or len(flushed):
            # print >> sys.stderr, len(data), len(compressed), len(flushed)
            self.write_chunk(outfile, 'IDAT', compressed + flushed)

        # http://www.w3.org/TR/PNG/#11IEND
        self.write_chunk(outfile, 'IEND', '')

    def write_array(self, outfile, pixels):
        """
        Encode a pixel array to PNG and write output file.
        """
        if self.interlaced:
            self.write(outfile, self.array_scanlines_interlace(pixels))
        else:
            self.write(outfile, self.array_scanlines(pixels))

    def convert_ppm(self, ppmfile, outfile):
        """
        Convert a PPM file containing raw pixel data into a PNG file
        with the parameters set in the writer object.
        """
        if self.interlaced:
            pixels = array('B')
            pixels.fromfile(ppmfile,
                            self.bytes_per_sample * self.color_depth *
                            self.width * self.height)
            self.write(outfile, self.array_scanlines_interlace(pixels))
        else:
            self.write(outfile, self.file_scanlines(ppmfile))

    def convert_ppm_and_pgm(self, ppmfile, pgmfile, outfile):
        """
        Convert a PPM and PGM file containing raw pixel data into a
        PNG outfile with the parameters set in the writer object.
        """
        pixels = array('B')
        pixels.fromfile(ppmfile,
                        self.bytes_per_sample * self.color_depth *
                        self.width * self.height)
        apixels = array('B')
        apixels.fromfile(pgmfile,
                         self.bytes_per_sample *
                         self.width * self.height)
        pixels = interleave_planes(pixels, apixels,
                                   self.bytes_per_sample * self.color_depth,
                                   self.bytes_per_sample)
        if self.interlaced:
            self.write(outfile, self.array_scanlines_interlace(pixels))
        else:
            self.write(outfile, self.array_scanlines(pixels))

    def file_scanlines(self, infile):
        """
        Generator for scanlines from an input file.
        """
        row_bytes = self.psize * self.width
        for y in range(self.height):
            scanline = array('B')
            scanline.fromfile(infile, row_bytes)
            yield scanline

    def array_scanlines(self, pixels):
        """
        Generator for scanlines from an array.
        """
        row_bytes = self.width * self.psize
        stop = 0
        for y in range(self.height):
            start = stop
            stop = start + row_bytes
            yield pixels[start:stop]

    def old_array_scanlines_interlace(self, pixels):
        """
        Generator for interlaced scanlines from an array.
        http://www.w3.org/TR/PNG/#8InterlaceMethods
        """
        row_bytes = self.psize * self.width
        for xstart, ystart, xstep, ystep in _adam7:
            for y in range(ystart, self.height, ystep):
                if xstart < self.width:
                    if xstep == 1:
                        offset = y*row_bytes
                        yield pixels[offset:offset+row_bytes]
                    else:
                        row = array('B')
                        offset = y*row_bytes + xstart* self.psize
                        skip = self.psize * xstep
                        for x in range(xstart, self.width, xstep):
                            row.extend(pixels[offset:offset + self.psize])
                            offset += skip
                        yield row

    def array_scanlines_interlace(self, pixels):
        """
        Generator for interlaced scanlines from an array.
        http://www.w3.org/TR/PNG/#8InterlaceMethods
        """
        row_bytes = self.psize * self.width
        for xstart, ystart, xstep, ystep in _adam7:
            for y in range(ystart, self.height, ystep):
                if xstart >= self.width:
                    continue
                if xstep == 1:
                    offset = y * row_bytes
                    yield pixels[offset:offset+row_bytes]
                else:
                    row = array('B')
                    # Note we want the ceiling of (self.width - xstart) / xtep
                    row_len = self.psize * (
                        (self.width - xstart + xstep - 1) / xstep)
                    # There's no easier way to set the length of an array
                    row.extend(pixels[0:row_len])
                    offset = y * row_bytes + xstart * self.psize
                    end_offset = (y+1) * row_bytes
                    skip = self.psize * xstep
                    for i in range(self.psize):
                        row[i:row_len:self.psize] = \
                            pixels[offset+i:end_offset:skip]
                    yield row

class _readable:
    """
    A simple file-like interface for strings and arrays.
    """

    def __init__(self, buf):
        self.buf = buf
        self.offset = 0

    def read(self, n):
        r = self.buf[offset:offset+n]
        if isinstance(r, array):
            r = r.tostring()
        self.offset += n
        return r

class Reader:
    """
    PNG decoder in pure Python.
    """

    def __init__(self, _guess=None, **kw):
        """
        Create a PNG decoder object.

        The constructor expects exactly one keyword argument. If you
        supply a positional argument instead, it will guess the input
        type. You can choose among the following arguments:
        filename - name of PNG input file
        file - object with a read() method
        pixels - array or string with PNG data

        """
        if ((_guess is not None and len(kw) != 0) or
            (_guess is None and len(kw) != 1)):
            raise TypeError("Reader() takes exactly 1 argument")

        if _guess is not None:
            if isinstance(_guess, array):
                kw["pixels"] = _guess
            elif isinstance(_guess, str):
                kw["filename"] = _guess
            elif isinstance(_guess, file):
                kw["file"] = _guess

        if "filename" in kw:
            self.file = file(kw["filename"])
        elif "file" in kw:
            self.file = kw["file"]
        elif "pixels" in kw:
            self.file = _readable(kw["pixels"])
        else:
            raise TypeError("expecting filename, file or pixels array")

    def read_chunk(self):
        """
        Read a PNG chunk from the input file, return tag name and data.
        """
        # http://www.w3.org/TR/PNG/#5Chunk-layout
        try:
            data_bytes, tag = struct.unpack('!I4s', self.file.read(8))
        except struct.error:
            raise ValueError('Chunk too short for header')
        data = self.file.read(data_bytes)
        if len(data) != data_bytes:
            raise ValueError('Chunk %s too short for required %i data octets'
                             % (tag, data_bytes))
        checksum = self.file.read(4)
        if len(checksum) != 4:
            raise ValueError('Chunk %s too short for checksum', tag)
        verify = zlib.crc32(tag)
        verify = zlib.crc32(data, verify)
        verify = struct.pack('!i', verify)
        if checksum != verify:
            # print repr(checksum)
            (a,) = struct.unpack('!I', checksum)
            (b,) = struct.unpack('!I', verify)
            raise ValueError("Checksum error in %s chunk: 0x%X != 0x%X"
                             % (tag, a, b))
        return tag, data

    def _reconstruct_sub(self, offset, xstep, ystep):
        """
        Reverse sub filter.
        """
        pixels = self.pixels
        a_offset = offset
        offset += self.psize * xstep
        if xstep == 1:
            for index in range(self.psize, self.row_bytes):
                x = pixels[offset]
                a = pixels[a_offset]
                pixels[offset] = (x + a) & 0xff
                offset += 1
                a_offset += 1
        else:
            byte_step = self.psize * xstep
            for index in range(byte_step, self.row_bytes, byte_step):
                for i in range(self.psize):
                    x = pixels[offset + i]
                    a = pixels[a_offset + i]
                    pixels[offset + i] = (x + a) & 0xff
                offset += self.psize * xstep
                a_offset += self.psize * xstep

    def _reconstruct_up(self, offset, xstep, ystep):
        """
        Reverse up filter.
        """
        pixels = self.pixels
        b_offset = offset - (self.row_bytes * ystep)
        if xstep == 1:
            for index in range(self.row_bytes):
                x = pixels[offset]
                b = pixels[b_offset]
                pixels[offset] = (x + b) & 0xff
                offset += 1
                b_offset += 1
        else:
            for index in range(0, self.row_bytes, xstep * self.psize):
                for i in range(self.psize):
                    x = pixels[offset + i]
                    b = pixels[b_offset + i]
                    pixels[offset + i] = (x + b) & 0xff
                offset += self.psize * xstep
                b_offset += self.psize * xstep

    def _reconstruct_average(self, offset, xstep, ystep):
        """
        Reverse average filter.
        """
        pixels = self.pixels
        a_offset = offset - (self.psize * xstep)
        b_offset = offset - (self.row_bytes * ystep)
        if xstep == 1:
            for index in range(self.row_bytes):
                x = pixels[offset]
                if index < self.psize:
                    a = 0
                else:
                    a = pixels[a_offset]
                if b_offset < 0:
                    b = 0
                else:
                    b = pixels[b_offset]
                pixels[offset] = (x + ((a + b) >> 1)) & 0xff
                offset += 1
                a_offset += 1
                b_offset += 1
        else:
            for index in range(0, self.row_bytes, self.psize * xstep):
                for i in range(self.psize):
                    x = pixels[offset+i]
                    if index < self.psize:
                        a = 0
                    else:
                        a = pixels[a_offset + i]
                    if b_offset < 0:
                        b = 0
                    else:
                        b = pixels[b_offset + i]
                    pixels[offset + i] = (x + ((a + b) >> 1)) & 0xff
                offset += self.psize * xstep
                a_offset += self.psize * xstep
                b_offset += self.psize * xstep

    def _reconstruct_paeth(self, offset, xstep, ystep):
        """
        Reverse Paeth filter.
        """
        pixels = self.pixels
        a_offset = offset - (self.psize * xstep)
        b_offset = offset - (self.row_bytes * ystep)
        c_offset = b_offset - (self.psize * xstep)
        # There's enough inside this loop that it's probably not worth
        # optimising for xstep == 1
        for index in range(0, self.row_bytes, self.psize * xstep):
            for i in range(self.psize):
                x = pixels[offset+i]
                if index < self.psize:
                    a = c = 0
                    b = pixels[b_offset+i]
                else:
                    a = pixels[a_offset+i]
                    b = pixels[b_offset+i]
                    c = pixels[c_offset+i]
                p = a + b - c
                pa = abs(p - a)
                pb = abs(p - b)
                pc = abs(p - c)
                if pa <= pb and pa <= pc:
                    pr = a
                elif pb <= pc:
                    pr = b
                else:
                    pr = c
                pixels[offset+i] = (x + pr) & 0xff
            offset += self.psize * xstep
            a_offset += self.psize * xstep
            b_offset += self.psize * xstep
            c_offset += self.psize * xstep

    # N.B. PNG files with 'up', 'average' or 'paeth' filters on the
    # first line of a pass are legal. The code above for 'average'
    # deals with this case explicitly. For up we map to the null
    # filter and for paeth we map to the sub filter.

    def reconstruct_line(self, filter_type, first_line, offset, xstep, ystep):
        # print >> sys.stderr, "Filter type %s, first_line=%s" % (
        #                      filter_type, first_line)
        filter_type += (first_line << 8)
        if filter_type == 1 or filter_type == 0x101 or filter_type == 0x104:
            self._reconstruct_sub(offset, xstep, ystep)
        elif filter_type == 2:
            self._reconstruct_up(offset, xstep, ystep)
        elif filter_type == 3 or filter_type == 0x103:
            self._reconstruct_average(offset, xstep, ystep)
        elif filter_type == 4:
            self._reconstruct_paeth(offset, xstep, ystep)
        return

    def deinterlace(self, scanlines):
        # print >> sys.stderr, ("Reading interlaced, w=%s, r=%s, planes=%s," +
        #     " bpp=%s") % (self.width, self.height, self.planes, self.bps)
        a = array('B')
        self.pixels = a
        # Make the array big enough
        temp = scanlines[0:self.width*self.height*self.psize]
        a.extend(temp)
        source_offset = 0
        for xstart, ystart, xstep, ystep in _adam7:
            # print >> sys.stderr, "Adam7: start=%s,%s step=%s,%s" % (
            #     xstart, ystart, xstep, ystep)
            filter_first_line = 1
            for y in range(ystart, self.height, ystep):
                if xstart >= self.width:
                    continue
                filter_type = scanlines[source_offset]
                source_offset += 1
                if xstep == 1:
                    offset = y * self.row_bytes
                    a[offset:offset+self.row_bytes] = \
                        scanlines[source_offset:source_offset + self.row_bytes]
                    source_offset += self.row_bytes
                else:
                    # Note we want the ceiling of (width - xstart) / xtep
                    row_len = self.psize * (
                        (self.width - xstart + xstep - 1) / xstep)
                    offset = y * self.row_bytes + xstart * self.psize
                    end_offset = (y+1) * self.row_bytes
                    skip = self.psize * xstep
                    for i in range(self.psize):
                        a[offset+i:end_offset:skip] = \
                            scanlines[source_offset + i:
                                      source_offset + row_len:
                                      self.psize]
                    source_offset += row_len
                if filter_type:
                    self.reconstruct_line(filter_type, filter_first_line,
                                          offset, xstep, ystep)
                filter_first_line = 0
        return a

    def read_flat(self, scanlines):
        a = array('B')
        self.pixels = a
        offset = 0
        source_offset = 0
        filter_first_line = 1
        for y in range(self.height):
            filter_type = scanlines[source_offset]
            source_offset += 1
            a.extend(scanlines[source_offset: source_offset + self.row_bytes])
            if filter_type:
                self.reconstruct_line(filter_type, filter_first_line,
                                      offset, 1, 1)
            filter_first_line = 0
            offset += self.row_bytes
            source_offset += self.row_bytes
        return a

    def read(self):
        """
        Read a simple PNG file, return width, height, pixels and image metadata

        This function is a very early prototype with limited flexibility
        and excessive use of memory.
        """
        signature = self.file.read(8)
        if (signature != struct.pack("8B", 137, 80, 78, 71, 13, 10, 26, 10)):
            raise Error("PNG file has invalid header")
        compressed = []
        image_metadata = {}
        while True:
            try:
                tag, data = self.read_chunk()
            except ValueError, e:
                raise Error('Chunk error: ' + e.args[0])

            # print >> sys.stderr, tag, len(data)
            if tag == 'IHDR': # http://www.w3.org/TR/PNG/#11IHDR
                (width, height, bits_per_sample, color_type,
                 compression_method, filter_method,
                 interlaced) = struct.unpack("!2I5B", data)
                bps = bits_per_sample / 8
                if bps == 0:
                    raise Error("unsupported pixel depth")
                if bps > 2 or bits_per_sample != (bps * 8):
                    raise Error("invalid pixel depth")
                if color_type == 0:
                    greyscale = True
                    has_alpha = False
                    planes = 1
                elif color_type == 2:
                    greyscale = False
                    has_alpha = False
                    planes = 3
                elif color_type == 4:
                    greyscale = True
                    has_alpha = True
                    planes = 2
                elif color_type == 6:
                    greyscale = False
                    has_alpha = True
                    planes = 4
                else:
                    raise Error("unknown PNG colour type %s" % color_type)
                if compression_method != 0:
                    raise Error("unknown compression method")
                if filter_method != 0:
                    raise Error("unknown filter method")
                self.bps = bps
                self.planes = planes
                self.psize = bps * planes
                self.width = width
                self.height = height
                self.row_bytes = width * self.psize
            elif tag == 'IDAT': # http://www.w3.org/TR/PNG/#11IDAT
                compressed.append(data)
            elif tag == 'bKGD':
                if greyscale:
                    image_metadata["background"] = struct.unpack("!1H", data)
                else:
                    image_metadata["background"] = struct.unpack("!3H", data)
            elif tag == 'tRNS':
                if greyscale:
                    image_metadata["transparent"] = struct.unpack("!1H", data)
                else:
                    image_metadata["transparent"] = struct.unpack("!3H", data)
            elif tag == 'gAMA':
                image_metadata["gamma"] = (
                    struct.unpack("!L", data)[0]) / 100000.0
            elif tag == 'IEND': # http://www.w3.org/TR/PNG/#11IEND
                break
        scanlines = array('B', zlib.decompress(''.join(compressed)))
        if interlaced:
            pixels = self.deinterlace(scanlines)
        else:
            pixels = self.read_flat(scanlines)
        image_metadata["greyscale"] = greyscale
        image_metadata["has_alpha"] = has_alpha
        image_metadata["bytes_per_sample"] = bps
        image_metadata["interlaced"] = interlaced
        return width, height, pixels, image_metadata


def test_suite(options):
    """
    Run regression test and write PNG file to stdout.
    """

    # Below is a big stack of test image generators

    def test_gradient_horizontal_lr(x, y):
        return x

    def test_gradient_horizontal_rl(x, y):
        return 1-x

    def test_gradient_vertical_tb(x, y):
        return y

    def test_gradient_vertical_bt(x, y):
        return 1-y

    def test_radial_tl(x, y):
        return max(1-math.sqrt(x*x+y*y), 0.0)

    def test_radial_center(x, y):
        return test_radial_tl(x-0.5, y-0.5)

    def test_radial_tr(x, y):
        return test_radial_tl(1-x, y)

    def test_radial_bl(x, y):
        return test_radial_tl(x, 1-y)

    def test_radial_br(x, y):
        return test_radial_tl(1-x, 1-y)

    def test_stripe(x, n):
        return 1.0*(int(x*n) & 1)

    def test_stripe_h_2(x, y):
        return test_stripe(x, 2)

    def test_stripe_h_4(x, y):
        return test_stripe(x, 4)

    def test_stripe_h_10(x, y):
        return test_stripe(x, 10)

    def test_stripe_v_2(x, y):
        return test_stripe(y, 2)

    def test_stripe_v_4(x, y):
        return test_stripe(y, 4)

    def test_stripe_v_10(x, y):
        return test_stripe(y, 10)

    def test_stripe_lr_10(x, y):
        return test_stripe(x+y, 10)

    def test_stripe_rl_10(x, y):
        return test_stripe(x-y, 10)

    def test_checker(x, y, n):
        return 1.0*((int(x*n) & 1) ^ (int(y*n) & 1))

    def test_checker_8(x, y):
        return test_checker(x, y, 8)

    def test_checker_15(x, y):
        return test_checker(x, y, 15)

    def test_zero(x, y):
        return 0

    def test_one(x, y):
        return 1

    test_patterns = {
        "GLR": test_gradient_horizontal_lr,
        "GRL": test_gradient_horizontal_rl,
        "GTB": test_gradient_vertical_tb,
        "GBT": test_gradient_vertical_bt,
        "RTL": test_radial_tl,
        "RTR": test_radial_tr,
        "RBL": test_radial_bl,
        "RBR": test_radial_br,
        "RCTR": test_radial_center,
        "HS2": test_stripe_h_2,
        "HS4": test_stripe_h_4,
        "HS10": test_stripe_h_10,
        "VS2": test_stripe_v_2,
        "VS4": test_stripe_v_4,
        "VS10": test_stripe_v_10,
        "LRS": test_stripe_lr_10,
        "RLS": test_stripe_rl_10,
        "CK8": test_checker_8,
        "CK15": test_checker_15,
        "ZERO": test_zero,
        "ONE": test_one,
        }

    def test_pattern(width, height, depth, pattern):
        a = array('B')
        fw = float(width)
        fh = float(height)
        pfun = test_patterns[pattern]
        if depth == 1:
            for y in range(height):
                for x in range(width):
                    a.append(int(pfun(float(x)/fw, float(y)/fh) * 255))
        elif depth == 2:
            for y in range(height):
                for x in range(width):
                    v = int(pfun(float(x)/fw, float(y)/fh) * 65535)
                    a.append(v >> 8)
                    a.append(v & 0xff)
        return a

    def test_rgba(size=256, depth=1,
                    red="GTB", green="GLR", blue="RTL", alpha=None):
        r = test_pattern(size, size, depth, red)
        g = test_pattern(size, size, depth, green)
        b = test_pattern(size, size, depth, blue)
        if alpha:
            a = test_pattern(size, size, depth, alpha)
        i = interleave_planes(r, g, depth, depth)
        i = interleave_planes(i, b, 2 * depth, depth)
        if alpha:
            i = interleave_planes(i, a, 3 * depth, depth)
        return i

    # The body of test_suite()
    size = 256
    if options.test_size:
        size = options.test_size
    depth = 1
    if options.test_deep:
        depth = 2

    kwargs = {}
    if options.test_red:
        kwargs["red"] = options.test_red
    if options.test_green:
        kwargs["green"] = options.test_green
    if options.test_blue:
        kwargs["blue"] = options.test_blue
    if options.test_alpha:
        kwargs["alpha"] = options.test_alpha
    pixels = test_rgba(size, depth, **kwargs)

    writer = Writer(size, size,
                    bytes_per_sample=depth,
                    transparent=options.transparent,
                    background=options.background,
                    gamma=options.gamma,
                    has_alpha=options.test_alpha,
                    compression=options.compression,
                    interlaced=options.interlace)
    writer.write_array(sys.stdout, pixels)


def read_pnm_header(infile, supported='P6'):
    """
    Read a PNM header, return width and height of the image in pixels.
    """
    header = []
    while len(header) < 4:
        line = infile.readline()
        sharp = line.find('#')
        if sharp > -1:
            line = line[:sharp]
        header.extend(line.split())
        if len(header) == 3 and header[0] == 'P4':
            break # PBM doesn't have maxval
    if header[0] not in supported:
        raise NotImplementedError('file format %s not supported' % header[0])
    if header[0] != 'P4' and header[3] != '255':
        raise NotImplementedError('maxval %s not supported' % header[3])
    return int(header[1]), int(header[2])


def color_triple(color):
    """
    Convert a command line color value to a RGB triple of integers.
    FIXME: Somewhere we need support for greyscale backgrounds etc.
    """
    if color.startswith('#') and len(color) == 4:
        return (int(color[1], 16),
                int(color[2], 16),
                int(color[3], 16))
    if color.startswith('#') and len(color) == 7:
        return (int(color[1:3], 16),
                int(color[3:5], 16),
                int(color[5:7], 16))
    elif color.startswith('#') and len(color) == 13:
        return (int(color[1:5], 16),
                int(color[5:9], 16),
                int(color[9:13], 16))


def _main():
    """
    Run the PNG encoder with options from the command line.
    """
    # Parse command line arguments
    from optparse import OptionParser
    version = '%prog ' + __revision__.strip('$').replace('Rev: ', 'r')
    parser = OptionParser(version=version)
    parser.set_usage("%prog [options] [pnmfile]")
    parser.add_option("-i", "--interlace",
                      default=False, action="store_true",
                      help="create an interlaced PNG file (Adam7)")
    parser.add_option("-t", "--transparent",
                      action="store", type="string", metavar="color",
                      help="mark the specified color as transparent")
    parser.add_option("-b", "--background",
                      action="store", type="string", metavar="color",
                      help="save the specified background color")
    parser.add_option("-a", "--alpha",
                      action="store", type="string", metavar="pgmfile",
                      help="alpha channel transparency (RGBA)")
    parser.add_option("-g", "--gamma",
                      action="store", type="float", metavar="value",
                      help="save the specified gamma value")
    parser.add_option("-c", "--compression",
                      action="store", type="int", metavar="level",
                      help="zlib compression level (0-9)")
    parser.add_option("-T", "--test",
                      default=False, action="store_true",
                      help="create a test image")
    parser.add_option("-R", "--test-red",
                      action="store", type="string", metavar="pattern",
                      help="test pattern for the red image layer")
    parser.add_option("-G", "--test-green",
                      action="store", type="string", metavar="pattern",
                      help="test pattern for the green image layer")
    parser.add_option("-B", "--test-blue",
                      action="store", type="string", metavar="pattern",
                      help="test pattern for the blue image layer")
    parser.add_option("-A", "--test-alpha",
                      action="store", type="string", metavar="pattern",
                      help="test pattern for the alpha image layer")
    parser.add_option("-D", "--test-deep",
                      default=False, action="store_true",
                      help="use test patterns with 16 bits per layer")
    parser.add_option("-S", "--test-size",
                      action="store", type="int", metavar="size",
                      help="width and height of the test image")
    (options, args) = parser.parse_args()

    # Convert options
    if options.transparent is not None:
        options.transparent = color_triple(options.transparent)
    if options.background is not None:
        options.background = color_triple(options.background)

    # Run regression tests
    if options.test:
        return test_suite(options)

    # Prepare input and output files
    if len(args) == 0:
        ppmfilename = '-'
        ppmfile = sys.stdin
    elif len(args) == 1:
        ppmfilename = args[0]
        ppmfile = open(ppmfilename, 'rb')
    else:
        parser.error("more than one input file")
    outfile = sys.stdout

    # Encode PNM to PNG
    width, height = read_pnm_header(ppmfile)
    writer = Writer(width, height,
                    transparent=options.transparent,
                    background=options.background,
                    has_alpha=options.alpha is not None,
                    gamma=options.gamma,
                    compression=options.compression)
    if options.alpha is not None:
        pgmfile = open(options.alpha, 'rb')
        awidth, aheight = read_pnm_header(pgmfile, 'P5')
        if (awidth, aheight) != (width, height):
            raise ValueError("alpha channel image size mismatch" +
                             " (%s has %sx%s but %s has %sx%s)"
                             % (ppmfilename, width, height,
                                options.alpha, awidth, aheight))
        writer.convert_ppm_and_pgm(ppmfile, pgmfile, outfile,
                           interlace=options.interlace)
    else:
        writer.convert_ppm(ppmfile, outfile,
                           interlace=options.interlace)


if __name__ == '__main__':
    _main()

########NEW FILE########
__FILENAME__ = quicktime
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: pil.py 163 2006-11-13 04:15:46Z Alex.Holkner $'

import sys

from ctypes import *

from pyglet.gl import *
from pyglet.image import *
from pyglet.image.codecs import *

from pyglet.window.carbon import carbon, quicktime, _oscheck
from pyglet.window.carbon.constants import _name
from pyglet.window.carbon.types import *

Handle = POINTER(POINTER(c_byte))

GWorldPtr = c_void_p
carbon.NewHandle.restype = Handle
HandleDataHandlerSubType = _name('hndl')
PointerDataHandlerSubType = _name('ptr ')
kDataHCanRead = 1
kDataRefExtensionFileName = _name('fnam')
kDataRefExtensionMIMEType = _name('mime')
ComponentInstance = c_void_p

k1MonochromePixelFormat       = 0x00000001
k2IndexedPixelFormat          = 0x00000002
k4IndexedPixelFormat          = 0x00000004
k8IndexedPixelFormat          = 0x00000008
k16BE555PixelFormat           = 0x00000010
k24RGBPixelFormat             = 0x00000018
k32ARGBPixelFormat            = 0x00000020
k32BGRAPixelFormat            = _name('BGRA')
k1IndexedGrayPixelFormat      = 0x00000021
k2IndexedGrayPixelFormat      = 0x00000022
k4IndexedGrayPixelFormat      = 0x00000024
k8IndexedGrayPixelFormat      = 0x00000028
kNativeEndianPixMap           = 1 << 8

newMovieActive                = 1
noErr                         = 0
movieTrackMediaType = 1 << 0
movieTrackCharacteristic = 1 << 1
movieTrackEnabledOnly = 1 << 2
VisualMediaCharacteristic = _name('eyes')
nextTimeMediaSample           = 1

class PointerDataRefRecord(Structure):
    _fields_ = [
        ('data', c_void_p),
        ('dataLength', c_long)
    ]

def Str255(value):
    return create_string_buffer(chr(len(value)) + value)

class QuickTimeImageDecoder(ImageDecoder):
    def get_file_extensions(self):
        # Only most common ones shown here
        return ['.bmp', '.cur', '.gif', '.ico', '.jpg', '.jpeg', '.pcx', '.png',
                '.tga', '.tif', '.tiff', '.xbm', '.xpm']

    def get_animation_file_extensions(self):
        return ['.gif']

    def _get_data_ref(self, file, filename):
        self._data_hold = data = create_string_buffer(file.read())

        dataref = carbon.NewHandle(sizeof(PointerDataRefRecord))
        datarec = cast(dataref,
            POINTER(POINTER(PointerDataRefRecord))).contents.contents
        datarec.data = addressof(data)
        datarec.dataLength = len(data)

        self._data_handler_holder = data_handler = ComponentInstance()
        r = quicktime.OpenADataHandler(dataref, PointerDataHandlerSubType,
            None, 0, None, kDataHCanRead, byref(data_handler))
        _oscheck(r)

        extension_handle = Handle()

        self._filename_hold = filename = Str255(filename)
        r = carbon.PtrToHand(filename, byref(extension_handle), len(filename))
        r = quicktime.DataHSetDataRefExtension(data_handler, extension_handle,
                                               kDataRefExtensionFileName)
        _oscheck(r)
        quicktime.DisposeHandle(extension_handle)

        quicktime.DisposeHandle(dataref)

        dataref = c_void_p()
        r = quicktime.DataHGetDataRef(data_handler, byref(dataref))
        _oscheck(r)

        quicktime.CloseComponent(data_handler)

        return dataref

    def _get_formats(self):
        # TODO choose 24 bit where appropriate.
        if sys.byteorder == 'big':
            format = 'ARGB'
            qtformat = k32ARGBPixelFormat
        else:
            format = 'BGRA'
            qtformat = k32BGRAPixelFormat
        return format, qtformat

    def decode(self, file, filename):
        dataref = self._get_data_ref(file, filename)
        importer = ComponentInstance()
        quicktime.GetGraphicsImporterForDataRef(dataref,
            PointerDataHandlerSubType, byref(importer))

        if not importer:
            raise ImageDecodeException(filename or file)

        rect = Rect()
        quicktime.GraphicsImportGetNaturalBounds(importer, byref(rect))
        width = rect.right
        height = rect.bottom

        format, qtformat = self._get_formats()

        buffer = (c_byte * (width * height * len(format)))()
        world = GWorldPtr()
        quicktime.QTNewGWorldFromPtr(byref(world), qtformat,
            byref(rect), c_void_p(), c_void_p(), 0, buffer,
            len(format) * width)

        quicktime.GraphicsImportSetGWorld(importer, world, c_void_p())
        result = quicktime.GraphicsImportDraw(importer)
        quicktime.DisposeGWorld(world)
        quicktime.CloseComponent(importer)

        if result != 0:
            raise ImageDecodeException(filename or file)

        pitch = len(format) * width

        return ImageData(width, height, format, buffer, -pitch)

    def decode_animation(self, file, filename):
        # TODO: Stop playing chicken with the GC
        # TODO: Cleanup in errors

        quicktime.EnterMovies()

        data_ref = self._get_data_ref(file, filename)
        if not data_ref:
            raise ImageDecodeException(filename or file)

        movie = c_void_p()
        id = c_short()
        result = quicktime.NewMovieFromDataRef(byref(movie),
                                      newMovieActive,
                                      0,
                                      data_ref,
                                      PointerDataHandlerSubType)

        if not movie:
            #_oscheck(result)
            raise ImageDecodeException(filename or file)
        quicktime.GoToBeginningOfMovie(movie)

        time_scale = float(quicktime.GetMovieTimeScale(movie))

        format, qtformat = self._get_formats()

        # Get movie width and height
        rect = Rect()
        quicktime.GetMovieBox(movie, byref(rect))
        width = rect.right
        height = rect.bottom
        pitch = len(format) * width

        # Set gworld
        buffer = (c_byte * (width * height * len(format)))()
        world = GWorldPtr()
        quicktime.QTNewGWorldFromPtr(byref(world), qtformat,
            byref(rect), c_void_p(), c_void_p(), 0, buffer,
            len(format) * width)
        quicktime.SetGWorld(world, 0)
        quicktime.SetMovieGWorld(movie, world, 0)

        visual = quicktime.GetMovieIndTrackType(movie, 1,
                                                VisualMediaCharacteristic,
                                                movieTrackCharacteristic)
        if not visual:
            raise ImageDecodeException('No video track')

        time = 0

        interesting_time = c_int()
        quicktime.GetTrackNextInterestingTime(
            visual,
            nextTimeMediaSample,
            time,
            1,
            byref(interesting_time),
            None)
        duration = interesting_time.value / time_scale

        frames = []

        while time >= 0:
            result = quicktime.GetMoviesError()
            if result == noErr:
                # force redraw
                result = quicktime.UpdateMovie(movie)
            if result == noErr:
                # process movie
                quicktime.MoviesTask(movie, 0)
                result = quicktime.GetMoviesError()
            _oscheck(result)

            buffer_copy = (c_byte * len(buffer))()
            memmove(buffer_copy, buffer, len(buffer))
            image = ImageData(width, height, format, buffer_copy, -pitch)
            frames.append(AnimationFrame(image, duration))

            interesting_time = c_int()
            duration = c_int()
            quicktime.GetTrackNextInterestingTime(
                visual,
                nextTimeMediaSample,
                time,
                1,
                byref(interesting_time),
                byref(duration))

            quicktime.SetMovieTimeValue(movie, interesting_time)
            time = interesting_time.value
            duration = duration.value / time_scale
            if duration <= 0.01:
                duration = 0.1

        quicktime.DisposeMovie(movie)
        carbon.DisposeHandle(data_ref)

        quicktime.ExitMovies()

        return Animation(frames)

def get_decoders():
    return [QuickTimeImageDecoder()]

def get_encoders():
    return []


########NEW FILE########
__FILENAME__ = s3tc
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
# $Id:$

'''Software decoder for S3TC compressed texture (i.e., DDS).

http://oss.sgi.com/projects/ogl-sample/registry/EXT/texture_compression_s3tc.txt
'''

import ctypes
import re

from pyglet.gl import *
from pyglet.gl import gl_info
from pyglet.image import AbstractImage, Texture

split_8byte = re.compile('.' * 8, flags=re.DOTALL)
split_16byte = re.compile('.' * 16, flags=re.DOTALL)

class PackedImageData(AbstractImage):
    _current_texture = None

    def __init__(self, width, height, format, packed_format, data):
        super(PackedImageData, self).__init__(width, height)
        self.format = format
        self.packed_format = packed_format
        self.data = data

    def unpack(self):
        if self.packed_format == GL_UNSIGNED_SHORT_5_6_5:
            # Unpack to GL_RGB.  Assume self.data is already 16-bit
            i = 0
            out = (c_ubyte * (self.width * self.height * 3))()
            for c in self.data:
                out[i+2] = (c & 0x1f) << 3
                out[i+1] = (c & 0x7e0) >> 3
                out[i] = (c & 0xf800) >> 8
                i += 3
            self.data = out
            self.packed_format = GL_UNSIGNED_BYTE

    def _get_texture(self):
        if self._current_texture:
            return self._current_texture

        texture = Texture.create_for_size(
            GL_TEXTURE_2D, self.width, self.height)
        glBindTexture(texture.target, texture.id)
        glTexParameteri(texture.target, GL_TEXTURE_MIN_FILTER, GL_LINEAR)

        if not gl_info.have_version(1, 2) or True:
            self.unpack()

        glTexImage2D(texture.target, texture.level,
            self.format, self.width, self.height, 0,
            self.format, self.packed_format, self.data)

        self._current_texture = texture
        return texture

    texture = property(_get_texture)

def decode_dxt1_rgb(data, width, height):
    # Decode to 16-bit RGB UNSIGNED_SHORT_5_6_5
    out = (ctypes.c_uint16 * (width * height))()

    # Read 8 bytes at a time
    image_offset = 0
    for c0_lo, c0_hi, c1_lo, c1_hi, b0, b1, b2, b3 in split_8byte.findall(data):
        color0 = ord(c0_lo) | ord(c0_hi) << 8
        color1 = ord(c1_lo) | ord(c1_hi) << 8
        bits = ord(b0) | ord(b1) << 8 | ord(b2) << 16 | ord(b3) << 24

        r0 = color0 & 0x1f
        g0 = (color0 & 0x7e0) >> 5
        b0 = (color0 & 0xf800) >> 11
        r1 = color1 & 0x1f
        g1 = (color1 & 0x7e0) >> 5
        b1 = (color1 & 0xf800) >> 11

        # i is the dest ptr for this block
        i = image_offset
        for y in range(4):
            for x in range(4):
                code = bits & 0x3

                if code == 0:
                    out[i] = color0
                elif code == 1:
                    out[i] = color1
                elif code == 3 and color0 <= color1:
                    out[i] = 0
                else:
                    if code == 2 and color0 > color1:
                        r = (2 * r0 + r1) / 3
                        g = (2 * g0 + g1) / 3
                        b = (2 * b0 + b1) / 3
                    elif code == 3 and color0 > color1:
                        r = (r0 + 2 * r1) / 3
                        g = (g0 + 2 * g1) / 3
                        b = (b0 + 2 * b1) / 3
                    else:
                        assert code == 2 and color0 <= color1
                        r = (r0 + r1) / 2
                        g = (g0 + g1) / 2
                        b = (b0 + b1) / 2
                    out[i] = r | g << 5 | b << 11

                bits >>= 2
                i += 1
            i += width - 4

        # Move dest ptr to next 4x4 block
        advance_row = (image_offset + 4) % width == 0
        image_offset += width * 3 * advance_row + 4

    return PackedImageData(width, height,
        GL_RGB, GL_UNSIGNED_SHORT_5_6_5, out)

def decode_dxt1_rgba(data, width, height):
    # Decode to GL_RGBA
    out = (ctypes.c_ubyte * (width * height * 4))()
    pitch = width << 2

    # Read 8 bytes at a time
    image_offset = 0
    for c0_lo, c0_hi, c1_lo, c1_hi, b0, b1, b2, b3 in split_8byte.findall(data):
        color0 = ord(c0_lo) | ord(c0_hi) << 8
        color1 = ord(c1_lo) | ord(c1_hi) << 8
        bits = ord(b0) | ord(b1) << 8 | ord(b2) << 16 | ord(b3) << 24

        r0 = color0 & 0x1f
        g0 = (color0 & 0x7e0) >> 5
        b0 = (color0 & 0xf800) >> 11
        r1 = color1 & 0x1f
        g1 = (color1 & 0x7e0) >> 5
        b1 = (color1 & 0xf800) >> 11

        # i is the dest ptr for this block
        i = image_offset
        for y in range(4):
            for x in range(4):
                code = bits & 0x3
                a = 255

                if code == 0:
                    r, g, b = r0, g0, b0
                elif code == 1:
                    r, g, b = r1, g1, b1
                elif code == 3 and color0 <= color1:
                    r = g = b = a = 0
                else:
                    if code == 2 and color0 > color1:
                        r = (2 * r0 + r1) / 3
                        g = (2 * g0 + g1) / 3
                        b = (2 * b0 + b1) / 3
                    elif code == 3 and color0 > color1:
                        r = (r0 + 2 * r1) / 3
                        g = (g0 + 2 * g1) / 3
                        b = (b0 + 2 * b1) / 3
                    else:
                        assert code == 2 and color0 <= color1
                        r = (r0 + r1) / 2
                        g = (g0 + g1) / 2
                        b = (b0 + b1) / 2

                out[i] = b << 3
                out[i+1] = g << 2
                out[i+2] = r << 3
                out[i+3] = a << 4

                bits >>= 2
                i += 4
            i += pitch - 16

        # Move dest ptr to next 4x4 block
        advance_row = (image_offset + 16) % pitch == 0
        image_offset += pitch * 3 * advance_row + 16

    return PackedImageData(width, height, GL_RGBA, GL_UNSIGNED_BYTE, out)


def decode_dxt3(data, width, height):
    # Decode to GL_RGBA
    out = (ctypes.c_ubyte * (width * height * 4))()
    pitch = width << 2

    # Read 16 bytes at a time
    image_offset = 0
    for (a0, a1, a2, a3, a4, a5, a6, a7,
         c0_lo, c0_hi, c1_lo, c1_hi,
         b0, b1, b2, b3) in split_16byte.findall(data):
        color0 = ord(c0_lo) | ord(c0_hi) << 8
        color1 = ord(c1_lo) | ord(c1_hi) << 8
        bits = ord(b0) | ord(b1) << 8 | ord(b2) << 16 | ord(b3) << 24
        alpha = ord(a0) | ord(a1) << 8 | ord(a2) << 16 | ord(a3) << 24 | \
            ord(a4) << 32 | ord(a5) << 40 | ord(a6) << 48 | ord(a7) << 56

        r0 = color0 & 0x1f
        g0 = (color0 & 0x7e0) >> 5
        b0 = (color0 & 0xf800) >> 11
        r1 = color1 & 0x1f
        g1 = (color1 & 0x7e0) >> 5
        b1 = (color1 & 0xf800) >> 11

        # i is the dest ptr for this block
        i = image_offset
        for y in range(4):
            for x in range(4):
                code = bits & 0x3
                a = alpha & 0xf

                if code == 0:
                    r, g, b = r0, g0, b0
                elif code == 1:
                    r, g, b = r1, g1, b1
                elif code == 3 and color0 <= color1:
                    r = g = b = 0
                else:
                    if code == 2 and color0 > color1:
                        r = (2 * r0 + r1) / 3
                        g = (2 * g0 + g1) / 3
                        b = (2 * b0 + b1) / 3
                    elif code == 3 and color0 > color1:
                        r = (r0 + 2 * r1) / 3
                        g = (g0 + 2 * g1) / 3
                        b = (b0 + 2 * b1) / 3
                    else:
                        assert code == 2 and color0 <= color1
                        r = (r0 + r1) / 2
                        g = (g0 + g1) / 2
                        b = (b0 + b1) / 2

                out[i] = b << 3
                out[i+1] = g << 2
                out[i+2] = r << 3
                out[i+3] = a << 4

                bits >>= 2
                alpha >>= 4
                i += 4
            i += pitch - 16

        # Move dest ptr to next 4x4 block
        advance_row = (image_offset + 16) % pitch == 0
        image_offset += pitch * 3 * advance_row + 16

    return PackedImageData(width, height, GL_RGBA, GL_UNSIGNED_BYTE, out)

def decode_dxt5(data, width, height):
    # Decode to GL_RGBA
    out = (ctypes.c_ubyte * (width * height * 4))()
    pitch = width << 2

    # Read 16 bytes at a time
    image_offset = 0
    for (alpha0, alpha1, ab0, ab1, ab2, ab3, ab4, ab5,
         c0_lo, c0_hi, c1_lo, c1_hi,
         b0, b1, b2, b3) in split_16byte.findall(data):
        color0 = ord(c0_lo) | ord(c0_hi) << 8
        color1 = ord(c1_lo) | ord(c1_hi) << 8
        alpha0 = ord(alpha0)
        alpha1 = ord(alpha1)
        bits = ord(b0) | ord(b1) << 8 | ord(b2) << 16 | ord(b3) << 24
        abits = ord(ab0) | ord(ab1) << 8 | ord(ab2) << 16 | ord(ab3) << 24 | \
            ord(ab4) << 32 | ord(ab5) << 40

        r0 = color0 & 0x1f
        g0 = (color0 & 0x7e0) >> 5
        b0 = (color0 & 0xf800) >> 11
        r1 = color1 & 0x1f
        g1 = (color1 & 0x7e0) >> 5
        b1 = (color1 & 0xf800) >> 11

        # i is the dest ptr for this block
        i = image_offset
        for y in range(4):
            for x in range(4):
                code = bits & 0x3
                acode = abits & 0x7

                if code == 0:
                    r, g, b = r0, g0, b0
                elif code == 1:
                    r, g, b = r1, g1, b1
                elif code == 3 and color0 <= color1:
                    r = g = b = 0
                else:
                    if code == 2 and color0 > color1:
                        r = (2 * r0 + r1) / 3
                        g = (2 * g0 + g1) / 3
                        b = (2 * b0 + b1) / 3
                    elif code == 3 and color0 > color1:
                        r = (r0 + 2 * r1) / 3
                        g = (g0 + 2 * g1) / 3
                        b = (b0 + 2 * b1) / 3
                    else:
                        assert code == 2 and color0 <= color1
                        r = (r0 + r1) / 2
                        g = (g0 + g1) / 2
                        b = (b0 + b1) / 2

                if acode == 0:
                    a = alpha0
                elif acode == 1:
                    a = alpha1
                elif alpha0 > alpha1:
                    if acode == 2:
                        a = (6 * alpha0 + 1 * alpha1) / 7
                    elif acode == 3:
                        a = (5 * alpha0 + 2 * alpha1) / 7
                    elif acode == 4:
                        a = (4 * alpha0 + 3 * alpha1) / 7
                    elif acode == 5:
                        a = (3 * alpha0 + 4 * alpha1) / 7
                    elif acode == 6:
                        a = (2 * alpha0 + 5 * alpha1) / 7
                    else:
                        assert acode == 7
                        a = (1 * alpha0 + 6 * alpha1) / 7
                else:
                    if acode == 2:
                        a = (4 * alpha0 + 1 * alpha1) / 5
                    elif acode == 3:
                        a = (3 * alpha0 + 2 * alpha1) / 5
                    elif acode == 4:
                        a = (2 * alpha0 + 3 * alpha1) / 5
                    elif acode == 5:
                        a = (1 * alpha0 + 4 * alpha1) / 5
                    elif acode == 6:
                        a = 0
                    else:
                        assert acode == 7
                        a = 255

                out[i] = b << 3
                out[i+1] = g << 2
                out[i+2] = r << 3
                out[i+3] = a

                bits >>= 2
                abits >>= 3
                i += 4
            i += pitch - 16

        # Move dest ptr to next 4x4 block
        advance_row = (image_offset + 16) % pitch == 0
        image_offset += pitch * 3 * advance_row + 16

    return PackedImageData(width, height, GL_RGBA, GL_UNSIGNED_BYTE, out)

########NEW FILE########
__FILENAME__ = info
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Get environment information useful for debugging.

Intended usage is to create a file for bug reports, e.g.::

    python -m pyglet.info > info.txt

'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'


def _print(*args):
    _dumped.append(u' '.join([str(i) for i in args]))
_dumped = []


def _heading(heading):
    global _first_heading
    if not _first_heading:
        _print()
    else:
        _first_heading = False
    _print(heading)
    _print('-' * 78)
_first_heading = True


def dump_python():
    '''Dump Python version and environment to stdout.'''
    import os
    import sys
    _print('sys.version:', sys.version)
    _print('sys.platform:', sys.platform)
    _print('os.getcwd():', os.getcwd())
    for key, value in os.environ.items():
        if key.startswith('PYGLET_'):
            _print("os.environ['%s']: %s" % (key, value))


def dump_pyglet():
    '''Dump pyglet version and options.'''
    import pyglet
    _print('pyglet.version:', pyglet.version)
    _print('pyglet.__file__:', pyglet.__file__)
    for key, value in pyglet.options.items():
        _print("pyglet.options['%s'] = %r" % (key, value))


def dump_window():
    '''Dump display, window, screen and default config info.'''
    import pyglet.window
    platform = pyglet.window.get_platform()
    _print('platform:', repr(platform))
    display = platform.get_default_display()
    _print('display:', repr(display))
    screens = display.get_screens()
    for i, screen in enumerate(screens):
        _print('screens[%d]: %r' % (i, screen))

    _print('window config omitted.')
    '''
    window = pyglet.window.Window(visible=False)
    for key, value in window.config.get_gl_attributes():
        _print("config['%s'] = %r" % (key, value))
    _print('context:', repr(window.context))
    window.close()
    '''


def dump_gl():
    '''Dump GL info.'''
    from pyglet.gl import gl_info
    _print('gl_info.get_version():',  gl_info.get_version())
    _print('gl_info.get_vendor():',  gl_info.get_vendor())
    _print('gl_info.get_renderer():',  gl_info.get_renderer())
    _print('gl_info.get_extensions():')
    extensions = list(gl_info.get_extensions())
    extensions.sort()
    for name in extensions:
        _print('  ', name)


def dump_glu():
    '''Dump GLU info.'''
    from pyglet.gl import glu_info
    _print('glu_info.get_version():',  glu_info.get_version())
    _print('glu_info.get_extensions():')
    extensions = list(glu_info.get_extensions())
    extensions.sort()
    for name in extensions:
        _print('  ', name)


def dump_glx():
    '''Dump GLX info.'''
    try:
        from pyglet.gl import glx_info
    except:
        _print('GLX not available.')
        return
    import pyglet
    window = pyglet.window.Window(visible=False)
    _print('context.is_direct():', window.context.is_direct())
    window.close()

    if not glx_info.have_version(1, 1):
        _print('Version: < 1.1')
    else:
        _print('glx_info.get_server_vendor():', glx_info.get_server_vendor())
        _print('glx_info.get_server_version():', glx_info.get_server_version())
        _print('glx_info.get_server_extensions():')
        for name in glx_info.get_server_extensions():
            _print('  ', name)
        _print('glx_info.get_client_vendor():', glx_info.get_client_vendor())
        _print('glx_info.get_client_version():', glx_info.get_client_version())
        _print('glx_info.get_client_extensions():')
        for name in glx_info.get_client_extensions():
            _print('  ', name)
        _print('glx_info.get_extensions():')
        for name in glx_info.get_extensions():
            _print('  ', name)


def dump_media():
    '''Dump pyglet.media info.'''
    import pyglet.media
    _print('driver:', pyglet.media.driver.__name__)


def dump_avbin():
    '''Dump AVbin info.'''
    try:
        import pyglet.media.avbin
        _print('Library:', pyglet.media.avbin.av)
        _print('AVbin version:', pyglet.media.avbin.av.avbin_get_version())
        _print('FFmpeg revision:',
            pyglet.media.avbin.av.avbin_get_ffmpeg_revision())
    except:
        _print('AVbin not available.')


def dump_al():
    '''Dump OpenAL info.'''
    try:
        from pyglet.media.drivers import openal
        _print('Library:', openal.al._lib)
        _print('Version:', openal.get_version())
        _print('Extensions:')
        for extension in openal.get_extensions():
            _print('  ', extension)
    except:
        _print('OpenAL not available.')


def _try_dump(heading, func):
    _heading(heading)
    try:
        func()
    except:
        import traceback
        _print(traceback.format_exc())


def dump():
    '''Dump all information to stdout.'''
    _try_dump('Python', dump_python)
    _try_dump('pyglet', dump_pyglet)
    _try_dump('pyglet.window', dump_window)
    _try_dump('pyglet.gl.gl_info', dump_gl)
    _try_dump('pyglet.gl.glu_info', dump_glu)
    _try_dump('pyglet.gl.glx_info', dump_glx)
    _try_dump('pyglet.media', dump_media)
    _try_dump('pyglet.media.avbin', dump_avbin)
    _try_dump('pyglet.media.drivers.openal', dump_al)

    return u'\n'.join(_dumped)

if __name__ == '__main__':
    print dump()

########NEW FILE########
__FILENAME__ = lib
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Functions for loading dynamic libraries.

These extend and correct ctypes functions.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import os
import re
import sys

import ctypes
import ctypes.util

import pyglet

_debug_lib = pyglet.options['debug_lib']
_debug_trace = pyglet.options['debug_trace']

class _TraceFunction(object):
    def __init__(self, func):
        self.__dict__['_func'] = func

    def __str__(self):
        return self._func.__name__

    def __call__(self, *args, **kwargs):
        return self._func(*args, **kwargs)

    def __getattr__(self, name):
        return getattr(self._func, name)

    def __setattr__(self, name, value):
        setattr(self._func, name, value)

class _TraceLibrary(object):
    def __init__(self, library):
        self._library = library
        print library

    def __getattr__(self, name):
        func = getattr(self._library, name)
        f = _TraceFunction(func)
        return f

class LibraryLoader(object):
    def load_library(self, *names, **kwargs):
        '''Find and load a library.

        More than one name can be specified, they will be tried in order.
        Platform-specific library names (given as kwargs) are tried first.

        Raises ImportError if library is not found.
        '''
        if 'framework' in kwargs and self.platform == 'darwin':
            return self.load_framework(kwargs['framework'])

        platform_names = kwargs.get(self.platform, [])
        if type(platform_names) in (str, unicode):
            platform_names = [platform_names]
        elif type(platform_names) is tuple:
            platform_names = list(platform_names)

        if self.platform == 'linux2':
            for name in names:
                libname = ctypes.util.find_library(name)
                platform_names.append(libname or 'lib%s.so' % name)

        platform_names.extend(names)
        for name in platform_names:
            try:
                lib = ctypes.cdll.LoadLibrary(name)
                if _debug_lib:
                    print name
                if _debug_trace:
                    lib = _TraceLibrary(lib)
                return lib
            except OSError:
                path = self.find_library(name)
                if path:
                    try:
                        lib = ctypes.cdll.LoadLibrary(path)
                        if _debug_lib:
                            print path
                        if _debug_trace:
                            lib = _TraceLibrary(lib)
                        return lib
                    except OSError:
                        pass
        raise ImportError('Library "%s" not found.' % names[0])

    find_library = lambda self, name: ctypes.util.find_library(name)

    platform = sys.platform
    if platform == 'cygwin':
        platform = 'win32'

    def load_framework(self, path):
        raise RuntimeError("Can't load framework on this platform.")

class MachOLibraryLoader(LibraryLoader):
    def __init__(self):
        if 'LD_LIBRARY_PATH' in os.environ:
            self.ld_library_path = os.environ['LD_LIBRARY_PATH'].split(':')
        else:
            self.ld_library_path = []

        if 'DYLD_LIBRARY_PATH' in os.environ:
            self.dyld_library_path = os.environ['DYLD_LIBRARY_PATH'].split(':')
        else:
            self.dyld_library_path = []

        if 'DYLD_FALLBACK_LIBRARY_PATH' in os.environ:
            self.dyld_fallback_library_path = \
                os.environ['DYLD_FALLBACK_LIBRARY_PATH'].split(':')
        else:
            self.dyld_fallback_library_path = [
                os.path.expanduser('~/lib'),
                '/usr/local/lib',
                '/usr/lib']

    def find_library(self, path):
        '''Implements the dylib search as specified in Apple documentation:

        http://developer.apple.com/documentation/DeveloperTools/Conceptual/DynamicLibraries/Articles/DynamicLibraryUsageGuidelines.html

        Before commencing the standard search, the method first checks
        the bundle's ``Frameworks`` directory if the application is running
        within a bundle (OS X .app).
        '''

        libname = os.path.basename(path)
        search_path = []

        if hasattr(sys, 'frozen') and sys.frozen == 'macosx_app':
            search_path.append(os.path.join(
                os.environ['RESOURCEPATH'],
                '..',
                'Frameworks',
                libname))

        if '/' in path:
            search_path.extend(
                [os.path.join(p, libname) \
                    for p in self.dyld_library_path])
            search_path.append(path)
            search_path.extend(
                [os.path.join(p, libname) \
                    for p in self.dyld_fallback_library_path])
        else:
            search_path.extend(
                [os.path.join(p, libname) \
                    for p in self.ld_library_path])
            search_path.extend(
                [os.path.join(p, libname) \
                    for p in self.dyld_library_path])
            search_path.append(path)
            search_path.extend(
                [os.path.join(p, libname) \
                    for p in self.dyld_fallback_library_path])

        for path in search_path:
            if os.path.exists(path):
                return path

        return None

    def find_framework(self, path):
        '''Implement runtime framework search as described by:

        http://developer.apple.com/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkBinding.html
        '''

        # e.g. path == '/System/Library/Frameworks/OpenGL.framework'
        #      name == 'OpenGL'
        # return '/System/Library/Frameworks/OpenGL.framework/OpenGL'
        name = os.path.splitext(os.path.split(path)[1])[0]

        realpath = os.path.join(path, name)
        if os.path.exists(realpath):
            return realpath

        for dir in ('/Library/Frameworks',
                    '/System/Library/Frameworks'):
            realpath = os.path.join(dir, '%s.framework' % name, name)
            if os.path.exists(realpath):
                return realpath

        return None

    def load_framework(self, path):
        realpath = self.find_framework(path)
        if realpath:
            lib = ctypes.cdll.LoadLibrary(realpath)
            if _debug_lib:
                print realpath
            if _debug_trace:
                lib = _TraceLibrary(lib)
            return lib

        raise ImportError("Can't find framework %s." % path)

class LinuxLibraryLoader(LibraryLoader):
    _ld_so_cache = None

    def _create_ld_so_cache(self):
        # Recreate search path followed by ld.so.  This is going to be
        # slow to build, and incorrect (ld.so uses ld.so.cache, which may
        # not be up-to-date).  Used only as fallback for distros without
        # /sbin/ldconfig.
        #
        # We assume the DT_RPATH and DT_RUNPATH binary sections are omitted.

        directories = []
        try:
            directories.extend(os.environ['LD_LIBRARY_PATH'].split(':'))
        except KeyError:
            pass

        try:
            directories.extend([dir.strip() for dir in open('/etc/ld.so.conf')])
        except IOError:
            pass

        directories.extend(['/lib', '/usr/lib'])

        cache = {}
        lib_re = re.compile('lib(.*)\.so')
        for dir in directories:
            try:
                for file in os.listdir(dir):
                    if '.so' not in file:
                        continue

                    # Index by filename
                    path = os.path.join(dir, file)
                    if file not in cache:
                        cache[file] = path

                    # Index by library name
                    match = lib_re.match(file)
                    if match:
                        library = match.group(1)
                        if library not in cache:
                            cache[library] = path
            except OSError:
                pass

        self._ld_so_cache = cache

    def find_library(self, path):
        # ctypes tries ldconfig, gcc and objdump.  If none of these are
        # present, we implement the ld-linux.so search path as described in
        # the man page.

        result = ctypes.util.find_library(path)
        if result:
            return result

        if self._ld_so_cache is None:
            self._create_ld_so_cache()

        return self._ld_so_cache.get(path)

if sys.platform == 'darwin':
    loader = MachOLibraryLoader()
elif sys.platform == 'linux2':
    loader = LinuxLibraryLoader()
else:
    loader = LibraryLoader()
load_library = loader.load_library

########NEW FILE########
__FILENAME__ = avbin
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Use avbin to decode audio and video media.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: avbin.py 2084 2008-05-27 12:42:19Z Alex.Holkner $'

from pyglet.media import (MediaFormatException, StreamingSource,
                          VideoFormat, AudioFormat, AudioData)

import pyglet
from pyglet import gl
from pyglet.gl import gl_info
from pyglet import image
import pyglet.lib

import ctypes

av = pyglet.lib.load_library('avbin',
                             darwin='/usr/local/lib/libavbin.dylib')

AVBIN_RESULT_ERROR = -1
AVBIN_RESULT_OK = 0
AVbinResult = ctypes.c_int

AVBIN_STREAM_TYPE_UNKNOWN = 0
AVBIN_STREAM_TYPE_VIDEO = 1
AVBIN_STREAM_TYPE_AUDIO = 2
AVbinStreamType = ctypes.c_int

AVBIN_SAMPLE_FORMAT_U8 = 0
AVBIN_SAMPLE_FORMAT_S16 = 1
AVBIN_SAMPLE_FORMAT_S24 = 2
AVBIN_SAMPLE_FORMAT_S32 = 3
AVBIN_SAMPLE_FORMAT_FLOAT = 4
AVbinSampleFormat = ctypes.c_int

AVBIN_LOG_QUIET = -8
AVBIN_LOG_PANIC = 0
AVBIN_LOG_FATAL = 8
AVBIN_LOG_ERROR = 16
AVBIN_LOG_WARNING = 24
AVBIN_LOG_INFO = 32
AVBIN_LOG_VERBOSE = 40
AVBIN_LOG_DEBUG = 48
AVbinLogLevel = ctypes.c_int

AVbinFileP = ctypes.c_void_p
AVbinStreamP = ctypes.c_void_p

Timestamp = ctypes.c_int64

class AVbinFileInfo(ctypes.Structure):
    _fields_ = [
        ('structure_size', ctypes.c_size_t),
        ('n_streams', ctypes.c_int),
        ('start_time', Timestamp),
        ('duration', Timestamp),
        ('title', ctypes.c_char * 512),
        ('author', ctypes.c_char * 512),
        ('copyright', ctypes.c_char * 512),
        ('comment', ctypes.c_char * 512),
        ('album', ctypes.c_char * 512),
        ('year', ctypes.c_int),
        ('track', ctypes.c_int),
        ('genre', ctypes.c_char * 32),
    ]

class _AVbinStreamInfoVideo(ctypes.Structure):
    _fields_ = [
        ('width', ctypes.c_uint),
        ('height', ctypes.c_uint),
        ('sample_aspect_num', ctypes.c_int),
        ('sample_aspect_den', ctypes.c_int),
    ]

class _AVbinStreamInfoAudio(ctypes.Structure):
    _fields_ = [
        ('sample_format', ctypes.c_int),
        ('sample_rate', ctypes.c_uint),
        ('sample_bits', ctypes.c_uint),
        ('channels', ctypes.c_uint),
    ]

class _AVbinStreamInfoUnion(ctypes.Union):
    _fields_ = [
        ('video', _AVbinStreamInfoVideo),
        ('audio', _AVbinStreamInfoAudio),
    ]

class AVbinStreamInfo(ctypes.Structure):
    _fields_ = [
        ('structure_size', ctypes.c_size_t),
        ('type', ctypes.c_int),
        ('u', _AVbinStreamInfoUnion)
    ]

class AVbinPacket(ctypes.Structure):
    _fields_ = [
        ('structure_size', ctypes.c_size_t),
        ('timestamp', Timestamp),
        ('stream_index', ctypes.c_int),
        ('data', ctypes.POINTER(ctypes.c_uint8)),
        ('size', ctypes.c_size_t),
    ]

AVbinLogCallback = ctypes.CFUNCTYPE(None,
    ctypes.c_char_p, ctypes.c_int, ctypes.c_char_p)

av.avbin_get_version.restype = ctypes.c_int
av.avbin_get_ffmpeg_revision.restype = ctypes.c_int
av.avbin_get_audio_buffer_size.restype = ctypes.c_size_t
av.avbin_have_feature.restype = ctypes.c_int
av.avbin_have_feature.argtypes = [ctypes.c_char_p]

av.avbin_init.restype = AVbinResult
av.avbin_set_log_level.restype = AVbinResult
av.avbin_set_log_level.argtypes = [AVbinLogLevel]
av.avbin_set_log_callback.argtypes = [AVbinLogCallback]

av.avbin_open_filename.restype = AVbinFileP
av.avbin_open_filename.argtypes = [ctypes.c_char_p]
av.avbin_close_file.argtypes = [AVbinFileP]
av.avbin_seek_file.argtypes = [AVbinFileP, Timestamp]
av.avbin_file_info.argtypes = [AVbinFileP, ctypes.POINTER(AVbinFileInfo)]
av.avbin_stream_info.argtypes = [AVbinFileP, ctypes.c_int,
                                 ctypes.POINTER(AVbinStreamInfo)]

av.avbin_open_stream.restype = ctypes.c_void_p
av.avbin_open_stream.argtypes = [AVbinFileP, ctypes.c_int]
av.avbin_close_stream.argtypes = [AVbinStreamP]

av.avbin_read.argtypes = [AVbinFileP, ctypes.POINTER(AVbinPacket)]
av.avbin_read.restype = AVbinResult
av.avbin_decode_audio.restype = ctypes.c_int
av.avbin_decode_audio.argtypes = [AVbinStreamP,
    ctypes.c_void_p, ctypes.c_size_t,
    ctypes.c_void_p, ctypes.POINTER(ctypes.c_int)]
av.avbin_decode_video.restype = ctypes.c_int
av.avbin_decode_video.argtypes = [AVbinStreamP,
    ctypes.c_void_p, ctypes.c_size_t,
    ctypes.c_void_p]

def get_version():
    return av.avbin_get_version()

class AVbinException(MediaFormatException):
    pass

def timestamp_from_avbin(timestamp):
    return float(timestamp) / 1000000

def timestamp_to_avbin(timestamp):
    return int(timestamp * 1000000)

class BufferedPacket(object):
    def __init__(self, packet):
        self.timestamp = packet.timestamp
        self.stream_index = packet.stream_index
        self.data = (ctypes.c_uint8 * packet.size)()
        self.size = packet.size
        ctypes.memmove(self.data, packet.data, self.size)

class BufferedImage(object):
    def __init__(self, image, timestamp):
        self.image = image
        self.timestamp = timestamp

class AVbinSource(StreamingSource):
    def __init__(self, filename, file=None):
        if file is not None:
            raise NotImplementedError('TODO: Load from file stream')

        self._file = av.avbin_open_filename(filename)
        if not self._file:
            raise AVbinException('Could not open "%s"' % filename)

        self._video_stream = None
        self._audio_stream = None

        file_info = AVbinFileInfo()
        file_info.structure_size = ctypes.sizeof(file_info)
        av.avbin_file_info(self._file, ctypes.byref(file_info))
        self._duration = timestamp_from_avbin(file_info.duration)

        # Pick the first video and audio streams found, ignore others.
        for i in range(file_info.n_streams):
            info = AVbinStreamInfo()
            info.structure_size = ctypes.sizeof(info)
            av.avbin_stream_info(self._file, i, info)

            if (info.type == AVBIN_STREAM_TYPE_VIDEO and
                not self._video_stream):

                stream = av.avbin_open_stream(self._file, i)
                if not stream:
                    continue

                self.video_format = VideoFormat(
                    width=info.u.video.width,
                    height=info.u.video.height)
                if info.u.video.sample_aspect_num != 0:
                    self.video_format.sample_aspect = (
                        float(info.u.video.sample_aspect_num) /
                            info.u.video.sample_aspect_den)
                self._video_stream = stream
                self._video_stream_index = i

            elif (info.type == AVBIN_STREAM_TYPE_AUDIO and
                  info.u.audio.sample_bits in (8, 16) and
                  info.u.audio.channels in (1, 2) and
                  not self._audio_stream):

                stream = av.avbin_open_stream(self._file, i)
                if not stream:
                    continue

                self.audio_format = AudioFormat(
                    channels=info.u.audio.channels,
                    sample_size=info.u.audio.sample_bits,
                    sample_rate=info.u.audio.sample_rate)
                self._audio_stream = stream
                self._audio_stream_index = i

        self._packet = AVbinPacket()
        self._packet.structure_size = ctypes.sizeof(self._packet)
        self._packet.stream_index = -1
        self._buffered_packets = []

        self._buffer_streams = []
        self._buffered_images = []
        if self.audio_format:
            self._audio_packet_ptr = 0
            self._audio_packet_size = 0
            self._audio_packet_timestamp = 0
            self._audio_buffer = \
                (ctypes.c_uint8 * av.avbin_get_audio_buffer_size())()
            self._buffer_streams.append(self._audio_stream_index)

        if self.video_format:
            self._buffer_streams.append(self._video_stream_index)
            self._force_next_video_image = True
            self._last_video_timestamp = None

    def __del__(self):
        try:
            if self._video_stream:
                av.avbin_close_stream(self._video_stream)
            if self._audio_stream:
                av.avbin_close_stream(self._audio_stream)
            av.avbin_close_file(self._file)
        except:
            pass

    def _seek(self, timestamp):
        av.avbin_seek_file(self._file, timestamp_to_avbin(timestamp))
        self._buffered_packets = []
        self._buffered_images = []
        self._audio_packet_size = 0
        self._force_next_video_image = True
        self._last_video_timestamp = None

    def _get_packet_for_stream(self, stream_index):
        # See if a packet has already been buffered
        for packet in self._buffered_packets:
            if packet.stream_index == stream_index:
                self._buffered_packets.remove(packet)
                return packet

        # XXX This is ugly and needs tuning per-codec.  Replace with an
        # explicit API for disabling unused streams (e.g. for silent driver).
        '''
        # Make sure we're not buffering packets that are being ignored
        for buffer in self._buffered_packets, self._buffered_images:
            if len(buffer) > 20:
                buffer.pop(0)
        '''

        # Read more packets, buffering each interesting one until we get to
        # the one we want or reach end of file.
        while True:
            if av.avbin_read(self._file, self._packet) != AVBIN_RESULT_OK:
                return None
            elif self._packet.stream_index == stream_index:
                return self._packet
            elif self._packet.stream_index == self._video_stream_index:
                buffered_image = self._decode_video_packet(self._packet)
                if buffered_image:
                    self._buffered_images.append(buffered_image)
            elif self._packet.stream_index in self._buffer_streams:
                self._buffered_packets.append(BufferedPacket(self._packet))

    def _get_audio_data(self, bytes):
        # XXX bytes currently ignored
        while True:
            while self._audio_packet_size > 0:
                size_out = ctypes.c_int(len(self._audio_buffer))

                #print self._audio_stream, self._audio_packet_ptr, self._audio_packet_size, self._audio_buffer, size_out
                used = av.avbin_decode_audio(self._audio_stream,
                    self._audio_packet_ptr, self._audio_packet_size,
                    self._audio_buffer, size_out)

                if used < 0:
                    self._audio_packet_size = 0
                    break

                self._audio_packet_ptr.value += used
                self._audio_packet_size -= used

                if size_out.value <= 0:
                    continue

                buffer = ctypes.string_at(self._audio_buffer, size_out)
                duration = \
                    float(len(buffer)) / self.audio_format.bytes_per_second
                timestamp = self._audio_packet_timestamp
                self._audio_packet_timestamp += duration
                return AudioData(buffer, len(buffer), timestamp, duration)

            packet = self._get_packet_for_stream(self._audio_stream_index)
            if not packet:
                return None

            self._audio_packet_timestamp = \
                timestamp_from_avbin(packet.timestamp)
            self._audio_packet = packet # keep from GC
            self._audio_packet_ptr = ctypes.cast(packet.data,
                                                 ctypes.c_void_p)
            self._audio_packet_size = packet.size

    def _init_texture(self, player):
        if not self.video_format:
            return

        width = self.video_format.width
        height = self.video_format.height
        if gl_info.have_extension('GL_ARB_texture_rectangle'):
            texture = image.Texture.create_for_size(
                gl.GL_TEXTURE_RECTANGLE_ARB, width, height,
                internalformat=gl.GL_RGB)
        else:
            texture = image.Texture.create_for_size(
                gl.GL_TEXTURE_2D, width, height, internalformat=gl.GL_RGB)
            if texture.width != width or texture.height != height:
                texture = texture.get_region(0, 0, width, height)
        player._texture = texture

        # Flip texture coords (good enough for simple apps).
        t = list(player._texture.tex_coords)
        player._texture.tex_coords = t[9:12] + t[6:9] + t[3:6] + t[:3]

    def _decode_video_packet(self, packet):
        timestamp = timestamp_from_avbin(packet.timestamp)

        width = self.video_format.width
        height = self.video_format.height
        pitch = width * 3
        buffer = (ctypes.c_uint8 * (pitch * height))()
        result = av.avbin_decode_video(self._video_stream,
                                       packet.data, packet.size,
                                       buffer)
        if result < 0:
            return None

        return BufferedImage(
            image.ImageData(width, height, 'RGB', buffer, pitch),
            timestamp)

    def _next_image(self):
        img = None
        while not img:
            packet = self._get_packet_for_stream(self._video_stream_index)
            if not packet:
                return
            img = self._decode_video_packet(packet)

        return img

    def get_next_video_timestamp(self):
        if not self.video_format:
            return

        try:
            img = self._buffered_images[0]
        except IndexError:
            img = self._next_image()
            self._buffered_images.append(img)

        if img:
            return img.timestamp

    def get_next_video_frame(self):
        if not self.video_format:
            return

        try:
            img = self._buffered_images.pop(0)
        except IndexError:
            img = self._next_image()

        if img:
            self._last_video_timestamp = img.timestamp
            self._force_next_video_image = False
            return img.image

    def _update_texture(self, player, timestamp):
        if not self.video_format:
            return

        if self._last_video_timestamp > timestamp:
            return

        img = None
        i = 0
        while (not img or
                (img.timestamp < timestamp and
                 not self._force_next_video_image) ):
            if self._buffered_images:
                img = self._buffered_images.pop(0)
            else:
                packet = self._get_packet_for_stream(self._video_stream_index)
                if not packet:
                    return
                img = self._decode_video_packet(packet)

            # Emergency loop exit when timestamps are bad
            i += 1
            if i > 60:
                break

        if img:
            player._texture.blit_into(img.image, 0, 0, 0)
            self._last_video_timestamp = img.timestamp
            self._force_next_video_image = False

    def _release_texture(self, player):
        player._texture = None

av.avbin_init()
if pyglet.options['debug_media']:
    av.avbin_set_log_level(AVBIN_LOG_DEBUG)
else:
    av.avbin_set_log_level(AVBIN_LOG_QUIET)

########NEW FILE########
__FILENAME__ = asound
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for asound

Generated with:
tools/wraptypes/wrap.py -o asound.py -lasound /usr/include/alsa/alisp.h /usr/include/alsa/asoundef.h /usr/include/alsa/asoundlib.h /usr/include/alsa/conf.h /usr/include/alsa/control.h /usr/include/alsa/control_external.h /usr/include/alsa/conv.h /usr/include/alsa/error.h /usr/include/alsa/global.h /usr/include/alsa/hwdep.h /usr/include/alsa/iatomic.h /usr/include/alsa/input.h /usr/include/alsa/instr.h /usr/include/alsa/mixer.h /usr/include/alsa/mixer_abst.h /usr/include/alsa/pcm.h /usr/include/alsa/pcm_external.h /usr/include/alsa/pcm_extplug.h /usr/include/alsa/pcm_ioplug.h /usr/include/alsa/pcm_old.h /usr/include/alsa/pcm_plugin.h /usr/include/alsa/pcm_rate.h /usr/include/alsa/rawmidi.h /usr/include/alsa/seq.h /usr/include/alsa/seq_event.h /usr/include/alsa/seq_midi_event.h /usr/include/alsa/seqmid.h /usr/include/alsa/timer.h /usr/include/alsa/version.h

 -- And then hacked to work with libasound.so, grep for XXX

Do not regenerate this file.
'''

__docformat__ =  'restructuredtext'
__version__ = '$Id: asound.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

import ctypes
from ctypes import *

import pyglet.lib

_lib = pyglet.lib.load_library('asound')

_int_types = (c_int16, c_int32)
if hasattr(ctypes, 'c_int64'):
    # Some builds of ctypes apparently do not have c_int64
    # defined; it's a pretty good bet that these builds do not
    # have 64-bit pointers.
    _int_types += (ctypes.c_int64,)
for t in _int_types:
    if sizeof(t) == sizeof(c_size_t):
        c_ptrdiff_t = t

class c_void(Structure):
    # c_void_p is a buggy return type, converting to int, so
    # POINTER(None) == c_void_p is actually written as
    # POINTER(c_void), so it can be treated as a real pointer.
    _fields_ = [('dummy', c_int)]



class struct_alisp_cfg(Structure):
    __slots__ = [
    ]
struct_alisp_cfg._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/alisp.h:39
alsa_lisp_default_cfg_free = _lib.alsa_lisp_default_cfg_free
alsa_lisp_default_cfg_free.restype = None
alsa_lisp_default_cfg_free.argtypes = [POINTER(struct_alisp_cfg)]

class struct_alisp_cfg(Structure):
    __slots__ = [
    ]
struct_alisp_cfg._fields_ = [
    ('_opaque_struct', c_int)
]

class struct_alisp_instance(Structure):
    __slots__ = [
    ]
struct_alisp_instance._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/alisp.h:40
alsa_lisp = _lib.alsa_lisp
alsa_lisp.restype = c_int
alsa_lisp.argtypes = [POINTER(struct_alisp_cfg), POINTER(POINTER(struct_alisp_instance))]

class struct_alisp_instance(Structure):
    __slots__ = [
    ]
struct_alisp_instance._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/alisp.h:41
alsa_lisp_free = _lib.alsa_lisp_free
alsa_lisp_free.restype = None
alsa_lisp_free.argtypes = [POINTER(struct_alisp_instance)]

class struct_alisp_instance(Structure):
    __slots__ = [
    ]
struct_alisp_instance._fields_ = [
    ('_opaque_struct', c_int)
]

class struct_alisp_seq_iterator(Structure):
    __slots__ = [
    ]
struct_alisp_seq_iterator._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/alisp.h:48
alsa_lisp_result_free = _lib.alsa_lisp_result_free
alsa_lisp_result_free.restype = None
alsa_lisp_result_free.argtypes = [POINTER(struct_alisp_instance), POINTER(struct_alisp_seq_iterator)]

class struct_alisp_instance(Structure):
    __slots__ = [
    ]
struct_alisp_instance._fields_ = [
    ('_opaque_struct', c_int)
]

class struct_alisp_seq_iterator(Structure):
    __slots__ = [
    ]
struct_alisp_seq_iterator._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/alisp.h:50
alsa_lisp_seq_first = _lib.alsa_lisp_seq_first
alsa_lisp_seq_first.restype = c_int
alsa_lisp_seq_first.argtypes = [POINTER(struct_alisp_instance), c_char_p, POINTER(POINTER(struct_alisp_seq_iterator))]

class struct_alisp_seq_iterator(Structure):
    __slots__ = [
    ]
struct_alisp_seq_iterator._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/alisp.h:52
alsa_lisp_seq_next = _lib.alsa_lisp_seq_next
alsa_lisp_seq_next.restype = c_int
alsa_lisp_seq_next.argtypes = [POINTER(POINTER(struct_alisp_seq_iterator))]

class struct_alisp_seq_iterator(Structure):
    __slots__ = [
    ]
struct_alisp_seq_iterator._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/alisp.h:53
alsa_lisp_seq_count = _lib.alsa_lisp_seq_count
alsa_lisp_seq_count.restype = c_int
alsa_lisp_seq_count.argtypes = [POINTER(struct_alisp_seq_iterator)]

class struct_alisp_seq_iterator(Structure):
    __slots__ = [
    ]
struct_alisp_seq_iterator._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/alisp.h:54
alsa_lisp_seq_integer = _lib.alsa_lisp_seq_integer
alsa_lisp_seq_integer.restype = c_int
alsa_lisp_seq_integer.argtypes = [POINTER(struct_alisp_seq_iterator), POINTER(c_long)]

class struct_alisp_seq_iterator(Structure):
    __slots__ = [
    ]
struct_alisp_seq_iterator._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/alisp.h:55
alsa_lisp_seq_pointer = _lib.alsa_lisp_seq_pointer
alsa_lisp_seq_pointer.restype = c_int
alsa_lisp_seq_pointer.argtypes = [POINTER(struct_alisp_seq_iterator), c_char_p, POINTER(POINTER(None))]

IEC958_AES0_PROFESSIONAL = 1 	# /usr/include/alsa/asoundef.h:96
IEC958_AES0_NONAUDIO = 2 	# /usr/include/alsa/asoundef.h:97
IEC958_AES0_PRO_EMPHASIS = 28 	# /usr/include/alsa/asoundef.h:98
IEC958_AES0_PRO_EMPHASIS_NOTID = 0 	# /usr/include/alsa/asoundef.h:99
IEC958_AES0_PRO_EMPHASIS_NONE = 4 	# /usr/include/alsa/asoundef.h:100
IEC958_AES0_PRO_EMPHASIS_5015 = 12 	# /usr/include/alsa/asoundef.h:101
IEC958_AES0_PRO_EMPHASIS_CCITT = 28 	# /usr/include/alsa/asoundef.h:102
IEC958_AES0_PRO_FREQ_UNLOCKED = 32 	# /usr/include/alsa/asoundef.h:103
IEC958_AES0_PRO_FS = 192 	# /usr/include/alsa/asoundef.h:104
IEC958_AES0_PRO_FS_NOTID = 0 	# /usr/include/alsa/asoundef.h:105
IEC958_AES0_PRO_FS_44100 = 64 	# /usr/include/alsa/asoundef.h:106
IEC958_AES0_PRO_FS_48000 = 128 	# /usr/include/alsa/asoundef.h:107
IEC958_AES0_PRO_FS_32000 = 192 	# /usr/include/alsa/asoundef.h:108
IEC958_AES0_CON_NOT_COPYRIGHT = 4 	# /usr/include/alsa/asoundef.h:109
IEC958_AES0_CON_EMPHASIS = 56 	# /usr/include/alsa/asoundef.h:110
IEC958_AES0_CON_EMPHASIS_NONE = 0 	# /usr/include/alsa/asoundef.h:111
IEC958_AES0_CON_EMPHASIS_5015 = 8 	# /usr/include/alsa/asoundef.h:112
IEC958_AES0_CON_MODE = 192 	# /usr/include/alsa/asoundef.h:113
IEC958_AES1_PRO_MODE = 15 	# /usr/include/alsa/asoundef.h:114
IEC958_AES1_PRO_MODE_NOTID = 0 	# /usr/include/alsa/asoundef.h:115
IEC958_AES1_PRO_MODE_STEREOPHONIC = 2 	# /usr/include/alsa/asoundef.h:116
IEC958_AES1_PRO_MODE_SINGLE = 4 	# /usr/include/alsa/asoundef.h:117
IEC958_AES1_PRO_MODE_TWO = 8 	# /usr/include/alsa/asoundef.h:118
IEC958_AES1_PRO_MODE_PRIMARY = 12 	# /usr/include/alsa/asoundef.h:119
IEC958_AES1_PRO_MODE_BYTE3 = 15 	# /usr/include/alsa/asoundef.h:120
IEC958_AES1_PRO_USERBITS = 240 	# /usr/include/alsa/asoundef.h:121
IEC958_AES1_PRO_USERBITS_NOTID = 0 	# /usr/include/alsa/asoundef.h:122
IEC958_AES1_PRO_USERBITS_192 = 128 	# /usr/include/alsa/asoundef.h:123
IEC958_AES1_PRO_USERBITS_UDEF = 192 	# /usr/include/alsa/asoundef.h:124
IEC958_AES1_CON_CATEGORY = 127 	# /usr/include/alsa/asoundef.h:125
IEC958_AES1_CON_GENERAL = 0 	# /usr/include/alsa/asoundef.h:126
IEC958_AES1_CON_EXPERIMENTAL = 64 	# /usr/include/alsa/asoundef.h:127
IEC958_AES1_CON_SOLIDMEM_MASK = 15 	# /usr/include/alsa/asoundef.h:128
IEC958_AES1_CON_SOLIDMEM_ID = 8 	# /usr/include/alsa/asoundef.h:129
IEC958_AES1_CON_BROADCAST1_MASK = 7 	# /usr/include/alsa/asoundef.h:130
IEC958_AES1_CON_BROADCAST1_ID = 4 	# /usr/include/alsa/asoundef.h:131
IEC958_AES1_CON_DIGDIGCONV_MASK = 7 	# /usr/include/alsa/asoundef.h:132
IEC958_AES1_CON_DIGDIGCONV_ID = 2 	# /usr/include/alsa/asoundef.h:133
IEC958_AES1_CON_ADC_COPYRIGHT_MASK = 31 	# /usr/include/alsa/asoundef.h:134
IEC958_AES1_CON_ADC_COPYRIGHT_ID = 6 	# /usr/include/alsa/asoundef.h:135
IEC958_AES1_CON_ADC_MASK = 31 	# /usr/include/alsa/asoundef.h:136
IEC958_AES1_CON_ADC_ID = 22 	# /usr/include/alsa/asoundef.h:137
IEC958_AES1_CON_BROADCAST2_MASK = 15 	# /usr/include/alsa/asoundef.h:138
IEC958_AES1_CON_BROADCAST2_ID = 14 	# /usr/include/alsa/asoundef.h:139
IEC958_AES1_CON_LASEROPT_MASK = 7 	# /usr/include/alsa/asoundef.h:140
IEC958_AES1_CON_LASEROPT_ID = 1 	# /usr/include/alsa/asoundef.h:141
IEC958_AES1_CON_MUSICAL_MASK = 7 	# /usr/include/alsa/asoundef.h:142
IEC958_AES1_CON_MUSICAL_ID = 5 	# /usr/include/alsa/asoundef.h:143
IEC958_AES1_CON_MAGNETIC_MASK = 7 	# /usr/include/alsa/asoundef.h:144
IEC958_AES1_CON_MAGNETIC_ID = 3 	# /usr/include/alsa/asoundef.h:145
IEC958_AES1_CON_IEC908_CD = 1 	# /usr/include/alsa/asoundef.h:146
IEC958_AES1_CON_NON_IEC908_CD = 9 	# /usr/include/alsa/asoundef.h:147
IEC958_AES1_CON_PCM_CODER = 2 	# /usr/include/alsa/asoundef.h:148
IEC958_AES1_CON_SAMPLER = 34 	# /usr/include/alsa/asoundef.h:149
IEC958_AES1_CON_MIXER = 18 	# /usr/include/alsa/asoundef.h:150
IEC958_AES1_CON_RATE_CONVERTER = 26 	# /usr/include/alsa/asoundef.h:151
IEC958_AES1_CON_SYNTHESIZER = 5 	# /usr/include/alsa/asoundef.h:152
IEC958_AES1_CON_MICROPHONE = 13 	# /usr/include/alsa/asoundef.h:153
IEC958_AES1_CON_DAT = 3 	# /usr/include/alsa/asoundef.h:154
IEC958_AES1_CON_VCR = 11 	# /usr/include/alsa/asoundef.h:155
IEC958_AES1_CON_ORIGINAL = 128 	# /usr/include/alsa/asoundef.h:156
IEC958_AES2_PRO_SBITS = 7 	# /usr/include/alsa/asoundef.h:157
IEC958_AES2_PRO_SBITS_20 = 2 	# /usr/include/alsa/asoundef.h:158
IEC958_AES2_PRO_SBITS_24 = 4 	# /usr/include/alsa/asoundef.h:159
IEC958_AES2_PRO_SBITS_UDEF = 6 	# /usr/include/alsa/asoundef.h:160
IEC958_AES2_PRO_WORDLEN = 56 	# /usr/include/alsa/asoundef.h:161
IEC958_AES2_PRO_WORDLEN_NOTID = 0 	# /usr/include/alsa/asoundef.h:162
IEC958_AES2_PRO_WORDLEN_22_18 = 16 	# /usr/include/alsa/asoundef.h:163
IEC958_AES2_PRO_WORDLEN_23_19 = 32 	# /usr/include/alsa/asoundef.h:164
IEC958_AES2_PRO_WORDLEN_24_20 = 40 	# /usr/include/alsa/asoundef.h:165
IEC958_AES2_PRO_WORDLEN_20_16 = 48 	# /usr/include/alsa/asoundef.h:166
IEC958_AES2_CON_SOURCE = 15 	# /usr/include/alsa/asoundef.h:167
IEC958_AES2_CON_SOURCE_UNSPEC = 0 	# /usr/include/alsa/asoundef.h:168
IEC958_AES2_CON_CHANNEL = 240 	# /usr/include/alsa/asoundef.h:169
IEC958_AES2_CON_CHANNEL_UNSPEC = 0 	# /usr/include/alsa/asoundef.h:170
IEC958_AES3_CON_FS = 15 	# /usr/include/alsa/asoundef.h:171
IEC958_AES3_CON_FS_44100 = 0 	# /usr/include/alsa/asoundef.h:172
IEC958_AES3_CON_FS_48000 = 2 	# /usr/include/alsa/asoundef.h:173
IEC958_AES3_CON_FS_32000 = 3 	# /usr/include/alsa/asoundef.h:174
IEC958_AES3_CON_CLOCK = 48 	# /usr/include/alsa/asoundef.h:175
IEC958_AES3_CON_CLOCK_1000PPM = 0 	# /usr/include/alsa/asoundef.h:176
IEC958_AES3_CON_CLOCK_50PPM = 16 	# /usr/include/alsa/asoundef.h:177
IEC958_AES3_CON_CLOCK_VARIABLE = 32 	# /usr/include/alsa/asoundef.h:178
MIDI_CHANNELS = 16 	# /usr/include/alsa/asoundef.h:188
MIDI_GM_DRUM_CHANNEL = 9 	# /usr/include/alsa/asoundef.h:189
MIDI_CMD_NOTE_OFF = 128 	# /usr/include/alsa/asoundef.h:197
MIDI_CMD_NOTE_ON = 144 	# /usr/include/alsa/asoundef.h:198
MIDI_CMD_NOTE_PRESSURE = 160 	# /usr/include/alsa/asoundef.h:199
MIDI_CMD_CONTROL = 176 	# /usr/include/alsa/asoundef.h:200
MIDI_CMD_PGM_CHANGE = 192 	# /usr/include/alsa/asoundef.h:201
MIDI_CMD_CHANNEL_PRESSURE = 208 	# /usr/include/alsa/asoundef.h:202
MIDI_CMD_BENDER = 224 	# /usr/include/alsa/asoundef.h:203
MIDI_CMD_COMMON_SYSEX = 240 	# /usr/include/alsa/asoundef.h:205
MIDI_CMD_COMMON_MTC_QUARTER = 241 	# /usr/include/alsa/asoundef.h:206
MIDI_CMD_COMMON_SONG_POS = 242 	# /usr/include/alsa/asoundef.h:207
MIDI_CMD_COMMON_SONG_SELECT = 243 	# /usr/include/alsa/asoundef.h:208
MIDI_CMD_COMMON_TUNE_REQUEST = 246 	# /usr/include/alsa/asoundef.h:209
MIDI_CMD_COMMON_SYSEX_END = 247 	# /usr/include/alsa/asoundef.h:210
MIDI_CMD_COMMON_CLOCK = 248 	# /usr/include/alsa/asoundef.h:211
MIDI_CMD_COMMON_START = 250 	# /usr/include/alsa/asoundef.h:212
MIDI_CMD_COMMON_CONTINUE = 251 	# /usr/include/alsa/asoundef.h:213
MIDI_CMD_COMMON_STOP = 252 	# /usr/include/alsa/asoundef.h:214
MIDI_CMD_COMMON_SENSING = 254 	# /usr/include/alsa/asoundef.h:215
MIDI_CMD_COMMON_RESET = 255 	# /usr/include/alsa/asoundef.h:216
MIDI_CTL_MSB_BANK = 0 	# /usr/include/alsa/asoundef.h:226
MIDI_CTL_MSB_MODWHEEL = 1 	# /usr/include/alsa/asoundef.h:227
MIDI_CTL_MSB_BREATH = 2 	# /usr/include/alsa/asoundef.h:228
MIDI_CTL_MSB_FOOT = 4 	# /usr/include/alsa/asoundef.h:229
MIDI_CTL_MSB_PORTAMENTO_TIME = 5 	# /usr/include/alsa/asoundef.h:230
MIDI_CTL_MSB_DATA_ENTRY = 6 	# /usr/include/alsa/asoundef.h:231
MIDI_CTL_MSB_MAIN_VOLUME = 7 	# /usr/include/alsa/asoundef.h:232
MIDI_CTL_MSB_BALANCE = 8 	# /usr/include/alsa/asoundef.h:233
MIDI_CTL_MSB_PAN = 10 	# /usr/include/alsa/asoundef.h:234
MIDI_CTL_MSB_EXPRESSION = 11 	# /usr/include/alsa/asoundef.h:235
MIDI_CTL_MSB_EFFECT1 = 12 	# /usr/include/alsa/asoundef.h:236
MIDI_CTL_MSB_EFFECT2 = 13 	# /usr/include/alsa/asoundef.h:237
MIDI_CTL_MSB_GENERAL_PURPOSE1 = 16 	# /usr/include/alsa/asoundef.h:238
MIDI_CTL_MSB_GENERAL_PURPOSE2 = 17 	# /usr/include/alsa/asoundef.h:239
MIDI_CTL_MSB_GENERAL_PURPOSE3 = 18 	# /usr/include/alsa/asoundef.h:240
MIDI_CTL_MSB_GENERAL_PURPOSE4 = 19 	# /usr/include/alsa/asoundef.h:241
MIDI_CTL_LSB_BANK = 32 	# /usr/include/alsa/asoundef.h:242
MIDI_CTL_LSB_MODWHEEL = 33 	# /usr/include/alsa/asoundef.h:243
MIDI_CTL_LSB_BREATH = 34 	# /usr/include/alsa/asoundef.h:244
MIDI_CTL_LSB_FOOT = 36 	# /usr/include/alsa/asoundef.h:245
MIDI_CTL_LSB_PORTAMENTO_TIME = 37 	# /usr/include/alsa/asoundef.h:246
MIDI_CTL_LSB_DATA_ENTRY = 38 	# /usr/include/alsa/asoundef.h:247
MIDI_CTL_LSB_MAIN_VOLUME = 39 	# /usr/include/alsa/asoundef.h:248
MIDI_CTL_LSB_BALANCE = 40 	# /usr/include/alsa/asoundef.h:249
MIDI_CTL_LSB_PAN = 42 	# /usr/include/alsa/asoundef.h:250
MIDI_CTL_LSB_EXPRESSION = 43 	# /usr/include/alsa/asoundef.h:251
MIDI_CTL_LSB_EFFECT1 = 44 	# /usr/include/alsa/asoundef.h:252
MIDI_CTL_LSB_EFFECT2 = 45 	# /usr/include/alsa/asoundef.h:253
MIDI_CTL_LSB_GENERAL_PURPOSE1 = 48 	# /usr/include/alsa/asoundef.h:254
MIDI_CTL_LSB_GENERAL_PURPOSE2 = 49 	# /usr/include/alsa/asoundef.h:255
MIDI_CTL_LSB_GENERAL_PURPOSE3 = 50 	# /usr/include/alsa/asoundef.h:256
MIDI_CTL_LSB_GENERAL_PURPOSE4 = 51 	# /usr/include/alsa/asoundef.h:257
MIDI_CTL_SUSTAIN = 64 	# /usr/include/alsa/asoundef.h:258
MIDI_CTL_PORTAMENTO = 65 	# /usr/include/alsa/asoundef.h:259
MIDI_CTL_SOSTENUTO = 66 	# /usr/include/alsa/asoundef.h:260
MIDI_CTL_SUSTENUTO = 66 	# /usr/include/alsa/asoundef.h:261
MIDI_CTL_SOFT_PEDAL = 67 	# /usr/include/alsa/asoundef.h:262
MIDI_CTL_LEGATO_FOOTSWITCH = 68 	# /usr/include/alsa/asoundef.h:263
MIDI_CTL_HOLD2 = 69 	# /usr/include/alsa/asoundef.h:264
MIDI_CTL_SC1_SOUND_VARIATION = 70 	# /usr/include/alsa/asoundef.h:265
MIDI_CTL_SC2_TIMBRE = 71 	# /usr/include/alsa/asoundef.h:266
MIDI_CTL_SC3_RELEASE_TIME = 72 	# /usr/include/alsa/asoundef.h:267
MIDI_CTL_SC4_ATTACK_TIME = 73 	# /usr/include/alsa/asoundef.h:268
MIDI_CTL_SC5_BRIGHTNESS = 74 	# /usr/include/alsa/asoundef.h:269
MIDI_CTL_SC6 = 75 	# /usr/include/alsa/asoundef.h:270
MIDI_CTL_SC7 = 76 	# /usr/include/alsa/asoundef.h:271
MIDI_CTL_SC8 = 77 	# /usr/include/alsa/asoundef.h:272
MIDI_CTL_SC9 = 78 	# /usr/include/alsa/asoundef.h:273
MIDI_CTL_SC10 = 79 	# /usr/include/alsa/asoundef.h:274
MIDI_CTL_GENERAL_PURPOSE5 = 80 	# /usr/include/alsa/asoundef.h:275
MIDI_CTL_GENERAL_PURPOSE6 = 81 	# /usr/include/alsa/asoundef.h:276
MIDI_CTL_GENERAL_PURPOSE7 = 82 	# /usr/include/alsa/asoundef.h:277
MIDI_CTL_GENERAL_PURPOSE8 = 83 	# /usr/include/alsa/asoundef.h:278
MIDI_CTL_PORTAMENTO_CONTROL = 84 	# /usr/include/alsa/asoundef.h:279
MIDI_CTL_E1_REVERB_DEPTH = 91 	# /usr/include/alsa/asoundef.h:280
MIDI_CTL_E2_TREMOLO_DEPTH = 92 	# /usr/include/alsa/asoundef.h:281
MIDI_CTL_E3_CHORUS_DEPTH = 93 	# /usr/include/alsa/asoundef.h:282
MIDI_CTL_E4_DETUNE_DEPTH = 94 	# /usr/include/alsa/asoundef.h:283
MIDI_CTL_E5_PHASER_DEPTH = 95 	# /usr/include/alsa/asoundef.h:284
MIDI_CTL_DATA_INCREMENT = 96 	# /usr/include/alsa/asoundef.h:285
MIDI_CTL_DATA_DECREMENT = 97 	# /usr/include/alsa/asoundef.h:286
MIDI_CTL_NONREG_PARM_NUM_LSB = 98 	# /usr/include/alsa/asoundef.h:287
MIDI_CTL_NONREG_PARM_NUM_MSB = 99 	# /usr/include/alsa/asoundef.h:288
MIDI_CTL_REGIST_PARM_NUM_LSB = 100 	# /usr/include/alsa/asoundef.h:289
MIDI_CTL_REGIST_PARM_NUM_MSB = 101 	# /usr/include/alsa/asoundef.h:290
MIDI_CTL_ALL_SOUNDS_OFF = 120 	# /usr/include/alsa/asoundef.h:291
MIDI_CTL_RESET_CONTROLLERS = 121 	# /usr/include/alsa/asoundef.h:292
MIDI_CTL_LOCAL_CONTROL_SWITCH = 122 	# /usr/include/alsa/asoundef.h:293
MIDI_CTL_ALL_NOTES_OFF = 123 	# /usr/include/alsa/asoundef.h:294
MIDI_CTL_OMNI_OFF = 124 	# /usr/include/alsa/asoundef.h:295
MIDI_CTL_OMNI_ON = 125 	# /usr/include/alsa/asoundef.h:296
MIDI_CTL_MONO1 = 126 	# /usr/include/alsa/asoundef.h:297
MIDI_CTL_MONO2 = 127 	# /usr/include/alsa/asoundef.h:298
IEC958_AES0_PROFESSIONAL = 1 	# /usr/include/alsa/asoundef.h:41
IEC958_AES0_NONAUDIO = 2 	# /usr/include/alsa/asoundef.h:42
IEC958_AES0_PRO_EMPHASIS = 28 	# /usr/include/alsa/asoundef.h:43
IEC958_AES0_PRO_EMPHASIS_NOTID = 0 	# /usr/include/alsa/asoundef.h:44
IEC958_AES0_PRO_EMPHASIS_NONE = 4 	# /usr/include/alsa/asoundef.h:45
IEC958_AES0_PRO_EMPHASIS_5015 = 12 	# /usr/include/alsa/asoundef.h:46
IEC958_AES0_PRO_EMPHASIS_CCITT = 28 	# /usr/include/alsa/asoundef.h:47
IEC958_AES0_PRO_FREQ_UNLOCKED = 32 	# /usr/include/alsa/asoundef.h:48
IEC958_AES0_PRO_FS = 192 	# /usr/include/alsa/asoundef.h:49
IEC958_AES0_PRO_FS_NOTID = 0 	# /usr/include/alsa/asoundef.h:50
IEC958_AES0_PRO_FS_44100 = 64 	# /usr/include/alsa/asoundef.h:51
IEC958_AES0_PRO_FS_48000 = 128 	# /usr/include/alsa/asoundef.h:52
IEC958_AES0_PRO_FS_32000 = 192 	# /usr/include/alsa/asoundef.h:53
IEC958_AES0_CON_NOT_COPYRIGHT = 4 	# /usr/include/alsa/asoundef.h:54
IEC958_AES0_CON_EMPHASIS = 56 	# /usr/include/alsa/asoundef.h:55
IEC958_AES0_CON_EMPHASIS_NONE = 0 	# /usr/include/alsa/asoundef.h:56
IEC958_AES0_CON_EMPHASIS_5015 = 8 	# /usr/include/alsa/asoundef.h:57
IEC958_AES0_CON_MODE = 192 	# /usr/include/alsa/asoundef.h:58
IEC958_AES1_PRO_MODE = 15 	# /usr/include/alsa/asoundef.h:59
IEC958_AES1_PRO_MODE_NOTID = 0 	# /usr/include/alsa/asoundef.h:60
IEC958_AES1_PRO_MODE_STEREOPHONIC = 2 	# /usr/include/alsa/asoundef.h:61
IEC958_AES1_PRO_MODE_SINGLE = 4 	# /usr/include/alsa/asoundef.h:62
IEC958_AES1_PRO_MODE_TWO = 8 	# /usr/include/alsa/asoundef.h:63
IEC958_AES1_PRO_MODE_PRIMARY = 12 	# /usr/include/alsa/asoundef.h:64
IEC958_AES1_PRO_MODE_BYTE3 = 15 	# /usr/include/alsa/asoundef.h:65
IEC958_AES1_PRO_USERBITS = 240 	# /usr/include/alsa/asoundef.h:66
IEC958_AES1_PRO_USERBITS_NOTID = 0 	# /usr/include/alsa/asoundef.h:67
IEC958_AES1_PRO_USERBITS_192 = 128 	# /usr/include/alsa/asoundef.h:68
IEC958_AES1_PRO_USERBITS_UDEF = 192 	# /usr/include/alsa/asoundef.h:69
IEC958_AES1_CON_CATEGORY = 127 	# /usr/include/alsa/asoundef.h:70
IEC958_AES1_CON_GENERAL = 0 	# /usr/include/alsa/asoundef.h:71
IEC958_AES1_CON_EXPERIMENTAL = 64 	# /usr/include/alsa/asoundef.h:72
IEC958_AES1_CON_SOLIDMEM_MASK = 15 	# /usr/include/alsa/asoundef.h:73
IEC958_AES1_CON_SOLIDMEM_ID = 8 	# /usr/include/alsa/asoundef.h:74
IEC958_AES1_CON_BROADCAST1_MASK = 7 	# /usr/include/alsa/asoundef.h:75
IEC958_AES1_CON_BROADCAST1_ID = 4 	# /usr/include/alsa/asoundef.h:76
IEC958_AES1_CON_DIGDIGCONV_MASK = 7 	# /usr/include/alsa/asoundef.h:77
IEC958_AES1_CON_DIGDIGCONV_ID = 2 	# /usr/include/alsa/asoundef.h:78
IEC958_AES1_CON_ADC_COPYRIGHT_MASK = 31 	# /usr/include/alsa/asoundef.h:79
IEC958_AES1_CON_ADC_COPYRIGHT_ID = 6 	# /usr/include/alsa/asoundef.h:80
IEC958_AES1_CON_ADC_MASK = 31 	# /usr/include/alsa/asoundef.h:81
IEC958_AES1_CON_ADC_ID = 22 	# /usr/include/alsa/asoundef.h:82
IEC958_AES1_CON_BROADCAST2_MASK = 15 	# /usr/include/alsa/asoundef.h:83
IEC958_AES1_CON_BROADCAST2_ID = 14 	# /usr/include/alsa/asoundef.h:84
IEC958_AES1_CON_LASEROPT_MASK = 7 	# /usr/include/alsa/asoundef.h:85
IEC958_AES1_CON_LASEROPT_ID = 1 	# /usr/include/alsa/asoundef.h:86
IEC958_AES1_CON_MUSICAL_MASK = 7 	# /usr/include/alsa/asoundef.h:87
IEC958_AES1_CON_MUSICAL_ID = 5 	# /usr/include/alsa/asoundef.h:88
IEC958_AES1_CON_MAGNETIC_MASK = 7 	# /usr/include/alsa/asoundef.h:89
IEC958_AES1_CON_MAGNETIC_ID = 3 	# /usr/include/alsa/asoundef.h:90
IEC958_AES1_CON_IEC908_CD = 1 	# /usr/include/alsa/asoundef.h:91
IEC958_AES1_CON_NON_IEC908_CD = 9 	# /usr/include/alsa/asoundef.h:92
IEC958_AES1_CON_PCM_CODER = 2 	# /usr/include/alsa/asoundef.h:93
IEC958_AES1_CON_SAMPLER = 34 	# /usr/include/alsa/asoundef.h:94
IEC958_AES1_CON_MIXER = 18 	# /usr/include/alsa/asoundef.h:95
IEC958_AES1_CON_RATE_CONVERTER = 26 	# /usr/include/alsa/asoundef.h:96
IEC958_AES1_CON_SYNTHESIZER = 5 	# /usr/include/alsa/asoundef.h:97
IEC958_AES1_CON_MICROPHONE = 13 	# /usr/include/alsa/asoundef.h:98
IEC958_AES1_CON_DAT = 3 	# /usr/include/alsa/asoundef.h:99
IEC958_AES1_CON_VCR = 11 	# /usr/include/alsa/asoundef.h:100
IEC958_AES1_CON_ORIGINAL = 128 	# /usr/include/alsa/asoundef.h:101
IEC958_AES2_PRO_SBITS = 7 	# /usr/include/alsa/asoundef.h:102
IEC958_AES2_PRO_SBITS_20 = 2 	# /usr/include/alsa/asoundef.h:103
IEC958_AES2_PRO_SBITS_24 = 4 	# /usr/include/alsa/asoundef.h:104
IEC958_AES2_PRO_SBITS_UDEF = 6 	# /usr/include/alsa/asoundef.h:105
IEC958_AES2_PRO_WORDLEN = 56 	# /usr/include/alsa/asoundef.h:106
IEC958_AES2_PRO_WORDLEN_NOTID = 0 	# /usr/include/alsa/asoundef.h:107
IEC958_AES2_PRO_WORDLEN_22_18 = 16 	# /usr/include/alsa/asoundef.h:108
IEC958_AES2_PRO_WORDLEN_23_19 = 32 	# /usr/include/alsa/asoundef.h:109
IEC958_AES2_PRO_WORDLEN_24_20 = 40 	# /usr/include/alsa/asoundef.h:110
IEC958_AES2_PRO_WORDLEN_20_16 = 48 	# /usr/include/alsa/asoundef.h:111
IEC958_AES2_CON_SOURCE = 15 	# /usr/include/alsa/asoundef.h:112
IEC958_AES2_CON_SOURCE_UNSPEC = 0 	# /usr/include/alsa/asoundef.h:113
IEC958_AES2_CON_CHANNEL = 240 	# /usr/include/alsa/asoundef.h:114
IEC958_AES2_CON_CHANNEL_UNSPEC = 0 	# /usr/include/alsa/asoundef.h:115
IEC958_AES3_CON_FS = 15 	# /usr/include/alsa/asoundef.h:116
IEC958_AES3_CON_FS_44100 = 0 	# /usr/include/alsa/asoundef.h:117
IEC958_AES3_CON_FS_48000 = 2 	# /usr/include/alsa/asoundef.h:118
IEC958_AES3_CON_FS_32000 = 3 	# /usr/include/alsa/asoundef.h:119
IEC958_AES3_CON_CLOCK = 48 	# /usr/include/alsa/asoundef.h:120
IEC958_AES3_CON_CLOCK_1000PPM = 0 	# /usr/include/alsa/asoundef.h:121
IEC958_AES3_CON_CLOCK_50PPM = 16 	# /usr/include/alsa/asoundef.h:122
IEC958_AES3_CON_CLOCK_VARIABLE = 32 	# /usr/include/alsa/asoundef.h:123
MIDI_CHANNELS = 16 	# /usr/include/alsa/asoundef.h:133
MIDI_GM_DRUM_CHANNEL = 9 	# /usr/include/alsa/asoundef.h:134
MIDI_CMD_NOTE_OFF = 128 	# /usr/include/alsa/asoundef.h:142
MIDI_CMD_NOTE_ON = 144 	# /usr/include/alsa/asoundef.h:143
MIDI_CMD_NOTE_PRESSURE = 160 	# /usr/include/alsa/asoundef.h:144
MIDI_CMD_CONTROL = 176 	# /usr/include/alsa/asoundef.h:145
MIDI_CMD_PGM_CHANGE = 192 	# /usr/include/alsa/asoundef.h:146
MIDI_CMD_CHANNEL_PRESSURE = 208 	# /usr/include/alsa/asoundef.h:147
MIDI_CMD_BENDER = 224 	# /usr/include/alsa/asoundef.h:148
MIDI_CMD_COMMON_SYSEX = 240 	# /usr/include/alsa/asoundef.h:150
MIDI_CMD_COMMON_MTC_QUARTER = 241 	# /usr/include/alsa/asoundef.h:151
MIDI_CMD_COMMON_SONG_POS = 242 	# /usr/include/alsa/asoundef.h:152
MIDI_CMD_COMMON_SONG_SELECT = 243 	# /usr/include/alsa/asoundef.h:153
MIDI_CMD_COMMON_TUNE_REQUEST = 246 	# /usr/include/alsa/asoundef.h:154
MIDI_CMD_COMMON_SYSEX_END = 247 	# /usr/include/alsa/asoundef.h:155
MIDI_CMD_COMMON_CLOCK = 248 	# /usr/include/alsa/asoundef.h:156
MIDI_CMD_COMMON_START = 250 	# /usr/include/alsa/asoundef.h:157
MIDI_CMD_COMMON_CONTINUE = 251 	# /usr/include/alsa/asoundef.h:158
MIDI_CMD_COMMON_STOP = 252 	# /usr/include/alsa/asoundef.h:159
MIDI_CMD_COMMON_SENSING = 254 	# /usr/include/alsa/asoundef.h:160
MIDI_CMD_COMMON_RESET = 255 	# /usr/include/alsa/asoundef.h:161
MIDI_CTL_MSB_BANK = 0 	# /usr/include/alsa/asoundef.h:171
MIDI_CTL_MSB_MODWHEEL = 1 	# /usr/include/alsa/asoundef.h:172
MIDI_CTL_MSB_BREATH = 2 	# /usr/include/alsa/asoundef.h:173
MIDI_CTL_MSB_FOOT = 4 	# /usr/include/alsa/asoundef.h:174
MIDI_CTL_MSB_PORTAMENTO_TIME = 5 	# /usr/include/alsa/asoundef.h:175
MIDI_CTL_MSB_DATA_ENTRY = 6 	# /usr/include/alsa/asoundef.h:176
MIDI_CTL_MSB_MAIN_VOLUME = 7 	# /usr/include/alsa/asoundef.h:177
MIDI_CTL_MSB_BALANCE = 8 	# /usr/include/alsa/asoundef.h:178
MIDI_CTL_MSB_PAN = 10 	# /usr/include/alsa/asoundef.h:179
MIDI_CTL_MSB_EXPRESSION = 11 	# /usr/include/alsa/asoundef.h:180
MIDI_CTL_MSB_EFFECT1 = 12 	# /usr/include/alsa/asoundef.h:181
MIDI_CTL_MSB_EFFECT2 = 13 	# /usr/include/alsa/asoundef.h:182
MIDI_CTL_MSB_GENERAL_PURPOSE1 = 16 	# /usr/include/alsa/asoundef.h:183
MIDI_CTL_MSB_GENERAL_PURPOSE2 = 17 	# /usr/include/alsa/asoundef.h:184
MIDI_CTL_MSB_GENERAL_PURPOSE3 = 18 	# /usr/include/alsa/asoundef.h:185
MIDI_CTL_MSB_GENERAL_PURPOSE4 = 19 	# /usr/include/alsa/asoundef.h:186
MIDI_CTL_LSB_BANK = 32 	# /usr/include/alsa/asoundef.h:187
MIDI_CTL_LSB_MODWHEEL = 33 	# /usr/include/alsa/asoundef.h:188
MIDI_CTL_LSB_BREATH = 34 	# /usr/include/alsa/asoundef.h:189
MIDI_CTL_LSB_FOOT = 36 	# /usr/include/alsa/asoundef.h:190
MIDI_CTL_LSB_PORTAMENTO_TIME = 37 	# /usr/include/alsa/asoundef.h:191
MIDI_CTL_LSB_DATA_ENTRY = 38 	# /usr/include/alsa/asoundef.h:192
MIDI_CTL_LSB_MAIN_VOLUME = 39 	# /usr/include/alsa/asoundef.h:193
MIDI_CTL_LSB_BALANCE = 40 	# /usr/include/alsa/asoundef.h:194
MIDI_CTL_LSB_PAN = 42 	# /usr/include/alsa/asoundef.h:195
MIDI_CTL_LSB_EXPRESSION = 43 	# /usr/include/alsa/asoundef.h:196
MIDI_CTL_LSB_EFFECT1 = 44 	# /usr/include/alsa/asoundef.h:197
MIDI_CTL_LSB_EFFECT2 = 45 	# /usr/include/alsa/asoundef.h:198
MIDI_CTL_LSB_GENERAL_PURPOSE1 = 48 	# /usr/include/alsa/asoundef.h:199
MIDI_CTL_LSB_GENERAL_PURPOSE2 = 49 	# /usr/include/alsa/asoundef.h:200
MIDI_CTL_LSB_GENERAL_PURPOSE3 = 50 	# /usr/include/alsa/asoundef.h:201
MIDI_CTL_LSB_GENERAL_PURPOSE4 = 51 	# /usr/include/alsa/asoundef.h:202
MIDI_CTL_SUSTAIN = 64 	# /usr/include/alsa/asoundef.h:203
MIDI_CTL_PORTAMENTO = 65 	# /usr/include/alsa/asoundef.h:204
MIDI_CTL_SOSTENUTO = 66 	# /usr/include/alsa/asoundef.h:205
MIDI_CTL_SUSTENUTO = 66 	# /usr/include/alsa/asoundef.h:206
MIDI_CTL_SOFT_PEDAL = 67 	# /usr/include/alsa/asoundef.h:207
MIDI_CTL_LEGATO_FOOTSWITCH = 68 	# /usr/include/alsa/asoundef.h:208
MIDI_CTL_HOLD2 = 69 	# /usr/include/alsa/asoundef.h:209
MIDI_CTL_SC1_SOUND_VARIATION = 70 	# /usr/include/alsa/asoundef.h:210
MIDI_CTL_SC2_TIMBRE = 71 	# /usr/include/alsa/asoundef.h:211
MIDI_CTL_SC3_RELEASE_TIME = 72 	# /usr/include/alsa/asoundef.h:212
MIDI_CTL_SC4_ATTACK_TIME = 73 	# /usr/include/alsa/asoundef.h:213
MIDI_CTL_SC5_BRIGHTNESS = 74 	# /usr/include/alsa/asoundef.h:214
MIDI_CTL_SC6 = 75 	# /usr/include/alsa/asoundef.h:215
MIDI_CTL_SC7 = 76 	# /usr/include/alsa/asoundef.h:216
MIDI_CTL_SC8 = 77 	# /usr/include/alsa/asoundef.h:217
MIDI_CTL_SC9 = 78 	# /usr/include/alsa/asoundef.h:218
MIDI_CTL_SC10 = 79 	# /usr/include/alsa/asoundef.h:219
MIDI_CTL_GENERAL_PURPOSE5 = 80 	# /usr/include/alsa/asoundef.h:220
MIDI_CTL_GENERAL_PURPOSE6 = 81 	# /usr/include/alsa/asoundef.h:221
MIDI_CTL_GENERAL_PURPOSE7 = 82 	# /usr/include/alsa/asoundef.h:222
MIDI_CTL_GENERAL_PURPOSE8 = 83 	# /usr/include/alsa/asoundef.h:223
MIDI_CTL_PORTAMENTO_CONTROL = 84 	# /usr/include/alsa/asoundef.h:224
MIDI_CTL_E1_REVERB_DEPTH = 91 	# /usr/include/alsa/asoundef.h:225
MIDI_CTL_E2_TREMOLO_DEPTH = 92 	# /usr/include/alsa/asoundef.h:226
MIDI_CTL_E3_CHORUS_DEPTH = 93 	# /usr/include/alsa/asoundef.h:227
MIDI_CTL_E4_DETUNE_DEPTH = 94 	# /usr/include/alsa/asoundef.h:228
MIDI_CTL_E5_PHASER_DEPTH = 95 	# /usr/include/alsa/asoundef.h:229
MIDI_CTL_DATA_INCREMENT = 96 	# /usr/include/alsa/asoundef.h:230
MIDI_CTL_DATA_DECREMENT = 97 	# /usr/include/alsa/asoundef.h:231
MIDI_CTL_NONREG_PARM_NUM_LSB = 98 	# /usr/include/alsa/asoundef.h:232
MIDI_CTL_NONREG_PARM_NUM_MSB = 99 	# /usr/include/alsa/asoundef.h:233
MIDI_CTL_REGIST_PARM_NUM_LSB = 100 	# /usr/include/alsa/asoundef.h:234
MIDI_CTL_REGIST_PARM_NUM_MSB = 101 	# /usr/include/alsa/asoundef.h:235
MIDI_CTL_ALL_SOUNDS_OFF = 120 	# /usr/include/alsa/asoundef.h:236
MIDI_CTL_RESET_CONTROLLERS = 121 	# /usr/include/alsa/asoundef.h:237
MIDI_CTL_LOCAL_CONTROL_SWITCH = 122 	# /usr/include/alsa/asoundef.h:238
MIDI_CTL_ALL_NOTES_OFF = 123 	# /usr/include/alsa/asoundef.h:239
MIDI_CTL_OMNI_OFF = 124 	# /usr/include/alsa/asoundef.h:240
MIDI_CTL_OMNI_ON = 125 	# /usr/include/alsa/asoundef.h:241
MIDI_CTL_MONO1 = 126 	# /usr/include/alsa/asoundef.h:242
MIDI_CTL_MONO2 = 127 	# /usr/include/alsa/asoundef.h:243
SND_LIB_MAJOR = 1 	# /usr/include/alsa/version.h:5
SND_LIB_MINOR = 0 	# /usr/include/alsa/version.h:6
SND_LIB_SUBMINOR = 14 	# /usr/include/alsa/version.h:7
SND_LIB_EXTRAVER = 100003 	# /usr/include/alsa/version.h:8
SND_LIB_VERSION = 65550 	# /usr/include/alsa/version.h:10
# /usr/include/alsa/global.h:47
snd_asoundlib_version = _lib.snd_asoundlib_version
snd_asoundlib_version.restype = c_char_p
snd_asoundlib_version.argtypes = []

# /usr/include/alsa/global.h:100
snd_dlopen = _lib.snd_dlopen
snd_dlopen.restype = POINTER(c_void)
snd_dlopen.argtypes = [c_char_p, c_int]

# /usr/include/alsa/global.h:101
snd_dlsym = _lib.snd_dlsym
snd_dlsym.restype = POINTER(c_void)
snd_dlsym.argtypes = [POINTER(None), c_char_p, c_char_p]

# /usr/include/alsa/global.h:102
snd_dlclose = _lib.snd_dlclose
snd_dlclose.restype = c_int
snd_dlclose.argtypes = [POINTER(None)]

class struct__snd_async_handler(Structure):
    __slots__ = [
    ]
struct__snd_async_handler._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_async_handler(Structure):
    __slots__ = [
    ]
struct__snd_async_handler._fields_ = [
    ('_opaque_struct', c_int)
]

snd_async_handler_t = struct__snd_async_handler 	# /usr/include/alsa/global.h:111
snd_async_callback_t = CFUNCTYPE(None, POINTER(snd_async_handler_t)) 	# /usr/include/alsa/global.h:118
# /usr/include/alsa/global.h:120
snd_async_add_handler = _lib.snd_async_add_handler
snd_async_add_handler.restype = c_int
snd_async_add_handler.argtypes = [POINTER(POINTER(snd_async_handler_t)), c_int, snd_async_callback_t, POINTER(None)]

# /usr/include/alsa/global.h:122
snd_async_del_handler = _lib.snd_async_del_handler
snd_async_del_handler.restype = c_int
snd_async_del_handler.argtypes = [POINTER(snd_async_handler_t)]

# /usr/include/alsa/global.h:123
snd_async_handler_get_fd = _lib.snd_async_handler_get_fd
snd_async_handler_get_fd.restype = c_int
snd_async_handler_get_fd.argtypes = [POINTER(snd_async_handler_t)]

# /usr/include/alsa/global.h:124
snd_async_handler_get_signo = _lib.snd_async_handler_get_signo
snd_async_handler_get_signo.restype = c_int
snd_async_handler_get_signo.argtypes = [POINTER(snd_async_handler_t)]

# /usr/include/alsa/global.h:125
snd_async_handler_get_callback_private = _lib.snd_async_handler_get_callback_private
snd_async_handler_get_callback_private.restype = POINTER(c_void)
snd_async_handler_get_callback_private.argtypes = [POINTER(snd_async_handler_t)]

class struct_snd_shm_area(Structure):
    __slots__ = [
    ]
struct_snd_shm_area._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/global.h:127
snd_shm_area_create = _lib.snd_shm_area_create
snd_shm_area_create.restype = POINTER(struct_snd_shm_area)
snd_shm_area_create.argtypes = [c_int, POINTER(None)]

class struct_snd_shm_area(Structure):
    __slots__ = [
    ]
struct_snd_shm_area._fields_ = [
    ('_opaque_struct', c_int)
]

class struct_snd_shm_area(Structure):
    __slots__ = [
    ]
struct_snd_shm_area._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/global.h:128
snd_shm_area_share = _lib.snd_shm_area_share
snd_shm_area_share.restype = POINTER(struct_snd_shm_area)
snd_shm_area_share.argtypes = [POINTER(struct_snd_shm_area)]

class struct_snd_shm_area(Structure):
    __slots__ = [
    ]
struct_snd_shm_area._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/global.h:129
snd_shm_area_destroy = _lib.snd_shm_area_destroy
snd_shm_area_destroy.restype = c_int
snd_shm_area_destroy.argtypes = [POINTER(struct_snd_shm_area)]

# /usr/include/alsa/global.h:131
snd_user_file = _lib.snd_user_file
snd_user_file.restype = c_int
snd_user_file.argtypes = [c_char_p, POINTER(c_char_p)]


# XXX from `man gettimeofday`
class struct_timeval(Structure):
    _fields_ = [
        ('tv_sec', c_long),
        ('tv_usec', c_long)
    ]

snd_timestamp_t = struct_timeval 	# /usr/include/alsa/global.h:146


# XXX wrong, but not used ATM
class struct_timespec(Structure):
    __slots__ = [
    ]
struct_timespec._fields_ = [
    ('_opaque_struct', c_int)
]

class struct_timespec(Structure):
    __slots__ = [
    ]
struct_timespec._fields_ = [
    ('_opaque_struct', c_int)
]

snd_htimestamp_t = struct_timespec 	# /usr/include/alsa/global.h:148
class struct__snd_input(Structure):
    __slots__ = [
    ]
struct__snd_input._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_input(Structure):
    __slots__ = [
    ]
struct__snd_input._fields_ = [
    ('_opaque_struct', c_int)
]

snd_input_t = struct__snd_input 	# /usr/include/alsa/input.h:54
enum__snd_input_type = c_int
SND_INPUT_STDIO = 1
SND_INPUT_BUFFER = 2
snd_input_type_t = enum__snd_input_type 	# /usr/include/alsa/input.h:62
# /usr/include/alsa/input.h:64
snd_input_stdio_open = _lib.snd_input_stdio_open
snd_input_stdio_open.restype = c_int
snd_input_stdio_open.argtypes = [POINTER(POINTER(snd_input_t)), c_char_p, c_char_p]

class struct__IO_FILE(Structure):
    __slots__ = [
    ]
struct__IO_FILE._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__IO_FILE(Structure):
    __slots__ = [
    ]
struct__IO_FILE._fields_ = [
    ('_opaque_struct', c_int)
]

FILE = struct__IO_FILE 	# /usr/include/gentoo-multilib/amd64/stdio.h:46
# /usr/include/alsa/input.h:65
snd_input_stdio_attach = _lib.snd_input_stdio_attach
snd_input_stdio_attach.restype = c_int
snd_input_stdio_attach.argtypes = [POINTER(POINTER(snd_input_t)), POINTER(FILE), c_int]

__ssize_t = c_long 	# /usr/include/gentoo-multilib/amd64/bits/types.h:183
ssize_t = __ssize_t 	# /usr/include/gentoo-multilib/amd64/unistd.h:189
# /usr/include/alsa/input.h:66
snd_input_buffer_open = _lib.snd_input_buffer_open
snd_input_buffer_open.restype = c_int
snd_input_buffer_open.argtypes = [POINTER(POINTER(snd_input_t)), c_char_p, ssize_t]

# /usr/include/alsa/input.h:67
snd_input_close = _lib.snd_input_close
snd_input_close.restype = c_int
snd_input_close.argtypes = [POINTER(snd_input_t)]

# /usr/include/alsa/input.h:68
snd_input_scanf = _lib.snd_input_scanf
snd_input_scanf.restype = c_int
snd_input_scanf.argtypes = [POINTER(snd_input_t), c_char_p]

# /usr/include/alsa/input.h:73
snd_input_gets = _lib.snd_input_gets
snd_input_gets.restype = c_char_p
snd_input_gets.argtypes = [POINTER(snd_input_t), c_char_p, c_size_t]

# /usr/include/alsa/input.h:74
snd_input_getc = _lib.snd_input_getc
snd_input_getc.restype = c_int
snd_input_getc.argtypes = [POINTER(snd_input_t)]

# /usr/include/alsa/input.h:75
snd_input_ungetc = _lib.snd_input_ungetc
snd_input_ungetc.restype = c_int
snd_input_ungetc.argtypes = [POINTER(snd_input_t), c_int]

SND_ERROR_BEGIN = 500000 	# /usr/include/alsa/error.h:41
SND_ERROR_INCOMPATIBLE_VERSION = 500000 	# /usr/include/alsa/error.h:42
SND_ERROR_ALISP_NIL = 500001 	# /usr/include/alsa/error.h:43
# /usr/include/alsa/error.h:45
snd_strerror = _lib.snd_strerror
snd_strerror.restype = c_char_p
snd_strerror.argtypes = [c_int]

snd_lib_error_handler_t = CFUNCTYPE(None, c_char_p, c_int, c_char_p, c_int, c_char_p) 	# /usr/include/alsa/error.h:59
# /usr/include/alsa/error.h:61
snd_lib_error_set_handler = _lib.snd_lib_error_set_handler
snd_lib_error_set_handler.restype = c_int
snd_lib_error_set_handler.argtypes = [snd_lib_error_handler_t]

SND_CONFIG_DLSYM_VERSION_EVALUATE = 0 	# /usr/include/alsa/conf.h:43
SND_CONFIG_DLSYM_VERSION_HOOK = 0 	# /usr/include/alsa/conf.h:45
enum__snd_config_type = c_int
SND_CONFIG_TYPE_INTEGER = 1
SND_CONFIG_TYPE_INTEGER64 = 2
SND_CONFIG_TYPE_REAL = 3
SND_CONFIG_TYPE_STRING = 4
SND_CONFIG_TYPE_POINTER = 5
SND_CONFIG_TYPE_COMPOUND = 1024
snd_config_type_t = enum__snd_config_type 	# /usr/include/alsa/conf.h:61
class struct__snd_config(Structure):
    __slots__ = [
    ]
struct__snd_config._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_config(Structure):
    __slots__ = [
    ]
struct__snd_config._fields_ = [
    ('_opaque_struct', c_int)
]

snd_config_t = struct__snd_config 	# /usr/include/alsa/conf.h:69
class struct__snd_config_iterator(Structure):
    __slots__ = [
    ]
struct__snd_config_iterator._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_config_iterator(Structure):
    __slots__ = [
    ]
struct__snd_config_iterator._fields_ = [
    ('_opaque_struct', c_int)
]

snd_config_iterator_t = POINTER(struct__snd_config_iterator) 	# /usr/include/alsa/conf.h:77
class struct__snd_config_update(Structure):
    __slots__ = [
    ]
struct__snd_config_update._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_config_update(Structure):
    __slots__ = [
    ]
struct__snd_config_update._fields_ = [
    ('_opaque_struct', c_int)
]

snd_config_update_t = struct__snd_config_update 	# /usr/include/alsa/conf.h:83
# /usr/include/alsa/conf.h:87
snd_config_top = _lib.snd_config_top
snd_config_top.restype = c_int
snd_config_top.argtypes = [POINTER(POINTER(snd_config_t))]

# /usr/include/alsa/conf.h:89
snd_config_load = _lib.snd_config_load
snd_config_load.restype = c_int
snd_config_load.argtypes = [POINTER(snd_config_t), POINTER(snd_input_t)]

# /usr/include/alsa/conf.h:90
snd_config_load_override = _lib.snd_config_load_override
snd_config_load_override.restype = c_int
snd_config_load_override.argtypes = [POINTER(snd_config_t), POINTER(snd_input_t)]

class struct__snd_output(Structure):
    __slots__ = [
    ]
struct__snd_output._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_output(Structure):
    __slots__ = [
    ]
struct__snd_output._fields_ = [
    ('_opaque_struct', c_int)
]

snd_output_t = struct__snd_output 	# /usr/include/alsa/output.h:54

# XXX output.h was not generated because of varargs, but we need this..
snd_output_stdio_open = _lib.snd_output_stdio_open
snd_output_stdio_open.restype = c_int
snd_output_stdio_open.argtypes = [POINTER(POINTER(snd_output_t)), c_char_p, c_char_p]

# XXX no args for varargs function (python can do formatting)
snd_output_printf = _lib.snd_output_printf
snd_output_printf.restype = c_int
snd_output_printf.argtypes = [POINTER(snd_output_t), c_char_p]

# /usr/include/alsa/conf.h:91
snd_config_save = _lib.snd_config_save
snd_config_save.restype = c_int
snd_config_save.argtypes = [POINTER(snd_config_t), POINTER(snd_output_t)]

# /usr/include/alsa/conf.h:92
snd_config_update = _lib.snd_config_update
snd_config_update.restype = c_int
snd_config_update.argtypes = []

# /usr/include/alsa/conf.h:93
snd_config_update_r = _lib.snd_config_update_r
snd_config_update_r.restype = c_int
snd_config_update_r.argtypes = [POINTER(POINTER(snd_config_t)), POINTER(POINTER(snd_config_update_t)), c_char_p]

# /usr/include/alsa/conf.h:94
snd_config_update_free = _lib.snd_config_update_free
snd_config_update_free.restype = c_int
snd_config_update_free.argtypes = [POINTER(snd_config_update_t)]

# /usr/include/alsa/conf.h:95
snd_config_update_free_global = _lib.snd_config_update_free_global
snd_config_update_free_global.restype = c_int
snd_config_update_free_global.argtypes = []

# /usr/include/alsa/conf.h:97
snd_config_search = _lib.snd_config_search
snd_config_search.restype = c_int
snd_config_search.argtypes = [POINTER(snd_config_t), c_char_p, POINTER(POINTER(snd_config_t))]

# /usr/include/alsa/conf.h:99
snd_config_searchv = _lib.snd_config_searchv
snd_config_searchv.restype = c_int
snd_config_searchv.argtypes = [POINTER(snd_config_t), POINTER(POINTER(snd_config_t))]

# /usr/include/alsa/conf.h:101
snd_config_search_definition = _lib.snd_config_search_definition
snd_config_search_definition.restype = c_int
snd_config_search_definition.argtypes = [POINTER(snd_config_t), c_char_p, c_char_p, POINTER(POINTER(snd_config_t))]

# /usr/include/alsa/conf.h:105
snd_config_expand = _lib.snd_config_expand
snd_config_expand.restype = c_int
snd_config_expand.argtypes = [POINTER(snd_config_t), POINTER(snd_config_t), c_char_p, POINTER(snd_config_t), POINTER(POINTER(snd_config_t))]

# /usr/include/alsa/conf.h:108
snd_config_evaluate = _lib.snd_config_evaluate
snd_config_evaluate.restype = c_int
snd_config_evaluate.argtypes = [POINTER(snd_config_t), POINTER(snd_config_t), POINTER(snd_config_t), POINTER(POINTER(snd_config_t))]

# /usr/include/alsa/conf.h:111
snd_config_add = _lib.snd_config_add
snd_config_add.restype = c_int
snd_config_add.argtypes = [POINTER(snd_config_t), POINTER(snd_config_t)]

# /usr/include/alsa/conf.h:112
snd_config_delete = _lib.snd_config_delete
snd_config_delete.restype = c_int
snd_config_delete.argtypes = [POINTER(snd_config_t)]

# /usr/include/alsa/conf.h:113
snd_config_delete_compound_members = _lib.snd_config_delete_compound_members
snd_config_delete_compound_members.restype = c_int
snd_config_delete_compound_members.argtypes = [POINTER(snd_config_t)]

# /usr/include/alsa/conf.h:114
snd_config_copy = _lib.snd_config_copy
snd_config_copy.restype = c_int
snd_config_copy.argtypes = [POINTER(POINTER(snd_config_t)), POINTER(snd_config_t)]

# /usr/include/alsa/conf.h:116
snd_config_make = _lib.snd_config_make
snd_config_make.restype = c_int
snd_config_make.argtypes = [POINTER(POINTER(snd_config_t)), c_char_p, snd_config_type_t]

# /usr/include/alsa/conf.h:118
snd_config_make_integer = _lib.snd_config_make_integer
snd_config_make_integer.restype = c_int
snd_config_make_integer.argtypes = [POINTER(POINTER(snd_config_t)), c_char_p]

# /usr/include/alsa/conf.h:119
snd_config_make_integer64 = _lib.snd_config_make_integer64
snd_config_make_integer64.restype = c_int
snd_config_make_integer64.argtypes = [POINTER(POINTER(snd_config_t)), c_char_p]

# /usr/include/alsa/conf.h:120
snd_config_make_real = _lib.snd_config_make_real
snd_config_make_real.restype = c_int
snd_config_make_real.argtypes = [POINTER(POINTER(snd_config_t)), c_char_p]

# /usr/include/alsa/conf.h:121
snd_config_make_string = _lib.snd_config_make_string
snd_config_make_string.restype = c_int
snd_config_make_string.argtypes = [POINTER(POINTER(snd_config_t)), c_char_p]

# /usr/include/alsa/conf.h:122
snd_config_make_pointer = _lib.snd_config_make_pointer
snd_config_make_pointer.restype = c_int
snd_config_make_pointer.argtypes = [POINTER(POINTER(snd_config_t)), c_char_p]

# /usr/include/alsa/conf.h:123
snd_config_make_compound = _lib.snd_config_make_compound
snd_config_make_compound.restype = c_int
snd_config_make_compound.argtypes = [POINTER(POINTER(snd_config_t)), c_char_p, c_int]

# /usr/include/alsa/conf.h:125
snd_config_imake_integer = _lib.snd_config_imake_integer
snd_config_imake_integer.restype = c_int
snd_config_imake_integer.argtypes = [POINTER(POINTER(snd_config_t)), c_char_p, c_long]

# /usr/include/alsa/conf.h:126
snd_config_imake_integer64 = _lib.snd_config_imake_integer64
snd_config_imake_integer64.restype = c_int
snd_config_imake_integer64.argtypes = [POINTER(POINTER(snd_config_t)), c_char_p, c_longlong]

# /usr/include/alsa/conf.h:127
snd_config_imake_real = _lib.snd_config_imake_real
snd_config_imake_real.restype = c_int
snd_config_imake_real.argtypes = [POINTER(POINTER(snd_config_t)), c_char_p, c_double]

# /usr/include/alsa/conf.h:128
snd_config_imake_string = _lib.snd_config_imake_string
snd_config_imake_string.restype = c_int
snd_config_imake_string.argtypes = [POINTER(POINTER(snd_config_t)), c_char_p, c_char_p]

# /usr/include/alsa/conf.h:129
snd_config_imake_pointer = _lib.snd_config_imake_pointer
snd_config_imake_pointer.restype = c_int
snd_config_imake_pointer.argtypes = [POINTER(POINTER(snd_config_t)), c_char_p, POINTER(None)]

# /usr/include/alsa/conf.h:131
snd_config_get_type = _lib.snd_config_get_type
snd_config_get_type.restype = snd_config_type_t
snd_config_get_type.argtypes = [POINTER(snd_config_t)]

# /usr/include/alsa/conf.h:133
snd_config_set_id = _lib.snd_config_set_id
snd_config_set_id.restype = c_int
snd_config_set_id.argtypes = [POINTER(snd_config_t), c_char_p]

# /usr/include/alsa/conf.h:134
snd_config_set_integer = _lib.snd_config_set_integer
snd_config_set_integer.restype = c_int
snd_config_set_integer.argtypes = [POINTER(snd_config_t), c_long]

# /usr/include/alsa/conf.h:135
snd_config_set_integer64 = _lib.snd_config_set_integer64
snd_config_set_integer64.restype = c_int
snd_config_set_integer64.argtypes = [POINTER(snd_config_t), c_longlong]

# /usr/include/alsa/conf.h:136
snd_config_set_real = _lib.snd_config_set_real
snd_config_set_real.restype = c_int
snd_config_set_real.argtypes = [POINTER(snd_config_t), c_double]

# /usr/include/alsa/conf.h:137
snd_config_set_string = _lib.snd_config_set_string
snd_config_set_string.restype = c_int
snd_config_set_string.argtypes = [POINTER(snd_config_t), c_char_p]

# /usr/include/alsa/conf.h:138
snd_config_set_ascii = _lib.snd_config_set_ascii
snd_config_set_ascii.restype = c_int
snd_config_set_ascii.argtypes = [POINTER(snd_config_t), c_char_p]

# /usr/include/alsa/conf.h:139
snd_config_set_pointer = _lib.snd_config_set_pointer
snd_config_set_pointer.restype = c_int
snd_config_set_pointer.argtypes = [POINTER(snd_config_t), POINTER(None)]

# /usr/include/alsa/conf.h:140
snd_config_get_id = _lib.snd_config_get_id
snd_config_get_id.restype = c_int
snd_config_get_id.argtypes = [POINTER(snd_config_t), POINTER(c_char_p)]

# /usr/include/alsa/conf.h:141
snd_config_get_integer = _lib.snd_config_get_integer
snd_config_get_integer.restype = c_int
snd_config_get_integer.argtypes = [POINTER(snd_config_t), POINTER(c_long)]

# /usr/include/alsa/conf.h:142
snd_config_get_integer64 = _lib.snd_config_get_integer64
snd_config_get_integer64.restype = c_int
snd_config_get_integer64.argtypes = [POINTER(snd_config_t), POINTER(c_longlong)]

# /usr/include/alsa/conf.h:143
snd_config_get_real = _lib.snd_config_get_real
snd_config_get_real.restype = c_int
snd_config_get_real.argtypes = [POINTER(snd_config_t), POINTER(c_double)]

# /usr/include/alsa/conf.h:144
snd_config_get_ireal = _lib.snd_config_get_ireal
snd_config_get_ireal.restype = c_int
snd_config_get_ireal.argtypes = [POINTER(snd_config_t), POINTER(c_double)]

# /usr/include/alsa/conf.h:145
snd_config_get_string = _lib.snd_config_get_string
snd_config_get_string.restype = c_int
snd_config_get_string.argtypes = [POINTER(snd_config_t), POINTER(c_char_p)]

# /usr/include/alsa/conf.h:146
snd_config_get_ascii = _lib.snd_config_get_ascii
snd_config_get_ascii.restype = c_int
snd_config_get_ascii.argtypes = [POINTER(snd_config_t), POINTER(c_char_p)]

# /usr/include/alsa/conf.h:147
snd_config_get_pointer = _lib.snd_config_get_pointer
snd_config_get_pointer.restype = c_int
snd_config_get_pointer.argtypes = [POINTER(snd_config_t), POINTER(POINTER(None))]

# /usr/include/alsa/conf.h:148
snd_config_test_id = _lib.snd_config_test_id
snd_config_test_id.restype = c_int
snd_config_test_id.argtypes = [POINTER(snd_config_t), c_char_p]

# /usr/include/alsa/conf.h:150
snd_config_iterator_first = _lib.snd_config_iterator_first
snd_config_iterator_first.restype = snd_config_iterator_t
snd_config_iterator_first.argtypes = [POINTER(snd_config_t)]

# /usr/include/alsa/conf.h:151
snd_config_iterator_next = _lib.snd_config_iterator_next
snd_config_iterator_next.restype = snd_config_iterator_t
snd_config_iterator_next.argtypes = [snd_config_iterator_t]

# /usr/include/alsa/conf.h:152
snd_config_iterator_end = _lib.snd_config_iterator_end
snd_config_iterator_end.restype = snd_config_iterator_t
snd_config_iterator_end.argtypes = [POINTER(snd_config_t)]

# /usr/include/alsa/conf.h:153
snd_config_iterator_entry = _lib.snd_config_iterator_entry
snd_config_iterator_entry.restype = POINTER(snd_config_t)
snd_config_iterator_entry.argtypes = [snd_config_iterator_t]

# /usr/include/alsa/conf.h:168
snd_config_get_bool_ascii = _lib.snd_config_get_bool_ascii
snd_config_get_bool_ascii.restype = c_int
snd_config_get_bool_ascii.argtypes = [c_char_p]

# /usr/include/alsa/conf.h:169
snd_config_get_bool = _lib.snd_config_get_bool
snd_config_get_bool.restype = c_int
snd_config_get_bool.argtypes = [POINTER(snd_config_t)]

# /usr/include/alsa/conf.h:170
snd_config_get_ctl_iface_ascii = _lib.snd_config_get_ctl_iface_ascii
snd_config_get_ctl_iface_ascii.restype = c_int
snd_config_get_ctl_iface_ascii.argtypes = [c_char_p]

# /usr/include/alsa/conf.h:171
snd_config_get_ctl_iface = _lib.snd_config_get_ctl_iface
snd_config_get_ctl_iface.restype = c_int
snd_config_get_ctl_iface.argtypes = [POINTER(snd_config_t)]

class struct_snd_devname(Structure):
    __slots__ = [
    ]
struct_snd_devname._fields_ = [
    ('_opaque_struct', c_int)
]

class struct_snd_devname(Structure):
    __slots__ = [
    ]
struct_snd_devname._fields_ = [
    ('_opaque_struct', c_int)
]

snd_devname_t = struct_snd_devname 	# /usr/include/alsa/conf.h:178
# /usr/include/alsa/conf.h:189
snd_names_list = _lib.snd_names_list
snd_names_list.restype = c_int
snd_names_list.argtypes = [c_char_p, POINTER(POINTER(snd_devname_t))]

# /usr/include/alsa/conf.h:190
snd_names_list_free = _lib.snd_names_list_free
snd_names_list_free.restype = None
snd_names_list_free.argtypes = [POINTER(snd_devname_t)]

SND_PCM_DLSYM_VERSION = 0 	# /usr/include/alsa/pcm.h:43
class struct__snd_pcm_info(Structure):
    __slots__ = [
    ]
struct__snd_pcm_info._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_pcm_info(Structure):
    __slots__ = [
    ]
struct__snd_pcm_info._fields_ = [
    ('_opaque_struct', c_int)
]

snd_pcm_info_t = struct__snd_pcm_info 	# /usr/include/alsa/pcm.h:46
class struct__snd_pcm_hw_params(Structure):
    __slots__ = [
    ]
struct__snd_pcm_hw_params._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_pcm_hw_params(Structure):
    __slots__ = [
    ]
struct__snd_pcm_hw_params._fields_ = [
    ('_opaque_struct', c_int)
]

snd_pcm_hw_params_t = struct__snd_pcm_hw_params 	# /usr/include/alsa/pcm.h:48
class struct__snd_pcm_sw_params(Structure):
    __slots__ = [
    ]
struct__snd_pcm_sw_params._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_pcm_sw_params(Structure):
    __slots__ = [
    ]
struct__snd_pcm_sw_params._fields_ = [
    ('_opaque_struct', c_int)
]

snd_pcm_sw_params_t = struct__snd_pcm_sw_params 	# /usr/include/alsa/pcm.h:50
class struct__snd_pcm_status(Structure):
    __slots__ = [
    ]
struct__snd_pcm_status._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_pcm_status(Structure):
    __slots__ = [
    ]
struct__snd_pcm_status._fields_ = [
    ('_opaque_struct', c_int)
]

snd_pcm_status_t = struct__snd_pcm_status 	# /usr/include/alsa/pcm.h:52
class struct__snd_pcm_access_mask(Structure):
    __slots__ = [
    ]
struct__snd_pcm_access_mask._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_pcm_access_mask(Structure):
    __slots__ = [
    ]
struct__snd_pcm_access_mask._fields_ = [
    ('_opaque_struct', c_int)
]

snd_pcm_access_mask_t = struct__snd_pcm_access_mask 	# /usr/include/alsa/pcm.h:54
class struct__snd_pcm_format_mask(Structure):
    __slots__ = [
    ]
struct__snd_pcm_format_mask._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_pcm_format_mask(Structure):
    __slots__ = [
    ]
struct__snd_pcm_format_mask._fields_ = [
    ('_opaque_struct', c_int)
]

snd_pcm_format_mask_t = struct__snd_pcm_format_mask 	# /usr/include/alsa/pcm.h:56
class struct__snd_pcm_subformat_mask(Structure):
    __slots__ = [
    ]
struct__snd_pcm_subformat_mask._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_pcm_subformat_mask(Structure):
    __slots__ = [
    ]
struct__snd_pcm_subformat_mask._fields_ = [
    ('_opaque_struct', c_int)
]

snd_pcm_subformat_mask_t = struct__snd_pcm_subformat_mask 	# /usr/include/alsa/pcm.h:58
enum__snd_pcm_class = c_int
SND_PCM_CLASS_GENERIC = 0
SND_PCM_CLASS_MULTI = 1
SND_PCM_CLASS_MODEM = 2
SND_PCM_CLASS_DIGITIZER = 3
SND_PCM_CLASS_LAST = 0
snd_pcm_class_t = enum__snd_pcm_class 	# /usr/include/alsa/pcm.h:72
enum__snd_pcm_subclass = c_int
SND_PCM_SUBCLASS_GENERIC_MIX = 0
SND_PCM_SUBCLASS_MULTI_MIX = 1
SND_PCM_SUBCLASS_LAST = 0
snd_pcm_subclass_t = enum__snd_pcm_subclass 	# /usr/include/alsa/pcm.h:81
enum__snd_pcm_stream = c_int
SND_PCM_STREAM_PLAYBACK = 0
SND_PCM_STREAM_CAPTURE = 1
SND_PCM_STREAM_LAST = 0
snd_pcm_stream_t = enum__snd_pcm_stream 	# /usr/include/alsa/pcm.h:90
enum__snd_pcm_access = c_int
SND_PCM_ACCESS_MMAP_INTERLEAVED = 0
SND_PCM_ACCESS_MMAP_NONINTERLEAVED = 1
SND_PCM_ACCESS_MMAP_COMPLEX = 2
SND_PCM_ACCESS_RW_INTERLEAVED = 3
SND_PCM_ACCESS_RW_NONINTERLEAVED = 4
SND_PCM_ACCESS_LAST = 0
snd_pcm_access_t = enum__snd_pcm_access 	# /usr/include/alsa/pcm.h:105
enum__snd_pcm_format = c_int
SND_PCM_FORMAT_UNKNOWN = 1
SND_PCM_FORMAT_S8 = 0
SND_PCM_FORMAT_U8 = 1
SND_PCM_FORMAT_S16_LE = 2
SND_PCM_FORMAT_S16_BE = 3
SND_PCM_FORMAT_U16_LE = 4
SND_PCM_FORMAT_U16_BE = 5
SND_PCM_FORMAT_S24_LE = 6
SND_PCM_FORMAT_S24_BE = 7
SND_PCM_FORMAT_U24_LE = 8
SND_PCM_FORMAT_U24_BE = 9
SND_PCM_FORMAT_S32_LE = 10
SND_PCM_FORMAT_S32_BE = 11
SND_PCM_FORMAT_U32_LE = 12
SND_PCM_FORMAT_U32_BE = 13
SND_PCM_FORMAT_FLOAT_LE = 14
SND_PCM_FORMAT_FLOAT_BE = 15
SND_PCM_FORMAT_FLOAT64_LE = 16
SND_PCM_FORMAT_FLOAT64_BE = 17
SND_PCM_FORMAT_IEC958_SUBFRAME_LE = 18
SND_PCM_FORMAT_IEC958_SUBFRAME_BE = 19
SND_PCM_FORMAT_MU_LAW = 20
SND_PCM_FORMAT_A_LAW = 21
SND_PCM_FORMAT_IMA_ADPCM = 22
SND_PCM_FORMAT_MPEG = 23
SND_PCM_FORMAT_GSM = 24
SND_PCM_FORMAT_SPECIAL = 31
SND_PCM_FORMAT_S24_3LE = 32
SND_PCM_FORMAT_S24_3BE = 33
SND_PCM_FORMAT_U24_3LE = 34
SND_PCM_FORMAT_U24_3BE = 35
SND_PCM_FORMAT_S20_3LE = 36
SND_PCM_FORMAT_S20_3BE = 37
SND_PCM_FORMAT_U20_3LE = 38
SND_PCM_FORMAT_U20_3BE = 39
SND_PCM_FORMAT_S18_3LE = 40
SND_PCM_FORMAT_S18_3BE = 41
SND_PCM_FORMAT_U18_3LE = 42
SND_PCM_FORMAT_U18_3BE = 43
SND_PCM_FORMAT_LAST = 0

# XXX wraptypes didn't pick up byte order detection
import sys
if sys.byteorder == 'little':
    SND_PCM_FORMAT_S16 = SND_PCM_FORMAT_S16_LE
    SND_PCM_FORMAT_U16 = SND_PCM_FORMAT_U16_LE
    SND_PCM_FORMAT_S24 = SND_PCM_FORMAT_S24_LE
    SND_PCM_FORMAT_U24 = SND_PCM_FORMAT_U24_LE
    SND_PCM_FORMAT_S32 = SND_PCM_FORMAT_S32_LE
    SND_PCM_FORMAT_U32 = SND_PCM_FORMAT_U32_LE
    SND_PCM_FORMAT_FLOAT = SND_PCM_FORMAT_FLOAT_LE
    SND_PCM_FORMAT_FLOAT64 = SND_PCM_FORMAT_FLOAT64_LE
    SND_PCM_FORMAT_IEC958_SUBFRAME = SND_PCM_FORMAT_IEC958_SUBFRAME_LE
else:
    SND_PCM_FORMAT_S16 = SND_PCM_FORMAT_S16_BE
    SND_PCM_FORMAT_U16 = SND_PCM_FORMAT_U16_BE
    SND_PCM_FORMAT_S24 = SND_PCM_FORMAT_S24_BE
    SND_PCM_FORMAT_U24 = SND_PCM_FORMAT_U24_BE
    SND_PCM_FORMAT_S32 = SND_PCM_FORMAT_S32_BE
    SND_PCM_FORMAT_U32 = SND_PCM_FORMAT_U32_BE
    SND_PCM_FORMAT_FLOAT = SND_PCM_FORMAT_FLOAT_BE
    SND_PCM_FORMAT_FLOAT64 = SND_PCM_FORMAT_FLOAT64_BE
    SND_PCM_FORMAT_IEC958_SUBFRAME = SND_PCM_FORMAT_IEC958_SUBFRAME_BE

snd_pcm_format_t = enum__snd_pcm_format 	# /usr/include/alsa/pcm.h:230
enum__snd_pcm_subformat = c_int
SND_PCM_SUBFORMAT_STD = 0
SND_PCM_SUBFORMAT_LAST = 0
snd_pcm_subformat_t = enum__snd_pcm_subformat 	# /usr/include/alsa/pcm.h:237
enum__snd_pcm_state = c_int
SND_PCM_STATE_OPEN = 0
SND_PCM_STATE_SETUP = 1
SND_PCM_STATE_PREPARED = 2
SND_PCM_STATE_RUNNING = 3
SND_PCM_STATE_XRUN = 4
SND_PCM_STATE_DRAINING = 5
SND_PCM_STATE_PAUSED = 6
SND_PCM_STATE_SUSPENDED = 7
SND_PCM_STATE_DISCONNECTED = 8
SND_PCM_STATE_LAST = 0
snd_pcm_state_t = enum__snd_pcm_state 	# /usr/include/alsa/pcm.h:260
enum__snd_pcm_start = c_int
SND_PCM_START_DATA = 0
SND_PCM_START_EXPLICIT = 1
SND_PCM_START_LAST = 0
snd_pcm_start_t = enum__snd_pcm_start 	# /usr/include/alsa/pcm.h:269
enum__snd_pcm_xrun = c_int
SND_PCM_XRUN_NONE = 0
SND_PCM_XRUN_STOP = 1
SND_PCM_XRUN_LAST = 0
snd_pcm_xrun_t = enum__snd_pcm_xrun 	# /usr/include/alsa/pcm.h:278
enum__snd_pcm_tstamp = c_int
SND_PCM_TSTAMP_NONE = 0
SND_PCM_TSTAMP_MMAP = 1
SND_PCM_TSTAMP_LAST = 0
snd_pcm_tstamp_t = enum__snd_pcm_tstamp 	# /usr/include/alsa/pcm.h:287
snd_pcm_uframes_t = c_ulong 	# /usr/include/alsa/pcm.h:290
snd_pcm_sframes_t = c_long 	# /usr/include/alsa/pcm.h:292
SND_PCM_NONBLOCK = 1 	# /usr/include/alsa/pcm.h:295
SND_PCM_ASYNC = 2 	# /usr/include/alsa/pcm.h:297
class struct__snd_pcm(Structure):
    __slots__ = [
    ]
struct__snd_pcm._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_pcm(Structure):
    __slots__ = [
    ]
struct__snd_pcm._fields_ = [
    ('_opaque_struct', c_int)
]

snd_pcm_t = struct__snd_pcm 	# /usr/include/alsa/pcm.h:300
enum__snd_pcm_type = c_int
snd_pcm_type_t = enum__snd_pcm_type 	# /usr/include/alsa/pcm.h:369
class struct__snd_pcm_channel_area(Structure):
    __slots__ = [
        'addr',
        'first',
        'step',
    ]
struct__snd_pcm_channel_area._fields_ = [
    ('addr', POINTER(None)),
    ('first', c_uint),
    ('step', c_uint),
]

snd_pcm_channel_area_t = struct__snd_pcm_channel_area 	# /usr/include/alsa/pcm.h:379
class struct__snd_pcm_sync_id(Union):
    __slots__ = [
        'id',
        'id16',
        'id32',
    ]
struct__snd_pcm_sync_id._fields_ = [
    ('id', c_ubyte * 16),
    ('id16', c_ushort * 8),
    ('id32', c_uint * 4),
]

snd_pcm_sync_id_t = struct__snd_pcm_sync_id 	# /usr/include/alsa/pcm.h:389
class struct__snd_pcm_scope(Structure):
    __slots__ = [
    ]
struct__snd_pcm_scope._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_pcm_scope(Structure):
    __slots__ = [
    ]
struct__snd_pcm_scope._fields_ = [
    ('_opaque_struct', c_int)
]

snd_pcm_scope_t = struct__snd_pcm_scope 	# /usr/include/alsa/pcm.h:392
# /usr/include/alsa/pcm.h:394
snd_pcm_open = _lib.snd_pcm_open
snd_pcm_open.restype = c_int
snd_pcm_open.argtypes = [POINTER(POINTER(snd_pcm_t)), c_char_p, snd_pcm_stream_t, c_int]

# /usr/include/alsa/pcm.h:396
snd_pcm_open_lconf = _lib.snd_pcm_open_lconf
snd_pcm_open_lconf.restype = c_int
snd_pcm_open_lconf.argtypes = [POINTER(POINTER(snd_pcm_t)), c_char_p, snd_pcm_stream_t, c_int, POINTER(snd_config_t)]

# /usr/include/alsa/pcm.h:400
snd_pcm_close = _lib.snd_pcm_close
snd_pcm_close.restype = c_int
snd_pcm_close.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:401
snd_pcm_name = _lib.snd_pcm_name
snd_pcm_name.restype = c_char_p
snd_pcm_name.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:402
snd_pcm_type = _lib.snd_pcm_type
snd_pcm_type.restype = snd_pcm_type_t
snd_pcm_type.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:403
snd_pcm_stream = _lib.snd_pcm_stream
snd_pcm_stream.restype = snd_pcm_stream_t
snd_pcm_stream.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:404
snd_pcm_poll_descriptors_count = _lib.snd_pcm_poll_descriptors_count
snd_pcm_poll_descriptors_count.restype = c_int
snd_pcm_poll_descriptors_count.argtypes = [POINTER(snd_pcm_t)]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/pcm.h:405
snd_pcm_poll_descriptors = _lib.snd_pcm_poll_descriptors
snd_pcm_poll_descriptors.restype = c_int
snd_pcm_poll_descriptors.argtypes = [POINTER(snd_pcm_t), POINTER(struct_pollfd), c_uint]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/pcm.h:406
snd_pcm_poll_descriptors_revents = _lib.snd_pcm_poll_descriptors_revents
snd_pcm_poll_descriptors_revents.restype = c_int
snd_pcm_poll_descriptors_revents.argtypes = [POINTER(snd_pcm_t), POINTER(struct_pollfd), c_uint, POINTER(c_ushort)]

# /usr/include/alsa/pcm.h:407
snd_pcm_nonblock = _lib.snd_pcm_nonblock
snd_pcm_nonblock.restype = c_int
snd_pcm_nonblock.argtypes = [POINTER(snd_pcm_t), c_int]

# /usr/include/alsa/pcm.h:408
snd_async_add_pcm_handler = _lib.snd_async_add_pcm_handler
snd_async_add_pcm_handler.restype = c_int
snd_async_add_pcm_handler.argtypes = [POINTER(POINTER(snd_async_handler_t)), POINTER(snd_pcm_t), snd_async_callback_t, POINTER(None)]

# /usr/include/alsa/pcm.h:410
snd_async_handler_get_pcm = _lib.snd_async_handler_get_pcm
snd_async_handler_get_pcm.restype = POINTER(snd_pcm_t)
snd_async_handler_get_pcm.argtypes = [POINTER(snd_async_handler_t)]

# /usr/include/alsa/pcm.h:411
snd_pcm_info = _lib.snd_pcm_info
snd_pcm_info.restype = c_int
snd_pcm_info.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_info_t)]

# /usr/include/alsa/pcm.h:412
snd_pcm_hw_params_current = _lib.snd_pcm_hw_params_current
snd_pcm_hw_params_current.restype = c_int
snd_pcm_hw_params_current.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:413
snd_pcm_hw_params = _lib.snd_pcm_hw_params
snd_pcm_hw_params.restype = c_int
snd_pcm_hw_params.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:414
snd_pcm_hw_free = _lib.snd_pcm_hw_free
snd_pcm_hw_free.restype = c_int
snd_pcm_hw_free.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:415
snd_pcm_sw_params_current = _lib.snd_pcm_sw_params_current
snd_pcm_sw_params_current.restype = c_int
snd_pcm_sw_params_current.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_sw_params_t)]

# /usr/include/alsa/pcm.h:416
snd_pcm_sw_params = _lib.snd_pcm_sw_params
snd_pcm_sw_params.restype = c_int
snd_pcm_sw_params.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_sw_params_t)]

# /usr/include/alsa/pcm.h:417
snd_pcm_prepare = _lib.snd_pcm_prepare
snd_pcm_prepare.restype = c_int
snd_pcm_prepare.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:418
snd_pcm_reset = _lib.snd_pcm_reset
snd_pcm_reset.restype = c_int
snd_pcm_reset.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:419
snd_pcm_status = _lib.snd_pcm_status
snd_pcm_status.restype = c_int
snd_pcm_status.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_status_t)]

# /usr/include/alsa/pcm.h:420
snd_pcm_start = _lib.snd_pcm_start
snd_pcm_start.restype = c_int
snd_pcm_start.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:421
snd_pcm_drop = _lib.snd_pcm_drop
snd_pcm_drop.restype = c_int
snd_pcm_drop.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:422
snd_pcm_drain = _lib.snd_pcm_drain
snd_pcm_drain.restype = c_int
snd_pcm_drain.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:423
snd_pcm_pause = _lib.snd_pcm_pause
snd_pcm_pause.restype = c_int
snd_pcm_pause.argtypes = [POINTER(snd_pcm_t), c_int]

# /usr/include/alsa/pcm.h:424
snd_pcm_state = _lib.snd_pcm_state
snd_pcm_state.restype = snd_pcm_state_t
snd_pcm_state.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:425
snd_pcm_hwsync = _lib.snd_pcm_hwsync
snd_pcm_hwsync.restype = c_int
snd_pcm_hwsync.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:426
snd_pcm_delay = _lib.snd_pcm_delay
snd_pcm_delay.restype = c_int
snd_pcm_delay.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_sframes_t)]

# /usr/include/alsa/pcm.h:427
snd_pcm_resume = _lib.snd_pcm_resume
snd_pcm_resume.restype = c_int
snd_pcm_resume.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:428
snd_pcm_avail_update = _lib.snd_pcm_avail_update
snd_pcm_avail_update.restype = snd_pcm_sframes_t
snd_pcm_avail_update.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:429
snd_pcm_rewind = _lib.snd_pcm_rewind
snd_pcm_rewind.restype = snd_pcm_sframes_t
snd_pcm_rewind.argtypes = [POINTER(snd_pcm_t), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:430
snd_pcm_forward = _lib.snd_pcm_forward
snd_pcm_forward.restype = snd_pcm_sframes_t
snd_pcm_forward.argtypes = [POINTER(snd_pcm_t), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:431
snd_pcm_writei = _lib.snd_pcm_writei
snd_pcm_writei.restype = snd_pcm_sframes_t
snd_pcm_writei.argtypes = [POINTER(snd_pcm_t), POINTER(None), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:432
snd_pcm_readi = _lib.snd_pcm_readi
snd_pcm_readi.restype = snd_pcm_sframes_t
snd_pcm_readi.argtypes = [POINTER(snd_pcm_t), POINTER(None), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:433
snd_pcm_writen = _lib.snd_pcm_writen
snd_pcm_writen.restype = snd_pcm_sframes_t
snd_pcm_writen.argtypes = [POINTER(snd_pcm_t), POINTER(POINTER(None)), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:434
snd_pcm_readn = _lib.snd_pcm_readn
snd_pcm_readn.restype = snd_pcm_sframes_t
snd_pcm_readn.argtypes = [POINTER(snd_pcm_t), POINTER(POINTER(None)), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:435
snd_pcm_wait = _lib.snd_pcm_wait
snd_pcm_wait.restype = c_int
snd_pcm_wait.argtypes = [POINTER(snd_pcm_t), c_int]

# /usr/include/alsa/pcm.h:437
snd_pcm_link = _lib.snd_pcm_link
snd_pcm_link.restype = c_int
snd_pcm_link.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:438
snd_pcm_unlink = _lib.snd_pcm_unlink
snd_pcm_unlink.restype = c_int
snd_pcm_unlink.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:445
snd_pcm_recover = _lib.snd_pcm_recover
snd_pcm_recover.restype = c_int
snd_pcm_recover.argtypes = [POINTER(snd_pcm_t), c_int, c_int]

# /usr/include/alsa/pcm.h:446
snd_pcm_set_params = _lib.snd_pcm_set_params
snd_pcm_set_params.restype = c_int
snd_pcm_set_params.argtypes = [POINTER(snd_pcm_t), snd_pcm_format_t, snd_pcm_access_t, c_uint, c_uint, c_int, c_uint]

# /usr/include/alsa/pcm.h:453
snd_pcm_get_params = _lib.snd_pcm_get_params
snd_pcm_get_params.restype = c_int
snd_pcm_get_params.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_uframes_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:466
snd_pcm_info_sizeof = _lib.snd_pcm_info_sizeof
snd_pcm_info_sizeof.restype = c_size_t
snd_pcm_info_sizeof.argtypes = []

# /usr/include/alsa/pcm.h:472
snd_pcm_info_malloc = _lib.snd_pcm_info_malloc
snd_pcm_info_malloc.restype = c_int
snd_pcm_info_malloc.argtypes = [POINTER(POINTER(snd_pcm_info_t))]

# /usr/include/alsa/pcm.h:473
snd_pcm_info_free = _lib.snd_pcm_info_free
snd_pcm_info_free.restype = None
snd_pcm_info_free.argtypes = [POINTER(snd_pcm_info_t)]

# /usr/include/alsa/pcm.h:474
snd_pcm_info_copy = _lib.snd_pcm_info_copy
snd_pcm_info_copy.restype = None
snd_pcm_info_copy.argtypes = [POINTER(snd_pcm_info_t), POINTER(snd_pcm_info_t)]

# /usr/include/alsa/pcm.h:475
snd_pcm_info_get_device = _lib.snd_pcm_info_get_device
snd_pcm_info_get_device.restype = c_uint
snd_pcm_info_get_device.argtypes = [POINTER(snd_pcm_info_t)]

# /usr/include/alsa/pcm.h:476
snd_pcm_info_get_subdevice = _lib.snd_pcm_info_get_subdevice
snd_pcm_info_get_subdevice.restype = c_uint
snd_pcm_info_get_subdevice.argtypes = [POINTER(snd_pcm_info_t)]

# /usr/include/alsa/pcm.h:477
snd_pcm_info_get_stream = _lib.snd_pcm_info_get_stream
snd_pcm_info_get_stream.restype = snd_pcm_stream_t
snd_pcm_info_get_stream.argtypes = [POINTER(snd_pcm_info_t)]

# /usr/include/alsa/pcm.h:478
snd_pcm_info_get_card = _lib.snd_pcm_info_get_card
snd_pcm_info_get_card.restype = c_int
snd_pcm_info_get_card.argtypes = [POINTER(snd_pcm_info_t)]

# /usr/include/alsa/pcm.h:479
snd_pcm_info_get_id = _lib.snd_pcm_info_get_id
snd_pcm_info_get_id.restype = c_char_p
snd_pcm_info_get_id.argtypes = [POINTER(snd_pcm_info_t)]

# /usr/include/alsa/pcm.h:480
snd_pcm_info_get_name = _lib.snd_pcm_info_get_name
snd_pcm_info_get_name.restype = c_char_p
snd_pcm_info_get_name.argtypes = [POINTER(snd_pcm_info_t)]

# /usr/include/alsa/pcm.h:481
snd_pcm_info_get_subdevice_name = _lib.snd_pcm_info_get_subdevice_name
snd_pcm_info_get_subdevice_name.restype = c_char_p
snd_pcm_info_get_subdevice_name.argtypes = [POINTER(snd_pcm_info_t)]

# /usr/include/alsa/pcm.h:482
snd_pcm_info_get_class = _lib.snd_pcm_info_get_class
snd_pcm_info_get_class.restype = snd_pcm_class_t
snd_pcm_info_get_class.argtypes = [POINTER(snd_pcm_info_t)]

# /usr/include/alsa/pcm.h:483
snd_pcm_info_get_subclass = _lib.snd_pcm_info_get_subclass
snd_pcm_info_get_subclass.restype = snd_pcm_subclass_t
snd_pcm_info_get_subclass.argtypes = [POINTER(snd_pcm_info_t)]

# /usr/include/alsa/pcm.h:484
snd_pcm_info_get_subdevices_count = _lib.snd_pcm_info_get_subdevices_count
snd_pcm_info_get_subdevices_count.restype = c_uint
snd_pcm_info_get_subdevices_count.argtypes = [POINTER(snd_pcm_info_t)]

# /usr/include/alsa/pcm.h:485
snd_pcm_info_get_subdevices_avail = _lib.snd_pcm_info_get_subdevices_avail
snd_pcm_info_get_subdevices_avail.restype = c_uint
snd_pcm_info_get_subdevices_avail.argtypes = [POINTER(snd_pcm_info_t)]

# /usr/include/alsa/pcm.h:486
snd_pcm_info_get_sync = _lib.snd_pcm_info_get_sync
snd_pcm_info_get_sync.restype = snd_pcm_sync_id_t
snd_pcm_info_get_sync.argtypes = [POINTER(snd_pcm_info_t)]

# /usr/include/alsa/pcm.h:487
snd_pcm_info_set_device = _lib.snd_pcm_info_set_device
snd_pcm_info_set_device.restype = None
snd_pcm_info_set_device.argtypes = [POINTER(snd_pcm_info_t), c_uint]

# /usr/include/alsa/pcm.h:488
snd_pcm_info_set_subdevice = _lib.snd_pcm_info_set_subdevice
snd_pcm_info_set_subdevice.restype = None
snd_pcm_info_set_subdevice.argtypes = [POINTER(snd_pcm_info_t), c_uint]

# /usr/include/alsa/pcm.h:489
snd_pcm_info_set_stream = _lib.snd_pcm_info_set_stream
snd_pcm_info_set_stream.restype = None
snd_pcm_info_set_stream.argtypes = [POINTER(snd_pcm_info_t), snd_pcm_stream_t]

# /usr/include/alsa/pcm.h:500
snd_pcm_hw_params_any = _lib.snd_pcm_hw_params_any
snd_pcm_hw_params_any.restype = c_int
snd_pcm_hw_params_any.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:502
snd_pcm_hw_params_can_mmap_sample_resolution = _lib.snd_pcm_hw_params_can_mmap_sample_resolution
snd_pcm_hw_params_can_mmap_sample_resolution.restype = c_int
snd_pcm_hw_params_can_mmap_sample_resolution.argtypes = [POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:503
snd_pcm_hw_params_is_double = _lib.snd_pcm_hw_params_is_double
snd_pcm_hw_params_is_double.restype = c_int
snd_pcm_hw_params_is_double.argtypes = [POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:504
snd_pcm_hw_params_is_batch = _lib.snd_pcm_hw_params_is_batch
snd_pcm_hw_params_is_batch.restype = c_int
snd_pcm_hw_params_is_batch.argtypes = [POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:505
snd_pcm_hw_params_is_block_transfer = _lib.snd_pcm_hw_params_is_block_transfer
snd_pcm_hw_params_is_block_transfer.restype = c_int
snd_pcm_hw_params_is_block_transfer.argtypes = [POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:506
snd_pcm_hw_params_can_overrange = _lib.snd_pcm_hw_params_can_overrange
snd_pcm_hw_params_can_overrange.restype = c_int
snd_pcm_hw_params_can_overrange.argtypes = [POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:507
snd_pcm_hw_params_can_pause = _lib.snd_pcm_hw_params_can_pause
snd_pcm_hw_params_can_pause.restype = c_int
snd_pcm_hw_params_can_pause.argtypes = [POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:508
snd_pcm_hw_params_can_resume = _lib.snd_pcm_hw_params_can_resume
snd_pcm_hw_params_can_resume.restype = c_int
snd_pcm_hw_params_can_resume.argtypes = [POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:509
snd_pcm_hw_params_is_half_duplex = _lib.snd_pcm_hw_params_is_half_duplex
snd_pcm_hw_params_is_half_duplex.restype = c_int
snd_pcm_hw_params_is_half_duplex.argtypes = [POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:510
snd_pcm_hw_params_is_joint_duplex = _lib.snd_pcm_hw_params_is_joint_duplex
snd_pcm_hw_params_is_joint_duplex.restype = c_int
snd_pcm_hw_params_is_joint_duplex.argtypes = [POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:511
snd_pcm_hw_params_can_sync_start = _lib.snd_pcm_hw_params_can_sync_start
snd_pcm_hw_params_can_sync_start.restype = c_int
snd_pcm_hw_params_can_sync_start.argtypes = [POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:512
snd_pcm_hw_params_get_rate_numden = _lib.snd_pcm_hw_params_get_rate_numden
snd_pcm_hw_params_get_rate_numden.restype = c_int
snd_pcm_hw_params_get_rate_numden.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_uint)]

# /usr/include/alsa/pcm.h:515
snd_pcm_hw_params_get_sbits = _lib.snd_pcm_hw_params_get_sbits
snd_pcm_hw_params_get_sbits.restype = c_int
snd_pcm_hw_params_get_sbits.argtypes = [POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:516
snd_pcm_hw_params_get_fifo_size = _lib.snd_pcm_hw_params_get_fifo_size
snd_pcm_hw_params_get_fifo_size.restype = c_int
snd_pcm_hw_params_get_fifo_size.argtypes = [POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:544
snd_pcm_hw_params_sizeof = _lib.snd_pcm_hw_params_sizeof
snd_pcm_hw_params_sizeof.restype = c_size_t
snd_pcm_hw_params_sizeof.argtypes = []

# /usr/include/alsa/pcm.h:550
snd_pcm_hw_params_malloc = _lib.snd_pcm_hw_params_malloc
snd_pcm_hw_params_malloc.restype = c_int
snd_pcm_hw_params_malloc.argtypes = [POINTER(POINTER(snd_pcm_hw_params_t))]

# /usr/include/alsa/pcm.h:551
snd_pcm_hw_params_free = _lib.snd_pcm_hw_params_free
snd_pcm_hw_params_free.restype = None
snd_pcm_hw_params_free.argtypes = [POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:552
snd_pcm_hw_params_copy = _lib.snd_pcm_hw_params_copy
snd_pcm_hw_params_copy.restype = None
snd_pcm_hw_params_copy.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:556
snd_pcm_hw_params_get_access = _lib.snd_pcm_hw_params_get_access
snd_pcm_hw_params_get_access.restype = c_int
snd_pcm_hw_params_get_access.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_access_t)]

# /usr/include/alsa/pcm.h:557
snd_pcm_hw_params_test_access = _lib.snd_pcm_hw_params_test_access
snd_pcm_hw_params_test_access.restype = c_int
snd_pcm_hw_params_test_access.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), snd_pcm_access_t]

# /usr/include/alsa/pcm.h:558
snd_pcm_hw_params_set_access = _lib.snd_pcm_hw_params_set_access
snd_pcm_hw_params_set_access.restype = c_int
snd_pcm_hw_params_set_access.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), snd_pcm_access_t]

# /usr/include/alsa/pcm.h:559
snd_pcm_hw_params_set_access_first = _lib.snd_pcm_hw_params_set_access_first
snd_pcm_hw_params_set_access_first.restype = c_int
snd_pcm_hw_params_set_access_first.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_access_t)]

# /usr/include/alsa/pcm.h:560
snd_pcm_hw_params_set_access_last = _lib.snd_pcm_hw_params_set_access_last
snd_pcm_hw_params_set_access_last.restype = c_int
snd_pcm_hw_params_set_access_last.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_access_t)]

# /usr/include/alsa/pcm.h:561
snd_pcm_hw_params_set_access_mask = _lib.snd_pcm_hw_params_set_access_mask
snd_pcm_hw_params_set_access_mask.restype = c_int
snd_pcm_hw_params_set_access_mask.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_access_mask_t)]

# /usr/include/alsa/pcm.h:562
snd_pcm_hw_params_get_access_mask = _lib.snd_pcm_hw_params_get_access_mask
snd_pcm_hw_params_get_access_mask.restype = c_int
snd_pcm_hw_params_get_access_mask.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_access_mask_t)]

# /usr/include/alsa/pcm.h:564
snd_pcm_hw_params_get_format = _lib.snd_pcm_hw_params_get_format
snd_pcm_hw_params_get_format.restype = c_int
snd_pcm_hw_params_get_format.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_format_t)]

# /usr/include/alsa/pcm.h:565
snd_pcm_hw_params_test_format = _lib.snd_pcm_hw_params_test_format
snd_pcm_hw_params_test_format.restype = c_int
snd_pcm_hw_params_test_format.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), snd_pcm_format_t]

# /usr/include/alsa/pcm.h:566
snd_pcm_hw_params_set_format = _lib.snd_pcm_hw_params_set_format
snd_pcm_hw_params_set_format.restype = c_int
snd_pcm_hw_params_set_format.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), snd_pcm_format_t]

# /usr/include/alsa/pcm.h:567
snd_pcm_hw_params_set_format_first = _lib.snd_pcm_hw_params_set_format_first
snd_pcm_hw_params_set_format_first.restype = c_int
snd_pcm_hw_params_set_format_first.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_format_t)]

# /usr/include/alsa/pcm.h:568
snd_pcm_hw_params_set_format_last = _lib.snd_pcm_hw_params_set_format_last
snd_pcm_hw_params_set_format_last.restype = c_int
snd_pcm_hw_params_set_format_last.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_format_t)]

# /usr/include/alsa/pcm.h:569
snd_pcm_hw_params_set_format_mask = _lib.snd_pcm_hw_params_set_format_mask
snd_pcm_hw_params_set_format_mask.restype = c_int
snd_pcm_hw_params_set_format_mask.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_format_mask_t)]

# /usr/include/alsa/pcm.h:570
snd_pcm_hw_params_get_format_mask = _lib.snd_pcm_hw_params_get_format_mask
snd_pcm_hw_params_get_format_mask.restype = None
snd_pcm_hw_params_get_format_mask.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_format_mask_t)]

# /usr/include/alsa/pcm.h:572
snd_pcm_hw_params_get_subformat = _lib.snd_pcm_hw_params_get_subformat
snd_pcm_hw_params_get_subformat.restype = c_int
snd_pcm_hw_params_get_subformat.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_subformat_t)]

# /usr/include/alsa/pcm.h:573
snd_pcm_hw_params_test_subformat = _lib.snd_pcm_hw_params_test_subformat
snd_pcm_hw_params_test_subformat.restype = c_int
snd_pcm_hw_params_test_subformat.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), snd_pcm_subformat_t]

# /usr/include/alsa/pcm.h:574
snd_pcm_hw_params_set_subformat = _lib.snd_pcm_hw_params_set_subformat
snd_pcm_hw_params_set_subformat.restype = c_int
snd_pcm_hw_params_set_subformat.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), snd_pcm_subformat_t]

# /usr/include/alsa/pcm.h:575
snd_pcm_hw_params_set_subformat_first = _lib.snd_pcm_hw_params_set_subformat_first
snd_pcm_hw_params_set_subformat_first.restype = c_int
snd_pcm_hw_params_set_subformat_first.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_subformat_t)]

# /usr/include/alsa/pcm.h:576
snd_pcm_hw_params_set_subformat_last = _lib.snd_pcm_hw_params_set_subformat_last
snd_pcm_hw_params_set_subformat_last.restype = c_int
snd_pcm_hw_params_set_subformat_last.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_subformat_t)]

# /usr/include/alsa/pcm.h:577
snd_pcm_hw_params_set_subformat_mask = _lib.snd_pcm_hw_params_set_subformat_mask
snd_pcm_hw_params_set_subformat_mask.restype = c_int
snd_pcm_hw_params_set_subformat_mask.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_subformat_mask_t)]

# /usr/include/alsa/pcm.h:578
snd_pcm_hw_params_get_subformat_mask = _lib.snd_pcm_hw_params_get_subformat_mask
snd_pcm_hw_params_get_subformat_mask.restype = None
snd_pcm_hw_params_get_subformat_mask.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_subformat_mask_t)]

# /usr/include/alsa/pcm.h:580
snd_pcm_hw_params_get_channels = _lib.snd_pcm_hw_params_get_channels
snd_pcm_hw_params_get_channels.restype = c_int
snd_pcm_hw_params_get_channels.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint)]

# /usr/include/alsa/pcm.h:581
snd_pcm_hw_params_get_channels_min = _lib.snd_pcm_hw_params_get_channels_min
snd_pcm_hw_params_get_channels_min.restype = c_int
snd_pcm_hw_params_get_channels_min.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint)]

# /usr/include/alsa/pcm.h:582
snd_pcm_hw_params_get_channels_max = _lib.snd_pcm_hw_params_get_channels_max
snd_pcm_hw_params_get_channels_max.restype = c_int
snd_pcm_hw_params_get_channels_max.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint)]

# /usr/include/alsa/pcm.h:583
snd_pcm_hw_params_test_channels = _lib.snd_pcm_hw_params_test_channels
snd_pcm_hw_params_test_channels.restype = c_int
snd_pcm_hw_params_test_channels.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), c_uint]

# /usr/include/alsa/pcm.h:584
snd_pcm_hw_params_set_channels = _lib.snd_pcm_hw_params_set_channels
snd_pcm_hw_params_set_channels.restype = c_int
snd_pcm_hw_params_set_channels.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), c_uint]

# /usr/include/alsa/pcm.h:585
snd_pcm_hw_params_set_channels_min = _lib.snd_pcm_hw_params_set_channels_min
snd_pcm_hw_params_set_channels_min.restype = c_int
snd_pcm_hw_params_set_channels_min.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint)]

# /usr/include/alsa/pcm.h:586
snd_pcm_hw_params_set_channels_max = _lib.snd_pcm_hw_params_set_channels_max
snd_pcm_hw_params_set_channels_max.restype = c_int
snd_pcm_hw_params_set_channels_max.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint)]

# /usr/include/alsa/pcm.h:587
snd_pcm_hw_params_set_channels_minmax = _lib.snd_pcm_hw_params_set_channels_minmax
snd_pcm_hw_params_set_channels_minmax.restype = c_int
snd_pcm_hw_params_set_channels_minmax.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_uint)]

# /usr/include/alsa/pcm.h:588
snd_pcm_hw_params_set_channels_near = _lib.snd_pcm_hw_params_set_channels_near
snd_pcm_hw_params_set_channels_near.restype = c_int
snd_pcm_hw_params_set_channels_near.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint)]

# /usr/include/alsa/pcm.h:589
snd_pcm_hw_params_set_channels_first = _lib.snd_pcm_hw_params_set_channels_first
snd_pcm_hw_params_set_channels_first.restype = c_int
snd_pcm_hw_params_set_channels_first.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint)]

# /usr/include/alsa/pcm.h:590
snd_pcm_hw_params_set_channels_last = _lib.snd_pcm_hw_params_set_channels_last
snd_pcm_hw_params_set_channels_last.restype = c_int
snd_pcm_hw_params_set_channels_last.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint)]

# /usr/include/alsa/pcm.h:592
snd_pcm_hw_params_get_rate = _lib.snd_pcm_hw_params_get_rate
snd_pcm_hw_params_get_rate.restype = c_int
snd_pcm_hw_params_get_rate.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:593
snd_pcm_hw_params_get_rate_min = _lib.snd_pcm_hw_params_get_rate_min
snd_pcm_hw_params_get_rate_min.restype = c_int
snd_pcm_hw_params_get_rate_min.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:594
snd_pcm_hw_params_get_rate_max = _lib.snd_pcm_hw_params_get_rate_max
snd_pcm_hw_params_get_rate_max.restype = c_int
snd_pcm_hw_params_get_rate_max.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:595
snd_pcm_hw_params_test_rate = _lib.snd_pcm_hw_params_test_rate
snd_pcm_hw_params_test_rate.restype = c_int
snd_pcm_hw_params_test_rate.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), c_uint, c_int]

# /usr/include/alsa/pcm.h:596
snd_pcm_hw_params_set_rate = _lib.snd_pcm_hw_params_set_rate
snd_pcm_hw_params_set_rate.restype = c_int
snd_pcm_hw_params_set_rate.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), c_uint, c_int]

# /usr/include/alsa/pcm.h:597
snd_pcm_hw_params_set_rate_min = _lib.snd_pcm_hw_params_set_rate_min
snd_pcm_hw_params_set_rate_min.restype = c_int
snd_pcm_hw_params_set_rate_min.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:598
snd_pcm_hw_params_set_rate_max = _lib.snd_pcm_hw_params_set_rate_max
snd_pcm_hw_params_set_rate_max.restype = c_int
snd_pcm_hw_params_set_rate_max.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:599
snd_pcm_hw_params_set_rate_minmax = _lib.snd_pcm_hw_params_set_rate_minmax
snd_pcm_hw_params_set_rate_minmax.restype = c_int
snd_pcm_hw_params_set_rate_minmax.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:600
snd_pcm_hw_params_set_rate_near = _lib.snd_pcm_hw_params_set_rate_near
snd_pcm_hw_params_set_rate_near.restype = c_int
snd_pcm_hw_params_set_rate_near.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:601
snd_pcm_hw_params_set_rate_first = _lib.snd_pcm_hw_params_set_rate_first
snd_pcm_hw_params_set_rate_first.restype = c_int
snd_pcm_hw_params_set_rate_first.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:602
snd_pcm_hw_params_set_rate_last = _lib.snd_pcm_hw_params_set_rate_last
snd_pcm_hw_params_set_rate_last.restype = c_int
snd_pcm_hw_params_set_rate_last.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:603
snd_pcm_hw_params_set_rate_resample = _lib.snd_pcm_hw_params_set_rate_resample
snd_pcm_hw_params_set_rate_resample.restype = c_int
snd_pcm_hw_params_set_rate_resample.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), c_uint]

# /usr/include/alsa/pcm.h:604
snd_pcm_hw_params_get_rate_resample = _lib.snd_pcm_hw_params_get_rate_resample
snd_pcm_hw_params_get_rate_resample.restype = c_int
snd_pcm_hw_params_get_rate_resample.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint)]

# /usr/include/alsa/pcm.h:605
snd_pcm_hw_params_set_export_buffer = _lib.snd_pcm_hw_params_set_export_buffer
snd_pcm_hw_params_set_export_buffer.restype = c_int
snd_pcm_hw_params_set_export_buffer.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), c_uint]

# /usr/include/alsa/pcm.h:606
snd_pcm_hw_params_get_export_buffer = _lib.snd_pcm_hw_params_get_export_buffer
snd_pcm_hw_params_get_export_buffer.restype = c_int
snd_pcm_hw_params_get_export_buffer.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint)]

# /usr/include/alsa/pcm.h:608
snd_pcm_hw_params_get_period_time = _lib.snd_pcm_hw_params_get_period_time
snd_pcm_hw_params_get_period_time.restype = c_int
snd_pcm_hw_params_get_period_time.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:609
snd_pcm_hw_params_get_period_time_min = _lib.snd_pcm_hw_params_get_period_time_min
snd_pcm_hw_params_get_period_time_min.restype = c_int
snd_pcm_hw_params_get_period_time_min.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:610
snd_pcm_hw_params_get_period_time_max = _lib.snd_pcm_hw_params_get_period_time_max
snd_pcm_hw_params_get_period_time_max.restype = c_int
snd_pcm_hw_params_get_period_time_max.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:611
snd_pcm_hw_params_test_period_time = _lib.snd_pcm_hw_params_test_period_time
snd_pcm_hw_params_test_period_time.restype = c_int
snd_pcm_hw_params_test_period_time.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), c_uint, c_int]

# /usr/include/alsa/pcm.h:612
snd_pcm_hw_params_set_period_time = _lib.snd_pcm_hw_params_set_period_time
snd_pcm_hw_params_set_period_time.restype = c_int
snd_pcm_hw_params_set_period_time.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), c_uint, c_int]

# /usr/include/alsa/pcm.h:613
snd_pcm_hw_params_set_period_time_min = _lib.snd_pcm_hw_params_set_period_time_min
snd_pcm_hw_params_set_period_time_min.restype = c_int
snd_pcm_hw_params_set_period_time_min.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:614
snd_pcm_hw_params_set_period_time_max = _lib.snd_pcm_hw_params_set_period_time_max
snd_pcm_hw_params_set_period_time_max.restype = c_int
snd_pcm_hw_params_set_period_time_max.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:615
snd_pcm_hw_params_set_period_time_minmax = _lib.snd_pcm_hw_params_set_period_time_minmax
snd_pcm_hw_params_set_period_time_minmax.restype = c_int
snd_pcm_hw_params_set_period_time_minmax.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:616
snd_pcm_hw_params_set_period_time_near = _lib.snd_pcm_hw_params_set_period_time_near
snd_pcm_hw_params_set_period_time_near.restype = c_int
snd_pcm_hw_params_set_period_time_near.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:617
snd_pcm_hw_params_set_period_time_first = _lib.snd_pcm_hw_params_set_period_time_first
snd_pcm_hw_params_set_period_time_first.restype = c_int
snd_pcm_hw_params_set_period_time_first.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:618
snd_pcm_hw_params_set_period_time_last = _lib.snd_pcm_hw_params_set_period_time_last
snd_pcm_hw_params_set_period_time_last.restype = c_int
snd_pcm_hw_params_set_period_time_last.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:620
snd_pcm_hw_params_get_period_size = _lib.snd_pcm_hw_params_get_period_size
snd_pcm_hw_params_get_period_size.restype = c_int
snd_pcm_hw_params_get_period_size.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t), POINTER(c_int)]

# /usr/include/alsa/pcm.h:621
snd_pcm_hw_params_get_period_size_min = _lib.snd_pcm_hw_params_get_period_size_min
snd_pcm_hw_params_get_period_size_min.restype = c_int
snd_pcm_hw_params_get_period_size_min.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t), POINTER(c_int)]

# /usr/include/alsa/pcm.h:622
snd_pcm_hw_params_get_period_size_max = _lib.snd_pcm_hw_params_get_period_size_max
snd_pcm_hw_params_get_period_size_max.restype = c_int
snd_pcm_hw_params_get_period_size_max.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t), POINTER(c_int)]

# /usr/include/alsa/pcm.h:623
snd_pcm_hw_params_test_period_size = _lib.snd_pcm_hw_params_test_period_size
snd_pcm_hw_params_test_period_size.restype = c_int
snd_pcm_hw_params_test_period_size.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), snd_pcm_uframes_t, c_int]

# /usr/include/alsa/pcm.h:624
snd_pcm_hw_params_set_period_size = _lib.snd_pcm_hw_params_set_period_size
snd_pcm_hw_params_set_period_size.restype = c_int
snd_pcm_hw_params_set_period_size.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), snd_pcm_uframes_t, c_int]

# /usr/include/alsa/pcm.h:625
snd_pcm_hw_params_set_period_size_min = _lib.snd_pcm_hw_params_set_period_size_min
snd_pcm_hw_params_set_period_size_min.restype = c_int
snd_pcm_hw_params_set_period_size_min.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t), POINTER(c_int)]

# /usr/include/alsa/pcm.h:626
snd_pcm_hw_params_set_period_size_max = _lib.snd_pcm_hw_params_set_period_size_max
snd_pcm_hw_params_set_period_size_max.restype = c_int
snd_pcm_hw_params_set_period_size_max.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t), POINTER(c_int)]

# /usr/include/alsa/pcm.h:627
snd_pcm_hw_params_set_period_size_minmax = _lib.snd_pcm_hw_params_set_period_size_minmax
snd_pcm_hw_params_set_period_size_minmax.restype = c_int
snd_pcm_hw_params_set_period_size_minmax.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t), POINTER(c_int), POINTER(snd_pcm_uframes_t), POINTER(c_int)]

# /usr/include/alsa/pcm.h:628
snd_pcm_hw_params_set_period_size_near = _lib.snd_pcm_hw_params_set_period_size_near
snd_pcm_hw_params_set_period_size_near.restype = c_int
snd_pcm_hw_params_set_period_size_near.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t), POINTER(c_int)]

# /usr/include/alsa/pcm.h:629
snd_pcm_hw_params_set_period_size_first = _lib.snd_pcm_hw_params_set_period_size_first
snd_pcm_hw_params_set_period_size_first.restype = c_int
snd_pcm_hw_params_set_period_size_first.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t), POINTER(c_int)]

# /usr/include/alsa/pcm.h:630
snd_pcm_hw_params_set_period_size_last = _lib.snd_pcm_hw_params_set_period_size_last
snd_pcm_hw_params_set_period_size_last.restype = c_int
snd_pcm_hw_params_set_period_size_last.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t), POINTER(c_int)]

# /usr/include/alsa/pcm.h:631
snd_pcm_hw_params_set_period_size_integer = _lib.snd_pcm_hw_params_set_period_size_integer
snd_pcm_hw_params_set_period_size_integer.restype = c_int
snd_pcm_hw_params_set_period_size_integer.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:633
snd_pcm_hw_params_get_periods = _lib.snd_pcm_hw_params_get_periods
snd_pcm_hw_params_get_periods.restype = c_int
snd_pcm_hw_params_get_periods.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:634
snd_pcm_hw_params_get_periods_min = _lib.snd_pcm_hw_params_get_periods_min
snd_pcm_hw_params_get_periods_min.restype = c_int
snd_pcm_hw_params_get_periods_min.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:635
snd_pcm_hw_params_get_periods_max = _lib.snd_pcm_hw_params_get_periods_max
snd_pcm_hw_params_get_periods_max.restype = c_int
snd_pcm_hw_params_get_periods_max.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:636
snd_pcm_hw_params_test_periods = _lib.snd_pcm_hw_params_test_periods
snd_pcm_hw_params_test_periods.restype = c_int
snd_pcm_hw_params_test_periods.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), c_uint, c_int]

# /usr/include/alsa/pcm.h:637
snd_pcm_hw_params_set_periods = _lib.snd_pcm_hw_params_set_periods
snd_pcm_hw_params_set_periods.restype = c_int
snd_pcm_hw_params_set_periods.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), c_uint, c_int]

# /usr/include/alsa/pcm.h:638
snd_pcm_hw_params_set_periods_min = _lib.snd_pcm_hw_params_set_periods_min
snd_pcm_hw_params_set_periods_min.restype = c_int
snd_pcm_hw_params_set_periods_min.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:639
snd_pcm_hw_params_set_periods_max = _lib.snd_pcm_hw_params_set_periods_max
snd_pcm_hw_params_set_periods_max.restype = c_int
snd_pcm_hw_params_set_periods_max.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:640
snd_pcm_hw_params_set_periods_minmax = _lib.snd_pcm_hw_params_set_periods_minmax
snd_pcm_hw_params_set_periods_minmax.restype = c_int
snd_pcm_hw_params_set_periods_minmax.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:641
snd_pcm_hw_params_set_periods_near = _lib.snd_pcm_hw_params_set_periods_near
snd_pcm_hw_params_set_periods_near.restype = c_int
snd_pcm_hw_params_set_periods_near.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:642
snd_pcm_hw_params_set_periods_first = _lib.snd_pcm_hw_params_set_periods_first
snd_pcm_hw_params_set_periods_first.restype = c_int
snd_pcm_hw_params_set_periods_first.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:643
snd_pcm_hw_params_set_periods_last = _lib.snd_pcm_hw_params_set_periods_last
snd_pcm_hw_params_set_periods_last.restype = c_int
snd_pcm_hw_params_set_periods_last.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:644
snd_pcm_hw_params_set_periods_integer = _lib.snd_pcm_hw_params_set_periods_integer
snd_pcm_hw_params_set_periods_integer.restype = c_int
snd_pcm_hw_params_set_periods_integer.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t)]

# /usr/include/alsa/pcm.h:646
snd_pcm_hw_params_get_buffer_time = _lib.snd_pcm_hw_params_get_buffer_time
snd_pcm_hw_params_get_buffer_time.restype = c_int
snd_pcm_hw_params_get_buffer_time.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:647
snd_pcm_hw_params_get_buffer_time_min = _lib.snd_pcm_hw_params_get_buffer_time_min
snd_pcm_hw_params_get_buffer_time_min.restype = c_int
snd_pcm_hw_params_get_buffer_time_min.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:648
snd_pcm_hw_params_get_buffer_time_max = _lib.snd_pcm_hw_params_get_buffer_time_max
snd_pcm_hw_params_get_buffer_time_max.restype = c_int
snd_pcm_hw_params_get_buffer_time_max.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:649
snd_pcm_hw_params_test_buffer_time = _lib.snd_pcm_hw_params_test_buffer_time
snd_pcm_hw_params_test_buffer_time.restype = c_int
snd_pcm_hw_params_test_buffer_time.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), c_uint, c_int]

# /usr/include/alsa/pcm.h:650
snd_pcm_hw_params_set_buffer_time = _lib.snd_pcm_hw_params_set_buffer_time
snd_pcm_hw_params_set_buffer_time.restype = c_int
snd_pcm_hw_params_set_buffer_time.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), c_uint, c_int]

# /usr/include/alsa/pcm.h:651
snd_pcm_hw_params_set_buffer_time_min = _lib.snd_pcm_hw_params_set_buffer_time_min
snd_pcm_hw_params_set_buffer_time_min.restype = c_int
snd_pcm_hw_params_set_buffer_time_min.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:652
snd_pcm_hw_params_set_buffer_time_max = _lib.snd_pcm_hw_params_set_buffer_time_max
snd_pcm_hw_params_set_buffer_time_max.restype = c_int
snd_pcm_hw_params_set_buffer_time_max.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:653
snd_pcm_hw_params_set_buffer_time_minmax = _lib.snd_pcm_hw_params_set_buffer_time_minmax
snd_pcm_hw_params_set_buffer_time_minmax.restype = c_int
snd_pcm_hw_params_set_buffer_time_minmax.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:654
snd_pcm_hw_params_set_buffer_time_near = _lib.snd_pcm_hw_params_set_buffer_time_near
snd_pcm_hw_params_set_buffer_time_near.restype = c_int
snd_pcm_hw_params_set_buffer_time_near.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:655
snd_pcm_hw_params_set_buffer_time_first = _lib.snd_pcm_hw_params_set_buffer_time_first
snd_pcm_hw_params_set_buffer_time_first.restype = c_int
snd_pcm_hw_params_set_buffer_time_first.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:656
snd_pcm_hw_params_set_buffer_time_last = _lib.snd_pcm_hw_params_set_buffer_time_last
snd_pcm_hw_params_set_buffer_time_last.restype = c_int
snd_pcm_hw_params_set_buffer_time_last.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:658
snd_pcm_hw_params_get_buffer_size = _lib.snd_pcm_hw_params_get_buffer_size
snd_pcm_hw_params_get_buffer_size.restype = c_int
snd_pcm_hw_params_get_buffer_size.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:659
snd_pcm_hw_params_get_buffer_size_min = _lib.snd_pcm_hw_params_get_buffer_size_min
snd_pcm_hw_params_get_buffer_size_min.restype = c_int
snd_pcm_hw_params_get_buffer_size_min.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:660
snd_pcm_hw_params_get_buffer_size_max = _lib.snd_pcm_hw_params_get_buffer_size_max
snd_pcm_hw_params_get_buffer_size_max.restype = c_int
snd_pcm_hw_params_get_buffer_size_max.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:661
snd_pcm_hw_params_test_buffer_size = _lib.snd_pcm_hw_params_test_buffer_size
snd_pcm_hw_params_test_buffer_size.restype = c_int
snd_pcm_hw_params_test_buffer_size.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:662
snd_pcm_hw_params_set_buffer_size = _lib.snd_pcm_hw_params_set_buffer_size
snd_pcm_hw_params_set_buffer_size.restype = c_int
snd_pcm_hw_params_set_buffer_size.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:663
snd_pcm_hw_params_set_buffer_size_min = _lib.snd_pcm_hw_params_set_buffer_size_min
snd_pcm_hw_params_set_buffer_size_min.restype = c_int
snd_pcm_hw_params_set_buffer_size_min.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:664
snd_pcm_hw_params_set_buffer_size_max = _lib.snd_pcm_hw_params_set_buffer_size_max
snd_pcm_hw_params_set_buffer_size_max.restype = c_int
snd_pcm_hw_params_set_buffer_size_max.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:665
snd_pcm_hw_params_set_buffer_size_minmax = _lib.snd_pcm_hw_params_set_buffer_size_minmax
snd_pcm_hw_params_set_buffer_size_minmax.restype = c_int
snd_pcm_hw_params_set_buffer_size_minmax.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:666
snd_pcm_hw_params_set_buffer_size_near = _lib.snd_pcm_hw_params_set_buffer_size_near
snd_pcm_hw_params_set_buffer_size_near.restype = c_int
snd_pcm_hw_params_set_buffer_size_near.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:667
snd_pcm_hw_params_set_buffer_size_first = _lib.snd_pcm_hw_params_set_buffer_size_first
snd_pcm_hw_params_set_buffer_size_first.restype = c_int
snd_pcm_hw_params_set_buffer_size_first.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:668
snd_pcm_hw_params_set_buffer_size_last = _lib.snd_pcm_hw_params_set_buffer_size_last
snd_pcm_hw_params_set_buffer_size_last.restype = c_int
snd_pcm_hw_params_set_buffer_size_last.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:670
snd_pcm_hw_params_get_tick_time = _lib.snd_pcm_hw_params_get_tick_time
snd_pcm_hw_params_get_tick_time.restype = c_int
snd_pcm_hw_params_get_tick_time.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:671
snd_pcm_hw_params_get_tick_time_min = _lib.snd_pcm_hw_params_get_tick_time_min
snd_pcm_hw_params_get_tick_time_min.restype = c_int
snd_pcm_hw_params_get_tick_time_min.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:672
snd_pcm_hw_params_get_tick_time_max = _lib.snd_pcm_hw_params_get_tick_time_max
snd_pcm_hw_params_get_tick_time_max.restype = c_int
snd_pcm_hw_params_get_tick_time_max.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:673
snd_pcm_hw_params_test_tick_time = _lib.snd_pcm_hw_params_test_tick_time
snd_pcm_hw_params_test_tick_time.restype = c_int
snd_pcm_hw_params_test_tick_time.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), c_uint, c_int]

# /usr/include/alsa/pcm.h:674
snd_pcm_hw_params_set_tick_time = _lib.snd_pcm_hw_params_set_tick_time
snd_pcm_hw_params_set_tick_time.restype = c_int
snd_pcm_hw_params_set_tick_time.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), c_uint, c_int]

# /usr/include/alsa/pcm.h:675
snd_pcm_hw_params_set_tick_time_min = _lib.snd_pcm_hw_params_set_tick_time_min
snd_pcm_hw_params_set_tick_time_min.restype = c_int
snd_pcm_hw_params_set_tick_time_min.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:676
snd_pcm_hw_params_set_tick_time_max = _lib.snd_pcm_hw_params_set_tick_time_max
snd_pcm_hw_params_set_tick_time_max.restype = c_int
snd_pcm_hw_params_set_tick_time_max.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:677
snd_pcm_hw_params_set_tick_time_minmax = _lib.snd_pcm_hw_params_set_tick_time_minmax
snd_pcm_hw_params_set_tick_time_minmax.restype = c_int
snd_pcm_hw_params_set_tick_time_minmax.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:678
snd_pcm_hw_params_set_tick_time_near = _lib.snd_pcm_hw_params_set_tick_time_near
snd_pcm_hw_params_set_tick_time_near.restype = c_int
snd_pcm_hw_params_set_tick_time_near.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:679
snd_pcm_hw_params_set_tick_time_first = _lib.snd_pcm_hw_params_set_tick_time_first
snd_pcm_hw_params_set_tick_time_first.restype = c_int
snd_pcm_hw_params_set_tick_time_first.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:680
snd_pcm_hw_params_set_tick_time_last = _lib.snd_pcm_hw_params_set_tick_time_last
snd_pcm_hw_params_set_tick_time_last.restype = c_int
snd_pcm_hw_params_set_tick_time_last.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_hw_params_t), POINTER(c_uint), POINTER(c_int)]

# /usr/include/alsa/pcm.h:684
snd_pcm_hw_params_get_min_align = _lib.snd_pcm_hw_params_get_min_align
snd_pcm_hw_params_get_min_align.restype = c_int
snd_pcm_hw_params_get_min_align.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:695
snd_pcm_sw_params_sizeof = _lib.snd_pcm_sw_params_sizeof
snd_pcm_sw_params_sizeof.restype = c_size_t
snd_pcm_sw_params_sizeof.argtypes = []

# /usr/include/alsa/pcm.h:701
snd_pcm_sw_params_malloc = _lib.snd_pcm_sw_params_malloc
snd_pcm_sw_params_malloc.restype = c_int
snd_pcm_sw_params_malloc.argtypes = [POINTER(POINTER(snd_pcm_sw_params_t))]

# /usr/include/alsa/pcm.h:702
snd_pcm_sw_params_free = _lib.snd_pcm_sw_params_free
snd_pcm_sw_params_free.restype = None
snd_pcm_sw_params_free.argtypes = [POINTER(snd_pcm_sw_params_t)]

# /usr/include/alsa/pcm.h:703
snd_pcm_sw_params_copy = _lib.snd_pcm_sw_params_copy
snd_pcm_sw_params_copy.restype = None
snd_pcm_sw_params_copy.argtypes = [POINTER(snd_pcm_sw_params_t), POINTER(snd_pcm_sw_params_t)]

# /usr/include/alsa/pcm.h:704
snd_pcm_sw_params_get_boundary = _lib.snd_pcm_sw_params_get_boundary
snd_pcm_sw_params_get_boundary.restype = c_int
snd_pcm_sw_params_get_boundary.argtypes = [POINTER(snd_pcm_sw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:708
snd_pcm_sw_params_set_tstamp_mode = _lib.snd_pcm_sw_params_set_tstamp_mode
snd_pcm_sw_params_set_tstamp_mode.restype = c_int
snd_pcm_sw_params_set_tstamp_mode.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_sw_params_t), snd_pcm_tstamp_t]

# /usr/include/alsa/pcm.h:709
snd_pcm_sw_params_get_tstamp_mode = _lib.snd_pcm_sw_params_get_tstamp_mode
snd_pcm_sw_params_get_tstamp_mode.restype = c_int
snd_pcm_sw_params_get_tstamp_mode.argtypes = [POINTER(snd_pcm_sw_params_t), POINTER(snd_pcm_tstamp_t)]

# /usr/include/alsa/pcm.h:710
snd_pcm_sw_params_set_sleep_min = _lib.snd_pcm_sw_params_set_sleep_min
snd_pcm_sw_params_set_sleep_min.restype = c_int
snd_pcm_sw_params_set_sleep_min.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_sw_params_t), c_uint]

# /usr/include/alsa/pcm.h:711
snd_pcm_sw_params_get_sleep_min = _lib.snd_pcm_sw_params_get_sleep_min
snd_pcm_sw_params_get_sleep_min.restype = c_int
snd_pcm_sw_params_get_sleep_min.argtypes = [POINTER(snd_pcm_sw_params_t), POINTER(c_uint)]

# /usr/include/alsa/pcm.h:712
snd_pcm_sw_params_set_avail_min = _lib.snd_pcm_sw_params_set_avail_min
snd_pcm_sw_params_set_avail_min.restype = c_int
snd_pcm_sw_params_set_avail_min.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_sw_params_t), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:713
snd_pcm_sw_params_get_avail_min = _lib.snd_pcm_sw_params_get_avail_min
snd_pcm_sw_params_get_avail_min.restype = c_int
snd_pcm_sw_params_get_avail_min.argtypes = [POINTER(snd_pcm_sw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:714
snd_pcm_sw_params_set_xfer_align = _lib.snd_pcm_sw_params_set_xfer_align
snd_pcm_sw_params_set_xfer_align.restype = c_int
snd_pcm_sw_params_set_xfer_align.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_sw_params_t), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:715
snd_pcm_sw_params_get_xfer_align = _lib.snd_pcm_sw_params_get_xfer_align
snd_pcm_sw_params_get_xfer_align.restype = c_int
snd_pcm_sw_params_get_xfer_align.argtypes = [POINTER(snd_pcm_sw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:716
snd_pcm_sw_params_set_start_threshold = _lib.snd_pcm_sw_params_set_start_threshold
snd_pcm_sw_params_set_start_threshold.restype = c_int
snd_pcm_sw_params_set_start_threshold.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_sw_params_t), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:717
snd_pcm_sw_params_get_start_threshold = _lib.snd_pcm_sw_params_get_start_threshold
snd_pcm_sw_params_get_start_threshold.restype = c_int
snd_pcm_sw_params_get_start_threshold.argtypes = [POINTER(snd_pcm_sw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:718
snd_pcm_sw_params_set_stop_threshold = _lib.snd_pcm_sw_params_set_stop_threshold
snd_pcm_sw_params_set_stop_threshold.restype = c_int
snd_pcm_sw_params_set_stop_threshold.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_sw_params_t), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:719
snd_pcm_sw_params_get_stop_threshold = _lib.snd_pcm_sw_params_get_stop_threshold
snd_pcm_sw_params_get_stop_threshold.restype = c_int
snd_pcm_sw_params_get_stop_threshold.argtypes = [POINTER(snd_pcm_sw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:720
snd_pcm_sw_params_set_silence_threshold = _lib.snd_pcm_sw_params_set_silence_threshold
snd_pcm_sw_params_set_silence_threshold.restype = c_int
snd_pcm_sw_params_set_silence_threshold.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_sw_params_t), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:721
snd_pcm_sw_params_get_silence_threshold = _lib.snd_pcm_sw_params_get_silence_threshold
snd_pcm_sw_params_get_silence_threshold.restype = c_int
snd_pcm_sw_params_get_silence_threshold.argtypes = [POINTER(snd_pcm_sw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:722
snd_pcm_sw_params_set_silence_size = _lib.snd_pcm_sw_params_set_silence_size
snd_pcm_sw_params_set_silence_size.restype = c_int
snd_pcm_sw_params_set_silence_size.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_sw_params_t), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:723
snd_pcm_sw_params_get_silence_size = _lib.snd_pcm_sw_params_get_silence_size
snd_pcm_sw_params_get_silence_size.restype = c_int
snd_pcm_sw_params_get_silence_size.argtypes = [POINTER(snd_pcm_sw_params_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:743
snd_pcm_access_mask_sizeof = _lib.snd_pcm_access_mask_sizeof
snd_pcm_access_mask_sizeof.restype = c_size_t
snd_pcm_access_mask_sizeof.argtypes = []

# /usr/include/alsa/pcm.h:749
snd_pcm_access_mask_malloc = _lib.snd_pcm_access_mask_malloc
snd_pcm_access_mask_malloc.restype = c_int
snd_pcm_access_mask_malloc.argtypes = [POINTER(POINTER(snd_pcm_access_mask_t))]

# /usr/include/alsa/pcm.h:750
snd_pcm_access_mask_free = _lib.snd_pcm_access_mask_free
snd_pcm_access_mask_free.restype = None
snd_pcm_access_mask_free.argtypes = [POINTER(snd_pcm_access_mask_t)]

# /usr/include/alsa/pcm.h:751
snd_pcm_access_mask_copy = _lib.snd_pcm_access_mask_copy
snd_pcm_access_mask_copy.restype = None
snd_pcm_access_mask_copy.argtypes = [POINTER(snd_pcm_access_mask_t), POINTER(snd_pcm_access_mask_t)]

# /usr/include/alsa/pcm.h:752
snd_pcm_access_mask_none = _lib.snd_pcm_access_mask_none
snd_pcm_access_mask_none.restype = None
snd_pcm_access_mask_none.argtypes = [POINTER(snd_pcm_access_mask_t)]

# /usr/include/alsa/pcm.h:753
snd_pcm_access_mask_any = _lib.snd_pcm_access_mask_any
snd_pcm_access_mask_any.restype = None
snd_pcm_access_mask_any.argtypes = [POINTER(snd_pcm_access_mask_t)]

# /usr/include/alsa/pcm.h:754
snd_pcm_access_mask_test = _lib.snd_pcm_access_mask_test
snd_pcm_access_mask_test.restype = c_int
snd_pcm_access_mask_test.argtypes = [POINTER(snd_pcm_access_mask_t), snd_pcm_access_t]

# /usr/include/alsa/pcm.h:755
snd_pcm_access_mask_empty = _lib.snd_pcm_access_mask_empty
snd_pcm_access_mask_empty.restype = c_int
snd_pcm_access_mask_empty.argtypes = [POINTER(snd_pcm_access_mask_t)]

# /usr/include/alsa/pcm.h:756
snd_pcm_access_mask_set = _lib.snd_pcm_access_mask_set
snd_pcm_access_mask_set.restype = None
snd_pcm_access_mask_set.argtypes = [POINTER(snd_pcm_access_mask_t), snd_pcm_access_t]

# /usr/include/alsa/pcm.h:757
snd_pcm_access_mask_reset = _lib.snd_pcm_access_mask_reset
snd_pcm_access_mask_reset.restype = None
snd_pcm_access_mask_reset.argtypes = [POINTER(snd_pcm_access_mask_t), snd_pcm_access_t]

# /usr/include/alsa/pcm.h:768
snd_pcm_format_mask_sizeof = _lib.snd_pcm_format_mask_sizeof
snd_pcm_format_mask_sizeof.restype = c_size_t
snd_pcm_format_mask_sizeof.argtypes = []

# /usr/include/alsa/pcm.h:774
snd_pcm_format_mask_malloc = _lib.snd_pcm_format_mask_malloc
snd_pcm_format_mask_malloc.restype = c_int
snd_pcm_format_mask_malloc.argtypes = [POINTER(POINTER(snd_pcm_format_mask_t))]

# /usr/include/alsa/pcm.h:775
snd_pcm_format_mask_free = _lib.snd_pcm_format_mask_free
snd_pcm_format_mask_free.restype = None
snd_pcm_format_mask_free.argtypes = [POINTER(snd_pcm_format_mask_t)]

# /usr/include/alsa/pcm.h:776
snd_pcm_format_mask_copy = _lib.snd_pcm_format_mask_copy
snd_pcm_format_mask_copy.restype = None
snd_pcm_format_mask_copy.argtypes = [POINTER(snd_pcm_format_mask_t), POINTER(snd_pcm_format_mask_t)]

# /usr/include/alsa/pcm.h:777
snd_pcm_format_mask_none = _lib.snd_pcm_format_mask_none
snd_pcm_format_mask_none.restype = None
snd_pcm_format_mask_none.argtypes = [POINTER(snd_pcm_format_mask_t)]

# /usr/include/alsa/pcm.h:778
snd_pcm_format_mask_any = _lib.snd_pcm_format_mask_any
snd_pcm_format_mask_any.restype = None
snd_pcm_format_mask_any.argtypes = [POINTER(snd_pcm_format_mask_t)]

# /usr/include/alsa/pcm.h:779
snd_pcm_format_mask_test = _lib.snd_pcm_format_mask_test
snd_pcm_format_mask_test.restype = c_int
snd_pcm_format_mask_test.argtypes = [POINTER(snd_pcm_format_mask_t), snd_pcm_format_t]

# /usr/include/alsa/pcm.h:780
snd_pcm_format_mask_empty = _lib.snd_pcm_format_mask_empty
snd_pcm_format_mask_empty.restype = c_int
snd_pcm_format_mask_empty.argtypes = [POINTER(snd_pcm_format_mask_t)]

# /usr/include/alsa/pcm.h:781
snd_pcm_format_mask_set = _lib.snd_pcm_format_mask_set
snd_pcm_format_mask_set.restype = None
snd_pcm_format_mask_set.argtypes = [POINTER(snd_pcm_format_mask_t), snd_pcm_format_t]

# /usr/include/alsa/pcm.h:782
snd_pcm_format_mask_reset = _lib.snd_pcm_format_mask_reset
snd_pcm_format_mask_reset.restype = None
snd_pcm_format_mask_reset.argtypes = [POINTER(snd_pcm_format_mask_t), snd_pcm_format_t]

# /usr/include/alsa/pcm.h:793
snd_pcm_subformat_mask_sizeof = _lib.snd_pcm_subformat_mask_sizeof
snd_pcm_subformat_mask_sizeof.restype = c_size_t
snd_pcm_subformat_mask_sizeof.argtypes = []

# /usr/include/alsa/pcm.h:799
snd_pcm_subformat_mask_malloc = _lib.snd_pcm_subformat_mask_malloc
snd_pcm_subformat_mask_malloc.restype = c_int
snd_pcm_subformat_mask_malloc.argtypes = [POINTER(POINTER(snd_pcm_subformat_mask_t))]

# /usr/include/alsa/pcm.h:800
snd_pcm_subformat_mask_free = _lib.snd_pcm_subformat_mask_free
snd_pcm_subformat_mask_free.restype = None
snd_pcm_subformat_mask_free.argtypes = [POINTER(snd_pcm_subformat_mask_t)]

# /usr/include/alsa/pcm.h:801
snd_pcm_subformat_mask_copy = _lib.snd_pcm_subformat_mask_copy
snd_pcm_subformat_mask_copy.restype = None
snd_pcm_subformat_mask_copy.argtypes = [POINTER(snd_pcm_subformat_mask_t), POINTER(snd_pcm_subformat_mask_t)]

# /usr/include/alsa/pcm.h:802
snd_pcm_subformat_mask_none = _lib.snd_pcm_subformat_mask_none
snd_pcm_subformat_mask_none.restype = None
snd_pcm_subformat_mask_none.argtypes = [POINTER(snd_pcm_subformat_mask_t)]

# /usr/include/alsa/pcm.h:803
snd_pcm_subformat_mask_any = _lib.snd_pcm_subformat_mask_any
snd_pcm_subformat_mask_any.restype = None
snd_pcm_subformat_mask_any.argtypes = [POINTER(snd_pcm_subformat_mask_t)]

# /usr/include/alsa/pcm.h:804
snd_pcm_subformat_mask_test = _lib.snd_pcm_subformat_mask_test
snd_pcm_subformat_mask_test.restype = c_int
snd_pcm_subformat_mask_test.argtypes = [POINTER(snd_pcm_subformat_mask_t), snd_pcm_subformat_t]

# /usr/include/alsa/pcm.h:805
snd_pcm_subformat_mask_empty = _lib.snd_pcm_subformat_mask_empty
snd_pcm_subformat_mask_empty.restype = c_int
snd_pcm_subformat_mask_empty.argtypes = [POINTER(snd_pcm_subformat_mask_t)]

# /usr/include/alsa/pcm.h:806
snd_pcm_subformat_mask_set = _lib.snd_pcm_subformat_mask_set
snd_pcm_subformat_mask_set.restype = None
snd_pcm_subformat_mask_set.argtypes = [POINTER(snd_pcm_subformat_mask_t), snd_pcm_subformat_t]

# /usr/include/alsa/pcm.h:807
snd_pcm_subformat_mask_reset = _lib.snd_pcm_subformat_mask_reset
snd_pcm_subformat_mask_reset.restype = None
snd_pcm_subformat_mask_reset.argtypes = [POINTER(snd_pcm_subformat_mask_t), snd_pcm_subformat_t]

# /usr/include/alsa/pcm.h:818
snd_pcm_status_sizeof = _lib.snd_pcm_status_sizeof
snd_pcm_status_sizeof.restype = c_size_t
snd_pcm_status_sizeof.argtypes = []

# /usr/include/alsa/pcm.h:824
snd_pcm_status_malloc = _lib.snd_pcm_status_malloc
snd_pcm_status_malloc.restype = c_int
snd_pcm_status_malloc.argtypes = [POINTER(POINTER(snd_pcm_status_t))]

# /usr/include/alsa/pcm.h:825
snd_pcm_status_free = _lib.snd_pcm_status_free
snd_pcm_status_free.restype = None
snd_pcm_status_free.argtypes = [POINTER(snd_pcm_status_t)]

# /usr/include/alsa/pcm.h:826
snd_pcm_status_copy = _lib.snd_pcm_status_copy
snd_pcm_status_copy.restype = None
snd_pcm_status_copy.argtypes = [POINTER(snd_pcm_status_t), POINTER(snd_pcm_status_t)]

# /usr/include/alsa/pcm.h:827
snd_pcm_status_get_state = _lib.snd_pcm_status_get_state
snd_pcm_status_get_state.restype = snd_pcm_state_t
snd_pcm_status_get_state.argtypes = [POINTER(snd_pcm_status_t)]

# /usr/include/alsa/pcm.h:828
snd_pcm_status_get_trigger_tstamp = _lib.snd_pcm_status_get_trigger_tstamp
snd_pcm_status_get_trigger_tstamp.restype = None
snd_pcm_status_get_trigger_tstamp.argtypes = [POINTER(snd_pcm_status_t), POINTER(snd_timestamp_t)]

# /usr/include/alsa/pcm.h:829
snd_pcm_status_get_trigger_htstamp = _lib.snd_pcm_status_get_trigger_htstamp
snd_pcm_status_get_trigger_htstamp.restype = None
snd_pcm_status_get_trigger_htstamp.argtypes = [POINTER(snd_pcm_status_t), POINTER(snd_htimestamp_t)]

# /usr/include/alsa/pcm.h:830
snd_pcm_status_get_tstamp = _lib.snd_pcm_status_get_tstamp
snd_pcm_status_get_tstamp.restype = None
snd_pcm_status_get_tstamp.argtypes = [POINTER(snd_pcm_status_t), POINTER(snd_timestamp_t)]

# /usr/include/alsa/pcm.h:831
snd_pcm_status_get_htstamp = _lib.snd_pcm_status_get_htstamp
snd_pcm_status_get_htstamp.restype = None
snd_pcm_status_get_htstamp.argtypes = [POINTER(snd_pcm_status_t), POINTER(snd_htimestamp_t)]

# /usr/include/alsa/pcm.h:832
snd_pcm_status_get_delay = _lib.snd_pcm_status_get_delay
snd_pcm_status_get_delay.restype = snd_pcm_sframes_t
snd_pcm_status_get_delay.argtypes = [POINTER(snd_pcm_status_t)]

# /usr/include/alsa/pcm.h:833
snd_pcm_status_get_avail = _lib.snd_pcm_status_get_avail
snd_pcm_status_get_avail.restype = snd_pcm_uframes_t
snd_pcm_status_get_avail.argtypes = [POINTER(snd_pcm_status_t)]

# /usr/include/alsa/pcm.h:834
snd_pcm_status_get_avail_max = _lib.snd_pcm_status_get_avail_max
snd_pcm_status_get_avail_max.restype = snd_pcm_uframes_t
snd_pcm_status_get_avail_max.argtypes = [POINTER(snd_pcm_status_t)]

# /usr/include/alsa/pcm.h:835
snd_pcm_status_get_overrange = _lib.snd_pcm_status_get_overrange
snd_pcm_status_get_overrange.restype = snd_pcm_uframes_t
snd_pcm_status_get_overrange.argtypes = [POINTER(snd_pcm_status_t)]

# /usr/include/alsa/pcm.h:846
snd_pcm_type_name = _lib.snd_pcm_type_name
snd_pcm_type_name.restype = c_char_p
snd_pcm_type_name.argtypes = [snd_pcm_type_t]

# /usr/include/alsa/pcm.h:847
snd_pcm_stream_name = _lib.snd_pcm_stream_name
snd_pcm_stream_name.restype = c_char_p
snd_pcm_stream_name.argtypes = [snd_pcm_stream_t]

# /usr/include/alsa/pcm.h:848
snd_pcm_access_name = _lib.snd_pcm_access_name
snd_pcm_access_name.restype = c_char_p
snd_pcm_access_name.argtypes = [snd_pcm_access_t]

# /usr/include/alsa/pcm.h:849
snd_pcm_format_name = _lib.snd_pcm_format_name
snd_pcm_format_name.restype = c_char_p
snd_pcm_format_name.argtypes = [snd_pcm_format_t]

# /usr/include/alsa/pcm.h:850
snd_pcm_format_description = _lib.snd_pcm_format_description
snd_pcm_format_description.restype = c_char_p
snd_pcm_format_description.argtypes = [snd_pcm_format_t]

# /usr/include/alsa/pcm.h:851
snd_pcm_subformat_name = _lib.snd_pcm_subformat_name
snd_pcm_subformat_name.restype = c_char_p
snd_pcm_subformat_name.argtypes = [snd_pcm_subformat_t]

# /usr/include/alsa/pcm.h:852
snd_pcm_subformat_description = _lib.snd_pcm_subformat_description
snd_pcm_subformat_description.restype = c_char_p
snd_pcm_subformat_description.argtypes = [snd_pcm_subformat_t]

# /usr/include/alsa/pcm.h:853
snd_pcm_format_value = _lib.snd_pcm_format_value
snd_pcm_format_value.restype = snd_pcm_format_t
snd_pcm_format_value.argtypes = [c_char_p]

# /usr/include/alsa/pcm.h:854
snd_pcm_tstamp_mode_name = _lib.snd_pcm_tstamp_mode_name
snd_pcm_tstamp_mode_name.restype = c_char_p
snd_pcm_tstamp_mode_name.argtypes = [snd_pcm_tstamp_t]

# /usr/include/alsa/pcm.h:855
snd_pcm_state_name = _lib.snd_pcm_state_name
snd_pcm_state_name.restype = c_char_p
snd_pcm_state_name.argtypes = [snd_pcm_state_t]

# /usr/include/alsa/pcm.h:866
snd_pcm_dump = _lib.snd_pcm_dump
snd_pcm_dump.restype = c_int
snd_pcm_dump.argtypes = [POINTER(snd_pcm_t), POINTER(snd_output_t)]

# /usr/include/alsa/pcm.h:867
snd_pcm_dump_hw_setup = _lib.snd_pcm_dump_hw_setup
snd_pcm_dump_hw_setup.restype = c_int
snd_pcm_dump_hw_setup.argtypes = [POINTER(snd_pcm_t), POINTER(snd_output_t)]

# /usr/include/alsa/pcm.h:868
snd_pcm_dump_sw_setup = _lib.snd_pcm_dump_sw_setup
snd_pcm_dump_sw_setup.restype = c_int
snd_pcm_dump_sw_setup.argtypes = [POINTER(snd_pcm_t), POINTER(snd_output_t)]

# /usr/include/alsa/pcm.h:869
snd_pcm_dump_setup = _lib.snd_pcm_dump_setup
snd_pcm_dump_setup.restype = c_int
snd_pcm_dump_setup.argtypes = [POINTER(snd_pcm_t), POINTER(snd_output_t)]

# /usr/include/alsa/pcm.h:870
snd_pcm_hw_params_dump = _lib.snd_pcm_hw_params_dump
snd_pcm_hw_params_dump.restype = c_int
snd_pcm_hw_params_dump.argtypes = [POINTER(snd_pcm_hw_params_t), POINTER(snd_output_t)]

# /usr/include/alsa/pcm.h:871
snd_pcm_sw_params_dump = _lib.snd_pcm_sw_params_dump
snd_pcm_sw_params_dump.restype = c_int
snd_pcm_sw_params_dump.argtypes = [POINTER(snd_pcm_sw_params_t), POINTER(snd_output_t)]

# /usr/include/alsa/pcm.h:872
snd_pcm_status_dump = _lib.snd_pcm_status_dump
snd_pcm_status_dump.restype = c_int
snd_pcm_status_dump.argtypes = [POINTER(snd_pcm_status_t), POINTER(snd_output_t)]

# /usr/include/alsa/pcm.h:883
snd_pcm_mmap_begin = _lib.snd_pcm_mmap_begin
snd_pcm_mmap_begin.restype = c_int
snd_pcm_mmap_begin.argtypes = [POINTER(snd_pcm_t), POINTER(POINTER(snd_pcm_channel_area_t)), POINTER(snd_pcm_uframes_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:887
snd_pcm_mmap_commit = _lib.snd_pcm_mmap_commit
snd_pcm_mmap_commit.restype = snd_pcm_sframes_t
snd_pcm_mmap_commit.argtypes = [POINTER(snd_pcm_t), snd_pcm_uframes_t, snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:890
snd_pcm_mmap_writei = _lib.snd_pcm_mmap_writei
snd_pcm_mmap_writei.restype = snd_pcm_sframes_t
snd_pcm_mmap_writei.argtypes = [POINTER(snd_pcm_t), POINTER(None), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:891
snd_pcm_mmap_readi = _lib.snd_pcm_mmap_readi
snd_pcm_mmap_readi.restype = snd_pcm_sframes_t
snd_pcm_mmap_readi.argtypes = [POINTER(snd_pcm_t), POINTER(None), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:892
snd_pcm_mmap_writen = _lib.snd_pcm_mmap_writen
snd_pcm_mmap_writen.restype = snd_pcm_sframes_t
snd_pcm_mmap_writen.argtypes = [POINTER(snd_pcm_t), POINTER(POINTER(None)), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:893
snd_pcm_mmap_readn = _lib.snd_pcm_mmap_readn
snd_pcm_mmap_readn.restype = snd_pcm_sframes_t
snd_pcm_mmap_readn.argtypes = [POINTER(snd_pcm_t), POINTER(POINTER(None)), snd_pcm_uframes_t]

# /usr/include/alsa/pcm.h:904
snd_pcm_format_signed = _lib.snd_pcm_format_signed
snd_pcm_format_signed.restype = c_int
snd_pcm_format_signed.argtypes = [snd_pcm_format_t]

# /usr/include/alsa/pcm.h:905
snd_pcm_format_unsigned = _lib.snd_pcm_format_unsigned
snd_pcm_format_unsigned.restype = c_int
snd_pcm_format_unsigned.argtypes = [snd_pcm_format_t]

# /usr/include/alsa/pcm.h:906
snd_pcm_format_linear = _lib.snd_pcm_format_linear
snd_pcm_format_linear.restype = c_int
snd_pcm_format_linear.argtypes = [snd_pcm_format_t]

# /usr/include/alsa/pcm.h:907
snd_pcm_format_float = _lib.snd_pcm_format_float
snd_pcm_format_float.restype = c_int
snd_pcm_format_float.argtypes = [snd_pcm_format_t]

# /usr/include/alsa/pcm.h:908
snd_pcm_format_little_endian = _lib.snd_pcm_format_little_endian
snd_pcm_format_little_endian.restype = c_int
snd_pcm_format_little_endian.argtypes = [snd_pcm_format_t]

# /usr/include/alsa/pcm.h:909
snd_pcm_format_big_endian = _lib.snd_pcm_format_big_endian
snd_pcm_format_big_endian.restype = c_int
snd_pcm_format_big_endian.argtypes = [snd_pcm_format_t]

# /usr/include/alsa/pcm.h:910
snd_pcm_format_cpu_endian = _lib.snd_pcm_format_cpu_endian
snd_pcm_format_cpu_endian.restype = c_int
snd_pcm_format_cpu_endian.argtypes = [snd_pcm_format_t]

# /usr/include/alsa/pcm.h:911
snd_pcm_format_width = _lib.snd_pcm_format_width
snd_pcm_format_width.restype = c_int
snd_pcm_format_width.argtypes = [snd_pcm_format_t]

# /usr/include/alsa/pcm.h:912
snd_pcm_format_physical_width = _lib.snd_pcm_format_physical_width
snd_pcm_format_physical_width.restype = c_int
snd_pcm_format_physical_width.argtypes = [snd_pcm_format_t]

# /usr/include/alsa/pcm.h:913
snd_pcm_build_linear_format = _lib.snd_pcm_build_linear_format
snd_pcm_build_linear_format.restype = snd_pcm_format_t
snd_pcm_build_linear_format.argtypes = [c_int, c_int, c_int, c_int]

# /usr/include/alsa/pcm.h:914
snd_pcm_format_size = _lib.snd_pcm_format_size
snd_pcm_format_size.restype = ssize_t
snd_pcm_format_size.argtypes = [snd_pcm_format_t, c_size_t]

u_int8_t = c_ubyte 	# /usr/include/gentoo-multilib/amd64/sys/types.h:174
# /usr/include/alsa/pcm.h:915
snd_pcm_format_silence = _lib.snd_pcm_format_silence
snd_pcm_format_silence.restype = u_int8_t
snd_pcm_format_silence.argtypes = [snd_pcm_format_t]

u_int16_t = c_uint 	# /usr/include/gentoo-multilib/amd64/sys/types.h:175
# /usr/include/alsa/pcm.h:916
snd_pcm_format_silence_16 = _lib.snd_pcm_format_silence_16
snd_pcm_format_silence_16.restype = u_int16_t
snd_pcm_format_silence_16.argtypes = [snd_pcm_format_t]

u_int32_t = c_uint 	# /usr/include/gentoo-multilib/amd64/sys/types.h:176
# /usr/include/alsa/pcm.h:917
snd_pcm_format_silence_32 = _lib.snd_pcm_format_silence_32
snd_pcm_format_silence_32.restype = u_int32_t
snd_pcm_format_silence_32.argtypes = [snd_pcm_format_t]

u_int64_t = c_ulong 	# /usr/include/gentoo-multilib/amd64/sys/types.h:178
# /usr/include/alsa/pcm.h:918
snd_pcm_format_silence_64 = _lib.snd_pcm_format_silence_64
snd_pcm_format_silence_64.restype = u_int64_t
snd_pcm_format_silence_64.argtypes = [snd_pcm_format_t]

# /usr/include/alsa/pcm.h:919
snd_pcm_format_set_silence = _lib.snd_pcm_format_set_silence
snd_pcm_format_set_silence.restype = c_int
snd_pcm_format_set_silence.argtypes = [snd_pcm_format_t, POINTER(None), c_uint]

# /usr/include/alsa/pcm.h:921
snd_pcm_bytes_to_frames = _lib.snd_pcm_bytes_to_frames
snd_pcm_bytes_to_frames.restype = snd_pcm_sframes_t
snd_pcm_bytes_to_frames.argtypes = [POINTER(snd_pcm_t), ssize_t]

# /usr/include/alsa/pcm.h:922
snd_pcm_frames_to_bytes = _lib.snd_pcm_frames_to_bytes
snd_pcm_frames_to_bytes.restype = ssize_t
snd_pcm_frames_to_bytes.argtypes = [POINTER(snd_pcm_t), snd_pcm_sframes_t]

# /usr/include/alsa/pcm.h:923
snd_pcm_bytes_to_samples = _lib.snd_pcm_bytes_to_samples
snd_pcm_bytes_to_samples.restype = c_long
snd_pcm_bytes_to_samples.argtypes = [POINTER(snd_pcm_t), ssize_t]

# /usr/include/alsa/pcm.h:924
snd_pcm_samples_to_bytes = _lib.snd_pcm_samples_to_bytes
snd_pcm_samples_to_bytes.restype = ssize_t
snd_pcm_samples_to_bytes.argtypes = [POINTER(snd_pcm_t), c_long]

# /usr/include/alsa/pcm.h:926
snd_pcm_area_silence = _lib.snd_pcm_area_silence
snd_pcm_area_silence.restype = c_int
snd_pcm_area_silence.argtypes = [POINTER(snd_pcm_channel_area_t), snd_pcm_uframes_t, c_uint, snd_pcm_format_t]

# /usr/include/alsa/pcm.h:928
snd_pcm_areas_silence = _lib.snd_pcm_areas_silence
snd_pcm_areas_silence.restype = c_int
snd_pcm_areas_silence.argtypes = [POINTER(snd_pcm_channel_area_t), snd_pcm_uframes_t, c_uint, snd_pcm_uframes_t, snd_pcm_format_t]

# /usr/include/alsa/pcm.h:930
snd_pcm_area_copy = _lib.snd_pcm_area_copy
snd_pcm_area_copy.restype = c_int
snd_pcm_area_copy.argtypes = [POINTER(snd_pcm_channel_area_t), snd_pcm_uframes_t, POINTER(snd_pcm_channel_area_t), snd_pcm_uframes_t, c_uint, snd_pcm_format_t]

# /usr/include/alsa/pcm.h:933
snd_pcm_areas_copy = _lib.snd_pcm_areas_copy
snd_pcm_areas_copy.restype = c_int
snd_pcm_areas_copy.argtypes = [POINTER(snd_pcm_channel_area_t), snd_pcm_uframes_t, POINTER(snd_pcm_channel_area_t), snd_pcm_uframes_t, c_uint, snd_pcm_uframes_t, snd_pcm_format_t]

enum__snd_pcm_hook_type = c_int
SND_PCM_HOOK_TYPE_HW_PARAMS = 0
SND_PCM_HOOK_TYPE_HW_FREE = 1
SND_PCM_HOOK_TYPE_CLOSE = 2
SND_PCM_HOOK_TYPE_LAST = 0
snd_pcm_hook_type_t = enum__snd_pcm_hook_type 	# /usr/include/alsa/pcm.h:952
class struct__snd_pcm_hook(Structure):
    __slots__ = [
    ]
struct__snd_pcm_hook._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_pcm_hook(Structure):
    __slots__ = [
    ]
struct__snd_pcm_hook._fields_ = [
    ('_opaque_struct', c_int)
]

snd_pcm_hook_t = struct__snd_pcm_hook 	# /usr/include/alsa/pcm.h:955
snd_pcm_hook_func_t = CFUNCTYPE(c_int, POINTER(snd_pcm_hook_t)) 	# /usr/include/alsa/pcm.h:957
# /usr/include/alsa/pcm.h:958
snd_pcm_hook_get_pcm = _lib.snd_pcm_hook_get_pcm
snd_pcm_hook_get_pcm.restype = POINTER(snd_pcm_t)
snd_pcm_hook_get_pcm.argtypes = [POINTER(snd_pcm_hook_t)]

# /usr/include/alsa/pcm.h:959
snd_pcm_hook_get_private = _lib.snd_pcm_hook_get_private
snd_pcm_hook_get_private.restype = POINTER(c_void)
snd_pcm_hook_get_private.argtypes = [POINTER(snd_pcm_hook_t)]

# /usr/include/alsa/pcm.h:960
snd_pcm_hook_set_private = _lib.snd_pcm_hook_set_private
snd_pcm_hook_set_private.restype = None
snd_pcm_hook_set_private.argtypes = [POINTER(snd_pcm_hook_t), POINTER(None)]

# /usr/include/alsa/pcm.h:961
snd_pcm_hook_add = _lib.snd_pcm_hook_add
snd_pcm_hook_add.restype = c_int
snd_pcm_hook_add.argtypes = [POINTER(POINTER(snd_pcm_hook_t)), POINTER(snd_pcm_t), snd_pcm_hook_type_t, snd_pcm_hook_func_t, POINTER(None)]

# /usr/include/alsa/pcm.h:964
snd_pcm_hook_remove = _lib.snd_pcm_hook_remove
snd_pcm_hook_remove.restype = c_int
snd_pcm_hook_remove.argtypes = [POINTER(snd_pcm_hook_t)]

class struct__snd_pcm_scope_ops(Structure):
    __slots__ = [
        'enable',
        'disable',
        'start',
        'stop',
        'update',
        'reset',
        'close',
    ]
struct__snd_pcm_scope_ops._fields_ = [
    ('enable', POINTER(CFUNCTYPE(c_int, POINTER(snd_pcm_scope_t)))),
    ('disable', POINTER(CFUNCTYPE(None, POINTER(snd_pcm_scope_t)))),
    ('start', POINTER(CFUNCTYPE(None, POINTER(snd_pcm_scope_t)))),
    ('stop', POINTER(CFUNCTYPE(None, POINTER(snd_pcm_scope_t)))),
    ('update', POINTER(CFUNCTYPE(None, POINTER(snd_pcm_scope_t)))),
    ('reset', POINTER(CFUNCTYPE(None, POINTER(snd_pcm_scope_t)))),
    ('close', POINTER(CFUNCTYPE(None, POINTER(snd_pcm_scope_t)))),
]

snd_pcm_scope_ops_t = struct__snd_pcm_scope_ops 	# /usr/include/alsa/pcm.h:1005
# /usr/include/alsa/pcm.h:1007
snd_pcm_meter_get_bufsize = _lib.snd_pcm_meter_get_bufsize
snd_pcm_meter_get_bufsize.restype = snd_pcm_uframes_t
snd_pcm_meter_get_bufsize.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:1008
snd_pcm_meter_get_channels = _lib.snd_pcm_meter_get_channels
snd_pcm_meter_get_channels.restype = c_uint
snd_pcm_meter_get_channels.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:1009
snd_pcm_meter_get_rate = _lib.snd_pcm_meter_get_rate
snd_pcm_meter_get_rate.restype = c_uint
snd_pcm_meter_get_rate.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:1010
snd_pcm_meter_get_now = _lib.snd_pcm_meter_get_now
snd_pcm_meter_get_now.restype = snd_pcm_uframes_t
snd_pcm_meter_get_now.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:1011
snd_pcm_meter_get_boundary = _lib.snd_pcm_meter_get_boundary
snd_pcm_meter_get_boundary.restype = snd_pcm_uframes_t
snd_pcm_meter_get_boundary.argtypes = [POINTER(snd_pcm_t)]

# /usr/include/alsa/pcm.h:1012
snd_pcm_meter_add_scope = _lib.snd_pcm_meter_add_scope
snd_pcm_meter_add_scope.restype = c_int
snd_pcm_meter_add_scope.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_scope_t)]

# /usr/include/alsa/pcm.h:1013
snd_pcm_meter_search_scope = _lib.snd_pcm_meter_search_scope
snd_pcm_meter_search_scope.restype = POINTER(snd_pcm_scope_t)
snd_pcm_meter_search_scope.argtypes = [POINTER(snd_pcm_t), c_char_p]

# /usr/include/alsa/pcm.h:1014
snd_pcm_scope_malloc = _lib.snd_pcm_scope_malloc
snd_pcm_scope_malloc.restype = c_int
snd_pcm_scope_malloc.argtypes = [POINTER(POINTER(snd_pcm_scope_t))]

# /usr/include/alsa/pcm.h:1015
snd_pcm_scope_set_ops = _lib.snd_pcm_scope_set_ops
snd_pcm_scope_set_ops.restype = None
snd_pcm_scope_set_ops.argtypes = [POINTER(snd_pcm_scope_t), POINTER(snd_pcm_scope_ops_t)]

# /usr/include/alsa/pcm.h:1016
snd_pcm_scope_set_name = _lib.snd_pcm_scope_set_name
snd_pcm_scope_set_name.restype = None
snd_pcm_scope_set_name.argtypes = [POINTER(snd_pcm_scope_t), c_char_p]

# /usr/include/alsa/pcm.h:1017
snd_pcm_scope_get_name = _lib.snd_pcm_scope_get_name
snd_pcm_scope_get_name.restype = c_char_p
snd_pcm_scope_get_name.argtypes = [POINTER(snd_pcm_scope_t)]

# /usr/include/alsa/pcm.h:1018
snd_pcm_scope_get_callback_private = _lib.snd_pcm_scope_get_callback_private
snd_pcm_scope_get_callback_private.restype = POINTER(c_void)
snd_pcm_scope_get_callback_private.argtypes = [POINTER(snd_pcm_scope_t)]

# /usr/include/alsa/pcm.h:1019
snd_pcm_scope_set_callback_private = _lib.snd_pcm_scope_set_callback_private
snd_pcm_scope_set_callback_private.restype = None
snd_pcm_scope_set_callback_private.argtypes = [POINTER(snd_pcm_scope_t), POINTER(None)]

# /usr/include/alsa/pcm.h:1020
snd_pcm_scope_s16_open = _lib.snd_pcm_scope_s16_open
snd_pcm_scope_s16_open.restype = c_int
snd_pcm_scope_s16_open.argtypes = [POINTER(snd_pcm_t), c_char_p, POINTER(POINTER(snd_pcm_scope_t))]

# /usr/include/alsa/pcm.h:1022
snd_pcm_scope_s16_get_channel_buffer = _lib.snd_pcm_scope_s16_get_channel_buffer
snd_pcm_scope_s16_get_channel_buffer.restype = POINTER(c_int16)
snd_pcm_scope_s16_get_channel_buffer.argtypes = [POINTER(snd_pcm_scope_t), c_uint]

enum__snd_spcm_latency = c_int
SND_SPCM_LATENCY_STANDARD = 0
SND_SPCM_LATENCY_MEDIUM = 1
SND_SPCM_LATENCY_REALTIME = 2
snd_spcm_latency_t = enum__snd_spcm_latency 	# /usr/include/alsa/pcm.h:1045
enum__snd_spcm_xrun_type = c_int
SND_SPCM_XRUN_IGNORE = 0
SND_SPCM_XRUN_STOP = 1
snd_spcm_xrun_type_t = enum__snd_spcm_xrun_type 	# /usr/include/alsa/pcm.h:1053
enum__snd_spcm_duplex_type = c_int
SND_SPCM_DUPLEX_LIBERAL = 0
SND_SPCM_DUPLEX_PEDANTIC = 1
snd_spcm_duplex_type_t = enum__snd_spcm_duplex_type 	# /usr/include/alsa/pcm.h:1061
# /usr/include/alsa/pcm.h:1063
snd_spcm_init = _lib.snd_spcm_init
snd_spcm_init.restype = c_int
snd_spcm_init.argtypes = [POINTER(snd_pcm_t), c_uint, c_uint, snd_pcm_format_t, snd_pcm_subformat_t, snd_spcm_latency_t, snd_pcm_access_t, snd_spcm_xrun_type_t]

# /usr/include/alsa/pcm.h:1072
snd_spcm_init_duplex = _lib.snd_spcm_init_duplex
snd_spcm_init_duplex.restype = c_int
snd_spcm_init_duplex.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_t), c_uint, c_uint, snd_pcm_format_t, snd_pcm_subformat_t, snd_spcm_latency_t, snd_pcm_access_t, snd_spcm_xrun_type_t, snd_spcm_duplex_type_t]

# /usr/include/alsa/pcm.h:1083
snd_spcm_init_get_params = _lib.snd_spcm_init_get_params
snd_spcm_init_get_params.restype = c_int
snd_spcm_init_get_params.argtypes = [POINTER(snd_pcm_t), POINTER(c_uint), POINTER(snd_pcm_uframes_t), POINTER(snd_pcm_uframes_t)]

# /usr/include/alsa/pcm.h:1098
snd_pcm_start_mode_name = _lib.snd_pcm_start_mode_name
snd_pcm_start_mode_name.restype = c_char_p
snd_pcm_start_mode_name.argtypes = [snd_pcm_start_t]

# /usr/include/alsa/pcm.h:1099
snd_pcm_xrun_mode_name = _lib.snd_pcm_xrun_mode_name
snd_pcm_xrun_mode_name.restype = c_char_p
snd_pcm_xrun_mode_name.argtypes = [snd_pcm_xrun_t]

# /usr/include/alsa/pcm.h:1100
snd_pcm_sw_params_set_start_mode = _lib.snd_pcm_sw_params_set_start_mode
snd_pcm_sw_params_set_start_mode.restype = c_int
snd_pcm_sw_params_set_start_mode.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_sw_params_t), snd_pcm_start_t]

# /usr/include/alsa/pcm.h:1101
snd_pcm_sw_params_get_start_mode = _lib.snd_pcm_sw_params_get_start_mode
snd_pcm_sw_params_get_start_mode.restype = snd_pcm_start_t
snd_pcm_sw_params_get_start_mode.argtypes = [POINTER(snd_pcm_sw_params_t)]

# /usr/include/alsa/pcm.h:1102
snd_pcm_sw_params_set_xrun_mode = _lib.snd_pcm_sw_params_set_xrun_mode
snd_pcm_sw_params_set_xrun_mode.restype = c_int
snd_pcm_sw_params_set_xrun_mode.argtypes = [POINTER(snd_pcm_t), POINTER(snd_pcm_sw_params_t), snd_pcm_xrun_t]

# /usr/include/alsa/pcm.h:1103
snd_pcm_sw_params_get_xrun_mode = _lib.snd_pcm_sw_params_get_xrun_mode
snd_pcm_sw_params_get_xrun_mode.restype = snd_pcm_xrun_t
snd_pcm_sw_params_get_xrun_mode.argtypes = [POINTER(snd_pcm_sw_params_t)]

SND_RAWMIDI_DLSYM_VERSION = 0 	# /usr/include/alsa/rawmidi.h:42
class struct__snd_rawmidi_info(Structure):
    __slots__ = [
    ]
struct__snd_rawmidi_info._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_rawmidi_info(Structure):
    __slots__ = [
    ]
struct__snd_rawmidi_info._fields_ = [
    ('_opaque_struct', c_int)
]

snd_rawmidi_info_t = struct__snd_rawmidi_info 	# /usr/include/alsa/rawmidi.h:45
class struct__snd_rawmidi_params(Structure):
    __slots__ = [
    ]
struct__snd_rawmidi_params._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_rawmidi_params(Structure):
    __slots__ = [
    ]
struct__snd_rawmidi_params._fields_ = [
    ('_opaque_struct', c_int)
]

snd_rawmidi_params_t = struct__snd_rawmidi_params 	# /usr/include/alsa/rawmidi.h:47
class struct__snd_rawmidi_status(Structure):
    __slots__ = [
    ]
struct__snd_rawmidi_status._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_rawmidi_status(Structure):
    __slots__ = [
    ]
struct__snd_rawmidi_status._fields_ = [
    ('_opaque_struct', c_int)
]

snd_rawmidi_status_t = struct__snd_rawmidi_status 	# /usr/include/alsa/rawmidi.h:49
enum__snd_rawmidi_stream = c_int
SND_RAWMIDI_STREAM_OUTPUT = 0
SND_RAWMIDI_STREAM_INPUT = 1
SND_RAWMIDI_STREAM_LAST = 0
snd_rawmidi_stream_t = enum__snd_rawmidi_stream 	# /usr/include/alsa/rawmidi.h:58
SND_RAWMIDI_APPEND = 1 	# /usr/include/alsa/rawmidi.h:61
SND_RAWMIDI_NONBLOCK = 2 	# /usr/include/alsa/rawmidi.h:63
SND_RAWMIDI_SYNC = 4 	# /usr/include/alsa/rawmidi.h:65
class struct__snd_rawmidi(Structure):
    __slots__ = [
    ]
struct__snd_rawmidi._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_rawmidi(Structure):
    __slots__ = [
    ]
struct__snd_rawmidi._fields_ = [
    ('_opaque_struct', c_int)
]

snd_rawmidi_t = struct__snd_rawmidi 	# /usr/include/alsa/rawmidi.h:68
enum__snd_rawmidi_type = c_int
SND_RAWMIDI_TYPE_HW = 1
SND_RAWMIDI_TYPE_SHM = 2
SND_RAWMIDI_TYPE_INET = 3
SND_RAWMIDI_TYPE_VIRTUAL = 4
snd_rawmidi_type_t = enum__snd_rawmidi_type 	# /usr/include/alsa/rawmidi.h:80
# /usr/include/alsa/rawmidi.h:82
snd_rawmidi_open = _lib.snd_rawmidi_open
snd_rawmidi_open.restype = c_int
snd_rawmidi_open.argtypes = [POINTER(POINTER(snd_rawmidi_t)), POINTER(POINTER(snd_rawmidi_t)), c_char_p, c_int]

# /usr/include/alsa/rawmidi.h:84
snd_rawmidi_open_lconf = _lib.snd_rawmidi_open_lconf
snd_rawmidi_open_lconf.restype = c_int
snd_rawmidi_open_lconf.argtypes = [POINTER(POINTER(snd_rawmidi_t)), POINTER(POINTER(snd_rawmidi_t)), c_char_p, c_int, POINTER(snd_config_t)]

# /usr/include/alsa/rawmidi.h:86
snd_rawmidi_close = _lib.snd_rawmidi_close
snd_rawmidi_close.restype = c_int
snd_rawmidi_close.argtypes = [POINTER(snd_rawmidi_t)]

# /usr/include/alsa/rawmidi.h:87
snd_rawmidi_poll_descriptors_count = _lib.snd_rawmidi_poll_descriptors_count
snd_rawmidi_poll_descriptors_count.restype = c_int
snd_rawmidi_poll_descriptors_count.argtypes = [POINTER(snd_rawmidi_t)]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/rawmidi.h:88
snd_rawmidi_poll_descriptors = _lib.snd_rawmidi_poll_descriptors
snd_rawmidi_poll_descriptors.restype = c_int
snd_rawmidi_poll_descriptors.argtypes = [POINTER(snd_rawmidi_t), POINTER(struct_pollfd), c_uint]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/rawmidi.h:89
snd_rawmidi_poll_descriptors_revents = _lib.snd_rawmidi_poll_descriptors_revents
snd_rawmidi_poll_descriptors_revents.restype = c_int
snd_rawmidi_poll_descriptors_revents.argtypes = [POINTER(snd_rawmidi_t), POINTER(struct_pollfd), c_uint, POINTER(c_ushort)]

# /usr/include/alsa/rawmidi.h:90
snd_rawmidi_nonblock = _lib.snd_rawmidi_nonblock
snd_rawmidi_nonblock.restype = c_int
snd_rawmidi_nonblock.argtypes = [POINTER(snd_rawmidi_t), c_int]

# /usr/include/alsa/rawmidi.h:91
snd_rawmidi_info_sizeof = _lib.snd_rawmidi_info_sizeof
snd_rawmidi_info_sizeof.restype = c_size_t
snd_rawmidi_info_sizeof.argtypes = []

# /usr/include/alsa/rawmidi.h:97
snd_rawmidi_info_malloc = _lib.snd_rawmidi_info_malloc
snd_rawmidi_info_malloc.restype = c_int
snd_rawmidi_info_malloc.argtypes = [POINTER(POINTER(snd_rawmidi_info_t))]

# /usr/include/alsa/rawmidi.h:98
snd_rawmidi_info_free = _lib.snd_rawmidi_info_free
snd_rawmidi_info_free.restype = None
snd_rawmidi_info_free.argtypes = [POINTER(snd_rawmidi_info_t)]

# /usr/include/alsa/rawmidi.h:99
snd_rawmidi_info_copy = _lib.snd_rawmidi_info_copy
snd_rawmidi_info_copy.restype = None
snd_rawmidi_info_copy.argtypes = [POINTER(snd_rawmidi_info_t), POINTER(snd_rawmidi_info_t)]

# /usr/include/alsa/rawmidi.h:100
snd_rawmidi_info_get_device = _lib.snd_rawmidi_info_get_device
snd_rawmidi_info_get_device.restype = c_uint
snd_rawmidi_info_get_device.argtypes = [POINTER(snd_rawmidi_info_t)]

# /usr/include/alsa/rawmidi.h:101
snd_rawmidi_info_get_subdevice = _lib.snd_rawmidi_info_get_subdevice
snd_rawmidi_info_get_subdevice.restype = c_uint
snd_rawmidi_info_get_subdevice.argtypes = [POINTER(snd_rawmidi_info_t)]

# /usr/include/alsa/rawmidi.h:102
snd_rawmidi_info_get_stream = _lib.snd_rawmidi_info_get_stream
snd_rawmidi_info_get_stream.restype = snd_rawmidi_stream_t
snd_rawmidi_info_get_stream.argtypes = [POINTER(snd_rawmidi_info_t)]

# /usr/include/alsa/rawmidi.h:103
snd_rawmidi_info_get_card = _lib.snd_rawmidi_info_get_card
snd_rawmidi_info_get_card.restype = c_int
snd_rawmidi_info_get_card.argtypes = [POINTER(snd_rawmidi_info_t)]

# /usr/include/alsa/rawmidi.h:104
snd_rawmidi_info_get_flags = _lib.snd_rawmidi_info_get_flags
snd_rawmidi_info_get_flags.restype = c_uint
snd_rawmidi_info_get_flags.argtypes = [POINTER(snd_rawmidi_info_t)]

# /usr/include/alsa/rawmidi.h:105
snd_rawmidi_info_get_id = _lib.snd_rawmidi_info_get_id
snd_rawmidi_info_get_id.restype = c_char_p
snd_rawmidi_info_get_id.argtypes = [POINTER(snd_rawmidi_info_t)]

# /usr/include/alsa/rawmidi.h:106
snd_rawmidi_info_get_name = _lib.snd_rawmidi_info_get_name
snd_rawmidi_info_get_name.restype = c_char_p
snd_rawmidi_info_get_name.argtypes = [POINTER(snd_rawmidi_info_t)]

# /usr/include/alsa/rawmidi.h:107
snd_rawmidi_info_get_subdevice_name = _lib.snd_rawmidi_info_get_subdevice_name
snd_rawmidi_info_get_subdevice_name.restype = c_char_p
snd_rawmidi_info_get_subdevice_name.argtypes = [POINTER(snd_rawmidi_info_t)]

# /usr/include/alsa/rawmidi.h:108
snd_rawmidi_info_get_subdevices_count = _lib.snd_rawmidi_info_get_subdevices_count
snd_rawmidi_info_get_subdevices_count.restype = c_uint
snd_rawmidi_info_get_subdevices_count.argtypes = [POINTER(snd_rawmidi_info_t)]

# /usr/include/alsa/rawmidi.h:109
snd_rawmidi_info_get_subdevices_avail = _lib.snd_rawmidi_info_get_subdevices_avail
snd_rawmidi_info_get_subdevices_avail.restype = c_uint
snd_rawmidi_info_get_subdevices_avail.argtypes = [POINTER(snd_rawmidi_info_t)]

# /usr/include/alsa/rawmidi.h:110
snd_rawmidi_info_set_device = _lib.snd_rawmidi_info_set_device
snd_rawmidi_info_set_device.restype = None
snd_rawmidi_info_set_device.argtypes = [POINTER(snd_rawmidi_info_t), c_uint]

# /usr/include/alsa/rawmidi.h:111
snd_rawmidi_info_set_subdevice = _lib.snd_rawmidi_info_set_subdevice
snd_rawmidi_info_set_subdevice.restype = None
snd_rawmidi_info_set_subdevice.argtypes = [POINTER(snd_rawmidi_info_t), c_uint]

# /usr/include/alsa/rawmidi.h:112
snd_rawmidi_info_set_stream = _lib.snd_rawmidi_info_set_stream
snd_rawmidi_info_set_stream.restype = None
snd_rawmidi_info_set_stream.argtypes = [POINTER(snd_rawmidi_info_t), snd_rawmidi_stream_t]

# /usr/include/alsa/rawmidi.h:113
snd_rawmidi_info = _lib.snd_rawmidi_info
snd_rawmidi_info.restype = c_int
snd_rawmidi_info.argtypes = [POINTER(snd_rawmidi_t), POINTER(snd_rawmidi_info_t)]

# /usr/include/alsa/rawmidi.h:114
snd_rawmidi_params_sizeof = _lib.snd_rawmidi_params_sizeof
snd_rawmidi_params_sizeof.restype = c_size_t
snd_rawmidi_params_sizeof.argtypes = []

# /usr/include/alsa/rawmidi.h:120
snd_rawmidi_params_malloc = _lib.snd_rawmidi_params_malloc
snd_rawmidi_params_malloc.restype = c_int
snd_rawmidi_params_malloc.argtypes = [POINTER(POINTER(snd_rawmidi_params_t))]

# /usr/include/alsa/rawmidi.h:121
snd_rawmidi_params_free = _lib.snd_rawmidi_params_free
snd_rawmidi_params_free.restype = None
snd_rawmidi_params_free.argtypes = [POINTER(snd_rawmidi_params_t)]

# /usr/include/alsa/rawmidi.h:122
snd_rawmidi_params_copy = _lib.snd_rawmidi_params_copy
snd_rawmidi_params_copy.restype = None
snd_rawmidi_params_copy.argtypes = [POINTER(snd_rawmidi_params_t), POINTER(snd_rawmidi_params_t)]

# /usr/include/alsa/rawmidi.h:123
snd_rawmidi_params_set_buffer_size = _lib.snd_rawmidi_params_set_buffer_size
snd_rawmidi_params_set_buffer_size.restype = c_int
snd_rawmidi_params_set_buffer_size.argtypes = [POINTER(snd_rawmidi_t), POINTER(snd_rawmidi_params_t), c_size_t]

# /usr/include/alsa/rawmidi.h:124
snd_rawmidi_params_get_buffer_size = _lib.snd_rawmidi_params_get_buffer_size
snd_rawmidi_params_get_buffer_size.restype = c_size_t
snd_rawmidi_params_get_buffer_size.argtypes = [POINTER(snd_rawmidi_params_t)]

# /usr/include/alsa/rawmidi.h:125
snd_rawmidi_params_set_avail_min = _lib.snd_rawmidi_params_set_avail_min
snd_rawmidi_params_set_avail_min.restype = c_int
snd_rawmidi_params_set_avail_min.argtypes = [POINTER(snd_rawmidi_t), POINTER(snd_rawmidi_params_t), c_size_t]

# /usr/include/alsa/rawmidi.h:126
snd_rawmidi_params_get_avail_min = _lib.snd_rawmidi_params_get_avail_min
snd_rawmidi_params_get_avail_min.restype = c_size_t
snd_rawmidi_params_get_avail_min.argtypes = [POINTER(snd_rawmidi_params_t)]

# /usr/include/alsa/rawmidi.h:127
snd_rawmidi_params_set_no_active_sensing = _lib.snd_rawmidi_params_set_no_active_sensing
snd_rawmidi_params_set_no_active_sensing.restype = c_int
snd_rawmidi_params_set_no_active_sensing.argtypes = [POINTER(snd_rawmidi_t), POINTER(snd_rawmidi_params_t), c_int]

# /usr/include/alsa/rawmidi.h:128
snd_rawmidi_params_get_no_active_sensing = _lib.snd_rawmidi_params_get_no_active_sensing
snd_rawmidi_params_get_no_active_sensing.restype = c_int
snd_rawmidi_params_get_no_active_sensing.argtypes = [POINTER(snd_rawmidi_params_t)]

# /usr/include/alsa/rawmidi.h:129
snd_rawmidi_params = _lib.snd_rawmidi_params
snd_rawmidi_params.restype = c_int
snd_rawmidi_params.argtypes = [POINTER(snd_rawmidi_t), POINTER(snd_rawmidi_params_t)]

# /usr/include/alsa/rawmidi.h:130
snd_rawmidi_params_current = _lib.snd_rawmidi_params_current
snd_rawmidi_params_current.restype = c_int
snd_rawmidi_params_current.argtypes = [POINTER(snd_rawmidi_t), POINTER(snd_rawmidi_params_t)]

# /usr/include/alsa/rawmidi.h:131
snd_rawmidi_status_sizeof = _lib.snd_rawmidi_status_sizeof
snd_rawmidi_status_sizeof.restype = c_size_t
snd_rawmidi_status_sizeof.argtypes = []

# /usr/include/alsa/rawmidi.h:137
snd_rawmidi_status_malloc = _lib.snd_rawmidi_status_malloc
snd_rawmidi_status_malloc.restype = c_int
snd_rawmidi_status_malloc.argtypes = [POINTER(POINTER(snd_rawmidi_status_t))]

# /usr/include/alsa/rawmidi.h:138
snd_rawmidi_status_free = _lib.snd_rawmidi_status_free
snd_rawmidi_status_free.restype = None
snd_rawmidi_status_free.argtypes = [POINTER(snd_rawmidi_status_t)]

# /usr/include/alsa/rawmidi.h:139
snd_rawmidi_status_copy = _lib.snd_rawmidi_status_copy
snd_rawmidi_status_copy.restype = None
snd_rawmidi_status_copy.argtypes = [POINTER(snd_rawmidi_status_t), POINTER(snd_rawmidi_status_t)]

# /usr/include/alsa/rawmidi.h:140
snd_rawmidi_status_get_tstamp = _lib.snd_rawmidi_status_get_tstamp
snd_rawmidi_status_get_tstamp.restype = None
snd_rawmidi_status_get_tstamp.argtypes = [POINTER(snd_rawmidi_status_t), POINTER(snd_htimestamp_t)]

# /usr/include/alsa/rawmidi.h:141
snd_rawmidi_status_get_avail = _lib.snd_rawmidi_status_get_avail
snd_rawmidi_status_get_avail.restype = c_size_t
snd_rawmidi_status_get_avail.argtypes = [POINTER(snd_rawmidi_status_t)]

# /usr/include/alsa/rawmidi.h:142
snd_rawmidi_status_get_xruns = _lib.snd_rawmidi_status_get_xruns
snd_rawmidi_status_get_xruns.restype = c_size_t
snd_rawmidi_status_get_xruns.argtypes = [POINTER(snd_rawmidi_status_t)]

# /usr/include/alsa/rawmidi.h:143
snd_rawmidi_status = _lib.snd_rawmidi_status
snd_rawmidi_status.restype = c_int
snd_rawmidi_status.argtypes = [POINTER(snd_rawmidi_t), POINTER(snd_rawmidi_status_t)]

# /usr/include/alsa/rawmidi.h:144
snd_rawmidi_drain = _lib.snd_rawmidi_drain
snd_rawmidi_drain.restype = c_int
snd_rawmidi_drain.argtypes = [POINTER(snd_rawmidi_t)]

# /usr/include/alsa/rawmidi.h:145
snd_rawmidi_drop = _lib.snd_rawmidi_drop
snd_rawmidi_drop.restype = c_int
snd_rawmidi_drop.argtypes = [POINTER(snd_rawmidi_t)]

# /usr/include/alsa/rawmidi.h:146
snd_rawmidi_write = _lib.snd_rawmidi_write
snd_rawmidi_write.restype = ssize_t
snd_rawmidi_write.argtypes = [POINTER(snd_rawmidi_t), POINTER(None), c_size_t]

# /usr/include/alsa/rawmidi.h:147
snd_rawmidi_read = _lib.snd_rawmidi_read
snd_rawmidi_read.restype = ssize_t
snd_rawmidi_read.argtypes = [POINTER(snd_rawmidi_t), POINTER(None), c_size_t]

# /usr/include/alsa/rawmidi.h:148
snd_rawmidi_name = _lib.snd_rawmidi_name
snd_rawmidi_name.restype = c_char_p
snd_rawmidi_name.argtypes = [POINTER(snd_rawmidi_t)]

# /usr/include/alsa/rawmidi.h:149
snd_rawmidi_type = _lib.snd_rawmidi_type
snd_rawmidi_type.restype = snd_rawmidi_type_t
snd_rawmidi_type.argtypes = [POINTER(snd_rawmidi_t)]

# /usr/include/alsa/rawmidi.h:150
snd_rawmidi_stream = _lib.snd_rawmidi_stream
snd_rawmidi_stream.restype = snd_rawmidi_stream_t
snd_rawmidi_stream.argtypes = [POINTER(snd_rawmidi_t)]

SND_TIMER_DLSYM_VERSION = 0 	# /usr/include/alsa/timer.h:42
SND_TIMER_QUERY_DLSYM_VERSION = 0 	# /usr/include/alsa/timer.h:44
class struct__snd_timer_id(Structure):
    __slots__ = [
    ]
struct__snd_timer_id._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_timer_id(Structure):
    __slots__ = [
    ]
struct__snd_timer_id._fields_ = [
    ('_opaque_struct', c_int)
]

snd_timer_id_t = struct__snd_timer_id 	# /usr/include/alsa/timer.h:47
class struct__snd_timer_ginfo(Structure):
    __slots__ = [
    ]
struct__snd_timer_ginfo._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_timer_ginfo(Structure):
    __slots__ = [
    ]
struct__snd_timer_ginfo._fields_ = [
    ('_opaque_struct', c_int)
]

snd_timer_ginfo_t = struct__snd_timer_ginfo 	# /usr/include/alsa/timer.h:49
class struct__snd_timer_gparams(Structure):
    __slots__ = [
    ]
struct__snd_timer_gparams._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_timer_gparams(Structure):
    __slots__ = [
    ]
struct__snd_timer_gparams._fields_ = [
    ('_opaque_struct', c_int)
]

snd_timer_gparams_t = struct__snd_timer_gparams 	# /usr/include/alsa/timer.h:51
class struct__snd_timer_gstatus(Structure):
    __slots__ = [
    ]
struct__snd_timer_gstatus._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_timer_gstatus(Structure):
    __slots__ = [
    ]
struct__snd_timer_gstatus._fields_ = [
    ('_opaque_struct', c_int)
]

snd_timer_gstatus_t = struct__snd_timer_gstatus 	# /usr/include/alsa/timer.h:53
class struct__snd_timer_info(Structure):
    __slots__ = [
    ]
struct__snd_timer_info._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_timer_info(Structure):
    __slots__ = [
    ]
struct__snd_timer_info._fields_ = [
    ('_opaque_struct', c_int)
]

snd_timer_info_t = struct__snd_timer_info 	# /usr/include/alsa/timer.h:55
class struct__snd_timer_params(Structure):
    __slots__ = [
    ]
struct__snd_timer_params._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_timer_params(Structure):
    __slots__ = [
    ]
struct__snd_timer_params._fields_ = [
    ('_opaque_struct', c_int)
]

snd_timer_params_t = struct__snd_timer_params 	# /usr/include/alsa/timer.h:57
class struct__snd_timer_status(Structure):
    __slots__ = [
    ]
struct__snd_timer_status._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_timer_status(Structure):
    __slots__ = [
    ]
struct__snd_timer_status._fields_ = [
    ('_opaque_struct', c_int)
]

snd_timer_status_t = struct__snd_timer_status 	# /usr/include/alsa/timer.h:59
enum__snd_timer_class = c_int
SND_TIMER_CLASS_NONE = 1
SND_TIMER_CLASS_SLAVE = 0
SND_TIMER_CLASS_GLOBAL = 1
SND_TIMER_CLASS_CARD = 2
SND_TIMER_CLASS_PCM = 3
SND_TIMER_CLASS_LAST = 0
snd_timer_class_t = enum__snd_timer_class 	# /usr/include/alsa/timer.h:68
enum__snd_timer_slave_class = c_int
SND_TIMER_SCLASS_NONE = 0
SND_TIMER_SCLASS_APPLICATION = 1
SND_TIMER_SCLASS_SEQUENCER = 2
SND_TIMER_SCLASS_OSS_SEQUENCER = 3
SND_TIMER_SCLASS_LAST = 0
snd_timer_slave_class_t = enum__snd_timer_slave_class 	# /usr/include/alsa/timer.h:77
enum__snd_timer_event = c_int
SND_TIMER_EVENT_RESOLUTION = 0
SND_TIMER_EVENT_TICK = 1
SND_TIMER_EVENT_START = 2
SND_TIMER_EVENT_STOP = 3
SND_TIMER_EVENT_CONTINUE = 4
SND_TIMER_EVENT_PAUSE = 5
SND_TIMER_EVENT_EARLY = 6
SND_TIMER_EVENT_SUSPEND = 7
SND_TIMER_EVENT_RESUME = 8
SND_TIMER_EVENT_MSTART = 9
SND_TIMER_EVENT_MSTOP = 10
SND_TIMER_EVENT_MCONTINUE = 11
SND_TIMER_EVENT_MPAUSE = 12
SND_TIMER_EVENT_MSUSPEND = 13
SND_TIMER_EVENT_MRESUME = 14
snd_timer_event_t = enum__snd_timer_event 	# /usr/include/alsa/timer.h:97
class struct__snd_timer_read(Structure):
    __slots__ = [
        'resolution',
        'ticks',
    ]
struct__snd_timer_read._fields_ = [
    ('resolution', c_uint),
    ('ticks', c_uint),
]

snd_timer_read_t = struct__snd_timer_read 	# /usr/include/alsa/timer.h:103
class struct__snd_timer_tread(Structure):
    __slots__ = [
        'event',
        'tstamp',
        'val',
    ]
struct__snd_timer_tread._fields_ = [
    ('event', snd_timer_event_t),
    ('tstamp', snd_htimestamp_t),
    ('val', c_uint),
]

snd_timer_tread_t = struct__snd_timer_tread 	# /usr/include/alsa/timer.h:110
SND_TIMER_GLOBAL_SYSTEM = 0 	# /usr/include/alsa/timer.h:113
SND_TIMER_GLOBAL_RTC = 1 	# /usr/include/alsa/timer.h:115
SND_TIMER_GLOBAL_HPET = 2 	# /usr/include/alsa/timer.h:117
SND_TIMER_OPEN_NONBLOCK = 1 	# /usr/include/alsa/timer.h:120
SND_TIMER_OPEN_TREAD = 2 	# /usr/include/alsa/timer.h:122
enum__snd_timer_type = c_int
SND_TIMER_TYPE_HW = 0
SND_TIMER_TYPE_SHM = 1
SND_TIMER_TYPE_INET = 2
snd_timer_type_t = enum__snd_timer_type 	# /usr/include/alsa/timer.h:132
class struct__snd_timer_query(Structure):
    __slots__ = [
    ]
struct__snd_timer_query._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_timer_query(Structure):
    __slots__ = [
    ]
struct__snd_timer_query._fields_ = [
    ('_opaque_struct', c_int)
]

snd_timer_query_t = struct__snd_timer_query 	# /usr/include/alsa/timer.h:135
class struct__snd_timer(Structure):
    __slots__ = [
    ]
struct__snd_timer._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_timer(Structure):
    __slots__ = [
    ]
struct__snd_timer._fields_ = [
    ('_opaque_struct', c_int)
]

snd_timer_t = struct__snd_timer 	# /usr/include/alsa/timer.h:137
# /usr/include/alsa/timer.h:140
snd_timer_query_open = _lib.snd_timer_query_open
snd_timer_query_open.restype = c_int
snd_timer_query_open.argtypes = [POINTER(POINTER(snd_timer_query_t)), c_char_p, c_int]

# /usr/include/alsa/timer.h:141
snd_timer_query_open_lconf = _lib.snd_timer_query_open_lconf
snd_timer_query_open_lconf.restype = c_int
snd_timer_query_open_lconf.argtypes = [POINTER(POINTER(snd_timer_query_t)), c_char_p, c_int, POINTER(snd_config_t)]

# /usr/include/alsa/timer.h:142
snd_timer_query_close = _lib.snd_timer_query_close
snd_timer_query_close.restype = c_int
snd_timer_query_close.argtypes = [POINTER(snd_timer_query_t)]

# /usr/include/alsa/timer.h:143
snd_timer_query_next_device = _lib.snd_timer_query_next_device
snd_timer_query_next_device.restype = c_int
snd_timer_query_next_device.argtypes = [POINTER(snd_timer_query_t), POINTER(snd_timer_id_t)]

# /usr/include/alsa/timer.h:144
snd_timer_query_info = _lib.snd_timer_query_info
snd_timer_query_info.restype = c_int
snd_timer_query_info.argtypes = [POINTER(snd_timer_query_t), POINTER(snd_timer_ginfo_t)]

# /usr/include/alsa/timer.h:145
snd_timer_query_params = _lib.snd_timer_query_params
snd_timer_query_params.restype = c_int
snd_timer_query_params.argtypes = [POINTER(snd_timer_query_t), POINTER(snd_timer_gparams_t)]

# /usr/include/alsa/timer.h:146
snd_timer_query_status = _lib.snd_timer_query_status
snd_timer_query_status.restype = c_int
snd_timer_query_status.argtypes = [POINTER(snd_timer_query_t), POINTER(snd_timer_gstatus_t)]

# /usr/include/alsa/timer.h:148
snd_timer_open = _lib.snd_timer_open
snd_timer_open.restype = c_int
snd_timer_open.argtypes = [POINTER(POINTER(snd_timer_t)), c_char_p, c_int]

# /usr/include/alsa/timer.h:149
snd_timer_open_lconf = _lib.snd_timer_open_lconf
snd_timer_open_lconf.restype = c_int
snd_timer_open_lconf.argtypes = [POINTER(POINTER(snd_timer_t)), c_char_p, c_int, POINTER(snd_config_t)]

# /usr/include/alsa/timer.h:150
snd_timer_close = _lib.snd_timer_close
snd_timer_close.restype = c_int
snd_timer_close.argtypes = [POINTER(snd_timer_t)]

# /usr/include/alsa/timer.h:151
snd_async_add_timer_handler = _lib.snd_async_add_timer_handler
snd_async_add_timer_handler.restype = c_int
snd_async_add_timer_handler.argtypes = [POINTER(POINTER(snd_async_handler_t)), POINTER(snd_timer_t), snd_async_callback_t, POINTER(None)]

# /usr/include/alsa/timer.h:153
snd_async_handler_get_timer = _lib.snd_async_handler_get_timer
snd_async_handler_get_timer.restype = POINTER(snd_timer_t)
snd_async_handler_get_timer.argtypes = [POINTER(snd_async_handler_t)]

# /usr/include/alsa/timer.h:154
snd_timer_poll_descriptors_count = _lib.snd_timer_poll_descriptors_count
snd_timer_poll_descriptors_count.restype = c_int
snd_timer_poll_descriptors_count.argtypes = [POINTER(snd_timer_t)]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/timer.h:155
snd_timer_poll_descriptors = _lib.snd_timer_poll_descriptors
snd_timer_poll_descriptors.restype = c_int
snd_timer_poll_descriptors.argtypes = [POINTER(snd_timer_t), POINTER(struct_pollfd), c_uint]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/timer.h:156
snd_timer_poll_descriptors_revents = _lib.snd_timer_poll_descriptors_revents
snd_timer_poll_descriptors_revents.restype = c_int
snd_timer_poll_descriptors_revents.argtypes = [POINTER(snd_timer_t), POINTER(struct_pollfd), c_uint, POINTER(c_ushort)]

# /usr/include/alsa/timer.h:157
snd_timer_info = _lib.snd_timer_info
snd_timer_info.restype = c_int
snd_timer_info.argtypes = [POINTER(snd_timer_t), POINTER(snd_timer_info_t)]

# /usr/include/alsa/timer.h:158
snd_timer_params = _lib.snd_timer_params
snd_timer_params.restype = c_int
snd_timer_params.argtypes = [POINTER(snd_timer_t), POINTER(snd_timer_params_t)]

# /usr/include/alsa/timer.h:159
snd_timer_status = _lib.snd_timer_status
snd_timer_status.restype = c_int
snd_timer_status.argtypes = [POINTER(snd_timer_t), POINTER(snd_timer_status_t)]

# /usr/include/alsa/timer.h:160
snd_timer_start = _lib.snd_timer_start
snd_timer_start.restype = c_int
snd_timer_start.argtypes = [POINTER(snd_timer_t)]

# /usr/include/alsa/timer.h:161
snd_timer_stop = _lib.snd_timer_stop
snd_timer_stop.restype = c_int
snd_timer_stop.argtypes = [POINTER(snd_timer_t)]

# /usr/include/alsa/timer.h:162
snd_timer_continue = _lib.snd_timer_continue
snd_timer_continue.restype = c_int
snd_timer_continue.argtypes = [POINTER(snd_timer_t)]

# /usr/include/alsa/timer.h:163
snd_timer_read = _lib.snd_timer_read
snd_timer_read.restype = ssize_t
snd_timer_read.argtypes = [POINTER(snd_timer_t), POINTER(None), c_size_t]

# /usr/include/alsa/timer.h:165
snd_timer_id_sizeof = _lib.snd_timer_id_sizeof
snd_timer_id_sizeof.restype = c_size_t
snd_timer_id_sizeof.argtypes = []

# /usr/include/alsa/timer.h:168
snd_timer_id_malloc = _lib.snd_timer_id_malloc
snd_timer_id_malloc.restype = c_int
snd_timer_id_malloc.argtypes = [POINTER(POINTER(snd_timer_id_t))]

# /usr/include/alsa/timer.h:169
snd_timer_id_free = _lib.snd_timer_id_free
snd_timer_id_free.restype = None
snd_timer_id_free.argtypes = [POINTER(snd_timer_id_t)]

# /usr/include/alsa/timer.h:170
snd_timer_id_copy = _lib.snd_timer_id_copy
snd_timer_id_copy.restype = None
snd_timer_id_copy.argtypes = [POINTER(snd_timer_id_t), POINTER(snd_timer_id_t)]

# /usr/include/alsa/timer.h:172
snd_timer_id_set_class = _lib.snd_timer_id_set_class
snd_timer_id_set_class.restype = None
snd_timer_id_set_class.argtypes = [POINTER(snd_timer_id_t), c_int]

# /usr/include/alsa/timer.h:173
snd_timer_id_get_class = _lib.snd_timer_id_get_class
snd_timer_id_get_class.restype = c_int
snd_timer_id_get_class.argtypes = [POINTER(snd_timer_id_t)]

# /usr/include/alsa/timer.h:174
snd_timer_id_set_sclass = _lib.snd_timer_id_set_sclass
snd_timer_id_set_sclass.restype = None
snd_timer_id_set_sclass.argtypes = [POINTER(snd_timer_id_t), c_int]

# /usr/include/alsa/timer.h:175
snd_timer_id_get_sclass = _lib.snd_timer_id_get_sclass
snd_timer_id_get_sclass.restype = c_int
snd_timer_id_get_sclass.argtypes = [POINTER(snd_timer_id_t)]

# /usr/include/alsa/timer.h:176
snd_timer_id_set_card = _lib.snd_timer_id_set_card
snd_timer_id_set_card.restype = None
snd_timer_id_set_card.argtypes = [POINTER(snd_timer_id_t), c_int]

# /usr/include/alsa/timer.h:177
snd_timer_id_get_card = _lib.snd_timer_id_get_card
snd_timer_id_get_card.restype = c_int
snd_timer_id_get_card.argtypes = [POINTER(snd_timer_id_t)]

# /usr/include/alsa/timer.h:178
snd_timer_id_set_device = _lib.snd_timer_id_set_device
snd_timer_id_set_device.restype = None
snd_timer_id_set_device.argtypes = [POINTER(snd_timer_id_t), c_int]

# /usr/include/alsa/timer.h:179
snd_timer_id_get_device = _lib.snd_timer_id_get_device
snd_timer_id_get_device.restype = c_int
snd_timer_id_get_device.argtypes = [POINTER(snd_timer_id_t)]

# /usr/include/alsa/timer.h:180
snd_timer_id_set_subdevice = _lib.snd_timer_id_set_subdevice
snd_timer_id_set_subdevice.restype = None
snd_timer_id_set_subdevice.argtypes = [POINTER(snd_timer_id_t), c_int]

# /usr/include/alsa/timer.h:181
snd_timer_id_get_subdevice = _lib.snd_timer_id_get_subdevice
snd_timer_id_get_subdevice.restype = c_int
snd_timer_id_get_subdevice.argtypes = [POINTER(snd_timer_id_t)]

# /usr/include/alsa/timer.h:183
snd_timer_ginfo_sizeof = _lib.snd_timer_ginfo_sizeof
snd_timer_ginfo_sizeof.restype = c_size_t
snd_timer_ginfo_sizeof.argtypes = []

# /usr/include/alsa/timer.h:186
snd_timer_ginfo_malloc = _lib.snd_timer_ginfo_malloc
snd_timer_ginfo_malloc.restype = c_int
snd_timer_ginfo_malloc.argtypes = [POINTER(POINTER(snd_timer_ginfo_t))]

# /usr/include/alsa/timer.h:187
snd_timer_ginfo_free = _lib.snd_timer_ginfo_free
snd_timer_ginfo_free.restype = None
snd_timer_ginfo_free.argtypes = [POINTER(snd_timer_ginfo_t)]

# /usr/include/alsa/timer.h:188
snd_timer_ginfo_copy = _lib.snd_timer_ginfo_copy
snd_timer_ginfo_copy.restype = None
snd_timer_ginfo_copy.argtypes = [POINTER(snd_timer_ginfo_t), POINTER(snd_timer_ginfo_t)]

# /usr/include/alsa/timer.h:190
snd_timer_ginfo_set_tid = _lib.snd_timer_ginfo_set_tid
snd_timer_ginfo_set_tid.restype = c_int
snd_timer_ginfo_set_tid.argtypes = [POINTER(snd_timer_ginfo_t), POINTER(snd_timer_id_t)]

# /usr/include/alsa/timer.h:191
snd_timer_ginfo_get_tid = _lib.snd_timer_ginfo_get_tid
snd_timer_ginfo_get_tid.restype = POINTER(snd_timer_id_t)
snd_timer_ginfo_get_tid.argtypes = [POINTER(snd_timer_ginfo_t)]

# /usr/include/alsa/timer.h:192
snd_timer_ginfo_get_flags = _lib.snd_timer_ginfo_get_flags
snd_timer_ginfo_get_flags.restype = c_uint
snd_timer_ginfo_get_flags.argtypes = [POINTER(snd_timer_ginfo_t)]

# /usr/include/alsa/timer.h:193
snd_timer_ginfo_get_card = _lib.snd_timer_ginfo_get_card
snd_timer_ginfo_get_card.restype = c_int
snd_timer_ginfo_get_card.argtypes = [POINTER(snd_timer_ginfo_t)]

# /usr/include/alsa/timer.h:194
snd_timer_ginfo_get_id = _lib.snd_timer_ginfo_get_id
snd_timer_ginfo_get_id.restype = c_char_p
snd_timer_ginfo_get_id.argtypes = [POINTER(snd_timer_ginfo_t)]

# /usr/include/alsa/timer.h:195
snd_timer_ginfo_get_name = _lib.snd_timer_ginfo_get_name
snd_timer_ginfo_get_name.restype = c_char_p
snd_timer_ginfo_get_name.argtypes = [POINTER(snd_timer_ginfo_t)]

# /usr/include/alsa/timer.h:196
snd_timer_ginfo_get_resolution = _lib.snd_timer_ginfo_get_resolution
snd_timer_ginfo_get_resolution.restype = c_ulong
snd_timer_ginfo_get_resolution.argtypes = [POINTER(snd_timer_ginfo_t)]

# /usr/include/alsa/timer.h:197
snd_timer_ginfo_get_resolution_min = _lib.snd_timer_ginfo_get_resolution_min
snd_timer_ginfo_get_resolution_min.restype = c_ulong
snd_timer_ginfo_get_resolution_min.argtypes = [POINTER(snd_timer_ginfo_t)]

# /usr/include/alsa/timer.h:198
snd_timer_ginfo_get_resolution_max = _lib.snd_timer_ginfo_get_resolution_max
snd_timer_ginfo_get_resolution_max.restype = c_ulong
snd_timer_ginfo_get_resolution_max.argtypes = [POINTER(snd_timer_ginfo_t)]

# /usr/include/alsa/timer.h:199
snd_timer_ginfo_get_clients = _lib.snd_timer_ginfo_get_clients
snd_timer_ginfo_get_clients.restype = c_uint
snd_timer_ginfo_get_clients.argtypes = [POINTER(snd_timer_ginfo_t)]

# /usr/include/alsa/timer.h:201
snd_timer_info_sizeof = _lib.snd_timer_info_sizeof
snd_timer_info_sizeof.restype = c_size_t
snd_timer_info_sizeof.argtypes = []

# /usr/include/alsa/timer.h:204
snd_timer_info_malloc = _lib.snd_timer_info_malloc
snd_timer_info_malloc.restype = c_int
snd_timer_info_malloc.argtypes = [POINTER(POINTER(snd_timer_info_t))]

# /usr/include/alsa/timer.h:205
snd_timer_info_free = _lib.snd_timer_info_free
snd_timer_info_free.restype = None
snd_timer_info_free.argtypes = [POINTER(snd_timer_info_t)]

# /usr/include/alsa/timer.h:206
snd_timer_info_copy = _lib.snd_timer_info_copy
snd_timer_info_copy.restype = None
snd_timer_info_copy.argtypes = [POINTER(snd_timer_info_t), POINTER(snd_timer_info_t)]

# /usr/include/alsa/timer.h:208
snd_timer_info_is_slave = _lib.snd_timer_info_is_slave
snd_timer_info_is_slave.restype = c_int
snd_timer_info_is_slave.argtypes = [POINTER(snd_timer_info_t)]

# /usr/include/alsa/timer.h:209
snd_timer_info_get_card = _lib.snd_timer_info_get_card
snd_timer_info_get_card.restype = c_int
snd_timer_info_get_card.argtypes = [POINTER(snd_timer_info_t)]

# /usr/include/alsa/timer.h:210
snd_timer_info_get_id = _lib.snd_timer_info_get_id
snd_timer_info_get_id.restype = c_char_p
snd_timer_info_get_id.argtypes = [POINTER(snd_timer_info_t)]

# /usr/include/alsa/timer.h:211
snd_timer_info_get_name = _lib.snd_timer_info_get_name
snd_timer_info_get_name.restype = c_char_p
snd_timer_info_get_name.argtypes = [POINTER(snd_timer_info_t)]

# /usr/include/alsa/timer.h:212
snd_timer_info_get_resolution = _lib.snd_timer_info_get_resolution
snd_timer_info_get_resolution.restype = c_long
snd_timer_info_get_resolution.argtypes = [POINTER(snd_timer_info_t)]

# /usr/include/alsa/timer.h:214
snd_timer_params_sizeof = _lib.snd_timer_params_sizeof
snd_timer_params_sizeof.restype = c_size_t
snd_timer_params_sizeof.argtypes = []

# /usr/include/alsa/timer.h:217
snd_timer_params_malloc = _lib.snd_timer_params_malloc
snd_timer_params_malloc.restype = c_int
snd_timer_params_malloc.argtypes = [POINTER(POINTER(snd_timer_params_t))]

# /usr/include/alsa/timer.h:218
snd_timer_params_free = _lib.snd_timer_params_free
snd_timer_params_free.restype = None
snd_timer_params_free.argtypes = [POINTER(snd_timer_params_t)]

# /usr/include/alsa/timer.h:219
snd_timer_params_copy = _lib.snd_timer_params_copy
snd_timer_params_copy.restype = None
snd_timer_params_copy.argtypes = [POINTER(snd_timer_params_t), POINTER(snd_timer_params_t)]

# /usr/include/alsa/timer.h:221
snd_timer_params_set_auto_start = _lib.snd_timer_params_set_auto_start
snd_timer_params_set_auto_start.restype = c_int
snd_timer_params_set_auto_start.argtypes = [POINTER(snd_timer_params_t), c_int]

# /usr/include/alsa/timer.h:222
snd_timer_params_get_auto_start = _lib.snd_timer_params_get_auto_start
snd_timer_params_get_auto_start.restype = c_int
snd_timer_params_get_auto_start.argtypes = [POINTER(snd_timer_params_t)]

# /usr/include/alsa/timer.h:223
snd_timer_params_set_exclusive = _lib.snd_timer_params_set_exclusive
snd_timer_params_set_exclusive.restype = c_int
snd_timer_params_set_exclusive.argtypes = [POINTER(snd_timer_params_t), c_int]

# /usr/include/alsa/timer.h:224
snd_timer_params_get_exclusive = _lib.snd_timer_params_get_exclusive
snd_timer_params_get_exclusive.restype = c_int
snd_timer_params_get_exclusive.argtypes = [POINTER(snd_timer_params_t)]

# /usr/include/alsa/timer.h:225
snd_timer_params_set_early_event = _lib.snd_timer_params_set_early_event
snd_timer_params_set_early_event.restype = c_int
snd_timer_params_set_early_event.argtypes = [POINTER(snd_timer_params_t), c_int]

# /usr/include/alsa/timer.h:226
snd_timer_params_get_early_event = _lib.snd_timer_params_get_early_event
snd_timer_params_get_early_event.restype = c_int
snd_timer_params_get_early_event.argtypes = [POINTER(snd_timer_params_t)]

# /usr/include/alsa/timer.h:227
snd_timer_params_set_ticks = _lib.snd_timer_params_set_ticks
snd_timer_params_set_ticks.restype = None
snd_timer_params_set_ticks.argtypes = [POINTER(snd_timer_params_t), c_long]

# /usr/include/alsa/timer.h:228
snd_timer_params_get_ticks = _lib.snd_timer_params_get_ticks
snd_timer_params_get_ticks.restype = c_long
snd_timer_params_get_ticks.argtypes = [POINTER(snd_timer_params_t)]

# /usr/include/alsa/timer.h:229
snd_timer_params_set_queue_size = _lib.snd_timer_params_set_queue_size
snd_timer_params_set_queue_size.restype = None
snd_timer_params_set_queue_size.argtypes = [POINTER(snd_timer_params_t), c_long]

# /usr/include/alsa/timer.h:230
snd_timer_params_get_queue_size = _lib.snd_timer_params_get_queue_size
snd_timer_params_get_queue_size.restype = c_long
snd_timer_params_get_queue_size.argtypes = [POINTER(snd_timer_params_t)]

# /usr/include/alsa/timer.h:231
snd_timer_params_set_filter = _lib.snd_timer_params_set_filter
snd_timer_params_set_filter.restype = None
snd_timer_params_set_filter.argtypes = [POINTER(snd_timer_params_t), c_uint]

# /usr/include/alsa/timer.h:232
snd_timer_params_get_filter = _lib.snd_timer_params_get_filter
snd_timer_params_get_filter.restype = c_uint
snd_timer_params_get_filter.argtypes = [POINTER(snd_timer_params_t)]

# /usr/include/alsa/timer.h:234
snd_timer_status_sizeof = _lib.snd_timer_status_sizeof
snd_timer_status_sizeof.restype = c_size_t
snd_timer_status_sizeof.argtypes = []

# /usr/include/alsa/timer.h:237
snd_timer_status_malloc = _lib.snd_timer_status_malloc
snd_timer_status_malloc.restype = c_int
snd_timer_status_malloc.argtypes = [POINTER(POINTER(snd_timer_status_t))]

# /usr/include/alsa/timer.h:238
snd_timer_status_free = _lib.snd_timer_status_free
snd_timer_status_free.restype = None
snd_timer_status_free.argtypes = [POINTER(snd_timer_status_t)]

# /usr/include/alsa/timer.h:239
snd_timer_status_copy = _lib.snd_timer_status_copy
snd_timer_status_copy.restype = None
snd_timer_status_copy.argtypes = [POINTER(snd_timer_status_t), POINTER(snd_timer_status_t)]

# /usr/include/alsa/timer.h:241
snd_timer_status_get_timestamp = _lib.snd_timer_status_get_timestamp
snd_timer_status_get_timestamp.restype = snd_htimestamp_t
snd_timer_status_get_timestamp.argtypes = [POINTER(snd_timer_status_t)]

# /usr/include/alsa/timer.h:242
snd_timer_status_get_resolution = _lib.snd_timer_status_get_resolution
snd_timer_status_get_resolution.restype = c_long
snd_timer_status_get_resolution.argtypes = [POINTER(snd_timer_status_t)]

# /usr/include/alsa/timer.h:243
snd_timer_status_get_lost = _lib.snd_timer_status_get_lost
snd_timer_status_get_lost.restype = c_long
snd_timer_status_get_lost.argtypes = [POINTER(snd_timer_status_t)]

# /usr/include/alsa/timer.h:244
snd_timer_status_get_overrun = _lib.snd_timer_status_get_overrun
snd_timer_status_get_overrun.restype = c_long
snd_timer_status_get_overrun.argtypes = [POINTER(snd_timer_status_t)]

# /usr/include/alsa/timer.h:245
snd_timer_status_get_queue = _lib.snd_timer_status_get_queue
snd_timer_status_get_queue.restype = c_long
snd_timer_status_get_queue.argtypes = [POINTER(snd_timer_status_t)]

# /usr/include/alsa/timer.h:248
snd_timer_info_get_ticks = _lib.snd_timer_info_get_ticks
snd_timer_info_get_ticks.restype = c_long
snd_timer_info_get_ticks.argtypes = [POINTER(snd_timer_info_t)]

SND_HWDEP_DLSYM_VERSION = 0 	# /usr/include/alsa/hwdep.h:42
class struct__snd_hwdep_info(Structure):
    __slots__ = [
    ]
struct__snd_hwdep_info._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_hwdep_info(Structure):
    __slots__ = [
    ]
struct__snd_hwdep_info._fields_ = [
    ('_opaque_struct', c_int)
]

snd_hwdep_info_t = struct__snd_hwdep_info 	# /usr/include/alsa/hwdep.h:45
class struct__snd_hwdep_dsp_status(Structure):
    __slots__ = [
    ]
struct__snd_hwdep_dsp_status._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_hwdep_dsp_status(Structure):
    __slots__ = [
    ]
struct__snd_hwdep_dsp_status._fields_ = [
    ('_opaque_struct', c_int)
]

snd_hwdep_dsp_status_t = struct__snd_hwdep_dsp_status 	# /usr/include/alsa/hwdep.h:48
class struct__snd_hwdep_dsp_image(Structure):
    __slots__ = [
    ]
struct__snd_hwdep_dsp_image._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_hwdep_dsp_image(Structure):
    __slots__ = [
    ]
struct__snd_hwdep_dsp_image._fields_ = [
    ('_opaque_struct', c_int)
]

snd_hwdep_dsp_image_t = struct__snd_hwdep_dsp_image 	# /usr/include/alsa/hwdep.h:51
enum__snd_hwdep_iface = c_int
SND_HWDEP_IFACE_OPL2 = 0
SND_HWDEP_IFACE_OPL3 = 1
SND_HWDEP_IFACE_OPL4 = 2
SND_HWDEP_IFACE_SB16CSP = 3
SND_HWDEP_IFACE_EMU10K1 = 4
SND_HWDEP_IFACE_YSS225 = 5
SND_HWDEP_IFACE_ICS2115 = 6
SND_HWDEP_IFACE_SSCAPE = 7
SND_HWDEP_IFACE_VX = 8
SND_HWDEP_IFACE_MIXART = 9
SND_HWDEP_IFACE_USX2Y = 10
SND_HWDEP_IFACE_EMUX_WAVETABLE = 11
SND_HWDEP_IFACE_BLUETOOTH = 12
SND_HWDEP_IFACE_USX2Y_PCM = 13
SND_HWDEP_IFACE_PCXHR = 14
SND_HWDEP_IFACE_SB_RC = 15
SND_HWDEP_IFACE_LAST = 0
snd_hwdep_iface_t = enum__snd_hwdep_iface 	# /usr/include/alsa/hwdep.h:73
SND_HWDEP_OPEN_READ = 0 	# /usr/include/alsa/hwdep.h:76
SND_HWDEP_OPEN_WRITE = 1 	# /usr/include/alsa/hwdep.h:78
SND_HWDEP_OPEN_DUPLEX = 2 	# /usr/include/alsa/hwdep.h:80
SND_HWDEP_OPEN_NONBLOCK = 2048 	# /usr/include/alsa/hwdep.h:82
enum__snd_hwdep_type = c_int
SND_HWDEP_TYPE_HW = 1
SND_HWDEP_TYPE_SHM = 2
SND_HWDEP_TYPE_INET = 3
snd_hwdep_type_t = enum__snd_hwdep_type 	# /usr/include/alsa/hwdep.h:92
class struct__snd_hwdep(Structure):
    __slots__ = [
    ]
struct__snd_hwdep._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_hwdep(Structure):
    __slots__ = [
    ]
struct__snd_hwdep._fields_ = [
    ('_opaque_struct', c_int)
]

snd_hwdep_t = struct__snd_hwdep 	# /usr/include/alsa/hwdep.h:95
# /usr/include/alsa/hwdep.h:97
snd_hwdep_open = _lib.snd_hwdep_open
snd_hwdep_open.restype = c_int
snd_hwdep_open.argtypes = [POINTER(POINTER(snd_hwdep_t)), c_char_p, c_int]

# /usr/include/alsa/hwdep.h:98
snd_hwdep_close = _lib.snd_hwdep_close
snd_hwdep_close.restype = c_int
snd_hwdep_close.argtypes = [POINTER(snd_hwdep_t)]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/hwdep.h:99
snd_hwdep_poll_descriptors = _lib.snd_hwdep_poll_descriptors
snd_hwdep_poll_descriptors.restype = c_int
snd_hwdep_poll_descriptors.argtypes = [POINTER(snd_hwdep_t), POINTER(struct_pollfd), c_uint]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/hwdep.h:100
snd_hwdep_poll_descriptors_revents = _lib.snd_hwdep_poll_descriptors_revents
snd_hwdep_poll_descriptors_revents.restype = c_int
snd_hwdep_poll_descriptors_revents.argtypes = [POINTER(snd_hwdep_t), POINTER(struct_pollfd), c_uint, POINTER(c_ushort)]

# /usr/include/alsa/hwdep.h:101
snd_hwdep_nonblock = _lib.snd_hwdep_nonblock
snd_hwdep_nonblock.restype = c_int
snd_hwdep_nonblock.argtypes = [POINTER(snd_hwdep_t), c_int]

# /usr/include/alsa/hwdep.h:102
snd_hwdep_info = _lib.snd_hwdep_info
snd_hwdep_info.restype = c_int
snd_hwdep_info.argtypes = [POINTER(snd_hwdep_t), POINTER(snd_hwdep_info_t)]

# /usr/include/alsa/hwdep.h:103
snd_hwdep_dsp_status = _lib.snd_hwdep_dsp_status
snd_hwdep_dsp_status.restype = c_int
snd_hwdep_dsp_status.argtypes = [POINTER(snd_hwdep_t), POINTER(snd_hwdep_dsp_status_t)]

# /usr/include/alsa/hwdep.h:104
snd_hwdep_dsp_load = _lib.snd_hwdep_dsp_load
snd_hwdep_dsp_load.restype = c_int
snd_hwdep_dsp_load.argtypes = [POINTER(snd_hwdep_t), POINTER(snd_hwdep_dsp_image_t)]

# /usr/include/alsa/hwdep.h:105
snd_hwdep_ioctl = _lib.snd_hwdep_ioctl
snd_hwdep_ioctl.restype = c_int
snd_hwdep_ioctl.argtypes = [POINTER(snd_hwdep_t), c_uint, POINTER(None)]

# /usr/include/alsa/hwdep.h:106
snd_hwdep_write = _lib.snd_hwdep_write
snd_hwdep_write.restype = ssize_t
snd_hwdep_write.argtypes = [POINTER(snd_hwdep_t), POINTER(None), c_size_t]

# /usr/include/alsa/hwdep.h:107
snd_hwdep_read = _lib.snd_hwdep_read
snd_hwdep_read.restype = ssize_t
snd_hwdep_read.argtypes = [POINTER(snd_hwdep_t), POINTER(None), c_size_t]

# /usr/include/alsa/hwdep.h:109
snd_hwdep_info_sizeof = _lib.snd_hwdep_info_sizeof
snd_hwdep_info_sizeof.restype = c_size_t
snd_hwdep_info_sizeof.argtypes = []

# /usr/include/alsa/hwdep.h:112
snd_hwdep_info_malloc = _lib.snd_hwdep_info_malloc
snd_hwdep_info_malloc.restype = c_int
snd_hwdep_info_malloc.argtypes = [POINTER(POINTER(snd_hwdep_info_t))]

# /usr/include/alsa/hwdep.h:113
snd_hwdep_info_free = _lib.snd_hwdep_info_free
snd_hwdep_info_free.restype = None
snd_hwdep_info_free.argtypes = [POINTER(snd_hwdep_info_t)]

# /usr/include/alsa/hwdep.h:114
snd_hwdep_info_copy = _lib.snd_hwdep_info_copy
snd_hwdep_info_copy.restype = None
snd_hwdep_info_copy.argtypes = [POINTER(snd_hwdep_info_t), POINTER(snd_hwdep_info_t)]

# /usr/include/alsa/hwdep.h:116
snd_hwdep_info_get_device = _lib.snd_hwdep_info_get_device
snd_hwdep_info_get_device.restype = c_uint
snd_hwdep_info_get_device.argtypes = [POINTER(snd_hwdep_info_t)]

# /usr/include/alsa/hwdep.h:117
snd_hwdep_info_get_card = _lib.snd_hwdep_info_get_card
snd_hwdep_info_get_card.restype = c_int
snd_hwdep_info_get_card.argtypes = [POINTER(snd_hwdep_info_t)]

# /usr/include/alsa/hwdep.h:118
snd_hwdep_info_get_id = _lib.snd_hwdep_info_get_id
snd_hwdep_info_get_id.restype = c_char_p
snd_hwdep_info_get_id.argtypes = [POINTER(snd_hwdep_info_t)]

# /usr/include/alsa/hwdep.h:119
snd_hwdep_info_get_name = _lib.snd_hwdep_info_get_name
snd_hwdep_info_get_name.restype = c_char_p
snd_hwdep_info_get_name.argtypes = [POINTER(snd_hwdep_info_t)]

# /usr/include/alsa/hwdep.h:120
snd_hwdep_info_get_iface = _lib.snd_hwdep_info_get_iface
snd_hwdep_info_get_iface.restype = snd_hwdep_iface_t
snd_hwdep_info_get_iface.argtypes = [POINTER(snd_hwdep_info_t)]

# /usr/include/alsa/hwdep.h:121
snd_hwdep_info_set_device = _lib.snd_hwdep_info_set_device
snd_hwdep_info_set_device.restype = None
snd_hwdep_info_set_device.argtypes = [POINTER(snd_hwdep_info_t), c_uint]

# /usr/include/alsa/hwdep.h:123
snd_hwdep_dsp_status_sizeof = _lib.snd_hwdep_dsp_status_sizeof
snd_hwdep_dsp_status_sizeof.restype = c_size_t
snd_hwdep_dsp_status_sizeof.argtypes = []

# /usr/include/alsa/hwdep.h:126
snd_hwdep_dsp_status_malloc = _lib.snd_hwdep_dsp_status_malloc
snd_hwdep_dsp_status_malloc.restype = c_int
snd_hwdep_dsp_status_malloc.argtypes = [POINTER(POINTER(snd_hwdep_dsp_status_t))]

# /usr/include/alsa/hwdep.h:127
snd_hwdep_dsp_status_free = _lib.snd_hwdep_dsp_status_free
snd_hwdep_dsp_status_free.restype = None
snd_hwdep_dsp_status_free.argtypes = [POINTER(snd_hwdep_dsp_status_t)]

# /usr/include/alsa/hwdep.h:128
snd_hwdep_dsp_status_copy = _lib.snd_hwdep_dsp_status_copy
snd_hwdep_dsp_status_copy.restype = None
snd_hwdep_dsp_status_copy.argtypes = [POINTER(snd_hwdep_dsp_status_t), POINTER(snd_hwdep_dsp_status_t)]

# /usr/include/alsa/hwdep.h:130
snd_hwdep_dsp_status_get_version = _lib.snd_hwdep_dsp_status_get_version
snd_hwdep_dsp_status_get_version.restype = c_uint
snd_hwdep_dsp_status_get_version.argtypes = [POINTER(snd_hwdep_dsp_status_t)]

# /usr/include/alsa/hwdep.h:131
snd_hwdep_dsp_status_get_id = _lib.snd_hwdep_dsp_status_get_id
snd_hwdep_dsp_status_get_id.restype = c_char_p
snd_hwdep_dsp_status_get_id.argtypes = [POINTER(snd_hwdep_dsp_status_t)]

# /usr/include/alsa/hwdep.h:132
snd_hwdep_dsp_status_get_num_dsps = _lib.snd_hwdep_dsp_status_get_num_dsps
snd_hwdep_dsp_status_get_num_dsps.restype = c_uint
snd_hwdep_dsp_status_get_num_dsps.argtypes = [POINTER(snd_hwdep_dsp_status_t)]

# /usr/include/alsa/hwdep.h:133
snd_hwdep_dsp_status_get_dsp_loaded = _lib.snd_hwdep_dsp_status_get_dsp_loaded
snd_hwdep_dsp_status_get_dsp_loaded.restype = c_uint
snd_hwdep_dsp_status_get_dsp_loaded.argtypes = [POINTER(snd_hwdep_dsp_status_t)]

# /usr/include/alsa/hwdep.h:134
snd_hwdep_dsp_status_get_chip_ready = _lib.snd_hwdep_dsp_status_get_chip_ready
snd_hwdep_dsp_status_get_chip_ready.restype = c_uint
snd_hwdep_dsp_status_get_chip_ready.argtypes = [POINTER(snd_hwdep_dsp_status_t)]

# /usr/include/alsa/hwdep.h:136
snd_hwdep_dsp_image_sizeof = _lib.snd_hwdep_dsp_image_sizeof
snd_hwdep_dsp_image_sizeof.restype = c_size_t
snd_hwdep_dsp_image_sizeof.argtypes = []

# /usr/include/alsa/hwdep.h:139
snd_hwdep_dsp_image_malloc = _lib.snd_hwdep_dsp_image_malloc
snd_hwdep_dsp_image_malloc.restype = c_int
snd_hwdep_dsp_image_malloc.argtypes = [POINTER(POINTER(snd_hwdep_dsp_image_t))]

# /usr/include/alsa/hwdep.h:140
snd_hwdep_dsp_image_free = _lib.snd_hwdep_dsp_image_free
snd_hwdep_dsp_image_free.restype = None
snd_hwdep_dsp_image_free.argtypes = [POINTER(snd_hwdep_dsp_image_t)]

# /usr/include/alsa/hwdep.h:141
snd_hwdep_dsp_image_copy = _lib.snd_hwdep_dsp_image_copy
snd_hwdep_dsp_image_copy.restype = None
snd_hwdep_dsp_image_copy.argtypes = [POINTER(snd_hwdep_dsp_image_t), POINTER(snd_hwdep_dsp_image_t)]

# /usr/include/alsa/hwdep.h:143
snd_hwdep_dsp_image_get_index = _lib.snd_hwdep_dsp_image_get_index
snd_hwdep_dsp_image_get_index.restype = c_uint
snd_hwdep_dsp_image_get_index.argtypes = [POINTER(snd_hwdep_dsp_image_t)]

# /usr/include/alsa/hwdep.h:144
snd_hwdep_dsp_image_get_name = _lib.snd_hwdep_dsp_image_get_name
snd_hwdep_dsp_image_get_name.restype = c_char_p
snd_hwdep_dsp_image_get_name.argtypes = [POINTER(snd_hwdep_dsp_image_t)]

# /usr/include/alsa/hwdep.h:145
snd_hwdep_dsp_image_get_image = _lib.snd_hwdep_dsp_image_get_image
snd_hwdep_dsp_image_get_image.restype = POINTER(c_void)
snd_hwdep_dsp_image_get_image.argtypes = [POINTER(snd_hwdep_dsp_image_t)]

# /usr/include/alsa/hwdep.h:146
snd_hwdep_dsp_image_get_length = _lib.snd_hwdep_dsp_image_get_length
snd_hwdep_dsp_image_get_length.restype = c_size_t
snd_hwdep_dsp_image_get_length.argtypes = [POINTER(snd_hwdep_dsp_image_t)]

# /usr/include/alsa/hwdep.h:148
snd_hwdep_dsp_image_set_index = _lib.snd_hwdep_dsp_image_set_index
snd_hwdep_dsp_image_set_index.restype = None
snd_hwdep_dsp_image_set_index.argtypes = [POINTER(snd_hwdep_dsp_image_t), c_uint]

# /usr/include/alsa/hwdep.h:149
snd_hwdep_dsp_image_set_name = _lib.snd_hwdep_dsp_image_set_name
snd_hwdep_dsp_image_set_name.restype = None
snd_hwdep_dsp_image_set_name.argtypes = [POINTER(snd_hwdep_dsp_image_t), c_char_p]

# /usr/include/alsa/hwdep.h:150
snd_hwdep_dsp_image_set_image = _lib.snd_hwdep_dsp_image_set_image
snd_hwdep_dsp_image_set_image.restype = None
snd_hwdep_dsp_image_set_image.argtypes = [POINTER(snd_hwdep_dsp_image_t), POINTER(None)]

# /usr/include/alsa/hwdep.h:151
snd_hwdep_dsp_image_set_length = _lib.snd_hwdep_dsp_image_set_length
snd_hwdep_dsp_image_set_length.restype = None
snd_hwdep_dsp_image_set_length.argtypes = [POINTER(snd_hwdep_dsp_image_t), c_size_t]

SND_CONTROL_DLSYM_VERSION = 0 	# /usr/include/alsa/control.h:43
class struct_snd_aes_iec958(Structure):
    __slots__ = [
        'status',
        'subcode',
        'pad',
        'dig_subframe',
    ]
struct_snd_aes_iec958._fields_ = [
    ('status', c_ubyte * 24),
    ('subcode', c_ubyte * 147),
    ('pad', c_ubyte),
    ('dig_subframe', c_ubyte * 4),
]

snd_aes_iec958_t = struct_snd_aes_iec958 	# /usr/include/alsa/control.h:51
class struct__snd_ctl_card_info(Structure):
    __slots__ = [
    ]
struct__snd_ctl_card_info._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_ctl_card_info(Structure):
    __slots__ = [
    ]
struct__snd_ctl_card_info._fields_ = [
    ('_opaque_struct', c_int)
]

snd_ctl_card_info_t = struct__snd_ctl_card_info 	# /usr/include/alsa/control.h:54
class struct__snd_ctl_elem_id(Structure):
    __slots__ = [
    ]
struct__snd_ctl_elem_id._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_ctl_elem_id(Structure):
    __slots__ = [
    ]
struct__snd_ctl_elem_id._fields_ = [
    ('_opaque_struct', c_int)
]

snd_ctl_elem_id_t = struct__snd_ctl_elem_id 	# /usr/include/alsa/control.h:57
class struct__snd_ctl_elem_list(Structure):
    __slots__ = [
    ]
struct__snd_ctl_elem_list._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_ctl_elem_list(Structure):
    __slots__ = [
    ]
struct__snd_ctl_elem_list._fields_ = [
    ('_opaque_struct', c_int)
]

snd_ctl_elem_list_t = struct__snd_ctl_elem_list 	# /usr/include/alsa/control.h:60
class struct__snd_ctl_elem_info(Structure):
    __slots__ = [
    ]
struct__snd_ctl_elem_info._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_ctl_elem_info(Structure):
    __slots__ = [
    ]
struct__snd_ctl_elem_info._fields_ = [
    ('_opaque_struct', c_int)
]

snd_ctl_elem_info_t = struct__snd_ctl_elem_info 	# /usr/include/alsa/control.h:63
class struct__snd_ctl_elem_value(Structure):
    __slots__ = [
    ]
struct__snd_ctl_elem_value._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_ctl_elem_value(Structure):
    __slots__ = [
    ]
struct__snd_ctl_elem_value._fields_ = [
    ('_opaque_struct', c_int)
]

snd_ctl_elem_value_t = struct__snd_ctl_elem_value 	# /usr/include/alsa/control.h:66
class struct__snd_ctl_event(Structure):
    __slots__ = [
    ]
struct__snd_ctl_event._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_ctl_event(Structure):
    __slots__ = [
    ]
struct__snd_ctl_event._fields_ = [
    ('_opaque_struct', c_int)
]

snd_ctl_event_t = struct__snd_ctl_event 	# /usr/include/alsa/control.h:69
enum__snd_ctl_elem_type = c_int
SND_CTL_ELEM_TYPE_NONE = 0
SND_CTL_ELEM_TYPE_BOOLEAN = 1
SND_CTL_ELEM_TYPE_INTEGER = 2
SND_CTL_ELEM_TYPE_ENUMERATED = 3
SND_CTL_ELEM_TYPE_BYTES = 4
SND_CTL_ELEM_TYPE_IEC958 = 5
SND_CTL_ELEM_TYPE_INTEGER64 = 6
SND_CTL_ELEM_TYPE_LAST = 0
snd_ctl_elem_type_t = enum__snd_ctl_elem_type 	# /usr/include/alsa/control.h:88
enum__snd_ctl_elem_iface = c_int
SND_CTL_ELEM_IFACE_CARD = 0
SND_CTL_ELEM_IFACE_HWDEP = 1
SND_CTL_ELEM_IFACE_MIXER = 2
SND_CTL_ELEM_IFACE_PCM = 3
SND_CTL_ELEM_IFACE_RAWMIDI = 4
SND_CTL_ELEM_IFACE_TIMER = 5
SND_CTL_ELEM_IFACE_SEQUENCER = 6
SND_CTL_ELEM_IFACE_LAST = 0
snd_ctl_elem_iface_t = enum__snd_ctl_elem_iface 	# /usr/include/alsa/control.h:107
enum__snd_ctl_event_type = c_int
SND_CTL_EVENT_ELEM = 0
SND_CTL_EVENT_LAST = 0
snd_ctl_event_type_t = enum__snd_ctl_event_type 	# /usr/include/alsa/control.h:114
SND_CTL_EVENT_MASK_REMOVE = -1 	# /usr/include/alsa/control.h:118
SND_CTL_EVENT_MASK_VALUE = 1 	# /usr/include/alsa/control.h:120
SND_CTL_EVENT_MASK_INFO = 2 	# /usr/include/alsa/control.h:122
SND_CTL_EVENT_MASK_ADD = 4 	# /usr/include/alsa/control.h:124
SND_CTL_EVENT_MASK_TLV = 8 	# /usr/include/alsa/control.h:126
SND_CTL_POWER_MASK = 65280 	# /usr/include/alsa/control.h:155
SND_CTL_POWER_D0 = 0 	# /usr/include/alsa/control.h:157
SND_CTL_POWER_D1 = 256 	# /usr/include/alsa/control.h:159
SND_CTL_POWER_D2 = 512 	# /usr/include/alsa/control.h:161
SND_CTL_POWER_D3 = 768 	# /usr/include/alsa/control.h:163
SND_CTL_POWER_D3hot = 768 	# /usr/include/alsa/control.h:165
SND_CTL_POWER_D3cold = 769 	# /usr/include/alsa/control.h:167
SND_CTL_TLVT_CONTAINER = 0 	# /usr/include/alsa/control.h:170
SND_CTL_TLVT_DB_SCALE = 1 	# /usr/include/alsa/control.h:172
SND_CTL_TLVT_DB_LINEAR = 2 	# /usr/include/alsa/control.h:174
SND_CTL_TLVT_DB_RANGE = 3 	# /usr/include/alsa/control.h:176
SND_CTL_TLV_DB_GAIN_MUTE = -9999999 	# /usr/include/alsa/control.h:179
enum__snd_ctl_type = c_int
SND_CTL_TYPE_HW = 1
SND_CTL_TYPE_SHM = 2
SND_CTL_TYPE_INET = 3
SND_CTL_TYPE_EXT = 4
snd_ctl_type_t = enum__snd_ctl_type 	# /usr/include/alsa/control.h:191
SND_CTL_NONBLOCK = 1 	# /usr/include/alsa/control.h:194
SND_CTL_ASYNC = 2 	# /usr/include/alsa/control.h:197
SND_CTL_READONLY = 4 	# /usr/include/alsa/control.h:200
class struct__snd_ctl(Structure):
    __slots__ = [
    ]
struct__snd_ctl._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_ctl(Structure):
    __slots__ = [
    ]
struct__snd_ctl._fields_ = [
    ('_opaque_struct', c_int)
]

snd_ctl_t = struct__snd_ctl 	# /usr/include/alsa/control.h:203
SND_SCTL_NOFREE = 1 	# /usr/include/alsa/control.h:206
class struct__snd_sctl(Structure):
    __slots__ = [
    ]
struct__snd_sctl._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_sctl(Structure):
    __slots__ = [
    ]
struct__snd_sctl._fields_ = [
    ('_opaque_struct', c_int)
]

snd_sctl_t = struct__snd_sctl 	# /usr/include/alsa/control.h:209
# /usr/include/alsa/control.h:211
snd_card_load = _lib.snd_card_load
snd_card_load.restype = c_int
snd_card_load.argtypes = [c_int]

# /usr/include/alsa/control.h:212
snd_card_next = _lib.snd_card_next
snd_card_next.restype = c_int
snd_card_next.argtypes = [POINTER(c_int)]

# /usr/include/alsa/control.h:213
snd_card_get_index = _lib.snd_card_get_index
snd_card_get_index.restype = c_int
snd_card_get_index.argtypes = [c_char_p]

# /usr/include/alsa/control.h:214
snd_card_get_name = _lib.snd_card_get_name
snd_card_get_name.restype = c_int
snd_card_get_name.argtypes = [c_int, POINTER(c_char_p)]

# /usr/include/alsa/control.h:215
snd_card_get_longname = _lib.snd_card_get_longname
snd_card_get_longname.restype = c_int
snd_card_get_longname.argtypes = [c_int, POINTER(c_char_p)]

''' Issue 144: These were added in 1.0.14
# /usr/include/alsa/control.h:217
snd_device_name_hint = _lib.snd_device_name_hint
snd_device_name_hint.restype = c_int
snd_device_name_hint.argtypes = [c_int, c_char_p, POINTER(POINTER(POINTER(None)))]

# /usr/include/alsa/control.h:218
snd_device_name_free_hint = _lib.snd_device_name_free_hint
snd_device_name_free_hint.restype = c_int
snd_device_name_free_hint.argtypes = [POINTER(POINTER(None))]

# /usr/include/alsa/control.h:219
snd_device_name_get_hint = _lib.snd_device_name_get_hint
snd_device_name_get_hint.restype = c_char_p
snd_device_name_get_hint.argtypes = [POINTER(None), c_char_p]
'''

# /usr/include/alsa/control.h:221
snd_ctl_open = _lib.snd_ctl_open
snd_ctl_open.restype = c_int
snd_ctl_open.argtypes = [POINTER(POINTER(snd_ctl_t)), c_char_p, c_int]

# /usr/include/alsa/control.h:222
snd_ctl_open_lconf = _lib.snd_ctl_open_lconf
snd_ctl_open_lconf.restype = c_int
snd_ctl_open_lconf.argtypes = [POINTER(POINTER(snd_ctl_t)), c_char_p, c_int, POINTER(snd_config_t)]

# /usr/include/alsa/control.h:223
snd_ctl_close = _lib.snd_ctl_close
snd_ctl_close.restype = c_int
snd_ctl_close.argtypes = [POINTER(snd_ctl_t)]

# /usr/include/alsa/control.h:224
snd_ctl_nonblock = _lib.snd_ctl_nonblock
snd_ctl_nonblock.restype = c_int
snd_ctl_nonblock.argtypes = [POINTER(snd_ctl_t), c_int]

# /usr/include/alsa/control.h:225
snd_async_add_ctl_handler = _lib.snd_async_add_ctl_handler
snd_async_add_ctl_handler.restype = c_int
snd_async_add_ctl_handler.argtypes = [POINTER(POINTER(snd_async_handler_t)), POINTER(snd_ctl_t), snd_async_callback_t, POINTER(None)]

# /usr/include/alsa/control.h:227
snd_async_handler_get_ctl = _lib.snd_async_handler_get_ctl
snd_async_handler_get_ctl.restype = POINTER(snd_ctl_t)
snd_async_handler_get_ctl.argtypes = [POINTER(snd_async_handler_t)]

# /usr/include/alsa/control.h:228
snd_ctl_poll_descriptors_count = _lib.snd_ctl_poll_descriptors_count
snd_ctl_poll_descriptors_count.restype = c_int
snd_ctl_poll_descriptors_count.argtypes = [POINTER(snd_ctl_t)]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/control.h:229
snd_ctl_poll_descriptors = _lib.snd_ctl_poll_descriptors
snd_ctl_poll_descriptors.restype = c_int
snd_ctl_poll_descriptors.argtypes = [POINTER(snd_ctl_t), POINTER(struct_pollfd), c_uint]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/control.h:230
snd_ctl_poll_descriptors_revents = _lib.snd_ctl_poll_descriptors_revents
snd_ctl_poll_descriptors_revents.restype = c_int
snd_ctl_poll_descriptors_revents.argtypes = [POINTER(snd_ctl_t), POINTER(struct_pollfd), c_uint, POINTER(c_ushort)]

# /usr/include/alsa/control.h:231
snd_ctl_subscribe_events = _lib.snd_ctl_subscribe_events
snd_ctl_subscribe_events.restype = c_int
snd_ctl_subscribe_events.argtypes = [POINTER(snd_ctl_t), c_int]

# /usr/include/alsa/control.h:232
snd_ctl_card_info = _lib.snd_ctl_card_info
snd_ctl_card_info.restype = c_int
snd_ctl_card_info.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_card_info_t)]

# /usr/include/alsa/control.h:233
snd_ctl_elem_list = _lib.snd_ctl_elem_list
snd_ctl_elem_list.restype = c_int
snd_ctl_elem_list.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_elem_list_t)]

# /usr/include/alsa/control.h:234
snd_ctl_elem_info = _lib.snd_ctl_elem_info
snd_ctl_elem_info.restype = c_int
snd_ctl_elem_info.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:235
snd_ctl_elem_read = _lib.snd_ctl_elem_read
snd_ctl_elem_read.restype = c_int
snd_ctl_elem_read.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_elem_value_t)]

# /usr/include/alsa/control.h:236
snd_ctl_elem_write = _lib.snd_ctl_elem_write
snd_ctl_elem_write.restype = c_int
snd_ctl_elem_write.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_elem_value_t)]

# /usr/include/alsa/control.h:237
snd_ctl_elem_lock = _lib.snd_ctl_elem_lock
snd_ctl_elem_lock.restype = c_int
snd_ctl_elem_lock.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:238
snd_ctl_elem_unlock = _lib.snd_ctl_elem_unlock
snd_ctl_elem_unlock.restype = c_int
snd_ctl_elem_unlock.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:239
snd_ctl_elem_tlv_read = _lib.snd_ctl_elem_tlv_read
snd_ctl_elem_tlv_read.restype = c_int
snd_ctl_elem_tlv_read.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_elem_id_t), POINTER(c_uint), c_uint]

# /usr/include/alsa/control.h:241
snd_ctl_elem_tlv_write = _lib.snd_ctl_elem_tlv_write
snd_ctl_elem_tlv_write.restype = c_int
snd_ctl_elem_tlv_write.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_elem_id_t), POINTER(c_uint)]

# /usr/include/alsa/control.h:243
snd_ctl_elem_tlv_command = _lib.snd_ctl_elem_tlv_command
snd_ctl_elem_tlv_command.restype = c_int
snd_ctl_elem_tlv_command.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_elem_id_t), POINTER(c_uint)]

# /usr/include/alsa/control.h:245
snd_ctl_hwdep_next_device = _lib.snd_ctl_hwdep_next_device
snd_ctl_hwdep_next_device.restype = c_int
snd_ctl_hwdep_next_device.argtypes = [POINTER(snd_ctl_t), POINTER(c_int)]

# /usr/include/alsa/control.h:246
snd_ctl_hwdep_info = _lib.snd_ctl_hwdep_info
snd_ctl_hwdep_info.restype = c_int
snd_ctl_hwdep_info.argtypes = [POINTER(snd_ctl_t), POINTER(snd_hwdep_info_t)]

# /usr/include/alsa/control.h:247
snd_ctl_pcm_next_device = _lib.snd_ctl_pcm_next_device
snd_ctl_pcm_next_device.restype = c_int
snd_ctl_pcm_next_device.argtypes = [POINTER(snd_ctl_t), POINTER(c_int)]

# /usr/include/alsa/control.h:248
snd_ctl_pcm_info = _lib.snd_ctl_pcm_info
snd_ctl_pcm_info.restype = c_int
snd_ctl_pcm_info.argtypes = [POINTER(snd_ctl_t), POINTER(snd_pcm_info_t)]

# /usr/include/alsa/control.h:249
snd_ctl_pcm_prefer_subdevice = _lib.snd_ctl_pcm_prefer_subdevice
snd_ctl_pcm_prefer_subdevice.restype = c_int
snd_ctl_pcm_prefer_subdevice.argtypes = [POINTER(snd_ctl_t), c_int]

# /usr/include/alsa/control.h:250
snd_ctl_rawmidi_next_device = _lib.snd_ctl_rawmidi_next_device
snd_ctl_rawmidi_next_device.restype = c_int
snd_ctl_rawmidi_next_device.argtypes = [POINTER(snd_ctl_t), POINTER(c_int)]

# /usr/include/alsa/control.h:251
snd_ctl_rawmidi_info = _lib.snd_ctl_rawmidi_info
snd_ctl_rawmidi_info.restype = c_int
snd_ctl_rawmidi_info.argtypes = [POINTER(snd_ctl_t), POINTER(snd_rawmidi_info_t)]

# /usr/include/alsa/control.h:252
snd_ctl_rawmidi_prefer_subdevice = _lib.snd_ctl_rawmidi_prefer_subdevice
snd_ctl_rawmidi_prefer_subdevice.restype = c_int
snd_ctl_rawmidi_prefer_subdevice.argtypes = [POINTER(snd_ctl_t), c_int]

# /usr/include/alsa/control.h:253
snd_ctl_set_power_state = _lib.snd_ctl_set_power_state
snd_ctl_set_power_state.restype = c_int
snd_ctl_set_power_state.argtypes = [POINTER(snd_ctl_t), c_uint]

# /usr/include/alsa/control.h:254
snd_ctl_get_power_state = _lib.snd_ctl_get_power_state
snd_ctl_get_power_state.restype = c_int
snd_ctl_get_power_state.argtypes = [POINTER(snd_ctl_t), POINTER(c_uint)]

# /usr/include/alsa/control.h:256
snd_ctl_read = _lib.snd_ctl_read
snd_ctl_read.restype = c_int
snd_ctl_read.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_event_t)]

# /usr/include/alsa/control.h:257
snd_ctl_wait = _lib.snd_ctl_wait
snd_ctl_wait.restype = c_int
snd_ctl_wait.argtypes = [POINTER(snd_ctl_t), c_int]

# /usr/include/alsa/control.h:258
snd_ctl_name = _lib.snd_ctl_name
snd_ctl_name.restype = c_char_p
snd_ctl_name.argtypes = [POINTER(snd_ctl_t)]

# /usr/include/alsa/control.h:259
snd_ctl_type = _lib.snd_ctl_type
snd_ctl_type.restype = snd_ctl_type_t
snd_ctl_type.argtypes = [POINTER(snd_ctl_t)]

# /usr/include/alsa/control.h:261
snd_ctl_elem_type_name = _lib.snd_ctl_elem_type_name
snd_ctl_elem_type_name.restype = c_char_p
snd_ctl_elem_type_name.argtypes = [snd_ctl_elem_type_t]

# /usr/include/alsa/control.h:262
snd_ctl_elem_iface_name = _lib.snd_ctl_elem_iface_name
snd_ctl_elem_iface_name.restype = c_char_p
snd_ctl_elem_iface_name.argtypes = [snd_ctl_elem_iface_t]

# /usr/include/alsa/control.h:263
snd_ctl_event_type_name = _lib.snd_ctl_event_type_name
snd_ctl_event_type_name.restype = c_char_p
snd_ctl_event_type_name.argtypes = [snd_ctl_event_type_t]

# /usr/include/alsa/control.h:265
snd_ctl_event_elem_get_mask = _lib.snd_ctl_event_elem_get_mask
snd_ctl_event_elem_get_mask.restype = c_uint
snd_ctl_event_elem_get_mask.argtypes = [POINTER(snd_ctl_event_t)]

# /usr/include/alsa/control.h:266
snd_ctl_event_elem_get_numid = _lib.snd_ctl_event_elem_get_numid
snd_ctl_event_elem_get_numid.restype = c_uint
snd_ctl_event_elem_get_numid.argtypes = [POINTER(snd_ctl_event_t)]

# /usr/include/alsa/control.h:267
snd_ctl_event_elem_get_id = _lib.snd_ctl_event_elem_get_id
snd_ctl_event_elem_get_id.restype = None
snd_ctl_event_elem_get_id.argtypes = [POINTER(snd_ctl_event_t), POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:268
snd_ctl_event_elem_get_interface = _lib.snd_ctl_event_elem_get_interface
snd_ctl_event_elem_get_interface.restype = snd_ctl_elem_iface_t
snd_ctl_event_elem_get_interface.argtypes = [POINTER(snd_ctl_event_t)]

# /usr/include/alsa/control.h:269
snd_ctl_event_elem_get_device = _lib.snd_ctl_event_elem_get_device
snd_ctl_event_elem_get_device.restype = c_uint
snd_ctl_event_elem_get_device.argtypes = [POINTER(snd_ctl_event_t)]

# /usr/include/alsa/control.h:270
snd_ctl_event_elem_get_subdevice = _lib.snd_ctl_event_elem_get_subdevice
snd_ctl_event_elem_get_subdevice.restype = c_uint
snd_ctl_event_elem_get_subdevice.argtypes = [POINTER(snd_ctl_event_t)]

# /usr/include/alsa/control.h:271
snd_ctl_event_elem_get_name = _lib.snd_ctl_event_elem_get_name
snd_ctl_event_elem_get_name.restype = c_char_p
snd_ctl_event_elem_get_name.argtypes = [POINTER(snd_ctl_event_t)]

# /usr/include/alsa/control.h:272
snd_ctl_event_elem_get_index = _lib.snd_ctl_event_elem_get_index
snd_ctl_event_elem_get_index.restype = c_uint
snd_ctl_event_elem_get_index.argtypes = [POINTER(snd_ctl_event_t)]

# /usr/include/alsa/control.h:274
snd_ctl_elem_list_alloc_space = _lib.snd_ctl_elem_list_alloc_space
snd_ctl_elem_list_alloc_space.restype = c_int
snd_ctl_elem_list_alloc_space.argtypes = [POINTER(snd_ctl_elem_list_t), c_uint]

# /usr/include/alsa/control.h:275
snd_ctl_elem_list_free_space = _lib.snd_ctl_elem_list_free_space
snd_ctl_elem_list_free_space.restype = None
snd_ctl_elem_list_free_space.argtypes = [POINTER(snd_ctl_elem_list_t)]

# /usr/include/alsa/control.h:277
snd_ctl_elem_id_sizeof = _lib.snd_ctl_elem_id_sizeof
snd_ctl_elem_id_sizeof.restype = c_size_t
snd_ctl_elem_id_sizeof.argtypes = []

# /usr/include/alsa/control.h:283
snd_ctl_elem_id_malloc = _lib.snd_ctl_elem_id_malloc
snd_ctl_elem_id_malloc.restype = c_int
snd_ctl_elem_id_malloc.argtypes = [POINTER(POINTER(snd_ctl_elem_id_t))]

# /usr/include/alsa/control.h:284
snd_ctl_elem_id_free = _lib.snd_ctl_elem_id_free
snd_ctl_elem_id_free.restype = None
snd_ctl_elem_id_free.argtypes = [POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:285
snd_ctl_elem_id_clear = _lib.snd_ctl_elem_id_clear
snd_ctl_elem_id_clear.restype = None
snd_ctl_elem_id_clear.argtypes = [POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:286
snd_ctl_elem_id_copy = _lib.snd_ctl_elem_id_copy
snd_ctl_elem_id_copy.restype = None
snd_ctl_elem_id_copy.argtypes = [POINTER(snd_ctl_elem_id_t), POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:287
snd_ctl_elem_id_get_numid = _lib.snd_ctl_elem_id_get_numid
snd_ctl_elem_id_get_numid.restype = c_uint
snd_ctl_elem_id_get_numid.argtypes = [POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:288
snd_ctl_elem_id_get_interface = _lib.snd_ctl_elem_id_get_interface
snd_ctl_elem_id_get_interface.restype = snd_ctl_elem_iface_t
snd_ctl_elem_id_get_interface.argtypes = [POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:289
snd_ctl_elem_id_get_device = _lib.snd_ctl_elem_id_get_device
snd_ctl_elem_id_get_device.restype = c_uint
snd_ctl_elem_id_get_device.argtypes = [POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:290
snd_ctl_elem_id_get_subdevice = _lib.snd_ctl_elem_id_get_subdevice
snd_ctl_elem_id_get_subdevice.restype = c_uint
snd_ctl_elem_id_get_subdevice.argtypes = [POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:291
snd_ctl_elem_id_get_name = _lib.snd_ctl_elem_id_get_name
snd_ctl_elem_id_get_name.restype = c_char_p
snd_ctl_elem_id_get_name.argtypes = [POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:292
snd_ctl_elem_id_get_index = _lib.snd_ctl_elem_id_get_index
snd_ctl_elem_id_get_index.restype = c_uint
snd_ctl_elem_id_get_index.argtypes = [POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:293
snd_ctl_elem_id_set_numid = _lib.snd_ctl_elem_id_set_numid
snd_ctl_elem_id_set_numid.restype = None
snd_ctl_elem_id_set_numid.argtypes = [POINTER(snd_ctl_elem_id_t), c_uint]

# /usr/include/alsa/control.h:294
snd_ctl_elem_id_set_interface = _lib.snd_ctl_elem_id_set_interface
snd_ctl_elem_id_set_interface.restype = None
snd_ctl_elem_id_set_interface.argtypes = [POINTER(snd_ctl_elem_id_t), snd_ctl_elem_iface_t]

# /usr/include/alsa/control.h:295
snd_ctl_elem_id_set_device = _lib.snd_ctl_elem_id_set_device
snd_ctl_elem_id_set_device.restype = None
snd_ctl_elem_id_set_device.argtypes = [POINTER(snd_ctl_elem_id_t), c_uint]

# /usr/include/alsa/control.h:296
snd_ctl_elem_id_set_subdevice = _lib.snd_ctl_elem_id_set_subdevice
snd_ctl_elem_id_set_subdevice.restype = None
snd_ctl_elem_id_set_subdevice.argtypes = [POINTER(snd_ctl_elem_id_t), c_uint]

# /usr/include/alsa/control.h:297
snd_ctl_elem_id_set_name = _lib.snd_ctl_elem_id_set_name
snd_ctl_elem_id_set_name.restype = None
snd_ctl_elem_id_set_name.argtypes = [POINTER(snd_ctl_elem_id_t), c_char_p]

# /usr/include/alsa/control.h:298
snd_ctl_elem_id_set_index = _lib.snd_ctl_elem_id_set_index
snd_ctl_elem_id_set_index.restype = None
snd_ctl_elem_id_set_index.argtypes = [POINTER(snd_ctl_elem_id_t), c_uint]

# /usr/include/alsa/control.h:300
snd_ctl_card_info_sizeof = _lib.snd_ctl_card_info_sizeof
snd_ctl_card_info_sizeof.restype = c_size_t
snd_ctl_card_info_sizeof.argtypes = []

# /usr/include/alsa/control.h:306
snd_ctl_card_info_malloc = _lib.snd_ctl_card_info_malloc
snd_ctl_card_info_malloc.restype = c_int
snd_ctl_card_info_malloc.argtypes = [POINTER(POINTER(snd_ctl_card_info_t))]

# /usr/include/alsa/control.h:307
snd_ctl_card_info_free = _lib.snd_ctl_card_info_free
snd_ctl_card_info_free.restype = None
snd_ctl_card_info_free.argtypes = [POINTER(snd_ctl_card_info_t)]

# /usr/include/alsa/control.h:308
snd_ctl_card_info_clear = _lib.snd_ctl_card_info_clear
snd_ctl_card_info_clear.restype = None
snd_ctl_card_info_clear.argtypes = [POINTER(snd_ctl_card_info_t)]

# /usr/include/alsa/control.h:309
snd_ctl_card_info_copy = _lib.snd_ctl_card_info_copy
snd_ctl_card_info_copy.restype = None
snd_ctl_card_info_copy.argtypes = [POINTER(snd_ctl_card_info_t), POINTER(snd_ctl_card_info_t)]

# /usr/include/alsa/control.h:310
snd_ctl_card_info_get_card = _lib.snd_ctl_card_info_get_card
snd_ctl_card_info_get_card.restype = c_int
snd_ctl_card_info_get_card.argtypes = [POINTER(snd_ctl_card_info_t)]

# /usr/include/alsa/control.h:311
snd_ctl_card_info_get_id = _lib.snd_ctl_card_info_get_id
snd_ctl_card_info_get_id.restype = c_char_p
snd_ctl_card_info_get_id.argtypes = [POINTER(snd_ctl_card_info_t)]

# /usr/include/alsa/control.h:312
snd_ctl_card_info_get_driver = _lib.snd_ctl_card_info_get_driver
snd_ctl_card_info_get_driver.restype = c_char_p
snd_ctl_card_info_get_driver.argtypes = [POINTER(snd_ctl_card_info_t)]

# /usr/include/alsa/control.h:313
snd_ctl_card_info_get_name = _lib.snd_ctl_card_info_get_name
snd_ctl_card_info_get_name.restype = c_char_p
snd_ctl_card_info_get_name.argtypes = [POINTER(snd_ctl_card_info_t)]

# /usr/include/alsa/control.h:314
snd_ctl_card_info_get_longname = _lib.snd_ctl_card_info_get_longname
snd_ctl_card_info_get_longname.restype = c_char_p
snd_ctl_card_info_get_longname.argtypes = [POINTER(snd_ctl_card_info_t)]

# /usr/include/alsa/control.h:315
snd_ctl_card_info_get_mixername = _lib.snd_ctl_card_info_get_mixername
snd_ctl_card_info_get_mixername.restype = c_char_p
snd_ctl_card_info_get_mixername.argtypes = [POINTER(snd_ctl_card_info_t)]

# /usr/include/alsa/control.h:316
snd_ctl_card_info_get_components = _lib.snd_ctl_card_info_get_components
snd_ctl_card_info_get_components.restype = c_char_p
snd_ctl_card_info_get_components.argtypes = [POINTER(snd_ctl_card_info_t)]

# /usr/include/alsa/control.h:318
snd_ctl_event_sizeof = _lib.snd_ctl_event_sizeof
snd_ctl_event_sizeof.restype = c_size_t
snd_ctl_event_sizeof.argtypes = []

# /usr/include/alsa/control.h:324
snd_ctl_event_malloc = _lib.snd_ctl_event_malloc
snd_ctl_event_malloc.restype = c_int
snd_ctl_event_malloc.argtypes = [POINTER(POINTER(snd_ctl_event_t))]

# /usr/include/alsa/control.h:325
snd_ctl_event_free = _lib.snd_ctl_event_free
snd_ctl_event_free.restype = None
snd_ctl_event_free.argtypes = [POINTER(snd_ctl_event_t)]

# /usr/include/alsa/control.h:326
snd_ctl_event_clear = _lib.snd_ctl_event_clear
snd_ctl_event_clear.restype = None
snd_ctl_event_clear.argtypes = [POINTER(snd_ctl_event_t)]

# /usr/include/alsa/control.h:327
snd_ctl_event_copy = _lib.snd_ctl_event_copy
snd_ctl_event_copy.restype = None
snd_ctl_event_copy.argtypes = [POINTER(snd_ctl_event_t), POINTER(snd_ctl_event_t)]

# /usr/include/alsa/control.h:328
snd_ctl_event_get_type = _lib.snd_ctl_event_get_type
snd_ctl_event_get_type.restype = snd_ctl_event_type_t
snd_ctl_event_get_type.argtypes = [POINTER(snd_ctl_event_t)]

# /usr/include/alsa/control.h:330
snd_ctl_elem_list_sizeof = _lib.snd_ctl_elem_list_sizeof
snd_ctl_elem_list_sizeof.restype = c_size_t
snd_ctl_elem_list_sizeof.argtypes = []

# /usr/include/alsa/control.h:336
snd_ctl_elem_list_malloc = _lib.snd_ctl_elem_list_malloc
snd_ctl_elem_list_malloc.restype = c_int
snd_ctl_elem_list_malloc.argtypes = [POINTER(POINTER(snd_ctl_elem_list_t))]

# /usr/include/alsa/control.h:337
snd_ctl_elem_list_free = _lib.snd_ctl_elem_list_free
snd_ctl_elem_list_free.restype = None
snd_ctl_elem_list_free.argtypes = [POINTER(snd_ctl_elem_list_t)]

# /usr/include/alsa/control.h:338
snd_ctl_elem_list_clear = _lib.snd_ctl_elem_list_clear
snd_ctl_elem_list_clear.restype = None
snd_ctl_elem_list_clear.argtypes = [POINTER(snd_ctl_elem_list_t)]

# /usr/include/alsa/control.h:339
snd_ctl_elem_list_copy = _lib.snd_ctl_elem_list_copy
snd_ctl_elem_list_copy.restype = None
snd_ctl_elem_list_copy.argtypes = [POINTER(snd_ctl_elem_list_t), POINTER(snd_ctl_elem_list_t)]

# /usr/include/alsa/control.h:340
snd_ctl_elem_list_set_offset = _lib.snd_ctl_elem_list_set_offset
snd_ctl_elem_list_set_offset.restype = None
snd_ctl_elem_list_set_offset.argtypes = [POINTER(snd_ctl_elem_list_t), c_uint]

# /usr/include/alsa/control.h:341
snd_ctl_elem_list_get_used = _lib.snd_ctl_elem_list_get_used
snd_ctl_elem_list_get_used.restype = c_uint
snd_ctl_elem_list_get_used.argtypes = [POINTER(snd_ctl_elem_list_t)]

# /usr/include/alsa/control.h:342
snd_ctl_elem_list_get_count = _lib.snd_ctl_elem_list_get_count
snd_ctl_elem_list_get_count.restype = c_uint
snd_ctl_elem_list_get_count.argtypes = [POINTER(snd_ctl_elem_list_t)]

# /usr/include/alsa/control.h:343
snd_ctl_elem_list_get_id = _lib.snd_ctl_elem_list_get_id
snd_ctl_elem_list_get_id.restype = None
snd_ctl_elem_list_get_id.argtypes = [POINTER(snd_ctl_elem_list_t), c_uint, POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:344
snd_ctl_elem_list_get_numid = _lib.snd_ctl_elem_list_get_numid
snd_ctl_elem_list_get_numid.restype = c_uint
snd_ctl_elem_list_get_numid.argtypes = [POINTER(snd_ctl_elem_list_t), c_uint]

# /usr/include/alsa/control.h:345
snd_ctl_elem_list_get_interface = _lib.snd_ctl_elem_list_get_interface
snd_ctl_elem_list_get_interface.restype = snd_ctl_elem_iface_t
snd_ctl_elem_list_get_interface.argtypes = [POINTER(snd_ctl_elem_list_t), c_uint]

# /usr/include/alsa/control.h:346
snd_ctl_elem_list_get_device = _lib.snd_ctl_elem_list_get_device
snd_ctl_elem_list_get_device.restype = c_uint
snd_ctl_elem_list_get_device.argtypes = [POINTER(snd_ctl_elem_list_t), c_uint]

# /usr/include/alsa/control.h:347
snd_ctl_elem_list_get_subdevice = _lib.snd_ctl_elem_list_get_subdevice
snd_ctl_elem_list_get_subdevice.restype = c_uint
snd_ctl_elem_list_get_subdevice.argtypes = [POINTER(snd_ctl_elem_list_t), c_uint]

# /usr/include/alsa/control.h:348
snd_ctl_elem_list_get_name = _lib.snd_ctl_elem_list_get_name
snd_ctl_elem_list_get_name.restype = c_char_p
snd_ctl_elem_list_get_name.argtypes = [POINTER(snd_ctl_elem_list_t), c_uint]

# /usr/include/alsa/control.h:349
snd_ctl_elem_list_get_index = _lib.snd_ctl_elem_list_get_index
snd_ctl_elem_list_get_index.restype = c_uint
snd_ctl_elem_list_get_index.argtypes = [POINTER(snd_ctl_elem_list_t), c_uint]

# /usr/include/alsa/control.h:351
snd_ctl_elem_info_sizeof = _lib.snd_ctl_elem_info_sizeof
snd_ctl_elem_info_sizeof.restype = c_size_t
snd_ctl_elem_info_sizeof.argtypes = []

# /usr/include/alsa/control.h:357
snd_ctl_elem_info_malloc = _lib.snd_ctl_elem_info_malloc
snd_ctl_elem_info_malloc.restype = c_int
snd_ctl_elem_info_malloc.argtypes = [POINTER(POINTER(snd_ctl_elem_info_t))]

# /usr/include/alsa/control.h:358
snd_ctl_elem_info_free = _lib.snd_ctl_elem_info_free
snd_ctl_elem_info_free.restype = None
snd_ctl_elem_info_free.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:359
snd_ctl_elem_info_clear = _lib.snd_ctl_elem_info_clear
snd_ctl_elem_info_clear.restype = None
snd_ctl_elem_info_clear.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:360
snd_ctl_elem_info_copy = _lib.snd_ctl_elem_info_copy
snd_ctl_elem_info_copy.restype = None
snd_ctl_elem_info_copy.argtypes = [POINTER(snd_ctl_elem_info_t), POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:361
snd_ctl_elem_info_get_type = _lib.snd_ctl_elem_info_get_type
snd_ctl_elem_info_get_type.restype = snd_ctl_elem_type_t
snd_ctl_elem_info_get_type.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:362
snd_ctl_elem_info_is_readable = _lib.snd_ctl_elem_info_is_readable
snd_ctl_elem_info_is_readable.restype = c_int
snd_ctl_elem_info_is_readable.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:363
snd_ctl_elem_info_is_writable = _lib.snd_ctl_elem_info_is_writable
snd_ctl_elem_info_is_writable.restype = c_int
snd_ctl_elem_info_is_writable.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:364
snd_ctl_elem_info_is_volatile = _lib.snd_ctl_elem_info_is_volatile
snd_ctl_elem_info_is_volatile.restype = c_int
snd_ctl_elem_info_is_volatile.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:365
snd_ctl_elem_info_is_inactive = _lib.snd_ctl_elem_info_is_inactive
snd_ctl_elem_info_is_inactive.restype = c_int
snd_ctl_elem_info_is_inactive.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:366
snd_ctl_elem_info_is_locked = _lib.snd_ctl_elem_info_is_locked
snd_ctl_elem_info_is_locked.restype = c_int
snd_ctl_elem_info_is_locked.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:367
snd_ctl_elem_info_is_tlv_readable = _lib.snd_ctl_elem_info_is_tlv_readable
snd_ctl_elem_info_is_tlv_readable.restype = c_int
snd_ctl_elem_info_is_tlv_readable.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:368
snd_ctl_elem_info_is_tlv_writable = _lib.snd_ctl_elem_info_is_tlv_writable
snd_ctl_elem_info_is_tlv_writable.restype = c_int
snd_ctl_elem_info_is_tlv_writable.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:369
snd_ctl_elem_info_is_tlv_commandable = _lib.snd_ctl_elem_info_is_tlv_commandable
snd_ctl_elem_info_is_tlv_commandable.restype = c_int
snd_ctl_elem_info_is_tlv_commandable.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:370
snd_ctl_elem_info_is_owner = _lib.snd_ctl_elem_info_is_owner
snd_ctl_elem_info_is_owner.restype = c_int
snd_ctl_elem_info_is_owner.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:371
snd_ctl_elem_info_is_user = _lib.snd_ctl_elem_info_is_user
snd_ctl_elem_info_is_user.restype = c_int
snd_ctl_elem_info_is_user.argtypes = [POINTER(snd_ctl_elem_info_t)]

__pid_t = c_int 	# /usr/include/gentoo-multilib/amd64/bits/types.h:146
pid_t = __pid_t 	# /usr/include/gentoo-multilib/amd64/unistd.h:229
# /usr/include/alsa/control.h:372
snd_ctl_elem_info_get_owner = _lib.snd_ctl_elem_info_get_owner
snd_ctl_elem_info_get_owner.restype = pid_t
snd_ctl_elem_info_get_owner.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:373
snd_ctl_elem_info_get_count = _lib.snd_ctl_elem_info_get_count
snd_ctl_elem_info_get_count.restype = c_uint
snd_ctl_elem_info_get_count.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:374
snd_ctl_elem_info_get_min = _lib.snd_ctl_elem_info_get_min
snd_ctl_elem_info_get_min.restype = c_long
snd_ctl_elem_info_get_min.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:375
snd_ctl_elem_info_get_max = _lib.snd_ctl_elem_info_get_max
snd_ctl_elem_info_get_max.restype = c_long
snd_ctl_elem_info_get_max.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:376
snd_ctl_elem_info_get_step = _lib.snd_ctl_elem_info_get_step
snd_ctl_elem_info_get_step.restype = c_long
snd_ctl_elem_info_get_step.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:377
snd_ctl_elem_info_get_min64 = _lib.snd_ctl_elem_info_get_min64
snd_ctl_elem_info_get_min64.restype = c_longlong
snd_ctl_elem_info_get_min64.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:378
snd_ctl_elem_info_get_max64 = _lib.snd_ctl_elem_info_get_max64
snd_ctl_elem_info_get_max64.restype = c_longlong
snd_ctl_elem_info_get_max64.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:379
snd_ctl_elem_info_get_step64 = _lib.snd_ctl_elem_info_get_step64
snd_ctl_elem_info_get_step64.restype = c_longlong
snd_ctl_elem_info_get_step64.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:380
snd_ctl_elem_info_get_items = _lib.snd_ctl_elem_info_get_items
snd_ctl_elem_info_get_items.restype = c_uint
snd_ctl_elem_info_get_items.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:381
snd_ctl_elem_info_set_item = _lib.snd_ctl_elem_info_set_item
snd_ctl_elem_info_set_item.restype = None
snd_ctl_elem_info_set_item.argtypes = [POINTER(snd_ctl_elem_info_t), c_uint]

# /usr/include/alsa/control.h:382
snd_ctl_elem_info_get_item_name = _lib.snd_ctl_elem_info_get_item_name
snd_ctl_elem_info_get_item_name.restype = c_char_p
snd_ctl_elem_info_get_item_name.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:383
snd_ctl_elem_info_get_dimensions = _lib.snd_ctl_elem_info_get_dimensions
snd_ctl_elem_info_get_dimensions.restype = c_int
snd_ctl_elem_info_get_dimensions.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:384
snd_ctl_elem_info_get_dimension = _lib.snd_ctl_elem_info_get_dimension
snd_ctl_elem_info_get_dimension.restype = c_int
snd_ctl_elem_info_get_dimension.argtypes = [POINTER(snd_ctl_elem_info_t), c_uint]

# /usr/include/alsa/control.h:385
snd_ctl_elem_info_get_id = _lib.snd_ctl_elem_info_get_id
snd_ctl_elem_info_get_id.restype = None
snd_ctl_elem_info_get_id.argtypes = [POINTER(snd_ctl_elem_info_t), POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:386
snd_ctl_elem_info_get_numid = _lib.snd_ctl_elem_info_get_numid
snd_ctl_elem_info_get_numid.restype = c_uint
snd_ctl_elem_info_get_numid.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:387
snd_ctl_elem_info_get_interface = _lib.snd_ctl_elem_info_get_interface
snd_ctl_elem_info_get_interface.restype = snd_ctl_elem_iface_t
snd_ctl_elem_info_get_interface.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:388
snd_ctl_elem_info_get_device = _lib.snd_ctl_elem_info_get_device
snd_ctl_elem_info_get_device.restype = c_uint
snd_ctl_elem_info_get_device.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:389
snd_ctl_elem_info_get_subdevice = _lib.snd_ctl_elem_info_get_subdevice
snd_ctl_elem_info_get_subdevice.restype = c_uint
snd_ctl_elem_info_get_subdevice.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:390
snd_ctl_elem_info_get_name = _lib.snd_ctl_elem_info_get_name
snd_ctl_elem_info_get_name.restype = c_char_p
snd_ctl_elem_info_get_name.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:391
snd_ctl_elem_info_get_index = _lib.snd_ctl_elem_info_get_index
snd_ctl_elem_info_get_index.restype = c_uint
snd_ctl_elem_info_get_index.argtypes = [POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:392
snd_ctl_elem_info_set_id = _lib.snd_ctl_elem_info_set_id
snd_ctl_elem_info_set_id.restype = None
snd_ctl_elem_info_set_id.argtypes = [POINTER(snd_ctl_elem_info_t), POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:393
snd_ctl_elem_info_set_numid = _lib.snd_ctl_elem_info_set_numid
snd_ctl_elem_info_set_numid.restype = None
snd_ctl_elem_info_set_numid.argtypes = [POINTER(snd_ctl_elem_info_t), c_uint]

# /usr/include/alsa/control.h:394
snd_ctl_elem_info_set_interface = _lib.snd_ctl_elem_info_set_interface
snd_ctl_elem_info_set_interface.restype = None
snd_ctl_elem_info_set_interface.argtypes = [POINTER(snd_ctl_elem_info_t), snd_ctl_elem_iface_t]

# /usr/include/alsa/control.h:395
snd_ctl_elem_info_set_device = _lib.snd_ctl_elem_info_set_device
snd_ctl_elem_info_set_device.restype = None
snd_ctl_elem_info_set_device.argtypes = [POINTER(snd_ctl_elem_info_t), c_uint]

# /usr/include/alsa/control.h:396
snd_ctl_elem_info_set_subdevice = _lib.snd_ctl_elem_info_set_subdevice
snd_ctl_elem_info_set_subdevice.restype = None
snd_ctl_elem_info_set_subdevice.argtypes = [POINTER(snd_ctl_elem_info_t), c_uint]

# /usr/include/alsa/control.h:397
snd_ctl_elem_info_set_name = _lib.snd_ctl_elem_info_set_name
snd_ctl_elem_info_set_name.restype = None
snd_ctl_elem_info_set_name.argtypes = [POINTER(snd_ctl_elem_info_t), c_char_p]

# /usr/include/alsa/control.h:398
snd_ctl_elem_info_set_index = _lib.snd_ctl_elem_info_set_index
snd_ctl_elem_info_set_index.restype = None
snd_ctl_elem_info_set_index.argtypes = [POINTER(snd_ctl_elem_info_t), c_uint]

# /usr/include/alsa/control.h:400
snd_ctl_elem_add_integer = _lib.snd_ctl_elem_add_integer
snd_ctl_elem_add_integer.restype = c_int
snd_ctl_elem_add_integer.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_elem_id_t), c_uint, c_long, c_long, c_long]

# /usr/include/alsa/control.h:401
snd_ctl_elem_add_integer64 = _lib.snd_ctl_elem_add_integer64
snd_ctl_elem_add_integer64.restype = c_int
snd_ctl_elem_add_integer64.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_elem_id_t), c_uint, c_longlong, c_longlong, c_longlong]

# /usr/include/alsa/control.h:402
snd_ctl_elem_add_boolean = _lib.snd_ctl_elem_add_boolean
snd_ctl_elem_add_boolean.restype = c_int
snd_ctl_elem_add_boolean.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_elem_id_t), c_uint]

# /usr/include/alsa/control.h:403
snd_ctl_elem_add_iec958 = _lib.snd_ctl_elem_add_iec958
snd_ctl_elem_add_iec958.restype = c_int
snd_ctl_elem_add_iec958.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:404
snd_ctl_elem_remove = _lib.snd_ctl_elem_remove
snd_ctl_elem_remove.restype = c_int
snd_ctl_elem_remove.argtypes = [POINTER(snd_ctl_t), POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:406
snd_ctl_elem_value_sizeof = _lib.snd_ctl_elem_value_sizeof
snd_ctl_elem_value_sizeof.restype = c_size_t
snd_ctl_elem_value_sizeof.argtypes = []

# /usr/include/alsa/control.h:412
snd_ctl_elem_value_malloc = _lib.snd_ctl_elem_value_malloc
snd_ctl_elem_value_malloc.restype = c_int
snd_ctl_elem_value_malloc.argtypes = [POINTER(POINTER(snd_ctl_elem_value_t))]

# /usr/include/alsa/control.h:413
snd_ctl_elem_value_free = _lib.snd_ctl_elem_value_free
snd_ctl_elem_value_free.restype = None
snd_ctl_elem_value_free.argtypes = [POINTER(snd_ctl_elem_value_t)]

# /usr/include/alsa/control.h:414
snd_ctl_elem_value_clear = _lib.snd_ctl_elem_value_clear
snd_ctl_elem_value_clear.restype = None
snd_ctl_elem_value_clear.argtypes = [POINTER(snd_ctl_elem_value_t)]

# /usr/include/alsa/control.h:415
snd_ctl_elem_value_copy = _lib.snd_ctl_elem_value_copy
snd_ctl_elem_value_copy.restype = None
snd_ctl_elem_value_copy.argtypes = [POINTER(snd_ctl_elem_value_t), POINTER(snd_ctl_elem_value_t)]

# /usr/include/alsa/control.h:416
snd_ctl_elem_value_get_id = _lib.snd_ctl_elem_value_get_id
snd_ctl_elem_value_get_id.restype = None
snd_ctl_elem_value_get_id.argtypes = [POINTER(snd_ctl_elem_value_t), POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:417
snd_ctl_elem_value_get_numid = _lib.snd_ctl_elem_value_get_numid
snd_ctl_elem_value_get_numid.restype = c_uint
snd_ctl_elem_value_get_numid.argtypes = [POINTER(snd_ctl_elem_value_t)]

# /usr/include/alsa/control.h:418
snd_ctl_elem_value_get_interface = _lib.snd_ctl_elem_value_get_interface
snd_ctl_elem_value_get_interface.restype = snd_ctl_elem_iface_t
snd_ctl_elem_value_get_interface.argtypes = [POINTER(snd_ctl_elem_value_t)]

# /usr/include/alsa/control.h:419
snd_ctl_elem_value_get_device = _lib.snd_ctl_elem_value_get_device
snd_ctl_elem_value_get_device.restype = c_uint
snd_ctl_elem_value_get_device.argtypes = [POINTER(snd_ctl_elem_value_t)]

# /usr/include/alsa/control.h:420
snd_ctl_elem_value_get_subdevice = _lib.snd_ctl_elem_value_get_subdevice
snd_ctl_elem_value_get_subdevice.restype = c_uint
snd_ctl_elem_value_get_subdevice.argtypes = [POINTER(snd_ctl_elem_value_t)]

# /usr/include/alsa/control.h:421
snd_ctl_elem_value_get_name = _lib.snd_ctl_elem_value_get_name
snd_ctl_elem_value_get_name.restype = c_char_p
snd_ctl_elem_value_get_name.argtypes = [POINTER(snd_ctl_elem_value_t)]

# /usr/include/alsa/control.h:422
snd_ctl_elem_value_get_index = _lib.snd_ctl_elem_value_get_index
snd_ctl_elem_value_get_index.restype = c_uint
snd_ctl_elem_value_get_index.argtypes = [POINTER(snd_ctl_elem_value_t)]

# /usr/include/alsa/control.h:423
snd_ctl_elem_value_set_id = _lib.snd_ctl_elem_value_set_id
snd_ctl_elem_value_set_id.restype = None
snd_ctl_elem_value_set_id.argtypes = [POINTER(snd_ctl_elem_value_t), POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:424
snd_ctl_elem_value_set_numid = _lib.snd_ctl_elem_value_set_numid
snd_ctl_elem_value_set_numid.restype = None
snd_ctl_elem_value_set_numid.argtypes = [POINTER(snd_ctl_elem_value_t), c_uint]

# /usr/include/alsa/control.h:425
snd_ctl_elem_value_set_interface = _lib.snd_ctl_elem_value_set_interface
snd_ctl_elem_value_set_interface.restype = None
snd_ctl_elem_value_set_interface.argtypes = [POINTER(snd_ctl_elem_value_t), snd_ctl_elem_iface_t]

# /usr/include/alsa/control.h:426
snd_ctl_elem_value_set_device = _lib.snd_ctl_elem_value_set_device
snd_ctl_elem_value_set_device.restype = None
snd_ctl_elem_value_set_device.argtypes = [POINTER(snd_ctl_elem_value_t), c_uint]

# /usr/include/alsa/control.h:427
snd_ctl_elem_value_set_subdevice = _lib.snd_ctl_elem_value_set_subdevice
snd_ctl_elem_value_set_subdevice.restype = None
snd_ctl_elem_value_set_subdevice.argtypes = [POINTER(snd_ctl_elem_value_t), c_uint]

# /usr/include/alsa/control.h:428
snd_ctl_elem_value_set_name = _lib.snd_ctl_elem_value_set_name
snd_ctl_elem_value_set_name.restype = None
snd_ctl_elem_value_set_name.argtypes = [POINTER(snd_ctl_elem_value_t), c_char_p]

# /usr/include/alsa/control.h:429
snd_ctl_elem_value_set_index = _lib.snd_ctl_elem_value_set_index
snd_ctl_elem_value_set_index.restype = None
snd_ctl_elem_value_set_index.argtypes = [POINTER(snd_ctl_elem_value_t), c_uint]

# /usr/include/alsa/control.h:430
snd_ctl_elem_value_get_boolean = _lib.snd_ctl_elem_value_get_boolean
snd_ctl_elem_value_get_boolean.restype = c_int
snd_ctl_elem_value_get_boolean.argtypes = [POINTER(snd_ctl_elem_value_t), c_uint]

# /usr/include/alsa/control.h:431
snd_ctl_elem_value_get_integer = _lib.snd_ctl_elem_value_get_integer
snd_ctl_elem_value_get_integer.restype = c_long
snd_ctl_elem_value_get_integer.argtypes = [POINTER(snd_ctl_elem_value_t), c_uint]

# /usr/include/alsa/control.h:432
snd_ctl_elem_value_get_integer64 = _lib.snd_ctl_elem_value_get_integer64
snd_ctl_elem_value_get_integer64.restype = c_longlong
snd_ctl_elem_value_get_integer64.argtypes = [POINTER(snd_ctl_elem_value_t), c_uint]

# /usr/include/alsa/control.h:433
snd_ctl_elem_value_get_enumerated = _lib.snd_ctl_elem_value_get_enumerated
snd_ctl_elem_value_get_enumerated.restype = c_uint
snd_ctl_elem_value_get_enumerated.argtypes = [POINTER(snd_ctl_elem_value_t), c_uint]

# /usr/include/alsa/control.h:434
snd_ctl_elem_value_get_byte = _lib.snd_ctl_elem_value_get_byte
snd_ctl_elem_value_get_byte.restype = c_ubyte
snd_ctl_elem_value_get_byte.argtypes = [POINTER(snd_ctl_elem_value_t), c_uint]

# /usr/include/alsa/control.h:435
snd_ctl_elem_value_set_boolean = _lib.snd_ctl_elem_value_set_boolean
snd_ctl_elem_value_set_boolean.restype = None
snd_ctl_elem_value_set_boolean.argtypes = [POINTER(snd_ctl_elem_value_t), c_uint, c_long]

# /usr/include/alsa/control.h:436
snd_ctl_elem_value_set_integer = _lib.snd_ctl_elem_value_set_integer
snd_ctl_elem_value_set_integer.restype = None
snd_ctl_elem_value_set_integer.argtypes = [POINTER(snd_ctl_elem_value_t), c_uint, c_long]

# /usr/include/alsa/control.h:437
snd_ctl_elem_value_set_integer64 = _lib.snd_ctl_elem_value_set_integer64
snd_ctl_elem_value_set_integer64.restype = None
snd_ctl_elem_value_set_integer64.argtypes = [POINTER(snd_ctl_elem_value_t), c_uint, c_longlong]

# /usr/include/alsa/control.h:438
snd_ctl_elem_value_set_enumerated = _lib.snd_ctl_elem_value_set_enumerated
snd_ctl_elem_value_set_enumerated.restype = None
snd_ctl_elem_value_set_enumerated.argtypes = [POINTER(snd_ctl_elem_value_t), c_uint, c_uint]

# /usr/include/alsa/control.h:439
snd_ctl_elem_value_set_byte = _lib.snd_ctl_elem_value_set_byte
snd_ctl_elem_value_set_byte.restype = None
snd_ctl_elem_value_set_byte.argtypes = [POINTER(snd_ctl_elem_value_t), c_uint, c_ubyte]

# /usr/include/alsa/control.h:440
snd_ctl_elem_set_bytes = _lib.snd_ctl_elem_set_bytes
snd_ctl_elem_set_bytes.restype = None
snd_ctl_elem_set_bytes.argtypes = [POINTER(snd_ctl_elem_value_t), POINTER(None), c_size_t]

# /usr/include/alsa/control.h:441
snd_ctl_elem_value_get_bytes = _lib.snd_ctl_elem_value_get_bytes
snd_ctl_elem_value_get_bytes.restype = POINTER(c_void)
snd_ctl_elem_value_get_bytes.argtypes = [POINTER(snd_ctl_elem_value_t)]

# /usr/include/alsa/control.h:442
snd_ctl_elem_value_get_iec958 = _lib.snd_ctl_elem_value_get_iec958
snd_ctl_elem_value_get_iec958.restype = None
snd_ctl_elem_value_get_iec958.argtypes = [POINTER(snd_ctl_elem_value_t), POINTER(snd_aes_iec958_t)]

# /usr/include/alsa/control.h:443
snd_ctl_elem_value_set_iec958 = _lib.snd_ctl_elem_value_set_iec958
snd_ctl_elem_value_set_iec958.restype = None
snd_ctl_elem_value_set_iec958.argtypes = [POINTER(snd_ctl_elem_value_t), POINTER(snd_aes_iec958_t)]

class struct__snd_hctl_elem(Structure):
    __slots__ = [
    ]
struct__snd_hctl_elem._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_hctl_elem(Structure):
    __slots__ = [
    ]
struct__snd_hctl_elem._fields_ = [
    ('_opaque_struct', c_int)
]

snd_hctl_elem_t = struct__snd_hctl_elem 	# /usr/include/alsa/control.h:454
class struct__snd_hctl(Structure):
    __slots__ = [
    ]
struct__snd_hctl._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_hctl(Structure):
    __slots__ = [
    ]
struct__snd_hctl._fields_ = [
    ('_opaque_struct', c_int)
]

snd_hctl_t = struct__snd_hctl 	# /usr/include/alsa/control.h:457
snd_hctl_compare_t = CFUNCTYPE(c_int, POINTER(snd_hctl_elem_t), POINTER(snd_hctl_elem_t)) 	# /usr/include/alsa/control.h:465
# /usr/include/alsa/control.h:467
snd_hctl_compare_fast = _lib.snd_hctl_compare_fast
snd_hctl_compare_fast.restype = c_int
snd_hctl_compare_fast.argtypes = [POINTER(snd_hctl_elem_t), POINTER(snd_hctl_elem_t)]

snd_hctl_callback_t = CFUNCTYPE(c_int, POINTER(snd_hctl_t), c_uint, POINTER(snd_hctl_elem_t)) 	# /usr/include/alsa/control.h:476
snd_hctl_elem_callback_t = CFUNCTYPE(c_int, POINTER(snd_hctl_elem_t), c_uint) 	# /usr/include/alsa/control.h:485
# /usr/include/alsa/control.h:488
snd_hctl_open = _lib.snd_hctl_open
snd_hctl_open.restype = c_int
snd_hctl_open.argtypes = [POINTER(POINTER(snd_hctl_t)), c_char_p, c_int]

# /usr/include/alsa/control.h:489
snd_hctl_open_ctl = _lib.snd_hctl_open_ctl
snd_hctl_open_ctl.restype = c_int
snd_hctl_open_ctl.argtypes = [POINTER(POINTER(snd_hctl_t)), POINTER(snd_ctl_t)]

# /usr/include/alsa/control.h:490
snd_hctl_close = _lib.snd_hctl_close
snd_hctl_close.restype = c_int
snd_hctl_close.argtypes = [POINTER(snd_hctl_t)]

# /usr/include/alsa/control.h:491
snd_hctl_nonblock = _lib.snd_hctl_nonblock
snd_hctl_nonblock.restype = c_int
snd_hctl_nonblock.argtypes = [POINTER(snd_hctl_t), c_int]

# /usr/include/alsa/control.h:492
snd_hctl_poll_descriptors_count = _lib.snd_hctl_poll_descriptors_count
snd_hctl_poll_descriptors_count.restype = c_int
snd_hctl_poll_descriptors_count.argtypes = [POINTER(snd_hctl_t)]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/control.h:493
snd_hctl_poll_descriptors = _lib.snd_hctl_poll_descriptors
snd_hctl_poll_descriptors.restype = c_int
snd_hctl_poll_descriptors.argtypes = [POINTER(snd_hctl_t), POINTER(struct_pollfd), c_uint]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/control.h:494
snd_hctl_poll_descriptors_revents = _lib.snd_hctl_poll_descriptors_revents
snd_hctl_poll_descriptors_revents.restype = c_int
snd_hctl_poll_descriptors_revents.argtypes = [POINTER(snd_hctl_t), POINTER(struct_pollfd), c_uint, POINTER(c_ushort)]

# /usr/include/alsa/control.h:495
snd_hctl_get_count = _lib.snd_hctl_get_count
snd_hctl_get_count.restype = c_uint
snd_hctl_get_count.argtypes = [POINTER(snd_hctl_t)]

# /usr/include/alsa/control.h:496
snd_hctl_set_compare = _lib.snd_hctl_set_compare
snd_hctl_set_compare.restype = c_int
snd_hctl_set_compare.argtypes = [POINTER(snd_hctl_t), snd_hctl_compare_t]

# /usr/include/alsa/control.h:497
snd_hctl_first_elem = _lib.snd_hctl_first_elem
snd_hctl_first_elem.restype = POINTER(snd_hctl_elem_t)
snd_hctl_first_elem.argtypes = [POINTER(snd_hctl_t)]

# /usr/include/alsa/control.h:498
snd_hctl_last_elem = _lib.snd_hctl_last_elem
snd_hctl_last_elem.restype = POINTER(snd_hctl_elem_t)
snd_hctl_last_elem.argtypes = [POINTER(snd_hctl_t)]

# /usr/include/alsa/control.h:499
snd_hctl_find_elem = _lib.snd_hctl_find_elem
snd_hctl_find_elem.restype = POINTER(snd_hctl_elem_t)
snd_hctl_find_elem.argtypes = [POINTER(snd_hctl_t), POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:500
snd_hctl_set_callback = _lib.snd_hctl_set_callback
snd_hctl_set_callback.restype = None
snd_hctl_set_callback.argtypes = [POINTER(snd_hctl_t), snd_hctl_callback_t]

# /usr/include/alsa/control.h:501
snd_hctl_set_callback_private = _lib.snd_hctl_set_callback_private
snd_hctl_set_callback_private.restype = None
snd_hctl_set_callback_private.argtypes = [POINTER(snd_hctl_t), POINTER(None)]

# /usr/include/alsa/control.h:502
snd_hctl_get_callback_private = _lib.snd_hctl_get_callback_private
snd_hctl_get_callback_private.restype = POINTER(c_void)
snd_hctl_get_callback_private.argtypes = [POINTER(snd_hctl_t)]

# /usr/include/alsa/control.h:503
snd_hctl_load = _lib.snd_hctl_load
snd_hctl_load.restype = c_int
snd_hctl_load.argtypes = [POINTER(snd_hctl_t)]

# /usr/include/alsa/control.h:504
snd_hctl_free = _lib.snd_hctl_free
snd_hctl_free.restype = c_int
snd_hctl_free.argtypes = [POINTER(snd_hctl_t)]

# /usr/include/alsa/control.h:505
snd_hctl_handle_events = _lib.snd_hctl_handle_events
snd_hctl_handle_events.restype = c_int
snd_hctl_handle_events.argtypes = [POINTER(snd_hctl_t)]

# /usr/include/alsa/control.h:506
snd_hctl_name = _lib.snd_hctl_name
snd_hctl_name.restype = c_char_p
snd_hctl_name.argtypes = [POINTER(snd_hctl_t)]

# /usr/include/alsa/control.h:507
snd_hctl_wait = _lib.snd_hctl_wait
snd_hctl_wait.restype = c_int
snd_hctl_wait.argtypes = [POINTER(snd_hctl_t), c_int]

# /usr/include/alsa/control.h:508
snd_hctl_ctl = _lib.snd_hctl_ctl
snd_hctl_ctl.restype = POINTER(snd_ctl_t)
snd_hctl_ctl.argtypes = [POINTER(snd_hctl_t)]

# /usr/include/alsa/control.h:510
snd_hctl_elem_next = _lib.snd_hctl_elem_next
snd_hctl_elem_next.restype = POINTER(snd_hctl_elem_t)
snd_hctl_elem_next.argtypes = [POINTER(snd_hctl_elem_t)]

# /usr/include/alsa/control.h:511
snd_hctl_elem_prev = _lib.snd_hctl_elem_prev
snd_hctl_elem_prev.restype = POINTER(snd_hctl_elem_t)
snd_hctl_elem_prev.argtypes = [POINTER(snd_hctl_elem_t)]

# /usr/include/alsa/control.h:512
snd_hctl_elem_info = _lib.snd_hctl_elem_info
snd_hctl_elem_info.restype = c_int
snd_hctl_elem_info.argtypes = [POINTER(snd_hctl_elem_t), POINTER(snd_ctl_elem_info_t)]

# /usr/include/alsa/control.h:513
snd_hctl_elem_read = _lib.snd_hctl_elem_read
snd_hctl_elem_read.restype = c_int
snd_hctl_elem_read.argtypes = [POINTER(snd_hctl_elem_t), POINTER(snd_ctl_elem_value_t)]

# /usr/include/alsa/control.h:514
snd_hctl_elem_write = _lib.snd_hctl_elem_write
snd_hctl_elem_write.restype = c_int
snd_hctl_elem_write.argtypes = [POINTER(snd_hctl_elem_t), POINTER(snd_ctl_elem_value_t)]

# /usr/include/alsa/control.h:515
snd_hctl_elem_tlv_read = _lib.snd_hctl_elem_tlv_read
snd_hctl_elem_tlv_read.restype = c_int
snd_hctl_elem_tlv_read.argtypes = [POINTER(snd_hctl_elem_t), POINTER(c_uint), c_uint]

# /usr/include/alsa/control.h:516
snd_hctl_elem_tlv_write = _lib.snd_hctl_elem_tlv_write
snd_hctl_elem_tlv_write.restype = c_int
snd_hctl_elem_tlv_write.argtypes = [POINTER(snd_hctl_elem_t), POINTER(c_uint)]

# /usr/include/alsa/control.h:517
snd_hctl_elem_tlv_command = _lib.snd_hctl_elem_tlv_command
snd_hctl_elem_tlv_command.restype = c_int
snd_hctl_elem_tlv_command.argtypes = [POINTER(snd_hctl_elem_t), POINTER(c_uint)]

# /usr/include/alsa/control.h:519
snd_hctl_elem_get_hctl = _lib.snd_hctl_elem_get_hctl
snd_hctl_elem_get_hctl.restype = POINTER(snd_hctl_t)
snd_hctl_elem_get_hctl.argtypes = [POINTER(snd_hctl_elem_t)]

# /usr/include/alsa/control.h:521
snd_hctl_elem_get_id = _lib.snd_hctl_elem_get_id
snd_hctl_elem_get_id.restype = None
snd_hctl_elem_get_id.argtypes = [POINTER(snd_hctl_elem_t), POINTER(snd_ctl_elem_id_t)]

# /usr/include/alsa/control.h:522
snd_hctl_elem_get_numid = _lib.snd_hctl_elem_get_numid
snd_hctl_elem_get_numid.restype = c_uint
snd_hctl_elem_get_numid.argtypes = [POINTER(snd_hctl_elem_t)]

# /usr/include/alsa/control.h:523
snd_hctl_elem_get_interface = _lib.snd_hctl_elem_get_interface
snd_hctl_elem_get_interface.restype = snd_ctl_elem_iface_t
snd_hctl_elem_get_interface.argtypes = [POINTER(snd_hctl_elem_t)]

# /usr/include/alsa/control.h:524
snd_hctl_elem_get_device = _lib.snd_hctl_elem_get_device
snd_hctl_elem_get_device.restype = c_uint
snd_hctl_elem_get_device.argtypes = [POINTER(snd_hctl_elem_t)]

# /usr/include/alsa/control.h:525
snd_hctl_elem_get_subdevice = _lib.snd_hctl_elem_get_subdevice
snd_hctl_elem_get_subdevice.restype = c_uint
snd_hctl_elem_get_subdevice.argtypes = [POINTER(snd_hctl_elem_t)]

# /usr/include/alsa/control.h:526
snd_hctl_elem_get_name = _lib.snd_hctl_elem_get_name
snd_hctl_elem_get_name.restype = c_char_p
snd_hctl_elem_get_name.argtypes = [POINTER(snd_hctl_elem_t)]

# /usr/include/alsa/control.h:527
snd_hctl_elem_get_index = _lib.snd_hctl_elem_get_index
snd_hctl_elem_get_index.restype = c_uint
snd_hctl_elem_get_index.argtypes = [POINTER(snd_hctl_elem_t)]

# /usr/include/alsa/control.h:528
snd_hctl_elem_set_callback = _lib.snd_hctl_elem_set_callback
snd_hctl_elem_set_callback.restype = None
snd_hctl_elem_set_callback.argtypes = [POINTER(snd_hctl_elem_t), snd_hctl_elem_callback_t]

# /usr/include/alsa/control.h:529
snd_hctl_elem_get_callback_private = _lib.snd_hctl_elem_get_callback_private
snd_hctl_elem_get_callback_private.restype = POINTER(c_void)
snd_hctl_elem_get_callback_private.argtypes = [POINTER(snd_hctl_elem_t)]

# /usr/include/alsa/control.h:530
snd_hctl_elem_set_callback_private = _lib.snd_hctl_elem_set_callback_private
snd_hctl_elem_set_callback_private.restype = None
snd_hctl_elem_set_callback_private.argtypes = [POINTER(snd_hctl_elem_t), POINTER(None)]

# /usr/include/alsa/control.h:543
snd_sctl_build = _lib.snd_sctl_build
snd_sctl_build.restype = c_int
snd_sctl_build.argtypes = [POINTER(POINTER(snd_sctl_t)), POINTER(snd_ctl_t), POINTER(snd_config_t), POINTER(snd_config_t), c_int]

# /usr/include/alsa/control.h:545
snd_sctl_free = _lib.snd_sctl_free
snd_sctl_free.restype = c_int
snd_sctl_free.argtypes = [POINTER(snd_sctl_t)]

# /usr/include/alsa/control.h:546
snd_sctl_install = _lib.snd_sctl_install
snd_sctl_install.restype = c_int
snd_sctl_install.argtypes = [POINTER(snd_sctl_t)]

# /usr/include/alsa/control.h:547
snd_sctl_remove = _lib.snd_sctl_remove
snd_sctl_remove.restype = c_int
snd_sctl_remove.argtypes = [POINTER(snd_sctl_t)]

class struct__snd_mixer(Structure):
    __slots__ = [
    ]
struct__snd_mixer._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_mixer(Structure):
    __slots__ = [
    ]
struct__snd_mixer._fields_ = [
    ('_opaque_struct', c_int)
]

snd_mixer_t = struct__snd_mixer 	# /usr/include/alsa/mixer.h:42
class struct__snd_mixer_class(Structure):
    __slots__ = [
    ]
struct__snd_mixer_class._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_mixer_class(Structure):
    __slots__ = [
    ]
struct__snd_mixer_class._fields_ = [
    ('_opaque_struct', c_int)
]

snd_mixer_class_t = struct__snd_mixer_class 	# /usr/include/alsa/mixer.h:44
class struct__snd_mixer_elem(Structure):
    __slots__ = [
    ]
struct__snd_mixer_elem._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_mixer_elem(Structure):
    __slots__ = [
    ]
struct__snd_mixer_elem._fields_ = [
    ('_opaque_struct', c_int)
]

snd_mixer_elem_t = struct__snd_mixer_elem 	# /usr/include/alsa/mixer.h:46
snd_mixer_callback_t = CFUNCTYPE(c_int, POINTER(snd_mixer_t), c_uint, POINTER(snd_mixer_elem_t)) 	# /usr/include/alsa/mixer.h:55
snd_mixer_elem_callback_t = CFUNCTYPE(c_int, POINTER(snd_mixer_elem_t), c_uint) 	# /usr/include/alsa/mixer.h:65
snd_mixer_compare_t = CFUNCTYPE(c_int, POINTER(snd_mixer_elem_t), POINTER(snd_mixer_elem_t)) 	# /usr/include/alsa/mixer.h:74
snd_mixer_event_t = CFUNCTYPE(c_int, POINTER(snd_mixer_class_t), c_uint, POINTER(snd_hctl_elem_t), POINTER(snd_mixer_elem_t)) 	# /usr/include/alsa/mixer.h:85
enum__snd_mixer_elem_type = c_int
SND_MIXER_ELEM_SIMPLE = 1
SND_MIXER_ELEM_LAST = 0
snd_mixer_elem_type_t = enum__snd_mixer_elem_type 	# /usr/include/alsa/mixer.h:94
# /usr/include/alsa/mixer.h:96
snd_mixer_open = _lib.snd_mixer_open
snd_mixer_open.restype = c_int
snd_mixer_open.argtypes = [POINTER(POINTER(snd_mixer_t)), c_int]

# /usr/include/alsa/mixer.h:97
snd_mixer_close = _lib.snd_mixer_close
snd_mixer_close.restype = c_int
snd_mixer_close.argtypes = [POINTER(snd_mixer_t)]

# /usr/include/alsa/mixer.h:98
snd_mixer_first_elem = _lib.snd_mixer_first_elem
snd_mixer_first_elem.restype = POINTER(snd_mixer_elem_t)
snd_mixer_first_elem.argtypes = [POINTER(snd_mixer_t)]

# /usr/include/alsa/mixer.h:99
snd_mixer_last_elem = _lib.snd_mixer_last_elem
snd_mixer_last_elem.restype = POINTER(snd_mixer_elem_t)
snd_mixer_last_elem.argtypes = [POINTER(snd_mixer_t)]

# /usr/include/alsa/mixer.h:100
snd_mixer_handle_events = _lib.snd_mixer_handle_events
snd_mixer_handle_events.restype = c_int
snd_mixer_handle_events.argtypes = [POINTER(snd_mixer_t)]

# /usr/include/alsa/mixer.h:101
snd_mixer_attach = _lib.snd_mixer_attach
snd_mixer_attach.restype = c_int
snd_mixer_attach.argtypes = [POINTER(snd_mixer_t), c_char_p]

# /usr/include/alsa/mixer.h:102
snd_mixer_attach_hctl = _lib.snd_mixer_attach_hctl
snd_mixer_attach_hctl.restype = c_int
snd_mixer_attach_hctl.argtypes = [POINTER(snd_mixer_t), POINTER(snd_hctl_t)]

# /usr/include/alsa/mixer.h:103
snd_mixer_detach = _lib.snd_mixer_detach
snd_mixer_detach.restype = c_int
snd_mixer_detach.argtypes = [POINTER(snd_mixer_t), c_char_p]

# /usr/include/alsa/mixer.h:104
snd_mixer_detach_hctl = _lib.snd_mixer_detach_hctl
snd_mixer_detach_hctl.restype = c_int
snd_mixer_detach_hctl.argtypes = [POINTER(snd_mixer_t), POINTER(snd_hctl_t)]

# /usr/include/alsa/mixer.h:105
snd_mixer_get_hctl = _lib.snd_mixer_get_hctl
snd_mixer_get_hctl.restype = c_int
snd_mixer_get_hctl.argtypes = [POINTER(snd_mixer_t), c_char_p, POINTER(POINTER(snd_hctl_t))]

# /usr/include/alsa/mixer.h:106
snd_mixer_poll_descriptors_count = _lib.snd_mixer_poll_descriptors_count
snd_mixer_poll_descriptors_count.restype = c_int
snd_mixer_poll_descriptors_count.argtypes = [POINTER(snd_mixer_t)]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/mixer.h:107
snd_mixer_poll_descriptors = _lib.snd_mixer_poll_descriptors
snd_mixer_poll_descriptors.restype = c_int
snd_mixer_poll_descriptors.argtypes = [POINTER(snd_mixer_t), POINTER(struct_pollfd), c_uint]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/mixer.h:108
snd_mixer_poll_descriptors_revents = _lib.snd_mixer_poll_descriptors_revents
snd_mixer_poll_descriptors_revents.restype = c_int
snd_mixer_poll_descriptors_revents.argtypes = [POINTER(snd_mixer_t), POINTER(struct_pollfd), c_uint, POINTER(c_ushort)]

# /usr/include/alsa/mixer.h:109
snd_mixer_load = _lib.snd_mixer_load
snd_mixer_load.restype = c_int
snd_mixer_load.argtypes = [POINTER(snd_mixer_t)]

# /usr/include/alsa/mixer.h:110
snd_mixer_free = _lib.snd_mixer_free
snd_mixer_free.restype = None
snd_mixer_free.argtypes = [POINTER(snd_mixer_t)]

# /usr/include/alsa/mixer.h:111
snd_mixer_wait = _lib.snd_mixer_wait
snd_mixer_wait.restype = c_int
snd_mixer_wait.argtypes = [POINTER(snd_mixer_t), c_int]

# /usr/include/alsa/mixer.h:112
snd_mixer_set_compare = _lib.snd_mixer_set_compare
snd_mixer_set_compare.restype = c_int
snd_mixer_set_compare.argtypes = [POINTER(snd_mixer_t), snd_mixer_compare_t]

# /usr/include/alsa/mixer.h:113
snd_mixer_set_callback = _lib.snd_mixer_set_callback
snd_mixer_set_callback.restype = None
snd_mixer_set_callback.argtypes = [POINTER(snd_mixer_t), snd_mixer_callback_t]

# /usr/include/alsa/mixer.h:114
snd_mixer_get_callback_private = _lib.snd_mixer_get_callback_private
snd_mixer_get_callback_private.restype = POINTER(c_void)
snd_mixer_get_callback_private.argtypes = [POINTER(snd_mixer_t)]

# /usr/include/alsa/mixer.h:115
snd_mixer_set_callback_private = _lib.snd_mixer_set_callback_private
snd_mixer_set_callback_private.restype = None
snd_mixer_set_callback_private.argtypes = [POINTER(snd_mixer_t), POINTER(None)]

# /usr/include/alsa/mixer.h:116
snd_mixer_get_count = _lib.snd_mixer_get_count
snd_mixer_get_count.restype = c_uint
snd_mixer_get_count.argtypes = [POINTER(snd_mixer_t)]

# /usr/include/alsa/mixer.h:117
snd_mixer_class_unregister = _lib.snd_mixer_class_unregister
snd_mixer_class_unregister.restype = c_int
snd_mixer_class_unregister.argtypes = [POINTER(snd_mixer_class_t)]

# /usr/include/alsa/mixer.h:119
snd_mixer_elem_next = _lib.snd_mixer_elem_next
snd_mixer_elem_next.restype = POINTER(snd_mixer_elem_t)
snd_mixer_elem_next.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:120
snd_mixer_elem_prev = _lib.snd_mixer_elem_prev
snd_mixer_elem_prev.restype = POINTER(snd_mixer_elem_t)
snd_mixer_elem_prev.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:121
snd_mixer_elem_set_callback = _lib.snd_mixer_elem_set_callback
snd_mixer_elem_set_callback.restype = None
snd_mixer_elem_set_callback.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_elem_callback_t]

# /usr/include/alsa/mixer.h:122
snd_mixer_elem_get_callback_private = _lib.snd_mixer_elem_get_callback_private
snd_mixer_elem_get_callback_private.restype = POINTER(c_void)
snd_mixer_elem_get_callback_private.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:123
snd_mixer_elem_set_callback_private = _lib.snd_mixer_elem_set_callback_private
snd_mixer_elem_set_callback_private.restype = None
snd_mixer_elem_set_callback_private.argtypes = [POINTER(snd_mixer_elem_t), POINTER(None)]

# /usr/include/alsa/mixer.h:124
snd_mixer_elem_get_type = _lib.snd_mixer_elem_get_type
snd_mixer_elem_get_type.restype = snd_mixer_elem_type_t
snd_mixer_elem_get_type.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:126
snd_mixer_class_register = _lib.snd_mixer_class_register
snd_mixer_class_register.restype = c_int
snd_mixer_class_register.argtypes = [POINTER(snd_mixer_class_t), POINTER(snd_mixer_t)]

'''
# XXX these two functions don't exist in my libasound.so
# /usr/include/alsa/mixer.h:127
snd_mixer_add_elem = _lib.snd_mixer_add_elem
snd_mixer_add_elem.restype = c_int
snd_mixer_add_elem.argtypes = [POINTER(snd_mixer_t), POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:128
snd_mixer_remove_elem = _lib.snd_mixer_remove_elem
snd_mixer_remove_elem.restype = c_int
snd_mixer_remove_elem.argtypes = [POINTER(snd_mixer_t), POINTER(snd_mixer_elem_t)]
'''

# /usr/include/alsa/mixer.h:129
snd_mixer_elem_new = _lib.snd_mixer_elem_new
snd_mixer_elem_new.restype = c_int
snd_mixer_elem_new.argtypes = [POINTER(POINTER(snd_mixer_elem_t)), snd_mixer_elem_type_t, c_int, POINTER(None), CFUNCTYPE(None, POINTER(snd_mixer_elem_t))]

# /usr/include/alsa/mixer.h:134
snd_mixer_elem_add = _lib.snd_mixer_elem_add
snd_mixer_elem_add.restype = c_int
snd_mixer_elem_add.argtypes = [POINTER(snd_mixer_elem_t), POINTER(snd_mixer_class_t)]

# /usr/include/alsa/mixer.h:135
snd_mixer_elem_remove = _lib.snd_mixer_elem_remove
snd_mixer_elem_remove.restype = c_int
snd_mixer_elem_remove.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:136
snd_mixer_elem_free = _lib.snd_mixer_elem_free
snd_mixer_elem_free.restype = None
snd_mixer_elem_free.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:137
snd_mixer_elem_info = _lib.snd_mixer_elem_info
snd_mixer_elem_info.restype = c_int
snd_mixer_elem_info.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:138
snd_mixer_elem_value = _lib.snd_mixer_elem_value
snd_mixer_elem_value.restype = c_int
snd_mixer_elem_value.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:139
snd_mixer_elem_attach = _lib.snd_mixer_elem_attach
snd_mixer_elem_attach.restype = c_int
snd_mixer_elem_attach.argtypes = [POINTER(snd_mixer_elem_t), POINTER(snd_hctl_elem_t)]

# /usr/include/alsa/mixer.h:140
snd_mixer_elem_detach = _lib.snd_mixer_elem_detach
snd_mixer_elem_detach.restype = c_int
snd_mixer_elem_detach.argtypes = [POINTER(snd_mixer_elem_t), POINTER(snd_hctl_elem_t)]

# /usr/include/alsa/mixer.h:141
snd_mixer_elem_empty = _lib.snd_mixer_elem_empty
snd_mixer_elem_empty.restype = c_int
snd_mixer_elem_empty.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:142
snd_mixer_elem_get_private = _lib.snd_mixer_elem_get_private
snd_mixer_elem_get_private.restype = POINTER(c_void)
snd_mixer_elem_get_private.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:144
snd_mixer_class_sizeof = _lib.snd_mixer_class_sizeof
snd_mixer_class_sizeof.restype = c_size_t
snd_mixer_class_sizeof.argtypes = []

# /usr/include/alsa/mixer.h:150
snd_mixer_class_malloc = _lib.snd_mixer_class_malloc
snd_mixer_class_malloc.restype = c_int
snd_mixer_class_malloc.argtypes = [POINTER(POINTER(snd_mixer_class_t))]

# /usr/include/alsa/mixer.h:151
snd_mixer_class_free = _lib.snd_mixer_class_free
snd_mixer_class_free.restype = None
snd_mixer_class_free.argtypes = [POINTER(snd_mixer_class_t)]

# /usr/include/alsa/mixer.h:152
snd_mixer_class_copy = _lib.snd_mixer_class_copy
snd_mixer_class_copy.restype = None
snd_mixer_class_copy.argtypes = [POINTER(snd_mixer_class_t), POINTER(snd_mixer_class_t)]

# /usr/include/alsa/mixer.h:153
snd_mixer_class_get_mixer = _lib.snd_mixer_class_get_mixer
snd_mixer_class_get_mixer.restype = POINTER(snd_mixer_t)
snd_mixer_class_get_mixer.argtypes = [POINTER(snd_mixer_class_t)]

# /usr/include/alsa/mixer.h:154
snd_mixer_class_get_event = _lib.snd_mixer_class_get_event
snd_mixer_class_get_event.restype = snd_mixer_event_t
snd_mixer_class_get_event.argtypes = [POINTER(snd_mixer_class_t)]

# /usr/include/alsa/mixer.h:155
snd_mixer_class_get_private = _lib.snd_mixer_class_get_private
snd_mixer_class_get_private.restype = POINTER(c_void)
snd_mixer_class_get_private.argtypes = [POINTER(snd_mixer_class_t)]

# /usr/include/alsa/mixer.h:156
snd_mixer_class_get_compare = _lib.snd_mixer_class_get_compare
snd_mixer_class_get_compare.restype = snd_mixer_compare_t
snd_mixer_class_get_compare.argtypes = [POINTER(snd_mixer_class_t)]

# /usr/include/alsa/mixer.h:157
snd_mixer_class_set_event = _lib.snd_mixer_class_set_event
snd_mixer_class_set_event.restype = c_int
snd_mixer_class_set_event.argtypes = [POINTER(snd_mixer_class_t), snd_mixer_event_t]

# /usr/include/alsa/mixer.h:158
snd_mixer_class_set_private = _lib.snd_mixer_class_set_private
snd_mixer_class_set_private.restype = c_int
snd_mixer_class_set_private.argtypes = [POINTER(snd_mixer_class_t), POINTER(None)]

# /usr/include/alsa/mixer.h:159
snd_mixer_class_set_private_free = _lib.snd_mixer_class_set_private_free
snd_mixer_class_set_private_free.restype = c_int
snd_mixer_class_set_private_free.argtypes = [POINTER(snd_mixer_class_t), CFUNCTYPE(None, POINTER(snd_mixer_class_t))]

# /usr/include/alsa/mixer.h:160
snd_mixer_class_set_compare = _lib.snd_mixer_class_set_compare
snd_mixer_class_set_compare.restype = c_int
snd_mixer_class_set_compare.argtypes = [POINTER(snd_mixer_class_t), snd_mixer_compare_t]

enum__snd_mixer_selem_channel_id = c_int
SND_MIXER_SCHN_UNKNOWN = 1
SND_MIXER_SCHN_FRONT_LEFT = 0
SND_MIXER_SCHN_FRONT_RIGHT = 1
SND_MIXER_SCHN_REAR_LEFT = 2
SND_MIXER_SCHN_REAR_RIGHT = 3
SND_MIXER_SCHN_FRONT_CENTER = 4
SND_MIXER_SCHN_WOOFER = 5
SND_MIXER_SCHN_SIDE_LEFT = 6
SND_MIXER_SCHN_SIDE_RIGHT = 7
SND_MIXER_SCHN_REAR_CENTER = 8
SND_MIXER_SCHN_LAST = 31
SND_MIXER_SCHN_MONO = 0
snd_mixer_selem_channel_id_t = enum__snd_mixer_selem_channel_id 	# /usr/include/alsa/mixer.h:196
class struct__snd_mixer_selem_id(Structure):
    __slots__ = [
    ]
struct__snd_mixer_selem_id._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_mixer_selem_id(Structure):
    __slots__ = [
    ]
struct__snd_mixer_selem_id._fields_ = [
    ('_opaque_struct', c_int)
]

snd_mixer_selem_id_t = struct__snd_mixer_selem_id 	# /usr/include/alsa/mixer.h:221
# /usr/include/alsa/mixer.h:223
snd_mixer_selem_channel_name = _lib.snd_mixer_selem_channel_name
snd_mixer_selem_channel_name.restype = c_char_p
snd_mixer_selem_channel_name.argtypes = [snd_mixer_selem_channel_id_t]

class struct_snd_mixer_selem_regopt(Structure):
    __slots__ = [
    ]
struct_snd_mixer_selem_regopt._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/mixer.h:225
snd_mixer_selem_register = _lib.snd_mixer_selem_register
snd_mixer_selem_register.restype = c_int
snd_mixer_selem_register.argtypes = [POINTER(snd_mixer_t), POINTER(struct_snd_mixer_selem_regopt), POINTER(POINTER(snd_mixer_class_t))]

# /usr/include/alsa/mixer.h:228
snd_mixer_selem_get_id = _lib.snd_mixer_selem_get_id
snd_mixer_selem_get_id.restype = None
snd_mixer_selem_get_id.argtypes = [POINTER(snd_mixer_elem_t), POINTER(snd_mixer_selem_id_t)]

# /usr/include/alsa/mixer.h:230
snd_mixer_selem_get_name = _lib.snd_mixer_selem_get_name
snd_mixer_selem_get_name.restype = c_char_p
snd_mixer_selem_get_name.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:231
snd_mixer_selem_get_index = _lib.snd_mixer_selem_get_index
snd_mixer_selem_get_index.restype = c_uint
snd_mixer_selem_get_index.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:232
snd_mixer_find_selem = _lib.snd_mixer_find_selem
snd_mixer_find_selem.restype = POINTER(snd_mixer_elem_t)
snd_mixer_find_selem.argtypes = [POINTER(snd_mixer_t), POINTER(snd_mixer_selem_id_t)]

# /usr/include/alsa/mixer.h:235
snd_mixer_selem_is_active = _lib.snd_mixer_selem_is_active
snd_mixer_selem_is_active.restype = c_int
snd_mixer_selem_is_active.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:236
snd_mixer_selem_is_playback_mono = _lib.snd_mixer_selem_is_playback_mono
snd_mixer_selem_is_playback_mono.restype = c_int
snd_mixer_selem_is_playback_mono.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:237
snd_mixer_selem_has_playback_channel = _lib.snd_mixer_selem_has_playback_channel
snd_mixer_selem_has_playback_channel.restype = c_int
snd_mixer_selem_has_playback_channel.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t]

# /usr/include/alsa/mixer.h:238
snd_mixer_selem_is_capture_mono = _lib.snd_mixer_selem_is_capture_mono
snd_mixer_selem_is_capture_mono.restype = c_int
snd_mixer_selem_is_capture_mono.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:239
snd_mixer_selem_has_capture_channel = _lib.snd_mixer_selem_has_capture_channel
snd_mixer_selem_has_capture_channel.restype = c_int
snd_mixer_selem_has_capture_channel.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t]

# /usr/include/alsa/mixer.h:240
snd_mixer_selem_get_capture_group = _lib.snd_mixer_selem_get_capture_group
snd_mixer_selem_get_capture_group.restype = c_int
snd_mixer_selem_get_capture_group.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:241
snd_mixer_selem_has_common_volume = _lib.snd_mixer_selem_has_common_volume
snd_mixer_selem_has_common_volume.restype = c_int
snd_mixer_selem_has_common_volume.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:242
snd_mixer_selem_has_playback_volume = _lib.snd_mixer_selem_has_playback_volume
snd_mixer_selem_has_playback_volume.restype = c_int
snd_mixer_selem_has_playback_volume.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:243
snd_mixer_selem_has_playback_volume_joined = _lib.snd_mixer_selem_has_playback_volume_joined
snd_mixer_selem_has_playback_volume_joined.restype = c_int
snd_mixer_selem_has_playback_volume_joined.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:244
snd_mixer_selem_has_capture_volume = _lib.snd_mixer_selem_has_capture_volume
snd_mixer_selem_has_capture_volume.restype = c_int
snd_mixer_selem_has_capture_volume.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:245
snd_mixer_selem_has_capture_volume_joined = _lib.snd_mixer_selem_has_capture_volume_joined
snd_mixer_selem_has_capture_volume_joined.restype = c_int
snd_mixer_selem_has_capture_volume_joined.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:246
snd_mixer_selem_has_common_switch = _lib.snd_mixer_selem_has_common_switch
snd_mixer_selem_has_common_switch.restype = c_int
snd_mixer_selem_has_common_switch.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:247
snd_mixer_selem_has_playback_switch = _lib.snd_mixer_selem_has_playback_switch
snd_mixer_selem_has_playback_switch.restype = c_int
snd_mixer_selem_has_playback_switch.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:248
snd_mixer_selem_has_playback_switch_joined = _lib.snd_mixer_selem_has_playback_switch_joined
snd_mixer_selem_has_playback_switch_joined.restype = c_int
snd_mixer_selem_has_playback_switch_joined.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:249
snd_mixer_selem_has_capture_switch = _lib.snd_mixer_selem_has_capture_switch
snd_mixer_selem_has_capture_switch.restype = c_int
snd_mixer_selem_has_capture_switch.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:250
snd_mixer_selem_has_capture_switch_joined = _lib.snd_mixer_selem_has_capture_switch_joined
snd_mixer_selem_has_capture_switch_joined.restype = c_int
snd_mixer_selem_has_capture_switch_joined.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:251
snd_mixer_selem_has_capture_switch_exclusive = _lib.snd_mixer_selem_has_capture_switch_exclusive
snd_mixer_selem_has_capture_switch_exclusive.restype = c_int
snd_mixer_selem_has_capture_switch_exclusive.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:253
snd_mixer_selem_get_playback_volume = _lib.snd_mixer_selem_get_playback_volume
snd_mixer_selem_get_playback_volume.restype = c_int
snd_mixer_selem_get_playback_volume.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t, POINTER(c_long)]

# /usr/include/alsa/mixer.h:254
snd_mixer_selem_get_capture_volume = _lib.snd_mixer_selem_get_capture_volume
snd_mixer_selem_get_capture_volume.restype = c_int
snd_mixer_selem_get_capture_volume.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t, POINTER(c_long)]

# /usr/include/alsa/mixer.h:255
snd_mixer_selem_get_playback_dB = _lib.snd_mixer_selem_get_playback_dB
snd_mixer_selem_get_playback_dB.restype = c_int
snd_mixer_selem_get_playback_dB.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t, POINTER(c_long)]

# /usr/include/alsa/mixer.h:256
snd_mixer_selem_get_capture_dB = _lib.snd_mixer_selem_get_capture_dB
snd_mixer_selem_get_capture_dB.restype = c_int
snd_mixer_selem_get_capture_dB.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t, POINTER(c_long)]

# /usr/include/alsa/mixer.h:257
snd_mixer_selem_get_playback_switch = _lib.snd_mixer_selem_get_playback_switch
snd_mixer_selem_get_playback_switch.restype = c_int
snd_mixer_selem_get_playback_switch.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t, POINTER(c_int)]

# /usr/include/alsa/mixer.h:258
snd_mixer_selem_get_capture_switch = _lib.snd_mixer_selem_get_capture_switch
snd_mixer_selem_get_capture_switch.restype = c_int
snd_mixer_selem_get_capture_switch.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t, POINTER(c_int)]

# /usr/include/alsa/mixer.h:259
snd_mixer_selem_set_playback_volume = _lib.snd_mixer_selem_set_playback_volume
snd_mixer_selem_set_playback_volume.restype = c_int
snd_mixer_selem_set_playback_volume.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t, c_long]

# /usr/include/alsa/mixer.h:260
snd_mixer_selem_set_capture_volume = _lib.snd_mixer_selem_set_capture_volume
snd_mixer_selem_set_capture_volume.restype = c_int
snd_mixer_selem_set_capture_volume.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t, c_long]

# /usr/include/alsa/mixer.h:261
snd_mixer_selem_set_playback_dB = _lib.snd_mixer_selem_set_playback_dB
snd_mixer_selem_set_playback_dB.restype = c_int
snd_mixer_selem_set_playback_dB.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t, c_long, c_int]

# /usr/include/alsa/mixer.h:262
snd_mixer_selem_set_capture_dB = _lib.snd_mixer_selem_set_capture_dB
snd_mixer_selem_set_capture_dB.restype = c_int
snd_mixer_selem_set_capture_dB.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t, c_long, c_int]

# /usr/include/alsa/mixer.h:263
snd_mixer_selem_set_playback_volume_all = _lib.snd_mixer_selem_set_playback_volume_all
snd_mixer_selem_set_playback_volume_all.restype = c_int
snd_mixer_selem_set_playback_volume_all.argtypes = [POINTER(snd_mixer_elem_t), c_long]

# /usr/include/alsa/mixer.h:264
snd_mixer_selem_set_capture_volume_all = _lib.snd_mixer_selem_set_capture_volume_all
snd_mixer_selem_set_capture_volume_all.restype = c_int
snd_mixer_selem_set_capture_volume_all.argtypes = [POINTER(snd_mixer_elem_t), c_long]

# /usr/include/alsa/mixer.h:265
snd_mixer_selem_set_playback_dB_all = _lib.snd_mixer_selem_set_playback_dB_all
snd_mixer_selem_set_playback_dB_all.restype = c_int
snd_mixer_selem_set_playback_dB_all.argtypes = [POINTER(snd_mixer_elem_t), c_long, c_int]

# /usr/include/alsa/mixer.h:266
snd_mixer_selem_set_capture_dB_all = _lib.snd_mixer_selem_set_capture_dB_all
snd_mixer_selem_set_capture_dB_all.restype = c_int
snd_mixer_selem_set_capture_dB_all.argtypes = [POINTER(snd_mixer_elem_t), c_long, c_int]

# /usr/include/alsa/mixer.h:267
snd_mixer_selem_set_playback_switch = _lib.snd_mixer_selem_set_playback_switch
snd_mixer_selem_set_playback_switch.restype = c_int
snd_mixer_selem_set_playback_switch.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t, c_int]

# /usr/include/alsa/mixer.h:268
snd_mixer_selem_set_capture_switch = _lib.snd_mixer_selem_set_capture_switch
snd_mixer_selem_set_capture_switch.restype = c_int
snd_mixer_selem_set_capture_switch.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t, c_int]

# /usr/include/alsa/mixer.h:269
snd_mixer_selem_set_playback_switch_all = _lib.snd_mixer_selem_set_playback_switch_all
snd_mixer_selem_set_playback_switch_all.restype = c_int
snd_mixer_selem_set_playback_switch_all.argtypes = [POINTER(snd_mixer_elem_t), c_int]

# /usr/include/alsa/mixer.h:270
snd_mixer_selem_set_capture_switch_all = _lib.snd_mixer_selem_set_capture_switch_all
snd_mixer_selem_set_capture_switch_all.restype = c_int
snd_mixer_selem_set_capture_switch_all.argtypes = [POINTER(snd_mixer_elem_t), c_int]

# /usr/include/alsa/mixer.h:271
snd_mixer_selem_get_playback_volume_range = _lib.snd_mixer_selem_get_playback_volume_range
snd_mixer_selem_get_playback_volume_range.restype = c_int
snd_mixer_selem_get_playback_volume_range.argtypes = [POINTER(snd_mixer_elem_t), POINTER(c_long), POINTER(c_long)]

# /usr/include/alsa/mixer.h:273
snd_mixer_selem_get_playback_dB_range = _lib.snd_mixer_selem_get_playback_dB_range
snd_mixer_selem_get_playback_dB_range.restype = c_int
snd_mixer_selem_get_playback_dB_range.argtypes = [POINTER(snd_mixer_elem_t), POINTER(c_long), POINTER(c_long)]

# /usr/include/alsa/mixer.h:275
snd_mixer_selem_set_playback_volume_range = _lib.snd_mixer_selem_set_playback_volume_range
snd_mixer_selem_set_playback_volume_range.restype = c_int
snd_mixer_selem_set_playback_volume_range.argtypes = [POINTER(snd_mixer_elem_t), c_long, c_long]

# /usr/include/alsa/mixer.h:277
snd_mixer_selem_get_capture_volume_range = _lib.snd_mixer_selem_get_capture_volume_range
snd_mixer_selem_get_capture_volume_range.restype = c_int
snd_mixer_selem_get_capture_volume_range.argtypes = [POINTER(snd_mixer_elem_t), POINTER(c_long), POINTER(c_long)]

# /usr/include/alsa/mixer.h:279
snd_mixer_selem_get_capture_dB_range = _lib.snd_mixer_selem_get_capture_dB_range
snd_mixer_selem_get_capture_dB_range.restype = c_int
snd_mixer_selem_get_capture_dB_range.argtypes = [POINTER(snd_mixer_elem_t), POINTER(c_long), POINTER(c_long)]

# /usr/include/alsa/mixer.h:281
snd_mixer_selem_set_capture_volume_range = _lib.snd_mixer_selem_set_capture_volume_range
snd_mixer_selem_set_capture_volume_range.restype = c_int
snd_mixer_selem_set_capture_volume_range.argtypes = [POINTER(snd_mixer_elem_t), c_long, c_long]

# /usr/include/alsa/mixer.h:284
snd_mixer_selem_is_enumerated = _lib.snd_mixer_selem_is_enumerated
snd_mixer_selem_is_enumerated.restype = c_int
snd_mixer_selem_is_enumerated.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:285
snd_mixer_selem_is_enum_playback = _lib.snd_mixer_selem_is_enum_playback
snd_mixer_selem_is_enum_playback.restype = c_int
snd_mixer_selem_is_enum_playback.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:286
snd_mixer_selem_is_enum_capture = _lib.snd_mixer_selem_is_enum_capture
snd_mixer_selem_is_enum_capture.restype = c_int
snd_mixer_selem_is_enum_capture.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:287
snd_mixer_selem_get_enum_items = _lib.snd_mixer_selem_get_enum_items
snd_mixer_selem_get_enum_items.restype = c_int
snd_mixer_selem_get_enum_items.argtypes = [POINTER(snd_mixer_elem_t)]

# /usr/include/alsa/mixer.h:288
snd_mixer_selem_get_enum_item_name = _lib.snd_mixer_selem_get_enum_item_name
snd_mixer_selem_get_enum_item_name.restype = c_int
snd_mixer_selem_get_enum_item_name.argtypes = [POINTER(snd_mixer_elem_t), c_uint, c_size_t, c_char_p]

# /usr/include/alsa/mixer.h:289
snd_mixer_selem_get_enum_item = _lib.snd_mixer_selem_get_enum_item
snd_mixer_selem_get_enum_item.restype = c_int
snd_mixer_selem_get_enum_item.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t, POINTER(c_uint)]

# /usr/include/alsa/mixer.h:290
snd_mixer_selem_set_enum_item = _lib.snd_mixer_selem_set_enum_item
snd_mixer_selem_set_enum_item.restype = c_int
snd_mixer_selem_set_enum_item.argtypes = [POINTER(snd_mixer_elem_t), snd_mixer_selem_channel_id_t, c_uint]

# /usr/include/alsa/mixer.h:292
snd_mixer_selem_id_sizeof = _lib.snd_mixer_selem_id_sizeof
snd_mixer_selem_id_sizeof.restype = c_size_t
snd_mixer_selem_id_sizeof.argtypes = []

# /usr/include/alsa/mixer.h:298
snd_mixer_selem_id_malloc = _lib.snd_mixer_selem_id_malloc
snd_mixer_selem_id_malloc.restype = c_int
snd_mixer_selem_id_malloc.argtypes = [POINTER(POINTER(snd_mixer_selem_id_t))]

# /usr/include/alsa/mixer.h:299
snd_mixer_selem_id_free = _lib.snd_mixer_selem_id_free
snd_mixer_selem_id_free.restype = None
snd_mixer_selem_id_free.argtypes = [POINTER(snd_mixer_selem_id_t)]

# /usr/include/alsa/mixer.h:300
snd_mixer_selem_id_copy = _lib.snd_mixer_selem_id_copy
snd_mixer_selem_id_copy.restype = None
snd_mixer_selem_id_copy.argtypes = [POINTER(snd_mixer_selem_id_t), POINTER(snd_mixer_selem_id_t)]

# /usr/include/alsa/mixer.h:301
snd_mixer_selem_id_get_name = _lib.snd_mixer_selem_id_get_name
snd_mixer_selem_id_get_name.restype = c_char_p
snd_mixer_selem_id_get_name.argtypes = [POINTER(snd_mixer_selem_id_t)]

# /usr/include/alsa/mixer.h:302
snd_mixer_selem_id_get_index = _lib.snd_mixer_selem_id_get_index
snd_mixer_selem_id_get_index.restype = c_uint
snd_mixer_selem_id_get_index.argtypes = [POINTER(snd_mixer_selem_id_t)]

# /usr/include/alsa/mixer.h:303
snd_mixer_selem_id_set_name = _lib.snd_mixer_selem_id_set_name
snd_mixer_selem_id_set_name.restype = None
snd_mixer_selem_id_set_name.argtypes = [POINTER(snd_mixer_selem_id_t), c_char_p]

# /usr/include/alsa/mixer.h:304
snd_mixer_selem_id_set_index = _lib.snd_mixer_selem_id_set_index
snd_mixer_selem_id_set_index.restype = None
snd_mixer_selem_id_set_index.argtypes = [POINTER(snd_mixer_selem_id_t), c_uint]

snd_seq_event_type_t = c_ubyte 	# /usr/include/alsa/seq_event.h:41
class struct_snd_seq_addr(Structure):
    __slots__ = [
        'client',
        'port',
    ]
struct_snd_seq_addr._fields_ = [
    ('client', c_ubyte),
    ('port', c_ubyte),
]

snd_seq_addr_t = struct_snd_seq_addr 	# /usr/include/alsa/seq_event.h:239
class struct_snd_seq_connect(Structure):
    __slots__ = [
        'sender',
        'dest',
    ]
struct_snd_seq_connect._fields_ = [
    ('sender', snd_seq_addr_t),
    ('dest', snd_seq_addr_t),
]

snd_seq_connect_t = struct_snd_seq_connect 	# /usr/include/alsa/seq_event.h:245
class struct_snd_seq_real_time(Structure):
    __slots__ = [
        'tv_sec',
        'tv_nsec',
    ]
struct_snd_seq_real_time._fields_ = [
    ('tv_sec', c_uint),
    ('tv_nsec', c_uint),
]

snd_seq_real_time_t = struct_snd_seq_real_time 	# /usr/include/alsa/seq_event.h:252
snd_seq_tick_time_t = c_uint 	# /usr/include/alsa/seq_event.h:255
class struct_snd_seq_timestamp(Union):
    __slots__ = [
        'tick',
        'time',
    ]
struct_snd_seq_timestamp._fields_ = [
    ('tick', snd_seq_tick_time_t),
    ('time', struct_snd_seq_real_time),
]

snd_seq_timestamp_t = struct_snd_seq_timestamp 	# /usr/include/alsa/seq_event.h:261
SND_SEQ_TIME_STAMP_TICK = 0 	# /usr/include/alsa/seq_event.h:269
SND_SEQ_TIME_STAMP_REAL = 1 	# /usr/include/alsa/seq_event.h:270
SND_SEQ_TIME_STAMP_MASK = 1 	# /usr/include/alsa/seq_event.h:271
SND_SEQ_TIME_MODE_ABS = 0 	# /usr/include/alsa/seq_event.h:273
SND_SEQ_TIME_MODE_REL = 2 	# /usr/include/alsa/seq_event.h:274
SND_SEQ_TIME_MODE_MASK = 2 	# /usr/include/alsa/seq_event.h:275
SND_SEQ_EVENT_LENGTH_FIXED = 0 	# /usr/include/alsa/seq_event.h:277
SND_SEQ_EVENT_LENGTH_VARIABLE = 4 	# /usr/include/alsa/seq_event.h:278
SND_SEQ_EVENT_LENGTH_VARUSR = 8 	# /usr/include/alsa/seq_event.h:279
SND_SEQ_EVENT_LENGTH_MASK = 12 	# /usr/include/alsa/seq_event.h:280
SND_SEQ_PRIORITY_NORMAL = 0 	# /usr/include/alsa/seq_event.h:282
SND_SEQ_PRIORITY_HIGH = 16 	# /usr/include/alsa/seq_event.h:283
SND_SEQ_PRIORITY_MASK = 16 	# /usr/include/alsa/seq_event.h:284
class struct_snd_seq_ev_note(Structure):
    __slots__ = [
        'channel',
        'note',
        'velocity',
        'off_velocity',
        'duration',
    ]
struct_snd_seq_ev_note._fields_ = [
    ('channel', c_ubyte),
    ('note', c_ubyte),
    ('velocity', c_ubyte),
    ('off_velocity', c_ubyte),
    ('duration', c_uint),
]

snd_seq_ev_note_t = struct_snd_seq_ev_note 	# /usr/include/alsa/seq_event.h:294
class struct_snd_seq_ev_ctrl(Structure):
    __slots__ = [
        'channel',
        'unused',
        'param',
        'value',
    ]
struct_snd_seq_ev_ctrl._fields_ = [
    ('channel', c_ubyte),
    ('unused', c_ubyte * 3),
    ('param', c_uint),
    ('value', c_int),
]

snd_seq_ev_ctrl_t = struct_snd_seq_ev_ctrl 	# /usr/include/alsa/seq_event.h:302
class struct_snd_seq_ev_raw8(Structure):
    __slots__ = [
        'd',
    ]
struct_snd_seq_ev_raw8._fields_ = [
    ('d', c_ubyte * 12),
]

snd_seq_ev_raw8_t = struct_snd_seq_ev_raw8 	# /usr/include/alsa/seq_event.h:307
class struct_snd_seq_ev_raw32(Structure):
    __slots__ = [
        'd',
    ]
struct_snd_seq_ev_raw32._fields_ = [
    ('d', c_uint * 3),
]

snd_seq_ev_raw32_t = struct_snd_seq_ev_raw32 	# /usr/include/alsa/seq_event.h:312
class struct_snd_seq_ev_ext(Structure):
    __slots__ = [
        'len',
        'ptr',
    ]
struct_snd_seq_ev_ext._fields_ = [
    ('len', c_uint),
    ('ptr', POINTER(None)),
]

snd_seq_ev_ext_t = struct_snd_seq_ev_ext 	# /usr/include/alsa/seq_event.h:318
snd_seq_instr_cluster_t = c_uint 	# /usr/include/alsa/seq_event.h:321
class struct_snd_seq_instr(Structure):
    __slots__ = [
        'cluster',
        'std',
        'bank',
        'prg',
    ]
struct_snd_seq_instr._fields_ = [
    ('cluster', snd_seq_instr_cluster_t),
    ('std', c_uint),
    ('bank', c_ushort),
    ('prg', c_ushort),
]

snd_seq_instr_t = struct_snd_seq_instr 	# /usr/include/alsa/seq_event.h:329
class struct_snd_seq_ev_sample(Structure):
    __slots__ = [
        'std',
        'bank',
        'prg',
    ]
struct_snd_seq_ev_sample._fields_ = [
    ('std', c_uint),
    ('bank', c_ushort),
    ('prg', c_ushort),
]

snd_seq_ev_sample_t = struct_snd_seq_ev_sample 	# /usr/include/alsa/seq_event.h:336
class struct_snd_seq_ev_cluster(Structure):
    __slots__ = [
        'cluster',
    ]
struct_snd_seq_ev_cluster._fields_ = [
    ('cluster', snd_seq_instr_cluster_t),
]

snd_seq_ev_cluster_t = struct_snd_seq_ev_cluster 	# /usr/include/alsa/seq_event.h:341
snd_seq_position_t = c_uint 	# /usr/include/alsa/seq_event.h:344
enum_snd_seq_stop_mode = c_int
SND_SEQ_SAMPLE_STOP_IMMEDIATELY = 0
SND_SEQ_SAMPLE_STOP_VENVELOPE = 1
SND_SEQ_SAMPLE_STOP_LOOP = 2
snd_seq_stop_mode_t = enum_snd_seq_stop_mode 	# /usr/include/alsa/seq_event.h:351
snd_seq_frequency_t = c_int 	# /usr/include/alsa/seq_event.h:354
class struct_snd_seq_ev_volume(Structure):
    __slots__ = [
        'volume',
        'lr',
        'fr',
        'du',
    ]
struct_snd_seq_ev_volume._fields_ = [
    ('volume', c_short),
    ('lr', c_short),
    ('fr', c_short),
    ('du', c_short),
]

snd_seq_ev_volume_t = struct_snd_seq_ev_volume 	# /usr/include/alsa/seq_event.h:362
class struct_snd_seq_ev_loop(Structure):
    __slots__ = [
        'start',
        'end',
    ]
struct_snd_seq_ev_loop._fields_ = [
    ('start', c_uint),
    ('end', c_uint),
]

snd_seq_ev_loop_t = struct_snd_seq_ev_loop 	# /usr/include/alsa/seq_event.h:368
class struct_snd_seq_ev_sample_control(Structure):
    __slots__ = [
        'channel',
        'unused',
        'param',
    ]
class struct_anon_27(Union):
    __slots__ = [
        'sample',
        'cluster',
        'position',
        'stop_mode',
        'frequency',
        'volume',
        'loop',
        'raw8',
    ]
struct_anon_27._fields_ = [
    ('sample', snd_seq_ev_sample_t),
    ('cluster', snd_seq_ev_cluster_t),
    ('position', snd_seq_position_t),
    ('stop_mode', snd_seq_stop_mode_t),
    ('frequency', snd_seq_frequency_t),
    ('volume', snd_seq_ev_volume_t),
    ('loop', snd_seq_ev_loop_t),
    ('raw8', c_ubyte * 8),
]

struct_snd_seq_ev_sample_control._fields_ = [
    ('channel', c_ubyte),
    ('unused', c_ubyte * 3),
    ('param', struct_anon_27),
]

snd_seq_ev_sample_control_t = struct_snd_seq_ev_sample_control 	# /usr/include/alsa/seq_event.h:384
class struct_snd_seq_ev_instr_begin(Structure):
    __slots__ = [
        'timeout',
    ]
struct_snd_seq_ev_instr_begin._fields_ = [
    ('timeout', c_int),
]

snd_seq_ev_instr_begin_t = struct_snd_seq_ev_instr_begin 	# /usr/include/alsa/seq_event.h:391
class struct_snd_seq_result(Structure):
    __slots__ = [
        'event',
        'result',
    ]
struct_snd_seq_result._fields_ = [
    ('event', c_int),
    ('result', c_int),
]

snd_seq_result_t = struct_snd_seq_result 	# /usr/include/alsa/seq_event.h:397
class struct_snd_seq_queue_skew(Structure):
    __slots__ = [
        'value',
        'base',
    ]
struct_snd_seq_queue_skew._fields_ = [
    ('value', c_uint),
    ('base', c_uint),
]

snd_seq_queue_skew_t = struct_snd_seq_queue_skew 	# /usr/include/alsa/seq_event.h:403
class struct_snd_seq_ev_queue_control(Structure):
    __slots__ = [
        'queue',
        'unused',
        'param',
    ]
class struct_anon_28(Union):
    __slots__ = [
        'value',
        'time',
        'position',
        'skew',
        'd32',
        'd8',
    ]
struct_anon_28._fields_ = [
    ('value', c_int),
    ('time', snd_seq_timestamp_t),
    ('position', c_uint),
    ('skew', snd_seq_queue_skew_t),
    ('d32', c_uint * 2),
    ('d8', c_ubyte * 8),
]

struct_snd_seq_ev_queue_control._fields_ = [
    ('queue', c_ubyte),
    ('unused', c_ubyte * 3),
    ('param', struct_anon_28),
]

snd_seq_ev_queue_control_t = struct_snd_seq_ev_queue_control 	# /usr/include/alsa/seq_event.h:417
class struct_snd_seq_event(Structure):
    __slots__ = [
        'type',
        'flags',
        'tag',
        'queue',
        'time',
        'source',
        'dest',
        'data',
    ]
class struct_anon_29(Union):
    __slots__ = [
        'note',
        'control',
        'raw8',
        'raw32',
        'ext',
        'queue',
        'time',
        'addr',
        'connect',
        'result',
        'instr_begin',
        'sample',
    ]
struct_anon_29._fields_ = [
    ('note', snd_seq_ev_note_t),
    ('control', snd_seq_ev_ctrl_t),
    ('raw8', snd_seq_ev_raw8_t),
    ('raw32', snd_seq_ev_raw32_t),
    ('ext', snd_seq_ev_ext_t),
    ('queue', snd_seq_ev_queue_control_t),
    ('time', snd_seq_timestamp_t),
    ('addr', snd_seq_addr_t),
    ('connect', snd_seq_connect_t),
    ('result', snd_seq_result_t),
    ('instr_begin', snd_seq_ev_instr_begin_t),
    ('sample', snd_seq_ev_sample_control_t),
]

struct_snd_seq_event._fields_ = [
    ('type', snd_seq_event_type_t),
    ('flags', c_ubyte),
    ('tag', c_ubyte),
    ('queue', c_ubyte),
    ('time', snd_seq_timestamp_t),
    ('source', snd_seq_addr_t),
    ('dest', snd_seq_addr_t),
    ('data', struct_anon_29),
]

snd_seq_event_t = struct_snd_seq_event 	# /usr/include/alsa/seq_event.h:446
SND_SEQ_DLSYM_VERSION = 0 	# /usr/include/alsa/seq.h:44
class struct__snd_seq(Structure):
    __slots__ = [
    ]
struct__snd_seq._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_seq(Structure):
    __slots__ = [
    ]
struct__snd_seq._fields_ = [
    ('_opaque_struct', c_int)
]

snd_seq_t = struct__snd_seq 	# /usr/include/alsa/seq.h:47
SND_SEQ_OPEN_OUTPUT = 1 	# /usr/include/alsa/seq.h:61
SND_SEQ_OPEN_INPUT = 2 	# /usr/include/alsa/seq.h:62
SND_SEQ_OPEN_DUPLEX = 3 	# /usr/include/alsa/seq.h:63
SND_SEQ_NONBLOCK = 1 	# /usr/include/alsa/seq.h:68
enum__snd_seq_type = c_int
SND_SEQ_TYPE_HW = 1
SND_SEQ_TYPE_SHM = 2
SND_SEQ_TYPE_INET = 3
snd_seq_type_t = enum__snd_seq_type 	# /usr/include/alsa/seq.h:75
SND_SEQ_ADDRESS_UNKNOWN = 253 	# /usr/include/alsa/seq.h:78
SND_SEQ_ADDRESS_SUBSCRIBERS = 254 	# /usr/include/alsa/seq.h:79
SND_SEQ_ADDRESS_BROADCAST = 255 	# /usr/include/alsa/seq.h:80
SND_SEQ_CLIENT_SYSTEM = 0 	# /usr/include/alsa/seq.h:83
# /usr/include/alsa/seq.h:87
snd_seq_open = _lib.snd_seq_open
snd_seq_open.restype = c_int
snd_seq_open.argtypes = [POINTER(POINTER(snd_seq_t)), c_char_p, c_int, c_int]

# /usr/include/alsa/seq.h:88
snd_seq_open_lconf = _lib.snd_seq_open_lconf
snd_seq_open_lconf.restype = c_int
snd_seq_open_lconf.argtypes = [POINTER(POINTER(snd_seq_t)), c_char_p, c_int, c_int, POINTER(snd_config_t)]

# /usr/include/alsa/seq.h:89
snd_seq_name = _lib.snd_seq_name
snd_seq_name.restype = c_char_p
snd_seq_name.argtypes = [POINTER(snd_seq_t)]

# /usr/include/alsa/seq.h:90
snd_seq_type = _lib.snd_seq_type
snd_seq_type.restype = snd_seq_type_t
snd_seq_type.argtypes = [POINTER(snd_seq_t)]

# /usr/include/alsa/seq.h:91
snd_seq_close = _lib.snd_seq_close
snd_seq_close.restype = c_int
snd_seq_close.argtypes = [POINTER(snd_seq_t)]

# /usr/include/alsa/seq.h:92
snd_seq_poll_descriptors_count = _lib.snd_seq_poll_descriptors_count
snd_seq_poll_descriptors_count.restype = c_int
snd_seq_poll_descriptors_count.argtypes = [POINTER(snd_seq_t), c_short]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/seq.h:93
snd_seq_poll_descriptors = _lib.snd_seq_poll_descriptors
snd_seq_poll_descriptors.restype = c_int
snd_seq_poll_descriptors.argtypes = [POINTER(snd_seq_t), POINTER(struct_pollfd), c_uint, c_short]

class struct_pollfd(Structure):
    __slots__ = [
    ]
struct_pollfd._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/alsa/seq.h:94
snd_seq_poll_descriptors_revents = _lib.snd_seq_poll_descriptors_revents
snd_seq_poll_descriptors_revents.restype = c_int
snd_seq_poll_descriptors_revents.argtypes = [POINTER(snd_seq_t), POINTER(struct_pollfd), c_uint, POINTER(c_ushort)]

# /usr/include/alsa/seq.h:95
snd_seq_nonblock = _lib.snd_seq_nonblock
snd_seq_nonblock.restype = c_int
snd_seq_nonblock.argtypes = [POINTER(snd_seq_t), c_int]

# /usr/include/alsa/seq.h:96
snd_seq_client_id = _lib.snd_seq_client_id
snd_seq_client_id.restype = c_int
snd_seq_client_id.argtypes = [POINTER(snd_seq_t)]

# /usr/include/alsa/seq.h:98
snd_seq_get_output_buffer_size = _lib.snd_seq_get_output_buffer_size
snd_seq_get_output_buffer_size.restype = c_size_t
snd_seq_get_output_buffer_size.argtypes = [POINTER(snd_seq_t)]

# /usr/include/alsa/seq.h:99
snd_seq_get_input_buffer_size = _lib.snd_seq_get_input_buffer_size
snd_seq_get_input_buffer_size.restype = c_size_t
snd_seq_get_input_buffer_size.argtypes = [POINTER(snd_seq_t)]

# /usr/include/alsa/seq.h:100
snd_seq_set_output_buffer_size = _lib.snd_seq_set_output_buffer_size
snd_seq_set_output_buffer_size.restype = c_int
snd_seq_set_output_buffer_size.argtypes = [POINTER(snd_seq_t), c_size_t]

# /usr/include/alsa/seq.h:101
snd_seq_set_input_buffer_size = _lib.snd_seq_set_input_buffer_size
snd_seq_set_input_buffer_size.restype = c_int
snd_seq_set_input_buffer_size.argtypes = [POINTER(snd_seq_t), c_size_t]

class struct__snd_seq_system_info(Structure):
    __slots__ = [
    ]
struct__snd_seq_system_info._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_seq_system_info(Structure):
    __slots__ = [
    ]
struct__snd_seq_system_info._fields_ = [
    ('_opaque_struct', c_int)
]

snd_seq_system_info_t = struct__snd_seq_system_info 	# /usr/include/alsa/seq.h:104
# /usr/include/alsa/seq.h:106
snd_seq_system_info_sizeof = _lib.snd_seq_system_info_sizeof
snd_seq_system_info_sizeof.restype = c_size_t
snd_seq_system_info_sizeof.argtypes = []

# /usr/include/alsa/seq.h:110
snd_seq_system_info_malloc = _lib.snd_seq_system_info_malloc
snd_seq_system_info_malloc.restype = c_int
snd_seq_system_info_malloc.argtypes = [POINTER(POINTER(snd_seq_system_info_t))]

# /usr/include/alsa/seq.h:111
snd_seq_system_info_free = _lib.snd_seq_system_info_free
snd_seq_system_info_free.restype = None
snd_seq_system_info_free.argtypes = [POINTER(snd_seq_system_info_t)]

# /usr/include/alsa/seq.h:112
snd_seq_system_info_copy = _lib.snd_seq_system_info_copy
snd_seq_system_info_copy.restype = None
snd_seq_system_info_copy.argtypes = [POINTER(snd_seq_system_info_t), POINTER(snd_seq_system_info_t)]

# /usr/include/alsa/seq.h:114
snd_seq_system_info_get_queues = _lib.snd_seq_system_info_get_queues
snd_seq_system_info_get_queues.restype = c_int
snd_seq_system_info_get_queues.argtypes = [POINTER(snd_seq_system_info_t)]

# /usr/include/alsa/seq.h:115
snd_seq_system_info_get_clients = _lib.snd_seq_system_info_get_clients
snd_seq_system_info_get_clients.restype = c_int
snd_seq_system_info_get_clients.argtypes = [POINTER(snd_seq_system_info_t)]

# /usr/include/alsa/seq.h:116
snd_seq_system_info_get_ports = _lib.snd_seq_system_info_get_ports
snd_seq_system_info_get_ports.restype = c_int
snd_seq_system_info_get_ports.argtypes = [POINTER(snd_seq_system_info_t)]

# /usr/include/alsa/seq.h:117
snd_seq_system_info_get_channels = _lib.snd_seq_system_info_get_channels
snd_seq_system_info_get_channels.restype = c_int
snd_seq_system_info_get_channels.argtypes = [POINTER(snd_seq_system_info_t)]

# /usr/include/alsa/seq.h:118
snd_seq_system_info_get_cur_clients = _lib.snd_seq_system_info_get_cur_clients
snd_seq_system_info_get_cur_clients.restype = c_int
snd_seq_system_info_get_cur_clients.argtypes = [POINTER(snd_seq_system_info_t)]

# /usr/include/alsa/seq.h:119
snd_seq_system_info_get_cur_queues = _lib.snd_seq_system_info_get_cur_queues
snd_seq_system_info_get_cur_queues.restype = c_int
snd_seq_system_info_get_cur_queues.argtypes = [POINTER(snd_seq_system_info_t)]

# /usr/include/alsa/seq.h:121
snd_seq_system_info = _lib.snd_seq_system_info
snd_seq_system_info.restype = c_int
snd_seq_system_info.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_system_info_t)]

class struct__snd_seq_client_info(Structure):
    __slots__ = [
    ]
struct__snd_seq_client_info._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_seq_client_info(Structure):
    __slots__ = [
    ]
struct__snd_seq_client_info._fields_ = [
    ('_opaque_struct', c_int)
]

snd_seq_client_info_t = struct__snd_seq_client_info 	# /usr/include/alsa/seq.h:134
enum_snd_seq_client_type = c_int
SND_SEQ_USER_CLIENT = 1
SND_SEQ_KERNEL_CLIENT = 2
snd_seq_client_type_t = enum_snd_seq_client_type 	# /usr/include/alsa/seq.h:140
# /usr/include/alsa/seq.h:142
snd_seq_client_info_sizeof = _lib.snd_seq_client_info_sizeof
snd_seq_client_info_sizeof.restype = c_size_t
snd_seq_client_info_sizeof.argtypes = []

# /usr/include/alsa/seq.h:146
snd_seq_client_info_malloc = _lib.snd_seq_client_info_malloc
snd_seq_client_info_malloc.restype = c_int
snd_seq_client_info_malloc.argtypes = [POINTER(POINTER(snd_seq_client_info_t))]

# /usr/include/alsa/seq.h:147
snd_seq_client_info_free = _lib.snd_seq_client_info_free
snd_seq_client_info_free.restype = None
snd_seq_client_info_free.argtypes = [POINTER(snd_seq_client_info_t)]

# /usr/include/alsa/seq.h:148
snd_seq_client_info_copy = _lib.snd_seq_client_info_copy
snd_seq_client_info_copy.restype = None
snd_seq_client_info_copy.argtypes = [POINTER(snd_seq_client_info_t), POINTER(snd_seq_client_info_t)]

# /usr/include/alsa/seq.h:150
snd_seq_client_info_get_client = _lib.snd_seq_client_info_get_client
snd_seq_client_info_get_client.restype = c_int
snd_seq_client_info_get_client.argtypes = [POINTER(snd_seq_client_info_t)]

# /usr/include/alsa/seq.h:151
snd_seq_client_info_get_type = _lib.snd_seq_client_info_get_type
snd_seq_client_info_get_type.restype = snd_seq_client_type_t
snd_seq_client_info_get_type.argtypes = [POINTER(snd_seq_client_info_t)]

# /usr/include/alsa/seq.h:152
snd_seq_client_info_get_name = _lib.snd_seq_client_info_get_name
snd_seq_client_info_get_name.restype = c_char_p
snd_seq_client_info_get_name.argtypes = [POINTER(snd_seq_client_info_t)]

# /usr/include/alsa/seq.h:153
snd_seq_client_info_get_broadcast_filter = _lib.snd_seq_client_info_get_broadcast_filter
snd_seq_client_info_get_broadcast_filter.restype = c_int
snd_seq_client_info_get_broadcast_filter.argtypes = [POINTER(snd_seq_client_info_t)]

# /usr/include/alsa/seq.h:154
snd_seq_client_info_get_error_bounce = _lib.snd_seq_client_info_get_error_bounce
snd_seq_client_info_get_error_bounce.restype = c_int
snd_seq_client_info_get_error_bounce.argtypes = [POINTER(snd_seq_client_info_t)]

# /usr/include/alsa/seq.h:155
snd_seq_client_info_get_event_filter = _lib.snd_seq_client_info_get_event_filter
snd_seq_client_info_get_event_filter.restype = POINTER(c_ubyte)
snd_seq_client_info_get_event_filter.argtypes = [POINTER(snd_seq_client_info_t)]

# /usr/include/alsa/seq.h:156
snd_seq_client_info_get_num_ports = _lib.snd_seq_client_info_get_num_ports
snd_seq_client_info_get_num_ports.restype = c_int
snd_seq_client_info_get_num_ports.argtypes = [POINTER(snd_seq_client_info_t)]

# /usr/include/alsa/seq.h:157
snd_seq_client_info_get_event_lost = _lib.snd_seq_client_info_get_event_lost
snd_seq_client_info_get_event_lost.restype = c_int
snd_seq_client_info_get_event_lost.argtypes = [POINTER(snd_seq_client_info_t)]

# /usr/include/alsa/seq.h:159
snd_seq_client_info_set_client = _lib.snd_seq_client_info_set_client
snd_seq_client_info_set_client.restype = None
snd_seq_client_info_set_client.argtypes = [POINTER(snd_seq_client_info_t), c_int]

# /usr/include/alsa/seq.h:160
snd_seq_client_info_set_name = _lib.snd_seq_client_info_set_name
snd_seq_client_info_set_name.restype = None
snd_seq_client_info_set_name.argtypes = [POINTER(snd_seq_client_info_t), c_char_p]

# /usr/include/alsa/seq.h:161
snd_seq_client_info_set_broadcast_filter = _lib.snd_seq_client_info_set_broadcast_filter
snd_seq_client_info_set_broadcast_filter.restype = None
snd_seq_client_info_set_broadcast_filter.argtypes = [POINTER(snd_seq_client_info_t), c_int]

# /usr/include/alsa/seq.h:162
snd_seq_client_info_set_error_bounce = _lib.snd_seq_client_info_set_error_bounce
snd_seq_client_info_set_error_bounce.restype = None
snd_seq_client_info_set_error_bounce.argtypes = [POINTER(snd_seq_client_info_t), c_int]

# /usr/include/alsa/seq.h:163
snd_seq_client_info_set_event_filter = _lib.snd_seq_client_info_set_event_filter
snd_seq_client_info_set_event_filter.restype = None
snd_seq_client_info_set_event_filter.argtypes = [POINTER(snd_seq_client_info_t), POINTER(c_ubyte)]

# /usr/include/alsa/seq.h:165
snd_seq_get_client_info = _lib.snd_seq_get_client_info
snd_seq_get_client_info.restype = c_int
snd_seq_get_client_info.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_client_info_t)]

# /usr/include/alsa/seq.h:166
snd_seq_get_any_client_info = _lib.snd_seq_get_any_client_info
snd_seq_get_any_client_info.restype = c_int
snd_seq_get_any_client_info.argtypes = [POINTER(snd_seq_t), c_int, POINTER(snd_seq_client_info_t)]

# /usr/include/alsa/seq.h:167
snd_seq_set_client_info = _lib.snd_seq_set_client_info
snd_seq_set_client_info.restype = c_int
snd_seq_set_client_info.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_client_info_t)]

# /usr/include/alsa/seq.h:168
snd_seq_query_next_client = _lib.snd_seq_query_next_client
snd_seq_query_next_client.restype = c_int
snd_seq_query_next_client.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_client_info_t)]

class struct__snd_seq_client_pool(Structure):
    __slots__ = [
    ]
struct__snd_seq_client_pool._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_seq_client_pool(Structure):
    __slots__ = [
    ]
struct__snd_seq_client_pool._fields_ = [
    ('_opaque_struct', c_int)
]

snd_seq_client_pool_t = struct__snd_seq_client_pool 	# /usr/include/alsa/seq.h:174
# /usr/include/alsa/seq.h:176
snd_seq_client_pool_sizeof = _lib.snd_seq_client_pool_sizeof
snd_seq_client_pool_sizeof.restype = c_size_t
snd_seq_client_pool_sizeof.argtypes = []

# /usr/include/alsa/seq.h:180
snd_seq_client_pool_malloc = _lib.snd_seq_client_pool_malloc
snd_seq_client_pool_malloc.restype = c_int
snd_seq_client_pool_malloc.argtypes = [POINTER(POINTER(snd_seq_client_pool_t))]

# /usr/include/alsa/seq.h:181
snd_seq_client_pool_free = _lib.snd_seq_client_pool_free
snd_seq_client_pool_free.restype = None
snd_seq_client_pool_free.argtypes = [POINTER(snd_seq_client_pool_t)]

# /usr/include/alsa/seq.h:182
snd_seq_client_pool_copy = _lib.snd_seq_client_pool_copy
snd_seq_client_pool_copy.restype = None
snd_seq_client_pool_copy.argtypes = [POINTER(snd_seq_client_pool_t), POINTER(snd_seq_client_pool_t)]

# /usr/include/alsa/seq.h:184
snd_seq_client_pool_get_client = _lib.snd_seq_client_pool_get_client
snd_seq_client_pool_get_client.restype = c_int
snd_seq_client_pool_get_client.argtypes = [POINTER(snd_seq_client_pool_t)]

# /usr/include/alsa/seq.h:185
snd_seq_client_pool_get_output_pool = _lib.snd_seq_client_pool_get_output_pool
snd_seq_client_pool_get_output_pool.restype = c_size_t
snd_seq_client_pool_get_output_pool.argtypes = [POINTER(snd_seq_client_pool_t)]

# /usr/include/alsa/seq.h:186
snd_seq_client_pool_get_input_pool = _lib.snd_seq_client_pool_get_input_pool
snd_seq_client_pool_get_input_pool.restype = c_size_t
snd_seq_client_pool_get_input_pool.argtypes = [POINTER(snd_seq_client_pool_t)]

# /usr/include/alsa/seq.h:187
snd_seq_client_pool_get_output_room = _lib.snd_seq_client_pool_get_output_room
snd_seq_client_pool_get_output_room.restype = c_size_t
snd_seq_client_pool_get_output_room.argtypes = [POINTER(snd_seq_client_pool_t)]

# /usr/include/alsa/seq.h:188
snd_seq_client_pool_get_output_free = _lib.snd_seq_client_pool_get_output_free
snd_seq_client_pool_get_output_free.restype = c_size_t
snd_seq_client_pool_get_output_free.argtypes = [POINTER(snd_seq_client_pool_t)]

# /usr/include/alsa/seq.h:189
snd_seq_client_pool_get_input_free = _lib.snd_seq_client_pool_get_input_free
snd_seq_client_pool_get_input_free.restype = c_size_t
snd_seq_client_pool_get_input_free.argtypes = [POINTER(snd_seq_client_pool_t)]

# /usr/include/alsa/seq.h:190
snd_seq_client_pool_set_output_pool = _lib.snd_seq_client_pool_set_output_pool
snd_seq_client_pool_set_output_pool.restype = None
snd_seq_client_pool_set_output_pool.argtypes = [POINTER(snd_seq_client_pool_t), c_size_t]

# /usr/include/alsa/seq.h:191
snd_seq_client_pool_set_input_pool = _lib.snd_seq_client_pool_set_input_pool
snd_seq_client_pool_set_input_pool.restype = None
snd_seq_client_pool_set_input_pool.argtypes = [POINTER(snd_seq_client_pool_t), c_size_t]

# /usr/include/alsa/seq.h:192
snd_seq_client_pool_set_output_room = _lib.snd_seq_client_pool_set_output_room
snd_seq_client_pool_set_output_room.restype = None
snd_seq_client_pool_set_output_room.argtypes = [POINTER(snd_seq_client_pool_t), c_size_t]

# /usr/include/alsa/seq.h:194
snd_seq_get_client_pool = _lib.snd_seq_get_client_pool
snd_seq_get_client_pool.restype = c_int
snd_seq_get_client_pool.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_client_pool_t)]

# /usr/include/alsa/seq.h:195
snd_seq_set_client_pool = _lib.snd_seq_set_client_pool
snd_seq_set_client_pool.restype = c_int
snd_seq_set_client_pool.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_client_pool_t)]

class struct__snd_seq_port_info(Structure):
    __slots__ = [
    ]
struct__snd_seq_port_info._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_seq_port_info(Structure):
    __slots__ = [
    ]
struct__snd_seq_port_info._fields_ = [
    ('_opaque_struct', c_int)
]

snd_seq_port_info_t = struct__snd_seq_port_info 	# /usr/include/alsa/seq.h:209
SND_SEQ_PORT_SYSTEM_TIMER = 0 	# /usr/include/alsa/seq.h:212
SND_SEQ_PORT_SYSTEM_ANNOUNCE = 1 	# /usr/include/alsa/seq.h:213
SND_SEQ_PORT_CAP_READ = 1 	# /usr/include/alsa/seq.h:216
SND_SEQ_PORT_CAP_WRITE = 2 	# /usr/include/alsa/seq.h:217
SND_SEQ_PORT_CAP_SYNC_READ = 4 	# /usr/include/alsa/seq.h:219
SND_SEQ_PORT_CAP_SYNC_WRITE = 8 	# /usr/include/alsa/seq.h:220
SND_SEQ_PORT_CAP_DUPLEX = 16 	# /usr/include/alsa/seq.h:222
SND_SEQ_PORT_CAP_SUBS_READ = 32 	# /usr/include/alsa/seq.h:224
SND_SEQ_PORT_CAP_SUBS_WRITE = 64 	# /usr/include/alsa/seq.h:225
SND_SEQ_PORT_CAP_NO_EXPORT = 128 	# /usr/include/alsa/seq.h:226
SND_SEQ_PORT_TYPE_SPECIFIC = 1 	# /usr/include/alsa/seq.h:230
SND_SEQ_PORT_TYPE_MIDI_GENERIC = 2 	# /usr/include/alsa/seq.h:232
SND_SEQ_PORT_TYPE_MIDI_GM = 4 	# /usr/include/alsa/seq.h:234
SND_SEQ_PORT_TYPE_MIDI_GS = 8 	# /usr/include/alsa/seq.h:236
SND_SEQ_PORT_TYPE_MIDI_XG = 16 	# /usr/include/alsa/seq.h:238
SND_SEQ_PORT_TYPE_MIDI_MT32 = 32 	# /usr/include/alsa/seq.h:240
SND_SEQ_PORT_TYPE_MIDI_GM2 = 64 	# /usr/include/alsa/seq.h:242
SND_SEQ_PORT_TYPE_SYNTH = 1024 	# /usr/include/alsa/seq.h:245
SND_SEQ_PORT_TYPE_DIRECT_SAMPLE = 2048 	# /usr/include/alsa/seq.h:248
SND_SEQ_PORT_TYPE_SAMPLE = 4096 	# /usr/include/alsa/seq.h:251
SND_SEQ_PORT_TYPE_HARDWARE = 65536 	# /usr/include/alsa/seq.h:253
SND_SEQ_PORT_TYPE_SOFTWARE = 131072 	# /usr/include/alsa/seq.h:255
SND_SEQ_PORT_TYPE_SYNTHESIZER = 262144 	# /usr/include/alsa/seq.h:257
SND_SEQ_PORT_TYPE_PORT = 524288 	# /usr/include/alsa/seq.h:260
SND_SEQ_PORT_TYPE_APPLICATION = 1048576 	# /usr/include/alsa/seq.h:262
# /usr/include/alsa/seq.h:265
snd_seq_port_info_sizeof = _lib.snd_seq_port_info_sizeof
snd_seq_port_info_sizeof.restype = c_size_t
snd_seq_port_info_sizeof.argtypes = []

# /usr/include/alsa/seq.h:269
snd_seq_port_info_malloc = _lib.snd_seq_port_info_malloc
snd_seq_port_info_malloc.restype = c_int
snd_seq_port_info_malloc.argtypes = [POINTER(POINTER(snd_seq_port_info_t))]

# /usr/include/alsa/seq.h:270
snd_seq_port_info_free = _lib.snd_seq_port_info_free
snd_seq_port_info_free.restype = None
snd_seq_port_info_free.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:271
snd_seq_port_info_copy = _lib.snd_seq_port_info_copy
snd_seq_port_info_copy.restype = None
snd_seq_port_info_copy.argtypes = [POINTER(snd_seq_port_info_t), POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:273
snd_seq_port_info_get_client = _lib.snd_seq_port_info_get_client
snd_seq_port_info_get_client.restype = c_int
snd_seq_port_info_get_client.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:274
snd_seq_port_info_get_port = _lib.snd_seq_port_info_get_port
snd_seq_port_info_get_port.restype = c_int
snd_seq_port_info_get_port.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:275
snd_seq_port_info_get_addr = _lib.snd_seq_port_info_get_addr
snd_seq_port_info_get_addr.restype = POINTER(snd_seq_addr_t)
snd_seq_port_info_get_addr.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:276
snd_seq_port_info_get_name = _lib.snd_seq_port_info_get_name
snd_seq_port_info_get_name.restype = c_char_p
snd_seq_port_info_get_name.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:277
snd_seq_port_info_get_capability = _lib.snd_seq_port_info_get_capability
snd_seq_port_info_get_capability.restype = c_uint
snd_seq_port_info_get_capability.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:278
snd_seq_port_info_get_type = _lib.snd_seq_port_info_get_type
snd_seq_port_info_get_type.restype = c_uint
snd_seq_port_info_get_type.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:279
snd_seq_port_info_get_midi_channels = _lib.snd_seq_port_info_get_midi_channels
snd_seq_port_info_get_midi_channels.restype = c_int
snd_seq_port_info_get_midi_channels.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:280
snd_seq_port_info_get_midi_voices = _lib.snd_seq_port_info_get_midi_voices
snd_seq_port_info_get_midi_voices.restype = c_int
snd_seq_port_info_get_midi_voices.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:281
snd_seq_port_info_get_synth_voices = _lib.snd_seq_port_info_get_synth_voices
snd_seq_port_info_get_synth_voices.restype = c_int
snd_seq_port_info_get_synth_voices.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:282
snd_seq_port_info_get_read_use = _lib.snd_seq_port_info_get_read_use
snd_seq_port_info_get_read_use.restype = c_int
snd_seq_port_info_get_read_use.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:283
snd_seq_port_info_get_write_use = _lib.snd_seq_port_info_get_write_use
snd_seq_port_info_get_write_use.restype = c_int
snd_seq_port_info_get_write_use.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:284
snd_seq_port_info_get_port_specified = _lib.snd_seq_port_info_get_port_specified
snd_seq_port_info_get_port_specified.restype = c_int
snd_seq_port_info_get_port_specified.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:285
snd_seq_port_info_get_timestamping = _lib.snd_seq_port_info_get_timestamping
snd_seq_port_info_get_timestamping.restype = c_int
snd_seq_port_info_get_timestamping.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:286
snd_seq_port_info_get_timestamp_real = _lib.snd_seq_port_info_get_timestamp_real
snd_seq_port_info_get_timestamp_real.restype = c_int
snd_seq_port_info_get_timestamp_real.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:287
snd_seq_port_info_get_timestamp_queue = _lib.snd_seq_port_info_get_timestamp_queue
snd_seq_port_info_get_timestamp_queue.restype = c_int
snd_seq_port_info_get_timestamp_queue.argtypes = [POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:289
snd_seq_port_info_set_client = _lib.snd_seq_port_info_set_client
snd_seq_port_info_set_client.restype = None
snd_seq_port_info_set_client.argtypes = [POINTER(snd_seq_port_info_t), c_int]

# /usr/include/alsa/seq.h:290
snd_seq_port_info_set_port = _lib.snd_seq_port_info_set_port
snd_seq_port_info_set_port.restype = None
snd_seq_port_info_set_port.argtypes = [POINTER(snd_seq_port_info_t), c_int]

# /usr/include/alsa/seq.h:291
snd_seq_port_info_set_addr = _lib.snd_seq_port_info_set_addr
snd_seq_port_info_set_addr.restype = None
snd_seq_port_info_set_addr.argtypes = [POINTER(snd_seq_port_info_t), POINTER(snd_seq_addr_t)]

# /usr/include/alsa/seq.h:292
snd_seq_port_info_set_name = _lib.snd_seq_port_info_set_name
snd_seq_port_info_set_name.restype = None
snd_seq_port_info_set_name.argtypes = [POINTER(snd_seq_port_info_t), c_char_p]

# /usr/include/alsa/seq.h:293
snd_seq_port_info_set_capability = _lib.snd_seq_port_info_set_capability
snd_seq_port_info_set_capability.restype = None
snd_seq_port_info_set_capability.argtypes = [POINTER(snd_seq_port_info_t), c_uint]

# /usr/include/alsa/seq.h:294
snd_seq_port_info_set_type = _lib.snd_seq_port_info_set_type
snd_seq_port_info_set_type.restype = None
snd_seq_port_info_set_type.argtypes = [POINTER(snd_seq_port_info_t), c_uint]

# /usr/include/alsa/seq.h:295
snd_seq_port_info_set_midi_channels = _lib.snd_seq_port_info_set_midi_channels
snd_seq_port_info_set_midi_channels.restype = None
snd_seq_port_info_set_midi_channels.argtypes = [POINTER(snd_seq_port_info_t), c_int]

# /usr/include/alsa/seq.h:296
snd_seq_port_info_set_midi_voices = _lib.snd_seq_port_info_set_midi_voices
snd_seq_port_info_set_midi_voices.restype = None
snd_seq_port_info_set_midi_voices.argtypes = [POINTER(snd_seq_port_info_t), c_int]

# /usr/include/alsa/seq.h:297
snd_seq_port_info_set_synth_voices = _lib.snd_seq_port_info_set_synth_voices
snd_seq_port_info_set_synth_voices.restype = None
snd_seq_port_info_set_synth_voices.argtypes = [POINTER(snd_seq_port_info_t), c_int]

# /usr/include/alsa/seq.h:298
snd_seq_port_info_set_port_specified = _lib.snd_seq_port_info_set_port_specified
snd_seq_port_info_set_port_specified.restype = None
snd_seq_port_info_set_port_specified.argtypes = [POINTER(snd_seq_port_info_t), c_int]

# /usr/include/alsa/seq.h:299
snd_seq_port_info_set_timestamping = _lib.snd_seq_port_info_set_timestamping
snd_seq_port_info_set_timestamping.restype = None
snd_seq_port_info_set_timestamping.argtypes = [POINTER(snd_seq_port_info_t), c_int]

# /usr/include/alsa/seq.h:300
snd_seq_port_info_set_timestamp_real = _lib.snd_seq_port_info_set_timestamp_real
snd_seq_port_info_set_timestamp_real.restype = None
snd_seq_port_info_set_timestamp_real.argtypes = [POINTER(snd_seq_port_info_t), c_int]

# /usr/include/alsa/seq.h:301
snd_seq_port_info_set_timestamp_queue = _lib.snd_seq_port_info_set_timestamp_queue
snd_seq_port_info_set_timestamp_queue.restype = None
snd_seq_port_info_set_timestamp_queue.argtypes = [POINTER(snd_seq_port_info_t), c_int]

# /usr/include/alsa/seq.h:303
snd_seq_create_port = _lib.snd_seq_create_port
snd_seq_create_port.restype = c_int
snd_seq_create_port.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:304
snd_seq_delete_port = _lib.snd_seq_delete_port
snd_seq_delete_port.restype = c_int
snd_seq_delete_port.argtypes = [POINTER(snd_seq_t), c_int]

# /usr/include/alsa/seq.h:305
snd_seq_get_port_info = _lib.snd_seq_get_port_info
snd_seq_get_port_info.restype = c_int
snd_seq_get_port_info.argtypes = [POINTER(snd_seq_t), c_int, POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:306
snd_seq_get_any_port_info = _lib.snd_seq_get_any_port_info
snd_seq_get_any_port_info.restype = c_int
snd_seq_get_any_port_info.argtypes = [POINTER(snd_seq_t), c_int, c_int, POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:307
snd_seq_set_port_info = _lib.snd_seq_set_port_info
snd_seq_set_port_info.restype = c_int
snd_seq_set_port_info.argtypes = [POINTER(snd_seq_t), c_int, POINTER(snd_seq_port_info_t)]

# /usr/include/alsa/seq.h:308
snd_seq_query_next_port = _lib.snd_seq_query_next_port
snd_seq_query_next_port.restype = c_int
snd_seq_query_next_port.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_port_info_t)]

class struct__snd_seq_port_subscribe(Structure):
    __slots__ = [
    ]
struct__snd_seq_port_subscribe._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_seq_port_subscribe(Structure):
    __slots__ = [
    ]
struct__snd_seq_port_subscribe._fields_ = [
    ('_opaque_struct', c_int)
]

snd_seq_port_subscribe_t = struct__snd_seq_port_subscribe 	# /usr/include/alsa/seq.h:321
# /usr/include/alsa/seq.h:323
snd_seq_port_subscribe_sizeof = _lib.snd_seq_port_subscribe_sizeof
snd_seq_port_subscribe_sizeof.restype = c_size_t
snd_seq_port_subscribe_sizeof.argtypes = []

# /usr/include/alsa/seq.h:327
snd_seq_port_subscribe_malloc = _lib.snd_seq_port_subscribe_malloc
snd_seq_port_subscribe_malloc.restype = c_int
snd_seq_port_subscribe_malloc.argtypes = [POINTER(POINTER(snd_seq_port_subscribe_t))]

# /usr/include/alsa/seq.h:328
snd_seq_port_subscribe_free = _lib.snd_seq_port_subscribe_free
snd_seq_port_subscribe_free.restype = None
snd_seq_port_subscribe_free.argtypes = [POINTER(snd_seq_port_subscribe_t)]

# /usr/include/alsa/seq.h:329
snd_seq_port_subscribe_copy = _lib.snd_seq_port_subscribe_copy
snd_seq_port_subscribe_copy.restype = None
snd_seq_port_subscribe_copy.argtypes = [POINTER(snd_seq_port_subscribe_t), POINTER(snd_seq_port_subscribe_t)]

# /usr/include/alsa/seq.h:331
snd_seq_port_subscribe_get_sender = _lib.snd_seq_port_subscribe_get_sender
snd_seq_port_subscribe_get_sender.restype = POINTER(snd_seq_addr_t)
snd_seq_port_subscribe_get_sender.argtypes = [POINTER(snd_seq_port_subscribe_t)]

# /usr/include/alsa/seq.h:332
snd_seq_port_subscribe_get_dest = _lib.snd_seq_port_subscribe_get_dest
snd_seq_port_subscribe_get_dest.restype = POINTER(snd_seq_addr_t)
snd_seq_port_subscribe_get_dest.argtypes = [POINTER(snd_seq_port_subscribe_t)]

# /usr/include/alsa/seq.h:333
snd_seq_port_subscribe_get_queue = _lib.snd_seq_port_subscribe_get_queue
snd_seq_port_subscribe_get_queue.restype = c_int
snd_seq_port_subscribe_get_queue.argtypes = [POINTER(snd_seq_port_subscribe_t)]

# /usr/include/alsa/seq.h:334
snd_seq_port_subscribe_get_exclusive = _lib.snd_seq_port_subscribe_get_exclusive
snd_seq_port_subscribe_get_exclusive.restype = c_int
snd_seq_port_subscribe_get_exclusive.argtypes = [POINTER(snd_seq_port_subscribe_t)]

# /usr/include/alsa/seq.h:335
snd_seq_port_subscribe_get_time_update = _lib.snd_seq_port_subscribe_get_time_update
snd_seq_port_subscribe_get_time_update.restype = c_int
snd_seq_port_subscribe_get_time_update.argtypes = [POINTER(snd_seq_port_subscribe_t)]

# /usr/include/alsa/seq.h:336
snd_seq_port_subscribe_get_time_real = _lib.snd_seq_port_subscribe_get_time_real
snd_seq_port_subscribe_get_time_real.restype = c_int
snd_seq_port_subscribe_get_time_real.argtypes = [POINTER(snd_seq_port_subscribe_t)]

# /usr/include/alsa/seq.h:338
snd_seq_port_subscribe_set_sender = _lib.snd_seq_port_subscribe_set_sender
snd_seq_port_subscribe_set_sender.restype = None
snd_seq_port_subscribe_set_sender.argtypes = [POINTER(snd_seq_port_subscribe_t), POINTER(snd_seq_addr_t)]

# /usr/include/alsa/seq.h:339
snd_seq_port_subscribe_set_dest = _lib.snd_seq_port_subscribe_set_dest
snd_seq_port_subscribe_set_dest.restype = None
snd_seq_port_subscribe_set_dest.argtypes = [POINTER(snd_seq_port_subscribe_t), POINTER(snd_seq_addr_t)]

# /usr/include/alsa/seq.h:340
snd_seq_port_subscribe_set_queue = _lib.snd_seq_port_subscribe_set_queue
snd_seq_port_subscribe_set_queue.restype = None
snd_seq_port_subscribe_set_queue.argtypes = [POINTER(snd_seq_port_subscribe_t), c_int]

# /usr/include/alsa/seq.h:341
snd_seq_port_subscribe_set_exclusive = _lib.snd_seq_port_subscribe_set_exclusive
snd_seq_port_subscribe_set_exclusive.restype = None
snd_seq_port_subscribe_set_exclusive.argtypes = [POINTER(snd_seq_port_subscribe_t), c_int]

# /usr/include/alsa/seq.h:342
snd_seq_port_subscribe_set_time_update = _lib.snd_seq_port_subscribe_set_time_update
snd_seq_port_subscribe_set_time_update.restype = None
snd_seq_port_subscribe_set_time_update.argtypes = [POINTER(snd_seq_port_subscribe_t), c_int]

# /usr/include/alsa/seq.h:343
snd_seq_port_subscribe_set_time_real = _lib.snd_seq_port_subscribe_set_time_real
snd_seq_port_subscribe_set_time_real.restype = None
snd_seq_port_subscribe_set_time_real.argtypes = [POINTER(snd_seq_port_subscribe_t), c_int]

# /usr/include/alsa/seq.h:345
snd_seq_get_port_subscription = _lib.snd_seq_get_port_subscription
snd_seq_get_port_subscription.restype = c_int
snd_seq_get_port_subscription.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_port_subscribe_t)]

# /usr/include/alsa/seq.h:346
snd_seq_subscribe_port = _lib.snd_seq_subscribe_port
snd_seq_subscribe_port.restype = c_int
snd_seq_subscribe_port.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_port_subscribe_t)]

# /usr/include/alsa/seq.h:347
snd_seq_unsubscribe_port = _lib.snd_seq_unsubscribe_port
snd_seq_unsubscribe_port.restype = c_int
snd_seq_unsubscribe_port.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_port_subscribe_t)]

class struct__snd_seq_query_subscribe(Structure):
    __slots__ = [
    ]
struct__snd_seq_query_subscribe._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_seq_query_subscribe(Structure):
    __slots__ = [
    ]
struct__snd_seq_query_subscribe._fields_ = [
    ('_opaque_struct', c_int)
]

snd_seq_query_subscribe_t = struct__snd_seq_query_subscribe 	# /usr/include/alsa/seq.h:353
enum_anon_30 = c_int
SND_SEQ_QUERY_SUBS_READ = 1
SND_SEQ_QUERY_SUBS_WRITE = 2
snd_seq_query_subs_type_t = enum_anon_30 	# /usr/include/alsa/seq.h:359
# /usr/include/alsa/seq.h:361
snd_seq_query_subscribe_sizeof = _lib.snd_seq_query_subscribe_sizeof
snd_seq_query_subscribe_sizeof.restype = c_size_t
snd_seq_query_subscribe_sizeof.argtypes = []

# /usr/include/alsa/seq.h:365
snd_seq_query_subscribe_malloc = _lib.snd_seq_query_subscribe_malloc
snd_seq_query_subscribe_malloc.restype = c_int
snd_seq_query_subscribe_malloc.argtypes = [POINTER(POINTER(snd_seq_query_subscribe_t))]

# /usr/include/alsa/seq.h:366
snd_seq_query_subscribe_free = _lib.snd_seq_query_subscribe_free
snd_seq_query_subscribe_free.restype = None
snd_seq_query_subscribe_free.argtypes = [POINTER(snd_seq_query_subscribe_t)]

# /usr/include/alsa/seq.h:367
snd_seq_query_subscribe_copy = _lib.snd_seq_query_subscribe_copy
snd_seq_query_subscribe_copy.restype = None
snd_seq_query_subscribe_copy.argtypes = [POINTER(snd_seq_query_subscribe_t), POINTER(snd_seq_query_subscribe_t)]

# /usr/include/alsa/seq.h:369
snd_seq_query_subscribe_get_client = _lib.snd_seq_query_subscribe_get_client
snd_seq_query_subscribe_get_client.restype = c_int
snd_seq_query_subscribe_get_client.argtypes = [POINTER(snd_seq_query_subscribe_t)]

# /usr/include/alsa/seq.h:370
snd_seq_query_subscribe_get_port = _lib.snd_seq_query_subscribe_get_port
snd_seq_query_subscribe_get_port.restype = c_int
snd_seq_query_subscribe_get_port.argtypes = [POINTER(snd_seq_query_subscribe_t)]

# /usr/include/alsa/seq.h:371
snd_seq_query_subscribe_get_root = _lib.snd_seq_query_subscribe_get_root
snd_seq_query_subscribe_get_root.restype = POINTER(snd_seq_addr_t)
snd_seq_query_subscribe_get_root.argtypes = [POINTER(snd_seq_query_subscribe_t)]

# /usr/include/alsa/seq.h:372
snd_seq_query_subscribe_get_type = _lib.snd_seq_query_subscribe_get_type
snd_seq_query_subscribe_get_type.restype = snd_seq_query_subs_type_t
snd_seq_query_subscribe_get_type.argtypes = [POINTER(snd_seq_query_subscribe_t)]

# /usr/include/alsa/seq.h:373
snd_seq_query_subscribe_get_index = _lib.snd_seq_query_subscribe_get_index
snd_seq_query_subscribe_get_index.restype = c_int
snd_seq_query_subscribe_get_index.argtypes = [POINTER(snd_seq_query_subscribe_t)]

# /usr/include/alsa/seq.h:374
snd_seq_query_subscribe_get_num_subs = _lib.snd_seq_query_subscribe_get_num_subs
snd_seq_query_subscribe_get_num_subs.restype = c_int
snd_seq_query_subscribe_get_num_subs.argtypes = [POINTER(snd_seq_query_subscribe_t)]

# /usr/include/alsa/seq.h:375
snd_seq_query_subscribe_get_addr = _lib.snd_seq_query_subscribe_get_addr
snd_seq_query_subscribe_get_addr.restype = POINTER(snd_seq_addr_t)
snd_seq_query_subscribe_get_addr.argtypes = [POINTER(snd_seq_query_subscribe_t)]

# /usr/include/alsa/seq.h:376
snd_seq_query_subscribe_get_queue = _lib.snd_seq_query_subscribe_get_queue
snd_seq_query_subscribe_get_queue.restype = c_int
snd_seq_query_subscribe_get_queue.argtypes = [POINTER(snd_seq_query_subscribe_t)]

# /usr/include/alsa/seq.h:377
snd_seq_query_subscribe_get_exclusive = _lib.snd_seq_query_subscribe_get_exclusive
snd_seq_query_subscribe_get_exclusive.restype = c_int
snd_seq_query_subscribe_get_exclusive.argtypes = [POINTER(snd_seq_query_subscribe_t)]

# /usr/include/alsa/seq.h:378
snd_seq_query_subscribe_get_time_update = _lib.snd_seq_query_subscribe_get_time_update
snd_seq_query_subscribe_get_time_update.restype = c_int
snd_seq_query_subscribe_get_time_update.argtypes = [POINTER(snd_seq_query_subscribe_t)]

# /usr/include/alsa/seq.h:379
snd_seq_query_subscribe_get_time_real = _lib.snd_seq_query_subscribe_get_time_real
snd_seq_query_subscribe_get_time_real.restype = c_int
snd_seq_query_subscribe_get_time_real.argtypes = [POINTER(snd_seq_query_subscribe_t)]

# /usr/include/alsa/seq.h:381
snd_seq_query_subscribe_set_client = _lib.snd_seq_query_subscribe_set_client
snd_seq_query_subscribe_set_client.restype = None
snd_seq_query_subscribe_set_client.argtypes = [POINTER(snd_seq_query_subscribe_t), c_int]

# /usr/include/alsa/seq.h:382
snd_seq_query_subscribe_set_port = _lib.snd_seq_query_subscribe_set_port
snd_seq_query_subscribe_set_port.restype = None
snd_seq_query_subscribe_set_port.argtypes = [POINTER(snd_seq_query_subscribe_t), c_int]

# /usr/include/alsa/seq.h:383
snd_seq_query_subscribe_set_root = _lib.snd_seq_query_subscribe_set_root
snd_seq_query_subscribe_set_root.restype = None
snd_seq_query_subscribe_set_root.argtypes = [POINTER(snd_seq_query_subscribe_t), POINTER(snd_seq_addr_t)]

# /usr/include/alsa/seq.h:384
snd_seq_query_subscribe_set_type = _lib.snd_seq_query_subscribe_set_type
snd_seq_query_subscribe_set_type.restype = None
snd_seq_query_subscribe_set_type.argtypes = [POINTER(snd_seq_query_subscribe_t), snd_seq_query_subs_type_t]

# /usr/include/alsa/seq.h:385
snd_seq_query_subscribe_set_index = _lib.snd_seq_query_subscribe_set_index
snd_seq_query_subscribe_set_index.restype = None
snd_seq_query_subscribe_set_index.argtypes = [POINTER(snd_seq_query_subscribe_t), c_int]

# /usr/include/alsa/seq.h:387
snd_seq_query_port_subscribers = _lib.snd_seq_query_port_subscribers
snd_seq_query_port_subscribers.restype = c_int
snd_seq_query_port_subscribers.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_query_subscribe_t)]

class struct__snd_seq_queue_info(Structure):
    __slots__ = [
    ]
struct__snd_seq_queue_info._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_seq_queue_info(Structure):
    __slots__ = [
    ]
struct__snd_seq_queue_info._fields_ = [
    ('_opaque_struct', c_int)
]

snd_seq_queue_info_t = struct__snd_seq_queue_info 	# /usr/include/alsa/seq.h:400
class struct__snd_seq_queue_status(Structure):
    __slots__ = [
    ]
struct__snd_seq_queue_status._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_seq_queue_status(Structure):
    __slots__ = [
    ]
struct__snd_seq_queue_status._fields_ = [
    ('_opaque_struct', c_int)
]

snd_seq_queue_status_t = struct__snd_seq_queue_status 	# /usr/include/alsa/seq.h:402
class struct__snd_seq_queue_tempo(Structure):
    __slots__ = [
    ]
struct__snd_seq_queue_tempo._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_seq_queue_tempo(Structure):
    __slots__ = [
    ]
struct__snd_seq_queue_tempo._fields_ = [
    ('_opaque_struct', c_int)
]

snd_seq_queue_tempo_t = struct__snd_seq_queue_tempo 	# /usr/include/alsa/seq.h:404
class struct__snd_seq_queue_timer(Structure):
    __slots__ = [
    ]
struct__snd_seq_queue_timer._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_seq_queue_timer(Structure):
    __slots__ = [
    ]
struct__snd_seq_queue_timer._fields_ = [
    ('_opaque_struct', c_int)
]

snd_seq_queue_timer_t = struct__snd_seq_queue_timer 	# /usr/include/alsa/seq.h:406
SND_SEQ_QUEUE_DIRECT = 253 	# /usr/include/alsa/seq.h:409
# /usr/include/alsa/seq.h:411
snd_seq_queue_info_sizeof = _lib.snd_seq_queue_info_sizeof
snd_seq_queue_info_sizeof.restype = c_size_t
snd_seq_queue_info_sizeof.argtypes = []

# /usr/include/alsa/seq.h:415
snd_seq_queue_info_malloc = _lib.snd_seq_queue_info_malloc
snd_seq_queue_info_malloc.restype = c_int
snd_seq_queue_info_malloc.argtypes = [POINTER(POINTER(snd_seq_queue_info_t))]

# /usr/include/alsa/seq.h:416
snd_seq_queue_info_free = _lib.snd_seq_queue_info_free
snd_seq_queue_info_free.restype = None
snd_seq_queue_info_free.argtypes = [POINTER(snd_seq_queue_info_t)]

# /usr/include/alsa/seq.h:417
snd_seq_queue_info_copy = _lib.snd_seq_queue_info_copy
snd_seq_queue_info_copy.restype = None
snd_seq_queue_info_copy.argtypes = [POINTER(snd_seq_queue_info_t), POINTER(snd_seq_queue_info_t)]

# /usr/include/alsa/seq.h:419
snd_seq_queue_info_get_queue = _lib.snd_seq_queue_info_get_queue
snd_seq_queue_info_get_queue.restype = c_int
snd_seq_queue_info_get_queue.argtypes = [POINTER(snd_seq_queue_info_t)]

# /usr/include/alsa/seq.h:420
snd_seq_queue_info_get_name = _lib.snd_seq_queue_info_get_name
snd_seq_queue_info_get_name.restype = c_char_p
snd_seq_queue_info_get_name.argtypes = [POINTER(snd_seq_queue_info_t)]

# /usr/include/alsa/seq.h:421
snd_seq_queue_info_get_owner = _lib.snd_seq_queue_info_get_owner
snd_seq_queue_info_get_owner.restype = c_int
snd_seq_queue_info_get_owner.argtypes = [POINTER(snd_seq_queue_info_t)]

# /usr/include/alsa/seq.h:422
snd_seq_queue_info_get_locked = _lib.snd_seq_queue_info_get_locked
snd_seq_queue_info_get_locked.restype = c_int
snd_seq_queue_info_get_locked.argtypes = [POINTER(snd_seq_queue_info_t)]

# /usr/include/alsa/seq.h:423
snd_seq_queue_info_get_flags = _lib.snd_seq_queue_info_get_flags
snd_seq_queue_info_get_flags.restype = c_uint
snd_seq_queue_info_get_flags.argtypes = [POINTER(snd_seq_queue_info_t)]

# /usr/include/alsa/seq.h:425
snd_seq_queue_info_set_name = _lib.snd_seq_queue_info_set_name
snd_seq_queue_info_set_name.restype = None
snd_seq_queue_info_set_name.argtypes = [POINTER(snd_seq_queue_info_t), c_char_p]

# /usr/include/alsa/seq.h:426
snd_seq_queue_info_set_owner = _lib.snd_seq_queue_info_set_owner
snd_seq_queue_info_set_owner.restype = None
snd_seq_queue_info_set_owner.argtypes = [POINTER(snd_seq_queue_info_t), c_int]

# /usr/include/alsa/seq.h:427
snd_seq_queue_info_set_locked = _lib.snd_seq_queue_info_set_locked
snd_seq_queue_info_set_locked.restype = None
snd_seq_queue_info_set_locked.argtypes = [POINTER(snd_seq_queue_info_t), c_int]

# /usr/include/alsa/seq.h:428
snd_seq_queue_info_set_flags = _lib.snd_seq_queue_info_set_flags
snd_seq_queue_info_set_flags.restype = None
snd_seq_queue_info_set_flags.argtypes = [POINTER(snd_seq_queue_info_t), c_uint]

# /usr/include/alsa/seq.h:430
snd_seq_create_queue = _lib.snd_seq_create_queue
snd_seq_create_queue.restype = c_int
snd_seq_create_queue.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_queue_info_t)]

# /usr/include/alsa/seq.h:431
snd_seq_alloc_named_queue = _lib.snd_seq_alloc_named_queue
snd_seq_alloc_named_queue.restype = c_int
snd_seq_alloc_named_queue.argtypes = [POINTER(snd_seq_t), c_char_p]

# /usr/include/alsa/seq.h:432
snd_seq_alloc_queue = _lib.snd_seq_alloc_queue
snd_seq_alloc_queue.restype = c_int
snd_seq_alloc_queue.argtypes = [POINTER(snd_seq_t)]

# /usr/include/alsa/seq.h:433
snd_seq_free_queue = _lib.snd_seq_free_queue
snd_seq_free_queue.restype = c_int
snd_seq_free_queue.argtypes = [POINTER(snd_seq_t), c_int]

# /usr/include/alsa/seq.h:434
snd_seq_get_queue_info = _lib.snd_seq_get_queue_info
snd_seq_get_queue_info.restype = c_int
snd_seq_get_queue_info.argtypes = [POINTER(snd_seq_t), c_int, POINTER(snd_seq_queue_info_t)]

# /usr/include/alsa/seq.h:435
snd_seq_set_queue_info = _lib.snd_seq_set_queue_info
snd_seq_set_queue_info.restype = c_int
snd_seq_set_queue_info.argtypes = [POINTER(snd_seq_t), c_int, POINTER(snd_seq_queue_info_t)]

# /usr/include/alsa/seq.h:436
snd_seq_query_named_queue = _lib.snd_seq_query_named_queue
snd_seq_query_named_queue.restype = c_int
snd_seq_query_named_queue.argtypes = [POINTER(snd_seq_t), c_char_p]

# /usr/include/alsa/seq.h:438
snd_seq_get_queue_usage = _lib.snd_seq_get_queue_usage
snd_seq_get_queue_usage.restype = c_int
snd_seq_get_queue_usage.argtypes = [POINTER(snd_seq_t), c_int]

# /usr/include/alsa/seq.h:439
snd_seq_set_queue_usage = _lib.snd_seq_set_queue_usage
snd_seq_set_queue_usage.restype = c_int
snd_seq_set_queue_usage.argtypes = [POINTER(snd_seq_t), c_int, c_int]

# /usr/include/alsa/seq.h:443
snd_seq_queue_status_sizeof = _lib.snd_seq_queue_status_sizeof
snd_seq_queue_status_sizeof.restype = c_size_t
snd_seq_queue_status_sizeof.argtypes = []

# /usr/include/alsa/seq.h:447
snd_seq_queue_status_malloc = _lib.snd_seq_queue_status_malloc
snd_seq_queue_status_malloc.restype = c_int
snd_seq_queue_status_malloc.argtypes = [POINTER(POINTER(snd_seq_queue_status_t))]

# /usr/include/alsa/seq.h:448
snd_seq_queue_status_free = _lib.snd_seq_queue_status_free
snd_seq_queue_status_free.restype = None
snd_seq_queue_status_free.argtypes = [POINTER(snd_seq_queue_status_t)]

# /usr/include/alsa/seq.h:449
snd_seq_queue_status_copy = _lib.snd_seq_queue_status_copy
snd_seq_queue_status_copy.restype = None
snd_seq_queue_status_copy.argtypes = [POINTER(snd_seq_queue_status_t), POINTER(snd_seq_queue_status_t)]

# /usr/include/alsa/seq.h:451
snd_seq_queue_status_get_queue = _lib.snd_seq_queue_status_get_queue
snd_seq_queue_status_get_queue.restype = c_int
snd_seq_queue_status_get_queue.argtypes = [POINTER(snd_seq_queue_status_t)]

# /usr/include/alsa/seq.h:452
snd_seq_queue_status_get_events = _lib.snd_seq_queue_status_get_events
snd_seq_queue_status_get_events.restype = c_int
snd_seq_queue_status_get_events.argtypes = [POINTER(snd_seq_queue_status_t)]

# /usr/include/alsa/seq.h:453
snd_seq_queue_status_get_tick_time = _lib.snd_seq_queue_status_get_tick_time
snd_seq_queue_status_get_tick_time.restype = snd_seq_tick_time_t
snd_seq_queue_status_get_tick_time.argtypes = [POINTER(snd_seq_queue_status_t)]

# /usr/include/alsa/seq.h:454
snd_seq_queue_status_get_real_time = _lib.snd_seq_queue_status_get_real_time
snd_seq_queue_status_get_real_time.restype = POINTER(snd_seq_real_time_t)
snd_seq_queue_status_get_real_time.argtypes = [POINTER(snd_seq_queue_status_t)]

# /usr/include/alsa/seq.h:455
snd_seq_queue_status_get_status = _lib.snd_seq_queue_status_get_status
snd_seq_queue_status_get_status.restype = c_uint
snd_seq_queue_status_get_status.argtypes = [POINTER(snd_seq_queue_status_t)]

# /usr/include/alsa/seq.h:457
snd_seq_get_queue_status = _lib.snd_seq_get_queue_status
snd_seq_get_queue_status.restype = c_int
snd_seq_get_queue_status.argtypes = [POINTER(snd_seq_t), c_int, POINTER(snd_seq_queue_status_t)]

# /usr/include/alsa/seq.h:461
snd_seq_queue_tempo_sizeof = _lib.snd_seq_queue_tempo_sizeof
snd_seq_queue_tempo_sizeof.restype = c_size_t
snd_seq_queue_tempo_sizeof.argtypes = []

# /usr/include/alsa/seq.h:465
snd_seq_queue_tempo_malloc = _lib.snd_seq_queue_tempo_malloc
snd_seq_queue_tempo_malloc.restype = c_int
snd_seq_queue_tempo_malloc.argtypes = [POINTER(POINTER(snd_seq_queue_tempo_t))]

# /usr/include/alsa/seq.h:466
snd_seq_queue_tempo_free = _lib.snd_seq_queue_tempo_free
snd_seq_queue_tempo_free.restype = None
snd_seq_queue_tempo_free.argtypes = [POINTER(snd_seq_queue_tempo_t)]

# /usr/include/alsa/seq.h:467
snd_seq_queue_tempo_copy = _lib.snd_seq_queue_tempo_copy
snd_seq_queue_tempo_copy.restype = None
snd_seq_queue_tempo_copy.argtypes = [POINTER(snd_seq_queue_tempo_t), POINTER(snd_seq_queue_tempo_t)]

# /usr/include/alsa/seq.h:469
snd_seq_queue_tempo_get_queue = _lib.snd_seq_queue_tempo_get_queue
snd_seq_queue_tempo_get_queue.restype = c_int
snd_seq_queue_tempo_get_queue.argtypes = [POINTER(snd_seq_queue_tempo_t)]

# /usr/include/alsa/seq.h:470
snd_seq_queue_tempo_get_tempo = _lib.snd_seq_queue_tempo_get_tempo
snd_seq_queue_tempo_get_tempo.restype = c_uint
snd_seq_queue_tempo_get_tempo.argtypes = [POINTER(snd_seq_queue_tempo_t)]

# /usr/include/alsa/seq.h:471
snd_seq_queue_tempo_get_ppq = _lib.snd_seq_queue_tempo_get_ppq
snd_seq_queue_tempo_get_ppq.restype = c_int
snd_seq_queue_tempo_get_ppq.argtypes = [POINTER(snd_seq_queue_tempo_t)]

# /usr/include/alsa/seq.h:472
snd_seq_queue_tempo_get_skew = _lib.snd_seq_queue_tempo_get_skew
snd_seq_queue_tempo_get_skew.restype = c_uint
snd_seq_queue_tempo_get_skew.argtypes = [POINTER(snd_seq_queue_tempo_t)]

# /usr/include/alsa/seq.h:473
snd_seq_queue_tempo_get_skew_base = _lib.snd_seq_queue_tempo_get_skew_base
snd_seq_queue_tempo_get_skew_base.restype = c_uint
snd_seq_queue_tempo_get_skew_base.argtypes = [POINTER(snd_seq_queue_tempo_t)]

# /usr/include/alsa/seq.h:474
snd_seq_queue_tempo_set_tempo = _lib.snd_seq_queue_tempo_set_tempo
snd_seq_queue_tempo_set_tempo.restype = None
snd_seq_queue_tempo_set_tempo.argtypes = [POINTER(snd_seq_queue_tempo_t), c_uint]

# /usr/include/alsa/seq.h:475
snd_seq_queue_tempo_set_ppq = _lib.snd_seq_queue_tempo_set_ppq
snd_seq_queue_tempo_set_ppq.restype = None
snd_seq_queue_tempo_set_ppq.argtypes = [POINTER(snd_seq_queue_tempo_t), c_int]

# /usr/include/alsa/seq.h:476
snd_seq_queue_tempo_set_skew = _lib.snd_seq_queue_tempo_set_skew
snd_seq_queue_tempo_set_skew.restype = None
snd_seq_queue_tempo_set_skew.argtypes = [POINTER(snd_seq_queue_tempo_t), c_uint]

# /usr/include/alsa/seq.h:477
snd_seq_queue_tempo_set_skew_base = _lib.snd_seq_queue_tempo_set_skew_base
snd_seq_queue_tempo_set_skew_base.restype = None
snd_seq_queue_tempo_set_skew_base.argtypes = [POINTER(snd_seq_queue_tempo_t), c_uint]

# /usr/include/alsa/seq.h:479
snd_seq_get_queue_tempo = _lib.snd_seq_get_queue_tempo
snd_seq_get_queue_tempo.restype = c_int
snd_seq_get_queue_tempo.argtypes = [POINTER(snd_seq_t), c_int, POINTER(snd_seq_queue_tempo_t)]

# /usr/include/alsa/seq.h:480
snd_seq_set_queue_tempo = _lib.snd_seq_set_queue_tempo
snd_seq_set_queue_tempo.restype = c_int
snd_seq_set_queue_tempo.argtypes = [POINTER(snd_seq_t), c_int, POINTER(snd_seq_queue_tempo_t)]

enum_anon_31 = c_int
SND_SEQ_TIMER_ALSA = 0
SND_SEQ_TIMER_MIDI_CLOCK = 1
SND_SEQ_TIMER_MIDI_TICK = 2
snd_seq_queue_timer_type_t = enum_anon_31 	# /usr/include/alsa/seq.h:490
# /usr/include/alsa/seq.h:492
snd_seq_queue_timer_sizeof = _lib.snd_seq_queue_timer_sizeof
snd_seq_queue_timer_sizeof.restype = c_size_t
snd_seq_queue_timer_sizeof.argtypes = []

# /usr/include/alsa/seq.h:496
snd_seq_queue_timer_malloc = _lib.snd_seq_queue_timer_malloc
snd_seq_queue_timer_malloc.restype = c_int
snd_seq_queue_timer_malloc.argtypes = [POINTER(POINTER(snd_seq_queue_timer_t))]

# /usr/include/alsa/seq.h:497
snd_seq_queue_timer_free = _lib.snd_seq_queue_timer_free
snd_seq_queue_timer_free.restype = None
snd_seq_queue_timer_free.argtypes = [POINTER(snd_seq_queue_timer_t)]

# /usr/include/alsa/seq.h:498
snd_seq_queue_timer_copy = _lib.snd_seq_queue_timer_copy
snd_seq_queue_timer_copy.restype = None
snd_seq_queue_timer_copy.argtypes = [POINTER(snd_seq_queue_timer_t), POINTER(snd_seq_queue_timer_t)]

# /usr/include/alsa/seq.h:500
snd_seq_queue_timer_get_queue = _lib.snd_seq_queue_timer_get_queue
snd_seq_queue_timer_get_queue.restype = c_int
snd_seq_queue_timer_get_queue.argtypes = [POINTER(snd_seq_queue_timer_t)]

# /usr/include/alsa/seq.h:501
snd_seq_queue_timer_get_type = _lib.snd_seq_queue_timer_get_type
snd_seq_queue_timer_get_type.restype = snd_seq_queue_timer_type_t
snd_seq_queue_timer_get_type.argtypes = [POINTER(snd_seq_queue_timer_t)]

# /usr/include/alsa/seq.h:502
snd_seq_queue_timer_get_id = _lib.snd_seq_queue_timer_get_id
snd_seq_queue_timer_get_id.restype = POINTER(snd_timer_id_t)
snd_seq_queue_timer_get_id.argtypes = [POINTER(snd_seq_queue_timer_t)]

# /usr/include/alsa/seq.h:503
snd_seq_queue_timer_get_resolution = _lib.snd_seq_queue_timer_get_resolution
snd_seq_queue_timer_get_resolution.restype = c_uint
snd_seq_queue_timer_get_resolution.argtypes = [POINTER(snd_seq_queue_timer_t)]

# /usr/include/alsa/seq.h:505
snd_seq_queue_timer_set_type = _lib.snd_seq_queue_timer_set_type
snd_seq_queue_timer_set_type.restype = None
snd_seq_queue_timer_set_type.argtypes = [POINTER(snd_seq_queue_timer_t), snd_seq_queue_timer_type_t]

# /usr/include/alsa/seq.h:506
snd_seq_queue_timer_set_id = _lib.snd_seq_queue_timer_set_id
snd_seq_queue_timer_set_id.restype = None
snd_seq_queue_timer_set_id.argtypes = [POINTER(snd_seq_queue_timer_t), POINTER(snd_timer_id_t)]

# /usr/include/alsa/seq.h:507
snd_seq_queue_timer_set_resolution = _lib.snd_seq_queue_timer_set_resolution
snd_seq_queue_timer_set_resolution.restype = None
snd_seq_queue_timer_set_resolution.argtypes = [POINTER(snd_seq_queue_timer_t), c_uint]

# /usr/include/alsa/seq.h:509
snd_seq_get_queue_timer = _lib.snd_seq_get_queue_timer
snd_seq_get_queue_timer.restype = c_int
snd_seq_get_queue_timer.argtypes = [POINTER(snd_seq_t), c_int, POINTER(snd_seq_queue_timer_t)]

# /usr/include/alsa/seq.h:510
snd_seq_set_queue_timer = _lib.snd_seq_set_queue_timer
snd_seq_set_queue_timer.restype = c_int
snd_seq_set_queue_timer.argtypes = [POINTER(snd_seq_t), c_int, POINTER(snd_seq_queue_timer_t)]

# /usr/include/alsa/seq.h:521
snd_seq_free_event = _lib.snd_seq_free_event
snd_seq_free_event.restype = c_int
snd_seq_free_event.argtypes = [POINTER(snd_seq_event_t)]

# /usr/include/alsa/seq.h:522
snd_seq_event_length = _lib.snd_seq_event_length
snd_seq_event_length.restype = ssize_t
snd_seq_event_length.argtypes = [POINTER(snd_seq_event_t)]

# /usr/include/alsa/seq.h:523
snd_seq_event_output = _lib.snd_seq_event_output
snd_seq_event_output.restype = c_int
snd_seq_event_output.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_event_t)]

# /usr/include/alsa/seq.h:524
snd_seq_event_output_buffer = _lib.snd_seq_event_output_buffer
snd_seq_event_output_buffer.restype = c_int
snd_seq_event_output_buffer.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_event_t)]

# /usr/include/alsa/seq.h:525
snd_seq_event_output_direct = _lib.snd_seq_event_output_direct
snd_seq_event_output_direct.restype = c_int
snd_seq_event_output_direct.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_event_t)]

# /usr/include/alsa/seq.h:526
snd_seq_event_input = _lib.snd_seq_event_input
snd_seq_event_input.restype = c_int
snd_seq_event_input.argtypes = [POINTER(snd_seq_t), POINTER(POINTER(snd_seq_event_t))]

# /usr/include/alsa/seq.h:527
snd_seq_event_input_pending = _lib.snd_seq_event_input_pending
snd_seq_event_input_pending.restype = c_int
snd_seq_event_input_pending.argtypes = [POINTER(snd_seq_t), c_int]

# /usr/include/alsa/seq.h:528
snd_seq_drain_output = _lib.snd_seq_drain_output
snd_seq_drain_output.restype = c_int
snd_seq_drain_output.argtypes = [POINTER(snd_seq_t)]

# /usr/include/alsa/seq.h:529
snd_seq_event_output_pending = _lib.snd_seq_event_output_pending
snd_seq_event_output_pending.restype = c_int
snd_seq_event_output_pending.argtypes = [POINTER(snd_seq_t)]

# /usr/include/alsa/seq.h:530
snd_seq_extract_output = _lib.snd_seq_extract_output
snd_seq_extract_output.restype = c_int
snd_seq_extract_output.argtypes = [POINTER(snd_seq_t), POINTER(POINTER(snd_seq_event_t))]

# /usr/include/alsa/seq.h:531
snd_seq_drop_output = _lib.snd_seq_drop_output
snd_seq_drop_output.restype = c_int
snd_seq_drop_output.argtypes = [POINTER(snd_seq_t)]

# /usr/include/alsa/seq.h:532
snd_seq_drop_output_buffer = _lib.snd_seq_drop_output_buffer
snd_seq_drop_output_buffer.restype = c_int
snd_seq_drop_output_buffer.argtypes = [POINTER(snd_seq_t)]

# /usr/include/alsa/seq.h:533
snd_seq_drop_input = _lib.snd_seq_drop_input
snd_seq_drop_input.restype = c_int
snd_seq_drop_input.argtypes = [POINTER(snd_seq_t)]

# /usr/include/alsa/seq.h:534
snd_seq_drop_input_buffer = _lib.snd_seq_drop_input_buffer
snd_seq_drop_input_buffer.restype = c_int
snd_seq_drop_input_buffer.argtypes = [POINTER(snd_seq_t)]

class struct__snd_seq_remove_events(Structure):
    __slots__ = [
    ]
struct__snd_seq_remove_events._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_seq_remove_events(Structure):
    __slots__ = [
    ]
struct__snd_seq_remove_events._fields_ = [
    ('_opaque_struct', c_int)
]

snd_seq_remove_events_t = struct__snd_seq_remove_events 	# /usr/include/alsa/seq.h:537
SND_SEQ_REMOVE_INPUT = 1 	# /usr/include/alsa/seq.h:540
SND_SEQ_REMOVE_OUTPUT = 2 	# /usr/include/alsa/seq.h:541
SND_SEQ_REMOVE_DEST = 4 	# /usr/include/alsa/seq.h:542
SND_SEQ_REMOVE_DEST_CHANNEL = 8 	# /usr/include/alsa/seq.h:543
SND_SEQ_REMOVE_TIME_BEFORE = 16 	# /usr/include/alsa/seq.h:544
SND_SEQ_REMOVE_TIME_AFTER = 32 	# /usr/include/alsa/seq.h:545
SND_SEQ_REMOVE_TIME_TICK = 64 	# /usr/include/alsa/seq.h:546
SND_SEQ_REMOVE_EVENT_TYPE = 128 	# /usr/include/alsa/seq.h:547
SND_SEQ_REMOVE_IGNORE_OFF = 256 	# /usr/include/alsa/seq.h:548
SND_SEQ_REMOVE_TAG_MATCH = 512 	# /usr/include/alsa/seq.h:549
# /usr/include/alsa/seq.h:551
snd_seq_remove_events_sizeof = _lib.snd_seq_remove_events_sizeof
snd_seq_remove_events_sizeof.restype = c_size_t
snd_seq_remove_events_sizeof.argtypes = []

# /usr/include/alsa/seq.h:555
snd_seq_remove_events_malloc = _lib.snd_seq_remove_events_malloc
snd_seq_remove_events_malloc.restype = c_int
snd_seq_remove_events_malloc.argtypes = [POINTER(POINTER(snd_seq_remove_events_t))]

# /usr/include/alsa/seq.h:556
snd_seq_remove_events_free = _lib.snd_seq_remove_events_free
snd_seq_remove_events_free.restype = None
snd_seq_remove_events_free.argtypes = [POINTER(snd_seq_remove_events_t)]

# /usr/include/alsa/seq.h:557
snd_seq_remove_events_copy = _lib.snd_seq_remove_events_copy
snd_seq_remove_events_copy.restype = None
snd_seq_remove_events_copy.argtypes = [POINTER(snd_seq_remove_events_t), POINTER(snd_seq_remove_events_t)]

# /usr/include/alsa/seq.h:559
snd_seq_remove_events_get_condition = _lib.snd_seq_remove_events_get_condition
snd_seq_remove_events_get_condition.restype = c_uint
snd_seq_remove_events_get_condition.argtypes = [POINTER(snd_seq_remove_events_t)]

# /usr/include/alsa/seq.h:560
snd_seq_remove_events_get_queue = _lib.snd_seq_remove_events_get_queue
snd_seq_remove_events_get_queue.restype = c_int
snd_seq_remove_events_get_queue.argtypes = [POINTER(snd_seq_remove_events_t)]

# /usr/include/alsa/seq.h:561
snd_seq_remove_events_get_time = _lib.snd_seq_remove_events_get_time
snd_seq_remove_events_get_time.restype = POINTER(snd_seq_timestamp_t)
snd_seq_remove_events_get_time.argtypes = [POINTER(snd_seq_remove_events_t)]

# /usr/include/alsa/seq.h:562
snd_seq_remove_events_get_dest = _lib.snd_seq_remove_events_get_dest
snd_seq_remove_events_get_dest.restype = POINTER(snd_seq_addr_t)
snd_seq_remove_events_get_dest.argtypes = [POINTER(snd_seq_remove_events_t)]

# /usr/include/alsa/seq.h:563
snd_seq_remove_events_get_channel = _lib.snd_seq_remove_events_get_channel
snd_seq_remove_events_get_channel.restype = c_int
snd_seq_remove_events_get_channel.argtypes = [POINTER(snd_seq_remove_events_t)]

# /usr/include/alsa/seq.h:564
snd_seq_remove_events_get_event_type = _lib.snd_seq_remove_events_get_event_type
snd_seq_remove_events_get_event_type.restype = c_int
snd_seq_remove_events_get_event_type.argtypes = [POINTER(snd_seq_remove_events_t)]

# /usr/include/alsa/seq.h:565
snd_seq_remove_events_get_tag = _lib.snd_seq_remove_events_get_tag
snd_seq_remove_events_get_tag.restype = c_int
snd_seq_remove_events_get_tag.argtypes = [POINTER(snd_seq_remove_events_t)]

# /usr/include/alsa/seq.h:567
snd_seq_remove_events_set_condition = _lib.snd_seq_remove_events_set_condition
snd_seq_remove_events_set_condition.restype = None
snd_seq_remove_events_set_condition.argtypes = [POINTER(snd_seq_remove_events_t), c_uint]

# /usr/include/alsa/seq.h:568
snd_seq_remove_events_set_queue = _lib.snd_seq_remove_events_set_queue
snd_seq_remove_events_set_queue.restype = None
snd_seq_remove_events_set_queue.argtypes = [POINTER(snd_seq_remove_events_t), c_int]

# /usr/include/alsa/seq.h:569
snd_seq_remove_events_set_time = _lib.snd_seq_remove_events_set_time
snd_seq_remove_events_set_time.restype = None
snd_seq_remove_events_set_time.argtypes = [POINTER(snd_seq_remove_events_t), POINTER(snd_seq_timestamp_t)]

# /usr/include/alsa/seq.h:570
snd_seq_remove_events_set_dest = _lib.snd_seq_remove_events_set_dest
snd_seq_remove_events_set_dest.restype = None
snd_seq_remove_events_set_dest.argtypes = [POINTER(snd_seq_remove_events_t), POINTER(snd_seq_addr_t)]

# /usr/include/alsa/seq.h:571
snd_seq_remove_events_set_channel = _lib.snd_seq_remove_events_set_channel
snd_seq_remove_events_set_channel.restype = None
snd_seq_remove_events_set_channel.argtypes = [POINTER(snd_seq_remove_events_t), c_int]

# /usr/include/alsa/seq.h:572
snd_seq_remove_events_set_event_type = _lib.snd_seq_remove_events_set_event_type
snd_seq_remove_events_set_event_type.restype = None
snd_seq_remove_events_set_event_type.argtypes = [POINTER(snd_seq_remove_events_t), c_int]

# /usr/include/alsa/seq.h:573
snd_seq_remove_events_set_tag = _lib.snd_seq_remove_events_set_tag
snd_seq_remove_events_set_tag.restype = None
snd_seq_remove_events_set_tag.argtypes = [POINTER(snd_seq_remove_events_t), c_int]

# /usr/include/alsa/seq.h:575
snd_seq_remove_events = _lib.snd_seq_remove_events
snd_seq_remove_events.restype = c_int
snd_seq_remove_events.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_remove_events_t)]

# /usr/include/alsa/seq.h:586
snd_seq_set_bit = _lib.snd_seq_set_bit
snd_seq_set_bit.restype = None
snd_seq_set_bit.argtypes = [c_int, POINTER(None)]

# /usr/include/alsa/seq.h:587
snd_seq_change_bit = _lib.snd_seq_change_bit
snd_seq_change_bit.restype = c_int
snd_seq_change_bit.argtypes = [c_int, POINTER(None)]

# /usr/include/alsa/seq.h:588
snd_seq_get_bit = _lib.snd_seq_get_bit
snd_seq_get_bit.restype = c_int
snd_seq_get_bit.argtypes = [c_int, POINTER(None)]

# /usr/include/alsa/seqmid.h:288
snd_seq_control_queue = _lib.snd_seq_control_queue
snd_seq_control_queue.restype = c_int
snd_seq_control_queue.argtypes = [POINTER(snd_seq_t), c_int, c_int, c_int, POINTER(snd_seq_event_t)]

# /usr/include/alsa/seqmid.h:328
snd_seq_create_simple_port = _lib.snd_seq_create_simple_port
snd_seq_create_simple_port.restype = c_int
snd_seq_create_simple_port.argtypes = [POINTER(snd_seq_t), c_char_p, c_uint, c_uint]

# /usr/include/alsa/seqmid.h:331
snd_seq_delete_simple_port = _lib.snd_seq_delete_simple_port
snd_seq_delete_simple_port.restype = c_int
snd_seq_delete_simple_port.argtypes = [POINTER(snd_seq_t), c_int]

# /usr/include/alsa/seqmid.h:336
snd_seq_connect_from = _lib.snd_seq_connect_from
snd_seq_connect_from.restype = c_int
snd_seq_connect_from.argtypes = [POINTER(snd_seq_t), c_int, c_int, c_int]

# /usr/include/alsa/seqmid.h:337
snd_seq_connect_to = _lib.snd_seq_connect_to
snd_seq_connect_to.restype = c_int
snd_seq_connect_to.argtypes = [POINTER(snd_seq_t), c_int, c_int, c_int]

# /usr/include/alsa/seqmid.h:338
snd_seq_disconnect_from = _lib.snd_seq_disconnect_from
snd_seq_disconnect_from.restype = c_int
snd_seq_disconnect_from.argtypes = [POINTER(snd_seq_t), c_int, c_int, c_int]

# /usr/include/alsa/seqmid.h:339
snd_seq_disconnect_to = _lib.snd_seq_disconnect_to
snd_seq_disconnect_to.restype = c_int
snd_seq_disconnect_to.argtypes = [POINTER(snd_seq_t), c_int, c_int, c_int]

# /usr/include/alsa/seqmid.h:344
snd_seq_set_client_name = _lib.snd_seq_set_client_name
snd_seq_set_client_name.restype = c_int
snd_seq_set_client_name.argtypes = [POINTER(snd_seq_t), c_char_p]

# /usr/include/alsa/seqmid.h:345
snd_seq_set_client_event_filter = _lib.snd_seq_set_client_event_filter
snd_seq_set_client_event_filter.restype = c_int
snd_seq_set_client_event_filter.argtypes = [POINTER(snd_seq_t), c_int]

# /usr/include/alsa/seqmid.h:346
snd_seq_set_client_pool_output = _lib.snd_seq_set_client_pool_output
snd_seq_set_client_pool_output.restype = c_int
snd_seq_set_client_pool_output.argtypes = [POINTER(snd_seq_t), c_size_t]

# /usr/include/alsa/seqmid.h:347
snd_seq_set_client_pool_output_room = _lib.snd_seq_set_client_pool_output_room
snd_seq_set_client_pool_output_room.restype = c_int
snd_seq_set_client_pool_output_room.argtypes = [POINTER(snd_seq_t), c_size_t]

# /usr/include/alsa/seqmid.h:348
snd_seq_set_client_pool_input = _lib.snd_seq_set_client_pool_input
snd_seq_set_client_pool_input.restype = c_int
snd_seq_set_client_pool_input.argtypes = [POINTER(snd_seq_t), c_size_t]

# /usr/include/alsa/seqmid.h:350
snd_seq_sync_output_queue = _lib.snd_seq_sync_output_queue
snd_seq_sync_output_queue.restype = c_int
snd_seq_sync_output_queue.argtypes = [POINTER(snd_seq_t)]

# /usr/include/alsa/seqmid.h:355
snd_seq_parse_address = _lib.snd_seq_parse_address
snd_seq_parse_address.restype = c_int
snd_seq_parse_address.argtypes = [POINTER(snd_seq_t), POINTER(snd_seq_addr_t), c_char_p]

# /usr/include/alsa/seqmid.h:360
snd_seq_reset_pool_output = _lib.snd_seq_reset_pool_output
snd_seq_reset_pool_output.restype = c_int
snd_seq_reset_pool_output.argtypes = [POINTER(snd_seq_t)]

# /usr/include/alsa/seqmid.h:361
snd_seq_reset_pool_input = _lib.snd_seq_reset_pool_input
snd_seq_reset_pool_input.restype = c_int
snd_seq_reset_pool_input.argtypes = [POINTER(snd_seq_t)]

class struct_snd_midi_event(Structure):
    __slots__ = [
    ]
struct_snd_midi_event._fields_ = [
    ('_opaque_struct', c_int)
]

class struct_snd_midi_event(Structure):
    __slots__ = [
    ]
struct_snd_midi_event._fields_ = [
    ('_opaque_struct', c_int)
]

snd_midi_event_t = struct_snd_midi_event 	# /usr/include/alsa/seq_midi_event.h:43
# /usr/include/alsa/seq_midi_event.h:45
snd_midi_event_new = _lib.snd_midi_event_new
snd_midi_event_new.restype = c_int
snd_midi_event_new.argtypes = [c_size_t, POINTER(POINTER(snd_midi_event_t))]

# /usr/include/alsa/seq_midi_event.h:46
snd_midi_event_resize_buffer = _lib.snd_midi_event_resize_buffer
snd_midi_event_resize_buffer.restype = c_int
snd_midi_event_resize_buffer.argtypes = [POINTER(snd_midi_event_t), c_size_t]

# /usr/include/alsa/seq_midi_event.h:47
snd_midi_event_free = _lib.snd_midi_event_free
snd_midi_event_free.restype = None
snd_midi_event_free.argtypes = [POINTER(snd_midi_event_t)]

# /usr/include/alsa/seq_midi_event.h:48
snd_midi_event_init = _lib.snd_midi_event_init
snd_midi_event_init.restype = None
snd_midi_event_init.argtypes = [POINTER(snd_midi_event_t)]

# /usr/include/alsa/seq_midi_event.h:49
snd_midi_event_reset_encode = _lib.snd_midi_event_reset_encode
snd_midi_event_reset_encode.restype = None
snd_midi_event_reset_encode.argtypes = [POINTER(snd_midi_event_t)]

# /usr/include/alsa/seq_midi_event.h:50
snd_midi_event_reset_decode = _lib.snd_midi_event_reset_decode
snd_midi_event_reset_decode.restype = None
snd_midi_event_reset_decode.argtypes = [POINTER(snd_midi_event_t)]

# /usr/include/alsa/seq_midi_event.h:51
snd_midi_event_no_status = _lib.snd_midi_event_no_status
snd_midi_event_no_status.restype = None
snd_midi_event_no_status.argtypes = [POINTER(snd_midi_event_t), c_int]

# /usr/include/alsa/seq_midi_event.h:53
snd_midi_event_encode = _lib.snd_midi_event_encode
snd_midi_event_encode.restype = c_long
snd_midi_event_encode.argtypes = [POINTER(snd_midi_event_t), POINTER(c_ubyte), c_long, POINTER(snd_seq_event_t)]

# /usr/include/alsa/seq_midi_event.h:54
snd_midi_event_encode_byte = _lib.snd_midi_event_encode_byte
snd_midi_event_encode_byte.restype = c_int
snd_midi_event_encode_byte.argtypes = [POINTER(snd_midi_event_t), c_int, POINTER(snd_seq_event_t)]

# /usr/include/alsa/seq_midi_event.h:56
snd_midi_event_decode = _lib.snd_midi_event_decode
snd_midi_event_decode.restype = c_long
snd_midi_event_decode.argtypes = [POINTER(snd_midi_event_t), POINTER(c_ubyte), c_long, POINTER(snd_seq_event_t)]

class struct__snd_instr_header(Structure):
    __slots__ = [
    ]
struct__snd_instr_header._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_instr_header(Structure):
    __slots__ = [
    ]
struct__snd_instr_header._fields_ = [
    ('_opaque_struct', c_int)
]

snd_instr_header_t = struct__snd_instr_header 	# /usr/include/alsa/instr.h:44
# /usr/include/alsa/instr.h:46
snd_instr_header_sizeof = _lib.snd_instr_header_sizeof
snd_instr_header_sizeof.restype = c_size_t
snd_instr_header_sizeof.argtypes = []

# /usr/include/alsa/instr.h:53
snd_instr_header_malloc = _lib.snd_instr_header_malloc
snd_instr_header_malloc.restype = c_int
snd_instr_header_malloc.argtypes = [POINTER(POINTER(snd_instr_header_t)), c_size_t]

# /usr/include/alsa/instr.h:54
snd_instr_header_free = _lib.snd_instr_header_free
snd_instr_header_free.restype = None
snd_instr_header_free.argtypes = [POINTER(snd_instr_header_t)]

# /usr/include/alsa/instr.h:55
snd_instr_header_copy = _lib.snd_instr_header_copy
snd_instr_header_copy.restype = None
snd_instr_header_copy.argtypes = [POINTER(snd_instr_header_t), POINTER(snd_instr_header_t)]

# /usr/include/alsa/instr.h:57
snd_instr_header_get_id = _lib.snd_instr_header_get_id
snd_instr_header_get_id.restype = POINTER(snd_seq_instr_t)
snd_instr_header_get_id.argtypes = [POINTER(snd_instr_header_t)]

# /usr/include/alsa/instr.h:58
snd_instr_header_get_cluster = _lib.snd_instr_header_get_cluster
snd_instr_header_get_cluster.restype = snd_seq_instr_cluster_t
snd_instr_header_get_cluster.argtypes = [POINTER(snd_instr_header_t)]

# /usr/include/alsa/instr.h:59
snd_instr_header_get_cmd = _lib.snd_instr_header_get_cmd
snd_instr_header_get_cmd.restype = c_uint
snd_instr_header_get_cmd.argtypes = [POINTER(snd_instr_header_t)]

# /usr/include/alsa/instr.h:60
snd_instr_header_get_len = _lib.snd_instr_header_get_len
snd_instr_header_get_len.restype = c_size_t
snd_instr_header_get_len.argtypes = [POINTER(snd_instr_header_t)]

# /usr/include/alsa/instr.h:61
snd_instr_header_get_name = _lib.snd_instr_header_get_name
snd_instr_header_get_name.restype = c_char_p
snd_instr_header_get_name.argtypes = [POINTER(snd_instr_header_t)]

# /usr/include/alsa/instr.h:62
snd_instr_header_get_type = _lib.snd_instr_header_get_type
snd_instr_header_get_type.restype = c_int
snd_instr_header_get_type.argtypes = [POINTER(snd_instr_header_t)]

# /usr/include/alsa/instr.h:63
snd_instr_header_get_format = _lib.snd_instr_header_get_format
snd_instr_header_get_format.restype = c_char_p
snd_instr_header_get_format.argtypes = [POINTER(snd_instr_header_t)]

# /usr/include/alsa/instr.h:64
snd_instr_header_get_alias = _lib.snd_instr_header_get_alias
snd_instr_header_get_alias.restype = POINTER(snd_seq_instr_t)
snd_instr_header_get_alias.argtypes = [POINTER(snd_instr_header_t)]

# /usr/include/alsa/instr.h:65
snd_instr_header_get_data = _lib.snd_instr_header_get_data
snd_instr_header_get_data.restype = POINTER(c_void)
snd_instr_header_get_data.argtypes = [POINTER(snd_instr_header_t)]

# /usr/include/alsa/instr.h:66
snd_instr_header_get_follow_alias = _lib.snd_instr_header_get_follow_alias
snd_instr_header_get_follow_alias.restype = c_int
snd_instr_header_get_follow_alias.argtypes = [POINTER(snd_instr_header_t)]

# /usr/include/alsa/instr.h:68
snd_instr_header_set_id = _lib.snd_instr_header_set_id
snd_instr_header_set_id.restype = None
snd_instr_header_set_id.argtypes = [POINTER(snd_instr_header_t), POINTER(snd_seq_instr_t)]

# /usr/include/alsa/instr.h:69
snd_instr_header_set_cluster = _lib.snd_instr_header_set_cluster
snd_instr_header_set_cluster.restype = None
snd_instr_header_set_cluster.argtypes = [POINTER(snd_instr_header_t), snd_seq_instr_cluster_t]

# /usr/include/alsa/instr.h:70
snd_instr_header_set_cmd = _lib.snd_instr_header_set_cmd
snd_instr_header_set_cmd.restype = None
snd_instr_header_set_cmd.argtypes = [POINTER(snd_instr_header_t), c_uint]

# /usr/include/alsa/instr.h:71
snd_instr_header_set_len = _lib.snd_instr_header_set_len
snd_instr_header_set_len.restype = None
snd_instr_header_set_len.argtypes = [POINTER(snd_instr_header_t), c_size_t]

# /usr/include/alsa/instr.h:72
snd_instr_header_set_name = _lib.snd_instr_header_set_name
snd_instr_header_set_name.restype = None
snd_instr_header_set_name.argtypes = [POINTER(snd_instr_header_t), c_char_p]

# /usr/include/alsa/instr.h:73
snd_instr_header_set_type = _lib.snd_instr_header_set_type
snd_instr_header_set_type.restype = None
snd_instr_header_set_type.argtypes = [POINTER(snd_instr_header_t), c_int]

# /usr/include/alsa/instr.h:74
snd_instr_header_set_format = _lib.snd_instr_header_set_format
snd_instr_header_set_format.restype = None
snd_instr_header_set_format.argtypes = [POINTER(snd_instr_header_t), c_char_p]

# /usr/include/alsa/instr.h:75
snd_instr_header_set_alias = _lib.snd_instr_header_set_alias
snd_instr_header_set_alias.restype = None
snd_instr_header_set_alias.argtypes = [POINTER(snd_instr_header_t), POINTER(snd_seq_instr_t)]

# /usr/include/alsa/instr.h:76
snd_instr_header_set_follow_alias = _lib.snd_instr_header_set_follow_alias
snd_instr_header_set_follow_alias.restype = None
snd_instr_header_set_follow_alias.argtypes = [POINTER(snd_instr_header_t), c_int]

SND_SEQ_INSTR_ATYPE_DATA = 0 	# /usr/include/alsa/instr.h:84
SND_SEQ_INSTR_ATYPE_ALIAS = 1 	# /usr/include/alsa/instr.h:85
SND_SEQ_INSTR_TYPE0_DLS1 = 1 	# /usr/include/alsa/instr.h:98
SND_SEQ_INSTR_TYPE0_DLS2 = 2 	# /usr/include/alsa/instr.h:99
SND_SEQ_INSTR_TYPE1_SIMPLE = 1 	# /usr/include/alsa/instr.h:100
SND_SEQ_INSTR_TYPE1_SOUNDFONT = 2 	# /usr/include/alsa/instr.h:101
SND_SEQ_INSTR_TYPE1_GUS_PATCH = 4 	# /usr/include/alsa/instr.h:102
SND_SEQ_INSTR_TYPE1_INTERWAVE = 8 	# /usr/include/alsa/instr.h:103
SND_SEQ_INSTR_TYPE2_OPL2_3 = 1 	# /usr/include/alsa/instr.h:104
SND_SEQ_INSTR_TYPE2_OPL4 = 2 	# /usr/include/alsa/instr.h:105
SND_SEQ_INSTR_PUT_CMD_CREATE = 0 	# /usr/include/alsa/instr.h:108
SND_SEQ_INSTR_PUT_CMD_REPLACE = 1 	# /usr/include/alsa/instr.h:109
SND_SEQ_INSTR_PUT_CMD_MODIFY = 2 	# /usr/include/alsa/instr.h:110
SND_SEQ_INSTR_PUT_CMD_ADD = 3 	# /usr/include/alsa/instr.h:111
SND_SEQ_INSTR_PUT_CMD_REMOVE = 4 	# /usr/include/alsa/instr.h:112
SND_SEQ_INSTR_GET_CMD_FULL = 0 	# /usr/include/alsa/instr.h:115
SND_SEQ_INSTR_GET_CMD_PARTIAL = 1 	# /usr/include/alsa/instr.h:116
SND_SEQ_INSTR_QUERY_FOLLOW_ALIAS = 1 	# /usr/include/alsa/instr.h:119
SND_SEQ_INSTR_FREE_CMD_ALL = 0 	# /usr/include/alsa/instr.h:122
SND_SEQ_INSTR_FREE_CMD_PRIVATE = 1 	# /usr/include/alsa/instr.h:123
SND_SEQ_INSTR_FREE_CMD_CLUSTER = 2 	# /usr/include/alsa/instr.h:124
SND_SEQ_INSTR_FREE_CMD_SINGLE = 3 	# /usr/include/alsa/instr.h:125
snd_instr_fm_t = None 	# /usr/include/alsa/instr.h:133
# /usr/include/alsa/instr.h:135
snd_instr_fm_convert_to_stream = _lib.snd_instr_fm_convert_to_stream
snd_instr_fm_convert_to_stream.restype = c_int
snd_instr_fm_convert_to_stream.argtypes = [POINTER(snd_instr_fm_t), c_char_p, POINTER(POINTER(snd_instr_header_t)), POINTER(c_size_t)]

# /usr/include/alsa/instr.h:136
snd_instr_fm_convert_from_stream = _lib.snd_instr_fm_convert_from_stream
snd_instr_fm_convert_from_stream.restype = c_int
snd_instr_fm_convert_from_stream.argtypes = [POINTER(snd_instr_header_t), c_size_t, POINTER(POINTER(snd_instr_fm_t))]

# /usr/include/alsa/instr.h:137
snd_instr_fm_free = _lib.snd_instr_fm_free
snd_instr_fm_free.restype = c_int
snd_instr_fm_free.argtypes = [POINTER(snd_instr_fm_t)]

snd_instr_simple_t = None 	# /usr/include/alsa/instr.h:145
# /usr/include/alsa/instr.h:147
snd_instr_simple_convert_to_stream = _lib.snd_instr_simple_convert_to_stream
snd_instr_simple_convert_to_stream.restype = c_int
snd_instr_simple_convert_to_stream.argtypes = [POINTER(snd_instr_simple_t), c_char_p, POINTER(POINTER(snd_instr_header_t)), POINTER(c_size_t)]

# /usr/include/alsa/instr.h:148
snd_instr_simple_convert_from_stream = _lib.snd_instr_simple_convert_from_stream
snd_instr_simple_convert_from_stream.restype = c_int
snd_instr_simple_convert_from_stream.argtypes = [POINTER(snd_instr_header_t), c_size_t, POINTER(POINTER(snd_instr_simple_t))]

# /usr/include/alsa/instr.h:149
snd_instr_simple_free = _lib.snd_instr_simple_free
snd_instr_simple_free.restype = c_int
snd_instr_simple_free.argtypes = [POINTER(snd_instr_simple_t)]

snd_instr_iwffff_t = None 	# /usr/include/alsa/instr.h:157
class struct__snd_iwffff_handle(Structure):
    __slots__ = [
    ]
struct__snd_iwffff_handle._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__snd_iwffff_handle(Structure):
    __slots__ = [
    ]
struct__snd_iwffff_handle._fields_ = [
    ('_opaque_struct', c_int)
]

snd_iwffff_handle_t = struct__snd_iwffff_handle 	# /usr/include/alsa/instr.h:159
# /usr/include/alsa/instr.h:161
snd_instr_iwffff_open = _lib.snd_instr_iwffff_open
snd_instr_iwffff_open.restype = c_int
snd_instr_iwffff_open.argtypes = [POINTER(POINTER(snd_iwffff_handle_t)), c_char_p, c_char_p]

# /usr/include/alsa/instr.h:162
snd_instr_iwffff_open_rom = _lib.snd_instr_iwffff_open_rom
snd_instr_iwffff_open_rom.restype = c_int
snd_instr_iwffff_open_rom.argtypes = [POINTER(POINTER(snd_iwffff_handle_t)), c_int, c_int, c_int]

# /usr/include/alsa/instr.h:163
snd_instr_iwffff_open_rom_file = _lib.snd_instr_iwffff_open_rom_file
snd_instr_iwffff_open_rom_file.restype = c_int
snd_instr_iwffff_open_rom_file.argtypes = [POINTER(POINTER(snd_iwffff_handle_t)), c_char_p, c_int, c_int]

# /usr/include/alsa/instr.h:164
snd_instr_iwffff_close = _lib.snd_instr_iwffff_close
snd_instr_iwffff_close.restype = c_int
snd_instr_iwffff_close.argtypes = [POINTER(snd_iwffff_handle_t)]

# /usr/include/alsa/instr.h:165
snd_instr_iwffff_load = _lib.snd_instr_iwffff_load
snd_instr_iwffff_load.restype = c_int
snd_instr_iwffff_load.argtypes = [POINTER(snd_iwffff_handle_t), c_int, c_int, POINTER(POINTER(snd_instr_iwffff_t))]

# /usr/include/alsa/instr.h:166
snd_instr_iwffff_convert_to_stream = _lib.snd_instr_iwffff_convert_to_stream
snd_instr_iwffff_convert_to_stream.restype = c_int
snd_instr_iwffff_convert_to_stream.argtypes = [POINTER(snd_instr_iwffff_t), c_char_p, POINTER(POINTER(snd_instr_header_t)), POINTER(c_size_t)]

# /usr/include/alsa/instr.h:167
snd_instr_iwffff_convert_from_stream = _lib.snd_instr_iwffff_convert_from_stream
snd_instr_iwffff_convert_from_stream.restype = c_int
snd_instr_iwffff_convert_from_stream.argtypes = [POINTER(snd_instr_header_t), c_size_t, POINTER(POINTER(snd_instr_iwffff_t))]

# /usr/include/alsa/instr.h:168
snd_instr_iwffff_free = _lib.snd_instr_iwffff_free
snd_instr_iwffff_free.restype = c_int
snd_instr_iwffff_free.argtypes = [POINTER(snd_instr_iwffff_t)]


__all__ = ['alsa_lisp_default_cfg_free', 'alsa_lisp', 'alsa_lisp_free',
'alsa_lisp_result_free', 'alsa_lisp_seq_first', 'alsa_lisp_seq_next',
'alsa_lisp_seq_count', 'alsa_lisp_seq_integer', 'alsa_lisp_seq_pointer',
'IEC958_AES0_PROFESSIONAL', 'IEC958_AES0_NONAUDIO',
'IEC958_AES0_PRO_EMPHASIS', 'IEC958_AES0_PRO_EMPHASIS_NOTID',
'IEC958_AES0_PRO_EMPHASIS_NONE', 'IEC958_AES0_PRO_EMPHASIS_5015',
'IEC958_AES0_PRO_EMPHASIS_CCITT', 'IEC958_AES0_PRO_FREQ_UNLOCKED',
'IEC958_AES0_PRO_FS', 'IEC958_AES0_PRO_FS_NOTID', 'IEC958_AES0_PRO_FS_44100',
'IEC958_AES0_PRO_FS_48000', 'IEC958_AES0_PRO_FS_32000',
'IEC958_AES0_CON_NOT_COPYRIGHT', 'IEC958_AES0_CON_EMPHASIS',
'IEC958_AES0_CON_EMPHASIS_NONE', 'IEC958_AES0_CON_EMPHASIS_5015',
'IEC958_AES0_CON_MODE', 'IEC958_AES1_PRO_MODE', 'IEC958_AES1_PRO_MODE_NOTID',
'IEC958_AES1_PRO_MODE_STEREOPHONIC', 'IEC958_AES1_PRO_MODE_SINGLE',
'IEC958_AES1_PRO_MODE_TWO', 'IEC958_AES1_PRO_MODE_PRIMARY',
'IEC958_AES1_PRO_MODE_BYTE3', 'IEC958_AES1_PRO_USERBITS',
'IEC958_AES1_PRO_USERBITS_NOTID', 'IEC958_AES1_PRO_USERBITS_192',
'IEC958_AES1_PRO_USERBITS_UDEF', 'IEC958_AES1_CON_CATEGORY',
'IEC958_AES1_CON_GENERAL', 'IEC958_AES1_CON_EXPERIMENTAL',
'IEC958_AES1_CON_SOLIDMEM_MASK', 'IEC958_AES1_CON_SOLIDMEM_ID',
'IEC958_AES1_CON_BROADCAST1_MASK', 'IEC958_AES1_CON_BROADCAST1_ID',
'IEC958_AES1_CON_DIGDIGCONV_MASK', 'IEC958_AES1_CON_DIGDIGCONV_ID',
'IEC958_AES1_CON_ADC_COPYRIGHT_MASK', 'IEC958_AES1_CON_ADC_COPYRIGHT_ID',
'IEC958_AES1_CON_ADC_MASK', 'IEC958_AES1_CON_ADC_ID',
'IEC958_AES1_CON_BROADCAST2_MASK', 'IEC958_AES1_CON_BROADCAST2_ID',
'IEC958_AES1_CON_LASEROPT_MASK', 'IEC958_AES1_CON_LASEROPT_ID',
'IEC958_AES1_CON_MUSICAL_MASK', 'IEC958_AES1_CON_MUSICAL_ID',
'IEC958_AES1_CON_MAGNETIC_MASK', 'IEC958_AES1_CON_MAGNETIC_ID',
'IEC958_AES1_CON_IEC908_CD', 'IEC958_AES1_CON_NON_IEC908_CD',
'IEC958_AES1_CON_PCM_CODER', 'IEC958_AES1_CON_SAMPLER',
'IEC958_AES1_CON_MIXER', 'IEC958_AES1_CON_RATE_CONVERTER',
'IEC958_AES1_CON_SYNTHESIZER', 'IEC958_AES1_CON_MICROPHONE',
'IEC958_AES1_CON_DAT', 'IEC958_AES1_CON_VCR', 'IEC958_AES1_CON_ORIGINAL',
'IEC958_AES2_PRO_SBITS', 'IEC958_AES2_PRO_SBITS_20',
'IEC958_AES2_PRO_SBITS_24', 'IEC958_AES2_PRO_SBITS_UDEF',
'IEC958_AES2_PRO_WORDLEN', 'IEC958_AES2_PRO_WORDLEN_NOTID',
'IEC958_AES2_PRO_WORDLEN_22_18', 'IEC958_AES2_PRO_WORDLEN_23_19',
'IEC958_AES2_PRO_WORDLEN_24_20', 'IEC958_AES2_PRO_WORDLEN_20_16',
'IEC958_AES2_CON_SOURCE', 'IEC958_AES2_CON_SOURCE_UNSPEC',
'IEC958_AES2_CON_CHANNEL', 'IEC958_AES2_CON_CHANNEL_UNSPEC',
'IEC958_AES3_CON_FS', 'IEC958_AES3_CON_FS_44100', 'IEC958_AES3_CON_FS_48000',
'IEC958_AES3_CON_FS_32000', 'IEC958_AES3_CON_CLOCK',
'IEC958_AES3_CON_CLOCK_1000PPM', 'IEC958_AES3_CON_CLOCK_50PPM',
'IEC958_AES3_CON_CLOCK_VARIABLE', 'MIDI_CHANNELS', 'MIDI_GM_DRUM_CHANNEL',
'MIDI_CMD_NOTE_OFF', 'MIDI_CMD_NOTE_ON', 'MIDI_CMD_NOTE_PRESSURE',
'MIDI_CMD_CONTROL', 'MIDI_CMD_PGM_CHANGE', 'MIDI_CMD_CHANNEL_PRESSURE',
'MIDI_CMD_BENDER', 'MIDI_CMD_COMMON_SYSEX', 'MIDI_CMD_COMMON_MTC_QUARTER',
'MIDI_CMD_COMMON_SONG_POS', 'MIDI_CMD_COMMON_SONG_SELECT',
'MIDI_CMD_COMMON_TUNE_REQUEST', 'MIDI_CMD_COMMON_SYSEX_END',
'MIDI_CMD_COMMON_CLOCK', 'MIDI_CMD_COMMON_START', 'MIDI_CMD_COMMON_CONTINUE',
'MIDI_CMD_COMMON_STOP', 'MIDI_CMD_COMMON_SENSING', 'MIDI_CMD_COMMON_RESET',
'MIDI_CTL_MSB_BANK', 'MIDI_CTL_MSB_MODWHEEL', 'MIDI_CTL_MSB_BREATH',
'MIDI_CTL_MSB_FOOT', 'MIDI_CTL_MSB_PORTAMENTO_TIME',
'MIDI_CTL_MSB_DATA_ENTRY', 'MIDI_CTL_MSB_MAIN_VOLUME', 'MIDI_CTL_MSB_BALANCE',
'MIDI_CTL_MSB_PAN', 'MIDI_CTL_MSB_EXPRESSION', 'MIDI_CTL_MSB_EFFECT1',
'MIDI_CTL_MSB_EFFECT2', 'MIDI_CTL_MSB_GENERAL_PURPOSE1',
'MIDI_CTL_MSB_GENERAL_PURPOSE2', 'MIDI_CTL_MSB_GENERAL_PURPOSE3',
'MIDI_CTL_MSB_GENERAL_PURPOSE4', 'MIDI_CTL_LSB_BANK', 'MIDI_CTL_LSB_MODWHEEL',
'MIDI_CTL_LSB_BREATH', 'MIDI_CTL_LSB_FOOT', 'MIDI_CTL_LSB_PORTAMENTO_TIME',
'MIDI_CTL_LSB_DATA_ENTRY', 'MIDI_CTL_LSB_MAIN_VOLUME', 'MIDI_CTL_LSB_BALANCE',
'MIDI_CTL_LSB_PAN', 'MIDI_CTL_LSB_EXPRESSION', 'MIDI_CTL_LSB_EFFECT1',
'MIDI_CTL_LSB_EFFECT2', 'MIDI_CTL_LSB_GENERAL_PURPOSE1',
'MIDI_CTL_LSB_GENERAL_PURPOSE2', 'MIDI_CTL_LSB_GENERAL_PURPOSE3',
'MIDI_CTL_LSB_GENERAL_PURPOSE4', 'MIDI_CTL_SUSTAIN', 'MIDI_CTL_PORTAMENTO',
'MIDI_CTL_SOSTENUTO', 'MIDI_CTL_SUSTENUTO', 'MIDI_CTL_SOFT_PEDAL',
'MIDI_CTL_LEGATO_FOOTSWITCH', 'MIDI_CTL_HOLD2',
'MIDI_CTL_SC1_SOUND_VARIATION', 'MIDI_CTL_SC2_TIMBRE',
'MIDI_CTL_SC3_RELEASE_TIME', 'MIDI_CTL_SC4_ATTACK_TIME',
'MIDI_CTL_SC5_BRIGHTNESS', 'MIDI_CTL_SC6', 'MIDI_CTL_SC7', 'MIDI_CTL_SC8',
'MIDI_CTL_SC9', 'MIDI_CTL_SC10', 'MIDI_CTL_GENERAL_PURPOSE5',
'MIDI_CTL_GENERAL_PURPOSE6', 'MIDI_CTL_GENERAL_PURPOSE7',
'MIDI_CTL_GENERAL_PURPOSE8', 'MIDI_CTL_PORTAMENTO_CONTROL',
'MIDI_CTL_E1_REVERB_DEPTH', 'MIDI_CTL_E2_TREMOLO_DEPTH',
'MIDI_CTL_E3_CHORUS_DEPTH', 'MIDI_CTL_E4_DETUNE_DEPTH',
'MIDI_CTL_E5_PHASER_DEPTH', 'MIDI_CTL_DATA_INCREMENT',
'MIDI_CTL_DATA_DECREMENT', 'MIDI_CTL_NONREG_PARM_NUM_LSB',
'MIDI_CTL_NONREG_PARM_NUM_MSB', 'MIDI_CTL_REGIST_PARM_NUM_LSB',
'MIDI_CTL_REGIST_PARM_NUM_MSB', 'MIDI_CTL_ALL_SOUNDS_OFF',
'MIDI_CTL_RESET_CONTROLLERS', 'MIDI_CTL_LOCAL_CONTROL_SWITCH',
'MIDI_CTL_ALL_NOTES_OFF', 'MIDI_CTL_OMNI_OFF', 'MIDI_CTL_OMNI_ON',
'MIDI_CTL_MONO1', 'MIDI_CTL_MONO2', 'IEC958_AES0_PROFESSIONAL',
'IEC958_AES0_NONAUDIO', 'IEC958_AES0_PRO_EMPHASIS',
'IEC958_AES0_PRO_EMPHASIS_NOTID', 'IEC958_AES0_PRO_EMPHASIS_NONE',
'IEC958_AES0_PRO_EMPHASIS_5015', 'IEC958_AES0_PRO_EMPHASIS_CCITT',
'IEC958_AES0_PRO_FREQ_UNLOCKED', 'IEC958_AES0_PRO_FS',
'IEC958_AES0_PRO_FS_NOTID', 'IEC958_AES0_PRO_FS_44100',
'IEC958_AES0_PRO_FS_48000', 'IEC958_AES0_PRO_FS_32000',
'IEC958_AES0_CON_NOT_COPYRIGHT', 'IEC958_AES0_CON_EMPHASIS',
'IEC958_AES0_CON_EMPHASIS_NONE', 'IEC958_AES0_CON_EMPHASIS_5015',
'IEC958_AES0_CON_MODE', 'IEC958_AES1_PRO_MODE', 'IEC958_AES1_PRO_MODE_NOTID',
'IEC958_AES1_PRO_MODE_STEREOPHONIC', 'IEC958_AES1_PRO_MODE_SINGLE',
'IEC958_AES1_PRO_MODE_TWO', 'IEC958_AES1_PRO_MODE_PRIMARY',
'IEC958_AES1_PRO_MODE_BYTE3', 'IEC958_AES1_PRO_USERBITS',
'IEC958_AES1_PRO_USERBITS_NOTID', 'IEC958_AES1_PRO_USERBITS_192',
'IEC958_AES1_PRO_USERBITS_UDEF', 'IEC958_AES1_CON_CATEGORY',
'IEC958_AES1_CON_GENERAL', 'IEC958_AES1_CON_EXPERIMENTAL',
'IEC958_AES1_CON_SOLIDMEM_MASK', 'IEC958_AES1_CON_SOLIDMEM_ID',
'IEC958_AES1_CON_BROADCAST1_MASK', 'IEC958_AES1_CON_BROADCAST1_ID',
'IEC958_AES1_CON_DIGDIGCONV_MASK', 'IEC958_AES1_CON_DIGDIGCONV_ID',
'IEC958_AES1_CON_ADC_COPYRIGHT_MASK', 'IEC958_AES1_CON_ADC_COPYRIGHT_ID',
'IEC958_AES1_CON_ADC_MASK', 'IEC958_AES1_CON_ADC_ID',
'IEC958_AES1_CON_BROADCAST2_MASK', 'IEC958_AES1_CON_BROADCAST2_ID',
'IEC958_AES1_CON_LASEROPT_MASK', 'IEC958_AES1_CON_LASEROPT_ID',
'IEC958_AES1_CON_MUSICAL_MASK', 'IEC958_AES1_CON_MUSICAL_ID',
'IEC958_AES1_CON_MAGNETIC_MASK', 'IEC958_AES1_CON_MAGNETIC_ID',
'IEC958_AES1_CON_IEC908_CD', 'IEC958_AES1_CON_NON_IEC908_CD',
'IEC958_AES1_CON_PCM_CODER', 'IEC958_AES1_CON_SAMPLER',
'IEC958_AES1_CON_MIXER', 'IEC958_AES1_CON_RATE_CONVERTER',
'IEC958_AES1_CON_SYNTHESIZER', 'IEC958_AES1_CON_MICROPHONE',
'IEC958_AES1_CON_DAT', 'IEC958_AES1_CON_VCR', 'IEC958_AES1_CON_ORIGINAL',
'IEC958_AES2_PRO_SBITS', 'IEC958_AES2_PRO_SBITS_20',
'IEC958_AES2_PRO_SBITS_24', 'IEC958_AES2_PRO_SBITS_UDEF',
'IEC958_AES2_PRO_WORDLEN', 'IEC958_AES2_PRO_WORDLEN_NOTID',
'IEC958_AES2_PRO_WORDLEN_22_18', 'IEC958_AES2_PRO_WORDLEN_23_19',
'IEC958_AES2_PRO_WORDLEN_24_20', 'IEC958_AES2_PRO_WORDLEN_20_16',
'IEC958_AES2_CON_SOURCE', 'IEC958_AES2_CON_SOURCE_UNSPEC',
'IEC958_AES2_CON_CHANNEL', 'IEC958_AES2_CON_CHANNEL_UNSPEC',
'IEC958_AES3_CON_FS', 'IEC958_AES3_CON_FS_44100', 'IEC958_AES3_CON_FS_48000',
'IEC958_AES3_CON_FS_32000', 'IEC958_AES3_CON_CLOCK',
'IEC958_AES3_CON_CLOCK_1000PPM', 'IEC958_AES3_CON_CLOCK_50PPM',
'IEC958_AES3_CON_CLOCK_VARIABLE', 'MIDI_CHANNELS', 'MIDI_GM_DRUM_CHANNEL',
'MIDI_CMD_NOTE_OFF', 'MIDI_CMD_NOTE_ON', 'MIDI_CMD_NOTE_PRESSURE',
'MIDI_CMD_CONTROL', 'MIDI_CMD_PGM_CHANGE', 'MIDI_CMD_CHANNEL_PRESSURE',
'MIDI_CMD_BENDER', 'MIDI_CMD_COMMON_SYSEX', 'MIDI_CMD_COMMON_MTC_QUARTER',
'MIDI_CMD_COMMON_SONG_POS', 'MIDI_CMD_COMMON_SONG_SELECT',
'MIDI_CMD_COMMON_TUNE_REQUEST', 'MIDI_CMD_COMMON_SYSEX_END',
'MIDI_CMD_COMMON_CLOCK', 'MIDI_CMD_COMMON_START', 'MIDI_CMD_COMMON_CONTINUE',
'MIDI_CMD_COMMON_STOP', 'MIDI_CMD_COMMON_SENSING', 'MIDI_CMD_COMMON_RESET',
'MIDI_CTL_MSB_BANK', 'MIDI_CTL_MSB_MODWHEEL', 'MIDI_CTL_MSB_BREATH',
'MIDI_CTL_MSB_FOOT', 'MIDI_CTL_MSB_PORTAMENTO_TIME',
'MIDI_CTL_MSB_DATA_ENTRY', 'MIDI_CTL_MSB_MAIN_VOLUME', 'MIDI_CTL_MSB_BALANCE',
'MIDI_CTL_MSB_PAN', 'MIDI_CTL_MSB_EXPRESSION', 'MIDI_CTL_MSB_EFFECT1',
'MIDI_CTL_MSB_EFFECT2', 'MIDI_CTL_MSB_GENERAL_PURPOSE1',
'MIDI_CTL_MSB_GENERAL_PURPOSE2', 'MIDI_CTL_MSB_GENERAL_PURPOSE3',
'MIDI_CTL_MSB_GENERAL_PURPOSE4', 'MIDI_CTL_LSB_BANK', 'MIDI_CTL_LSB_MODWHEEL',
'MIDI_CTL_LSB_BREATH', 'MIDI_CTL_LSB_FOOT', 'MIDI_CTL_LSB_PORTAMENTO_TIME',
'MIDI_CTL_LSB_DATA_ENTRY', 'MIDI_CTL_LSB_MAIN_VOLUME', 'MIDI_CTL_LSB_BALANCE',
'MIDI_CTL_LSB_PAN', 'MIDI_CTL_LSB_EXPRESSION', 'MIDI_CTL_LSB_EFFECT1',
'MIDI_CTL_LSB_EFFECT2', 'MIDI_CTL_LSB_GENERAL_PURPOSE1',
'MIDI_CTL_LSB_GENERAL_PURPOSE2', 'MIDI_CTL_LSB_GENERAL_PURPOSE3',
'MIDI_CTL_LSB_GENERAL_PURPOSE4', 'MIDI_CTL_SUSTAIN', 'MIDI_CTL_PORTAMENTO',
'MIDI_CTL_SOSTENUTO', 'MIDI_CTL_SUSTENUTO', 'MIDI_CTL_SOFT_PEDAL',
'MIDI_CTL_LEGATO_FOOTSWITCH', 'MIDI_CTL_HOLD2',
'MIDI_CTL_SC1_SOUND_VARIATION', 'MIDI_CTL_SC2_TIMBRE',
'MIDI_CTL_SC3_RELEASE_TIME', 'MIDI_CTL_SC4_ATTACK_TIME',
'MIDI_CTL_SC5_BRIGHTNESS', 'MIDI_CTL_SC6', 'MIDI_CTL_SC7', 'MIDI_CTL_SC8',
'MIDI_CTL_SC9', 'MIDI_CTL_SC10', 'MIDI_CTL_GENERAL_PURPOSE5',
'MIDI_CTL_GENERAL_PURPOSE6', 'MIDI_CTL_GENERAL_PURPOSE7',
'MIDI_CTL_GENERAL_PURPOSE8', 'MIDI_CTL_PORTAMENTO_CONTROL',
'MIDI_CTL_E1_REVERB_DEPTH', 'MIDI_CTL_E2_TREMOLO_DEPTH',
'MIDI_CTL_E3_CHORUS_DEPTH', 'MIDI_CTL_E4_DETUNE_DEPTH',
'MIDI_CTL_E5_PHASER_DEPTH', 'MIDI_CTL_DATA_INCREMENT',
'MIDI_CTL_DATA_DECREMENT', 'MIDI_CTL_NONREG_PARM_NUM_LSB',
'MIDI_CTL_NONREG_PARM_NUM_MSB', 'MIDI_CTL_REGIST_PARM_NUM_LSB',
'MIDI_CTL_REGIST_PARM_NUM_MSB', 'MIDI_CTL_ALL_SOUNDS_OFF',
'MIDI_CTL_RESET_CONTROLLERS', 'MIDI_CTL_LOCAL_CONTROL_SWITCH',
'MIDI_CTL_ALL_NOTES_OFF', 'MIDI_CTL_OMNI_OFF', 'MIDI_CTL_OMNI_ON',
'MIDI_CTL_MONO1', 'MIDI_CTL_MONO2', 'SND_LIB_MAJOR', 'SND_LIB_MINOR',
'SND_LIB_SUBMINOR', 'SND_LIB_EXTRAVER', 'SND_LIB_VERSION',
'snd_asoundlib_version', 'snd_dlopen', 'snd_dlsym', 'snd_dlclose',
'snd_async_handler_t', 'snd_async_callback_t', 'snd_async_add_handler',
'snd_async_del_handler', 'snd_async_handler_get_fd',
'snd_async_handler_get_signo', 'snd_async_handler_get_callback_private',
'snd_shm_area_create', 'snd_shm_area_share', 'snd_shm_area_destroy',
'snd_user_file', 'snd_timestamp_t', 'snd_htimestamp_t', 'snd_input_t',
'snd_input_type_t', 'SND_INPUT_STDIO', 'SND_INPUT_BUFFER',
'snd_input_stdio_open', 'snd_input_stdio_attach', 'snd_input_buffer_open',
'snd_input_close', 'snd_input_scanf', 'snd_input_gets', 'snd_input_getc',
'snd_input_ungetc', 'SND_ERROR_BEGIN', 'SND_ERROR_INCOMPATIBLE_VERSION',
'SND_ERROR_ALISP_NIL', 'snd_strerror', 'snd_lib_error_handler_t',
'snd_lib_error_set_handler', 'SND_CONFIG_DLSYM_VERSION_EVALUATE',
'SND_CONFIG_DLSYM_VERSION_HOOK', 'snd_config_type_t',
'SND_CONFIG_TYPE_INTEGER', 'SND_CONFIG_TYPE_INTEGER64',
'SND_CONFIG_TYPE_REAL', 'SND_CONFIG_TYPE_STRING', 'SND_CONFIG_TYPE_POINTER',
'SND_CONFIG_TYPE_COMPOUND', 'snd_config_t', 'snd_config_iterator_t',
'snd_config_update_t', 'snd_config_top', 'snd_config_load',
'snd_config_load_override', 'snd_config_save', 'snd_config_update',
'snd_config_update_r', 'snd_config_update_free',
'snd_config_update_free_global', 'snd_config_search', 'snd_config_searchv',
'snd_config_search_definition', 'snd_config_expand', 'snd_config_evaluate',
'snd_config_add', 'snd_config_delete', 'snd_config_delete_compound_members',
'snd_config_copy', 'snd_config_make', 'snd_config_make_integer',
'snd_config_make_integer64', 'snd_config_make_real', 'snd_config_make_string',
'snd_config_make_pointer', 'snd_config_make_compound',
'snd_config_imake_integer', 'snd_config_imake_integer64',
'snd_config_imake_real', 'snd_config_imake_string',
'snd_config_imake_pointer', 'snd_config_get_type', 'snd_config_set_id',
'snd_config_set_integer', 'snd_config_set_integer64', 'snd_config_set_real',
'snd_config_set_string', 'snd_config_set_ascii', 'snd_config_set_pointer',
'snd_config_get_id', 'snd_config_get_integer', 'snd_config_get_integer64',
'snd_config_get_real', 'snd_config_get_ireal', 'snd_config_get_string',
'snd_config_get_ascii', 'snd_config_get_pointer', 'snd_config_test_id',
'snd_config_iterator_first', 'snd_config_iterator_next',
'snd_config_iterator_end', 'snd_config_iterator_entry',
'snd_config_get_bool_ascii', 'snd_config_get_bool',
'snd_config_get_ctl_iface_ascii', 'snd_config_get_ctl_iface', 'snd_devname_t',
'snd_names_list', 'snd_names_list_free', 'SND_PCM_DLSYM_VERSION',
'snd_pcm_info_t', 'snd_pcm_hw_params_t', 'snd_pcm_sw_params_t',
'snd_pcm_status_t', 'snd_pcm_access_mask_t', 'snd_pcm_format_mask_t',
'snd_pcm_subformat_mask_t', 'snd_pcm_class_t', 'SND_PCM_CLASS_GENERIC',
'SND_PCM_CLASS_MULTI', 'SND_PCM_CLASS_MODEM', 'SND_PCM_CLASS_DIGITIZER',
'SND_PCM_CLASS_LAST', 'snd_pcm_subclass_t', 'SND_PCM_SUBCLASS_GENERIC_MIX',
'SND_PCM_SUBCLASS_MULTI_MIX', 'SND_PCM_SUBCLASS_LAST', 'snd_pcm_stream_t',
'SND_PCM_STREAM_PLAYBACK', 'SND_PCM_STREAM_CAPTURE', 'SND_PCM_STREAM_LAST',
'snd_pcm_access_t', 'SND_PCM_ACCESS_MMAP_INTERLEAVED',
'SND_PCM_ACCESS_MMAP_NONINTERLEAVED', 'SND_PCM_ACCESS_MMAP_COMPLEX',
'SND_PCM_ACCESS_RW_INTERLEAVED', 'SND_PCM_ACCESS_RW_NONINTERLEAVED',
'SND_PCM_ACCESS_LAST', 'snd_pcm_format_t', 'SND_PCM_FORMAT_UNKNOWN',
'SND_PCM_FORMAT_S8', 'SND_PCM_FORMAT_U8', 'SND_PCM_FORMAT_S16_LE',
'SND_PCM_FORMAT_S16_BE', 'SND_PCM_FORMAT_U16_LE', 'SND_PCM_FORMAT_U16_BE',
'SND_PCM_FORMAT_S24_LE', 'SND_PCM_FORMAT_S24_BE', 'SND_PCM_FORMAT_U24_LE',
'SND_PCM_FORMAT_U24_BE', 'SND_PCM_FORMAT_S32_LE', 'SND_PCM_FORMAT_S32_BE',
'SND_PCM_FORMAT_U32_LE', 'SND_PCM_FORMAT_U32_BE', 'SND_PCM_FORMAT_FLOAT_LE',
'SND_PCM_FORMAT_FLOAT_BE', 'SND_PCM_FORMAT_FLOAT64_LE',
'SND_PCM_FORMAT_FLOAT64_BE', 'SND_PCM_FORMAT_IEC958_SUBFRAME_LE',
'SND_PCM_FORMAT_IEC958_SUBFRAME_BE', 'SND_PCM_FORMAT_MU_LAW',
'SND_PCM_FORMAT_A_LAW', 'SND_PCM_FORMAT_IMA_ADPCM', 'SND_PCM_FORMAT_MPEG',
'SND_PCM_FORMAT_GSM', 'SND_PCM_FORMAT_SPECIAL', 'SND_PCM_FORMAT_S24_3LE',
'SND_PCM_FORMAT_S24_3BE', 'SND_PCM_FORMAT_U24_3LE', 'SND_PCM_FORMAT_U24_3BE',
'SND_PCM_FORMAT_S20_3LE', 'SND_PCM_FORMAT_S20_3BE', 'SND_PCM_FORMAT_U20_3LE',
'SND_PCM_FORMAT_U20_3BE', 'SND_PCM_FORMAT_S18_3LE', 'SND_PCM_FORMAT_S18_3BE',
'SND_PCM_FORMAT_U18_3LE', 'SND_PCM_FORMAT_U18_3BE', 'SND_PCM_FORMAT_LAST',
'SND_PCM_FORMAT_S16', 'SND_PCM_FORMAT_U16', 'SND_PCM_FORMAT_S24',
'SND_PCM_FORMAT_U24', 'SND_PCM_FORMAT_S32', 'SND_PCM_FORMAT_U32',
'SND_PCM_FORMAT_FLOAT', 'SND_PCM_FORMAT_FLOAT64',
'SND_PCM_FORMAT_IEC958_SUBFRAME', 'snd_pcm_subformat_t',
'SND_PCM_SUBFORMAT_STD', 'SND_PCM_SUBFORMAT_LAST', 'snd_pcm_state_t',
'SND_PCM_STATE_OPEN', 'SND_PCM_STATE_SETUP', 'SND_PCM_STATE_PREPARED',
'SND_PCM_STATE_RUNNING', 'SND_PCM_STATE_XRUN', 'SND_PCM_STATE_DRAINING',
'SND_PCM_STATE_PAUSED', 'SND_PCM_STATE_SUSPENDED',
'SND_PCM_STATE_DISCONNECTED', 'SND_PCM_STATE_LAST', 'snd_pcm_start_t',
'SND_PCM_START_DATA', 'SND_PCM_START_EXPLICIT', 'SND_PCM_START_LAST',
'snd_pcm_xrun_t', 'SND_PCM_XRUN_NONE', 'SND_PCM_XRUN_STOP',
'SND_PCM_XRUN_LAST', 'snd_pcm_tstamp_t', 'SND_PCM_TSTAMP_NONE',
'SND_PCM_TSTAMP_MMAP', 'SND_PCM_TSTAMP_LAST', 'snd_pcm_uframes_t',
'snd_pcm_sframes_t', 'SND_PCM_NONBLOCK', 'SND_PCM_ASYNC', 'snd_pcm_t',
'snd_pcm_type_t', 'snd_pcm_channel_area_t', 'snd_pcm_sync_id_t',
'snd_pcm_scope_t', 'snd_pcm_open', 'snd_pcm_open_lconf', 'snd_pcm_close',
'snd_pcm_name', 'snd_pcm_type', 'snd_pcm_stream',
'snd_pcm_poll_descriptors_count', 'snd_pcm_poll_descriptors',
'snd_pcm_poll_descriptors_revents', 'snd_pcm_nonblock',
'snd_async_add_pcm_handler', 'snd_async_handler_get_pcm', 'snd_pcm_info',
'snd_pcm_hw_params_current', 'snd_pcm_hw_params', 'snd_pcm_hw_free',
'snd_pcm_sw_params_current', 'snd_pcm_sw_params', 'snd_pcm_prepare',
'snd_pcm_reset', 'snd_pcm_status', 'snd_pcm_start', 'snd_pcm_drop',
'snd_pcm_drain', 'snd_pcm_pause', 'snd_pcm_state', 'snd_pcm_hwsync',
'snd_pcm_delay', 'snd_pcm_resume', 'snd_pcm_avail_update', 'snd_pcm_rewind',
'snd_pcm_forward', 'snd_pcm_writei', 'snd_pcm_readi', 'snd_pcm_writen',
'snd_pcm_readn', 'snd_pcm_wait', 'snd_pcm_link', 'snd_pcm_unlink',
'snd_pcm_recover', 'snd_pcm_set_params', 'snd_pcm_get_params',
'snd_pcm_info_sizeof', 'snd_pcm_info_malloc', 'snd_pcm_info_free',
'snd_pcm_info_copy', 'snd_pcm_info_get_device', 'snd_pcm_info_get_subdevice',
'snd_pcm_info_get_stream', 'snd_pcm_info_get_card', 'snd_pcm_info_get_id',
'snd_pcm_info_get_name', 'snd_pcm_info_get_subdevice_name',
'snd_pcm_info_get_class', 'snd_pcm_info_get_subclass',
'snd_pcm_info_get_subdevices_count', 'snd_pcm_info_get_subdevices_avail',
'snd_pcm_info_get_sync', 'snd_pcm_info_set_device',
'snd_pcm_info_set_subdevice', 'snd_pcm_info_set_stream',
'snd_pcm_hw_params_any', 'snd_pcm_hw_params_can_mmap_sample_resolution',
'snd_pcm_hw_params_is_double', 'snd_pcm_hw_params_is_batch',
'snd_pcm_hw_params_is_block_transfer', 'snd_pcm_hw_params_can_overrange',
'snd_pcm_hw_params_can_pause', 'snd_pcm_hw_params_can_resume',
'snd_pcm_hw_params_is_half_duplex', 'snd_pcm_hw_params_is_joint_duplex',
'snd_pcm_hw_params_can_sync_start', 'snd_pcm_hw_params_get_rate_numden',
'snd_pcm_hw_params_get_sbits', 'snd_pcm_hw_params_get_fifo_size',
'snd_pcm_hw_params_sizeof', 'snd_pcm_hw_params_malloc',
'snd_pcm_hw_params_free', 'snd_pcm_hw_params_copy',
'snd_pcm_hw_params_get_access', 'snd_pcm_hw_params_test_access',
'snd_pcm_hw_params_set_access', 'snd_pcm_hw_params_set_access_first',
'snd_pcm_hw_params_set_access_last', 'snd_pcm_hw_params_set_access_mask',
'snd_pcm_hw_params_get_access_mask', 'snd_pcm_hw_params_get_format',
'snd_pcm_hw_params_test_format', 'snd_pcm_hw_params_set_format',
'snd_pcm_hw_params_set_format_first', 'snd_pcm_hw_params_set_format_last',
'snd_pcm_hw_params_set_format_mask', 'snd_pcm_hw_params_get_format_mask',
'snd_pcm_hw_params_get_subformat', 'snd_pcm_hw_params_test_subformat',
'snd_pcm_hw_params_set_subformat', 'snd_pcm_hw_params_set_subformat_first',
'snd_pcm_hw_params_set_subformat_last',
'snd_pcm_hw_params_set_subformat_mask',
'snd_pcm_hw_params_get_subformat_mask', 'snd_pcm_hw_params_get_channels',
'snd_pcm_hw_params_get_channels_min', 'snd_pcm_hw_params_get_channels_max',
'snd_pcm_hw_params_test_channels', 'snd_pcm_hw_params_set_channels',
'snd_pcm_hw_params_set_channels_min', 'snd_pcm_hw_params_set_channels_max',
'snd_pcm_hw_params_set_channels_minmax',
'snd_pcm_hw_params_set_channels_near', 'snd_pcm_hw_params_set_channels_first',
'snd_pcm_hw_params_set_channels_last', 'snd_pcm_hw_params_get_rate',
'snd_pcm_hw_params_get_rate_min', 'snd_pcm_hw_params_get_rate_max',
'snd_pcm_hw_params_test_rate', 'snd_pcm_hw_params_set_rate',
'snd_pcm_hw_params_set_rate_min', 'snd_pcm_hw_params_set_rate_max',
'snd_pcm_hw_params_set_rate_minmax', 'snd_pcm_hw_params_set_rate_near',
'snd_pcm_hw_params_set_rate_first', 'snd_pcm_hw_params_set_rate_last',
'snd_pcm_hw_params_set_rate_resample', 'snd_pcm_hw_params_get_rate_resample',
'snd_pcm_hw_params_set_export_buffer', 'snd_pcm_hw_params_get_export_buffer',
'snd_pcm_hw_params_get_period_time', 'snd_pcm_hw_params_get_period_time_min',
'snd_pcm_hw_params_get_period_time_max', 'snd_pcm_hw_params_test_period_time',
'snd_pcm_hw_params_set_period_time', 'snd_pcm_hw_params_set_period_time_min',
'snd_pcm_hw_params_set_period_time_max',
'snd_pcm_hw_params_set_period_time_minmax',
'snd_pcm_hw_params_set_period_time_near',
'snd_pcm_hw_params_set_period_time_first',
'snd_pcm_hw_params_set_period_time_last', 'snd_pcm_hw_params_get_period_size',
'snd_pcm_hw_params_get_period_size_min',
'snd_pcm_hw_params_get_period_size_max', 'snd_pcm_hw_params_test_period_size',
'snd_pcm_hw_params_set_period_size', 'snd_pcm_hw_params_set_period_size_min',
'snd_pcm_hw_params_set_period_size_max',
'snd_pcm_hw_params_set_period_size_minmax',
'snd_pcm_hw_params_set_period_size_near',
'snd_pcm_hw_params_set_period_size_first',
'snd_pcm_hw_params_set_period_size_last',
'snd_pcm_hw_params_set_period_size_integer', 'snd_pcm_hw_params_get_periods',
'snd_pcm_hw_params_get_periods_min', 'snd_pcm_hw_params_get_periods_max',
'snd_pcm_hw_params_test_periods', 'snd_pcm_hw_params_set_periods',
'snd_pcm_hw_params_set_periods_min', 'snd_pcm_hw_params_set_periods_max',
'snd_pcm_hw_params_set_periods_minmax', 'snd_pcm_hw_params_set_periods_near',
'snd_pcm_hw_params_set_periods_first', 'snd_pcm_hw_params_set_periods_last',
'snd_pcm_hw_params_set_periods_integer', 'snd_pcm_hw_params_get_buffer_time',
'snd_pcm_hw_params_get_buffer_time_min',
'snd_pcm_hw_params_get_buffer_time_max', 'snd_pcm_hw_params_test_buffer_time',
'snd_pcm_hw_params_set_buffer_time', 'snd_pcm_hw_params_set_buffer_time_min',
'snd_pcm_hw_params_set_buffer_time_max',
'snd_pcm_hw_params_set_buffer_time_minmax',
'snd_pcm_hw_params_set_buffer_time_near',
'snd_pcm_hw_params_set_buffer_time_first',
'snd_pcm_hw_params_set_buffer_time_last', 'snd_pcm_hw_params_get_buffer_size',
'snd_pcm_hw_params_get_buffer_size_min',
'snd_pcm_hw_params_get_buffer_size_max', 'snd_pcm_hw_params_test_buffer_size',
'snd_pcm_hw_params_set_buffer_size', 'snd_pcm_hw_params_set_buffer_size_min',
'snd_pcm_hw_params_set_buffer_size_max',
'snd_pcm_hw_params_set_buffer_size_minmax',
'snd_pcm_hw_params_set_buffer_size_near',
'snd_pcm_hw_params_set_buffer_size_first',
'snd_pcm_hw_params_set_buffer_size_last', 'snd_pcm_hw_params_get_tick_time',
'snd_pcm_hw_params_get_tick_time_min', 'snd_pcm_hw_params_get_tick_time_max',
'snd_pcm_hw_params_test_tick_time', 'snd_pcm_hw_params_set_tick_time',
'snd_pcm_hw_params_set_tick_time_min', 'snd_pcm_hw_params_set_tick_time_max',
'snd_pcm_hw_params_set_tick_time_minmax',
'snd_pcm_hw_params_set_tick_time_near',
'snd_pcm_hw_params_set_tick_time_first',
'snd_pcm_hw_params_set_tick_time_last', 'snd_pcm_hw_params_get_min_align',
'snd_pcm_sw_params_sizeof', 'snd_pcm_sw_params_malloc',
'snd_pcm_sw_params_free', 'snd_pcm_sw_params_copy',
'snd_pcm_sw_params_get_boundary', 'snd_pcm_sw_params_set_tstamp_mode',
'snd_pcm_sw_params_get_tstamp_mode', 'snd_pcm_sw_params_set_sleep_min',
'snd_pcm_sw_params_get_sleep_min', 'snd_pcm_sw_params_set_avail_min',
'snd_pcm_sw_params_get_avail_min', 'snd_pcm_sw_params_set_xfer_align',
'snd_pcm_sw_params_get_xfer_align', 'snd_pcm_sw_params_set_start_threshold',
'snd_pcm_sw_params_get_start_threshold',
'snd_pcm_sw_params_set_stop_threshold',
'snd_pcm_sw_params_get_stop_threshold',
'snd_pcm_sw_params_set_silence_threshold',
'snd_pcm_sw_params_get_silence_threshold',
'snd_pcm_sw_params_set_silence_size', 'snd_pcm_sw_params_get_silence_size',
'snd_pcm_access_mask_sizeof', 'snd_pcm_access_mask_malloc',
'snd_pcm_access_mask_free', 'snd_pcm_access_mask_copy',
'snd_pcm_access_mask_none', 'snd_pcm_access_mask_any',
'snd_pcm_access_mask_test', 'snd_pcm_access_mask_empty',
'snd_pcm_access_mask_set', 'snd_pcm_access_mask_reset',
'snd_pcm_format_mask_sizeof', 'snd_pcm_format_mask_malloc',
'snd_pcm_format_mask_free', 'snd_pcm_format_mask_copy',
'snd_pcm_format_mask_none', 'snd_pcm_format_mask_any',
'snd_pcm_format_mask_test', 'snd_pcm_format_mask_empty',
'snd_pcm_format_mask_set', 'snd_pcm_format_mask_reset',
'snd_pcm_subformat_mask_sizeof', 'snd_pcm_subformat_mask_malloc',
'snd_pcm_subformat_mask_free', 'snd_pcm_subformat_mask_copy',
'snd_pcm_subformat_mask_none', 'snd_pcm_subformat_mask_any',
'snd_pcm_subformat_mask_test', 'snd_pcm_subformat_mask_empty',
'snd_pcm_subformat_mask_set', 'snd_pcm_subformat_mask_reset',
'snd_pcm_status_sizeof', 'snd_pcm_status_malloc', 'snd_pcm_status_free',
'snd_pcm_status_copy', 'snd_pcm_status_get_state',
'snd_pcm_status_get_trigger_tstamp', 'snd_pcm_status_get_trigger_htstamp',
'snd_pcm_status_get_tstamp', 'snd_pcm_status_get_htstamp',
'snd_pcm_status_get_delay', 'snd_pcm_status_get_avail',
'snd_pcm_status_get_avail_max', 'snd_pcm_status_get_overrange',
'snd_pcm_type_name', 'snd_pcm_stream_name', 'snd_pcm_access_name',
'snd_pcm_format_name', 'snd_pcm_format_description', 'snd_pcm_subformat_name',
'snd_pcm_subformat_description', 'snd_pcm_format_value',
'snd_pcm_tstamp_mode_name', 'snd_pcm_state_name', 'snd_pcm_dump',
'snd_pcm_dump_hw_setup', 'snd_pcm_dump_sw_setup', 'snd_pcm_dump_setup',
'snd_pcm_hw_params_dump', 'snd_pcm_sw_params_dump', 'snd_pcm_status_dump',
'snd_pcm_mmap_begin', 'snd_pcm_mmap_commit', 'snd_pcm_mmap_writei',
'snd_pcm_mmap_readi', 'snd_pcm_mmap_writen', 'snd_pcm_mmap_readn',
'snd_pcm_format_signed', 'snd_pcm_format_unsigned', 'snd_pcm_format_linear',
'snd_pcm_format_float', 'snd_pcm_format_little_endian',
'snd_pcm_format_big_endian', 'snd_pcm_format_cpu_endian',
'snd_pcm_format_width', 'snd_pcm_format_physical_width',
'snd_pcm_build_linear_format', 'snd_pcm_format_size',
'snd_pcm_format_silence', 'snd_pcm_format_silence_16',
'snd_pcm_format_silence_32', 'snd_pcm_format_silence_64',
'snd_pcm_format_set_silence', 'snd_pcm_bytes_to_frames',
'snd_pcm_frames_to_bytes', 'snd_pcm_bytes_to_samples',
'snd_pcm_samples_to_bytes', 'snd_pcm_area_silence', 'snd_pcm_areas_silence',
'snd_pcm_area_copy', 'snd_pcm_areas_copy', 'snd_pcm_hook_type_t',
'SND_PCM_HOOK_TYPE_HW_PARAMS', 'SND_PCM_HOOK_TYPE_HW_FREE',
'SND_PCM_HOOK_TYPE_CLOSE', 'SND_PCM_HOOK_TYPE_LAST', 'snd_pcm_hook_t',
'snd_pcm_hook_func_t', 'snd_pcm_hook_get_pcm', 'snd_pcm_hook_get_private',
'snd_pcm_hook_set_private', 'snd_pcm_hook_add', 'snd_pcm_hook_remove',
'snd_pcm_scope_ops_t', 'snd_pcm_meter_get_bufsize',
'snd_pcm_meter_get_channels', 'snd_pcm_meter_get_rate',
'snd_pcm_meter_get_now', 'snd_pcm_meter_get_boundary',
'snd_pcm_meter_add_scope', 'snd_pcm_meter_search_scope',
'snd_pcm_scope_malloc', 'snd_pcm_scope_set_ops', 'snd_pcm_scope_set_name',
'snd_pcm_scope_get_name', 'snd_pcm_scope_get_callback_private',
'snd_pcm_scope_set_callback_private', 'snd_pcm_scope_s16_open',
'snd_pcm_scope_s16_get_channel_buffer', 'snd_spcm_latency_t',
'SND_SPCM_LATENCY_STANDARD', 'SND_SPCM_LATENCY_MEDIUM',
'SND_SPCM_LATENCY_REALTIME', 'snd_spcm_xrun_type_t', 'SND_SPCM_XRUN_IGNORE',
'SND_SPCM_XRUN_STOP', 'snd_spcm_duplex_type_t', 'SND_SPCM_DUPLEX_LIBERAL',
'SND_SPCM_DUPLEX_PEDANTIC', 'snd_spcm_init', 'snd_spcm_init_duplex',
'snd_spcm_init_get_params', 'snd_pcm_start_mode_name',
'snd_pcm_xrun_mode_name', 'snd_pcm_sw_params_set_start_mode',
'snd_pcm_sw_params_get_start_mode', 'snd_pcm_sw_params_set_xrun_mode',
'snd_pcm_sw_params_get_xrun_mode', 'SND_RAWMIDI_DLSYM_VERSION',
'snd_rawmidi_info_t', 'snd_rawmidi_params_t', 'snd_rawmidi_status_t',
'snd_rawmidi_stream_t', 'SND_RAWMIDI_STREAM_OUTPUT',
'SND_RAWMIDI_STREAM_INPUT', 'SND_RAWMIDI_STREAM_LAST', 'SND_RAWMIDI_APPEND',
'SND_RAWMIDI_NONBLOCK', 'SND_RAWMIDI_SYNC', 'snd_rawmidi_t',
'snd_rawmidi_type_t', 'SND_RAWMIDI_TYPE_HW', 'SND_RAWMIDI_TYPE_SHM',
'SND_RAWMIDI_TYPE_INET', 'SND_RAWMIDI_TYPE_VIRTUAL', 'snd_rawmidi_open',
'snd_rawmidi_open_lconf', 'snd_rawmidi_close',
'snd_rawmidi_poll_descriptors_count', 'snd_rawmidi_poll_descriptors',
'snd_rawmidi_poll_descriptors_revents', 'snd_rawmidi_nonblock',
'snd_rawmidi_info_sizeof', 'snd_rawmidi_info_malloc', 'snd_rawmidi_info_free',
'snd_rawmidi_info_copy', 'snd_rawmidi_info_get_device',
'snd_rawmidi_info_get_subdevice', 'snd_rawmidi_info_get_stream',
'snd_rawmidi_info_get_card', 'snd_rawmidi_info_get_flags',
'snd_rawmidi_info_get_id', 'snd_rawmidi_info_get_name',
'snd_rawmidi_info_get_subdevice_name',
'snd_rawmidi_info_get_subdevices_count',
'snd_rawmidi_info_get_subdevices_avail', 'snd_rawmidi_info_set_device',
'snd_rawmidi_info_set_subdevice', 'snd_rawmidi_info_set_stream',
'snd_rawmidi_info', 'snd_rawmidi_params_sizeof', 'snd_rawmidi_params_malloc',
'snd_rawmidi_params_free', 'snd_rawmidi_params_copy',
'snd_rawmidi_params_set_buffer_size', 'snd_rawmidi_params_get_buffer_size',
'snd_rawmidi_params_set_avail_min', 'snd_rawmidi_params_get_avail_min',
'snd_rawmidi_params_set_no_active_sensing',
'snd_rawmidi_params_get_no_active_sensing', 'snd_rawmidi_params',
'snd_rawmidi_params_current', 'snd_rawmidi_status_sizeof',
'snd_rawmidi_status_malloc', 'snd_rawmidi_status_free',
'snd_rawmidi_status_copy', 'snd_rawmidi_status_get_tstamp',
'snd_rawmidi_status_get_avail', 'snd_rawmidi_status_get_xruns',
'snd_rawmidi_status', 'snd_rawmidi_drain', 'snd_rawmidi_drop',
'snd_rawmidi_write', 'snd_rawmidi_read', 'snd_rawmidi_name',
'snd_rawmidi_type', 'snd_rawmidi_stream', 'SND_TIMER_DLSYM_VERSION',
'SND_TIMER_QUERY_DLSYM_VERSION', 'snd_timer_id_t', 'snd_timer_ginfo_t',
'snd_timer_gparams_t', 'snd_timer_gstatus_t', 'snd_timer_info_t',
'snd_timer_params_t', 'snd_timer_status_t', 'snd_timer_class_t',
'SND_TIMER_CLASS_NONE', 'SND_TIMER_CLASS_SLAVE', 'SND_TIMER_CLASS_GLOBAL',
'SND_TIMER_CLASS_CARD', 'SND_TIMER_CLASS_PCM', 'SND_TIMER_CLASS_LAST',
'snd_timer_slave_class_t', 'SND_TIMER_SCLASS_NONE',
'SND_TIMER_SCLASS_APPLICATION', 'SND_TIMER_SCLASS_SEQUENCER',
'SND_TIMER_SCLASS_OSS_SEQUENCER', 'SND_TIMER_SCLASS_LAST',
'snd_timer_event_t', 'SND_TIMER_EVENT_RESOLUTION', 'SND_TIMER_EVENT_TICK',
'SND_TIMER_EVENT_START', 'SND_TIMER_EVENT_STOP', 'SND_TIMER_EVENT_CONTINUE',
'SND_TIMER_EVENT_PAUSE', 'SND_TIMER_EVENT_EARLY', 'SND_TIMER_EVENT_SUSPEND',
'SND_TIMER_EVENT_RESUME', 'SND_TIMER_EVENT_MSTART', 'SND_TIMER_EVENT_MSTOP',
'SND_TIMER_EVENT_MCONTINUE', 'SND_TIMER_EVENT_MPAUSE',
'SND_TIMER_EVENT_MSUSPEND', 'SND_TIMER_EVENT_MRESUME', 'snd_timer_read_t',
'snd_timer_tread_t', 'SND_TIMER_GLOBAL_SYSTEM', 'SND_TIMER_GLOBAL_RTC',
'SND_TIMER_GLOBAL_HPET', 'SND_TIMER_OPEN_NONBLOCK', 'SND_TIMER_OPEN_TREAD',
'snd_timer_type_t', 'SND_TIMER_TYPE_HW', 'SND_TIMER_TYPE_SHM',
'SND_TIMER_TYPE_INET', 'snd_timer_query_t', 'snd_timer_t',
'snd_timer_query_open', 'snd_timer_query_open_lconf', 'snd_timer_query_close',
'snd_timer_query_next_device', 'snd_timer_query_info',
'snd_timer_query_params', 'snd_timer_query_status', 'snd_timer_open',
'snd_timer_open_lconf', 'snd_timer_close', 'snd_async_add_timer_handler',
'snd_async_handler_get_timer', 'snd_timer_poll_descriptors_count',
'snd_timer_poll_descriptors', 'snd_timer_poll_descriptors_revents',
'snd_timer_info', 'snd_timer_params', 'snd_timer_status', 'snd_timer_start',
'snd_timer_stop', 'snd_timer_continue', 'snd_timer_read',
'snd_timer_id_sizeof', 'snd_timer_id_malloc', 'snd_timer_id_free',
'snd_timer_id_copy', 'snd_timer_id_set_class', 'snd_timer_id_get_class',
'snd_timer_id_set_sclass', 'snd_timer_id_get_sclass', 'snd_timer_id_set_card',
'snd_timer_id_get_card', 'snd_timer_id_set_device', 'snd_timer_id_get_device',
'snd_timer_id_set_subdevice', 'snd_timer_id_get_subdevice',
'snd_timer_ginfo_sizeof', 'snd_timer_ginfo_malloc', 'snd_timer_ginfo_free',
'snd_timer_ginfo_copy', 'snd_timer_ginfo_set_tid', 'snd_timer_ginfo_get_tid',
'snd_timer_ginfo_get_flags', 'snd_timer_ginfo_get_card',
'snd_timer_ginfo_get_id', 'snd_timer_ginfo_get_name',
'snd_timer_ginfo_get_resolution', 'snd_timer_ginfo_get_resolution_min',
'snd_timer_ginfo_get_resolution_max', 'snd_timer_ginfo_get_clients',
'snd_timer_info_sizeof', 'snd_timer_info_malloc', 'snd_timer_info_free',
'snd_timer_info_copy', 'snd_timer_info_is_slave', 'snd_timer_info_get_card',
'snd_timer_info_get_id', 'snd_timer_info_get_name',
'snd_timer_info_get_resolution', 'snd_timer_params_sizeof',
'snd_timer_params_malloc', 'snd_timer_params_free', 'snd_timer_params_copy',
'snd_timer_params_set_auto_start', 'snd_timer_params_get_auto_start',
'snd_timer_params_set_exclusive', 'snd_timer_params_get_exclusive',
'snd_timer_params_set_early_event', 'snd_timer_params_get_early_event',
'snd_timer_params_set_ticks', 'snd_timer_params_get_ticks',
'snd_timer_params_set_queue_size', 'snd_timer_params_get_queue_size',
'snd_timer_params_set_filter', 'snd_timer_params_get_filter',
'snd_timer_status_sizeof', 'snd_timer_status_malloc', 'snd_timer_status_free',
'snd_timer_status_copy', 'snd_timer_status_get_timestamp',
'snd_timer_status_get_resolution', 'snd_timer_status_get_lost',
'snd_timer_status_get_overrun', 'snd_timer_status_get_queue',
'snd_timer_info_get_ticks', 'SND_HWDEP_DLSYM_VERSION', 'snd_hwdep_info_t',
'snd_hwdep_dsp_status_t', 'snd_hwdep_dsp_image_t', 'snd_hwdep_iface_t',
'SND_HWDEP_IFACE_OPL2', 'SND_HWDEP_IFACE_OPL3', 'SND_HWDEP_IFACE_OPL4',
'SND_HWDEP_IFACE_SB16CSP', 'SND_HWDEP_IFACE_EMU10K1',
'SND_HWDEP_IFACE_YSS225', 'SND_HWDEP_IFACE_ICS2115', 'SND_HWDEP_IFACE_SSCAPE',
'SND_HWDEP_IFACE_VX', 'SND_HWDEP_IFACE_MIXART', 'SND_HWDEP_IFACE_USX2Y',
'SND_HWDEP_IFACE_EMUX_WAVETABLE', 'SND_HWDEP_IFACE_BLUETOOTH',
'SND_HWDEP_IFACE_USX2Y_PCM', 'SND_HWDEP_IFACE_PCXHR', 'SND_HWDEP_IFACE_SB_RC',
'SND_HWDEP_IFACE_LAST', 'SND_HWDEP_OPEN_READ', 'SND_HWDEP_OPEN_WRITE',
'SND_HWDEP_OPEN_DUPLEX', 'SND_HWDEP_OPEN_NONBLOCK', 'snd_hwdep_type_t',
'SND_HWDEP_TYPE_HW', 'SND_HWDEP_TYPE_SHM', 'SND_HWDEP_TYPE_INET',
'snd_hwdep_t', 'snd_hwdep_open', 'snd_hwdep_close',
'snd_hwdep_poll_descriptors', 'snd_hwdep_poll_descriptors_revents',
'snd_hwdep_nonblock', 'snd_hwdep_info', 'snd_hwdep_dsp_status',
'snd_hwdep_dsp_load', 'snd_hwdep_ioctl', 'snd_hwdep_write', 'snd_hwdep_read',
'snd_hwdep_info_sizeof', 'snd_hwdep_info_malloc', 'snd_hwdep_info_free',
'snd_hwdep_info_copy', 'snd_hwdep_info_get_device', 'snd_hwdep_info_get_card',
'snd_hwdep_info_get_id', 'snd_hwdep_info_get_name',
'snd_hwdep_info_get_iface', 'snd_hwdep_info_set_device',
'snd_hwdep_dsp_status_sizeof', 'snd_hwdep_dsp_status_malloc',
'snd_hwdep_dsp_status_free', 'snd_hwdep_dsp_status_copy',
'snd_hwdep_dsp_status_get_version', 'snd_hwdep_dsp_status_get_id',
'snd_hwdep_dsp_status_get_num_dsps', 'snd_hwdep_dsp_status_get_dsp_loaded',
'snd_hwdep_dsp_status_get_chip_ready', 'snd_hwdep_dsp_image_sizeof',
'snd_hwdep_dsp_image_malloc', 'snd_hwdep_dsp_image_free',
'snd_hwdep_dsp_image_copy', 'snd_hwdep_dsp_image_get_index',
'snd_hwdep_dsp_image_get_name', 'snd_hwdep_dsp_image_get_image',
'snd_hwdep_dsp_image_get_length', 'snd_hwdep_dsp_image_set_index',
'snd_hwdep_dsp_image_set_name', 'snd_hwdep_dsp_image_set_image',
'snd_hwdep_dsp_image_set_length', 'SND_CONTROL_DLSYM_VERSION',
'snd_aes_iec958_t', 'snd_ctl_card_info_t', 'snd_ctl_elem_id_t',
'snd_ctl_elem_list_t', 'snd_ctl_elem_info_t', 'snd_ctl_elem_value_t',
'snd_ctl_event_t', 'snd_ctl_elem_type_t', 'SND_CTL_ELEM_TYPE_NONE',
'SND_CTL_ELEM_TYPE_BOOLEAN', 'SND_CTL_ELEM_TYPE_INTEGER',
'SND_CTL_ELEM_TYPE_ENUMERATED', 'SND_CTL_ELEM_TYPE_BYTES',
'SND_CTL_ELEM_TYPE_IEC958', 'SND_CTL_ELEM_TYPE_INTEGER64',
'SND_CTL_ELEM_TYPE_LAST', 'snd_ctl_elem_iface_t', 'SND_CTL_ELEM_IFACE_CARD',
'SND_CTL_ELEM_IFACE_HWDEP', 'SND_CTL_ELEM_IFACE_MIXER',
'SND_CTL_ELEM_IFACE_PCM', 'SND_CTL_ELEM_IFACE_RAWMIDI',
'SND_CTL_ELEM_IFACE_TIMER', 'SND_CTL_ELEM_IFACE_SEQUENCER',
'SND_CTL_ELEM_IFACE_LAST', 'snd_ctl_event_type_t', 'SND_CTL_EVENT_ELEM',
'SND_CTL_EVENT_LAST', 'SND_CTL_EVENT_MASK_REMOVE', 'SND_CTL_EVENT_MASK_VALUE',
'SND_CTL_EVENT_MASK_INFO', 'SND_CTL_EVENT_MASK_ADD', 'SND_CTL_EVENT_MASK_TLV',
'SND_CTL_POWER_MASK', 'SND_CTL_POWER_D0', 'SND_CTL_POWER_D1',
'SND_CTL_POWER_D2', 'SND_CTL_POWER_D3', 'SND_CTL_POWER_D3hot',
'SND_CTL_POWER_D3cold', 'SND_CTL_TLVT_CONTAINER', 'SND_CTL_TLVT_DB_SCALE',
'SND_CTL_TLVT_DB_LINEAR', 'SND_CTL_TLVT_DB_RANGE', 'SND_CTL_TLV_DB_GAIN_MUTE',
'snd_ctl_type_t', 'SND_CTL_TYPE_HW', 'SND_CTL_TYPE_SHM', 'SND_CTL_TYPE_INET',
'SND_CTL_TYPE_EXT', 'SND_CTL_NONBLOCK', 'SND_CTL_ASYNC', 'SND_CTL_READONLY',
'snd_ctl_t', 'SND_SCTL_NOFREE', 'snd_sctl_t', 'snd_card_load',
'snd_card_next', 'snd_card_get_index', 'snd_card_get_name',
'snd_card_get_longname', 'snd_device_name_hint', 'snd_device_name_free_hint',
'snd_device_name_get_hint', 'snd_ctl_open', 'snd_ctl_open_lconf',
'snd_ctl_close', 'snd_ctl_nonblock', 'snd_async_add_ctl_handler',
'snd_async_handler_get_ctl', 'snd_ctl_poll_descriptors_count',
'snd_ctl_poll_descriptors', 'snd_ctl_poll_descriptors_revents',
'snd_ctl_subscribe_events', 'snd_ctl_card_info', 'snd_ctl_elem_list',
'snd_ctl_elem_info', 'snd_ctl_elem_read', 'snd_ctl_elem_write',
'snd_ctl_elem_lock', 'snd_ctl_elem_unlock', 'snd_ctl_elem_tlv_read',
'snd_ctl_elem_tlv_write', 'snd_ctl_elem_tlv_command',
'snd_ctl_hwdep_next_device', 'snd_ctl_hwdep_info', 'snd_ctl_pcm_next_device',
'snd_ctl_pcm_info', 'snd_ctl_pcm_prefer_subdevice',
'snd_ctl_rawmidi_next_device', 'snd_ctl_rawmidi_info',
'snd_ctl_rawmidi_prefer_subdevice', 'snd_ctl_set_power_state',
'snd_ctl_get_power_state', 'snd_ctl_read', 'snd_ctl_wait', 'snd_ctl_name',
'snd_ctl_type', 'snd_ctl_elem_type_name', 'snd_ctl_elem_iface_name',
'snd_ctl_event_type_name', 'snd_ctl_event_elem_get_mask',
'snd_ctl_event_elem_get_numid', 'snd_ctl_event_elem_get_id',
'snd_ctl_event_elem_get_interface', 'snd_ctl_event_elem_get_device',
'snd_ctl_event_elem_get_subdevice', 'snd_ctl_event_elem_get_name',
'snd_ctl_event_elem_get_index', 'snd_ctl_elem_list_alloc_space',
'snd_ctl_elem_list_free_space', 'snd_ctl_elem_id_sizeof',
'snd_ctl_elem_id_malloc', 'snd_ctl_elem_id_free', 'snd_ctl_elem_id_clear',
'snd_ctl_elem_id_copy', 'snd_ctl_elem_id_get_numid',
'snd_ctl_elem_id_get_interface', 'snd_ctl_elem_id_get_device',
'snd_ctl_elem_id_get_subdevice', 'snd_ctl_elem_id_get_name',
'snd_ctl_elem_id_get_index', 'snd_ctl_elem_id_set_numid',
'snd_ctl_elem_id_set_interface', 'snd_ctl_elem_id_set_device',
'snd_ctl_elem_id_set_subdevice', 'snd_ctl_elem_id_set_name',
'snd_ctl_elem_id_set_index', 'snd_ctl_card_info_sizeof',
'snd_ctl_card_info_malloc', 'snd_ctl_card_info_free',
'snd_ctl_card_info_clear', 'snd_ctl_card_info_copy',
'snd_ctl_card_info_get_card', 'snd_ctl_card_info_get_id',
'snd_ctl_card_info_get_driver', 'snd_ctl_card_info_get_name',
'snd_ctl_card_info_get_longname', 'snd_ctl_card_info_get_mixername',
'snd_ctl_card_info_get_components', 'snd_ctl_event_sizeof',
'snd_ctl_event_malloc', 'snd_ctl_event_free', 'snd_ctl_event_clear',
'snd_ctl_event_copy', 'snd_ctl_event_get_type', 'snd_ctl_elem_list_sizeof',
'snd_ctl_elem_list_malloc', 'snd_ctl_elem_list_free',
'snd_ctl_elem_list_clear', 'snd_ctl_elem_list_copy',
'snd_ctl_elem_list_set_offset', 'snd_ctl_elem_list_get_used',
'snd_ctl_elem_list_get_count', 'snd_ctl_elem_list_get_id',
'snd_ctl_elem_list_get_numid', 'snd_ctl_elem_list_get_interface',
'snd_ctl_elem_list_get_device', 'snd_ctl_elem_list_get_subdevice',
'snd_ctl_elem_list_get_name', 'snd_ctl_elem_list_get_index',
'snd_ctl_elem_info_sizeof', 'snd_ctl_elem_info_malloc',
'snd_ctl_elem_info_free', 'snd_ctl_elem_info_clear', 'snd_ctl_elem_info_copy',
'snd_ctl_elem_info_get_type', 'snd_ctl_elem_info_is_readable',
'snd_ctl_elem_info_is_writable', 'snd_ctl_elem_info_is_volatile',
'snd_ctl_elem_info_is_inactive', 'snd_ctl_elem_info_is_locked',
'snd_ctl_elem_info_is_tlv_readable', 'snd_ctl_elem_info_is_tlv_writable',
'snd_ctl_elem_info_is_tlv_commandable', 'snd_ctl_elem_info_is_owner',
'snd_ctl_elem_info_is_user', 'snd_ctl_elem_info_get_owner',
'snd_ctl_elem_info_get_count', 'snd_ctl_elem_info_get_min',
'snd_ctl_elem_info_get_max', 'snd_ctl_elem_info_get_step',
'snd_ctl_elem_info_get_min64', 'snd_ctl_elem_info_get_max64',
'snd_ctl_elem_info_get_step64', 'snd_ctl_elem_info_get_items',
'snd_ctl_elem_info_set_item', 'snd_ctl_elem_info_get_item_name',
'snd_ctl_elem_info_get_dimensions', 'snd_ctl_elem_info_get_dimension',
'snd_ctl_elem_info_get_id', 'snd_ctl_elem_info_get_numid',
'snd_ctl_elem_info_get_interface', 'snd_ctl_elem_info_get_device',
'snd_ctl_elem_info_get_subdevice', 'snd_ctl_elem_info_get_name',
'snd_ctl_elem_info_get_index', 'snd_ctl_elem_info_set_id',
'snd_ctl_elem_info_set_numid', 'snd_ctl_elem_info_set_interface',
'snd_ctl_elem_info_set_device', 'snd_ctl_elem_info_set_subdevice',
'snd_ctl_elem_info_set_name', 'snd_ctl_elem_info_set_index',
'snd_ctl_elem_add_integer', 'snd_ctl_elem_add_integer64',
'snd_ctl_elem_add_boolean', 'snd_ctl_elem_add_iec958', 'snd_ctl_elem_remove',
'snd_ctl_elem_value_sizeof', 'snd_ctl_elem_value_malloc',
'snd_ctl_elem_value_free', 'snd_ctl_elem_value_clear',
'snd_ctl_elem_value_copy', 'snd_ctl_elem_value_get_id',
'snd_ctl_elem_value_get_numid', 'snd_ctl_elem_value_get_interface',
'snd_ctl_elem_value_get_device', 'snd_ctl_elem_value_get_subdevice',
'snd_ctl_elem_value_get_name', 'snd_ctl_elem_value_get_index',
'snd_ctl_elem_value_set_id', 'snd_ctl_elem_value_set_numid',
'snd_ctl_elem_value_set_interface', 'snd_ctl_elem_value_set_device',
'snd_ctl_elem_value_set_subdevice', 'snd_ctl_elem_value_set_name',
'snd_ctl_elem_value_set_index', 'snd_ctl_elem_value_get_boolean',
'snd_ctl_elem_value_get_integer', 'snd_ctl_elem_value_get_integer64',
'snd_ctl_elem_value_get_enumerated', 'snd_ctl_elem_value_get_byte',
'snd_ctl_elem_value_set_boolean', 'snd_ctl_elem_value_set_integer',
'snd_ctl_elem_value_set_integer64', 'snd_ctl_elem_value_set_enumerated',
'snd_ctl_elem_value_set_byte', 'snd_ctl_elem_set_bytes',
'snd_ctl_elem_value_get_bytes', 'snd_ctl_elem_value_get_iec958',
'snd_ctl_elem_value_set_iec958', 'snd_hctl_elem_t', 'snd_hctl_t',
'snd_hctl_compare_t', 'snd_hctl_compare_fast', 'snd_hctl_callback_t',
'snd_hctl_elem_callback_t', 'snd_hctl_open', 'snd_hctl_open_ctl',
'snd_hctl_close', 'snd_hctl_nonblock', 'snd_hctl_poll_descriptors_count',
'snd_hctl_poll_descriptors', 'snd_hctl_poll_descriptors_revents',
'snd_hctl_get_count', 'snd_hctl_set_compare', 'snd_hctl_first_elem',
'snd_hctl_last_elem', 'snd_hctl_find_elem', 'snd_hctl_set_callback',
'snd_hctl_set_callback_private', 'snd_hctl_get_callback_private',
'snd_hctl_load', 'snd_hctl_free', 'snd_hctl_handle_events', 'snd_hctl_name',
'snd_hctl_wait', 'snd_hctl_ctl', 'snd_hctl_elem_next', 'snd_hctl_elem_prev',
'snd_hctl_elem_info', 'snd_hctl_elem_read', 'snd_hctl_elem_write',
'snd_hctl_elem_tlv_read', 'snd_hctl_elem_tlv_write',
'snd_hctl_elem_tlv_command', 'snd_hctl_elem_get_hctl', 'snd_hctl_elem_get_id',
'snd_hctl_elem_get_numid', 'snd_hctl_elem_get_interface',
'snd_hctl_elem_get_device', 'snd_hctl_elem_get_subdevice',
'snd_hctl_elem_get_name', 'snd_hctl_elem_get_index',
'snd_hctl_elem_set_callback', 'snd_hctl_elem_get_callback_private',
'snd_hctl_elem_set_callback_private', 'snd_sctl_build', 'snd_sctl_free',
'snd_sctl_install', 'snd_sctl_remove', 'snd_mixer_t', 'snd_mixer_class_t',
'snd_mixer_elem_t', 'snd_mixer_callback_t', 'snd_mixer_elem_callback_t',
'snd_mixer_compare_t', 'snd_mixer_event_t', 'snd_mixer_elem_type_t',
'SND_MIXER_ELEM_SIMPLE', 'SND_MIXER_ELEM_LAST', 'snd_mixer_open',
'snd_mixer_close', 'snd_mixer_first_elem', 'snd_mixer_last_elem',
'snd_mixer_handle_events', 'snd_mixer_attach', 'snd_mixer_attach_hctl',
'snd_mixer_detach', 'snd_mixer_detach_hctl', 'snd_mixer_get_hctl',
'snd_mixer_poll_descriptors_count', 'snd_mixer_poll_descriptors',
'snd_mixer_poll_descriptors_revents', 'snd_mixer_load', 'snd_mixer_free',
'snd_mixer_wait', 'snd_mixer_set_compare', 'snd_mixer_set_callback',
'snd_mixer_get_callback_private', 'snd_mixer_set_callback_private',
'snd_mixer_get_count', 'snd_mixer_class_unregister', 'snd_mixer_elem_next',
'snd_mixer_elem_prev', 'snd_mixer_elem_set_callback',
'snd_mixer_elem_get_callback_private', 'snd_mixer_elem_set_callback_private',
'snd_mixer_elem_get_type', 'snd_mixer_class_register', 'snd_mixer_add_elem',
'snd_mixer_remove_elem', 'snd_mixer_elem_new', 'snd_mixer_elem_add',
'snd_mixer_elem_remove', 'snd_mixer_elem_free', 'snd_mixer_elem_info',
'snd_mixer_elem_value', 'snd_mixer_elem_attach', 'snd_mixer_elem_detach',
'snd_mixer_elem_empty', 'snd_mixer_elem_get_private',
'snd_mixer_class_sizeof', 'snd_mixer_class_malloc', 'snd_mixer_class_free',
'snd_mixer_class_copy', 'snd_mixer_class_get_mixer',
'snd_mixer_class_get_event', 'snd_mixer_class_get_private',
'snd_mixer_class_get_compare', 'snd_mixer_class_set_event',
'snd_mixer_class_set_private', 'snd_mixer_class_set_private_free',
'snd_mixer_class_set_compare', 'snd_mixer_selem_channel_id_t',
'SND_MIXER_SCHN_UNKNOWN', 'SND_MIXER_SCHN_FRONT_LEFT',
'SND_MIXER_SCHN_FRONT_RIGHT', 'SND_MIXER_SCHN_REAR_LEFT',
'SND_MIXER_SCHN_REAR_RIGHT', 'SND_MIXER_SCHN_FRONT_CENTER',
'SND_MIXER_SCHN_WOOFER', 'SND_MIXER_SCHN_SIDE_LEFT',
'SND_MIXER_SCHN_SIDE_RIGHT', 'SND_MIXER_SCHN_REAR_CENTER',
'SND_MIXER_SCHN_LAST', 'SND_MIXER_SCHN_MONO', 'snd_mixer_selem_id_t',
'snd_mixer_selem_channel_name', 'snd_mixer_selem_register',
'snd_mixer_selem_get_id', 'snd_mixer_selem_get_name',
'snd_mixer_selem_get_index', 'snd_mixer_find_selem',
'snd_mixer_selem_is_active', 'snd_mixer_selem_is_playback_mono',
'snd_mixer_selem_has_playback_channel', 'snd_mixer_selem_is_capture_mono',
'snd_mixer_selem_has_capture_channel', 'snd_mixer_selem_get_capture_group',
'snd_mixer_selem_has_common_volume', 'snd_mixer_selem_has_playback_volume',
'snd_mixer_selem_has_playback_volume_joined',
'snd_mixer_selem_has_capture_volume',
'snd_mixer_selem_has_capture_volume_joined',
'snd_mixer_selem_has_common_switch', 'snd_mixer_selem_has_playback_switch',
'snd_mixer_selem_has_playback_switch_joined',
'snd_mixer_selem_has_capture_switch',
'snd_mixer_selem_has_capture_switch_joined',
'snd_mixer_selem_has_capture_switch_exclusive',
'snd_mixer_selem_get_playback_volume', 'snd_mixer_selem_get_capture_volume',
'snd_mixer_selem_get_playback_dB', 'snd_mixer_selem_get_capture_dB',
'snd_mixer_selem_get_playback_switch', 'snd_mixer_selem_get_capture_switch',
'snd_mixer_selem_set_playback_volume', 'snd_mixer_selem_set_capture_volume',
'snd_mixer_selem_set_playback_dB', 'snd_mixer_selem_set_capture_dB',
'snd_mixer_selem_set_playback_volume_all',
'snd_mixer_selem_set_capture_volume_all',
'snd_mixer_selem_set_playback_dB_all', 'snd_mixer_selem_set_capture_dB_all',
'snd_mixer_selem_set_playback_switch', 'snd_mixer_selem_set_capture_switch',
'snd_mixer_selem_set_playback_switch_all',
'snd_mixer_selem_set_capture_switch_all',
'snd_mixer_selem_get_playback_volume_range',
'snd_mixer_selem_get_playback_dB_range',
'snd_mixer_selem_set_playback_volume_range',
'snd_mixer_selem_get_capture_volume_range',
'snd_mixer_selem_get_capture_dB_range',
'snd_mixer_selem_set_capture_volume_range', 'snd_mixer_selem_is_enumerated',
'snd_mixer_selem_is_enum_playback', 'snd_mixer_selem_is_enum_capture',
'snd_mixer_selem_get_enum_items', 'snd_mixer_selem_get_enum_item_name',
'snd_mixer_selem_get_enum_item', 'snd_mixer_selem_set_enum_item',
'snd_mixer_selem_id_sizeof', 'snd_mixer_selem_id_malloc',
'snd_mixer_selem_id_free', 'snd_mixer_selem_id_copy',
'snd_mixer_selem_id_get_name', 'snd_mixer_selem_id_get_index',
'snd_mixer_selem_id_set_name', 'snd_mixer_selem_id_set_index',
'snd_seq_event_type_t', 'snd_seq_addr_t', 'snd_seq_connect_t',
'snd_seq_real_time_t', 'snd_seq_tick_time_t', 'snd_seq_timestamp_t',
'SND_SEQ_TIME_STAMP_TICK', 'SND_SEQ_TIME_STAMP_REAL',
'SND_SEQ_TIME_STAMP_MASK', 'SND_SEQ_TIME_MODE_ABS', 'SND_SEQ_TIME_MODE_REL',
'SND_SEQ_TIME_MODE_MASK', 'SND_SEQ_EVENT_LENGTH_FIXED',
'SND_SEQ_EVENT_LENGTH_VARIABLE', 'SND_SEQ_EVENT_LENGTH_VARUSR',
'SND_SEQ_EVENT_LENGTH_MASK', 'SND_SEQ_PRIORITY_NORMAL',
'SND_SEQ_PRIORITY_HIGH', 'SND_SEQ_PRIORITY_MASK', 'snd_seq_ev_note_t',
'snd_seq_ev_ctrl_t', 'snd_seq_ev_raw8_t', 'snd_seq_ev_raw32_t',
'snd_seq_ev_ext_t', 'snd_seq_instr_cluster_t', 'snd_seq_instr_t',
'snd_seq_ev_sample_t', 'snd_seq_ev_cluster_t', 'snd_seq_position_t',
'snd_seq_stop_mode_t', 'SND_SEQ_SAMPLE_STOP_IMMEDIATELY',
'SND_SEQ_SAMPLE_STOP_VENVELOPE', 'SND_SEQ_SAMPLE_STOP_LOOP',
'snd_seq_frequency_t', 'snd_seq_ev_volume_t', 'snd_seq_ev_loop_t',
'snd_seq_ev_sample_control_t', 'snd_seq_ev_instr_begin_t', 'snd_seq_result_t',
'snd_seq_queue_skew_t', 'snd_seq_ev_queue_control_t', 'snd_seq_event_t',
'SND_SEQ_DLSYM_VERSION', 'snd_seq_t', 'SND_SEQ_OPEN_OUTPUT',
'SND_SEQ_OPEN_INPUT', 'SND_SEQ_OPEN_DUPLEX', 'SND_SEQ_NONBLOCK',
'snd_seq_type_t', 'SND_SEQ_TYPE_HW', 'SND_SEQ_TYPE_SHM', 'SND_SEQ_TYPE_INET',
'SND_SEQ_ADDRESS_UNKNOWN', 'SND_SEQ_ADDRESS_SUBSCRIBERS',
'SND_SEQ_ADDRESS_BROADCAST', 'SND_SEQ_CLIENT_SYSTEM', 'snd_seq_open',
'snd_seq_open_lconf', 'snd_seq_name', 'snd_seq_type', 'snd_seq_close',
'snd_seq_poll_descriptors_count', 'snd_seq_poll_descriptors',
'snd_seq_poll_descriptors_revents', 'snd_seq_nonblock', 'snd_seq_client_id',
'snd_seq_get_output_buffer_size', 'snd_seq_get_input_buffer_size',
'snd_seq_set_output_buffer_size', 'snd_seq_set_input_buffer_size',
'snd_seq_system_info_t', 'snd_seq_system_info_sizeof',
'snd_seq_system_info_malloc', 'snd_seq_system_info_free',
'snd_seq_system_info_copy', 'snd_seq_system_info_get_queues',
'snd_seq_system_info_get_clients', 'snd_seq_system_info_get_ports',
'snd_seq_system_info_get_channels', 'snd_seq_system_info_get_cur_clients',
'snd_seq_system_info_get_cur_queues', 'snd_seq_system_info',
'snd_seq_client_info_t', 'snd_seq_client_type_t', 'SND_SEQ_USER_CLIENT',
'SND_SEQ_KERNEL_CLIENT', 'snd_seq_client_info_sizeof',
'snd_seq_client_info_malloc', 'snd_seq_client_info_free',
'snd_seq_client_info_copy', 'snd_seq_client_info_get_client',
'snd_seq_client_info_get_type', 'snd_seq_client_info_get_name',
'snd_seq_client_info_get_broadcast_filter',
'snd_seq_client_info_get_error_bounce',
'snd_seq_client_info_get_event_filter', 'snd_seq_client_info_get_num_ports',
'snd_seq_client_info_get_event_lost', 'snd_seq_client_info_set_client',
'snd_seq_client_info_set_name', 'snd_seq_client_info_set_broadcast_filter',
'snd_seq_client_info_set_error_bounce',
'snd_seq_client_info_set_event_filter', 'snd_seq_get_client_info',
'snd_seq_get_any_client_info', 'snd_seq_set_client_info',
'snd_seq_query_next_client', 'snd_seq_client_pool_t',
'snd_seq_client_pool_sizeof', 'snd_seq_client_pool_malloc',
'snd_seq_client_pool_free', 'snd_seq_client_pool_copy',
'snd_seq_client_pool_get_client', 'snd_seq_client_pool_get_output_pool',
'snd_seq_client_pool_get_input_pool', 'snd_seq_client_pool_get_output_room',
'snd_seq_client_pool_get_output_free', 'snd_seq_client_pool_get_input_free',
'snd_seq_client_pool_set_output_pool', 'snd_seq_client_pool_set_input_pool',
'snd_seq_client_pool_set_output_room', 'snd_seq_get_client_pool',
'snd_seq_set_client_pool', 'snd_seq_port_info_t', 'SND_SEQ_PORT_SYSTEM_TIMER',
'SND_SEQ_PORT_SYSTEM_ANNOUNCE', 'SND_SEQ_PORT_CAP_READ',
'SND_SEQ_PORT_CAP_WRITE', 'SND_SEQ_PORT_CAP_SYNC_READ',
'SND_SEQ_PORT_CAP_SYNC_WRITE', 'SND_SEQ_PORT_CAP_DUPLEX',
'SND_SEQ_PORT_CAP_SUBS_READ', 'SND_SEQ_PORT_CAP_SUBS_WRITE',
'SND_SEQ_PORT_CAP_NO_EXPORT', 'SND_SEQ_PORT_TYPE_SPECIFIC',
'SND_SEQ_PORT_TYPE_MIDI_GENERIC', 'SND_SEQ_PORT_TYPE_MIDI_GM',
'SND_SEQ_PORT_TYPE_MIDI_GS', 'SND_SEQ_PORT_TYPE_MIDI_XG',
'SND_SEQ_PORT_TYPE_MIDI_MT32', 'SND_SEQ_PORT_TYPE_MIDI_GM2',
'SND_SEQ_PORT_TYPE_SYNTH', 'SND_SEQ_PORT_TYPE_DIRECT_SAMPLE',
'SND_SEQ_PORT_TYPE_SAMPLE', 'SND_SEQ_PORT_TYPE_HARDWARE',
'SND_SEQ_PORT_TYPE_SOFTWARE', 'SND_SEQ_PORT_TYPE_SYNTHESIZER',
'SND_SEQ_PORT_TYPE_PORT', 'SND_SEQ_PORT_TYPE_APPLICATION',
'snd_seq_port_info_sizeof', 'snd_seq_port_info_malloc',
'snd_seq_port_info_free', 'snd_seq_port_info_copy',
'snd_seq_port_info_get_client', 'snd_seq_port_info_get_port',
'snd_seq_port_info_get_addr', 'snd_seq_port_info_get_name',
'snd_seq_port_info_get_capability', 'snd_seq_port_info_get_type',
'snd_seq_port_info_get_midi_channels', 'snd_seq_port_info_get_midi_voices',
'snd_seq_port_info_get_synth_voices', 'snd_seq_port_info_get_read_use',
'snd_seq_port_info_get_write_use', 'snd_seq_port_info_get_port_specified',
'snd_seq_port_info_get_timestamping', 'snd_seq_port_info_get_timestamp_real',
'snd_seq_port_info_get_timestamp_queue', 'snd_seq_port_info_set_client',
'snd_seq_port_info_set_port', 'snd_seq_port_info_set_addr',
'snd_seq_port_info_set_name', 'snd_seq_port_info_set_capability',
'snd_seq_port_info_set_type', 'snd_seq_port_info_set_midi_channels',
'snd_seq_port_info_set_midi_voices', 'snd_seq_port_info_set_synth_voices',
'snd_seq_port_info_set_port_specified', 'snd_seq_port_info_set_timestamping',
'snd_seq_port_info_set_timestamp_real',
'snd_seq_port_info_set_timestamp_queue', 'snd_seq_create_port',
'snd_seq_delete_port', 'snd_seq_get_port_info', 'snd_seq_get_any_port_info',
'snd_seq_set_port_info', 'snd_seq_query_next_port',
'snd_seq_port_subscribe_t', 'snd_seq_port_subscribe_sizeof',
'snd_seq_port_subscribe_malloc', 'snd_seq_port_subscribe_free',
'snd_seq_port_subscribe_copy', 'snd_seq_port_subscribe_get_sender',
'snd_seq_port_subscribe_get_dest', 'snd_seq_port_subscribe_get_queue',
'snd_seq_port_subscribe_get_exclusive',
'snd_seq_port_subscribe_get_time_update',
'snd_seq_port_subscribe_get_time_real', 'snd_seq_port_subscribe_set_sender',
'snd_seq_port_subscribe_set_dest', 'snd_seq_port_subscribe_set_queue',
'snd_seq_port_subscribe_set_exclusive',
'snd_seq_port_subscribe_set_time_update',
'snd_seq_port_subscribe_set_time_real', 'snd_seq_get_port_subscription',
'snd_seq_subscribe_port', 'snd_seq_unsubscribe_port',
'snd_seq_query_subscribe_t', 'snd_seq_query_subs_type_t',
'SND_SEQ_QUERY_SUBS_READ', 'SND_SEQ_QUERY_SUBS_WRITE',
'snd_seq_query_subscribe_sizeof', 'snd_seq_query_subscribe_malloc',
'snd_seq_query_subscribe_free', 'snd_seq_query_subscribe_copy',
'snd_seq_query_subscribe_get_client', 'snd_seq_query_subscribe_get_port',
'snd_seq_query_subscribe_get_root', 'snd_seq_query_subscribe_get_type',
'snd_seq_query_subscribe_get_index', 'snd_seq_query_subscribe_get_num_subs',
'snd_seq_query_subscribe_get_addr', 'snd_seq_query_subscribe_get_queue',
'snd_seq_query_subscribe_get_exclusive',
'snd_seq_query_subscribe_get_time_update',
'snd_seq_query_subscribe_get_time_real', 'snd_seq_query_subscribe_set_client',
'snd_seq_query_subscribe_set_port', 'snd_seq_query_subscribe_set_root',
'snd_seq_query_subscribe_set_type', 'snd_seq_query_subscribe_set_index',
'snd_seq_query_port_subscribers', 'snd_seq_queue_info_t',
'snd_seq_queue_status_t', 'snd_seq_queue_tempo_t', 'snd_seq_queue_timer_t',
'SND_SEQ_QUEUE_DIRECT', 'snd_seq_queue_info_sizeof',
'snd_seq_queue_info_malloc', 'snd_seq_queue_info_free',
'snd_seq_queue_info_copy', 'snd_seq_queue_info_get_queue',
'snd_seq_queue_info_get_name', 'snd_seq_queue_info_get_owner',
'snd_seq_queue_info_get_locked', 'snd_seq_queue_info_get_flags',
'snd_seq_queue_info_set_name', 'snd_seq_queue_info_set_owner',
'snd_seq_queue_info_set_locked', 'snd_seq_queue_info_set_flags',
'snd_seq_create_queue', 'snd_seq_alloc_named_queue', 'snd_seq_alloc_queue',
'snd_seq_free_queue', 'snd_seq_get_queue_info', 'snd_seq_set_queue_info',
'snd_seq_query_named_queue', 'snd_seq_get_queue_usage',
'snd_seq_set_queue_usage', 'snd_seq_queue_status_sizeof',
'snd_seq_queue_status_malloc', 'snd_seq_queue_status_free',
'snd_seq_queue_status_copy', 'snd_seq_queue_status_get_queue',
'snd_seq_queue_status_get_events', 'snd_seq_queue_status_get_tick_time',
'snd_seq_queue_status_get_real_time', 'snd_seq_queue_status_get_status',
'snd_seq_get_queue_status', 'snd_seq_queue_tempo_sizeof',
'snd_seq_queue_tempo_malloc', 'snd_seq_queue_tempo_free',
'snd_seq_queue_tempo_copy', 'snd_seq_queue_tempo_get_queue',
'snd_seq_queue_tempo_get_tempo', 'snd_seq_queue_tempo_get_ppq',
'snd_seq_queue_tempo_get_skew', 'snd_seq_queue_tempo_get_skew_base',
'snd_seq_queue_tempo_set_tempo', 'snd_seq_queue_tempo_set_ppq',
'snd_seq_queue_tempo_set_skew', 'snd_seq_queue_tempo_set_skew_base',
'snd_seq_get_queue_tempo', 'snd_seq_set_queue_tempo',
'snd_seq_queue_timer_type_t', 'SND_SEQ_TIMER_ALSA',
'SND_SEQ_TIMER_MIDI_CLOCK', 'SND_SEQ_TIMER_MIDI_TICK',
'snd_seq_queue_timer_sizeof', 'snd_seq_queue_timer_malloc',
'snd_seq_queue_timer_free', 'snd_seq_queue_timer_copy',
'snd_seq_queue_timer_get_queue', 'snd_seq_queue_timer_get_type',
'snd_seq_queue_timer_get_id', 'snd_seq_queue_timer_get_resolution',
'snd_seq_queue_timer_set_type', 'snd_seq_queue_timer_set_id',
'snd_seq_queue_timer_set_resolution', 'snd_seq_get_queue_timer',
'snd_seq_set_queue_timer', 'snd_seq_free_event', 'snd_seq_event_length',
'snd_seq_event_output', 'snd_seq_event_output_buffer',
'snd_seq_event_output_direct', 'snd_seq_event_input',
'snd_seq_event_input_pending', 'snd_seq_drain_output',
'snd_seq_event_output_pending', 'snd_seq_extract_output',
'snd_seq_drop_output', 'snd_seq_drop_output_buffer', 'snd_seq_drop_input',
'snd_seq_drop_input_buffer', 'snd_seq_remove_events_t',
'SND_SEQ_REMOVE_INPUT', 'SND_SEQ_REMOVE_OUTPUT', 'SND_SEQ_REMOVE_DEST',
'SND_SEQ_REMOVE_DEST_CHANNEL', 'SND_SEQ_REMOVE_TIME_BEFORE',
'SND_SEQ_REMOVE_TIME_AFTER', 'SND_SEQ_REMOVE_TIME_TICK',
'SND_SEQ_REMOVE_EVENT_TYPE', 'SND_SEQ_REMOVE_IGNORE_OFF',
'SND_SEQ_REMOVE_TAG_MATCH', 'snd_seq_remove_events_sizeof',
'snd_seq_remove_events_malloc', 'snd_seq_remove_events_free',
'snd_seq_remove_events_copy', 'snd_seq_remove_events_get_condition',
'snd_seq_remove_events_get_queue', 'snd_seq_remove_events_get_time',
'snd_seq_remove_events_get_dest', 'snd_seq_remove_events_get_channel',
'snd_seq_remove_events_get_event_type', 'snd_seq_remove_events_get_tag',
'snd_seq_remove_events_set_condition', 'snd_seq_remove_events_set_queue',
'snd_seq_remove_events_set_time', 'snd_seq_remove_events_set_dest',
'snd_seq_remove_events_set_channel', 'snd_seq_remove_events_set_event_type',
'snd_seq_remove_events_set_tag', 'snd_seq_remove_events', 'snd_seq_set_bit',
'snd_seq_change_bit', 'snd_seq_get_bit', 'snd_seq_control_queue',
'snd_seq_create_simple_port', 'snd_seq_delete_simple_port',
'snd_seq_connect_from', 'snd_seq_connect_to', 'snd_seq_disconnect_from',
'snd_seq_disconnect_to', 'snd_seq_set_client_name',
'snd_seq_set_client_event_filter', 'snd_seq_set_client_pool_output',
'snd_seq_set_client_pool_output_room', 'snd_seq_set_client_pool_input',
'snd_seq_sync_output_queue', 'snd_seq_parse_address',
'snd_seq_reset_pool_output', 'snd_seq_reset_pool_input', 'snd_midi_event_t',
'snd_midi_event_new', 'snd_midi_event_resize_buffer', 'snd_midi_event_free',
'snd_midi_event_init', 'snd_midi_event_reset_encode',
'snd_midi_event_reset_decode', 'snd_midi_event_no_status',
'snd_midi_event_encode', 'snd_midi_event_encode_byte',
'snd_midi_event_decode', 'snd_instr_header_t', 'snd_instr_header_sizeof',
'snd_instr_header_malloc', 'snd_instr_header_free', 'snd_instr_header_copy',
'snd_instr_header_get_id', 'snd_instr_header_get_cluster',
'snd_instr_header_get_cmd', 'snd_instr_header_get_len',
'snd_instr_header_get_name', 'snd_instr_header_get_type',
'snd_instr_header_get_format', 'snd_instr_header_get_alias',
'snd_instr_header_get_data', 'snd_instr_header_get_follow_alias',
'snd_instr_header_set_id', 'snd_instr_header_set_cluster',
'snd_instr_header_set_cmd', 'snd_instr_header_set_len',
'snd_instr_header_set_name', 'snd_instr_header_set_type',
'snd_instr_header_set_format', 'snd_instr_header_set_alias',
'snd_instr_header_set_follow_alias', 'SND_SEQ_INSTR_ATYPE_DATA',
'SND_SEQ_INSTR_ATYPE_ALIAS', 'SND_SEQ_INSTR_TYPE0_DLS1',
'SND_SEQ_INSTR_TYPE0_DLS2', 'SND_SEQ_INSTR_TYPE1_SIMPLE',
'SND_SEQ_INSTR_TYPE1_SOUNDFONT', 'SND_SEQ_INSTR_TYPE1_GUS_PATCH',
'SND_SEQ_INSTR_TYPE1_INTERWAVE', 'SND_SEQ_INSTR_TYPE2_OPL2_3',
'SND_SEQ_INSTR_TYPE2_OPL4', 'SND_SEQ_INSTR_PUT_CMD_CREATE',
'SND_SEQ_INSTR_PUT_CMD_REPLACE', 'SND_SEQ_INSTR_PUT_CMD_MODIFY',
'SND_SEQ_INSTR_PUT_CMD_ADD', 'SND_SEQ_INSTR_PUT_CMD_REMOVE',
'SND_SEQ_INSTR_GET_CMD_FULL', 'SND_SEQ_INSTR_GET_CMD_PARTIAL',
'SND_SEQ_INSTR_QUERY_FOLLOW_ALIAS', 'SND_SEQ_INSTR_FREE_CMD_ALL',
'SND_SEQ_INSTR_FREE_CMD_PRIVATE', 'SND_SEQ_INSTR_FREE_CMD_CLUSTER',
'SND_SEQ_INSTR_FREE_CMD_SINGLE', 'snd_instr_fm_t',
'snd_instr_fm_convert_to_stream', 'snd_instr_fm_convert_from_stream',
'snd_instr_fm_free', 'snd_instr_simple_t',
'snd_instr_simple_convert_to_stream', 'snd_instr_simple_convert_from_stream',
'snd_instr_simple_free', 'snd_instr_iwffff_t', 'snd_iwffff_handle_t',
'snd_instr_iwffff_open', 'snd_instr_iwffff_open_rom',
'snd_instr_iwffff_open_rom_file', 'snd_instr_iwffff_close',
'snd_instr_iwffff_load', 'snd_instr_iwffff_convert_to_stream',
'snd_instr_iwffff_convert_from_stream', 'snd_instr_iwffff_free']

########NEW FILE########
__FILENAME__ = lib_dsound
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
# $Id:$

import ctypes
from pyglet import com

lib = ctypes.oledll.dsound

DWORD = ctypes.c_uint32
LPDWORD = ctypes.POINTER(DWORD)
LONG = ctypes.c_long
LPLONG = ctypes.POINTER(LONG)
WORD = ctypes.c_uint16
HWND = DWORD
LPUNKNOWN = ctypes.c_void_p

D3DVALUE = ctypes.c_float
PD3DVALUE = ctypes.POINTER(D3DVALUE)

class D3DVECTOR(ctypes.Structure):
    _fields_ = [
        ('x', ctypes.c_float),
        ('y', ctypes.c_float),
        ('z', ctypes.c_float),
    ]
PD3DVECTOR = ctypes.POINTER(D3DVECTOR)

class WAVEFORMATEX(ctypes.Structure):
    _fields_ = [
        ('wFormatTag', WORD),
        ('nChannels', WORD),
        ('nSamplesPerSec', DWORD),
        ('nAvgBytesPerSec', DWORD),
        ('nBlockAlign', WORD),
        ('wBitsPerSample', WORD),
        ('cbSize', WORD),
    ]
LPWAVEFORMATEX = ctypes.POINTER(WAVEFORMATEX)
WAVE_FORMAT_PCM = 1

class DSCAPS(ctypes.Structure):
    _fields_ = [
        ('dwSize', DWORD),
        ('dwFlags', DWORD),
        ('dwMinSecondarySampleRate', DWORD),
        ('dwMaxSecondarySampleRate', DWORD),
        ('dwPrimaryBuffers', DWORD),
        ('dwMaxHwMixingAllBuffers', DWORD),
        ('dwMaxHwMixingStaticBuffers', DWORD),
        ('dwMaxHwMixingStreamingBuffers', DWORD),
        ('dwFreeHwMixingAllBuffers', DWORD),
        ('dwFreeHwMixingStaticBuffers', DWORD),
        ('dwFreeHwMixingStreamingBuffers', DWORD),
        ('dwMaxHw3DAllBuffers', DWORD),
        ('dwMaxHw3DStaticBuffers', DWORD),
        ('dwMaxHw3DStreamingBuffers', DWORD),
        ('dwFreeHw3DAllBuffers', DWORD),
        ('dwFreeHw3DStaticBuffers', DWORD),
        ('dwFreeHw3DStreamingBuffers', DWORD),
        ('dwTotalHwMemBytes', DWORD),
        ('dwFreeHwMemBytes', DWORD),
        ('dwMaxContigFreeHwMemBytes', DWORD),
        ('dwUnlockTransferRateHwBuffers', DWORD),
        ('dwPlayCpuOverheadSwBuffers', DWORD),
        ('dwReserved1', DWORD),
        ('dwReserved2', DWORD)
    ]
LPDSCAPS = ctypes.POINTER(DSCAPS)

class DSBCAPS(ctypes.Structure):
    _fields_ = [
        ('dwSize', DWORD),
        ('dwFlags', DWORD),
        ('dwBufferBytes', DWORD),
        ('dwUnlockTransferRate', DWORD),
        ('dwPlayCpuOverhead', DWORD),
    ]
LPDSBCAPS = ctypes.POINTER(DSBCAPS)

class DSBUFFERDESC(ctypes.Structure):
    _fields_ = [
        ('dwSize', DWORD),
        ('dwFlags', DWORD),
        ('dwBufferBytes', DWORD),
        ('dwReserved', DWORD),
        ('lpwfxFormat', LPWAVEFORMATEX),
    ]
LPDSBUFFERDESC = ctypes.POINTER(DSBUFFERDESC)

class DS3DBUFFER(ctypes.Structure):
    _fields_ = [
        ('dwSize', DWORD),
        ('vPosition', D3DVECTOR),
        ('vVelocity', D3DVECTOR),
        ('dwInsideConeAngle', DWORD),
        ('dwOutsideConeAngle', DWORD),
        ('vConeOrientation', D3DVECTOR),
        ('lConeOutsideVolume', LONG),
        ('flMinDistance', D3DVALUE),
        ('flMaxDistance', D3DVALUE),
        ('dwMode', DWORD),
    ]
LPDS3DBUFFER = ctypes.POINTER(DS3DBUFFER)

class DS3DLISTENER(ctypes.Structure):
    _fields_ = [
        ('dwSize', DWORD),
        ('vPosition', D3DVECTOR),
        ('vVelocity', D3DVECTOR),
        ('vOrientFront', D3DVECTOR),
        ('vOrientTop', D3DVECTOR),
        ('flDistanceFactor', D3DVALUE),
        ('flRolloffFactor', D3DVALUE),
        ('flDopplerFactor', D3DVALUE),
    ]
LPDS3DLISTENER = ctypes.POINTER(DS3DLISTENER)

class IDirectSoundBuffer(com.IUnknown):
    _methods_ = [
        ('GetCaps',
         com.STDMETHOD(LPDSBCAPS)),
        ('GetCurrentPosition',
         com.STDMETHOD(LPDWORD, LPDWORD)),
        ('GetFormat',
         com.STDMETHOD(LPWAVEFORMATEX, DWORD, LPDWORD)),
        ('GetVolume',
         com.STDMETHOD(LPLONG)),
        ('GetPan',
         com.STDMETHOD(LPLONG)),
        ('GetFrequency',
         com.STDMETHOD(LPDWORD)),
        ('GetStatus',
         com.STDMETHOD(LPDWORD)),
        ('Initialize',
         com.STDMETHOD(ctypes.c_void_p, LPDSBUFFERDESC)),
        ('Lock',
         com.STDMETHOD(DWORD, DWORD,
                       ctypes.POINTER(ctypes.c_void_p), LPDWORD,
                       ctypes.POINTER(ctypes.c_void_p), LPDWORD,
                       DWORD)),
        ('Play',
         com.STDMETHOD(DWORD, DWORD, DWORD)),
        ('SetCurrentPosition',
         com.STDMETHOD(DWORD)),
        ('SetFormat',
         com.STDMETHOD(LPWAVEFORMATEX)),
        ('SetVolume',
         com.STDMETHOD(LONG)),
        ('SetPan',
         com.STDMETHOD(LONG)),
        ('SetFrequency',
         com.STDMETHOD(DWORD)),
        ('Stop',
         com.STDMETHOD()),
        ('Unlock',
         com.STDMETHOD(ctypes.c_void_p, DWORD, ctypes.c_void_p, DWORD)),
        ('Restore',
         com.STDMETHOD()),
    ]

IID_IDirectSound3DListener = com.GUID(
    0x279AFA84, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60)

class IDirectSound3DListener(com.IUnknown):
    _methods_ = [
        ('GetAllParameters',
         com.STDMETHOD(LPDS3DLISTENER)),
        ('GetDistanceFactor',
         com.STDMETHOD(PD3DVALUE)),
        ('GetDopplerFactor',
         com.STDMETHOD(PD3DVALUE)),
        ('GetOrientation',
         com.STDMETHOD(PD3DVECTOR)),
        ('GetPosition',
         com.STDMETHOD(PD3DVECTOR)),
        ('GetRolloffFactor',
         com.STDMETHOD(PD3DVALUE)),
        ('GetVelocity',
         com.STDMETHOD(PD3DVECTOR)),
        ('SetAllParameters',
         com.STDMETHOD(LPDS3DLISTENER)),
        ('SetDistanceFactor',
         com.STDMETHOD(D3DVALUE, DWORD)),
        ('SetDopplerFactor',
         com.STDMETHOD(D3DVALUE, DWORD)),
        ('SetOrientation',
         com.STDMETHOD(D3DVALUE, D3DVALUE, D3DVALUE,
                       D3DVALUE, D3DVALUE, D3DVALUE, DWORD)),
        ('SetPosition',
         com.STDMETHOD(D3DVALUE, D3DVALUE, D3DVALUE, DWORD)),
        ('SetRolloffFactor',
         com.STDMETHOD(D3DVALUE, DWORD)),
        ('SetVelocity',
         com.STDMETHOD(D3DVALUE, D3DVALUE, D3DVALUE, DWORD)),
        ('CommitDeferredSettings',
         com.STDMETHOD()),
    ]

IID_IDirectSound3DBuffer = com.GUID(
    0x279AFA86, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60)

class IDirectSound3DBuffer(com.IUnknown):
    _methods_ = [
        ('GetAllParameters',
         com.STDMETHOD(LPDS3DBUFFER)),
        ('GetConeAngles',
         com.STDMETHOD(LPDWORD, LPDWORD)),
        ('GetConeOrientation',
         com.STDMETHOD(PD3DVECTOR)),
        ('GetConeOutsideVolume',
         com.STDMETHOD(LPLONG)),
        ('GetMaxDistance',
         com.STDMETHOD(PD3DVALUE)),
        ('GetMinDistance',
         com.STDMETHOD(PD3DVALUE)),
        ('GetMode',
         com.STDMETHOD(LPDWORD)),
        ('GetPosition',
         com.STDMETHOD(PD3DVECTOR)),
        ('GetVelocity',
         com.STDMETHOD(PD3DVECTOR)),
        ('SetAllParameters',
         com.STDMETHOD(LPDS3DBUFFER, DWORD)),
        ('SetConeAngles',
         com.STDMETHOD(DWORD, DWORD, DWORD)),
        ('SetConeOrientation',
         com.STDMETHOD(D3DVALUE, D3DVALUE, D3DVALUE, DWORD)),
        ('SetConeOutsideVolume',
         com.STDMETHOD(LONG, DWORD)),
        ('SetMaxDistance',
         com.STDMETHOD(D3DVALUE, DWORD)),
        ('SetMinDistance',
         com.STDMETHOD(D3DVALUE, DWORD)),
        ('SetMode',
         com.STDMETHOD(DWORD, DWORD)),
        ('SetPosition',
         com.STDMETHOD(D3DVALUE, D3DVALUE, D3DVALUE, DWORD)),
        ('SetVelocity',
         com.STDMETHOD(D3DVALUE, D3DVALUE, D3DVALUE, DWORD)),
    ]

class IDirectSound(com.IUnknown):
    _methods_ = [
        ('CreateSoundBuffer',
         com.STDMETHOD(LPDSBUFFERDESC,
                       ctypes.POINTER(IDirectSoundBuffer),
                       LPUNKNOWN)),
        ('GetCaps',
         com.STDMETHOD(LPDSCAPS)),
        ('DuplicateSoundBuffer',
         com.STDMETHOD(IDirectSoundBuffer,
                       ctypes.POINTER(IDirectSoundBuffer))),
        ('SetCooperativeLevel',
         com.STDMETHOD(HWND, DWORD)),
        ('Compact',
         com.STDMETHOD()),
        ('GetSpeakerConfig',
         com.STDMETHOD(LPDWORD)),
        ('SetSpeakerConfig',
         com.STDMETHOD(DWORD)),
        ('Initialize',
         com.STDMETHOD(com.LPGUID)),
    ]
    _type_ = com.COMInterface

DirectSoundCreate = lib.DirectSoundCreate
DirectSoundCreate.argtypes = \
    [com.LPGUID, ctypes.POINTER(IDirectSound), ctypes.c_void_p]

DSCAPS_PRIMARYMONO = 0x00000001
DSCAPS_PRIMARYSTEREO = 0x00000002
DSCAPS_PRIMARY8BIT = 0x00000004
DSCAPS_PRIMARY16BIT = 0x00000008
DSCAPS_CONTINUOUSRATE = 0x00000010
DSCAPS_EMULDRIVER = 0x00000020
DSCAPS_CERTIFIED = 0x00000040
DSCAPS_SECONDARYMONO = 0x00000100
DSCAPS_SECONDARYSTEREO = 0x00000200
DSCAPS_SECONDARY8BIT = 0x00000400
DSCAPS_SECONDARY16BIT = 0x00000800

DSSCL_NORMAL = 0x00000001
DSSCL_PRIORITY = 0x00000002
DSSCL_EXCLUSIVE = 0x00000003
DSSCL_WRITEPRIMARY = 0x00000004

DSSPEAKER_DIRECTOUT = 0x00000000
DSSPEAKER_HEADPHONE = 0x00000001
DSSPEAKER_MONO = 0x00000002
DSSPEAKER_QUAD = 0x00000003
DSSPEAKER_STEREO = 0x00000004
DSSPEAKER_SURROUND = 0x00000005
DSSPEAKER_5POINT1 = 0x00000006
DSSPEAKER_7POINT1 = 0x00000007

DSSPEAKER_GEOMETRY_MIN = 0x00000005  #   5 degrees
DSSPEAKER_GEOMETRY_NARROW = 0x0000000A  #  10 degrees
DSSPEAKER_GEOMETRY_WIDE = 0x00000014  #  20 degrees
DSSPEAKER_GEOMETRY_MAX = 0x000000B4  # 180 degrees

DSBCAPS_PRIMARYBUFFER = 0x00000001
DSBCAPS_STATIC = 0x00000002
DSBCAPS_LOCHARDWARE = 0x00000004
DSBCAPS_LOCSOFTWARE = 0x00000008
DSBCAPS_CTRL3D = 0x00000010
DSBCAPS_CTRLFREQUENCY = 0x00000020
DSBCAPS_CTRLPAN = 0x00000040
DSBCAPS_CTRLVOLUME = 0x00000080
DSBCAPS_CTRLPOSITIONNOTIFY = 0x00000100
DSBCAPS_CTRLFX = 0x00000200
DSBCAPS_STICKYFOCUS = 0x00004000
DSBCAPS_GLOBALFOCUS = 0x00008000
DSBCAPS_GETCURRENTPOSITION2 = 0x00010000
DSBCAPS_MUTE3DATMAXDISTANCE = 0x00020000
DSBCAPS_LOCDEFER = 0x00040000

DSBPLAY_LOOPING = 0x00000001
DSBPLAY_LOCHARDWARE = 0x00000002
DSBPLAY_LOCSOFTWARE = 0x00000004
DSBPLAY_TERMINATEBY_TIME = 0x00000008
DSBPLAY_TERMINATEBY_DISTANCE = 0x000000010
DSBPLAY_TERMINATEBY_PRIORITY = 0x000000020

DSBSTATUS_PLAYING = 0x00000001
DSBSTATUS_BUFFERLOST = 0x00000002
DSBSTATUS_LOOPING = 0x00000004
DSBSTATUS_LOCHARDWARE = 0x00000008
DSBSTATUS_LOCSOFTWARE = 0x00000010
DSBSTATUS_TERMINATED = 0x00000020

DSBLOCK_FROMWRITECURSOR = 0x00000001
DSBLOCK_ENTIREBUFFER = 0x00000002

DSBFREQUENCY_MIN = 100
DSBFREQUENCY_MAX = 100000
DSBFREQUENCY_ORIGINAL = 0

DSBPAN_LEFT = -10000
DSBPAN_CENTER = 0
DSBPAN_RIGHT = 10000

DSBVOLUME_MIN = -10000
DSBVOLUME_MAX = 0

DSBSIZE_MIN = 4
DSBSIZE_MAX = 0x0FFFFFFF
DSBSIZE_FX_MIN = 150  # NOTE: Milliseconds, not bytes

DS3DMODE_NORMAL = 0x00000000
DS3DMODE_HEADRELATIVE = 0x00000001
DS3DMODE_DISABLE = 0x00000002

DS3D_IMMEDIATE = 0x00000000
DS3D_DEFERRED = 0x00000001

DS3D_MINDISTANCEFACTOR = -1000000.0 # XXX FLT_MIN
DS3D_MAXDISTANCEFACTOR = 1000000.0  # XXX FLT_MAX
DS3D_DEFAULTDISTANCEFACTOR = 1.0

DS3D_MINROLLOFFFACTOR = 0.0
DS3D_MAXROLLOFFFACTOR = 10.0
DS3D_DEFAULTROLLOFFFACTOR = 1.0

DS3D_MINDOPPLERFACTOR = 0.0
DS3D_MAXDOPPLERFACTOR = 10.0
DS3D_DEFAULTDOPPLERFACTOR = 1.0

DS3D_DEFAULTMINDISTANCE = 1.0
DS3D_DEFAULTMAXDISTANCE = 1000000000.0

DS3D_MINCONEANGLE = 0
DS3D_MAXCONEANGLE = 360
DS3D_DEFAULTCONEANGLE = 360

DS3D_DEFAULTCONEOUTSIDEVOLUME = DSBVOLUME_MAX


########NEW FILE########
__FILENAME__ = lib_alc
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for openal

Generated with:
../tools/wraptypes/wrap.py /usr/include/AL/alc.h -lopenal -olib_alc.py

.. Hacked to fix ALCvoid argtypes.
'''

__docformat__ =  'restructuredtext'
__version__ = '$Id: lib_alc.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

import ctypes
from ctypes import *
import sys

import pyglet.lib

_lib = pyglet.lib.load_library('openal', win32='openal32',
    framework='/System/Library/Frameworks/OpenAL.framework')

_int_types = (c_int16, c_int32)
if hasattr(ctypes, 'c_int64'):
    # Some builds of ctypes apparently do not have c_int64
    # defined; it's a pretty good bet that these builds do not
    # have 64-bit pointers.
    _int_types += (ctypes.c_int64,)
for t in _int_types:
    if sizeof(t) == sizeof(c_size_t):
        c_ptrdiff_t = t

class c_void(Structure):
    # c_void_p is a buggy return type, converting to int, so
    # POINTER(None) == c_void_p is actually written as
    # POINTER(c_void), so it can be treated as a real pointer.
    _fields_ = [('dummy', c_int)]



ALC_API = 0 	# /usr/include/AL/alc.h:19
ALCAPI = 0 	# /usr/include/AL/alc.h:37
ALC_INVALID = 0 	# /usr/include/AL/alc.h:39
ALC_VERSION_0_1 = 1 	# /usr/include/AL/alc.h:42
class struct_ALCdevice_struct(Structure):
    __slots__ = [
    ]
struct_ALCdevice_struct._fields_ = [
    ('_opaque_struct', c_int)
]

class struct_ALCdevice_struct(Structure):
    __slots__ = [
    ]
struct_ALCdevice_struct._fields_ = [
    ('_opaque_struct', c_int)
]

ALCdevice = struct_ALCdevice_struct 	# /usr/include/AL/alc.h:44
class struct_ALCcontext_struct(Structure):
    __slots__ = [
    ]
struct_ALCcontext_struct._fields_ = [
    ('_opaque_struct', c_int)
]

class struct_ALCcontext_struct(Structure):
    __slots__ = [
    ]
struct_ALCcontext_struct._fields_ = [
    ('_opaque_struct', c_int)
]

ALCcontext = struct_ALCcontext_struct 	# /usr/include/AL/alc.h:45
ALCboolean = c_char 	# /usr/include/AL/alc.h:49
ALCchar = c_char 	# /usr/include/AL/alc.h:52
ALCbyte = c_char 	# /usr/include/AL/alc.h:55
ALCubyte = c_ubyte 	# /usr/include/AL/alc.h:58
ALCshort = c_short 	# /usr/include/AL/alc.h:61
ALCushort = c_ushort 	# /usr/include/AL/alc.h:64
ALCint = c_int 	# /usr/include/AL/alc.h:67
ALCuint = c_uint 	# /usr/include/AL/alc.h:70
ALCsizei = c_int 	# /usr/include/AL/alc.h:73
ALCenum = c_int 	# /usr/include/AL/alc.h:76
ALCfloat = c_float 	# /usr/include/AL/alc.h:79
ALCdouble = c_double 	# /usr/include/AL/alc.h:82
ALCvoid = None 	# /usr/include/AL/alc.h:85
ALC_FALSE = 0 	# /usr/include/AL/alc.h:91
ALC_TRUE = 1 	# /usr/include/AL/alc.h:94
ALC_FREQUENCY = 4103 	# /usr/include/AL/alc.h:99
ALC_REFRESH = 4104 	# /usr/include/AL/alc.h:104
ALC_SYNC = 4105 	# /usr/include/AL/alc.h:109
ALC_MONO_SOURCES = 4112 	# /usr/include/AL/alc.h:114
ALC_STEREO_SOURCES = 4113 	# /usr/include/AL/alc.h:119
ALC_NO_ERROR = 0 	# /usr/include/AL/alc.h:128
ALC_INVALID_DEVICE = 40961 	# /usr/include/AL/alc.h:133
ALC_INVALID_CONTEXT = 40962 	# /usr/include/AL/alc.h:138
ALC_INVALID_ENUM = 40963 	# /usr/include/AL/alc.h:143
ALC_INVALID_VALUE = 40964 	# /usr/include/AL/alc.h:148
ALC_OUT_OF_MEMORY = 40965 	# /usr/include/AL/alc.h:153
ALC_DEFAULT_DEVICE_SPECIFIER = 4100 	# /usr/include/AL/alc.h:159
ALC_DEVICE_SPECIFIER = 4101 	# /usr/include/AL/alc.h:160
ALC_EXTENSIONS = 4102 	# /usr/include/AL/alc.h:161
ALC_MAJOR_VERSION = 4096 	# /usr/include/AL/alc.h:163
ALC_MINOR_VERSION = 4097 	# /usr/include/AL/alc.h:164
ALC_ATTRIBUTES_SIZE = 4098 	# /usr/include/AL/alc.h:166
ALC_ALL_ATTRIBUTES = 4099 	# /usr/include/AL/alc.h:167
ALC_CAPTURE_DEVICE_SPECIFIER = 784 	# /usr/include/AL/alc.h:172
ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER = 785 	# /usr/include/AL/alc.h:173
ALC_CAPTURE_SAMPLES = 786 	# /usr/include/AL/alc.h:174
# /usr/include/AL/alc.h:180
alcCreateContext = _lib.alcCreateContext
alcCreateContext.restype = POINTER(ALCcontext)
alcCreateContext.argtypes = [POINTER(ALCdevice), POINTER(ALCint)]

# /usr/include/AL/alc.h:182
alcMakeContextCurrent = _lib.alcMakeContextCurrent
alcMakeContextCurrent.restype = ALCboolean
alcMakeContextCurrent.argtypes = [POINTER(ALCcontext)]

# /usr/include/AL/alc.h:184
alcProcessContext = _lib.alcProcessContext
alcProcessContext.restype = None
alcProcessContext.argtypes = [POINTER(ALCcontext)]

# /usr/include/AL/alc.h:186
alcSuspendContext = _lib.alcSuspendContext
alcSuspendContext.restype = None
alcSuspendContext.argtypes = [POINTER(ALCcontext)]

# /usr/include/AL/alc.h:188
alcDestroyContext = _lib.alcDestroyContext
alcDestroyContext.restype = None
alcDestroyContext.argtypes = [POINTER(ALCcontext)]

# /usr/include/AL/alc.h:190
alcGetCurrentContext = _lib.alcGetCurrentContext
alcGetCurrentContext.restype = POINTER(ALCcontext)
alcGetCurrentContext.argtypes = []

# /usr/include/AL/alc.h:192
alcGetContextsDevice = _lib.alcGetContextsDevice
alcGetContextsDevice.restype = POINTER(ALCdevice)
alcGetContextsDevice.argtypes = [POINTER(ALCcontext)]

# /usr/include/AL/alc.h:198
alcOpenDevice = _lib.alcOpenDevice
alcOpenDevice.restype = POINTER(ALCdevice)
alcOpenDevice.argtypes = [POINTER(ALCchar)]

# /usr/include/AL/alc.h:200
alcCloseDevice = _lib.alcCloseDevice
alcCloseDevice.restype = ALCboolean
alcCloseDevice.argtypes = [POINTER(ALCdevice)]

# /usr/include/AL/alc.h:207
alcGetError = _lib.alcGetError
alcGetError.restype = ALCenum
alcGetError.argtypes = [POINTER(ALCdevice)]

# /usr/include/AL/alc.h:215
alcIsExtensionPresent = _lib.alcIsExtensionPresent
alcIsExtensionPresent.restype = ALCboolean
alcIsExtensionPresent.argtypes = [POINTER(ALCdevice), POINTER(ALCchar)]

# /usr/include/AL/alc.h:217
alcGetProcAddress = _lib.alcGetProcAddress
alcGetProcAddress.restype = POINTER(c_void)
alcGetProcAddress.argtypes = [POINTER(ALCdevice), POINTER(ALCchar)]

# /usr/include/AL/alc.h:219
alcGetEnumValue = _lib.alcGetEnumValue
alcGetEnumValue.restype = ALCenum
alcGetEnumValue.argtypes = [POINTER(ALCdevice), POINTER(ALCchar)]

# /usr/include/AL/alc.h:225
alcGetString = _lib.alcGetString
alcGetString.restype = POINTER(ALCchar)
alcGetString.argtypes = [POINTER(ALCdevice), ALCenum]

# /usr/include/AL/alc.h:227
alcGetIntegerv = _lib.alcGetIntegerv
alcGetIntegerv.restype = None
alcGetIntegerv.argtypes = [POINTER(ALCdevice), ALCenum, ALCsizei, POINTER(ALCint)]

# /usr/include/AL/alc.h:233
alcCaptureOpenDevice = _lib.alcCaptureOpenDevice
alcCaptureOpenDevice.restype = POINTER(ALCdevice)
alcCaptureOpenDevice.argtypes = [POINTER(ALCchar), ALCuint, ALCenum, ALCsizei]

# /usr/include/AL/alc.h:235
alcCaptureCloseDevice = _lib.alcCaptureCloseDevice
alcCaptureCloseDevice.restype = ALCboolean
alcCaptureCloseDevice.argtypes = [POINTER(ALCdevice)]

# /usr/include/AL/alc.h:237
alcCaptureStart = _lib.alcCaptureStart
alcCaptureStart.restype = None
alcCaptureStart.argtypes = [POINTER(ALCdevice)]

# /usr/include/AL/alc.h:239
alcCaptureStop = _lib.alcCaptureStop
alcCaptureStop.restype = None
alcCaptureStop.argtypes = [POINTER(ALCdevice)]

# /usr/include/AL/alc.h:241
alcCaptureSamples = _lib.alcCaptureSamples
alcCaptureSamples.restype = None
alcCaptureSamples.argtypes = [POINTER(ALCdevice), POINTER(ALCvoid), ALCsizei]

LPALCCREATECONTEXT = CFUNCTYPE(POINTER(ALCcontext), POINTER(ALCdevice), POINTER(ALCint)) 	# /usr/include/AL/alc.h:246
LPALCMAKECONTEXTCURRENT = CFUNCTYPE(ALCboolean, POINTER(ALCcontext)) 	# /usr/include/AL/alc.h:247
LPALCPROCESSCONTEXT = CFUNCTYPE(None, POINTER(ALCcontext)) 	# /usr/include/AL/alc.h:248
LPALCSUSPENDCONTEXT = CFUNCTYPE(None, POINTER(ALCcontext)) 	# /usr/include/AL/alc.h:249
LPALCDESTROYCONTEXT = CFUNCTYPE(None, POINTER(ALCcontext)) 	# /usr/include/AL/alc.h:250
LPALCGETCURRENTCONTEXT = CFUNCTYPE(POINTER(ALCcontext)) 	# /usr/include/AL/alc.h:251
LPALCGETCONTEXTSDEVICE = CFUNCTYPE(POINTER(ALCdevice), POINTER(ALCcontext)) 	# /usr/include/AL/alc.h:252
LPALCOPENDEVICE = CFUNCTYPE(POINTER(ALCdevice), POINTER(ALCchar)) 	# /usr/include/AL/alc.h:253
LPALCCLOSEDEVICE = CFUNCTYPE(ALCboolean, POINTER(ALCdevice)) 	# /usr/include/AL/alc.h:254
LPALCGETERROR = CFUNCTYPE(ALCenum, POINTER(ALCdevice)) 	# /usr/include/AL/alc.h:255
LPALCISEXTENSIONPRESENT = CFUNCTYPE(ALCboolean, POINTER(ALCdevice), POINTER(ALCchar)) 	# /usr/include/AL/alc.h:256
LPALCGETPROCADDRESS = CFUNCTYPE(POINTER(c_void), POINTER(ALCdevice), POINTER(ALCchar)) 	# /usr/include/AL/alc.h:257
LPALCGETENUMVALUE = CFUNCTYPE(ALCenum, POINTER(ALCdevice), POINTER(ALCchar)) 	# /usr/include/AL/alc.h:258
LPALCGETSTRING = CFUNCTYPE(POINTER(ALCchar), POINTER(ALCdevice), ALCenum) 	# /usr/include/AL/alc.h:259
LPALCGETINTEGERV = CFUNCTYPE(None, POINTER(ALCdevice), ALCenum, ALCsizei, POINTER(ALCint)) 	# /usr/include/AL/alc.h:260
LPALCCAPTUREOPENDEVICE = CFUNCTYPE(POINTER(ALCdevice), POINTER(ALCchar), ALCuint, ALCenum, ALCsizei) 	# /usr/include/AL/alc.h:261
LPALCCAPTURECLOSEDEVICE = CFUNCTYPE(ALCboolean, POINTER(ALCdevice)) 	# /usr/include/AL/alc.h:262
LPALCCAPTURESTART = CFUNCTYPE(None, POINTER(ALCdevice)) 	# /usr/include/AL/alc.h:263
LPALCCAPTURESTOP = CFUNCTYPE(None, POINTER(ALCdevice)) 	# /usr/include/AL/alc.h:264
LPALCCAPTURESAMPLES = CFUNCTYPE(None, POINTER(ALCdevice), POINTER(ALCvoid), ALCsizei) 	# /usr/include/AL/alc.h:265

__all__ = ['ALC_API', 'ALCAPI', 'ALC_INVALID', 'ALC_VERSION_0_1', 'ALCdevice',
'ALCcontext', 'ALCboolean', 'ALCchar', 'ALCbyte', 'ALCubyte', 'ALCshort',
'ALCushort', 'ALCint', 'ALCuint', 'ALCsizei', 'ALCenum', 'ALCfloat',
'ALCdouble', 'ALCvoid', 'ALC_FALSE', 'ALC_TRUE', 'ALC_FREQUENCY',
'ALC_REFRESH', 'ALC_SYNC', 'ALC_MONO_SOURCES', 'ALC_STEREO_SOURCES',
'ALC_NO_ERROR', 'ALC_INVALID_DEVICE', 'ALC_INVALID_CONTEXT',
'ALC_INVALID_ENUM', 'ALC_INVALID_VALUE', 'ALC_OUT_OF_MEMORY',
'ALC_DEFAULT_DEVICE_SPECIFIER', 'ALC_DEVICE_SPECIFIER', 'ALC_EXTENSIONS',
'ALC_MAJOR_VERSION', 'ALC_MINOR_VERSION', 'ALC_ATTRIBUTES_SIZE',
'ALC_ALL_ATTRIBUTES', 'ALC_CAPTURE_DEVICE_SPECIFIER',
'ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER', 'ALC_CAPTURE_SAMPLES',
'alcCreateContext', 'alcMakeContextCurrent', 'alcProcessContext',
'alcSuspendContext', 'alcDestroyContext', 'alcGetCurrentContext',
'alcGetContextsDevice', 'alcOpenDevice', 'alcCloseDevice', 'alcGetError',
'alcIsExtensionPresent', 'alcGetProcAddress', 'alcGetEnumValue',
'alcGetString', 'alcGetIntegerv', 'alcCaptureOpenDevice',
'alcCaptureCloseDevice', 'alcCaptureStart', 'alcCaptureStop',
'alcCaptureSamples', 'LPALCCREATECONTEXT', 'LPALCMAKECONTEXTCURRENT',
'LPALCPROCESSCONTEXT', 'LPALCSUSPENDCONTEXT', 'LPALCDESTROYCONTEXT',
'LPALCGETCURRENTCONTEXT', 'LPALCGETCONTEXTSDEVICE', 'LPALCOPENDEVICE',
'LPALCCLOSEDEVICE', 'LPALCGETERROR', 'LPALCISEXTENSIONPRESENT',
'LPALCGETPROCADDRESS', 'LPALCGETENUMVALUE', 'LPALCGETSTRING',
'LPALCGETINTEGERV', 'LPALCCAPTUREOPENDEVICE', 'LPALCCAPTURECLOSEDEVICE',
'LPALCCAPTURESTART', 'LPALCCAPTURESTOP', 'LPALCCAPTURESAMPLES']

########NEW FILE########
__FILENAME__ = lib_openal
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for openal

Generated with:
../tools/wraptypes/wrap.py /usr/include/AL/al.h -lopenal -olib_openal.py

.. Hacked to remove non-existent library functions.

TODO add alGetError check.

.. alListener3i and alListeneriv are present in my OS X 10.4 but not another
10.4 user's installation.  They've also been removed for compatibility.
'''

__docformat__ =  'restructuredtext'
__version__ = '$Id: lib_openal.py 2541 2009-12-31 04:31:11Z benjamin.coder.smith@gmail.com $'

import ctypes
from ctypes import *
import sys

import pyglet.lib

_lib = pyglet.lib.load_library('openal', win32='openal32',
        framework='/System/Library/Frameworks/OpenAL.framework')

_int_types = (c_int16, c_int32)
if hasattr(ctypes, 'c_int64'):
    # Some builds of ctypes apparently do not have c_int64
    # defined; it's a pretty good bet that these builds do not
    # have 64-bit pointers.
    _int_types += (ctypes.c_int64,)
for t in _int_types:
    if sizeof(t) == sizeof(c_size_t):
        c_ptrdiff_t = t

class c_void(Structure):
    # c_void_p is a buggy return type, converting to int, so
    # POINTER(None) == c_void_p is actually written as
    # POINTER(c_void), so it can be treated as a real pointer.
    _fields_ = [('dummy', c_int)]



AL_API = 0 	# /usr/include/AL/al.h:39
ALAPI = 0 	# /usr/include/AL/al.h:59
AL_INVALID = -1 	# /usr/include/AL/al.h:61
AL_ILLEGAL_ENUM = 0 	# /usr/include/AL/al.h:62
AL_ILLEGAL_COMMAND = 0 	# /usr/include/AL/al.h:63
ALboolean = c_int 	# Better return type than c_char, as generated
ALchar = c_char 	# /usr/include/AL/al.h:73
ALbyte = c_char 	# /usr/include/AL/al.h:76
ALubyte = c_ubyte 	# /usr/include/AL/al.h:79
ALshort = c_short 	# /usr/include/AL/al.h:82
ALushort = c_ushort 	# /usr/include/AL/al.h:85
ALint = c_int 	# /usr/include/AL/al.h:88
ALuint = c_uint 	# /usr/include/AL/al.h:91
ALsizei = c_int 	# /usr/include/AL/al.h:94
ALenum = c_int 	# /usr/include/AL/al.h:97
ALfloat = c_float 	# /usr/include/AL/al.h:100
ALdouble = c_double 	# /usr/include/AL/al.h:103
ALvoid = None 	# /usr/include/AL/al.h:106
AL_NONE = 0 	# /usr/include/AL/al.h:112
AL_FALSE = 0 	# /usr/include/AL/al.h:115
AL_TRUE = 1 	# /usr/include/AL/al.h:118
AL_SOURCE_RELATIVE = 514 	# /usr/include/AL/al.h:121
AL_CONE_INNER_ANGLE = 4097 	# /usr/include/AL/al.h:130
AL_CONE_OUTER_ANGLE = 4098 	# /usr/include/AL/al.h:137
AL_PITCH = 4099 	# /usr/include/AL/al.h:145
AL_POSITION = 4100 	# /usr/include/AL/al.h:157
AL_DIRECTION = 4101 	# /usr/include/AL/al.h:160
AL_VELOCITY = 4102 	# /usr/include/AL/al.h:163
AL_LOOPING = 4103 	# /usr/include/AL/al.h:171
AL_BUFFER = 4105 	# /usr/include/AL/al.h:178
AL_GAIN = 4106 	# /usr/include/AL/al.h:191
AL_MIN_GAIN = 4109 	# /usr/include/AL/al.h:200
AL_MAX_GAIN = 4110 	# /usr/include/AL/al.h:209
AL_ORIENTATION = 4111 	# /usr/include/AL/al.h:216
AL_SOURCE_STATE = 4112 	# /usr/include/AL/al.h:221
AL_INITIAL = 4113 	# /usr/include/AL/al.h:222
AL_PLAYING = 4114 	# /usr/include/AL/al.h:223
AL_PAUSED = 4115 	# /usr/include/AL/al.h:224
AL_STOPPED = 4116 	# /usr/include/AL/al.h:225
AL_BUFFERS_QUEUED = 4117 	# /usr/include/AL/al.h:230
AL_BUFFERS_PROCESSED = 4118 	# /usr/include/AL/al.h:231
AL_SEC_OFFSET = 4132 	# /usr/include/AL/al.h:236
AL_SAMPLE_OFFSET = 4133 	# /usr/include/AL/al.h:237
AL_BYTE_OFFSET = 4134 	# /usr/include/AL/al.h:238
AL_SOURCE_TYPE = 4135 	# /usr/include/AL/al.h:246
AL_STATIC = 4136 	# /usr/include/AL/al.h:247
AL_STREAMING = 4137 	# /usr/include/AL/al.h:248
AL_UNDETERMINED = 4144 	# /usr/include/AL/al.h:249
AL_FORMAT_MONO8 = 4352 	# /usr/include/AL/al.h:252
AL_FORMAT_MONO16 = 4353 	# /usr/include/AL/al.h:253
AL_FORMAT_STEREO8 = 4354 	# /usr/include/AL/al.h:254
AL_FORMAT_STEREO16 = 4355 	# /usr/include/AL/al.h:255
AL_REFERENCE_DISTANCE = 4128 	# /usr/include/AL/al.h:265
AL_ROLLOFF_FACTOR = 4129 	# /usr/include/AL/al.h:273
AL_CONE_OUTER_GAIN = 4130 	# /usr/include/AL/al.h:282
AL_MAX_DISTANCE = 4131 	# /usr/include/AL/al.h:292
AL_FREQUENCY = 8193 	# /usr/include/AL/al.h:300
AL_BITS = 8194 	# /usr/include/AL/al.h:301
AL_CHANNELS = 8195 	# /usr/include/AL/al.h:302
AL_SIZE = 8196 	# /usr/include/AL/al.h:303
AL_UNUSED = 8208 	# /usr/include/AL/al.h:310
AL_PENDING = 8209 	# /usr/include/AL/al.h:311
AL_PROCESSED = 8210 	# /usr/include/AL/al.h:312
AL_NO_ERROR = 0 	# /usr/include/AL/al.h:316
AL_INVALID_NAME = 40961 	# /usr/include/AL/al.h:321
AL_INVALID_ENUM = 40962 	# /usr/include/AL/al.h:326
AL_INVALID_VALUE = 40963 	# /usr/include/AL/al.h:331
AL_INVALID_OPERATION = 40964 	# /usr/include/AL/al.h:336
AL_OUT_OF_MEMORY = 40965 	# /usr/include/AL/al.h:342
AL_VENDOR = 45057 	# /usr/include/AL/al.h:346
AL_VERSION = 45058 	# /usr/include/AL/al.h:347
AL_RENDERER = 45059 	# /usr/include/AL/al.h:348
AL_EXTENSIONS = 45060 	# /usr/include/AL/al.h:349
AL_DOPPLER_FACTOR = 49152 	# /usr/include/AL/al.h:356
AL_DOPPLER_VELOCITY = 49153 	# /usr/include/AL/al.h:361
AL_SPEED_OF_SOUND = 49155 	# /usr/include/AL/al.h:366
AL_DISTANCE_MODEL = 53248 	# /usr/include/AL/al.h:375
AL_INVERSE_DISTANCE = 53249 	# /usr/include/AL/al.h:376
AL_INVERSE_DISTANCE_CLAMPED = 53250 	# /usr/include/AL/al.h:377
AL_LINEAR_DISTANCE = 53251 	# /usr/include/AL/al.h:378
AL_LINEAR_DISTANCE_CLAMPED = 53252 	# /usr/include/AL/al.h:379
AL_EXPONENT_DISTANCE = 53253 	# /usr/include/AL/al.h:380
AL_EXPONENT_DISTANCE_CLAMPED = 53254 	# /usr/include/AL/al.h:381
# /usr/include/AL/al.h:386
alEnable = _lib.alEnable
alEnable.restype = None
alEnable.argtypes = [ALenum]

# /usr/include/AL/al.h:388
alDisable = _lib.alDisable
alDisable.restype = None
alDisable.argtypes = [ALenum]

# /usr/include/AL/al.h:390
alIsEnabled = _lib.alIsEnabled
alIsEnabled.restype = ALboolean
alIsEnabled.argtypes = [ALenum]

# /usr/include/AL/al.h:396
alGetString = _lib.alGetString
alGetString.restype = POINTER(ALchar)
alGetString.argtypes = [ALenum]

# /usr/include/AL/al.h:398
alGetBooleanv = _lib.alGetBooleanv
alGetBooleanv.restype = None
alGetBooleanv.argtypes = [ALenum, POINTER(ALboolean)]

# /usr/include/AL/al.h:400
alGetIntegerv = _lib.alGetIntegerv
alGetIntegerv.restype = None
alGetIntegerv.argtypes = [ALenum, POINTER(ALint)]

# /usr/include/AL/al.h:402
alGetFloatv = _lib.alGetFloatv
alGetFloatv.restype = None
alGetFloatv.argtypes = [ALenum, POINTER(ALfloat)]

# /usr/include/AL/al.h:404
alGetDoublev = _lib.alGetDoublev
alGetDoublev.restype = None
alGetDoublev.argtypes = [ALenum, POINTER(ALdouble)]

# /usr/include/AL/al.h:406
alGetBoolean = _lib.alGetBoolean
alGetBoolean.restype = ALboolean
alGetBoolean.argtypes = [ALenum]

# /usr/include/AL/al.h:408
alGetInteger = _lib.alGetInteger
alGetInteger.restype = ALint
alGetInteger.argtypes = [ALenum]

# /usr/include/AL/al.h:410
alGetFloat = _lib.alGetFloat
alGetFloat.restype = ALfloat
alGetFloat.argtypes = [ALenum]

# /usr/include/AL/al.h:412
alGetDouble = _lib.alGetDouble
alGetDouble.restype = ALdouble
alGetDouble.argtypes = [ALenum]

# /usr/include/AL/al.h:419
alGetError = _lib.alGetError
alGetError.restype = ALenum
alGetError.argtypes = []

# /usr/include/AL/al.h:427
alIsExtensionPresent = _lib.alIsExtensionPresent
alIsExtensionPresent.restype = ALboolean
alIsExtensionPresent.argtypes = [POINTER(ALchar)]

# /usr/include/AL/al.h:429
alGetProcAddress = _lib.alGetProcAddress
alGetProcAddress.restype = POINTER(c_void)
alGetProcAddress.argtypes = [POINTER(ALchar)]

# /usr/include/AL/al.h:431
alGetEnumValue = _lib.alGetEnumValue
alGetEnumValue.restype = ALenum
alGetEnumValue.argtypes = [POINTER(ALchar)]

# /usr/include/AL/al.h:450
alListenerf = _lib.alListenerf
alListenerf.restype = None
alListenerf.argtypes = [ALenum, ALfloat]

# /usr/include/AL/al.h:452
alListener3f = _lib.alListener3f
alListener3f.restype = None
alListener3f.argtypes = [ALenum, ALfloat, ALfloat, ALfloat]

# /usr/include/AL/al.h:454
alListenerfv = _lib.alListenerfv
alListenerfv.restype = None
alListenerfv.argtypes = [ALenum, POINTER(ALfloat)]

# /usr/include/AL/al.h:456
alListeneri = _lib.alListeneri
alListeneri.restype = None
alListeneri.argtypes = [ALenum, ALint]

# /usr/include/AL/al.h:458
#alListener3i = _lib.alListener3i
#alListener3i.restype = None
#alListener3i.argtypes = [ALenum, ALint, ALint, ALint]

# /usr/include/AL/al.h:460
#alListeneriv = _lib.alListeneriv
#alListeneriv.restype = None
#alListeneriv.argtypes = [ALenum, POINTER(ALint)]

# /usr/include/AL/al.h:465
alGetListenerf = _lib.alGetListenerf
alGetListenerf.restype = None
alGetListenerf.argtypes = [ALenum, POINTER(ALfloat)]

# /usr/include/AL/al.h:467
alGetListener3f = _lib.alGetListener3f
alGetListener3f.restype = None
alGetListener3f.argtypes = [ALenum, POINTER(ALfloat), POINTER(ALfloat), POINTER(ALfloat)]

# /usr/include/AL/al.h:469
alGetListenerfv = _lib.alGetListenerfv
alGetListenerfv.restype = None
alGetListenerfv.argtypes = [ALenum, POINTER(ALfloat)]

# /usr/include/AL/al.h:471
alGetListeneri = _lib.alGetListeneri
alGetListeneri.restype = None
alGetListeneri.argtypes = [ALenum, POINTER(ALint)]

# /usr/include/AL/al.h:473
alGetListener3i = _lib.alGetListener3i
alGetListener3i.restype = None
alGetListener3i.argtypes = [ALenum, POINTER(ALint), POINTER(ALint), POINTER(ALint)]

# /usr/include/AL/al.h:475
alGetListeneriv = _lib.alGetListeneriv
alGetListeneriv.restype = None
alGetListeneriv.argtypes = [ALenum, POINTER(ALint)]

# /usr/include/AL/al.h:512
alGenSources = _lib.alGenSources
alGenSources.restype = None
alGenSources.argtypes = [ALsizei, POINTER(ALuint)]

# /usr/include/AL/al.h:515
alDeleteSources = _lib.alDeleteSources
alDeleteSources.restype = None
alDeleteSources.argtypes = [ALsizei, POINTER(ALuint)]

# /usr/include/AL/al.h:518
alIsSource = _lib.alIsSource
alIsSource.restype = ALboolean
alIsSource.argtypes = [ALuint]

# /usr/include/AL/al.h:523
alSourcef = _lib.alSourcef
alSourcef.restype = None
alSourcef.argtypes = [ALuint, ALenum, ALfloat]

# /usr/include/AL/al.h:525
alSource3f = _lib.alSource3f
alSource3f.restype = None
alSource3f.argtypes = [ALuint, ALenum, ALfloat, ALfloat, ALfloat]

# /usr/include/AL/al.h:527
alSourcefv = _lib.alSourcefv
alSourcefv.restype = None
alSourcefv.argtypes = [ALuint, ALenum, POINTER(ALfloat)]

# /usr/include/AL/al.h:529
alSourcei = _lib.alSourcei
alSourcei.restype = None
alSourcei.argtypes = [ALuint, ALenum, ALint]

# /usr/include/AL/al.h:531
#alSource3i = _lib.alSource3i
#alSource3i.restype = None
#alSource3i.argtypes = [ALuint, ALenum, ALint, ALint, ALint]

# /usr/include/AL/al.h:533
#alSourceiv = _lib.alSourceiv
#alSourceiv.restype = None
#alSourceiv.argtypes = [ALuint, ALenum, POINTER(ALint)]

# /usr/include/AL/al.h:538
alGetSourcef = _lib.alGetSourcef
alGetSourcef.restype = None
alGetSourcef.argtypes = [ALuint, ALenum, POINTER(ALfloat)]

# /usr/include/AL/al.h:540
alGetSource3f = _lib.alGetSource3f
alGetSource3f.restype = None
alGetSource3f.argtypes = [ALuint, ALenum, POINTER(ALfloat), POINTER(ALfloat), POINTER(ALfloat)]

# /usr/include/AL/al.h:542
alGetSourcefv = _lib.alGetSourcefv
alGetSourcefv.restype = None
alGetSourcefv.argtypes = [ALuint, ALenum, POINTER(ALfloat)]

# /usr/include/AL/al.h:544
alGetSourcei = _lib.alGetSourcei
alGetSourcei.restype = None
alGetSourcei.argtypes = [ALuint, ALenum, POINTER(ALint)]

# /usr/include/AL/al.h:546
#alGetSource3i = _lib.alGetSource3i
#alGetSource3i.restype = None
#alGetSource3i.argtypes = [ALuint, ALenum, POINTER(ALint), POINTER(ALint), POINTER(ALint)]

# /usr/include/AL/al.h:548
alGetSourceiv = _lib.alGetSourceiv
alGetSourceiv.restype = None
alGetSourceiv.argtypes = [ALuint, ALenum, POINTER(ALint)]

# /usr/include/AL/al.h:556
alSourcePlayv = _lib.alSourcePlayv
alSourcePlayv.restype = None
alSourcePlayv.argtypes = [ALsizei, POINTER(ALuint)]

# /usr/include/AL/al.h:559
alSourceStopv = _lib.alSourceStopv
alSourceStopv.restype = None
alSourceStopv.argtypes = [ALsizei, POINTER(ALuint)]

# /usr/include/AL/al.h:562
alSourceRewindv = _lib.alSourceRewindv
alSourceRewindv.restype = None
alSourceRewindv.argtypes = [ALsizei, POINTER(ALuint)]

# /usr/include/AL/al.h:565
alSourcePausev = _lib.alSourcePausev
alSourcePausev.restype = None
alSourcePausev.argtypes = [ALsizei, POINTER(ALuint)]

# /usr/include/AL/al.h:572
alSourcePlay = _lib.alSourcePlay
alSourcePlay.restype = None
alSourcePlay.argtypes = [ALuint]

# /usr/include/AL/al.h:575
alSourceStop = _lib.alSourceStop
alSourceStop.restype = None
alSourceStop.argtypes = [ALuint]

# /usr/include/AL/al.h:578
alSourceRewind = _lib.alSourceRewind
alSourceRewind.restype = None
alSourceRewind.argtypes = [ALuint]

# /usr/include/AL/al.h:581
alSourcePause = _lib.alSourcePause
alSourcePause.restype = None
alSourcePause.argtypes = [ALuint]

# /usr/include/AL/al.h:586
alSourceQueueBuffers = _lib.alSourceQueueBuffers
alSourceQueueBuffers.restype = None
alSourceQueueBuffers.argtypes = [ALuint, ALsizei, POINTER(ALuint)]

# /usr/include/AL/al.h:588
alSourceUnqueueBuffers = _lib.alSourceUnqueueBuffers
alSourceUnqueueBuffers.restype = None
alSourceUnqueueBuffers.argtypes = [ALuint, ALsizei, POINTER(ALuint)]

# /usr/include/AL/al.h:606
alGenBuffers = _lib.alGenBuffers
alGenBuffers.restype = None
alGenBuffers.argtypes = [ALsizei, POINTER(ALuint)]

# /usr/include/AL/al.h:609
alDeleteBuffers = _lib.alDeleteBuffers
alDeleteBuffers.restype = None
alDeleteBuffers.argtypes = [ALsizei, POINTER(ALuint)]

# /usr/include/AL/al.h:612
alIsBuffer = _lib.alIsBuffer
alIsBuffer.restype = ALboolean
alIsBuffer.argtypes = [ALuint]

# /usr/include/AL/al.h:615
alBufferData = _lib.alBufferData
alBufferData.restype = None
alBufferData.argtypes = [ALuint, ALenum, POINTER(ALvoid), ALsizei, ALsizei]

# /usr/include/AL/al.h:620
alBufferf = _lib.alBufferf
alBufferf.restype = None
alBufferf.argtypes = [ALuint, ALenum, ALfloat]

# /usr/include/AL/al.h:622
alBuffer3f = _lib.alBuffer3f
alBuffer3f.restype = None
alBuffer3f.argtypes = [ALuint, ALenum, ALfloat, ALfloat, ALfloat]

# /usr/include/AL/al.h:624
alBufferfv = _lib.alBufferfv
alBufferfv.restype = None
alBufferfv.argtypes = [ALuint, ALenum, POINTER(ALfloat)]

# /usr/include/AL/al.h:626
alBufferi = _lib.alBufferi
alBufferi.restype = None
alBufferi.argtypes = [ALuint, ALenum, ALint]

# /usr/include/AL/al.h:628
alBuffer3i = _lib.alBuffer3i
alBuffer3i.restype = None
alBuffer3i.argtypes = [ALuint, ALenum, ALint, ALint, ALint]

# /usr/include/AL/al.h:630
alBufferiv = _lib.alBufferiv
alBufferiv.restype = None
alBufferiv.argtypes = [ALuint, ALenum, POINTER(ALint)]

# /usr/include/AL/al.h:635
alGetBufferf = _lib.alGetBufferf
alGetBufferf.restype = None
alGetBufferf.argtypes = [ALuint, ALenum, POINTER(ALfloat)]

# /usr/include/AL/al.h:637
alGetBuffer3f = _lib.alGetBuffer3f
alGetBuffer3f.restype = None
alGetBuffer3f.argtypes = [ALuint, ALenum, POINTER(ALfloat), POINTER(ALfloat), POINTER(ALfloat)]

# /usr/include/AL/al.h:639
alGetBufferfv = _lib.alGetBufferfv
alGetBufferfv.restype = None
alGetBufferfv.argtypes = [ALuint, ALenum, POINTER(ALfloat)]

# /usr/include/AL/al.h:641
alGetBufferi = _lib.alGetBufferi
alGetBufferi.restype = None
alGetBufferi.argtypes = [ALuint, ALenum, POINTER(ALint)]

# /usr/include/AL/al.h:643
alGetBuffer3i = _lib.alGetBuffer3i
alGetBuffer3i.restype = None
alGetBuffer3i.argtypes = [ALuint, ALenum, POINTER(ALint), POINTER(ALint), POINTER(ALint)]

# /usr/include/AL/al.h:645
alGetBufferiv = _lib.alGetBufferiv
alGetBufferiv.restype = None
alGetBufferiv.argtypes = [ALuint, ALenum, POINTER(ALint)]

# /usr/include/AL/al.h:651
alDopplerFactor = _lib.alDopplerFactor
alDopplerFactor.restype = None
alDopplerFactor.argtypes = [ALfloat]

# /usr/include/AL/al.h:653
alDopplerVelocity = _lib.alDopplerVelocity
alDopplerVelocity.restype = None
alDopplerVelocity.argtypes = [ALfloat]

# /usr/include/AL/al.h:655
alSpeedOfSound = _lib.alSpeedOfSound
alSpeedOfSound.restype = None
alSpeedOfSound.argtypes = [ALfloat]

# /usr/include/AL/al.h:657
alDistanceModel = _lib.alDistanceModel
alDistanceModel.restype = None
alDistanceModel.argtypes = [ALenum]

LPALENABLE = CFUNCTYPE(None, ALenum) 	# /usr/include/AL/al.h:662
LPALDISABLE = CFUNCTYPE(None, ALenum) 	# /usr/include/AL/al.h:663
LPALISENABLED = CFUNCTYPE(ALboolean, ALenum) 	# /usr/include/AL/al.h:664
LPALGETSTRING = CFUNCTYPE(POINTER(ALchar), ALenum) 	# /usr/include/AL/al.h:665
LPALGETBOOLEANV = CFUNCTYPE(None, ALenum, POINTER(ALboolean)) 	# /usr/include/AL/al.h:666
LPALGETINTEGERV = CFUNCTYPE(None, ALenum, POINTER(ALint)) 	# /usr/include/AL/al.h:667
LPALGETFLOATV = CFUNCTYPE(None, ALenum, POINTER(ALfloat)) 	# /usr/include/AL/al.h:668
LPALGETDOUBLEV = CFUNCTYPE(None, ALenum, POINTER(ALdouble)) 	# /usr/include/AL/al.h:669
LPALGETBOOLEAN = CFUNCTYPE(ALboolean, ALenum) 	# /usr/include/AL/al.h:670
LPALGETINTEGER = CFUNCTYPE(ALint, ALenum) 	# /usr/include/AL/al.h:671
LPALGETFLOAT = CFUNCTYPE(ALfloat, ALenum) 	# /usr/include/AL/al.h:672
LPALGETDOUBLE = CFUNCTYPE(ALdouble, ALenum) 	# /usr/include/AL/al.h:673
LPALGETERROR = CFUNCTYPE(ALenum) 	# /usr/include/AL/al.h:674
LPALISEXTENSIONPRESENT = CFUNCTYPE(ALboolean, POINTER(ALchar)) 	# /usr/include/AL/al.h:675
LPALGETPROCADDRESS = CFUNCTYPE(POINTER(c_void), POINTER(ALchar)) 	# /usr/include/AL/al.h:676
LPALGETENUMVALUE = CFUNCTYPE(ALenum, POINTER(ALchar)) 	# /usr/include/AL/al.h:677
LPALLISTENERF = CFUNCTYPE(None, ALenum, ALfloat) 	# /usr/include/AL/al.h:678
LPALLISTENER3F = CFUNCTYPE(None, ALenum, ALfloat, ALfloat, ALfloat) 	# /usr/include/AL/al.h:679
LPALLISTENERFV = CFUNCTYPE(None, ALenum, POINTER(ALfloat)) 	# /usr/include/AL/al.h:680
LPALLISTENERI = CFUNCTYPE(None, ALenum, ALint) 	# /usr/include/AL/al.h:681
LPALLISTENER3I = CFUNCTYPE(None, ALenum, ALint, ALint, ALint) 	# /usr/include/AL/al.h:682
LPALLISTENERIV = CFUNCTYPE(None, ALenum, POINTER(ALint)) 	# /usr/include/AL/al.h:683
LPALGETLISTENERF = CFUNCTYPE(None, ALenum, POINTER(ALfloat)) 	# /usr/include/AL/al.h:684
LPALGETLISTENER3F = CFUNCTYPE(None, ALenum, POINTER(ALfloat), POINTER(ALfloat), POINTER(ALfloat)) 	# /usr/include/AL/al.h:685
LPALGETLISTENERFV = CFUNCTYPE(None, ALenum, POINTER(ALfloat)) 	# /usr/include/AL/al.h:686
LPALGETLISTENERI = CFUNCTYPE(None, ALenum, POINTER(ALint)) 	# /usr/include/AL/al.h:687
LPALGETLISTENER3I = CFUNCTYPE(None, ALenum, POINTER(ALint), POINTER(ALint), POINTER(ALint)) 	# /usr/include/AL/al.h:688
LPALGETLISTENERIV = CFUNCTYPE(None, ALenum, POINTER(ALint)) 	# /usr/include/AL/al.h:689
LPALGENSOURCES = CFUNCTYPE(None, ALsizei, POINTER(ALuint)) 	# /usr/include/AL/al.h:690
LPALDELETESOURCES = CFUNCTYPE(None, ALsizei, POINTER(ALuint)) 	# /usr/include/AL/al.h:691
LPALISSOURCE = CFUNCTYPE(ALboolean, ALuint) 	# /usr/include/AL/al.h:692
LPALSOURCEF = CFUNCTYPE(None, ALuint, ALenum, ALfloat) 	# /usr/include/AL/al.h:693
LPALSOURCE3F = CFUNCTYPE(None, ALuint, ALenum, ALfloat, ALfloat, ALfloat) 	# /usr/include/AL/al.h:694
LPALSOURCEFV = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALfloat)) 	# /usr/include/AL/al.h:695
LPALSOURCEI = CFUNCTYPE(None, ALuint, ALenum, ALint) 	# /usr/include/AL/al.h:696
LPALSOURCE3I = CFUNCTYPE(None, ALuint, ALenum, ALint, ALint, ALint) 	# /usr/include/AL/al.h:697
LPALSOURCEIV = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALint)) 	# /usr/include/AL/al.h:698
LPALGETSOURCEF = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALfloat)) 	# /usr/include/AL/al.h:699
LPALGETSOURCE3F = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALfloat), POINTER(ALfloat), POINTER(ALfloat)) 	# /usr/include/AL/al.h:700
LPALGETSOURCEFV = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALfloat)) 	# /usr/include/AL/al.h:701
LPALGETSOURCEI = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALint)) 	# /usr/include/AL/al.h:702
LPALGETSOURCE3I = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALint), POINTER(ALint), POINTER(ALint)) 	# /usr/include/AL/al.h:703
LPALGETSOURCEIV = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALint)) 	# /usr/include/AL/al.h:704
LPALSOURCEPLAYV = CFUNCTYPE(None, ALsizei, POINTER(ALuint)) 	# /usr/include/AL/al.h:705
LPALSOURCESTOPV = CFUNCTYPE(None, ALsizei, POINTER(ALuint)) 	# /usr/include/AL/al.h:706
LPALSOURCEREWINDV = CFUNCTYPE(None, ALsizei, POINTER(ALuint)) 	# /usr/include/AL/al.h:707
LPALSOURCEPAUSEV = CFUNCTYPE(None, ALsizei, POINTER(ALuint)) 	# /usr/include/AL/al.h:708
LPALSOURCEPLAY = CFUNCTYPE(None, ALuint) 	# /usr/include/AL/al.h:709
LPALSOURCESTOP = CFUNCTYPE(None, ALuint) 	# /usr/include/AL/al.h:710
LPALSOURCEREWIND = CFUNCTYPE(None, ALuint) 	# /usr/include/AL/al.h:711
LPALSOURCEPAUSE = CFUNCTYPE(None, ALuint) 	# /usr/include/AL/al.h:712
LPALSOURCEQUEUEBUFFERS = CFUNCTYPE(None, ALuint, ALsizei, POINTER(ALuint)) 	# /usr/include/AL/al.h:713
LPALSOURCEUNQUEUEBUFFERS = CFUNCTYPE(None, ALuint, ALsizei, POINTER(ALuint)) 	# /usr/include/AL/al.h:714
LPALGENBUFFERS = CFUNCTYPE(None, ALsizei, POINTER(ALuint)) 	# /usr/include/AL/al.h:715
LPALDELETEBUFFERS = CFUNCTYPE(None, ALsizei, POINTER(ALuint)) 	# /usr/include/AL/al.h:716
LPALISBUFFER = CFUNCTYPE(ALboolean, ALuint) 	# /usr/include/AL/al.h:717
LPALBUFFERDATA = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALvoid), ALsizei, ALsizei) 	# /usr/include/AL/al.h:718
LPALBUFFERF = CFUNCTYPE(None, ALuint, ALenum, ALfloat) 	# /usr/include/AL/al.h:719
LPALBUFFER3F = CFUNCTYPE(None, ALuint, ALenum, ALfloat, ALfloat, ALfloat) 	# /usr/include/AL/al.h:720
LPALBUFFERFV = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALfloat)) 	# /usr/include/AL/al.h:721
LPALBUFFERI = CFUNCTYPE(None, ALuint, ALenum, ALint) 	# /usr/include/AL/al.h:722
LPALBUFFER3I = CFUNCTYPE(None, ALuint, ALenum, ALint, ALint, ALint) 	# /usr/include/AL/al.h:723
LPALBUFFERIV = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALint)) 	# /usr/include/AL/al.h:724
LPALGETBUFFERF = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALfloat)) 	# /usr/include/AL/al.h:725
LPALGETBUFFER3F = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALfloat), POINTER(ALfloat), POINTER(ALfloat)) 	# /usr/include/AL/al.h:726
LPALGETBUFFERFV = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALfloat)) 	# /usr/include/AL/al.h:727
LPALGETBUFFERI = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALint)) 	# /usr/include/AL/al.h:728
LPALGETBUFFER3I = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALint), POINTER(ALint), POINTER(ALint)) 	# /usr/include/AL/al.h:729
LPALGETBUFFERIV = CFUNCTYPE(None, ALuint, ALenum, POINTER(ALint)) 	# /usr/include/AL/al.h:730
LPALDOPPLERFACTOR = CFUNCTYPE(None, ALfloat) 	# /usr/include/AL/al.h:731
LPALDOPPLERVELOCITY = CFUNCTYPE(None, ALfloat) 	# /usr/include/AL/al.h:732
LPALSPEEDOFSOUND = CFUNCTYPE(None, ALfloat) 	# /usr/include/AL/al.h:733
LPALDISTANCEMODEL = CFUNCTYPE(None, ALenum) 	# /usr/include/AL/al.h:734

__all__ = ['AL_API', 'ALAPI', 'AL_INVALID', 'AL_ILLEGAL_ENUM',
'AL_ILLEGAL_COMMAND', 'ALboolean', 'ALchar', 'ALbyte', 'ALubyte', 'ALshort',
'ALushort', 'ALint', 'ALuint', 'ALsizei', 'ALenum', 'ALfloat', 'ALdouble',
'ALvoid', 'AL_NONE', 'AL_FALSE', 'AL_TRUE', 'AL_SOURCE_RELATIVE',
'AL_CONE_INNER_ANGLE', 'AL_CONE_OUTER_ANGLE', 'AL_PITCH', 'AL_POSITION',
'AL_DIRECTION', 'AL_VELOCITY', 'AL_LOOPING', 'AL_BUFFER', 'AL_GAIN',
'AL_MIN_GAIN', 'AL_MAX_GAIN', 'AL_ORIENTATION', 'AL_SOURCE_STATE',
'AL_INITIAL', 'AL_PLAYING', 'AL_PAUSED', 'AL_STOPPED', 'AL_BUFFERS_QUEUED',
'AL_BUFFERS_PROCESSED', 'AL_SEC_OFFSET', 'AL_SAMPLE_OFFSET', 'AL_BYTE_OFFSET',
'AL_SOURCE_TYPE', 'AL_STATIC', 'AL_STREAMING', 'AL_UNDETERMINED',
'AL_FORMAT_MONO8', 'AL_FORMAT_MONO16', 'AL_FORMAT_STEREO8',
'AL_FORMAT_STEREO16', 'AL_REFERENCE_DISTANCE', 'AL_ROLLOFF_FACTOR',
'AL_CONE_OUTER_GAIN', 'AL_MAX_DISTANCE', 'AL_FREQUENCY', 'AL_BITS',
'AL_CHANNELS', 'AL_SIZE', 'AL_UNUSED', 'AL_PENDING', 'AL_PROCESSED',
'AL_NO_ERROR', 'AL_INVALID_NAME', 'AL_INVALID_ENUM', 'AL_INVALID_VALUE',
'AL_INVALID_OPERATION', 'AL_OUT_OF_MEMORY', 'AL_VENDOR', 'AL_VERSION',
'AL_RENDERER', 'AL_EXTENSIONS', 'AL_DOPPLER_FACTOR', 'AL_DOPPLER_VELOCITY',
'AL_SPEED_OF_SOUND', 'AL_DISTANCE_MODEL', 'AL_INVERSE_DISTANCE',
'AL_INVERSE_DISTANCE_CLAMPED', 'AL_LINEAR_DISTANCE',
'AL_LINEAR_DISTANCE_CLAMPED', 'AL_EXPONENT_DISTANCE',
'AL_EXPONENT_DISTANCE_CLAMPED', 'alEnable', 'alDisable', 'alIsEnabled',
'alGetString', 'alGetBooleanv', 'alGetIntegerv', 'alGetFloatv',
'alGetDoublev', 'alGetBoolean', 'alGetInteger', 'alGetFloat', 'alGetDouble',
'alGetError', 'alIsExtensionPresent', 'alGetProcAddress', 'alGetEnumValue',
'alListenerf', 'alListener3f', 'alListenerfv', 'alListeneri', 'alListener3i',
'alListeneriv', 'alGetListenerf', 'alGetListener3f', 'alGetListenerfv',
'alGetListeneri', 'alGetListener3i', 'alGetListeneriv', 'alGenSources',
'alDeleteSources', 'alIsSource', 'alSourcef', 'alSource3f', 'alSourcefv',
'alSourcei', 'alSource3i', 'alSourceiv', 'alGetSourcef', 'alGetSource3f',
'alGetSourcefv', 'alGetSourcei', 'alGetSource3i', 'alGetSourceiv',
'alSourcePlayv', 'alSourceStopv', 'alSourceRewindv', 'alSourcePausev',
'alSourcePlay', 'alSourceStop', 'alSourceRewind', 'alSourcePause',
'alSourceQueueBuffers', 'alSourceUnqueueBuffers', 'alGenBuffers',
'alDeleteBuffers', 'alIsBuffer', 'alBufferData', 'alBufferf', 'alBuffer3f',
'alBufferfv', 'alBufferi', 'alBuffer3i', 'alBufferiv', 'alGetBufferf',
'alGetBuffer3f', 'alGetBufferfv', 'alGetBufferi', 'alGetBuffer3i',
'alGetBufferiv', 'alDopplerFactor', 'alDopplerVelocity', 'alSpeedOfSound',
'alDistanceModel', 'LPALENABLE', 'LPALDISABLE', 'LPALISENABLED',
'LPALGETSTRING', 'LPALGETBOOLEANV', 'LPALGETINTEGERV', 'LPALGETFLOATV',
'LPALGETDOUBLEV', 'LPALGETBOOLEAN', 'LPALGETINTEGER', 'LPALGETFLOAT',
'LPALGETDOUBLE', 'LPALGETERROR', 'LPALISEXTENSIONPRESENT',
'LPALGETPROCADDRESS', 'LPALGETENUMVALUE', 'LPALLISTENERF', 'LPALLISTENER3F',
'LPALLISTENERFV', 'LPALLISTENERI', 'LPALLISTENER3I', 'LPALLISTENERIV',
'LPALGETLISTENERF', 'LPALGETLISTENER3F', 'LPALGETLISTENERFV',
'LPALGETLISTENERI', 'LPALGETLISTENER3I', 'LPALGETLISTENERIV',
'LPALGENSOURCES', 'LPALDELETESOURCES', 'LPALISSOURCE', 'LPALSOURCEF',
'LPALSOURCE3F', 'LPALSOURCEFV', 'LPALSOURCEI', 'LPALSOURCE3I', 'LPALSOURCEIV',
'LPALGETSOURCEF', 'LPALGETSOURCE3F', 'LPALGETSOURCEFV', 'LPALGETSOURCEI',
'LPALGETSOURCE3I', 'LPALGETSOURCEIV', 'LPALSOURCEPLAYV', 'LPALSOURCESTOPV',
'LPALSOURCEREWINDV', 'LPALSOURCEPAUSEV', 'LPALSOURCEPLAY', 'LPALSOURCESTOP',
'LPALSOURCEREWIND', 'LPALSOURCEPAUSE', 'LPALSOURCEQUEUEBUFFERS',
'LPALSOURCEUNQUEUEBUFFERS', 'LPALGENBUFFERS', 'LPALDELETEBUFFERS',
'LPALISBUFFER', 'LPALBUFFERDATA', 'LPALBUFFERF', 'LPALBUFFER3F',
'LPALBUFFERFV', 'LPALBUFFERI', 'LPALBUFFER3I', 'LPALBUFFERIV',
'LPALGETBUFFERF', 'LPALGETBUFFER3F', 'LPALGETBUFFERFV', 'LPALGETBUFFERI',
'LPALGETBUFFER3I', 'LPALGETBUFFERIV', 'LPALDOPPLERFACTOR',
'LPALDOPPLERVELOCITY', 'LPALSPEEDOFSOUND', 'LPALDISTANCEMODEL']

########NEW FILE########
__FILENAME__ = silent
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Fallback driver producing no audio.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: silent.py 1680 2008-01-27 09:13:50Z Alex.Holkner $'

import time

from pyglet.media import AudioPlayer, Listener, AudioData
from pyglet.media import MediaException

class SilentAudioPlayer(AudioPlayer):
    UPDATE_PERIOD = 0.1

    def __init__(self, audio_format):
        super(SilentAudioPlayer, self).__init__(audio_format)

        self._playing = False
        self._eos_count = 0

        self._audio_data_list = []
        self._head_time = 0.0
        self._head_timestamp = 0.0
        self._head_system_time = time.time()

    def get_write_size(self):
        bytes = int(self.audio_format.bytes_per_second * self.UPDATE_PERIOD)
        return max(0, bytes - sum(
            [a.length for a in self._audio_data_list if a is not None]))

    def write(self, audio_data):
        if not self._audio_data_list:
            self._head_time = 0.0
            self._head_timestamp = audio_data.timestamp
            self._head_system_time = time.time()
        self._audio_data_list.append(
            AudioData(None,
                      audio_data.length,
                      audio_data.timestamp,
                      audio_data.duration))
        audio_data.consume(audio_data.length, self.audio_format)

    def write_eos(self):
        if self._audio_data_list:
            self._audio_data_list.append(None)

    def write_end(self):
        pass

    def play(self):
        self._playing = True
        self._head_system_time = time.time()

    def stop(self):
        self._playing = False
        self._head_time = time.time() - self._head_system_time

    def clear(self):
        self._audio_data_list = []
        self._head_time = 0.0
        self._head_system_time = time.time()
        self._eos_count = 0

    def pump(self):
        if not self._playing:
            return
        system_time = time.time()
        head_time = system_time - self._head_system_time
        try:
            while head_time >= self._audio_data_list[0].duration:
                head_time -= self._audio_data_list[0].duration
                self._audio_data_list.pop(0)
                while self._audio_data_list[0] is None:
                    self._eos_count += 1
                    self._audio_data_list.pop(0)
            self._head_timestamp = self._audio_data_list[0].timestamp
            self._head_system_time = system_time - head_time
        except IndexError:
            pass

    def get_time(self):
        if not self._audio_data_list:
            return time.time() - self._head_system_time + self._head_timestamp

        if self._playing:
            system_time = time.time()
            head_time = system_time - self._head_system_time
            return head_time + self._audio_data_list[0].timestamp
        else:
            return self._audio_data_list[0].timestamp + self._head_time

    def clear_eos(self):
        if self._eos_count:
            self._eos_count -= 1
            return True
        return False

class SilentListener(Listener):
    def _set_volume(self, volume):
        self._volume = volume

    def _set_position(self, position):
        self._position = position

    def _set_velocity(self, velocity):
        self._velocity = velocity

    def _set_forward_orientation(self, orientation):
        self._forward_orientation = orientation

    def _set_up_orientation(self, orientation):
        self._up_orientation = orientation

    def _set_doppler_factor(self, factor):
        self._doppler_factor = factor

    def _set_speed_of_sound(self, speed_of_sound):
        self._speed_of_sound = speed_of_sound

def driver_init():
    pass

driver_listener = SilentListener()
driver_audio_player_class = SilentAudioPlayer

########NEW FILE########
__FILENAME__ = procedural
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
# $Id:$

from pyglet.media import Source, AudioFormat, AudioData

import ctypes
import os
import math

class ProceduralSource(Source):
    def __init__(self, duration, sample_rate=44800, sample_size=16):
        self._duration = float(duration)
        self.audio_format = AudioFormat(
            channels=1,
            sample_size=sample_size,
            sample_rate=sample_rate)

        self._offset = 0
        self._bytes_per_sample = sample_size >> 3
        self._bytes_per_second = self._bytes_per_sample * sample_rate
        self._max_offset = int(self._bytes_per_second * self._duration)

        if self._bytes_per_sample == 2:
            self._max_offset &= 0xfffffffe

    def _get_audio_data(self, bytes):
        bytes = min(bytes, self._max_offset - self._offset)
        if bytes <= 0:
            return None

        timestamp = float(self._offset) / self._bytes_per_second
        duration = float(bytes) / self._bytes_per_second
        data = self._generate_data(bytes, self._offset)
        self._offset += bytes
        is_eos = self._offset >= self._max_offset

        return AudioData(data,
                         bytes,
                         timestamp,
                         duration)

    def _generate_data(self, bytes, offset):
        '''Generate `bytes` bytes of data.

        Return data as ctypes array or string.
        '''
        raise NotImplementedError('abstract')

    def _seek(self, timestamp):
        self._offset = int(timestamp * self._bytes_per_second)

        # Bound within duration
        self._offset = min(max(self._offset, 0), self._max_offset)

        # Align to sample
        if self._bytes_per_sample == 2:
            self._offset &= 0xfffffffe

class Silence(ProceduralSource):
    def _generate_data(self, bytes, offset):
        if self._bytes_per_sample == 1:
            return '\127' * bytes
        else:
            return '\0' * bytes

class WhiteNoise(ProceduralSource):
    def _generate_data(self, bytes, offset):
        return os.urandom(bytes)

class Sine(ProceduralSource):
    def __init__(self, duration, frequency=440, **kwargs):
        super(Sine, self).__init__(duration, **kwargs)
        self.frequency = frequency

    def _generate_data(self, bytes, offset):
        if self._bytes_per_sample == 1:
            start = offset
            samples = bytes
            bias = 127
            amplitude = 127
            data = (ctypes.c_ubyte * samples)()
        else:
            start = offset >> 1
            samples = bytes >> 1
            bias = 0
            amplitude = 32767
            data = (ctypes.c_short * samples)()
        step = self.frequency * (math.pi * 2) / self.audio_format.sample_rate
        for i in range(samples):
            data[i] = int(math.sin(step * (i + start)) * amplitude + bias)
        return data

class Saw(ProceduralSource):
    def __init__(self, duration, frequency=440, **kwargs):
        super(Saw, self).__init__(duration, **kwargs)
        self.frequency = frequency

    def _generate_data(self, bytes, offset):
        # XXX TODO consider offset
        if self._bytes_per_sample == 1:
            samples = bytes
            value = 127
            max = 255
            min = 0
            data = (ctypes.c_ubyte * samples)()
        else:
            samples = bytes >> 1
            value = 0
            max = 32767
            min = -32768
            data = (ctypes.c_short * samples)()
        step = (max - min) * 2 * self.frequency / self.audio_format.sample_rate
        for i in range(samples):
            value += step
            if value > max:
                value = max - (value - max)
                step = -step
            if value < min:
                value = min - (value - min)
                step = -step
            data[i] = value
        return data

class Square(ProceduralSource):
    def __init__(self, duration, frequency=440, **kwargs):
        super(Square, self).__init__(duration, **kwargs)
        self.frequency = frequency

    def _generate_data(self, bytes, offset):
        # XXX TODO consider offset
        if self._bytes_per_sample == 1:
            samples = bytes
            value = 0
            amplitude = 255
            data = (ctypes.c_ubyte * samples)()
        else:
            samples = bytes >> 1
            value = -32768
            amplitude = 65535
            data = (ctypes.c_short * samples)()
        period = self.audio_format.sample_rate / self.frequency / 2
        count = 0
        for i in range(samples):
            count += 1
            if count == period:
                value = amplitude - value
                count = 0
            data[i] = value
        return data

########NEW FILE########
__FILENAME__ = riff
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Simple Python-only RIFF reader, supports uncompressed WAV files.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: riff.py 2005 2008-04-13 01:03:03Z Alex.Holkner $'

# RIFF reference:
# http://www.saettler.com/RIFFMCI/riffmci.html
#
# More readable WAVE summaries:
#
# http://www.borg.com/~jglatt/tech/wave.htm
# http://www.sonicspot.com/guide/wavefiles.html

from pyglet.media import StreamingSource, AudioData, AudioFormat
from pyglet.media import MediaFormatException

import ctypes
import struct
import StringIO

WAVE_FORMAT_PCM = 0x0001
IBM_FORMAT_MULAW = 0x0101
IBM_FORMAT_ALAW = 0x0102
IBM_FORMAT_ADPCM = 0x0103

class RIFFFormatException(MediaFormatException):
    pass

class WAVEFormatException(RIFFFormatException):
    pass

class RIFFChunk(object):
    header_fmt = '<4sL'
    header_length = struct.calcsize(header_fmt)

    def __init__(self, file, name, length, offset):
        self.file = file
        self.name = name
        self.length = length
        self.offset = offset

    def get_data(self):
        self.file.seek(self.offset)
        return self.file.read(self.length)

    def __repr__(self):
        return '%s(%r, offset=%r, length=%r)' % (
            self.__class__.__name__,
            self.name,
            self.offset,
            self.length)

class RIFFForm(object):
    _chunks = None

    def __init__(self, file, offset):
        self.file = file
        self.offset = offset

    def get_chunks(self):
        if self._chunks:
            return self._chunks

        self._chunks = []
        self.file.seek(self.offset)
        offset = self.offset
        while True:
            header = self.file.read(RIFFChunk.header_length)
            if not header:
                break
            name, length = struct.unpack(RIFFChunk.header_fmt, header)
            offset += RIFFChunk.header_length

            cls = self._chunk_types.get(name, RIFFChunk)
            chunk = cls(self.file, name, length, offset)
            self._chunks.append(chunk)

            offset += length
            if offset & 0x3 != 0:
                offset = (offset | 0x3) + 1
            self.file.seek(offset)
        return self._chunks

    def __repr__(self):
        return '%s(offset=%r)' % (self.__class__.__name__, self.offset)

class RIFFType(RIFFChunk):
    def __init__(self, *args, **kwargs):
        super(RIFFType, self).__init__(*args, **kwargs)

        self.file.seek(self.offset)
        form = self.file.read(4)
        if form != 'WAVE':
            raise RIFFFormatException('Unsupported RIFF form "%s"' % form)

        self.form = WaveForm(self.file, self.offset + 4)

class RIFFFile(RIFFForm):
    _chunk_types = {
        'RIFF': RIFFType,
    }

    def __init__(self, file):
        if not hasattr(file, 'seek'):
            file = StringIO.StringIO(file.read())

        super(RIFFFile, self).__init__(file, 0)

    def get_wave_form(self):
        chunks = self.get_chunks()
        if len(chunks) == 1 and isinstance(chunks[0], RIFFType):
            return chunks[0].form

class WaveFormatChunk(RIFFChunk):
    def __init__(self, *args, **kwargs):
        super(WaveFormatChunk, self).__init__(*args, **kwargs)

        fmt = '<HHLLHH'
        if struct.calcsize(fmt) != self.length:
            raise RIFFFormatException('Size of format chunk is incorrect.')

        (self.wFormatTag,
         self.wChannels,
         self.dwSamplesPerSec,
         self.dwAvgBytesPerSec,
         self.wBlockAlign,
         self.wBitsPerSample) = struct.unpack(fmt, self.get_data())

class WaveDataChunk(RIFFChunk):
    pass

class WaveForm(RIFFForm):
    _chunk_types = {
        'fmt ': WaveFormatChunk,
        'data': WaveDataChunk
    }

    def get_format_chunk(self):
        for chunk in self.get_chunks():
            if isinstance(chunk, WaveFormatChunk):
                return chunk

    def get_data_chunk(self):
        for chunk in self.get_chunks():
            if isinstance(chunk, WaveDataChunk):
                return chunk

class WaveSource(StreamingSource):
    def __init__(self, filename, file=None):
        if file is None:
            file = open(filename, 'rb')

        self._file = file

        # Read RIFF format, get format and data chunks
        riff = RIFFFile(file)
        wave_form = riff.get_wave_form()
        if wave_form:
            format = wave_form.get_format_chunk()
            data_chunk = wave_form.get_data_chunk()

        if not wave_form or not format or not data_chunk:
            if not filename or filename.lower().endswith('.wav'):
                raise WAVEFormatException('Not a WAVE file')
            else:
                raise WAVEFormatException(
                    'AVbin is required to decode compressed media')

        if format.wFormatTag != WAVE_FORMAT_PCM:
            raise WAVEFormatException('Unsupported WAVE format category')

        if format.wBitsPerSample not in (8, 16):
            raise WAVEFormatException('Unsupported sample bit size: %d' %
                format.wBitsPerSample)

        self.audio_format = AudioFormat(
            channels=format.wChannels,
            sample_size=format.wBitsPerSample,
            sample_rate=format.dwSamplesPerSec)
        self._duration = \
            float(data_chunk.length) / self.audio_format.bytes_per_second

        self._start_offset = data_chunk.offset
        self._max_offset = data_chunk.length
        self._offset = 0
        self._file.seek(self._start_offset)

    def _get_audio_data(self, bytes):
        bytes = min(bytes, self._max_offset - self._offset)
        if not bytes:
            return None

        data = self._file.read(bytes)
        self._offset += len(data)

        timestamp = float(self._offset) / self.audio_format.bytes_per_second
        duration = float(bytes) / self.audio_format.bytes_per_second

        return AudioData(data, len(data), timestamp, duration)

    def seek(self, timestamp):
        offset = int(timestamp * self.audio_format.bytes_per_second)

        # Bound within duration
        offset = min(max(offset, 0), self._max_offset)

        # Align to sample
        if self.audio_format.bytes_per_sample == 2:
            offset &= 0xfffffffe
        elif self.audio_format.bytes_per_sample == 4:
            offset &= 0xfffffffc

        self._file.seek(offset + self._start_offset)
        self._offset = offset

########NEW FILE########
__FILENAME__ = resource
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Load application resources from a known path.

Loading resources by specifying relative paths to filenames is often
problematic in Python, as the working directory is not necessarily the same
directory as the application's script files.

This module allows applications to specify a search path for resources.
Relative paths are taken to be relative to the application's __main__ module.
ZIP files can appear on the path; they will be searched inside.  The resource
module also behaves as expected when applications are bundled using py2exe or
py2app.

As well as providing file references (with the `file` function), the resource
module also contains convenience functions for loading images, textures,
fonts, media and documents.

3rd party modules or packages not bound to a specific application should
construct their own `Loader` instance and override the path to use the
resources in the module's directory.

Path format
^^^^^^^^^^^

The resource path `path` (see also `Loader.__init__` and `Loader.path`)
is a list of locations to search for resources.  Locations are searched in the
order given in the path.  If a location is not valid (for example, if the
directory does not exist), it is skipped.

Locations in the path beginning with an ampersand (''@'' symbol) specify
Python packages.  Other locations specify a ZIP archive or directory on the
filesystem.  Locations that are not absolute are assumed to be relative to the
script home.  Some examples::

    # Search just the `res` directory, assumed to be located alongside the
    # main script file.
    path = ['res']

    # Search the directory containing the module `levels.level1`, followed
    # by the `res/images` directory.
    path = ['@levels.level1', 'res/images']

Paths are always case-sensitive and forward slashes are always used as path
separators, even in cases when the filesystem or platform does not do this.
This avoids a common programmer error when porting applications between
platforms.

The default path is ``['.']``.  If you modify the path, you must call
`reindex`.

:since: pyglet 1.1
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import os
import weakref
import sys
import zipfile
import StringIO

import pyglet

class ResourceNotFoundException(Exception):
    '''The named resource was not found on the search path.'''
    def __init__(self, name):
        message = ('Resource "%s" was not found on the path.  '
            'Ensure that the filename has the correct captialisation.') % name
        Exception.__init__(self, message)

def get_script_home():
    '''Get the directory containing the program entry module.

    For ordinary Python scripts, this is the directory containing the
    ``__main__`` module.  For executables created with py2exe the result is
    the directory containing the running executable file.  For OS X bundles
    created using Py2App the result is the Resources directory within the
    running bundle.

    If none of the above cases apply and the file for ``__main__`` cannot
    be determined the working directory is returned.

    :rtype: str
    '''

    frozen = getattr(sys, 'frozen', None)
    if frozen in ('windows_exe', 'console_exe'):
        return os.path.dirname(sys.executable)
    elif frozen == 'macosx_app':
        return os.environ['RESOURCEPATH']
    else:
        main = sys.modules['__main__']
        if hasattr(main, '__file__'):
            return os.path.dirname(main.__file__)

    # Probably interactive
    return ''

def get_settings_path(name):
    '''Get a directory to save user preferences.

    Different platforms have different conventions for where to save user
    preferences, saved games, and settings.  This function implements those
    conventions.  Note that the returned path may not exist: applications
    should use ``os.makedirs`` to construct it if desired.

    On Linux, a hidden directory `name` in the user's home directory is
    returned.

    On Windows (including under Cygwin) the `name` directory in the user's
    ``Application Settings`` directory is returned.

    On Mac OS X the `name` directory under ``~/Library/Application Support``
    is returned.

    :Parameters:
        `name` : str
            The name of the application.

    :rtype: str
    '''
    if sys.platform in ('cygwin', 'win32'):
        if 'APPDATA' in os.environ:
            return os.path.join(os.environ['APPDATA'], name)
        else:
            return os.path.expanduser('~/%s' % name)
    elif sys.platform == 'darwin':
        return os.path.expanduser('~/Library/Application Support/%s' % name)
    else:
        return os.path.expanduser('~/.%s' % name)

class Location(object):
    '''Abstract resource location.

    Given a location, a file can be loaded from that location with the `open`
    method.  This provides a convenient way to specify a path to load files
    from, and not necessarily have that path reside on the filesystem.
    '''
    def open(self, filename, mode='rb'):
        '''Open a file at this location.

        :Parameters:
            `filename` : str
                The filename to open.  Absolute paths are not supported.
                Relative paths are not supported by most locations (you
                should specify only a filename with no path component).
            `mode` : str
                The file mode to open with.  Only files opened on the
                filesystem make use of this parameter; others ignore it.

        :rtype: file object
        '''
        raise NotImplementedError('abstract')

class FileLocation(Location):
    '''Location on the filesystem.
    '''
    def __init__(self, path):
        '''Create a location given a relative or absolute path.

        :Parameters:
            `path` : str
                Path on the filesystem.
        '''
        self.path = path

    def open(self, filename, mode='rb'):
        return open(os.path.join(self.path, filename), mode)

class ZIPLocation(Location):
    '''Location within a ZIP file.
    '''
    def __init__(self, zip, dir):
        '''Create a location given an open ZIP file and a path within that
        file.

        :Parameters:
            `zip` : ``zipfile.ZipFile``
                An open ZIP file from the ``zipfile`` module.
            `dir` : str
                A path within that ZIP file.  Can be empty to specify files at
                the top level of the ZIP file.

        '''
        self.zip = zip
        self.dir = dir

    def open(self, filename, mode='rb'):
        if self.dir:
            path = self.dir + '/' + filename
        else:
            path = filename
        text = self.zip.read(path)
        return StringIO.StringIO(text)

class URLLocation(Location):
    '''Location on the network.

    This class uses the ``urlparse`` and ``urllib2`` modules to open files on
    the network given a URL.
    '''
    def __init__(self, base_url):
        '''Create a location given a base URL.

        :Parameters:
            `base_url` : str
                URL string to prepend to filenames.

        '''
        self.base = base_url

    def open(self, filename, mode='rb'):
        import urlparse
        import urllib2
        url = urlparse.urljoin(self.base, filename)
        return urllib2.urlopen(url)

class Loader(object):
    '''Load program resource files from disk.

    The loader contains a search path which can include filesystem
    directories, ZIP archives and Python packages.

    :Ivariables:
        `path` : list of str
            List of search locations.  After modifying the path you must
            call the `reindex` method.
        `script_home` : str
            Base resource location, defaulting to the location of the
            application script.

    '''
    def __init__(self, path=None, script_home=None):
        '''Create a loader for the given path.

        If no path is specified it defaults to ``['.']``; that is, just the
        program directory.

        See the module documentation for details on the path format.

        :Parameters:
            `path` : list of str
                List of locations to search for resources.
            `script_home` : str
                Base location of relative files.  Defaults to the result of
                `get_script_home`.

        '''
        if path is None:
            path = ['.']
        if type(path) in (str, unicode):
            path = [path]
        self.path = list(path)
        if script_home is None:
            script_home = get_script_home()
        self._script_home = script_home
        self.reindex()

        # Map name to image
        self._cached_textures = weakref.WeakValueDictionary()
        self._cached_images = weakref.WeakValueDictionary()
        self._cached_animations = weakref.WeakValueDictionary()

        # Map bin size to list of atlases
        self._texture_atlas_bins = {}

    def reindex(self):
        '''Refresh the file index.

        You must call this method if `path` is changed or the filesystem
        layout changes.
        '''
        self._index = {}
        for path in self.path:
            if path.startswith('@'):
                # Module
                name = path[1:]

                try:
                    module = __import__(name)
                except:
                    continue

                for component in name.split('.')[1:]:
                    module = getattr(module, component)

                if hasattr(module, '__file__'):
                    path = os.path.dirname(module.__file__)
                else:
                    path = '' # interactive
            elif not os.path.isabs(path):
                # Add script base unless absolute
                assert '\\' not in path, \
                    'Backslashes not permitted in relative path'
                path = os.path.join(self._script_home, path)

            if os.path.isdir(path):
                # Filesystem directory
                path = path.rstrip(os.path.sep)
                location = FileLocation(path)
                for dirpath, dirnames, filenames in os.walk(path):
                    dirpath = dirpath[len(path) + 1:]
                    # Force forward slashes for index
                    if dirpath:
                        parts = filter(None, dirpath.split(os.sep))
                        dirpath = '/'.join(parts)
                    for filename in filenames:
                        if dirpath:
                            index_name = dirpath + '/' + filename
                        else:
                            index_name = filename
                        self._index_file(index_name, location)
            else:
                # Find path component that is the ZIP file.
                dir = ''
                old_path = None
                while path and not os.path.isfile(path):
                    old_path = path
                    path, tail_dir = os.path.split(path)
                    if path == old_path:
                        break
                    dir = '/'.join((tail_dir, dir))
                if path == old_path:
                    continue
                dir = dir.rstrip('/')

                # path is a ZIP file, dir resides within ZIP
                if path and zipfile.is_zipfile(path):
                    zip = zipfile.ZipFile(path, 'r')
                    location = ZIPLocation(zip, dir)
                    for zip_name in zip.namelist():
                        #zip_name_dir, zip_name = os.path.split(zip_name)
                        #assert '\\' not in name_dir
                        #assert not name_dir.endswith('/')
                        if zip_name.startswith(dir):
                            if dir:
                                zip_name = zip_name[len(dir)+1:]
                            self._index_file(zip_name, location)

    def _index_file(self, name, location):
        if name not in self._index:
            self._index[name] = location

    def file(self, name, mode='rb'):
        '''Load a resource.

        :Parameters:
            `name` : str
                Filename of the resource to load.
            `mode` : str
                Combination of ``r``, ``w``, ``a``, ``b`` and ``t`` characters
                with the meaning as for the builtin ``open`` function.

        :rtype: file object
        '''
        try:
            location = self._index[name]
            return location.open(name, mode)
        except KeyError:
            raise ResourceNotFoundException(name)

    def location(self, name):
        '''Get the location of a resource.

        This method is useful for opening files referenced from a resource.
        For example, an HTML file loaded as a resource might reference some
        images.  These images should be located relative to the HTML file, not
        looked up individually in the loader's path.

        :Parameters:
            `name` : str
                Filename of the resource to locate.

        :rtype: `Location`
        '''
        try:
            return self._index[name]
        except KeyError:
            raise ResourceNotFoundException(name)

    def add_font(self, name):
        '''Add a font resource to the application.

        Fonts not installed on the system must be added to pyglet before they
        can be used with `font.load`.  Although the font is added with
        its filename using this function, it is loaded by specifying its
        family name.  For example::

            resource.add_font('action_man.ttf')
            action_man = font.load('Action Man')

        :Parameters:
            `name` : str
                Filename of the font resource to add.

        '''
        from pyglet import font
        file = self.file(name)
        font.add_file(file)

    def _alloc_image(self, name):
        file = self.file(name)
        img = pyglet.image.load(name, file=file)
        bin = self._get_texture_atlas_bin(img.width, img.height)
        if bin is None:
            return img.get_texture(True)

        return bin.add(img)

    def _get_texture_atlas_bin(self, width, height):
        '''A heuristic for determining the atlas bin to use for a given image
        size.  Returns None if the image should not be placed in an atlas (too
        big), otherwise the bin (a list of TextureAtlas).
        '''
        # Large images are not placed in an atlas
        if width > 128 or height > 128:
            return None

        # Group images with small height separately to larger height (as the
        # allocator can't stack within a single row).
        bin_size = 1
        if height > 32:
            bin_size = 2

        try:
            bin = self._texture_atlas_bins[bin_size]
        except KeyError:
            bin = self._texture_atlas_bins[bin_size] = \
                pyglet.image.atlas.TextureBin()

        return bin

    def image(self, name, flip_x=False, flip_y=False, rotate=0):
        '''Load an image with optional transformation.

        This is similar to `texture`, except the resulting image will be
        packed into a `TextureBin` if it is an appropriate size for packing.
        This is more efficient than loading images into separate textures.

        :Parameters:
            `name` : str
                Filename of the image source to load.
            `flip_x` : bool
                If True, the returned image will be flipped horizontally.
            `flip_y` : bool
                If True, the returned image will be flipped vertically.
            `rotate` : int
                The returned image will be rotated clockwise by the given
                number of degrees (a multiple of 90).

        :rtype: `Texture`
        :return: A complete texture if the image is large, otherwise a
            `TextureRegion` of a texture atlas.
        '''
        if name in self._cached_images:
            identity = self._cached_images[name]
        else:
            identity = self._cached_images[name] = self._alloc_image(name)

        if not rotate and not flip_x and not flip_y:
            return identity

        return identity.get_transform(flip_x, flip_y, rotate)

    def animation(self, name, flip_x=False, flip_y=False, rotate=0):
        '''Load an animation with optional transformation.

        Animations loaded from the same source but with different
        transformations will use the same textures.

        :Parameters:
            `name` : str
                Filename of the animation source to load.
            `flip_x` : bool
                If True, the returned image will be flipped horizontally.
            `flip_y` : bool
                If True, the returned image will be flipped vertically.
            `rotate` : int
                The returned image will be rotated clockwise by the given
                number of degrees (a multiple of 90).

        :rtype: `Animation`
        '''
        try:
            identity = self._cached_animations[name]
        except KeyError:
            animation = pyglet.image.load_animation(name, self.file(name))
            bin = self._get_texture_atlas_bin(animation.get_max_width(),
                                              animation.get_max_height())
            if bin:
                animation.add_to_texture_bin(bin)

            identity = self._cached_animations[name] = animation

        if not rotate and not flip_x and not flip_y:
            return identity

        return identity.get_transform(flip_x, flip_y, rotate)

    def get_cached_image_names(self):
        '''Get a list of image filenames that have been cached.

        This is useful for debugging and profiling only.

        :rtype: list
        :return: List of str
        '''
        return self._cached_images.keys()

    def get_cached_animation_names(self):
        '''Get a list of animation filenames that have been cached.

        This is useful for debugging and profiling only.

        :rtype: list
        :return: List of str
        '''
        return self._cached_animations.keys()

    def get_texture_bins(self):
        '''Get a list of texture bins in use.

        This is useful for debugging and profiling only.

        :rtype: list
        :return: List of `TextureBin`
        '''
        return self._texture_atlas_bins.values()

    def media(self, name, streaming=True):
        '''Load a sound or video resource.

        The meaning of `streaming` is as for `media.load`.  Compressed
        sources cannot be streamed (that is, video and compressed audio
        cannot be streamed from a ZIP archive).

        :Parameters:
            `name` : str
                Filename of the media source to load.
            `streaming` : bool
                True if the source should be streamed from disk, False if
                it should be entirely decoded into memory immediately.

        :rtype: `media.Source`
        '''
        from pyglet import media
        try:
            location = self._index[name]
            if isinstance(location, FileLocation):
                # Don't open the file if it's streamed from disk -- AVbin
                # needs to do it.
                path = os.path.join(location.path, name)
                return media.load(path, streaming=streaming)
            else:
                file = location.open(name)
                return media.load(name, file=file, streaming=streaming)
        except KeyError:
            raise ResourceNotFoundException(name)

    def texture(self, name):
        '''Load a texture.

        The named image will be loaded as a single OpenGL texture.  If the
        dimensions of the image are not powers of 2 a `TextureRegion` will
        be returned.

        :Parameters:
            `name` : str
                Filename of the image resource to load.

        :rtype: `Texture`
        '''
        if name in self._cached_textures:
            return self._cached_textures[name]

        file = self.file(name)
        texture = pyglet.image.load(name, file=file).get_texture()
        self._cached_textures[name] = texture
        return texture

    def html(self, name):
        '''Load an HTML document.

        :Parameters:
            `name` : str
                Filename of the HTML resource to load.

        :rtype: `FormattedDocument`
        '''
        file = self.file(name)
        return pyglet.text.decode_html(file.read(), self.location(name))

    def attributed(self, name):
        '''Load an attributed text document.

        See `pyglet.text.formats.attributed` for details on this format.

        :Parameters:
            `name` : str
                Filename of the attribute text resource to load.

        :rtype: `FormattedDocument`
        '''
        file = self.file(name)
        return pyglet.text.load(name, file, 'text/vnd.pyglet-attributed')

    def text(self, name):
        '''Load a plain text document.

        :Parameters:
            `name` : str
                Filename of the plain text resource to load.

        :rtype: `UnformattedDocument`
        '''
        file = self.file(name)
        return pyglet.text.load(name, file, 'text/plain')

    def get_cached_texture_names(self):
        '''Get the names of textures currently cached.

        :rtype: list of str
        '''
        return self._cached_textures.keys()

#: Default resource search path.
#:
#: Locations in the search path are searched in order and are always
#: case-sensitive.  After changing the path you must call `reindex`.
#:
#: See the module documentation for details on the path format.
#:
#: :type: list of str
path = []

class _DefaultLoader(Loader):
    def _get_path(self):
        return path

    def _set_path(self, value):
        global path
        path = value

    path = property(_get_path, _set_path)

_default_loader = _DefaultLoader()
reindex = _default_loader.reindex
file = _default_loader.file
location = _default_loader.location
add_font = _default_loader.add_font
image = _default_loader.image
animation = _default_loader.animation
get_cached_image_names = _default_loader.get_cached_image_names
get_cached_animation_names = _default_loader.get_cached_animation_names
get_texture_bins = _default_loader.get_texture_bins
media = _default_loader.media
texture = _default_loader.texture
html = _default_loader.html
attributed = _default_loader.attributed
text = _default_loader.text
get_cached_texture_names = _default_loader.get_cached_texture_names

########NEW FILE########
__FILENAME__ = sprite
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Display positioned, scaled and rotated images.

A sprite is an instance of an image displayed on-screen.  Multiple sprites can
display the same image at different positions on the screen.  Sprites can also
be scaled larger or smaller, rotated at any angle and drawn at a fractional
opacity.

The following complete example loads a ``"ball.png"`` image and creates a
sprite for that image.  The sprite is then drawn in the window's
draw event handler::

    import pyglet

    ball_image = pyglet.image.load('ball.png')
    ball = pyglet.sprite.Sprite(ball_image, x=50, y=50)

    window = pyglet.window.Window()

    @window.event
    def on_draw():
        ball.draw()

    pyglet.app.run()

The sprite can be moved by modifying the ``x`` and ``y`` properties.  Other
properties determine the sprite's rotation, scale and opacity.

The sprite's positioning, rotation and scaling all honor the original
image's anchor (anchor_x, anchor_y).


Drawing multiple sprites
========================

Sprites can be "batched" together and drawn at once more quickly than if each
of their ``draw`` methods were called individually.  The following example
creates one hundred ball sprites and adds each of them to a `Batch`.  The
entire batch of sprites is then drawn in one call::

    batch = pyglet.graphics.Batch()

    ball_sprites = []
    for i in range(100):
        x, y = i * 10, 50
        ball_sprites.append(pyglet.sprite.Sprite(ball_image, x, y, batch=batch)

    @window.event
    def on_draw():
        batch.draw()

Sprites can be freely modified in any way even after being added to a batch,
however a sprite can belong to at most one batch.  See the documentation for
`pyglet.graphics` for more details on batched rendering, and grouping of
sprites within batches.

:since: pyglet 1.1
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: sprite.py 2541 2009-12-31 04:31:11Z benjamin.coder.smith@gmail.com $'

import math
import sys

from pyglet.gl import *
from pyglet import clock
from pyglet import event
from pyglet import graphics
from pyglet import image

_is_epydoc = hasattr(sys, 'is_epydoc') and sys.is_epydoc

class SpriteGroup(graphics.Group):
    '''Shared sprite rendering group.

    The group is automatically coalesced with other sprite groups sharing the
    same parent group, texture and blend parameters.
    '''
    def __init__(self, texture, blend_src, blend_dest, parent=None):
        '''Create a sprite group.

        The group is created internally within `Sprite`; applications usually
        do not need to explicitly create it.

        :Parameters:
            `texture` : `Texture`
                The (top-level) texture containing the sprite image.
            `blend_src` : int
                OpenGL blend source mode; for example,
                ``GL_SRC_ALPHA``.
            `blend_dest` : int
                OpenGL blend destination mode; for example,
                ``GL_ONE_MINUS_SRC_ALPHA``.
            `parent` : `Group`
                Optional parent group.

        '''
        super(SpriteGroup, self).__init__(parent)
        self.texture = texture
        self.blend_src = blend_src
        self.blend_dest = blend_dest

    def set_state(self):
        glEnable(self.texture.target)
        glBindTexture(self.texture.target, self.texture.id)

        glPushAttrib(GL_COLOR_BUFFER_BIT)
        glEnable(GL_BLEND)
        glBlendFunc(self.blend_src, self.blend_dest)

    def unset_state(self):
        glPopAttrib()
        glDisable(self.texture.target)

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.texture)

    def __eq__(self, other):
        return (other.__class__ is self.__class__ and
                self.parent is other.parent and
                self.texture.target == other.texture.target and
                self.texture.id == other.texture.id and
                self.blend_src == other.blend_src and
                self.blend_dest == other.blend_dest)

    def __hash__(self):
        return hash((id(self.parent),
                     self.texture.id, self.texture.target,
                     self.blend_src, self.blend_dest))

class Sprite(event.EventDispatcher):
    '''Instance of an on-screen image.

    See the module documentation for usage.
    '''
    _batch = None
    _animation = None
    _rotation = 0
    _opacity = 255
    _rgb = (255, 255, 255)
    _scale = 1.0
    _visible = True
    _vertex_list = None

    def __init__(self,
                 img, x=0, y=0,
                 blend_src=GL_SRC_ALPHA,
                 blend_dest=GL_ONE_MINUS_SRC_ALPHA,
                 batch=None,
                 group=None,
                 usage='dynamic'):
        '''Create a sprite.

        :Parameters:
            `img` : `AbstractImage` or `Animation`
                Image or animation to display.
            `x` : int
                X coordinate of the sprite.
            `y` : int
                Y coordinate of the sprite.
            `blend_src` : int
                OpenGL blend source mode.  The default is suitable for
                compositing sprites drawn from back-to-front.
            `blend_dest` : int
                OpenGL blend destination mode.  The default is suitable for
                compositing sprites drawn from back-to-front.
            `batch` : `Batch`
                Optional batch to add the sprite to.
            `group` : `Group`
                Optional parent group of the sprite.
            `usage` : str
                Vertex buffer object usage hint, one of ``"none"`` (default),
                ``"stream"``, ``"dynamic"`` or ``"static"``.  Applies
                only to vertex data.

        '''
        if batch is not None:
            self._batch = batch

        self._x = x
        self._y = y

        if isinstance(img, image.Animation):
            self._animation = img
            self._frame_index = 0
            self._texture = img.frames[0].image.get_texture()
            self._next_dt = img.frames[0].duration
            if self._next_dt:
                clock.schedule_once(self._animate, self._next_dt)
        else:
            self._texture = img.get_texture()

        self._group = SpriteGroup(self._texture, blend_src, blend_dest, group)
        self._usage = usage
        self._create_vertex_list()

    def __del__(self):
        try:
            if self._vertex_list is not None:
                self._vertex_list.delete()
        except:
            pass

    def delete(self):
        '''Force immediate removal of the sprite from video memory.

        This is often necessary when using batches, as the Python garbage
        collector will not necessarily call the finalizer as soon as the
        sprite is garbage.
        '''
        if self._animation:
            clock.unschedule(self._animate)
        self._vertex_list.delete()
        self._vertex_list = None
        self._texture = None

        # Easy way to break circular reference, speeds up GC
        self._group = None

    def _animate(self, dt):
        self._frame_index += 1
        if self._frame_index >= len(self._animation.frames):
            self._frame_index = 0
            self.dispatch_event('on_animation_end')
            if self._vertex_list is None:
                return # Deleted in event handler.

        frame = self._animation.frames[self._frame_index]
        self._set_texture(frame.image.get_texture())

        if frame.duration is not None:
            duration = frame.duration - (self._next_dt - dt)
            duration = min(max(0, duration), frame.duration)
            clock.schedule_once(self._animate, duration)
            self._next_dt = duration
        else:
            self.dispatch_event('on_animation_end')

    def _set_batch(self, batch):
        if self._batch == batch:
            return

        if batch is not None and self._batch is not None:
            self._batch.migrate(self._vertex_list, GL_QUADS, self._group, batch)
            self._batch = batch
        else:
            self._vertex_list.delete()
            self._batch = batch
            self._create_vertex_list()

    def _get_batch(self):
        return self._batch

    batch = property(_get_batch, _set_batch,
                     doc='''Graphics batch.

    The sprite can be migrated from one batch to another, or removed from its
    batch (for individual drawing).  Note that this can be an expensive
    operation.

    :type: `Batch`
    ''')

    def _set_group(self, group):
        if self._group.parent == group:
            return

        self._group = SpriteGroup(self._texture,
                                  self._group.blend_src,
                                  self._group.blend_dest,
                                  group)

        if self._batch is not None:
            self._batch.migrate(self._vertex_list, GL_QUADS, self._group,
                                self._batch)

    def _get_group(self):
        return self._group.parent

    group = property(_get_group, _set_group,
                     doc='''Parent graphics group.

    The sprite can change its rendering group, however this can be an
    expensive operation.

    :type: `Group`
    ''')

    def _get_image(self):
        if self._animation:
            return self._animation
        return self._texture

    def _set_image(self, img):
        if self._animation is not None:
            clock.unschedule(self._animate)
            self._animation = None

        if isinstance(img, image.Animation):
            self._animation = img
            self._frame_index = 0
            self._set_texture(img.frames[0].image.get_texture())
            self._next_dt = img.frames[0].duration
            clock.schedule_once(self._animate, self._next_dt)
        else:
            self._set_texture(img.get_texture())
        self._update_position()

    image = property(_get_image, _set_image,
                     doc='''Image or animation to display.

    :type: `AbstractImage` or `Animation`
    ''')

    def _set_texture(self, texture):
        if texture.id is not self._texture.id:
            self._group = SpriteGroup(texture,
                                      self._group.blend_src,
                                      self._group.blend_dest,
                                      self._group.parent)
            if self._batch is None:
                self._vertex_list.tex_coords[:] = texture.tex_coords
            else:
                self._vertex_list.delete()
                self._texture = texture
                self._create_vertex_list()
        else:
            self._vertex_list.tex_coords[:] = texture.tex_coords
        self._texture = texture

    def _create_vertex_list(self):
        if self._batch is None:
            self._vertex_list = graphics.vertex_list(4,
                'v2i/%s' % self._usage,
                'c4B', ('t3f', self._texture.tex_coords))
        else:
            self._vertex_list = self._batch.add(4, GL_QUADS, self._group,
                'v2i/%s' % self._usage,
                'c4B', ('t3f', self._texture.tex_coords))
        self._update_position()
        self._update_color()

    def _update_position(self):
        img = self._texture
        if not self._visible:
            self._vertex_list.vertices[:] = [0, 0, 0, 0, 0, 0, 0, 0]
        elif self._rotation:
            x1 = -img.anchor_x * self._scale
            y1 = -img.anchor_y * self._scale
            x2 = x1 + img.width * self._scale
            y2 = y1 + img.height * self._scale
            x = self._x
            y = self._y

            r = -math.radians(self._rotation)
            cr = math.cos(r)
            sr = math.sin(r)
            ax = int(x1 * cr - y1 * sr + x)
            ay = int(x1 * sr + y1 * cr + y)
            bx = int(x2 * cr - y1 * sr + x)
            by = int(x2 * sr + y1 * cr + y)
            cx = int(x2 * cr - y2 * sr + x)
            cy = int(x2 * sr + y2 * cr + y)
            dx = int(x1 * cr - y2 * sr + x)
            dy = int(x1 * sr + y2 * cr + y)

            self._vertex_list.vertices[:] = [ax, ay, bx, by, cx, cy, dx, dy]
        elif self._scale != 1.0:
            x1 = int(self._x - img.anchor_x * self._scale)
            y1 = int(self._y - img.anchor_y * self._scale)
            x2 = int(x1 + img.width * self._scale)
            y2 = int(y1 + img.height * self._scale)
            self._vertex_list.vertices[:] = [x1, y1, x2, y1, x2, y2, x1, y2]
        else:
            x1 = int(self._x - img.anchor_x)
            y1 = int(self._y - img.anchor_y)
            x2 = x1 + img.width
            y2 = y1 + img.height
            self._vertex_list.vertices[:] = [x1, y1, x2, y1, x2, y2, x1, y2]

    def _update_color(self):
        r, g, b = self._rgb
        self._vertex_list.colors[:] = [r, g, b, int(self._opacity)] * 4

    def set_position(self, x, y):
        '''Set the X and Y coordinates of the sprite simultaneously.

        :Parameters:
            `x` : int
                X coordinate of the sprite.
            `y` : int
                Y coordinate of the sprite.

        '''
        self._x = x
        self._y = y
        self._update_position()

    position = property(lambda self: (self._x, self._y),
                        lambda self, t: self.set_position(*t),
                        doc='''The (x, y) coordinates of the sprite.

    :type: (int, int)
    ''')

    def _set_x(self, x):
        self._x = x
        self._update_position()

    x = property(lambda self: self._x, _set_x,
                 doc='''X coordinate of the sprite.

    :type: int
    ''')

    def _set_y(self, y):
        self._y = y
        self._update_position()

    y = property(lambda self: self._y, _set_y,
                 doc='''Y coordinate of the sprite.

    :type: int
    ''')

    def _set_rotation(self, rotation):
        self._rotation = rotation
        self._update_position()

    rotation = property(lambda self: self._rotation, _set_rotation,
                        doc='''Clockwise rotation of the sprite, in degrees.

    The sprite image will be rotated about its image's (anchor_x, anchor_y)
    position.

    :type: float
    ''')

    def _set_scale(self, scale):
        self._scale = scale
        self._update_position()

    scale = property(lambda self: self._scale, _set_scale,
                     doc='''Scaling factor.

    A scaling factor of 1 (the default) has no effect.  A scale of 2 will draw
    the sprite at twice the native size of its image.

    :type: float
    ''')

    width = property(lambda self: int(self._texture.width * self._scale),
                     doc='''Scaled width of the sprite.

    Read-only.  Invariant under rotation.

    :type: int
    ''')

    height = property(lambda self: int(self._texture.height * self._scale),
                      doc='''Scaled height of the sprite.

    Read-only.  Invariant under rotation.

    :type: int
    ''')

    def _set_opacity(self, opacity):
        self._opacity = opacity
        self._update_color()

    opacity = property(lambda self: self._opacity, _set_opacity,
                       doc='''Blend opacity.

    This property sets the alpha component of the colour of the sprite's
    vertices.  With the default blend mode (see the constructor), this
    allows the sprite to be drawn with fractional opacity, blending with the
    background.

    An opacity of 255 (the default) has no effect.  An opacity of 128 will
    make the sprite appear translucent.

    :type: int
    ''')

    def _set_color(self, rgb):
        self._rgb = map(int, rgb)
        self._update_color()

    color = property(lambda self: self._rgb, _set_color,
                       doc='''Blend color.

    This property sets the color of the sprite's vertices. This allows the
    sprite to be drawn with a color tint.

    The color is specified as an RGB tuple of integers ``(red, green, blue)``.
    Each color component must be in the range 0 (dark) to 255 (saturated).

    :type: (int, int, int)
    ''')

    def _set_visible(self, visible):
        self._visible = visible
        self._update_position()

    visible = property(lambda self: self._visible, _set_visible,
                       '''True if the sprite will be drawn.

    :type: bool
    ''')


    def draw(self):
        '''Draw the sprite at its current position.

        See the module documentation for hints on drawing multiple sprites
        efficiently.
        '''
        self._group.set_state_recursive()
        self._vertex_list.draw(GL_QUADS)
        self._group.unset_state_recursive()

    if _is_epydoc:
        def on_animation_end(self):
            '''The sprite animation reached the final frame.

            The event is triggered only if the sprite has an animation, not an
            image.  For looping animations, the event is triggered each time
            the animation loops.

            :event:
            '''

Sprite.register_event_type('on_animation_end')

########NEW FILE########
__FILENAME__ = caret
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
# $Id:$

'''Provides keyboard and mouse editing procedures for text layout.

Example usage::

    from pyglet import window
    from pyglet.text import layout, caret

    my_window = window.Window(...)
    my_layout = layout.IncrementalTextLayout(...)
    my_caret = caret.Caret(my_layout)
    my_window.push_handlers(my_caret)

:since: pyglet 1.1
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import re
import time

from pyglet import clock
from pyglet import event
from pyglet.window import key

class Caret(object):
    '''Visible text insertion marker for
    `pyglet.text.layout.IncrementalTextLayout`.

    The caret is drawn as a single vertical bar at the document `position`
    on a text layout object.  If `mark` is not None, it gives the unmoving
    end of the current text selection.  The visible text selection on the
    layout is updated along with `mark` and `position`.

    By default the layout's graphics batch is used, so the caret does not need
    to be drawn explicitly.  Even if a different graphics batch is supplied,
    the caret will be correctly positioned and clipped within the layout.

    Updates to the document (and so the layout) are automatically propagated
    to the caret.

    The caret object can be pushed onto a window event handler stack with
    `Window.push_handlers`.  The caret will respond correctly to keyboard,
    text, mouse and activation events, including double- and triple-clicks.
    If the text layout is being used alongside other graphical widgets, a
    GUI toolkit will be needed to delegate keyboard and mouse events to the
    appropriate widget.  pyglet does not provide such a toolkit at this stage.
    '''

    _next_word_re = re.compile(r'(?<=\W)\w')
    _previous_word_re = re.compile(r'(?<=\W)\w+\W*$')
    _next_para_re = re.compile(r'\n', flags=re.DOTALL)
    _previous_para_re = re.compile(r'\n', flags=re.DOTALL)

    _position = 0

    _active = True
    _visible = True
    _blink_visible = True
    _click_count = 0
    _click_time = 0

    #: Blink period, in seconds.
    PERIOD = 0.5

    #: Pixels to scroll viewport per mouse scroll wheel movement.  Defaults
    #: to 12pt at 96dpi.
    SCROLL_INCREMENT= 12 * 96 / 72

    def __init__(self, layout, batch=None, color=(0, 0, 0)):
        '''Create a caret for a layout.

        By default the layout's batch is used, so the caret does not need to
        be drawn explicitly.

        :Parameters:
            `layout` : `TextLayout`
                Layout to control.
            `batch` : `Batch`
                Graphics batch to add vertices to.
            `color` : (int, int, int)
                RGB tuple with components in range [0, 255].

        '''
        from pyglet import gl
        self._layout = layout
        if batch is None:
            batch = layout.batch
        r, g, b = color
        colors = (r, g, b, 255, r, g, b, 255)
        self._list = batch.add(2, gl.GL_LINES, layout.background_group,
            'v2f', ('c4B', colors))

        self._ideal_x = None
        self._ideal_line = None
        self._next_attributes = {}

        self.visible = True

        layout.push_handlers(self)

    def delete(self):
        '''Remove the caret from its batch.

        Also disconnects the caret from further layout events.
        '''
        self._list.delete()
        self._layout.remove_handlers(self)

    def _blink(self, dt):
        if self.PERIOD:
            self._blink_visible = not self._blink_visible
        if self._visible and self._active and self._blink_visible:
            alpha = 255
        else:
            alpha = 0
        self._list.colors[3] = alpha
        self._list.colors[7] = alpha

    def _nudge(self):
        self.visible = True

    def _set_visible(self, visible):
        self._visible = visible
        clock.unschedule(self._blink)
        if visible and self._active and self.PERIOD:
            clock.schedule_interval(self._blink, self.PERIOD)
            self._blink_visible = False # flipped immediately by next blink
        self._blink(0)

    def _get_visible(self):
        return self._visible

    visible = property(_get_visible, _set_visible,
                       doc='''Caret visibility.

    The caret may be hidden despite this property due to the periodic blinking
    or by `on_deactivate` if the event handler is attached to a window.

    :type: bool
    ''')

    def _set_color(self, color):
        self._list.colors[:3] = color
        self._list.colors[4:7] = color

    def _get_color(self):
        return self._list.colors[:3]

    color = property(_get_color, _set_color,
                     doc='''Caret color.

    The default caret color is ``[0, 0, 0]`` (black).  Each RGB color
    component is in the range 0 to 255.

    :type: (int, int, int)
    ''')

    def _set_position(self, index):
        self._position = index
        self._next_attributes.clear()
        self._update()

    def _get_position(self):
        return self._position

    position = property(_get_position, _set_position,
                        doc='''Position of caret within document.

    :type: int
    ''')

    _mark = None
    def _set_mark(self, mark):
        self._mark = mark
        self._update(line=self._ideal_line)
        if mark is None:
            self._layout.set_selection(0, 0)

    def _get_mark(self):
        return self._mark

    mark = property(_get_mark, _set_mark,
                    doc='''Position of immovable end of text selection within
    document.

    An interactive text selection is determined by its immovable end (the
    caret's position when a mouse drag begins) and the caret's position, which
    moves interactively by mouse and keyboard input.

    This property is ``None`` when there is no selection.

    :type: int
    ''')

    def _set_line(self, line):
        if self._ideal_x is None:
            self._ideal_x, _ = \
                self._layout.get_point_from_position(self._position)
        self._position = \
            self._layout.get_position_on_line(line, self._ideal_x)
        self._update(line=line, update_ideal_x=False)

    def _get_line(self):
        if self._ideal_line is not None:
            return self._ideal_line
        else:
            return self._layout.get_line_from_position(self._position)

    line = property(_get_line, _set_line,
                    doc='''Index of line containing the caret's position.

    When set, `position` is modified to place the caret on requested line
    while maintaining the closest possible X offset.

    :type: int
    ''')

    def get_style(self, attribute):
        '''Get the document's named style at the caret's current position.

        If there is a text selection and the style varies over the selection,
        `pyglet.text.document.STYLE_INDETERMINATE` is returned.

        :Parameters:
            `attribute` : str
                Name of style attribute to retrieve.  See
                `pyglet.text.document` for a list of recognised attribute
                names.

        :rtype: object
        '''
        if self._mark is None or self._mark == self._position:
            try:
                return self._next_attributes[attribute]
            except KeyError:
                return self._layout.document.get_style(attribute,
                                                          self._position)

        start = min(self._position, self._mark)
        end = max(self._position, self._mark)
        return self._layout.document.get_style_range(attribute, start, end)

    def set_style(self, attributes):
        '''Set the document style at the caret's current position.

        If there is a text selection the style is modified immediately.
        Otherwise, the next text that is entered before the position is
        modified will take on the given style.

        :Parameters:
            `attributes` : dict
                Dict mapping attribute names to style values.  See
                `pyglet.text.document` for a list of recognised attribute
                names.

        '''

        if self._mark is None or self._mark == self._position:
            self._next_attributes.update(attributes)
            return

        start = min(self._position, self._mark)
        end = max(self._position, self._mark)
        self._layout.document.set_style(start, end, attributes)

    def _delete_selection(self):
        start = min(self._mark, self._position)
        end = max(self._mark, self._position)
        self._position = start
        self._mark = None
        self._layout.document.delete_text(start, end)
        self._layout.set_selection(0, 0)

    def move_to_point(self, x, y):
        '''Move the caret close to the given window coordinate.

        The `mark` will be reset to ``None``.

        :Parameters:
            `x` : int
                X coordinate.
            `y` : int
                Y coordinate.

        '''
        line = self._layout.get_line_from_point(x, y)
        self._mark = None
        self._layout.set_selection(0, 0)
        self._position = self._layout.get_position_on_line(line, x)
        self._update(line=line)
        self._next_attributes.clear()

    def select_to_point(self, x, y):
        '''Move the caret close to the given window coordinate while
        maintaining the `mark`.

        :Parameters:
            `x` : int
                X coordinate.
            `y` : int
                Y coordinate.

        '''
        line = self._layout.get_line_from_point(x, y)
        self._position = self._layout.get_position_on_line(line, x)
        self._update(line=line)
        self._next_attributes.clear()

    def select_word(self, x, y):
        '''Select the word at the given window coordinate.

        :Parameters:
            `x` : int
                X coordinate.
            `y` : int
                Y coordinate.

        '''
        line = self._layout.get_line_from_point(x, y)
        p = self._layout.get_position_on_line(line, x)
        m1 = self._previous_word_re.search(self._layout.document.text,
                                           0, p+1)
        if not m1:
            m1 = 0
        else:
            m1 = m1.start()
        self.mark = m1

        m2 = self._next_word_re.search(self._layout.document.text, p)
        if not m2:
            m2 = len(self._layout.document.text)
        else:
            m2 = m2.start()
        self._position = m2
        self._update(line=line)
        self._next_attributes.clear()

    def select_paragraph(self, x, y):
        '''Select the paragraph at the given window coordinate.

        :Parameters:
            `x` : int
                X coordinate.
            `y` : int
                Y coordinate.

        '''
        line = self._layout.get_line_from_point(x, y)
        p = self._layout.get_position_on_line(line, x)
        self.mark = self._layout.document.get_paragraph_start(p)
        self._position = self._layout.document.get_paragraph_end(p)
        self._update(line=line)
        self._next_attributes.clear()

    def _update(self, line=None, update_ideal_x=True):
        if line is None:
            line = self._layout.get_line_from_position(self._position)
            self._ideal_line = None
        else:
            self._ideal_line = line
        x, y = self._layout.get_point_from_position(self._position, line)
        if update_ideal_x:
            self._ideal_x = x

        x -= self._layout.top_group.translate_x
        y -= self._layout.top_group.translate_y
        font = self._layout.document.get_font(max(0, self._position - 1))
        self._list.vertices[:] = [x, y + font.descent, x, y + font.ascent]

        if self._mark is not None:
            self._layout.set_selection(min(self._position, self._mark),
                                          max(self._position, self._mark))

        self._layout.ensure_line_visible(line)
        self._layout.ensure_x_visible(x)

    def on_layout_update(self):
        if self.position > len(self._layout.document.text):
            self.position = len(self._layout.document.text)
        self._update()

    def on_text(self, text):
        '''Handler for the `pyglet.window.Window.on_text` event.

        Caret keyboard handlers assume the layout always has keyboard focus.
        GUI toolkits should filter keyboard and text events by widget focus
        before invoking this handler.
        '''
        if self._mark is not None:
            self._delete_selection()

        text = text.replace('\r', '\n')
        pos = self._position
        self._position += len(text)
        self._layout.document.insert_text(pos, text, self._next_attributes)
        self._nudge()
        return event.EVENT_HANDLED

    def on_text_motion(self, motion, select=False):
        '''Handler for the `pyglet.window.Window.on_text_motion` event.

        Caret keyboard handlers assume the layout always has keyboard focus.
        GUI toolkits should filter keyboard and text events by widget focus
        before invoking this handler.
        '''
        if motion == key.MOTION_BACKSPACE:
            if self.mark is not None:
                self._delete_selection()
            elif self._position > 0:
                self._position -= 1
                self._layout.document.delete_text(
                    self._position, self._position + 1)
        elif motion == key.MOTION_DELETE:
            if self.mark is not None:
                self._delete_selection()
            elif self._position < len(self._layout.document.text):
                self._layout.document.delete_text(
                    self._position, self._position + 1)
        elif self._mark is not None and not select:
            self._mark = None
            self._layout.set_selection(0, 0)

        if motion == key.MOTION_LEFT:
            self.position = max(0, self.position - 1)
        elif motion == key.MOTION_RIGHT:
            self.position = min(len(self._layout.document.text),
                                self.position + 1)
        elif motion == key.MOTION_UP:
            self.line = max(0, self.line - 1)
        elif motion == key.MOTION_DOWN:
            line = self.line
            if line < self._layout.get_line_count() - 1:
                self.line = line + 1
        elif motion == key.MOTION_BEGINNING_OF_LINE:
            self.position = self._layout.get_position_from_line(self.line)
        elif motion == key.MOTION_END_OF_LINE:
            line = self.line
            if line < self._layout.get_line_count() - 1:
                self._position = \
                    self._layout.get_position_from_line(line + 1) - 1
                self._update(line)
            else:
                self.position = len(self._layout.document.text)
        elif motion == key.MOTION_BEGINNING_OF_FILE:
            self.position = 0
        elif motion == key.MOTION_END_OF_FILE:
            self.position = len(self._layout.document.text)
        elif motion == key.MOTION_NEXT_WORD:
            pos = self._position + 1
            m = self._next_word_re.search(self._layout.document.text, pos)
            if not m:
                self.position = len(self._layout.document.text)
            else:
                self.position = m.start()
        elif motion == key.MOTION_PREVIOUS_WORD:
            pos = self._position
            m = self._previous_word_re.search(self._layout.document.text,
                                              0, pos)
            if not m:
                self.position = 0
            else:
                self.position = m.start()

        self._next_attributes.clear()
        self._nudge()
        return event.EVENT_HANDLED

    def on_text_motion_select(self, motion):
        '''Handler for the `pyglet.window.Window.on_text_motion_select` event.

        Caret keyboard handlers assume the layout always has keyboard focus.
        GUI toolkits should filter keyboard and text events by widget focus
        before invoking this handler.
        '''
        if self.mark is None:
            self.mark = self.position
        self.on_text_motion(motion, True)
        return event.EVENT_HANDLED

    def on_mouse_scroll(self, x, y, scroll_x, scroll_y):
        '''Handler for the `pyglet.window.Window.on_mouse_scroll` event.

        Mouse handlers do not check the bounds of the coordinates: GUI
        toolkits should filter events that do not intersect the layout
        before invoking this handler.

        The layout viewport is scrolled by `SCROLL_INCREMENT` pixels per
        "click".
        '''
        self._layout.view_x -= scroll_x * self.SCROLL_INCREMENT
        self._layout.view_y += scroll_y * self.SCROLL_INCREMENT
        return event.EVENT_HANDLED

    def on_mouse_press(self, x, y, button, modifiers):
        '''Handler for the `pyglet.window.Window.on_mouse_press` event.

        Mouse handlers do not check the bounds of the coordinates: GUI
        toolkits should filter events that do not intersect the layout
        before invoking this handler.

        This handler keeps track of the number of mouse presses within
        a short span of time and uses this to reconstruct double- and
        triple-click events for selecting words and paragraphs.  This
        technique is not suitable when a GUI toolkit is in use, as the active
        widget must also be tracked.  Do not use this mouse handler if
        a GUI toolkit is being used.
        '''
        t = time.time()
        if t - self._click_time < 0.25:
            self._click_count += 1
        else:
            self._click_count = 1
        self._click_time = time.time()

        if self._click_count == 1:
            self.move_to_point(x, y)
        elif self._click_count == 2:
            self.select_word(x, y)
        elif self._click_count == 3:
            self.select_paragraph(x, y)
            self._click_count = 0

        self._nudge()
        return event.EVENT_HANDLED

    def on_mouse_drag(self, x, y, dx, dy, buttons, modifiers):
        '''Handler for the `pyglet.window.Window.on_mouse_drag` event.

        Mouse handlers do not check the bounds of the coordinates: GUI
        toolkits should filter events that do not intersect the layout
        before invoking this handler.
        '''
        if self.mark is None:
            self.mark = self.position
        self.select_to_point(x, y)
        self._nudge()
        return event.EVENT_HANDLED

    def on_activate(self):
        '''Handler for the `pyglet.window.Window.on_activate` event.

        The caret is hidden when the window is not active.
        '''
        self._active = True
        self.visible = self.visible
        return event.EVENT_HANDLED

    def on_deactivate(self):
        '''Handler for the `pyglet.window.Window.on_deactivate` event.

        The caret is hidden when the window is not active.
        '''
        self._active = False
        self.visible = self.visible
        return event.EVENT_HANDLED

########NEW FILE########
__FILENAME__ = document
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
# $Id:$

'''Formatted and unformatted document interfaces used by text layout.

Abstract representation
=======================

Styled text in pyglet is represented by one of the `AbstractDocument` classes,
which manage the state representation of text and style independently of how
it is loaded or rendered.

A document consists of the document text (a Unicode string) and a set of
named style ranges.  For example, consider the following (artificial)
example::

    0    5   10   15   20
    The cat sat on the mat.
    +++++++        +++++++    "bold"
                ++++++      "italic"

If this example were to be rendered, "The cat" and "the mat" would be in bold,
and "on the" in italics.  Note that the second "the" is both bold and italic.

The document styles recorded for this example would be ``"bold"`` over ranges
(0-7, 15-22) and ``"italic"`` over range (12-18).  Overlapping styles are
permitted; unlike HTML and other structured markup, the ranges need not be
nested.

The document has no knowledge of the semantics of ``"bold"`` or ``"italic"``,
it stores only the style names.  The pyglet layout classes give meaning to
these style names in the way they are rendered; but you are also free to
invent your own style names (which will be ignored by the layout classes).
This can be useful to tag areas of interest in a document, or maintain
references back to the source material.

As well as text, the document can contain arbitrary elements represented by
`InlineElement`.  An inline element behaves like a single character in the
documented, but can be rendered by the application.

Paragraph breaks
================

Paragraph breaks are marked with a "newline" character (U+0010).  The Unicode
paragraph break (U+2029) can also be used.

Line breaks (U+2028) can be used to force a line break within a paragraph.

See Unicode recommendation UTR #13 for more information:
http://unicode.org/reports/tr13/tr13-5.html.

Document classes
================

Any class implementing `AbstractDocument` provides a an interface to a
document model as described above.  In theory a structured document such as
HTML or XML could export this model, though the classes provided by pyglet
implement only unstructured documents.

The `UnformattedDocument` class assumes any styles set are set over the entire
document.  So, regardless of the range specified when setting a ``"bold"``
style attribute, for example, the entire document will receive that style.

The `FormattedDocument` class implements the document model directly, using
the `RunList` class to represent style runs efficiently.

Style attributes
================

The following character style attribute names are recognised by pyglet:

``font_name``
    Font family name, as given to `pyglet.font.load`.
``font_size``
    Font size, in points.
``bold``
    Boolean.
``italic``
    Boolean.
``underline``
    4-tuple of ints in range (0, 255) giving RGBA underline color, or None
    (default) for no underline.
``kerning``
    Additional space to insert between glyphs, in points.  Defaults to 0.
``baseline``
    Offset of glyph baseline from line baseline, in points.  Positive values
    give a superscript, negative values give a subscript.  Defaults to 0.
``color``
    4-tuple of ints in range (0, 255) giving RGBA text color
``background_color``
    4-tuple of ints in range (0, 255) giving RGBA text background color; or
    ``None`` for no background fill.

The following paragraph style attribute names are recognised by pyglet.  Note
that paragraph styles are handled no differently from character styles by the
document: it is the application's responsibility to set the style over an
entire paragraph, otherwise results are undefined.

``align``
    ``left`` (default), ``center`` or ``right``.
``indent``
    Additional horizontal space to insert before the first
``leading``
    Additional space to insert between consecutive lines within a paragraph,
    in points.  Defaults to 0.
``line_spacing``
    Distance between consecutive baselines in a paragraph, in points.
    Defaults to ``None``, which automatically calculates the tightest line
    spacing for each line based on the font ascent and descent.
``margin_left``
    Left paragraph margin, in pixels.
``margin_right``
    Right paragraph margin, in pixels.
``margin_top``
    Margin above paragraph, in pixels.
``margin_bottom``
    Margin below paragraph, in pixels.  Adjacent margins do not collapse.
``tab_stops``
    List of horizontal tab stops, in pixels, measured from the left edge of
    the text layout.  Defaults to the empty list.  When the tab stops
    are exhausted, they implicitly continue at 50 pixel intervals.
``wrap``
    Boolean.  If True (the default), text wraps within the width of the layout.

Other attributes can be used to store additional style information within the
document; it will be ignored by the built-in text classes.

All style attributes (including those not present in a document) default to
``None`` (including the so-called "boolean" styles listed above).  The meaning
of a ``None`` style is style- and application-dependent.

:since: pyglet 1.1
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import re
import sys

from pyglet import event
from pyglet.text import runlist

_is_epydoc = hasattr(sys, 'is_epydoc') and sys.is_epydoc

#: The style attribute takes on multiple values in the document.
STYLE_INDETERMINATE = 'indeterminate'

class InlineElement(object):
    '''Arbitrary inline element positioned within a formatted document.

    Elements behave like a single glyph in the document.  They are
    measured by their horizontal advance, ascent above the baseline, and
    descent below the baseline.

    The pyglet layout classes reserve space in the layout for elements and
    call the element's methods to ensure they are rendered at the
    appropriate position.

    If the size of a element (any of the `advance`, `ascent`, or `descent`
    instance variables) is modified it is the application's responsibility to
    trigger a reflow of the appropriate area in the affected layouts.  This
    can be done by forcing a style change over the element's position.

    :Ivariables:
        `ascent` : int
            Ascent of the element above the baseline, in pixels.
        `descent` : int
            Descent of the element below the baseline, in pixels.
            Typically negative.
        `advance` : int
            Width of the element, in pixels.

    '''
    def __init__(self, ascent, descent, advance):
        self.ascent = ascent
        self.descent = descent
        self.advance = advance
        self._position = None

    position = property(lambda self: self._position,
                        doc='''Position of the element within the
        document.  Read-only.

        :type: int
        ''')

    def place(self, layout, x, y):
        '''Construct an instance of the element at the given coordinates.

        Called when the element's position within a layout changes, either
        due to the initial condition, changes in the document or changes in
        the layout size.

        It is the responsibility of the element to clip itself against
        the layout boundaries, and position itself appropriately with respect
        to the layout's position and viewport offset.

        The `TextLayout.top_state` graphics state implements this transform
        and clipping into window space.

        :Parameters:
            `layout` : `pyglet.text.layout.TextLayout`
                The layout the element moved within.
            `x` : int
                Position of the left edge of the element, relative
                to the left edge of the document, in pixels.
            `y` : int
                Position of the baseline, relative to the top edge of the
                document, in pixels.  Note that this is typically negative.

        '''
        raise NotImplementedError('abstract')

    def remove(self, layout):
        '''Remove this element from a layout.

        The counterpart of `place`; called when the element is no longer
        visible in the given layout.

        :Parameters:
            `layout` : `pyglet.text.layout.TextLayout`
                The layout the element was removed from.

        '''
        raise NotImplementedError('abstract')

class AbstractDocument(event.EventDispatcher):
    '''Abstract document interface used by all `pyglet.text` classes.

    This class can be overridden to interface pyglet with a third-party
    document format.  It may be easier to implement the document format in
    terms of one of the supplied concrete classes `FormattedDocument` or
    `UnformattedDocument`.
    '''
    _previous_paragraph_re = re.compile(u'\n[^\n\u2029]*$')
    _next_paragraph_re = re.compile(u'[\n\u2029]')

    def __init__(self, text=''):
        super(AbstractDocument, self).__init__()
        self._text = u''
        self._elements = []
        if text:
            self.insert_text(0, text)

    def _get_text(self):
        return self._text

    def _set_text(self, text):
        if text == self._text:
            return
        self.delete_text(0, len(self._text))
        self.insert_text(0, text)

    text = property(_get_text, _set_text,
                    doc='''Document text.

        For efficient incremental updates, use the `insert_text` and
        `delete_text` methods instead of replacing this property.

        :type: str
        ''')

    def get_paragraph_start(self, pos):
        '''Get the starting position of a paragraph.

        :Parameters:
            `pos` : int
                Character position within paragraph.

        :rtype: int
        '''
        # Tricky special case where the $ in pattern matches before the \n at
        # the end of the string instead of the end of the string.
        if (self._text[:pos + 1].endswith('\n') or
            self._text[:pos + 1].endswith(u'\u2029')):
            return pos

        m = self._previous_paragraph_re.search(self._text, 0, pos + 1)
        if not m:
            return 0
        return m.start() + 1

    def get_paragraph_end(self, pos):
        '''Get the end position of a paragraph.

        :Parameters:
            `pos` : int
                Character position within paragraph.

        :rtype: int
        '''
        m = self._next_paragraph_re.search(self._text, pos)
        if not m:
            return len(self._text)
        return m.start() + 1

    def get_style_runs(self, attribute):
        '''Get a style iterator over the given style attribute.

        :Parameters:
            `attribute` : str
                Name of style attribute to query.

        :rtype: `AbstractRunIterator`
        '''
        raise NotImplementedError('abstract')

    def get_style(self, attribute, position=0):
        '''Get an attribute style at the given position.

        :Parameters:
            `attribute` : str
                Name of style attribute to query.
            `position` : int
                Character position of document to query.

        :return: The style set for the attribute at the given position.
        '''
        raise NotImplementedError('abstract')

    def get_style_range(self, attribute, start, end):
        '''Get an attribute style over the given range.

        If the style varies over the range, `STYLE_INDETERMINATE` is returned.

        :Parameters:
            `attribute` : str
                Name of style attribute to query.
            `start` : int
                Starting character position.
            `end` : int
                Ending character position (exclusive).

        :return: The style set for the attribute over the given range, or
            `STYLE_INDETERMINATE` if more than one value is set.
        '''
        iter = self.get_style_runs(attribute)
        _, value_end, value = iter.ranges(start, end).next()
        if value_end < end:
            return STYLE_INDETERMINATE
        else:
            return value

    def get_font_runs(self, dpi=None):
        '''Get a style iterator over the `pyglet.font.Font` instances used in
        the document.

        The font instances are created on-demand by inspection of the
        ``font_name``, ``font_size``, ``bold`` and ``italic`` style
        attributes.

        :Parameters:
            `dpi` : float
                Optional resolution to construct fonts at.  See
                `pyglet.font.load`.

        :rtype: `AbstractRunIterator`
        '''
        raise NotImplementedError('abstract')

    def get_font(self, position, dpi=None):
        '''Get the font instance used at the given position.

        :see: `get_font_runs`

        :Parameters:
            `position` : int
                Character position of document to query.
            `dpi` : float
                Optional resolution to construct fonts at.  See
                `pyglet.font.load`.

        :rtype: `pyglet.font.Font`
        :return: The font at the given position.
        '''
        raise NotImplementedError('abstract')

    def insert_text(self, start, text, attributes=None):
        '''Insert text into the document.

        :Parameters:
            `start` : int
                Character insertion point within document.
            `text` : str
                Text to insert.
            `attributes` : dict
                Optional dictionary giving named style attributes of the
                inserted text.

        '''
        self._insert_text(start, text, attributes)
        self.dispatch_event('on_insert_text', start, text)

    def _insert_text(self, start, text, attributes):
        self._text = u''.join((self._text[:start], text, self._text[start:]))
        len_text = len(text)
        for element in self._elements:
            if element._position >= start:
                element._position += len_text

    def delete_text(self, start, end):
        '''Delete text from the document.

        :Parameters:
            `start` : int
                Starting character position to delete from.
            `end` : int
                Ending character position to delete to (exclusive).

        '''
        self._delete_text(start, end)
        self.dispatch_event('on_delete_text', start, end)

    def _delete_text(self, start, end):
        for element in list(self._elements):
            if start <= element.position < end:
                self._elements.remove(element)

        self._text = self._text[:start] + self._text[end:]

    def insert_element(self, position, element, attributes=None):
        '''Insert a element into the document.

        See the `InlineElement` class documentation for details of
        usage.

        :Parameters:
            `position` : int
                Character insertion point within document.
            `element` : `InlineElement`
                Element to insert.
            `attributes` : dict
                Optional dictionary giving named style attributes of the
                inserted text.

        '''
        assert element._position is None, \
            'Element is already in a document.'
        self.insert_text(position, '\0', attributes)
        element._position = position
        self._elements.append(element)
        self._elements.sort(key=lambda d:d.position)

    def get_element(self, position):
        '''Get the element at a specified position.

        :Parameters:
            `position` : int
                Position in the document of the element.

        :rtype: `InlineElement`
        '''
        for element in self._elements:
            if element._position == position:
                return element
        raise RuntimeError('No element at position %d' % position)

    def set_style(self, start, end, attributes):
        '''Set text style of some or all of the document.

        :Parameters:
            `start` : int
                Starting character position.
            `end` : int
                Ending character position (exclusive).
            `attributes` : dict
                Dictionary giving named style attributes of the text.

        '''
        self._set_style(start, end, attributes)
        self.dispatch_event('on_style_text', start, end, attributes)

    def _set_style(self, start, end, attributes):
        raise NotImplementedError('abstract')

    def set_paragraph_style(self, start, end, attributes):
        '''Set the style for a range of paragraphs.

        This is a convenience method for `set_style` that aligns the
        character range to the enclosing paragraph(s).

        :Parameters:
            `start` : int
                Starting character position.
            `end` : int
                Ending character position (exclusive).
            `attributes` : dict
                Dictionary giving named style attributes of the paragraphs.

        '''
        start = self.get_paragraph_start(start)
        end = self.get_paragraph_end(end)
        self._set_style(start, end, attributes)
        self.dispatch_event('on_style_text', start, end, attributes)

    if _is_epydoc:
        def on_insert_text(self, start, text):
            '''Text was inserted into the document.

            :Parameters:
                `start` : int
                    Character insertion point within document.
                `text` : str
                    The text that was inserted.

            :event:
            '''

        def on_delete_text(self, start, end):
            '''Text was deleted from the document.

            :Parameters:
                `start` : int
                    Starting character position of deleted text.
                `end` : int
                    Ending character position of deleted text (exclusive).

            :event:
            '''

        def on_style_text(self, start, end, attributes):
            '''Text character style was modified.

            :Parameters:
                `start` : int
                    Starting character position of modified text.
                `end` : int
                    Ending character position of modified text (exclusive).
                `attributes` : dict
                    Dictionary giving updated named style attributes of the
                    text.

            :event:
            '''
AbstractDocument.register_event_type('on_insert_text')
AbstractDocument.register_event_type('on_delete_text')
AbstractDocument.register_event_type('on_style_text')

class UnformattedDocument(AbstractDocument):
    '''A document having uniform style over all text.

    Changes to the style of text within the document affects the entire
    document.  For convenience, the ``position`` parameters of the style
    methods may therefore be omitted.
    '''

    def __init__(self, text=''):
        super(UnformattedDocument, self).__init__(text)
        self.styles = {}

    def get_style_runs(self, attribute):
        value = self.styles.get(attribute)
        return runlist.ConstRunIterator(len(self.text), value)

    def get_style(self, attribute, position=None):
        return self.styles.get(attribute)

    def set_style(self, start, end, attributes):
        return super(UnformattedDocument, self).set_style(
            0, len(self.text), attributes)

    def _set_style(self, start, end, attributes):
        self.styles.update(attributes)

    def set_paragraph_style(self, start, end, attributes):
        return super(UnformattedDocument, self).set_paragraph_style(
            0, len(self.text), attributes)

    def get_font_runs(self, dpi=None):
        ft = self.get_font(dpi=dpi)
        return runlist.ConstRunIterator(len(self.text), ft)

    def get_font(self, position=None, dpi=None):
        from pyglet import font
        font_name = self.styles.get('font_name')
        font_size = self.styles.get('font_size')
        bold = self.styles.get('bold', False)
        italic = self.styles.get('italic', False)
        return font.load(font_name, font_size,
                         bold=bool(bold), italic=bool(italic), dpi=dpi)

    def get_element_runs(self):
        return runlist.ConstRunIterator(len(self._text), None)

class FormattedDocument(AbstractDocument):
    '''Simple implementation of a document that maintains text formatting.

    Changes to text style are applied according to the description in
    `AbstractDocument`.  All styles default to ``None``.
    '''

    def __init__(self, text=''):
        self._style_runs = {}
        super(FormattedDocument, self).__init__(text)

    def get_style_runs(self, attribute):
        try:
            return self._style_runs[attribute].get_run_iterator()
        except KeyError:
            return _no_style_range_iterator

    def get_style(self, attribute, position=0):
        try:
            return self._style_runs[attribute][position]
        except KeyError:
            return None

    def _set_style(self, start, end, attributes):
        for attribute, value in attributes.items():
            try:
                runs = self._style_runs[attribute]
            except KeyError:
                runs = self._style_runs[attribute] = runlist.RunList(0, None)
                runs.insert(0, len(self._text))
            runs.set_run(start, end, value)

    def get_font_runs(self, dpi=None):
        return _FontStyleRunsRangeIterator(
            self.get_style_runs('font_name'),
            self.get_style_runs('font_size'),
            self.get_style_runs('bold'),
            self.get_style_runs('italic'),
            dpi)

    def get_font(self, position, dpi=None):
        iter = self.get_font_runs(dpi)
        return iter[position]

    def get_element_runs(self):
        return _ElementIterator(self._elements, len(self._text))

    def _insert_text(self, start, text, attributes):
        super(FormattedDocument, self)._insert_text(start, text, attributes)

        len_text = len(text)
        for runs in self._style_runs.values():
            runs.insert(start, len_text)

        if attributes is not None:
            for attribute, value in attributes.items():
                try:
                    runs = self._style_runs[attribute]
                except KeyError:
                    runs = self._style_runs[attribute] = \
                        runlist.RunList(0, None)
                    runs.insert(0, len(self.text))
                runs.set_run(start, start + len_text, value)

    def _delete_text(self, start, end):
        super(FormattedDocument, self)._delete_text(start, end)
        for runs in self._style_runs.values():
            runs.delete(start, end)

def _iter_elements(elements, length):
    last = 0
    for element in elements:
        p = element.position
        yield last, p, None
        yield p, p + 1, element
        last = p + 1
    yield last, length, None

class _ElementIterator(runlist.RunIterator):
    def __init__(self, elements, length):
        self.next = _iter_elements(elements, length).next
        self.start, self.end, self.value = self.next()

class _FontStyleRunsRangeIterator(object):
    # XXX subclass runlist
    def __init__(self, font_names, font_sizes, bolds, italics, dpi):
        self.zip_iter = runlist.ZipRunIterator(
            (font_names, font_sizes, bolds, italics))
        self.dpi = dpi

    def ranges(self, start, end):
        from pyglet import font
        for start, end, styles in self.zip_iter.ranges(start, end):
            font_name, font_size, bold, italic = styles
            ft = font.load(font_name, font_size,
                           bold=bool(bold), italic=bool(italic),
                           dpi=self.dpi)
            yield start, end, ft

    def __getitem__(self, index):
        from pyglet import font
        font_name, font_size, bold, italic = self.zip_iter[index]
        return font.load(font_name, font_size,
                         bold=bool(bold), italic=bool(italic),
                         dpi=self.dpi)

class _NoStyleRangeIterator(object):
    # XXX subclass runlist
    def ranges(self, start, end):
        yield start, end, None

    def __getitem__(self, index):
        return None
_no_style_range_iterator = _NoStyleRangeIterator()

########NEW FILE########
__FILENAME__ = attributed
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Extensible attributed text format for representing pyglet formatted
documents.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import operator
import parser
import re
import token

import pyglet

_pattern = re.compile(r'''
    (?P<escape_hex>\{\#x(?P<escape_hex_val>[0-9a-fA-F]+)\})
  | (?P<escape_dec>\{\#(?P<escape_dec_val>[0-9]+)\})
  | (?P<escape_lbrace>\{\{)
  | (?P<escape_rbrace>\}\})
  | (?P<attr>\{
        (?P<attr_name>[^ \{\}]+)\s+
        (?P<attr_val>[^\}]+)\})
  | (?P<nl_hard1>\n(?=[ \t]))
  | (?P<nl_hard2>\{\}\n)
  | (?P<nl_soft>\n(?=\S))
  | (?P<nl_para>\n\n+)
  | (?P<text>[^\{\}\n]+)
    ''', re.VERBOSE | re.DOTALL)

class AttributedTextDecoder(pyglet.text.DocumentDecoder):
    def decode(self, text, location=None):
        self.doc = pyglet.text.document.FormattedDocument()

        self.length = 0
        self.attributes = {}
        next_trailing_space = True
        trailing_newline = True

        for m in _pattern.finditer(text):
            group = m.lastgroup
            trailing_space = True
            if group == 'text':
                t = m.group('text')
                self.append(t)
                trailing_space = t.endswith(' ')
                trailing_newline = False
            elif group == 'nl_soft':
                if not next_trailing_space:
                    self.append(' ')
                trailing_newline = False
            elif group in ('nl_hard1', 'nl_hard2'):
                self.append('\n')
                trailing_newline = True
            elif group == 'nl_para':
                self.append(m.group('nl_para'))
                trailing_newline = True
            elif group == 'attr':
                try:
                    ast = parser.expr(m.group('attr_val'))
                    if self.safe(ast):
                        val = eval(ast.compile())
                    else:
                        val = None
                except (parser.ParserError, SyntaxError):
                    val = None
                name = m.group('attr_name')
                if name[0] == '.':
                    if trailing_newline:
                        self.attributes[name[1:]] = val
                    else:
                        self.doc.set_paragraph_style(self.length, self.length,
                                                     {name[1:]: val})
                else:
                    self.attributes[name] = val
            elif group == 'escape_dec':
                self.append(unichr(int(m.group('escape_dec_val'))))
            elif group == 'escape_hex':
                self.append(unichr(int(m.group('escape_hex_val'), 16)))
            elif group == 'escape_lbrace':
                self.append('{')
            elif group == 'escape_rbrace':
                self.append('}')
            next_trailing_space = trailing_space

        return self.doc

    def append(self, text):
        self.doc.insert_text(self.length, text, self.attributes)
        self.length += len(text)
        self.attributes.clear()

    _safe_names = ('True', 'False', 'None')

    def safe(self, ast):
        tree = ast.totuple()
        return self.safe_node(tree)

    def safe_node(self, node):
        if token.ISNONTERMINAL(node[0]):
            return reduce(operator.and_, map(self.safe_node, node[1:]))
        elif node[0] == token.NAME:
            return node[1] in self._safe_names
        else:
            return True

########NEW FILE########
__FILENAME__ = html
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Decode HTML into attributed text.

A subset of HTML 4.01 Transitional is implemented.  The following elements are
supported fully::

    B BLOCKQUOTE BR CENTER CODE DD DIR DL EM FONT H1 H2 H3 H4 H5 H6 I IMG KBD
    LI MENU OL P PRE Q SAMP STRONG SUB SUP TT U UL VAR

The mark (bullet or number) of a list item is separated from the body of the
list item with a tab, as the pyglet document model does not allow
out-of-stream text.  This means lists display as expected, but behave a little
oddly if edited.

No CSS styling is supported.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import HTMLParser
import htmlentitydefs
import re

import pyglet
from pyglet.text.formats import structured

def _hex_color(val):
    return [(val >> 16) & 0xff, (val >> 8) & 0xff, val & 0xff, 255]

_color_names = {
    'black':    _hex_color(0x000000),
    'silver':   _hex_color(0xc0c0c0),
    'gray':     _hex_color(0x808080),
    'white':    _hex_color(0xffffff),
    'maroon':   _hex_color(0x800000),
    'red':      _hex_color(0xff0000),
    'purple':   _hex_color(0x800080),
    'fucsia':   _hex_color(0x008000),
    'green':    _hex_color(0x00ff00),
    'lime':     _hex_color(0xffff00),
    'olive':    _hex_color(0x808000),
    'yellow':   _hex_color(0xff0000),
    'navy':     _hex_color(0x000080),
    'blue':     _hex_color(0x0000ff),
    'teal':     _hex_color(0x008080),
    'aqua':     _hex_color(0x00ffff),
}

def _parse_color(value):
    if value.startswith('#'):
        return _hex_color(int(value[1:], 16))
    else:
        try:
            return _color_names[value.lower()]
        except KeyError:
            raise ValueError()

_whitespace_re = re.compile(u'[\u0020\u0009\u000c\u200b\r\n]+', re.DOTALL)

_metadata_elements = ['head', 'title']

_block_elements = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                   'ul', 'ol', 'dir', 'menu',
                   'pre', 'dl', 'div', 'center',
                   'noscript', 'noframes', 'blockquote', 'form',
                   'isindex', 'hr', 'table', 'fieldset', 'address',
                    # Incorrect, but we treat list items as blocks:
                   'li', 'dd', 'dt', ]


_block_containers = ['_top_block',
                     'body', 'div', 'center', 'object', 'applet',
                     'blockquote', 'ins', 'del', 'dd', 'li', 'form',
                     'fieldset', 'button', 'th', 'td', 'iframe', 'noscript',
                     'noframes',
                     # Incorrect, but we treat list items as blocks:
                     'ul', 'ol', 'dir', 'menu', 'dl']


class HTMLDecoder(HTMLParser.HTMLParser, structured.StructuredTextDecoder):
    '''Decoder for HTML documents.
    '''
    #: Default style attributes for unstyled text in the HTML document.
    #:
    #: :type: dict
    default_style = {
        'font_name': 'Times New Roman',
        'font_size': 12,
        'margin_bottom': '12pt',
    }

    #: Map HTML font sizes to actual font sizes, in points.
    #:
    #: :type: dict
    font_sizes = {
        1: 8,
        2: 10,
        3: 12,
        4: 14,
        5: 18,
        6: 24,
        7: 48
    }

    def decode_structured(self, text, location):
        self.location = location
        self._font_size_stack = [3]
        self.list_stack.append(structured.UnorderedListBuilder({}))
        self.strip_leading_space = True
        self.block_begin = True
        self.need_block_begin = False
        self.element_stack = ['_top_block']
        self.in_metadata = False
        self.in_pre = False

        self.push_style('_default', self.default_style)

        self.feed(text)
        self.close()

    def get_image(self, filename):
        return pyglet.image.load(filename, file=self.location.open(filename))

    def prepare_for_data(self):
        if self.need_block_begin:
            self.add_text('\n')
            self.block_begin = True
            self.need_block_begin = False

    def handle_data(self, data):
        if self.in_metadata:
            return

        if self.in_pre:
            self.add_text(data)
        else:
            data = _whitespace_re.sub(' ', data)
            if data.strip():
                self.prepare_for_data()
                if self.block_begin or self.strip_leading_space:
                    data = data.lstrip()
                    self.block_begin = False
                self.add_text(data)
            self.strip_leading_space = data.endswith(' ')

    def handle_starttag(self, tag, case_attrs):
        if self.in_metadata:
            return

        element = tag.lower()
        attrs = {}
        for key, value in case_attrs:
            attrs[key.lower()] = value

        if element in _metadata_elements:
            self.in_metadata = True
        elif element in _block_elements:
            # Pop off elements until we get to a block container.
            while self.element_stack[-1] not in _block_containers:
                self.handle_endtag(self.element_stack[-1])
            if not self.block_begin:
                self.add_text('\n')
                self.block_begin = True
                self.need_block_begin = False
        self.element_stack.append(element)

        style = {}
        if element in ('b', 'strong'):
            style['bold'] = True
        elif element in ('i', 'em', 'var'):
            style['italic'] = True
        elif element in ('tt', 'code', 'samp', 'kbd'):
            style['font_name'] = 'Courier New'
        elif element == 'u':
            color = self.current_style.get('color')
            if color is None:
                color = [0, 0, 0, 255]
            style['underline'] = color
        elif element == 'font':
            if 'face' in attrs:
                style['font_name'] = attrs['face'].split(',')
            if 'size' in attrs:
                size = attrs['size']
                try:
                    if size.startswith('+'):
                        size = self._font_size_stack[-1] + int(size[1:])
                    elif size.startswith('-'):
                        size = self._font_size_stack[-1] - int(size[1:])
                    else:
                        size = int(size)
                except ValueError:
                    size = 3
                self._font_size_stack.append(size)
                if size in self.font_sizes:
                    style['font_size'] = self.font_sizes.get(size, 3)
            else:
                self._font_size_stack.append(self._font_size_stack[-1])
            if 'color' in attrs:
                try:
                    style['color'] = _parse_color(attrs['color'])
                except ValueError:
                    pass
        elif element == 'sup':
            size = self._font_size_stack[-1] - 1
            style['font_size'] = self.font_sizes.get(size, 1)
            style['baseline'] = '3pt'
        elif element == 'sub':
            size = self._font_size_stack[-1] - 1
            style['font_size'] = self.font_sizes.get(size, 1)
            style['baseline'] = '-3pt'
        elif element == 'h1':
            style['font_size'] = 24
            style['bold'] = True
            style['align'] = 'center'
        elif element == 'h2':
            style['font_size'] = 18
            style['bold'] = True
        elif element == 'h3':
            style['font_size'] = 16
            style['bold'] = True
        elif element == 'h4':
            style['font_size'] = 14
            style['bold'] = True
        elif element == 'h5':
            style['font_size'] = 12
            style['bold'] = True
        elif element == 'h6':
            style['font_size'] = 12
            style['italic'] = True
        elif element == 'br':
            self.add_text(u'\u2028')
            self.strip_leading_space = True
        elif element == 'p':
            if attrs.get('align') in ('left', 'center', 'right'):
                style['align'] = attrs['align']
        elif element == 'center':
            style['align'] = 'center'
        elif element == 'pre':
            style['font_name'] = 'Courier New'
            style['margin_bottom'] = 0
            self.in_pre = True
        elif element == 'blockquote':
            left_margin = self.current_style.get('margin_left') or 0
            right_margin = self.current_style.get('margin_right') or 0
            style['margin_left'] = left_margin + 60
            style['margin_right'] = right_margin + 60
        elif element == 'q':
            self.handle_data(u'\u201c')
        elif element == 'ol':
            try:
                start = int(attrs.get('start', 1))
            except ValueError:
                start = 1
            format = attrs.get('type', '1') + '.'
            builder = structured.OrderedListBuilder(start, format)
            builder.begin(self, style)
            self.list_stack.append(builder)
        elif element in ('ul', 'dir', 'menu'):
            type = attrs.get('type', 'disc').lower()
            if type == 'circle':
                mark = u'\u25cb'
            elif type == 'square':
                mark = u'\u25a1'
            else:
                mark = u'\u25cf'
            builder = structured.UnorderedListBuilder(mark)
            builder.begin(self, style)
            self.list_stack.append(builder)
        elif element == 'li':
            self.list_stack[-1].item(self, style)
            self.strip_leading_space = True
        elif element == 'dl':
            style['margin_bottom'] = 0
        elif element == 'dd':
            left_margin = self.current_style.get('margin_left') or 0
            style['margin_left'] = left_margin + 30
        elif element == 'img':
            image = self.get_image(attrs.get('src'))
            if image:
                width = attrs.get('width')
                if width:
                    width = int(width)
                height = attrs.get('height')
                if height:
                    height = int(height)
                self.prepare_for_data()
                self.add_element(structured.ImageElement(image, width, height))
                self.strip_leading_space = False

        self.push_style(element, style)

    def handle_endtag(self, tag):
        element = tag.lower()
        if element not in self.element_stack:
            return

        self.pop_style(element)
        while self.element_stack.pop() != element:
            pass

        if element in _metadata_elements:
            self.in_metadata = False
        elif element in _block_elements:
            self.block_begin = False
            self.need_block_begin = True

        if element == 'font' and len(self._font_size_stack) > 1:
            self._font_size_stack.pop()
        elif element == 'pre':
            self.in_pre = False
        elif element == 'q':
            self.handle_data(u'\u201d')
        elif element in ('ul', 'ol'):
            if len(self.list_stack) > 1:
                self.list_stack.pop()

    def handle_entityref(self, name):
        if name in htmlentitydefs.name2codepoint:
            self.handle_data(unichr(htmlentitydefs.name2codepoint[name]))

    def handle_charref(self, name):
        name = name.lower()
        try:
            if name.startswith('x'):
                self.handle_data(unichr(int(name[1:], 16)))
            else:
                self.handle_data(unichr(int(name)))
        except ValueError:
            pass

########NEW FILE########
__FILENAME__ = plaintext
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Plain text decoder.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import pyglet

class PlainTextDecoder(pyglet.text.DocumentDecoder):
    def decode(self, text, location=None):
        document = pyglet.text.document.UnformattedDocument()
        document.insert_text(0, text)
        return document

########NEW FILE########
__FILENAME__ = structured
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Base class for structured (hierarchical) document formats.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import re

import pyglet

class ImageElement(pyglet.text.document.InlineElement):
    def __init__(self, image, width=None, height=None):
        self.image = image.get_texture()
        self.width = width is None and image.width or width
        self.height = height is None and image.height or height
        self.vertex_lists = {}

        anchor_y = self.height / image.height * image.anchor_y
        ascent = max(0, self.height - anchor_y)
        descent = min(0, -anchor_y)
        super(ImageElement, self).__init__(ascent, descent, self.width)

    def place(self, layout, x, y):
        group = pyglet.graphics.TextureGroup(self.image.texture,
                                             layout.top_group)
        x1 = x
        y1 = y + self.descent
        x2 = x + self.width
        y2 = y + self.height + self.descent
        vertex_list = layout.batch.add(4, pyglet.gl.GL_QUADS, group,
            ('v2i', (x1, y1, x2, y1, x2, y2, x1, y2)),
            ('c3B', (255, 255, 255) * 4),
            ('t3f', self.image.tex_coords))
        self.vertex_lists[layout] = vertex_list

    def remove(self, layout):
        self.vertex_lists[layout].delete()
        del self.vertex_lists[layout]

def _int_to_roman(input):
    # From http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/81611
    if not 0 < input < 4000:
        raise ValueError, "Argument must be between 1 and 3999"
    ints = (1000, 900,  500, 400, 100,  90, 50,  40, 10,  9,   5,   4,  1)
    nums = ('M',  'CM', 'D', 'CD','C', 'XC','L','XL','X','IX','V','IV','I')
    result = ""
    for i in range(len(ints)):
        count = int(input / ints[i])
        result += nums[i] * count
        input -= ints[i] * count
    return result

class ListBuilder(object):
    def begin(self, decoder, style):
        '''Begin a list.

        :Parameters:
            `decoder` : `StructuredTextDecoder`
                Decoder.
            `style` : dict
                Style dictionary that applies over the entire list.

        '''
        left_margin = decoder.current_style.get('margin_left') or 0
        tab_stops = decoder.current_style.get('tab_stops')
        if tab_stops:
            tab_stops = list(tab_stops)
        else:
            tab_stops = []
        tab_stops.append(left_margin + 50)
        style['margin_left'] = left_margin + 50
        style['indent'] = -30
        style['tab_stops'] = tab_stops

    def item(self, decoder, style, value=None):
        '''Begin a list item.

        :Parameters:
            `decoder` : `StructuredTextDecoder`
                Decoder.
            `style` : dict
                Style dictionary that applies over the list item.
            `value` : str
                Optional value of the list item.  The meaning is list-type
                dependent.

        '''
        mark = self.get_mark(value)
        if mark:
            decoder.add_text(mark)
        decoder.add_text('\t')

    def get_mark(self, value=None):
        '''Get the mark text for the next list item.

        :Parameters:
            `value` : str
                Optional value of the list item.  The meaning is list-type
                dependent.

        :rtype: str
        '''
        return ''

class UnorderedListBuilder(ListBuilder):
    def __init__(self, mark):
        '''Create an unordered list with constant mark text.

        :Parameters:
            `mark` : str
                Mark to prepend to each list item.

        '''
        self.mark = mark


    def get_mark(self, value):
        return self.mark

class OrderedListBuilder(ListBuilder):
    format_re = re.compile('(.*?)([1aAiI])(.*)')

    def __init__(self, start, format):
        '''Create an ordered list with sequentially numbered mark text.

        The format is composed of an optional prefix text, a numbering
        scheme character followed by suffix text. Valid numbering schemes
        are:

        ``1``
            Decimal Arabic
        ``a``
            Lowercase alphanumeric
        ``A``
            Uppercase alphanumeric
        ``i``
            Lowercase Roman
        ``I``
            Uppercase Roman

        Prefix text may typically be ``(`` or ``[`` and suffix text is
        typically ``.``, ``)`` or empty, but either can be any string.

        :Parameters:
            `start` : int
                First list item number.
            `format` : str
                Format style, for example ``"1."``.

        '''
        self.next_value = start

        self.prefix, self.numbering, self.suffix = self.format_re.match(format).groups()
        assert self.numbering in '1aAiI'

    def get_mark(self, value):
        if value is None:
            value = self.next_value
        self.next_value = value + 1
        if self.numbering in 'aA':
            try:
                mark = 'abcdefghijklmnopqrstuvwxyz'[value - 1]
            except ValueError:
                mark = '?'
            if self.numbering == 'A':
                mark = mark.upper()
            return '%s%s%s' % (self.prefix, mark, self.suffix)
        elif self.numbering in 'iI':
            try:
                mark = _int_to_roman(value)
            except ValueError:
                mark = '?'
            if self.numbering == 'i':
                mark = mark.lower()
            return '%s%s%s' % (self.prefix, mark, self.suffix)
        else:
            return '%s%d%s' % (self.prefix, value, self.suffix)

class StructuredTextDecoder(pyglet.text.DocumentDecoder):
    def decode(self, text, location=None):
        self.len_text = 0
        self.current_style = {}
        self.next_style = {}
        self.stack = []
        self.list_stack = []
        self.document = pyglet.text.document.FormattedDocument()
        if location is None:
            location = pyglet.resource.FileLocation('')
        self.decode_structured(text, location)
        return self.document

    def decode_structured(self, text, location):
        raise NotImplementedError('abstract')

    def push_style(self, key, styles):
        old_styles = {}
        for name in styles.keys():
            old_styles[name] = self.current_style.get(name)
        self.stack.append((key, old_styles))
        self.current_style.update(styles)
        self.next_style.update(styles)

    def pop_style(self, key):
        # Don't do anything if key is not in stack
        for match, _ in self.stack:
            if key == match:
                break
        else:
            return

        # Remove all innermost elements until key is closed.
        while True:
            match, old_styles = self.stack.pop()
            self.next_style.update(old_styles)
            self.current_style.update(old_styles)
            if match == key:
                break

    def add_text(self, text):
        self.document.insert_text(self.len_text, text, self.next_style)
        self.next_style.clear()
        self.len_text += len(text)

    def add_element(self, element):
        self.document.insert_element(self.len_text, element, self.next_style)
        self.next_style.clear()
        self.len_text += 1

########NEW FILE########
__FILENAME__ = layout
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
# $Id: $

'''Render simple text and formatted documents efficiently.

Three layout classes are provided:

`TextLayout`
    The entire document is laid out before it is rendered.  The layout will
    be grouped with other layouts in the same batch (allowing for efficient
    rendering of multiple layouts).

    Any change to the layout or document,
    and even querying some properties, will cause the entire document
    to be laid out again.

`ScrollableTextLayout`
    Based on `TextLayout`.

    A separate group is used for layout which crops the contents of the
    layout to the layout rectangle.  Additionally, the contents of the
    layout can be "scrolled" within that rectangle with the ``view_x`` and
    ``view_y`` properties.

`IncrementalTextLayout`
    Based on `ScrollableTextLayout`.

    When the layout or document are modified, only the affected regions
    are laid out again.  This permits efficient interactive editing and
    styling of text.

    Only the visible portion of the layout is actually rendered; as the
    viewport is scrolled additional sections are rendered and discarded as
    required.  This permits efficient viewing and editing of large documents.

    Additionally, this class provides methods for locating the position of a
    caret in the document, and for displaying interactive text selections.

All three layout classes can be used with either `UnformattedDocument` or
`FormattedDocument`, and can be either single-line or ``multiline``.  The
combinations of these options effectively provides 12 different text display
possibilities.

Style attributes
================

The following character style attribute names are recognised by the layout
classes.  Data types and units are as specified.

Where an attribute is marked "as a distance" the value is assumed to be
in pixels if given as an int or float, otherwise a string of the form
``"0u"`` is required, where ``0`` is the distance and ``u`` is the unit; one
of ``"px"`` (pixels), ``"pt"`` (points), ``"pc"`` (picas), ``"cm"``
(centimeters), ``"mm"`` (millimeters) or ``"in"`` (inches).  For example,
``"14pt"`` is the distance covering 14 points, which at the default DPI of 96
is 18 pixels.

``font_name``
    Font family name, as given to `pyglet.font.load`.
``font_size``
    Font size, in points.
``bold``
    Boolean.
``italic``
    Boolean.
``underline``
    4-tuple of ints in range (0, 255) giving RGBA underline color, or None
    (default) for no underline.
``kerning``
    Additional space to insert between glyphs, as a distance.  Defaults to 0.
``baseline``
    Offset of glyph baseline from line baseline, as a distance.  Positive
    values give a superscript, negative values give a subscript.  Defaults to
    0.
``color``
    4-tuple of ints in range (0, 255) giving RGBA text color
``background_color``
    4-tuple of ints in range (0, 255) giving RGBA text background color; or
    ``None`` for no background fill.

The following paragraph style attribute names are recognised.  Note
that paragraph styles are handled no differently from character styles by the
document: it is the application's responsibility to set the style over an
entire paragraph, otherwise results are undefined.

``align``
    ``left`` (default), ``center`` or ``right``.
``indent``
    Additional horizontal space to insert before the first glyph of the
    first line of a paragraph, as a distance.
``leading``
    Additional space to insert between consecutive lines within a paragraph,
    as a distance.  Defaults to 0.
``line_spacing``
    Distance between consecutive baselines in a paragraph, as a distance.
    Defaults to ``None``, which automatically calculates the tightest line
    spacing for each line based on the font ascent and descent.
``margin_left``
    Left paragraph margin, as a distance.
``margin_right``
    Right paragraph margin, as a distance.
``margin_top``
    Margin above paragraph, as a distance.
``margin_bottom``
    Margin below paragraph, as a distance.  Adjacent margins do not collapse.
``tab_stops``
    List of horizontal tab stops, as distances, measured from the left edge of
    the text layout.  Defaults to the empty list.  When the tab stops
    are exhausted, they implicitly continue at 50 pixel intervals.
``wrap``
    Boolean.  If True (the default), text wraps within the width of the layout.

Other attributes can be used to store additional style information within the
document; they will be ignored by the built-in text classes.

:since: pyglet 1.1
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

import re
import sys

from pyglet.gl import glEnable, glDisable, glBlendFunc, glClipPlane
from pyglet.gl import glPopAttrib, glPushAttrib, glTranslatef, glBindTexture
from pyglet.gl import GL_BLEND, GLdouble, GL_LINES, GL_QUADS, GL_SRC_ALPHA
from pyglet.gl import GL_ENABLE_BIT, GL_TEXTURE_2D, GL_CLIP_PLANE0, GL_CLIP_PLANE1
from pyglet.gl import GL_CLIP_PLANE2, GL_CLIP_PLANE3, GL_CURRENT_BIT
from pyglet.gl import GL_TRANSFORM_BIT, GL_ONE_MINUS_SRC_ALPHA

from pyglet import event
from pyglet import graphics
from pyglet.text import runlist

from pyglet.font.base import _grapheme_break

_is_epydoc = hasattr(sys, 'is_epydoc') and sys.is_epydoc

_distance_re = re.compile(r'([-0-9.]+)([a-zA-Z]+)')


def _parse_distance(distance, dpi):
    '''Parse a distance string and return corresponding distance in pixels as
    an integer.
    '''
    if isinstance(distance, int):
        return distance
    elif isinstance(distance, float):
        return int(distance)

    match = _distance_re.match(distance)
    assert match, 'Could not parse distance %s' % (distance)
    if not match:
        return 0

    value, unit = match.groups()
    value = float(value)
    if unit == 'px':
        return int(value)
    elif unit == 'pt':
        return int(value * dpi / 72.0)
    elif unit == 'pc':
        return int(value * dpi / 6.0)
    elif unit == 'in':
        return int(value * dpi)
    elif unit == 'mm':
        return int(value * dpi * 0.0393700787)
    elif unit == 'cm':
        return int(value * dpi * 0.393700787)
    else:
        assert False, 'Unknown distance unit %s' % unit


class _Line(object):
    align = 'left'

    margin_left = 0
    margin_right = 0

    length = 0

    ascent = 0
    descent = 0
    width = 0
    paragraph_begin = False
    paragraph_end = False

    x = None
    y = None

    def __init__(self, start):
        self.vertex_lists = []
        self.start = start
        self.boxes = []

    def __repr__(self):
        return '_Line(%r)' % self.boxes

    def add_box(self, box):
        self.boxes.append(box)
        self.length += box.length
        self.ascent = max(self.ascent, box.ascent)
        self.descent = min(self.descent, box.descent)
        self.width += box.advance

    def delete(self, layout):
        for list in self.vertex_lists:
            list.delete()
        self.vertex_lists = []

        for box in self.boxes:
            box.delete(layout)


class _LayoutContext(object):
    def __init__(self, layout, document, colors_iter, shadow_iter, background_iter):
        self.colors_iter = colors_iter
        underline_iter = document.get_style_runs('underline')
        self.shadow_iter = shadow_iter
        self.decoration_iter = runlist.ZipRunIterator((
            background_iter, underline_iter,
        ))
        self.baseline_iter = runlist.FilteredRunIterator(
            document.get_style_runs('baseline'),
            lambda value: value is not None, 0)


class _StaticLayoutContext(_LayoutContext):
    def __init__(self, layout, document, colors_iter, shadow_iter, background_iter):
        super(_StaticLayoutContext, self).__init__(layout, document,
                                                  colors_iter, shadow_iter,
                                                  background_iter)
        self.vertex_lists = layout._vertex_lists
        self.boxes = layout._boxes

    def add_list(self, list):
        self.vertex_lists.append(list)

    def add_box(self, box):
        self.boxes.append(box)


class _IncrementalLayoutContext(_LayoutContext):
    line = None

    def add_list(self, list):
        self.line.vertex_lists.append(list)

    def add_box(self, box):
        pass


class _AbstractBox(object):
    owner = None

    def __init__(self, ascent, descent, advance, length):
        self.ascent = ascent
        self.descent = descent
        self.advance = advance
        self.length = length

    def place(self, layout, i, x, y):
        raise NotImplementedError('abstract')

    def delete(self, layout):
        raise NotImplementedError('abstract')

    def get_position_in_box(self, x):
        raise NotImplementedError('abstract')

    def get_point_in_box(self, position):
        raise NotImplementedError('abstract')


class _GlyphBox(_AbstractBox):
    def __init__(self, owner, font, glyphs, advance):
        '''Create a run of glyphs sharing the same texture.

        :Parameters:
            `owner` : `pyglet.image.Texture`
                Texture of all glyphs in this run.
            `font` : `pyglet.font.base.Font`
                Font of all glyphs in this run.
            `glyphs` : list of (int, `pyglet.font.base.Glyph`)
                Pairs of ``(kern, glyph)``, where ``kern`` gives horizontal
                displacement of the glyph in pixels (typically 0).
            `advance` : int
                Width of glyph run; must correspond to the sum of advances
                and kerns in the glyph list.

        '''
        super(_GlyphBox, self).__init__(
            font.ascent, font.descent, advance, len(glyphs))
        assert owner
        self.owner = owner
        self.font = font
        self.glyphs = glyphs
        self.advance = advance

    def place(self, layout, i, x, y, context):
        assert self.glyphs
        try:
            group = layout.groups[self.owner]
        except KeyError:
            group = layout.groups[self.owner] = \
                TextLayoutTextureGroup(self.owner, layout.foreground_group)

        n_glyphs = self.length
        vertices = []
        tex_coords = []
        colors = []
        shadow_vertices = []
        shadow_tex_coords = []
        shadow_colors = []
        n_shadows = 0
        x1 = x
        iterator = runlist.ZipRunIterator((
            context.baseline_iter,
            context.colors_iter,
            context.shadow_iter,
        ))
        for start, end, (baseline, color, shadow) in iterator.ranges(i, i+n_glyphs):
            baseline = layout._parse_distance(baseline)
            assert len(self.glyphs[start - i:end - i]) == end - start
            for kern, glyph in self.glyphs[start - i:end - i]:
                x1 += kern
                v0, v1, v2, v3 = glyph.vertices
                v0 += x1
                v2 += x1
                v1 += y + baseline
                v3 += y + baseline
                vertices.extend([v0, v1, v2, v1, v2, v3, v0, v3])
                t = glyph.tex_coords
                tex_coords.extend(t)

                if shadow is not None:
                    # XXX: This assumes shadow glyphs are in the
                    #      same owner with normal glyph
                    stype = shadow[0]
                    if stype:
                        scolor = shadow[1:]
                        assert len(scolor) == 4
                        sglyph = glyph.shadows[stype]

                        v0, v1, v2, v3 = sglyph.vertices
                        v0 += x1
                        v2 += x1
                        v1 += y + baseline
                        v3 += y + baseline
                        shadow_vertices.extend([v0, v1, v2, v1, v2, v3, v0, v3])
                        t = sglyph.tex_coords
                        shadow_tex_coords.extend(t)
                        shadow_colors.extend(scolor * 4)

                        n_shadows += 1

                x1 += glyph.advance

            color = color or (0, 0, 0, 255)
            colors.extend(color * ((end - start) * 4))

        if n_shadows:
            slist = layout.batch.add(n_shadows * 4, GL_QUADS, group,
                ('v2f/dynamic', shadow_vertices),
                ('t3f/dynamic', shadow_tex_coords),
                ('c4B/dynamic', shadow_colors))
            context.add_list(slist)

        list = layout.batch.add(n_glyphs * 4, GL_QUADS, group,
            ('v2f/dynamic', vertices),
            ('t3f/dynamic', tex_coords),
            ('c4B/dynamic', colors))
        context.add_list(list)

        # Decoration (background color and underline)
        #
        # Should iterate over baseline too, but in practice any sensible
        # change in baseline will correspond with a change in font size,
        # and thus glyph run as well.  So we cheat and just use whatever
        # baseline was seen last.
        background_vertices = []
        background_colors = []
        underline_vertices = []
        underline_colors = []

        y1 = y + self.descent + baseline
        y2 = y + self.ascent + baseline
        x1 = x
        for start, end, decoration in context.decoration_iter.ranges(i, i+n_glyphs):
            bg, underline = decoration
            x2 = x1
            for kern, glyph in self.glyphs[start - i:end - i]:
                x2 += glyph.advance + kern

            if bg is not None:
                background_vertices.extend(
                    [x1, y1, x2, y1, x2, y2, x1, y2])
                background_colors.extend(bg * 4)

            if underline is not None:
                underline_vertices.extend(
                    [x1, y + baseline - 2, x2, y + baseline - 2])
                underline_colors.extend(underline * 2)

            x1 = x2

        if background_vertices:
            background_list = layout.batch.add(
                len(background_vertices) // 2, GL_QUADS,
                layout.background_group,
                ('v2f/dynamic', background_vertices),
                ('c4B/dynamic', background_colors))
            context.add_list(background_list)

        if underline_vertices:
            underline_list = layout.batch.add(
                len(underline_vertices) // 2, GL_LINES,
                layout.foreground_decoration_group,
                ('v2f/dynamic', underline_vertices),
                ('c4B/dynamic', underline_colors))
            context.add_list(underline_list)

    def delete(self, layout):
        pass

    def get_point_in_box(self, position):
        x = 0
        for (kern, glyph) in self.glyphs:
            if position == 0:
                break
            position -= 1
            x += glyph.advance + kern
        return x

    def get_position_in_box(self, x):
        position = 0
        last_glyph_x = 0
        for kern, glyph in self.glyphs:
            last_glyph_x += kern
            if last_glyph_x + glyph.advance / 2 > x:
                return position
            position += 1
            last_glyph_x += glyph.advance
        return position

    def __repr__(self):
        return '_GlyphBox(%r)' % self.glyphs


class _InlineElementBox(_AbstractBox):
    def __init__(self, element):
        '''Create a glyph run holding a single element.
        '''
        super(_InlineElementBox, self).__init__(
            element.ascent, element.descent, element.advance, 1)
        self.element = element
        self.placed = False

    def place(self, layout, i, x, y, context):
        self.element.place(layout, x, y)
        self.placed = True
        context.add_box(self)

    def delete(self, layout):
        # font == element
        if self.placed:
            self.element.remove(layout)
            self.placed = False

    def get_point_in_box(self, position):
        if position == 0:
            return 0
        else:
            return self.advance

    def get_position_in_box(self, x):
        if x < self.advance / 2:
            return 0
        else:
            return 1

    def __repr__(self):
        return '_InlineElementBox(%r)' % self.element


class _InvalidRange(object):
    def __init__(self):
        self.start = sys.maxint
        self.end = 0

    def insert(self, start, length):
        if self.start >= start:
            self.start += length
        if self.end >= start:
            self.end += length
        self.invalidate(start, start + length)

    def delete(self, start, end):
        if self.start > end:
            self.start -= end - start
        elif self.start > start:
            self.start = start
        if self.end > end:
            self.end -= end - start
        elif self.end > start:
            self.end = start

    def invalidate(self, start, end):
        if end <= start:
            return
        self.start = min(self.start, start)
        self.end = max(self.end, end)

    def validate(self):
        start, end = self.start, self.end
        self.start = sys.maxint
        self.end = 0
        return start, end

    def is_invalid(self):
        return self.end > self.start

# Text group hierarchy
#
# top_group                     [Scrollable]TextLayoutGroup(Group)
#   background_group            OrderedGroup(0)
#   foreground_group            TextLayoutForegroundGroup(OrderedGroup(1))
#     [font textures]           TextLayoutTextureGroup(Group)
#     [...]                     TextLayoutTextureGroup(Group)
#   foreground_decoration_group
#                       TextLayoutForegroundDecorationGroup(OrderedGroup(2))


class TextLayoutGroup(graphics.Group):
    '''Top-level rendering group for `TextLayout`.

    The blend function is set for glyph rendering (``GL_SRC_ALPHA`` /
    ``GL_ONE_MINUS_SRC_ALPHA``).  The group is shared by all `TextLayout`
    instances as it has no internal state.
    '''
    def set_state(self):
        glPushAttrib(GL_ENABLE_BIT | GL_CURRENT_BIT)
        glEnable(GL_BLEND)
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)

    def unset_state(self):
        glPopAttrib()


class ScrollableTextLayoutGroup(graphics.Group):
    '''Top-level rendering group for `ScrollableTextLayout`.

    The group maintains internal state for setting the clipping planes and
    view transform for scrolling.  Because the group has internal state
    specific to the text layout, the group is never shared.
    '''
    _clip_x = 0
    _clip_y = 0
    _clip_width = 0
    _clip_height = 0
    _view_x = 0
    _view_y = 0
    translate_x = 0  # x - view_x
    translate_y = 0  # y - view_y

    def set_state(self):
        glPushAttrib(GL_ENABLE_BIT | GL_TRANSFORM_BIT | GL_CURRENT_BIT)
        glEnable(GL_BLEND)
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
        # Disable clipping planes to check culling.
        glEnable(GL_CLIP_PLANE0)
        glEnable(GL_CLIP_PLANE1)
        glEnable(GL_CLIP_PLANE2)
        glEnable(GL_CLIP_PLANE3)
        # Left
        glClipPlane(GL_CLIP_PLANE0, (GLdouble * 4)(
                    1, 0, 0, -(self._clip_x - 1)))
        # Top
        glClipPlane(GL_CLIP_PLANE1, (GLdouble * 4)(
                    0, -1, 0, self._clip_y))
        # Right
        glClipPlane(GL_CLIP_PLANE2, (GLdouble * 4)(
                    -1, 0, 0, self._clip_x + self._clip_width + 1))
        # Bottom
        glClipPlane(GL_CLIP_PLANE3, (GLdouble * 4)(
                    0, 1, 0, -(self._clip_y - self._clip_height)))
        glTranslatef(self.translate_x, self.translate_y, 0)

    def unset_state(self):
        glTranslatef(-self.translate_x, -self.translate_y, 0)
        glPopAttrib()

    def _set_top(self, top):
        self._clip_y = top
        self.translate_y = self._clip_y - self._view_y

    top = property(lambda self: self._clip_y, _set_top,
                   doc='''Top edge of the text layout (measured from the
    bottom of the graphics viewport).

    :type: int
    ''')

    def _set_left(self, left):
        self._clip_x = left
        self.translate_x = self._clip_x - self._view_x

    left = property(lambda self: self._clip_x, _set_left,
                   doc='''Left edge of the text layout.

    :type: int
    ''')

    def _set_width(self, width):
        self._clip_width = width

    width = property(lambda self: self._clip_width, _set_width,
                     doc='''Width of the text layout.

    :type: int
    ''')

    def _set_height(self, height):
        self._clip_height = height

    height = property(lambda self: self._height, _set_height,
                   doc='''Height of the text layout.

    :type: int
    ''')

    def _set_view_x(self, view_x):
        self._view_x = view_x
        self.translate_x = self._clip_x - self._view_x

    view_x = property(lambda self: self._view_x, _set_view_x,
                   doc='''Horizontal scroll offset.

    :type: int
    ''')

    def _set_view_y(self, view_y):
        self._view_y = view_y
        self.translate_y = self._clip_y - self._view_y

    view_y = property(lambda self: self._view_y, _set_view_y,
                   doc='''Vertical scroll offset.

    :type: int
    ''')

    def __eq__(self, other):
        return self is other

    def __hash__(self):
        return id(self)


class TextLayoutForegroundGroup(graphics.OrderedGroup):
    '''Rendering group for foreground elements (glyphs) in all text layouts.

    The group enables ``GL_TEXTURE_2D``.
    '''
    def set_state(self):
        glEnable(GL_TEXTURE_2D)

    # unset_state not needed, as parent group will pop enable bit


class TextLayoutForegroundDecorationGroup(graphics.OrderedGroup):
    '''Rendering group for decorative elements (e.g., glyph underlines) in all
    text layouts.

    The group disables ``GL_TEXTURE_2D``.
    '''
    def set_state(self):
        glDisable(GL_TEXTURE_2D)

    # unset_state not needed, as parent group will pop enable bit


class TextLayoutTextureGroup(graphics.Group):
    '''Rendering group for a glyph texture in all text layouts.

    The group binds its texture to ``GL_TEXTURE_2D``.  The group is shared
    between all other text layout uses of the same texture.
    '''
    def __init__(self, texture, parent):
        assert texture.target == GL_TEXTURE_2D
        super(TextLayoutTextureGroup, self).__init__(parent)

        self.texture = texture

    def set_state(self):
        glBindTexture(GL_TEXTURE_2D, self.texture.id)

    # unset_state not needed, as next group will either bind a new texture or
    # pop enable bit.

    def __hash__(self):
        return hash((self.texture.id, self.parent))

    def __eq__(self, other):
        return (self.__class__ is other.__class__ and
                self.texture.id == other.texture.id and
                self.parent is other.parent)

    def __repr__(self):
        return '%s(%d, %r)' % (self.__class__.__name__,
                               self.texture.id,
                               self.parent)


class TextLayout(object):
    '''Lay out and display documents.

    This class is intended for displaying documents that do not change
    regularly -- any change will cost some time to lay out the complete
    document again and regenerate all vertex lists.

    The benefit of this class is that texture state is shared between
    all layouts of this class.  The time to draw one `TextLayout` may be
    roughly the same as the time to draw one `IncrementalTextLayout`; but
    drawing ten `TextLayout` objects in one batch is much faster than drawing
    ten incremental or scrollable text layouts.

    `Label` and `HTMLLabel` provide a convenient interface to this class.

    :Ivariables:
        `content_width` : int
            Calculated width of the text in the layout.  This may overflow
            the desired width if word-wrapping failed.
        `content_height` : int
            Calculated height of the text in the layout.
        `top_group` : `Group`
            Top-level rendering group.
        `background_group` : `Group`
            Rendering group for background color.
        `foreground_group` : `Group`
            Rendering group for glyphs.
        `foreground_decoration_group` : `Group`
            Rendering group for glyph underlines.

    '''
    _document = None
    _vertex_lists = ()
    _boxes = ()

    top_group = TextLayoutGroup()
    background_group = graphics.OrderedGroup(0, top_group)
    foreground_group = TextLayoutForegroundGroup(1, top_group)
    foreground_decoration_group = \
        TextLayoutForegroundDecorationGroup(2, top_group)

    _update_enabled = True
    _own_batch = False
    _origin_layout = False  # Lay out relative to origin?  Otherwise to box.

    def __init__(self, document, width=None, height=None,
                 multiline=False, dpi=None, batch=None, group=None):
        '''Create a text layout.

        :Parameters:
            `document` : `AbstractDocument`
                Document to display.
            `width` : int
                Width of the layout in pixels, or None
            `height` : int
                Height of the layout in pixels, or None
            `multiline` : bool
                If False, newline and paragraph characters are ignored, and
                text is not word-wrapped.
            `dpi` : float
                Font resolution; defaults to 96.
            `batch` : `Batch`
                Optional graphics batch to add this layout to.
            `group` : `Group`
                Optional rendering group to parent all groups this text layout
                uses.  Note that layouts with different
                rendered simultaneously in a batch.

        '''
        self.content_width = 0
        self.content_height = 0

        self.groups = {}
        self._init_groups(group)

        if batch is None:
            batch = graphics.Batch()
            self._own_batch = True
        self.batch = batch

        if width is not None:
            self._width = width
        if height is not None:
            self._height = height
        if multiline:
            assert not multiline or width, 'Must specify width with multiline'
            self._multiline = multiline

        if dpi is None:
            dpi = 96
        self._dpi = dpi
        self.document = document

    def _parse_distance(self, distance):
        if distance is None:
            return None
        return _parse_distance(distance, self._dpi)

    def begin_update(self):
        '''Indicate that a number of changes to the layout or document
        are about to occur.

        Changes to the layout or document between calls to `begin_update` and
        `end_update` do not trigger any costly relayout of text.  Relayout of
        all changes is performed when `end_update` is called.

        Note that between the `begin_update` and `end_update` calls, values
        such as `content_width` and `content_height` are undefined (i.e., they
        may or may not be updated to reflect the latest changes).
        '''
        self._update_enabled = False

    def end_update(self):
        '''Perform pending layout changes since `begin_update`.

        See `begin_update`.
        '''
        self._update_enabled = True
        self._update()

    dpi = property(lambda self: self._dpi,
                   doc='''Get DPI used by this layout.

    Read-only.

    :type: float
    ''')

    def delete(self):
        '''Remove this layout from its batch.
        '''
        for vertex_list in self._vertex_lists:
            vertex_list.delete()
        self._vertex_lists = []

        for box in self._boxes:
            box.delete(self)

    def draw(self):
        '''Draw this text layout.

        Note that this method performs very badly if a batch was supplied to
        the constructor.  If you add this layout to a batch, you should
        ideally use only the batch's draw method.
        '''
        if self._own_batch:
            self.batch.draw()
        else:
            self.batch.draw_subset(self._vertex_lists)

    def _init_groups(self, group):
        if group:
            self.top_group = TextLayoutGroup(group)
            self.background_group = graphics.OrderedGroup(0, self.top_group)
            self.foreground_group = TextLayoutForegroundGroup(1, self.top_group)
            self.foreground_decoration_group = \
                TextLayoutForegroundDecorationGroup(2, self.top_group)
        # Otherwise class groups are (re)used.

    def _get_document(self):
        return self._document

    def _set_document(self, document):
        if self._document:
            self._document.remove_handlers(self)
            self._uninit_document()
        document.push_handlers(self)
        self._document = document
        self._init_document()

    document = property(_get_document, _set_document,
                       '''Document to display.

    For `IncrementalTextLayout` it is far more efficient to modify a document
    in-place than to replace the document instance on the layout.

    :type: `AbstractDocument`
    ''')

    def _get_lines(self):
        len_text = len(self._document.text)
        glyphs = self._get_glyphs()
        owner_runs = runlist.RunList(len_text, None)
        self._get_owner_runs(owner_runs, glyphs, 0, len_text)
        lines = [line for line in self._flow_glyphs(glyphs, owner_runs,
                                                    0, len_text)]
        self.content_width = 0
        self._flow_lines(lines, 0, len(lines))
        return lines

    def _update(self):
        if not self._update_enabled:
            return

        for _vertex_list in self._vertex_lists:
            _vertex_list.delete()
        for box in self._boxes:
            box.delete(self)
        self._vertex_lists = []
        self._boxes = []
        self.groups.clear()

        if not self._document or not self._document.text:
            return

        lines = self._get_lines()

        colors_iter = self._document.get_style_runs('color')
        shadow_iter = self._document.get_style_runs('shadow')
        background_iter = self._document.get_style_runs('background_color')

        if self._origin_layout:
            left = top = 0
        else:
            left = self._get_left()
            top = self._get_top(lines)

        context = _StaticLayoutContext(self, self._document,
                                       colors_iter, shadow_iter, background_iter)
        for line in lines:
            self._create_vertex_lists(left + line.x, top + line.y,
                                      line.start, line.boxes, context)

    def _get_left(self):
        if self._multiline:
            width = self._width
        else:
            width = self.content_width

        if self._anchor_x == 'left':
            return self._x
        elif self._anchor_x == 'center':
            return self._x - width // 2
        elif self._anchor_x == 'right':
            return self._x - width
        else:
            assert False, 'Invalid anchor_x'

    def _get_top(self, lines):
        if self._height is None:
            height = self.content_height
            offset = 0
        else:
            height = self._height
            if self._content_valign == 'top':
                offset = 0
            elif self._content_valign == 'bottom':
                offset = max(0, self._height - self.content_height)
            elif self._content_valign == 'center':
                offset = max(0, self._height - self.content_height) // 2
            else:
                assert False, 'Invalid content_valign'

        if self._anchor_y == 'top':
            return self._y - offset
        elif self._anchor_y == 'baseline':
            return self._y + lines[0].ascent - offset
        elif self._anchor_y == 'bottom':
            return self._y + height - offset
        elif self._anchor_y == 'center':
            if len(lines) == 1 and self._height is None:
                # This "looks" more centered than considering all of the
                # descent.
                line = lines[0]
                return self._y + line.ascent // 2 - line.descent // 4
            else:
                return self._y + height // 2 - offset
        else:
            assert False, 'Invalid anchor_y'

    def _init_document(self):
        self._update()

    def _uninit_document(self):
        pass

    def on_insert_text(self, start, text):
        '''Event handler for `AbstractDocument.on_insert_text`.

        The event handler is bound by the text layout; there is no need for
        applications to interact with this method.
        '''
        self._init_document()

    def on_delete_text(self, start, end):
        '''Event handler for `AbstractDocument.on_delete_text`.

        The event handler is bound by the text layout; there is no need for
        applications to interact with this method.
        '''
        self._init_document()

    def on_style_text(self, start, end, attributes):
        '''Event handler for `AbstractDocument.on_style_text`.

        The event handler is bound by the text layout; there is no need for
        applications to interact with this method.
        '''
        self._init_document()

    def _get_glyphs(self):
        glyphs = []
        runs = runlist.ZipRunIterator((
            self._document.get_font_runs(dpi=self._dpi),
            self._document.get_element_runs()))
        text = self._document.text
        for start, end, (font, element) in runs.ranges(0, len(text)):
            if element:
                glyphs.append(_InlineElementBox(element))
            else:
                glyphs.extend(font.get_glyphs(text[start:end]))
        return glyphs

    def _get_owner_runs(self, owner_runs, glyphs, start, end):
        owner = glyphs[start].owner
        run_start = start
        # TODO avoid glyph slice on non-incremental
        for i, glyph in enumerate(glyphs[start:end]):
            if owner != glyph.owner:
                owner_runs.set_run(run_start, i + start, owner)
                owner = glyph.owner
                run_start = i + start
        owner_runs.set_run(run_start, end, owner)

    def _flow_glyphs(self, glyphs, owner_runs, start, end):
        # TODO change flow generator on self, avoiding this conditional.
        if not self._multiline:
            for line in self._flow_glyphs_single_line(glyphs, owner_runs,
                                                      start, end):
                yield line
        else:
            for line in self._flow_glyphs_wrap(glyphs, owner_runs, start, end):
                yield line

    def _flow_glyphs_wrap(self, glyphs, owner_runs, start, end):
        '''Word-wrap styled text into lines of fixed width.

        Fits `glyphs` in range `start` to `end` into `_Line` s which are
        then yielded.
        '''
        owner_iterator = owner_runs.get_run_iterator().ranges(start, end)

        font_iterator = self._document.get_font_runs(dpi=self._dpi)

        align_iterator = runlist.FilteredRunIterator(
            self._document.get_style_runs('align'),
            lambda value: value in ('left', 'right', 'center'),
            'left')
        if self._width is None:
            wrap_iterator = runlist.ConstRunIterator(
                len(self.document.text), False)
        else:
            wrap_iterator = runlist.FilteredRunIterator(
                self._document.get_style_runs('wrap'),
                lambda value: value in (True, False),
                True)
        margin_left_iterator = runlist.FilteredRunIterator(
            self._document.get_style_runs('margin_left'),
            lambda value: value is not None, 0)
        margin_right_iterator = runlist.FilteredRunIterator(
            self._document.get_style_runs('margin_right'),
            lambda value: value is not None, 0)
        indent_iterator = runlist.FilteredRunIterator(
            self._document.get_style_runs('indent'),
            lambda value: value is not None, 0)
        kerning_iterator = runlist.FilteredRunIterator(
            self._document.get_style_runs('kerning'),
            lambda value: value is not None, 0)
        tab_stops_iterator = runlist.FilteredRunIterator(
            self._document.get_style_runs('tab_stops'),
            lambda value: value is not None, [])

        line = _Line(start)
        line.align = align_iterator[start]
        line.margin_left = self._parse_distance(margin_left_iterator[start])
        line.margin_right = self._parse_distance(margin_right_iterator[start])
        if start == 0 or self.document.text[start - 1] in u'\n\u2029':
            line.paragraph_begin = True
            line.margin_left += self._parse_distance(indent_iterator[start])
        wrap = wrap_iterator[start]
        if self._width is None:
            width = None
        else:
            width = self._width - line.margin_left - line.margin_right

        # Current right-most x position in line being laid out.
        x = 0

        # Boxes accumulated but not yet committed to a line.
        run_accum = []
        run_accum_width = 0

        # Amount of whitespace accumulated at end of line
        eol_ws = 0

        # Iterate over glyph owners (texture states); these form GlyphBoxes,
        # but broken into lines.
        font = None
        for start, end, owner in owner_iterator:
            font = font_iterator[start]

            # Glyphs accumulated in this owner but not yet committed to a
            # line.
            owner_accum = []
            owner_accum_width = 0

            # Glyphs accumulated in this owner AND also committed to the
            # current line (some whitespace has followed all of the committed
            # glyphs).
            owner_accum_commit = []
            owner_accum_commit_width = 0

            # Ignore kerning of first glyph on each line
            nokern = True

            # Current glyph index
            index = start

            from unicodedata import category as unicat

            # Iterate over glyphs in this owner run.  `text` is the
            # corresponding character data for the glyph, and is used to find
            # whitespace and newlines.
            for (text, glyph) in zip(self.document.text[start:end], glyphs[start:end]):
                if nokern:
                    kern = 0
                    nokern = False
                else:
                    kern = self._parse_distance(kerning_iterator[index])

                textcat = unicat(text)

                if text in u'\u0020\u200b\t' or textcat == 'Zs':
                    # Whitespace: commit pending runs to this line.
                    for run in run_accum:
                        line.add_box(run)
                    run_accum = []
                    run_accum_width = 0

                    if text == '\t':
                        # Fix up kern for this glyph to align to the next tab
                        # stop
                        for tab_stop in tab_stops_iterator[index]:
                            tab_stop = self._parse_distance(tab_stop)
                            if tab_stop > x + line.margin_left:
                                break
                        else:
                            # No more tab stops, tab to 100 pixels
                            tab = 50.
                            tab_stop = (((x + line.margin_left) // tab) + 1) * tab

                        kern = int(tab_stop - x - line.margin_left - glyph.advance)

                    owner_accum.append((kern, glyph))
                    owner_accum_commit.extend(owner_accum)
                    owner_accum_commit_width += owner_accum_width + glyph.advance + kern
                    eol_ws += glyph.advance + kern

                    owner_accum = []
                    owner_accum_width = 0

                    x += glyph.advance + kern
                    index += 1

                    # The index at which the next line will begin (the
                    # current index, because this is the current best
                    # breakpoint).
                    next_start = index
                else:
                    new_paragraph = text == '\n' or textcat == 'Zp'
                    new_line = textcat == 'Zl' or new_paragraph
                    if textcat == 'Lo':  # non-letter character
                        for run in run_accum:
                            line.add_box(run)
                        run_accum = []
                        run_accum_width = 0
                        owner_accum_commit.extend(owner_accum)
                        owner_accum_commit_width += owner_accum_width
                        eol_ws = 0
                        owner_accum = []
                        owner_accum_width = 0
                        next_start = index

                    if (wrap and x + kern + glyph.advance > width) or new_line:
                        # Either the pending runs have overflowed the allowed
                        # line width or a newline was encountered.  Either
                        # way, the current line must be flushed.

                        if new_line:
                            # Forced newline.  Commit everything pending
                            # without exception.
                            for run in run_accum:
                                line.add_box(run)
                            run_accum = []
                            run_accum_width = 0
                            owner_accum_commit.extend(owner_accum)
                            owner_accum_commit_width += owner_accum_width
                            owner_accum = []
                            owner_accum_width = 0

                            line.length += 1
                            next_start = index + 1

                        # Create the _GlyphBox for the committed glyphs in the
                        # current owner.
                        if owner_accum_commit:
                            line.add_box(
                                _GlyphBox(owner, font, owner_accum_commit,
                                          owner_accum_commit_width))
                            owner_accum_commit = []
                            owner_accum_commit_width = 0

                        if new_line and not line.boxes:
                            # Empty line: give it the current font's default
                            # line-height.
                            line.ascent = font.ascent
                            line.descent = font.descent

                        if not new_line and not line.boxes:
                            # Force newline.
                            for run in run_accum:
                                line.add_box(run)
                            run_accum = []
                            run_accum_width = 0
                            owner_accum_commit.extend(owner_accum)
                            owner_accum_commit_width += owner_accum_width
                            owner_accum = []
                            owner_accum_width = 0

                            eol_ws = 0
                            next_start = index


                        # Flush the line, unless nothing got committed, in
                        # which case it's a really long string of glyphs
                        # without any breakpoints (in which case it will be
                        # flushed at the earliest breakpoint, not before
                        # something is committed).
                        if line.boxes or new_line:
                            # Trim line width of whitespace on right-side.
                            line.width -= eol_ws
                            if new_paragraph:
                                line.paragraph_end = True
                            yield line
                            line = _Line(next_start)
                            line.align = align_iterator[next_start]
                            line.margin_left = self._parse_distance(
                                margin_left_iterator[next_start])
                            line.margin_right = self._parse_distance(
                                margin_right_iterator[next_start])
                            if new_paragraph:
                                line.paragraph_begin = True

                            # Remove kern from first glyph of line
                            if run_accum:
                                k, g = run_accum[0].glyphs[0]
                                run_accum[0].glyphs[0] = (0, g)
                                run_accum_width -= k
                            elif owner_accum:
                                k, g = owner_accum[0]
                                owner_accum[0] = (0, g)
                                owner_accum_width -= k
                            else:
                                nokern = True

                            x = run_accum_width + owner_accum_width
                            width = (self._width - line.margin_left - line.margin_right)

                    if isinstance(glyph, _AbstractBox):
                        # Glyph is already in a box. XXX Ignore kern?
                        run_accum.append(glyph)
                        run_accum_width += glyph.advance
                        x += glyph.advance
                    elif new_paragraph:
                        # New paragraph started, update wrap style
                        wrap = wrap_iterator[next_start]
                        line.margin_left += \
                            self._parse_distance(indent_iterator[next_start])
                        if width is not None:
                            width = (self._width - line.margin_left - line.margin_right)
                    elif not new_line:
                        # If the glyph was any non-whitespace, non-newline
                        # character, add it to the pending run.
                        owner_accum.append((kern, glyph))
                        owner_accum_width += glyph.advance + kern
                        x += glyph.advance + kern
                    
                    index += 1
                    eol_ws = 0
                    
                    if textcat == 'Lo' or textcat[0] in 'MPS':
                        # non-letter character, mark, symbol, punctuation
                        for run in run_accum:
                            line.add_box(run)
                        run_accum = []
                        run_accum_width = 0
                        owner_accum_commit.extend(owner_accum)
                        owner_accum_commit_width += owner_accum_width
                        eol_ws = 0
                        owner_accum = []
                        owner_accum_width = 0
                        next_start = index
                    
            # The owner run is finished; create GlyphBoxes for the committed
            # and pending glyphs.
            if owner_accum_commit:
                line.add_box(_GlyphBox(owner, font, owner_accum_commit,
                                       owner_accum_commit_width))
            if owner_accum:
                run_accum.append(_GlyphBox(owner, font, owner_accum,
                                           owner_accum_width))
                run_accum_width += owner_accum_width

        # All glyphs have been processed: commit everything pending and flush
        # the final line.
        for run in run_accum:
            line.add_box(run)

        if not line.boxes:
            # Empty line gets font's line-height
            if font is None:
                font = self._document.get_font(0, dpi=self._dpi)
            line.ascent = font.ascent
            line.descent = font.descent

        yield line

    def _flow_glyphs_single_line(self, glyphs, owner_runs, start, end):
        owner_iterator = owner_runs.get_run_iterator().ranges(start, end)
        font_iterator = self.document.get_font_runs(dpi=self._dpi)
        kern_iterator = runlist.FilteredRunIterator(
            self.document.get_style_runs('kerning'),
            lambda value: value is not None, 0)

        line = _Line(start)
        font = font_iterator[0]

        for start, end, owner in owner_iterator:
            font = font_iterator[start]
            width = 0
            owner_glyphs = []
            for kern_start, kern_end, kern in kern_iterator.ranges(start, end):
                gs = glyphs[kern_start:kern_end]
                width += sum([g.advance for g in gs])
                width += kern * (kern_end - kern_start)
                owner_glyphs.extend(zip([kern] * (kern_end - kern_start), gs))
            if owner is None:
                # Assume glyphs are already boxes.
                for kern, glyph in owner_glyphs:
                    line.add_box(glyph)
            else:
                line.add_box(_GlyphBox(owner, font, owner_glyphs, width))

        if not line.boxes:
            line.ascent = font.ascent
            line.descent = font.descent

        line.paragraph_begin = line.paragraph_end = True

        yield line

    def _flow_lines(self, lines, start, end):
        margin_top_iterator = runlist.FilteredRunIterator(
            self._document.get_style_runs('margin_top'),
            lambda value: value is not None, 0)
        margin_bottom_iterator = runlist.FilteredRunIterator(
            self._document.get_style_runs('margin_bottom'),
            lambda value: value is not None, 0)
        line_spacing_iterator = self._document.get_style_runs('line_spacing')
        leading_iterator = runlist.FilteredRunIterator(
            self._document.get_style_runs('leading'),
            lambda value: value is not None, 0)

        if start == 0:
            y = 0
        else:
            line = lines[start - 1]
            line_spacing = \
                self._parse_distance(line_spacing_iterator[line.start])
            leading = \
                self._parse_distance(leading_iterator[line.start])

            y = line.y
            if line_spacing is None:
                y += line.descent
            if line.paragraph_end:
                y -= self._parse_distance(margin_bottom_iterator[line.start])

        line_index = start
        for line in lines[start:]:
            if line.paragraph_begin:
                y -= self._parse_distance(margin_top_iterator[line.start])
                line_spacing = \
                    self._parse_distance(line_spacing_iterator[line.start])
                leading = self._parse_distance(leading_iterator[line.start])
            else:
                y -= leading

            if line_spacing is None:
                y -= line.ascent
            else:
                y -= line_spacing
            if line.align == 'left' or line.width > self.width:
                line.x = line.margin_left
            elif line.align == 'center':
                line.x = (self.width - line.margin_left - line.margin_right
                          - line.width) // 2 + line.margin_left
            elif line.align == 'right':
                line.x = self.width - line.margin_right - line.width

            self.content_width = max(self.content_width,
                                     line.width + line.margin_left)

            if line.y == y and line_index >= end:
                # Early exit: all invalidated lines have been reflowed and the
                # next line has no change (therefore subsequent lines do not
                # need to be changed).
                break
            line.y = y

            if line_spacing is None:
                y += line.descent
            if line.paragraph_end:
                y -= self._parse_distance(margin_bottom_iterator[line.start])

            line_index += 1
        else:
            self.content_height = -y

        return line_index

    def _create_vertex_lists(self, x, y, i, boxes, context):
        for box in boxes:
            box.place(self, i, x, y, context)
            x += box.advance
            i += box.length

    _x = 0

    def _set_x(self, x):
        if self._boxes:
            self._x = x
            self._update()
        else:
            dx = x - self._x
            l_dx = lambda x: x + dx
            for vertex_list in self._vertex_lists:
                vertices = vertex_list.vertices[:]
                vertices[::2] = map(l_dx, vertices[::2])
                vertex_list.vertices[:] = vertices
            self._x = x

    def _get_x(self):
        return self._x

    x = property(_get_x, _set_x,
                 doc='''X coordinate of the layout.

    See also `anchor_x`.

    :type: int
    ''')

    _y = 0

    def _set_y(self, y):
        if self._boxes:
            self._y = y
            self._update()
        else:
            dy = y - self._y
            l_dy = lambda y: y + dy
            for vertex_list in self._vertex_lists:
                vertices = vertex_list.vertices[:]
                vertices[1::2] = map(l_dy, vertices[1::2])
                vertex_list.vertices[:] = vertices
            self._y = y

    def _get_y(self):
        return self._y

    y = property(_get_y, _set_y,
                 doc='''Y coordinate of the layout.

    See also `anchor_y`.

    :type: int
    ''')

    _width = None

    def _set_width(self, width):
        self._width = width
        self._update()

    def _get_width(self):
        return self._width

    width = property(_get_width, _set_width,
                     doc='''Width of the layout.

    This property has no effect if `multiline` is False.

    :type: int
    ''')

    _height = None

    def _set_height(self, height):
        self._height = height
        self._update()

    def _get_height(self):
        return self._height

    height = property(_get_height, _set_height,
                      doc='''Height of the layout.

    :type: int
    ''')

    _multiline = False

    def _set_multiline(self, multiline):
        self._multiline = multiline
        self._update()

    def _get_multiline(self):
        return self._multiline

    multiline = property(_get_multiline, _set_multiline,
                         doc='''Set if multiline layout is enabled.

    If multiline is False, newline and paragraph characters are ignored and
    text is not word-wrapped.

    :type: bool
    ''')

    _anchor_x = 'left'

    def _set_anchor_x(self, anchor_x):
        self._anchor_x = anchor_x
        self._update()

    def _get_anchor_x(self):
        return self._anchor_x

    anchor_x = property(_get_anchor_x, _set_anchor_x,
                      doc='''Horizontal anchor alignment.

    This property determines the meaning of the `x` coordinate.  It is one of
    the enumerants:

    ``"left"`` (default)
        The X coordinate gives the position of the left edge of the layout.
    ``"center"``
        The X coordinate gives the position of the center of the layout.
    ``"right"``
        The X coordinate gives the position of the right edge of the layout.

    For the purposes of calculating the position resulting from this
    alignment, the width of the layout is taken to be `width` if `multiline`
    is True, otherwise `content_width`.

    :type: str
    ''')

    _anchor_y = 'bottom'

    def _set_anchor_y(self, anchor_y):
        self._anchor_y = anchor_y
        self._update()

    def _get_anchor_y(self):
        return self._anchor_y

    anchor_y = property(_get_anchor_y, _set_anchor_y,
                      doc='''Vertical anchor alignment.

    This property determines the meaning of the `y` coordinate.  It is one of
    the enumerants:

    ``"top"``
        The Y coordinate gives the position of the top edge of the layout.
    ``"center"``
        The Y coordinate gives the position of the center of the layout.
    ``"baseline"``
        The Y coordinate gives the position of the baseline of the first
        line of text in the layout.
    ``"bottom"`` (default)
        The Y coordinate gives the position of the bottom edge of the layout.

    For the purposes of calculating the position resulting from this
    alignment, the height of the layout is taken to be the smaller of
    `height` and `content_height`.

    See also `content_valign`.

    :type: str
    ''')

    _content_valign = 'top'

    def _set_content_valign(self, content_valign):
        self._content_valign = content_valign
        self._update()

    def _get_content_valign(self):
        return self._content_valign

    content_valign = property(_get_content_valign, _set_content_valign,
                              doc='''Vertical alignment of content within
    larger layout box.

    This property determines how content is positioned within the layout
    box when ``content_height`` is less than ``height``.  It is one
    of the enumerants:

    ``top`` (default)
        Content is aligned to the top of the layout box.
    ``center``
        Content is centered vertically within the layout box.
    ``bottom``
        Content is aligned to the bottom of the layout box.

    This property has no effect when ``content_height`` is greater
    than ``height`` (in which case the content is aligned to the top) or when
    ``height`` is ``None`` (in which case there is no vertical layout box
    dimension).

    :type: str
    ''')


class ScrollableTextLayout(TextLayout):
    '''Display text in a scrollable viewport.

    This class does not display a scrollbar or handle scroll events; it merely
    clips the text that would be drawn in `TextLayout` to the bounds of the
    layout given by `x`, `y`, `width` and `height`; and offsets the text by a
    scroll offset.

    Use `view_x` and `view_y` to scroll the text within the viewport.
    '''
    _origin_layout = True

    def __init__(self, document, width, height, multiline=False, dpi=None,
                 batch=None, group=None):
        super(ScrollableTextLayout, self).__init__(
            document, width, height, multiline, dpi, batch, group)
        self.top_group.width = self._width
        self.top_group.height = self._height

    def _init_groups(self, group):
        # Scrollable layout never shares group becauase of translation.
        self.top_group = ScrollableTextLayoutGroup(group)
        self.background_group = graphics.OrderedGroup(0, self.top_group)
        self.foreground_group = TextLayoutForegroundGroup(1, self.top_group)
        self.foreground_decoration_group = \
            TextLayoutForegroundDecorationGroup(2, self.top_group)

    def _set_x(self, x):
        self._x = x
        self.top_group.left = self._get_left()

    def _get_x(self):
        return self._x

    x = property(_get_x, _set_x)

    def _set_y(self, y):
        self._y = y
        self.top_group.top = self._get_top(self._get_lines())

    def _get_y(self):
        return self._y

    y = property(_get_y, _set_y)

    def _set_width(self, width):
        super(ScrollableTextLayout, self)._set_width(width)
        self.top_group.left = self._get_left()
        self.top_group.width = self._width

    def _get_width(self):
        return self._width

    width = property(_get_width, _set_width)

    def _set_height(self, height):
        super(ScrollableTextLayout, self)._set_height(height)
        self.top_group.top = self._get_top(self._get_lines())
        self.top_group.height = self._height

    def _get_height(self):
        return self._height

    height = property(_get_height, _set_height)

    def _set_anchor_x(self, anchor_x):
        self._anchor_x = anchor_x
        self.top_group.left = self._get_left()

    def _get_anchor_x(self):
        return self._anchor_x

    anchor_x = property(_get_anchor_x, _set_anchor_x)

    def _set_anchor_y(self, anchor_y):
        self._anchor_y = anchor_y
        self.top_group.top = self._get_top(self._get_lines())

    def _get_anchor_y(self):
        return self._anchor_y

    anchor_y = property(_get_anchor_y, _set_anchor_y)

    # Offset of content within viewport

    def _set_view_x(self, view_x):
        view_x = max(0, min(self.content_width - self.width, view_x))
        self.top_group.view_x = view_x

    def _get_view_x(self):
        return self.top_group.view_x

    view_x = property(_get_view_x, _set_view_x,
                      doc='''Horizontal scroll offset.

    The initial value is 0, and the left edge of the text will touch the left
    side of the layout bounds.  A positive value causes the text to "scroll"
    to the right.  Values are automatically clipped into the range
    ``[0, content_width - width]``

    :type: int
    ''')

    def _set_view_y(self, view_y):
        # view_y must be negative.
        view_y = min(0, max(self.height - self.content_height, view_y))
        self.top_group.view_y = view_y

    def _get_view_y(self):
        return self.top_group.view_y

    view_y = property(_get_view_y, _set_view_y,
                      doc='''Vertical scroll offset.

    The initial value is 0, and the top of the text will touch the top of the
    layout bounds (unless the content height is less than the layout height,
    in which case `content_valign` is used).

    A negative value causes the text to "scroll" upwards.  Values outside of
    the range ``[height - content_height, 0]`` are automatically clipped in
    range.

    :type: int
    ''')


class IncrementalTextLayout(ScrollableTextLayout, event.EventDispatcher):
    '''Displayed text suitable for interactive editing and/or scrolling
    large documents.

    Unlike `TextLayout` and `ScrollableTextLayout`, this class generates
    vertex lists only for lines of text that are visible.  As the document is
    scrolled, vertex lists are deleted and created as appropriate to keep
    video memory usage to a minimum and improve rendering speed.

    Changes to the document are quickly reflected in this layout, as only the
    affected line(s) are reflowed.  Use `begin_update` and `end_update` to
    further reduce the amount of processing required.

    The layout can also display a text selection (text with a different
    background color).  The `Caret` class implements a visible text cursor and
    provides event handlers for scrolling, selecting and editing text in an
    incremental text layout.
    '''
    _selection_start = 0
    _selection_end = 0
    _selection_color = [255, 255, 255, 255]
    _selection_background_color = [46, 106, 197, 255]

    def __init__(self, document, width, height, multiline=False, dpi=None,
                 batch=None, group=None):
        event.EventDispatcher.__init__(self)
        self.glyphs = []
        self.lines = []

        self.invalid_glyphs = _InvalidRange()
        self.invalid_flow = _InvalidRange()
        self.invalid_lines = _InvalidRange()
        self.invalid_style = _InvalidRange()
        self.invalid_vertex_lines = _InvalidRange()
        self.visible_lines = _InvalidRange()

        self.owner_runs = runlist.RunList(0, None)

        ScrollableTextLayout.__init__(self,
            document, width, height, multiline, dpi, batch, group)

        self.top_group.width = width
        self.top_group.left = self._get_left()
        self.top_group.height = height
        self.top_group.top = self._get_top(self._get_lines())

    def _init_document(self):
        assert self._document, \
            'Cannot remove document from IncrementalTextLayout'
        self.on_insert_text(0, self._document.text)

    def _uninit_document(self):
        self.on_delete_text(0, len(self._document.text))

    def _get_lines(self):
        return self.lines

    def delete(self):
        for line in self.lines:
            line.delete(self)
        self.batch = None
        if self._document:
            self._document.remove_handlers(self)
        self._document = None

    def on_insert_text(self, start, text):
        len_text = len(text)
        self.glyphs[start:start] = [None] * len_text

        self.invalid_glyphs.insert(start, len_text)
        self.invalid_flow.insert(start, len_text)
        self.invalid_style.insert(start, len_text)

        self.owner_runs.insert(start, len_text)

        for line in self.lines:
            if line.start >= start:
                line.start += len_text

        self._update()

    def on_delete_text(self, start, end):
        self.glyphs[start:end] = []

        self.invalid_glyphs.delete(start, end)
        self.invalid_flow.delete(start, end)
        self.invalid_style.delete(start, end)

        self.owner_runs.delete(start, end)

        size = end - start
        for line in self.lines:
            if line.start > start:
                line.start = max(line.start - size, start)

        if start == 0:
            self.invalid_flow.invalidate(0, 1)
        else:
            self.invalid_flow.invalidate(start - 1, start)

        self._update()

    def on_style_text(self, start, end, attributes):
        if set(('font_name', 'font_size', 'bold', 'italic')) & set(attributes):
            self.invalid_glyphs.invalidate(start, end)
        elif False:  # Attributes that change flow
            self.invalid_flow.invalidate(start, end)
        elif ('color' in attributes or
              'background_color' in attributes):
            self.invalid_style.invalidate(start, end)

        self._update()

    def _update(self):
        if not self._update_enabled:
            return

        trigger_update_event = (self.invalid_glyphs.is_invalid() or
                                self.invalid_flow.is_invalid() or
                                self.invalid_lines.is_invalid())

        # Special care if there is no text:
        if not self.glyphs:
            for line in self.lines:
                line.delete(self)
            del self.lines[:]
            self.lines.append(_Line(0))
            font = self.document.get_font(0, dpi=self._dpi)
            self.lines[0].ascent = font.ascent
            self.lines[0].descent = font.descent
            self.lines[0].paragraph_begin = self.lines[0].paragraph_end = True
            self.invalid_lines.invalidate(0, 1)

        self._update_glyphs()
        self._update_flow_glyphs()
        self._update_flow_lines()
        self._update_visible_lines()
        self._update_vertex_lists()
        self.top_group.top = self._get_top(self.lines)

        # Reclamp view_y in case content height has changed and reset top of
        # content.
        self.view_y = self.view_y
        self.top_group.top = self._get_top(self._get_lines())

        if trigger_update_event:
            self.dispatch_event('on_layout_update')

    def _update_glyphs(self):
        invalid_start, invalid_end = self.invalid_glyphs.validate()

        if invalid_end - invalid_start <= 0:
            return

        # Find grapheme breaks and extend glyph range to encompass.
        text = self.document.text
        while invalid_start > 0:
            if _grapheme_break(text[invalid_start - 1], text[invalid_start]):
                break
            invalid_start -= 1

        len_text = len(text)
        while invalid_end < len_text:
            if _grapheme_break(text[invalid_end - 1], text[invalid_end]):
                break
            invalid_end += 1

        # Update glyphs
        runs = runlist.ZipRunIterator((
            self._document.get_font_runs(dpi=self._dpi),
            self._document.get_element_runs()))
        for start, end, (font, element) in \
                runs.ranges(invalid_start, invalid_end):
            if element:
                self.glyphs[start] = _InlineElementBox(element)
            else:
                text = self.document.text[start:end]
                self.glyphs[start:end] = font.get_glyphs(text)

        # Update owner runs
        self._get_owner_runs(
            self.owner_runs, self.glyphs, invalid_start, invalid_end)

        # Updated glyphs need flowing
        self.invalid_flow.invalidate(invalid_start, invalid_end)

    def _update_flow_glyphs(self):
        invalid_start, invalid_end = self.invalid_flow.validate()

        if invalid_end - invalid_start <= 0:
            return

        # Find first invalid line
        line_index = 0
        for i, line in enumerate(self.lines):
            if line.start >= invalid_start:
                break
            line_index = i

        # Flow from previous line; fixes issue with adding a space into
        # overlong line (glyphs before space would then flow back onto
        # previous line).  TODO Could optimise this by keeping track of where
        # the overlong lines are.
        line_index = max(0, line_index - 1)

        # (No need to find last invalid line; the update loop below stops
        # calling the flow generator when no more changes are necessary.)

        try:
            line = self.lines[line_index]
            invalid_start = min(invalid_start, line.start)
            line.delete(self)
            line = self.lines[line_index] = _Line(invalid_start)
            self.invalid_lines.invalidate(line_index, line_index + 1)
        except IndexError:
            line_index = 0
            invalid_start = 0
            line = _Line(0)
            self.lines.append(line)
            self.invalid_lines.insert(0, 1)

        content_width_invalid = False
        next_start = invalid_start

        for line in self._flow_glyphs(self.glyphs, self.owner_runs,
                                      invalid_start, len(self._document.text)):
            try:
                old_line = self.lines[line_index]
                old_line.delete(self)
                old_line_width = old_line.width + old_line.margin_left
                new_line_width = line.width + line.margin_left
                content_width_invalid = (
                    old_line_width == self.content_width and
                    new_line_width < old_line_width
                )
                self.lines[line_index] = line
                self.invalid_lines.invalidate(line_index, line_index + 1)
            except IndexError:
                self.lines.append(line)
                self.invalid_lines.insert(line_index, 1)

            next_start = line.start + line.length
            line_index += 1

            try:
                next_line = self.lines[line_index]
                if next_start == next_line.start and next_start > invalid_end:
                    # No more lines need to be modified, early exit.
                    break
            except IndexError:
                pass
        else:
            # The last line is at line_index - 1, if there are any more lines
            # after that they are stale and need to be deleted.
            if next_start == len(self._document.text) and line_index > 0:
                for line in self.lines[line_index:]:
                    old_line_width = old_line.width + old_line.margin_left
                    if old_line_width == self.content_width:
                        content_width_invalid = True
                    line.delete(self)
                del self.lines[line_index:]

        if content_width_invalid:
            # Rescan all lines to look for the new maximum content width
            content_width = 0
            for line in self.lines:
                content_width = max(line.width + line.margin_left,
                                    content_width)
            self.content_width = content_width

    def _update_flow_lines(self):
        invalid_start, invalid_end = self.invalid_lines.validate()
        if invalid_end - invalid_start <= 0:
            return

        invalid_end = self._flow_lines(self.lines, invalid_start, invalid_end)

        # Invalidate lines that need new vertex lists.
        self.invalid_vertex_lines.invalidate(invalid_start, invalid_end)

    def _update_visible_lines(self):
        start = sys.maxint
        end = 0
        for i, line in enumerate(self.lines):
            if line.y + line.descent < self.view_y:
                start = min(start, i)
            if line.y + line.ascent > self.view_y - self.height:
                end = max(end, i) + 1

        # Delete newly invisible lines
        for i in range(self.visible_lines.start, min(start, len(self.lines))):
            self.lines[i].delete(self)
        for i in range(end, min(self.visible_lines.end, len(self.lines))):
            self.lines[i].delete(self)

        # Invalidate newly visible lines
        self.invalid_vertex_lines.invalidate(start, self.visible_lines.start)
        self.invalid_vertex_lines.invalidate(self.visible_lines.end, end)

        self.visible_lines.start = start
        self.visible_lines.end = end

    def _update_vertex_lists(self):
        # Find lines that have been affected by style changes
        style_invalid_start, style_invalid_end = self.invalid_style.validate()
        self.invalid_vertex_lines.invalidate(
            self.get_line_from_position(style_invalid_start),
            self.get_line_from_position(style_invalid_end) + 1)

        invalid_start, invalid_end = self.invalid_vertex_lines.validate()
        if invalid_end - invalid_start <= 0:
            return

        colors_iter = self.document.get_style_runs('color')
        shadow_iter = self.document.get_style_runs('shadow')
        background_iter = self.document.get_style_runs('background_color')
        if self._selection_end - self._selection_start > 0:
            colors_iter = runlist.OverriddenRunIterator(
                colors_iter,
                self._selection_start,
                self._selection_end,
                self._selection_color)
            shadow_iter = runlist.OverriddenRunIterator(
                shadow_iter,
                self._selection_start,
                self._selection_end,
                None)
            background_iter = runlist.OverriddenRunIterator(
                background_iter,
                self._selection_start,
                self._selection_end,
                self._selection_background_color)

        context = _IncrementalLayoutContext(self, self._document,
                                            colors_iter, shadow_iter,
                                            background_iter)

        for line in self.lines[invalid_start:invalid_end]:
            line.delete(self)
            context.line = line
            y = line.y

            # Early out if not visible
            if y + line.descent > self.view_y:
                continue
            elif y + line.ascent < self.view_y - self.height:
                break

            self._create_vertex_lists(line.x, y, line.start,
                                      line.boxes, context)

    # Invalidate everything when width changes

    def _set_width(self, width):
        if width == self._width:
            return

        self.invalid_flow.invalidate(0, len(self.document.text))
        super(IncrementalTextLayout, self)._set_width(width)

    def _get_width(self):
        return self._width

    width = property(_get_width, _set_width)

    # Recalculate visible lines when height changes
    def _set_height(self, height):
        if height == self._height:
            return

        super(IncrementalTextLayout, self)._set_height(height)
        if self._update_enabled:
            self._update_visible_lines()
            self._update_vertex_lists()

    def _get_height(self):
        return self._height

    height = property(_get_height, _set_height)

    def _set_multiline(self, multiline):
        self.invalid_flow.invalidate(0, len(self.document.text))
        super(IncrementalTextLayout, self)._set_multiline(multiline)

    def _get_multiline(self):
        return self._multiline

    multiline = property(_get_multiline, _set_multiline)

    # Invalidate invisible/visible lines when y scrolls

    def _set_view_y(self, view_y):
        # view_y must be negative.
        super(IncrementalTextLayout, self)._set_view_y(view_y)
        self._update_visible_lines()
        self._update_vertex_lists()

    def _get_view_y(self):
        return self.top_group.view_y

    view_y = property(_get_view_y, _set_view_y)

    # Visible selection

    def set_selection(self, start, end):
        '''Set the text selection range.

        If ``start`` equals ``end`` no selection will be visible.

        :Parameters:
            `start` : int
                Starting character position of selection.
            `end` : int
                End of selection, exclusive.

        '''
        start = max(0, start)
        end = min(end, len(self.document.text))
        if start == self._selection_start and end == self._selection_end:
            return

        if end > self._selection_start and start < self._selection_end:
            # Overlapping, only invalidate difference
            self.invalid_style.invalidate(min(start, self._selection_start),
                                          max(start, self._selection_start))
            self.invalid_style.invalidate(min(end, self._selection_end),
                                          max(end, self._selection_end))
        else:
            # Non-overlapping, invalidate both ranges
            self.invalid_style.invalidate(self._selection_start,
                                          self._selection_end)
            self.invalid_style.invalidate(start, end)

        self._selection_start = start
        self._selection_end = end

        self._update()

    selection_start = property(
        lambda self: self._selection_start,
        lambda self, v: self.set_selection(v, self._selection_end),
        doc='''Starting position of the active selection.

    :see: `set_selection`

    :type: int
    ''')

    selection_end = property(
        lambda self: self._selection_end,
        lambda self, v: self.set_selection(self._selection_start, v),
        doc='''End position of the active selection (exclusive).

    :see: `set_selection`

    :type: int
    ''')

    def _get_selection_color(self):
        return self._selection_color

    def _set_selection_color(self, color):
        self._selection_color = color
        self.invalid_style.invalidate(self._selection_start,
                                      self._selection_end)

    selection_color = property(_get_selection_color, _set_selection_color,
                               doc='''Text color of active selection.

    The color is an RGBA tuple with components in range [0, 255].

    :type: (int, int, int, int)
    ''')

    def _get_selection_background_color(self):
        return self._selection_background_color

    def _set_selection_background_color(self, background_color):
        self._selection_background_color = background_color
        self.invalid_style.invalidate(self._selection_start,
                                      self._selection_end)

    selection_background_color = property(_get_selection_background_color,
                                          _set_selection_background_color,
                                          doc='''Background color of active
    selection.

    The color is an RGBA tuple with components in range [0, 255].

    :type: (int, int, int, int)
    ''')

    # Coordinate translation

    def get_position_from_point(self, x, y):
        '''Get the closest document position to a point.

        :Parameters:
            `x` : int
                X coordinate
            `y` : int
                Y coordinate

        '''
        line = self.get_line_from_point(x, y)
        return self.get_position_on_line(line, x)

    def get_point_from_position(self, position, line=None):
        '''Get the X, Y coordinates of a position in the document.

        The position that ends a line has an ambiguous point: it can be either
        the end of the line, or the beginning of the next line.  You may
        optionally specify a line index to disambiguate the case.

        The resulting Y coordinate gives the baseline of the line.

        :Parameters:
            `position` : int
                Character position within document.
            `line` : int
                Line index.

        :rtype: (int, int)
        :return: (x, y)
        '''
        if line is None:
            line = self.lines[0]
            for next_line in self.lines:
                if next_line.start > position:
                    break
                line = next_line
        else:
            line = self.lines[line]

        x = line.x

        baseline = self._document.get_style('baseline', max(0, position - 1))
        if baseline is None:
            baseline = 0
        else:
            baseline = self._parse_distance(baseline)

        position -= line.start
        for box in line.boxes:
            if position - box.length <= 0:
                x += box.get_point_in_box(position)
                break
            position -= box.length
            x += box.advance

        return (x + self.top_group.translate_x,
                line.y + self.top_group.translate_y + baseline)

    def get_line_from_point(self, x, y):
        '''Get the closest line index to a point.

        :Parameters:
            `x` : int
                X coordinate.
            `y` : int
                Y coordinate.

        :rtype: int
        '''
        x -= self.top_group.translate_x
        y -= self.top_group.translate_y

        line_index = 0
        for line in self.lines:
            if y > line.y + line.descent:
                break
            line_index += 1
        if line_index >= len(self.lines):
            line_index = len(self.lines) - 1
        return line_index

    def get_point_from_line(self, line):
        '''Get the X, Y coordinates of a line index.

        :Parameters:
            `line` : int
                Line index.

        :rtype: (int, int)
        :return: (x, y)
        '''
        line = self.lines[line]
        return (line.x + self.top_group.translate_x,
                line.y + self.top_group.translate_y)

    def get_line_from_position(self, position):
        '''Get the line index of a character position in the document.

        :Parameters:
            `position` : int
                Document position.

        :rtype: int
        '''
        line = -1
        for next_line in self.lines:
            if next_line.start > position:
                break
            line += 1
        return line

    def get_position_from_line(self, line):
        '''Get the first document character position of a given line index.

        :Parameters:
            `line` : int
                Line index.

        :rtype: int
        '''
        return self.lines[line].start

    def get_position_on_line(self, line, x):
        '''Get the closest document position for a given line index and X
        coordinate.

        :Parameters:
            `line` : int
                Line index.
            `x` : int
                X coordinate.

        :rtype: int
        '''
        line = self.lines[line]
        x -= self.top_group.translate_x

        position = line.start
        last_glyph_x = line.x
        for box in line.boxes:
            if 0 <= x - last_glyph_x < box.advance:
                position += box.get_position_in_box(x - last_glyph_x)
                break
            last_glyph_x += box.advance
            position += box.length

        return position

    def get_line_count(self):
        '''Get the number of lines in the text layout.

        :rtype: int
        '''
        return len(self.lines)

    def ensure_line_visible(self, line):
        '''Adjust `view_y` so that the line with the given index is visible.

        :Parameters:
            `line` : int
                Line index.

        '''
        line = self.lines[line]
        y1 = line.y + line.ascent
        y2 = line.y + line.descent
        if y1 > self.view_y:
            self.view_y = y1
        elif y2 < self.view_y - self.height:
            self.view_y = y2 + self.height

    def ensure_x_visible(self, x):
        '''Adjust `view_x` so that the given X coordinate is visible.

        The X coordinate is given relative to the current `view_x`.

        :Parameters:
            `x` : int
                X coordinate

        '''
        if x <= self.view_x + 10:
            self.view_x = x - 10
        elif x >= self.view_x + self.width:
            self.view_x = x - self.width + 10
        elif (x >= self.view_x + self.width - 10 and
              self.content_width > self.width):
            self.view_x = x - self.width + 10

    if _is_epydoc:
        def on_layout_update(self):
            '''Some or all of the layout text was reflowed.

            Text reflow is caused by document edits or changes to the layout's
            size.  Changes to the layout's position or active selection, and
            certain document edits such as text color, do not cause a reflow.

            Handle this event to update the position of a graphical element
            that depends on the laid out position of a glyph or line.

            :event:
            '''

IncrementalTextLayout.register_event_type('on_layout_update')

########NEW FILE########
__FILENAME__ = runlist
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Run list encoding utilities.

:since: pyglet 1.1
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

class _Run(object):
    def __init__(self, value, count):
        self.value = value
        self.count = count

    def __repr__(self):
        return 'Run(%r, %d)' % (self.value, self.count)

class RunList(object):
    '''List of contiguous runs of values.

    A `RunList` is an efficient encoding of a sequence of values.  For
    example, the sequence ``aaaabbccccc`` is encoded as ``(4, a), (2, b),
    (5, c)``.  The class provides methods for modifying and querying the
    run list without needing to deal with the tricky cases of splitting and
    merging the run list entries.

    Run lists are used to represent formatted character data in pyglet.  A
    separate run list is maintained for each style attribute, for example,
    bold, italic, font size, and so on.  Unless you are overriding the
    document interfaces, the only interaction with run lists is via
    `RunIterator`.

    The length and ranges of a run list always refer to the character
    positions in the decoded list.  For example, in the above sequence,
    ``set_run(2, 5, 'x')`` would change the sequence to ``aaxxxbccccc``.
    '''
    def __init__(self, size, initial):
        '''Create a run list of the given size and a default value.

        :Parameters:
            `size` : int
                Number of characters to represent initially.
            `initial` : object
                The value of all characters in the run list.

        '''
        self.runs = [_Run(initial, size)]

    def insert(self, pos, length):
        '''Insert characters into the run list.

        The inserted characters will take on the value immediately preceding
        the insertion point (or the value of the first character, if `pos` is
        0).

        :Parameters:
            `pos` : int
                Insertion index
            `length` : int
                Number of characters to insert.

        '''

        i = 0
        for run in self.runs:
            if i <= pos <= i + run.count:
                run.count += length
            i += run.count

    def delete(self, start, end):
        '''Remove characters from the run list.

        :Parameters:
            `start` : int
                Starting index to remove from.
            `end` : int
                End index, exclusive.

        '''
        i = 0
        for run in self.runs:
            if end - start == 0:
                break
            if i <= start <= i + run.count:
                trim = min(end - start, i + run.count - start)
                run.count -= trim
                end -= trim
            i += run.count
        self.runs = [r for r in self.runs if r.count > 0]

        # Don't leave an empty list
        if not self.runs:
            self.runs = [_Run(run.value, 0)]

    def set_run(self, start, end, value):
        '''Set the value of a range of characters.

        :Parameters:
            `start` : int
                Start index of range.
            `end` : int
                End of range, exclusive.
            `value` : object
                Value to set over the range.

        '''
        if end - start <= 0:
            return

        # Find runs that need to be split
        i = 0
        start_i = None
        start_trim = 0
        end_i = None
        end_trim = 0
        for run_i, run in enumerate(self.runs):
            count = run.count
            if i < start < i + count:
                start_i = run_i
                start_trim = start - i
            if i < end < i + count:
                end_i = run_i
                end_trim = end - i
            i += count

        # Split runs
        if start_i is not None:
            run = self.runs[start_i]
            self.runs.insert(start_i, _Run(run.value, start_trim))
            run.count -= start_trim
            if end_i is not None:
                if end_i == start_i:
                    end_trim -= start_trim
                end_i += 1
        if end_i is not None:
            run = self.runs[end_i]
            self.runs.insert(end_i, _Run(run.value, end_trim))
            run.count -= end_trim

        # Set new value on runs
        i = 0
        for run in self.runs:
            if start <= i and i + run.count <= end:
                run.value = value
            i += run.count

        # Merge adjacent runs
        last_run = self.runs[0]
        for run in self.runs[1:]:
            if run.value == last_run.value:
                run.count += last_run.count
                last_run.count = 0
            last_run = run

        # Delete collapsed runs
        self.runs = [r for r in self.runs if r.count > 0]

    def __iter__(self):
        i = 0
        for run in self.runs:
            yield i, i + run.count, run.value
            i += run.count

    def get_run_iterator(self):
        '''Get an extended iterator over the run list.

        :rtype: `RunIterator`
        '''
        return RunIterator(self)

    def __getitem__(self, index):
        '''Get the value at a character position.

        :Parameters:
            `index` : int
                Index of character.  Must be within range and non-negative.

        :rtype: object
        '''
        i = 0
        for run in self.runs:
            if i <= index < i + run.count:
                return run.value
            i += run.count

        # Append insertion point
        if index == i:
            return self.runs[-1].value

        assert False, 'Index not in range'

    def __repr__(self):
        return str(list(self))

class AbstractRunIterator(object):
    '''Range iteration over `RunList`.

    `AbstractRunIterator` objects allow any monotonically non-decreasing
    access of the iteration, including repeated iteration over the same index.
    Use the ``[index]`` operator to get the value at a particular index within
    the document.  For example::

        run_iter = iter(run_list)
        value = run_iter[0]
        value = run_iter[0]       # non-decreasing access is OK
        value = run_iter[15]
        value = run_iter[17]
        value = run_iter[16]      # this is illegal, the index decreased.

    Using `AbstractRunIterator` to access increasing indices of the value runs
    is more efficient than calling `RunList.__getitem__` repeatedly.

    You can also iterate over monotonically non-decreasing ranges over the
    iteration.  For example::

        run_iter = iter(run_list)
        for start, end, value in run_iter.ranges(0, 20):
            pass
        for start, end, value in run_iter.ranges(25, 30):
            pass
        for start, end, value in run_iter.ranges(30, 40):
            pass

    Both start and end indices of the slice are required and must be positive.
    '''

    def __getitem__(self, index):
        '''Get the value at a given index.

        See the class documentation for examples of valid usage.

        :Parameters:
            `index` : int
                Document position to query.

        :rtype: object
        '''

    def ranges(self, start, end):
        '''Iterate over a subrange of the run list.

        See the class documentation for examples of valid usage.

        :Parameters:
            `start` : int
                Start index to iterate from.
            `end` : int
                End index, exclusive.

        :rtype: iterator
        :return: Iterator over (start, end, value) tuples.
        '''

class RunIterator(AbstractRunIterator):
    def __init__(self, run_list):
        self.next = iter(run_list).next
        self.start, self.end, self.value = self.next()

    def __getitem__(self, index):
        try:
            while index >= self.end:
                self.start, self.end, self.value = self.next()
        except StopIteration:
            pass
        return self.value

    def ranges(self, start, end):
        while start >= self.end:
            self.start, self.end, self.value = self.next()
        yield start, min(self.end, end), self.value
        while end > self.end:
            self.start, self.end, self.value = self.next()
            yield self.start, min(self.end, end), self.value

class OverriddenRunIterator(AbstractRunIterator):
    '''Iterator over a `RunIterator`, with a value temporarily replacing
    a given range.
    '''
    def __init__(self, base_iterator, start, end, value):
        '''Create a derived iterator.

        :Parameters:
            `start` : int
                Start of range to override
            `end` : int
                End of range to override, exclusive
            `value` : object
                Value to replace over the range

        '''
        self.iter = base_iterator
        self.override_start = start
        self.override_end = end
        self.override_value = value

    def ranges(self, start, end):
        if end <= self.override_start or start >= self.override_end:
            # No overlap
            for r in self.iter.ranges(start, end):
                yield r
        else:
            # Overlap: before, override, after
            if start < self.override_start < end:
                for r in self.iter.ranges(start, self.override_start):
                    yield r
            yield (max(self.override_start, start),
                   min(self.override_end, end),
                   self.override_value)
            if start < self.override_end < end:
                for r in self.iter.ranges(self.override_end, end):
                    yield r

    def __getitem__(self, index):
        if self.override_start <= index < self.override_end:
            return self.override_value
        else:
            return self.iter[index]

class FilteredRunIterator(AbstractRunIterator):
    '''Iterate over an `AbstractRunIterator` with filtered values replaced
    by a default value.
    '''
    def __init__(self, base_iterator, filter, default):
        '''Create a filtered run iterator.

        :Parameters:
            `base_iterator` : `AbstractRunIterator`
                Source of runs.
            `filter` : ``lambda object: bool``
                Function taking a value as parameter, and returning ``True``
                if the value is acceptable, and ``False`` if the default value
                should be substituted.
            `default` : object
                Default value to replace filtered values.

        '''
        self.iter = base_iterator
        self.filter = filter
        self.default = default

    def ranges(self, start, end):
        for start, end, value in self.iter.ranges(start, end):
            if self.filter(value):
                yield start, end, value
            else:
                yield start, end, self.default

    def __getitem__(self, index):
        value = self.iter[index]
        if self.filter(value):
            return value
        return self.default

class ZipRunIterator(AbstractRunIterator):
    '''Iterate over multiple run iterators concurrently.'''
    def __init__(self, range_iterators):
        self.range_iterators = range_iterators

    def ranges(self, start, end):
        iterators = [i.ranges(start, end) for i in self.range_iterators]
        starts, ends, values = zip(*[i.next() for i in iterators])
        starts = list(starts)
        ends = list(ends)
        values = list(values)
        while start < end:
            min_end = min(ends)
            yield start, min_end, values
            start = min_end
            for i, iterator in enumerate(iterators):
                if ends[i] == min_end:
                    starts[i], ends[i], values[i] = iterator.next()

    def __getitem__(self, index):
        return [i[index] for i in self.range_iterators]

class ConstRunIterator(AbstractRunIterator):
    '''Iterate over a constant value without creating a RunList.'''
    def __init__(self, length, value):
        self.length = length
        self.value = value

    def next(self):
        yield 0, self.length, self.value

    def ranges(self, start, end):
        yield start, end, self.value

    def __getitem__(self, index):
        return self.value

########NEW FILE########
__FILENAME__ = constants
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

# CFString.h
kCFStringEncodingMacRoman = 0
kCFStringEncodingWindowsLatin1 = 0x0500
kCFStringEncodingISOLatin1 = 0x0201
kCFStringEncodingNextStepLatin = 0x0B01
kCFStringEncodingASCII = 0x0600
kCFStringEncodingUnicode = 0x0100
kCFStringEncodingUTF8 = 0x08000100
kCFStringEncodingNonLossyASCII = 0x0BFF

# MacTypes.h
noErr = 0

# CarbonEventsCore.h
eventLoopTimedOutErr = -9875
eventLoopQuitErr = -9876

# MacApplication.h
kUIModeNormal                 = 0
kUIModeContentSuppressed      = 1
kUIModeContentHidden          = 2
kUIModeAllSuppressed          = 4
kUIModeAllHidden              = 3
kUIOptionAutoShowMenuBar      = 1 << 0
kUIOptionDisableAppleMenu     = 1 << 2
kUIOptionDisableProcessSwitch = 1 << 3
kUIOptionDisableForceQuit     = 1 << 4
kUIOptionDisableSessionTerminate = 1 << 5
kUIOptionDisableHide          = 1 << 6

# MacWindows.h
kAlertWindowClass = 1
kMovableAlertWindowClass = 2
kModalWindowClass = 3
kMovableModalWindowClass = 4
kFloatingWindowClass = 5
kDocumentWindowClass = 6
kUtilityWindowClass = 8
kHelpWindowClass = 10
kSheetWindowClass = 11
kToolbarWindowClass = 12
kPlainWindowClass = 13
kOverlayWindowClass = 14
kSheetAlertWindowClass = 15
kAltPlainWindowClass = 16
kSimpleWindowClass = 18  # no window frame
kDrawerWindowClass = 20

kWindowNoAttributes = 0x0
kWindowCloseBoxAttribute = 0x1
kWindowHorizontalZoomAttribute = 0x2
kWindowVerticalZoomAttribute = 0x4
kWindowFullZoomAttribute = kWindowHorizontalZoomAttribute | \
    kWindowVerticalZoomAttribute
kWindowCollapseBoxAttribute = 0x8
kWindowResizableAttribute = 0x10
kWindowSideTitlebarAttribute = 0x20
kWindowToolbarAttribute = 0x40
kWindowMetalAttribute = 1 << 8
kWindowDoesNotCycleAttribute = 1 << 15
kWindowNoupdatesAttribute = 1 << 16
kWindowNoActivatesAttribute = 1 << 17
kWindowOpaqueForEventsAttribute = 1 << 18
kWindowCompositingAttribute = 1 << 19
kWindowNoShadowAttribute = 1 << 21
kWindowHideOnSuspendAttribute = 1 << 24
kWindowAsyncDragAttribute = 1 << 23
kWindowStandardHandlerAttribute = 1 << 25
kWindowHideOnFullScreenAttribute = 1 << 26
kWindowInWindowMenuAttribute = 1 << 27
kWindowLiveResizeAttribute = 1 << 28
kWindowIgnoreClicksAttribute = 1 << 29
kWindowNoConstrainAttribute = 1 << 31
kWindowStandardDocumentAttributes = kWindowCloseBoxAttribute | \
                                    kWindowFullZoomAttribute | \
                                    kWindowCollapseBoxAttribute | \
                                    kWindowResizableAttribute
kWindowStandardFloatingAttributes = kWindowCloseBoxAttribute | \
                                    kWindowCollapseBoxAttribute

kWindowCenterOnMainScreen = 1
kWindowCenterOnParentWindow = 2
kWindowCenterOnParentWindowScreen = 3
kWindowCascadeOnMainScreen = 4
kWindowCascadeOnParentWindow = 5
kWindowCascadeonParentWindowScreen = 6
kWindowCascadeStartAtParentWindowScreen = 10
kWindowAlertPositionOnMainScreen = 7
kWindowAlertPositionOnParentWindow = 8
kWindowAlertPositionOnParentWindowScreen = 9


kWindowTitleBarRgn            = 0
kWindowTitleTextRgn           = 1
kWindowCloseBoxRgn            = 2
kWindowZoomBoxRgn             = 3
kWindowDragRgn                = 5
kWindowGrowRgn                = 6
kWindowCollapseBoxRgn         = 7
kWindowTitleProxyIconRgn      = 8
kWindowStructureRgn           = 32
kWindowContentRgn             = 33
kWindowUpdateRgn              = 34
kWindowOpaqueRgn              = 35
kWindowGlobalPortRgn          = 40
kWindowToolbarButtonRgn       = 41

inDesk                        = 0
inNoWindow                    = 0
inMenuBar                     = 1
inSysWindow                   = 2
inContent                     = 3
inDrag                        = 4
inGrow                        = 5
inGoAway                      = 6
inZoomIn                      = 7
inZoomOut                     = 8
inCollapseBox                 = 11
inProxyIcon                   = 12
inToolbarButton               = 13
inStructure                   = 15

def _name(name):
    return ord(name[0]) << 24 | \
           ord(name[1]) << 16 | \
           ord(name[2]) << 8 | \
           ord(name[3])

# AEDataModel.h

typeBoolean = _name('bool')
typeChar = _name('TEXT')
typeSInt16 = _name('shor')
typeSInt32 = _name('long')
typeUInt32 = _name('magn')
typeSInt64 = _name('comp')
typeIEEE32BitFloatingPoint = _name('sing')
typeIEEE64BitFloatingPoint = _name('doub')
type128BitFloatingPoint = _name('ldbl')
typeDecimalStruct = _name('decm')

# AERegistry.h
typeUnicodeText = _name('utxt')
typeStyledUnicodeText = _name('sutx')
typeUTF8Text = _name('utf8')
typeEncodedString = _name('encs')
typeCString = _name('cstr')
typePString = _name('pstr')
typeEventRef = _name('evrf')

# CarbonEvents.h

kEventParamWindowRef          = _name('wind')
kEventParamWindowPartCode     = _name('wpar')
kEventParamGrafPort           = _name('graf')
kEventParamMenuRef            = _name('menu')
kEventParamEventRef           = _name('evnt')
kEventParamControlRef         = _name('ctrl')
kEventParamRgnHandle          = _name('rgnh')
kEventParamEnabled            = _name('enab')
kEventParamDimensions         = _name('dims')
kEventParamBounds             = _name('boun')
kEventParamAvailableBounds    = _name('avlb')
#kEventParamAEEventID          = keyAEEventID
#kEventParamAEEventClass       = keyAEEventClass
kEventParamCGContextRef       = _name('cntx')
kEventParamDeviceDepth        = _name('devd')
kEventParamDeviceColor        = _name('devc')
kEventParamMutableArray       = _name('marr')
kEventParamResult             = _name('ansr')
kEventParamMinimumSize        = _name('mnsz')
kEventParamMaximumSize        = _name('mxsz')
kEventParamAttributes         = _name('attr')
kEventParamReason             = _name('why?')
kEventParamTransactionID      = _name('trns')
kEventParamGDevice            = _name('gdev')
kEventParamIndex              = _name('indx')
kEventParamUserData           = _name('usrd')
kEventParamShape              = _name('shap')
typeWindowRef                 = _name('wind')
typeWindowPartCode            = _name('wpar')
typeGrafPtr                   = _name('graf')
typeGWorldPtr                 = _name('gwld')
typeMenuRef                   = _name('menu')
typeControlRef                = _name('ctrl')
typeCollection                = _name('cltn')
typeQDRgnHandle               = _name('rgnh')
typeOSStatus                  = _name('osst')
typeCFIndex                   = _name('cfix')
typeCGContextRef              = _name('cntx')
typeQDPoint                   = _name('QDpt')
typeHICommand                 = _name('hcmd')
typeHIPoint                   = _name('hipt')
typeHISize                    = _name('hisz')
typeHIRect                    = _name('hirc')
typeHIShapeRef                = _name('shap')
typeVoidPtr                   = _name('void')
typeGDHandle                  = _name('gdev')

kCoreEventClass = _name('aevt')
kEventClassMouse = _name('mous')
kEventClassKeyboard = _name('keyb')
kEventClassTextInput = _name('text')
kEventClassApplication = _name('appl')
kEventClassAppleEvent = _name('eppc')
kEventClassMenu = _name('menu')
kEventClassWindow = _name('wind')
kEventClassControl = _name('cntl')
kEventClassCommand = _name('cmds')
kEventClassTablet = _name('tblt')
kEventClassVolume = _name('vol ')
kEventClassAppearance = _name('appm')
kEventClassService = _name('serv')
kEventClassToolbar = _name('tbar')
kEventClassToolbarItem = _name('tbit')
kEventClassToolbarItemView = _name('tbiv')
kEventClassAccessibility = _name('acce')
kEventClassSystem = _name('macs')
kEventClassInk = _name('ink ')
kEventClassTSMDocumentAccess = _name('tdac')

kEventDurationForever = -1.0

# Appearance.h
kThemeArrowCursor             = 0
kThemeCopyArrowCursor         = 1
kThemeAliasArrowCursor        = 2
kThemeContextualMenuArrowCursor = 3
kThemeIBeamCursor             = 4
kThemeCrossCursor             = 5
kThemePlusCursor              = 6
kThemeWatchCursor             = 7
kThemeClosedHandCursor        = 8
kThemeOpenHandCursor          = 9
kThemePointingHandCursor      = 10
kThemeCountingUpHandCursor    = 11
kThemeCountingDownHandCursor  = 12
kThemeCountingUpAndDownHandCursor = 13
kThemeSpinningCursor          = 14
kThemeResizeLeftCursor        = 15
kThemeResizeRightCursor       = 16
kThemeResizeLeftRightCursor   = 17
kThemeNotAllowedCursor        = 18
kThemeResizeUpCursor          = 19
kThemeResizeDownCursor        = 20
kThemeResizeUpDownCursor      = 21
kThemePoofCursor              = 22

# AE
kEventAppleEvent                = 1
kEventAppQuit                   = 3
kAEQuitApplication              = _name('quit')

# Commands
kEventProcessCommand            = 1
kEventParamHICommand            = _name('hcmd')
kEventParamDirectObject         = _name('----')
kHICommandQuit                  = _name('quit')

# Keyboard
kEventRawKeyDown                = 1
kEventRawKeyRepeat              = 2
kEventRawKeyUp                  = 3
kEventRawKeyModifiersChanged    = 4
kEventHotKeyPressed             = 5
kEventHotKeyReleased            = 6

kEventParamKeyCode = _name('kcod')
kEventParamKeyMacCharCodes = _name('kchr')
kEventParamKeyModifiers = _name('kmod')
kEventParamKeyUnicodes = _name('kuni')
kEventParamKeyboardType = _name('kbdt')
typeEventHotKeyID = _name('hkid')

activeFlagBit                 = 0
btnStateBit                   = 7
cmdKeyBit                     = 8
shiftKeyBit                   = 9
alphaLockBit                  = 10
optionKeyBit                  = 11
controlKeyBit                 = 12
rightShiftKeyBit              = 13
rightOptionKeyBit             = 14
rightControlKeyBit            = 15
numLockBit                    = 16

activeFlag                    = 1 << activeFlagBit
btnState                      = 1 << btnStateBit
cmdKey                        = 1 << cmdKeyBit
shiftKey                      = 1 << shiftKeyBit
alphaLock                     = 1 << alphaLockBit
optionKey                     = 1 << optionKeyBit
controlKey                    = 1 << controlKeyBit
rightShiftKey                 = 1 << rightShiftKeyBit
rightOptionKey                = 1 << rightOptionKeyBit
rightControlKey               = 1 << rightControlKeyBit
numLock                       = 1 << numLockBit

# TextInput
kEventTextInputUpdateActiveInputArea    = 1
kEventTextInputUnicodeForKeyEvent       = 2
kEventTextInputOffsetToPos              = 3
kEventTextInputPosToOffset              = 4
kEventTextInputShowHideBottomWindow     = 5
kEventTextInputGetSelectedText          = 6
kEventTextInputUnicodeText              = 7

kEventParamTextInputSendText = _name('tstx')
kEventParamTextInputSendKeyboardEvent = _name('tske')

# Mouse
kEventMouseDown                 = 1
kEventMouseUp                   = 2
kEventMouseMoved                = 5
kEventMouseDragged              = 6
kEventMouseEntered              = 8
kEventMouseExited               = 9
kEventMouseWheelMoved           = 10
kEventParamMouseLocation = _name('mloc')
kEventParamWindowMouseLocation = _name('wmou')
kEventParamMouseButton = _name('mbtn')
kEventParamClickCount = _name('ccnt')
kEventParamMouseWheelAxis = _name('mwax')
kEventParamMouseWheelDelta = _name('mwdl')
kEventParamMouseDelta = _name('mdta')
kEventParamMouseChord = _name('chor')
kEventParamTabletEventType = _name('tblt')
kEventParamMouseTrackingRef = _name('mtrf')
typeMouseButton         = _name('mbtn')
typeMouseWheelAxis      = _name('mwax')
typeMouseTrackingRef    = _name('mtrf')

kMouseTrackingOptionsLocalClip = 0
kMouseTrackingOptionsGlobalClip = 1

kEventMouseButtonPrimary = 1
kEventMouseButtonSecondary = 2
kEventMouseButtonTertiary = 3

kEventMouseWheelAxisX = 0
kEventMouseWheelAxisY = 1

DEFAULT_CREATOR_CODE = _name('PYGL')    # <ah> this is registered for Pyglet
                                        # apps.  register your own at:
                                        # http://developer.apple.com/datatype

# Window
kEventWindowUpdate                  = 1
kEventWindowDrawContent             = 2

# -- window activation events --

kEventWindowActivated               = 5
kEventWindowDeactivated             = 6
kEventWindowHandleActivate          = 91
kEventWindowHandleDeactivate        = 92
kEventWindowGetClickActivation      = 7
kEventWindowGetClickModality        = 8

# -- window state change events --

kEventWindowShowing                 = 22
kEventWindowHiding                  = 23
kEventWindowShown                   = 24
kEventWindowHidden                  = 25
kEventWindowCollapsing              = 86
kEventWindowCollapsed               = 67
kEventWindowExpanding               = 87
kEventWindowExpanded                = 70
kEventWindowZoomed                  = 76
kEventWindowBoundsChanging          = 26
kEventWindowBoundsChanged           = 27
kEventWindowResizeStarted           = 28
kEventWindowResizeCompleted         = 29
kEventWindowDragStarted             = 30
kEventWindowDragCompleted           = 31
kEventWindowClosed                  = 73
kEventWindowTransitionStarted       = 88
kEventWindowTransitionCompleted     = 89

# -- window click events --

kEventWindowClickDragRgn            = 32
kEventWindowClickResizeRgn          = 33
kEventWindowClickCollapseRgn        = 34
kEventWindowClickCloseRgn           = 35
kEventWindowClickZoomRgn            = 36
kEventWindowClickContentRgn         = 37
kEventWindowClickProxyIconRgn       = 38
kEventWindowClickToolbarButtonRgn   = 41
kEventWindowClickStructureRgn       = 42

# -- window cursor change events --

kEventWindowCursorChange            = 40

# -- window action events --

kEventWindowCollapse                = 66
kEventWindowCollapsed               = 67
kEventWindowCollapseAll             = 68
kEventWindowExpand                  = 69
kEventWindowExpanded                = 70
kEventWindowExpandAll               = 71
kEventWindowClose                   = 72
kEventWindowClosed                  = 73
kEventWindowCloseAll                = 74
kEventWindowZoom                    = 75
kEventWindowZoomed                  = 76
kEventWindowZoomAll                 = 77
kEventWindowContextualMenuSelect    = 78
kEventWindowPathSelect              = 79
kEventWindowGetIdealSize            = 80
kEventWindowGetMinimumSize          = 81
kEventWindowGetMaximumSize          = 82
kEventWindowConstrain               = 83
kEventWindowHandleContentClick      = 85
kEventWindowCollapsing              = 86
kEventWindowExpanding               = 87
kEventWindowTransitionStarted       = 88
kEventWindowTransitionCompleted     = 89
kEventWindowGetDockTileMenu         = 90
kEventWindowHandleActivate          = 91
kEventWindowHandleDeactivate        = 92
kEventWindowProxyBeginDrag          = 128
kEventWindowProxyEndDrag            = 129
kEventWindowToolbarSwitchMode       = 150

# -- window focus events --

kEventWindowFocusAcquired           = 200
kEventWindowFocusRelinquish         = 201
kEventWindowFocusContent            = 202
kEventWindowFocusToolbar            = 203
kEventWindowFocusDrawer             = 204

# -- sheet events --

kEventWindowSheetOpening            = 210
kEventWindowSheetOpened             = 211
kEventWindowSheetClosing            = 212
kEventWindowSheetClosed             = 213

# -- drawer events --

kEventWindowDrawerOpening           = 220
kEventWindowDrawerOpened            = 221
kEventWindowDrawerClosing           = 222
kEventWindowDrawerClosed            = 223

# -- window definition events --

kEventWindowDrawFrame               = 1000
kEventWindowDrawPart                = 1001
kEventWindowGetRegion               = 1002
kEventWindowHitTest                 = 1003
kEventWindowInit                    = 1004
kEventWindowDispose                 = 1005
kEventWindowDragHilite              = 1006
kEventWindowModified                = 1007
kEventWindowSetupProxyDragImage     = 1008
kEventWindowStateChanged            = 1009
kEventWindowMeasureTitle            = 1010
kEventWindowDrawGrowBox             = 1011
kEventWindowGetGrowImageRegion      = 1012
kEventWindowPaint                   = 1013

# Process.h

kNoProcess                    = 0
kSystemProcess                = 1
kCurrentProcess               = 2

# CGColorSpace.h
kCGRenderingIntentDefault = 0

# CGImage.h
kCGImageAlphaNone                   = 0
kCGImageAlphaPremultipliedLast      = 1
kCGImageAlphaPremultipliedFirst     = 2
kCGImageAlphaLast                   = 3
kCGImageAlphaFirst                  = 4
kCGImageAlphaNoneSkipLast           = 5
kCGImageAlphaNoneSkipFirst          = 6
kCGImageAlphaOnly                   = 7

########NEW FILE########
__FILENAME__ = quartzkey
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = ''

from pyglet.window import key

# From SDL: src/video/quartz/SDL_QuartzKeys.h
# These are the Macintosh key scancode constants -- from Inside Macintosh

QZ_ESCAPE = 0x35
QZ_F1 = 0x7A
QZ_F2 = 0x78
QZ_F3 = 0x63
QZ_F4 = 0x76
QZ_F5 = 0x60
QZ_F6 = 0x61
QZ_F7 = 0x62
QZ_F8 = 0x64
QZ_F9 = 0x65
QZ_F10 = 0x6D
QZ_F11 = 0x67
QZ_F12 = 0x6F
QZ_PRINT = 0x69
QZ_SCROLLOCK = 0x6B
QZ_PAUSE = 0x71
QZ_POWER = 0x7F
QZ_BACKQUOTE = 0x32
QZ_1 = 0x12
QZ_2 = 0x13
QZ_3 = 0x14
QZ_4 = 0x15
QZ_5 = 0x17
QZ_6 = 0x16
QZ_7 = 0x1A
QZ_8 = 0x1C
QZ_9 = 0x19
QZ_0 = 0x1D
QZ_MINUS = 0x1B
QZ_EQUALS = 0x18
QZ_BACKSPACE = 0x33
QZ_INSERT = 0x72
QZ_HOME = 0x73
QZ_PAGEUP = 0x74
QZ_NUMLOCK = 0x47
QZ_KP_EQUALS = 0x51
QZ_KP_DIVIDE = 0x4B
QZ_KP_MULTIPLY = 0x43
QZ_TAB = 0x30
QZ_q = 0x0C
QZ_w = 0x0D
QZ_e = 0x0E
QZ_r = 0x0F
QZ_t = 0x11
QZ_y = 0x10
QZ_u = 0x20
QZ_i = 0x22
QZ_o = 0x1F
QZ_p = 0x23
QZ_LEFTBRACKET = 0x21
QZ_RIGHTBRACKET = 0x1E
QZ_BACKSLASH = 0x2A
QZ_DELETE = 0x75
QZ_END = 0x77
QZ_PAGEDOWN = 0x79
QZ_KP7 = 0x59
QZ_KP8 = 0x5B
QZ_KP9 = 0x5C
QZ_KP_MINUS = 0x4E
QZ_CAPSLOCK = 0x39
QZ_a = 0x00
QZ_s = 0x01
QZ_d = 0x02
QZ_f = 0x03
QZ_g = 0x05
QZ_h = 0x04
QZ_j = 0x26
QZ_k = 0x28
QZ_l = 0x25
QZ_SEMICOLON = 0x29
QZ_QUOTE = 0x27
QZ_RETURN = 0x24
QZ_KP4 = 0x56
QZ_KP5 = 0x57
QZ_KP6 = 0x58
QZ_KP_PLUS = 0x45
QZ_LSHIFT = 0x38
QZ_z = 0x06
QZ_x = 0x07
QZ_c = 0x08
QZ_v = 0x09
QZ_b = 0x0B
QZ_n = 0x2D
QZ_m = 0x2E
QZ_COMMA = 0x2B
QZ_PERIOD = 0x2F
QZ_SLASH = 0x2C
QZ_RSHIFT = 0x3C
QZ_UP = 0x7E
QZ_KP1 = 0x53
QZ_KP2 = 0x54
QZ_KP3 = 0x55
QZ_KP_ENTER = 0x4C
QZ_LCTRL = 0x3B
QZ_LALT = 0x3A
QZ_LMETA = 0x37
QZ_SPACE = 0x31
QZ_RMETA = 0x36
QZ_RALT = 0x3D
QZ_RCTRL = 0x3E
QZ_LEFT = 0x7B
QZ_DOWN = 0x7D
QZ_RIGHT = 0x7C
QZ_KP0 = 0x52
QZ_KP_PERIOD = 0x41
QZ_IBOOK_ENTER = 0x34
QZ_IBOOK_LEFT = 0x3B
QZ_IBOOK_RIGHT = 0x3C
QZ_IBOOK_DOWN = 0x3D
QZ_IBOOK_UP = 0x3E

keymap = {
    QZ_ESCAPE: key.ESCAPE,
    QZ_F1: key.F1,
    QZ_F2: key.F2,
    QZ_F3: key.F3,
    QZ_F4: key.F4,
    QZ_F5: key.F5,
    QZ_F6: key.F6,
    QZ_F7: key.F7,
    QZ_F8: key.F8,
    QZ_F9: key.F9,
    QZ_F10: key.F10,
    QZ_F11: key.F11,
    QZ_F12: key.F12,
    QZ_PRINT: key.PRINT,
    QZ_SCROLLOCK: key.SCROLLLOCK,
    QZ_PAUSE: key.PAUSE,
    #QZ_POWER: key.POWER,
    QZ_BACKQUOTE: key.QUOTELEFT,
    QZ_1: key._1,
    QZ_2: key._2,
    QZ_3: key._3,
    QZ_4: key._4,
    QZ_5: key._5,
    QZ_6: key._6,
    QZ_7: key._7,
    QZ_8: key._8,
    QZ_9: key._9,
    QZ_0: key._0,
    QZ_MINUS: key.MINUS,
    QZ_EQUALS: key.EQUAL,
    QZ_BACKSPACE: key.BACKSPACE,
    QZ_INSERT: key.INSERT,
    QZ_HOME: key.HOME,
    QZ_PAGEUP: key.PAGEUP,
    QZ_NUMLOCK: key.NUMLOCK,
    QZ_KP_EQUALS: key.NUM_EQUAL,
    QZ_KP_DIVIDE: key.NUM_DIVIDE,
    QZ_KP_MULTIPLY: key.NUM_MULTIPLY,
    QZ_TAB: key.TAB,
    QZ_q: key.Q,
    QZ_w: key.W,
    QZ_e: key.E,
    QZ_r: key.R,
    QZ_t: key.T,
    QZ_y: key.Y,
    QZ_u: key.U,
    QZ_i: key.I,
    QZ_o: key.O,
    QZ_p: key.P,
    QZ_LEFTBRACKET: key.BRACKETLEFT,
    QZ_RIGHTBRACKET: key.BRACKETRIGHT,
    QZ_BACKSLASH: key.BACKSLASH,
    QZ_DELETE: key.DELETE,
    QZ_END: key.END,
    QZ_PAGEDOWN: key.PAGEDOWN,
    QZ_KP7: key.NUM_7,
    QZ_KP8: key.NUM_8,
    QZ_KP9: key.NUM_9,
    QZ_KP_MINUS: key.NUM_SUBTRACT,
    QZ_CAPSLOCK: key.CAPSLOCK,
    QZ_a: key.A,
    QZ_s: key.S,
    QZ_d: key.D,
    QZ_f: key.F,
    QZ_g: key.G,
    QZ_h: key.H,
    QZ_j: key.J,
    QZ_k: key.K,
    QZ_l: key.L,
    QZ_SEMICOLON: key.SEMICOLON,
    QZ_QUOTE: key.APOSTROPHE,
    QZ_RETURN: key.RETURN,
    QZ_KP4: key.NUM_4,
    QZ_KP5: key.NUM_5,
    QZ_KP6: key.NUM_6,
    QZ_KP_PLUS: key.NUM_ADD,
    QZ_LSHIFT: key.LSHIFT,
    QZ_z: key.Z,
    QZ_x: key.X,
    QZ_c: key.C,
    QZ_v: key.V,
    QZ_b: key.B,
    QZ_n: key.N,
    QZ_m: key.M,
    QZ_COMMA: key.COMMA,
    QZ_PERIOD: key.PERIOD,
    QZ_SLASH: key.SLASH,
    QZ_RSHIFT: key.RSHIFT,
    QZ_UP: key.UP,
    QZ_KP1: key.NUM_1,
    QZ_KP2: key.NUM_2,
    QZ_KP3: key.NUM_3,
    QZ_KP_ENTER: key.NUM_ENTER,
    QZ_LCTRL: key.LCTRL,
    QZ_LALT: key.LALT,
    QZ_LMETA: key.LMETA,
    QZ_SPACE: key.SPACE,
    QZ_RMETA: key.RMETA,
    QZ_RALT: key.RALT,
    QZ_RCTRL: key.RCTRL,
    QZ_LEFT: key.LEFT,
    QZ_DOWN: key.DOWN,
    QZ_RIGHT: key.RIGHT,
    QZ_KP0: key.NUM_0,
    QZ_KP_PERIOD: key.NUM_DECIMAL,
    QZ_IBOOK_ENTER: key.ENTER,
    QZ_IBOOK_LEFT: key.LEFT,
    QZ_IBOOK_RIGHT: key.RIGHT,
    QZ_IBOOK_DOWN: key.DOWN,
    QZ_IBOOK_UP: key.UP,
}



########NEW FILE########
__FILENAME__ = types
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

from ctypes import *

import pyglet.gl.agl
agl = pyglet.gl.agl

Boolean = c_ubyte           # actually an unsigned char
Fixed = c_int32
ItemCount = c_uint32
ByteOffset = ByteCount = c_uint32

GDHandle = agl.GDHandle

class Rect(Structure):
    _fields_ = [
        ('top', c_short),
        ('left', c_short),
        ('bottom', c_short),
        ('right', c_short)
    ]

class Point(Structure):
    _fields_ = [
        ('v', c_short),
        ('h', c_short),
    ]

class CGPoint(Structure):
    _fields_ = [
        ('x', c_float),
        ('y', c_float),
    ]

class CGSize(Structure):
    _fields_ = [
        ('width', c_float),
        ('height', c_float)
    ]

class CGRect(Structure):
    _fields_ = [
        ('origin', CGPoint),
        ('size', CGSize)
    ]
    __slots__ = ['origin', 'size']

CGDirectDisplayID = c_void_p
CGDisplayCount = c_uint32
CGTableCount = c_uint32
CGDisplayCoord = c_int32
CGByteValue = c_ubyte
CGOpenGLDisplayMask = c_uint32
CGRefreshRate = c_double
CGCaptureOptions = c_uint32

HIPoint = CGPoint
HISize = CGSize
HIRect = CGRect

class EventTypeSpec(Structure):
    _fields_ = [
        ('eventClass', c_uint32),
        ('eventKind', c_uint32)
    ]

WindowRef = c_void_p
EventRef = c_void_p
EventTargetRef = c_void_p
EventHandlerRef = c_void_p

MenuRef = c_void_p
MenuID = c_int16
MenuItemIndex = c_uint16
MenuCommand = c_uint32

CFStringEncoding = c_uint
WindowClass = c_uint32
WindowAttributes = c_uint32
WindowPositionMethod = c_uint32
EventMouseButton = c_uint16
EventMouseWheelAxis = c_uint16

OSType = c_uint32
OSStatus = c_int32


class MouseTrackingRegionID(Structure):
    _fields_ = [('signature', OSType),
                ('id', c_int32)]

MouseTrackingRef = c_void_p

RgnHandle = c_void_p

class ProcessSerialNumber(Structure):
    _fields_ = [('highLongOfPSN', c_uint32),
                ('lowLongOfPSN', c_uint32)]


class HICommand_Menu(Structure):
    _fields_ = [
        ('menuRef', MenuRef),
        ('menuItemIndex', MenuItemIndex),
    ]

class HICommand(Structure):
    _fields_ = [
        ('attributes', c_uint32),
        ('commandID', c_uint32),
        ('menu', HICommand_Menu)
    ]

class EventRecord(Structure):
    _fields_ = [
        ('what', c_uint16),
        ('message', c_uint32),
        ('when', c_uint32),
        ('where', Point),
        ('modifiers', c_uint16)
    ]

########NEW FILE########
__FILENAME__ = event
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Events for `pyglet.window`.

See `Window` for a description of the window event types.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: event.py 1669 2008-01-27 01:31:58Z Alex.Holkner $'

import sys

from pyglet.window import key
from pyglet.window import mouse

class WindowExitHandler(object):
    '''Determine if the window should be closed.

    This event handler watches for the ESC key or the window close event
    and sets `self.has_exit` to True when either is pressed.  An instance
    of this class is automatically attached to all new `pyglet.window.Window`
    objects.

    :deprecated: This class's functionality is provided directly on `Window`
        in pyglet 1.1.

    :Ivariables:
        `has_exit` : bool
            True if the user wants to close the window.

    '''
    has_exit = False

    def on_close(self):
        self.has_exit = True

    def on_key_press(self, symbol, modifiers):
        if symbol == key.ESCAPE:
            self.has_exit = True

class WindowEventLogger(object):
    '''Print all events to a file.

    When this event handler is added to a window it prints out all events
    and their parameters; useful for debugging or discovering which events
    you need to handle.

    Example::

        win = window.Window()
        win.push_handlers(WindowEventLogger())

    '''
    def __init__(self, logfile=None):
        '''Create a `WindowEventLogger` which writes to `logfile`.

        :Parameters:
            `logfile` : file-like object
                The file to write to.  If unspecified, stdout will be used.

        '''
        if logfile is None:
            import sys
            logfile = sys.stdout
        self.file = logfile

    def on_key_press(self, symbol, modifiers):
        print >> self.file, 'on_key_press(symbol=%s, modifiers=%s)' % (
            key.symbol_string(symbol), key.modifiers_string(modifiers))

    def on_key_release(self, symbol, modifiers):
        print >> self.file, 'on_key_release(symbol=%s, modifiers=%s)' % (
            key.symbol_string(symbol), key.modifiers_string(modifiers))

    def on_text(self, text):
        print >> self.file, 'on_text(text=%r)' % text

    def on_text_motion(self, motion):
        print >> self.file, 'on_text_motion(motion=%s)' % (
            key.motion_string(motion))

    def on_text_motion_select(self, motion):
        print >> self.file, 'on_text_motion_select(motion=%s)' % (
            key.motion_string(motion))

    def on_mouse_motion(self, x, y, dx, dy):
        print >> self.file, 'on_mouse_motion(x=%d, y=%d, dx=%d, dy=%d)' % (
            x, y, dx, dy)

    def on_mouse_drag(self, x, y, dx, dy, buttons, modifiers):
        print >> self.file, 'on_mouse_drag(x=%d, y=%d, dx=%d, dy=%d, '\
                            'buttons=%s, modifiers=%s)' % (
              x, y, dx, dy,
              mouse.buttons_string(buttons), key.modifiers_string(modifiers))

    def on_mouse_press(self, x, y, button, modifiers):
        print >> self.file, 'on_mouse_press(x=%d, y=%d, button=%r, '\
                            'modifiers=%s)' % (x, y,
            mouse.buttons_string(button), key.modifiers_string(modifiers))

    def on_mouse_release(self, x, y, button, modifiers):
        print >> self.file, 'on_mouse_release(x=%d, y=%d, button=%r, '\
                            'modifiers=%s)' % (x, y,
            mouse.buttons_string(button), key.modifiers_string(modifiers))

    def on_mouse_scroll(self, x, y, dx, dy):
        print >> self.file, 'on_mouse_scroll(x=%f, y=%f, dx=%f, dy=%f)' % (
            x, y, dx, dy)

    def on_close(self):
        print >> self.file, 'on_close()'

    def on_mouse_enter(self, x, y):
        print >> self.file, 'on_mouse_enter(x=%d, y=%d)' % (x, y)

    def on_mouse_leave(self, x, y):
        print >> self.file, 'on_mouse_leave(x=%d, y=%d)' % (x, y)

    def on_expose(self):
        print >> self.file, 'on_expose()'

    def on_resize(self, width, height):
        print >> self.file, 'on_resize(width=%d, height=%d)' % (width, height)

    def on_move(self, x, y):
        print >> self.file, 'on_move(x=%d, y=%d)' % (x, y)

    def on_activate(self):
        print >> self.file, 'on_activate()'

    def on_deactivate(self):
        print >> self.file, 'on_deactivate()'

    def on_show(self):
        print >> self.file, 'on_show()'

    def on_hide(self):
        print >> self.file, 'on_hide()'

    def on_context_lost(self):
        print >> self.file, 'on_context_lost()'

    def on_context_state_lost(self):
        print >> self.file, 'on_context_state_lost()'


########NEW FILE########
__FILENAME__ = key
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Key constants and utilities for pyglet.window.

Usage::

    from pyglet.window import Window
    from pyglet.window import key

    window = Window()

    @window.event
    def on_key_press(symbol, modifiers):
        # Symbolic names:
        if symbol == key.RETURN:

        # Alphabet keys:
        elif symbol == key.Z:

        # Number keys:
        elif symbol == key._1:

        # Number keypad keys:
        elif symbol == key.NUM_1:

        # Modifiers:
        if modifiers & key.MOD_CTRL:

'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: key.py 1919 2008-03-19 07:47:01Z Alex.Holkner $'

class KeyStateHandler(dict):
    '''Simple handler that tracks the state of keys on the keyboard. If a
    key is pressed then this handler holds a True value for it.

    For example::

        >>> win = window.Window
        >>> keyboard = key.KeyStateHandler()
        >>> win.push_handlers(keyboard)

        # Hold down the "up" arrow...

        >>> keyboard[key.UP]
        True
        >>> keyboard[key.DOWN]
        False

    '''
    def on_key_press(self, symbol, modifiers):
        self[symbol] = True
    def on_key_release(self, symbol, modifiers):
        self[symbol] = False
    def __getitem__(self, key):
        return self.get(key, False)

def modifiers_string(modifiers):
    '''Return a string describing a set of modifiers.

    Example::

        >>> modifiers_string(MOD_SHIFT | MOD_CTRL)
        'MOD_SHIFT|MOD_CTRL'

    :Parameters:
        `modifiers` : int
            Bitwise combination of modifier constants.

    :rtype: str
    '''
    mod_names = []
    if modifiers & MOD_SHIFT:
        mod_names.append('MOD_SHIFT')
    if modifiers & MOD_CTRL:
        mod_names.append('MOD_CTRL')
    if modifiers & MOD_ALT:
        mod_names.append('MOD_ALT')
    if modifiers & MOD_CAPSLOCK:
        mod_names.append('MOD_CAPSLOCK')
    if modifiers & MOD_NUMLOCK:
        mod_names.append('MOD_NUMLOCK')
    if modifiers & MOD_SCROLLLOCK:
        mod_names.append('MOD_SCROLLLOCK')
    if modifiers & MOD_COMMAND:
        mod_names.append('MOD_COMMAND')
    if modifiers & MOD_OPTION:
        mod_names.append('MOD_OPTION')
    return '|'.join(mod_names)

def symbol_string(symbol):
    '''Return a string describing a key symbol.

    Example::

        >>> symbol_string(BACKSPACE)
        'BACKSPACE'

    :Parameters:
        `symbol` : int
            Symbolic key constant.

    :rtype: str
    '''
    if symbol < 1 << 32:
        return _key_names.get(symbol, str(symbol))
    else:
        return 'user_key(%x)' % (symbol >> 32)

def motion_string(motion):
    '''Return a string describing a text motion.

    Example::

        >>> motion_string(MOTION_NEXT_WORD):
        'MOTION_NEXT_WORD'

    :Parameters:
        `motion` : int
            Text motion constant.

    :rtype: str
    '''
    return _motion_names.get(motion, str(motion))

def user_key(scancode):
    '''Return a key symbol for a key not supported by pyglet.

    This can be used to map virtual keys or scancodes from unsupported
    keyboard layouts into a machine-specific symbol.  The symbol will
    be meaningless on any other machine, or under a different keyboard layout.

    Applications should use user-keys only when user explicitly binds them
    (for example, mapping keys to actions in a game options screen).
    '''
    assert scancode > 0
    return scancode << 32

# Modifier mask constants
MOD_SHIFT       = 1 << 0
MOD_CTRL        = 1 << 1
MOD_ALT         = 1 << 2
MOD_CAPSLOCK    = 1 << 3
MOD_NUMLOCK     = 1 << 4
MOD_WINDOWS     = 1 << 5
MOD_COMMAND     = 1 << 6
MOD_OPTION      = 1 << 7
MOD_SCROLLLOCK  = 1 << 8

#: Accelerator modifier.  On Windows and Linux, this is ``MOD_CTRL``, on
#: Mac OS X it's ``MOD_COMMAND``.
MOD_ACCEL       = MOD_CTRL
import sys as _sys
if _sys.platform == 'darwin':
    MOD_ACCEL   = MOD_COMMAND


# Key symbol constants

# ASCII commands
BACKSPACE     = 0xff08
TAB           = 0xff09
LINEFEED      = 0xff0a
CLEAR         = 0xff0b
RETURN        = 0xff0d
ENTER         = 0xff0d      # synonym
PAUSE         = 0xff13
SCROLLLOCK    = 0xff14
SYSREQ        = 0xff15
ESCAPE        = 0xff1b
SPACE         = 0xff20

# Cursor control and motion
HOME          = 0xff50
LEFT          = 0xff51
UP            = 0xff52
RIGHT         = 0xff53
DOWN          = 0xff54
PAGEUP        = 0xff55
PAGEDOWN      = 0xff56
END           = 0xff57
BEGIN         = 0xff58

# Misc functions
DELETE        = 0xffff
SELECT        = 0xff60
PRINT         = 0xff61
EXECUTE       = 0xff62
INSERT        = 0xff63
UNDO          = 0xff65
REDO          = 0xff66
MENU          = 0xff67
FIND          = 0xff68
CANCEL        = 0xff69
HELP          = 0xff6a
BREAK         = 0xff6b
MODESWITCH    = 0xff7e
SCRIPTSWITCH  = 0xff7e

# Text motion constants: these are allowed to clash with key constants
MOTION_UP                = UP
MOTION_RIGHT             = RIGHT
MOTION_DOWN              = DOWN
MOTION_LEFT              = LEFT
MOTION_NEXT_WORD         = 1
MOTION_PREVIOUS_WORD     = 2
MOTION_BEGINNING_OF_LINE = 3
MOTION_END_OF_LINE       = 4
MOTION_NEXT_PAGE         = PAGEDOWN
MOTION_PREVIOUS_PAGE     = PAGEUP
MOTION_BEGINNING_OF_FILE = 5
MOTION_END_OF_FILE       = 6
MOTION_BACKSPACE         = BACKSPACE
MOTION_DELETE            = DELETE

# Number pad
NUMLOCK       = 0xff7f
NUM_SPACE     = 0xff80
NUM_TAB       = 0xff89
NUM_ENTER     = 0xff8d
NUM_F1        = 0xff91
NUM_F2        = 0xff92
NUM_F3        = 0xff93
NUM_F4        = 0xff94
NUM_HOME      = 0xff95
NUM_LEFT      = 0xff96
NUM_UP        = 0xff97
NUM_RIGHT     = 0xff98
NUM_DOWN      = 0xff99
NUM_PRIOR     = 0xff9a
NUM_PAGE_UP   = 0xff9a
NUM_NEXT      = 0xff9b
NUM_PAGE_DOWN = 0xff9b
NUM_END       = 0xff9c
NUM_BEGIN     = 0xff9d
NUM_INSERT    = 0xff9e
NUM_DELETE    = 0xff9f
NUM_EQUAL     = 0xffbd
NUM_MULTIPLY  = 0xffaa
NUM_ADD       = 0xffab
NUM_SEPARATOR = 0xffac
NUM_SUBTRACT  = 0xffad
NUM_DECIMAL   = 0xffae
NUM_DIVIDE    = 0xffaf

NUM_0         = 0xffb0
NUM_1         = 0xffb1
NUM_2         = 0xffb2
NUM_3         = 0xffb3
NUM_4         = 0xffb4
NUM_5         = 0xffb5
NUM_6         = 0xffb6
NUM_7         = 0xffb7
NUM_8         = 0xffb8
NUM_9         = 0xffb9

# Function keys
F1            = 0xffbe
F2            = 0xffbf
F3            = 0xffc0
F4            = 0xffc1
F5            = 0xffc2
F6            = 0xffc3
F7            = 0xffc4
F8            = 0xffc5
F9            = 0xffc6
F10           = 0xffc7
F11           = 0xffc8
F12           = 0xffc9
F13           = 0xffca
F14           = 0xffcb
F15           = 0xffcc
F16           = 0xffcd

# Modifiers
LSHIFT        = 0xffe1
RSHIFT        = 0xffe2
LCTRL         = 0xffe3
RCTRL         = 0xffe4
CAPSLOCK      = 0xffe5
LMETA         = 0xffe7
RMETA         = 0xffe8
LALT          = 0xffe9
RALT          = 0xffea
LWINDOWS      = 0xffeb
RWINDOWS      = 0xffec
LCOMMAND      = 0xffed
RCOMMAND      = 0xffee
LOPTION       = 0xffd0
ROPTION       = 0xffd1

# Latin-1
SPACE         = 0x020
EXCLAMATION   = 0x021
DOUBLEQUOTE   = 0x022
HASH          = 0x023
POUND         = 0x023  # synonym
DOLLAR        = 0x024
PERCENT       = 0x025
AMPERSAND     = 0x026
APOSTROPHE    = 0x027
PARENLEFT     = 0x028
PARENRIGHT    = 0x029
ASTERISK      = 0x02a
PLUS          = 0x02b
COMMA         = 0x02c
MINUS         = 0x02d
PERIOD        = 0x02e
SLASH         = 0x02f
_0            = 0x030
_1            = 0x031
_2            = 0x032
_3            = 0x033
_4            = 0x034
_5            = 0x035
_6            = 0x036
_7            = 0x037
_8            = 0x038
_9            = 0x039
COLON         = 0x03a
SEMICOLON     = 0x03b
LESS          = 0x03c
EQUAL         = 0x03d
GREATER       = 0x03e
QUESTION      = 0x03f
AT            = 0x040
BRACKETLEFT   = 0x05b
BACKSLASH     = 0x05c
BRACKETRIGHT  = 0x05d
ASCIICIRCUM   = 0x05e
UNDERSCORE    = 0x05f
GRAVE         = 0x060
QUOTELEFT     = 0x060
A             = 0x061
B             = 0x062
C             = 0x063
D             = 0x064
E             = 0x065
F             = 0x066
G             = 0x067
H             = 0x068
I             = 0x069
J             = 0x06a
K             = 0x06b
L             = 0x06c
M             = 0x06d
N             = 0x06e
O             = 0x06f
P             = 0x070
Q             = 0x071
R             = 0x072
S             = 0x073
T             = 0x074
U             = 0x075
V             = 0x076
W             = 0x077
X             = 0x078
Y             = 0x079
Z             = 0x07a
BRACELEFT     = 0x07b
BAR           = 0x07c
BRACERIGHT    = 0x07d
ASCIITILDE    = 0x07e

_key_names = {}
_motion_names = {}
for _name, _value in locals().items():
    if _name[:2] != '__' and _name.upper() == _name and \
       not _name.startswith('MOD_'):
        if _name.startswith('MOTION_'):
            _motion_names[_value] = _name
        else:
            _key_names[_value] = _name


########NEW FILE########
__FILENAME__ = mouse
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''Mouse constants and utilities for pyglet.window.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: mouse.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

def buttons_string(buttons):
    '''Return a string describing a set of active mouse buttons.

    Example::

        >>> buttons_string(LEFT | RIGHT)
        'LEFT|RIGHT'

    :Parameters:
        `buttons` : int
            Bitwise combination of mouse button constants.

    :rtype: str
    '''
    button_names = []
    if buttons & LEFT:
        button_names.append('LEFT')
    if buttons & MIDDLE:
        button_names.append('MIDDLE')
    if buttons & RIGHT:
        button_names.append('RIGHT')
    return '|'.join(button_names)

# Symbolic names for the mouse buttons
LEFT =   1 << 0
MIDDLE = 1 << 1
RIGHT =  1 << 2

########NEW FILE########
__FILENAME__ = constants
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
# Most of this file is win32con.py from Python for Windows Extensions:
# http://www.python.net/crew/mhammond/win32/

# From Windows 2000 API SuperBible:

VK_OEM_1 = 0xba
VK_OEM_PLUS = 0xbb
VK_OEM_COMMA = 0xbc
VK_OEM_MINUS = 0xbd
VK_OEM_PERIOD = 0xbe
VK_OEM_2 = 0xbf
VK_OEM_3 = 0xc0
VK_OEM_4 = 0xdb
VK_OEM_5 = 0xdc
VK_OEM_6 = 0xdd
VK_OEM_7 = 0xde
VK_OEM_8 = 0xdf
VK_OEM_102 = 0xe2

# Copyright (c) 1994-2001, Mark Hammond
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer.
#
# Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in
# the documentation and/or other materials provided with the distribution.
#
# Neither name of Mark Hammond nor the name of contributors may be used
# to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS
# IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. P

# From WinGDI.h
PFD_TYPE_RGBA = 0
PFD_TYPE_COLORINDEX = 1
PFD_MAIN_PLANE = 0
PFD_OVERLAY_PLANE = 1
PFD_UNDERLAY_PLANE = (-1)
PFD_DOUBLEBUFFER = 0x00000001
PFD_STEREO = 0x00000002
PFD_DRAW_TO_WINDOW = 0x00000004
PFD_DRAW_TO_BITMAP = 0x00000008
PFD_SUPPORT_GDI = 0x00000010
PFD_SUPPORT_OPENGL = 0x00000020
PFD_GENERIC_FORMAT = 0x00000040
PFD_NEED_PALETTE = 0x00000080
PFD_NEED_SYSTEM_PALETTE = 0x00000100
PFD_SWAP_EXCHANGE = 0x00000200
PFD_SWAP_COPY = 0x00000400
PFD_SWAP_LAYER_BUFFERS = 0x00000800
PFD_GENERIC_ACCELERATED = 0x00001000
PFD_SUPPORT_DIRECTDRAW = 0x00002000
PFD_DEPTH_DONTCARE = 0x20000000
PFD_DOUBLEBUFFER_DONTCARE = 0x40000000
PFD_STEREO_DONTCARE = 0x80000000

# Generated by h2py from commdlg.h (plus modifications 4jan98)
WINVER = 1280
WM_USER = 1024
PY_0U = 0
OFN_READONLY = 1
OFN_OVERWRITEPROMPT = 2
OFN_HIDEREADONLY = 4
OFN_NOCHANGEDIR = 8
OFN_SHOWHELP = 16
OFN_ENABLEHOOK = 32
OFN_ENABLETEMPLATE = 64
OFN_ENABLETEMPLATEHANDLE = 128
OFN_NOVALIDATE = 256
OFN_ALLOWMULTISELECT = 512
OFN_EXTENSIONDIFFERENT = 1024
OFN_PATHMUSTEXIST = 2048
OFN_FILEMUSTEXIST = 4096
OFN_CREATEPROMPT = 8192
OFN_SHAREAWARE = 16384
OFN_NOREADONLYRETURN = 32768
OFN_NOTESTFILECREATE = 65536
OFN_NONETWORKBUTTON = 131072
OFN_NOLONGNAMES = 262144
OFN_EXPLORER = 524288            # new look commdlg
OFN_NODEREFERENCELINKS = 1048576
OFN_LONGNAMES = 2097152           # force long names for 3.x modules
OFN_ENABLEINCLUDENOTIFY = 4194304 # send include message to callback
OFN_ENABLESIZING = 8388608
OFN_DONTADDTORECENT = 33554432
OFN_FORCESHOWHIDDEN = 268435456 # Show All files including System and hidden files
OFN_EX_NOPLACESBAR = 1
OFN_SHAREFALLTHROUGH = 2
OFN_SHARENOWARN = 1
OFN_SHAREWARN = 0
CDN_FIRST = (PY_0U-601)
CDN_LAST = (PY_0U-699)
CDN_INITDONE = (CDN_FIRST - 0)
CDN_SELCHANGE = (CDN_FIRST - 1)
CDN_FOLDERCHANGE = (CDN_FIRST - 2)
CDN_SHAREVIOLATION = (CDN_FIRST - 3)
CDN_HELP = (CDN_FIRST - 4)
CDN_FILEOK = (CDN_FIRST - 5)
CDN_TYPECHANGE = (CDN_FIRST - 6)
CDN_INCLUDEITEM = (CDN_FIRST - 7)
CDM_FIRST = (WM_USER + 100)
CDM_LAST = (WM_USER + 200)
CDM_GETSPEC = (CDM_FIRST + 0)
CDM_GETFILEPATH = (CDM_FIRST + 1)
CDM_GETFOLDERPATH = (CDM_FIRST + 2)
CDM_GETFOLDERIDLIST = (CDM_FIRST + 3)
CDM_SETCONTROLTEXT = (CDM_FIRST + 4)
CDM_HIDECONTROL = (CDM_FIRST + 5)
CDM_SETDEFEXT = (CDM_FIRST + 6)
CC_RGBINIT = 1
CC_FULLOPEN = 2
CC_PREVENTFULLOPEN = 4
CC_SHOWHELP = 8
CC_ENABLEHOOK = 16
CC_ENABLETEMPLATE = 32
CC_ENABLETEMPLATEHANDLE = 64
CC_SOLIDCOLOR = 128
CC_ANYCOLOR = 256
FR_DOWN = 1
FR_WHOLEWORD = 2
FR_MATCHCASE = 4
FR_FINDNEXT = 8
FR_REPLACE = 16
FR_REPLACEALL = 32
FR_DIALOGTERM = 64
FR_SHOWHELP = 128
FR_ENABLEHOOK = 256
FR_ENABLETEMPLATE = 512
FR_NOUPDOWN = 1024
FR_NOMATCHCASE = 2048
FR_NOWHOLEWORD = 4096
FR_ENABLETEMPLATEHANDLE = 8192
FR_HIDEUPDOWN = 16384
FR_HIDEMATCHCASE = 32768
FR_HIDEWHOLEWORD = 65536
CF_SCREENFONTS = 1
CF_PRINTERFONTS = 2
CF_BOTH = (CF_SCREENFONTS | CF_PRINTERFONTS)
CF_SHOWHELP = 4
CF_ENABLEHOOK = 8
CF_ENABLETEMPLATE = 16
CF_ENABLETEMPLATEHANDLE = 32
CF_INITTOLOGFONTSTRUCT = 64
CF_USESTYLE = 128
CF_EFFECTS = 256
CF_APPLY = 512
CF_ANSIONLY = 1024
CF_SCRIPTSONLY = CF_ANSIONLY
CF_NOVECTORFONTS = 2048
CF_NOOEMFONTS = CF_NOVECTORFONTS
CF_NOSIMULATIONS = 4096
CF_LIMITSIZE = 8192
CF_FIXEDPITCHONLY = 16384
CF_WYSIWYG = 32768 # must also have CF_SCREENFONTS & CF_PRINTERFONTS
CF_FORCEFONTEXIST = 65536
CF_SCALABLEONLY = 131072
CF_TTONLY = 262144
CF_NOFACESEL = 524288
CF_NOSTYLESEL = 1048576
CF_NOSIZESEL = 2097152
CF_SELECTSCRIPT = 4194304
CF_NOSCRIPTSEL = 8388608
CF_NOVERTFONTS = 16777216
SIMULATED_FONTTYPE = 32768
PRINTER_FONTTYPE = 16384
SCREEN_FONTTYPE = 8192
BOLD_FONTTYPE = 256
ITALIC_FONTTYPE = 512
REGULAR_FONTTYPE = 1024
OPENTYPE_FONTTYPE = 65536
TYPE1_FONTTYPE = 131072
DSIG_FONTTYPE = 262144
WM_CHOOSEFONT_GETLOGFONT = (WM_USER + 1)
WM_CHOOSEFONT_SETLOGFONT = (WM_USER + 101)
WM_CHOOSEFONT_SETFLAGS = (WM_USER + 102)
LBSELCHSTRINGA = "commdlg_LBSelChangedNotify"
SHAREVISTRINGA = "commdlg_ShareViolation"
FILEOKSTRINGA = "commdlg_FileNameOK"
COLOROKSTRINGA = "commdlg_ColorOK"
SETRGBSTRINGA = "commdlg_SetRGBColor"
HELPMSGSTRINGA = "commdlg_help"
FINDMSGSTRINGA = "commdlg_FindReplace"
LBSELCHSTRING = LBSELCHSTRINGA
SHAREVISTRING = SHAREVISTRINGA
FILEOKSTRING = FILEOKSTRINGA
COLOROKSTRING = COLOROKSTRINGA
SETRGBSTRING = SETRGBSTRINGA
HELPMSGSTRING = HELPMSGSTRINGA
FINDMSGSTRING = FINDMSGSTRINGA
CD_LBSELNOITEMS = -1
CD_LBSELCHANGE = 0
CD_LBSELSUB = 1
CD_LBSELADD = 2
PD_ALLPAGES = 0
PD_SELECTION = 1
PD_PAGENUMS = 2
PD_NOSELECTION = 4
PD_NOPAGENUMS = 8
PD_COLLATE = 16
PD_PRINTTOFILE = 32
PD_PRINTSETUP = 64
PD_NOWARNING = 128
PD_RETURNDC = 256
PD_RETURNIC = 512
PD_RETURNDEFAULT = 1024
PD_SHOWHELP = 2048
PD_ENABLEPRINTHOOK = 4096
PD_ENABLESETUPHOOK = 8192
PD_ENABLEPRINTTEMPLATE = 16384
PD_ENABLESETUPTEMPLATE = 32768
PD_ENABLEPRINTTEMPLATEHANDLE = 65536
PD_ENABLESETUPTEMPLATEHANDLE = 131072
PD_USEDEVMODECOPIES = 262144
PD_DISABLEPRINTTOFILE = 524288
PD_HIDEPRINTTOFILE = 1048576
PD_NONETWORKBUTTON = 2097152
DN_DEFAULTPRN = 1
WM_PSD_PAGESETUPDLG = (WM_USER  )
WM_PSD_FULLPAGERECT = (WM_USER+1)
WM_PSD_MINMARGINRECT = (WM_USER+2)
WM_PSD_MARGINRECT = (WM_USER+3)
WM_PSD_GREEKTEXTRECT = (WM_USER+4)
WM_PSD_ENVSTAMPRECT = (WM_USER+5)
WM_PSD_YAFULLPAGERECT = (WM_USER+6)
PSD_DEFAULTMINMARGINS = 0 # default (printer's)
PSD_INWININIINTLMEASURE = 0 # 1st of 4 possible
PSD_MINMARGINS = 1 # use caller's
PSD_MARGINS = 2 # use caller's
PSD_INTHOUSANDTHSOFINCHES = 4 # 2nd of 4 possible
PSD_INHUNDREDTHSOFMILLIMETERS = 8 # 3rd of 4 possible
PSD_DISABLEMARGINS = 16
PSD_DISABLEPRINTER = 32
PSD_NOWARNING = 128 # must be same as PD_*
PSD_DISABLEORIENTATION = 256
PSD_RETURNDEFAULT = 1024 # must be same as PD_*
PSD_DISABLEPAPER = 512
PSD_SHOWHELP = 2048 # must be same as PD_*
PSD_ENABLEPAGESETUPHOOK = 8192 # must be same as PD_*
PSD_ENABLEPAGESETUPTEMPLATE = 32768 # must be same as PD_*
PSD_ENABLEPAGESETUPTEMPLATEHANDLE = 131072 # must be same as PD_*
PSD_ENABLEPAGEPAINTHOOK = 262144
PSD_DISABLEPAGEPAINTING = 524288
PSD_NONETWORKBUTTON = 2097152 # must be same as PD_*

# Generated by h2py from winreg.h
HKEY_CLASSES_ROOT = -2147483648
HKEY_CURRENT_USER = -2147483647
HKEY_LOCAL_MACHINE = -2147483646
HKEY_USERS = -2147483645
HKEY_PERFORMANCE_DATA = -2147483644
HKEY_CURRENT_CONFIG = -2147483643
HKEY_DYN_DATA = -2147483642
HKEY_PERFORMANCE_TEXT = -2147483568  # ?? 4Jan98
HKEY_PERFORMANCE_NLSTEXT = -2147483552  # ?? 4Jan98

# Generated by h2py from winuser.h
HWND_BROADCAST = 65535
HWND_DESKTOP = 0
HWND_TOP = 0
HWND_BOTTOM = 1
HWND_TOPMOST = -1
HWND_NOTOPMOST = -2
HWND_MESSAGE = -3

# winuser.h line 4601
SM_CXSCREEN = 0
SM_CYSCREEN = 1
SM_CXVSCROLL = 2
SM_CYHSCROLL = 3
SM_CYCAPTION = 4
SM_CXBORDER = 5
SM_CYBORDER = 6
SM_CXDLGFRAME = 7
SM_CYDLGFRAME = 8
SM_CYVTHUMB = 9
SM_CXHTHUMB = 10
SM_CXICON = 11
SM_CYICON = 12
SM_CXCURSOR = 13
SM_CYCURSOR = 14
SM_CYMENU = 15
SM_CXFULLSCREEN = 16
SM_CYFULLSCREEN = 17
SM_CYKANJIWINDOW = 18
SM_MOUSEPRESENT = 19
SM_CYVSCROLL = 20
SM_CXHSCROLL = 21
SM_DEBUG = 22
SM_SWAPBUTTON = 23
SM_RESERVED1 = 24
SM_RESERVED2 = 25
SM_RESERVED3 = 26
SM_RESERVED4 = 27
SM_CXMIN = 28
SM_CYMIN = 29
SM_CXSIZE = 30
SM_CYSIZE = 31
SM_CXFRAME = 32
SM_CYFRAME = 33
SM_CXMINTRACK = 34
SM_CYMINTRACK = 35
SM_CXDOUBLECLK = 36
SM_CYDOUBLECLK = 37
SM_CXICONSPACING = 38
SM_CYICONSPACING = 39
SM_MENUDROPALIGNMENT = 40
SM_PENWINDOWS = 41
SM_DBCSENABLED = 42
SM_CMOUSEBUTTONS = 43
SM_CXFIXEDFRAME = SM_CXDLGFRAME
SM_CYFIXEDFRAME = SM_CYDLGFRAME
SM_CXSIZEFRAME = SM_CXFRAME
SM_CYSIZEFRAME = SM_CYFRAME
SM_SECURE = 44
SM_CXEDGE = 45
SM_CYEDGE = 46
SM_CXMINSPACING = 47
SM_CYMINSPACING = 48
SM_CXSMICON = 49
SM_CYSMICON = 50
SM_CYSMCAPTION = 51
SM_CXSMSIZE = 52
SM_CYSMSIZE = 53
SM_CXMENUSIZE = 54
SM_CYMENUSIZE = 55
SM_ARRANGE = 56
SM_CXMINIMIZED = 57
SM_CYMINIMIZED = 58
SM_CXMAXTRACK = 59
SM_CYMAXTRACK = 60
SM_CXMAXIMIZED = 61
SM_CYMAXIMIZED = 62
SM_NETWORK = 63
SM_CLEANBOOT = 67
SM_CXDRAG = 68
SM_CYDRAG = 69
SM_SHOWSOUNDS = 70
SM_CXMENUCHECK = 71
SM_CYMENUCHECK = 72
SM_SLOWMACHINE = 73
SM_MIDEASTENABLED = 74
SM_MOUSEWHEELPRESENT = 75
SM_XVIRTUALSCREEN = 76
SM_YVIRTUALSCREEN = 77
SM_CXVIRTUALSCREEN = 78
SM_CYVIRTUALSCREEN = 79
SM_CMONITORS = 80
SM_SAMEDISPLAYFORMAT = 81
SM_CMETRICS = 83
MNC_IGNORE = 0
MNC_CLOSE = 1
MNC_EXECUTE = 2
MNC_SELECT = 3
MNS_NOCHECK = -2147483648
MNS_MODELESS = 1073741824
MNS_DRAGDROP = 536870912
MNS_AUTODISMISS = 268435456
MNS_NOTIFYBYPOS = 134217728
MNS_CHECKORBMP = 67108864
MIM_MAXHEIGHT = 1
MIM_BACKGROUND = 2
MIM_HELPID = 4
MIM_MENUDATA = 8
MIM_STYLE = 16
MIM_APPLYTOSUBMENUS = -2147483648
MND_CONTINUE = 0
MND_ENDMENU = 1
MNGOF_GAP = 3
MNGO_NOINTERFACE = 0
MNGO_NOERROR = 1
MIIM_STATE = 1
MIIM_ID = 2
MIIM_SUBMENU = 4
MIIM_CHECKMARKS = 8
MIIM_TYPE = 16
MIIM_DATA = 32
MIIM_STRING = 64
MIIM_BITMAP = 128
MIIM_FTYPE = 256
HBMMENU_CALLBACK = -1
HBMMENU_SYSTEM = 1
HBMMENU_MBAR_RESTORE = 2
HBMMENU_MBAR_MINIMIZE = 3
HBMMENU_MBAR_CLOSE = 5
HBMMENU_MBAR_CLOSE_D = 6
HBMMENU_MBAR_MINIMIZE_D = 7
HBMMENU_POPUP_CLOSE = 8
HBMMENU_POPUP_RESTORE = 9
HBMMENU_POPUP_MAXIMIZE = 10
HBMMENU_POPUP_MINIMIZE = 11
GMDI_USEDISABLED = 1
GMDI_GOINTOPOPUPS = 2
TPM_LEFTBUTTON = 0
TPM_RIGHTBUTTON = 2
TPM_LEFTALIGN = 0
TPM_CENTERALIGN = 4
TPM_RIGHTALIGN = 8
TPM_TOPALIGN = 0
TPM_VCENTERALIGN = 16
TPM_BOTTOMALIGN = 32
TPM_HORIZONTAL = 0
TPM_VERTICAL = 64
TPM_NONOTIFY = 128
TPM_RETURNCMD = 256
TPM_RECURSE = 1
DOF_EXECUTABLE = 32769
DOF_DOCUMENT = 32770
DOF_DIRECTORY = 32771
DOF_MULTIPLE = 32772
DOF_PROGMAN = 1
DOF_SHELLDATA = 2
DO_DROPFILE = 1162627398
DO_PRINTFILE = 1414419024
DT_TOP = 0
DT_LEFT = 0
DT_CENTER = 1
DT_RIGHT = 2
DT_VCENTER = 4
DT_BOTTOM = 8
DT_WORDBREAK = 16
DT_SINGLELINE = 32
DT_EXPANDTABS = 64
DT_TABSTOP = 128
DT_NOCLIP = 256
DT_EXTERNALLEADING = 512
DT_CALCRECT = 1024
DT_NOPREFIX = 2048
DT_INTERNAL = 4096
DT_EDITCONTROL = 8192
DT_PATH_ELLIPSIS = 16384
DT_END_ELLIPSIS = 32768
DT_MODIFYSTRING = 65536
DT_RTLREADING = 131072
DT_WORD_ELLIPSIS = 262144
DST_COMPLEX = 0
DST_TEXT = 1
DST_PREFIXTEXT = 2
DST_ICON = 3
DST_BITMAP = 4
DSS_NORMAL = 0
DSS_UNION = 16
DSS_DISABLED = 32
DSS_MONO = 128
DSS_RIGHT = 32768
DCX_WINDOW = 1
DCX_CACHE = 2
DCX_NORESETATTRS = 4
DCX_CLIPCHILDREN = 8
DCX_CLIPSIBLINGS = 16
DCX_PARENTCLIP = 32
DCX_EXCLUDERGN = 64
DCX_INTERSECTRGN = 128
DCX_EXCLUDEUPDATE = 256
DCX_INTERSECTUPDATE = 512
DCX_LOCKWINDOWUPDATE = 1024
DCX_VALIDATE = 2097152
CUDR_NORMAL = 0
CUDR_NOSNAPTOGRID = 1
CUDR_NORESOLVEPOSITIONS = 2
CUDR_NOCLOSEGAPS = 4
CUDR_NEGATIVECOORDS = 8
CUDR_NOPRIMARY = 16
RDW_INVALIDATE = 1
RDW_INTERNALPAINT = 2
RDW_ERASE = 4
RDW_VALIDATE = 8
RDW_NOINTERNALPAINT = 16
RDW_NOERASE = 32
RDW_NOCHILDREN = 64
RDW_ALLCHILDREN = 128
RDW_UPDATENOW = 256
RDW_ERASENOW = 512
RDW_FRAME = 1024
RDW_NOFRAME = 2048
SW_SCROLLCHILDREN = 1
SW_INVALIDATE = 2
SW_ERASE = 4
SW_SMOOTHSCROLL = 16  # Use smooth scrolling
ESB_ENABLE_BOTH = 0
ESB_DISABLE_BOTH = 3
ESB_DISABLE_LEFT = 1
ESB_DISABLE_RIGHT = 2
ESB_DISABLE_UP = 1
ESB_DISABLE_DOWN = 2
ESB_DISABLE_LTUP = ESB_DISABLE_LEFT
ESB_DISABLE_RTDN = ESB_DISABLE_RIGHT
HELPINFO_WINDOW = 1
HELPINFO_MENUITEM = 2
MB_OK = 0
MB_OKCANCEL = 1
MB_ABORTRETRYIGNORE = 2
MB_YESNOCANCEL = 3
MB_YESNO = 4
MB_RETRYCANCEL = 5
MB_ICONHAND = 16
MB_ICONQUESTION = 32
MB_ICONEXCLAMATION = 48
MB_ICONASTERISK = 64
MB_ICONWARNING = MB_ICONEXCLAMATION
MB_ICONERROR = MB_ICONHAND
MB_ICONINFORMATION = MB_ICONASTERISK
MB_ICONSTOP = MB_ICONHAND
MB_DEFBUTTON1 = 0
MB_DEFBUTTON2 = 256
MB_DEFBUTTON3 = 512
MB_DEFBUTTON4 = 768
MB_APPLMODAL = 0
MB_SYSTEMMODAL = 4096
MB_TASKMODAL = 8192
MB_HELP = 16384
MB_NOFOCUS = 32768
MB_SETFOREGROUND = 65536
MB_DEFAULT_DESKTOP_ONLY = 131072
MB_TOPMOST = 262144L
MB_RIGHT = 524288
MB_RTLREADING = 1048576
MB_SERVICE_NOTIFICATION = 2097152
MB_TYPEMASK = 15
MB_USERICON = 128
MB_ICONMASK = 240
MB_DEFMASK = 3840
MB_MODEMASK = 12288
MB_MISCMASK = 49152
# winuser.h line 6373
CWP_ALL = 0
CWP_SKIPINVISIBLE = 1
CWP_SKIPDISABLED = 2
CWP_SKIPTRANSPARENT = 4
CTLCOLOR_MSGBOX = 0
CTLCOLOR_EDIT = 1
CTLCOLOR_LISTBOX = 2
CTLCOLOR_BTN = 3
CTLCOLOR_DLG = 4
CTLCOLOR_SCROLLBAR = 5
CTLCOLOR_STATIC = 6
CTLCOLOR_MAX = 7
COLOR_SCROLLBAR = 0
COLOR_BACKGROUND = 1
COLOR_ACTIVECAPTION = 2
COLOR_INACTIVECAPTION = 3
COLOR_MENU = 4
COLOR_WINDOW = 5
COLOR_WINDOWFRAME = 6
COLOR_MENUTEXT = 7
COLOR_WINDOWTEXT = 8
COLOR_CAPTIONTEXT = 9
COLOR_ACTIVEBORDER = 10
COLOR_INACTIVEBORDER = 11
COLOR_APPWORKSPACE = 12
COLOR_HIGHLIGHT = 13
COLOR_HIGHLIGHTTEXT = 14
COLOR_BTNFACE = 15
COLOR_BTNSHADOW = 16
COLOR_GRAYTEXT = 17
COLOR_BTNTEXT = 18
COLOR_INACTIVECAPTIONTEXT = 19
COLOR_BTNHIGHLIGHT = 20
COLOR_3DDKSHADOW = 21
COLOR_3DLIGHT = 22
COLOR_INFOTEXT = 23
COLOR_INFOBK = 24
COLOR_HOTLIGHT = 26
COLOR_GRADIENTACTIVECAPTION = 27
COLOR_GRADIENTINACTIVECAPTION = 28
COLOR_DESKTOP = COLOR_BACKGROUND
COLOR_3DFACE = COLOR_BTNFACE
COLOR_3DSHADOW = COLOR_BTNSHADOW
COLOR_3DHIGHLIGHT = COLOR_BTNHIGHLIGHT
COLOR_3DHILIGHT = COLOR_BTNHIGHLIGHT
COLOR_BTNHILIGHT = COLOR_BTNHIGHLIGHT
GW_HWNDFIRST = 0
GW_HWNDLAST = 1
GW_HWNDNEXT = 2
GW_HWNDPREV = 3
GW_OWNER = 4
GW_CHILD = 5
GW_ENABLEDPOPUP = 6
GW_MAX = 6
MF_INSERT = 0
MF_CHANGE = 128
MF_APPEND = 256
MF_DELETE = 512
MF_REMOVE = 4096
MF_BYCOMMAND = 0
MF_BYPOSITION = 1024
MF_SEPARATOR = 2048
MF_ENABLED = 0
MF_GRAYED = 1
MF_DISABLED = 2
MF_UNCHECKED = 0
MF_CHECKED = 8
MF_USECHECKBITMAPS = 512
MF_STRING = 0
MF_BITMAP = 4
MF_OWNERDRAW = 256
MF_POPUP = 16
MF_MENUBARBREAK = 32
MF_MENUBREAK = 64
MF_UNHILITE = 0
MF_HILITE = 128
MF_DEFAULT = 4096
MF_SYSMENU = 8192
MF_HELP = 16384
MF_RIGHTJUSTIFY = 16384
MF_MOUSESELECT = 32768
MF_END = 128
MFT_STRING = MF_STRING
MFT_BITMAP = MF_BITMAP
MFT_MENUBARBREAK = MF_MENUBARBREAK
MFT_MENUBREAK = MF_MENUBREAK
MFT_OWNERDRAW = MF_OWNERDRAW
MFT_RADIOCHECK = 512
MFT_SEPARATOR = MF_SEPARATOR
MFT_RIGHTORDER = 8192
MFT_RIGHTJUSTIFY = MF_RIGHTJUSTIFY
MFS_GRAYED = 3
MFS_DISABLED = MFS_GRAYED
MFS_CHECKED = MF_CHECKED
MFS_HILITE = MF_HILITE
MFS_ENABLED = MF_ENABLED
MFS_UNCHECKED = MF_UNCHECKED
MFS_UNHILITE = MF_UNHILITE
MFS_DEFAULT = MF_DEFAULT
MFS_MASK = 4235L
MFS_HOTTRACKDRAWN = 268435456
MFS_CACHEDBMP = 536870912
MFS_BOTTOMGAPDROP = 1073741824
MFS_TOPGAPDROP = -2147483648
MFS_GAPDROP = -1073741824
SC_SIZE = 61440
SC_MOVE = 61456
SC_MINIMIZE = 61472
SC_MAXIMIZE = 61488
SC_NEXTWINDOW = 61504
SC_PREVWINDOW = 61520
SC_CLOSE = 61536
SC_VSCROLL = 61552
SC_HSCROLL = 61568
SC_MOUSEMENU = 61584
SC_KEYMENU = 61696
SC_ARRANGE = 61712
SC_RESTORE = 61728
SC_TASKLIST = 61744
SC_SCREENSAVE = 61760
SC_HOTKEY = 61776
SC_DEFAULT = 61792
SC_MONITORPOWER = 61808
SC_CONTEXTHELP = 61824
SC_SEPARATOR = 61455
SC_ICON = SC_MINIMIZE
SC_ZOOM = SC_MAXIMIZE
IDC_ARROW = 32512
IDC_IBEAM = 32513
IDC_WAIT = 32514
IDC_CROSS = 32515
IDC_UPARROW = 32516
IDC_SIZE = 32640  # OBSOLETE: use IDC_SIZEALL
IDC_ICON = 32641  # OBSOLETE: use IDC_ARROW
IDC_SIZENWSE = 32642
IDC_SIZENESW = 32643
IDC_SIZEWE = 32644
IDC_SIZENS = 32645
IDC_SIZEALL = 32646
IDC_NO = 32648
IDC_HAND = 32649
IDC_APPSTARTING = 32650
IDC_HELP = 32651
IMAGE_BITMAP = 0
IMAGE_ICON = 1
IMAGE_CURSOR = 2
IMAGE_ENHMETAFILE = 3
LR_DEFAULTCOLOR = 0
LR_MONOCHROME = 1
LR_COLOR = 2
LR_COPYRETURNORG = 4
LR_COPYDELETEORG = 8
LR_LOADFROMFILE = 16
LR_LOADTRANSPARENT = 32
LR_DEFAULTSIZE = 64
LR_LOADREALSIZE = 128
LR_LOADMAP3DCOLORS = 4096
LR_CREATEDIBSECTION = 8192
LR_COPYFROMRESOURCE = 16384
LR_SHARED = 32768
DI_MASK = 1
DI_IMAGE = 2
DI_NORMAL = 3
DI_COMPAT = 4
DI_DEFAULTSIZE = 8
RES_ICON = 1
RES_CURSOR = 2
OBM_CLOSE = 32754
OBM_UPARROW = 32753
OBM_DNARROW = 32752
OBM_RGARROW = 32751
OBM_LFARROW = 32750
OBM_REDUCE = 32749
OBM_ZOOM = 32748
OBM_RESTORE = 32747
OBM_REDUCED = 32746
OBM_ZOOMD = 32745
OBM_RESTORED = 32744
OBM_UPARROWD = 32743
OBM_DNARROWD = 32742
OBM_RGARROWD = 32741
OBM_LFARROWD = 32740
OBM_MNARROW = 32739
OBM_COMBO = 32738
OBM_UPARROWI = 32737
OBM_DNARROWI = 32736
OBM_RGARROWI = 32735
OBM_LFARROWI = 32734
OBM_OLD_CLOSE = 32767
OBM_SIZE = 32766
OBM_OLD_UPARROW = 32765
OBM_OLD_DNARROW = 32764
OBM_OLD_RGARROW = 32763
OBM_OLD_LFARROW = 32762
OBM_BTSIZE = 32761
OBM_CHECK = 32760
OBM_CHECKBOXES = 32759
OBM_BTNCORNERS = 32758
OBM_OLD_REDUCE = 32757
OBM_OLD_ZOOM = 32756
OBM_OLD_RESTORE = 32755
OCR_NORMAL = 32512
OCR_IBEAM = 32513
OCR_WAIT = 32514
OCR_CROSS = 32515
OCR_UP = 32516
OCR_SIZE = 32640
OCR_ICON = 32641
OCR_SIZENWSE = 32642
OCR_SIZENESW = 32643
OCR_SIZEWE = 32644
OCR_SIZENS = 32645
OCR_SIZEALL = 32646
OCR_ICOCUR = 32647
OCR_NO = 32648
OCR_HAND = 32649
OCR_APPSTARTING = 32650
# winuser.h line 7455
OIC_SAMPLE = 32512
OIC_HAND = 32513
OIC_QUES = 32514
OIC_BANG = 32515
OIC_NOTE = 32516
OIC_WINLOGO = 32517
OIC_WARNING = OIC_BANG
OIC_ERROR = OIC_HAND
OIC_INFORMATION = OIC_NOTE
ORD_LANGDRIVER = 1
IDI_APPLICATION = 32512
IDI_HAND = 32513
IDI_QUESTION = 32514
IDI_EXCLAMATION = 32515
IDI_ASTERISK = 32516
IDI_WINLOGO = 32517
IDI_WARNING = IDI_EXCLAMATION
IDI_ERROR = IDI_HAND
IDI_INFORMATION = IDI_ASTERISK
IDOK = 1
IDCANCEL = 2
IDABORT = 3
IDRETRY = 4
IDIGNORE = 5
IDYES = 6
IDNO = 7
IDCLOSE = 8
IDHELP = 9
ES_LEFT = 0
ES_CENTER = 1
ES_RIGHT = 2
ES_MULTILINE = 4
ES_UPPERCASE = 8
ES_LOWERCASE = 16
ES_PASSWORD = 32
ES_AUTOVSCROLL = 64
ES_AUTOHSCROLL = 128
ES_NOHIDESEL = 256
ES_OEMCONVERT = 1024
ES_READONLY = 2048
ES_WANTRETURN = 4096
ES_NUMBER = 8192
EN_SETFOCUS = 256
EN_KILLFOCUS = 512
EN_CHANGE = 768
EN_UPDATE = 1024
EN_ERRSPACE = 1280
EN_MAXTEXT = 1281
EN_HSCROLL = 1537
EN_VSCROLL = 1538
EC_LEFTMARGIN = 1
EC_RIGHTMARGIN = 2
EC_USEFONTINFO = 65535
EMSIS_COMPOSITIONSTRING = 1
EIMES_GETCOMPSTRATONCE = 1
EIMES_CANCELCOMPSTRINFOCUS = 2
EIMES_COMPLETECOMPSTRKILLFOCUS = 4
EM_GETSEL = 176
EM_SETSEL = 177
EM_GETRECT = 178
EM_SETRECT = 179
EM_SETRECTNP = 180
EM_SCROLL = 181
EM_LINESCROLL = 182
EM_SCROLLCARET = 183
EM_GETMODIFY = 184
EM_SETMODIFY = 185
EM_GETLINECOUNT = 186
EM_LINEINDEX = 187
EM_SETHANDLE = 188
EM_GETHANDLE = 189
EM_GETTHUMB = 190
EM_LINELENGTH = 193
EM_REPLACESEL = 194
EM_GETLINE = 196
EM_LIMITTEXT = 197
EM_CANUNDO = 198
EM_UNDO = 199
EM_FMTLINES = 200
EM_LINEFROMCHAR = 201
EM_SETTABSTOPS = 203
EM_SETPASSWORDCHAR = 204
EM_EMPTYUNDOBUFFER = 205
EM_GETFIRSTVISIBLELINE = 206
EM_SETREADONLY = 207
EM_SETWORDBREAKPROC = 208
EM_GETWORDBREAKPROC = 209
EM_GETPASSWORDCHAR = 210
EM_SETMARGINS = 211
EM_GETMARGINS = 212
EM_SETLIMITTEXT = EM_LIMITTEXT
EM_GETLIMITTEXT = 213
EM_POSFROMCHAR = 214
EM_CHARFROMPOS = 215
EM_SETIMESTATUS = 216
EM_GETIMESTATUS = 217
WB_LEFT = 0
WB_RIGHT = 1
WB_ISDELIMITER = 2
BS_PUSHBUTTON = 0
BS_DEFPUSHBUTTON = 1
BS_CHECKBOX = 2
BS_AUTOCHECKBOX = 3
BS_RADIOBUTTON = 4
BS_3STATE = 5
BS_AUTO3STATE = 6
BS_GROUPBOX = 7
BS_USERBUTTON = 8
BS_AUTORADIOBUTTON = 9
BS_OWNERDRAW = 11L
BS_LEFTTEXT = 32
BS_TEXT = 0
BS_ICON = 64
BS_BITMAP = 128
BS_LEFT = 256
BS_RIGHT = 512
BS_CENTER = 768
BS_TOP = 1024
BS_BOTTOM = 2048
BS_VCENTER = 3072
BS_PUSHLIKE = 4096
BS_MULTILINE = 8192
BS_NOTIFY = 16384
BS_FLAT = 32768
BS_RIGHTBUTTON = BS_LEFTTEXT
BN_CLICKED = 0
BN_PAINT = 1
BN_HILITE = 2
BN_UNHILITE = 3
BN_DISABLE = 4
BN_DOUBLECLICKED = 5
BN_PUSHED = BN_HILITE
BN_UNPUSHED = BN_UNHILITE
BN_DBLCLK = BN_DOUBLECLICKED
BN_SETFOCUS = 6
BN_KILLFOCUS = 7
BM_GETCHECK = 240
BM_SETCHECK = 241
BM_GETSTATE = 242
BM_SETSTATE = 243
BM_SETSTYLE = 244
BM_CLICK = 245
BM_GETIMAGE = 246
BM_SETIMAGE = 247
BST_UNCHECKED = 0
BST_CHECKED = 1
BST_INDETERMINATE = 2
BST_PUSHED = 4
BST_FOCUS = 8
SS_LEFT = 0
SS_CENTER = 1
SS_RIGHT = 2
SS_ICON = 3
SS_BLACKRECT = 4
SS_GRAYRECT = 5
SS_WHITERECT = 6
SS_BLACKFRAME = 7
SS_GRAYFRAME = 8
SS_WHITEFRAME = 9
SS_USERITEM = 10
SS_SIMPLE = 11
SS_LEFTNOWORDWRAP = 12
SS_BITMAP = 14
SS_OWNERDRAW = 13
SS_ENHMETAFILE = 15
SS_ETCHEDHORZ = 16
SS_ETCHEDVERT = 17
SS_ETCHEDFRAME = 18
SS_TYPEMASK = 31
SS_NOPREFIX = 128
SS_NOTIFY = 256
SS_CENTERIMAGE = 512
SS_RIGHTJUST = 1024
SS_REALSIZEIMAGE = 2048
SS_SUNKEN = 4096
SS_ENDELLIPSIS = 16384
SS_PATHELLIPSIS = 32768
SS_WORDELLIPSIS = 49152
SS_ELLIPSISMASK = 49152
STM_SETICON = 368
STM_GETICON = 369
STM_SETIMAGE = 370
STM_GETIMAGE = 371
STN_CLICKED = 0
STN_DBLCLK = 1
STN_ENABLE = 2
STN_DISABLE = 3
STM_MSGMAX = 372
DWL_MSGRESULT = 0
DWL_DLGPROC = 4
DWL_USER = 8
DDL_READWRITE = 0
DDL_READONLY = 1
DDL_HIDDEN = 2
DDL_SYSTEM = 4
DDL_DIRECTORY = 16
DDL_ARCHIVE = 32
DDL_POSTMSGS = 8192
DDL_DRIVES = 16384
DDL_EXCLUSIVE = 32768

#from winuser.h line 153
RT_CURSOR = 1
RT_BITMAP = 2
RT_ICON = 3
RT_MENU = 4
RT_DIALOG = 5
RT_STRING = 6
RT_FONTDIR = 7
RT_FONT = 8
RT_ACCELERATOR = 9
RT_RCDATA = 10
RT_MESSAGETABLE = 11
DIFFERENCE = 11
RT_GROUP_CURSOR = (RT_CURSOR + DIFFERENCE)
RT_GROUP_ICON = (RT_ICON + DIFFERENCE)
RT_VERSION = 16
RT_DLGINCLUDE = 17
RT_PLUGPLAY = 19
RT_VXD = 20
RT_ANICURSOR = 21
RT_ANIICON = 22
RT_HTML = 23
# from winuser.h line 218
SB_HORZ = 0
SB_VERT = 1
SB_CTL = 2
SB_BOTH = 3
SB_LINEUP = 0
SB_LINELEFT = 0
SB_LINEDOWN = 1
SB_LINERIGHT = 1
SB_PAGEUP = 2
SB_PAGELEFT = 2
SB_PAGEDOWN = 3
SB_PAGERIGHT = 3
SB_THUMBPOSITION = 4
SB_THUMBTRACK = 5
SB_TOP = 6
SB_LEFT = 6
SB_BOTTOM = 7
SB_RIGHT = 7
SB_ENDSCROLL = 8
SW_HIDE = 0
SW_SHOWNORMAL = 1
SW_NORMAL = 1
SW_SHOWMINIMIZED = 2
SW_SHOWMAXIMIZED = 3
SW_MAXIMIZE = 3
SW_SHOWNOACTIVATE = 4
SW_SHOW = 5
SW_MINIMIZE = 6
SW_SHOWMINNOACTIVE = 7
SW_SHOWNA = 8
SW_RESTORE = 9
SW_SHOWDEFAULT = 10
SW_FORCEMINIMIZE = 11
SW_MAX = 11
HIDE_WINDOW = 0
SHOW_OPENWINDOW = 1
SHOW_ICONWINDOW = 2
SHOW_FULLSCREEN = 3
SHOW_OPENNOACTIVATE = 4
SW_PARENTCLOSING = 1
SW_OTHERZOOM = 2
SW_PARENTOPENING = 3
SW_OTHERUNZOOM = 4
AW_HOR_POSITIVE = 1
AW_HOR_NEGATIVE = 2
AW_VER_POSITIVE = 4
AW_VER_NEGATIVE = 8
AW_CENTER = 16
AW_HIDE = 65536
AW_ACTIVATE = 131072
AW_SLIDE = 262144
AW_BLEND = 524288
KF_EXTENDED = 256
KF_DLGMODE = 2048
KF_MENUMODE = 4096
KF_ALTDOWN = 8192
KF_REPEAT = 16384
KF_UP = 32768
VK_LBUTTON = 1
VK_RBUTTON = 2
VK_CANCEL = 3
VK_MBUTTON = 4
VK_BACK = 8
VK_TAB = 9
VK_CLEAR = 12
VK_RETURN = 13
VK_SHIFT = 16
VK_CONTROL = 17
VK_MENU = 18
VK_PAUSE = 19
VK_CAPITAL = 20
VK_KANA = 21
VK_HANGEUL = 21  # old name - should be here for compatibility
VK_HANGUL = 21
VK_JUNJA = 23
VK_FINAL = 24
VK_HANJA = 25
VK_KANJI = 25
VK_ESCAPE = 27
VK_CONVERT = 28
VK_NONCONVERT = 29
VK_ACCEPT = 30
VK_MODECHANGE = 31
VK_SPACE = 32
VK_PRIOR = 33
VK_NEXT = 34
VK_END = 35
VK_HOME = 36
VK_LEFT = 37
VK_UP = 38
VK_RIGHT = 39
VK_DOWN = 40
VK_SELECT = 41
VK_PRINT = 42
VK_EXECUTE = 43
VK_SNAPSHOT = 44
VK_INSERT = 45
VK_DELETE = 46
VK_HELP = 47
VK_LWIN = 91
VK_RWIN = 92
VK_APPS = 93
VK_NUMPAD0 = 96
VK_NUMPAD1 = 97
VK_NUMPAD2 = 98
VK_NUMPAD3 = 99
VK_NUMPAD4 = 100
VK_NUMPAD5 = 101
VK_NUMPAD6 = 102
VK_NUMPAD7 = 103
VK_NUMPAD8 = 104
VK_NUMPAD9 = 105
VK_MULTIPLY = 106
VK_ADD = 107
VK_SEPARATOR = 108
VK_SUBTRACT = 109
VK_DECIMAL = 110
VK_DIVIDE = 111
VK_F1 = 112
VK_F2 = 113
VK_F3 = 114
VK_F4 = 115
VK_F5 = 116
VK_F6 = 117
VK_F7 = 118
VK_F8 = 119
VK_F9 = 120
VK_F10 = 121
VK_F11 = 122
VK_F12 = 123
VK_F13 = 124
VK_F14 = 125
VK_F15 = 126
VK_F16 = 127
VK_F17 = 128
VK_F18 = 129
VK_F19 = 130
VK_F20 = 131
VK_F21 = 132
VK_F22 = 133
VK_F23 = 134
VK_F24 = 135
VK_NUMLOCK = 144
VK_SCROLL = 145
VK_LSHIFT = 160
VK_RSHIFT = 161
VK_LCONTROL = 162
VK_RCONTROL = 163
VK_LMENU = 164
VK_RMENU = 165
VK_PROCESSKEY = 229
VK_ATTN = 246
VK_CRSEL = 247
VK_EXSEL = 248
VK_EREOF = 249
VK_PLAY = 250
VK_ZOOM = 251
VK_NONAME = 252
VK_PA1 = 253
VK_OEM_CLEAR = 254
# multi-media related "keys"
MOUSEEVENTF_XDOWN = 0x0080
MOUSEEVENTF_XUP = 0x0100
MOUSEEVENTF_WHEEL = 0x0800
VK_XBUTTON1 = 0x05
VK_XBUTTON2 = 0x06
VK_VOLUME_MUTE = 0xAD
VK_VOLUME_DOWN = 0xAE
VK_VOLUME_UP = 0xAF
VK_MEDIA_NEXT_TRACK = 0xB0
VK_MEDIA_PREV_TRACK = 0xB1
VK_MEDIA_PLAY_PAUSE = 0xB3
VK_BROWSER_BACK = 0xA6
VK_BROWSER_FORWARD = 0xA7
WH_MIN = (-1)
WH_MSGFILTER = (-1)
WH_JOURNALRECORD = 0
WH_JOURNALPLAYBACK = 1
WH_KEYBOARD = 2
WH_GETMESSAGE = 3
WH_CALLWNDPROC = 4
WH_CBT = 5
WH_SYSMSGFILTER = 6
WH_MOUSE = 7
WH_HARDWARE = 8
WH_DEBUG = 9
WH_SHELL = 10
WH_FOREGROUNDIDLE = 11
WH_CALLWNDPROCRET = 12
WH_KEYBOARD_LL = 13
WH_MOUSE_LL = 14
WH_MAX = 14
WH_MINHOOK = WH_MIN
WH_MAXHOOK = WH_MAX
HC_ACTION = 0
HC_GETNEXT = 1
HC_SKIP = 2
HC_NOREMOVE = 3
HC_NOREM = HC_NOREMOVE
HC_SYSMODALON = 4
HC_SYSMODALOFF = 5
HCBT_MOVESIZE = 0
HCBT_MINMAX = 1
HCBT_QS = 2
HCBT_CREATEWND = 3
HCBT_DESTROYWND = 4
HCBT_ACTIVATE = 5
HCBT_CLICKSKIPPED = 6
HCBT_KEYSKIPPED = 7
HCBT_SYSCOMMAND = 8
HCBT_SETFOCUS = 9
MSGF_DIALOGBOX = 0
MSGF_MESSAGEBOX = 1
MSGF_MENU = 2
#MSGF_MOVE = 3
#MSGF_SIZE = 4
MSGF_SCROLLBAR = 5
MSGF_NEXTWINDOW = 6
#MSGF_MAINLOOP = 8
MSGF_MAX = 8
MSGF_USER = 4096
HSHELL_WINDOWCREATED = 1
HSHELL_WINDOWDESTROYED = 2
HSHELL_ACTIVATESHELLWINDOW = 3
HSHELL_WINDOWACTIVATED = 4
HSHELL_GETMINRECT = 5
HSHELL_REDRAW = 6
HSHELL_TASKMAN = 7
HSHELL_LANGUAGE = 8
HSHELL_ACCESSIBILITYSTATE = 11
ACCESS_STICKYKEYS = 1
ACCESS_FILTERKEYS = 2
ACCESS_MOUSEKEYS = 3
# winuser.h line 624
LLKHF_EXTENDED = 1
LLKHF_INJECTED = 16
LLKHF_ALTDOWN = 32
LLKHF_UP = 128
LLMHF_INJECTED = 1
# line 692
HKL_PREV = 0
HKL_NEXT = 1
KLF_ACTIVATE = 1
KLF_SUBSTITUTE_OK = 2
KLF_UNLOADPREVIOUS = 4
KLF_REORDER = 8
KLF_REPLACELANG = 16
KLF_NOTELLSHELL = 128
KLF_SETFORPROCESS = 256
KL_NAMELENGTH = 9
DESKTOP_READOBJECTS = 1
DESKTOP_CREATEWINDOW = 2
DESKTOP_CREATEMENU = 4
DESKTOP_HOOKCONTROL = 8
DESKTOP_JOURNALRECORD = 16
DESKTOP_JOURNALPLAYBACK = 32
DESKTOP_ENUMERATE = 64
DESKTOP_WRITEOBJECTS = 128
DESKTOP_SWITCHDESKTOP = 256
DF_ALLOWOTHERACCOUNTHOOK = 1
WINSTA_ENUMDESKTOPS = 1
WINSTA_READATTRIBUTES = 2
WINSTA_ACCESSCLIPBOARD = 4
WINSTA_CREATEDESKTOP = 8
WINSTA_WRITEATTRIBUTES = 16
WINSTA_ACCESSGLOBALATOMS = 32
WINSTA_EXITWINDOWS = 64
WINSTA_ENUMERATE = 256
WINSTA_READSCREEN = 512
WSF_VISIBLE = 1
UOI_FLAGS = 1
UOI_NAME = 2
UOI_TYPE = 3
UOI_USER_SID = 4
GWL_WNDPROC = (-4)
GWL_HINSTANCE = (-6)
GWL_HWNDPARENT = (-8)
GWL_STYLE = (-16)
GWL_EXSTYLE = (-20)
GWL_USERDATA = (-21)
GWL_ID = (-12)
GCL_MENUNAME = (-8)
GCL_HBRBACKGROUND = (-10)
GCL_HCURSOR = (-12)
GCL_HICON = (-14)
GCL_HMODULE = (-16)
GCL_CBWNDEXTRA = (-18)
GCL_CBCLSEXTRA = (-20)
GCL_WNDPROC = (-24)
GCL_STYLE = (-26)
GCW_ATOM = (-32)
GCL_HICONSM = (-34)
# line 1291
WM_NULL = 0
WM_CREATE = 1
WM_DESTROY = 2
WM_MOVE = 3
WM_SIZE = 5
WM_ACTIVATE = 6
WA_INACTIVE = 0
WA_ACTIVE = 1
WA_CLICKACTIVE = 2
WM_SETFOCUS = 7
WM_KILLFOCUS = 8
WM_ENABLE = 10
WM_SETREDRAW = 11
WM_SETTEXT = 12
WM_GETTEXT = 13
WM_GETTEXTLENGTH = 14
WM_PAINT = 15
WM_CLOSE = 16
WM_QUERYENDSESSION = 17
WM_QUIT = 18
WM_QUERYOPEN = 19
WM_ERASEBKGND = 20
WM_SYSCOLORCHANGE = 21
WM_ENDSESSION = 22
WM_SHOWWINDOW = 24
WM_WININICHANGE = 26
WM_SETTINGCHANGE = WM_WININICHANGE
WM_DEVMODECHANGE = 27
WM_ACTIVATEAPP = 28
WM_FONTCHANGE = 29
WM_TIMECHANGE = 30
WM_CANCELMODE = 31
WM_SETCURSOR = 32
WM_MOUSEACTIVATE = 33
WM_CHILDACTIVATE = 34
WM_QUEUESYNC = 35
WM_GETMINMAXINFO = 36
WM_PAINTICON = 38
WM_ICONERASEBKGND = 39
WM_NEXTDLGCTL = 40
WM_SPOOLERSTATUS = 42
WM_DRAWITEM = 43
WM_MEASUREITEM = 44
WM_DELETEITEM = 45
WM_VKEYTOITEM = 46
WM_CHARTOITEM = 47
WM_SETFONT = 48
WM_GETFONT = 49
WM_SETHOTKEY = 50
WM_GETHOTKEY = 51
WM_QUERYDRAGICON = 55
WM_COMPAREITEM = 57
WM_GETOBJECT = 61
WM_COMPACTING = 65
WM_COMMNOTIFY = 68
WM_WINDOWPOSCHANGING = 70
WM_WINDOWPOSCHANGED = 71
WM_POWER = 72
PWR_OK = 1
PWR_FAIL = (-1)
PWR_SUSPENDREQUEST = 1
PWR_SUSPENDRESUME = 2
PWR_CRITICALRESUME = 3
WM_COPYDATA = 74
WM_CANCELJOURNAL = 75
WM_NOTIFY = 78
WM_INPUTLANGCHANGEREQUEST = 80
WM_INPUTLANGCHANGE = 81
WM_TCARD = 82
WM_HELP = 83
WM_USERCHANGED = 84
WM_NOTIFYFORMAT = 85
NFR_ANSI = 1
NFR_UNICODE = 2
NF_QUERY = 3
NF_REQUERY = 4
WM_CONTEXTMENU = 123
WM_STYLECHANGING = 124
WM_STYLECHANGED = 125
WM_DISPLAYCHANGE = 126
WM_GETICON = 127
WM_SETICON = 128
WM_NCCREATE = 129
WM_NCDESTROY = 130
WM_NCCALCSIZE = 131
WM_NCHITTEST = 132
WM_NCPAINT = 133
WM_NCACTIVATE = 134
WM_GETDLGCODE = 135
WM_SYNCPAINT = 136
WM_NCMOUSEMOVE = 160
WM_NCLBUTTONDOWN = 161
WM_NCLBUTTONUP = 162
WM_NCLBUTTONDBLCLK = 163
WM_NCRBUTTONDOWN = 164
WM_NCRBUTTONUP = 165
WM_NCRBUTTONDBLCLK = 166
WM_NCMBUTTONDOWN = 167
WM_NCMBUTTONUP = 168
WM_NCMBUTTONDBLCLK = 169
WM_KEYFIRST = 256
WM_KEYDOWN = 256
WM_KEYUP = 257
WM_CHAR = 258
WM_DEADCHAR = 259
WM_SYSKEYDOWN = 260
WM_SYSKEYUP = 261
WM_SYSCHAR = 262
WM_SYSDEADCHAR = 263
WM_KEYLAST = 264
WM_IME_STARTCOMPOSITION = 269
WM_IME_ENDCOMPOSITION = 270
WM_IME_COMPOSITION = 271
WM_IME_KEYLAST = 271
WM_INITDIALOG = 272
WM_COMMAND = 273
WM_SYSCOMMAND = 274
WM_TIMER = 275
WM_HSCROLL = 276
WM_VSCROLL = 277
WM_INITMENU = 278
WM_INITMENUPOPUP = 279
WM_MENUSELECT = 287
WM_MENUCHAR = 288
WM_ENTERIDLE = 289
WM_MENURBUTTONUP = 290
WM_MENUDRAG = 291
WM_MENUGETOBJECT = 292
WM_UNINITMENUPOPUP = 293
WM_MENUCOMMAND = 294
WM_CTLCOLORMSGBOX = 306
WM_CTLCOLOREDIT = 307
WM_CTLCOLORLISTBOX = 308
WM_CTLCOLORBTN = 309
WM_CTLCOLORDLG = 310
WM_CTLCOLORSCROLLBAR = 311
WM_CTLCOLORSTATIC = 312
WM_MOUSEFIRST = 512
WM_MOUSEMOVE = 512
WM_LBUTTONDOWN = 513
WM_LBUTTONUP = 514
WM_LBUTTONDBLCLK = 515
WM_RBUTTONDOWN = 516
WM_RBUTTONUP = 517
WM_RBUTTONDBLCLK = 518
WM_MBUTTONDOWN = 519
WM_MBUTTONUP = 520
WM_MBUTTONDBLCLK = 521
WM_MOUSEWHEEL = 522
WM_MOUSELAST = 522
WHEEL_DELTA = 120     # Value for rolling one detent
WHEEL_PAGESCROLL = -1 # Scroll one page
WM_PARENTNOTIFY = 528
MENULOOP_WINDOW = 0
MENULOOP_POPUP = 1
WM_ENTERMENULOOP = 529
WM_EXITMENULOOP = 530
WM_NEXTMENU = 531
WM_SIZING = 532
WM_CAPTURECHANGED = 533
WM_MOVING = 534
WM_POWERBROADCAST = 536
PBT_APMQUERYSUSPEND = 0
PBT_APMQUERYSTANDBY = 1
PBT_APMQUERYSUSPENDFAILED = 2
PBT_APMQUERYSTANDBYFAILED = 3
PBT_APMSUSPEND = 4
PBT_APMSTANDBY = 5
PBT_APMRESUMECRITICAL = 6
PBT_APMRESUMESUSPEND = 7
PBT_APMRESUMESTANDBY = 8
PBTF_APMRESUMEFROMFAILURE = 1
PBT_APMBATTERYLOW = 9
PBT_APMPOWERSTATUSCHANGE = 10
PBT_APMOEMEVENT = 11
PBT_APMRESUMEAUTOMATIC = 18
WM_DEVICECHANGE = 537
WM_MDICREATE = 544
WM_MDIDESTROY = 545
WM_MDIACTIVATE = 546
WM_MDIRESTORE = 547
WM_MDINEXT = 548
WM_MDIMAXIMIZE = 549
WM_MDITILE = 550
WM_MDICASCADE = 551
WM_MDIICONARRANGE = 552
WM_MDIGETACTIVE = 553
WM_MDISETMENU = 560
WM_ENTERSIZEMOVE = 561
WM_EXITSIZEMOVE = 562
WM_DROPFILES = 563
WM_MDIREFRESHMENU = 564
WM_IME_SETCONTEXT = 641
WM_IME_NOTIFY = 642
WM_IME_CONTROL = 643
WM_IME_COMPOSITIONFULL = 644
WM_IME_SELECT = 645
WM_IME_CHAR = 646
WM_IME_REQUEST = 648
WM_IME_KEYDOWN = 656
WM_IME_KEYUP = 657
WM_MOUSEHOVER = 673
WM_MOUSELEAVE = 675
WM_CUT = 768
WM_COPY = 769
WM_PASTE = 770
WM_CLEAR = 771
WM_UNDO = 772
WM_RENDERFORMAT = 773
WM_RENDERALLFORMATS = 774
WM_DESTROYCLIPBOARD = 775
WM_DRAWCLIPBOARD = 776
WM_PAINTCLIPBOARD = 777
WM_VSCROLLCLIPBOARD = 778
WM_SIZECLIPBOARD = 779
WM_ASKCBFORMATNAME = 780
WM_CHANGECBCHAIN = 781
WM_HSCROLLCLIPBOARD = 782
WM_QUERYNEWPALETTE = 783
WM_PALETTEISCHANGING = 784
WM_PALETTECHANGED = 785
WM_HOTKEY = 786
WM_PRINT = 791
WM_PRINTCLIENT = 792
WM_HANDHELDFIRST = 856
WM_HANDHELDLAST = 863
WM_AFXFIRST = 864
WM_AFXLAST = 895
WM_PENWINFIRST = 896
WM_PENWINLAST = 911
WM_APP = 32768
WMSZ_LEFT = 1
WMSZ_RIGHT = 2
WMSZ_TOP = 3
WMSZ_TOPLEFT = 4
WMSZ_TOPRIGHT = 5
WMSZ_BOTTOM = 6
WMSZ_BOTTOMLEFT = 7
WMSZ_BOTTOMRIGHT = 8
#ST_BEGINSWP = 0
#ST_ENDSWP = 1
HTERROR = (-2)
HTTRANSPARENT = (-1)
HTNOWHERE = 0
HTCLIENT = 1
HTCAPTION = 2
HTSYSMENU = 3
HTGROWBOX = 4
HTSIZE = HTGROWBOX
HTMENU = 5
HTHSCROLL = 6
HTVSCROLL = 7
HTMINBUTTON = 8
HTMAXBUTTON = 9
HTLEFT = 10
HTRIGHT = 11
HTTOP = 12
HTTOPLEFT = 13
HTTOPRIGHT = 14
HTBOTTOM = 15
HTBOTTOMLEFT = 16
HTBOTTOMRIGHT = 17
HTBORDER = 18
HTREDUCE = HTMINBUTTON
HTZOOM = HTMAXBUTTON
HTSIZEFIRST = HTLEFT
HTSIZELAST = HTBOTTOMRIGHT
HTOBJECT = 19
HTCLOSE = 20
HTHELP = 21
SMTO_NORMAL = 0
SMTO_BLOCK = 1
SMTO_ABORTIFHUNG = 2
SMTO_NOTIMEOUTIFNOTHUNG = 8
MA_ACTIVATE = 1
MA_ACTIVATEANDEAT = 2
MA_NOACTIVATE = 3
MA_NOACTIVATEANDEAT = 4
ICON_SMALL = 0
ICON_BIG = 1
SIZE_RESTORED = 0
SIZE_MINIMIZED = 1
SIZE_MAXIMIZED = 2
SIZE_MAXSHOW = 3
SIZE_MAXHIDE = 4
SIZENORMAL = SIZE_RESTORED
SIZEICONIC = SIZE_MINIMIZED
SIZEFULLSCREEN = SIZE_MAXIMIZED
SIZEZOOMSHOW = SIZE_MAXSHOW
SIZEZOOMHIDE = SIZE_MAXHIDE
WVR_ALIGNTOP = 16
WVR_ALIGNLEFT = 32
WVR_ALIGNBOTTOM = 64
WVR_ALIGNRIGHT = 128
WVR_HREDRAW = 256
WVR_VREDRAW = 512
WVR_REDRAW = (WVR_HREDRAW | WVR_VREDRAW)
WVR_VALIDRECTS = 1024
MK_LBUTTON = 1
MK_RBUTTON = 2
MK_SHIFT = 4
MK_CONTROL = 8
MK_MBUTTON = 16
TME_HOVER = 1
TME_LEAVE = 2
TME_QUERY = 1073741824
TME_CANCEL = -2147483648
HOVER_DEFAULT = -1
WS_OVERLAPPED = 0
WS_POPUP = -2147483648
WS_CHILD = 1073741824
WS_MINIMIZE = 536870912
WS_VISIBLE = 268435456
WS_DISABLED = 134217728
WS_CLIPSIBLINGS = 67108864
WS_CLIPCHILDREN = 33554432
WS_MAXIMIZE = 16777216
WS_CAPTION = 12582912
WS_BORDER = 8388608
WS_DLGFRAME = 4194304
WS_VSCROLL = 2097152
WS_HSCROLL = 1048576
WS_SYSMENU = 524288
WS_THICKFRAME = 262144
WS_GROUP = 131072
WS_TABSTOP = 65536
WS_MINIMIZEBOX = 131072
WS_MAXIMIZEBOX = 65536
WS_TILED = WS_OVERLAPPED
WS_ICONIC = WS_MINIMIZE
WS_SIZEBOX = WS_THICKFRAME
WS_OVERLAPPEDWINDOW = (WS_OVERLAPPED     | \
                             WS_CAPTION        | \
                             WS_SYSMENU        | \
                             WS_THICKFRAME     | \
                             WS_MINIMIZEBOX    | \
                             WS_MAXIMIZEBOX)
WS_POPUPWINDOW = (WS_POPUP          | \
                             WS_BORDER         | \
                             WS_SYSMENU)
WS_CHILDWINDOW = (WS_CHILD)
WS_TILEDWINDOW = WS_OVERLAPPEDWINDOW
WS_EX_DLGMODALFRAME = 1
WS_EX_NOPARENTNOTIFY = 4
WS_EX_TOPMOST = 8
WS_EX_ACCEPTFILES = 16
WS_EX_TRANSPARENT = 32
WS_EX_MDICHILD = 64
WS_EX_TOOLWINDOW = 128
WS_EX_WINDOWEDGE = 256
WS_EX_CLIENTEDGE = 512
WS_EX_CONTEXTHELP = 1024
WS_EX_RIGHT = 4096
WS_EX_LEFT = 0
WS_EX_RTLREADING = 8192
WS_EX_LTRREADING = 0
WS_EX_LEFTSCROLLBAR = 16384
WS_EX_RIGHTSCROLLBAR = 0
WS_EX_CONTROLPARENT = 65536
WS_EX_STATICEDGE = 131072
WS_EX_APPWINDOW = 262144
WS_EX_OVERLAPPEDWINDOW = (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)
WS_EX_PALETTEWINDOW = (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)
WS_EX_LAYERED = 0x00080000
WS_EX_NOINHERITLAYOUT = 0x00100000
WS_EX_LAYOUTRTL = 0x00400000
WS_EX_COMPOSITED = 0x02000000
WS_EX_NOACTIVATE = 0x08000000

CS_VREDRAW = 1
CS_HREDRAW = 2
#CS_KEYCVTWINDOW = 0x0004
CS_DBLCLKS = 8
CS_OWNDC = 32
CS_CLASSDC = 64
CS_PARENTDC = 128
#CS_NOKEYCVT = 0x0100
CS_NOCLOSE = 512
CS_SAVEBITS = 2048
CS_BYTEALIGNCLIENT = 4096
CS_BYTEALIGNWINDOW = 8192
CS_GLOBALCLASS = 16384
CS_IME = 65536
PRF_CHECKVISIBLE = 1
PRF_NONCLIENT = 2
PRF_CLIENT = 4
PRF_ERASEBKGND = 8
PRF_CHILDREN = 16
PRF_OWNED = 32
BDR_RAISEDOUTER = 1
BDR_SUNKENOUTER = 2
BDR_RAISEDINNER = 4
BDR_SUNKENINNER = 8
BDR_OUTER = 3
BDR_INNER = 12
#BDR_RAISED = 0x0005
#BDR_SUNKEN = 0x000a
EDGE_RAISED = (BDR_RAISEDOUTER | BDR_RAISEDINNER)
EDGE_SUNKEN = (BDR_SUNKENOUTER | BDR_SUNKENINNER)
EDGE_ETCHED = (BDR_SUNKENOUTER | BDR_RAISEDINNER)
EDGE_BUMP = (BDR_RAISEDOUTER | BDR_SUNKENINNER)

# winuser.h line 2879
ISMEX_NOSEND = 0
ISMEX_SEND = 1
ISMEX_NOTIFY = 2
ISMEX_CALLBACK = 4
ISMEX_REPLIED = 8
CW_USEDEFAULT = -2147483648
FLASHW_STOP = 0
FLASHW_CAPTION = 1
FLASHW_TRAY = 2
FLASHW_ALL = (FLASHW_CAPTION | FLASHW_TRAY)
FLASHW_TIMER = 4
FLASHW_TIMERNOFG = 12

# winuser.h line 7963
DS_ABSALIGN = 1
DS_SYSMODAL = 2
DS_LOCALEDIT = 32
DS_SETFONT = 64
DS_MODALFRAME = 128
DS_NOIDLEMSG = 256
DS_SETFOREGROUND = 512
DS_3DLOOK = 4
DS_FIXEDSYS = 8
DS_NOFAILCREATE = 16
DS_CONTROL = 1024
DS_CENTER = 2048
DS_CENTERMOUSE = 4096
DS_CONTEXTHELP = 8192
DM_GETDEFID = (WM_USER+0)
DM_SETDEFID = (WM_USER+1)
DM_REPOSITION = (WM_USER+2)
#PSM_PAGEINFO = (WM_USER+100)
#PSM_SHEETINFO = (WM_USER+101)
#PSI_SETACTIVE = 0x0001
#PSI_KILLACTIVE = 0x0002
#PSI_APPLY = 0x0003
#PSI_RESET = 0x0004
#PSI_HASHELP = 0x0005
#PSI_HELP = 0x0006
#PSI_CHANGED = 0x0001
#PSI_GUISTART = 0x0002
#PSI_REBOOT = 0x0003
#PSI_GETSIBLINGS = 0x0004
DC_HASDEFID = 21323
DLGC_WANTARROWS = 1
DLGC_WANTTAB = 2
DLGC_WANTALLKEYS = 4
DLGC_WANTMESSAGE = 4
DLGC_HASSETSEL = 8
DLGC_DEFPUSHBUTTON = 16
DLGC_UNDEFPUSHBUTTON = 32
DLGC_RADIOBUTTON = 64
DLGC_WANTCHARS = 128
DLGC_STATIC = 256
DLGC_BUTTON = 8192
LB_CTLCODE = 0
LB_OKAY = 0
LB_ERR = (-1)
LB_ERRSPACE = (-2)
LBN_ERRSPACE = (-2)
LBN_SELCHANGE = 1
LBN_DBLCLK = 2
LBN_SELCANCEL = 3
LBN_SETFOCUS = 4
LBN_KILLFOCUS = 5
LB_ADDSTRING = 384
LB_INSERTSTRING = 385
LB_DELETESTRING = 386
LB_SELITEMRANGEEX = 387
LB_RESETCONTENT = 388
LB_SETSEL = 389
LB_SETCURSEL = 390
LB_GETSEL = 391
LB_GETCURSEL = 392
LB_GETTEXT = 393
LB_GETTEXTLEN = 394
LB_GETCOUNT = 395
LB_SELECTSTRING = 396
LB_DIR = 397
LB_GETTOPINDEX = 398
LB_FINDSTRING = 399
LB_GETSELCOUNT = 400
LB_GETSELITEMS = 401
LB_SETTABSTOPS = 402
LB_GETHORIZONTALEXTENT = 403
LB_SETHORIZONTALEXTENT = 404
LB_SETCOLUMNWIDTH = 405
LB_ADDFILE = 406
LB_SETTOPINDEX = 407
LB_GETITEMRECT = 408
LB_GETITEMDATA = 409
LB_SETITEMDATA = 410
LB_SELITEMRANGE = 411
LB_SETANCHORINDEX = 412
LB_GETANCHORINDEX = 413
LB_SETCARETINDEX = 414
LB_GETCARETINDEX = 415
LB_SETITEMHEIGHT = 416
LB_GETITEMHEIGHT = 417
LB_FINDSTRINGEXACT = 418
LB_SETLOCALE = 421
LB_GETLOCALE = 422
LB_SETCOUNT = 423
LB_INITSTORAGE = 424
LB_ITEMFROMPOINT = 425
LB_MSGMAX = 432
LBS_NOTIFY = 1
LBS_SORT = 2
LBS_NOREDRAW = 4
LBS_MULTIPLESEL = 8
LBS_OWNERDRAWFIXED = 16
LBS_OWNERDRAWVARIABLE = 32
LBS_HASSTRINGS = 64
LBS_USETABSTOPS = 128
LBS_NOINTEGRALHEIGHT = 256
LBS_MULTICOLUMN = 512
LBS_WANTKEYBOARDINPUT = 1024
LBS_EXTENDEDSEL = 2048
LBS_DISABLENOSCROLL = 4096
LBS_NODATA = 8192
LBS_NOSEL = 16384
LBS_STANDARD = (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
CB_OKAY = 0
CB_ERR = (-1)
CB_ERRSPACE = (-2)
CBN_ERRSPACE = (-1)
CBN_SELCHANGE = 1
CBN_DBLCLK = 2
CBN_SETFOCUS = 3
CBN_KILLFOCUS = 4
CBN_EDITCHANGE = 5
CBN_EDITUPDATE = 6
CBN_DROPDOWN = 7
CBN_CLOSEUP = 8
CBN_SELENDOK = 9
CBN_SELENDCANCEL = 10
CBS_SIMPLE = 1
CBS_DROPDOWN = 2
CBS_DROPDOWNLIST = 3
CBS_OWNERDRAWFIXED = 16
CBS_OWNERDRAWVARIABLE = 32
CBS_AUTOHSCROLL = 64
CBS_OEMCONVERT = 128
CBS_SORT = 256
CBS_HASSTRINGS = 512
CBS_NOINTEGRALHEIGHT = 1024
CBS_DISABLENOSCROLL = 2048
CBS_UPPERCASE = 8192
CBS_LOWERCASE = 16384
CB_GETEDITSEL = 320
CB_LIMITTEXT = 321
CB_SETEDITSEL = 322
CB_ADDSTRING = 323
CB_DELETESTRING = 324
CB_DIR = 325
CB_GETCOUNT = 326
CB_GETCURSEL = 327
CB_GETLBTEXT = 328
CB_GETLBTEXTLEN = 329
CB_INSERTSTRING = 330
CB_RESETCONTENT = 331
CB_FINDSTRING = 332
CB_SELECTSTRING = 333
CB_SETCURSEL = 334
CB_SHOWDROPDOWN = 335
CB_GETITEMDATA = 336
CB_SETITEMDATA = 337
CB_GETDROPPEDCONTROLRECT = 338
CB_SETITEMHEIGHT = 339
CB_GETITEMHEIGHT = 340
CB_SETEXTENDEDUI = 341
CB_GETEXTENDEDUI = 342
CB_GETDROPPEDSTATE = 343
CB_FINDSTRINGEXACT = 344
CB_SETLOCALE = 345
CB_GETLOCALE = 346
CB_GETTOPINDEX = 347
CB_SETTOPINDEX = 348
CB_GETHORIZONTALEXTENT = 349
CB_SETHORIZONTALEXTENT = 350
CB_GETDROPPEDWIDTH = 351
CB_SETDROPPEDWIDTH = 352
CB_INITSTORAGE = 353
CB_MSGMAX = 354
SBS_HORZ = 0
SBS_VERT = 1
SBS_TOPALIGN = 2
SBS_LEFTALIGN = 2
SBS_BOTTOMALIGN = 4
SBS_RIGHTALIGN = 4
SBS_SIZEBOXTOPLEFTALIGN = 2
SBS_SIZEBOXBOTTOMRIGHTALIGN = 4
SBS_SIZEBOX = 8
SBS_SIZEGRIP = 16
SBM_SETPOS = 224
SBM_GETPOS = 225
SBM_SETRANGE = 226
SBM_SETRANGEREDRAW = 230
SBM_GETRANGE = 227
SBM_ENABLE_ARROWS = 228
SBM_SETSCROLLINFO = 233
SBM_GETSCROLLINFO = 234
SIF_RANGE = 1
SIF_PAGE = 2
SIF_POS = 4
SIF_DISABLENOSCROLL = 8
SIF_TRACKPOS = 16
SIF_ALL = (SIF_RANGE | SIF_PAGE | SIF_POS | SIF_TRACKPOS)
MDIS_ALLCHILDSTYLES = 1
MDITILE_VERTICAL = 0
MDITILE_HORIZONTAL = 1
MDITILE_SKIPDISABLED = 2

IMC_GETCANDIDATEPOS = 7
IMC_SETCANDIDATEPOS = 8
IMC_GETCOMPOSITIONFONT = 9
IMC_SETCOMPOSITIONFONT = 10
IMC_GETCOMPOSITIONWINDOW = 11
IMC_SETCOMPOSITIONWINDOW = 12
IMC_GETSTATUSWINDOWPOS = 15
IMC_SETSTATUSWINDOWPOS = 16
IMC_CLOSESTATUSWINDOW = 33
IMC_OPENSTATUSWINDOW = 34
# Generated by h2py from \msvc20\include\winnt.h
# hacked and split by mhammond.
DELETE = (65536)
READ_CONTROL = (131072)
WRITE_DAC = (262144)
WRITE_OWNER = (524288)
SYNCHRONIZE = (1048576)
STANDARD_RIGHTS_REQUIRED = (983040)
STANDARD_RIGHTS_READ = (READ_CONTROL)
STANDARD_RIGHTS_WRITE = (READ_CONTROL)
STANDARD_RIGHTS_EXECUTE = (READ_CONTROL)
STANDARD_RIGHTS_ALL = (2031616)
SPECIFIC_RIGHTS_ALL = (65535)
ACCESS_SYSTEM_SECURITY = (16777216)
MAXIMUM_ALLOWED = (33554432)
GENERIC_READ = (-2147483648)
GENERIC_WRITE = (1073741824)
GENERIC_EXECUTE = (536870912)
GENERIC_ALL = (268435456)

SERVICE_KERNEL_DRIVER = 1
SERVICE_FILE_SYSTEM_DRIVER = 2
SERVICE_ADAPTER = 4
SERVICE_RECOGNIZER_DRIVER = 8
SERVICE_DRIVER = (SERVICE_KERNEL_DRIVER | \
                                        SERVICE_FILE_SYSTEM_DRIVER | \
                                        SERVICE_RECOGNIZER_DRIVER)
SERVICE_WIN32_OWN_PROCESS = 16
SERVICE_WIN32_SHARE_PROCESS = 32
SERVICE_WIN32 = (SERVICE_WIN32_OWN_PROCESS | \
                                        SERVICE_WIN32_SHARE_PROCESS)
SERVICE_INTERACTIVE_PROCESS = 256
SERVICE_TYPE_ALL = (SERVICE_WIN32  | \
                                        SERVICE_ADAPTER | \
                                        SERVICE_DRIVER  | \
                                        SERVICE_INTERACTIVE_PROCESS)
SERVICE_BOOT_START = 0
SERVICE_SYSTEM_START = 1
SERVICE_AUTO_START = 2
SERVICE_DEMAND_START = 3
SERVICE_DISABLED = 4
SERVICE_ERROR_IGNORE = 0
SERVICE_ERROR_NORMAL = 1
SERVICE_ERROR_SEVERE = 2
SERVICE_ERROR_CRITICAL = 3
TAPE_ERASE_SHORT = 0
TAPE_ERASE_LONG = 1
TAPE_LOAD = 0
TAPE_UNLOAD = 1
TAPE_TENSION = 2
TAPE_LOCK = 3
TAPE_UNLOCK = 4
TAPE_FORMAT = 5
TAPE_SETMARKS = 0
TAPE_FILEMARKS = 1
TAPE_SHORT_FILEMARKS = 2
TAPE_LONG_FILEMARKS = 3
TAPE_ABSOLUTE_POSITION = 0
TAPE_LOGICAL_POSITION = 1
TAPE_PSEUDO_LOGICAL_POSITION = 2
TAPE_REWIND = 0
TAPE_ABSOLUTE_BLOCK = 1
TAPE_LOGICAL_BLOCK = 2
TAPE_PSEUDO_LOGICAL_BLOCK = 3
TAPE_SPACE_END_OF_DATA = 4
TAPE_SPACE_RELATIVE_BLOCKS = 5
TAPE_SPACE_FILEMARKS = 6
TAPE_SPACE_SEQUENTIAL_FMKS = 7
TAPE_SPACE_SETMARKS = 8
TAPE_SPACE_SEQUENTIAL_SMKS = 9
TAPE_DRIVE_FIXED = 1
TAPE_DRIVE_SELECT = 2
TAPE_DRIVE_INITIATOR = 4
TAPE_DRIVE_ERASE_SHORT = 16
TAPE_DRIVE_ERASE_LONG = 32
TAPE_DRIVE_ERASE_BOP_ONLY = 64
TAPE_DRIVE_ERASE_IMMEDIATE = 128
TAPE_DRIVE_TAPE_CAPACITY = 256
TAPE_DRIVE_TAPE_REMAINING = 512
TAPE_DRIVE_FIXED_BLOCK = 1024
TAPE_DRIVE_VARIABLE_BLOCK = 2048
TAPE_DRIVE_WRITE_PROTECT = 4096
TAPE_DRIVE_EOT_WZ_SIZE = 8192
TAPE_DRIVE_ECC = 65536
TAPE_DRIVE_COMPRESSION = 131072
TAPE_DRIVE_PADDING = 262144
TAPE_DRIVE_REPORT_SMKS = 524288
TAPE_DRIVE_GET_ABSOLUTE_BLK = 1048576
TAPE_DRIVE_GET_LOGICAL_BLK = 2097152
TAPE_DRIVE_SET_EOT_WZ_SIZE = 4194304
TAPE_DRIVE_LOAD_UNLOAD = -2147483647
TAPE_DRIVE_TENSION = -2147483646
TAPE_DRIVE_LOCK_UNLOCK = -2147483644
TAPE_DRIVE_REWIND_IMMEDIATE = -2147483640
TAPE_DRIVE_SET_BLOCK_SIZE = -2147483632
TAPE_DRIVE_LOAD_UNLD_IMMED = -2147483616
TAPE_DRIVE_TENSION_IMMED = -2147483584
TAPE_DRIVE_LOCK_UNLK_IMMED = -2147483520
TAPE_DRIVE_SET_ECC = -2147483392
TAPE_DRIVE_SET_COMPRESSION = -2147483136
TAPE_DRIVE_SET_PADDING = -2147482624
TAPE_DRIVE_SET_REPORT_SMKS = -2147481600
TAPE_DRIVE_ABSOLUTE_BLK = -2147479552
TAPE_DRIVE_ABS_BLK_IMMED = -2147475456
TAPE_DRIVE_LOGICAL_BLK = -2147467264
TAPE_DRIVE_LOG_BLK_IMMED = -2147450880
TAPE_DRIVE_END_OF_DATA = -2147418112
TAPE_DRIVE_RELATIVE_BLKS = -2147352576
TAPE_DRIVE_FILEMARKS = -2147221504
TAPE_DRIVE_SEQUENTIAL_FMKS = -2146959360
TAPE_DRIVE_SETMARKS = -2146435072
TAPE_DRIVE_SEQUENTIAL_SMKS = -2145386496
TAPE_DRIVE_REVERSE_POSITION = -2143289344
TAPE_DRIVE_SPACE_IMMEDIATE = -2139095040
TAPE_DRIVE_WRITE_SETMARKS = -2130706432
TAPE_DRIVE_WRITE_FILEMARKS = -2113929216
TAPE_DRIVE_WRITE_SHORT_FMKS = -2080374784
TAPE_DRIVE_WRITE_LONG_FMKS = -2013265920
TAPE_DRIVE_WRITE_MARK_IMMED = -1879048192
TAPE_DRIVE_FORMAT = -1610612736
TAPE_DRIVE_FORMAT_IMMEDIATE = -1073741824
TAPE_FIXED_PARTITIONS = 0
TAPE_SELECT_PARTITIONS = 1
TAPE_INITIATOR_PARTITIONS = 2
# Generated by h2py from \msvc20\include\winnt.h
# hacked and split by mhammond.

APPLICATION_ERROR_MASK = 536870912
ERROR_SEVERITY_SUCCESS = 0
ERROR_SEVERITY_INFORMATIONAL = 1073741824
ERROR_SEVERITY_WARNING = -2147483648
ERROR_SEVERITY_ERROR = -1073741824
MINCHAR = 128
MAXCHAR = 127
MINSHORT = 32768
MAXSHORT = 32767
MINLONG = -2147483648
MAXLONG = 2147483647
MAXBYTE = 255
MAXWORD = 65535
MAXDWORD = -1
LANG_NEUTRAL = 0
LANG_BULGARIAN = 2
LANG_CHINESE = 4
LANG_CROATIAN = 26
LANG_CZECH = 5
LANG_DANISH = 6
LANG_DUTCH = 19
LANG_ENGLISH = 9
LANG_FINNISH = 11
LANG_FRENCH = 12
LANG_GERMAN = 7
LANG_GREEK = 8
LANG_HUNGARIAN = 14
LANG_ICELANDIC = 15
LANG_ITALIAN = 16
LANG_JAPANESE = 17
LANG_KOREAN = 18
LANG_NORWEGIAN = 20
LANG_POLISH = 21
LANG_PORTUGUESE = 22
LANG_ROMANIAN = 24
LANG_RUSSIAN = 25
LANG_SLOVAK = 27
LANG_SLOVENIAN = 36
LANG_SPANISH = 10
LANG_SWEDISH = 29
LANG_TURKISH = 31
SUBLANG_NEUTRAL = 0
SUBLANG_DEFAULT = 1
SUBLANG_SYS_DEFAULT = 2
SUBLANG_CHINESE_TRADITIONAL = 1
SUBLANG_CHINESE_SIMPLIFIED = 2
SUBLANG_CHINESE_HONGKONG = 3
SUBLANG_CHINESE_SINGAPORE = 4
SUBLANG_DUTCH = 1
SUBLANG_DUTCH_BELGIAN = 2
SUBLANG_ENGLISH_US = 1
SUBLANG_ENGLISH_UK = 2
SUBLANG_ENGLISH_AUS = 3
SUBLANG_ENGLISH_CAN = 4
SUBLANG_ENGLISH_NZ = 5
SUBLANG_ENGLISH_EIRE = 6
SUBLANG_FRENCH = 1
SUBLANG_FRENCH_BELGIAN = 2
SUBLANG_FRENCH_CANADIAN = 3
SUBLANG_FRENCH_SWISS = 4
SUBLANG_GERMAN = 1
SUBLANG_GERMAN_SWISS = 2
SUBLANG_GERMAN_AUSTRIAN = 3
SUBLANG_ITALIAN = 1
SUBLANG_ITALIAN_SWISS = 2
SUBLANG_NORWEGIAN_BOKMAL = 1
SUBLANG_NORWEGIAN_NYNORSK = 2
SUBLANG_PORTUGUESE = 2
SUBLANG_PORTUGUESE_BRAZILIAN = 1
SUBLANG_SPANISH = 1
SUBLANG_SPANISH_MEXICAN = 2
SUBLANG_SPANISH_MODERN = 3
SORT_DEFAULT = 0
SORT_JAPANESE_XJIS = 0
SORT_JAPANESE_UNICODE = 1
SORT_CHINESE_BIG5 = 0
SORT_CHINESE_UNICODE = 1
SORT_KOREAN_KSC = 0
SORT_KOREAN_UNICODE = 1
def PRIMARYLANGID(lgid): return ((lgid) & 1023)

def SUBLANGID(lgid): return ((lgid) >> 10)

NLS_VALID_LOCALE_MASK = 1048575
CONTEXT_PORTABLE_32BIT = 1048576
CONTEXT_ALPHA = 131072
CONTEXT_CONTROL = (CONTEXT_ALPHA | 1)
CONTEXT_FLOATING_POINT = (CONTEXT_ALPHA | 2)
CONTEXT_INTEGER = (CONTEXT_ALPHA | 4)
CONTEXT_FULL = (CONTEXT_CONTROL | CONTEXT_FLOATING_POINT | CONTEXT_INTEGER)
SIZE_OF_80387_REGISTERS = 80
CONTEXT_FULL = (CONTEXT_CONTROL | CONTEXT_FLOATING_POINT | CONTEXT_INTEGER)
CONTEXT_CONTROL = 1
CONTEXT_FLOATING_POINT = 2
CONTEXT_INTEGER = 4
CONTEXT_FULL = (CONTEXT_CONTROL | CONTEXT_FLOATING_POINT | CONTEXT_INTEGER)
PROCESS_TERMINATE = (1)
PROCESS_CREATE_THREAD = (2)
PROCESS_VM_OPERATION = (8)
PROCESS_VM_READ = (16)
PROCESS_VM_WRITE = (32)
PROCESS_DUP_HANDLE = (64)
PROCESS_CREATE_PROCESS = (128)
PROCESS_SET_QUOTA = (256)
PROCESS_SET_INFORMATION = (512)
PROCESS_QUERY_INFORMATION = (1024)
PROCESS_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 4095)
THREAD_TERMINATE = (1)
THREAD_SUSPEND_RESUME = (2)
THREAD_GET_CONTEXT = (8)
THREAD_SET_CONTEXT = (16)
THREAD_SET_INFORMATION = (32)
THREAD_QUERY_INFORMATION = (64)
THREAD_SET_THREAD_TOKEN = (128)
THREAD_IMPERSONATE = (256)
THREAD_DIRECT_IMPERSONATION = (512)
TLS_MINIMUM_AVAILABLE = 64
EVENT_MODIFY_STATE = 2
MUTANT_QUERY_STATE = 1
SEMAPHORE_MODIFY_STATE = 2
TIME_ZONE_ID_UNKNOWN = 0
TIME_ZONE_ID_STANDARD = 1
TIME_ZONE_ID_DAYLIGHT = 2
PROCESSOR_INTEL_386 = 386
PROCESSOR_INTEL_486 = 486
PROCESSOR_INTEL_PENTIUM = 586
PROCESSOR_INTEL_860 = 860
PROCESSOR_MIPS_R2000 = 2000
PROCESSOR_MIPS_R3000 = 3000
PROCESSOR_MIPS_R4000 = 4000
PROCESSOR_ALPHA_21064 = 21064
PROCESSOR_PPC_601 = 601
PROCESSOR_PPC_603 = 603
PROCESSOR_PPC_604 = 604
PROCESSOR_PPC_620 = 620
SECTION_QUERY = 1
SECTION_MAP_WRITE = 2
SECTION_MAP_READ = 4
SECTION_MAP_EXECUTE = 8
SECTION_EXTEND_SIZE = 16
PAGE_NOACCESS = 1
PAGE_READONLY = 2
PAGE_READWRITE = 4
PAGE_WRITECOPY = 8
PAGE_EXECUTE = 16
PAGE_EXECUTE_READ = 32
PAGE_EXECUTE_READWRITE = 64
PAGE_EXECUTE_WRITECOPY = 128
PAGE_GUARD = 256
PAGE_NOCACHE = 512
MEM_COMMIT = 4096
MEM_RESERVE = 8192
MEM_DECOMMIT = 16384
MEM_RELEASE = 32768
MEM_FREE = 65536
MEM_PRIVATE = 131072
MEM_MAPPED = 262144
MEM_TOP_DOWN = 1048576

# Generated by h2py from \msvc20\include\winnt.h
# hacked and split by mhammond.
SEC_FILE = 8388608
SEC_IMAGE = 16777216
SEC_RESERVE = 67108864
SEC_COMMIT = 134217728
SEC_NOCACHE = 268435456
MEM_IMAGE = SEC_IMAGE
FILE_SHARE_READ = 1
FILE_SHARE_WRITE = 2
FILE_SHARE_DELETE = 4
FILE_ATTRIBUTE_READONLY = 1
FILE_ATTRIBUTE_HIDDEN = 2
FILE_ATTRIBUTE_SYSTEM = 4
FILE_ATTRIBUTE_DIRECTORY = 16
FILE_ATTRIBUTE_ARCHIVE = 32
FILE_ATTRIBUTE_NORMAL = 128
FILE_ATTRIBUTE_TEMPORARY = 256
FILE_ATTRIBUTE_ATOMIC_WRITE = 512
FILE_ATTRIBUTE_XACTION_WRITE = 1024
FILE_ATTRIBUTE_COMPRESSED = 2048
FILE_NOTIFY_CHANGE_FILE_NAME = 1
FILE_NOTIFY_CHANGE_DIR_NAME = 2
FILE_NOTIFY_CHANGE_ATTRIBUTES = 4
FILE_NOTIFY_CHANGE_SIZE = 8
FILE_NOTIFY_CHANGE_LAST_WRITE = 16
FILE_NOTIFY_CHANGE_SECURITY = 256
FILE_CASE_SENSITIVE_SEARCH = 1
FILE_CASE_PRESERVED_NAMES = 2
FILE_UNICODE_ON_DISK = 4
FILE_PERSISTENT_ACLS = 8
FILE_FILE_COMPRESSION = 16
FILE_VOLUME_IS_COMPRESSED = 32768
IO_COMPLETION_MODIFY_STATE = 2
DUPLICATE_CLOSE_SOURCE = 1
DUPLICATE_SAME_ACCESS = 2
SID_MAX_SUB_AUTHORITIES = (15)
SECURITY_NULL_RID = (0)
SECURITY_WORLD_RID = (0)
SECURITY_LOCAL_RID = (0X00000000)
SECURITY_CREATOR_OWNER_RID = (0)
SECURITY_CREATOR_GROUP_RID = (1)
SECURITY_DIALUP_RID = (1)
SECURITY_NETWORK_RID = (2)
SECURITY_BATCH_RID = (3)
SECURITY_INTERACTIVE_RID = (4)
SECURITY_SERVICE_RID = (6)
SECURITY_ANONYMOUS_LOGON_RID = (7)
SECURITY_LOGON_IDS_RID = (5)
SECURITY_LOGON_IDS_RID_COUNT = (3)
SECURITY_LOCAL_SYSTEM_RID = (18)
SECURITY_NT_NON_UNIQUE = (21)
SECURITY_BUILTIN_DOMAIN_RID = (32)
DOMAIN_USER_RID_ADMIN = (500)
DOMAIN_USER_RID_GUEST = (501)
DOMAIN_GROUP_RID_ADMINS = (512)
DOMAIN_GROUP_RID_USERS = (513)
DOMAIN_GROUP_RID_GUESTS = (514)
DOMAIN_ALIAS_RID_ADMINS = (544)
DOMAIN_ALIAS_RID_USERS = (545)
DOMAIN_ALIAS_RID_GUESTS = (546)
DOMAIN_ALIAS_RID_POWER_USERS = (547)
DOMAIN_ALIAS_RID_ACCOUNT_OPS = (548)
DOMAIN_ALIAS_RID_SYSTEM_OPS = (549)
DOMAIN_ALIAS_RID_PRINT_OPS = (550)
DOMAIN_ALIAS_RID_BACKUP_OPS = (551)
DOMAIN_ALIAS_RID_REPLICATOR = (552)
SE_GROUP_MANDATORY = (1)
SE_GROUP_ENABLED_BY_DEFAULT = (2)
SE_GROUP_ENABLED = (4)
SE_GROUP_OWNER = (8)
SE_GROUP_LOGON_ID = (-1073741824)
ACL_REVISION = (2)
ACL_REVISION1 = (1)
ACL_REVISION2 = (2)
ACCESS_ALLOWED_ACE_TYPE = (0)
ACCESS_DENIED_ACE_TYPE = (1)
SYSTEM_AUDIT_ACE_TYPE = (2)
SYSTEM_ALARM_ACE_TYPE = (3)
OBJECT_INHERIT_ACE = (1)
CONTAINER_INHERIT_ACE = (2)
NO_PROPAGATE_INHERIT_ACE = (4)
INHERIT_ONLY_ACE = (8)
VALID_INHERIT_FLAGS = (15)
SUCCESSFUL_ACCESS_ACE_FLAG = (64)
FAILED_ACCESS_ACE_FLAG = (128)
SECURITY_DESCRIPTOR_REVISION = (1)
SECURITY_DESCRIPTOR_REVISION1 = (1)
SECURITY_DESCRIPTOR_MIN_LENGTH = (20)
SE_OWNER_DEFAULTED = (1)
SE_GROUP_DEFAULTED = (2)
SE_DACL_PRESENT = (4)
SE_DACL_DEFAULTED = (8)
SE_SACL_PRESENT = (16)
SE_SACL_DEFAULTED = (32)
SE_SELF_RELATIVE = (32768)
SE_PRIVILEGE_ENABLED_BY_DEFAULT = (1)
SE_PRIVILEGE_ENABLED = (2)
SE_PRIVILEGE_USED_FOR_ACCESS = (-2147483648)
PRIVILEGE_SET_ALL_NECESSARY = (1)
SE_CREATE_TOKEN_NAME = "SeCreateTokenPrivilege"
SE_ASSIGNPRIMARYTOKEN_NAME = "SeAssignPrimaryTokenPrivilege"
SE_LOCK_MEMORY_NAME = "SeLockMemoryPrivilege"
SE_INCREASE_QUOTA_NAME = "SeIncreaseQuotaPrivilege"
SE_UNSOLICITED_INPUT_NAME = "SeUnsolicitedInputPrivilege"
SE_MACHINE_ACCOUNT_NAME = "SeMachineAccountPrivilege"
SE_TCB_NAME = "SeTcbPrivilege"
SE_SECURITY_NAME = "SeSecurityPrivilege"
SE_TAKE_OWNERSHIP_NAME = "SeTakeOwnershipPrivilege"
SE_LOAD_DRIVER_NAME = "SeLoadDriverPrivilege"
SE_SYSTEM_PROFILE_NAME = "SeSystemProfilePrivilege"
SE_SYSTEMTIME_NAME = "SeSystemtimePrivilege"
SE_PROF_SINGLE_PROCESS_NAME = "SeProfileSingleProcessPrivilege"
SE_INC_BASE_PRIORITY_NAME = "SeIncreaseBasePriorityPrivilege"
SE_CREATE_PAGEFILE_NAME = "SeCreatePagefilePrivilege"
SE_CREATE_PERMANENT_NAME = "SeCreatePermanentPrivilege"
SE_BACKUP_NAME = "SeBackupPrivilege"
SE_RESTORE_NAME = "SeRestorePrivilege"
SE_SHUTDOWN_NAME = "SeShutdownPrivilege"
SE_DEBUG_NAME = "SeDebugPrivilege"
SE_AUDIT_NAME = "SeAuditPrivilege"
SE_SYSTEM_ENVIRONMENT_NAME = "SeSystemEnvironmentPrivilege"
SE_CHANGE_NOTIFY_NAME = "SeChangeNotifyPrivilege"
SE_REMOTE_SHUTDOWN_NAME = "SeRemoteShutdownPrivilege"

TOKEN_ASSIGN_PRIMARY = (1)
TOKEN_DUPLICATE = (2)
TOKEN_IMPERSONATE = (4)
TOKEN_QUERY = (8)
TOKEN_QUERY_SOURCE = (16)
TOKEN_ADJUST_PRIVILEGES = (32)
TOKEN_ADJUST_GROUPS = (64)
TOKEN_ADJUST_DEFAULT = (128)
TOKEN_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED  |\
                          TOKEN_ASSIGN_PRIMARY      |\
                          TOKEN_DUPLICATE           |\
                          TOKEN_IMPERSONATE         |\
                          TOKEN_QUERY               |\
                          TOKEN_QUERY_SOURCE        |\
                          TOKEN_ADJUST_PRIVILEGES   |\
                          TOKEN_ADJUST_GROUPS       |\
                          TOKEN_ADJUST_DEFAULT)
TOKEN_READ = (STANDARD_RIGHTS_READ      |\
                          TOKEN_QUERY)
TOKEN_WRITE = (STANDARD_RIGHTS_WRITE     |\
                          TOKEN_ADJUST_PRIVILEGES   |\
                          TOKEN_ADJUST_GROUPS       |\
                          TOKEN_ADJUST_DEFAULT)
TOKEN_EXECUTE = (STANDARD_RIGHTS_EXECUTE)
TOKEN_SOURCE_LENGTH = 8

KEY_QUERY_VALUE = (1)
KEY_SET_VALUE = (2)
KEY_CREATE_SUB_KEY = (4)
KEY_ENUMERATE_SUB_KEYS = (8)
KEY_NOTIFY = (16)
KEY_CREATE_LINK = (32)
KEY_READ = ((STANDARD_RIGHTS_READ       |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY)                 \
                                  &                           \
                                 (~SYNCHRONIZE))
KEY_WRITE = ((STANDARD_RIGHTS_WRITE      |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY)         \
                                  &                           \
                                 (~SYNCHRONIZE))
KEY_EXECUTE = ((KEY_READ)                   \
                                  &                           \
                                 (~SYNCHRONIZE))
KEY_ALL_ACCESS = ((STANDARD_RIGHTS_ALL        |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY         |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY                 |\
                                  KEY_CREATE_LINK)            \
                                  &                           \
                                 (~SYNCHRONIZE))
REG_NOTIFY_CHANGE_ATTRIBUTES = (2)
REG_NOTIFY_CHANGE_SECURITY = (8)
REG_RESOURCE_REQUIREMENTS_LIST = ( 10 )
REG_NONE =                   ( 0 )   # No value type
REG_SZ =                     ( 1 )   # Unicode nul terminated string
REG_EXPAND_SZ =              ( 2 )   # Unicode nul terminated string
                                     # (with environment variable references)
REG_BINARY =                 ( 3 )   # Free form binary
REG_DWORD =                  ( 4 )   # 32-bit number
REG_DWORD_LITTLE_ENDIAN =    ( 4 )   # 32-bit number (same as REG_DWORD)
REG_DWORD_BIG_ENDIAN =       ( 5 )   # 32-bit number
REG_LINK =                   ( 6 )   # Symbolic Link (unicode)
REG_MULTI_SZ =               ( 7 )   # Multiple Unicode strings
REG_RESOURCE_LIST =          ( 8 )   # Resource list in the resource map
REG_FULL_RESOURCE_DESCRIPTOR =( 9 )  # Resource list in the hardware description
REG_RESOURCE_REQUIREMENTS_LIST = ( 10 )
REG_QWORD =                 ( 11 )  # 64-bit number
REG_QWORD_LITTLE_ENDIAN =   ( 11 )  # 64-bit number (same as REG_QWORD)


# Generated by h2py from \msvc20\include\winnt.h
# hacked and split by mhammond.
# Included from string.h
_NLSCMPERROR = 2147483647
NULL = 0
HEAP_NO_SERIALIZE = 1
HEAP_GROWABLE = 2
HEAP_GENERATE_EXCEPTIONS = 4
HEAP_ZERO_MEMORY = 8
HEAP_REALLOC_IN_PLACE_ONLY = 16
HEAP_TAIL_CHECKING_ENABLED = 32
HEAP_FREE_CHECKING_ENABLED = 64
HEAP_DISABLE_COALESCE_ON_FREE = 128
IS_TEXT_UNICODE_ASCII16 = 1
IS_TEXT_UNICODE_REVERSE_ASCII16 = 16
IS_TEXT_UNICODE_STATISTICS = 2
IS_TEXT_UNICODE_REVERSE_STATISTICS = 32
IS_TEXT_UNICODE_CONTROLS = 4
IS_TEXT_UNICODE_REVERSE_CONTROLS = 64
IS_TEXT_UNICODE_SIGNATURE = 8
IS_TEXT_UNICODE_REVERSE_SIGNATURE = 128
IS_TEXT_UNICODE_ILLEGAL_CHARS = 256
IS_TEXT_UNICODE_ODD_LENGTH = 512
IS_TEXT_UNICODE_DBCS_LEADBYTE = 1024
IS_TEXT_UNICODE_NULL_BYTES = 4096
IS_TEXT_UNICODE_UNICODE_MASK = 15
IS_TEXT_UNICODE_REVERSE_MASK = 240
IS_TEXT_UNICODE_NOT_UNICODE_MASK = 3840
IS_TEXT_UNICODE_NOT_ASCII_MASK = 61440
COMPRESSION_FORMAT_NONE = (0)
COMPRESSION_FORMAT_DEFAULT = (1)
COMPRESSION_FORMAT_LZNT1 = (2)
COMPRESSION_ENGINE_STANDARD = (0)
COMPRESSION_ENGINE_MAXIMUM = (256)
MESSAGE_RESOURCE_UNICODE = 1
RTL_CRITSECT_TYPE = 0
RTL_RESOURCE_TYPE = 1
DLL_PROCESS_ATTACH = 1
DLL_THREAD_ATTACH = 2
DLL_THREAD_DETACH = 3
DLL_PROCESS_DETACH = 0
EVENTLOG_SEQUENTIAL_READ = 0X0001
EVENTLOG_SEEK_READ = 0X0002
EVENTLOG_FORWARDS_READ = 0X0004
EVENTLOG_BACKWARDS_READ = 0X0008
EVENTLOG_SUCCESS = 0X0000
EVENTLOG_ERROR_TYPE = 1
EVENTLOG_WARNING_TYPE = 2
EVENTLOG_INFORMATION_TYPE = 4
EVENTLOG_AUDIT_SUCCESS = 8
EVENTLOG_AUDIT_FAILURE = 16
EVENTLOG_START_PAIRED_EVENT = 1
EVENTLOG_END_PAIRED_EVENT = 2
EVENTLOG_END_ALL_PAIRED_EVENTS = 4
EVENTLOG_PAIRED_EVENT_ACTIVE = 8
EVENTLOG_PAIRED_EVENT_INACTIVE = 16
# Generated by h2py from \msvc20\include\winnt.h
# hacked and split by mhammond.
OWNER_SECURITY_INFORMATION = (0X00000001)
GROUP_SECURITY_INFORMATION = (0X00000002)
DACL_SECURITY_INFORMATION = (0X00000004)
SACL_SECURITY_INFORMATION = (0X00000008)
IMAGE_SIZEOF_FILE_HEADER = 20
IMAGE_FILE_MACHINE_UNKNOWN = 0
IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16
IMAGE_SIZEOF_ROM_OPTIONAL_HEADER = 56
IMAGE_SIZEOF_STD_OPTIONAL_HEADER = 28
IMAGE_SIZEOF_NT_OPTIONAL_HEADER = 224
IMAGE_NT_OPTIONAL_HDR_MAGIC = 267
IMAGE_ROM_OPTIONAL_HDR_MAGIC = 263
IMAGE_SIZEOF_SHORT_NAME = 8
IMAGE_SIZEOF_SECTION_HEADER = 40
IMAGE_SIZEOF_SYMBOL = 18
IMAGE_SYM_CLASS_NULL = 0
IMAGE_SYM_CLASS_AUTOMATIC = 1
IMAGE_SYM_CLASS_EXTERNAL = 2
IMAGE_SYM_CLASS_STATIC = 3
IMAGE_SYM_CLASS_REGISTER = 4
IMAGE_SYM_CLASS_EXTERNAL_DEF = 5
IMAGE_SYM_CLASS_LABEL = 6
IMAGE_SYM_CLASS_UNDEFINED_LABEL = 7
IMAGE_SYM_CLASS_MEMBER_OF_STRUCT = 8
IMAGE_SYM_CLASS_ARGUMENT = 9
IMAGE_SYM_CLASS_STRUCT_TAG = 10
IMAGE_SYM_CLASS_MEMBER_OF_UNION = 11
IMAGE_SYM_CLASS_UNION_TAG = 12
IMAGE_SYM_CLASS_TYPE_DEFINITION = 13
IMAGE_SYM_CLASS_UNDEFINED_STATIC = 14
IMAGE_SYM_CLASS_ENUM_TAG = 15
IMAGE_SYM_CLASS_MEMBER_OF_ENUM = 16
IMAGE_SYM_CLASS_REGISTER_PARAM = 17
IMAGE_SYM_CLASS_BIT_FIELD = 18
IMAGE_SYM_CLASS_BLOCK = 100
IMAGE_SYM_CLASS_FUNCTION = 101
IMAGE_SYM_CLASS_END_OF_STRUCT = 102
IMAGE_SYM_CLASS_FILE = 103
IMAGE_SYM_CLASS_SECTION = 104
IMAGE_SYM_CLASS_WEAK_EXTERNAL = 105
N_BTMASK = 017
N_TMASK = 060
N_TMASK1 = 0300
N_TMASK2 = 0360
N_BTSHFT = 4
N_TSHIFT = 2
IMAGE_SIZEOF_AUX_SYMBOL = 18
IMAGE_COMDAT_SELECT_NODUPLICATES = 1
IMAGE_COMDAT_SELECT_ANY = 2
IMAGE_COMDAT_SELECT_SAME_SIZE = 3
IMAGE_COMDAT_SELECT_EXACT_MATCH = 4
IMAGE_COMDAT_SELECT_ASSOCIATIVE = 5
IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY = 1
IMAGE_WEAK_EXTERN_SEARCH_LIBRARY = 2
IMAGE_WEAK_EXTERN_SEARCH_ALIAS = 3
IMAGE_SIZEOF_RELOCATION = 10
IMAGE_REL_I386_SECTION = 012
IMAGE_REL_I386_SECREL = 013
IMAGE_REL_MIPS_REFHALF = 01
IMAGE_REL_MIPS_REFWORD = 02
IMAGE_REL_MIPS_JMPADDR = 03
IMAGE_REL_MIPS_REFHI = 04
IMAGE_REL_MIPS_REFLO = 05
IMAGE_REL_MIPS_GPREL = 06
IMAGE_REL_MIPS_LITERAL = 07
IMAGE_REL_MIPS_SECTION = 012
IMAGE_REL_MIPS_SECREL = 013
IMAGE_REL_MIPS_REFWORDNB = 042
IMAGE_REL_MIPS_PAIR = 045
IMAGE_REL_ALPHA_ABSOLUTE = 0
IMAGE_REL_ALPHA_REFLONG = 1
IMAGE_REL_ALPHA_REFQUAD = 2
IMAGE_REL_ALPHA_GPREL32 = 3
IMAGE_REL_ALPHA_LITERAL = 4
IMAGE_REL_ALPHA_LITUSE = 5
IMAGE_REL_ALPHA_GPDISP = 6
IMAGE_REL_ALPHA_BRADDR = 7
IMAGE_REL_ALPHA_HINT = 8
IMAGE_REL_ALPHA_INLINE_REFLONG = 9
IMAGE_REL_ALPHA_REFHI = 10
IMAGE_REL_ALPHA_REFLO = 11
IMAGE_REL_ALPHA_PAIR = 12
IMAGE_REL_ALPHA_MATCH = 13
IMAGE_REL_ALPHA_SECTION = 14
IMAGE_REL_ALPHA_SECREL = 15
IMAGE_REL_ALPHA_REFLONGNB = 16
IMAGE_SIZEOF_BASE_RELOCATION = 8
IMAGE_REL_BASED_ABSOLUTE = 0
IMAGE_REL_BASED_HIGH = 1
IMAGE_REL_BASED_LOW = 2
IMAGE_REL_BASED_HIGHLOW = 3
IMAGE_REL_BASED_HIGHADJ = 4
IMAGE_REL_BASED_MIPS_JMPADDR = 5
IMAGE_SIZEOF_LINENUMBER = 6
IMAGE_ARCHIVE_START_SIZE = 8
IMAGE_ARCHIVE_START = "!<arch>\n"
IMAGE_ARCHIVE_END = "`\n"
IMAGE_ARCHIVE_PAD = "\n"
IMAGE_ARCHIVE_LINKER_MEMBER = "/               "
IMAGE_ARCHIVE_LONGNAMES_MEMBER = "//              "
IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR = 60
IMAGE_ORDINAL_FLAG = -2147483648
def IMAGE_SNAP_BY_ORDINAL(Ordinal): return ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)

def IMAGE_ORDINAL(Ordinal): return (Ordinal & 65535)

IMAGE_RESOURCE_NAME_IS_STRING = -2147483648
IMAGE_RESOURCE_DATA_IS_DIRECTORY = -2147483648
IMAGE_DEBUG_TYPE_UNKNOWN = 0
IMAGE_DEBUG_TYPE_COFF = 1
IMAGE_DEBUG_TYPE_CODEVIEW = 2
IMAGE_DEBUG_TYPE_FPO = 3
IMAGE_DEBUG_TYPE_MISC = 4
IMAGE_DEBUG_TYPE_EXCEPTION = 5
IMAGE_DEBUG_TYPE_FIXUP = 6
IMAGE_DEBUG_TYPE_OMAP_TO_SRC = 7
IMAGE_DEBUG_TYPE_OMAP_FROM_SRC = 8
FRAME_FPO = 0
FRAME_TRAP = 1
FRAME_TSS = 2
SIZEOF_RFPO_DATA = 16
IMAGE_DEBUG_MISC_EXENAME = 1
IMAGE_SEPARATE_DEBUG_SIGNATURE = 18756
# Generated by h2py from \msvcnt\include\wingdi.h
# hacked and split manually by mhammond.
NEWFRAME = 1
ABORTDOC = 2
NEXTBAND = 3
SETCOLORTABLE = 4
GETCOLORTABLE = 5
FLUSHOUTPUT = 6
DRAFTMODE = 7
QUERYESCSUPPORT = 8
SETABORTPROC = 9
STARTDOC = 10
ENDDOC = 11
GETPHYSPAGESIZE = 12
GETPRINTINGOFFSET = 13
GETSCALINGFACTOR = 14
MFCOMMENT = 15
GETPENWIDTH = 16
SETCOPYCOUNT = 17
SELECTPAPERSOURCE = 18
DEVICEDATA = 19
PASSTHROUGH = 19
GETTECHNOLGY = 20
GETTECHNOLOGY = 20
SETLINECAP = 21
SETLINEJOIN = 22
SETMITERLIMIT = 23
BANDINFO = 24
DRAWPATTERNRECT = 25
GETVECTORPENSIZE = 26
GETVECTORBRUSHSIZE = 27
ENABLEDUPLEX = 28
GETSETPAPERBINS = 29
GETSETPRINTORIENT = 30
ENUMPAPERBINS = 31
SETDIBSCALING = 32
EPSPRINTING = 33
ENUMPAPERMETRICS = 34
GETSETPAPERMETRICS = 35
POSTSCRIPT_DATA = 37
POSTSCRIPT_IGNORE = 38
MOUSETRAILS = 39
GETDEVICEUNITS = 42
GETEXTENDEDTEXTMETRICS = 256
GETEXTENTTABLE = 257
GETPAIRKERNTABLE = 258
GETTRACKKERNTABLE = 259
EXTTEXTOUT = 512
GETFACENAME = 513
DOWNLOADFACE = 514
ENABLERELATIVEWIDTHS = 768
ENABLEPAIRKERNING = 769
SETKERNTRACK = 770
SETALLJUSTVALUES = 771
SETCHARSET = 772
STRETCHBLT = 2048
GETSETSCREENPARAMS = 3072
BEGIN_PATH = 4096
CLIP_TO_PATH = 4097
END_PATH = 4098
EXT_DEVICE_CAPS = 4099
RESTORE_CTM = 4100
SAVE_CTM = 4101
SET_ARC_DIRECTION = 4102
SET_BACKGROUND_COLOR = 4103
SET_POLY_MODE = 4104
SET_SCREEN_ANGLE = 4105
SET_SPREAD = 4106
TRANSFORM_CTM = 4107
SET_CLIP_BOX = 4108
SET_BOUNDS = 4109
SET_MIRROR_MODE = 4110
OPENCHANNEL = 4110
DOWNLOADHEADER = 4111
CLOSECHANNEL = 4112
POSTSCRIPT_PASSTHROUGH = 4115
ENCAPSULATED_POSTSCRIPT = 4116
SP_NOTREPORTED = 16384
SP_ERROR = (-1)
SP_APPABORT = (-2)
SP_USERABORT = (-3)
SP_OUTOFDISK = (-4)
SP_OUTOFMEMORY = (-5)
PR_JOBSTATUS = 0
OBJ_PEN = 1
OBJ_BRUSH = 2
OBJ_DC = 3
OBJ_METADC = 4
OBJ_PAL = 5
OBJ_FONT = 6
OBJ_BITMAP = 7
OBJ_REGION = 8
OBJ_METAFILE = 9
OBJ_MEMDC = 10
OBJ_EXTPEN = 11
OBJ_ENHMETADC = 12
OBJ_ENHMETAFILE = 13
MWT_IDENTITY = 1
MWT_LEFTMULTIPLY = 2
MWT_RIGHTMULTIPLY = 3
MWT_MIN = MWT_IDENTITY
MWT_MAX = MWT_RIGHTMULTIPLY
BI_RGB = 0
BI_RLE8 = 1
BI_RLE4 = 2
BI_BITFIELDS = 3
TMPF_FIXED_PITCH = 1
TMPF_VECTOR = 2
TMPF_DEVICE = 8
TMPF_TRUETYPE = 4
NTM_REGULAR = 64
NTM_BOLD = 32
NTM_ITALIC = 1
LF_FACESIZE = 32
LF_FULLFACESIZE = 64
OUT_DEFAULT_PRECIS = 0
OUT_STRING_PRECIS = 1
OUT_CHARACTER_PRECIS = 2
OUT_STROKE_PRECIS = 3
OUT_TT_PRECIS = 4
OUT_DEVICE_PRECIS = 5
OUT_RASTER_PRECIS = 6
OUT_TT_ONLY_PRECIS = 7
OUT_OUTLINE_PRECIS = 8
CLIP_DEFAULT_PRECIS = 0
CLIP_CHARACTER_PRECIS = 1
CLIP_STROKE_PRECIS = 2
CLIP_MASK = 15
CLIP_LH_ANGLES = (1<<4)
CLIP_TT_ALWAYS = (2<<4)
CLIP_EMBEDDED = (8<<4)
DEFAULT_QUALITY = 0
DRAFT_QUALITY = 1
PROOF_QUALITY = 2
NONANTIALIASED_QUALITY = 3
ANTIALIASED_QUALITY = 4
CLEARTYPE_QUALITY = 5
CLEARTYPE_NATURAL_QUALITY = 6
DEFAULT_PITCH = 0
FIXED_PITCH = 1
VARIABLE_PITCH = 2
ANSI_CHARSET = 0
DEFAULT_CHARSET = 1
SYMBOL_CHARSET = 2
SHIFTJIS_CHARSET = 128
HANGEUL_CHARSET = 129
CHINESEBIG5_CHARSET = 136
OEM_CHARSET = 255
JOHAB_CHARSET = 130
HEBREW_CHARSET = 177
ARABIC_CHARSET = 178
GREEK_CHARSET = 161
TURKISH_CHARSET = 162
VIETNAMESE_CHARSET = 163
THAI_CHARSET = 222
EASTEUROPE_CHARSET = 238
RUSSIAN_CHARSET = 204
MAC_CHARSET = 77
BALTIC_CHARSET = 186
FF_DONTCARE = (0<<4)
FF_ROMAN = (1<<4)
FF_SWISS = (2<<4)
FF_MODERN = (3<<4)
FF_SCRIPT = (4<<4)
FF_DECORATIVE = (5<<4)
FW_DONTCARE = 0
FW_THIN = 100
FW_EXTRALIGHT = 200
FW_LIGHT = 300
FW_NORMAL = 400
FW_MEDIUM = 500
FW_SEMIBOLD = 600
FW_BOLD = 700
FW_EXTRABOLD = 800
FW_HEAVY = 900
FW_ULTRALIGHT = FW_EXTRALIGHT
FW_REGULAR = FW_NORMAL
FW_DEMIBOLD = FW_SEMIBOLD
FW_ULTRABOLD = FW_EXTRABOLD
FW_BLACK = FW_HEAVY
# Generated by h2py from \msvcnt\include\wingdi.h
# hacked and split manually by mhammond.
BS_SOLID = 0
BS_NULL = 1
BS_HOLLOW = BS_NULL
BS_HATCHED = 2
BS_PATTERN = 3
BS_INDEXED = 4
BS_DIBPATTERN = 5
BS_DIBPATTERNPT = 6
BS_PATTERN8X8 = 7
BS_DIBPATTERN8X8 = 8
HS_HORIZONTAL = 0
HS_VERTICAL = 1
HS_FDIAGONAL = 2
HS_BDIAGONAL = 3
HS_CROSS = 4
HS_DIAGCROSS = 5
HS_FDIAGONAL1 = 6
HS_BDIAGONAL1 = 7
HS_SOLID = 8
HS_DENSE1 = 9
HS_DENSE2 = 10
HS_DENSE3 = 11
HS_DENSE4 = 12
HS_DENSE5 = 13
HS_DENSE6 = 14
HS_DENSE7 = 15
HS_DENSE8 = 16
HS_NOSHADE = 17
HS_HALFTONE = 18
HS_SOLIDCLR = 19
HS_DITHEREDCLR = 20
HS_SOLIDTEXTCLR = 21
HS_DITHEREDTEXTCLR = 22
HS_SOLIDBKCLR = 23
HS_DITHEREDBKCLR = 24
HS_API_MAX = 25
PS_SOLID = 0
PS_DASH = 1
PS_DOT = 2
PS_DASHDOT = 3
PS_DASHDOTDOT = 4
PS_NULL = 5
PS_INSIDEFRAME = 6
PS_USERSTYLE = 7
PS_ALTERNATE = 8
PS_STYLE_MASK = 15
PS_ENDCAP_ROUND = 0
PS_ENDCAP_SQUARE = 256
PS_ENDCAP_FLAT = 512
PS_ENDCAP_MASK = 3840
PS_JOIN_ROUND = 0
PS_JOIN_BEVEL = 4096
PS_JOIN_MITER = 8192
PS_JOIN_MASK = 61440
PS_COSMETIC = 0
PS_GEOMETRIC = 65536
PS_TYPE_MASK = 983040
AD_COUNTERCLOCKWISE = 1
AD_CLOCKWISE = 2
DRIVERVERSION = 0
TECHNOLOGY = 2
HORZSIZE = 4
VERTSIZE = 6
HORZRES = 8
VERTRES = 10
BITSPIXEL = 12
PLANES = 14
NUMBRUSHES = 16
NUMPENS = 18
NUMMARKERS = 20
NUMFONTS = 22
NUMCOLORS = 24
PDEVICESIZE = 26
CURVECAPS = 28
LINECAPS = 30
POLYGONALCAPS = 32
TEXTCAPS = 34
CLIPCAPS = 36
RASTERCAPS = 38
ASPECTX = 40
ASPECTY = 42
ASPECTXY = 44
LOGPIXELSX = 88
LOGPIXELSY = 90
SIZEPALETTE = 104
NUMRESERVED = 106
COLORRES = 108
DT_PLOTTER = 0
DT_RASDISPLAY = 1
DT_RASPRINTER = 2
DT_RASCAMERA = 3
DT_CHARSTREAM = 4
DT_METAFILE = 5
DT_DISPFILE = 6
CC_NONE = 0
CC_CIRCLES = 1
CC_PIE = 2
CC_CHORD = 4
CC_ELLIPSES = 8
CC_WIDE = 16
CC_STYLED = 32
CC_WIDESTYLED = 64
CC_INTERIORS = 128
CC_ROUNDRECT = 256
LC_NONE = 0
LC_POLYLINE = 2
LC_MARKER = 4
LC_POLYMARKER = 8
LC_WIDE = 16
LC_STYLED = 32
LC_WIDESTYLED = 64
LC_INTERIORS = 128
PC_NONE = 0
PC_POLYGON = 1
PC_RECTANGLE = 2
PC_WINDPOLYGON = 4
PC_TRAPEZOID = 4
PC_SCANLINE = 8
PC_WIDE = 16
PC_STYLED = 32
PC_WIDESTYLED = 64
PC_INTERIORS = 128
CP_NONE = 0
CP_RECTANGLE = 1
CP_REGION = 2
TC_OP_CHARACTER = 1
TC_OP_STROKE = 2
TC_CP_STROKE = 4
TC_CR_90 = 8
TC_CR_ANY = 16
TC_SF_X_YINDEP = 32
TC_SA_DOUBLE = 64
TC_SA_INTEGER = 128
TC_SA_CONTIN = 256
TC_EA_DOUBLE = 512
TC_IA_ABLE = 1024
TC_UA_ABLE = 2048
TC_SO_ABLE = 4096
TC_RA_ABLE = 8192
TC_VA_ABLE = 16384
TC_RESERVED = 32768
TC_SCROLLBLT = 65536
RC_BITBLT = 1
RC_BANDING = 2
RC_SCALING = 4
RC_BITMAP64 = 8
RC_GDI20_OUTPUT = 16
RC_GDI20_STATE = 32
RC_SAVEBITMAP = 64
RC_DI_BITMAP = 128
RC_PALETTE = 256
RC_DIBTODEV = 512
RC_BIGFONT = 1024
RC_STRETCHBLT = 2048
RC_FLOODFILL = 4096
RC_STRETCHDIB = 8192
RC_OP_DX_OUTPUT = 16384
RC_DEVBITS = 32768
DIB_RGB_COLORS = 0
DIB_PAL_COLORS = 1
DIB_PAL_INDICES = 2
DIB_PAL_PHYSINDICES = 2
DIB_PAL_LOGINDICES = 4
SYSPAL_ERROR = 0
SYSPAL_STATIC = 1
SYSPAL_NOSTATIC = 2
CBM_CREATEDIB = 2
CBM_INIT = 4
FLOODFILLBORDER = 0
FLOODFILLSURFACE = 1
CCHDEVICENAME = 32
CCHFORMNAME = 32
# Generated by h2py from \msvcnt\include\wingdi.h
# hacked and split manually by mhammond.

# DEVMODE.dmFields
DM_SPECVERSION = 800
DM_ORIENTATION = 1
DM_PAPERSIZE = 2
DM_PAPERLENGTH = 4
DM_PAPERWIDTH = 8
DM_SCALE = 16
DM_POSITION = 32
DM_NUP = 64
DM_DISPLAYORIENTATION = 128
DM_COPIES = 256
DM_DEFAULTSOURCE = 512
DM_PRINTQUALITY = 1024
DM_COLOR = 2048
DM_DUPLEX = 4096
DM_YRESOLUTION = 8192
DM_TTOPTION = 16384
DM_COLLATE = 32768
DM_FORMNAME = 65536
DM_LOGPIXELS = 131072
DM_BITSPERPEL = 262144
DM_PELSWIDTH = 524288
DM_PELSHEIGHT = 1048576
DM_DISPLAYFLAGS = 2097152
DM_DISPLAYFREQUENCY = 4194304
DM_ICMMETHOD = 8388608
DM_ICMINTENT = 16777216
DM_MEDIATYPE = 33554432
DM_DITHERTYPE = 67108864
DM_PANNINGWIDTH = 134217728
DM_PANNINGHEIGHT = 268435456
DM_DISPLAYFIXEDOUTPUT = 536870912

# DEVMODE.dmOrientation
DMORIENT_PORTRAIT = 1
DMORIENT_LANDSCAPE = 2

# DEVMODE.dmDisplayOrientation
DMDO_DEFAULT = 0
DMDO_90 = 1
DMDO_180 = 2
DMDO_270 = 3

# DEVMODE.dmDisplayFixedOutput
DMDFO_DEFAULT = 0
DMDFO_STRETCH = 1
DMDFO_CENTER = 2

# DEVMODE.dmPaperSize
DMPAPER_LETTER = 1
DMPAPER_LETTERSMALL = 2
DMPAPER_TABLOID = 3
DMPAPER_LEDGER = 4
DMPAPER_LEGAL = 5
DMPAPER_STATEMENT = 6
DMPAPER_EXECUTIVE = 7
DMPAPER_A3 = 8
DMPAPER_A4 = 9
DMPAPER_A4SMALL = 10
DMPAPER_A5 = 11
DMPAPER_B4 = 12
DMPAPER_B5 = 13
DMPAPER_FOLIO = 14
DMPAPER_QUARTO = 15
DMPAPER_10X14 = 16
DMPAPER_11X17 = 17
DMPAPER_NOTE = 18
DMPAPER_ENV_9 = 19
DMPAPER_ENV_10 = 20
DMPAPER_ENV_11 = 21
DMPAPER_ENV_12 = 22
DMPAPER_ENV_14 = 23
DMPAPER_CSHEET = 24
DMPAPER_DSHEET = 25
DMPAPER_ESHEET = 26
DMPAPER_ENV_DL = 27
DMPAPER_ENV_C5 = 28
DMPAPER_ENV_C3 = 29
DMPAPER_ENV_C4 = 30
DMPAPER_ENV_C6 = 31
DMPAPER_ENV_C65 = 32
DMPAPER_ENV_B4 = 33
DMPAPER_ENV_B5 = 34
DMPAPER_ENV_B6 = 35
DMPAPER_ENV_ITALY = 36
DMPAPER_ENV_MONARCH = 37
DMPAPER_ENV_PERSONAL = 38
DMPAPER_FANFOLD_US = 39
DMPAPER_FANFOLD_STD_GERMAN = 40
DMPAPER_FANFOLD_LGL_GERMAN = 41
DMPAPER_ISO_B4 = 42
DMPAPER_JAPANESE_POSTCARD = 43
DMPAPER_9X11 = 44
DMPAPER_10X11 = 45
DMPAPER_15X11 = 46
DMPAPER_ENV_INVITE = 47
DMPAPER_RESERVED_48 = 48
DMPAPER_RESERVED_49 = 49
DMPAPER_LETTER_EXTRA = 50
DMPAPER_LEGAL_EXTRA = 51
DMPAPER_TABLOID_EXTRA = 52
DMPAPER_A4_EXTRA = 53
DMPAPER_LETTER_TRANSVERSE = 54
DMPAPER_A4_TRANSVERSE = 55
DMPAPER_LETTER_EXTRA_TRANSVERSE = 56
DMPAPER_A_PLUS = 57
DMPAPER_B_PLUS = 58
DMPAPER_LETTER_PLUS = 59
DMPAPER_A4_PLUS = 60
DMPAPER_A5_TRANSVERSE = 61
DMPAPER_B5_TRANSVERSE = 62
DMPAPER_A3_EXTRA = 63
DMPAPER_A5_EXTRA = 64
DMPAPER_B5_EXTRA = 65
DMPAPER_A2 = 66
DMPAPER_A3_TRANSVERSE = 67
DMPAPER_A3_EXTRA_TRANSVERSE = 68
DMPAPER_DBL_JAPANESE_POSTCARD = 69
DMPAPER_A6 = 70
DMPAPER_JENV_KAKU2 = 71
DMPAPER_JENV_KAKU3 = 72
DMPAPER_JENV_CHOU3 = 73
DMPAPER_JENV_CHOU4 = 74
DMPAPER_LETTER_ROTATED = 75
DMPAPER_A3_ROTATED = 76
DMPAPER_A4_ROTATED = 77
DMPAPER_A5_ROTATED = 78
DMPAPER_B4_JIS_ROTATED = 79
DMPAPER_B5_JIS_ROTATED = 80
DMPAPER_JAPANESE_POSTCARD_ROTATED = 81
DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82
DMPAPER_A6_ROTATED = 83
DMPAPER_JENV_KAKU2_ROTATED = 84
DMPAPER_JENV_KAKU3_ROTATED = 85
DMPAPER_JENV_CHOU3_ROTATED = 86
DMPAPER_JENV_CHOU4_ROTATED = 87
DMPAPER_B6_JIS = 88
DMPAPER_B6_JIS_ROTATED = 89
DMPAPER_12X11 = 90
DMPAPER_JENV_YOU4 = 91
DMPAPER_JENV_YOU4_ROTATED = 92
DMPAPER_P16K = 93
DMPAPER_P32K = 94
DMPAPER_P32KBIG = 95
DMPAPER_PENV_1 = 96
DMPAPER_PENV_2 = 97
DMPAPER_PENV_3 = 98
DMPAPER_PENV_4 = 99
DMPAPER_PENV_5 = 100
DMPAPER_PENV_6 = 101
DMPAPER_PENV_7 = 102
DMPAPER_PENV_8 = 103
DMPAPER_PENV_9 = 104
DMPAPER_PENV_10 = 105
DMPAPER_P16K_ROTATED = 106
DMPAPER_P32K_ROTATED = 107
DMPAPER_P32KBIG_ROTATED = 108
DMPAPER_PENV_1_ROTATED = 109
DMPAPER_PENV_2_ROTATED = 110
DMPAPER_PENV_3_ROTATED = 111
DMPAPER_PENV_4_ROTATED = 112
DMPAPER_PENV_5_ROTATED = 113
DMPAPER_PENV_6_ROTATED = 114
DMPAPER_PENV_7_ROTATED = 115
DMPAPER_PENV_8_ROTATED = 116
DMPAPER_PENV_9_ROTATED = 117
DMPAPER_PENV_10_ROTATED = 118
DMPAPER_LAST = DMPAPER_PENV_10_ROTATED
DMPAPER_USER = 256

# DEVMODE.dmDefaultSource
DMBIN_UPPER = 1
DMBIN_ONLYONE = 1
DMBIN_LOWER = 2
DMBIN_MIDDLE = 3
DMBIN_MANUAL = 4
DMBIN_ENVELOPE = 5
DMBIN_ENVMANUAL = 6
DMBIN_AUTO = 7
DMBIN_TRACTOR = 8
DMBIN_SMALLFMT = 9
DMBIN_LARGEFMT = 10
DMBIN_LARGECAPACITY = 11
DMBIN_CASSETTE = 14
DMBIN_LAST = DMBIN_CASSETTE
DMBIN_USER = 256

# DEVMODE.dmPrintQuality
DMRES_DRAFT = (-1)
DMRES_LOW = (-2)
DMRES_MEDIUM = (-3)
DMRES_HIGH = (-4)

# DEVMODE.dmColor
DMCOLOR_MONOCHROME = 1
DMCOLOR_COLOR = 2

# DEVMODE.dmDuplex
DMDUP_SIMPLEX = 1
DMDUP_VERTICAL = 2
DMDUP_HORIZONTAL = 3

# DEVMODE.dmTTOption
DMTT_BITMAP = 1
DMTT_DOWNLOAD = 2
DMTT_SUBDEV = 3
DMTT_DOWNLOAD_OUTLINE = 4

# DEVMODE.dmCollate
DMCOLLATE_FALSE = 0
DMCOLLATE_TRUE = 1

# DEVMODE.dmDisplayFlags
DM_GRAYSCALE = 1
DM_INTERLACED = 2

# DEVMODE.dmICMMethod
DMICMMETHOD_NONE = 1
DMICMMETHOD_SYSTEM = 2
DMICMMETHOD_DRIVER = 3
DMICMMETHOD_DEVICE = 4
DMICMMETHOD_USER = 256

# DEVMODE.dmICMIntent
DMICM_SATURATE = 1
DMICM_CONTRAST = 2
DMICM_COLORIMETRIC = 3
DMICM_ABS_COLORIMETRIC = 4
DMICM_USER = 256

# DEVMODE.dmMediaType
DMMEDIA_STANDARD = 1
DMMEDIA_TRANSPARENCY = 2
DMMEDIA_GLOSSY = 3
DMMEDIA_USER = 256

# DEVMODE.dmDitherType
DMDITHER_NONE = 1
DMDITHER_COARSE = 2
DMDITHER_FINE = 3
DMDITHER_LINEART = 4
DMDITHER_ERRORDIFFUSION = 5
DMDITHER_RESERVED6 = 6
DMDITHER_RESERVED7 = 7
DMDITHER_RESERVED8 = 8
DMDITHER_RESERVED9 = 9
DMDITHER_GRAYSCALE = 10
DMDITHER_USER = 256

# DEVMODE.dmNup
DMNUP_SYSTEM = 1
DMNUP_ONEUP = 2

RDH_RECTANGLES = 1
GGO_METRICS = 0
GGO_BITMAP = 1
GGO_NATIVE = 2
TT_POLYGON_TYPE = 24
TT_PRIM_LINE = 1
TT_PRIM_QSPLINE = 2
TT_AVAILABLE = 1
TT_ENABLED = 2
DM_UPDATE = 1
DM_COPY = 2
DM_PROMPT = 4
DM_MODIFY = 8
DM_IN_BUFFER = DM_MODIFY
DM_IN_PROMPT = DM_PROMPT
DM_OUT_BUFFER = DM_COPY
DM_OUT_DEFAULT = DM_UPDATE

# DISPLAY_DEVICE.StateFlags
DISPLAY_DEVICE_ATTACHED_TO_DESKTOP = 1
DISPLAY_DEVICE_MULTI_DRIVER = 2
DISPLAY_DEVICE_PRIMARY_DEVICE = 4
DISPLAY_DEVICE_MIRRORING_DRIVER = 8
DISPLAY_DEVICE_VGA_COMPATIBLE = 16
DISPLAY_DEVICE_REMOVABLE = 32
DISPLAY_DEVICE_MODESPRUNED = 134217728
DISPLAY_DEVICE_REMOTE = 67108864
DISPLAY_DEVICE_DISCONNECT = 33554432

# DeviceCapabilities types
DC_FIELDS = 1
DC_PAPERS = 2
DC_PAPERSIZE = 3
DC_MINEXTENT = 4
DC_MAXEXTENT = 5
DC_BINS = 6
DC_DUPLEX = 7
DC_SIZE = 8
DC_EXTRA = 9
DC_VERSION = 10
DC_DRIVER = 11
DC_BINNAMES = 12
DC_ENUMRESOLUTIONS = 13
DC_FILEDEPENDENCIES = 14
DC_TRUETYPE = 15
DC_PAPERNAMES = 16
DC_ORIENTATION = 17
DC_COPIES = 18
DC_BINADJUST = 19
DC_EMF_COMPLIANT = 20
DC_DATATYPE_PRODUCED = 21
DC_COLLATE = 22
DC_MANUFACTURER = 23
DC_MODEL = 24
DC_PERSONALITY = 25
DC_PRINTRATE = 26
DC_PRINTRATEUNIT = 27
DC_PRINTERMEM = 28
DC_MEDIAREADY = 29
DC_STAPLE = 30
DC_PRINTRATEPPM = 31
DC_COLORDEVICE = 32
DC_NUP = 33
DC_MEDIATYPENAMES = 34
DC_MEDIATYPES = 35

PRINTRATEUNIT_PPM = 1
PRINTRATEUNIT_CPS = 2
PRINTRATEUNIT_LPM = 3
PRINTRATEUNIT_IPM = 4

# TrueType constants
DCTT_BITMAP = 1
DCTT_DOWNLOAD = 2
DCTT_SUBDEV = 4
DCTT_DOWNLOAD_OUTLINE = 8

CA_NEGATIVE = 1
CA_LOG_FILTER = 2
ILLUMINANT_DEVICE_DEFAULT = 0
ILLUMINANT_A = 1
ILLUMINANT_B = 2
ILLUMINANT_C = 3
ILLUMINANT_D50 = 4
ILLUMINANT_D55 = 5
ILLUMINANT_D65 = 6
ILLUMINANT_D75 = 7
ILLUMINANT_F2 = 8
ILLUMINANT_MAX_INDEX = ILLUMINANT_F2
ILLUMINANT_TUNGSTEN = ILLUMINANT_A
ILLUMINANT_DAYLIGHT = ILLUMINANT_C
ILLUMINANT_FLUORESCENT = ILLUMINANT_F2
ILLUMINANT_NTSC = ILLUMINANT_C

# Generated by h2py from \msvcnt\include\wingdi.h
# hacked and split manually by mhammond.
FONTMAPPER_MAX = 10
ENHMETA_SIGNATURE = 1179469088
ENHMETA_STOCK_OBJECT = -2147483648
EMR_HEADER = 1
EMR_POLYBEZIER = 2
EMR_POLYGON = 3
EMR_POLYLINE = 4
EMR_POLYBEZIERTO = 5
EMR_POLYLINETO = 6
EMR_POLYPOLYLINE = 7
EMR_POLYPOLYGON = 8
EMR_SETWINDOWEXTEX = 9
EMR_SETWINDOWORGEX = 10
EMR_SETVIEWPORTEXTEX = 11
EMR_SETVIEWPORTORGEX = 12
EMR_SETBRUSHORGEX = 13
EMR_EOF = 14
EMR_SETPIXELV = 15
EMR_SETMAPPERFLAGS = 16
EMR_SETMAPMODE = 17
EMR_SETBKMODE = 18
EMR_SETPOLYFILLMODE = 19
EMR_SETROP2 = 20
EMR_SETSTRETCHBLTMODE = 21
EMR_SETTEXTALIGN = 22
EMR_SETCOLORADJUSTMENT = 23
EMR_SETTEXTCOLOR = 24
EMR_SETBKCOLOR = 25
EMR_OFFSETCLIPRGN = 26
EMR_MOVETOEX = 27
EMR_SETMETARGN = 28
EMR_EXCLUDECLIPRECT = 29
EMR_INTERSECTCLIPRECT = 30
EMR_SCALEVIEWPORTEXTEX = 31
EMR_SCALEWINDOWEXTEX = 32
EMR_SAVEDC = 33
EMR_RESTOREDC = 34
EMR_SETWORLDTRANSFORM = 35
EMR_MODIFYWORLDTRANSFORM = 36
EMR_SELECTOBJECT = 37
EMR_CREATEPEN = 38
EMR_CREATEBRUSHINDIRECT = 39
EMR_DELETEOBJECT = 40
EMR_ANGLEARC = 41
EMR_ELLIPSE = 42
EMR_RECTANGLE = 43
EMR_ROUNDRECT = 44
EMR_ARC = 45
EMR_CHORD = 46
EMR_PIE = 47
EMR_SELECTPALETTE = 48
EMR_CREATEPALETTE = 49
EMR_SETPALETTEENTRIES = 50
EMR_RESIZEPALETTE = 51
EMR_REALIZEPALETTE = 52
EMR_EXTFLOODFILL = 53
EMR_LINETO = 54
EMR_ARCTO = 55
EMR_POLYDRAW = 56
EMR_SETARCDIRECTION = 57
EMR_SETMITERLIMIT = 58
EMR_BEGINPATH = 59
EMR_ENDPATH = 60
EMR_CLOSEFIGURE = 61
EMR_FILLPATH = 62
EMR_STROKEANDFILLPATH = 63
EMR_STROKEPATH = 64
EMR_FLATTENPATH = 65
EMR_WIDENPATH = 66
EMR_SELECTCLIPPATH = 67
EMR_ABORTPATH = 68
EMR_GDICOMMENT = 70
EMR_FILLRGN = 71
EMR_FRAMERGN = 72
EMR_INVERTRGN = 73
EMR_PAINTRGN = 74
EMR_EXTSELECTCLIPRGN = 75
EMR_BITBLT = 76
EMR_STRETCHBLT = 77
EMR_MASKBLT = 78
EMR_PLGBLT = 79
EMR_SETDIBITSTODEVICE = 80
EMR_STRETCHDIBITS = 81
EMR_EXTCREATEFONTINDIRECTW = 82
EMR_EXTTEXTOUTA = 83
EMR_EXTTEXTOUTW = 84
EMR_POLYBEZIER16 = 85
EMR_POLYGON16 = 86
EMR_POLYLINE16 = 87
EMR_POLYBEZIERTO16 = 88
EMR_POLYLINETO16 = 89
EMR_POLYPOLYLINE16 = 90
EMR_POLYPOLYGON16 = 91
EMR_POLYDRAW16 = 92
EMR_CREATEMONOBRUSH = 93
EMR_CREATEDIBPATTERNBRUSHPT = 94
EMR_EXTCREATEPEN = 95
EMR_POLYTEXTOUTA = 96
EMR_POLYTEXTOUTW = 97
EMR_MIN = 1
EMR_MAX = 97
# Generated by h2py from \msvcnt\include\wingdi.h
# hacked and split manually by mhammond.
PANOSE_COUNT = 10
PAN_FAMILYTYPE_INDEX = 0
PAN_SERIFSTYLE_INDEX = 1
PAN_WEIGHT_INDEX = 2
PAN_PROPORTION_INDEX = 3
PAN_CONTRAST_INDEX = 4
PAN_STROKEVARIATION_INDEX = 5
PAN_ARMSTYLE_INDEX = 6
PAN_LETTERFORM_INDEX = 7
PAN_MIDLINE_INDEX = 8
PAN_XHEIGHT_INDEX = 9
PAN_CULTURE_LATIN = 0
PAN_ANY = 0
PAN_NO_FIT = 1
PAN_FAMILY_TEXT_DISPLAY = 2
PAN_FAMILY_SCRIPT = 3
PAN_FAMILY_DECORATIVE = 4
PAN_FAMILY_PICTORIAL = 5
PAN_SERIF_COVE = 2
PAN_SERIF_OBTUSE_COVE = 3
PAN_SERIF_SQUARE_COVE = 4
PAN_SERIF_OBTUSE_SQUARE_COVE = 5
PAN_SERIF_SQUARE = 6
PAN_SERIF_THIN = 7
PAN_SERIF_BONE = 8
PAN_SERIF_EXAGGERATED = 9
PAN_SERIF_TRIANGLE = 10
PAN_SERIF_NORMAL_SANS = 11
PAN_SERIF_OBTUSE_SANS = 12
PAN_SERIF_PERP_SANS = 13
PAN_SERIF_FLARED = 14
PAN_SERIF_ROUNDED = 15
PAN_WEIGHT_VERY_LIGHT = 2
PAN_WEIGHT_LIGHT = 3
PAN_WEIGHT_THIN = 4
PAN_WEIGHT_BOOK = 5
PAN_WEIGHT_MEDIUM = 6
PAN_WEIGHT_DEMI = 7
PAN_WEIGHT_BOLD = 8
PAN_WEIGHT_HEAVY = 9
PAN_WEIGHT_BLACK = 10
PAN_WEIGHT_NORD = 11
PAN_PROP_OLD_STYLE = 2
PAN_PROP_MODERN = 3
PAN_PROP_EVEN_WIDTH = 4
PAN_PROP_EXPANDED = 5
PAN_PROP_CONDENSED = 6
PAN_PROP_VERY_EXPANDED = 7
PAN_PROP_VERY_CONDENSED = 8
PAN_PROP_MONOSPACED = 9
PAN_CONTRAST_NONE = 2
PAN_CONTRAST_VERY_LOW = 3
PAN_CONTRAST_LOW = 4
PAN_CONTRAST_MEDIUM_LOW = 5
PAN_CONTRAST_MEDIUM = 6
PAN_CONTRAST_MEDIUM_HIGH = 7
PAN_CONTRAST_HIGH = 8
PAN_CONTRAST_VERY_HIGH = 9
PAN_STROKE_GRADUAL_DIAG = 2
PAN_STROKE_GRADUAL_TRAN = 3
PAN_STROKE_GRADUAL_VERT = 4
PAN_STROKE_GRADUAL_HORZ = 5
PAN_STROKE_RAPID_VERT = 6
PAN_STROKE_RAPID_HORZ = 7
PAN_STROKE_INSTANT_VERT = 8
PAN_STRAIGHT_ARMS_HORZ = 2
PAN_STRAIGHT_ARMS_WEDGE = 3
PAN_STRAIGHT_ARMS_VERT = 4
PAN_STRAIGHT_ARMS_SINGLE_SERIF = 5
PAN_STRAIGHT_ARMS_DOUBLE_SERIF = 6
PAN_BENT_ARMS_HORZ = 7
PAN_BENT_ARMS_WEDGE = 8
PAN_BENT_ARMS_VERT = 9
PAN_BENT_ARMS_SINGLE_SERIF = 10
PAN_BENT_ARMS_DOUBLE_SERIF = 11
PAN_LETT_NORMAL_CONTACT = 2
PAN_LETT_NORMAL_WEIGHTED = 3
PAN_LETT_NORMAL_BOXED = 4
PAN_LETT_NORMAL_FLATTENED = 5
PAN_LETT_NORMAL_ROUNDED = 6
PAN_LETT_NORMAL_OFF_CENTER = 7
PAN_LETT_NORMAL_SQUARE = 8
PAN_LETT_OBLIQUE_CONTACT = 9
PAN_LETT_OBLIQUE_WEIGHTED = 10
PAN_LETT_OBLIQUE_BOXED = 11
PAN_LETT_OBLIQUE_FLATTENED = 12
PAN_LETT_OBLIQUE_ROUNDED = 13
PAN_LETT_OBLIQUE_OFF_CENTER = 14
PAN_LETT_OBLIQUE_SQUARE = 15
PAN_MIDLINE_STANDARD_TRIMMED = 2
PAN_MIDLINE_STANDARD_POINTED = 3
PAN_MIDLINE_STANDARD_SERIFED = 4
PAN_MIDLINE_HIGH_TRIMMED = 5
PAN_MIDLINE_HIGH_POINTED = 6
PAN_MIDLINE_HIGH_SERIFED = 7
PAN_MIDLINE_CONSTANT_TRIMMED = 8
PAN_MIDLINE_CONSTANT_POINTED = 9
PAN_MIDLINE_CONSTANT_SERIFED = 10
PAN_MIDLINE_LOW_TRIMMED = 11
PAN_MIDLINE_LOW_POINTED = 12
PAN_MIDLINE_LOW_SERIFED = 13
PAN_XHEIGHT_CONSTANT_SMALL = 2
PAN_XHEIGHT_CONSTANT_STD = 3
PAN_XHEIGHT_CONSTANT_LARGE = 4
PAN_XHEIGHT_DUCKING_SMALL = 5
PAN_XHEIGHT_DUCKING_STD = 6
PAN_XHEIGHT_DUCKING_LARGE = 7
ELF_VENDOR_SIZE = 4
ELF_VERSION = 0
ELF_CULTURE_LATIN = 0
RASTER_FONTTYPE = 1
DEVICE_FONTTYPE = 2
TRUETYPE_FONTTYPE = 4
def PALETTEINDEX(i): return ((16777216 | (i)))

PC_RESERVED = 1
PC_EXPLICIT = 2
PC_NOCOLLAPSE = 4
def GetRValue(rgb): return rgb & 0xff

def GetGValue(rgb): return (rgb >> 8) & 0xff

def GetBValue(rgb): return (rgb >> 16) & 0xff

TRANSPARENT = 1
OPAQUE = 2
BKMODE_LAST = 2
GM_COMPATIBLE = 1
GM_ADVANCED = 2
GM_LAST = 2
PT_CLOSEFIGURE = 1
PT_LINETO = 2
PT_BEZIERTO = 4
PT_MOVETO = 6
MM_TEXT = 1
MM_LOMETRIC = 2
MM_HIMETRIC = 3
MM_LOENGLISH = 4
MM_HIENGLISH = 5
MM_TWIPS = 6
MM_ISOTROPIC = 7
MM_ANISOTROPIC = 8
MM_MIN = MM_TEXT
MM_MAX = MM_ANISOTROPIC
MM_MAX_FIXEDSCALE = MM_TWIPS
ABSOLUTE = 1
RELATIVE = 2
WHITE_BRUSH = 0
LTGRAY_BRUSH = 1
GRAY_BRUSH = 2
DKGRAY_BRUSH = 3
BLACK_BRUSH = 4
NULL_BRUSH = 5
HOLLOW_BRUSH = NULL_BRUSH
WHITE_PEN = 6
BLACK_PEN = 7
NULL_PEN = 8
OEM_FIXED_FONT = 10
ANSI_FIXED_FONT = 11
ANSI_VAR_FONT = 12
SYSTEM_FONT = 13
DEVICE_DEFAULT_FONT = 14
DEFAULT_PALETTE = 15
SYSTEM_FIXED_FONT = 16
STOCK_LAST = 16
CLR_INVALID = -1

# Exception/Status codes from winuser.h and winnt.h
STATUS_WAIT_0                    = 0
STATUS_ABANDONED_WAIT_0          = 128
STATUS_USER_APC                  = 192
STATUS_TIMEOUT                   = 258
STATUS_PENDING                   = 259
STATUS_SEGMENT_NOTIFICATION      = 1073741829
STATUS_GUARD_PAGE_VIOLATION      = -2147483647
STATUS_DATATYPE_MISALIGNMENT     = -2147483646
STATUS_BREAKPOINT                = -2147483645
STATUS_SINGLE_STEP               = -2147483644
STATUS_ACCESS_VIOLATION          = -1073741819
STATUS_IN_PAGE_ERROR             = -1073741818
STATUS_INVALID_HANDLE            = -1073741816
STATUS_NO_MEMORY                 = -1073741801
STATUS_ILLEGAL_INSTRUCTION       = -1073741795
STATUS_NONCONTINUABLE_EXCEPTION  = -1073741787
STATUS_INVALID_DISPOSITION       = -1073741786
STATUS_ARRAY_BOUNDS_EXCEEDED     = -1073741684
STATUS_FLOAT_DENORMAL_OPERAND    = -1073741683
STATUS_FLOAT_DIVIDE_BY_ZERO      = -1073741682
STATUS_FLOAT_INEXACT_RESULT      = -1073741681
STATUS_FLOAT_INVALID_OPERATION   = -1073741680
STATUS_FLOAT_OVERFLOW            = -1073741679
STATUS_FLOAT_STACK_CHECK         = -1073741678
STATUS_FLOAT_UNDERFLOW           = -1073741677
STATUS_INTEGER_DIVIDE_BY_ZERO    = -1073741676
STATUS_INTEGER_OVERFLOW          = -1073741675
STATUS_PRIVILEGED_INSTRUCTION    = -1073741674
STATUS_STACK_OVERFLOW            = -1073741571
STATUS_CONTROL_C_EXIT            = -1073741510


WAIT_FAILED                      = -1
WAIT_OBJECT_0                    = STATUS_WAIT_0 + 0

WAIT_ABANDONED                      = STATUS_ABANDONED_WAIT_0 + 0
WAIT_ABANDONED_0                    = STATUS_ABANDONED_WAIT_0 + 0

WAIT_TIMEOUT                        = STATUS_TIMEOUT
WAIT_IO_COMPLETION                  = STATUS_USER_APC
STILL_ACTIVE                        = STATUS_PENDING
EXCEPTION_ACCESS_VIOLATION          = STATUS_ACCESS_VIOLATION
EXCEPTION_DATATYPE_MISALIGNMENT     = STATUS_DATATYPE_MISALIGNMENT
EXCEPTION_BREAKPOINT                = STATUS_BREAKPOINT
EXCEPTION_SINGLE_STEP               = STATUS_SINGLE_STEP
EXCEPTION_ARRAY_BOUNDS_EXCEEDED     = STATUS_ARRAY_BOUNDS_EXCEEDED
EXCEPTION_FLT_DENORMAL_OPERAND      = STATUS_FLOAT_DENORMAL_OPERAND
EXCEPTION_FLT_DIVIDE_BY_ZERO        = STATUS_FLOAT_DIVIDE_BY_ZERO
EXCEPTION_FLT_INEXACT_RESULT        = STATUS_FLOAT_INEXACT_RESULT
EXCEPTION_FLT_INVALID_OPERATION     = STATUS_FLOAT_INVALID_OPERATION
EXCEPTION_FLT_OVERFLOW              = STATUS_FLOAT_OVERFLOW
EXCEPTION_FLT_STACK_CHECK           = STATUS_FLOAT_STACK_CHECK
EXCEPTION_FLT_UNDERFLOW             = STATUS_FLOAT_UNDERFLOW
EXCEPTION_INT_DIVIDE_BY_ZERO        = STATUS_INTEGER_DIVIDE_BY_ZERO
EXCEPTION_INT_OVERFLOW              = STATUS_INTEGER_OVERFLOW
EXCEPTION_PRIV_INSTRUCTION          = STATUS_PRIVILEGED_INSTRUCTION
EXCEPTION_IN_PAGE_ERROR             = STATUS_IN_PAGE_ERROR
EXCEPTION_ILLEGAL_INSTRUCTION       = STATUS_ILLEGAL_INSTRUCTION
EXCEPTION_NONCONTINUABLE_EXCEPTION  = STATUS_NONCONTINUABLE_EXCEPTION
EXCEPTION_STACK_OVERFLOW            = STATUS_STACK_OVERFLOW
EXCEPTION_INVALID_DISPOSITION       = STATUS_INVALID_DISPOSITION
EXCEPTION_GUARD_PAGE                = STATUS_GUARD_PAGE_VIOLATION
EXCEPTION_INVALID_HANDLE            = STATUS_INVALID_HANDLE
CONTROL_C_EXIT                      = STATUS_CONTROL_C_EXIT

# winuser.h line 8594
# constants used with SystemParametersInfo
SPI_GETBEEP = 1
SPI_SETBEEP = 2
SPI_GETMOUSE = 3
SPI_SETMOUSE = 4
SPI_GETBORDER = 5
SPI_SETBORDER = 6
SPI_GETKEYBOARDSPEED = 10
SPI_SETKEYBOARDSPEED = 11
SPI_LANGDRIVER = 12
SPI_ICONHORIZONTALSPACING = 13
SPI_GETSCREENSAVETIMEOUT = 14
SPI_SETSCREENSAVETIMEOUT = 15
SPI_GETSCREENSAVEACTIVE = 16
SPI_SETSCREENSAVEACTIVE = 17
SPI_GETGRIDGRANULARITY = 18
SPI_SETGRIDGRANULARITY = 19
SPI_SETDESKWALLPAPER = 20
SPI_SETDESKPATTERN = 21
SPI_GETKEYBOARDDELAY = 22
SPI_SETKEYBOARDDELAY = 23
SPI_ICONVERTICALSPACING = 24
SPI_GETICONTITLEWRAP = 25
SPI_SETICONTITLEWRAP = 26
SPI_GETMENUDROPALIGNMENT = 27
SPI_SETMENUDROPALIGNMENT = 28
SPI_SETDOUBLECLKWIDTH = 29
SPI_SETDOUBLECLKHEIGHT = 30
SPI_GETICONTITLELOGFONT = 31
SPI_SETDOUBLECLICKTIME = 32
SPI_SETMOUSEBUTTONSWAP = 33
SPI_SETICONTITLELOGFONT = 34
SPI_GETFASTTASKSWITCH = 35
SPI_SETFASTTASKSWITCH = 36
SPI_SETDRAGFULLWINDOWS = 37
SPI_GETDRAGFULLWINDOWS = 38
SPI_GETNONCLIENTMETRICS = 41
SPI_SETNONCLIENTMETRICS = 42
SPI_GETMINIMIZEDMETRICS = 43
SPI_SETMINIMIZEDMETRICS = 44
SPI_GETICONMETRICS = 45
SPI_SETICONMETRICS = 46
SPI_SETWORKAREA = 47
SPI_GETWORKAREA = 48
SPI_SETPENWINDOWS = 49
SPI_GETFILTERKEYS = 50
SPI_SETFILTERKEYS = 51
SPI_GETTOGGLEKEYS = 52
SPI_SETTOGGLEKEYS = 53
SPI_GETMOUSEKEYS = 54
SPI_SETMOUSEKEYS = 55
SPI_GETSHOWSOUNDS = 56
SPI_SETSHOWSOUNDS = 57
SPI_GETSTICKYKEYS = 58
SPI_SETSTICKYKEYS = 59
SPI_GETACCESSTIMEOUT = 60
SPI_SETACCESSTIMEOUT = 61
SPI_GETSERIALKEYS = 62
SPI_SETSERIALKEYS = 63
SPI_GETSOUNDSENTRY = 64
SPI_SETSOUNDSENTRY = 65
SPI_GETHIGHCONTRAST = 66
SPI_SETHIGHCONTRAST = 67
SPI_GETKEYBOARDPREF = 68
SPI_SETKEYBOARDPREF = 69
SPI_GETSCREENREADER = 70
SPI_SETSCREENREADER = 71
SPI_GETANIMATION = 72
SPI_SETANIMATION = 73
SPI_GETFONTSMOOTHING = 74
SPI_SETFONTSMOOTHING = 75
SPI_SETDRAGWIDTH = 76
SPI_SETDRAGHEIGHT = 77
SPI_SETHANDHELD = 78
SPI_GETLOWPOWERTIMEOUT = 79
SPI_GETPOWEROFFTIMEOUT = 80
SPI_SETLOWPOWERTIMEOUT = 81
SPI_SETPOWEROFFTIMEOUT = 82
SPI_GETLOWPOWERACTIVE = 83
SPI_GETPOWEROFFACTIVE = 84
SPI_SETLOWPOWERACTIVE = 85
SPI_SETPOWEROFFACTIVE = 86
SPI_SETCURSORS = 87
SPI_SETICONS = 88
SPI_GETDEFAULTINPUTLANG = 89
SPI_SETDEFAULTINPUTLANG = 90
SPI_SETLANGTOGGLE = 91
SPI_GETWINDOWSEXTENSION = 92
SPI_SETMOUSETRAILS = 93
SPI_GETMOUSETRAILS = 94
SPI_GETSNAPTODEFBUTTON = 95
SPI_SETSNAPTODEFBUTTON = 96
SPI_SETSCREENSAVERRUNNING = 97
SPI_SCREENSAVERRUNNING = SPI_SETSCREENSAVERRUNNING
SPI_GETMOUSEHOVERWIDTH = 98
SPI_SETMOUSEHOVERWIDTH = 99
SPI_GETMOUSEHOVERHEIGHT = 100
SPI_SETMOUSEHOVERHEIGHT = 101
SPI_GETMOUSEHOVERTIME = 102
SPI_SETMOUSEHOVERTIME = 103
SPI_GETWHEELSCROLLLINES = 104
SPI_SETWHEELSCROLLLINES = 105
SPI_GETMENUSHOWDELAY = 106
SPI_SETMENUSHOWDELAY = 107

SPI_GETSHOWIMEUI = 110
SPI_SETSHOWIMEUI = 111
SPI_GETMOUSESPEED = 112
SPI_SETMOUSESPEED = 113
SPI_GETSCREENSAVERRUNNING = 114
SPI_GETDESKWALLPAPER = 115

SPI_GETACTIVEWINDOWTRACKING = 4096
SPI_SETACTIVEWINDOWTRACKING = 4097
SPI_GETMENUANIMATION = 4098
SPI_SETMENUANIMATION = 4099
SPI_GETCOMBOBOXANIMATION = 4100
SPI_SETCOMBOBOXANIMATION = 4101
SPI_GETLISTBOXSMOOTHSCROLLING = 4102
SPI_SETLISTBOXSMOOTHSCROLLING = 4103
SPI_GETGRADIENTCAPTIONS = 4104
SPI_SETGRADIENTCAPTIONS = 4105
SPI_GETKEYBOARDCUES = 4106
SPI_SETKEYBOARDCUES = 4107
SPI_GETMENUUNDERLINES = 4106
SPI_SETMENUUNDERLINES = 4107
SPI_GETACTIVEWNDTRKZORDER = 4108
SPI_SETACTIVEWNDTRKZORDER = 4109
SPI_GETHOTTRACKING = 4110
SPI_SETHOTTRACKING = 4111

SPI_GETMENUFADE = 4114
SPI_SETMENUFADE = 4115
SPI_GETSELECTIONFADE = 4116
SPI_SETSELECTIONFADE = 4117
SPI_GETTOOLTIPANIMATION = 4118
SPI_SETTOOLTIPANIMATION = 4119
SPI_GETTOOLTIPFADE = 4120
SPI_SETTOOLTIPFADE = 4121
SPI_GETCURSORSHADOW = 4122
SPI_SETCURSORSHADOW = 4123
SPI_GETMOUSESONAR = 4124
SPI_SETMOUSESONAR = 4125
SPI_GETMOUSECLICKLOCK = 4126
SPI_SETMOUSECLICKLOCK = 4127
SPI_GETMOUSEVANISH = 4128
SPI_SETMOUSEVANISH = 4129
SPI_GETFLATMENU = 4130
SPI_SETFLATMENU = 4131
SPI_GETDROPSHADOW = 4132
SPI_SETDROPSHADOW = 4133
SPI_GETBLOCKSENDINPUTRESETS = 4134
SPI_SETBLOCKSENDINPUTRESETS = 4135
SPI_GETUIEFFECTS = 4158
SPI_SETUIEFFECTS = 4159

SPI_GETFOREGROUNDLOCKTIMEOUT = 8192
SPI_SETFOREGROUNDLOCKTIMEOUT = 8193
SPI_GETACTIVEWNDTRKTIMEOUT = 8194
SPI_SETACTIVEWNDTRKTIMEOUT = 8195
SPI_GETFOREGROUNDFLASHCOUNT = 8196
SPI_SETFOREGROUNDFLASHCOUNT = 8197
SPI_GETCARETWIDTH = 8198
SPI_SETCARETWIDTH = 8199
SPI_GETMOUSECLICKLOCKTIME = 8200
SPI_SETMOUSECLICKLOCKTIME = 8201
SPI_GETFONTSMOOTHINGTYPE = 8202
SPI_SETFONTSMOOTHINGTYPE = 8203
SPI_GETFONTSMOOTHINGCONTRAST = 8204
SPI_SETFONTSMOOTHINGCONTRAST = 8205
SPI_GETFOCUSBORDERWIDTH = 8206
SPI_SETFOCUSBORDERWIDTH = 8207
SPI_GETFOCUSBORDERHEIGHT = 8208
SPI_SETFOCUSBORDERHEIGHT = 8209
SPI_GETFONTSMOOTHINGORIENTATION = 8210
SPI_SETFONTSMOOTHINGORIENTATION = 8211

# fWinIni flags for SystemParametersInfo
SPIF_UPDATEINIFILE = 1
SPIF_SENDWININICHANGE = 2
SPIF_SENDCHANGE = SPIF_SENDWININICHANGE

# used with SystemParametersInfo and SPI_GETFONTSMOOTHINGTYPE/SPI_SETFONTSMOOTHINGTYPE
FE_FONTSMOOTHINGSTANDARD = 1
FE_FONTSMOOTHINGCLEARTYPE = 2
FE_FONTSMOOTHINGDOCKING = 32768

METRICS_USEDEFAULT = -1
ARW_BOTTOMLEFT = 0
ARW_BOTTOMRIGHT = 1
ARW_TOPLEFT = 2
ARW_TOPRIGHT = 3
ARW_STARTMASK = 3
ARW_STARTRIGHT = 1
ARW_STARTTOP = 2
ARW_LEFT = 0
ARW_RIGHT = 0
ARW_UP = 4
ARW_DOWN = 4
ARW_HIDE = 8
#ARW_VALID = 0x000F
SERKF_SERIALKEYSON = 1
SERKF_AVAILABLE = 2
SERKF_INDICATOR = 4
HCF_HIGHCONTRASTON = 1
HCF_AVAILABLE = 2
HCF_HOTKEYACTIVE = 4
HCF_CONFIRMHOTKEY = 8
HCF_HOTKEYSOUND = 16
HCF_INDICATOR = 32
HCF_HOTKEYAVAILABLE = 64
CDS_UPDATEREGISTRY = 1
CDS_TEST = 2
CDS_FULLSCREEN = 4
CDS_GLOBAL = 8
CDS_SET_PRIMARY = 16
CDS_RESET = 1073741824
CDS_SETRECT = 536870912
CDS_NORESET = 268435456

# return values from ChangeDisplaySettings and ChangeDisplaySettingsEx
DISP_CHANGE_SUCCESSFUL = 0
DISP_CHANGE_RESTART = 1
DISP_CHANGE_FAILED = -1
DISP_CHANGE_BADMODE = -2
DISP_CHANGE_NOTUPDATED = -3
DISP_CHANGE_BADFLAGS = -4
DISP_CHANGE_BADPARAM = -5
DISP_CHANGE_BADDUALVIEW = -6

ENUM_CURRENT_SETTINGS = -1
ENUM_REGISTRY_SETTINGS = -2
FKF_FILTERKEYSON = 1
FKF_AVAILABLE = 2
FKF_HOTKEYACTIVE = 4
FKF_CONFIRMHOTKEY = 8
FKF_HOTKEYSOUND = 16
FKF_INDICATOR = 32
FKF_CLICKON = 64
SKF_STICKYKEYSON = 1
SKF_AVAILABLE = 2
SKF_HOTKEYACTIVE = 4
SKF_CONFIRMHOTKEY = 8
SKF_HOTKEYSOUND = 16
SKF_INDICATOR = 32
SKF_AUDIBLEFEEDBACK = 64
SKF_TRISTATE = 128
SKF_TWOKEYSOFF = 256
SKF_LALTLATCHED = 268435456
SKF_LCTLLATCHED = 67108864
SKF_LSHIFTLATCHED = 16777216
SKF_RALTLATCHED = 536870912
SKF_RCTLLATCHED = 134217728
SKF_RSHIFTLATCHED = 33554432
SKF_LWINLATCHED = 1073741824
SKF_RWINLATCHED = -2147483648
SKF_LALTLOCKED = 1048576
SKF_LCTLLOCKED = 262144
SKF_LSHIFTLOCKED = 65536
SKF_RALTLOCKED = 2097152
SKF_RCTLLOCKED = 524288
SKF_RSHIFTLOCKED = 131072
SKF_LWINLOCKED = 4194304
SKF_RWINLOCKED = 8388608
MKF_MOUSEKEYSON = 1
MKF_AVAILABLE = 2
MKF_HOTKEYACTIVE = 4
MKF_CONFIRMHOTKEY = 8
MKF_HOTKEYSOUND = 16
MKF_INDICATOR = 32
MKF_MODIFIERS = 64
MKF_REPLACENUMBERS = 128
MKF_LEFTBUTTONSEL = 268435456
MKF_RIGHTBUTTONSEL = 536870912
MKF_LEFTBUTTONDOWN = 16777216
MKF_RIGHTBUTTONDOWN = 33554432
MKF_MOUSEMODE = -2147483648
ATF_TIMEOUTON = 1
ATF_ONOFFFEEDBACK = 2
SSGF_NONE = 0
SSGF_DISPLAY = 3
SSTF_NONE = 0
SSTF_CHARS = 1
SSTF_BORDER = 2
SSTF_DISPLAY = 3
SSWF_NONE = 0
SSWF_TITLE = 1
SSWF_WINDOW = 2
SSWF_DISPLAY = 3
SSWF_CUSTOM = 4
SSF_SOUNDSENTRYON = 1
SSF_AVAILABLE = 2
SSF_INDICATOR = 4
TKF_TOGGLEKEYSON = 1
TKF_AVAILABLE = 2
TKF_HOTKEYACTIVE = 4
TKF_CONFIRMHOTKEY = 8
TKF_HOTKEYSOUND = 16
TKF_INDICATOR = 32
SLE_ERROR = 1
SLE_MINORERROR = 2
SLE_WARNING = 3
MONITOR_DEFAULTTONULL = 0
MONITOR_DEFAULTTOPRIMARY = 1
MONITOR_DEFAULTTONEAREST = 2
MONITORINFOF_PRIMARY = 1
CCHDEVICENAME = 32
CHILDID_SELF = 0
INDEXID_OBJECT = 0
INDEXID_CONTAINER = 0
OBJID_WINDOW = 0
OBJID_SYSMENU = -1
OBJID_TITLEBAR = -2
OBJID_MENU = -3
OBJID_CLIENT = -4
OBJID_VSCROLL = -5
OBJID_HSCROLL = -6
OBJID_SIZEGRIP = -7
OBJID_CARET = -8
OBJID_CURSOR = -9
OBJID_ALERT = -10
OBJID_SOUND = -11
EVENT_MIN = 1
EVENT_MAX = 2147483647
EVENT_SYSTEM_SOUND = 1
EVENT_SYSTEM_ALERT = 2
EVENT_SYSTEM_FOREGROUND = 3
EVENT_SYSTEM_MENUSTART = 4
EVENT_SYSTEM_MENUEND = 5
EVENT_SYSTEM_MENUPOPUPSTART = 6
EVENT_SYSTEM_MENUPOPUPEND = 7
EVENT_SYSTEM_CAPTURESTART = 8
EVENT_SYSTEM_CAPTUREEND = 9
EVENT_SYSTEM_MOVESIZESTART = 10
EVENT_SYSTEM_MOVESIZEEND = 11
EVENT_SYSTEM_CONTEXTHELPSTART = 12
EVENT_SYSTEM_CONTEXTHELPEND = 13
EVENT_SYSTEM_DRAGDROPSTART = 14
EVENT_SYSTEM_DRAGDROPEND = 15
EVENT_SYSTEM_DIALOGSTART = 16
EVENT_SYSTEM_DIALOGEND = 17
EVENT_SYSTEM_SCROLLINGSTART = 18
EVENT_SYSTEM_SCROLLINGEND = 19
EVENT_SYSTEM_SWITCHSTART = 20
EVENT_SYSTEM_SWITCHEND = 21
EVENT_SYSTEM_MINIMIZESTART = 22
EVENT_SYSTEM_MINIMIZEEND = 23
EVENT_OBJECT_CREATE = 32768
EVENT_OBJECT_DESTROY = 32769
EVENT_OBJECT_SHOW = 32770
EVENT_OBJECT_HIDE = 32771
EVENT_OBJECT_REORDER = 32772
EVENT_OBJECT_FOCUS = 32773
EVENT_OBJECT_SELECTION = 32774
EVENT_OBJECT_SELECTIONADD = 32775
EVENT_OBJECT_SELECTIONREMOVE = 32776
EVENT_OBJECT_SELECTIONWITHIN = 32777
EVENT_OBJECT_STATECHANGE = 32778
EVENT_OBJECT_LOCATIONCHANGE = 32779
EVENT_OBJECT_NAMECHANGE = 32780
EVENT_OBJECT_DESCRIPTIONCHANGE = 32781
EVENT_OBJECT_VALUECHANGE = 32782
EVENT_OBJECT_PARENTCHANGE = 32783
EVENT_OBJECT_HELPCHANGE = 32784
EVENT_OBJECT_DEFACTIONCHANGE = 32785
EVENT_OBJECT_ACCELERATORCHANGE = 32786
SOUND_SYSTEM_STARTUP = 1
SOUND_SYSTEM_SHUTDOWN = 2
SOUND_SYSTEM_BEEP = 3
SOUND_SYSTEM_ERROR = 4
SOUND_SYSTEM_QUESTION = 5
SOUND_SYSTEM_WARNING = 6
SOUND_SYSTEM_INFORMATION = 7
SOUND_SYSTEM_MAXIMIZE = 8
SOUND_SYSTEM_MINIMIZE = 9
SOUND_SYSTEM_RESTOREUP = 10
SOUND_SYSTEM_RESTOREDOWN = 11
SOUND_SYSTEM_APPSTART = 12
SOUND_SYSTEM_FAULT = 13
SOUND_SYSTEM_APPEND = 14
SOUND_SYSTEM_MENUCOMMAND = 15
SOUND_SYSTEM_MENUPOPUP = 16
CSOUND_SYSTEM = 16
ALERT_SYSTEM_INFORMATIONAL = 1
ALERT_SYSTEM_WARNING = 2
ALERT_SYSTEM_ERROR = 3
ALERT_SYSTEM_QUERY = 4
ALERT_SYSTEM_CRITICAL = 5
CALERT_SYSTEM = 6
WINEVENT_OUTOFCONTEXT = 0
WINEVENT_SKIPOWNTHREAD = 1
WINEVENT_SKIPOWNPROCESS = 2
WINEVENT_INCONTEXT = 4
GUI_CARETBLINKING = 1
GUI_INMOVESIZE = 2
GUI_INMENUMODE = 4
GUI_SYSTEMMENUMODE = 8
GUI_POPUPMENUMODE = 16
STATE_SYSTEM_UNAVAILABLE = 1
STATE_SYSTEM_SELECTED = 2
STATE_SYSTEM_FOCUSED = 4
STATE_SYSTEM_PRESSED = 8
STATE_SYSTEM_CHECKED = 16
STATE_SYSTEM_MIXED = 32
STATE_SYSTEM_READONLY = 64
STATE_SYSTEM_HOTTRACKED = 128
STATE_SYSTEM_DEFAULT = 256
STATE_SYSTEM_EXPANDED = 512
STATE_SYSTEM_COLLAPSED = 1024
STATE_SYSTEM_BUSY = 2048
STATE_SYSTEM_FLOATING = 4096
STATE_SYSTEM_MARQUEED = 8192
STATE_SYSTEM_ANIMATED = 16384
STATE_SYSTEM_INVISIBLE = 32768
STATE_SYSTEM_OFFSCREEN = 65536
STATE_SYSTEM_SIZEABLE = 131072
STATE_SYSTEM_MOVEABLE = 262144
STATE_SYSTEM_SELFVOICING = 524288
STATE_SYSTEM_FOCUSABLE = 1048576
STATE_SYSTEM_SELECTABLE = 2097152
STATE_SYSTEM_LINKED = 4194304
STATE_SYSTEM_TRAVERSED = 8388608
STATE_SYSTEM_MULTISELECTABLE = 16777216
STATE_SYSTEM_EXTSELECTABLE = 33554432
STATE_SYSTEM_ALERT_LOW = 67108864
STATE_SYSTEM_ALERT_MEDIUM = 134217728
STATE_SYSTEM_ALERT_HIGH = 268435456
STATE_SYSTEM_VALID = 536870911
CCHILDREN_TITLEBAR = 5
CCHILDREN_SCROLLBAR = 5
CURSOR_SHOWING = 1
WS_ACTIVECAPTION = 1
GA_MIC = 1
GA_PARENT = 1
GA_ROOT = 2
GA_ROOTOWNER = 3
GA_MAC = 4

# winuser.h line 1979
BF_LEFT = 1
BF_TOP = 2
BF_RIGHT = 4
BF_BOTTOM = 8
BF_TOPLEFT = (BF_TOP | BF_LEFT)
BF_TOPRIGHT = (BF_TOP | BF_RIGHT)
BF_BOTTOMLEFT = (BF_BOTTOM | BF_LEFT)
BF_BOTTOMRIGHT = (BF_BOTTOM | BF_RIGHT)
BF_RECT = (BF_LEFT | BF_TOP | BF_RIGHT | BF_BOTTOM)
BF_DIAGONAL = 16
BF_DIAGONAL_ENDTOPRIGHT = (BF_DIAGONAL | BF_TOP | BF_RIGHT)
BF_DIAGONAL_ENDTOPLEFT = (BF_DIAGONAL | BF_TOP | BF_LEFT)
BF_DIAGONAL_ENDBOTTOMLEFT = (BF_DIAGONAL | BF_BOTTOM | BF_LEFT)
BF_DIAGONAL_ENDBOTTOMRIGHT = (BF_DIAGONAL | BF_BOTTOM | BF_RIGHT)
BF_MIDDLE = 2048
BF_SOFT = 4096
BF_ADJUST = 8192
BF_FLAT = 16384
BF_MONO = 32768
DFC_CAPTION = 1
DFC_MENU = 2
DFC_SCROLL = 3
DFC_BUTTON = 4
DFC_POPUPMENU = 5
DFCS_CAPTIONCLOSE = 0
DFCS_CAPTIONMIN = 1
DFCS_CAPTIONMAX = 2
DFCS_CAPTIONRESTORE = 3
DFCS_CAPTIONHELP = 4
DFCS_MENUARROW = 0
DFCS_MENUCHECK = 1
DFCS_MENUBULLET = 2
DFCS_MENUARROWRIGHT = 4
DFCS_SCROLLUP = 0
DFCS_SCROLLDOWN = 1
DFCS_SCROLLLEFT = 2
DFCS_SCROLLRIGHT = 3
DFCS_SCROLLCOMBOBOX = 5
DFCS_SCROLLSIZEGRIP = 8
DFCS_SCROLLSIZEGRIPRIGHT = 16
DFCS_BUTTONCHECK = 0
DFCS_BUTTONRADIOIMAGE = 1
DFCS_BUTTONRADIOMASK = 2
DFCS_BUTTONRADIO = 4
DFCS_BUTTON3STATE = 8
DFCS_BUTTONPUSH = 16
DFCS_INACTIVE = 256
DFCS_PUSHED = 512
DFCS_CHECKED = 1024
DFCS_TRANSPARENT = 2048
DFCS_HOT = 4096
DFCS_ADJUSTRECT = 8192
DFCS_FLAT = 16384
DFCS_MONO = 32768
DC_ACTIVE = 1
DC_SMALLCAP = 2
DC_ICON = 4
DC_TEXT = 8
DC_INBUTTON = 16
DC_GRADIENT = 32
IDANI_OPEN = 1
IDANI_CLOSE = 2
IDANI_CAPTION = 3
CF_TEXT = 1
CF_BITMAP = 2
CF_METAFILEPICT = 3
CF_SYLK = 4
CF_DIF = 5
CF_TIFF = 6
CF_OEMTEXT = 7
CF_DIB = 8
CF_PALETTE = 9
CF_PENDATA = 10
CF_RIFF = 11
CF_WAVE = 12
CF_UNICODETEXT = 13
CF_ENHMETAFILE = 14
CF_HDROP = 15
CF_LOCALE = 16
CF_MAX = 17
CF_OWNERDISPLAY = 128
CF_DSPTEXT = 129
CF_DSPBITMAP = 130
CF_DSPMETAFILEPICT = 131
CF_DSPENHMETAFILE = 142
CF_PRIVATEFIRST = 512
CF_PRIVATELAST = 767
CF_GDIOBJFIRST = 768
CF_GDIOBJLAST = 1023
FVIRTKEY =1
FNOINVERT = 2
FSHIFT = 4
FCONTROL = 8
FALT = 16
WPF_SETMINPOSITION = 1
WPF_RESTORETOMAXIMIZED = 2
ODT_MENU = 1
ODT_LISTBOX = 2
ODT_COMBOBOX = 3
ODT_BUTTON = 4
ODT_STATIC = 5
ODA_DRAWENTIRE = 1
ODA_SELECT = 2
ODA_FOCUS = 4
ODS_SELECTED = 1
ODS_GRAYED = 2
ODS_DISABLED = 4
ODS_CHECKED = 8
ODS_FOCUS = 16
ODS_DEFAULT = 32
ODS_COMBOBOXEDIT = 4096
ODS_HOTLIGHT = 64
ODS_INACTIVE = 128
PM_NOREMOVE = 0
PM_REMOVE = 1
PM_NOYIELD = 2
# Name clashes with key.MOD_ALT, key.MOD_CONTROL and key.MOD_SHIFT
WIN32_MOD_ALT = 1
WIN32_MOD_CONTROL = 2
WIN32_MOD_SHIFT = 4
WIN32_MOD_WIN = 8
IDHOT_SNAPWINDOW = (-1)
IDHOT_SNAPDESKTOP = (-2)
#EW_RESTARTWINDOWS = 0x0042
#EW_REBOOTSYSTEM = 0x0043
#EW_EXITANDEXECAPP = 0x0044
ENDSESSION_LOGOFF = -2147483648
EWX_LOGOFF = 0
EWX_SHUTDOWN = 1
EWX_REBOOT = 2
EWX_FORCE = 4
EWX_POWEROFF = 8
EWX_FORCEIFHUNG = 16
BSM_ALLCOMPONENTS = 0
BSM_VXDS = 1
BSM_NETDRIVER = 2
BSM_INSTALLABLEDRIVERS = 4
BSM_APPLICATIONS = 8
BSM_ALLDESKTOPS = 16
BSF_QUERY = 1
BSF_IGNORECURRENTTASK = 2
BSF_FLUSHDISK = 4
BSF_NOHANG = 8
BSF_POSTMESSAGE = 16
BSF_FORCEIFHUNG = 32
BSF_NOTIMEOUTIFNOTHUNG = 64
BROADCAST_QUERY_DENY = 1112363332  # Return this value to deny a query.

DBWF_LPARAMPOINTER = 32768

# winuser.h line 3232
SWP_NOSIZE = 1
SWP_NOMOVE = 2
SWP_NOZORDER = 4
SWP_NOREDRAW = 8
SWP_NOACTIVATE = 16
SWP_FRAMECHANGED = 32
SWP_SHOWWINDOW = 64
SWP_HIDEWINDOW = 128
SWP_NOCOPYBITS = 256
SWP_NOOWNERZORDER = 512
SWP_NOSENDCHANGING = 1024
SWP_DRAWFRAME = SWP_FRAMECHANGED
SWP_NOREPOSITION = SWP_NOOWNERZORDER
SWP_DEFERERASE = 8192
SWP_ASYNCWINDOWPOS = 16384

DLGWINDOWEXTRA = 30
# winuser.h line 4249
KEYEVENTF_EXTENDEDKEY = 1
KEYEVENTF_KEYUP = 2
MOUSEEVENTF_MOVE = 1
MOUSEEVENTF_LEFTDOWN = 2
MOUSEEVENTF_LEFTUP = 4
MOUSEEVENTF_RIGHTDOWN = 8
MOUSEEVENTF_RIGHTUP = 16
MOUSEEVENTF_MIDDLEDOWN = 32
MOUSEEVENTF_MIDDLEUP = 64
MOUSEEVENTF_ABSOLUTE = 32768
INPUT_MOUSE = 0
INPUT_KEYBOARD = 1
INPUT_HARDWARE = 2
MWMO_WAITALL = 1
MWMO_ALERTABLE = 2
MWMO_INPUTAVAILABLE = 4
QS_KEY = 1
QS_MOUSEMOVE = 2
QS_MOUSEBUTTON = 4
QS_POSTMESSAGE = 8
QS_TIMER = 16
QS_PAINT = 32
QS_SENDMESSAGE = 64
QS_HOTKEY = 128
QS_MOUSE = (QS_MOUSEMOVE     | \
                            QS_MOUSEBUTTON)
QS_INPUT = (QS_MOUSE         | \
                            QS_KEY)
QS_ALLEVENTS = (QS_INPUT         | \
                            QS_POSTMESSAGE   | \
                            QS_TIMER         | \
                            QS_PAINT         | \
                            QS_HOTKEY)
QS_ALLINPUT = (QS_INPUT         | \
                            QS_POSTMESSAGE   | \
                            QS_TIMER         | \
                            QS_PAINT         | \
                            QS_HOTKEY        | \
                            QS_SENDMESSAGE)


IMN_CLOSESTATUSWINDOW = 1
IMN_OPENSTATUSWINDOW = 2
IMN_CHANGECANDIDATE = 3
IMN_CLOSECANDIDATE = 4
IMN_OPENCANDIDATE = 5
IMN_SETCONVERSIONMODE = 6
IMN_SETSENTENCEMODE = 7
IMN_SETOPENSTATUS = 8
IMN_SETCANDIDATEPOS = 9
IMN_SETCOMPOSITIONFONT = 10
IMN_SETCOMPOSITIONWINDOW = 11
IMN_SETSTATUSWINDOWPOS = 12
IMN_GUIDELINE = 13
IMN_PRIVATE = 14

# winuser.h line 8518
HELP_CONTEXT = 1
HELP_QUIT = 2
HELP_INDEX = 3
HELP_CONTENTS = 3
HELP_HELPONHELP = 4
HELP_SETINDEX = 5
HELP_SETCONTENTS = 5
HELP_CONTEXTPOPUP = 8
HELP_FORCEFILE = 9
HELP_KEY = 257
HELP_COMMAND = 258
HELP_PARTIALKEY = 261
HELP_MULTIKEY = 513
HELP_SETWINPOS = 515
HELP_CONTEXTMENU = 10
HELP_FINDER = 11
HELP_WM_HELP = 12
HELP_SETPOPUP_POS = 13
HELP_TCARD = 32768
HELP_TCARD_DATA = 16
HELP_TCARD_OTHER_CALLER = 17
IDH_NO_HELP = 28440
IDH_MISSING_CONTEXT = 28441 # Control doesn't have matching help context
IDH_GENERIC_HELP_BUTTON = 28442 # Property sheet help button
IDH_OK = 28443
IDH_CANCEL = 28444
IDH_HELP = 28445
GR_GDIOBJECTS = 0      # Count of GDI objects
GR_USEROBJECTS = 1     # Count of USER objects
# Generated by h2py from \msvcnt\include\wingdi.h
# manually added (missed by generation some how!
SRCCOPY		= 13369376	# dest = source
SRCPAINT	= 15597702	# dest = source OR dest
SRCAND		= 8913094	# dest = source AND dest
SRCINVERT	= 6684742	# dest = source XOR dest
SRCERASE	= 4457256	# dest = source AND (NOT dest )
NOTSRCCOPY	= 3342344	# dest = (NOT source)
NOTSRCERASE	= 1114278	# dest = (NOT src) AND (NOT dest)
MERGECOPY	= 12583114	# dest = (source AND pattern)
MERGEPAINT	= 12255782	# dest = (NOT source) OR dest
PATCOPY		= 15728673	# dest = pattern
PATPAINT	= 16452105	# dest = DPSnoo
PATINVERT	= 5898313	# dest = pattern XOR dest
DSTINVERT	= 5570569	# dest = (NOT dest)
BLACKNESS	= 66	# dest = BLACK
WHITENESS	= 16711778	# dest = WHITE

# hacked and split manually by mhammond.
R2_BLACK = 1
R2_NOTMERGEPEN = 2
R2_MASKNOTPEN = 3
R2_NOTCOPYPEN = 4
R2_MASKPENNOT = 5
R2_NOT = 6
R2_XORPEN = 7
R2_NOTMASKPEN = 8
R2_MASKPEN = 9
R2_NOTXORPEN = 10
R2_NOP = 11
R2_MERGENOTPEN = 12
R2_COPYPEN = 13
R2_MERGEPENNOT = 14
R2_MERGEPEN = 15
R2_WHITE = 16
R2_LAST = 16
GDI_ERROR = (-1)
ERROR = 0
NULLREGION = 1
SIMPLEREGION = 2
COMPLEXREGION = 3
RGN_ERROR = ERROR
RGN_AND = 1
RGN_OR = 2
RGN_XOR = 3
RGN_DIFF = 4
RGN_COPY = 5
RGN_MIN = RGN_AND
RGN_MAX = RGN_COPY
BLACKONWHITE = 1
WHITEONBLACK = 2
COLORONCOLOR = 3
HALFTONE = 4
MAXSTRETCHBLTMODE = 4
ALTERNATE = 1
WINDING = 2
POLYFILL_LAST = 2
TA_NOUPDATECP = 0
TA_UPDATECP = 1
TA_LEFT = 0
TA_RIGHT = 2
TA_CENTER = 6
TA_TOP = 0
TA_BOTTOM = 8
TA_BASELINE = 24
TA_MASK = (TA_BASELINE+TA_CENTER+TA_UPDATECP)
VTA_BASELINE = TA_BASELINE
VTA_LEFT = TA_BOTTOM
VTA_RIGHT = TA_TOP
VTA_CENTER = TA_CENTER
VTA_BOTTOM = TA_RIGHT
VTA_TOP = TA_LEFT
ETO_GRAYED = 1
ETO_OPAQUE = 2
ETO_CLIPPED = 4
ASPECT_FILTERING = 1
DCB_RESET = 1
DCB_ACCUMULATE = 2
DCB_DIRTY = DCB_ACCUMULATE
DCB_SET = (DCB_RESET | DCB_ACCUMULATE)
DCB_ENABLE = 4
DCB_DISABLE = 8
META_SETBKCOLOR = 513
META_SETBKMODE = 258
META_SETMAPMODE = 259
META_SETROP2 = 260
META_SETRELABS = 261
META_SETPOLYFILLMODE = 262
META_SETSTRETCHBLTMODE = 263
META_SETTEXTCHAREXTRA = 264
META_SETTEXTCOLOR = 521
META_SETTEXTJUSTIFICATION = 522
META_SETWINDOWORG = 523
META_SETWINDOWEXT = 524
META_SETVIEWPORTORG = 525
META_SETVIEWPORTEXT = 526
META_OFFSETWINDOWORG = 527
META_SCALEWINDOWEXT = 1040
META_OFFSETVIEWPORTORG = 529
META_SCALEVIEWPORTEXT = 1042
META_LINETO = 531
META_MOVETO = 532
META_EXCLUDECLIPRECT = 1045
META_INTERSECTCLIPRECT = 1046
META_ARC = 2071
META_ELLIPSE = 1048
META_FLOODFILL = 1049
META_PIE = 2074
META_RECTANGLE = 1051
META_ROUNDRECT = 1564
META_PATBLT = 1565
META_SAVEDC = 30
META_SETPIXEL = 1055
META_OFFSETCLIPRGN = 544
META_TEXTOUT = 1313
META_BITBLT = 2338
META_STRETCHBLT = 2851
META_POLYGON = 804
META_POLYLINE = 805
META_ESCAPE = 1574
META_RESTOREDC = 295
META_FILLREGION = 552
META_FRAMEREGION = 1065
META_INVERTREGION = 298
META_PAINTREGION = 299
META_SELECTCLIPREGION = 300
META_SELECTOBJECT = 301
META_SETTEXTALIGN = 302
META_CHORD = 2096
META_SETMAPPERFLAGS = 561
META_EXTTEXTOUT = 2610
META_SETDIBTODEV = 3379
META_SELECTPALETTE = 564
META_REALIZEPALETTE = 53
META_ANIMATEPALETTE = 1078
META_SETPALENTRIES = 55
META_POLYPOLYGON = 1336
META_RESIZEPALETTE = 313
META_DIBBITBLT = 2368
META_DIBSTRETCHBLT = 2881
META_DIBCREATEPATTERNBRUSH = 322
META_STRETCHDIB = 3907
META_EXTFLOODFILL = 1352
META_DELETEOBJECT = 496
META_CREATEPALETTE = 247
META_CREATEPATTERNBRUSH = 505
META_CREATEPENINDIRECT = 762
META_CREATEFONTINDIRECT = 763
META_CREATEBRUSHINDIRECT = 764
META_CREATEREGION = 1791
FILE_BEGIN = 0
FILE_CURRENT = 1
FILE_END = 2
FILE_FLAG_WRITE_THROUGH = -2147483648
FILE_FLAG_OVERLAPPED = 1073741824
FILE_FLAG_NO_BUFFERING = 536870912
FILE_FLAG_RANDOM_ACCESS = 268435456
FILE_FLAG_SEQUENTIAL_SCAN = 134217728
FILE_FLAG_DELETE_ON_CLOSE = 67108864
FILE_FLAG_BACKUP_SEMANTICS = 33554432
FILE_FLAG_POSIX_SEMANTICS = 16777216
CREATE_NEW = 1
CREATE_ALWAYS = 2
OPEN_EXISTING = 3
OPEN_ALWAYS = 4
TRUNCATE_EXISTING = 5
PIPE_ACCESS_INBOUND = 1
PIPE_ACCESS_OUTBOUND = 2
PIPE_ACCESS_DUPLEX = 3
PIPE_CLIENT_END = 0
PIPE_SERVER_END = 1
PIPE_WAIT = 0
PIPE_NOWAIT = 1
PIPE_READMODE_BYTE = 0
PIPE_READMODE_MESSAGE = 2
PIPE_TYPE_BYTE = 0
PIPE_TYPE_MESSAGE = 4
PIPE_UNLIMITED_INSTANCES = 255
SECURITY_CONTEXT_TRACKING = 262144
SECURITY_EFFECTIVE_ONLY = 524288
SECURITY_SQOS_PRESENT = 1048576
SECURITY_VALID_SQOS_FLAGS = 2031616
DTR_CONTROL_DISABLE = 0
DTR_CONTROL_ENABLE = 1
DTR_CONTROL_HANDSHAKE = 2
RTS_CONTROL_DISABLE = 0
RTS_CONTROL_ENABLE = 1
RTS_CONTROL_HANDSHAKE = 2
RTS_CONTROL_TOGGLE = 3
GMEM_FIXED = 0
GMEM_MOVEABLE = 2
GMEM_NOCOMPACT = 16
GMEM_NODISCARD = 32
GMEM_ZEROINIT = 64
GMEM_MODIFY = 128
GMEM_DISCARDABLE = 256
GMEM_NOT_BANKED = 4096
GMEM_SHARE = 8192
GMEM_DDESHARE = 8192
GMEM_NOTIFY = 16384
GMEM_LOWER = GMEM_NOT_BANKED
GMEM_VALID_FLAGS = 32626
GMEM_INVALID_HANDLE = 32768
GHND = (GMEM_MOVEABLE | GMEM_ZEROINIT)
GPTR = (GMEM_FIXED | GMEM_ZEROINIT)
GMEM_DISCARDED = 16384
GMEM_LOCKCOUNT = 255
LMEM_FIXED = 0
LMEM_MOVEABLE = 2
LMEM_NOCOMPACT = 16
LMEM_NODISCARD = 32
LMEM_ZEROINIT = 64
LMEM_MODIFY = 128
LMEM_DISCARDABLE = 3840
LMEM_VALID_FLAGS = 3954
LMEM_INVALID_HANDLE = 32768
LHND = (LMEM_MOVEABLE | LMEM_ZEROINIT)
LPTR = (LMEM_FIXED | LMEM_ZEROINIT)
NONZEROLHND = (LMEM_MOVEABLE)
NONZEROLPTR = (LMEM_FIXED)
LMEM_DISCARDED = 16384
LMEM_LOCKCOUNT = 255
DEBUG_PROCESS = 1
DEBUG_ONLY_THIS_PROCESS = 2
CREATE_SUSPENDED = 4
DETACHED_PROCESS = 8
CREATE_NEW_CONSOLE = 16
NORMAL_PRIORITY_CLASS = 32
IDLE_PRIORITY_CLASS = 64
HIGH_PRIORITY_CLASS = 128
REALTIME_PRIORITY_CLASS = 256
CREATE_NEW_PROCESS_GROUP = 512
CREATE_UNICODE_ENVIRONMENT = 1024
CREATE_SEPARATE_WOW_VDM = 2048
CREATE_SHARED_WOW_VDM = 4096
CREATE_DEFAULT_ERROR_MODE = 67108864
CREATE_NO_WINDOW = 134217728
PROFILE_USER = 268435456
PROFILE_KERNEL = 536870912
PROFILE_SERVER = 1073741824
THREAD_BASE_PRIORITY_LOWRT  = 15
THREAD_BASE_PRIORITY_MAX =   2
THREAD_BASE_PRIORITY_MIN =  -2
THREAD_BASE_PRIORITY_IDLE = -15
THREAD_PRIORITY_LOWEST = THREAD_BASE_PRIORITY_MIN
THREAD_PRIORITY_BELOW_NORMAL = THREAD_PRIORITY_LOWEST+1
THREAD_PRIORITY_HIGHEST =         THREAD_BASE_PRIORITY_MAX
THREAD_PRIORITY_ABOVE_NORMAL =   THREAD_PRIORITY_HIGHEST-1
THREAD_PRIORITY_ERROR_RETURN =   MAXLONG
THREAD_PRIORITY_TIME_CRITICAL   = THREAD_BASE_PRIORITY_LOWRT
THREAD_PRIORITY_IDLE            = THREAD_BASE_PRIORITY_IDLE
THREAD_PRIORITY_NORMAL = 0
EXCEPTION_DEBUG_EVENT = 1
CREATE_THREAD_DEBUG_EVENT = 2
CREATE_PROCESS_DEBUG_EVENT = 3
EXIT_THREAD_DEBUG_EVENT = 4
EXIT_PROCESS_DEBUG_EVENT = 5
LOAD_DLL_DEBUG_EVENT = 6
UNLOAD_DLL_DEBUG_EVENT = 7
OUTPUT_DEBUG_STRING_EVENT = 8
RIP_EVENT = 9
DRIVE_UNKNOWN = 0
DRIVE_NO_ROOT_DIR = 1
DRIVE_REMOVABLE = 2
DRIVE_FIXED = 3
DRIVE_REMOTE = 4
DRIVE_CDROM = 5
DRIVE_RAMDISK = 6
FILE_TYPE_UNKNOWN = 0
FILE_TYPE_DISK = 1
FILE_TYPE_CHAR = 2
FILE_TYPE_PIPE = 3
FILE_TYPE_REMOTE = 32768
NOPARITY = 0
ODDPARITY = 1
EVENPARITY = 2
MARKPARITY = 3
SPACEPARITY = 4
ONESTOPBIT = 0
ONE5STOPBITS = 1
TWOSTOPBITS = 2
CBR_110 = 110
CBR_300 = 300
CBR_600 = 600
CBR_1200 = 1200
CBR_2400 = 2400
CBR_4800 = 4800
CBR_9600 = 9600
CBR_14400 = 14400
CBR_19200 = 19200
CBR_38400 = 38400
CBR_56000 = 56000
CBR_57600 = 57600
CBR_115200 = 115200
CBR_128000 = 128000
CBR_256000 = 256000
S_QUEUEEMPTY = 0
S_THRESHOLD = 1
S_ALLTHRESHOLD = 2
S_NORMAL = 0
S_LEGATO = 1
S_STACCATO = 2
NMPWAIT_WAIT_FOREVER = -1
NMPWAIT_NOWAIT = 1
NMPWAIT_USE_DEFAULT_WAIT = 0
OF_READ = 0
OF_WRITE = 1
OF_READWRITE = 2
OF_SHARE_COMPAT = 0
OF_SHARE_EXCLUSIVE = 16
OF_SHARE_DENY_WRITE = 32
OF_SHARE_DENY_READ = 48
OF_SHARE_DENY_NONE = 64
OF_PARSE = 256
OF_DELETE = 512
OF_VERIFY = 1024
OF_CANCEL = 2048
OF_CREATE = 4096
OF_PROMPT = 8192
OF_EXIST = 16384
OF_REOPEN = 32768
OFS_MAXPATHNAME = 128
MAXINTATOM = 49152

# winbase.h
PROCESS_HEAP_REGION = 1
PROCESS_HEAP_UNCOMMITTED_RANGE = 2
PROCESS_HEAP_ENTRY_BUSY = 4
PROCESS_HEAP_ENTRY_MOVEABLE = 16
PROCESS_HEAP_ENTRY_DDESHARE = 32
SCS_32BIT_BINARY = 0
SCS_DOS_BINARY = 1
SCS_WOW_BINARY = 2
SCS_PIF_BINARY = 3
SCS_POSIX_BINARY = 4
SCS_OS216_BINARY = 5
SEM_FAILCRITICALERRORS = 1
SEM_NOGPFAULTERRORBOX = 2
SEM_NOALIGNMENTFAULTEXCEPT = 4
SEM_NOOPENFILEERRORBOX = 32768
LOCKFILE_FAIL_IMMEDIATELY = 1
LOCKFILE_EXCLUSIVE_LOCK = 2
HANDLE_FLAG_INHERIT = 1
HANDLE_FLAG_PROTECT_FROM_CLOSE = 2
HINSTANCE_ERROR = 32
GET_TAPE_MEDIA_INFORMATION = 0
GET_TAPE_DRIVE_INFORMATION = 1
SET_TAPE_MEDIA_INFORMATION = 0
SET_TAPE_DRIVE_INFORMATION = 1
FORMAT_MESSAGE_ALLOCATE_BUFFER = 256
FORMAT_MESSAGE_IGNORE_INSERTS = 512
FORMAT_MESSAGE_FROM_STRING = 1024
FORMAT_MESSAGE_FROM_HMODULE = 2048
FORMAT_MESSAGE_FROM_SYSTEM = 4096
FORMAT_MESSAGE_ARGUMENT_ARRAY = 8192
FORMAT_MESSAGE_MAX_WIDTH_MASK = 255
BACKUP_INVALID = 0
BACKUP_DATA = 1
BACKUP_EA_DATA = 2
BACKUP_SECURITY_DATA = 3
BACKUP_ALTERNATE_DATA = 4
BACKUP_LINK = 5
BACKUP_PROPERTY_DATA = 6
BACKUP_OBJECT_ID = 7
BACKUP_REPARSE_DATA = 8
BACKUP_SPARSE_BLOCK = 9

STREAM_NORMAL_ATTRIBUTE = 0
STREAM_MODIFIED_WHEN_READ = 1
STREAM_CONTAINS_SECURITY = 2
STREAM_CONTAINS_PROPERTIES = 4
STARTF_USESHOWWINDOW = 1
STARTF_USESIZE = 2
STARTF_USEPOSITION = 4
STARTF_USECOUNTCHARS = 8
STARTF_USEFILLATTRIBUTE = 16
STARTF_FORCEONFEEDBACK = 64
STARTF_FORCEOFFFEEDBACK = 128
STARTF_USESTDHANDLES = 256
STARTF_USEHOTKEY = 512
SHUTDOWN_NORETRY = 1
DONT_RESOLVE_DLL_REFERENCES = 1
LOAD_LIBRARY_AS_DATAFILE = 2
LOAD_WITH_ALTERED_SEARCH_PATH = 8
DDD_RAW_TARGET_PATH = 1
DDD_REMOVE_DEFINITION = 2
DDD_EXACT_MATCH_ON_REMOVE = 4
MOVEFILE_REPLACE_EXISTING = 1
MOVEFILE_COPY_ALLOWED = 2
MOVEFILE_DELAY_UNTIL_REBOOT = 4
MAX_COMPUTERNAME_LENGTH = 15
LOGON32_LOGON_INTERACTIVE = 2
LOGON32_LOGON_BATCH = 4
LOGON32_LOGON_SERVICE = 5
LOGON32_PROVIDER_DEFAULT = 0
LOGON32_PROVIDER_WINNT35 = 1
VER_PLATFORM_WIN32s = 0
VER_PLATFORM_WIN32_WINDOWS = 1
VER_PLATFORM_WIN32_NT = 2
TC_NORMAL = 0
TC_HARDERR = 1
TC_GP_TRAP = 2
TC_SIGNAL = 3
AC_LINE_OFFLINE = 0
AC_LINE_ONLINE = 1
AC_LINE_BACKUP_POWER = 2
AC_LINE_UNKNOWN = 255
BATTERY_FLAG_HIGH = 1
BATTERY_FLAG_LOW = 2
BATTERY_FLAG_CRITICAL = 4
BATTERY_FLAG_CHARGING = 8
BATTERY_FLAG_NO_BATTERY = 128
BATTERY_FLAG_UNKNOWN = 255
BATTERY_PERCENTAGE_UNKNOWN = 255
BATTERY_LIFE_UNKNOWN = -1

# Generated by h2py from d:\msdev\include\richedit.h
cchTextLimitDefault = 32767
WM_CONTEXTMENU = 123
WM_PRINTCLIENT = 792
EN_MSGFILTER = 1792
EN_REQUESTRESIZE = 1793
EN_SELCHANGE = 1794
EN_DROPFILES = 1795
EN_PROTECTED = 1796
EN_CORRECTTEXT = 1797
EN_STOPNOUNDO = 1798
EN_IMECHANGE = 1799
EN_SAVECLIPBOARD = 1800
EN_OLEOPFAILED = 1801
ENM_NONE = 0
ENM_CHANGE = 1
ENM_UPDATE = 2
ENM_SCROLL = 4
ENM_KEYEVENTS = 65536
ENM_MOUSEEVENTS = 131072
ENM_REQUESTRESIZE = 262144
ENM_SELCHANGE = 524288
ENM_DROPFILES = 1048576
ENM_PROTECTED = 2097152
ENM_CORRECTTEXT = 4194304
ENM_IMECHANGE = 8388608
ES_SAVESEL = 32768
ES_SUNKEN = 16384
ES_DISABLENOSCROLL = 8192
ES_SELECTIONBAR = 16777216
ES_EX_NOCALLOLEINIT = 16777216
ES_VERTICAL = 4194304
ES_NOIME = 524288
ES_SELFIME = 262144
ECO_AUTOWORDSELECTION = 1
ECO_AUTOVSCROLL = 64
ECO_AUTOHSCROLL = 128
ECO_NOHIDESEL = 256
ECO_READONLY = 2048
ECO_WANTRETURN = 4096
ECO_SAVESEL = 32768
ECO_SELECTIONBAR = 16777216
ECO_VERTICAL = 4194304
ECOOP_SET = 1
ECOOP_OR = 2
ECOOP_AND = 3
ECOOP_XOR = 4
WB_CLASSIFY = 3
WB_MOVEWORDLEFT = 4
WB_MOVEWORDRIGHT = 5
WB_LEFTBREAK = 6
WB_RIGHTBREAK = 7
WB_MOVEWORDPREV = 4
WB_MOVEWORDNEXT = 5
WB_PREVBREAK = 6
WB_NEXTBREAK = 7
PC_FOLLOWING = 1
PC_LEADING = 2
PC_OVERFLOW = 3
PC_DELIMITER = 4
WBF_WORDWRAP = 16
WBF_WORDBREAK = 32
WBF_OVERFLOW = 64
WBF_LEVEL1 = 128
WBF_LEVEL2 = 256
WBF_CUSTOM = 512
CFM_BOLD = 1
CFM_ITALIC = 2
CFM_UNDERLINE = 4
CFM_STRIKEOUT = 8
CFM_PROTECTED = 16
CFM_SIZE = -2147483648
CFM_COLOR = 1073741824
CFM_FACE = 536870912
CFM_OFFSET = 268435456
CFM_CHARSET = 134217728
CFE_BOLD = 1
CFE_ITALIC = 2
CFE_UNDERLINE = 4
CFE_STRIKEOUT = 8
CFE_PROTECTED = 16
CFE_AUTOCOLOR = 1073741824
yHeightCharPtsMost = 1638
SCF_SELECTION = 1
SCF_WORD = 2
SF_TEXT = 1
SF_RTF = 2
SF_RTFNOOBJS = 3
SF_TEXTIZED = 4
SFF_SELECTION = 32768
SFF_PLAINRTF = 16384
MAX_TAB_STOPS = 32
lDefaultTab = 720
PFM_STARTINDENT = 1
PFM_RIGHTINDENT = 2
PFM_OFFSET = 4
PFM_ALIGNMENT = 8
PFM_TABSTOPS = 16
PFM_NUMBERING = 32
PFM_OFFSETINDENT = -2147483648
PFN_BULLET = 1
PFA_LEFT = 1
PFA_RIGHT = 2
PFA_CENTER = 3
WM_NOTIFY = 78
SEL_EMPTY = 0
SEL_TEXT = 1
SEL_OBJECT = 2
SEL_MULTICHAR = 4
SEL_MULTIOBJECT = 8
OLEOP_DOVERB = 1
CF_RTF = "Rich Text Format"
CF_RTFNOOBJS = "Rich Text Format Without Objects"
CF_RETEXTOBJ = "RichEdit Text and Objects"

# From wincon.h
RIGHT_ALT_PRESSED     = 1 # the right alt key is pressed.
LEFT_ALT_PRESSED      = 2 # the left alt key is pressed.
RIGHT_CTRL_PRESSED    = 4 # the right ctrl key is pressed.
LEFT_CTRL_PRESSED     = 8 # the left ctrl key is pressed.
SHIFT_PRESSED         = 16 # the shift key is pressed.
NUMLOCK_ON            = 32 # the numlock light is on.
SCROLLLOCK_ON         = 64 # the scrolllock light is on.
CAPSLOCK_ON           = 128 # the capslock light is on.
ENHANCED_KEY          = 256 # the key is enhanced.
NLS_DBCSCHAR          = 65536 # DBCS for JPN: SBCS/DBCS mode.
NLS_ALPHANUMERIC      = 0 # DBCS for JPN: Alphanumeric mode.
NLS_KATAKANA          = 131072 # DBCS for JPN: Katakana mode.
NLS_HIRAGANA          = 262144 # DBCS for JPN: Hiragana mode.
NLS_ROMAN             = 4194304 # DBCS for JPN: Roman/Noroman mode.
NLS_IME_CONVERSION    = 8388608 # DBCS for JPN: IME conversion.
NLS_IME_DISABLE       = 536870912 # DBCS for JPN: IME enable/disable.

FROM_LEFT_1ST_BUTTON_PRESSED    = 1
RIGHTMOST_BUTTON_PRESSED        = 2
FROM_LEFT_2ND_BUTTON_PRESSED    = 4
FROM_LEFT_3RD_BUTTON_PRESSED    = 8
FROM_LEFT_4TH_BUTTON_PRESSED    = 16

CTRL_C_EVENT        = 0
CTRL_BREAK_EVENT    = 1
CTRL_CLOSE_EVENT    = 2
CTRL_LOGOFF_EVENT   = 5
CTRL_SHUTDOWN_EVENT = 6

MOUSE_MOVED   = 1
DOUBLE_CLICK  = 2
MOUSE_WHEELED = 4

#property sheet window messages from prsht.h
PSM_SETCURSEL = (WM_USER + 101)
PSM_REMOVEPAGE = (WM_USER + 102)
PSM_ADDPAGE = (WM_USER + 103)
PSM_CHANGED = (WM_USER + 104)
PSM_RESTARTWINDOWS = (WM_USER + 105)
PSM_REBOOTSYSTEM = (WM_USER + 106)
PSM_CANCELTOCLOSE = (WM_USER + 107)
PSM_QUERYSIBLINGS = (WM_USER + 108)
PSM_UNCHANGED = (WM_USER + 109)
PSM_APPLY = (WM_USER + 110)
PSM_SETTITLEA = (WM_USER + 111)
PSM_SETTITLEW = (WM_USER + 120)
PSM_SETWIZBUTTONS = (WM_USER + 112)
PSM_PRESSBUTTON = (WM_USER + 113)
PSM_SETCURSELID = (WM_USER + 114)
PSM_SETFINISHTEXTA = (WM_USER + 115)
PSM_SETFINISHTEXTW = (WM_USER + 121)
PSM_GETTABCONTROL = (WM_USER + 116)
PSM_ISDIALOGMESSAGE = (WM_USER + 117)
PSM_GETCURRENTPAGEHWND = (WM_USER + 118)
PSM_INSERTPAGE = (WM_USER + 119)
PSM_SETHEADERTITLEA = (WM_USER + 125)
PSM_SETHEADERTITLEW = (WM_USER + 126)
PSM_SETHEADERSUBTITLEA = (WM_USER + 127)
PSM_SETHEADERSUBTITLEW = (WM_USER + 128)
PSM_HWNDTOINDEX = (WM_USER + 129)
PSM_INDEXTOHWND = (WM_USER + 130)
PSM_PAGETOINDEX = (WM_USER + 131)
PSM_INDEXTOPAGE = (WM_USER + 132)
PSM_IDTOINDEX = (WM_USER + 133)
PSM_INDEXTOID = (WM_USER + 134)
PSM_GETRESULT = (WM_USER + 135)
PSM_RECALCPAGESIZES = (WM_USER + 136)

# GetUserNameEx/GetComputerNameEx
NameUnknown = 0
NameFullyQualifiedDN = 1
NameSamCompatible = 2
NameDisplay = 3
NameUniqueId = 6
NameCanonical = 7
NameUserPrincipal = 8
NameCanonicalEx = 9
NameServicePrincipal = 10
NameDnsDomain = 12

ComputerNameNetBIOS = 0
ComputerNameDnsHostname = 1
ComputerNameDnsDomain = 2
ComputerNameDnsFullyQualified = 3
ComputerNamePhysicalNetBIOS = 4
ComputerNamePhysicalDnsHostname = 5
ComputerNamePhysicalDnsDomain = 6
ComputerNamePhysicalDnsFullyQualified = 7

LWA_COLORKEY = 0x00000001
LWA_ALPHA = 0x00000002
ULW_COLORKEY = 0x00000001
ULW_ALPHA = 0x00000002
ULW_OPAQUE = 0x00000004

# WinDef.h
TRUE = 1
FALSE = 0
MAX_PATH = 260
# WinGDI.h
AC_SRC_OVER = 0
AC_SRC_ALPHA = 1
GRADIENT_FILL_RECT_H = 0
GRADIENT_FILL_RECT_V = 1
GRADIENT_FILL_TRIANGLE = 2
GRADIENT_FILL_OP_FLAG = 255

# Bizarrely missing from any platform header.  Ref:
# http://www.codeguru.com/forum/archive/index.php/t-426785.html
MAPVK_VK_TO_VSC = 0
MAPVK_VSC_TO_VK = 1
MAPVK_VK_TO_CHAR = 2
MAPVK_VSC_TO_VK_EX = 3

USER_TIMER_MAXIMUM = 0x7fffffff

########NEW FILE########
__FILENAME__ = types
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

from ctypes import *

BOOL = c_int
DWORD = c_uint32
BYTE = c_char
LONG = c_long
WORD = c_short

HANDLE = c_void_p
HWND = HANDLE
HMONITOR = HANDLE
HGLOBAL = HANDLE
HDC = HANDLE
HBITMAP = HANDLE
LPARAM = c_long

WNDPROC = WINFUNCTYPE(c_long, c_int, c_uint, c_int, c_int)
TIMERPROC = WINFUNCTYPE(None, HWND, c_uint, POINTER(c_uint), c_uint)

class RECT(Structure):
    _fields_ = [
        ('left', c_long),
        ('top', c_long),
        ('right', c_long),
        ('bottom', c_long)
    ]

class WNDCLASS(Structure):
    _fields_ = [
        ('style', c_uint),
        ('lpfnWndProc', WNDPROC),
        ('cbClsExtra', c_int),
        ('cbWndExtra', c_int),
        ('hInstance', c_int),
        ('hIcon', c_int),
        ('hCursor', c_int),
        ('hbrBackground', c_int),
        ('lpszMenuName', c_char_p),
        ('lpszClassName', c_wchar_p)
    ]

class POINT(Structure):
    _fields_ = [
        ('x', c_long),
        ('y', c_long)
    ]

class MSG(Structure):
    _fields_ = [
        ('hwnd', c_int),
        ('message', c_uint),
        ('wParam', c_int),
        ('lParam', c_int),
        ('time', c_int),
        ('pt', POINT)
    ]

class PIXELFORMATDESCRIPTOR(Structure):
    _fields_ = [
        ('nSize', c_ushort),
        ('nVersion', c_ushort),
        ('dwFlags', c_ulong),
        ('iPixelType', c_ubyte),
        ('cColorBits', c_ubyte),
        ('cRedBits', c_ubyte),
        ('cRedShift', c_ubyte),
        ('cGreenBits', c_ubyte),
        ('cGreenShift', c_ubyte),
        ('cBlueBits', c_ubyte),
        ('cBlueShift', c_ubyte),
        ('cAlphaBits', c_ubyte),
        ('cAlphaShift', c_ubyte),
        ('cAccumBits', c_ubyte),
        ('cAccumRedBits', c_ubyte),
        ('cAccumGreenBits', c_ubyte),
        ('cAccumBlueBits', c_ubyte),
        ('cAccumAlphaBits', c_ubyte),
        ('cDepthBits', c_ubyte),
        ('cStencilBits', c_ubyte),
        ('cAuxBuffers', c_ubyte),
        ('iLayerType', c_ubyte),
        ('bReserved', c_ubyte),
        ('dwLayerMask', c_ulong),
        ('dwVisibleMask', c_ulong),
        ('dwDamageMask', c_ulong)
    ]

class TRACKMOUSEEVENT(Structure):
    _fields_ = [
        ('cbSize', DWORD),
        ('dwFlags', DWORD),
        ('hwndTrack', HWND),
        ('dwHoverTime', DWORD)
    ]

class MINMAXINFO(Structure):
    _fields_ = [
        ('ptReserved', POINT),
        ('ptMaxSize', POINT),
        ('ptMaxPosition', POINT),
        ('ptMinTrackSize', POINT),
        ('ptMaxTrackSize', POINT)
    ]

class RGBQUAD(Structure):
    _fields_ = [
        ('rgbBlue', BYTE),
        ('rgbGreen', BYTE),
        ('rgbRed', BYTE),
        ('rgbReserved', BYTE),
    ]

class BITMAPINFOHEADER(Structure):
    _fields_ = [
        ('biSize', DWORD),
        ('biWidth', LONG),
        ('biHeight', LONG),
        ('biPlanes', WORD),
        ('biBitCount', WORD),
        ('biCompression', DWORD),
        ('biSizeImage', DWORD),
        ('biXPelsPerMeter', LONG),
        ('biYPelsPerMeter', LONG),
        ('biClrUsed', DWORD),
        ('biClrImportant', DWORD),
    ]

class BITMAPINFO(Structure):
    _fields_ = [
        ('bmiHeader', BITMAPINFOHEADER),
        ('bmiColors', RGBQUAD * 1)
    ]

class CIEXYZ(Structure):
    _fields_ = [
        ('ciexyzX', DWORD),
        ('ciexyzY', DWORD),
        ('ciexyzZ', DWORD),
    ]

class CIEXYZTRIPLE(Structure):
    _fields_ = [
        ('ciexyzRed', CIEXYZ),
        ('ciexyzBlue', CIEXYZ),
        ('ciexyzGreen', CIEXYZ),
    ]

class BITMAPV5HEADER(Structure):
    _fields_ = [
        ('bV5Size', DWORD),
        ('bV5Width', LONG),
        ('bV5Height', LONG),
        ('bV5Planes', WORD),
        ('bV5BitCount', WORD),
        ('bV5Compression', DWORD),
        ('bV5SizeImage', DWORD),
        ('bV5XPelsPerMeter', LONG),
        ('bV5YPelsPerMeter', LONG),
        ('bV5ClrUsed', DWORD),
        ('bV5ClrImportant', DWORD),
        ('bV5RedMask', DWORD),
        ('bV5GreenMask', DWORD),
        ('bV5BlueMask', DWORD),
        ('bV5AlphaMask', DWORD),
        ('bV5CSType', DWORD),
        ('bV5Endpoints', CIEXYZTRIPLE),
        ('bV5GammaRed', DWORD),
        ('bV5GammaGreen', DWORD),
        ('bV5GammaBlue', DWORD),
        ('bV5Intent', DWORD),
        ('bV5ProfileData', DWORD),
        ('bV5ProfileSize', DWORD),
        ('bV5Reserved', DWORD),
    ]

class ICONINFO(Structure):
    _fields_ = [
        ('fIcon', BOOL),
        ('xHotspot', DWORD),
        ('yHotspot', DWORD),
        ('hbmMask', HBITMAP),
        ('hbmColor', HBITMAP)
    ]

########NEW FILE########
__FILENAME__ = winkey
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: $'

from pyglet.window import key
from pyglet.window.win32.constants import *

keymap = {
    ord('A'): key.A,
    ord('B'): key.B,
    ord('C'): key.C,
    ord('D'): key.D,
    ord('E'): key.E,
    ord('F'): key.F,
    ord('G'): key.G,
    ord('H'): key.H,
    ord('I'): key.I,
    ord('J'): key.J,
    ord('K'): key.K,
    ord('L'): key.L,
    ord('M'): key.M,
    ord('N'): key.N,
    ord('O'): key.O,
    ord('P'): key.P,
    ord('Q'): key.Q,
    ord('R'): key.R,
    ord('S'): key.S,
    ord('T'): key.T,
    ord('U'): key.U,
    ord('V'): key.V,
    ord('W'): key.W,
    ord('X'): key.X,
    ord('Y'): key.Y,
    ord('Z'): key.Z,
    ord('0'): key._0,
    ord('1'): key._1,
    ord('2'): key._2,
    ord('3'): key._3,
    ord('4'): key._4,
    ord('5'): key._5,
    ord('6'): key._6,
    ord('7'): key._7,
    ord('8'): key._8,
    ord('9'): key._9,
    ord('\b'): key.BACKSPACE,

    # By experiment:
    0x14: key.CAPSLOCK,
    0x5d: key.MENU,

#    VK_LBUTTON: ,
#    VK_RBUTTON: ,
    VK_CANCEL: key.CANCEL,
#    VK_MBUTTON: ,
#    VK_BACK: ,
    VK_TAB: key.TAB,
#    VK_CLEAR: ,
    VK_RETURN: key.RETURN,
    VK_SHIFT: key.LSHIFT,
    VK_CONTROL: key.LCTRL,
    VK_MENU: key.LALT,
    VK_PAUSE: key.PAUSE,
#    VK_CAPITAL: ,
#    VK_KANA: ,
#    VK_HANGEUL: ,
#    VK_HANGUL: ,
#    VK_JUNJA: ,
#    VK_FINAL: ,
#    VK_HANJA: ,
#    VK_KANJI: ,
    VK_ESCAPE: key.ESCAPE,
#    VK_CONVERT: ,
#    VK_NONCONVERT: ,
#    VK_ACCEPT: ,
#    VK_MODECHANGE: ,
    VK_SPACE: key.SPACE,
    VK_PRIOR: key.PAGEUP,
    VK_NEXT: key.PAGEDOWN,
    VK_END: key.END,
    VK_HOME: key.HOME,
    VK_LEFT: key.LEFT,
    VK_UP: key.UP,
    VK_RIGHT: key.RIGHT,
    VK_DOWN: key.DOWN,
#    VK_SELECT: ,
    VK_PRINT: key.PRINT,
#    VK_EXECUTE: ,
#    VK_SNAPSHOT: ,
    VK_INSERT: key.INSERT,
    VK_DELETE: key.DELETE,
    VK_HELP: key.HELP,
    VK_LWIN: key.LWINDOWS,
    VK_RWIN: key.RWINDOWS,
#    VK_APPS: ,
    VK_NUMPAD0: key.NUM_0,
    VK_NUMPAD1: key.NUM_1,
    VK_NUMPAD2: key.NUM_2,
    VK_NUMPAD3: key.NUM_3,
    VK_NUMPAD4: key.NUM_4,
    VK_NUMPAD5: key.NUM_5,
    VK_NUMPAD6: key.NUM_6,
    VK_NUMPAD7: key.NUM_7,
    VK_NUMPAD8: key.NUM_8,
    VK_NUMPAD9: key.NUM_9,
    VK_MULTIPLY: key.NUM_MULTIPLY,
    VK_ADD: key.NUM_ADD,
#    VK_SEPARATOR: ,
    VK_SUBTRACT: key.NUM_SUBTRACT,
    VK_DECIMAL: key.NUM_DECIMAL,
    VK_DIVIDE: key.NUM_DIVIDE,
    VK_F1: key.F1,
    VK_F2: key.F2,
    VK_F3: key.F3,
    VK_F4: key.F4,
    VK_F5: key.F5,
    VK_F6: key.F6,
    VK_F7: key.F7,
    VK_F8: key.F8,
    VK_F9: key.F9,
    VK_F10: key.F10,
    VK_F11: key.F11,
    VK_F12: key.F12,
    VK_F13: key.F13,
    VK_F14: key.F14,
    VK_F15: key.F15,
    VK_F16: key.F16,
#    VK_F17: ,
#    VK_F18: ,
#    VK_F19: ,
#    VK_F20: ,
#    VK_F21: ,
#    VK_F22: ,
#    VK_F23: ,
#    VK_F24: ,
    VK_NUMLOCK: key.NUMLOCK,
    VK_SCROLL: key.SCROLLLOCK,
    VK_LSHIFT: key.LSHIFT,
    VK_RSHIFT: key.RSHIFT,
    VK_LCONTROL: key.LCTRL,
    VK_RCONTROL: key.RCTRL,
    VK_LMENU: key.LALT,
    VK_RMENU: key.RALT,
#    VK_PROCESSKEY: ,
#    VK_ATTN: ,
#    VK_CRSEL: ,
#    VK_EXSEL: ,
#    VK_EREOF: ,
#    VK_PLAY: ,
#    VK_ZOOM: ,
#    VK_NONAME: ,
#    VK_PA1: ,
#    VK_OEM_CLEAR: ,
#    VK_XBUTTON1: ,
#    VK_XBUTTON2: ,
#    VK_VOLUME_MUTE: ,
#    VK_VOLUME_DOWN: ,
#    VK_VOLUME_UP: ,
#    VK_MEDIA_NEXT_TRACK: ,
#    VK_MEDIA_PREV_TRACK: ,
#    VK_MEDIA_PLAY_PAUSE: ,
#    VK_BROWSER_BACK: ,
#    VK_BROWSER_FORWARD: ,
}

# Keys that must be translated via MapVirtualKey, as the virtual key code
# is language and keyboard dependent.
chmap = {
    ord('!'): key.EXCLAMATION,
    ord('"'): key.DOUBLEQUOTE,
    ord('#'): key.HASH,
    ord('$'): key.DOLLAR,
    ord('%'): key.PERCENT,
    ord('&'): key.AMPERSAND,
    ord("'"): key.APOSTROPHE,
    ord('('): key.PARENLEFT,
    ord(')'): key.PARENRIGHT,
    ord('*'): key.ASTERISK,
    ord('+'): key.PLUS,
    ord(','): key.COMMA,
    ord('-'): key.MINUS,
    ord('.'): key.PERIOD,
    ord('/'): key.SLASH,
    ord(':'): key.COLON,
    ord(';'): key.SEMICOLON,
    ord('<'): key.LESS,
    ord('='): key.EQUAL,
    ord('>'): key.GREATER,
    ord('?'): key.QUESTION,
    ord('@'): key.AT,
    ord('['): key.BRACKETLEFT,
    ord('\\'): key.BACKSLASH,
    ord(']'): key.BRACKETRIGHT,
    ord('\x5e'): key.ASCIICIRCUM,
    ord('_'): key.UNDERSCORE,
    ord('\x60'): key.GRAVE,
    ord('`'): key.QUOTELEFT,
    ord('{'): key.BRACELEFT,
    ord('|'): key.BAR,
    ord('}'): key.BRACERIGHT,
    ord('~'): key.ASCIITILDE,
}

########NEW FILE########
__FILENAME__ = cursorfont
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

'''
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id: cursorfont.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

# /usr/include/X11/cursorfont.h

XC_num_glyphs = 154
XC_X_cursor = 0
XC_arrow = 2
XC_based_arrow_down = 4
XC_based_arrow_up = 6
XC_boat = 8
XC_bogosity = 10
XC_bottom_left_corner = 12
XC_bottom_right_corner = 14
XC_bottom_side = 16
XC_bottom_tee = 18
XC_box_spiral = 20
XC_center_ptr = 22
XC_circle = 24
XC_clock = 26
XC_coffee_mug = 28
XC_cross = 30
XC_cross_reverse = 32
XC_crosshair = 34
XC_diamond_cross = 36
XC_dot = 38
XC_dotbox = 40
XC_double_arrow = 42
XC_draft_large = 44
XC_draft_small = 46
XC_draped_box = 48
XC_exchange = 50
XC_fleur = 52
XC_gobbler = 54
XC_gumby = 56
XC_hand1 = 58
XC_hand2 = 60
XC_heart = 62
XC_icon = 64
XC_iron_cross = 66
XC_left_ptr = 68
XC_left_side = 70
XC_left_tee = 72
XC_leftbutton = 74
XC_ll_angle = 76
XC_lr_angle = 78
XC_man = 80
XC_middlebutton = 82
XC_mouse = 84
XC_pencil = 86
XC_pirate = 88
XC_plus = 90
XC_question_arrow = 92
XC_right_ptr = 94
XC_right_side = 96
XC_right_tee = 98
XC_rightbutton = 100
XC_rtl_logo = 102
XC_sailboat = 104
XC_sb_down_arrow = 106
XC_sb_h_double_arrow = 108
XC_sb_left_arrow = 110
XC_sb_right_arrow = 112
XC_sb_up_arrow = 114
XC_sb_v_double_arrow = 116
XC_shuttle = 118
XC_sizing = 120
XC_spider = 122
XC_spraycan = 124
XC_star = 126
XC_target = 128
XC_tcross = 130
XC_top_left_arrow = 132
XC_top_left_corner = 134
XC_top_right_corner = 136
XC_top_side = 138
XC_top_tee = 140
XC_trek = 142
XC_ul_angle = 144
XC_umbrella = 146
XC_ur_angle = 148
XC_watch = 150
XC_xterm = 152

########NEW FILE########
__FILENAME__ = xinerama
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for Xinerama

Generated with:
tools/genwrappers.py

Do not modify this file.
'''

__docformat__ =  'restructuredtext'
__version__ = '$Id: xinerama.py 1579 2008-01-15 14:47:19Z Alex.Holkner $'

import ctypes
from ctypes import *

import pyglet.lib

_lib = pyglet.lib.load_library('Xinerama')

_int_types = (c_int16, c_int32)
if hasattr(ctypes, 'c_int64'):
    # Some builds of ctypes apparently do not have c_int64
    # defined; it's a pretty good bet that these builds do not
    # have 64-bit pointers.
    _int_types += (ctypes.c_int64,)
for t in _int_types:
    if sizeof(t) == sizeof(c_size_t):
        c_ptrdiff_t = t

class c_void(Structure):
    # c_void_p is a buggy return type, converting to int, so
    # POINTER(None) == c_void_p is actually written as
    # POINTER(c_void), so it can be treated as a real pointer.
    _fields_ = [('dummy', c_int)]


import pyglet.gl.glx
import pyglet.window.xlib.xlib

class struct_anon_181(Structure):
    __slots__ = [
        'screen_number',
        'x_org',
        'y_org',
        'width',
        'height',
    ]
struct_anon_181._fields_ = [
    ('screen_number', c_int),
    ('x_org', c_short),
    ('y_org', c_short),
    ('width', c_short),
    ('height', c_short),
]

XineramaScreenInfo = struct_anon_181 	# /usr/include/X11/extensions/Xinerama.h:40
Display = pyglet.gl.glx.Display
# /usr/include/X11/extensions/Xinerama.h:44
XineramaQueryExtension = _lib.XineramaQueryExtension
XineramaQueryExtension.restype = c_int
XineramaQueryExtension.argtypes = [POINTER(Display), POINTER(c_int), POINTER(c_int)]

# /usr/include/X11/extensions/Xinerama.h:50
XineramaQueryVersion = _lib.XineramaQueryVersion
XineramaQueryVersion.restype = c_int
XineramaQueryVersion.argtypes = [POINTER(Display), POINTER(c_int), POINTER(c_int)]

# /usr/include/X11/extensions/Xinerama.h:56
XineramaIsActive = _lib.XineramaIsActive
XineramaIsActive.restype = c_int
XineramaIsActive.argtypes = [POINTER(Display)]

# /usr/include/X11/extensions/Xinerama.h:67
XineramaQueryScreens = _lib.XineramaQueryScreens
XineramaQueryScreens.restype = POINTER(XineramaScreenInfo)
XineramaQueryScreens.argtypes = [POINTER(Display), POINTER(c_int)]


__all__ = ['XineramaScreenInfo', 'XineramaQueryExtension',
'XineramaQueryVersion', 'XineramaIsActive', 'XineramaQueryScreens']

########NEW FILE########
__FILENAME__ = xlib
'''Wrapper for X11

Generated with:
tools/genwrappers.py xlib

Do not modify this file.
'''

__docformat__ =  'restructuredtext'
__version__ = '$Id: xlib.py 2060 2008-05-04 13:09:15Z Alex.Holkner $'

import ctypes
from ctypes import *

import pyglet.lib

_lib = pyglet.lib.load_library('X11')

_int_types = (c_int16, c_int32)
if hasattr(ctypes, 'c_int64'):
    # Some builds of ctypes apparently do not have c_int64
    # defined; it's a pretty good bet that these builds do not
    # have 64-bit pointers.
    _int_types += (ctypes.c_int64,)
for t in _int_types:
    if sizeof(t) == sizeof(c_size_t):
        c_ptrdiff_t = t

class c_void(Structure):
    # c_void_p is a buggy return type, converting to int, so
    # POINTER(None) == c_void_p is actually written as
    # POINTER(c_void), so it can be treated as a real pointer.
    _fields_ = [('dummy', c_int)]


import pyglet.gl.glx

XlibSpecificationRelease = 6 	# /usr/include/X11/Xlib.h:39
X_PROTOCOL = 11 	# /usr/include/X11/X.h:58
X_PROTOCOL_REVISION = 0 	# /usr/include/X11/X.h:59
XID = pyglet.gl.glx.XID
Mask = c_ulong 	# /usr/include/X11/X.h:75
Atom = c_ulong 	# /usr/include/X11/X.h:79
VisualID = pyglet.gl.glx.VisualID
Time = c_ulong 	# /usr/include/X11/X.h:82
Window = pyglet.gl.glx.Window
Drawable = XID 	# /usr/include/X11/X.h:102
Font = pyglet.gl.glx.Font
Pixmap = pyglet.gl.glx.Pixmap
Cursor = XID 	# /usr/include/X11/X.h:108
Colormap = XID 	# /usr/include/X11/X.h:109
GContext = XID 	# /usr/include/X11/X.h:110
KeySym = XID 	# /usr/include/X11/X.h:111
KeyCode = c_ubyte 	# /usr/include/X11/X.h:113
None_ = 0 	# /usr/include/X11/X.h:120
ParentRelative = 1 	# /usr/include/X11/X.h:123
CopyFromParent = 0 	# /usr/include/X11/X.h:126
PointerWindow = 0 	# /usr/include/X11/X.h:131
InputFocus = 1 	# /usr/include/X11/X.h:132
PointerRoot = 1 	# /usr/include/X11/X.h:134
AnyPropertyType = 0 	# /usr/include/X11/X.h:136
AnyKey = 0 	# /usr/include/X11/X.h:138
AnyButton = 0 	# /usr/include/X11/X.h:140
AllTemporary = 0 	# /usr/include/X11/X.h:142
CurrentTime = 0 	# /usr/include/X11/X.h:144
NoSymbol = 0 	# /usr/include/X11/X.h:146
NoEventMask = 0 	# /usr/include/X11/X.h:155
KeyPressMask = 1 	# /usr/include/X11/X.h:156
KeyReleaseMask = 2 	# /usr/include/X11/X.h:157
ButtonPressMask = 4 	# /usr/include/X11/X.h:158
ButtonReleaseMask = 8 	# /usr/include/X11/X.h:159
EnterWindowMask = 16 	# /usr/include/X11/X.h:160
LeaveWindowMask = 32 	# /usr/include/X11/X.h:161
PointerMotionMask = 64 	# /usr/include/X11/X.h:162
PointerMotionHintMask = 128 	# /usr/include/X11/X.h:163
Button1MotionMask = 256 	# /usr/include/X11/X.h:164
Button2MotionMask = 512 	# /usr/include/X11/X.h:165
Button3MotionMask = 1024 	# /usr/include/X11/X.h:166
Button4MotionMask = 2048 	# /usr/include/X11/X.h:167
Button5MotionMask = 4096 	# /usr/include/X11/X.h:168
ButtonMotionMask = 8192 	# /usr/include/X11/X.h:169
KeymapStateMask = 16384 	# /usr/include/X11/X.h:170
ExposureMask = 32768 	# /usr/include/X11/X.h:171
VisibilityChangeMask = 65536 	# /usr/include/X11/X.h:172
StructureNotifyMask = 131072 	# /usr/include/X11/X.h:173
ResizeRedirectMask = 262144 	# /usr/include/X11/X.h:174
SubstructureNotifyMask = 524288 	# /usr/include/X11/X.h:175
SubstructureRedirectMask = 1048576 	# /usr/include/X11/X.h:176
FocusChangeMask = 2097152 	# /usr/include/X11/X.h:177
PropertyChangeMask = 4194304 	# /usr/include/X11/X.h:178
ColormapChangeMask = 8388608 	# /usr/include/X11/X.h:179
OwnerGrabButtonMask = 16777216 	# /usr/include/X11/X.h:180
KeyPress = 2 	# /usr/include/X11/X.h:186
KeyRelease = 3 	# /usr/include/X11/X.h:187
ButtonPress = 4 	# /usr/include/X11/X.h:188
ButtonRelease = 5 	# /usr/include/X11/X.h:189
MotionNotify = 6 	# /usr/include/X11/X.h:190
EnterNotify = 7 	# /usr/include/X11/X.h:191
LeaveNotify = 8 	# /usr/include/X11/X.h:192
FocusIn = 9 	# /usr/include/X11/X.h:193
FocusOut = 10 	# /usr/include/X11/X.h:194
KeymapNotify = 11 	# /usr/include/X11/X.h:195
Expose = 12 	# /usr/include/X11/X.h:196
GraphicsExpose = 13 	# /usr/include/X11/X.h:197
NoExpose = 14 	# /usr/include/X11/X.h:198
VisibilityNotify = 15 	# /usr/include/X11/X.h:199
CreateNotify = 16 	# /usr/include/X11/X.h:200
DestroyNotify = 17 	# /usr/include/X11/X.h:201
UnmapNotify = 18 	# /usr/include/X11/X.h:202
MapNotify = 19 	# /usr/include/X11/X.h:203
MapRequest = 20 	# /usr/include/X11/X.h:204
ReparentNotify = 21 	# /usr/include/X11/X.h:205
ConfigureNotify = 22 	# /usr/include/X11/X.h:206
ConfigureRequest = 23 	# /usr/include/X11/X.h:207
GravityNotify = 24 	# /usr/include/X11/X.h:208
ResizeRequest = 25 	# /usr/include/X11/X.h:209
CirculateNotify = 26 	# /usr/include/X11/X.h:210
CirculateRequest = 27 	# /usr/include/X11/X.h:211
PropertyNotify = 28 	# /usr/include/X11/X.h:212
SelectionClear = 29 	# /usr/include/X11/X.h:213
SelectionRequest = 30 	# /usr/include/X11/X.h:214
SelectionNotify = 31 	# /usr/include/X11/X.h:215
ColormapNotify = 32 	# /usr/include/X11/X.h:216
ClientMessage = 33 	# /usr/include/X11/X.h:217
MappingNotify = 34 	# /usr/include/X11/X.h:218
LASTEvent = 35 	# /usr/include/X11/X.h:219
ShiftMask = 1 	# /usr/include/X11/X.h:225
LockMask = 2 	# /usr/include/X11/X.h:226
ControlMask = 4 	# /usr/include/X11/X.h:227
Mod1Mask = 8 	# /usr/include/X11/X.h:228
Mod2Mask = 16 	# /usr/include/X11/X.h:229
Mod3Mask = 32 	# /usr/include/X11/X.h:230
Mod4Mask = 64 	# /usr/include/X11/X.h:231
Mod5Mask = 128 	# /usr/include/X11/X.h:232
ShiftMapIndex = 0 	# /usr/include/X11/X.h:237
LockMapIndex = 1 	# /usr/include/X11/X.h:238
ControlMapIndex = 2 	# /usr/include/X11/X.h:239
Mod1MapIndex = 3 	# /usr/include/X11/X.h:240
Mod2MapIndex = 4 	# /usr/include/X11/X.h:241
Mod3MapIndex = 5 	# /usr/include/X11/X.h:242
Mod4MapIndex = 6 	# /usr/include/X11/X.h:243
Mod5MapIndex = 7 	# /usr/include/X11/X.h:244
Button1Mask = 256 	# /usr/include/X11/X.h:250
Button2Mask = 512 	# /usr/include/X11/X.h:251
Button3Mask = 1024 	# /usr/include/X11/X.h:252
Button4Mask = 2048 	# /usr/include/X11/X.h:253
Button5Mask = 4096 	# /usr/include/X11/X.h:254
AnyModifier = 32768 	# /usr/include/X11/X.h:256
Button1 = 1 	# /usr/include/X11/X.h:263
Button2 = 2 	# /usr/include/X11/X.h:264
Button3 = 3 	# /usr/include/X11/X.h:265
Button4 = 4 	# /usr/include/X11/X.h:266
Button5 = 5 	# /usr/include/X11/X.h:267
NotifyNormal = 0 	# /usr/include/X11/X.h:271
NotifyGrab = 1 	# /usr/include/X11/X.h:272
NotifyUngrab = 2 	# /usr/include/X11/X.h:273
NotifyWhileGrabbed = 3 	# /usr/include/X11/X.h:274
NotifyHint = 1 	# /usr/include/X11/X.h:276
NotifyAncestor = 0 	# /usr/include/X11/X.h:280
NotifyVirtual = 1 	# /usr/include/X11/X.h:281
NotifyInferior = 2 	# /usr/include/X11/X.h:282
NotifyNonlinear = 3 	# /usr/include/X11/X.h:283
NotifyNonlinearVirtual = 4 	# /usr/include/X11/X.h:284
NotifyPointer = 5 	# /usr/include/X11/X.h:285
NotifyPointerRoot = 6 	# /usr/include/X11/X.h:286
NotifyDetailNone = 7 	# /usr/include/X11/X.h:287
VisibilityUnobscured = 0 	# /usr/include/X11/X.h:291
VisibilityPartiallyObscured = 1 	# /usr/include/X11/X.h:292
VisibilityFullyObscured = 2 	# /usr/include/X11/X.h:293
PlaceOnTop = 0 	# /usr/include/X11/X.h:297
PlaceOnBottom = 1 	# /usr/include/X11/X.h:298
FamilyInternet = 0 	# /usr/include/X11/X.h:302
FamilyDECnet = 1 	# /usr/include/X11/X.h:303
FamilyChaos = 2 	# /usr/include/X11/X.h:304
FamilyInternet6 = 6 	# /usr/include/X11/X.h:305
FamilyServerInterpreted = 5 	# /usr/include/X11/X.h:308
PropertyNewValue = 0 	# /usr/include/X11/X.h:312
PropertyDelete = 1 	# /usr/include/X11/X.h:313
ColormapUninstalled = 0 	# /usr/include/X11/X.h:317
ColormapInstalled = 1 	# /usr/include/X11/X.h:318
GrabModeSync = 0 	# /usr/include/X11/X.h:322
GrabModeAsync = 1 	# /usr/include/X11/X.h:323
GrabSuccess = 0 	# /usr/include/X11/X.h:327
AlreadyGrabbed = 1 	# /usr/include/X11/X.h:328
GrabInvalidTime = 2 	# /usr/include/X11/X.h:329
GrabNotViewable = 3 	# /usr/include/X11/X.h:330
GrabFrozen = 4 	# /usr/include/X11/X.h:331
AsyncPointer = 0 	# /usr/include/X11/X.h:335
SyncPointer = 1 	# /usr/include/X11/X.h:336
ReplayPointer = 2 	# /usr/include/X11/X.h:337
AsyncKeyboard = 3 	# /usr/include/X11/X.h:338
SyncKeyboard = 4 	# /usr/include/X11/X.h:339
ReplayKeyboard = 5 	# /usr/include/X11/X.h:340
AsyncBoth = 6 	# /usr/include/X11/X.h:341
SyncBoth = 7 	# /usr/include/X11/X.h:342
RevertToParent = 2 	# /usr/include/X11/X.h:348
Success = 0 	# /usr/include/X11/X.h:354
BadRequest = 1 	# /usr/include/X11/X.h:355
BadValue = 2 	# /usr/include/X11/X.h:356
BadWindow = 3 	# /usr/include/X11/X.h:357
BadPixmap = 4 	# /usr/include/X11/X.h:358
BadAtom = 5 	# /usr/include/X11/X.h:359
BadCursor = 6 	# /usr/include/X11/X.h:360
BadFont = 7 	# /usr/include/X11/X.h:361
BadMatch = 8 	# /usr/include/X11/X.h:362
BadDrawable = 9 	# /usr/include/X11/X.h:363
BadAccess = 10 	# /usr/include/X11/X.h:364
BadAlloc = 11 	# /usr/include/X11/X.h:373
BadColor = 12 	# /usr/include/X11/X.h:374
BadGC = 13 	# /usr/include/X11/X.h:375
BadIDChoice = 14 	# /usr/include/X11/X.h:376
BadName = 15 	# /usr/include/X11/X.h:377
BadLength = 16 	# /usr/include/X11/X.h:378
BadImplementation = 17 	# /usr/include/X11/X.h:379
FirstExtensionError = 128 	# /usr/include/X11/X.h:381
LastExtensionError = 255 	# /usr/include/X11/X.h:382
InputOutput = 1 	# /usr/include/X11/X.h:391
InputOnly = 2 	# /usr/include/X11/X.h:392
CWBackPixmap = 1 	# /usr/include/X11/X.h:396
CWBackPixel = 2 	# /usr/include/X11/X.h:397
CWBorderPixmap = 4 	# /usr/include/X11/X.h:398
CWBorderPixel = 8 	# /usr/include/X11/X.h:399
CWBitGravity = 16 	# /usr/include/X11/X.h:400
CWWinGravity = 32 	# /usr/include/X11/X.h:401
CWBackingStore = 64 	# /usr/include/X11/X.h:402
CWBackingPlanes = 128 	# /usr/include/X11/X.h:403
CWBackingPixel = 256 	# /usr/include/X11/X.h:404
CWOverrideRedirect = 512 	# /usr/include/X11/X.h:405
CWSaveUnder = 1024 	# /usr/include/X11/X.h:406
CWEventMask = 2048 	# /usr/include/X11/X.h:407
CWDontPropagate = 4096 	# /usr/include/X11/X.h:408
CWColormap = 8192 	# /usr/include/X11/X.h:409
CWCursor = 16384 	# /usr/include/X11/X.h:410
CWX = 1 	# /usr/include/X11/X.h:414
CWY = 2 	# /usr/include/X11/X.h:415
CWWidth = 4 	# /usr/include/X11/X.h:416
CWHeight = 8 	# /usr/include/X11/X.h:417
CWBorderWidth = 16 	# /usr/include/X11/X.h:418
CWSibling = 32 	# /usr/include/X11/X.h:419
CWStackMode = 64 	# /usr/include/X11/X.h:420
ForgetGravity = 0 	# /usr/include/X11/X.h:425
NorthWestGravity = 1 	# /usr/include/X11/X.h:426
NorthGravity = 2 	# /usr/include/X11/X.h:427
NorthEastGravity = 3 	# /usr/include/X11/X.h:428
WestGravity = 4 	# /usr/include/X11/X.h:429
CenterGravity = 5 	# /usr/include/X11/X.h:430
EastGravity = 6 	# /usr/include/X11/X.h:431
SouthWestGravity = 7 	# /usr/include/X11/X.h:432
SouthGravity = 8 	# /usr/include/X11/X.h:433
SouthEastGravity = 9 	# /usr/include/X11/X.h:434
StaticGravity = 10 	# /usr/include/X11/X.h:435
UnmapGravity = 0 	# /usr/include/X11/X.h:439
NotUseful = 0 	# /usr/include/X11/X.h:443
WhenMapped = 1 	# /usr/include/X11/X.h:444
Always = 2 	# /usr/include/X11/X.h:445
IsUnmapped = 0 	# /usr/include/X11/X.h:449
IsUnviewable = 1 	# /usr/include/X11/X.h:450
IsViewable = 2 	# /usr/include/X11/X.h:451
SetModeInsert = 0 	# /usr/include/X11/X.h:455
SetModeDelete = 1 	# /usr/include/X11/X.h:456
DestroyAll = 0 	# /usr/include/X11/X.h:460
RetainPermanent = 1 	# /usr/include/X11/X.h:461
RetainTemporary = 2 	# /usr/include/X11/X.h:462
Above = 0 	# /usr/include/X11/X.h:466
Below = 1 	# /usr/include/X11/X.h:467
TopIf = 2 	# /usr/include/X11/X.h:468
BottomIf = 3 	# /usr/include/X11/X.h:469
Opposite = 4 	# /usr/include/X11/X.h:470
RaiseLowest = 0 	# /usr/include/X11/X.h:474
LowerHighest = 1 	# /usr/include/X11/X.h:475
PropModeReplace = 0 	# /usr/include/X11/X.h:479
PropModePrepend = 1 	# /usr/include/X11/X.h:480
PropModeAppend = 2 	# /usr/include/X11/X.h:481
GXclear = 0 	# /usr/include/X11/X.h:489
GXand = 1 	# /usr/include/X11/X.h:490
GXandReverse = 2 	# /usr/include/X11/X.h:491
GXcopy = 3 	# /usr/include/X11/X.h:492
GXandInverted = 4 	# /usr/include/X11/X.h:493
GXnoop = 5 	# /usr/include/X11/X.h:494
GXxor = 6 	# /usr/include/X11/X.h:495
GXor = 7 	# /usr/include/X11/X.h:496
GXnor = 8 	# /usr/include/X11/X.h:497
GXequiv = 9 	# /usr/include/X11/X.h:498
GXinvert = 10 	# /usr/include/X11/X.h:499
GXorReverse = 11 	# /usr/include/X11/X.h:500
GXcopyInverted = 12 	# /usr/include/X11/X.h:501
GXorInverted = 13 	# /usr/include/X11/X.h:502
GXnand = 14 	# /usr/include/X11/X.h:503
GXset = 15 	# /usr/include/X11/X.h:504
LineSolid = 0 	# /usr/include/X11/X.h:508
LineOnOffDash = 1 	# /usr/include/X11/X.h:509
LineDoubleDash = 2 	# /usr/include/X11/X.h:510
CapNotLast = 0 	# /usr/include/X11/X.h:514
CapButt = 1 	# /usr/include/X11/X.h:515
CapRound = 2 	# /usr/include/X11/X.h:516
CapProjecting = 3 	# /usr/include/X11/X.h:517
JoinMiter = 0 	# /usr/include/X11/X.h:521
JoinRound = 1 	# /usr/include/X11/X.h:522
JoinBevel = 2 	# /usr/include/X11/X.h:523
FillSolid = 0 	# /usr/include/X11/X.h:527
FillTiled = 1 	# /usr/include/X11/X.h:528
FillStippled = 2 	# /usr/include/X11/X.h:529
FillOpaqueStippled = 3 	# /usr/include/X11/X.h:530
EvenOddRule = 0 	# /usr/include/X11/X.h:534
WindingRule = 1 	# /usr/include/X11/X.h:535
ClipByChildren = 0 	# /usr/include/X11/X.h:539
IncludeInferiors = 1 	# /usr/include/X11/X.h:540
Unsorted = 0 	# /usr/include/X11/X.h:544
YSorted = 1 	# /usr/include/X11/X.h:545
YXSorted = 2 	# /usr/include/X11/X.h:546
YXBanded = 3 	# /usr/include/X11/X.h:547
CoordModeOrigin = 0 	# /usr/include/X11/X.h:551
CoordModePrevious = 1 	# /usr/include/X11/X.h:552
Complex = 0 	# /usr/include/X11/X.h:556
Nonconvex = 1 	# /usr/include/X11/X.h:557
Convex = 2 	# /usr/include/X11/X.h:558
ArcChord = 0 	# /usr/include/X11/X.h:562
ArcPieSlice = 1 	# /usr/include/X11/X.h:563
GCFunction = 1 	# /usr/include/X11/X.h:568
GCPlaneMask = 2 	# /usr/include/X11/X.h:569
GCForeground = 4 	# /usr/include/X11/X.h:570
GCBackground = 8 	# /usr/include/X11/X.h:571
GCLineWidth = 16 	# /usr/include/X11/X.h:572
GCLineStyle = 32 	# /usr/include/X11/X.h:573
GCCapStyle = 64 	# /usr/include/X11/X.h:574
GCJoinStyle = 128 	# /usr/include/X11/X.h:575
GCFillStyle = 256 	# /usr/include/X11/X.h:576
GCFillRule = 512 	# /usr/include/X11/X.h:577
GCTile = 1024 	# /usr/include/X11/X.h:578
GCStipple = 2048 	# /usr/include/X11/X.h:579
GCTileStipXOrigin = 4096 	# /usr/include/X11/X.h:580
GCTileStipYOrigin = 8192 	# /usr/include/X11/X.h:581
GCFont = 16384 	# /usr/include/X11/X.h:582
GCSubwindowMode = 32768 	# /usr/include/X11/X.h:583
GCGraphicsExposures = 65536 	# /usr/include/X11/X.h:584
GCClipXOrigin = 131072 	# /usr/include/X11/X.h:585
GCClipYOrigin = 262144 	# /usr/include/X11/X.h:586
GCClipMask = 524288 	# /usr/include/X11/X.h:587
GCDashOffset = 1048576 	# /usr/include/X11/X.h:588
GCDashList = 2097152 	# /usr/include/X11/X.h:589
GCArcMode = 4194304 	# /usr/include/X11/X.h:590
GCLastBit = 22 	# /usr/include/X11/X.h:592
FontLeftToRight = 0 	# /usr/include/X11/X.h:599
FontRightToLeft = 1 	# /usr/include/X11/X.h:600
FontChange = 255 	# /usr/include/X11/X.h:602
XYBitmap = 0 	# /usr/include/X11/X.h:610
XYPixmap = 1 	# /usr/include/X11/X.h:611
ZPixmap = 2 	# /usr/include/X11/X.h:612
AllocNone = 0 	# /usr/include/X11/X.h:620
AllocAll = 1 	# /usr/include/X11/X.h:621
DoRed = 1 	# /usr/include/X11/X.h:626
DoGreen = 2 	# /usr/include/X11/X.h:627
DoBlue = 4 	# /usr/include/X11/X.h:628
CursorShape = 0 	# /usr/include/X11/X.h:636
TileShape = 1 	# /usr/include/X11/X.h:637
StippleShape = 2 	# /usr/include/X11/X.h:638
AutoRepeatModeOff = 0 	# /usr/include/X11/X.h:644
AutoRepeatModeOn = 1 	# /usr/include/X11/X.h:645
AutoRepeatModeDefault = 2 	# /usr/include/X11/X.h:646
LedModeOff = 0 	# /usr/include/X11/X.h:648
LedModeOn = 1 	# /usr/include/X11/X.h:649
KBKeyClickPercent = 1 	# /usr/include/X11/X.h:653
KBBellPercent = 2 	# /usr/include/X11/X.h:654
KBBellPitch = 4 	# /usr/include/X11/X.h:655
KBBellDuration = 8 	# /usr/include/X11/X.h:656
KBLed = 16 	# /usr/include/X11/X.h:657
KBLedMode = 32 	# /usr/include/X11/X.h:658
KBKey = 64 	# /usr/include/X11/X.h:659
KBAutoRepeatMode = 128 	# /usr/include/X11/X.h:660
MappingSuccess = 0 	# /usr/include/X11/X.h:662
MappingBusy = 1 	# /usr/include/X11/X.h:663
MappingFailed = 2 	# /usr/include/X11/X.h:664
MappingModifier = 0 	# /usr/include/X11/X.h:666
MappingKeyboard = 1 	# /usr/include/X11/X.h:667
MappingPointer = 2 	# /usr/include/X11/X.h:668
DontPreferBlanking = 0 	# /usr/include/X11/X.h:674
PreferBlanking = 1 	# /usr/include/X11/X.h:675
DefaultBlanking = 2 	# /usr/include/X11/X.h:676
DisableScreenSaver = 0 	# /usr/include/X11/X.h:678
DisableScreenInterval = 0 	# /usr/include/X11/X.h:679
DontAllowExposures = 0 	# /usr/include/X11/X.h:681
AllowExposures = 1 	# /usr/include/X11/X.h:682
DefaultExposures = 2 	# /usr/include/X11/X.h:683
ScreenSaverReset = 0 	# /usr/include/X11/X.h:687
ScreenSaverActive = 1 	# /usr/include/X11/X.h:688
HostInsert = 0 	# /usr/include/X11/X.h:696
HostDelete = 1 	# /usr/include/X11/X.h:697
EnableAccess = 1 	# /usr/include/X11/X.h:701
DisableAccess = 0 	# /usr/include/X11/X.h:702
StaticGray = 0 	# /usr/include/X11/X.h:708
GrayScale = 1 	# /usr/include/X11/X.h:709
StaticColor = 2 	# /usr/include/X11/X.h:710
PseudoColor = 3 	# /usr/include/X11/X.h:711
TrueColor = 4 	# /usr/include/X11/X.h:712
DirectColor = 5 	# /usr/include/X11/X.h:713
LSBFirst = 0 	# /usr/include/X11/X.h:718
MSBFirst = 1 	# /usr/include/X11/X.h:719
# /usr/include/X11/Xlib.h:94
_Xmblen = _lib._Xmblen
_Xmblen.restype = c_int
_Xmblen.argtypes = [c_char_p, c_int]

X_HAVE_UTF8_STRING = 1 	# /usr/include/X11/Xlib.h:106
XPointer = pyglet.gl.glx.XPointer
Bool = c_int 	# /usr/include/X11/Xlib.h:110
Status = c_int 	# /usr/include/X11/Xlib.h:111
True = 1 	# /usr/include/X11/Xlib.h:112
False = 0 	# /usr/include/X11/Xlib.h:113
QueuedAlready = 0 	# /usr/include/X11/Xlib.h:115
QueuedAfterReading = 1 	# /usr/include/X11/Xlib.h:116
QueuedAfterFlush = 2 	# /usr/include/X11/Xlib.h:117
XExtData = pyglet.gl.glx.XExtData
class struct_anon_15(Structure):
    __slots__ = [
        'extension',
        'major_opcode',
        'first_event',
        'first_error',
    ]
struct_anon_15._fields_ = [
    ('extension', c_int),
    ('major_opcode', c_int),
    ('first_event', c_int),
    ('first_error', c_int),
]

XExtCodes = struct_anon_15 	# /usr/include/X11/Xlib.h:197
class struct_anon_16(Structure):
    __slots__ = [
        'depth',
        'bits_per_pixel',
        'scanline_pad',
    ]
struct_anon_16._fields_ = [
    ('depth', c_int),
    ('bits_per_pixel', c_int),
    ('scanline_pad', c_int),
]

XPixmapFormatValues = struct_anon_16 	# /usr/include/X11/Xlib.h:207
class struct_anon_17(Structure):
    __slots__ = [
        'function',
        'plane_mask',
        'foreground',
        'background',
        'line_width',
        'line_style',
        'cap_style',
        'join_style',
        'fill_style',
        'fill_rule',
        'arc_mode',
        'tile',
        'stipple',
        'ts_x_origin',
        'ts_y_origin',
        'font',
        'subwindow_mode',
        'graphics_exposures',
        'clip_x_origin',
        'clip_y_origin',
        'clip_mask',
        'dash_offset',
        'dashes',
    ]
struct_anon_17._fields_ = [
    ('function', c_int),
    ('plane_mask', c_ulong),
    ('foreground', c_ulong),
    ('background', c_ulong),
    ('line_width', c_int),
    ('line_style', c_int),
    ('cap_style', c_int),
    ('join_style', c_int),
    ('fill_style', c_int),
    ('fill_rule', c_int),
    ('arc_mode', c_int),
    ('tile', Pixmap),
    ('stipple', Pixmap),
    ('ts_x_origin', c_int),
    ('ts_y_origin', c_int),
    ('font', Font),
    ('subwindow_mode', c_int),
    ('graphics_exposures', c_int),
    ('clip_x_origin', c_int),
    ('clip_y_origin', c_int),
    ('clip_mask', Pixmap),
    ('dash_offset', c_int),
    ('dashes', c_char),
]

XGCValues = struct_anon_17 	# /usr/include/X11/Xlib.h:239
class struct__XGC(Structure):
    __slots__ = [
    ]
struct__XGC._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__XGC(Structure):
    __slots__ = [
    ]
struct__XGC._fields_ = [
    ('_opaque_struct', c_int)
]

GC = POINTER(struct__XGC) 	# /usr/include/X11/Xlib.h:254
Visual = pyglet.gl.glx.Visual
class struct_anon_19(Structure):
    __slots__ = [
        'depth',
        'nvisuals',
        'visuals',
    ]
struct_anon_19._fields_ = [
    ('depth', c_int),
    ('nvisuals', c_int),
    ('visuals', POINTER(Visual)),
]

Depth = struct_anon_19 	# /usr/include/X11/Xlib.h:279
class struct_anon_20(Structure):
    __slots__ = [
        'ext_data',
        'display',
        'root',
        'width',
        'height',
        'mwidth',
        'mheight',
        'ndepths',
        'depths',
        'root_depth',
        'root_visual',
        'default_gc',
        'cmap',
        'white_pixel',
        'black_pixel',
        'max_maps',
        'min_maps',
        'backing_store',
        'save_unders',
        'root_input_mask',
    ]
class struct__XDisplay(Structure):
    __slots__ = [
    ]
struct__XDisplay._fields_ = [
    ('_opaque_struct', c_int)
]

struct_anon_20._fields_ = [
    ('ext_data', POINTER(XExtData)),
    ('display', POINTER(struct__XDisplay)),
    ('root', Window),
    ('width', c_int),
    ('height', c_int),
    ('mwidth', c_int),
    ('mheight', c_int),
    ('ndepths', c_int),
    ('depths', POINTER(Depth)),
    ('root_depth', c_int),
    ('root_visual', POINTER(Visual)),
    ('default_gc', GC),
    ('cmap', Colormap),
    ('white_pixel', c_ulong),
    ('black_pixel', c_ulong),
    ('max_maps', c_int),
    ('min_maps', c_int),
    ('backing_store', c_int),
    ('save_unders', c_int),
    ('root_input_mask', c_long),
]

Screen = struct_anon_20 	# /usr/include/X11/Xlib.h:307
class struct_anon_21(Structure):
    __slots__ = [
        'ext_data',
        'depth',
        'bits_per_pixel',
        'scanline_pad',
    ]
struct_anon_21._fields_ = [
    ('ext_data', POINTER(XExtData)),
    ('depth', c_int),
    ('bits_per_pixel', c_int),
    ('scanline_pad', c_int),
]

ScreenFormat = struct_anon_21 	# /usr/include/X11/Xlib.h:317
class struct_anon_22(Structure):
    __slots__ = [
        'background_pixmap',
        'background_pixel',
        'border_pixmap',
        'border_pixel',
        'bit_gravity',
        'win_gravity',
        'backing_store',
        'backing_planes',
        'backing_pixel',
        'save_under',
        'event_mask',
        'do_not_propagate_mask',
        'override_redirect',
        'colormap',
        'cursor',
    ]
struct_anon_22._fields_ = [
    ('background_pixmap', Pixmap),
    ('background_pixel', c_ulong),
    ('border_pixmap', Pixmap),
    ('border_pixel', c_ulong),
    ('bit_gravity', c_int),
    ('win_gravity', c_int),
    ('backing_store', c_int),
    ('backing_planes', c_ulong),
    ('backing_pixel', c_ulong),
    ('save_under', c_int),
    ('event_mask', c_long),
    ('do_not_propagate_mask', c_long),
    ('override_redirect', c_int),
    ('colormap', Colormap),
    ('cursor', Cursor),
]

XSetWindowAttributes = struct_anon_22 	# /usr/include/X11/Xlib.h:338
class struct_anon_23(Structure):
    __slots__ = [
        'x',
        'y',
        'width',
        'height',
        'border_width',
        'depth',
        'visual',
        'root',
        'class',
        'bit_gravity',
        'win_gravity',
        'backing_store',
        'backing_planes',
        'backing_pixel',
        'save_under',
        'colormap',
        'map_installed',
        'map_state',
        'all_event_masks',
        'your_event_mask',
        'do_not_propagate_mask',
        'override_redirect',
        'screen',
    ]
struct_anon_23._fields_ = [
    ('x', c_int),
    ('y', c_int),
    ('width', c_int),
    ('height', c_int),
    ('border_width', c_int),
    ('depth', c_int),
    ('visual', POINTER(Visual)),
    ('root', Window),
    ('class', c_int),
    ('bit_gravity', c_int),
    ('win_gravity', c_int),
    ('backing_store', c_int),
    ('backing_planes', c_ulong),
    ('backing_pixel', c_ulong),
    ('save_under', c_int),
    ('colormap', Colormap),
    ('map_installed', c_int),
    ('map_state', c_int),
    ('all_event_masks', c_long),
    ('your_event_mask', c_long),
    ('do_not_propagate_mask', c_long),
    ('override_redirect', c_int),
    ('screen', POINTER(Screen)),
]

XWindowAttributes = struct_anon_23 	# /usr/include/X11/Xlib.h:366
class struct_anon_24(Structure):
    __slots__ = [
        'family',
        'length',
        'address',
    ]
struct_anon_24._fields_ = [
    ('family', c_int),
    ('length', c_int),
    ('address', c_char_p),
]

XHostAddress = struct_anon_24 	# /usr/include/X11/Xlib.h:377
class struct_anon_25(Structure):
    __slots__ = [
        'typelength',
        'valuelength',
        'type',
        'value',
    ]
struct_anon_25._fields_ = [
    ('typelength', c_int),
    ('valuelength', c_int),
    ('type', c_char_p),
    ('value', c_char_p),
]

XServerInterpretedAddress = struct_anon_25 	# /usr/include/X11/Xlib.h:387
class struct__XImage(Structure):
    __slots__ = [
        'width',
        'height',
        'xoffset',
        'format',
        'data',
        'byte_order',
        'bitmap_unit',
        'bitmap_bit_order',
        'bitmap_pad',
        'depth',
        'bytes_per_line',
        'bits_per_pixel',
        'red_mask',
        'green_mask',
        'blue_mask',
        'obdata',
        'f',
    ]
class struct_funcs(Structure):
    __slots__ = [
        'create_image',
        'destroy_image',
        'get_pixel',
        'put_pixel',
        'sub_image',
        'add_pixel',
    ]
class struct__XDisplay(Structure):
    __slots__ = [
    ]
struct__XDisplay._fields_ = [
    ('_opaque_struct', c_int)
]

struct_funcs._fields_ = [
    ('create_image', POINTER(CFUNCTYPE(POINTER(struct__XImage), POINTER(struct__XDisplay), POINTER(Visual), c_uint, c_int, c_int, c_char_p, c_uint, c_uint, c_int, c_int))),
    ('destroy_image', POINTER(CFUNCTYPE(c_int, POINTER(struct__XImage)))),
    ('get_pixel', POINTER(CFUNCTYPE(c_ulong, POINTER(struct__XImage), c_int, c_int))),
    ('put_pixel', POINTER(CFUNCTYPE(c_int, POINTER(struct__XImage), c_int, c_int, c_ulong))),
    ('sub_image', POINTER(CFUNCTYPE(POINTER(struct__XImage), POINTER(struct__XImage), c_int, c_int, c_uint, c_uint))),
    ('add_pixel', POINTER(CFUNCTYPE(c_int, POINTER(struct__XImage), c_long))),
]

struct__XImage._fields_ = [
    ('width', c_int),
    ('height', c_int),
    ('xoffset', c_int),
    ('format', c_int),
    ('data', c_char_p),
    ('byte_order', c_int),
    ('bitmap_unit', c_int),
    ('bitmap_bit_order', c_int),
    ('bitmap_pad', c_int),
    ('depth', c_int),
    ('bytes_per_line', c_int),
    ('bits_per_pixel', c_int),
    ('red_mask', c_ulong),
    ('green_mask', c_ulong),
    ('blue_mask', c_ulong),
    ('obdata', XPointer),
    ('f', struct_funcs),
]

XImage = struct__XImage 	# /usr/include/X11/Xlib.h:426
class struct_anon_26(Structure):
    __slots__ = [
        'x',
        'y',
        'width',
        'height',
        'border_width',
        'sibling',
        'stack_mode',
    ]
struct_anon_26._fields_ = [
    ('x', c_int),
    ('y', c_int),
    ('width', c_int),
    ('height', c_int),
    ('border_width', c_int),
    ('sibling', Window),
    ('stack_mode', c_int),
]

XWindowChanges = struct_anon_26 	# /usr/include/X11/Xlib.h:437
class struct_anon_27(Structure):
    __slots__ = [
        'pixel',
        'red',
        'green',
        'blue',
        'flags',
        'pad',
    ]
struct_anon_27._fields_ = [
    ('pixel', c_ulong),
    ('red', c_ushort),
    ('green', c_ushort),
    ('blue', c_ushort),
    ('flags', c_char),
    ('pad', c_char),
]

XColor = struct_anon_27 	# /usr/include/X11/Xlib.h:447
class struct_anon_28(Structure):
    __slots__ = [
        'x1',
        'y1',
        'x2',
        'y2',
    ]
struct_anon_28._fields_ = [
    ('x1', c_short),
    ('y1', c_short),
    ('x2', c_short),
    ('y2', c_short),
]

XSegment = struct_anon_28 	# /usr/include/X11/Xlib.h:456
class struct_anon_29(Structure):
    __slots__ = [
        'x',
        'y',
    ]
struct_anon_29._fields_ = [
    ('x', c_short),
    ('y', c_short),
]

XPoint = struct_anon_29 	# /usr/include/X11/Xlib.h:460
class struct_anon_30(Structure):
    __slots__ = [
        'x',
        'y',
        'width',
        'height',
    ]
struct_anon_30._fields_ = [
    ('x', c_short),
    ('y', c_short),
    ('width', c_ushort),
    ('height', c_ushort),
]

XRectangle = struct_anon_30 	# /usr/include/X11/Xlib.h:465
class struct_anon_31(Structure):
    __slots__ = [
        'x',
        'y',
        'width',
        'height',
        'angle1',
        'angle2',
    ]
struct_anon_31._fields_ = [
    ('x', c_short),
    ('y', c_short),
    ('width', c_ushort),
    ('height', c_ushort),
    ('angle1', c_short),
    ('angle2', c_short),
]

XArc = struct_anon_31 	# /usr/include/X11/Xlib.h:471
class struct_anon_32(Structure):
    __slots__ = [
        'key_click_percent',
        'bell_percent',
        'bell_pitch',
        'bell_duration',
        'led',
        'led_mode',
        'key',
        'auto_repeat_mode',
    ]
struct_anon_32._fields_ = [
    ('key_click_percent', c_int),
    ('bell_percent', c_int),
    ('bell_pitch', c_int),
    ('bell_duration', c_int),
    ('led', c_int),
    ('led_mode', c_int),
    ('key', c_int),
    ('auto_repeat_mode', c_int),
]

XKeyboardControl = struct_anon_32 	# /usr/include/X11/Xlib.h:485
class struct_anon_33(Structure):
    __slots__ = [
        'key_click_percent',
        'bell_percent',
        'bell_pitch',
        'bell_duration',
        'led_mask',
        'global_auto_repeat',
        'auto_repeats',
    ]
struct_anon_33._fields_ = [
    ('key_click_percent', c_int),
    ('bell_percent', c_int),
    ('bell_pitch', c_uint),
    ('bell_duration', c_uint),
    ('led_mask', c_ulong),
    ('global_auto_repeat', c_int),
    ('auto_repeats', c_char * 32),
]

XKeyboardState = struct_anon_33 	# /usr/include/X11/Xlib.h:496
class struct_anon_34(Structure):
    __slots__ = [
        'time',
        'x',
        'y',
    ]
struct_anon_34._fields_ = [
    ('time', Time),
    ('x', c_short),
    ('y', c_short),
]

XTimeCoord = struct_anon_34 	# /usr/include/X11/Xlib.h:503
class struct_anon_35(Structure):
    __slots__ = [
        'max_keypermod',
        'modifiermap',
    ]
struct_anon_35._fields_ = [
    ('max_keypermod', c_int),
    ('modifiermap', POINTER(KeyCode)),
]

XModifierKeymap = struct_anon_35 	# /usr/include/X11/Xlib.h:510
Display = pyglet.gl.glx.Display
class struct_anon_36(Structure):
    __slots__ = [
        'ext_data',
        'private1',
        'fd',
        'private2',
        'proto_major_version',
        'proto_minor_version',
        'vendor',
        'private3',
        'private4',
        'private5',
        'private6',
        'resource_alloc',
        'byte_order',
        'bitmap_unit',
        'bitmap_pad',
        'bitmap_bit_order',
        'nformats',
        'pixmap_format',
        'private8',
        'release',
        'private9',
        'private10',
        'qlen',
        'last_request_read',
        'request',
        'private11',
        'private12',
        'private13',
        'private14',
        'max_request_size',
        'db',
        'private15',
        'display_name',
        'default_screen',
        'nscreens',
        'screens',
        'motion_buffer',
        'private16',
        'min_keycode',
        'max_keycode',
        'private17',
        'private18',
        'private19',
        'xdefaults',
    ]
class struct__XPrivate(Structure):
    __slots__ = [
    ]
struct__XPrivate._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__XDisplay(Structure):
    __slots__ = [
    ]
struct__XDisplay._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__XPrivate(Structure):
    __slots__ = [
    ]
struct__XPrivate._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__XPrivate(Structure):
    __slots__ = [
    ]
struct__XPrivate._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__XrmHashBucketRec(Structure):
    __slots__ = [
    ]
struct__XrmHashBucketRec._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__XDisplay(Structure):
    __slots__ = [
    ]
struct__XDisplay._fields_ = [
    ('_opaque_struct', c_int)
]

struct_anon_36._fields_ = [
    ('ext_data', POINTER(XExtData)),
    ('private1', POINTER(struct__XPrivate)),
    ('fd', c_int),
    ('private2', c_int),
    ('proto_major_version', c_int),
    ('proto_minor_version', c_int),
    ('vendor', c_char_p),
    ('private3', XID),
    ('private4', XID),
    ('private5', XID),
    ('private6', c_int),
    ('resource_alloc', POINTER(CFUNCTYPE(XID, POINTER(struct__XDisplay)))),
    ('byte_order', c_int),
    ('bitmap_unit', c_int),
    ('bitmap_pad', c_int),
    ('bitmap_bit_order', c_int),
    ('nformats', c_int),
    ('pixmap_format', POINTER(ScreenFormat)),
    ('private8', c_int),
    ('release', c_int),
    ('private9', POINTER(struct__XPrivate)),
    ('private10', POINTER(struct__XPrivate)),
    ('qlen', c_int),
    ('last_request_read', c_ulong),
    ('request', c_ulong),
    ('private11', XPointer),
    ('private12', XPointer),
    ('private13', XPointer),
    ('private14', XPointer),
    ('max_request_size', c_uint),
    ('db', POINTER(struct__XrmHashBucketRec)),
    ('private15', POINTER(CFUNCTYPE(c_int, POINTER(struct__XDisplay)))),
    ('display_name', c_char_p),
    ('default_screen', c_int),
    ('nscreens', c_int),
    ('screens', POINTER(Screen)),
    ('motion_buffer', c_ulong),
    ('private16', c_ulong),
    ('min_keycode', c_int),
    ('max_keycode', c_int),
    ('private17', XPointer),
    ('private18', XPointer),
    ('private19', c_int),
    ('xdefaults', c_char_p),
]

_XPrivDisplay = POINTER(struct_anon_36) 	# /usr/include/X11/Xlib.h:582
class struct_anon_37(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'window',
        'root',
        'subwindow',
        'time',
        'x',
        'y',
        'x_root',
        'y_root',
        'state',
        'keycode',
        'same_screen',
    ]
struct_anon_37._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('window', Window),
    ('root', Window),
    ('subwindow', Window),
    ('time', Time),
    ('x', c_int),
    ('y', c_int),
    ('x_root', c_int),
    ('y_root', c_int),
    ('state', c_uint),
    ('keycode', c_uint),
    ('same_screen', c_int),
]

XKeyEvent = struct_anon_37 	# /usr/include/X11/Xlib.h:603
XKeyPressedEvent = XKeyEvent 	# /usr/include/X11/Xlib.h:604
XKeyReleasedEvent = XKeyEvent 	# /usr/include/X11/Xlib.h:605
class struct_anon_38(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'window',
        'root',
        'subwindow',
        'time',
        'x',
        'y',
        'x_root',
        'y_root',
        'state',
        'button',
        'same_screen',
    ]
struct_anon_38._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('window', Window),
    ('root', Window),
    ('subwindow', Window),
    ('time', Time),
    ('x', c_int),
    ('y', c_int),
    ('x_root', c_int),
    ('y_root', c_int),
    ('state', c_uint),
    ('button', c_uint),
    ('same_screen', c_int),
]

XButtonEvent = struct_anon_38 	# /usr/include/X11/Xlib.h:621
XButtonPressedEvent = XButtonEvent 	# /usr/include/X11/Xlib.h:622
XButtonReleasedEvent = XButtonEvent 	# /usr/include/X11/Xlib.h:623
class struct_anon_39(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'window',
        'root',
        'subwindow',
        'time',
        'x',
        'y',
        'x_root',
        'y_root',
        'state',
        'is_hint',
        'same_screen',
    ]
struct_anon_39._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('window', Window),
    ('root', Window),
    ('subwindow', Window),
    ('time', Time),
    ('x', c_int),
    ('y', c_int),
    ('x_root', c_int),
    ('y_root', c_int),
    ('state', c_uint),
    ('is_hint', c_char),
    ('same_screen', c_int),
]

XMotionEvent = struct_anon_39 	# /usr/include/X11/Xlib.h:639
XPointerMovedEvent = XMotionEvent 	# /usr/include/X11/Xlib.h:640
class struct_anon_40(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'window',
        'root',
        'subwindow',
        'time',
        'x',
        'y',
        'x_root',
        'y_root',
        'mode',
        'detail',
        'same_screen',
        'focus',
        'state',
    ]
struct_anon_40._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('window', Window),
    ('root', Window),
    ('subwindow', Window),
    ('time', Time),
    ('x', c_int),
    ('y', c_int),
    ('x_root', c_int),
    ('y_root', c_int),
    ('mode', c_int),
    ('detail', c_int),
    ('same_screen', c_int),
    ('focus', c_int),
    ('state', c_uint),
]

XCrossingEvent = struct_anon_40 	# /usr/include/X11/Xlib.h:662
XEnterWindowEvent = XCrossingEvent 	# /usr/include/X11/Xlib.h:663
XLeaveWindowEvent = XCrossingEvent 	# /usr/include/X11/Xlib.h:664
class struct_anon_41(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'window',
        'mode',
        'detail',
    ]
struct_anon_41._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('window', Window),
    ('mode', c_int),
    ('detail', c_int),
]

XFocusChangeEvent = struct_anon_41 	# /usr/include/X11/Xlib.h:680
XFocusInEvent = XFocusChangeEvent 	# /usr/include/X11/Xlib.h:681
XFocusOutEvent = XFocusChangeEvent 	# /usr/include/X11/Xlib.h:682
class struct_anon_42(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'window',
        'key_vector',
    ]
struct_anon_42._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('window', Window),
    ('key_vector', c_char * 32),
]

XKeymapEvent = struct_anon_42 	# /usr/include/X11/Xlib.h:692
class struct_anon_43(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'window',
        'x',
        'y',
        'width',
        'height',
        'count',
    ]
struct_anon_43._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('window', Window),
    ('x', c_int),
    ('y', c_int),
    ('width', c_int),
    ('height', c_int),
    ('count', c_int),
]

XExposeEvent = struct_anon_43 	# /usr/include/X11/Xlib.h:703
class struct_anon_44(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'drawable',
        'x',
        'y',
        'width',
        'height',
        'count',
        'major_code',
        'minor_code',
    ]
struct_anon_44._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('drawable', Drawable),
    ('x', c_int),
    ('y', c_int),
    ('width', c_int),
    ('height', c_int),
    ('count', c_int),
    ('major_code', c_int),
    ('minor_code', c_int),
]

XGraphicsExposeEvent = struct_anon_44 	# /usr/include/X11/Xlib.h:716
class struct_anon_45(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'drawable',
        'major_code',
        'minor_code',
    ]
struct_anon_45._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('drawable', Drawable),
    ('major_code', c_int),
    ('minor_code', c_int),
]

XNoExposeEvent = struct_anon_45 	# /usr/include/X11/Xlib.h:726
class struct_anon_46(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'window',
        'state',
    ]
struct_anon_46._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('window', Window),
    ('state', c_int),
]

XVisibilityEvent = struct_anon_46 	# /usr/include/X11/Xlib.h:735
class struct_anon_47(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'parent',
        'window',
        'x',
        'y',
        'width',
        'height',
        'border_width',
        'override_redirect',
    ]
struct_anon_47._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('parent', Window),
    ('window', Window),
    ('x', c_int),
    ('y', c_int),
    ('width', c_int),
    ('height', c_int),
    ('border_width', c_int),
    ('override_redirect', c_int),
]

XCreateWindowEvent = struct_anon_47 	# /usr/include/X11/Xlib.h:748
class struct_anon_48(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'event',
        'window',
    ]
struct_anon_48._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('event', Window),
    ('window', Window),
]

XDestroyWindowEvent = struct_anon_48 	# /usr/include/X11/Xlib.h:757
class struct_anon_49(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'event',
        'window',
        'from_configure',
    ]
struct_anon_49._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('event', Window),
    ('window', Window),
    ('from_configure', c_int),
]

XUnmapEvent = struct_anon_49 	# /usr/include/X11/Xlib.h:767
class struct_anon_50(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'event',
        'window',
        'override_redirect',
    ]
struct_anon_50._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('event', Window),
    ('window', Window),
    ('override_redirect', c_int),
]

XMapEvent = struct_anon_50 	# /usr/include/X11/Xlib.h:777
class struct_anon_51(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'parent',
        'window',
    ]
struct_anon_51._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('parent', Window),
    ('window', Window),
]

XMapRequestEvent = struct_anon_51 	# /usr/include/X11/Xlib.h:786
class struct_anon_52(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'event',
        'window',
        'parent',
        'x',
        'y',
        'override_redirect',
    ]
struct_anon_52._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('event', Window),
    ('window', Window),
    ('parent', Window),
    ('x', c_int),
    ('y', c_int),
    ('override_redirect', c_int),
]

XReparentEvent = struct_anon_52 	# /usr/include/X11/Xlib.h:798
class struct_anon_53(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'event',
        'window',
        'x',
        'y',
        'width',
        'height',
        'border_width',
        'above',
        'override_redirect',
    ]
struct_anon_53._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('event', Window),
    ('window', Window),
    ('x', c_int),
    ('y', c_int),
    ('width', c_int),
    ('height', c_int),
    ('border_width', c_int),
    ('above', Window),
    ('override_redirect', c_int),
]

XConfigureEvent = struct_anon_53 	# /usr/include/X11/Xlib.h:812
class struct_anon_54(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'event',
        'window',
        'x',
        'y',
    ]
struct_anon_54._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('event', Window),
    ('window', Window),
    ('x', c_int),
    ('y', c_int),
]

XGravityEvent = struct_anon_54 	# /usr/include/X11/Xlib.h:822
class struct_anon_55(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'window',
        'width',
        'height',
    ]
struct_anon_55._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('window', Window),
    ('width', c_int),
    ('height', c_int),
]

XResizeRequestEvent = struct_anon_55 	# /usr/include/X11/Xlib.h:831
class struct_anon_56(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'parent',
        'window',
        'x',
        'y',
        'width',
        'height',
        'border_width',
        'above',
        'detail',
        'value_mask',
    ]
struct_anon_56._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('parent', Window),
    ('window', Window),
    ('x', c_int),
    ('y', c_int),
    ('width', c_int),
    ('height', c_int),
    ('border_width', c_int),
    ('above', Window),
    ('detail', c_int),
    ('value_mask', c_ulong),
]

XConfigureRequestEvent = struct_anon_56 	# /usr/include/X11/Xlib.h:846
class struct_anon_57(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'event',
        'window',
        'place',
    ]
struct_anon_57._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('event', Window),
    ('window', Window),
    ('place', c_int),
]

XCirculateEvent = struct_anon_57 	# /usr/include/X11/Xlib.h:856
class struct_anon_58(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'parent',
        'window',
        'place',
    ]
struct_anon_58._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('parent', Window),
    ('window', Window),
    ('place', c_int),
]

XCirculateRequestEvent = struct_anon_58 	# /usr/include/X11/Xlib.h:866
class struct_anon_59(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'window',
        'atom',
        'time',
        'state',
    ]
struct_anon_59._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('window', Window),
    ('atom', Atom),
    ('time', Time),
    ('state', c_int),
]

XPropertyEvent = struct_anon_59 	# /usr/include/X11/Xlib.h:877
class struct_anon_60(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'window',
        'selection',
        'time',
    ]
struct_anon_60._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('window', Window),
    ('selection', Atom),
    ('time', Time),
]

XSelectionClearEvent = struct_anon_60 	# /usr/include/X11/Xlib.h:887
class struct_anon_61(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'owner',
        'requestor',
        'selection',
        'target',
        'property',
        'time',
    ]
struct_anon_61._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('owner', Window),
    ('requestor', Window),
    ('selection', Atom),
    ('target', Atom),
    ('property', Atom),
    ('time', Time),
]

XSelectionRequestEvent = struct_anon_61 	# /usr/include/X11/Xlib.h:900
class struct_anon_62(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'requestor',
        'selection',
        'target',
        'property',
        'time',
    ]
struct_anon_62._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('requestor', Window),
    ('selection', Atom),
    ('target', Atom),
    ('property', Atom),
    ('time', Time),
]

XSelectionEvent = struct_anon_62 	# /usr/include/X11/Xlib.h:912
class struct_anon_63(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'window',
        'colormap',
        'new',
        'state',
    ]
struct_anon_63._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('window', Window),
    ('colormap', Colormap),
    ('new', c_int),
    ('state', c_int),
]

XColormapEvent = struct_anon_63 	# /usr/include/X11/Xlib.h:927
class struct_anon_64(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'window',
        'message_type',
        'format',
        'data',
    ]
class struct_anon_65(Union):
    __slots__ = [
        'b',
        's',
        'l',
    ]
struct_anon_65._fields_ = [
    ('b', c_char * 20),
    ('s', c_short * 10),
    ('l', c_long * 5),
]

struct_anon_64._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('window', Window),
    ('message_type', Atom),
    ('format', c_int),
    ('data', struct_anon_65),
]

XClientMessageEvent = struct_anon_64 	# /usr/include/X11/Xlib.h:942
class struct_anon_66(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'window',
        'request',
        'first_keycode',
        'count',
    ]
struct_anon_66._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('window', Window),
    ('request', c_int),
    ('first_keycode', c_int),
    ('count', c_int),
]

XMappingEvent = struct_anon_66 	# /usr/include/X11/Xlib.h:954
class struct_anon_67(Structure):
    __slots__ = [
        'type',
        'display',
        'resourceid',
        'serial',
        'error_code',
        'request_code',
        'minor_code',
    ]
struct_anon_67._fields_ = [
    ('type', c_int),
    ('display', POINTER(Display)),
    ('resourceid', XID),
    ('serial', c_ulong),
    ('error_code', c_ubyte),
    ('request_code', c_ubyte),
    ('minor_code', c_ubyte),
]

XErrorEvent = struct_anon_67 	# /usr/include/X11/Xlib.h:964
class struct_anon_68(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'window',
    ]
struct_anon_68._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', c_int),
    ('display', POINTER(Display)),
    ('window', Window),
]

XAnyEvent = struct_anon_68 	# /usr/include/X11/Xlib.h:972
class struct__XEvent(Union):
    __slots__ = [
        'type',
        'xany',
        'xkey',
        'xbutton',
        'xmotion',
        'xcrossing',
        'xfocus',
        'xexpose',
        'xgraphicsexpose',
        'xnoexpose',
        'xvisibility',
        'xcreatewindow',
        'xdestroywindow',
        'xunmap',
        'xmap',
        'xmaprequest',
        'xreparent',
        'xconfigure',
        'xgravity',
        'xresizerequest',
        'xconfigurerequest',
        'xcirculate',
        'xcirculaterequest',
        'xproperty',
        'xselectionclear',
        'xselectionrequest',
        'xselection',
        'xcolormap',
        'xclient',
        'xmapping',
        'xerror',
        'xkeymap',
        'pad',
    ]
struct__XEvent._fields_ = [
    ('type', c_int),
    ('xany', XAnyEvent),
    ('xkey', XKeyEvent),
    ('xbutton', XButtonEvent),
    ('xmotion', XMotionEvent),
    ('xcrossing', XCrossingEvent),
    ('xfocus', XFocusChangeEvent),
    ('xexpose', XExposeEvent),
    ('xgraphicsexpose', XGraphicsExposeEvent),
    ('xnoexpose', XNoExposeEvent),
    ('xvisibility', XVisibilityEvent),
    ('xcreatewindow', XCreateWindowEvent),
    ('xdestroywindow', XDestroyWindowEvent),
    ('xunmap', XUnmapEvent),
    ('xmap', XMapEvent),
    ('xmaprequest', XMapRequestEvent),
    ('xreparent', XReparentEvent),
    ('xconfigure', XConfigureEvent),
    ('xgravity', XGravityEvent),
    ('xresizerequest', XResizeRequestEvent),
    ('xconfigurerequest', XConfigureRequestEvent),
    ('xcirculate', XCirculateEvent),
    ('xcirculaterequest', XCirculateRequestEvent),
    ('xproperty', XPropertyEvent),
    ('xselectionclear', XSelectionClearEvent),
    ('xselectionrequest', XSelectionRequestEvent),
    ('xselection', XSelectionEvent),
    ('xcolormap', XColormapEvent),
    ('xclient', XClientMessageEvent),
    ('xmapping', XMappingEvent),
    ('xerror', XErrorEvent),
    ('xkeymap', XKeymapEvent),
    ('pad', c_long * 24),
]

XEvent = struct__XEvent 	# /usr/include/X11/Xlib.h:1012
class struct_anon_69(Structure):
    __slots__ = [
        'lbearing',
        'rbearing',
        'width',
        'ascent',
        'descent',
        'attributes',
    ]
struct_anon_69._fields_ = [
    ('lbearing', c_short),
    ('rbearing', c_short),
    ('width', c_short),
    ('ascent', c_short),
    ('descent', c_short),
    ('attributes', c_ushort),
]

XCharStruct = struct_anon_69 	# /usr/include/X11/Xlib.h:1027
class struct_anon_70(Structure):
    __slots__ = [
        'name',
        'card32',
    ]
struct_anon_70._fields_ = [
    ('name', Atom),
    ('card32', c_ulong),
]

XFontProp = struct_anon_70 	# /usr/include/X11/Xlib.h:1036
class struct_anon_71(Structure):
    __slots__ = [
        'ext_data',
        'fid',
        'direction',
        'min_char_or_byte2',
        'max_char_or_byte2',
        'min_byte1',
        'max_byte1',
        'all_chars_exist',
        'default_char',
        'n_properties',
        'properties',
        'min_bounds',
        'max_bounds',
        'per_char',
        'ascent',
        'descent',
    ]
struct_anon_71._fields_ = [
    ('ext_data', POINTER(XExtData)),
    ('fid', Font),
    ('direction', c_uint),
    ('min_char_or_byte2', c_uint),
    ('max_char_or_byte2', c_uint),
    ('min_byte1', c_uint),
    ('max_byte1', c_uint),
    ('all_chars_exist', c_int),
    ('default_char', c_uint),
    ('n_properties', c_int),
    ('properties', POINTER(XFontProp)),
    ('min_bounds', XCharStruct),
    ('max_bounds', XCharStruct),
    ('per_char', POINTER(XCharStruct)),
    ('ascent', c_int),
    ('descent', c_int),
]

XFontStruct = struct_anon_71 	# /usr/include/X11/Xlib.h:1055
class struct_anon_72(Structure):
    __slots__ = [
        'chars',
        'nchars',
        'delta',
        'font',
    ]
struct_anon_72._fields_ = [
    ('chars', c_char_p),
    ('nchars', c_int),
    ('delta', c_int),
    ('font', Font),
]

XTextItem = struct_anon_72 	# /usr/include/X11/Xlib.h:1065
class struct_anon_73(Structure):
    __slots__ = [
        'byte1',
        'byte2',
    ]
struct_anon_73._fields_ = [
    ('byte1', c_ubyte),
    ('byte2', c_ubyte),
]

XChar2b = struct_anon_73 	# /usr/include/X11/Xlib.h:1070
class struct_anon_74(Structure):
    __slots__ = [
        'chars',
        'nchars',
        'delta',
        'font',
    ]
struct_anon_74._fields_ = [
    ('chars', POINTER(XChar2b)),
    ('nchars', c_int),
    ('delta', c_int),
    ('font', Font),
]

XTextItem16 = struct_anon_74 	# /usr/include/X11/Xlib.h:1077
class struct_anon_75(Union):
    __slots__ = [
        'display',
        'gc',
        'visual',
        'screen',
        'pixmap_format',
        'font',
    ]
struct_anon_75._fields_ = [
    ('display', POINTER(Display)),
    ('gc', GC),
    ('visual', POINTER(Visual)),
    ('screen', POINTER(Screen)),
    ('pixmap_format', POINTER(ScreenFormat)),
    ('font', POINTER(XFontStruct)),
]

XEDataObject = struct_anon_75 	# /usr/include/X11/Xlib.h:1085
class struct_anon_76(Structure):
    __slots__ = [
        'max_ink_extent',
        'max_logical_extent',
    ]
struct_anon_76._fields_ = [
    ('max_ink_extent', XRectangle),
    ('max_logical_extent', XRectangle),
]

XFontSetExtents = struct_anon_76 	# /usr/include/X11/Xlib.h:1090
class struct__XOM(Structure):
    __slots__ = [
    ]
struct__XOM._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__XOM(Structure):
    __slots__ = [
    ]
struct__XOM._fields_ = [
    ('_opaque_struct', c_int)
]

XOM = POINTER(struct__XOM) 	# /usr/include/X11/Xlib.h:1096
class struct__XOC(Structure):
    __slots__ = [
    ]
struct__XOC._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__XOC(Structure):
    __slots__ = [
    ]
struct__XOC._fields_ = [
    ('_opaque_struct', c_int)
]

XOC = POINTER(struct__XOC) 	# /usr/include/X11/Xlib.h:1097
class struct__XOC(Structure):
    __slots__ = [
    ]
struct__XOC._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__XOC(Structure):
    __slots__ = [
    ]
struct__XOC._fields_ = [
    ('_opaque_struct', c_int)
]

XFontSet = POINTER(struct__XOC) 	# /usr/include/X11/Xlib.h:1097
class struct_anon_77(Structure):
    __slots__ = [
        'chars',
        'nchars',
        'delta',
        'font_set',
    ]
struct_anon_77._fields_ = [
    ('chars', c_char_p),
    ('nchars', c_int),
    ('delta', c_int),
    ('font_set', XFontSet),
]

XmbTextItem = struct_anon_77 	# /usr/include/X11/Xlib.h:1104
class struct_anon_78(Structure):
    __slots__ = [
        'chars',
        'nchars',
        'delta',
        'font_set',
    ]
struct_anon_78._fields_ = [
    ('chars', c_wchar_p),
    ('nchars', c_int),
    ('delta', c_int),
    ('font_set', XFontSet),
]

XwcTextItem = struct_anon_78 	# /usr/include/X11/Xlib.h:1111
class struct_anon_79(Structure):
    __slots__ = [
        'charset_count',
        'charset_list',
    ]
struct_anon_79._fields_ = [
    ('charset_count', c_int),
    ('charset_list', POINTER(c_char_p)),
]

XOMCharSetList = struct_anon_79 	# /usr/include/X11/Xlib.h:1127
enum_anon_80 = c_int
XOMOrientation_LTR_TTB = 0
XOMOrientation_RTL_TTB = 1
XOMOrientation_TTB_LTR = 2
XOMOrientation_TTB_RTL = 3
XOMOrientation_Context = 4
XOrientation = enum_anon_80 	# /usr/include/X11/Xlib.h:1135
class struct_anon_81(Structure):
    __slots__ = [
        'num_orientation',
        'orientation',
    ]
struct_anon_81._fields_ = [
    ('num_orientation', c_int),
    ('orientation', POINTER(XOrientation)),
]

XOMOrientation = struct_anon_81 	# /usr/include/X11/Xlib.h:1140
class struct_anon_82(Structure):
    __slots__ = [
        'num_font',
        'font_struct_list',
        'font_name_list',
    ]
struct_anon_82._fields_ = [
    ('num_font', c_int),
    ('font_struct_list', POINTER(POINTER(XFontStruct))),
    ('font_name_list', POINTER(c_char_p)),
]

XOMFontInfo = struct_anon_82 	# /usr/include/X11/Xlib.h:1146
class struct__XIM(Structure):
    __slots__ = [
    ]
struct__XIM._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__XIM(Structure):
    __slots__ = [
    ]
struct__XIM._fields_ = [
    ('_opaque_struct', c_int)
]

XIM = POINTER(struct__XIM) 	# /usr/include/X11/Xlib.h:1148
class struct__XIC(Structure):
    __slots__ = [
    ]
struct__XIC._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__XIC(Structure):
    __slots__ = [
    ]
struct__XIC._fields_ = [
    ('_opaque_struct', c_int)
]

XIC = POINTER(struct__XIC) 	# /usr/include/X11/Xlib.h:1149
XIMProc = CFUNCTYPE(None, XIM, XPointer, XPointer) 	# /usr/include/X11/Xlib.h:1151
XICProc = CFUNCTYPE(c_int, XIC, XPointer, XPointer) 	# /usr/include/X11/Xlib.h:1157
XIDProc = CFUNCTYPE(None, POINTER(Display), XPointer, XPointer) 	# /usr/include/X11/Xlib.h:1163
XIMStyle = c_ulong 	# /usr/include/X11/Xlib.h:1169
class struct_anon_83(Structure):
    __slots__ = [
        'count_styles',
        'supported_styles',
    ]
struct_anon_83._fields_ = [
    ('count_styles', c_ushort),
    ('supported_styles', POINTER(XIMStyle)),
]

XIMStyles = struct_anon_83 	# /usr/include/X11/Xlib.h:1174
XIMPreeditArea = 1 	# /usr/include/X11/Xlib.h:1176
XIMPreeditCallbacks = 2 	# /usr/include/X11/Xlib.h:1177
XIMPreeditPosition = 4 	# /usr/include/X11/Xlib.h:1178
XIMPreeditNothing = 8 	# /usr/include/X11/Xlib.h:1179
XIMPreeditNone = 16 	# /usr/include/X11/Xlib.h:1180
XIMStatusArea = 256 	# /usr/include/X11/Xlib.h:1181
XIMStatusCallbacks = 512 	# /usr/include/X11/Xlib.h:1182
XIMStatusNothing = 1024 	# /usr/include/X11/Xlib.h:1183
XIMStatusNone = 2048 	# /usr/include/X11/Xlib.h:1184
XBufferOverflow = -1 	# /usr/include/X11/Xlib.h:1230
XLookupNone = 1 	# /usr/include/X11/Xlib.h:1231
XLookupChars = 2 	# /usr/include/X11/Xlib.h:1232
XLookupKeySym = 3 	# /usr/include/X11/Xlib.h:1233
XLookupBoth = 4 	# /usr/include/X11/Xlib.h:1234
XVaNestedList = POINTER(None) 	# /usr/include/X11/Xlib.h:1236
class struct_anon_84(Structure):
    __slots__ = [
        'client_data',
        'callback',
    ]
struct_anon_84._fields_ = [
    ('client_data', XPointer),
    ('callback', XIMProc),
]

XIMCallback = struct_anon_84 	# /usr/include/X11/Xlib.h:1241
class struct_anon_85(Structure):
    __slots__ = [
        'client_data',
        'callback',
    ]
struct_anon_85._fields_ = [
    ('client_data', XPointer),
    ('callback', XICProc),
]

XICCallback = struct_anon_85 	# /usr/include/X11/Xlib.h:1246
XIMFeedback = c_ulong 	# /usr/include/X11/Xlib.h:1248
XIMReverse = 1 	# /usr/include/X11/Xlib.h:1250
XIMUnderline = 2 	# /usr/include/X11/Xlib.h:1251
XIMHighlight = 4 	# /usr/include/X11/Xlib.h:1252
XIMPrimary = 32 	# /usr/include/X11/Xlib.h:1253
XIMSecondary = 64 	# /usr/include/X11/Xlib.h:1254
XIMTertiary = 128 	# /usr/include/X11/Xlib.h:1255
XIMVisibleToForward = 256 	# /usr/include/X11/Xlib.h:1256
XIMVisibleToBackword = 512 	# /usr/include/X11/Xlib.h:1257
XIMVisibleToCenter = 1024 	# /usr/include/X11/Xlib.h:1258
class struct__XIMText(Structure):
    __slots__ = [
        'length',
        'feedback',
        'encoding_is_wchar',
        'string',
    ]
class struct_anon_86(Union):
    __slots__ = [
        'multi_byte',
        'wide_char',
    ]
struct_anon_86._fields_ = [
    ('multi_byte', c_char_p),
    ('wide_char', c_wchar_p),
]

struct__XIMText._fields_ = [
    ('length', c_ushort),
    ('feedback', POINTER(XIMFeedback)),
    ('encoding_is_wchar', c_int),
    ('string', struct_anon_86),
]

XIMText = struct__XIMText 	# /usr/include/X11/Xlib.h:1268
XIMPreeditState = c_ulong 	# /usr/include/X11/Xlib.h:1270
XIMPreeditUnKnown = 0 	# /usr/include/X11/Xlib.h:1272
XIMPreeditEnable = 1 	# /usr/include/X11/Xlib.h:1273
XIMPreeditDisable = 2 	# /usr/include/X11/Xlib.h:1274
class struct__XIMPreeditStateNotifyCallbackStruct(Structure):
    __slots__ = [
        'state',
    ]
struct__XIMPreeditStateNotifyCallbackStruct._fields_ = [
    ('state', XIMPreeditState),
]

XIMPreeditStateNotifyCallbackStruct = struct__XIMPreeditStateNotifyCallbackStruct 	# /usr/include/X11/Xlib.h:1278
XIMResetState = c_ulong 	# /usr/include/X11/Xlib.h:1280
XIMInitialState = 1 	# /usr/include/X11/Xlib.h:1282
XIMPreserveState = 2 	# /usr/include/X11/Xlib.h:1283
XIMStringConversionFeedback = c_ulong 	# /usr/include/X11/Xlib.h:1285
XIMStringConversionLeftEdge = 1 	# /usr/include/X11/Xlib.h:1287
XIMStringConversionRightEdge = 2 	# /usr/include/X11/Xlib.h:1288
XIMStringConversionTopEdge = 4 	# /usr/include/X11/Xlib.h:1289
XIMStringConversionBottomEdge = 8 	# /usr/include/X11/Xlib.h:1290
XIMStringConversionConcealed = 16 	# /usr/include/X11/Xlib.h:1291
XIMStringConversionWrapped = 32 	# /usr/include/X11/Xlib.h:1292
class struct__XIMStringConversionText(Structure):
    __slots__ = [
        'length',
        'feedback',
        'encoding_is_wchar',
        'string',
    ]
class struct_anon_87(Union):
    __slots__ = [
        'mbs',
        'wcs',
    ]
struct_anon_87._fields_ = [
    ('mbs', c_char_p),
    ('wcs', c_wchar_p),
]

struct__XIMStringConversionText._fields_ = [
    ('length', c_ushort),
    ('feedback', POINTER(XIMStringConversionFeedback)),
    ('encoding_is_wchar', c_int),
    ('string', struct_anon_87),
]

XIMStringConversionText = struct__XIMStringConversionText 	# /usr/include/X11/Xlib.h:1302
XIMStringConversionPosition = c_ushort 	# /usr/include/X11/Xlib.h:1304
XIMStringConversionType = c_ushort 	# /usr/include/X11/Xlib.h:1306
XIMStringConversionBuffer = 1 	# /usr/include/X11/Xlib.h:1308
XIMStringConversionLine = 2 	# /usr/include/X11/Xlib.h:1309
XIMStringConversionWord = 3 	# /usr/include/X11/Xlib.h:1310
XIMStringConversionChar = 4 	# /usr/include/X11/Xlib.h:1311
XIMStringConversionOperation = c_ushort 	# /usr/include/X11/Xlib.h:1313
XIMStringConversionSubstitution = 1 	# /usr/include/X11/Xlib.h:1315
XIMStringConversionRetrieval = 2 	# /usr/include/X11/Xlib.h:1316
enum_anon_88 = c_int
XIMForwardChar = 0
XIMBackwardChar = 1
XIMForwardWord = 2
XIMBackwardWord = 3
XIMCaretUp = 4
XIMCaretDown = 5
XIMNextLine = 6
XIMPreviousLine = 7
XIMLineStart = 8
XIMLineEnd = 9
XIMAbsolutePosition = 10
XIMDontChange = 11
XIMCaretDirection = enum_anon_88 	# /usr/include/X11/Xlib.h:1326
class struct__XIMStringConversionCallbackStruct(Structure):
    __slots__ = [
        'position',
        'direction',
        'operation',
        'factor',
        'text',
    ]
struct__XIMStringConversionCallbackStruct._fields_ = [
    ('position', XIMStringConversionPosition),
    ('direction', XIMCaretDirection),
    ('operation', XIMStringConversionOperation),
    ('factor', c_ushort),
    ('text', POINTER(XIMStringConversionText)),
]

XIMStringConversionCallbackStruct = struct__XIMStringConversionCallbackStruct 	# /usr/include/X11/Xlib.h:1334
class struct__XIMPreeditDrawCallbackStruct(Structure):
    __slots__ = [
        'caret',
        'chg_first',
        'chg_length',
        'text',
    ]
struct__XIMPreeditDrawCallbackStruct._fields_ = [
    ('caret', c_int),
    ('chg_first', c_int),
    ('chg_length', c_int),
    ('text', POINTER(XIMText)),
]

XIMPreeditDrawCallbackStruct = struct__XIMPreeditDrawCallbackStruct 	# /usr/include/X11/Xlib.h:1341
enum_anon_89 = c_int
XIMIsInvisible = 0
XIMIsPrimary = 1
XIMIsSecondary = 2
XIMCaretStyle = enum_anon_89 	# /usr/include/X11/Xlib.h:1347
class struct__XIMPreeditCaretCallbackStruct(Structure):
    __slots__ = [
        'position',
        'direction',
        'style',
    ]
struct__XIMPreeditCaretCallbackStruct._fields_ = [
    ('position', c_int),
    ('direction', XIMCaretDirection),
    ('style', XIMCaretStyle),
]

XIMPreeditCaretCallbackStruct = struct__XIMPreeditCaretCallbackStruct 	# /usr/include/X11/Xlib.h:1353
enum_anon_90 = c_int
XIMTextType = 0
XIMBitmapType = 1
XIMStatusDataType = enum_anon_90 	# /usr/include/X11/Xlib.h:1358
class struct__XIMStatusDrawCallbackStruct(Structure):
    __slots__ = [
        'type',
        'data',
    ]
class struct_anon_91(Union):
    __slots__ = [
        'text',
        'bitmap',
    ]
struct_anon_91._fields_ = [
    ('text', POINTER(XIMText)),
    ('bitmap', Pixmap),
]

struct__XIMStatusDrawCallbackStruct._fields_ = [
    ('type', XIMStatusDataType),
    ('data', struct_anon_91),
]

XIMStatusDrawCallbackStruct = struct__XIMStatusDrawCallbackStruct 	# /usr/include/X11/Xlib.h:1366
class struct__XIMHotKeyTrigger(Structure):
    __slots__ = [
        'keysym',
        'modifier',
        'modifier_mask',
    ]
struct__XIMHotKeyTrigger._fields_ = [
    ('keysym', KeySym),
    ('modifier', c_int),
    ('modifier_mask', c_int),
]

XIMHotKeyTrigger = struct__XIMHotKeyTrigger 	# /usr/include/X11/Xlib.h:1372
class struct__XIMHotKeyTriggers(Structure):
    __slots__ = [
        'num_hot_key',
        'key',
    ]
struct__XIMHotKeyTriggers._fields_ = [
    ('num_hot_key', c_int),
    ('key', POINTER(XIMHotKeyTrigger)),
]

XIMHotKeyTriggers = struct__XIMHotKeyTriggers 	# /usr/include/X11/Xlib.h:1377
XIMHotKeyState = c_ulong 	# /usr/include/X11/Xlib.h:1379
XIMHotKeyStateON = 1 	# /usr/include/X11/Xlib.h:1381
XIMHotKeyStateOFF = 2 	# /usr/include/X11/Xlib.h:1382
class struct_anon_92(Structure):
    __slots__ = [
        'count_values',
        'supported_values',
    ]
struct_anon_92._fields_ = [
    ('count_values', c_ushort),
    ('supported_values', POINTER(c_char_p)),
]

XIMValuesList = struct_anon_92 	# /usr/include/X11/Xlib.h:1387
# /usr/include/X11/Xlib.h:1397
XLoadQueryFont = _lib.XLoadQueryFont
XLoadQueryFont.restype = POINTER(XFontStruct)
XLoadQueryFont.argtypes = [POINTER(Display), c_char_p]

# /usr/include/X11/Xlib.h:1402
XQueryFont = _lib.XQueryFont
XQueryFont.restype = POINTER(XFontStruct)
XQueryFont.argtypes = [POINTER(Display), XID]

# /usr/include/X11/Xlib.h:1408
XGetMotionEvents = _lib.XGetMotionEvents
XGetMotionEvents.restype = POINTER(XTimeCoord)
XGetMotionEvents.argtypes = [POINTER(Display), Window, Time, Time, POINTER(c_int)]

# /usr/include/X11/Xlib.h:1416
XDeleteModifiermapEntry = _lib.XDeleteModifiermapEntry
XDeleteModifiermapEntry.restype = POINTER(XModifierKeymap)
XDeleteModifiermapEntry.argtypes = [POINTER(XModifierKeymap), KeyCode, c_int]

# /usr/include/X11/Xlib.h:1426
XGetModifierMapping = _lib.XGetModifierMapping
XGetModifierMapping.restype = POINTER(XModifierKeymap)
XGetModifierMapping.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:1430
XInsertModifiermapEntry = _lib.XInsertModifiermapEntry
XInsertModifiermapEntry.restype = POINTER(XModifierKeymap)
XInsertModifiermapEntry.argtypes = [POINTER(XModifierKeymap), KeyCode, c_int]

# /usr/include/X11/Xlib.h:1440
XNewModifiermap = _lib.XNewModifiermap
XNewModifiermap.restype = POINTER(XModifierKeymap)
XNewModifiermap.argtypes = [c_int]

# /usr/include/X11/Xlib.h:1444
XCreateImage = _lib.XCreateImage
XCreateImage.restype = POINTER(XImage)
XCreateImage.argtypes = [POINTER(Display), POINTER(Visual), c_uint, c_int, c_int, c_char_p, c_uint, c_uint, c_int, c_int]

# /usr/include/X11/Xlib.h:1456
XInitImage = _lib.XInitImage
XInitImage.restype = c_int
XInitImage.argtypes = [POINTER(XImage)]

# /usr/include/X11/Xlib.h:1459
XGetImage = _lib.XGetImage
XGetImage.restype = POINTER(XImage)
XGetImage.argtypes = [POINTER(Display), Drawable, c_int, c_int, c_uint, c_uint, c_ulong, c_int]

# /usr/include/X11/Xlib.h:1469
XGetSubImage = _lib.XGetSubImage
XGetSubImage.restype = POINTER(XImage)
XGetSubImage.argtypes = [POINTER(Display), Drawable, c_int, c_int, c_uint, c_uint, c_ulong, c_int, POINTER(XImage), c_int, c_int]

# /usr/include/X11/Xlib.h:1486
XOpenDisplay = _lib.XOpenDisplay
XOpenDisplay.restype = POINTER(Display)
XOpenDisplay.argtypes = [c_char_p]

# /usr/include/X11/Xlib.h:1490
XrmInitialize = _lib.XrmInitialize
XrmInitialize.restype = None
XrmInitialize.argtypes = []

# /usr/include/X11/Xlib.h:1494
XFetchBytes = _lib.XFetchBytes
XFetchBytes.restype = c_char_p
XFetchBytes.argtypes = [POINTER(Display), POINTER(c_int)]

# /usr/include/X11/Xlib.h:1498
XFetchBuffer = _lib.XFetchBuffer
XFetchBuffer.restype = c_char_p
XFetchBuffer.argtypes = [POINTER(Display), POINTER(c_int), c_int]

# /usr/include/X11/Xlib.h:1503
XGetAtomName = _lib.XGetAtomName
XGetAtomName.restype = c_char_p
XGetAtomName.argtypes = [POINTER(Display), Atom]

# /usr/include/X11/Xlib.h:1507
XGetAtomNames = _lib.XGetAtomNames
XGetAtomNames.restype = c_int
XGetAtomNames.argtypes = [POINTER(Display), POINTER(Atom), c_int, POINTER(c_char_p)]

# /usr/include/X11/Xlib.h:1513
XGetDefault = _lib.XGetDefault
XGetDefault.restype = c_char_p
XGetDefault.argtypes = [POINTER(Display), c_char_p, c_char_p]

# /usr/include/X11/Xlib.h:1518
XDisplayName = _lib.XDisplayName
XDisplayName.restype = c_char_p
XDisplayName.argtypes = [c_char_p]

# /usr/include/X11/Xlib.h:1521
XKeysymToString = _lib.XKeysymToString
XKeysymToString.restype = c_char_p
XKeysymToString.argtypes = [KeySym]

# /usr/include/X11/Xlib.h:1525
XSynchronize = _lib.XSynchronize
XSynchronize.restype = POINTER(CFUNCTYPE(c_int, POINTER(Display)))
XSynchronize.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:1531
XSetAfterFunction = _lib.XSetAfterFunction
XSetAfterFunction.restype = POINTER(CFUNCTYPE(c_int, POINTER(Display)))
XSetAfterFunction.argtypes = [POINTER(Display), CFUNCTYPE(c_int, POINTER(Display))]

# /usr/include/X11/Xlib.h:1539
XInternAtom = _lib.XInternAtom
XInternAtom.restype = Atom
XInternAtom.argtypes = [POINTER(Display), c_char_p, c_int]

# /usr/include/X11/Xlib.h:1544
XInternAtoms = _lib.XInternAtoms
XInternAtoms.restype = c_int
XInternAtoms.argtypes = [POINTER(Display), POINTER(c_char_p), c_int, c_int, POINTER(Atom)]

# /usr/include/X11/Xlib.h:1551
XCopyColormapAndFree = _lib.XCopyColormapAndFree
XCopyColormapAndFree.restype = Colormap
XCopyColormapAndFree.argtypes = [POINTER(Display), Colormap]

# /usr/include/X11/Xlib.h:1555
XCreateColormap = _lib.XCreateColormap
XCreateColormap.restype = Colormap
XCreateColormap.argtypes = [POINTER(Display), Window, POINTER(Visual), c_int]

# /usr/include/X11/Xlib.h:1561
XCreatePixmapCursor = _lib.XCreatePixmapCursor
XCreatePixmapCursor.restype = Cursor
XCreatePixmapCursor.argtypes = [POINTER(Display), Pixmap, Pixmap, POINTER(XColor), POINTER(XColor), c_uint, c_uint]

# /usr/include/X11/Xlib.h:1570
XCreateGlyphCursor = _lib.XCreateGlyphCursor
XCreateGlyphCursor.restype = Cursor
XCreateGlyphCursor.argtypes = [POINTER(Display), Font, Font, c_uint, c_uint, POINTER(XColor), POINTER(XColor)]

# /usr/include/X11/Xlib.h:1579
XCreateFontCursor = _lib.XCreateFontCursor
XCreateFontCursor.restype = Cursor
XCreateFontCursor.argtypes = [POINTER(Display), c_uint]

# /usr/include/X11/Xlib.h:1583
XLoadFont = _lib.XLoadFont
XLoadFont.restype = Font
XLoadFont.argtypes = [POINTER(Display), c_char_p]

# /usr/include/X11/Xlib.h:1587
XCreateGC = _lib.XCreateGC
XCreateGC.restype = GC
XCreateGC.argtypes = [POINTER(Display), Drawable, c_ulong, POINTER(XGCValues)]

# /usr/include/X11/Xlib.h:1593
XGContextFromGC = _lib.XGContextFromGC
XGContextFromGC.restype = GContext
XGContextFromGC.argtypes = [GC]

# /usr/include/X11/Xlib.h:1596
XFlushGC = _lib.XFlushGC
XFlushGC.restype = None
XFlushGC.argtypes = [POINTER(Display), GC]

# /usr/include/X11/Xlib.h:1600
XCreatePixmap = _lib.XCreatePixmap
XCreatePixmap.restype = Pixmap
XCreatePixmap.argtypes = [POINTER(Display), Drawable, c_uint, c_uint, c_uint]

# /usr/include/X11/Xlib.h:1607
XCreateBitmapFromData = _lib.XCreateBitmapFromData
XCreateBitmapFromData.restype = Pixmap
XCreateBitmapFromData.argtypes = [POINTER(Display), Drawable, c_char_p, c_uint, c_uint]

# /usr/include/X11/Xlib.h:1614
XCreatePixmapFromBitmapData = _lib.XCreatePixmapFromBitmapData
XCreatePixmapFromBitmapData.restype = Pixmap
XCreatePixmapFromBitmapData.argtypes = [POINTER(Display), Drawable, c_char_p, c_uint, c_uint, c_ulong, c_ulong, c_uint]

# /usr/include/X11/Xlib.h:1624
XCreateSimpleWindow = _lib.XCreateSimpleWindow
XCreateSimpleWindow.restype = Window
XCreateSimpleWindow.argtypes = [POINTER(Display), Window, c_int, c_int, c_uint, c_uint, c_uint, c_ulong, c_ulong]

# /usr/include/X11/Xlib.h:1635
XGetSelectionOwner = _lib.XGetSelectionOwner
XGetSelectionOwner.restype = Window
XGetSelectionOwner.argtypes = [POINTER(Display), Atom]

# /usr/include/X11/Xlib.h:1639
XCreateWindow = _lib.XCreateWindow
XCreateWindow.restype = Window
XCreateWindow.argtypes = [POINTER(Display), Window, c_int, c_int, c_uint, c_uint, c_uint, c_int, c_uint, POINTER(Visual), c_ulong, POINTER(XSetWindowAttributes)]

# /usr/include/X11/Xlib.h:1653
XListInstalledColormaps = _lib.XListInstalledColormaps
XListInstalledColormaps.restype = POINTER(Colormap)
XListInstalledColormaps.argtypes = [POINTER(Display), Window, POINTER(c_int)]

# /usr/include/X11/Xlib.h:1658
XListFonts = _lib.XListFonts
XListFonts.restype = POINTER(c_char_p)
XListFonts.argtypes = [POINTER(Display), c_char_p, c_int, POINTER(c_int)]

# /usr/include/X11/Xlib.h:1664
XListFontsWithInfo = _lib.XListFontsWithInfo
XListFontsWithInfo.restype = POINTER(c_char_p)
XListFontsWithInfo.argtypes = [POINTER(Display), c_char_p, c_int, POINTER(c_int), POINTER(POINTER(XFontStruct))]

# /usr/include/X11/Xlib.h:1671
XGetFontPath = _lib.XGetFontPath
XGetFontPath.restype = POINTER(c_char_p)
XGetFontPath.argtypes = [POINTER(Display), POINTER(c_int)]

# /usr/include/X11/Xlib.h:1675
XListExtensions = _lib.XListExtensions
XListExtensions.restype = POINTER(c_char_p)
XListExtensions.argtypes = [POINTER(Display), POINTER(c_int)]

# /usr/include/X11/Xlib.h:1679
XListProperties = _lib.XListProperties
XListProperties.restype = POINTER(Atom)
XListProperties.argtypes = [POINTER(Display), Window, POINTER(c_int)]

# /usr/include/X11/Xlib.h:1684
XListHosts = _lib.XListHosts
XListHosts.restype = POINTER(XHostAddress)
XListHosts.argtypes = [POINTER(Display), POINTER(c_int), POINTER(c_int)]

# /usr/include/X11/Xlib.h:1689
XKeycodeToKeysym = _lib.XKeycodeToKeysym
XKeycodeToKeysym.restype = KeySym
XKeycodeToKeysym.argtypes = [POINTER(Display), KeyCode, c_int]

# /usr/include/X11/Xlib.h:1698
XLookupKeysym = _lib.XLookupKeysym
XLookupKeysym.restype = KeySym
XLookupKeysym.argtypes = [POINTER(XKeyEvent), c_int]

# /usr/include/X11/Xlib.h:1702
XGetKeyboardMapping = _lib.XGetKeyboardMapping
XGetKeyboardMapping.restype = POINTER(KeySym)
XGetKeyboardMapping.argtypes = [POINTER(Display), KeyCode, c_int, POINTER(c_int)]

# /usr/include/X11/Xlib.h:1712
XStringToKeysym = _lib.XStringToKeysym
XStringToKeysym.restype = KeySym
XStringToKeysym.argtypes = [c_char_p]

# /usr/include/X11/Xlib.h:1715
XMaxRequestSize = _lib.XMaxRequestSize
XMaxRequestSize.restype = c_long
XMaxRequestSize.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:1718
XExtendedMaxRequestSize = _lib.XExtendedMaxRequestSize
XExtendedMaxRequestSize.restype = c_long
XExtendedMaxRequestSize.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:1721
XResourceManagerString = _lib.XResourceManagerString
XResourceManagerString.restype = c_char_p
XResourceManagerString.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:1724
XScreenResourceString = _lib.XScreenResourceString
XScreenResourceString.restype = c_char_p
XScreenResourceString.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:1727
XDisplayMotionBufferSize = _lib.XDisplayMotionBufferSize
XDisplayMotionBufferSize.restype = c_ulong
XDisplayMotionBufferSize.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:1730
XVisualIDFromVisual = _lib.XVisualIDFromVisual
XVisualIDFromVisual.restype = VisualID
XVisualIDFromVisual.argtypes = [POINTER(Visual)]

# /usr/include/X11/Xlib.h:1736
XInitThreads = _lib.XInitThreads
XInitThreads.restype = c_int
XInitThreads.argtypes = []

# /usr/include/X11/Xlib.h:1740
XLockDisplay = _lib.XLockDisplay
XLockDisplay.restype = None
XLockDisplay.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:1744
XUnlockDisplay = _lib.XUnlockDisplay
XUnlockDisplay.restype = None
XUnlockDisplay.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:1750
XInitExtension = _lib.XInitExtension
XInitExtension.restype = POINTER(XExtCodes)
XInitExtension.argtypes = [POINTER(Display), c_char_p]

# /usr/include/X11/Xlib.h:1755
XAddExtension = _lib.XAddExtension
XAddExtension.restype = POINTER(XExtCodes)
XAddExtension.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:1758
XFindOnExtensionList = _lib.XFindOnExtensionList
XFindOnExtensionList.restype = POINTER(XExtData)
XFindOnExtensionList.argtypes = [POINTER(POINTER(XExtData)), c_int]

# /usr/include/X11/Xlib.h:1762
XEHeadOfExtensionList = _lib.XEHeadOfExtensionList
XEHeadOfExtensionList.restype = POINTER(POINTER(XExtData))
XEHeadOfExtensionList.argtypes = [XEDataObject]

# /usr/include/X11/Xlib.h:1767
XRootWindow = _lib.XRootWindow
XRootWindow.restype = Window
XRootWindow.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:1771
XDefaultRootWindow = _lib.XDefaultRootWindow
XDefaultRootWindow.restype = Window
XDefaultRootWindow.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:1774
XRootWindowOfScreen = _lib.XRootWindowOfScreen
XRootWindowOfScreen.restype = Window
XRootWindowOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:1777
XDefaultVisual = _lib.XDefaultVisual
XDefaultVisual.restype = POINTER(Visual)
XDefaultVisual.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:1781
XDefaultVisualOfScreen = _lib.XDefaultVisualOfScreen
XDefaultVisualOfScreen.restype = POINTER(Visual)
XDefaultVisualOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:1784
XDefaultGC = _lib.XDefaultGC
XDefaultGC.restype = GC
XDefaultGC.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:1788
XDefaultGCOfScreen = _lib.XDefaultGCOfScreen
XDefaultGCOfScreen.restype = GC
XDefaultGCOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:1791
XBlackPixel = _lib.XBlackPixel
XBlackPixel.restype = c_ulong
XBlackPixel.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:1795
XWhitePixel = _lib.XWhitePixel
XWhitePixel.restype = c_ulong
XWhitePixel.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:1799
XAllPlanes = _lib.XAllPlanes
XAllPlanes.restype = c_ulong
XAllPlanes.argtypes = []

# /usr/include/X11/Xlib.h:1802
XBlackPixelOfScreen = _lib.XBlackPixelOfScreen
XBlackPixelOfScreen.restype = c_ulong
XBlackPixelOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:1805
XWhitePixelOfScreen = _lib.XWhitePixelOfScreen
XWhitePixelOfScreen.restype = c_ulong
XWhitePixelOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:1808
XNextRequest = _lib.XNextRequest
XNextRequest.restype = c_ulong
XNextRequest.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:1811
XLastKnownRequestProcessed = _lib.XLastKnownRequestProcessed
XLastKnownRequestProcessed.restype = c_ulong
XLastKnownRequestProcessed.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:1814
XServerVendor = _lib.XServerVendor
XServerVendor.restype = c_char_p
XServerVendor.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:1817
XDisplayString = _lib.XDisplayString
XDisplayString.restype = c_char_p
XDisplayString.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:1820
XDefaultColormap = _lib.XDefaultColormap
XDefaultColormap.restype = Colormap
XDefaultColormap.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:1824
XDefaultColormapOfScreen = _lib.XDefaultColormapOfScreen
XDefaultColormapOfScreen.restype = Colormap
XDefaultColormapOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:1827
XDisplayOfScreen = _lib.XDisplayOfScreen
XDisplayOfScreen.restype = POINTER(Display)
XDisplayOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:1830
XScreenOfDisplay = _lib.XScreenOfDisplay
XScreenOfDisplay.restype = POINTER(Screen)
XScreenOfDisplay.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:1834
XDefaultScreenOfDisplay = _lib.XDefaultScreenOfDisplay
XDefaultScreenOfDisplay.restype = POINTER(Screen)
XDefaultScreenOfDisplay.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:1837
XEventMaskOfScreen = _lib.XEventMaskOfScreen
XEventMaskOfScreen.restype = c_long
XEventMaskOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:1841
XScreenNumberOfScreen = _lib.XScreenNumberOfScreen
XScreenNumberOfScreen.restype = c_int
XScreenNumberOfScreen.argtypes = [POINTER(Screen)]

XErrorHandler = CFUNCTYPE(c_int, POINTER(Display), POINTER(XErrorEvent)) 	# /usr/include/X11/Xlib.h:1845
# /usr/include/X11/Xlib.h:1850
XSetErrorHandler = _lib.XSetErrorHandler
XSetErrorHandler.restype = XErrorHandler
XSetErrorHandler.argtypes = [XErrorHandler]

XIOErrorHandler = CFUNCTYPE(c_int, POINTER(Display)) 	# /usr/include/X11/Xlib.h:1855
# /usr/include/X11/Xlib.h:1859
XSetIOErrorHandler = _lib.XSetIOErrorHandler
XSetIOErrorHandler.restype = XIOErrorHandler
XSetIOErrorHandler.argtypes = [XIOErrorHandler]

# /usr/include/X11/Xlib.h:1864
XListPixmapFormats = _lib.XListPixmapFormats
XListPixmapFormats.restype = POINTER(XPixmapFormatValues)
XListPixmapFormats.argtypes = [POINTER(Display), POINTER(c_int)]

# /usr/include/X11/Xlib.h:1868
XListDepths = _lib.XListDepths
XListDepths.restype = POINTER(c_int)
XListDepths.argtypes = [POINTER(Display), c_int, POINTER(c_int)]

# /usr/include/X11/Xlib.h:1876
XReconfigureWMWindow = _lib.XReconfigureWMWindow
XReconfigureWMWindow.restype = c_int
XReconfigureWMWindow.argtypes = [POINTER(Display), Window, c_int, c_uint, POINTER(XWindowChanges)]

# /usr/include/X11/Xlib.h:1884
XGetWMProtocols = _lib.XGetWMProtocols
XGetWMProtocols.restype = c_int
XGetWMProtocols.argtypes = [POINTER(Display), Window, POINTER(POINTER(Atom)), POINTER(c_int)]

# /usr/include/X11/Xlib.h:1890
XSetWMProtocols = _lib.XSetWMProtocols
XSetWMProtocols.restype = c_int
XSetWMProtocols.argtypes = [POINTER(Display), Window, POINTER(Atom), c_int]

# /usr/include/X11/Xlib.h:1896
XIconifyWindow = _lib.XIconifyWindow
XIconifyWindow.restype = c_int
XIconifyWindow.argtypes = [POINTER(Display), Window, c_int]

# /usr/include/X11/Xlib.h:1901
XWithdrawWindow = _lib.XWithdrawWindow
XWithdrawWindow.restype = c_int
XWithdrawWindow.argtypes = [POINTER(Display), Window, c_int]

# /usr/include/X11/Xlib.h:1906
XGetCommand = _lib.XGetCommand
XGetCommand.restype = c_int
XGetCommand.argtypes = [POINTER(Display), Window, POINTER(POINTER(c_char_p)), POINTER(c_int)]

# /usr/include/X11/Xlib.h:1912
XGetWMColormapWindows = _lib.XGetWMColormapWindows
XGetWMColormapWindows.restype = c_int
XGetWMColormapWindows.argtypes = [POINTER(Display), Window, POINTER(POINTER(Window)), POINTER(c_int)]

# /usr/include/X11/Xlib.h:1918
XSetWMColormapWindows = _lib.XSetWMColormapWindows
XSetWMColormapWindows.restype = c_int
XSetWMColormapWindows.argtypes = [POINTER(Display), Window, POINTER(Window), c_int]

# /usr/include/X11/Xlib.h:1924
XFreeStringList = _lib.XFreeStringList
XFreeStringList.restype = None
XFreeStringList.argtypes = [POINTER(c_char_p)]

# /usr/include/X11/Xlib.h:1927
XSetTransientForHint = _lib.XSetTransientForHint
XSetTransientForHint.restype = c_int
XSetTransientForHint.argtypes = [POINTER(Display), Window, Window]

# /usr/include/X11/Xlib.h:1935
XActivateScreenSaver = _lib.XActivateScreenSaver
XActivateScreenSaver.restype = c_int
XActivateScreenSaver.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:1939
XAddHost = _lib.XAddHost
XAddHost.restype = c_int
XAddHost.argtypes = [POINTER(Display), POINTER(XHostAddress)]

# /usr/include/X11/Xlib.h:1944
XAddHosts = _lib.XAddHosts
XAddHosts.restype = c_int
XAddHosts.argtypes = [POINTER(Display), POINTER(XHostAddress), c_int]

class struct__XExtData(Structure):
    __slots__ = [
    ]
struct__XExtData._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/X11/Xlib.h:1950
XAddToExtensionList = _lib.XAddToExtensionList
XAddToExtensionList.restype = c_int
XAddToExtensionList.argtypes = [POINTER(POINTER(struct__XExtData)), POINTER(XExtData)]

# /usr/include/X11/Xlib.h:1955
XAddToSaveSet = _lib.XAddToSaveSet
XAddToSaveSet.restype = c_int
XAddToSaveSet.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xlib.h:1960
XAllocColor = _lib.XAllocColor
XAllocColor.restype = c_int
XAllocColor.argtypes = [POINTER(Display), Colormap, POINTER(XColor)]

# /usr/include/X11/Xlib.h:1966
XAllocColorCells = _lib.XAllocColorCells
XAllocColorCells.restype = c_int
XAllocColorCells.argtypes = [POINTER(Display), Colormap, c_int, POINTER(c_ulong), c_uint, POINTER(c_ulong), c_uint]

# /usr/include/X11/Xlib.h:1976
XAllocColorPlanes = _lib.XAllocColorPlanes
XAllocColorPlanes.restype = c_int
XAllocColorPlanes.argtypes = [POINTER(Display), Colormap, c_int, POINTER(c_ulong), c_int, c_int, c_int, c_int, POINTER(c_ulong), POINTER(c_ulong), POINTER(c_ulong)]

# /usr/include/X11/Xlib.h:1990
XAllocNamedColor = _lib.XAllocNamedColor
XAllocNamedColor.restype = c_int
XAllocNamedColor.argtypes = [POINTER(Display), Colormap, c_char_p, POINTER(XColor), POINTER(XColor)]

# /usr/include/X11/Xlib.h:1998
XAllowEvents = _lib.XAllowEvents
XAllowEvents.restype = c_int
XAllowEvents.argtypes = [POINTER(Display), c_int, Time]

# /usr/include/X11/Xlib.h:2004
XAutoRepeatOff = _lib.XAutoRepeatOff
XAutoRepeatOff.restype = c_int
XAutoRepeatOff.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2008
XAutoRepeatOn = _lib.XAutoRepeatOn
XAutoRepeatOn.restype = c_int
XAutoRepeatOn.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2012
XBell = _lib.XBell
XBell.restype = c_int
XBell.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:2017
XBitmapBitOrder = _lib.XBitmapBitOrder
XBitmapBitOrder.restype = c_int
XBitmapBitOrder.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2021
XBitmapPad = _lib.XBitmapPad
XBitmapPad.restype = c_int
XBitmapPad.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2025
XBitmapUnit = _lib.XBitmapUnit
XBitmapUnit.restype = c_int
XBitmapUnit.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2029
XCellsOfScreen = _lib.XCellsOfScreen
XCellsOfScreen.restype = c_int
XCellsOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:2033
XChangeActivePointerGrab = _lib.XChangeActivePointerGrab
XChangeActivePointerGrab.restype = c_int
XChangeActivePointerGrab.argtypes = [POINTER(Display), c_uint, Cursor, Time]

# /usr/include/X11/Xlib.h:2040
XChangeGC = _lib.XChangeGC
XChangeGC.restype = c_int
XChangeGC.argtypes = [POINTER(Display), GC, c_ulong, POINTER(XGCValues)]

# /usr/include/X11/Xlib.h:2047
XChangeKeyboardControl = _lib.XChangeKeyboardControl
XChangeKeyboardControl.restype = c_int
XChangeKeyboardControl.argtypes = [POINTER(Display), c_ulong, POINTER(XKeyboardControl)]

# /usr/include/X11/Xlib.h:2053
XChangeKeyboardMapping = _lib.XChangeKeyboardMapping
XChangeKeyboardMapping.restype = c_int
XChangeKeyboardMapping.argtypes = [POINTER(Display), c_int, c_int, POINTER(KeySym), c_int]

# /usr/include/X11/Xlib.h:2061
XChangePointerControl = _lib.XChangePointerControl
XChangePointerControl.restype = c_int
XChangePointerControl.argtypes = [POINTER(Display), c_int, c_int, c_int, c_int, c_int]

# /usr/include/X11/Xlib.h:2070
XChangeProperty = _lib.XChangeProperty
XChangeProperty.restype = c_int
XChangeProperty.argtypes = [POINTER(Display), Window, Atom, Atom, c_int, c_int, POINTER(c_ubyte), c_int]

# /usr/include/X11/Xlib.h:2081
XChangeSaveSet = _lib.XChangeSaveSet
XChangeSaveSet.restype = c_int
XChangeSaveSet.argtypes = [POINTER(Display), Window, c_int]

# /usr/include/X11/Xlib.h:2087
XChangeWindowAttributes = _lib.XChangeWindowAttributes
XChangeWindowAttributes.restype = c_int
XChangeWindowAttributes.argtypes = [POINTER(Display), Window, c_ulong, POINTER(XSetWindowAttributes)]

# /usr/include/X11/Xlib.h:2094
XCheckIfEvent = _lib.XCheckIfEvent
XCheckIfEvent.restype = c_int
XCheckIfEvent.argtypes = [POINTER(Display), POINTER(XEvent), CFUNCTYPE(c_int, POINTER(Display), POINTER(XEvent), XPointer), XPointer]

# /usr/include/X11/Xlib.h:2105
XCheckMaskEvent = _lib.XCheckMaskEvent
XCheckMaskEvent.restype = c_int
XCheckMaskEvent.argtypes = [POINTER(Display), c_long, POINTER(XEvent)]

# /usr/include/X11/Xlib.h:2111
XCheckTypedEvent = _lib.XCheckTypedEvent
XCheckTypedEvent.restype = c_int
XCheckTypedEvent.argtypes = [POINTER(Display), c_int, POINTER(XEvent)]

# /usr/include/X11/Xlib.h:2117
XCheckTypedWindowEvent = _lib.XCheckTypedWindowEvent
XCheckTypedWindowEvent.restype = c_int
XCheckTypedWindowEvent.argtypes = [POINTER(Display), Window, c_int, POINTER(XEvent)]

# /usr/include/X11/Xlib.h:2124
XCheckWindowEvent = _lib.XCheckWindowEvent
XCheckWindowEvent.restype = c_int
XCheckWindowEvent.argtypes = [POINTER(Display), Window, c_long, POINTER(XEvent)]

# /usr/include/X11/Xlib.h:2131
XCirculateSubwindows = _lib.XCirculateSubwindows
XCirculateSubwindows.restype = c_int
XCirculateSubwindows.argtypes = [POINTER(Display), Window, c_int]

# /usr/include/X11/Xlib.h:2137
XCirculateSubwindowsDown = _lib.XCirculateSubwindowsDown
XCirculateSubwindowsDown.restype = c_int
XCirculateSubwindowsDown.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xlib.h:2142
XCirculateSubwindowsUp = _lib.XCirculateSubwindowsUp
XCirculateSubwindowsUp.restype = c_int
XCirculateSubwindowsUp.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xlib.h:2147
XClearArea = _lib.XClearArea
XClearArea.restype = c_int
XClearArea.argtypes = [POINTER(Display), Window, c_int, c_int, c_uint, c_uint, c_int]

# /usr/include/X11/Xlib.h:2157
XClearWindow = _lib.XClearWindow
XClearWindow.restype = c_int
XClearWindow.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xlib.h:2162
XCloseDisplay = _lib.XCloseDisplay
XCloseDisplay.restype = c_int
XCloseDisplay.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2166
XConfigureWindow = _lib.XConfigureWindow
XConfigureWindow.restype = c_int
XConfigureWindow.argtypes = [POINTER(Display), Window, c_uint, POINTER(XWindowChanges)]

# /usr/include/X11/Xlib.h:2173
XConnectionNumber = _lib.XConnectionNumber
XConnectionNumber.restype = c_int
XConnectionNumber.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2177
XConvertSelection = _lib.XConvertSelection
XConvertSelection.restype = c_int
XConvertSelection.argtypes = [POINTER(Display), Atom, Atom, Atom, Window, Time]

# /usr/include/X11/Xlib.h:2186
XCopyArea = _lib.XCopyArea
XCopyArea.restype = c_int
XCopyArea.argtypes = [POINTER(Display), Drawable, Drawable, GC, c_int, c_int, c_uint, c_uint, c_int, c_int]

# /usr/include/X11/Xlib.h:2199
XCopyGC = _lib.XCopyGC
XCopyGC.restype = c_int
XCopyGC.argtypes = [POINTER(Display), GC, c_ulong, GC]

# /usr/include/X11/Xlib.h:2206
XCopyPlane = _lib.XCopyPlane
XCopyPlane.restype = c_int
XCopyPlane.argtypes = [POINTER(Display), Drawable, Drawable, GC, c_int, c_int, c_uint, c_uint, c_int, c_int, c_ulong]

# /usr/include/X11/Xlib.h:2220
XDefaultDepth = _lib.XDefaultDepth
XDefaultDepth.restype = c_int
XDefaultDepth.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:2225
XDefaultDepthOfScreen = _lib.XDefaultDepthOfScreen
XDefaultDepthOfScreen.restype = c_int
XDefaultDepthOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:2229
XDefaultScreen = _lib.XDefaultScreen
XDefaultScreen.restype = c_int
XDefaultScreen.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2233
XDefineCursor = _lib.XDefineCursor
XDefineCursor.restype = c_int
XDefineCursor.argtypes = [POINTER(Display), Window, Cursor]

# /usr/include/X11/Xlib.h:2239
XDeleteProperty = _lib.XDeleteProperty
XDeleteProperty.restype = c_int
XDeleteProperty.argtypes = [POINTER(Display), Window, Atom]

# /usr/include/X11/Xlib.h:2245
XDestroyWindow = _lib.XDestroyWindow
XDestroyWindow.restype = c_int
XDestroyWindow.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xlib.h:2250
XDestroySubwindows = _lib.XDestroySubwindows
XDestroySubwindows.restype = c_int
XDestroySubwindows.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xlib.h:2255
XDoesBackingStore = _lib.XDoesBackingStore
XDoesBackingStore.restype = c_int
XDoesBackingStore.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:2259
XDoesSaveUnders = _lib.XDoesSaveUnders
XDoesSaveUnders.restype = c_int
XDoesSaveUnders.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:2263
XDisableAccessControl = _lib.XDisableAccessControl
XDisableAccessControl.restype = c_int
XDisableAccessControl.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2268
XDisplayCells = _lib.XDisplayCells
XDisplayCells.restype = c_int
XDisplayCells.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:2273
XDisplayHeight = _lib.XDisplayHeight
XDisplayHeight.restype = c_int
XDisplayHeight.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:2278
XDisplayHeightMM = _lib.XDisplayHeightMM
XDisplayHeightMM.restype = c_int
XDisplayHeightMM.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:2283
XDisplayKeycodes = _lib.XDisplayKeycodes
XDisplayKeycodes.restype = c_int
XDisplayKeycodes.argtypes = [POINTER(Display), POINTER(c_int), POINTER(c_int)]

# /usr/include/X11/Xlib.h:2289
XDisplayPlanes = _lib.XDisplayPlanes
XDisplayPlanes.restype = c_int
XDisplayPlanes.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:2294
XDisplayWidth = _lib.XDisplayWidth
XDisplayWidth.restype = c_int
XDisplayWidth.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:2299
XDisplayWidthMM = _lib.XDisplayWidthMM
XDisplayWidthMM.restype = c_int
XDisplayWidthMM.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:2304
XDrawArc = _lib.XDrawArc
XDrawArc.restype = c_int
XDrawArc.argtypes = [POINTER(Display), Drawable, GC, c_int, c_int, c_uint, c_uint, c_int, c_int]

# /usr/include/X11/Xlib.h:2316
XDrawArcs = _lib.XDrawArcs
XDrawArcs.restype = c_int
XDrawArcs.argtypes = [POINTER(Display), Drawable, GC, POINTER(XArc), c_int]

# /usr/include/X11/Xlib.h:2324
XDrawImageString = _lib.XDrawImageString
XDrawImageString.restype = c_int
XDrawImageString.argtypes = [POINTER(Display), Drawable, GC, c_int, c_int, c_char_p, c_int]

# /usr/include/X11/Xlib.h:2334
XDrawImageString16 = _lib.XDrawImageString16
XDrawImageString16.restype = c_int
XDrawImageString16.argtypes = [POINTER(Display), Drawable, GC, c_int, c_int, POINTER(XChar2b), c_int]

# /usr/include/X11/Xlib.h:2344
XDrawLine = _lib.XDrawLine
XDrawLine.restype = c_int
XDrawLine.argtypes = [POINTER(Display), Drawable, GC, c_int, c_int, c_int, c_int]

# /usr/include/X11/Xlib.h:2354
XDrawLines = _lib.XDrawLines
XDrawLines.restype = c_int
XDrawLines.argtypes = [POINTER(Display), Drawable, GC, POINTER(XPoint), c_int, c_int]

# /usr/include/X11/Xlib.h:2363
XDrawPoint = _lib.XDrawPoint
XDrawPoint.restype = c_int
XDrawPoint.argtypes = [POINTER(Display), Drawable, GC, c_int, c_int]

# /usr/include/X11/Xlib.h:2371
XDrawPoints = _lib.XDrawPoints
XDrawPoints.restype = c_int
XDrawPoints.argtypes = [POINTER(Display), Drawable, GC, POINTER(XPoint), c_int, c_int]

# /usr/include/X11/Xlib.h:2380
XDrawRectangle = _lib.XDrawRectangle
XDrawRectangle.restype = c_int
XDrawRectangle.argtypes = [POINTER(Display), Drawable, GC, c_int, c_int, c_uint, c_uint]

# /usr/include/X11/Xlib.h:2390
XDrawRectangles = _lib.XDrawRectangles
XDrawRectangles.restype = c_int
XDrawRectangles.argtypes = [POINTER(Display), Drawable, GC, POINTER(XRectangle), c_int]

# /usr/include/X11/Xlib.h:2398
XDrawSegments = _lib.XDrawSegments
XDrawSegments.restype = c_int
XDrawSegments.argtypes = [POINTER(Display), Drawable, GC, POINTER(XSegment), c_int]

# /usr/include/X11/Xlib.h:2406
XDrawString = _lib.XDrawString
XDrawString.restype = c_int
XDrawString.argtypes = [POINTER(Display), Drawable, GC, c_int, c_int, c_char_p, c_int]

# /usr/include/X11/Xlib.h:2416
XDrawString16 = _lib.XDrawString16
XDrawString16.restype = c_int
XDrawString16.argtypes = [POINTER(Display), Drawable, GC, c_int, c_int, POINTER(XChar2b), c_int]

# /usr/include/X11/Xlib.h:2426
XDrawText = _lib.XDrawText
XDrawText.restype = c_int
XDrawText.argtypes = [POINTER(Display), Drawable, GC, c_int, c_int, POINTER(XTextItem), c_int]

# /usr/include/X11/Xlib.h:2436
XDrawText16 = _lib.XDrawText16
XDrawText16.restype = c_int
XDrawText16.argtypes = [POINTER(Display), Drawable, GC, c_int, c_int, POINTER(XTextItem16), c_int]

# /usr/include/X11/Xlib.h:2446
XEnableAccessControl = _lib.XEnableAccessControl
XEnableAccessControl.restype = c_int
XEnableAccessControl.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2450
XEventsQueued = _lib.XEventsQueued
XEventsQueued.restype = c_int
XEventsQueued.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:2455
XFetchName = _lib.XFetchName
XFetchName.restype = c_int
XFetchName.argtypes = [POINTER(Display), Window, POINTER(c_char_p)]

# /usr/include/X11/Xlib.h:2461
XFillArc = _lib.XFillArc
XFillArc.restype = c_int
XFillArc.argtypes = [POINTER(Display), Drawable, GC, c_int, c_int, c_uint, c_uint, c_int, c_int]

# /usr/include/X11/Xlib.h:2473
XFillArcs = _lib.XFillArcs
XFillArcs.restype = c_int
XFillArcs.argtypes = [POINTER(Display), Drawable, GC, POINTER(XArc), c_int]

# /usr/include/X11/Xlib.h:2481
XFillPolygon = _lib.XFillPolygon
XFillPolygon.restype = c_int
XFillPolygon.argtypes = [POINTER(Display), Drawable, GC, POINTER(XPoint), c_int, c_int, c_int]

# /usr/include/X11/Xlib.h:2491
XFillRectangle = _lib.XFillRectangle
XFillRectangle.restype = c_int
XFillRectangle.argtypes = [POINTER(Display), Drawable, GC, c_int, c_int, c_uint, c_uint]

# /usr/include/X11/Xlib.h:2501
XFillRectangles = _lib.XFillRectangles
XFillRectangles.restype = c_int
XFillRectangles.argtypes = [POINTER(Display), Drawable, GC, POINTER(XRectangle), c_int]

# /usr/include/X11/Xlib.h:2509
XFlush = _lib.XFlush
XFlush.restype = c_int
XFlush.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2513
XForceScreenSaver = _lib.XForceScreenSaver
XForceScreenSaver.restype = c_int
XForceScreenSaver.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:2518
XFree = _lib.XFree
XFree.restype = c_int
XFree.argtypes = [POINTER(None)]

# /usr/include/X11/Xlib.h:2522
XFreeColormap = _lib.XFreeColormap
XFreeColormap.restype = c_int
XFreeColormap.argtypes = [POINTER(Display), Colormap]

# /usr/include/X11/Xlib.h:2527
XFreeColors = _lib.XFreeColors
XFreeColors.restype = c_int
XFreeColors.argtypes = [POINTER(Display), Colormap, POINTER(c_ulong), c_int, c_ulong]

# /usr/include/X11/Xlib.h:2535
XFreeCursor = _lib.XFreeCursor
XFreeCursor.restype = c_int
XFreeCursor.argtypes = [POINTER(Display), Cursor]

# /usr/include/X11/Xlib.h:2540
XFreeExtensionList = _lib.XFreeExtensionList
XFreeExtensionList.restype = c_int
XFreeExtensionList.argtypes = [POINTER(c_char_p)]

# /usr/include/X11/Xlib.h:2544
XFreeFont = _lib.XFreeFont
XFreeFont.restype = c_int
XFreeFont.argtypes = [POINTER(Display), POINTER(XFontStruct)]

# /usr/include/X11/Xlib.h:2549
XFreeFontInfo = _lib.XFreeFontInfo
XFreeFontInfo.restype = c_int
XFreeFontInfo.argtypes = [POINTER(c_char_p), POINTER(XFontStruct), c_int]

# /usr/include/X11/Xlib.h:2555
XFreeFontNames = _lib.XFreeFontNames
XFreeFontNames.restype = c_int
XFreeFontNames.argtypes = [POINTER(c_char_p)]

# /usr/include/X11/Xlib.h:2559
XFreeFontPath = _lib.XFreeFontPath
XFreeFontPath.restype = c_int
XFreeFontPath.argtypes = [POINTER(c_char_p)]

# /usr/include/X11/Xlib.h:2563
XFreeGC = _lib.XFreeGC
XFreeGC.restype = c_int
XFreeGC.argtypes = [POINTER(Display), GC]

# /usr/include/X11/Xlib.h:2568
XFreeModifiermap = _lib.XFreeModifiermap
XFreeModifiermap.restype = c_int
XFreeModifiermap.argtypes = [POINTER(XModifierKeymap)]

# /usr/include/X11/Xlib.h:2572
XFreePixmap = _lib.XFreePixmap
XFreePixmap.restype = c_int
XFreePixmap.argtypes = [POINTER(Display), Pixmap]

# /usr/include/X11/Xlib.h:2577
XGeometry = _lib.XGeometry
XGeometry.restype = c_int
XGeometry.argtypes = [POINTER(Display), c_int, c_char_p, c_char_p, c_uint, c_uint, c_uint, c_int, c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int)]

# /usr/include/X11/Xlib.h:2593
XGetErrorDatabaseText = _lib.XGetErrorDatabaseText
XGetErrorDatabaseText.restype = c_int
XGetErrorDatabaseText.argtypes = [POINTER(Display), c_char_p, c_char_p, c_char_p, c_char_p, c_int]

# /usr/include/X11/Xlib.h:2602
XGetErrorText = _lib.XGetErrorText
XGetErrorText.restype = c_int
XGetErrorText.argtypes = [POINTER(Display), c_int, c_char_p, c_int]

# /usr/include/X11/Xlib.h:2609
XGetFontProperty = _lib.XGetFontProperty
XGetFontProperty.restype = c_int
XGetFontProperty.argtypes = [POINTER(XFontStruct), Atom, POINTER(c_ulong)]

# /usr/include/X11/Xlib.h:2615
XGetGCValues = _lib.XGetGCValues
XGetGCValues.restype = c_int
XGetGCValues.argtypes = [POINTER(Display), GC, c_ulong, POINTER(XGCValues)]

# /usr/include/X11/Xlib.h:2622
XGetGeometry = _lib.XGetGeometry
XGetGeometry.restype = c_int
XGetGeometry.argtypes = [POINTER(Display), Drawable, POINTER(Window), POINTER(c_int), POINTER(c_int), POINTER(c_uint), POINTER(c_uint), POINTER(c_uint), POINTER(c_uint)]

# /usr/include/X11/Xlib.h:2634
XGetIconName = _lib.XGetIconName
XGetIconName.restype = c_int
XGetIconName.argtypes = [POINTER(Display), Window, POINTER(c_char_p)]

# /usr/include/X11/Xlib.h:2640
XGetInputFocus = _lib.XGetInputFocus
XGetInputFocus.restype = c_int
XGetInputFocus.argtypes = [POINTER(Display), POINTER(Window), POINTER(c_int)]

# /usr/include/X11/Xlib.h:2646
XGetKeyboardControl = _lib.XGetKeyboardControl
XGetKeyboardControl.restype = c_int
XGetKeyboardControl.argtypes = [POINTER(Display), POINTER(XKeyboardState)]

# /usr/include/X11/Xlib.h:2651
XGetPointerControl = _lib.XGetPointerControl
XGetPointerControl.restype = c_int
XGetPointerControl.argtypes = [POINTER(Display), POINTER(c_int), POINTER(c_int), POINTER(c_int)]

# /usr/include/X11/Xlib.h:2658
XGetPointerMapping = _lib.XGetPointerMapping
XGetPointerMapping.restype = c_int
XGetPointerMapping.argtypes = [POINTER(Display), POINTER(c_ubyte), c_int]

# /usr/include/X11/Xlib.h:2664
XGetScreenSaver = _lib.XGetScreenSaver
XGetScreenSaver.restype = c_int
XGetScreenSaver.argtypes = [POINTER(Display), POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int)]

# /usr/include/X11/Xlib.h:2672
XGetTransientForHint = _lib.XGetTransientForHint
XGetTransientForHint.restype = c_int
XGetTransientForHint.argtypes = [POINTER(Display), Window, POINTER(Window)]

# /usr/include/X11/Xlib.h:2678
XGetWindowProperty = _lib.XGetWindowProperty
XGetWindowProperty.restype = c_int
XGetWindowProperty.argtypes = [POINTER(Display), Window, Atom, c_long, c_long, c_int, Atom, POINTER(Atom), POINTER(c_int), POINTER(c_ulong), POINTER(c_ulong), POINTER(POINTER(c_ubyte))]

# /usr/include/X11/Xlib.h:2693
XGetWindowAttributes = _lib.XGetWindowAttributes
XGetWindowAttributes.restype = c_int
XGetWindowAttributes.argtypes = [POINTER(Display), Window, POINTER(XWindowAttributes)]

# /usr/include/X11/Xlib.h:2699
XGrabButton = _lib.XGrabButton
XGrabButton.restype = c_int
XGrabButton.argtypes = [POINTER(Display), c_uint, c_uint, Window, c_int, c_uint, c_int, c_int, Window, Cursor]

# /usr/include/X11/Xlib.h:2712
XGrabKey = _lib.XGrabKey
XGrabKey.restype = c_int
XGrabKey.argtypes = [POINTER(Display), c_int, c_uint, Window, c_int, c_int, c_int]

# /usr/include/X11/Xlib.h:2722
XGrabKeyboard = _lib.XGrabKeyboard
XGrabKeyboard.restype = c_int
XGrabKeyboard.argtypes = [POINTER(Display), Window, c_int, c_int, c_int, Time]

# /usr/include/X11/Xlib.h:2731
XGrabPointer = _lib.XGrabPointer
XGrabPointer.restype = c_int
XGrabPointer.argtypes = [POINTER(Display), Window, c_int, c_uint, c_int, c_int, Window, Cursor, Time]

# /usr/include/X11/Xlib.h:2743
XGrabServer = _lib.XGrabServer
XGrabServer.restype = c_int
XGrabServer.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2747
XHeightMMOfScreen = _lib.XHeightMMOfScreen
XHeightMMOfScreen.restype = c_int
XHeightMMOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:2751
XHeightOfScreen = _lib.XHeightOfScreen
XHeightOfScreen.restype = c_int
XHeightOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:2755
XIfEvent = _lib.XIfEvent
XIfEvent.restype = c_int
XIfEvent.argtypes = [POINTER(Display), POINTER(XEvent), CFUNCTYPE(c_int, POINTER(Display), POINTER(XEvent), XPointer), XPointer]

# /usr/include/X11/Xlib.h:2766
XImageByteOrder = _lib.XImageByteOrder
XImageByteOrder.restype = c_int
XImageByteOrder.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2770
XInstallColormap = _lib.XInstallColormap
XInstallColormap.restype = c_int
XInstallColormap.argtypes = [POINTER(Display), Colormap]

# /usr/include/X11/Xlib.h:2775
XKeysymToKeycode = _lib.XKeysymToKeycode
XKeysymToKeycode.restype = KeyCode
XKeysymToKeycode.argtypes = [POINTER(Display), KeySym]

# /usr/include/X11/Xlib.h:2780
XKillClient = _lib.XKillClient
XKillClient.restype = c_int
XKillClient.argtypes = [POINTER(Display), XID]

# /usr/include/X11/Xlib.h:2785
XLookupColor = _lib.XLookupColor
XLookupColor.restype = c_int
XLookupColor.argtypes = [POINTER(Display), Colormap, c_char_p, POINTER(XColor), POINTER(XColor)]

# /usr/include/X11/Xlib.h:2793
XLowerWindow = _lib.XLowerWindow
XLowerWindow.restype = c_int
XLowerWindow.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xlib.h:2798
XMapRaised = _lib.XMapRaised
XMapRaised.restype = c_int
XMapRaised.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xlib.h:2803
XMapSubwindows = _lib.XMapSubwindows
XMapSubwindows.restype = c_int
XMapSubwindows.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xlib.h:2808
XMapWindow = _lib.XMapWindow
XMapWindow.restype = c_int
XMapWindow.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xlib.h:2813
XMaskEvent = _lib.XMaskEvent
XMaskEvent.restype = c_int
XMaskEvent.argtypes = [POINTER(Display), c_long, POINTER(XEvent)]

# /usr/include/X11/Xlib.h:2819
XMaxCmapsOfScreen = _lib.XMaxCmapsOfScreen
XMaxCmapsOfScreen.restype = c_int
XMaxCmapsOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:2823
XMinCmapsOfScreen = _lib.XMinCmapsOfScreen
XMinCmapsOfScreen.restype = c_int
XMinCmapsOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:2827
XMoveResizeWindow = _lib.XMoveResizeWindow
XMoveResizeWindow.restype = c_int
XMoveResizeWindow.argtypes = [POINTER(Display), Window, c_int, c_int, c_uint, c_uint]

# /usr/include/X11/Xlib.h:2836
XMoveWindow = _lib.XMoveWindow
XMoveWindow.restype = c_int
XMoveWindow.argtypes = [POINTER(Display), Window, c_int, c_int]

# /usr/include/X11/Xlib.h:2843
XNextEvent = _lib.XNextEvent
XNextEvent.restype = c_int
XNextEvent.argtypes = [POINTER(Display), POINTER(XEvent)]

# /usr/include/X11/Xlib.h:2848
XNoOp = _lib.XNoOp
XNoOp.restype = c_int
XNoOp.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2852
XParseColor = _lib.XParseColor
XParseColor.restype = c_int
XParseColor.argtypes = [POINTER(Display), Colormap, c_char_p, POINTER(XColor)]

# /usr/include/X11/Xlib.h:2859
XParseGeometry = _lib.XParseGeometry
XParseGeometry.restype = c_int
XParseGeometry.argtypes = [c_char_p, POINTER(c_int), POINTER(c_int), POINTER(c_uint), POINTER(c_uint)]

# /usr/include/X11/Xlib.h:2867
XPeekEvent = _lib.XPeekEvent
XPeekEvent.restype = c_int
XPeekEvent.argtypes = [POINTER(Display), POINTER(XEvent)]

# /usr/include/X11/Xlib.h:2872
XPeekIfEvent = _lib.XPeekIfEvent
XPeekIfEvent.restype = c_int
XPeekIfEvent.argtypes = [POINTER(Display), POINTER(XEvent), CFUNCTYPE(c_int, POINTER(Display), POINTER(XEvent), XPointer), XPointer]

# /usr/include/X11/Xlib.h:2883
XPending = _lib.XPending
XPending.restype = c_int
XPending.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2887
XPlanesOfScreen = _lib.XPlanesOfScreen
XPlanesOfScreen.restype = c_int
XPlanesOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:2891
XProtocolRevision = _lib.XProtocolRevision
XProtocolRevision.restype = c_int
XProtocolRevision.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2895
XProtocolVersion = _lib.XProtocolVersion
XProtocolVersion.restype = c_int
XProtocolVersion.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2900
XPutBackEvent = _lib.XPutBackEvent
XPutBackEvent.restype = c_int
XPutBackEvent.argtypes = [POINTER(Display), POINTER(XEvent)]

# /usr/include/X11/Xlib.h:2905
XPutImage = _lib.XPutImage
XPutImage.restype = c_int
XPutImage.argtypes = [POINTER(Display), Drawable, GC, POINTER(XImage), c_int, c_int, c_int, c_int, c_uint, c_uint]

# /usr/include/X11/Xlib.h:2918
XQLength = _lib.XQLength
XQLength.restype = c_int
XQLength.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:2922
XQueryBestCursor = _lib.XQueryBestCursor
XQueryBestCursor.restype = c_int
XQueryBestCursor.argtypes = [POINTER(Display), Drawable, c_uint, c_uint, POINTER(c_uint), POINTER(c_uint)]

# /usr/include/X11/Xlib.h:2931
XQueryBestSize = _lib.XQueryBestSize
XQueryBestSize.restype = c_int
XQueryBestSize.argtypes = [POINTER(Display), c_int, Drawable, c_uint, c_uint, POINTER(c_uint), POINTER(c_uint)]

# /usr/include/X11/Xlib.h:2941
XQueryBestStipple = _lib.XQueryBestStipple
XQueryBestStipple.restype = c_int
XQueryBestStipple.argtypes = [POINTER(Display), Drawable, c_uint, c_uint, POINTER(c_uint), POINTER(c_uint)]

# /usr/include/X11/Xlib.h:2950
XQueryBestTile = _lib.XQueryBestTile
XQueryBestTile.restype = c_int
XQueryBestTile.argtypes = [POINTER(Display), Drawable, c_uint, c_uint, POINTER(c_uint), POINTER(c_uint)]

# /usr/include/X11/Xlib.h:2959
XQueryColor = _lib.XQueryColor
XQueryColor.restype = c_int
XQueryColor.argtypes = [POINTER(Display), Colormap, POINTER(XColor)]

# /usr/include/X11/Xlib.h:2965
XQueryColors = _lib.XQueryColors
XQueryColors.restype = c_int
XQueryColors.argtypes = [POINTER(Display), Colormap, POINTER(XColor), c_int]

# /usr/include/X11/Xlib.h:2972
XQueryExtension = _lib.XQueryExtension
XQueryExtension.restype = c_int
XQueryExtension.argtypes = [POINTER(Display), c_char_p, POINTER(c_int), POINTER(c_int), POINTER(c_int)]

# /usr/include/X11/Xlib.h:2980
XQueryKeymap = _lib.XQueryKeymap
XQueryKeymap.restype = c_int
XQueryKeymap.argtypes = [POINTER(Display), c_char * 32]

# /usr/include/X11/Xlib.h:2985
XQueryPointer = _lib.XQueryPointer
XQueryPointer.restype = c_int
XQueryPointer.argtypes = [POINTER(Display), Window, POINTER(Window), POINTER(Window), POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_uint)]

# /usr/include/X11/Xlib.h:2997
XQueryTextExtents = _lib.XQueryTextExtents
XQueryTextExtents.restype = c_int
XQueryTextExtents.argtypes = [POINTER(Display), XID, c_char_p, c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(XCharStruct)]

# /usr/include/X11/Xlib.h:3008
XQueryTextExtents16 = _lib.XQueryTextExtents16
XQueryTextExtents16.restype = c_int
XQueryTextExtents16.argtypes = [POINTER(Display), XID, POINTER(XChar2b), c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(XCharStruct)]

# /usr/include/X11/Xlib.h:3019
XQueryTree = _lib.XQueryTree
XQueryTree.restype = c_int
XQueryTree.argtypes = [POINTER(Display), Window, POINTER(Window), POINTER(Window), POINTER(POINTER(Window)), POINTER(c_uint)]

# /usr/include/X11/Xlib.h:3028
XRaiseWindow = _lib.XRaiseWindow
XRaiseWindow.restype = c_int
XRaiseWindow.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xlib.h:3033
XReadBitmapFile = _lib.XReadBitmapFile
XReadBitmapFile.restype = c_int
XReadBitmapFile.argtypes = [POINTER(Display), Drawable, c_char_p, POINTER(c_uint), POINTER(c_uint), POINTER(Pixmap), POINTER(c_int), POINTER(c_int)]

# /usr/include/X11/Xlib.h:3044
XReadBitmapFileData = _lib.XReadBitmapFileData
XReadBitmapFileData.restype = c_int
XReadBitmapFileData.argtypes = [c_char_p, POINTER(c_uint), POINTER(c_uint), POINTER(POINTER(c_ubyte)), POINTER(c_int), POINTER(c_int)]

# /usr/include/X11/Xlib.h:3053
XRebindKeysym = _lib.XRebindKeysym
XRebindKeysym.restype = c_int
XRebindKeysym.argtypes = [POINTER(Display), KeySym, POINTER(KeySym), c_int, POINTER(c_ubyte), c_int]

# /usr/include/X11/Xlib.h:3062
XRecolorCursor = _lib.XRecolorCursor
XRecolorCursor.restype = c_int
XRecolorCursor.argtypes = [POINTER(Display), Cursor, POINTER(XColor), POINTER(XColor)]

# /usr/include/X11/Xlib.h:3069
XRefreshKeyboardMapping = _lib.XRefreshKeyboardMapping
XRefreshKeyboardMapping.restype = c_int
XRefreshKeyboardMapping.argtypes = [POINTER(XMappingEvent)]

# /usr/include/X11/Xlib.h:3073
XRemoveFromSaveSet = _lib.XRemoveFromSaveSet
XRemoveFromSaveSet.restype = c_int
XRemoveFromSaveSet.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xlib.h:3078
XRemoveHost = _lib.XRemoveHost
XRemoveHost.restype = c_int
XRemoveHost.argtypes = [POINTER(Display), POINTER(XHostAddress)]

# /usr/include/X11/Xlib.h:3083
XRemoveHosts = _lib.XRemoveHosts
XRemoveHosts.restype = c_int
XRemoveHosts.argtypes = [POINTER(Display), POINTER(XHostAddress), c_int]

# /usr/include/X11/Xlib.h:3089
XReparentWindow = _lib.XReparentWindow
XReparentWindow.restype = c_int
XReparentWindow.argtypes = [POINTER(Display), Window, Window, c_int, c_int]

# /usr/include/X11/Xlib.h:3097
XResetScreenSaver = _lib.XResetScreenSaver
XResetScreenSaver.restype = c_int
XResetScreenSaver.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:3101
XResizeWindow = _lib.XResizeWindow
XResizeWindow.restype = c_int
XResizeWindow.argtypes = [POINTER(Display), Window, c_uint, c_uint]

# /usr/include/X11/Xlib.h:3108
XRestackWindows = _lib.XRestackWindows
XRestackWindows.restype = c_int
XRestackWindows.argtypes = [POINTER(Display), POINTER(Window), c_int]

# /usr/include/X11/Xlib.h:3114
XRotateBuffers = _lib.XRotateBuffers
XRotateBuffers.restype = c_int
XRotateBuffers.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:3119
XRotateWindowProperties = _lib.XRotateWindowProperties
XRotateWindowProperties.restype = c_int
XRotateWindowProperties.argtypes = [POINTER(Display), Window, POINTER(Atom), c_int, c_int]

# /usr/include/X11/Xlib.h:3127
XScreenCount = _lib.XScreenCount
XScreenCount.restype = c_int
XScreenCount.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:3131
XSelectInput = _lib.XSelectInput
XSelectInput.restype = c_int
XSelectInput.argtypes = [POINTER(Display), Window, c_long]

# /usr/include/X11/Xlib.h:3137
XSendEvent = _lib.XSendEvent
XSendEvent.restype = c_int
XSendEvent.argtypes = [POINTER(Display), Window, c_int, c_long, POINTER(XEvent)]

# /usr/include/X11/Xlib.h:3145
XSetAccessControl = _lib.XSetAccessControl
XSetAccessControl.restype = c_int
XSetAccessControl.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:3150
XSetArcMode = _lib.XSetArcMode
XSetArcMode.restype = c_int
XSetArcMode.argtypes = [POINTER(Display), GC, c_int]

# /usr/include/X11/Xlib.h:3156
XSetBackground = _lib.XSetBackground
XSetBackground.restype = c_int
XSetBackground.argtypes = [POINTER(Display), GC, c_ulong]

# /usr/include/X11/Xlib.h:3162
XSetClipMask = _lib.XSetClipMask
XSetClipMask.restype = c_int
XSetClipMask.argtypes = [POINTER(Display), GC, Pixmap]

# /usr/include/X11/Xlib.h:3168
XSetClipOrigin = _lib.XSetClipOrigin
XSetClipOrigin.restype = c_int
XSetClipOrigin.argtypes = [POINTER(Display), GC, c_int, c_int]

# /usr/include/X11/Xlib.h:3175
XSetClipRectangles = _lib.XSetClipRectangles
XSetClipRectangles.restype = c_int
XSetClipRectangles.argtypes = [POINTER(Display), GC, c_int, c_int, POINTER(XRectangle), c_int, c_int]

# /usr/include/X11/Xlib.h:3185
XSetCloseDownMode = _lib.XSetCloseDownMode
XSetCloseDownMode.restype = c_int
XSetCloseDownMode.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:3190
XSetCommand = _lib.XSetCommand
XSetCommand.restype = c_int
XSetCommand.argtypes = [POINTER(Display), Window, POINTER(c_char_p), c_int]

# /usr/include/X11/Xlib.h:3197
XSetDashes = _lib.XSetDashes
XSetDashes.restype = c_int
XSetDashes.argtypes = [POINTER(Display), GC, c_int, c_char_p, c_int]

# /usr/include/X11/Xlib.h:3205
XSetFillRule = _lib.XSetFillRule
XSetFillRule.restype = c_int
XSetFillRule.argtypes = [POINTER(Display), GC, c_int]

# /usr/include/X11/Xlib.h:3211
XSetFillStyle = _lib.XSetFillStyle
XSetFillStyle.restype = c_int
XSetFillStyle.argtypes = [POINTER(Display), GC, c_int]

# /usr/include/X11/Xlib.h:3217
XSetFont = _lib.XSetFont
XSetFont.restype = c_int
XSetFont.argtypes = [POINTER(Display), GC, Font]

# /usr/include/X11/Xlib.h:3223
XSetFontPath = _lib.XSetFontPath
XSetFontPath.restype = c_int
XSetFontPath.argtypes = [POINTER(Display), POINTER(c_char_p), c_int]

# /usr/include/X11/Xlib.h:3229
XSetForeground = _lib.XSetForeground
XSetForeground.restype = c_int
XSetForeground.argtypes = [POINTER(Display), GC, c_ulong]

# /usr/include/X11/Xlib.h:3235
XSetFunction = _lib.XSetFunction
XSetFunction.restype = c_int
XSetFunction.argtypes = [POINTER(Display), GC, c_int]

# /usr/include/X11/Xlib.h:3241
XSetGraphicsExposures = _lib.XSetGraphicsExposures
XSetGraphicsExposures.restype = c_int
XSetGraphicsExposures.argtypes = [POINTER(Display), GC, c_int]

# /usr/include/X11/Xlib.h:3247
XSetIconName = _lib.XSetIconName
XSetIconName.restype = c_int
XSetIconName.argtypes = [POINTER(Display), Window, c_char_p]

# /usr/include/X11/Xlib.h:3253
XSetInputFocus = _lib.XSetInputFocus
XSetInputFocus.restype = c_int
XSetInputFocus.argtypes = [POINTER(Display), Window, c_int, Time]

# /usr/include/X11/Xlib.h:3260
XSetLineAttributes = _lib.XSetLineAttributes
XSetLineAttributes.restype = c_int
XSetLineAttributes.argtypes = [POINTER(Display), GC, c_uint, c_int, c_int, c_int]

# /usr/include/X11/Xlib.h:3269
XSetModifierMapping = _lib.XSetModifierMapping
XSetModifierMapping.restype = c_int
XSetModifierMapping.argtypes = [POINTER(Display), POINTER(XModifierKeymap)]

# /usr/include/X11/Xlib.h:3274
XSetPlaneMask = _lib.XSetPlaneMask
XSetPlaneMask.restype = c_int
XSetPlaneMask.argtypes = [POINTER(Display), GC, c_ulong]

# /usr/include/X11/Xlib.h:3280
XSetPointerMapping = _lib.XSetPointerMapping
XSetPointerMapping.restype = c_int
XSetPointerMapping.argtypes = [POINTER(Display), POINTER(c_ubyte), c_int]

# /usr/include/X11/Xlib.h:3286
XSetScreenSaver = _lib.XSetScreenSaver
XSetScreenSaver.restype = c_int
XSetScreenSaver.argtypes = [POINTER(Display), c_int, c_int, c_int, c_int]

# /usr/include/X11/Xlib.h:3294
XSetSelectionOwner = _lib.XSetSelectionOwner
XSetSelectionOwner.restype = c_int
XSetSelectionOwner.argtypes = [POINTER(Display), Atom, Window, Time]

# /usr/include/X11/Xlib.h:3301
XSetState = _lib.XSetState
XSetState.restype = c_int
XSetState.argtypes = [POINTER(Display), GC, c_ulong, c_ulong, c_int, c_ulong]

# /usr/include/X11/Xlib.h:3310
XSetStipple = _lib.XSetStipple
XSetStipple.restype = c_int
XSetStipple.argtypes = [POINTER(Display), GC, Pixmap]

# /usr/include/X11/Xlib.h:3316
XSetSubwindowMode = _lib.XSetSubwindowMode
XSetSubwindowMode.restype = c_int
XSetSubwindowMode.argtypes = [POINTER(Display), GC, c_int]

# /usr/include/X11/Xlib.h:3322
XSetTSOrigin = _lib.XSetTSOrigin
XSetTSOrigin.restype = c_int
XSetTSOrigin.argtypes = [POINTER(Display), GC, c_int, c_int]

# /usr/include/X11/Xlib.h:3329
XSetTile = _lib.XSetTile
XSetTile.restype = c_int
XSetTile.argtypes = [POINTER(Display), GC, Pixmap]

# /usr/include/X11/Xlib.h:3335
XSetWindowBackground = _lib.XSetWindowBackground
XSetWindowBackground.restype = c_int
XSetWindowBackground.argtypes = [POINTER(Display), Window, c_ulong]

# /usr/include/X11/Xlib.h:3341
XSetWindowBackgroundPixmap = _lib.XSetWindowBackgroundPixmap
XSetWindowBackgroundPixmap.restype = c_int
XSetWindowBackgroundPixmap.argtypes = [POINTER(Display), Window, Pixmap]

# /usr/include/X11/Xlib.h:3347
XSetWindowBorder = _lib.XSetWindowBorder
XSetWindowBorder.restype = c_int
XSetWindowBorder.argtypes = [POINTER(Display), Window, c_ulong]

# /usr/include/X11/Xlib.h:3353
XSetWindowBorderPixmap = _lib.XSetWindowBorderPixmap
XSetWindowBorderPixmap.restype = c_int
XSetWindowBorderPixmap.argtypes = [POINTER(Display), Window, Pixmap]

# /usr/include/X11/Xlib.h:3359
XSetWindowBorderWidth = _lib.XSetWindowBorderWidth
XSetWindowBorderWidth.restype = c_int
XSetWindowBorderWidth.argtypes = [POINTER(Display), Window, c_uint]

# /usr/include/X11/Xlib.h:3365
XSetWindowColormap = _lib.XSetWindowColormap
XSetWindowColormap.restype = c_int
XSetWindowColormap.argtypes = [POINTER(Display), Window, Colormap]

# /usr/include/X11/Xlib.h:3371
XStoreBuffer = _lib.XStoreBuffer
XStoreBuffer.restype = c_int
XStoreBuffer.argtypes = [POINTER(Display), c_char_p, c_int, c_int]

# /usr/include/X11/Xlib.h:3378
XStoreBytes = _lib.XStoreBytes
XStoreBytes.restype = c_int
XStoreBytes.argtypes = [POINTER(Display), c_char_p, c_int]

# /usr/include/X11/Xlib.h:3384
XStoreColor = _lib.XStoreColor
XStoreColor.restype = c_int
XStoreColor.argtypes = [POINTER(Display), Colormap, POINTER(XColor)]

# /usr/include/X11/Xlib.h:3390
XStoreColors = _lib.XStoreColors
XStoreColors.restype = c_int
XStoreColors.argtypes = [POINTER(Display), Colormap, POINTER(XColor), c_int]

# /usr/include/X11/Xlib.h:3397
XStoreName = _lib.XStoreName
XStoreName.restype = c_int
XStoreName.argtypes = [POINTER(Display), Window, c_char_p]

# /usr/include/X11/Xlib.h:3403
XStoreNamedColor = _lib.XStoreNamedColor
XStoreNamedColor.restype = c_int
XStoreNamedColor.argtypes = [POINTER(Display), Colormap, c_char_p, c_ulong, c_int]

# /usr/include/X11/Xlib.h:3411
XSync = _lib.XSync
XSync.restype = c_int
XSync.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:3416
XTextExtents = _lib.XTextExtents
XTextExtents.restype = c_int
XTextExtents.argtypes = [POINTER(XFontStruct), c_char_p, c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(XCharStruct)]

# /usr/include/X11/Xlib.h:3426
XTextExtents16 = _lib.XTextExtents16
XTextExtents16.restype = c_int
XTextExtents16.argtypes = [POINTER(XFontStruct), POINTER(XChar2b), c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(XCharStruct)]

# /usr/include/X11/Xlib.h:3436
XTextWidth = _lib.XTextWidth
XTextWidth.restype = c_int
XTextWidth.argtypes = [POINTER(XFontStruct), c_char_p, c_int]

# /usr/include/X11/Xlib.h:3442
XTextWidth16 = _lib.XTextWidth16
XTextWidth16.restype = c_int
XTextWidth16.argtypes = [POINTER(XFontStruct), POINTER(XChar2b), c_int]

# /usr/include/X11/Xlib.h:3448
XTranslateCoordinates = _lib.XTranslateCoordinates
XTranslateCoordinates.restype = c_int
XTranslateCoordinates.argtypes = [POINTER(Display), Window, Window, c_int, c_int, POINTER(c_int), POINTER(c_int), POINTER(Window)]

# /usr/include/X11/Xlib.h:3459
XUndefineCursor = _lib.XUndefineCursor
XUndefineCursor.restype = c_int
XUndefineCursor.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xlib.h:3464
XUngrabButton = _lib.XUngrabButton
XUngrabButton.restype = c_int
XUngrabButton.argtypes = [POINTER(Display), c_uint, c_uint, Window]

# /usr/include/X11/Xlib.h:3471
XUngrabKey = _lib.XUngrabKey
XUngrabKey.restype = c_int
XUngrabKey.argtypes = [POINTER(Display), c_int, c_uint, Window]

# /usr/include/X11/Xlib.h:3478
XUngrabKeyboard = _lib.XUngrabKeyboard
XUngrabKeyboard.restype = c_int
XUngrabKeyboard.argtypes = [POINTER(Display), Time]

# /usr/include/X11/Xlib.h:3483
XUngrabPointer = _lib.XUngrabPointer
XUngrabPointer.restype = c_int
XUngrabPointer.argtypes = [POINTER(Display), Time]

# /usr/include/X11/Xlib.h:3488
XUngrabServer = _lib.XUngrabServer
XUngrabServer.restype = c_int
XUngrabServer.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:3492
XUninstallColormap = _lib.XUninstallColormap
XUninstallColormap.restype = c_int
XUninstallColormap.argtypes = [POINTER(Display), Colormap]

# /usr/include/X11/Xlib.h:3497
XUnloadFont = _lib.XUnloadFont
XUnloadFont.restype = c_int
XUnloadFont.argtypes = [POINTER(Display), Font]

# /usr/include/X11/Xlib.h:3502
XUnmapSubwindows = _lib.XUnmapSubwindows
XUnmapSubwindows.restype = c_int
XUnmapSubwindows.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xlib.h:3507
XUnmapWindow = _lib.XUnmapWindow
XUnmapWindow.restype = c_int
XUnmapWindow.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xlib.h:3512
XVendorRelease = _lib.XVendorRelease
XVendorRelease.restype = c_int
XVendorRelease.argtypes = [POINTER(Display)]

# /usr/include/X11/Xlib.h:3516
XWarpPointer = _lib.XWarpPointer
XWarpPointer.restype = c_int
XWarpPointer.argtypes = [POINTER(Display), Window, Window, c_int, c_int, c_uint, c_uint, c_int, c_int]

# /usr/include/X11/Xlib.h:3528
XWidthMMOfScreen = _lib.XWidthMMOfScreen
XWidthMMOfScreen.restype = c_int
XWidthMMOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:3532
XWidthOfScreen = _lib.XWidthOfScreen
XWidthOfScreen.restype = c_int
XWidthOfScreen.argtypes = [POINTER(Screen)]

# /usr/include/X11/Xlib.h:3536
XWindowEvent = _lib.XWindowEvent
XWindowEvent.restype = c_int
XWindowEvent.argtypes = [POINTER(Display), Window, c_long, POINTER(XEvent)]

# /usr/include/X11/Xlib.h:3543
XWriteBitmapFile = _lib.XWriteBitmapFile
XWriteBitmapFile.restype = c_int
XWriteBitmapFile.argtypes = [POINTER(Display), c_char_p, Pixmap, c_uint, c_uint, c_int, c_int]

# /usr/include/X11/Xlib.h:3553
XSupportsLocale = _lib.XSupportsLocale
XSupportsLocale.restype = c_int
XSupportsLocale.argtypes = []

# /usr/include/X11/Xlib.h:3555
XSetLocaleModifiers = _lib.XSetLocaleModifiers
XSetLocaleModifiers.restype = c_char_p
XSetLocaleModifiers.argtypes = [c_char_p]

class struct__XrmHashBucketRec(Structure):
    __slots__ = [
    ]
struct__XrmHashBucketRec._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/X11/Xlib.h:3559
XOpenOM = _lib.XOpenOM
XOpenOM.restype = XOM
XOpenOM.argtypes = [POINTER(Display), POINTER(struct__XrmHashBucketRec), c_char_p, c_char_p]

# /usr/include/X11/Xlib.h:3566
XCloseOM = _lib.XCloseOM
XCloseOM.restype = c_int
XCloseOM.argtypes = [XOM]

# /usr/include/X11/Xlib.h:3570
XSetOMValues = _lib.XSetOMValues
XSetOMValues.restype = c_char_p
XSetOMValues.argtypes = [XOM]

# /usr/include/X11/Xlib.h:3575
XGetOMValues = _lib.XGetOMValues
XGetOMValues.restype = c_char_p
XGetOMValues.argtypes = [XOM]

# /usr/include/X11/Xlib.h:3580
XDisplayOfOM = _lib.XDisplayOfOM
XDisplayOfOM.restype = POINTER(Display)
XDisplayOfOM.argtypes = [XOM]

# /usr/include/X11/Xlib.h:3584
XLocaleOfOM = _lib.XLocaleOfOM
XLocaleOfOM.restype = c_char_p
XLocaleOfOM.argtypes = [XOM]

# /usr/include/X11/Xlib.h:3588
XCreateOC = _lib.XCreateOC
XCreateOC.restype = XOC
XCreateOC.argtypes = [XOM]

# /usr/include/X11/Xlib.h:3593
XDestroyOC = _lib.XDestroyOC
XDestroyOC.restype = None
XDestroyOC.argtypes = [XOC]

# /usr/include/X11/Xlib.h:3597
XOMOfOC = _lib.XOMOfOC
XOMOfOC.restype = XOM
XOMOfOC.argtypes = [XOC]

# /usr/include/X11/Xlib.h:3601
XSetOCValues = _lib.XSetOCValues
XSetOCValues.restype = c_char_p
XSetOCValues.argtypes = [XOC]

# /usr/include/X11/Xlib.h:3606
XGetOCValues = _lib.XGetOCValues
XGetOCValues.restype = c_char_p
XGetOCValues.argtypes = [XOC]

# /usr/include/X11/Xlib.h:3611
XCreateFontSet = _lib.XCreateFontSet
XCreateFontSet.restype = XFontSet
XCreateFontSet.argtypes = [POINTER(Display), c_char_p, POINTER(POINTER(c_char_p)), POINTER(c_int), POINTER(c_char_p)]

# /usr/include/X11/Xlib.h:3619
XFreeFontSet = _lib.XFreeFontSet
XFreeFontSet.restype = None
XFreeFontSet.argtypes = [POINTER(Display), XFontSet]

# /usr/include/X11/Xlib.h:3624
XFontsOfFontSet = _lib.XFontsOfFontSet
XFontsOfFontSet.restype = c_int
XFontsOfFontSet.argtypes = [XFontSet, POINTER(POINTER(POINTER(XFontStruct))), POINTER(POINTER(c_char_p))]

# /usr/include/X11/Xlib.h:3630
XBaseFontNameListOfFontSet = _lib.XBaseFontNameListOfFontSet
XBaseFontNameListOfFontSet.restype = c_char_p
XBaseFontNameListOfFontSet.argtypes = [XFontSet]

# /usr/include/X11/Xlib.h:3634
XLocaleOfFontSet = _lib.XLocaleOfFontSet
XLocaleOfFontSet.restype = c_char_p
XLocaleOfFontSet.argtypes = [XFontSet]

# /usr/include/X11/Xlib.h:3638
XContextDependentDrawing = _lib.XContextDependentDrawing
XContextDependentDrawing.restype = c_int
XContextDependentDrawing.argtypes = [XFontSet]

# /usr/include/X11/Xlib.h:3642
XDirectionalDependentDrawing = _lib.XDirectionalDependentDrawing
XDirectionalDependentDrawing.restype = c_int
XDirectionalDependentDrawing.argtypes = [XFontSet]

# /usr/include/X11/Xlib.h:3646
XContextualDrawing = _lib.XContextualDrawing
XContextualDrawing.restype = c_int
XContextualDrawing.argtypes = [XFontSet]

# /usr/include/X11/Xlib.h:3650
XExtentsOfFontSet = _lib.XExtentsOfFontSet
XExtentsOfFontSet.restype = POINTER(XFontSetExtents)
XExtentsOfFontSet.argtypes = [XFontSet]

# /usr/include/X11/Xlib.h:3654
XmbTextEscapement = _lib.XmbTextEscapement
XmbTextEscapement.restype = c_int
XmbTextEscapement.argtypes = [XFontSet, c_char_p, c_int]

# /usr/include/X11/Xlib.h:3660
XwcTextEscapement = _lib.XwcTextEscapement
XwcTextEscapement.restype = c_int
XwcTextEscapement.argtypes = [XFontSet, c_wchar_p, c_int]

# /usr/include/X11/Xlib.h:3666
Xutf8TextEscapement = _lib.Xutf8TextEscapement
Xutf8TextEscapement.restype = c_int
Xutf8TextEscapement.argtypes = [XFontSet, c_char_p, c_int]

# /usr/include/X11/Xlib.h:3672
XmbTextExtents = _lib.XmbTextExtents
XmbTextExtents.restype = c_int
XmbTextExtents.argtypes = [XFontSet, c_char_p, c_int, POINTER(XRectangle), POINTER(XRectangle)]

# /usr/include/X11/Xlib.h:3680
XwcTextExtents = _lib.XwcTextExtents
XwcTextExtents.restype = c_int
XwcTextExtents.argtypes = [XFontSet, c_wchar_p, c_int, POINTER(XRectangle), POINTER(XRectangle)]

# /usr/include/X11/Xlib.h:3688
Xutf8TextExtents = _lib.Xutf8TextExtents
Xutf8TextExtents.restype = c_int
Xutf8TextExtents.argtypes = [XFontSet, c_char_p, c_int, POINTER(XRectangle), POINTER(XRectangle)]

# /usr/include/X11/Xlib.h:3696
XmbTextPerCharExtents = _lib.XmbTextPerCharExtents
XmbTextPerCharExtents.restype = c_int
XmbTextPerCharExtents.argtypes = [XFontSet, c_char_p, c_int, POINTER(XRectangle), POINTER(XRectangle), c_int, POINTER(c_int), POINTER(XRectangle), POINTER(XRectangle)]

# /usr/include/X11/Xlib.h:3708
XwcTextPerCharExtents = _lib.XwcTextPerCharExtents
XwcTextPerCharExtents.restype = c_int
XwcTextPerCharExtents.argtypes = [XFontSet, c_wchar_p, c_int, POINTER(XRectangle), POINTER(XRectangle), c_int, POINTER(c_int), POINTER(XRectangle), POINTER(XRectangle)]

# /usr/include/X11/Xlib.h:3720
Xutf8TextPerCharExtents = _lib.Xutf8TextPerCharExtents
Xutf8TextPerCharExtents.restype = c_int
Xutf8TextPerCharExtents.argtypes = [XFontSet, c_char_p, c_int, POINTER(XRectangle), POINTER(XRectangle), c_int, POINTER(c_int), POINTER(XRectangle), POINTER(XRectangle)]

# /usr/include/X11/Xlib.h:3732
XmbDrawText = _lib.XmbDrawText
XmbDrawText.restype = None
XmbDrawText.argtypes = [POINTER(Display), Drawable, GC, c_int, c_int, POINTER(XmbTextItem), c_int]

# /usr/include/X11/Xlib.h:3742
XwcDrawText = _lib.XwcDrawText
XwcDrawText.restype = None
XwcDrawText.argtypes = [POINTER(Display), Drawable, GC, c_int, c_int, POINTER(XwcTextItem), c_int]

# /usr/include/X11/Xlib.h:3752
Xutf8DrawText = _lib.Xutf8DrawText
Xutf8DrawText.restype = None
Xutf8DrawText.argtypes = [POINTER(Display), Drawable, GC, c_int, c_int, POINTER(XmbTextItem), c_int]

# /usr/include/X11/Xlib.h:3762
XmbDrawString = _lib.XmbDrawString
XmbDrawString.restype = None
XmbDrawString.argtypes = [POINTER(Display), Drawable, XFontSet, GC, c_int, c_int, c_char_p, c_int]

# /usr/include/X11/Xlib.h:3773
XwcDrawString = _lib.XwcDrawString
XwcDrawString.restype = None
XwcDrawString.argtypes = [POINTER(Display), Drawable, XFontSet, GC, c_int, c_int, c_wchar_p, c_int]

# /usr/include/X11/Xlib.h:3784
Xutf8DrawString = _lib.Xutf8DrawString
Xutf8DrawString.restype = None
Xutf8DrawString.argtypes = [POINTER(Display), Drawable, XFontSet, GC, c_int, c_int, c_char_p, c_int]

# /usr/include/X11/Xlib.h:3795
XmbDrawImageString = _lib.XmbDrawImageString
XmbDrawImageString.restype = None
XmbDrawImageString.argtypes = [POINTER(Display), Drawable, XFontSet, GC, c_int, c_int, c_char_p, c_int]

# /usr/include/X11/Xlib.h:3806
XwcDrawImageString = _lib.XwcDrawImageString
XwcDrawImageString.restype = None
XwcDrawImageString.argtypes = [POINTER(Display), Drawable, XFontSet, GC, c_int, c_int, c_wchar_p, c_int]

# /usr/include/X11/Xlib.h:3817
Xutf8DrawImageString = _lib.Xutf8DrawImageString
Xutf8DrawImageString.restype = None
Xutf8DrawImageString.argtypes = [POINTER(Display), Drawable, XFontSet, GC, c_int, c_int, c_char_p, c_int]

class struct__XrmHashBucketRec(Structure):
    __slots__ = [
    ]
struct__XrmHashBucketRec._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/X11/Xlib.h:3828
XOpenIM = _lib.XOpenIM
XOpenIM.restype = XIM
XOpenIM.argtypes = [POINTER(Display), POINTER(struct__XrmHashBucketRec), c_char_p, c_char_p]

# /usr/include/X11/Xlib.h:3835
XCloseIM = _lib.XCloseIM
XCloseIM.restype = c_int
XCloseIM.argtypes = [XIM]

# /usr/include/X11/Xlib.h:3839
XGetIMValues = _lib.XGetIMValues
XGetIMValues.restype = c_char_p
XGetIMValues.argtypes = [XIM]

# /usr/include/X11/Xlib.h:3843
XSetIMValues = _lib.XSetIMValues
XSetIMValues.restype = c_char_p
XSetIMValues.argtypes = [XIM]

# /usr/include/X11/Xlib.h:3847
XDisplayOfIM = _lib.XDisplayOfIM
XDisplayOfIM.restype = POINTER(Display)
XDisplayOfIM.argtypes = [XIM]

# /usr/include/X11/Xlib.h:3851
XLocaleOfIM = _lib.XLocaleOfIM
XLocaleOfIM.restype = c_char_p
XLocaleOfIM.argtypes = [XIM]

# /usr/include/X11/Xlib.h:3855
XCreateIC = _lib.XCreateIC
XCreateIC.restype = XIC
XCreateIC.argtypes = [XIM]

# /usr/include/X11/Xlib.h:3859
XDestroyIC = _lib.XDestroyIC
XDestroyIC.restype = None
XDestroyIC.argtypes = [XIC]

# /usr/include/X11/Xlib.h:3863
XSetICFocus = _lib.XSetICFocus
XSetICFocus.restype = None
XSetICFocus.argtypes = [XIC]

# /usr/include/X11/Xlib.h:3867
XUnsetICFocus = _lib.XUnsetICFocus
XUnsetICFocus.restype = None
XUnsetICFocus.argtypes = [XIC]

# /usr/include/X11/Xlib.h:3871
XwcResetIC = _lib.XwcResetIC
XwcResetIC.restype = c_wchar_p
XwcResetIC.argtypes = [XIC]

# /usr/include/X11/Xlib.h:3875
XmbResetIC = _lib.XmbResetIC
XmbResetIC.restype = c_char_p
XmbResetIC.argtypes = [XIC]

# /usr/include/X11/Xlib.h:3879
Xutf8ResetIC = _lib.Xutf8ResetIC
Xutf8ResetIC.restype = c_char_p
Xutf8ResetIC.argtypes = [XIC]

# /usr/include/X11/Xlib.h:3883
XSetICValues = _lib.XSetICValues
XSetICValues.restype = c_char_p
XSetICValues.argtypes = [XIC]

# /usr/include/X11/Xlib.h:3887
XGetICValues = _lib.XGetICValues
XGetICValues.restype = c_char_p
XGetICValues.argtypes = [XIC]

# /usr/include/X11/Xlib.h:3891
XIMOfIC = _lib.XIMOfIC
XIMOfIC.restype = XIM
XIMOfIC.argtypes = [XIC]

# /usr/include/X11/Xlib.h:3895
XFilterEvent = _lib.XFilterEvent
XFilterEvent.restype = c_int
XFilterEvent.argtypes = [POINTER(XEvent), Window]

# /usr/include/X11/Xlib.h:3900
XmbLookupString = _lib.XmbLookupString
XmbLookupString.restype = c_int
XmbLookupString.argtypes = [XIC, POINTER(XKeyPressedEvent), c_char_p, c_int, POINTER(KeySym), POINTER(c_int)]

# /usr/include/X11/Xlib.h:3909
XwcLookupString = _lib.XwcLookupString
XwcLookupString.restype = c_int
XwcLookupString.argtypes = [XIC, POINTER(XKeyPressedEvent), c_wchar_p, c_int, POINTER(KeySym), POINTER(c_int)]

# /usr/include/X11/Xlib.h:3918
Xutf8LookupString = _lib.Xutf8LookupString
Xutf8LookupString.restype = c_int
Xutf8LookupString.argtypes = [XIC, POINTER(XKeyPressedEvent), c_char_p, c_int, POINTER(KeySym), POINTER(c_int)]

# /usr/include/X11/Xlib.h:3927
XVaCreateNestedList = _lib.XVaCreateNestedList
XVaCreateNestedList.restype = XVaNestedList
XVaCreateNestedList.argtypes = [c_int]

class struct__XrmHashBucketRec(Structure):
    __slots__ = [
    ]
struct__XrmHashBucketRec._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/X11/Xlib.h:3933
XRegisterIMInstantiateCallback = _lib.XRegisterIMInstantiateCallback
XRegisterIMInstantiateCallback.restype = c_int
XRegisterIMInstantiateCallback.argtypes = [POINTER(Display), POINTER(struct__XrmHashBucketRec), c_char_p, c_char_p, XIDProc, XPointer]

class struct__XrmHashBucketRec(Structure):
    __slots__ = [
    ]
struct__XrmHashBucketRec._fields_ = [
    ('_opaque_struct', c_int)
]

# /usr/include/X11/Xlib.h:3942
XUnregisterIMInstantiateCallback = _lib.XUnregisterIMInstantiateCallback
XUnregisterIMInstantiateCallback.restype = c_int
XUnregisterIMInstantiateCallback.argtypes = [POINTER(Display), POINTER(struct__XrmHashBucketRec), c_char_p, c_char_p, XIDProc, XPointer]

XConnectionWatchProc = CFUNCTYPE(None, POINTER(Display), XPointer, c_int, c_int, POINTER(XPointer)) 	# /usr/include/X11/Xlib.h:3951
# /usr/include/X11/Xlib.h:3960
XInternalConnectionNumbers = _lib.XInternalConnectionNumbers
XInternalConnectionNumbers.restype = c_int
XInternalConnectionNumbers.argtypes = [POINTER(Display), POINTER(POINTER(c_int)), POINTER(c_int)]

# /usr/include/X11/Xlib.h:3966
XProcessInternalConnection = _lib.XProcessInternalConnection
XProcessInternalConnection.restype = None
XProcessInternalConnection.argtypes = [POINTER(Display), c_int]

# /usr/include/X11/Xlib.h:3971
XAddConnectionWatch = _lib.XAddConnectionWatch
XAddConnectionWatch.restype = c_int
XAddConnectionWatch.argtypes = [POINTER(Display), XConnectionWatchProc, XPointer]

# /usr/include/X11/Xlib.h:3977
XRemoveConnectionWatch = _lib.XRemoveConnectionWatch
XRemoveConnectionWatch.restype = None
XRemoveConnectionWatch.argtypes = [POINTER(Display), XConnectionWatchProc, XPointer]

# /usr/include/X11/Xlib.h:3983
XSetAuthorization = _lib.XSetAuthorization
XSetAuthorization.restype = None
XSetAuthorization.argtypes = [c_char_p, c_int, c_char_p, c_int]

# /usr/include/X11/Xlib.h:3990
_Xmbtowc = _lib._Xmbtowc
_Xmbtowc.restype = c_int
_Xmbtowc.argtypes = [c_wchar_p, c_char_p, c_int]

# /usr/include/X11/Xlib.h:4001
_Xwctomb = _lib._Xwctomb
_Xwctomb.restype = c_int
_Xwctomb.argtypes = [c_char_p, c_wchar]

NoValue = 0 	# /usr/include/X11/Xutil.h:4791
XValue = 1 	# /usr/include/X11/Xutil.h:4792
YValue = 2 	# /usr/include/X11/Xutil.h:4793
WidthValue = 4 	# /usr/include/X11/Xutil.h:4794
HeightValue = 8 	# /usr/include/X11/Xutil.h:4795
AllValues = 15 	# /usr/include/X11/Xutil.h:4796
XNegative = 16 	# /usr/include/X11/Xutil.h:4797
YNegative = 32 	# /usr/include/X11/Xutil.h:4798
class struct_anon_93(Structure):
    __slots__ = [
        'flags',
        'x',
        'y',
        'width',
        'height',
        'min_width',
        'min_height',
        'max_width',
        'max_height',
        'width_inc',
        'height_inc',
        'min_aspect',
        'max_aspect',
        'base_width',
        'base_height',
        'win_gravity',
    ]
class struct_anon_94(Structure):
    __slots__ = [
        'x',
        'y',
    ]
struct_anon_94._fields_ = [
    ('x', c_int),
    ('y', c_int),
]

class struct_anon_95(Structure):
    __slots__ = [
        'x',
        'y',
    ]
struct_anon_95._fields_ = [
    ('x', c_int),
    ('y', c_int),
]

struct_anon_93._fields_ = [
    ('flags', c_long),
    ('x', c_int),
    ('y', c_int),
    ('width', c_int),
    ('height', c_int),
    ('min_width', c_int),
    ('min_height', c_int),
    ('max_width', c_int),
    ('max_height', c_int),
    ('width_inc', c_int),
    ('height_inc', c_int),
    ('min_aspect', struct_anon_94),
    ('max_aspect', struct_anon_95),
    ('base_width', c_int),
    ('base_height', c_int),
    ('win_gravity', c_int),
]

XSizeHints = struct_anon_93 	# /usr/include/X11/Xutil.h:4817
USPosition = 1 	# /usr/include/X11/Xutil.h:4825
USSize = 2 	# /usr/include/X11/Xutil.h:4826
PPosition = 4 	# /usr/include/X11/Xutil.h:4828
PSize = 8 	# /usr/include/X11/Xutil.h:4829
PMinSize = 16 	# /usr/include/X11/Xutil.h:4830
PMaxSize = 32 	# /usr/include/X11/Xutil.h:4831
PResizeInc = 64 	# /usr/include/X11/Xutil.h:4832
PAspect = 128 	# /usr/include/X11/Xutil.h:4833
PBaseSize = 256 	# /usr/include/X11/Xutil.h:4834
PWinGravity = 512 	# /usr/include/X11/Xutil.h:4835
PAllHints = 252 	# /usr/include/X11/Xutil.h:4838
class struct_anon_96(Structure):
    __slots__ = [
        'flags',
        'input',
        'initial_state',
        'icon_pixmap',
        'icon_window',
        'icon_x',
        'icon_y',
        'icon_mask',
        'window_group',
    ]
struct_anon_96._fields_ = [
    ('flags', c_long),
    ('input', c_int),
    ('initial_state', c_int),
    ('icon_pixmap', Pixmap),
    ('icon_window', Window),
    ('icon_x', c_int),
    ('icon_y', c_int),
    ('icon_mask', Pixmap),
    ('window_group', XID),
]

XWMHints = struct_anon_96 	# /usr/include/X11/Xutil.h:4853
InputHint = 1 	# /usr/include/X11/Xutil.h:4857
StateHint = 2 	# /usr/include/X11/Xutil.h:4858
IconPixmapHint = 4 	# /usr/include/X11/Xutil.h:4859
IconWindowHint = 8 	# /usr/include/X11/Xutil.h:4860
IconPositionHint = 16 	# /usr/include/X11/Xutil.h:4861
IconMaskHint = 32 	# /usr/include/X11/Xutil.h:4862
WindowGroupHint = 64 	# /usr/include/X11/Xutil.h:4863
AllHints = 127 	# /usr/include/X11/Xutil.h:4864
XUrgencyHint = 256 	# /usr/include/X11/Xutil.h:4866
WithdrawnState = 0 	# /usr/include/X11/Xutil.h:4869
NormalState = 1 	# /usr/include/X11/Xutil.h:4870
IconicState = 3 	# /usr/include/X11/Xutil.h:4871
DontCareState = 0 	# /usr/include/X11/Xutil.h:4876
ZoomState = 2 	# /usr/include/X11/Xutil.h:4877
InactiveState = 4 	# /usr/include/X11/Xutil.h:4878
class struct_anon_97(Structure):
    __slots__ = [
        'value',
        'encoding',
        'format',
        'nitems',
    ]
struct_anon_97._fields_ = [
    ('value', POINTER(c_ubyte)),
    ('encoding', Atom),
    ('format', c_int),
    ('nitems', c_ulong),
]

XTextProperty = struct_anon_97 	# /usr/include/X11/Xutil.h:4891
XNoMemory = -1 	# /usr/include/X11/Xutil.h:4893
XLocaleNotSupported = -2 	# /usr/include/X11/Xutil.h:4894
XConverterNotFound = -3 	# /usr/include/X11/Xutil.h:4895
enum_anon_98 = c_int
XStringStyle = 0
XCompoundTextStyle = 1
XTextStyle = 2
XStdICCTextStyle = 3
XUTF8StringStyle = 4
XICCEncodingStyle = enum_anon_98 	# /usr/include/X11/Xutil.h:4904
class struct_anon_99(Structure):
    __slots__ = [
        'min_width',
        'min_height',
        'max_width',
        'max_height',
        'width_inc',
        'height_inc',
    ]
struct_anon_99._fields_ = [
    ('min_width', c_int),
    ('min_height', c_int),
    ('max_width', c_int),
    ('max_height', c_int),
    ('width_inc', c_int),
    ('height_inc', c_int),
]

XIconSize = struct_anon_99 	# /usr/include/X11/Xutil.h:4910
class struct_anon_100(Structure):
    __slots__ = [
        'res_name',
        'res_class',
    ]
struct_anon_100._fields_ = [
    ('res_name', c_char_p),
    ('res_class', c_char_p),
]

XClassHint = struct_anon_100 	# /usr/include/X11/Xutil.h:4915
class struct__XComposeStatus(Structure):
    __slots__ = [
        'compose_ptr',
        'chars_matched',
    ]
struct__XComposeStatus._fields_ = [
    ('compose_ptr', XPointer),
    ('chars_matched', c_int),
]

XComposeStatus = struct__XComposeStatus 	# /usr/include/X11/Xutil.h:4957
class struct__XRegion(Structure):
    __slots__ = [
    ]
struct__XRegion._fields_ = [
    ('_opaque_struct', c_int)
]

class struct__XRegion(Structure):
    __slots__ = [
    ]
struct__XRegion._fields_ = [
    ('_opaque_struct', c_int)
]

Region = POINTER(struct__XRegion) 	# /usr/include/X11/Xutil.h:4996
RectangleOut = 0 	# /usr/include/X11/Xutil.h:5000
RectangleIn = 1 	# /usr/include/X11/Xutil.h:5001
RectanglePart = 2 	# /usr/include/X11/Xutil.h:5002
XVisualInfo = pyglet.gl.glx.XVisualInfo
VisualNoMask = 0 	# /usr/include/X11/Xutil.h:5027
VisualIDMask = 1 	# /usr/include/X11/Xutil.h:5028
VisualScreenMask = 2 	# /usr/include/X11/Xutil.h:5029
VisualDepthMask = 4 	# /usr/include/X11/Xutil.h:5030
VisualClassMask = 8 	# /usr/include/X11/Xutil.h:5031
VisualRedMaskMask = 16 	# /usr/include/X11/Xutil.h:5032
VisualGreenMaskMask = 32 	# /usr/include/X11/Xutil.h:5033
VisualBlueMaskMask = 64 	# /usr/include/X11/Xutil.h:5034
VisualColormapSizeMask = 128 	# /usr/include/X11/Xutil.h:5035
VisualBitsPerRGBMask = 256 	# /usr/include/X11/Xutil.h:5036
VisualAllMask = 511 	# /usr/include/X11/Xutil.h:5037
class struct_anon_102(Structure):
    __slots__ = [
        'colormap',
        'red_max',
        'red_mult',
        'green_max',
        'green_mult',
        'blue_max',
        'blue_mult',
        'base_pixel',
        'visualid',
        'killid',
    ]
struct_anon_102._fields_ = [
    ('colormap', Colormap),
    ('red_max', c_ulong),
    ('red_mult', c_ulong),
    ('green_max', c_ulong),
    ('green_mult', c_ulong),
    ('blue_max', c_ulong),
    ('blue_mult', c_ulong),
    ('base_pixel', c_ulong),
    ('visualid', VisualID),
    ('killid', XID),
]

XStandardColormap = struct_anon_102 	# /usr/include/X11/Xutil.h:5054
BitmapSuccess = 0 	# /usr/include/X11/Xutil.h:5062
BitmapOpenFailed = 1 	# /usr/include/X11/Xutil.h:5063
BitmapFileInvalid = 2 	# /usr/include/X11/Xutil.h:5064
BitmapNoMemory = 3 	# /usr/include/X11/Xutil.h:5065
XCSUCCESS = 0 	# /usr/include/X11/Xutil.h:5076
XCNOMEM = 1 	# /usr/include/X11/Xutil.h:5077
XCNOENT = 2 	# /usr/include/X11/Xutil.h:5078
XContext = c_int 	# /usr/include/X11/Xutil.h:5080
# /usr/include/X11/Xutil.h:5089
XAllocClassHint = _lib.XAllocClassHint
XAllocClassHint.restype = POINTER(XClassHint)
XAllocClassHint.argtypes = []

# /usr/include/X11/Xutil.h:5093
XAllocIconSize = _lib.XAllocIconSize
XAllocIconSize.restype = POINTER(XIconSize)
XAllocIconSize.argtypes = []

# /usr/include/X11/Xutil.h:5097
XAllocSizeHints = _lib.XAllocSizeHints
XAllocSizeHints.restype = POINTER(XSizeHints)
XAllocSizeHints.argtypes = []

# /usr/include/X11/Xutil.h:5101
XAllocStandardColormap = _lib.XAllocStandardColormap
XAllocStandardColormap.restype = POINTER(XStandardColormap)
XAllocStandardColormap.argtypes = []

# /usr/include/X11/Xutil.h:5105
XAllocWMHints = _lib.XAllocWMHints
XAllocWMHints.restype = POINTER(XWMHints)
XAllocWMHints.argtypes = []

# /usr/include/X11/Xutil.h:5109
XClipBox = _lib.XClipBox
XClipBox.restype = c_int
XClipBox.argtypes = [Region, POINTER(XRectangle)]

# /usr/include/X11/Xutil.h:5114
XCreateRegion = _lib.XCreateRegion
XCreateRegion.restype = Region
XCreateRegion.argtypes = []

# /usr/include/X11/Xutil.h:5118
XDefaultString = _lib.XDefaultString
XDefaultString.restype = c_char_p
XDefaultString.argtypes = []

# /usr/include/X11/Xutil.h:5120
XDeleteContext = _lib.XDeleteContext
XDeleteContext.restype = c_int
XDeleteContext.argtypes = [POINTER(Display), XID, XContext]

# /usr/include/X11/Xutil.h:5126
XDestroyRegion = _lib.XDestroyRegion
XDestroyRegion.restype = c_int
XDestroyRegion.argtypes = [Region]

# /usr/include/X11/Xutil.h:5130
XEmptyRegion = _lib.XEmptyRegion
XEmptyRegion.restype = c_int
XEmptyRegion.argtypes = [Region]

# /usr/include/X11/Xutil.h:5134
XEqualRegion = _lib.XEqualRegion
XEqualRegion.restype = c_int
XEqualRegion.argtypes = [Region, Region]

# /usr/include/X11/Xutil.h:5139
XFindContext = _lib.XFindContext
XFindContext.restype = c_int
XFindContext.argtypes = [POINTER(Display), XID, XContext, POINTER(XPointer)]

# /usr/include/X11/Xutil.h:5146
XGetClassHint = _lib.XGetClassHint
XGetClassHint.restype = c_int
XGetClassHint.argtypes = [POINTER(Display), Window, POINTER(XClassHint)]

# /usr/include/X11/Xutil.h:5152
XGetIconSizes = _lib.XGetIconSizes
XGetIconSizes.restype = c_int
XGetIconSizes.argtypes = [POINTER(Display), Window, POINTER(POINTER(XIconSize)), POINTER(c_int)]

# /usr/include/X11/Xutil.h:5159
XGetNormalHints = _lib.XGetNormalHints
XGetNormalHints.restype = c_int
XGetNormalHints.argtypes = [POINTER(Display), Window, POINTER(XSizeHints)]

# /usr/include/X11/Xutil.h:5165
XGetRGBColormaps = _lib.XGetRGBColormaps
XGetRGBColormaps.restype = c_int
XGetRGBColormaps.argtypes = [POINTER(Display), Window, POINTER(POINTER(XStandardColormap)), POINTER(c_int), Atom]

# /usr/include/X11/Xutil.h:5173
XGetSizeHints = _lib.XGetSizeHints
XGetSizeHints.restype = c_int
XGetSizeHints.argtypes = [POINTER(Display), Window, POINTER(XSizeHints), Atom]

# /usr/include/X11/Xutil.h:5180
XGetStandardColormap = _lib.XGetStandardColormap
XGetStandardColormap.restype = c_int
XGetStandardColormap.argtypes = [POINTER(Display), Window, POINTER(XStandardColormap), Atom]

# /usr/include/X11/Xutil.h:5187
XGetTextProperty = _lib.XGetTextProperty
XGetTextProperty.restype = c_int
XGetTextProperty.argtypes = [POINTER(Display), Window, POINTER(XTextProperty), Atom]

# /usr/include/X11/Xutil.h:5194
XGetVisualInfo = _lib.XGetVisualInfo
XGetVisualInfo.restype = POINTER(XVisualInfo)
XGetVisualInfo.argtypes = [POINTER(Display), c_long, POINTER(XVisualInfo), POINTER(c_int)]

# /usr/include/X11/Xutil.h:5201
XGetWMClientMachine = _lib.XGetWMClientMachine
XGetWMClientMachine.restype = c_int
XGetWMClientMachine.argtypes = [POINTER(Display), Window, POINTER(XTextProperty)]

# /usr/include/X11/Xutil.h:5207
XGetWMHints = _lib.XGetWMHints
XGetWMHints.restype = POINTER(XWMHints)
XGetWMHints.argtypes = [POINTER(Display), Window]

# /usr/include/X11/Xutil.h:5212
XGetWMIconName = _lib.XGetWMIconName
XGetWMIconName.restype = c_int
XGetWMIconName.argtypes = [POINTER(Display), Window, POINTER(XTextProperty)]

# /usr/include/X11/Xutil.h:5218
XGetWMName = _lib.XGetWMName
XGetWMName.restype = c_int
XGetWMName.argtypes = [POINTER(Display), Window, POINTER(XTextProperty)]

# /usr/include/X11/Xutil.h:5224
XGetWMNormalHints = _lib.XGetWMNormalHints
XGetWMNormalHints.restype = c_int
XGetWMNormalHints.argtypes = [POINTER(Display), Window, POINTER(XSizeHints), POINTER(c_long)]

# /usr/include/X11/Xutil.h:5231
XGetWMSizeHints = _lib.XGetWMSizeHints
XGetWMSizeHints.restype = c_int
XGetWMSizeHints.argtypes = [POINTER(Display), Window, POINTER(XSizeHints), POINTER(c_long), Atom]

# /usr/include/X11/Xutil.h:5239
XGetZoomHints = _lib.XGetZoomHints
XGetZoomHints.restype = c_int
XGetZoomHints.argtypes = [POINTER(Display), Window, POINTER(XSizeHints)]

# /usr/include/X11/Xutil.h:5245
XIntersectRegion = _lib.XIntersectRegion
XIntersectRegion.restype = c_int
XIntersectRegion.argtypes = [Region, Region, Region]

# /usr/include/X11/Xutil.h:5251
XConvertCase = _lib.XConvertCase
XConvertCase.restype = None
XConvertCase.argtypes = [KeySym, POINTER(KeySym), POINTER(KeySym)]

# /usr/include/X11/Xutil.h:5257
XLookupString = _lib.XLookupString
XLookupString.restype = c_int
XLookupString.argtypes = [POINTER(XKeyEvent), c_char_p, c_int, POINTER(KeySym), POINTER(XComposeStatus)]

# /usr/include/X11/Xutil.h:5265
XMatchVisualInfo = _lib.XMatchVisualInfo
XMatchVisualInfo.restype = c_int
XMatchVisualInfo.argtypes = [POINTER(Display), c_int, c_int, c_int, POINTER(XVisualInfo)]

# /usr/include/X11/Xutil.h:5273
XOffsetRegion = _lib.XOffsetRegion
XOffsetRegion.restype = c_int
XOffsetRegion.argtypes = [Region, c_int, c_int]

# /usr/include/X11/Xutil.h:5279
XPointInRegion = _lib.XPointInRegion
XPointInRegion.restype = c_int
XPointInRegion.argtypes = [Region, c_int, c_int]

# /usr/include/X11/Xutil.h:5285
XPolygonRegion = _lib.XPolygonRegion
XPolygonRegion.restype = Region
XPolygonRegion.argtypes = [POINTER(XPoint), c_int, c_int]

# /usr/include/X11/Xutil.h:5291
XRectInRegion = _lib.XRectInRegion
XRectInRegion.restype = c_int
XRectInRegion.argtypes = [Region, c_int, c_int, c_uint, c_uint]

# /usr/include/X11/Xutil.h:5299
XSaveContext = _lib.XSaveContext
XSaveContext.restype = c_int
XSaveContext.argtypes = [POINTER(Display), XID, XContext, c_char_p]

# /usr/include/X11/Xutil.h:5306
XSetClassHint = _lib.XSetClassHint
XSetClassHint.restype = c_int
XSetClassHint.argtypes = [POINTER(Display), Window, POINTER(XClassHint)]

# /usr/include/X11/Xutil.h:5312
XSetIconSizes = _lib.XSetIconSizes
XSetIconSizes.restype = c_int
XSetIconSizes.argtypes = [POINTER(Display), Window, POINTER(XIconSize), c_int]

# /usr/include/X11/Xutil.h:5319
XSetNormalHints = _lib.XSetNormalHints
XSetNormalHints.restype = c_int
XSetNormalHints.argtypes = [POINTER(Display), Window, POINTER(XSizeHints)]

# /usr/include/X11/Xutil.h:5325
XSetRGBColormaps = _lib.XSetRGBColormaps
XSetRGBColormaps.restype = None
XSetRGBColormaps.argtypes = [POINTER(Display), Window, POINTER(XStandardColormap), c_int, Atom]

# /usr/include/X11/Xutil.h:5333
XSetSizeHints = _lib.XSetSizeHints
XSetSizeHints.restype = c_int
XSetSizeHints.argtypes = [POINTER(Display), Window, POINTER(XSizeHints), Atom]

# /usr/include/X11/Xutil.h:5340
XSetStandardProperties = _lib.XSetStandardProperties
XSetStandardProperties.restype = c_int
XSetStandardProperties.argtypes = [POINTER(Display), Window, c_char_p, c_char_p, Pixmap, POINTER(c_char_p), c_int, POINTER(XSizeHints)]

# /usr/include/X11/Xutil.h:5351
XSetTextProperty = _lib.XSetTextProperty
XSetTextProperty.restype = None
XSetTextProperty.argtypes = [POINTER(Display), Window, POINTER(XTextProperty), Atom]

# /usr/include/X11/Xutil.h:5358
XSetWMClientMachine = _lib.XSetWMClientMachine
XSetWMClientMachine.restype = None
XSetWMClientMachine.argtypes = [POINTER(Display), Window, POINTER(XTextProperty)]

# /usr/include/X11/Xutil.h:5364
XSetWMHints = _lib.XSetWMHints
XSetWMHints.restype = c_int
XSetWMHints.argtypes = [POINTER(Display), Window, POINTER(XWMHints)]

# /usr/include/X11/Xutil.h:5370
XSetWMIconName = _lib.XSetWMIconName
XSetWMIconName.restype = None
XSetWMIconName.argtypes = [POINTER(Display), Window, POINTER(XTextProperty)]

# /usr/include/X11/Xutil.h:5376
XSetWMName = _lib.XSetWMName
XSetWMName.restype = None
XSetWMName.argtypes = [POINTER(Display), Window, POINTER(XTextProperty)]

# /usr/include/X11/Xutil.h:5382
XSetWMNormalHints = _lib.XSetWMNormalHints
XSetWMNormalHints.restype = None
XSetWMNormalHints.argtypes = [POINTER(Display), Window, POINTER(XSizeHints)]

# /usr/include/X11/Xutil.h:5388
XSetWMProperties = _lib.XSetWMProperties
XSetWMProperties.restype = None
XSetWMProperties.argtypes = [POINTER(Display), Window, POINTER(XTextProperty), POINTER(XTextProperty), POINTER(c_char_p), c_int, POINTER(XSizeHints), POINTER(XWMHints), POINTER(XClassHint)]

# /usr/include/X11/Xutil.h:5400
XmbSetWMProperties = _lib.XmbSetWMProperties
XmbSetWMProperties.restype = None
XmbSetWMProperties.argtypes = [POINTER(Display), Window, c_char_p, c_char_p, POINTER(c_char_p), c_int, POINTER(XSizeHints), POINTER(XWMHints), POINTER(XClassHint)]

# /usr/include/X11/Xutil.h:5412
Xutf8SetWMProperties = _lib.Xutf8SetWMProperties
Xutf8SetWMProperties.restype = None
Xutf8SetWMProperties.argtypes = [POINTER(Display), Window, c_char_p, c_char_p, POINTER(c_char_p), c_int, POINTER(XSizeHints), POINTER(XWMHints), POINTER(XClassHint)]

# /usr/include/X11/Xutil.h:5424
XSetWMSizeHints = _lib.XSetWMSizeHints
XSetWMSizeHints.restype = None
XSetWMSizeHints.argtypes = [POINTER(Display), Window, POINTER(XSizeHints), Atom]

# /usr/include/X11/Xutil.h:5431
XSetRegion = _lib.XSetRegion
XSetRegion.restype = c_int
XSetRegion.argtypes = [POINTER(Display), GC, Region]

# /usr/include/X11/Xutil.h:5437
XSetStandardColormap = _lib.XSetStandardColormap
XSetStandardColormap.restype = None
XSetStandardColormap.argtypes = [POINTER(Display), Window, POINTER(XStandardColormap), Atom]

# /usr/include/X11/Xutil.h:5444
XSetZoomHints = _lib.XSetZoomHints
XSetZoomHints.restype = c_int
XSetZoomHints.argtypes = [POINTER(Display), Window, POINTER(XSizeHints)]

# /usr/include/X11/Xutil.h:5450
XShrinkRegion = _lib.XShrinkRegion
XShrinkRegion.restype = c_int
XShrinkRegion.argtypes = [Region, c_int, c_int]

# /usr/include/X11/Xutil.h:5456
XStringListToTextProperty = _lib.XStringListToTextProperty
XStringListToTextProperty.restype = c_int
XStringListToTextProperty.argtypes = [POINTER(c_char_p), c_int, POINTER(XTextProperty)]

# /usr/include/X11/Xutil.h:5462
XSubtractRegion = _lib.XSubtractRegion
XSubtractRegion.restype = c_int
XSubtractRegion.argtypes = [Region, Region, Region]

# /usr/include/X11/Xutil.h:5468
XmbTextListToTextProperty = _lib.XmbTextListToTextProperty
XmbTextListToTextProperty.restype = c_int
XmbTextListToTextProperty.argtypes = [POINTER(Display), POINTER(c_char_p), c_int, XICCEncodingStyle, POINTER(XTextProperty)]

# /usr/include/X11/Xutil.h:5476
XwcTextListToTextProperty = _lib.XwcTextListToTextProperty
XwcTextListToTextProperty.restype = c_int
XwcTextListToTextProperty.argtypes = [POINTER(Display), POINTER(c_wchar_p), c_int, XICCEncodingStyle, POINTER(XTextProperty)]

# /usr/include/X11/Xutil.h:5484
Xutf8TextListToTextProperty = _lib.Xutf8TextListToTextProperty
Xutf8TextListToTextProperty.restype = c_int
Xutf8TextListToTextProperty.argtypes = [POINTER(Display), POINTER(c_char_p), c_int, XICCEncodingStyle, POINTER(XTextProperty)]

# /usr/include/X11/Xutil.h:5492
XwcFreeStringList = _lib.XwcFreeStringList
XwcFreeStringList.restype = None
XwcFreeStringList.argtypes = [POINTER(c_wchar_p)]

# /usr/include/X11/Xutil.h:5496
XTextPropertyToStringList = _lib.XTextPropertyToStringList
XTextPropertyToStringList.restype = c_int
XTextPropertyToStringList.argtypes = [POINTER(XTextProperty), POINTER(POINTER(c_char_p)), POINTER(c_int)]

# /usr/include/X11/Xutil.h:5502
XmbTextPropertyToTextList = _lib.XmbTextPropertyToTextList
XmbTextPropertyToTextList.restype = c_int
XmbTextPropertyToTextList.argtypes = [POINTER(Display), POINTER(XTextProperty), POINTER(POINTER(c_char_p)), POINTER(c_int)]

# /usr/include/X11/Xutil.h:5509
XwcTextPropertyToTextList = _lib.XwcTextPropertyToTextList
XwcTextPropertyToTextList.restype = c_int
XwcTextPropertyToTextList.argtypes = [POINTER(Display), POINTER(XTextProperty), POINTER(POINTER(c_wchar_p)), POINTER(c_int)]

# /usr/include/X11/Xutil.h:5516
Xutf8TextPropertyToTextList = _lib.Xutf8TextPropertyToTextList
Xutf8TextPropertyToTextList.restype = c_int
Xutf8TextPropertyToTextList.argtypes = [POINTER(Display), POINTER(XTextProperty), POINTER(POINTER(c_char_p)), POINTER(c_int)]

# /usr/include/X11/Xutil.h:5523
XUnionRectWithRegion = _lib.XUnionRectWithRegion
XUnionRectWithRegion.restype = c_int
XUnionRectWithRegion.argtypes = [POINTER(XRectangle), Region, Region]

# /usr/include/X11/Xutil.h:5529
XUnionRegion = _lib.XUnionRegion
XUnionRegion.restype = c_int
XUnionRegion.argtypes = [Region, Region, Region]

# /usr/include/X11/Xutil.h:5535
XWMGeometry = _lib.XWMGeometry
XWMGeometry.restype = c_int
XWMGeometry.argtypes = [POINTER(Display), c_int, c_char_p, c_char_p, c_uint, POINTER(XSizeHints), POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int)]

# /usr/include/X11/Xutil.h:5549
XXorRegion = _lib.XXorRegion
XXorRegion.restype = c_int
XXorRegion.argtypes = [Region, Region, Region]


__all__ = ['XlibSpecificationRelease', 'X_PROTOCOL', 'X_PROTOCOL_REVISION',
'XID', 'Mask', 'Atom', 'VisualID', 'Time', 'Window', 'Drawable', 'Font',
'Pixmap', 'Cursor', 'Colormap', 'GContext', 'KeySym', 'KeyCode', 'None_',
'ParentRelative', 'CopyFromParent', 'PointerWindow', 'InputFocus',
'PointerRoot', 'AnyPropertyType', 'AnyKey', 'AnyButton', 'AllTemporary',
'CurrentTime', 'NoSymbol', 'NoEventMask', 'KeyPressMask', 'KeyReleaseMask',
'ButtonPressMask', 'ButtonReleaseMask', 'EnterWindowMask', 'LeaveWindowMask',
'PointerMotionMask', 'PointerMotionHintMask', 'Button1MotionMask',
'Button2MotionMask', 'Button3MotionMask', 'Button4MotionMask',
'Button5MotionMask', 'ButtonMotionMask', 'KeymapStateMask', 'ExposureMask',
'VisibilityChangeMask', 'StructureNotifyMask', 'ResizeRedirectMask',
'SubstructureNotifyMask', 'SubstructureRedirectMask', 'FocusChangeMask',
'PropertyChangeMask', 'ColormapChangeMask', 'OwnerGrabButtonMask', 'KeyPress',
'KeyRelease', 'ButtonPress', 'ButtonRelease', 'MotionNotify', 'EnterNotify',
'LeaveNotify', 'FocusIn', 'FocusOut', 'KeymapNotify', 'Expose',
'GraphicsExpose', 'NoExpose', 'VisibilityNotify', 'CreateNotify',
'DestroyNotify', 'UnmapNotify', 'MapNotify', 'MapRequest', 'ReparentNotify',
'ConfigureNotify', 'ConfigureRequest', 'GravityNotify', 'ResizeRequest',
'CirculateNotify', 'CirculateRequest', 'PropertyNotify', 'SelectionClear',
'SelectionRequest', 'SelectionNotify', 'ColormapNotify', 'ClientMessage',
'MappingNotify', 'LASTEvent', 'ShiftMask', 'LockMask', 'ControlMask',
'Mod1Mask', 'Mod2Mask', 'Mod3Mask', 'Mod4Mask', 'Mod5Mask', 'ShiftMapIndex',
'LockMapIndex', 'ControlMapIndex', 'Mod1MapIndex', 'Mod2MapIndex',
'Mod3MapIndex', 'Mod4MapIndex', 'Mod5MapIndex', 'Button1Mask', 'Button2Mask',
'Button3Mask', 'Button4Mask', 'Button5Mask', 'AnyModifier', 'Button1',
'Button2', 'Button3', 'Button4', 'Button5', 'NotifyNormal', 'NotifyGrab',
'NotifyUngrab', 'NotifyWhileGrabbed', 'NotifyHint', 'NotifyAncestor',
'NotifyVirtual', 'NotifyInferior', 'NotifyNonlinear',
'NotifyNonlinearVirtual', 'NotifyPointer', 'NotifyPointerRoot',
'NotifyDetailNone', 'VisibilityUnobscured', 'VisibilityPartiallyObscured',
'VisibilityFullyObscured', 'PlaceOnTop', 'PlaceOnBottom', 'FamilyInternet',
'FamilyDECnet', 'FamilyChaos', 'FamilyInternet6', 'FamilyServerInterpreted',
'PropertyNewValue', 'PropertyDelete', 'ColormapUninstalled',
'ColormapInstalled', 'GrabModeSync', 'GrabModeAsync', 'GrabSuccess',
'AlreadyGrabbed', 'GrabInvalidTime', 'GrabNotViewable', 'GrabFrozen',
'AsyncPointer', 'SyncPointer', 'ReplayPointer', 'AsyncKeyboard',
'SyncKeyboard', 'ReplayKeyboard', 'AsyncBoth', 'SyncBoth', 'RevertToParent',
'Success', 'BadRequest', 'BadValue', 'BadWindow', 'BadPixmap', 'BadAtom',
'BadCursor', 'BadFont', 'BadMatch', 'BadDrawable', 'BadAccess', 'BadAlloc',
'BadColor', 'BadGC', 'BadIDChoice', 'BadName', 'BadLength',
'BadImplementation', 'FirstExtensionError', 'LastExtensionError',
'InputOutput', 'InputOnly', 'CWBackPixmap', 'CWBackPixel', 'CWBorderPixmap',
'CWBorderPixel', 'CWBitGravity', 'CWWinGravity', 'CWBackingStore',
'CWBackingPlanes', 'CWBackingPixel', 'CWOverrideRedirect', 'CWSaveUnder',
'CWEventMask', 'CWDontPropagate', 'CWColormap', 'CWCursor', 'CWX', 'CWY',
'CWWidth', 'CWHeight', 'CWBorderWidth', 'CWSibling', 'CWStackMode',
'ForgetGravity', 'NorthWestGravity', 'NorthGravity', 'NorthEastGravity',
'WestGravity', 'CenterGravity', 'EastGravity', 'SouthWestGravity',
'SouthGravity', 'SouthEastGravity', 'StaticGravity', 'UnmapGravity',
'NotUseful', 'WhenMapped', 'Always', 'IsUnmapped', 'IsUnviewable',
'IsViewable', 'SetModeInsert', 'SetModeDelete', 'DestroyAll',
'RetainPermanent', 'RetainTemporary', 'Above', 'Below', 'TopIf', 'BottomIf',
'Opposite', 'RaiseLowest', 'LowerHighest', 'PropModeReplace',
'PropModePrepend', 'PropModeAppend', 'GXclear', 'GXand', 'GXandReverse',
'GXcopy', 'GXandInverted', 'GXnoop', 'GXxor', 'GXor', 'GXnor', 'GXequiv',
'GXinvert', 'GXorReverse', 'GXcopyInverted', 'GXorInverted', 'GXnand',
'GXset', 'LineSolid', 'LineOnOffDash', 'LineDoubleDash', 'CapNotLast',
'CapButt', 'CapRound', 'CapProjecting', 'JoinMiter', 'JoinRound', 'JoinBevel',
'FillSolid', 'FillTiled', 'FillStippled', 'FillOpaqueStippled', 'EvenOddRule',
'WindingRule', 'ClipByChildren', 'IncludeInferiors', 'Unsorted', 'YSorted',
'YXSorted', 'YXBanded', 'CoordModeOrigin', 'CoordModePrevious', 'Complex',
'Nonconvex', 'Convex', 'ArcChord', 'ArcPieSlice', 'GCFunction', 'GCPlaneMask',
'GCForeground', 'GCBackground', 'GCLineWidth', 'GCLineStyle', 'GCCapStyle',
'GCJoinStyle', 'GCFillStyle', 'GCFillRule', 'GCTile', 'GCStipple',
'GCTileStipXOrigin', 'GCTileStipYOrigin', 'GCFont', 'GCSubwindowMode',
'GCGraphicsExposures', 'GCClipXOrigin', 'GCClipYOrigin', 'GCClipMask',
'GCDashOffset', 'GCDashList', 'GCArcMode', 'GCLastBit', 'FontLeftToRight',
'FontRightToLeft', 'FontChange', 'XYBitmap', 'XYPixmap', 'ZPixmap',
'AllocNone', 'AllocAll', 'DoRed', 'DoGreen', 'DoBlue', 'CursorShape',
'TileShape', 'StippleShape', 'AutoRepeatModeOff', 'AutoRepeatModeOn',
'AutoRepeatModeDefault', 'LedModeOff', 'LedModeOn', 'KBKeyClickPercent',
'KBBellPercent', 'KBBellPitch', 'KBBellDuration', 'KBLed', 'KBLedMode',
'KBKey', 'KBAutoRepeatMode', 'MappingSuccess', 'MappingBusy', 'MappingFailed',
'MappingModifier', 'MappingKeyboard', 'MappingPointer', 'DontPreferBlanking',
'PreferBlanking', 'DefaultBlanking', 'DisableScreenSaver',
'DisableScreenInterval', 'DontAllowExposures', 'AllowExposures',
'DefaultExposures', 'ScreenSaverReset', 'ScreenSaverActive', 'HostInsert',
'HostDelete', 'EnableAccess', 'DisableAccess', 'StaticGray', 'GrayScale',
'StaticColor', 'PseudoColor', 'TrueColor', 'DirectColor', 'LSBFirst',
'MSBFirst', '_Xmblen', 'X_HAVE_UTF8_STRING', 'XPointer', 'Bool', 'Status',
'True', 'False', 'QueuedAlready', 'QueuedAfterReading', 'QueuedAfterFlush',
'XExtData', 'XExtCodes', 'XPixmapFormatValues', 'XGCValues', 'GC', 'Visual',
'Depth', 'Screen', 'ScreenFormat', 'XSetWindowAttributes',
'XWindowAttributes', 'XHostAddress', 'XServerInterpretedAddress', 'XImage',
'XWindowChanges', 'XColor', 'XSegment', 'XPoint', 'XRectangle', 'XArc',
'XKeyboardControl', 'XKeyboardState', 'XTimeCoord', 'XModifierKeymap',
'Display', '_XPrivDisplay', 'XKeyEvent', 'XKeyPressedEvent',
'XKeyReleasedEvent', 'XButtonEvent', 'XButtonPressedEvent',
'XButtonReleasedEvent', 'XMotionEvent', 'XPointerMovedEvent',
'XCrossingEvent', 'XEnterWindowEvent', 'XLeaveWindowEvent',
'XFocusChangeEvent', 'XFocusInEvent', 'XFocusOutEvent', 'XKeymapEvent',
'XExposeEvent', 'XGraphicsExposeEvent', 'XNoExposeEvent', 'XVisibilityEvent',
'XCreateWindowEvent', 'XDestroyWindowEvent', 'XUnmapEvent', 'XMapEvent',
'XMapRequestEvent', 'XReparentEvent', 'XConfigureEvent', 'XGravityEvent',
'XResizeRequestEvent', 'XConfigureRequestEvent', 'XCirculateEvent',
'XCirculateRequestEvent', 'XPropertyEvent', 'XSelectionClearEvent',
'XSelectionRequestEvent', 'XSelectionEvent', 'XColormapEvent',
'XClientMessageEvent', 'XMappingEvent', 'XErrorEvent', 'XAnyEvent', 'XEvent',
'XCharStruct', 'XFontProp', 'XFontStruct', 'XTextItem', 'XChar2b',
'XTextItem16', 'XEDataObject', 'XFontSetExtents', 'XOM', 'XOC', 'XFontSet',
'XmbTextItem', 'XwcTextItem', 'XOMCharSetList', 'XOrientation',
'XOMOrientation_LTR_TTB', 'XOMOrientation_RTL_TTB', 'XOMOrientation_TTB_LTR',
'XOMOrientation_TTB_RTL', 'XOMOrientation_Context', 'XOMOrientation',
'XOMFontInfo', 'XIM', 'XIC', 'XIMProc', 'XICProc', 'XIDProc', 'XIMStyle',
'XIMStyles', 'XIMPreeditArea', 'XIMPreeditCallbacks', 'XIMPreeditPosition',
'XIMPreeditNothing', 'XIMPreeditNone', 'XIMStatusArea', 'XIMStatusCallbacks',
'XIMStatusNothing', 'XIMStatusNone', 'XBufferOverflow', 'XLookupNone',
'XLookupChars', 'XLookupKeySym', 'XLookupBoth', 'XVaNestedList',
'XIMCallback', 'XICCallback', 'XIMFeedback', 'XIMReverse', 'XIMUnderline',
'XIMHighlight', 'XIMPrimary', 'XIMSecondary', 'XIMTertiary',
'XIMVisibleToForward', 'XIMVisibleToBackword', 'XIMVisibleToCenter',
'XIMText', 'XIMPreeditState', 'XIMPreeditUnKnown', 'XIMPreeditEnable',
'XIMPreeditDisable', 'XIMPreeditStateNotifyCallbackStruct', 'XIMResetState',
'XIMInitialState', 'XIMPreserveState', 'XIMStringConversionFeedback',
'XIMStringConversionLeftEdge', 'XIMStringConversionRightEdge',
'XIMStringConversionTopEdge', 'XIMStringConversionBottomEdge',
'XIMStringConversionConcealed', 'XIMStringConversionWrapped',
'XIMStringConversionText', 'XIMStringConversionPosition',
'XIMStringConversionType', 'XIMStringConversionBuffer',
'XIMStringConversionLine', 'XIMStringConversionWord',
'XIMStringConversionChar', 'XIMStringConversionOperation',
'XIMStringConversionSubstitution', 'XIMStringConversionRetrieval',
'XIMCaretDirection', 'XIMForwardChar', 'XIMBackwardChar', 'XIMForwardWord',
'XIMBackwardWord', 'XIMCaretUp', 'XIMCaretDown', 'XIMNextLine',
'XIMPreviousLine', 'XIMLineStart', 'XIMLineEnd', 'XIMAbsolutePosition',
'XIMDontChange', 'XIMStringConversionCallbackStruct',
'XIMPreeditDrawCallbackStruct', 'XIMCaretStyle', 'XIMIsInvisible',
'XIMIsPrimary', 'XIMIsSecondary', 'XIMPreeditCaretCallbackStruct',
'XIMStatusDataType', 'XIMTextType', 'XIMBitmapType',
'XIMStatusDrawCallbackStruct', 'XIMHotKeyTrigger', 'XIMHotKeyTriggers',
'XIMHotKeyState', 'XIMHotKeyStateON', 'XIMHotKeyStateOFF', 'XIMValuesList',
'XLoadQueryFont', 'XQueryFont', 'XGetMotionEvents', 'XDeleteModifiermapEntry',
'XGetModifierMapping', 'XInsertModifiermapEntry', 'XNewModifiermap',
'XCreateImage', 'XInitImage', 'XGetImage', 'XGetSubImage', 'XOpenDisplay',
'XrmInitialize', 'XFetchBytes', 'XFetchBuffer', 'XGetAtomName',
'XGetAtomNames', 'XGetDefault', 'XDisplayName', 'XKeysymToString',
'XSynchronize', 'XSetAfterFunction', 'XInternAtom', 'XInternAtoms',
'XCopyColormapAndFree', 'XCreateColormap', 'XCreatePixmapCursor',
'XCreateGlyphCursor', 'XCreateFontCursor', 'XLoadFont', 'XCreateGC',
'XGContextFromGC', 'XFlushGC', 'XCreatePixmap', 'XCreateBitmapFromData',
'XCreatePixmapFromBitmapData', 'XCreateSimpleWindow', 'XGetSelectionOwner',
'XCreateWindow', 'XListInstalledColormaps', 'XListFonts',
'XListFontsWithInfo', 'XGetFontPath', 'XListExtensions', 'XListProperties',
'XListHosts', 'XKeycodeToKeysym', 'XLookupKeysym', 'XGetKeyboardMapping',
'XStringToKeysym', 'XMaxRequestSize', 'XExtendedMaxRequestSize',
'XResourceManagerString', 'XScreenResourceString', 'XDisplayMotionBufferSize',
'XVisualIDFromVisual', 'XInitThreads', 'XLockDisplay', 'XUnlockDisplay',
'XInitExtension', 'XAddExtension', 'XFindOnExtensionList',
'XEHeadOfExtensionList', 'XRootWindow', 'XDefaultRootWindow',
'XRootWindowOfScreen', 'XDefaultVisual', 'XDefaultVisualOfScreen',
'XDefaultGC', 'XDefaultGCOfScreen', 'XBlackPixel', 'XWhitePixel',
'XAllPlanes', 'XBlackPixelOfScreen', 'XWhitePixelOfScreen', 'XNextRequest',
'XLastKnownRequestProcessed', 'XServerVendor', 'XDisplayString',
'XDefaultColormap', 'XDefaultColormapOfScreen', 'XDisplayOfScreen',
'XScreenOfDisplay', 'XDefaultScreenOfDisplay', 'XEventMaskOfScreen',
'XScreenNumberOfScreen', 'XErrorHandler', 'XSetErrorHandler',
'XIOErrorHandler', 'XSetIOErrorHandler', 'XListPixmapFormats', 'XListDepths',
'XReconfigureWMWindow', 'XGetWMProtocols', 'XSetWMProtocols',
'XIconifyWindow', 'XWithdrawWindow', 'XGetCommand', 'XGetWMColormapWindows',
'XSetWMColormapWindows', 'XFreeStringList', 'XSetTransientForHint',
'XActivateScreenSaver', 'XAddHost', 'XAddHosts', 'XAddToExtensionList',
'XAddToSaveSet', 'XAllocColor', 'XAllocColorCells', 'XAllocColorPlanes',
'XAllocNamedColor', 'XAllowEvents', 'XAutoRepeatOff', 'XAutoRepeatOn',
'XBell', 'XBitmapBitOrder', 'XBitmapPad', 'XBitmapUnit', 'XCellsOfScreen',
'XChangeActivePointerGrab', 'XChangeGC', 'XChangeKeyboardControl',
'XChangeKeyboardMapping', 'XChangePointerControl', 'XChangeProperty',
'XChangeSaveSet', 'XChangeWindowAttributes', 'XCheckIfEvent',
'XCheckMaskEvent', 'XCheckTypedEvent', 'XCheckTypedWindowEvent',
'XCheckWindowEvent', 'XCirculateSubwindows', 'XCirculateSubwindowsDown',
'XCirculateSubwindowsUp', 'XClearArea', 'XClearWindow', 'XCloseDisplay',
'XConfigureWindow', 'XConnectionNumber', 'XConvertSelection', 'XCopyArea',
'XCopyGC', 'XCopyPlane', 'XDefaultDepth', 'XDefaultDepthOfScreen',
'XDefaultScreen', 'XDefineCursor', 'XDeleteProperty', 'XDestroyWindow',
'XDestroySubwindows', 'XDoesBackingStore', 'XDoesSaveUnders',
'XDisableAccessControl', 'XDisplayCells', 'XDisplayHeight',
'XDisplayHeightMM', 'XDisplayKeycodes', 'XDisplayPlanes', 'XDisplayWidth',
'XDisplayWidthMM', 'XDrawArc', 'XDrawArcs', 'XDrawImageString',
'XDrawImageString16', 'XDrawLine', 'XDrawLines', 'XDrawPoint', 'XDrawPoints',
'XDrawRectangle', 'XDrawRectangles', 'XDrawSegments', 'XDrawString',
'XDrawString16', 'XDrawText', 'XDrawText16', 'XEnableAccessControl',
'XEventsQueued', 'XFetchName', 'XFillArc', 'XFillArcs', 'XFillPolygon',
'XFillRectangle', 'XFillRectangles', 'XFlush', 'XForceScreenSaver', 'XFree',
'XFreeColormap', 'XFreeColors', 'XFreeCursor', 'XFreeExtensionList',
'XFreeFont', 'XFreeFontInfo', 'XFreeFontNames', 'XFreeFontPath', 'XFreeGC',
'XFreeModifiermap', 'XFreePixmap', 'XGeometry', 'XGetErrorDatabaseText',
'XGetErrorText', 'XGetFontProperty', 'XGetGCValues', 'XGetGeometry',
'XGetIconName', 'XGetInputFocus', 'XGetKeyboardControl', 'XGetPointerControl',
'XGetPointerMapping', 'XGetScreenSaver', 'XGetTransientForHint',
'XGetWindowProperty', 'XGetWindowAttributes', 'XGrabButton', 'XGrabKey',
'XGrabKeyboard', 'XGrabPointer', 'XGrabServer', 'XHeightMMOfScreen',
'XHeightOfScreen', 'XIfEvent', 'XImageByteOrder', 'XInstallColormap',
'XKeysymToKeycode', 'XKillClient', 'XLookupColor', 'XLowerWindow',
'XMapRaised', 'XMapSubwindows', 'XMapWindow', 'XMaskEvent',
'XMaxCmapsOfScreen', 'XMinCmapsOfScreen', 'XMoveResizeWindow', 'XMoveWindow',
'XNextEvent', 'XNoOp', 'XParseColor', 'XParseGeometry', 'XPeekEvent',
'XPeekIfEvent', 'XPending', 'XPlanesOfScreen', 'XProtocolRevision',
'XProtocolVersion', 'XPutBackEvent', 'XPutImage', 'XQLength',
'XQueryBestCursor', 'XQueryBestSize', 'XQueryBestStipple', 'XQueryBestTile',
'XQueryColor', 'XQueryColors', 'XQueryExtension', 'XQueryKeymap',
'XQueryPointer', 'XQueryTextExtents', 'XQueryTextExtents16', 'XQueryTree',
'XRaiseWindow', 'XReadBitmapFile', 'XReadBitmapFileData', 'XRebindKeysym',
'XRecolorCursor', 'XRefreshKeyboardMapping', 'XRemoveFromSaveSet',
'XRemoveHost', 'XRemoveHosts', 'XReparentWindow', 'XResetScreenSaver',
'XResizeWindow', 'XRestackWindows', 'XRotateBuffers',
'XRotateWindowProperties', 'XScreenCount', 'XSelectInput', 'XSendEvent',
'XSetAccessControl', 'XSetArcMode', 'XSetBackground', 'XSetClipMask',
'XSetClipOrigin', 'XSetClipRectangles', 'XSetCloseDownMode', 'XSetCommand',
'XSetDashes', 'XSetFillRule', 'XSetFillStyle', 'XSetFont', 'XSetFontPath',
'XSetForeground', 'XSetFunction', 'XSetGraphicsExposures', 'XSetIconName',
'XSetInputFocus', 'XSetLineAttributes', 'XSetModifierMapping',
'XSetPlaneMask', 'XSetPointerMapping', 'XSetScreenSaver',
'XSetSelectionOwner', 'XSetState', 'XSetStipple', 'XSetSubwindowMode',
'XSetTSOrigin', 'XSetTile', 'XSetWindowBackground',
'XSetWindowBackgroundPixmap', 'XSetWindowBorder', 'XSetWindowBorderPixmap',
'XSetWindowBorderWidth', 'XSetWindowColormap', 'XStoreBuffer', 'XStoreBytes',
'XStoreColor', 'XStoreColors', 'XStoreName', 'XStoreNamedColor', 'XSync',
'XTextExtents', 'XTextExtents16', 'XTextWidth', 'XTextWidth16',
'XTranslateCoordinates', 'XUndefineCursor', 'XUngrabButton', 'XUngrabKey',
'XUngrabKeyboard', 'XUngrabPointer', 'XUngrabServer', 'XUninstallColormap',
'XUnloadFont', 'XUnmapSubwindows', 'XUnmapWindow', 'XVendorRelease',
'XWarpPointer', 'XWidthMMOfScreen', 'XWidthOfScreen', 'XWindowEvent',
'XWriteBitmapFile', 'XSupportsLocale', 'XSetLocaleModifiers', 'XOpenOM',
'XCloseOM', 'XSetOMValues', 'XGetOMValues', 'XDisplayOfOM', 'XLocaleOfOM',
'XCreateOC', 'XDestroyOC', 'XOMOfOC', 'XSetOCValues', 'XGetOCValues',
'XCreateFontSet', 'XFreeFontSet', 'XFontsOfFontSet',
'XBaseFontNameListOfFontSet', 'XLocaleOfFontSet', 'XContextDependentDrawing',
'XDirectionalDependentDrawing', 'XContextualDrawing', 'XExtentsOfFontSet',
'XmbTextEscapement', 'XwcTextEscapement', 'Xutf8TextEscapement',
'XmbTextExtents', 'XwcTextExtents', 'Xutf8TextExtents',
'XmbTextPerCharExtents', 'XwcTextPerCharExtents', 'Xutf8TextPerCharExtents',
'XmbDrawText', 'XwcDrawText', 'Xutf8DrawText', 'XmbDrawString',
'XwcDrawString', 'Xutf8DrawString', 'XmbDrawImageString',
'XwcDrawImageString', 'Xutf8DrawImageString', 'XOpenIM', 'XCloseIM',
'XGetIMValues', 'XSetIMValues', 'XDisplayOfIM', 'XLocaleOfIM', 'XCreateIC',
'XDestroyIC', 'XSetICFocus', 'XUnsetICFocus', 'XwcResetIC', 'XmbResetIC',
'Xutf8ResetIC', 'XSetICValues', 'XGetICValues', 'XIMOfIC', 'XFilterEvent',
'XmbLookupString', 'XwcLookupString', 'Xutf8LookupString',
'XVaCreateNestedList', 'XRegisterIMInstantiateCallback',
'XUnregisterIMInstantiateCallback', 'XConnectionWatchProc',
'XInternalConnectionNumbers', 'XProcessInternalConnection',
'XAddConnectionWatch', 'XRemoveConnectionWatch', 'XSetAuthorization',
'_Xmbtowc', '_Xwctomb', 'NoValue', 'XValue', 'YValue', 'WidthValue',
'HeightValue', 'AllValues', 'XNegative', 'YNegative', 'XSizeHints',
'USPosition', 'USSize', 'PPosition', 'PSize', 'PMinSize', 'PMaxSize',
'PResizeInc', 'PAspect', 'PBaseSize', 'PWinGravity', 'PAllHints', 'XWMHints',
'InputHint', 'StateHint', 'IconPixmapHint', 'IconWindowHint',
'IconPositionHint', 'IconMaskHint', 'WindowGroupHint', 'AllHints',
'XUrgencyHint', 'WithdrawnState', 'NormalState', 'IconicState',
'DontCareState', 'ZoomState', 'InactiveState', 'XTextProperty', 'XNoMemory',
'XLocaleNotSupported', 'XConverterNotFound', 'XICCEncodingStyle',
'XStringStyle', 'XCompoundTextStyle', 'XTextStyle', 'XStdICCTextStyle',
'XUTF8StringStyle', 'XIconSize', 'XClassHint', 'XComposeStatus', 'Region',
'RectangleOut', 'RectangleIn', 'RectanglePart', 'XVisualInfo', 'VisualNoMask',
'VisualIDMask', 'VisualScreenMask', 'VisualDepthMask', 'VisualClassMask',
'VisualRedMaskMask', 'VisualGreenMaskMask', 'VisualBlueMaskMask',
'VisualColormapSizeMask', 'VisualBitsPerRGBMask', 'VisualAllMask',
'XStandardColormap', 'BitmapSuccess', 'BitmapOpenFailed', 'BitmapFileInvalid',
'BitmapNoMemory', 'XCSUCCESS', 'XCNOMEM', 'XCNOENT', 'XContext',
'XAllocClassHint', 'XAllocIconSize', 'XAllocSizeHints',
'XAllocStandardColormap', 'XAllocWMHints', 'XClipBox', 'XCreateRegion',
'XDefaultString', 'XDeleteContext', 'XDestroyRegion', 'XEmptyRegion',
'XEqualRegion', 'XFindContext', 'XGetClassHint', 'XGetIconSizes',
'XGetNormalHints', 'XGetRGBColormaps', 'XGetSizeHints',
'XGetStandardColormap', 'XGetTextProperty', 'XGetVisualInfo',
'XGetWMClientMachine', 'XGetWMHints', 'XGetWMIconName', 'XGetWMName',
'XGetWMNormalHints', 'XGetWMSizeHints', 'XGetZoomHints', 'XIntersectRegion',
'XConvertCase', 'XLookupString', 'XMatchVisualInfo', 'XOffsetRegion',
'XPointInRegion', 'XPolygonRegion', 'XRectInRegion', 'XSaveContext',
'XSetClassHint', 'XSetIconSizes', 'XSetNormalHints', 'XSetRGBColormaps',
'XSetSizeHints', 'XSetStandardProperties', 'XSetTextProperty',
'XSetWMClientMachine', 'XSetWMHints', 'XSetWMIconName', 'XSetWMName',
'XSetWMNormalHints', 'XSetWMProperties', 'XmbSetWMProperties',
'Xutf8SetWMProperties', 'XSetWMSizeHints', 'XSetRegion',
'XSetStandardColormap', 'XSetZoomHints', 'XShrinkRegion',
'XStringListToTextProperty', 'XSubtractRegion', 'XmbTextListToTextProperty',
'XwcTextListToTextProperty', 'Xutf8TextListToTextProperty',
'XwcFreeStringList', 'XTextPropertyToStringList', 'XmbTextPropertyToTextList',
'XwcTextPropertyToTextList', 'Xutf8TextPropertyToTextList',
'XUnionRectWithRegion', 'XUnionRegion', 'XWMGeometry', 'XXorRegion']

########NEW FILE########
__FILENAME__ = xsync
# ----------------------------------------------------------------------------
# pyglet
# Copyright (c) 2006-2008 Alex Holkner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of pyglet nor the names of its
#    contributors may be used to endorse or promote products
#    derived from this software without specific prior written
#    permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------
'''Wrapper for Xext

Generated with:
tools/genwrappers.py xsync

Do not modify this file.
'''

__docformat__ =  'restructuredtext'
__version__ = '$Id: xsync.py 1848 2008-03-01 04:21:43Z Alex.Holkner $'

import ctypes
from ctypes import *

import pyglet.lib

_lib = pyglet.lib.load_library('Xext')

_int_types = (c_int16, c_int32)
if hasattr(ctypes, 'c_int64'):
    # Some builds of ctypes apparently do not have c_int64
    # defined; it's a pretty good bet that these builds do not
    # have 64-bit pointers.
    _int_types += (ctypes.c_int64,)
for t in _int_types:
    if sizeof(t) == sizeof(c_size_t):
        c_ptrdiff_t = t

class c_void(Structure):
    # c_void_p is a buggy return type, converting to int, so
    # POINTER(None) == c_void_p is actually written as
    # POINTER(c_void), so it can be treated as a real pointer.
    _fields_ = [('dummy', c_int)]


# XXX DODGY relative import of xlib.py, which contains XID etc definitions.
# can't use wrapped import which gave
#   import pyglet.window.xlib.xlib
# because Python has the lamest import semantics and can't handle that kind of
# recursive import, even though it's the same as
import xlib

SYNC_MAJOR_VERSION = 3 	# /usr/include/X11/extensions/sync.h:4901
SYNC_MINOR_VERSION = 0 	# /usr/include/X11/extensions/sync.h:4902
X_SyncInitialize = 0 	# /usr/include/X11/extensions/sync.h:4904
X_SyncListSystemCounters = 1 	# /usr/include/X11/extensions/sync.h:4905
X_SyncCreateCounter = 2 	# /usr/include/X11/extensions/sync.h:4906
X_SyncSetCounter = 3 	# /usr/include/X11/extensions/sync.h:4907
X_SyncChangeCounter = 4 	# /usr/include/X11/extensions/sync.h:4908
X_SyncQueryCounter = 5 	# /usr/include/X11/extensions/sync.h:4909
X_SyncDestroyCounter = 6 	# /usr/include/X11/extensions/sync.h:4910
X_SyncAwait = 7 	# /usr/include/X11/extensions/sync.h:4911
X_SyncCreateAlarm = 8 	# /usr/include/X11/extensions/sync.h:4912
X_SyncChangeAlarm = 9 	# /usr/include/X11/extensions/sync.h:4913
X_SyncQueryAlarm = 10 	# /usr/include/X11/extensions/sync.h:4914
X_SyncDestroyAlarm = 11 	# /usr/include/X11/extensions/sync.h:4915
X_SyncSetPriority = 12 	# /usr/include/X11/extensions/sync.h:4916
X_SyncGetPriority = 13 	# /usr/include/X11/extensions/sync.h:4917
XSyncCounterNotify = 0 	# /usr/include/X11/extensions/sync.h:4919
XSyncAlarmNotify = 1 	# /usr/include/X11/extensions/sync.h:4920
XSyncAlarmNotifyMask = 2 	# /usr/include/X11/extensions/sync.h:4921
XSyncNumberEvents = 2 	# /usr/include/X11/extensions/sync.h:4923
XSyncBadCounter = 0 	# /usr/include/X11/extensions/sync.h:4925
XSyncBadAlarm = 1 	# /usr/include/X11/extensions/sync.h:4926
XSyncNumberErrors = 2 	# /usr/include/X11/extensions/sync.h:4927
XSyncCACounter = 1 	# /usr/include/X11/extensions/sync.h:4932
XSyncCAValueType = 2 	# /usr/include/X11/extensions/sync.h:4933
XSyncCAValue = 4 	# /usr/include/X11/extensions/sync.h:4934
XSyncCATestType = 8 	# /usr/include/X11/extensions/sync.h:4935
XSyncCADelta = 16 	# /usr/include/X11/extensions/sync.h:4936
XSyncCAEvents = 32 	# /usr/include/X11/extensions/sync.h:4937
enum_anon_93 = c_int
XSyncAbsolute = 0
XSyncRelative = 1
XSyncValueType = enum_anon_93 	# /usr/include/X11/extensions/sync.h:4945
enum_anon_94 = c_int
XSyncPositiveTransition = 0
XSyncNegativeTransition = 1
XSyncPositiveComparison = 2
XSyncNegativeComparison = 3
XSyncTestType = enum_anon_94 	# /usr/include/X11/extensions/sync.h:4955
enum_anon_95 = c_int
XSyncAlarmActive = 0
XSyncAlarmInactive = 1
XSyncAlarmDestroyed = 2
XSyncAlarmState = enum_anon_95 	# /usr/include/X11/extensions/sync.h:4964
XID = xlib.XID
XSyncCounter = XID 	# /usr/include/X11/extensions/sync.h:4967
XSyncAlarm = XID 	# /usr/include/X11/extensions/sync.h:4968
class struct__XSyncValue(Structure):
    __slots__ = [
        'hi',
        'lo',
    ]
struct__XSyncValue._fields_ = [
    ('hi', c_int),
    ('lo', c_uint),
]

XSyncValue = struct__XSyncValue 	# /usr/include/X11/extensions/sync.h:4972
# /usr/include/X11/extensions/sync.h:4980
XSyncIntToValue = _lib.XSyncIntToValue
XSyncIntToValue.restype = None
XSyncIntToValue.argtypes = [POINTER(XSyncValue), c_int]

# /usr/include/X11/extensions/sync.h:4985
XSyncIntsToValue = _lib.XSyncIntsToValue
XSyncIntsToValue.restype = None
XSyncIntsToValue.argtypes = [POINTER(XSyncValue), c_uint, c_int]

Bool = xlib.Bool
# /usr/include/X11/extensions/sync.h:4991
XSyncValueGreaterThan = _lib.XSyncValueGreaterThan
XSyncValueGreaterThan.restype = Bool
XSyncValueGreaterThan.argtypes = [XSyncValue, XSyncValue]

# /usr/include/X11/extensions/sync.h:4996
XSyncValueLessThan = _lib.XSyncValueLessThan
XSyncValueLessThan.restype = Bool
XSyncValueLessThan.argtypes = [XSyncValue, XSyncValue]

# /usr/include/X11/extensions/sync.h:5001
XSyncValueGreaterOrEqual = _lib.XSyncValueGreaterOrEqual
XSyncValueGreaterOrEqual.restype = Bool
XSyncValueGreaterOrEqual.argtypes = [XSyncValue, XSyncValue]

# /usr/include/X11/extensions/sync.h:5006
XSyncValueLessOrEqual = _lib.XSyncValueLessOrEqual
XSyncValueLessOrEqual.restype = Bool
XSyncValueLessOrEqual.argtypes = [XSyncValue, XSyncValue]

# /usr/include/X11/extensions/sync.h:5011
XSyncValueEqual = _lib.XSyncValueEqual
XSyncValueEqual.restype = Bool
XSyncValueEqual.argtypes = [XSyncValue, XSyncValue]

# /usr/include/X11/extensions/sync.h:5016
XSyncValueIsNegative = _lib.XSyncValueIsNegative
XSyncValueIsNegative.restype = Bool
XSyncValueIsNegative.argtypes = [XSyncValue]

# /usr/include/X11/extensions/sync.h:5020
XSyncValueIsZero = _lib.XSyncValueIsZero
XSyncValueIsZero.restype = Bool
XSyncValueIsZero.argtypes = [XSyncValue]

# /usr/include/X11/extensions/sync.h:5024
XSyncValueIsPositive = _lib.XSyncValueIsPositive
XSyncValueIsPositive.restype = Bool
XSyncValueIsPositive.argtypes = [XSyncValue]

# /usr/include/X11/extensions/sync.h:5028
XSyncValueLow32 = _lib.XSyncValueLow32
XSyncValueLow32.restype = c_uint
XSyncValueLow32.argtypes = [XSyncValue]

# /usr/include/X11/extensions/sync.h:5032
XSyncValueHigh32 = _lib.XSyncValueHigh32
XSyncValueHigh32.restype = c_int
XSyncValueHigh32.argtypes = [XSyncValue]

# /usr/include/X11/extensions/sync.h:5036
XSyncValueAdd = _lib.XSyncValueAdd
XSyncValueAdd.restype = None
XSyncValueAdd.argtypes = [POINTER(XSyncValue), XSyncValue, XSyncValue, POINTER(c_int)]

# /usr/include/X11/extensions/sync.h:5043
XSyncValueSubtract = _lib.XSyncValueSubtract
XSyncValueSubtract.restype = None
XSyncValueSubtract.argtypes = [POINTER(XSyncValue), XSyncValue, XSyncValue, POINTER(c_int)]

# /usr/include/X11/extensions/sync.h:5050
XSyncMaxValue = _lib.XSyncMaxValue
XSyncMaxValue.restype = None
XSyncMaxValue.argtypes = [POINTER(XSyncValue)]

# /usr/include/X11/extensions/sync.h:5054
XSyncMinValue = _lib.XSyncMinValue
XSyncMinValue.restype = None
XSyncMinValue.argtypes = [POINTER(XSyncValue)]

class struct__XSyncSystemCounter(Structure):
    __slots__ = [
        'name',
        'counter',
        'resolution',
    ]
struct__XSyncSystemCounter._fields_ = [
    ('name', c_char_p),
    ('counter', XSyncCounter),
    ('resolution', XSyncValue),
]

XSyncSystemCounter = struct__XSyncSystemCounter 	# /usr/include/X11/extensions/sync.h:5131
class struct_anon_96(Structure):
    __slots__ = [
        'counter',
        'value_type',
        'wait_value',
        'test_type',
    ]
struct_anon_96._fields_ = [
    ('counter', XSyncCounter),
    ('value_type', XSyncValueType),
    ('wait_value', XSyncValue),
    ('test_type', XSyncTestType),
]

XSyncTrigger = struct_anon_96 	# /usr/include/X11/extensions/sync.h:5139
class struct_anon_97(Structure):
    __slots__ = [
        'trigger',
        'event_threshold',
    ]
struct_anon_97._fields_ = [
    ('trigger', XSyncTrigger),
    ('event_threshold', XSyncValue),
]

XSyncWaitCondition = struct_anon_97 	# /usr/include/X11/extensions/sync.h:5144
class struct_anon_98(Structure):
    __slots__ = [
        'trigger',
        'delta',
        'events',
        'state',
    ]
struct_anon_98._fields_ = [
    ('trigger', XSyncTrigger),
    ('delta', XSyncValue),
    ('events', Bool),
    ('state', XSyncAlarmState),
]

XSyncAlarmAttributes = struct_anon_98 	# /usr/include/X11/extensions/sync.h:5152
class struct_anon_99(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'counter',
        'wait_value',
        'counter_value',
        'time',
        'count',
        'destroyed',
    ]
Display = xlib.Display
Time = xlib.Time
struct_anon_99._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', Bool),
    ('display', POINTER(Display)),
    ('counter', XSyncCounter),
    ('wait_value', XSyncValue),
    ('counter_value', XSyncValue),
    ('time', Time),
    ('count', c_int),
    ('destroyed', Bool),
]

XSyncCounterNotifyEvent = struct_anon_99 	# /usr/include/X11/extensions/sync.h:5169
class struct_anon_100(Structure):
    __slots__ = [
        'type',
        'serial',
        'send_event',
        'display',
        'alarm',
        'counter_value',
        'alarm_value',
        'time',
        'state',
    ]
struct_anon_100._fields_ = [
    ('type', c_int),
    ('serial', c_ulong),
    ('send_event', Bool),
    ('display', POINTER(Display)),
    ('alarm', XSyncAlarm),
    ('counter_value', XSyncValue),
    ('alarm_value', XSyncValue),
    ('time', Time),
    ('state', XSyncAlarmState),
]

XSyncAlarmNotifyEvent = struct_anon_100 	# /usr/include/X11/extensions/sync.h:5181
class struct_anon_101(Structure):
    __slots__ = [
        'type',
        'display',
        'alarm',
        'serial',
        'error_code',
        'request_code',
        'minor_code',
    ]
struct_anon_101._fields_ = [
    ('type', c_int),
    ('display', POINTER(Display)),
    ('alarm', XSyncAlarm),
    ('serial', c_ulong),
    ('error_code', c_ubyte),
    ('request_code', c_ubyte),
    ('minor_code', c_ubyte),
]

XSyncAlarmError = struct_anon_101 	# /usr/include/X11/extensions/sync.h:5195
class struct_anon_102(Structure):
    __slots__ = [
        'type',
        'display',
        'counter',
        'serial',
        'error_code',
        'request_code',
        'minor_code',
    ]
struct_anon_102._fields_ = [
    ('type', c_int),
    ('display', POINTER(Display)),
    ('counter', XSyncCounter),
    ('serial', c_ulong),
    ('error_code', c_ubyte),
    ('request_code', c_ubyte),
    ('minor_code', c_ubyte),
]

XSyncCounterError = struct_anon_102 	# /usr/include/X11/extensions/sync.h:5205
# /usr/include/X11/extensions/sync.h:5213
XSyncQueryExtension = _lib.XSyncQueryExtension
XSyncQueryExtension.restype = c_int
XSyncQueryExtension.argtypes = [POINTER(Display), POINTER(c_int), POINTER(c_int)]

# /usr/include/X11/extensions/sync.h:5219
XSyncInitialize = _lib.XSyncInitialize
XSyncInitialize.restype = c_int
XSyncInitialize.argtypes = [POINTER(Display), POINTER(c_int), POINTER(c_int)]

# /usr/include/X11/extensions/sync.h:5225
XSyncListSystemCounters = _lib.XSyncListSystemCounters
XSyncListSystemCounters.restype = POINTER(XSyncSystemCounter)
XSyncListSystemCounters.argtypes = [POINTER(Display), POINTER(c_int)]

# /usr/include/X11/extensions/sync.h:5230
XSyncFreeSystemCounterList = _lib.XSyncFreeSystemCounterList
XSyncFreeSystemCounterList.restype = None
XSyncFreeSystemCounterList.argtypes = [POINTER(XSyncSystemCounter)]

# /usr/include/X11/extensions/sync.h:5234
XSyncCreateCounter = _lib.XSyncCreateCounter
XSyncCreateCounter.restype = XSyncCounter
XSyncCreateCounter.argtypes = [POINTER(Display), XSyncValue]

# /usr/include/X11/extensions/sync.h:5239
XSyncSetCounter = _lib.XSyncSetCounter
XSyncSetCounter.restype = c_int
XSyncSetCounter.argtypes = [POINTER(Display), XSyncCounter, XSyncValue]

# /usr/include/X11/extensions/sync.h:5245
XSyncChangeCounter = _lib.XSyncChangeCounter
XSyncChangeCounter.restype = c_int
XSyncChangeCounter.argtypes = [POINTER(Display), XSyncCounter, XSyncValue]

# /usr/include/X11/extensions/sync.h:5251
XSyncDestroyCounter = _lib.XSyncDestroyCounter
XSyncDestroyCounter.restype = c_int
XSyncDestroyCounter.argtypes = [POINTER(Display), XSyncCounter]

# /usr/include/X11/extensions/sync.h:5256
XSyncQueryCounter = _lib.XSyncQueryCounter
XSyncQueryCounter.restype = c_int
XSyncQueryCounter.argtypes = [POINTER(Display), XSyncCounter, POINTER(XSyncValue)]

# /usr/include/X11/extensions/sync.h:5262
XSyncAwait = _lib.XSyncAwait
XSyncAwait.restype = c_int
XSyncAwait.argtypes = [POINTER(Display), POINTER(XSyncWaitCondition), c_int]

# /usr/include/X11/extensions/sync.h:5268
XSyncCreateAlarm = _lib.XSyncCreateAlarm
XSyncCreateAlarm.restype = XSyncAlarm
XSyncCreateAlarm.argtypes = [POINTER(Display), c_ulong, POINTER(XSyncAlarmAttributes)]

# /usr/include/X11/extensions/sync.h:5274
XSyncDestroyAlarm = _lib.XSyncDestroyAlarm
XSyncDestroyAlarm.restype = c_int
XSyncDestroyAlarm.argtypes = [POINTER(Display), XSyncAlarm]

# /usr/include/X11/extensions/sync.h:5279
XSyncQueryAlarm = _lib.XSyncQueryAlarm
XSyncQueryAlarm.restype = c_int
XSyncQueryAlarm.argtypes = [POINTER(Display), XSyncAlarm, POINTER(XSyncAlarmAttributes)]

# /usr/include/X11/extensions/sync.h:5285
XSyncChangeAlarm = _lib.XSyncChangeAlarm
XSyncChangeAlarm.restype = c_int
XSyncChangeAlarm.argtypes = [POINTER(Display), XSyncAlarm, c_ulong, POINTER(XSyncAlarmAttributes)]

# /usr/include/X11/extensions/sync.h:5292
XSyncSetPriority = _lib.XSyncSetPriority
XSyncSetPriority.restype = c_int
XSyncSetPriority.argtypes = [POINTER(Display), XID, c_int]

# /usr/include/X11/extensions/sync.h:5298
XSyncGetPriority = _lib.XSyncGetPriority
XSyncGetPriority.restype = c_int
XSyncGetPriority.argtypes = [POINTER(Display), XID, POINTER(c_int)]


__all__ = ['SYNC_MAJOR_VERSION', 'SYNC_MINOR_VERSION', 'X_SyncInitialize',
'X_SyncListSystemCounters', 'X_SyncCreateCounter', 'X_SyncSetCounter',
'X_SyncChangeCounter', 'X_SyncQueryCounter', 'X_SyncDestroyCounter',
'X_SyncAwait', 'X_SyncCreateAlarm', 'X_SyncChangeAlarm', 'X_SyncQueryAlarm',
'X_SyncDestroyAlarm', 'X_SyncSetPriority', 'X_SyncGetPriority',
'XSyncCounterNotify', 'XSyncAlarmNotify', 'XSyncAlarmNotifyMask',
'XSyncNumberEvents', 'XSyncBadCounter', 'XSyncBadAlarm', 'XSyncNumberErrors',
'XSyncCACounter', 'XSyncCAValueType', 'XSyncCAValue', 'XSyncCATestType',
'XSyncCADelta', 'XSyncCAEvents', 'XSyncValueType', 'XSyncAbsolute',
'XSyncRelative', 'XSyncTestType', 'XSyncPositiveTransition',
'XSyncNegativeTransition', 'XSyncPositiveComparison',
'XSyncNegativeComparison', 'XSyncAlarmState', 'XSyncAlarmActive',
'XSyncAlarmInactive', 'XSyncAlarmDestroyed', 'XSyncCounter', 'XSyncAlarm',
'XSyncValue', 'XSyncIntToValue', 'XSyncIntsToValue', 'XSyncValueGreaterThan',
'XSyncValueLessThan', 'XSyncValueGreaterOrEqual', 'XSyncValueLessOrEqual',
'XSyncValueEqual', 'XSyncValueIsNegative', 'XSyncValueIsZero',
'XSyncValueIsPositive', 'XSyncValueLow32', 'XSyncValueHigh32',
'XSyncValueAdd', 'XSyncValueSubtract', 'XSyncMaxValue', 'XSyncMinValue',
'XSyncSystemCounter', 'XSyncTrigger', 'XSyncWaitCondition',
'XSyncAlarmAttributes', 'XSyncCounterNotifyEvent', 'XSyncAlarmNotifyEvent',
'XSyncAlarmError', 'XSyncCounterError', 'XSyncQueryExtension',
'XSyncInitialize', 'XSyncListSystemCounters', 'XSyncFreeSystemCounterList',
'XSyncCreateCounter', 'XSyncSetCounter', 'XSyncChangeCounter',
'XSyncDestroyCounter', 'XSyncQueryCounter', 'XSyncAwait', 'XSyncCreateAlarm',
'XSyncDestroyAlarm', 'XSyncQueryAlarm', 'XSyncChangeAlarm',
'XSyncSetPriority', 'XSyncGetPriority']

########NEW FILE########
__FILENAME__ = gamehall
# -*- coding: utf-8 -*-

# -- stdlib --
from weakref import WeakSet
from collections import defaultdict
import atexit
import logging
import os
import random
import time
import gzip

# -- third party --
import gevent
from gevent import Timeout
from gevent.event import Event
from gevent.pool import Pool
from gevent.queue import Queue, Empty as QueueEmpty
import simplejson as json

# -- own --
from network.server import Client as ClientEndpoint, DroppedClient
from utils import BatchList, log_failure, instantiate
from utils.interconnect import Interconnect
from options import options
from settings import VERSION
from account import Account

# -- code --
log = logging.getLogger('GameHall')


class Client(ClientEndpoint):
    def __init__(self, *a, **k):
        ClientEndpoint.__init__(self, *a, **k)
        self.cmd_listeners = defaultdict(WeakSet)

    def listen_command(self, *cmds):
        listeners_set = self.cmd_listeners
        q = Queue(100)
        for cmd in cmds:
            listeners_set[cmd].add(q)

        return q

    def handle_command(self, cmd, data):
        f = getattr(self, 'command_' + str(cmd), None)
        if not f:
            listeners = self.cmd_listeners[cmd]
            if listeners:
                [l.put(data) for l in listeners]
                return

            log.debug('No command %s', cmd)
            self.write(['invalid_command', [cmd, data]])
            return

        for_state = getattr(f, 'for_state', None)
        if for_state and self.state not in for_state:
            log.debug('Command %s is for state %s, called in %s', cmd, for_state, self.state)
            self.write(['invalid_command', [cmd, data]])
            return

        f(data)

    def handle_drop(self):
        if self.state not in ('connected', 'hang'):
            exit_game(self, drops=True)

        if self.state != 'connected':
            user_exit(self)

    def for_state(*state):
        def register(f):
            f.for_state = state
            return f

        return register

    # --------- Handlers ---------
    @for_state('connected')
    def command_auth(self, cred):
        if self.account:
            self.write(['invalid_command', ['auth', '']])
            return

        login, password = cred
        acc = Account.authenticate(login, password)
        if acc:
            self.account = acc
            if not acc.available():
                self.write(['auth_result', 'not_available'])
                self.close()
            else:
                self.write(['auth_result', 'success'])
                self.account = acc
                new_user(self)

        else:
            self.write(['auth_result', 'invalid_credential'])

    @for_state('hang')
    def command_create_game(self, arg):
        _type, name = arg
        g = create_game(self, _type, name)
        join_game(self, g.gameid)

    @for_state('hang')
    def command_join_game(self, gameid):
        join_game(self, gameid)

    def command_get_hallinfo(self, _):
        send_hallinfo(self)

    @for_state('hang')
    def command_quick_start_game(self, _):
        quick_start_game(self)

    @for_state('hang')
    def command_observe_user(self, uid):
        observe_user(self, uid)

    @for_state('hang')
    def command_query_gameinfo(self, gid):
        query_gameinfo(self, gid)

    @for_state('inroomwait')
    def command_get_ready(self, _):
        get_ready(self)

    @for_state('inroomwait', 'ready', 'ingame', 'observing')
    def command_exit_game(self, _):
        exit_game(self)

    @for_state('inroomwait', 'ready')
    def command_kick_user(self, uid):
        kick_user(self, uid)

    @for_state('inroomwait', 'ready')
    def command_invite_user(self, uid):
        invite_user(self, uid)

    @for_state('inroomwait', 'ready', 'ingame')
    def command_kick_observer(self, uid):
        kick_observer(self, uid)

    @for_state('inroomwait', 'observing')
    def command_change_location(self, loc):
        change_location(self, loc)

    @for_state('ready')
    def command_cancel_ready(self, _):
        cancel_ready(self)

    def command_heartbeat(self, _):
        pass

    @for_state('hang', 'inroomwait', 'ready', 'ingame', 'observing')
    def command_chat(self, data):
        chat(self, data)

    @for_state('hang', 'inroomwait', 'ready', 'ingame', 'observing')
    def command_speaker(self, data):
        speaker(self, data)

    # --------- End handlers ---------

    del for_state


'''
User state machine:
     [Observing]     --------------<------------<-----------
          |          |                                     |
    -> [Hang] <-> [InRoomWait] <-> [Ready] -> [InGame] -->----
        |                  |         |             |
        --->[[Disconnect]]<-------------------------
'''

# should use WeakSet or WeakValueDictionary,
# but this works fine, not touching it.
games = {}  # all games
users = {}  # all users
dropped_users = {}  # passively dropped users
evt_datachange = Event()


if options.gidfile:
    try:
        with open(options.gidfile, 'r') as f:
            _curgameid = int(f.read())
    except:
        _curgameid = 0
else:
    _curgameid = 0


def new_gameid():
    global _curgameid
    _curgameid += 1
    return _curgameid


if options.interconnect:
    class InterconnectHandler(Interconnect):
        def on_message(self, node, topic, message):
            if topic == 'speaker':
                node = node if node != options.node else ''
                message.insert(0, node)
                Pool(5).map_async(lambda u: u.write(['speaker_msg', message]), users.values())

    Interconnect = InterconnectHandler.spawn(options.node, options.redis, options.redis_port)

else:
    class DummyInterconnect(object):
        def publish(self, key, message):
            pass

    Interconnect = DummyInterconnect()


@gevent.spawn
@log_failure(log)
def gamehall_status_updator():
    last_update = time.time()
    evt = evt_datachange
    time_limit = 1
    while True:
        evt.wait()
        t = time.time()
        delta = t - last_update
        if delta > time_limit:
            last_update = t

            ul = [u for u in users.values() if u.state == 'hang']
            Pool(5).map_async(send_hallinfo, ul)

            Interconnect.publish('current_users', users.values())
            Interconnect.publish('current_games', games.values())

            evt.clear()

        else:
            gevent.sleep(time_limit - delta)


@instantiate
class PlayerPlaceHolder(object):

    def __data__(self):
        return dict(
            state='left',
            account=None,
        )

    @instantiate
    class client(object):
        state = 'left'
        observers = BatchList()
        raw_write = write = lambda *a: False


def new_user(user):
    uid = user.account.userid
    user.write(['your_account', user.account])
    if uid in users:
        # squeeze the original one out
        log.info('%s has been sqeezed out' % user.account.username)
        old = users[uid]
        #if old.state not in('connected', 'hang'):
        #    exit_game(old, drops=True)
        old.write(['others_logged_in', None])
        old.close()

        user.account = old.account

    users[uid] = user
    user.state = 'hang'
    user.observing = None
    log.info(u'User %s joined, online user %d' % (user.account.username, len(users)))

    if uid in dropped_users:
        log.info(u'%s rejoining dropped game' % user.account.username)
        old = dropped_users[uid]
        assert isinstance(old, DroppedClient), 'Arghhhhh'

        g = user.current_game = old.current_game
        user.player_index = old.player_index
        user.gdhistory = old.gdhistory
        user.usergdhistory = old.usergdhistory
        user.state = 'ingame'

        for p in g.players:
            if p.client is old:
                break
        else:
            assert False, 'Oops'

        p.reconnect(user)

        user.account = old.account

        user.write(['game_joined', g])
        user.write(['game_started', g.players_original])

        user.replay(user)

        del dropped_users[uid]

        _notify_playerchange(g)

    evt_datachange.set()
    return True


def user_exit(user):
    uid = user.account.userid
    del users[uid]
    log.info(u'User %s leaved, online user %d' % (user.account.username, len(users)))
    evt_datachange.set()


def _notify_playerchange(g):
    @gevent.spawn
    def notify_playerchage_worker():
        try:
            from network.server import Client
            s = Client.encode(['player_change', g.players])
            for cl in g.players.client:
                cl.raw_write(s)
                if cl.observers: cl.observers.raw_write(s)

        except Exception as e:
            log.warning('Exception in _notify_playerchange: %s', e.__class__.__name__)


def query_gameinfo(user, gid):
    g = games.get(gid, None)
    g and user.write(['gameinfo', [gid, g.players]])


def _next_free_slot(game):
    try:
        return game.players.index(PlayerPlaceHolder)
    except ValueError:
        return None


def create_game(user, gametype, gamename):
    from gamepack import gamemodes
    if not gametype in gamemodes:
        user.write(['gamehall_error', 'gametype_not_exist'])
        return

    g = gamemodes[gametype]()
    g.game_started = False
    g.game_name = gamename
    g.players = BatchList([PlayerPlaceHolder] * g.n_persons)
    g.players_original = None
    g.rndseed = random.randint(1, 10 ** 20)
    g.random = random.Random(g.rndseed)
    g.banlist = defaultdict(set)
    g.gr_groups = WeakSet()
    gid = new_gameid()
    g.gameid = gid
    games[gid] = g
    log.info("create game")
    evt_datachange.set()
    return g


def _archive_game(g):
    if not options.archive_path:
        return

    data = []

    data.append('# ' + ', '.join([
        p.account.username.encode('utf-8')
        for p in g.players_original
    ]))

    data.append('# Ver: ' + VERSION)
    data.append('# GameId: ' + str(g.gameid))
    s, e = int(g.start_time), int(time.time())
    data.append('# Time: start = %d, end = %d, elapsed = %d' % (s, e, e - s))

    data.append(g.__class__.__name__)
    data.append(str(g.rndseed))
    data.append(json.dumps(g.usergdhistory))
    data.append(json.dumps(g.gdhistory))

    f = gzip.open(os.path.join(options.archive_path, str(g.gameid)) + '.gz', 'wb')
    f.write('\n'.join(data))
    f.close()


def get_ready(user):
    user.state = 'ready'
    g = user.current_game
    _notify_playerchange(g)
    evt_datachange.set()
    if all(p.client.state == 'ready' for p in g.players):
        if not g.started:
            # race condition here.
            # wrap in 'if g.started' to prevent double starting.
            log.info("game starting")
            g.start()


def cancel_ready(user):
    user.state = 'inroomwait'
    _notify_playerchange(user.current_game)
    evt_datachange.set()


def change_location(user, loc):
    g = user.current_game
    pl = g.players
    if (not 0 <= loc < len(g.players)) or (pl[loc] is not PlayerPlaceHolder):
        user.write(['change_loc_failed', None])
        return
    if user.state == 'observing':
        join_game(user, g.gameid, loc)
    else:
        i = pl.client.index(user)
        pl[loc], pl[i] = pl[i], pl[loc]
        _notify_playerchange(g)


def kick_user(user, uid):
    g = user.current_game
    u = users.get(uid, None)
    cl = g.players.client
    if u not in cl:
        return
    bl = g.banlist[u]
    bl.add(user)
    cl.write(['kick_request', [user, u, len(bl)]])
    if len(bl) >= len(cl)//2:
        exit_game(u)


def kick_observer(user, uid):
    g = user.current_game
    ob = users.get(uid, None)
    if not (ob and ob.state == 'observing'):
        return

    if g is not ob.current_game:
        return

    exit_game(ob)


def exit_game(user, drops=False):
    if user.state == 'observing':
        tgt = user.observing
        tgt.observers.remove(user)
        user.state = 'hang'
        user.observing = None
        user.current_game = None
        user.gclear()
        user.write(['game_left', None])

        @gevent.spawn
        def notify_observer_leave(user=user, observee=tgt):
            g = tgt.current_game
            ul = g.players.client
            info = [user.account.userid, user.account.username, observee.account.username]
            ul.write(['observer_leave', info])
            for obl in ul.observers:
                obl and obl.write(['observer_leave', info])

    elif user.state != 'hang':
        g = user.current_game
        if not drops: user.gclear()
        i = g.players.client.index(user)
        if g.game_started:
            p = g.players[i]
            log.info('player dropped')
            if g.can_leave(p):
                user.write(['game_left', None])
                p.set_fleed(False)
            else:
                if not drops:
                    user.write(['fleed', None])
                    p.set_fleed(True)
                else:
                    p.set_fleed(False)

            p.client.gbreak()  # XXX: fuck I forgot why it's here. Exp: see comment on Client.gbreak

            p.set_dropped()
            dummy = DroppedClient(g.players[i].client)
            if drops:
                dropped_users[p.client.account.userid] = dummy
            p.set_client(dummy)
        else:
            log.info('player leave')
            g.players[i] = PlayerPlaceHolder
            user.write(['game_left', None])

        for ob in user.observers:
            ob.write(['game_left', None])
            ob.state = 'hang'
            ob.observing = None

        user.observers[:] = []

        user.state = 'hang'
        _notify_playerchange(g)

        for bl in g.banlist.values():
            try:
                bl.remove(user)
            except KeyError:
                pass

        if all((p is PlayerPlaceHolder or p.dropped) for p in g.players):
            if g.game_started:
                log.info('game aborted')
                _archive_game(g)
            else:
                log.info('game canceled')

            for p in g.players:
                if p is PlayerPlaceHolder: continue
                try:
                    del dropped_users[p.client.account.userid]
                except KeyError:
                    pass

            g.suicide = True  # game will kill itself in get_synctag()
            try:
                del games[g.gameid]
            except:
                pass

        evt_datachange.set()
    else:
        user.write(['gamehall_error', 'not_in_a_game'])


def join_game(user, gameid, slot=None):
    if user.state == 'hang' and gameid in games:
        g = games[gameid]
    elif user.state == 'observing':
        g = user.current_game
        g = g if g.gameid == gameid else None
    else:
        return

    if g is not None:
        if len(g.banlist[user]) >= 3:
            user.write(['gamehall_error', 'banned'])
            return

        log.info("join game")

        if slot is None:
            slot = _next_free_slot(g)
        elif g.players[slot] is not PlayerPlaceHolder:
            slot = None

        if slot is not None:
            if user.state == 'observing':
                user.observing.observers.remove(user)
                user.observing = None

            user.state = 'inroomwait'
            user.current_game = g
            from .game_server import Player
            g.players[slot] = Player(user)
            user.write(['game_joined', g])
            _notify_playerchange(g)
            evt_datachange.set()
            return

    user.write(['gamehall_error', 'cant_join_game'])


def quick_start_game(user):
    if user.state == 'hang':
        gl = [g for g in games.values() if _next_free_slot(g) is not None]
        if gl:
            join_game(user, random.choice(gl).gameid)
            return

    user.write(['gamehall_error', 'cant_join_game'])


def _observe_user(user, observee):
    if not observee:
        user.write(['gamehall_error', 'no_such_user'])
        return

    if observee.state not in ('ingame', 'inroomwait', 'ready'):
        user.write(['gamehall_error', 'user_not_ingame'])
        return

    g = observee.current_game
    observee.observers.append(user)

    log.info("observe game")
    user.state = 'observing'
    user.current_game = g
    user.observing = observee
    user.write(['game_joined', g])
    user.gclear()  # clear stale gamedata
    #_notify_playerchange(g)
    pl = g.players if not g.players_original else g.players_original
    evt_datachange.set()

    @gevent.spawn
    def notify_observer():
        ul = g.players.client
        info = [user.account.userid, user.account.username, observee.account.username]
        ul.write(['observer_enter', info])
        for obl in ul.observers:
            obl and obl.write(['observer_enter', info])

    if g.started:
        user.write(['observe_started', [observee.account.userid, pl]])
        observee.replay(user)
    else:
        # send room player data to the observer
        user.write(['player_change', pl])


def observe_user(user, other_userid):
    other = users.get(other_userid, None)

    if not other:
        user.write(['gamehall_error', 'no_such_user'])
        return

    if other.state == 'observing':
        other = other.observing

    if other.state not in ('ingame', 'inroomwait', 'ready'):
        user.write(['gamehall_error', 'user_not_ingame'])
        return

    @gevent.spawn
    def worker():
        with Timeout(20, False):
            rst = None
            other.write(['observe_request', [user.account.userid, user.account.username]])
            chan = other.listen_command('observe_grant')
            while True:
                rst = chan.get()
                if rst is None:
                    return

                try:
                    ob_id, grant = rst
                except:
                    continue

                if ob_id != user.account.userid:
                    continue

                break

        if not rst:
            return

        if not user.state == 'hang':
            return

        if other.state not in ('ingame', 'inroomwait', 'ready'):
            return

        if grant:
            _observe_user(user, other)
        else:
            user.write(['observe_refused', other.account.username])

    worker.gr_name = 'OB:[%r] -> [%r]' % (user, other)


def invite_user(user, other_userid):
    if user.account.userid < 0:
        gevent.spawn(user.write, ['system_msg', [None, u'毛玉不能使用邀请功能']])
        return

    other = users.get(other_userid, None)

    if not (other and other.state in ('hang', 'observing')):
        user.write(['gamehall_error', 'user_not_found'])
        return

    g = user.current_game

    @gevent.spawn
    def worker():
        with Timeout(20, False):
            other.write(['invite_request', [
                user.account.userid,
                user.account.username,
                g.gameid,
                g.__class__.__name__,
            ]])

            rst = None
            chan = other.listen_command('invite_grant')
            gid = grant = 0

            while True:
                rst = chan.get()
                if rst is None:
                    return

                try:
                    gid, grant = rst
                except:
                    continue

                if gid != g.gameid:
                    continue

                break

        if not (grant and gid in games and not g.started and other.state != 'ingame'):
            # granted, game not cancelled or started
            return

        if _next_free_slot(g) is None:
            # no free space
            return

        if other.state == 'observing':
            exit_game(other)

        if other.state in ('inroomwait', 'ready') and other.current_game is g:
            # same game
            return

        join_game(other, gid)

    worker.gr_name = 'Invite:[%r] -> [%r]' % (user, other)


def send_hallinfo(user):
    user.write(['current_games', games.values()])
    user.write(['current_users', users.values()])
    user.write(['your_account', user.account])


def start_game(g):
    log.info("game started")
    g.game_started = True
    g.players_original = BatchList(g.players)
    g.usergdhistory = ugh = []
    g.gdhistory = [list() for p in g.players]

    for i, (u, l) in enumerate(zip(g.players.client, g.gdhistory)):
        u.player_index = i
        u.usergdhistory = ugh
        u.gdhistory = l

    g.start_time = time.time()
    for u in g.players.client:
        u.write(["game_started", g.players])
        u.gclear()
        if u.observers:
            u.observers.gclear()
            u.observers.write(['observe_started', [u.account.userid, g.players]])
        u.state = 'ingame'
    evt_datachange.set()


def end_game(g):
    from .game_server import Player

    log.info("end game")
    pl = g.players

    # add credits
    t = time.time()
    percent = min(1.0, (t - g.start_time) / 1200)
    import math
    rate = math.sin(math.pi / 2 * percent)
    winners = g.winners
    bonus = g.n_persons * 5 / len(winners) if winners else 0

    _archive_game(g)

    all_dropped = all(p.dropped for p in pl)
    # TODO: likely there is something wrong, log it

    for p in pl:
        acc = p.client.account
        if not all_dropped:
            acc.add_credit('games', 1)
            if p.dropped and p.fleed:
                acc.add_credit('drops', 1)
            else:
                s = 5 + bonus if p in winners else 5
                acc.add_credit('credits', int(s * rate))

        p.client.gclear()  # clear game data

        if p.dropped:
            try:
                del dropped_users[acc.userid]
            except KeyError:
                pass

    # -----------

    for i, p in enumerate(pl):
        if p.dropped:
            pl[i] = PlayerPlaceHolder

    try:
        del games[g.gameid]
    except:
        pass

    if all_dropped:
        return

    ng = create_game(None, g.__class__.__name__, g.game_name)
    ng.players = BatchList([
        Player(p.client)
        if p is not PlayerPlaceHolder
        else PlayerPlaceHolder
        for p in pl
    ])
    for cl in pl.client:
        cl.write(['end_game', None])
        cl.write(['game_joined', ng])
        if cl.observers:
            obl = cl.observers
            obl.write(['end_game', None])
            obl.write(['game_joined', ng])
        cl.current_game = ng
        cl.state = 'inroomwait'
        for ob in cl.observers:
            ob.current_game = ng
            ob.state = 'observing'
    _notify_playerchange(ng)
    evt_datachange.set()


def chat(user, msg):
    @log_failure(log)
    def worker():
        if msg.startswith('!!') and (options.freeplay or user.account.userid in (2,)):
            # admin commands
            cmd = msg[2:]
            if cmd == 'stacktrace':
                admin_stacktrace(user.current_game)
                return
            elif cmd == 'clearzombies':
                admin_clearzombies()
                return
            elif cmd == 'ping':
                admin_ping(user)
                return

        packed = (user.account.username, msg)
        if user.state == 'hang':  # hall chat
            for u in users.values():
                if u.state == 'hang':
                    u.write(['chat_msg', packed])

        elif user.state in ('inroomwait', 'ready', 'ingame', 'observing'):  # room chat
            ul = user.current_game.players.client
            obl = BatchList()
            map(obl.__iadd__, ul.observers)
            _type = 'ob_msg' if user.state == 'observing' else 'chat_msg'
            ul.write([_type, packed])  # should be here?
            obl.write([_type, packed])

    worker.gr_name = 'chat worker for %s' % user.account.username
    gevent.spawn(worker)


def speaker(user, msg):
    def worker():
        if user.account.other['credits'] < 10:
            user.write(['system_msg', [None, u'您的节操掉了一地，文文不愿意帮你散播消息。']])
        else:
            user.account.add_credit('credits', -10)
            Interconnect.publish('speaker', [user.account.username, msg])

    log.info(u'Speaker: %s', msg)
    gevent.spawn(worker)


def system_msg(msg):
    def worker():
        for u in users.values():
            u.write(['system_msg', [None, msg]])
    gevent.spawn(worker)


def admin_clearzombies():
    for i, u in users.items():
        if u.ready():
            log.info('Clear zombie: %r', u)
            del users[i]


def admin_stacktrace(g):
    log.info('>>>>> GAME STACKTRACE <<<<<')

    def logtraceback(gr):
        import traceback
        log.info('----- %r -----\n%s', gr, ''.join(traceback.format_stack(gr.gr_frame)))

    logtraceback(g)
    for i in g.gr_groups:
        for j in i:
            logtraceback(j)

    for cl in g.players.client:
        if isinstance(cl, Client):
            logtraceback(cl)

    log.info('===========================')


def admin_ping(user):
    g = getattr(user, 'current_game', None)
    if g:
        clients = [c for c in g.players.client if isinstance(c, Client)]
    else:
        clients = users.values()

    def ping(p):
        chan = p.listen_command('pong')
        b4 = time.time()
        p.write(['ping', None])
        try:
            chan.get(timeout=5)
            t = time.time() - b4
            t *= 1000
            user.write(['system_msg', [None, u'%s %fms' % (p.account.username, t)]])
        except QueueEmpty:
            user.write(['system_msg', [None, u'%s 超时' % p.account.username]])

    for p in clients:
        gevent.spawn(ping, p)


@atexit.register
def _exit_handler():
    # logout all the accounts
    # to save the credits
    for u in users.values():
        u.account.add_credit('credits', 50)

    # save gameid
    fn = options.gidfile
    if fn:
        with open(fn, 'w') as f:
            f.write(str(_curgameid + 1))

########NEW FILE########
__FILENAME__ = game_server
# -*- coding: utf-8 -*-

# -- stdlib --
from collections import OrderedDict
from copy import copy
import time
import logging
log = logging.getLogger('Game_Server')


# -- third party --
from gevent import Greenlet, getcurrent
from gevent.pool import Group as GreenletGroup
import gevent

# -- own --
from network.server import EndpointDied
from game import TimeLimitExceeded, InputTransaction, GameEnded
from utils import waitany, log_failure
import game

# -- code --


def user_input(players, inputlet, timeout=25, type='single', trans=None):
    '''
    Type can be 'single', 'all' or 'any'
    '''
    assert type in ('single', 'all', 'any')
    assert not type == 'single' or len(players) == 1

    timeout = max(0, timeout)

    g = Game.getgame()
    inputlet.timeout = timeout
    players = list(players)

    if not trans:
        with InputTransaction(inputlet.tag(), players) as trans:
            return user_input(players, inputlet, timeout, type, trans)

    t = {'single': '', 'all': '&', 'any': '|'}[type]
    tag = 'I{0}:{1}:'.format(t, inputlet.tag())

    ilets = {p: copy(inputlet) for p in players}
    for p in players:
        ilets[p].actor = p

    results = {p: None for p in players}
    synctags = {p: g.get_synctag() for p in players}

    orig_players = players[:]
    input_group = GreenletGroup()
    g.gr_groups.add(input_group)
    _input_group = set()

    till = time.time() + timeout + 5
    try:
        inputany_player = None

        def get_input_waiter(p, t):
            try:
                # should be [tag, <Data for Inputlet.parse>]
                # tag likes 'I?:ChooseOption:2345'
                tag, rst = p.client.gexpect(t)
                return rst
            except EndpointDied:
                return None

        for p in players:
            t = tag + str(synctags[p])
            w = input_group.spawn(get_input_waiter, p, t)
            _input_group.add(w)
            w.player = p
            w.gr_name = 'get_input_waiter: p=%r, tag=%s' % (p, t)

        for p in players:
            g.emit_event('user_input_start', (trans, ilets[p]))

        while players:
            # NOTICE: This is a must.
            # TLE would be raised at other part (notably my.post_process) in the original solution
            # (wrapping large parts of code in 'with TimeLimitExceeded(): ...')
            with TimeLimitExceeded(max(till - time.time(), 0)):
                w = waitany(_input_group)
                _input_group.discard(w)
                try:
                    rst = w.get()
                    p, data = w.player, rst
                except:
                    p, data = w.player, None

            g.players.client.gwrite('R{}{}'.format(tag, synctags[p]), data)

            my = ilets[p]

            try:
                rst = my.parse(data)
            except:
                log.error('user_input: exception in .process()', exc_info=1)
                # ----- FOR DEBUG -----
                if g.IS_DEBUG:
                    raise
                # ----- END FOR DEBUG -----
                rst = None

            rst = my.post_process(p, rst)

            g.emit_event('user_input_finish', (trans, my, rst))

            players.remove(p)
            results[p] = rst

            if type == 'any' and rst is not None:
                inputany_player = p
                break

    except TimeLimitExceeded:
        pass

    finally:
        input_group.kill()

    # timed-out players
    for p in players:
        my = ilets[p]
        rst = my.parse(None)
        rst = my.post_process(p, rst)
        results[p] = rst
        g.emit_event('user_input_finish', (trans, my, rst))
        g.players.client.gwrite('R{}{}'.format(tag, synctags[p]), None)

    if type == 'single':
        return results[orig_players[0]]

    elif type == 'any':
        if not inputany_player:
            return None, None

        return inputany_player, results[inputany_player]

    elif type == 'all':
        return OrderedDict([(p, results[p]) for p in orig_players])

    assert False, 'WTF?!'


class Player(game.AbstractPlayer):
    dropped = False
    fleed = False

    def __init__(self, client):
        self.client = client

    def reveal(self, obj_list):
        g = Game.getgame()
        st = g.get_synctag()
        self.client.gwrite('Sync:%d' % st, obj_list)

    def set_dropped(self, v=True):
        self.dropped = v

    def set_fleed(self, v=True):
        self.fleed = v

    def set_client(self, v):
        self.client = v

    def reconnect(self, client):
        self.client = client
        self.dropped = False

    def __data__(self):
        if self.dropped:
            if self.fleed:
                state = 'fleed'
            else:
                state = 'dropped'
        else:
            state = self.client.state

        return dict(
            account=self.client.account,
            state=state,
        )

    @property
    def account(self):
        return self.client.account


class Game(Greenlet, game.Game):
    suicide = False
    '''
    The Game class, all game mode derives from this.
    Provides fundamental behaviors.

    Instance variables:
        players: list(Players)
        event_handlers: list(EventHandler)

        and all game related vars, eg. tags used by [EventHandler]s and [Action]s
    '''

    CLIENT_SIDE = False
    SERVER_SIDE = True

    def __data__(self):
        from .gamehall import PlayerPlaceHolder as pph
        return dict(
            id=self.gameid,
            type=self.__class__.__name__,
            started=self.game_started,
            name=self.game_name,
            nplayers=sum(not (p is pph or p.dropped) for p in self.players),
        )

    def __init__(self):
        Greenlet.__init__(self)
        game.Game.__init__(self)
        self.players = []

    @log_failure(log)
    def _run(self):
        from server.core import gamehall as hall
        self.synctag = 0
        self.game = getcurrent()
        hall.start_game(self)
        try:
            self.game_start()
        except GameEnded:
            pass
        finally:
            hall.end_game(self)

        assert self.ended

    @staticmethod
    def getgame():
        return getcurrent().game

    def __repr__(self):
        try:
            gid = str(self.gameid)
        except:
            gid = 'X'

        return '%s:%s' % (self.__class__.__name__, gid)

    def get_synctag(self):
        if self.suicide:
            self.kill()
            return

        self.synctag += 1
        return self.synctag

    def pause(self, time):
        gevent.sleep(time)

########NEW FILE########
__FILENAME__ = events
# -*- coding: utf-8 -*-

from gevent import monkey
monkey.patch_all()


# -- stdlib --
import sys
import argparse
from urllib import unquote
from collections import deque, defaultdict
import time
import logging
import zlib
import smtplib
from email.MIMEMultipart import MIMEMultipart
from email.MIMEText import MIMEText
from email.Utils import formatdate

# -- third party --
import gevent
from gevent.event import Event
from bottle import route, run, request, response
import simplejson as json

# -- own --
from utils.rpc import RPCClient
from utils.interconnect import Interconnect


# -- code --
member_service = None
options = None
current_users = {}
event_waiters = set()
events_history = deque([[None, 0]] * 1000)
gameid_last_see = defaultdict(int)
interconnect = None

logging.basicConfig()


class Interconnect(Interconnect):
    def on_message(self, node, topic, message):
        if topic == 'current_users':
            # [[node, username, state], ...]
            current_users[node] = [
                (node, i[1], i[2]) for i in message
            ]
            rst = []
            map(rst.__iadd__, current_users.values())
            self.notify('current_users', rst)

        elif topic == 'shutdown':
            # not implemented yet
            current_users[node] = []
            rst = []
            map(rst.__iadd__, current_users.values())
            self.notify('current_users', rst)

        if topic == 'speaker':
            # [node, username, content]
            message.insert(0, node)
            self.notify('speaker', message)

    def notify(self, key, message):
        @gevent.spawn
        def _notify():
            events_history.rotate()
            events_history[0] = [[key, message], time.time()]
            [evt.set() for evt in list(event_waiters)]


@route('/interconnect/onlineusers')
def onlineusers():
    rst = []
    map(rst.__iadd__, current_users.values())
    return json.dumps(rst)


@route('/interconnect/events')
def events():
    try:
        last = float(request.get_cookie('interconnect_last_event'))
    except:
        last = time.time()

    evt = Event()

    events_history[0][1] > last and evt.set()

    event_waiters.add(evt)
    success = evt.wait(timeout=30)
    event_waiters.discard(evt)

    response.set_header('Content-Type', 'application/json')
    response.set_header('Pragma', 'no-cache')
    response.set_header('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate')
    response.set_header('Expires', 'Thu, 01 Dec 1994 16:00:00 GMT')
    success and response.set_cookie('interconnect_last_event', '%.5f' % time.time())

    data = []
    for e in events_history:
        if e[1] > last:
            data.append(e[0])
        else:
            break

    data = list(reversed(data))
    return json.dumps(data)


@route('/interconnect/speaker', method='POST')
def speaker():
    idx = {
        k.split('_')[-1]: k for k in request.cookies
        if k.startswith(options.discuz_cookiepre)
    }

    if not ('auth' in idx and 'saltkey' in idx):
        response.status = 403
        return

    auth = unquote(request.get_cookie(idx['auth']))
    saltkey = unquote(request.get_cookie(idx['saltkey']))
    member = member_service.validate_by_cookie(auth, saltkey)
    if not member:
        return 'false'

    if member['credits'] < 10:
        return 'false'

    message = request.forms.get('message').decode('utf-8', 'ignore')
    username = member['username'].decode('utf-8', 'ignore')
    member_service.add_credit(member['uid'], 'credits', -10)

    interconnect.publish('speaker', [username, message])

    return 'true'


def send_mail(send_from, send_to, subject, text, files=[], server="localhost"):
    msg = MIMEMultipart()
    msg['From'] = send_from
    msg['To'] = send_to
    msg['Date'] = formatdate(localtime=True)
    msg['Subject'] = subject
    msg.attach(MIMEText(text))
    smtp = smtplib.SMTP(server)
    smtp.sendmail(send_from, send_to, msg.as_string())
    smtp.close()


@route('/interconnect/crashreport', method='POST')
def crashreport():
    gameid = int(request.forms.get('gameid', 0))
    active = int(request.forms.get('active', 0))
    userid = int(request.forms.get('userid', 0))
    username = unicode(request.forms.get('username', 'unknown'), 'utf-8')

    if time.time() - gameid_last_see[gameid] < 300 and not active: return ''
    if gameid:
        gameid_last_see[gameid] = time.time()

    f = request.files.get('file')
    if not f: return ''

    content = f.file.read()
    content = zlib.decompress(content)

    @gevent.spawn
    def sendmail(content=content):
        subject = u'THB Crash Report{active} #{gameid}, reported by {username}[{userid}]'.format(
            gameid=gameid,
            active=' (Active)' if active else '',
            username=username,
            userid=userid,
        ).encode('utf-8')

        send_mail(
            send_from='crashreport@thbattle.net',
            send_to='feisuzhu@163.com',
            subject=subject,
            text=content,
        )

        send_mail(
            send_from='crashreport@thbattle.net',
            send_to='zhykzhykzhyk@163.com',
            subject=subject,
            text=content,
        )

    return ''


def main():
    global options, member_service, interconnect
    parser = argparse.ArgumentParser(sys.argv[0])
    parser.add_argument('--host', default='127.0.0.1')
    parser.add_argument('--port', type=int, default=7001)
    parser.add_argument('--redis', default='localhost')
    parser.add_argument('--redis-port', default=6379)
    parser.add_argument('--member-service', default='localhost')
    parser.add_argument('--discuz-cookiepre', default='VfKd_')
    options = parser.parse_args()

    member_service = RPCClient((options.member_service, 7000), timeout=2)
    interconnect = Interconnect.spawn('forum', options.redis, options.redis_port)

    run(server='gevent', host=options.host, port=options.port)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = member
# -*- coding: utf-8 -*-

# -- stdlib --
import sys
import argparse
import hashlib
import time
from base64 import b64encode, b64decode

# -- third party --
from sqlalchemy import create_engine, text as sq_text
from gevent.server import StreamServer

# -- own --
from utils.rpc import RPCService


# -- globals --
CREDITS_MAPPING = {
    'credits': 'extcredits2',
    'games': 'extcredits8',
    'drops': 'extcredits7',
}


# -- code --
options = None
engine = None

text = lambda t: sq_text(t.replace('cdb_', options.discuz_dbpre))


def md5(s):
    return hashlib.md5(s).hexdigest()


def _discuz_authcode(string, operation, key, expiry=0):
    try:
        ckey_length = 4
        key = md5(key)
        keya = md5(key[:16])
        keyb = md5(key[16:])
        if ckey_length:
            if operation == 'DECODE':
                keyc = string[:ckey_length]
            else:
                keyc = md5(str(time.time()))[-ckey_length:]
        else:
            keyc = ''

        cryptkey = keya + md5(keya + keyc)
        key_length = len(cryptkey)

        if operation == 'DECODE':
            pads = len(string) % 4 - 4
            if pads != -4:
                string += '=' * -pads

            string = b64decode(string[ckey_length:])
        else:
            string = str(int(time.time()) + expiry if expiry else 10000000000)[-10:]
            string += md5(string + keyb)[:16] + string

        string_length = len(string)
        result = []

        box = range(256)
        rndkey = [ord(cryptkey[i % key_length]) for i in xrange(256)]
        j = 0
        for i in xrange(256):
            j = (j + box[i] + rndkey[i]) % 256
            box[i], box[j] = box[j], box[i]

        a = j = 0
        for i in xrange(string_length):
            a = (a + 1) % 256
            j = (j + box[a]) % 256
            box[a], box[j] = box[j], box[a]
            result.append(
                chr(ord(string[i]) ^ (box[(box[a] + box[j]) % 256]))
            )

        result = ''.join(result)

        if operation == 'DECODE':
            cond = int(result[:10]) == 0 or int(result[:10]) - time.time() > 0
            cond = cond and result[10:26] == md5(result[26:] + keyb)[:16]
            if cond:
                return result[26:]
            else:
                return ''

        else:
            return keyc + b64encode(result).replace('=', '')

    except:
        return ''


def authencode(plain, saltkey):
    return _discuz_authcode(plain, 'ENCODE', md5(options.discuz_authkey + saltkey))


def authdecode(encrypted, saltkey):
    return _discuz_authcode(encrypted, 'DECODE', md5(options.discuz_authkey + saltkey))


class MemberService(RPCService):
    def get_user_info(self, uid):
        member = engine.execute(text('''
            SELECT * FROM cdb_common_member
            WHERE uid=:uid
        '''), uid=int(uid)).fetchone()

        if not member:
            return {}

        ucmember = engine.execute(text('''
            SELECT * FROM cdb_ucenter_members
            WHERE uid=:uid
        '''), uid=uid).fetchone()

        mcount = engine.execute(text('''
            SELECT * FROM cdb_common_member_count
            WHERE uid=:uid
        '''), uid=int(uid)).fetchone()

        mfield = engine.execute(text('''
            SELECT * FROM cdb_common_member_field_forum
            WHERE uid=:uid
        '''), uid=int(uid)).fetchone()

        rst = {
            'uid': int(uid),
            'username': member.username,
            'password': member.password,
            'ucpassword': ucmember.password,
            'ucsalt': ucmember.salt,
            'status': member.status,
            'title': mfield.customstatus,
        }

        for k, v in CREDITS_MAPPING.items():
            rst[k] = getattr(mcount, v)

        return rst

    def validate_by_uid(self, uid, password):
        info = self.get_user_info(uid)

        if not info:
            return {}

        if isinstance(password, unicode):
            password = password.encode('utf-8')

        if md5(md5(password) + info['ucsalt']) != info['ucpassword']:
            return {}

        return info

    def validate_by_username(self, username, password):
        if isinstance(username, unicode):
            username = username.encode('utf-8')

        if isinstance(password, unicode):
            password = password.encode('utf-8')

        ucmember = engine.execute(text('''
            select * from cdb_ucenter_members
            where username=:username
        '''), username=username).fetchone()

        if not ucmember:
            return {}

        info = self.get_user_info(ucmember.uid)

        if md5(md5(password) + info['ucsalt']) != info['ucpassword']:
            return {}

        return info

    def validate_by_cookie(self, auth, saltkey):
        rst = authdecode(auth, saltkey)
        if not rst:
            return {}

        password, uid = rst.split('\t')

        info = self.get_user_info(int(uid))

        if not info or password != info['password']:
            return {}

        return info

    def add_credit(self, uid, type, amount):
        field = CREDITS_MAPPING.get(type)
        if not type:
            return {}

        # be aware of sql injection
        engine.execute(text('''
            UPDATE cdb_common_member_count
            SET %s = %s + :amount
            WHERE uid=:uid
        ''' % (field, field)), amount=amount, uid=uid)

        return self.get_user_info(uid)


def main():
    global options, engine
    parser = argparse.ArgumentParser(sys.argv[0])
    parser.add_argument('--host', default='127.0.0.1')
    parser.add_argument('--port', type=int, default=7000)
    parser.add_argument('--connect-str', default='mysql://root@localhost/ultrax?charset=utf8')
    parser.add_argument('--discuz-dbpre', default='pre_')
    parser.add_argument('--discuz-authkey', default='Proton rocks')
    options = parser.parse_args()

    engine = create_engine(
        options.connect_str,
        encoding='utf-8',
        convert_unicode=True,
    )

    server = StreamServer((options.host, options.port), MemberService.spawn, None)
    server.serve_forever()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-


def makedict(clsname, bases, _dict):
    try:
        del _dict['__module__']
    except KeyError:
        pass

    return _dict

#__metaclass__ = lambda clsname, bases, _dict: _dict
__metaclass__ = makedict

import os

import sys
UPDATE_BASE = os.path.dirname(os.path.realpath(__file__))

if not sys.platform.startswith('linux'):
    UPDATE_BASE = os.path.dirname(UPDATE_BASE)

from options import options

if options.testing:
    UPDATE_URL = 'http://misc.thbattle.net/testing/'
else:
    UPDATE_URL = 'http://update.thbattle.net/'

if sys.platform.startswith('linux'):
    UPDATE_URL += 'src/'

VERSION = 'THBATTLE V1.0b incr 201'

HALL_NOTICE_URL = 'http://www.thbattle.net/notice.txt'

ACCOUNT_MODULE = 'freeplay' if options.freeplay else 'forum_integration'
ACCOUNT_FORUMURL = 'http://www.thbattle.net'

import re

UPDATE_IGNORES = re.compile(r'''^(
          current_version
        | .*_custom\..{2,4}
        | .*~
        | .+\.py[co]
        | OGLdpf\.log
        | [sd]
        | \..*
        | \.txt
        | cc?
        | client_log\.txt
        | client_log\.txt\.gz
        | update_info\.json
        | user_settings\.json
    )$
''', re.VERBOSE)


class ServerNames:
    forum = u'论坛'
    localhost = u'本机'
    lake = u'雾之湖'
    forest = u'魔法之森'
    hakurei = u'博丽神社'
    aya = u'文文专访'


def _get_box(vlist):
    xl = [i[0] for i in vlist]
    yl = [i[1] for i in vlist]
    x0, x1 = min(xl) - 5, max(xl) + 10
    y0, y1 = min(yl) - 5, max(yl) + 10
    return x0, y0, x1 - x0, y1 - y0


class ServerList:
    import os
    IS_PROTON = hasattr(os, 'uname') and os.uname()[:2] == ('Linux', 'Proton')
    del os

    if options.testing or IS_PROTON:
        class hakurei:
            address = ('game.thbattle.net', 8999)
            polygon = [
                (878, 423), (829, 409), (760, 376), (748, 346), (787, 329),
                (863, 313), (929, 322), (970, 330), (992, 366), (968, 399),
            ]
            box = _get_box(polygon)
            description = (
                u'|R没什么香火钱 博丽神社|r\n\n'
                u'冷清的神社，不过很欢迎大家去玩的，更欢迎随手塞一点香火钱！'
                u'出手大方的话，说不定会欣赏到博丽神社历代传下来的10万元COS哦。\n\n'
                u'|R|B注意：这是测试服务器，并不保证稳定、与正常服务器的同步！|r\n\n'
                u'|DB服务器地址： %s|r'
            ) % repr(address)

    if options.freeplay or IS_PROTON:
        class localhost:
            address = ('127.0.0.1', 9999)
            polygon = [
                (891, 704), (839, 707), (740, 601), (749, 575), (834, 570),
                (947, 576), (986, 597), (991, 675), (964, 696),
            ]
            box = _get_box(polygon)
            description = (
                u'|R你自己的本机服务器|r'
            )

    class lake:
        address = ('cngame.thbattle.net', 9999)
        polygon = [
            (569, 510), (514, 501), (489, 474), (514, 449), (585, 439),
            (647, 447), (670, 457), (671, 487), (628, 504),
        ]
        box = _get_box(polygon)
        description = (
            u'|R这里没有青蛙 雾之湖|r\n\n'
            u'一个让人开心的地方。只是游客普遍反应，游玩结束后会感到自己的智商被拉低了一个档次。'
            u'另外，请不要把青蛙带到这里来。这不是规定，只是一个建议。\n\n'
            u'|DB服务器地址： %s|r'
        ) % repr(address)

    class forest:
        address = ('cngame.thbattle.net', 9999)
        polygon = [
            (360, 415), (237, 380), (197, 309), (222, 199), (285, 159),
            (397, 150), (524, 168), (611, 256), (592, 318), (536, 359),
        ]
        box = _get_box(polygon)
        description = (
            u'|R光明牛奶指定销售地点 魔法之森|r\n\n'
            u'森林里好玩的东西很多，比如被捉弄什么的。'
            u'旁边有一个神奇的物品店，只是店主有点变态。\n\n'
            u'|DB服务器地址： %s|r'
        ) % repr(address)

    del IS_PROTON

NOTICE = u'''
东方符斗祭 测试版
==================

图片素材大多来自于互联网，如果其中有你的作品，请联系我。
Proton制作

|s2ff0000ff|W玩家大多在晚上8点之后进来玩，白天进来没人的话晚上再来试试～|r
|s2ff0000ff|W如果提示更新失败，请试着运行一下游戏目录中的update.bat文件更新。|r

|B游戏论坛：|r
http://www.thbattle.net

|B最近更新情况：|r
天子、梅蒂欣、妹红、正邪、橙：技能、设定调整
妖梦技能调整：觉醒技效果并入二刀流
爱丽丝重制，技能调整
犬走椛相关bug修复
紫设定调整：跳判定不再能弃置判定牌
小町设定调整：觉醒不再回复残机
灵梦设定调整：取消【纳奉】技能
新人物：梅蒂欣（开发：zhyk）
----
新人物：鬼人正邪、八坂神奈子（开发：zhyk）
新头像：帕秋莉（画师：渚FUN）
大狸子现在在除了KOF之外的所有模式可用
大狸子相关bug修复
新人物：大狸子（人物设计：鵺子丶爱丽丝）
新人物：秦心（画师：Takibi）
新模式：信（xue）仰（zhan）之（dao）战（di）
妖梦设定调整：如果装备了两把武器，现在可以主动弃置一把
好人卡bug修复
人物强度调整（露米娅、早苗、灵梦，具体调整请看论坛帖子）
新人物：藤原妹红(开发：zhyk)
出牌时间调整为25秒
新头像（小町、八意永琳、大妖精、八云紫，画师：渚FUN）
|R帐号与论坛绑定，请使用论坛帐号登录游戏！|r
'''.strip()

########NEW FILE########
__FILENAME__ = start_client
# -*- coding: utf-8 -*-

import sys
reload(sys)
sys.setdefaultencoding(sys.getfilesystemencoding())


def start_client():
    import ctypes
    try:
        ctypes.cdll.avbin  # force avbin load
    except:
        pass

    import logging
    import os
    import argparse
    import cStringIO

    parser = argparse.ArgumentParser(prog=sys.argv[0])
    parser.add_argument('--testing', action='store_true')
    parser.add_argument('--no-update', action='store_true')
    parser.add_argument('--with-gl-errcheck', action='store_true')
    parser.add_argument('--freeplay', action='store_true')
    parser.add_argument('--fastjoin', action='store_true')
    parser.add_argument('--dump-gameobj', action='store_true')
    parser.add_argument('--log', default='INFO')
    parser.add_argument('--color-log', action='store_true')
    parser.add_argument('--no-crashreport', action='store_true')

    options = parser.parse_args()

    import options as opmodule
    opmodule.options = options
    IS_PROTON = hasattr(os, 'uname') and os.uname()[:2] == ('Linux', 'Proton')

    class Tee(object):
        def __init__(self):
            self.logfile = f = open('client_log.txt', 'a+')
            self.history = []
            import datetime
            s = (
                '\n' + datetime.datetime.now().strftime("%Y-%m-%d %H:%M") +
                '\n==============================================\n'
            )
            self.history.append(s)
            f.write(s)

        def write(self, v):
            sys.__stdout__.write(v)
            self.history.append(v)
            self.logfile.write(v.encode('utf-8'))

    tee = sys.stderr = sys.stdout = Tee()

    root = logging.getLogger()
    root.setLevel(logging.DEBUG)
    hldr = logging.StreamHandler(tee)
    hldr.setLevel(getattr(logging, options.log.upper()))
    root.addHandler(hldr)

    debug_log_file = cStringIO.StringIO()
    hldr = logging.StreamHandler(debug_log_file)
    hldr.setLevel(logging.DEBUG)
    root.addHandler(hldr)

    if IS_PROTON or options.color_log:
        from colorlog import ColoredFormatter

        formatter = ColoredFormatter(
            "%(log_color)s%(message)s%(reset)s",
            log_colors={
                'CRITICAL': 'bold_red',
                'ERROR': 'red',
                'WARNING': 'yellow',
                'INFO': 'green',
                'DEBUG': 'blue',
            }
        )

        logging.getLogger().handlers[0].setFormatter(formatter)

    log = logging.getLogger('start_client')

    # gevent: do not patch dns, they fail on windows
    # monkey.patch_socket(dns=False) won't work since
    # socket.create_connection internally references
    # gevents' getaddrinfo
    import socket
    from gevent import socket as gsock

    if not sys.platform.startswith('linux'):
        gsock.getaddrinfo = socket.getaddrinfo
        gsock.gethostbyname = socket.gethostbyname

        # HACK: resolve domain in parallel
        import threading

        class ResolveIt(threading.Thread):
            def __init__(self, host):
                threading.Thread.__init__(self)
                self.host = host

            def run(self):
                host = self.host
                socket.getaddrinfo(host, 80)
                socket.gethostbyname(host)

        domains = [
            'www.thbattle.net',
            'update.thbattle.net',
            'cngame.thbattle.net',
        ]
        for host in domains:
            thread = ResolveIt(host)
            thread.daemon = True
            thread.start()

    from gevent import monkey
    monkey.patch_socket()

    from game import autoenv
    autoenv.init('Client')

    from client.core import Executive

    import pyglet

    pyglet.options['audio'] = ('directsound', 'openal', 'alsa', 'silent')
    pyglet.options['shadow_window'] = False

    if not options.with_gl_errcheck:
        pyglet.options['debug_gl'] = False

    if sys.platform == 'win32':
        from pyglet.media.drivers.directsound import DirectSoundAudioPlayer
        DirectSoundAudioPlayer._buffer_size = 44800 * 2
        DirectSoundAudioPlayer._update_buffer_size = 44800 * 2 // 8

    if sys.platform.startswith('linux') and options.dump_gameobj:
        import atexit
        import game
        atexit.register(game.GameObjectMeta._dump_gameobject_hierarchy)
        atexit.register(game.EventHandler._dump_eh_dependency_graph)

    def do_crashreport(active=False):
        if options.no_crashreport: return
        import requests
        import zlib
        import traceback

        s = u''.join(tee.history)
        s += u'\n\n\nException:\n' + '=' * 80 + '\n' + traceback.format_exc()
        import pyglet.info
        s += u'\n\n\nPyglet info:\n' + pyglet.info.dump()
        debug_log_file.seek(0)
        debug_log = debug_log_file.read()
        s += u'\n\n\nDebug log:\n' + '=' * 80 + '\n' + debug_log
        content = zlib.compress(s.encode('utf-8'))

        try:
            from game.autoenv import Game
            g = Game.getgame()
            gameid = g.gameid
        except:
            gameid = 0

        try:
            from client.core import Executive
            userid = Executive.gamemgr.account.userid
            username = Executive.gamemgr.account.username
        except:
            userid = 0
            username = u'unknown'

        requests.post(
            'http://www.thbattle.net/interconnect/crashreport',
            data={
                'gameid': gameid,
                'active': int(active),
                'userid': userid,
                'username': username,
            },
            files={'file': content},
        )

    from client.ui.entry import start_ui

    try:
        start_ui()
    except KeyboardInterrupt:
        import pyglet
        pyglet.app.exit()
        Executive.call('app_exit')
        raise
    except:
        import pyglet
        pyglet.app.exit()

        if options.fastjoin:
            import pdb
            pdb.post_mortem()

        Executive.call('app_exit')
        log.error(u'游戏崩溃，正在报告bug，请稍等下……')
        do_crashreport()

        raise

    Executive.call('app_exit')


if __name__ == '__main__':
    start_client()

########NEW FILE########
__FILENAME__ = start_server
# -*- coding: utf-8 -*-

import gevent
from gevent import monkey
monkey.patch_all()

from gevent.server import StreamServer

import logging
import sys

MAIN = gevent.getcurrent()

from gevent import signal as sig
import signal


def start_server():

    def _exit_handler(*a, **k):
        gevent.kill(MAIN, SystemExit)
    sig(signal.SIGTERM, _exit_handler)

    from game import autoenv

    import argparse

    parser = argparse.ArgumentParser(prog=sys.argv[0])
    parser.add_argument('node', type=str)
    parser.add_argument('--port', default=9999, type=int)
    parser.add_argument('--backdoor-port', default=19999, type=int)
    parser.add_argument('--testing', action='store_true')
    parser.add_argument('--no-backdoor', action='store_true')
    parser.add_argument('--freeplay', action='store_true')
    parser.add_argument('--log', default='INFO')
    parser.add_argument('--logfile', default='')
    parser.add_argument('--gidfile', default='')
    parser.add_argument('--archive-path', default='')
    parser.add_argument('--interconnect', action='store_true', default=False)
    parser.add_argument('--redis', default='localhost')
    parser.add_argument('--redis-port', default=6379)
    parser.add_argument('--member-service', default='localhost:7000')
    options = parser.parse_args()

    import options as opmodule
    opmodule.options = options

    autoenv.init('Server')

    import settings

    class ServerLogFormatter(logging.Formatter):
        def format(self, rec):

            if rec.exc_info:
                s = []
                s.append('>>>>>>' + '-' * 74)
                s.append(self._format(rec))
                import traceback
                s.append(u''.join(traceback.format_exception(*rec.exc_info)).strip())
                s.append('<<<<<<' + '-' * 74)
                return u'\n'.join(s)
            else:
                return self._format(rec)

        def _format(self, rec):
            from game.autoenv import Game
            import time
            try:
                g = Game.getgame()
            except:
                g = gevent.getcurrent()

            gr_name = getattr(g, 'gr_name', None) or repr(g)
            gr_name = 'MAIN' if g is MAIN else gr_name

            return u'[%s %s %s] %s' % (
                rec.levelname[0],
                time.strftime('%y%m%d %H:%M:%S'),
                gr_name.decode('utf-8'),
                rec.msg % rec.args if isinstance(rec.msg, basestring) else repr((rec.msg, rec.args)),
            )

    fmter = ServerLogFormatter()

    root = logging.getLogger()

    root.setLevel(getattr(logging, options.log.upper()))
    std = logging.StreamHandler(stream=sys.stdout)
    std.setFormatter(fmter)
    root.handlers = []
    root.addHandler(std)

    if options.logfile:
        from logging.handlers import WatchedFileHandler
        filehdlr = WatchedFileHandler(options.logfile)
        filehdlr.setFormatter(fmter)
        root.addHandler(filehdlr)

    if not options.no_backdoor:
        from gevent.backdoor import BackdoorServer
        gevent.spawn(BackdoorServer(('127.0.0.1', options.backdoor_port)).serve_forever)

    from server.core import Client

    root.info('=' * 20 + settings.VERSION + '=' * 20)
    server = StreamServer(('0.0.0.0', options.port), Client.spawn, None)
    server.serve_forever()


if __name__ == '__main__':
    start_server()

########NEW FILE########
__FILENAME__ = user_settings
# -*- coding: utf-8 -*-

from utils.misc import Observable
from utils.crypto import simple_encrypt
import atexit
import logging
import os.path
import simplejson as json

log = logging.getLogger('user_settings')


class UserSettings(dict, Observable):
    __slots__ = ('_ob_dict', )

    def __setitem__(self, k, v):
        dict.__setitem__(self, k, v)
        self.notify('setting_change', k, v)

    def __getattr__(self, name):
        try:
            return self[name]
        except KeyError:
            raise AttributeError

    def __setattr__(self, name, v):
        if name.startswith('_'):
            dict.__setattr__(self, name, v)
            return

        self[name] = v

    def add_setting(self, name, default):
        self[name] = default

    def save(self):
        with open(self._get_conf_name(), 'w') as f:
            f.write(json.dumps(self))

    def load(self):
        conf = self._get_conf_name()
        if not os.path.exists(conf):
            return

        try:
            with open(conf, 'r') as f:
                self.update(json.loads(f.read()))

        except:
            log.exception('Error loading conf')

    def _get_conf_name(self):
        import settings
        return os.path.join(settings.UPDATE_BASE, 'user_settings.json')


UserSettings = UserSettings()

UserSettings.add_setting('last_id', u'无名の罪袋')
UserSettings.add_setting('saved_passwd', simple_encrypt(''))
UserSettings.add_setting('notify_level', 1)
UserSettings.add_setting('sound_notify', True)
UserSettings.add_setting('volume', 1.0)

UserSettings.load()

# reset at start
UserSettings.no_invite = False

atexit.register(UserSettings.save)

########NEW FILE########
__FILENAME__ = crypto
# -*- coding: utf-8 -*-

from cStringIO import StringIO

IV = 'The init vector.'


def _aes_op(data, key, op):
    assert len(key) == 32  # 256 bits

    buf = StringIO()
    import M2Crypto
    c = M2Crypto.EVP.Cipher('aes_256_cbc', key, IV, op)

    buf.write(c.update(data))
    buf.write(c.final())
    return buf.getvalue()


def aes_encrypt(data, key):
    return _aes_op(data, key, 1)


def aes_decrypt(data, key):
    return _aes_op(data, key, 0)

import hashlib
_simple_key = hashlib.sha256('zheshijintiandeqiaokelijianpan').digest()
_enc_head = 'ENC_HEAD'

def simple_encrypt(data):
    return aes_encrypt(_enc_head + str(data), _simple_key).encode('base64')

def simple_decrypt(data):
    try:
        v = aes_decrypt(data.decode('base64'), _simple_key)
        assert v.startswith(_enc_head)
        return v[len(_enc_head):]
    except:
        return ''

########NEW FILE########
__FILENAME__ = geometry
# -*- coding: utf-8 -*-


def rect_to_dict(rect):
    x, y, w, h = rect
    return dict(
        x=x, y=y,
        width=w, height=h,
    )


def rectv2f(x, y, w, h, ax=0, ay=0):
    x1, y1 = x + w, y + h
    return [ax+x, ay+y, ax+x1, ay+y, ax+x1, ay+y1, ax+x, ay+y1]


def rrectv2f(x, y, w, h, ax=0, ay=0):
    x1, y1 = x + w, y + h
    return [ax+x, ay+y, ax+x, ay+y1, ax+x1, ay+y1, ax+x1, ay+y]


def inpoly(x, y, vlist):
    rst = False
    n = len(vlist)
    i = 0
    j = n - 1
    while i < n:
        if ((vlist[i][1] > y) != (vlist[j][1] > y)) and \
                (x <
                    (vlist[j][0] - vlist[i][0]) *
                    (y - vlist[i][1]) /
                    (vlist[j][1] - vlist[i][1]) +
                    (vlist[i][0])):
            rst = not rst

        j = i
        i += 1

    return rst

########NEW FILE########
__FILENAME__ = gevent_ext
# -- coding: utf-8 -*-

from gevent.hub import _NONE, Waiter
from gevent import core


def waitany(objects, timeout=None):
    waiter = Waiter()
    switch = waiter.switch

    if not objects:
        return None

    timer = None
    if timeout is not None:
        timer = core.timer(timeout, switch, _NONE)

    try:
        for obj in objects:
            obj.rawlink(switch)

        rst = waiter.get()
        return None if rst is _NONE else rst

    finally:
        timer and timer.cancel()

        for obj in objects:
            unlink = getattr(obj, 'unlink', None)
            if unlink:
                try:
                    unlink(switch)
                except:
                    import traceback
                    traceback.print_exc()

########NEW FILE########
__FILENAME__ = interconnect
# -*- coding: utf-8 -*-

import redis
import gevent
from gevent import Greenlet
from network import Endpoint
from .misc import surpress_and_restart
import simplejson as json


class Interconnect(Greenlet):
    def __init__(self, node, host, port):
        Greenlet.__init__(self)
        self.node = node
        self.pub = redis.Redis(host=host, port=port)
        self.sub = redis.Redis(host=host, port=port)

    @surpress_and_restart
    def _run(self):
        try:
            sub = self.sub.pubsub()
            sub.psubscribe('thb.*')

            for msg in sub.listen():
                if msg['type'] not in ('message', 'pmessage'):
                    continue

                _, node, topic = msg['channel'].split('.')[:3]
                message = json.loads(msg['data'])

                self.on_message(node, topic, message)

        finally:
            gevent.sleep(1)

    def on_message(self, node, topic, message):
        pass

    def publish(self, topic, data):
        self.pub.publish(
            'thb.{}.{}'.format(self.node, topic),
            Endpoint.encode(data),
        )

    def __repr__(self):
        return self.__class__.__name__

########NEW FILE########
__FILENAME__ = misc
# -*- coding: utf-8 -*-

from collections import deque, defaultdict
from functools import wraps


class Packet(list):  # compare by identity list
    __slots__ = ('scan_count')

    def __hash__(self):
        return id(self)

    def __eq__(self, other):
        return id(self) == id(other)

    def __ne__(self, other):
        return not self.__eq__(other)


class DataHolder(object):
    def __data__(self):
        return self.__dict__

    @staticmethod
    def parse(dd):
        new = DataHolder()
        for k, v in dd.items():
            if isinstance(v, dict):
                setattr(new, k, DataHolder.parse(v))
            elif isinstance(v, (list, tuple, set, frozenset)):
                setattr(new, k, type(v)(
                    DataHolder.parse(lv) if isinstance(lv, dict) else lv
                    for lv in v
                ))
            else:
                setattr(new, k, v)

        return new


class BatchList(list):
    def __getattribute__(self, name):
        try:
            list_attr = list.__getattribute__(self, name)
            return list_attr
        except AttributeError:
            pass

        return list.__getattribute__(self, '__class__')(
            getattr(i, name) for i in self
        )

    def __call__(self, *a, **k):
        return list.__getattribute__(self, '__class__')(
            f(*a, **k) for f in self
        )

    def exclude(self, *elems):
        nl = list.__getattribute__(self, '__class__')(self)
        for e in elems:
            try:
                nl.remove(e)
            except ValueError:
                pass

        return nl

    def rotate_to(self, elem):
        i = self.index(elem)
        n = len(self)
        return self.__class__((self*2)[i:i+n])

    def replace(self, old, new):
        try:
            self[self.index(old)] = new
        except ValueError:
            pass


class CheckFailed(Exception):
    pass


def check(b):
    if not b:
        raise CheckFailed


_ = Ellipsis


def check_type(pattern, obj):
    if isinstance(pattern, (list, tuple)):
        check(isinstance(obj, (list, tuple)))
        if len(pattern) == 2 and pattern[-1] is _:
            cls = pattern[0]
            for v in obj:
                check(isinstance(v, cls))
        else:
            check(len(pattern) == len(obj))
            for cls, v in zip(pattern, obj):
                check_type(cls, v)
    else:
        check(isinstance(obj, pattern))


class Framebuffer(object):
    current_fbo = None

    def __init__(self, texture=None):
        from pyglet import gl
        fbo_id = gl.GLuint(0)
        gl.glGenFramebuffersEXT(1, gl.byref(fbo_id))
        self.fbo_id = fbo_id
        self._texture = None
        if texture:
            self.bind()
            self.texture = texture
            self.unbind()

    def _get_texture(self):
        return self._texture

    def _set_texture(self, t):
        self._texture = t
        from pyglet import gl
        try:
            gl.glFramebufferTexture2DEXT(
                gl.GL_FRAMEBUFFER_EXT,
                gl.GL_COLOR_ATTACHMENT0_EXT,
                t.target, t.id, 0,
            )
        except gl.GLException:
            # HACK: Some Intel card return errno == 1286L
            # which means GL_INVALID_FRAMEBUFFER_OPERATION_EXT
            # but IT ACTUALLY WORKS FINE!!
            pass

        gl.glViewport(0, 0, t.width, t.height)

        gl.glMatrixMode(gl.GL_PROJECTION)
        gl.glLoadIdentity()
        gl.gluOrtho2D(0, t.width, 0, t.height)

        gl.glMatrixMode(gl.GL_MODELVIEW)
        gl.glLoadIdentity()

        # ATI cards hack
        gl.glBegin(gl.GL_LINES)
        gl.glEnd()
        # --------------

    texture = property(_get_texture, _set_texture)

    def __enter__(self):
        self.bind()

    def __exit__(self, exc_type, exc_value, tb):
        self.unbind()

    def bind(self):
        assert Framebuffer.current_fbo is None
        from pyglet import gl
        t = self.texture
        gl.glBindFramebufferEXT(gl.GL_FRAMEBUFFER_EXT, self.fbo_id)
        gl.glPushAttrib(gl.GL_VIEWPORT_BIT | gl.GL_TRANSFORM_BIT)
        if t:
            gl.glViewport(0, 0, t.width, t.height)
        gl.glMatrixMode(gl.GL_PROJECTION)
        gl.glPushMatrix()
        if t:
            gl.glLoadIdentity()
            gl.gluOrtho2D(0, t.width, 0, t.height)
        gl.glMatrixMode(gl.GL_MODELVIEW)
        gl.glPushMatrix()
        if t:
            gl.glLoadIdentity()

        Framebuffer.current_fbo = self

    def unbind(self):
        from pyglet import gl
        gl.glMatrixMode(gl.GL_MODELVIEW)
        gl.glPopMatrix()
        gl.glMatrixMode(gl.GL_PROJECTION)
        gl.glPopMatrix()
        gl.glPopAttrib()
        gl.glBindFramebufferEXT(gl.GL_FRAMEBUFFER_EXT, 0)
        Framebuffer.current_fbo = None

    def __del__(self):
        from pyglet import gl
        try:
            gl.glDeleteFramebuffersEXT(1, self.fbo_id)
        except:
            pass

    def blit_from_current_readbuffer(self, src_box, dst_box=None, mask=None, _filter=None):
        from pyglet import gl
        mask = mask if mask else gl.GL_COLOR_BUFFER_BIT
        _filter = _filter if _filter else gl.GL_LINEAR

        if not dst_box:
            dst_box = (0, 0, src_box[2] - src_box[0], src_box[3] - src_box[1])

        args = tuple(src_box) + tuple(dst_box) + (mask, _filter)
        gl.glBlitFramebufferEXT(*args)


def dilate(im, color):
    import pyglet
    w, h = im.width, im.height
    _ori = bytearray(im.get_data('A', w))
    _new = bytearray(_ori)

    class accesser(object):
        def __init__(self, arr):
            self.arr = arr

        def __getitem__(self, val):
            x, y = val
            if not (0 <= x < w and 0 <= y < h):
                return 0
            else:
                return self.arr[y*w + x]

        def __setitem__(self, loc, val):
            x, y = loc
            self.arr[y*w + x] = val

    ori = accesser(_ori)
    new = accesser(_new)

    for x in xrange(w):
        for y in xrange(h):
            if any([
                ori[x, y],
                ori[x-1, y], ori[x+1, y], ori[x, y-1], ori[x, y+1],
                ori[x-1, y-1], ori[x-1, y+1], ori[x+1, y-1], ori[x+1, y+1],
            ]):
                new[x, y] = True
            else:
                new[x, y] = False

    color = ''.join([chr(i) for i in color]) + '\xff'
    tr = ['\x00'*4, color]
    new = ''.join([tr[i] for i in _new])
    new = pyglet.image.ImageData(w, h, 'RGBA', new)
    return new

TRANS = {
    124: 101,  # LOAD_FAST: LOAD_NAME,
    125: 90,  # STORE_FAST: STORE_NAME,
    126: 91,  # DELETE_FAST: DELETE_NAME,
}


def pinnable(*scopevars):
    def _pinnable(f):
        c = f.__code__

        assert c.co_argcount == 0
        assert len(c.co_freevars) == 0
        assert len(c.co_cellvars) == 0

        names = c.co_names
        vnames = c.co_varnames

        len_names = len(names)

        bcode = [ord(i) for i in c.co_code]
        nbcode = []
        i = 0
        n = len(bcode)
        while i < n:
            op = bcode[i]
            nop = TRANS.get(op, op)
            i += 1
            if op >= 90:  # HAVE_ARGUMENT
                if op in (124, 125, 126):  # (LOAD|STORE|DELETE)_FAST opcodes
                    nbcode.append(nop)
                    arg = bcode[i] + (bcode[i+1] << 8)
                    arg += len_names
                    nbcode.extend([arg & 255, (arg >> 8) & 255])
                elif op == 116:  # LOAD_GLOBAL
                    arg = bcode[i] + (bcode[i+1] << 8)
                    gname = names[arg]
                    if gname in scopevars:
                        nbcode.append(101)  # LOAD_NAME
                    else:
                        nbcode.append(nop)
                    nbcode.extend(bcode[i:i+2])
                else:
                    nbcode.append(nop)
                    nbcode.extend(bcode[i:i+2])
                i += 2
            else:
                nbcode.append(nop)

        nbcode = ''.join(chr(i) for i in nbcode)
        newco = type(c)(
            0, 0, c.co_stacksize, c.co_flags & (~2),  # CO_NEWLOCALS
            nbcode, c.co_consts, names + vnames,
            tuple(), c.co_filename, '<pinnable %s>' % f.__name__,
            c.co_firstlineno, c.co_lnotab
        )
        return newco
    return _pinnable


def remove_dups(s):
    seen = set()
    for i in s:
        if i not in seen:
            yield i
            seen.add(i)


def classmix(*_classes):
    classes = []
    for c in _classes:
        if hasattr(c, '_is_mixedclass'):
            classes.extend(c.__bases__)
        else:
            classes.append(c)

    classes = tuple(remove_dups(classes))
    cached = cls_cache.get(classes, None)
    if cached: return cached

    clsname = ', '.join(cls.__name__ for cls in classes)
    new_cls = type('Mixed(%s)' % clsname, classes, {'_is_mixedclass': True})
    cls_cache[classes] = new_cls
    return new_cls

cls_cache = {}


def hook(module):
    def inner(hooker):
        funcname = hooker.__name__
        hookee = getattr(module, funcname)

        @wraps(hookee)
        def real_hooker(*args, **kwargs):
            return hooker(hookee, *args, **kwargs)
        setattr(module, funcname, real_hooker)
        return real_hooker
    return inner


def gif_to_animation(giffile):
    import pyglet
    from PIL import Image

    im = Image.open(giffile)

    dur = []
    framedata = []

    while True:
        dur.append(im.info['duration'])
        framedata.append(im.convert('RGBA').tostring())
        try:
            im.seek(im.tell()+1)
        except:
            break

    dur[0] = 100

    w, h = im.size

    frames = []
    for d, data in zip(dur, framedata):
        img = pyglet.image.ImageData(w, h, 'RGBA', data, pitch=-w*4)
        img.anchor_x, img.anchor_y = img.width // 2, img.height // 2
        frames.append(
            pyglet.image.AnimationFrame(img, d/1000.0)
        )

    anim = pyglet.image.Animation(frames)
    anim.width, anim.height = w, h

    return anim


class DisplayList(object):
    compiled = False

    def __init__(self):
        from pyglet import gl
        self._list_id = gl.glGenLists(1)

    def __enter__(self):
        self.compiled = True
        from pyglet import gl
        gl.glNewList(self._list_id, gl.GL_COMPILE)
        return self

    def __exit__(self, *exc_args):
        from pyglet import gl
        gl.glEndList()

    def __call__(self):
        if not self.compiled:
            return Exception('Not compiled!')
        from pyglet import gl
        gl.glCallList(self._list_id)

    def __del__(self):
        from pyglet import gl
        try:
            gl.glDeleteLists(self._list_id, 1)
        except:
            pass


def extendclass(clsname, bases, _dict):
    for cls in bases:
        for key, value in _dict.items():
            if key == '__module__':
                continue
            setattr(cls, key, value)


def textsnap(text, font, l):
    tl = 0
    for i, g in enumerate(font.get_glyphs(text)):
        if tl + g.advance > l:
            break
        tl += g.advance
    else:
        return text

    return text[:i]


def textwidth(text, font):
    return sum([g.advance for g in font.get_glyphs(text)])


def partition(pred, l):
    t = filter(pred, l)
    f = filter(lambda v: not pred(v), l)
    return t, f


import functools


def track(f):
    @functools.wraps(f)
    def _wrapper(*a, **k):
        print '%s: %s %s' % (f.__name__, a, k)
        return f(*a, **k)
    return _wrapper


class _Enum(object):
    def __init__(self, forward, reverse):
        self.forward = forward
        self.reverse = reverse

    def __getattr__(self, name):
        return self.forward[name]

    def rlookup(self, v):
        return self.reverse[v]


class EnumMeta(type):
    def __new__(cls, clsname, bases, _dict):
        if bases == (object,):
            return type.__new__(cls, clsname, bases, _dict)

        forward = {}
        reverse = {}
        _dict.pop('__module__')
        for k, v in _dict.iteritems():
            forward[k] = v
            reverse[v] = k

        return _Enum(forward, reverse)


class Enum(object):
    __metaclass__ = EnumMeta


def flatten(l):
    rst = []

    def _flatten(sl):
        for i in sl:
            if isinstance(i, (list, tuple, deque)):
                _flatten(i)
            else:
                rst.append(i)

    _flatten(l)
    return rst


def group_by(l, keyfunc):
    if not l: return []

    grouped = []
    group = []

    lastkey = keyfunc(l[0])
    for i in l:
        k = keyfunc(i)
        if k == lastkey:
            group.append(i)
        else:
            grouped.append(group)
            group = [i]
            lastkey = k

    if group:
        grouped.append(group)

    return grouped


def filter_out(l, func):
    filtered = []
    reserved = []
    [(filtered if func(x) else reserved).append(x) for x in l]
    l[:] = reserved
    return filtered


def instantiate(cls):
    return cls()


def surpress_and_restart(f):
    def wrapper(*a, **k):
        while True:
            try:
                return f(*a, **k)
            except Exception as e:
                import logging
                log = logging.getLogger('misc')
                log.exception(e)

    return wrapper


def swallow(f):
    def wrapper(*a, **k):
        try:
            return f(*a, **k)
        except:
            pass

    return wrapper


def log_failure(logger):
    def decorate(f):
        def wrapper(*a, **k):
            try:
                return f(*a, **k)
            except Exception as e:
                logger.exception(e)
                raise

        return wrapper

    return decorate


def openurl(url):
    import sys
    import os

    if sys.platform == 'win32':
        os.startfile(url, 'open')

    elif sys.platform.startswith('linux'):
        os.system("xdg-open '%s'" % url)


class Observable(object):
    def _get_ob_dict(self):
        obdict = getattr(self, '_ob_dict', None)

        if obdict is None:
            obdict = self._ob_dict = defaultdict(set)

        return obdict

    def add_observer(self, event, callable):
        self._get_ob_dict()[event].add(callable)

    def remove_observer(self, event, callable):
        self._get_ob_dict()[event].discard(callable)

    def notify(self, event, *a, **k):
        for cb in self._get_ob_dict()[event]:
            cb(*a, **k)

########NEW FILE########
__FILENAME__ = notify
# -*- coding: utf-8 -*-
NONE = 0
BASIC = 0.5
AT = 1
SPEAKER = 2


def _notify(title, msg):
    pass


try:
    import pynotify
    pynotify.init('thbattle')
    n = pynotify.Notification('None')

    def _notify(title, msg):  # noqa
        try:
            n.update(title, msg)
            n.show()
        except:
            pass

except ImportError:
    pass

import os
import platform

if os.name == 'nt' or platform.system() == 'Windows':
    from ctypes import Structure, windll, sizeof, byref
    from ctypes.wintypes import DWORD, HICON, HWND, UINT, WCHAR

    class NOTIFYICONDATAW(Structure):
        _fields_ = [
            ("cbSize", DWORD),
            ("hWnd", HWND),
            ("uID", UINT),
            ("uFlags", UINT),
            ("uCallbackMessage", UINT),
            ("hIcon", HICON),
            ("szTip", WCHAR * 128),
            ("dwState", DWORD),
            ("dwStateMask", DWORD),
            ("szInfo", WCHAR * 256),
            ("uVersion", UINT),
            ("szInfoTitle", WCHAR * 64),
            ("dwInfoFlags", DWORD),
        ]

    NIM_ADD = 0
    NIM_MODIFY = 1
    NIM_DELETE = 2
    NIM_SETFOCUS = 3
    NIM_SETVERSION = 4

    NIF_ICON = 2
    NIF_TIP = 4
    NIF_STATE = 8
    NIF_INFO = 0x10

    NIIF_NONE = 0
    NIIF_INFO = 1
    NIIF_WARNING = 2
    NIIF_ERROR = 3
    NIIF_USER = 4
    NIIF_NOSOUND = 0x10

    GCLP_HICON = -14

    has_init = False

    def _notify(title, msg):  # noqa
        global data, has_init

        if not has_init:
            has_init = True

            from client.ui.base.baseclasses import main_window
            hWnd = main_window._hwnd
            windll.user32.GetClassLongW.restype = HICON
            hIcon = windll.user32.GetClassLongW(hWnd, GCLP_HICON)
            data = NOTIFYICONDATAW(sizeof(NOTIFYICONDATAW), hWnd)
            data.hIcon = hIcon
            data.uFlags = NIF_ICON
            data.uVersion = 3
            windll.shell32.Shell_NotifyIconW(NIM_ADD, byref(data))
            windll.shell32.Shell_NotifyIconW(NIM_SETVERSION, byref(data))
            data.uVersion = 10  # uTimeout
            data.uFlags = NIF_INFO
            data.dwInfoFlags = NIIF_INFO

            def remove_icon():
                windll.shell32.Shell_NotifyIconW(NIM_DELETE, byref(data))
            import atexit
            atexit.register(remove_icon)

        data.szInfoTitle = unicode(title)[:63]
        data.szInfo = unicode(msg)[:255]
        windll.shell32.Shell_NotifyIconW(NIM_MODIFY, byref(data))


def notify(title, msg, level=BASIC):
    from user_settings import UserSettings as us
    if level <= us.notify_level:
        _notify(title, msg)
        if us.sound_notify:
            from client.ui.soundmgr import SoundManager
            from client.ui.resource import resource as cres

            SoundManager.play(cres.sound.input)

__all__ = ['notify', 'NONE', 'BASIC', 'SPEAKER', 'AT']

########NEW FILE########
__FILENAME__ = pyperclip
# Pyperclip v1.3
# A cross-platform clipboard module for Python. (only handles plain text for now)
# By Al Sweigart al@coffeeghost.net

# Usage:
#   import pyperclip
#   pyperclip.copy('The text to be copied to the clipboard.')
#   spam = pyperclip.paste()

# On Mac, this module makes use of the pbcopy and pbpaste commands, which should come with the os.
# On Linux, this module makes use of the xclip command, which should come with the os. Otherwise run "sudo apt-get install xclip"


# Copyright (c) 2010, Albert Sweigart
# All rights reserved.
#
# BSD-style license:
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the pyperclip nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY Albert Sweigart "AS IS" AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL Albert Sweigart BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Change Log:
# 1.2 Use the platform module to help determine OS.
# 1.3 Changed ctypes.windll.user32.OpenClipboard(None) to ctypes.windll.user32.OpenClipboard(0), after some people ran into some TypeError

import platform, os

def winGetClipboard():
    ctypes.windll.user32.OpenClipboard(0)
    pcontents = ctypes.windll.user32.GetClipboardData(13) # CF_UNICODETEXT
    data = ctypes.c_wchar_p(pcontents).value
    ctypes.windll.user32.CloseClipboard()
    return data

def winSetClipboard(text):
    GMEM_DDESHARE = 0x2000 # Compat for 16-bit windows !?
    ctypes.windll.user32.OpenClipboard(0)
    ctypes.windll.user32.EmptyClipboard()
    lpwstr = ctypes.c_wchar_p(text)
    strlen = ctypes.cdll.msvcrt.wcslen(lpwstr)
    hcd = ctypes.windll.kernel32.GlobalAlloc(GMEM_DDESHARE, 2 * (strlen + 1))
    pcd = ctypes.windll.kernel32.GlobalLock(hcd)
    ctypes.cdll.msvcrt.wcscpy(pcd, lpwstr)
    ctypes.windll.kernel32.GlobalUnlock(hcd)
    ctypes.windll.user32.SetClipboardData(13, hcd) # CF_UNICODETEXT
    ctypes.windll.user32.CloseClipboard()

def macSetClipboard(text):
    outf = os.popen('pbcopy', 'w')
    outf.write(text)
    outf.close()

def macGetClipboard():
    outf = os.popen('pbpaste', 'r')
    content = outf.read()
    outf.close()
    return content

def gtkGetClipboard():
    return gtk.Clipboard().wait_for_text()

def gtkSetClipboard(text):
    cb = gtk.Clipboard()
    cb.set_text(text)
    cb.store()

def qtGetClipboard():
    return str(cb.text())

def qtSetClipboard(text):
    cb.setText(text)

def xclipSetClipboard(text):
    outf = os.popen('xclip -selection c', 'w')
    outf.write(text)
    outf.close()

def xclipGetClipboard():
    outf = os.popen('xclip -selection c -o', 'r')
    content = outf.read()
    outf.close()
    return content

def xselSetClipboard(text):
    outf = os.popen('xsel -i', 'w')
    outf.write(text)
    outf.close()

def xselGetClipboard():
    outf = os.popen('xsel -o', 'r')
    content = outf.read()
    outf.close()
    return content


if os.name == 'nt' or platform.system() == 'Windows':
    import ctypes
    getcb = winGetClipboard
    setcb = winSetClipboard
elif os.name == 'mac' or platform.system() == 'Darwin':
    getcb = macGetClipboard
    setcb = macSetClipboard
elif os.name == 'posix' or platform.system() == 'Linux':
    xclipExists = os.system('which xclip > /dev/null') == 0
    if xclipExists:
        getcb = xclipGetClipboard
        setcb = xclipSetClipboard
    else:
        xselExists = os.system('which xsel > /dev/null') == 0
        if xselExists:
            getcb = xselGetClipboard
            setcb = xselSetClipboard
        try:
            import gtk
            getcb = gtkGetClipboard
            setcb = gtkSetClipboard
        except:
            try:
                import PyQt4.QtCore
                import PyQt4.QtGui
                app = QApplication([])
                cb = PyQt4.QtGui.QApplication.clipboard()
                getcb = qtGetClipboard
                setcb = qtSetClipboard
            except:
                getcb = setcb = lambda *a, **k: ''

copy = setcb
paste = getcb

########NEW FILE########
__FILENAME__ = rpc
# -*- coding: utf-8 -*-

# -- stdlib --
import traceback
from functools import partial

# -- third party --
import gevent
from gevent import Timeout
from gevent import socket, Greenlet
from gevent.coros import RLock
import msgpack

# -- own --
from .misc import swallow


# -- code --
REQUEST = 1
RESPONSE = 2
EXCEPTION = 3


class RPCError(Exception):
    pass


class RPCServerGone(RPCError):
    pass


class RPCClient(object):
    def __init__(self, addr, timeout=2):
        self.addr = addr
        self.sock = None
        self.unpacker = None
        self.timeout = timeout
        self.lock = RLock()

    def __getattr__(self, name):
        return partial(self.call, name)

    def call(self, func_name, *args, **kwargs):
        for i in range(2):
            try:
                return self._do_call(func_name, args, kwargs)
            except RPCServerGone:
                pass

        raise RPCError("WTF?! Shouldn't be here!")

    def _do_call(self, func_name, args, kwargs):
        with self.lock:
            if not self.sock:
                try:
                    connected = False
                    with Timeout(self.timeout):
                        s = socket.socket()
                        s.connect(self.addr)
                        connected = True

                    if not connected:
                        raise RPCError("Connection time out!")

                except socket.error:
                    raise RPCError("can't connect!")

                s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                s.read = s.recv
                s.write = s.send
                self.unpacker = msgpack.Unpacker(s)
                self.sock = s

            try:
                msgpack.pack([REQUEST, func_name, args, kwargs], self.sock)
                resp = self.unpacker.unpack()
            except:
                swallow(self.sock.close)()
                self.sock = self.unpacker = None
                raise RPCServerGone()

            if resp[0] == RESPONSE:
                # resp == [RESPONSE, result]
                return resp[1]
            elif resp[0] == EXCEPTION:
                # resp == [EXCEPTION, name, traceback_text]
                exc = RPCError('Remote exception: %s' % resp[1])
                exc.traceback_text = resp[2]
                raise exc

            raise RPCError('Wrong protocol!')


class RPCService(Greenlet):
    def __init__(self, sock, addr):
        self.sock = sock
        self.addr = addr
        Greenlet.__init__(self)

    def _run(self):
        try:
            sock = self.sock
            sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
            sock.read = sock.recv
            sock.write = sock.send
            unpacker = msgpack.Unpacker(sock)
            for req in unpacker:
                if not req[0] == REQUEST:
                    msgpack.pack([EXCEPTION, 'InvalidRequest', ''], sock)
                    continue

                _, method, args, kwargs = req
                f = getattr(self, method, None)

                if not f:
                    msgpack.pack([EXCEPTION, 'NoSuchMethod', ''], sock)
                    continue

                try:
                    ret = f(*args, **kwargs)
                    rst = [RESPONSE, ret]
                except Exception as e:
                    rst = [EXCEPTION, e.__class__.__name__, traceback.format_exc()]

                msgpack.pack(rst, sock)

        except:
            swallow(sock.close)()

########NEW FILE########
__FILENAME__ = mock
# -*- coding: utf-8 -*-

import logging
log = logging.getLogger('mock')

from utils import hook
from gevent.event import Event
from network import Endpoint
import simplejson as json
import re


class MockConnection(object):
    def __init__(self, gdlist):
        self.gdlist = gdlist
        self.gdevent = Event()
        self.gdevent.clear()
        self.exhausted = False
        self.gdhistory = []

    def gexpect(self, tag, blocking=False):
        assert self.gdlist, 'GAME_DATA_EXHAUSTED!'
        # log.info('GAME_EXPECT: %s', repr(tag))

        log.info('GAME_EXPECT: %s', tag)
        glob = False
        if tag.endswith('*'):
            glob = True

        missed = False
        for i, d in enumerate(self.gdlist):
            cond = d[0] == tag
            cond = cond or glob and d[0].startswith(tag[:-1])
            cond = cond or d[0].startswith('>') and re.match(d[0][1:] + '$', tag)
            if cond:
                log.info('GAME_READ: %s', repr(d))
                del self.gdlist[i]

                if not self.gdlist:
                    log.info('Game data exhausted.')

                return d
            if not missed:
                log.info('GAME_DATA_MISS: %s', repr(d))
                missed = True

        assert False, 'GAME_DATA_MISS! EXPECTS "%s"' % tag

    def gwrite(self, tag, data):
        log.debug('GAME_WRITE: %s', repr([tag, data]))
        encoded = Endpoint.encode(data)
        self.gdhistory.append([tag, json.loads(encoded)])


    def gclear(self):
        assert self.exhausted


def create_mock_player(gdlist):
    conn = MockConnection(gdlist[:])
    from server.core import Player
    return Player(conn)


def hook_game(g):
    @hook(g)
    def pause(*a):
        pass

    g.synctag = 0

    from client.core import Game
    Game.getgame = staticmethod(lambda: g)

    from server.core import Game
    Game.getgame = staticmethod(lambda: g)

    g.__class__.getgame = staticmethod(lambda: g)

########NEW FILE########
__FILENAME__ = test_general
# -*- coding: utf-8 -*-

class TestImport(object):
    def test_client_import(self):
        from game import autoenv
        autoenv.init('Client')

        import network
        import client.core

    def test_server_import(self):
        from game import autoenv
        autoenv.init('Server')

        import server.core

    def test_thb_import(self):
        from game import autoenv
        autoenv.init('Server')

        import gamepack.thb
        # import gamepack.thb.ui
        import gamepack.thb.cards
        import gamepack.thb.characters

########NEW FILE########
__FILENAME__ = test_inputlet
# -*- coding: utf-8 -*-
from collections import defaultdict
from .mock import create_mock_player, hook_game, MockConnection
from nose.tools import eq_
import random


class TestInputlet(object):
    def getInputletInstances(self):
        from gamepack.thb.cards import AttackCard
        from gamepack.thb.characters.youmu import Youmu
        from gamepack.thb.common import CharChoice
        from gamepack.thb.inputlets import ActionInputlet
        from gamepack.thb.inputlets import ChooseGirlInputlet
        from gamepack.thb.inputlets import ChooseIndividualCardInputlet
        from gamepack.thb.inputlets import ChooseOptionInputlet
        from gamepack.thb.inputlets import ChoosePeerCardInputlet
        from gamepack.thb.inputlets import ProphetInputlet

        g, p = self.makeGame()

        ilets = [
            ActionInputlet(self, ['cards', 'showncards'], []),
            ChooseGirlInputlet(self, {p: [CharChoice(Youmu)]}),
            ChooseIndividualCardInputlet(self, [AttackCard()]),
            ChooseOptionInputlet(self),
            ChoosePeerCardInputlet(self, p, ['cards']),
            ProphetInputlet(self, [AttackCard()]),
        ]

        for i in ilets:
            i.actor = p

        return g, p, ilets

    def testParseNone(self):
        g, p, ilets = self.getInputletInstances()
        for ilet in ilets:
            ilet.parse(None)

    def testCallDataWithoutResultBeingSet(self):
        g, p, ilets = self.getInputletInstances()
        for ilet in ilets:
            ilet.data()

    def testInputletNameClash(self):
        from game import Inputlet
        classes = Inputlet.__subclasses__()

        clsnames = set([cls.tag() for cls in classes])
        assert len(clsnames) == len(classes)

    def testChooseOptionInputlet(self):
        from game import autoenv
        from game.autoenv import user_input
        from client.core import TheChosenOne, PeerPlayer

        from gamepack.thb.thb3v3 import THBattle
        from gamepack.thb.inputlets import ChooseOptionInputlet
        from utils import BatchList

        autoenv.init('Server')
        g = THBattle()
        g.IS_DEBUG = True
        pl = [create_mock_player([]) for i in xrange(6)]
        p = pl[0]
        g.me = p
        p.client.gdlist.extend([
            ['I:ChooseOption:1', True],
            ['I&:ChooseOption:2', False],
            ['I|:ChooseOption:3', True],
        ])
        p.client.gdevent.set()
        g.players = BatchList(pl)
        hook_game(g)

        ilet = ChooseOptionInputlet(self)

        eq_(user_input([p], ilet), True)
        eq_(user_input([p], ilet, type='all'), {p: False})
        eq_(user_input([p], ilet, type='any'), (p, True))

        for p in pl:
            eq_(p.client.gdhistory, [
                ['RI:ChooseOption:1', True],
                ['RI&:ChooseOption:2', False],
                ['RI|:ChooseOption:3', True],
            ])

        autoenv.init('Client')
        g = THBattle()
        pl = [PeerPlayer() for i in xrange(6)]
        svr = MockConnection([
            ['RI:ChooseOption:1', True],
            ['RI&:ChooseOption:2', False],
            ['RI|:ChooseOption:3', True],
        ])
        p = TheChosenOne(svr)
        pl[0] = p
        g.me = p
        svr.gdevent.set()
        g.players = BatchList(pl)
        hook_game(g)
        assert autoenv.Game.getgame() is g

        ilet = ChooseOptionInputlet(self)

        eq_(user_input([p], ilet), True)
        eq_(user_input([p], ilet, type='all'), {p: False})
        eq_(user_input([p], ilet, type='any'), (p, True))

    def makeGame(self):
        from game import autoenv

        from gamepack.thb.thb3v3 import THBattle
        from gamepack.thb.cards import Deck, CardList
        from gamepack.thb.characters.eirin import FirstAid, Medic

        from utils import BatchList

        autoenv.init('Server')
        g = THBattle()
        g.IS_DEBUG = True
        g.random = random
        hook_game(g)
        deck = Deck()
        g.deck = deck

        pl = [create_mock_player([]) for i in xrange(6)]
        for p in pl:
            p.skills = [FirstAid, Medic]

            p.cards = CardList(p, 'cards')  # Cards in hand
            p.showncards = CardList(p, 'showncard')  # Cards which are shown to the others, treated as 'Cards in hand'
            p.equips = CardList(p, 'equips')  # Equipments
            p.fatetell = CardList(p, 'fatetell')  # Cards in the Fatetell Zone
            p.faiths = CardList(p, 'faiths')  # Cards in the Fatetell Zone
            p.special = CardList(p, 'special')  # used on special purpose

            p.showncardlists = [p.showncards, p.fatetell]

            p.tags = defaultdict(int)

            p.dead = False

        p = pl[0]
        p.client.gdevent.set()
        g.players = BatchList(pl)

        return g, p

    def testActionInputlet(self):
        from game.autoenv import user_input
        from gamepack.thb.cards import migrate_cards
        from gamepack.thb.characters.eirin import FirstAid, Medic
        from gamepack.thb.inputlets import ActionInputlet

        g, p = self.makeGame()
        c1, c2, c3 = g.deck.getcards(3)

        migrate_cards([c1, c2, c3], p.cards, no_event=True)

        ilet = ActionInputlet(self, ['cards', 'showncards'], candidates=g.players)
        ilet.skills = [FirstAid]
        ilet.cards = [c1, c2]
        ilet.players = [p, p]
        ilet.actor = p
        eq_(ilet.data(), [[0], [c1.syncid, c2.syncid], [0, 0]])

        p.client.gdlist.append([r'>I:Action:\d+', [[], [c1.syncid, c2.syncid], []]])
        ilet = ActionInputlet(self, ['cards', 'showncards'], [])
        eq_(user_input([p], ilet), [[], [c1, c2], []])

        p.client.gdlist.append([r'>I:Action:\d+', [[0], [c2.syncid, c3.syncid], []]])
        ilet = ActionInputlet(self, ['cards', 'showncards'], [])
        eq_(user_input([p], ilet), [[FirstAid], [c2, c3], []])

        p.client.gdlist.append([r'>I:Action:\d+', [[1, 0], [c3.syncid, c1.syncid], [0]]])
        ilet = ActionInputlet(self, ['cards', 'showncards'], [])
        eq_(user_input([p], ilet), [[Medic, FirstAid], [c3, c1], []])

        p.client.gdlist.append([r'>I:Action:\d+', [[1, 0], [c3.syncid, c1.syncid], [0]]])
        ilet = ActionInputlet(self, ['cards', 'showncards'], candidates=g.players)
        eq_(user_input([p], ilet), [[Medic, FirstAid], [c3, c1], [p]])

        p.client.gdlist.append([r'>I:Action:\d+', [[3, 0], [c3.syncid, c1.syncid], [0]]])
        ilet = ActionInputlet(self, ['cards', 'showncards'], [])
        eq_(user_input([p], ilet), None)

        p.client.gdlist.append([r'>I:Action:\d+', 'evil'])
        ilet = ActionInputlet(self, ['cards', 'showncards'], [])
        eq_(user_input([p], ilet), None)

    def testChooseIndividualCardInputlet(self):
        from game.autoenv import user_input
        from gamepack.thb.inputlets import ChooseIndividualCardInputlet

        g, p = self.makeGame()
        cards = g.deck.getcards(5)

        ilet = ChooseIndividualCardInputlet(self, cards=cards)
        ilet.set_card(cards[1])
        eq_(ilet.data(), cards[1].syncid)

        p.client.gdlist.append([r'>I:ChooseIndividualCard:\d+', cards[2].syncid])
        ilet = ChooseIndividualCardInputlet(self, cards=cards)
        eq_(user_input([p], ilet), cards[2])

        p.client.gdlist.append([r'>I:ChooseIndividualCard:\d+', 343434])
        ilet = ChooseIndividualCardInputlet(self, cards=cards)
        eq_(user_input([p], ilet), None)

    def testChoosePeerCardInputlet(self):
        from game.autoenv import user_input
        from gamepack.thb.inputlets import ChoosePeerCardInputlet
        from gamepack.thb.cards import migrate_cards

        g, p = self.makeGame()
        tgt = g.players[1]

        cards = g.deck.getcards(5)
        migrate_cards(cards, tgt.cards, no_event=True)

        showncards = g.deck.getcards(5)
        migrate_cards(showncards, tgt.showncards, no_event=True)

        ilet = ChoosePeerCardInputlet(self, target=tgt, categories=['cards'])
        ilet.set_card(cards[1])
        eq_(ilet.data(), cards[1].syncid)

        p.client.gdlist.append([r'>I:ChoosePeerCard:\d+', cards[2].syncid])
        ilet = ChoosePeerCardInputlet(self, target=tgt, categories=['cards'])
        eq_(user_input([p], ilet), cards[2])

        p.client.gdlist.append([r'>I:ChoosePeerCard:\d+', showncards[2].syncid])
        ilet = ChoosePeerCardInputlet(self, target=tgt, categories=['cards'])
        eq_(user_input([p], ilet), None)

        p.client.gdlist.append([r'>I:ChoosePeerCard:\d+', 343434])
        ilet = ChoosePeerCardInputlet(self, target=tgt, categories=['cards'])
        eq_(user_input([p], ilet), None)

    def testProphetInputlet(self):
        from game import autoenv
        autoenv.init('Server')

        from game.autoenv import user_input
        from gamepack.thb.inputlets import ProphetInputlet

        g, p = self.makeGame()

        cards = g.deck.getcards(5)
        c0, c1, c2, c3, c4 = cards

        ilet = ProphetInputlet(self, cards=cards)
        ilet.set_result([c2, c3, c1], [c0, c4])
        eq_(ilet.data(), [[2, 3, 1], [0, 4]])

        p.client.gdlist.append([r'>I:Prophet:\d+', [[2, 3, 1], [0, 4]]])
        ilet = ProphetInputlet(self, cards=cards)
        eq_(user_input([p], ilet), [[c2, c3, c1], [c0, c4]])

        p.client.gdlist.append([r'>I:Prophet:\d+', [[2, 3], [0, 4]]])
        ilet = ProphetInputlet(self, cards=cards)
        eq_(user_input([p], ilet), [cards, []])

        p.client.gdlist.append([r'>I:Prophet:\d+', [[2, 3, 1, 0], [0, 4]]])
        ilet = ProphetInputlet(self, cards=cards)
        eq_(user_input([p], ilet), [cards, []])

        p.client.gdlist.append([r'>I:Prophet:\d+', [[2, 3, 0], [0, 4]]])
        ilet = ProphetInputlet(self, cards=cards)
        eq_(user_input([p], ilet), [cards, []])

    def testChooseGirlInputlet(self):
        from game.autoenv import user_input
        from gamepack.thb.common import CharChoice
        from gamepack.thb.characters.youmu import Youmu
        from gamepack.thb.characters.seiga import Seiga
        from gamepack.thb.inputlets import ChooseGirlInputlet

        g, p = self.makeGame()
        choices = [CharChoice(Youmu), CharChoice(Seiga)]
        mapping = {p: choices}

        ilet = ChooseGirlInputlet(self, mapping)
        ilet.actor = p
        ilet.set_choice(choices[0])
        eq_(ilet.data(), 0)

        p.client.gdlist.append([r'>I:ChooseGirl:\d+', 0])
        ilet = ChooseGirlInputlet(self, mapping)
        eq_(user_input([p], ilet), choices[0])

    def testGameImport(self):
        from gamepack.thb.thb3v3 import THBattle  # noqa
        from gamepack.thb.thbkof import THBattleKOF  # noqa
        from gamepack.thb.thbidentity import THBattleIdentity  # noqa
        from gamepack.thb.thbraid import THBattleRaid  # noqa

########NEW FILE########
__FILENAME__ = build_viewer_data
# -*- coding: utf-8 -*-

import sys
sys.path.append('../src')

import re
import pyglet
pyglet.options['shadow_window'] = False

import simplejson as json
from unidecode import unidecode

from game import autoenv
autoenv.init('Client')

sys.modules['gamepack.thb.ui.resource'] = sys.modules['__main__']  # dark art


class attrname(object):
    def __getattr__(self, name):
        return name


resource = attrname()


from gamepack.thb.ui.ui_meta.common import metadata
from gamepack.thb import cards
from gamepack.thb import characters
from game.autoenv import Game


def to_html(text):
    result = []
    tagstack = []

    def push(klass):
        def scanner_cb(s, tok):
            result.append('<span class="{}">'.format(klass))
            tagstack.append('span')
        return scanner_cb

    def restore(s, tok):
        for i in reversed(tagstack):
            result.append('</{}>'.format(i))

        tagstack[:] = []

    def error(s, tok):
        raise Exception('....')

    def instext(s, tok):
        result.append(tok.replace('\n', '<br />'))

    def color(s, tok):
        c = tok[2:8]
        result.append('<span style="color: #{};">'.format(c))
        tagstack.append('span')

    def insert_pipe(s, tok):
        instext(s, '|')

    def label(ltype):
        def scanner_cb(s, tok):
            result.append('<span class="label label-{}">'.format(ltype))
            tagstack.append('span')

        return scanner_cb

    scanner = re.Scanner([
        (r'[^|]+', instext),
        (r'\|c[A-Fa-f0-9]{8}', color),
        (r'\|B', push('bold')),
        (r'\|b', error),
        (r'\|I', push('italic')),
        (r'\|i', error),
        (r'\|U', push('underline')),
        (r'\|u', error),
        (r'\|\|', insert_pipe),
        (r'\|r', restore),

        # shortcuts
        (r'\|R', push('shortcut-r')),
        (r'\|G', push('shortcut-g')),
        (r'\|Y', push('shortcut-y')),
        (r'\|LB', push('shortcut-lb')),
        (r'\|DB', push('shortcut-db')),
        (r'\|W', push('shortcut-w')),

        # thbviewer labels
        (r'\|!R', label('important')),
        (r'\|!G', label('success')),
        (r'\|!O', label('warning')),
        (r'\|!B', label('info')),
    ])

    toks, reminder = scanner.scan(text)
    if reminder:
        instext(None, reminder)

    return u''.join(result)


def conv_card_category(t):
    return tuple([_card_category[i] for i in t])

_card_category = {
    'basic': u'基本牌',
    'spellcard': u'符卡',
    'delayed_spellcard': u'延时符卡',
    'instant_spellcard': u'非延时符卡',
    'equipment': u'装备',
    'weapon': u'武器',
    'shield': u'防具',
    'redufo': u'红色UFO',
    'greenufo': u'绿色UFO',
    'accessories': u'饰品',
}


result = {
    'Cards': [],
    'Characters': [],
    'Modes': [],
}

#  --- Cards ---
excludes = [
    cards.HiddenCard,
    cards.DummyCard,
]


def snstring(suit, num):
    num = ' A23456789_JQK'[num]
    if num == '_': num = '10'
    return ftstring[suit] + num

ftstring = {
    cards.Card.SPADE: u'♠',
    cards.Card.HEART: u'♡',
    cards.Card.CLUB: u'♣',
    cards.Card.DIAMOND: u'♢',
}


def find_cards(cardcls):
    lst = [(n, s) for (cls, s, n) in cards.card_definition if cls is cardcls]
    lst.sort()
    return [snstring(s, n) for n, s in lst]


for k, v in metadata.iteritems():
    if not issubclass(k, cards.Card): continue
    if issubclass(k, cards.VirtualCard): continue
    if k in excludes: continue
    result['Cards'].append({
        "token": k.__name__,
        "image": "{}.png".format(v['image']),
        "name": v['name'],
        "categories": conv_card_category(k.category),
        "description": to_html(v['description']),
        "fulltextindex": unidecode(v['description']).replace(' ', '').lower(),
        "deck": find_cards(k),
    })


#  --- Characters ---
excludes = [
    characters.dummy.Dummy,
    characters.remilia_ex.RemiliaEx2,
    characters.akari.Akari,
]

for k, v in metadata.iteritems():
    if not issubclass(k, characters.baseclasses.Character): continue
    if k in excludes: continue
    result['Characters'].append({
        "token": k.__name__,
        "image": "{}.png".format(v['port_image']),
        "name": v['char_name'],
        "maxlife": k.maxlife,
        "description": to_html(v['description']),
        "fulltextindex": unidecode(v['description']).replace(' ', '').lower(),
        "positions": ("暂缺",),
    })


#  --- Modes ---
for k, v in metadata.iteritems():
    if not issubclass(k, Game): continue
    result['Modes'].append({
        "token": k.__name__,
        "image": "{}.png".format(v['logo']),
        "name": v['name'],
        "description": to_html(v.get('description', u'暂缺')),
    })


#  --- Save result ---
with open('/dev/shm/thbviewer.json', 'w') as f:
    f.write(json.dumps(result))

########NEW FILE########
__FILENAME__ = dummy_player
#!/usr/bin/python2
# -*- coding: utf-8 -*-

import gevent
from gevent import socket
from simplejson import dumps

names = ['Reimu', 'Marisa', 'Sakuya', 'Youmu', 'Sanae', 'Yuyuko', 'Alice', 'Patchouli']
import itertools
names = itertools.cycle(names)

import sys

types = {
    '3v3': 'THBattle',
    'id5': 'THBattleIdentity5',
    'id8': 'THBattleIdentity',
    'kof': 'THBattleKOF',
    'raid': 'THBattleRaid',
    'faith': 'THBattleFaith',
}

argv = sys.argv[1:]
t = argv.pop(0)
n = int(argv.pop(0))
N = int(argv.pop(0)) if argv else 1

t = types[t]
no_create = n < 0
n = abs(n)

en = lambda d: dumps(d) + '\n'

l = []


def create():
    s = socket.socket()
    s.connect(('127.0.0.1', 9999))
    s.sendall(en(['auth', [names.next(), '']])); gevent.sleep(0.05)
    s.sendall(en(['create_game', [t, u'我们是机器人哈哈哈']])); gevent.sleep(0.05)
    s.sendall(en(['get_ready', None])); gevent.sleep(0.05)

    while s.recv(100): pass


def join():
    s = socket.socket()
    s.connect(('127.0.0.1', 9999))
    s.sendall(en(['auth', [names.next(), '']])); gevent.sleep(0.05)
    s.sendall(en(['quick_start_game', 'nyan'])); gevent.sleep(0.05)
    s.sendall(en(['get_ready', None])); gevent.sleep(0.05)

    while s.recv(100): pass


if not no_create:
    print 'create'
    for _ in xrange(int(N)):
        l.append(gevent.spawn(create))

    gevent.sleep(1.0)

print 'join'
for _ in xrange(int(N)):
    for i in xrange(n-(not no_create)):
        l.append(gevent.spawn(join))

print 'done'

# import signal
# signal.alarm(2)

for i in l:
    i.join()

########NEW FILE########
__FILENAME__ = encrypt
# -*- coding: utf-8 -*-

import hashlib
import argparse
from utils.crypto import aes_encrypt

parser = argparse.ArgumentParser('encrypt')
parser.add_argument('filename')
parser.add_argument('passphrase')
options = parser.parse_args()

fn = options.filename
if fn.endswith('.png'):
    fn = fn[:-4]

data = open(options.filename, 'rb').read()
key = hashlib.sha256(options.passphrase).digest()
hint = hashlib.sha256(key).digest().encode('base64')

enc = aes_encrypt(data, key)
open(fn + '_encrypted.bin', 'wb').write(enc)
open(fn + '.hint', 'wb').write(hint)

########NEW FILE########
__FILENAME__ = generate_font_shadow
#!/usr/bin/python
import math

from SimpleCV import *
import Image as PIL


def generate(filename, w, h):
    print filename
    data = open(filename).read()

    thin_file = open(filename + 'SHADOWTHIN', 'w')
    thick_file = open(filename + 'SHADOWTHICK', 'w')
    bloat_file = open(filename + 'BLOAT', 'w')

    linesize = int(math.ceil(w/8.0))
    charsize = linesize * h

    chars = [
        data[i*charsize:(i+1)*charsize]
        for i in xrange(len(data)/charsize)
    ]

    for char in chars:
        charimg = PIL.fromstring('1', (w, h), char)
        paste = PIL.new('1', (w+4, h+4))
        paste.paste(charimg, (2, 2))
        bloat_file.write(paste.tostring())

        img = Image(paste)
        img = img.convolve([
            [0, 1, 0],
            [1, 1, 1],
            [0, 1, 0],
        ])
        thin = PIL.fromstring('RGB', (w+4, h+4), img.toString()).convert('1').tostring()
        thin_file.write(thin)
        img = img.dilate()
        thick = PIL.fromstring('RGB', (w+4, h+4), img.toString()).convert('1').tostring()
        thick_file.write(thick)


generate('ASC12', 6, 12)
generate('ASC16', 8, 16)
generate('GBK12', 12, 12)
generate('GBK16', 16, 16)

########NEW FILE########
__FILENAME__ = gen_bdf
#!/usr/bin/python2
# -*- coding: utf-8 -*-
# Obsoleted, using custom pyglet.font.Font class to render
# Windows sucks.

from struct import unpack

class GBK(object):
    rols = 126
    cols = 191
    @staticmethod
    def to_unicode(rol, col):
        return (chr(rol+0x81) + chr(col+0x40)).decode('gbk')

    @classmethod
    def get_data(cls, rol, col):
        loc = rol * cls.cols + col
        loc *= cls.data_size
        return cls.data[loc:loc+cls.data_size]

class GBK12(GBK):
    filename = 'GBK12'
    with open(filename, 'rb') as f:
        data = buffer(f.read())
    data_size = 24
    box = (12, 12)

    @classmethod
    def format(cls, data):
        l = unpack('>' + 'H'*12, data)
        l = [hex(i+65536)[-4:] for i in l]
        s = '\n'.join(l)
        return s.upper()


class GBK16(GBK):
    filename = 'GBK16'
    with open(filename, 'rb') as f:
        data = buffer(f.read())
    data_size = 32
    box = (16, 16)
    @classmethod
    def format(cls, data):
        l = unpack('>' + 'H'*16, data)
        l = [hex(i+65536)[-4:] for i in l]
        s = '\n'.join(l)
        return s.upper()

class ASC(object):
    rols = 128
    cols = 1
    @staticmethod
    def to_unicode(rol, col):
        return chr(rol)

    @classmethod
    def get_data(cls, rol, col):
        loc = rol
        loc *= cls.data_size
        return cls.data[loc:loc+cls.data_size]

class ASC12(ASC):
    filename = 'ASC12'
    with open(filename, 'rb') as f:
        data = buffer(f.read())
    data_size = 12
    box = (6, 12)
    @staticmethod
    def format(data):
        return '\n'.join(
            hex(ord(i)+256)[-2:].upper()
            for i in data
        )

class ASC16(ASC12):
    filename = 'ASC16'
    with open(filename, 'rb') as f:
        data = buffer(f.read())
    data_size = 16
    box = (8, 16)

for T in (GBK12, GBK16, ASC12, ASC16):

    f = open(T.__name__ + '_DATA.bdf', 'w')

    template = '''STARTCHAR uni%%s
ENCODING %%d
SWIDTH 1000 0
DWIDTH %d 0
BBX %d %d 0 0
BITMAP
%%s
ENDCHAR
    ''' % (T.box[0], T.box[0], T.box[1])

    count = 0
    rst = ''
    for rol in xrange(T.rols):
        for col in xrange(T.cols):
            try:
                ucs = ord(T.to_unicode(rol, col))
                data = T.get_data(rol, col)
                s = template % (hex(ucs+65536)[-4:].upper(), ucs, T.format(data))
                rst+=s
                count += 1
            except UnicodeDecodeError:
                print 'ERR: %d %d' % (rol, col)

    sz = T.box[1]

    f.write('''STARTFONT 2.1
FONT -FontForge-Untitled1-Medium-R-Normal--%d-120-75-75-M-120-ISO10646-1
SIZE %d 75 75
FONTBOUNDINGBOX %d %d -1 -2
COMMENT "Generated by fontforge, http://fontforge.sourceforge.net"
COMMENT "Created by Proton,,, with FontForge 2.0 (http://fontforge.sf.net)"
STARTPROPERTIES 27
FOUNDRY "FontForge"
FAMILY_NAME "Untitled1"
WEIGHT_NAME "Medium"
SLANT "R"
SETWIDTH_NAME "Normal"
ADD_STYLE_NAME ""
PIXEL_SIZE %d
POINT_SIZE 120
RESOLUTION_X 75
RESOLUTION_Y 75
SPACING "M"
AVERAGE_WIDTH 120
CHARSET_REGISTRY "ISO10646"
CHARSET_ENCODING "1"
FONTNAME_REGISTRY ""
CHARSET_COLLECTIONS "ISO10646-1"
FONT_NAME "Untitled1"
FACE_NAME "Untitled1"
FONT_VERSION "001.000"
FONT_ASCENT %d
FONT_DESCENT 0
UNDERLINE_POSITION -1
UNDERLINE_THICKNESS 1
RAW_ASCENT 1000
RAW_DESCENT 0
FIGURE_WIDTH -1
AVG_UPPERCASE_WIDTH 120
ENDPROPERTIES
''' % (sz, sz, sz, sz, sz, sz))

    f.write('CHARS %d\n' % count)
    f.write(rst)
    f.write('ENDFONT\n')

########NEW FILE########
__FILENAME__ = layouter
# -*- coding: utf-8 -*-
import sys
from pyglet.window import key
from pyglet.text import Label as RawLabel

sys.path.append('../src')

import pyglet
from pyglet.gl import *

from client.ui.base import *
from client.ui.controls import *

class Layouter(Control):
    def __init__(self, *args, **kwargs):
        Control.__init__(self, can_focus=False, *args, **kwargs)
        self.set_focus()
        self.index = 0
        class Dummy(object):
            def draw(self): pass
            x = 0
            y = 0
            width = 0
            height = 0
        self.add_control(Dummy())
        self.flash = False
        self.width = WINDOW_WIDTH
        self.height = WINDOW_HEIGHT
        self.x = 0
        self.y = 0
        self.scale = 1
        self.set_capture('on_mouse_drag')
        self.set_capture('on_key_press')
        self.set_capture('on_text_motion')

        def flashing(dt):
            self.flash = not self.flash
        pyglet.clock.schedule_interval(flashing, 0.4)

    def on_key_press(self, symbol, modifier):
        _ = lambda b: modifier & b == b
        if symbol == key.TAB:
            if _(key.MOD_SHIFT):
                self.index += 1
            else:
                self.index -= 1
            l = len(self.control_list)
            self.index = (self.index + l*100) % l
        elif symbol == key.SPACE:
            self.scale = 1 if self.scale != 1 else 10

    def on_text_motion(self, motion):
        dir = {
            key.MOTION_UP: (0, 1),
            key.MOTION_DOWN: (0, -1),
            key.MOTION_LEFT: (-1, 0),
            key.MOTION_RIGHT: (1, 0),
        }
        c = self.control_list[self.index]
        dd = dir.get(motion)
        if dd:
            c.x = c.x + dd[0] * self.scale
            c.y = c.y + dd[1] * self.scale

    def draw_hook_before(self):
        pass

    def draw_hook_after(self):
        pass

    def draw(self):
        self.draw_hook_before()
        l = len(self.control_list)
        index = (self.index + l*100) % len(self.control_list)
        for i, c in enumerate(self.control_list):
            glPushMatrix()
            glTranslatef(c.x, c.y, 0)
            '''
            if i == index and self.flash:
                glColor3f(0.3, 0.3, 0.3)
                glRecti(0, 0, c.width, c.height)
            else:
                c._do_draw(dt)
            '''
            c.draw()
            if i == index and self.flash:
                glEnable(GL_COLOR_LOGIC_OP)
                glLogicOp(GL_INVERT)
                glRecti(0, 0, c.width, c.height)
                glDisable(GL_COLOR_LOGIC_OP)

            glPopMatrix()
        self.draw_hook_after()

    def on_mouse_drag(self, x, y, dx, dy, button, modifier):
        _ = lambda b: modifier & b == b
        if _(key.MOD_SHIFT | key.MOD_CTRL):
            c = self.control_list[self.index]
            c.width += dx
            c.height -= dy
            c.y += dy
        elif _(key.MOD_SHIFT):
            c = self.control_list[self.index]
            c.x += dx
            c.y += dy


    def on_mouse_press(self, x, y, button, modifier):
        _ = lambda b: modifier & b == b
        if _(key.MOD_SHIFT):
            try:
                c = self.control_frompoint1(x, y)
                self.index = self.control_list.index(c)
            except:
                self.index = 0

class Label(Control):
    def __init__(self, text=u'Label',
                font_size=30, color=(0,0,0,255),
                x=0, y=0, bold=False, italic=False, *a, **k):
        self.rawlabel = RawLabel(
            text=text, font_size=font_size,
            color=color,x=0,y=0,
            anchor_x='left', anchor_y='bottom',
            bold=bold, italic=italic
        )
        w, h = self.rawlabel.content_width, self.rawlabel.content_height
        Control.__init__(self, x=x, y=y, width=w, height=h, *a, **k)

    def draw(self):
        self.rawlabel.draw()

class Rectangle(Control):
    def draw(self):
        glPushAttrib(GL_POLYGON_BIT)
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)
        glColor3f(0,0,0)
        glRecti(0,0,self.width,self.height)
        glPopAttrib()

init_gui()
layout = Layouter(parent=Overlay.cur_overlay)
_base = None
#----------------

img = pyglet.image.load('/home/proton/Desktop/capture/snap00031.png')
#img = pyglet.image.load('/dev/shm/1.png')
from game import autoenv
autoenv.init('Client')
from client.ui import resource as cres
from gamepack.thb.ui.game_controls import *
from gamepack.thb.ui import resource as gres
from utils import BatchList

def bg():
    glColor4f(1,1,1,1)
    img.blit(0,0)

layout.draw_hook_before = bg

from gamepack.thb.cards import *

c = AttackCard(1, 1)

cs = CardSprite(c, parent=layout)

cs.init_ballon_text('|Ghahahah!|r\n\nasdfasdfasdfasdfasdfa\nsdfasdfasdfasdf')


#------------------
pyglet.app.run()
if _base:
    ox, oy = _base.x, _base.y
    print 'Base: x=%d, y=%d' % (ox, oy)
else:   ox, oy = 0, 0

for i, c in enumerate(layout.control_list[1:]):
    print ("#%d(%s) ==> x=%d, y=%d, width=%d, height=%d" %
        (i, c.__class__.__name__, c.x - ox, c.y - oy, c.width, c.height))

########NEW FILE########
__FILENAME__ = mif2png
# -*- coding: utf-8 -*-
# Convert QQYXS's mif animation to png & desc file

import sys

try:
    fn = sys.argv[1]
except IndexError:
    print 'Usage: mif2png.py <filename>'
    sys.exit(1)

print 'Converting %s' % fn

import Image, ImageDraw, os
from struct import unpack

f = open(fn, 'rb')

FRAME_ANIM = 7
FRAME_SINGLE = 3

_, frame_width, frame_height, frame_type, frame_count = \
    unpack('IIIII', f.read(4*5))

img_size = frame_width * frame_height

img = Image.new('RGBA', (frame_width*frame_count, frame_height))

def parse565a(i, a):
    r = ((0xF800 & i) >> 11) << 3
    g = ((0x07E0 & i) >> 5) << 2
    b = ((0x001F & i) >> 0) << 3
    return (r,g,b,min(a<<3, 255))

def convert(imgdata, alpha, sz):
    #sz = len(alpha)
    imgdata = unpack('H'*sz, imgdata)
    alpha = unpack('B'*sz, alpha)
    pixels = [parse565a(i, a) for i, a in zip(imgdata, alpha)]
    return pixels

atlist = []
for i in xrange(frame_count):
    if frame_type == FRAME_ANIM:
        animtime, = unpack('I', f.read(4))
        atlist.append(animtime)
    elif frame_type == FRAME_SINGLE:
        assert frame_count == 1
    imgdata = f.read(img_size*2)
    alpha = f.read(img_size)
    pixels = convert(imgdata, alpha, img_size)
    p = 0
    for y in xrange(frame_height):
        for x in xrange(i*frame_width, (i+1)*frame_width):
            img.putpixel((x, y), pixels[p])
            p += 1

img.save('%s.png' % fn)
open('%s.desc.py' % fn, 'w').write(
    '%s_animtime = %s' % (os.path.basename(fn), repr(atlist))
)

########NEW FILE########
__FILENAME__ = polygoncoord
import pyglet
from pyglet.gl import *

w = pyglet.window.Window(width=1024, height=720)
glMatrixMode(GL_PROJECTION)
glLoadIdentity()
glViewport(0, 0, 1024, 720)
glOrtho(0, 1024, 0, 720, -1000, 1000)
glMatrixMode(GL_MODELVIEW)
glClearColor(1, 1, 1, 1)
glEnable(GL_BLEND)
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
glPolygonMode(GL_BACK, GL_LINE)
img = pyglet.image.load('../src/client/ui/res/worldmap.png')
tex = img.get_texture()

coords = []


@w.event
def on_draw():
    glColor3f(1, 1, 1)
    glPolygonMode(GL_FRONT, GL_FILL)
    tex.blit(0, 0)
    glPolygonMode(GL_FRONT, GL_LINE)
    glBegin(GL_POLYGON)
    for x, y in coords:
        glVertex2f(x, y)
    glEnd()


@w.event
def on_mouse_press(x, y, button, modifiers):
    coords.append((x, y))


pyglet.app.run()
print coords

########NEW FILE########
__FILENAME__ = replay

#!/usr/bbin/python2
# -*- coding: utf-8 -*-

import sys
sys.path.append('../src')

import simplejson as json

from utils import hook, BatchList

import gzip
from game import autoenv
autoenv.init('Client')
# autoenv.init('Server')
from account.freeplay import Account
from game.autoenv import Game
from client.core import PeerPlayer, TheLittleBrother
Game.CLIENT_SIDE = 'blah'  # Hack: not loading ui resource
from gamepack import gamemodes

from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument('replay_file', type=str)
parser.add_argument('location', type=int)
parser.add_argument('--catch', action='store_true', default=False)
parser.add_argument('--log', type=str, default='DEBUG')
parser.add_argument('--break-at', type=int, default=0)
parser.add_argument('--print-synctag', action='store_true', default=False)
parser.add_argument('--action-singlestep', default=0)
options = parser.parse_args()

import logging
logging.basicConfig(stream=sys.stdout)
logging.getLogger().setLevel(getattr(logging, options.log.upper()))
log = logging.getLogger('Replay')


class MockExecutive(object):
    def __init__(self, server):
        self.server = server
        self.account = Account.authenticate('Proton', '123')


class MockServer(object):
    def __init__(self, gdlist):
        self.gdlist = gdlist

    def gexpect(self, tag):
        log.info('GAME_EXPECT: %s', repr(tag))
        if not self.gdlist:
            log.info('Game data exhausted, exiting...')
            if options.catch:
                import pdb; pdb.set_trace()
            sys.exit(0)

        glob = False
        if tag.endswith('*'):
            tag = tag[:-1]
            glob = True

        missed = False
        for i, d in enumerate(self.gdlist):
            if d[0] == tag or (glob and d[0].startswith(tag)):
                log.info('GAME_READ: %s', repr(d))
                del self.gdlist[i]
                return d
            if not missed:
                log.info('GAME_DATA_MISS: %s', repr(d))
                missed = True

        log.info('GAME_DATA_MISS!!')
        log.info('Remaining game data:')
        for i in self.gdlist:
            log.info(repr(i))

        sys.exit(1)

    def gwrite(self, tag, data):
        log.debug('GAME_WRITE: %s', repr([tag, data]))

    def gclear(self):
        pass


if options.replay_file.endswith('.gz'):
    data = gzip.open(options.replay_file, 'r').read()
else:
    data = open(options.replay_file, 'r').read()

data = data.split('\n')

while True:
    last = data.pop(0)
    if not last.startswith('#'):
        break
    print last

mode = last
data.pop(0)  # seed
data.pop(0)  # server data

loc = options.location
gdlist = json.loads(data.pop(0))[loc]

server = MockServer(gdlist)
Executive = MockExecutive(server)

from client.core import game_client
game_client.Executive = Executive  # Hack

GameMode = gamemodes[mode]

players = [PeerPlayer() for i in xrange(GameMode.n_persons)]
players[loc].__class__ = TheLittleBrother
players[loc].server = server

for p in players:
    p.account = Account.authenticate('Proton', '123')

g = GameMode()
g.players = BatchList(players)
g.me = players[loc]
g.replay_file = options.replay_file


@hook(g)
def pause(*a):
    pass


@hook(g)
def get_synctag(ori):
    tag = ori()
    if options.print_synctag:
        print '----- %d -----' % tag

    if options.break_at and tag == options.break_at:
        if options.catch:
            import pdb; pdb.set_trace()
        else:
            raise Exception('break!')

    return tag


@hook(g)
def process_action(ori, act):
    ass = options.action_singlestep
    if ass and ass >= g.synctag:
        print g.action_stack
        raw_input()

    return ori(act)

try:
    g._run()
except Exception as e:
    if not isinstance(e, SystemExit) and options.catch:
        import pdb; pdb.post_mortem()

    raise

########NEW FILE########
__FILENAME__ = replay_server

#!/usr/bbin/python2
# -*- coding: utf-8 -*-

# -- stdlib --
import sys
sys.path.append('../src')
import random
import gzip

import logging
logging.basicConfig(stream=sys.stdout)
logging.getLogger().setLevel(logging.DEBUG)
log = logging.getLogger('ReplayServer')

from argparse import ArgumentParser

# -- third party --
import gevent
from gevent.queue import Queue
from gevent.event import Event
import simplejson as json

# -- own --
from game import autoenv
autoenv.init('Server')

from server.core import Player
from network import EndpointDied
from network.common import GamedataMixin
from account.freeplay import Account
from utils import BatchList


# -- code --
parser = ArgumentParser()
parser.add_argument('replay_file', type=str)
parser.add_argument('--catch', action='store_true')

options = parser.parse_args()


def ask_for_feed(player_index, tag):
    if not gdlist:
        log.warning('Game data exhausted.')
        if options.catch:
            import pdb; pdb.set_trace()

        sys.exit(0)

    data = gdlist[0]
    if tuple(data[:2]) == (player_index, tag):
        gdlist.pop(0)
        return data[1:]

    return None, GamedataMixin.NODATA

gdlist = []


class MockClient(object):
    def __init__(self, player_index):
        self.player_index = player_index
        self.account = Account.authenticate('Proton', '123')
        self.observers = []
        self._channel = Queue(0)
        e = Event()
        e.set()
        self.gdevent = e

    def gexpect(self, tag, blocking=True):
        assert not blocking
        data = ask_for_feed(self.player_index, tag)
        if data is EndpointDied:
            raise EndpointDied
        log.info('GAME_EXPECT[%d]: %s, return %s', self.player_index, repr(tag), repr(data))
        return data

    def gwrite(self, tag, data):
        log.debug('GAME_WRITE[%d]: %s', self.player_index, repr([tag, data]))

    def write(self, data):
        pass

    def gclear(self):
        pass

if options.replay_file.endswith('.gz'):
    data = gzip.open(options.replay_file, 'r').read().split('\n')
else:
    data = open(options.replay_file, 'r').read().split('\n')

while data[0].startswith('#'):
    print data.pop(0)

mode = data.pop(0)
rndseed = long(data.pop(0))

gdlist = json.loads(data.pop(0))

from gamepack import gamemodes

mode = gamemodes[mode]

clients = [MockClient(i) for i in xrange(mode.n_persons)]
players = BatchList([Player(i) for i in clients])

g = mode()
g.players = players
g.rndseed = rndseed
g.random = random.Random(rndseed)
gevent.getcurrent().game = g
g._run()

########NEW FILE########
__FILENAME__ = write_meta
#!/usr/bin/python2
# -*- coding: utf-8 -*-

import sys
sys.path.append('../src')

import autoupdate
autoupdate.write_metadata('.')

########NEW FILE########
