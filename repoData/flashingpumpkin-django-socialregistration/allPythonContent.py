__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-socialregistration documentation build configuration file, created by
# sphinx-quickstart on Wed Feb 22 17:25:59 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os, socialregistration

os.environ['DJANGO_SETTINGS_MODULE'] = 'example.settings'

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-socialregistration'
copyright = u'2012, Alen Mujezinovic'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.5.1'
# The full version, including alpha/beta/rc tags.
release = '0.5.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-socialregistrationdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('fooasdf', 'django-socialregistration.tex', u'django-socialregistration Documentation',
   u'Alen Mujezinovic', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('fooasdf', 'django-socialregistration', u'django-socialregistration Documentation',
     [u'Alen Mujezinovic'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('fooasdf', 'django-socialregistration', u'django-socialregistration Documentation',
   u'Alen Mujezinovic', 'django-socialregistration', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "tests.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = auth
from django.contrib.auth.models import User
from socialregistration.contrib.facebook.auth import FacebookAuth
from socialregistration.contrib.linkedin.auth import LinkedInAuth
from socialregistration.contrib.openid.auth import OpenIDAuth
from socialregistration.contrib.twitter.auth import TwitterAuth

import warnings

warnings.warn("`socialregistration.auth.*` will be removed. "
    "Use `socialregistration.contrib.*.auth.*` instead.")

########NEW FILE########
__FILENAME__ = oauth
from django.utils.encoding import smart_unicode
from django.utils.translation import ugettext_lazy as _
from socialregistration.clients import Client

from django.conf import settings

import httplib2
import socket
import logging
import oauth2 as oauth
import urllib
import urlparse

logger = logging.getLogger(__name__)

TIMEOUT = getattr(settings, 'SOCIALREGISTRATION_SOCKET_TIMEOUT', 5)

class OAuthError(Exception):
    """ 
    Exception thrown when we run into OAuth{1,2} errors. This error is 
    displayed to the end user in the default templates. 
    """
    pass

class OAuth(Client):
    """
    Base class for OAuth1 services such as Twitter, LinkedIn and Tumblr. 
    """
    
    # The API key provided by the service 
    api_key = None
    
    # The secret key provided by the service 
    secret_key = None
    
    # The authorization / authentication URL we'll be asking the user for
    # permissions at
    auth_url = None
    
    # The request token URL we'll be fetching the request token from
    request_token_url = None
    
    # The access token URL we'll be fetching the access token from
    access_token_url = None
    
    # Memoized request token
    _request_token = None
    
    # Memoized access token
    _access_token = None
    
    # Memoized dict of whole access token response
    _access_token_dict = None
    
    # Memoized user information 
    _user_info = None
    
    def __init__(self, access_token=None, access_token_secret=None):
        self.consumer = oauth.Consumer(self.api_key, self.secret_key)
        
        if access_token and access_token_secret:
            self._access_token = oauth.Token(access_token, access_token_secret)
        
    def client(self, verifier=None):
        """
        Return the correct client depending on which stage of the OAuth process
        we're in.
        """
        # We're just starting out and don't have neither request nor access
        # token. Return the standard client
        if not self._request_token and not self._access_token:
            client = oauth.Client(self.consumer, timeout=TIMEOUT)
        
        # We're one step in, we've got the request token and can add that to 
        # the client.
        if self._request_token and not self._access_token:
            if verifier is not None:
                self._request_token.set_verifier(verifier)
            client = oauth.Client(self.consumer, self._request_token, timeout=TIMEOUT)
            
        # Two steps in, we've got an access token and can now properly sign 
        # our client requests with it.
        if self._access_token:
            client = oauth.Client(self.consumer, self._access_token, timeout=TIMEOUT)
        
        return client

    def _get_request_token(self):
        """
        Fetch a request token from `self.request_token_url`.
        """
        
        params = {
            'oauth_callback': self.get_callback_url()
        }
        
        
        response, content = self.client().request(self.request_token_url,
            "POST", body=urllib.urlencode(params))
        
        content = smart_unicode(content)

        if not response['status'] == '200':
            raise OAuthError(_(
                u"Invalid status code %s while obtaining request token from %s: %s") % (
                    response['status'], self.request_token_url, content))
        
        token = dict(urlparse.parse_qsl(content))
        
        return oauth.Token(token['oauth_token'], token['oauth_token_secret'])
    
    def _get_access_token(self, verifier=None):
        """
        Fetch an access token from `self.access_token_url`.
        """
        
        response, content = self.client(verifier).request(
            self.access_token_url, "POST")
        
        content = smart_unicode(content)

        if not response['status'] == '200':
            raise OAuthError(_(
                u"Invalid status code %s while obtaining access token from %s: %s") % 
                (response['status'], self.access_token_url, content))
        
        token = dict(urlparse.parse_qsl(content))
        
        
        return (oauth.Token(token['oauth_token'], token['oauth_token_secret']),
            token)
        
    def get_request_token(self):
        """
        Return the request token for this API. If we've not fetched it yet,
        go out, request and memoize it.
        """
        
        if self._request_token is None:
            self._request_token = self._get_request_token()
        return self._request_token
    
    def get_access_token(self, verifier=None):
        """
        Return the access token for this API. If we've not fetched it yet,
        go out, request and memoize it.
        """
        
        if self._access_token is None:
            self._access_token, self._access_token_dict = self._get_access_token(verifier)
        return self._access_token
    
    
    def get_redirect_url(self, **kwargs):
        """
        Return the authorization/authentication URL signed with the request 
        token.
        """
        params = {
            'oauth_token': self.get_request_token().key,
        }
        return '%s?%s' % (self.auth_url, urllib.urlencode(params))
    
    def complete(self, GET):
        """
        When redirect back to our application, try to complete the flow by
        requesting an access token. If the access token request fails, it'll
        throw an `OAuthError`.
        
        Tries to complete the flow by validating against the `GET` paramters 
        received.
        """
        token = self.get_access_token(verifier=GET.get('oauth_verifier', None))
        return token
    
    def request(self, url, method="GET", params=None, headers=None):
        """
        Make signed requests against `url`.
        """
        params = params or {}
        headers = headers or {}

        logger.debug("URL: %s", url)
        logger.debug("Method: %s", method)
        logger.debug("Headers: %s", headers)
        logger.debug("Params: %s", params)
        
        response, content = self.client().request(url, method, headers=headers,
            body=urllib.urlencode(params))
        
        content = smart_unicode(content)

        logger.debug("Status: %s", response['status'])
        logger.debug("Content: %s", content)
        
        if response['status'] != '200':
            raise OAuthError(_(
                u"Invalid status code %s while requesting %s: %s") % (
                    response['status'], url, content))
        
        return content
    
    
class OAuth2(Client):
    """
    Base class for OAuth2 services such as Facebook, Github and Foursquare.
    """
    
    # The client id provided by the service
    client_id = None
     
    # The secret id provided by the service 
    secret = None
    
    # The URL where we'll be requesting permissions from the user
    auth_url = None
    
    # The URL where we'll be obtaining an access token once permissions were
    # granted
    access_token_url = None
    
    # The permission's we'll be asking for
    scope = None
    
    # The access token we obtained
    _access_token = None
    
    # The dict holding all infos we got from the access token endpoint
    access_token_dict = None
    
    # Memoized user info fetched once an access token was obtained
    _user_info = None
    
    def __init__(self, access_token=None):
        self._access_token = access_token
    
    def client(self):
        ca_certs = getattr(settings, 'HTTPLIB2_CA_CERTS', None)
        return httplib2.Http(ca_certs=ca_certs, timeout=TIMEOUT)
    
    def get_redirect_url(self, state='', **kwargs):
        """
        Assemble the URL to where we'll be redirecting the user to to request
        permissions.
        """
        params = {
            'response_type': 'code',
            'client_id': self.client_id,
            'redirect_uri': self.get_callback_url(**kwargs),
            'scope': self.scope or '',
            'state': state,
        }
        
        return '%s?%s' % (self.auth_url, urllib.urlencode(params))
    
    def parse_access_token(self, content):
        """
        Parse the access token response. The default OAuth response should be
        a query string - but some services return JSON instead. 
        """
        return dict(urlparse.parse_qsl(content))

    def request_access_token(self, params):
        """
        Request the access token from `self.access_token_url`. The default 
        behaviour is to use a `POST` request, but some services use `GET` 
        requests. Individual clients can override this method to use the 
        correct HTTP method.
        """
        return self.request(self.access_token_url, method="POST", params=params,
            is_signed=False)
    
    def _get_access_token(self, code, **params):
        """
        Fetch an access token with the provided `code`.
        """
        params.update({
            'code': code,
            'client_id': self.client_id,
            'client_secret': self.secret,
            'redirect_uri': self.get_callback_url(),
        })

        logger.debug("Params: %s", params)

        resp, content = self.request_access_token(params=params)

        content = smart_unicode(content)

        logger.debug("Status: %s", resp['status'])
        logger.debug("Content: %s", content)
        
        content = self.parse_access_token(content)
        
        if 'error' in content:
            raise OAuthError(_(
                u"Received error while obtaining access token from %s: %s") % (
                    self.access_token_url, content['error']))

        return content
    
    def get_access_token(self, code=None, **params):
        """
        Return the memoized access token or go out and fetch one.
        """
        if self._access_token is None:
            if code is None:
                raise ValueError(_('Invalid code.'))
            
            self.access_token_dict = self._get_access_token(code, **params)
            try:
                self._access_token = self.access_token_dict['access_token']
            except KeyError, e:
                raise OAuthError("Credentials could not be validated, the provider returned no access token.")
                
        return self._access_token
    
    def complete(self, GET):
        """
        Complete the OAuth2 flow by fetching an access token with the provided
        code in the GET parameters.
        """
        if 'error' in GET:
            raise OAuthError(
                _("Received error while obtaining access token from %s: %s") % (
                    self.access_token_url, GET['error']))
        return self.get_access_token(code=GET.get('code'))        

    def get_signing_params(self):
        """
        Return the paramters for signing a request. Some APIs don't 
        obey the standard `access_token` parameter - they can override this 
        method and return their used parameters.
        """
        return dict(access_token=self._access_token)
        
    def request(self, url, method="GET", params=None, headers=None, is_signed=True):
        """
        Make a request against ``url``. By default, the request is signed with
        an access token, but can be turned off by passing ``is_signed=False``.
        """
        params = params or {}
        headers = headers or {}
        
        if is_signed:
            params.update(self.get_signing_params())
        
        if method.upper() == "GET":
            url = '%s?%s' % (url, urllib.urlencode(params))
            return self.client().request(url, method=method, headers=headers)
        return self.client().request(url, method, body=urllib.urlencode(params), headers=headers)
        


########NEW FILE########
__FILENAME__ = urls
try:
    from django.conf.urls import patterns, url, include
except ImportError: # django 1.3
    from django.conf.urls.defaults import patterns, url, include

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from socialregistration.contrib.facebook.models import FacebookProfile

admin.site.register(FacebookProfile)

########NEW FILE########
__FILENAME__ = auth
from django.contrib.auth.backends import ModelBackend
from django.contrib.sites.models import Site
from socialregistration.contrib.facebook.models import FacebookProfile


class FacebookAuth(ModelBackend):
    supports_object_permissions = False
    supports_anonymous_user = False
    
    def authenticate(self, uid = None):
        try:
            return FacebookProfile.objects.get(
                uid = uid,
                site = Site.objects.get_current()).user
        except FacebookProfile.DoesNotExist:
            return None

########NEW FILE########
__FILENAME__ = client
from django.conf import settings
from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse
from socialregistration.clients.oauth import OAuth2
from socialregistration.settings import SESSION_KEY
import json
import facebook

class Facebook(OAuth2):
    client_id = getattr(settings, 'FACEBOOK_APP_ID', '')
    secret = getattr(settings, 'FACEBOOK_SECRET_KEY', '')
    scope = getattr(settings, 'FACEBOOK_REQUEST_PERMISSIONS', '')
    
    auth_url = 'https://www.facebook.com/dialog/oauth'
    access_token_url = 'https://graph.facebook.com/oauth/access_token'
    
    graph = None
    _user_info = None
    
    
    def get_callback_url(self, **kwargs):
        if self.is_https():
            return 'https://%s%s' % (Site.objects.get_current().domain,
                reverse('socialregistration:facebook:callback'))
        return 'http://%s%s' % (Site.objects.get_current().domain,
            reverse('socialregistration:facebook:callback'))
        
    def get_user_info(self):
        if self._user_info is None:
            self.graph = facebook.GraphAPI(self._access_token)
            self._user_info = self.graph.request('me')
        return self._user_info
    
    @staticmethod
    def get_session_key():
        return '%sfacebook' % SESSION_KEY

########NEW FILE########
__FILENAME__ = middleware
from django.utils.functional import SimpleLazyObject
from socialregistration.contrib.facebook.models import FacebookAccessToken, \
    FacebookProfile
import facebook

def get_uid(user):
    try:
        return FacebookProfile.objects.get(user = user).uid
    except FacebookProfile.DoesNotExist:
        return ''

def get_access_token(user):
    try:
        return FacebookAccessToken.objects.get(profile__user = user).access_token
    except FacebookAccessToken.DoesNotExist:
        return ''
    
def get_graph(user):
    def wrapped(self):
        if not self.access_token:
            return None
        return facebook.GraphAPI(self.access_token)
    return wrapped

def get_facebook_object(user):
    def wrapped():
        return type('Facebook', (object,), {'uid': get_uid(user), 
            'access_token': get_access_token(user), 'get_graph': get_graph(user)})()    
    return wrapped

class FacebookMiddleware(object):
    def process_request(self, request):
        """
        Enables ``request.facebook`` in your views for authenticated users.
        It's a lazy object that does database lookups.
        """
        
        request.facebook = SimpleLazyObject(get_facebook_object(request.user))
        
        return None
########NEW FILE########
__FILENAME__ = models
from django.conf import settings
from django.contrib.auth import authenticate
from django.contrib.sites.models import Site
from django.db import models
from socialregistration.signals import connect, login

AUTH_USER_MODEL = getattr(settings, 'AUTH_USER_MODEL', 'auth.User')

class FacebookProfile(models.Model):
    user = models.ForeignKey(AUTH_USER_MODEL, unique=True)
    site = models.ForeignKey(Site, default=Site.objects.get_current)
    uid = models.CharField(max_length=255, blank=False, null=False)

    def __unicode__(self):
        try:
            return u'%s: %s' % (self.user, self.uid)
        except models.ObjectDoesNotExist:
            return u'None'

    def authenticate(self):
        return authenticate(uid=self.uid)

class FacebookAccessToken(models.Model):
    profile = models.OneToOneField(FacebookProfile, related_name='access_token')
    access_token = models.CharField(max_length=255)


def save_facebook_token(sender, user, profile, client, **kwargs):
    try:
        FacebookAccessToken.objects.get(profile=profile).delete()
    except FacebookAccessToken.DoesNotExist:
        pass

    FacebookAccessToken.objects.create(profile=profile,
        access_token=client.graph.access_token)

connect.connect(save_facebook_token, sender=FacebookProfile,
    dispatch_uid='socialregistration.facebook.connect')
login.connect(save_facebook_token, sender = FacebookProfile,
    dispatch_uid = 'socialregistration.facebook.login')

########NEW FILE########
__FILENAME__ = facebook
from django import template

from socialregistration.templatetags import button

register = template.Library()

register.tag('facebook_button', button('socialregistration/facebook/facebook_button.html'))
########NEW FILE########
__FILENAME__ = facebook_tags
import warnings 

warnings.warn("{% load facebook_tags %} will be removed. Use {% load facebook %} instead")

from facebook import *
########NEW FILE########
__FILENAME__ = tests
from django.conf import settings
from django.core.urlresolvers import reverse
from django.test import TestCase
from socialregistration.contrib.facebook.models import FacebookProfile
from socialregistration.tests import TemplateTagTest, OAuth2Test, get_mock_func
import json
import mock
import urllib

class TestTemplateTag(TemplateTagTest, TestCase):
    def get_tag(self):
        return 'facebook', 'facebook_button'

class TestFacebook(OAuth2Test, TestCase):
    profile = FacebookProfile

    def get_redirect_url(self):
        return reverse('socialregistration:facebook:redirect')
    
    def get_callback_url(self):
        return reverse('socialregistration:facebook:callback')

    def get_setup_callback_url(self):
        return reverse('socialregistration:facebook:setup')
    
    def get_callback_mock_response(self, *args, **kwargs):
        return {'status': '200'}, urllib.urlencode({
            'access_token': '456'})
    
    def get_setup_callback_mock_response(self, *args, **kwargs):
        return {'status': '200'}, json.dumps({'id': '123'})
    
    def create_profile(self, user):
        FacebookProfile.objects.create(user=user, uid='123')

    def get_facebook_data(self, *args, **kwargs):
        return {'id': '123'}
    
    @mock.patch('socialregistration.clients.oauth.OAuth2.request')
    @mock.patch('facebook.GraphAPI.request')
    def callback(self, MockFacebook, MockRequest):
        MockRequest.side_effect = get_mock_func(self.get_callback_mock_response)
        MockFacebook.side_effect = get_mock_func(self.get_facebook_data)
        response = self.client.get(self.get_callback_url(), {'code': 'abc'})
        return response
    
    @mock.patch('socialregistration.clients.oauth.OAuth2.request')
    @mock.patch('facebook.GraphAPI.request')
    def setup_callback(self, MockFacebook, MockRequest):
        MockRequest.side_effect = get_mock_func(self.get_setup_callback_mock_response)
        MockFacebook.side_effect = get_mock_func(self.get_facebook_data)
        response = self.client.get(self.get_setup_callback_url())
        return response

class TestAuthenticationBackend(TestCase):
    def test_authentication_backend_should_be_configured_in_settings(self):
        self.assertTrue('socialregistration.contrib.facebook.auth.FacebookAuth' in settings.AUTHENTICATION_BACKENDS)

########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from socialregistration.compat.urls import *
from socialregistration.contrib.facebook.views import FacebookSetup, \
    FacebookRedirect, FacebookCallback
 
urlpatterns = patterns('',
    url('^redirect/$', FacebookRedirect.as_view(), name='redirect'),
    url('^callback/$', FacebookCallback.as_view(), name='callback'),
    url('^setup/$', FacebookSetup.as_view(), name='setup'),
)

########NEW FILE########
__FILENAME__ = views
from django.core.urlresolvers import reverse
from socialregistration.contrib.facebook.client import Facebook
from socialregistration.contrib.facebook.models import FacebookProfile
from socialregistration.views import OAuthRedirect, OAuthCallback, SetupCallback

class FacebookRedirect(OAuthRedirect):
    client = Facebook
    template_name = 'socialregistration/facebook/facebook.html'

class FacebookCallback(OAuthCallback):
    client = Facebook
    template_name = 'socialregistration/facebook/facebook.html'
    
    def get_redirect(self):
        return reverse('socialregistration:facebook:setup')

class FacebookSetup(SetupCallback):
    client = Facebook
    profile = FacebookProfile
    template_name = 'socialregistration/facebook/facebook.html'
    
    def get_lookup_kwargs(self, request, client):
        return {'uid': client.get_user_info()['id']}

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from socialregistration.contrib.foursquare.models import FoursquareProfile

admin.site.register(FoursquareProfile)

########NEW FILE########
__FILENAME__ = auth
from django.contrib.auth.backends import ModelBackend
from django.contrib.sites.models import Site
from socialregistration.contrib.foursquare.models import FoursquareProfile

class FoursquareAuth(ModelBackend):
    def authenticate(self, foursquare=None):
        try:
            return FoursquareProfile.objects.get(
                foursquare=foursquare,
                site=Site.objects.get_current()).user
        except FoursquareProfile.DoesNotExist:
            return None

########NEW FILE########
__FILENAME__ = client
from django.conf import settings
from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse
from socialregistration.clients.oauth import OAuth2
from socialregistration.settings import SESSION_KEY
import json


class Foursquare(OAuth2):
    client_id = getattr(settings, 'FOURSQUARE_CLIENT_ID', '')
    secret = getattr(settings, 'FOURSQUARE_CLIENT_SECRET', '')
    scope = getattr(settings, 'FOURSQUARE_REQUEST_PERMISSIONS', '')
    
    auth_url = 'https://foursquare.com/oauth2/authorize'
    access_token_url = 'https://foursquare.com/oauth2/access_token'
    
    _user_info = None
    
    def get_callback_url(self, **kwargs):
        if self.is_https():
            return 'https://%s%s' % (Site.objects.get_current().domain,
                reverse('socialregistration:foursquare:callback'))
        return 'http://%s%s' % (Site.objects.get_current().domain,
            reverse('socialregistration:foursquare:callback'))
    
    def parse_access_token(self, content):
        """ 
        Forsquare returns JSON instead of url encoded data.
        """
        return json.loads(content)
    
    def request_access_token(self, params):
        """ 
        Foursquare does not accept POST requests to retrieve an access token,
        so we'll be doing a GET request instead.
        """
        return self.request(self.access_token_url, method="GET", params=params)
    
    def get_access_token(self, **params):
        """
        Foursquare requires a `grant_type` parameter when requesting the access
        token. 
        """
        return super(Foursquare, self).get_access_token(grant_type='authorization_code', **params)

    def get_signing_params(self):
        """
        Foursquare requires `oauth_token` parameter instead of `access_token` 
        """
        return dict(oauth_token=self._access_token)
    
    def get_user_info(self):
        if self._user_info is None:
            resp, content = self.request('https://api.foursquare.com/v2/users/self')
            self._user_info = json.loads(content)['response']['user']
        return self._user_info
    
    @staticmethod
    def get_session_key():
        return '%sfoursquare' % SESSION_KEY

########NEW FILE########
__FILENAME__ = models
from django.conf import settings
from django.contrib.auth import authenticate
from django.contrib.sites.models import Site
from django.db import models
from socialregistration.signals import connect

AUTH_USER_MODEL = getattr(settings, 'AUTH_USER_MODEL', 'auth.User')

class FoursquareProfile(models.Model):
    user = models.ForeignKey(AUTH_USER_MODEL, unique=True)
    site = models.ForeignKey(Site, default=Site.objects.get_current)
    foursquare = models.CharField(max_length=255)

    def __unicode__(self):
        try:
            return u'%s: %s' % (self.user, self.foursquare)
        except models.ObjectDoesNotExist:
            return u'None'

    def authenticate(self):
        return authenticate(foursquare=self.foursquare)

class FoursquareAccessToken(models.Model):
    profile = models.OneToOneField(FoursquareProfile, related_name='access_token')
    access_token = models.CharField(max_length=255)

def save_foursquare_token(sender, user, profile, client, **kwargs):
    try:
        FoursquareAccessToken.objects.get(profile=profile).delete()
    except FoursquareAccessToken.DoesNotExist:
        pass

    FoursquareAccessToken.objects.create(access_token=client.get_access_token(),
        profile=profile)


connect.connect(save_foursquare_token, sender=FoursquareProfile,
    dispatch_uid='socialregistration_foursquare_token')

########NEW FILE########
__FILENAME__ = foursquare
from django import template
from socialregistration.templatetags import button

register = template.Library()

register.tag('foursquare_button', button('socialregistration/foursquare/foursquare_button.html'))

########NEW FILE########
__FILENAME__ = tests
from django.conf import settings
from django.core.urlresolvers import reverse
from django.test import TestCase
from socialregistration.contrib.foursquare.models import FoursquareProfile
from socialregistration.tests import TemplateTagTest, OAuth2Test
import json


class TestTemplateTag(TemplateTagTest, TestCase):
    def get_tag(self):
        return 'foursquare', 'foursquare_button'

class TestFoursquare(OAuth2Test, TestCase):
    profile = FoursquareProfile

    def get_redirect_url(self):
        return reverse('socialregistration:foursquare:redirect')
    
    def get_callback_url(self):
        return reverse('socialregistration:foursquare:callback')

    def get_setup_callback_url(self):
        return reverse('socialregistration:foursquare:setup')
    
    def get_callback_mock_response(self, *args, **kwargs):
        return {'status': '200'}, json.dumps({
            'access_token': '456'})
    
    def get_setup_callback_mock_response(self, *args, **kwargs):
        return {'status': '200'}, json.dumps({
            'response': {
                'user':{
                    'id': '123'}}})
    
    def create_profile(self, user):
        FoursquareProfile.objects.create(user=user, foursquare='123')

    
class TestAuthenticationBackend(TestCase):
    def test_authentication_backend_should_be_configured_in_settings(self):
        self.assertTrue('socialregistration.contrib.foursquare.auth.FoursquareAuth' in settings.AUTHENTICATION_BACKENDS)

########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from socialregistration.compat.urls import *
from socialregistration.contrib.foursquare.views import FoursquareRedirect, \
    FoursquareCallback, FoursquareSetup

 
urlpatterns = patterns('',
    url('^redirect/$', FoursquareRedirect.as_view(), name='redirect'),
    url('^callback/$', FoursquareCallback.as_view(), name='callback'),
    url('^setup/$', FoursquareSetup.as_view(), name='setup'),
)

########NEW FILE########
__FILENAME__ = views
from django.core.urlresolvers import reverse
from socialregistration.contrib.foursquare.client import Foursquare
from socialregistration.contrib.foursquare.models import FoursquareProfile
from socialregistration.views import OAuthRedirect, OAuthCallback, SetupCallback

class FoursquareRedirect(OAuthRedirect):
    client = Foursquare
    template_name = 'socialregistration/foursquare/foursquare.html'

class FoursquareCallback(OAuthCallback):
    client = Foursquare
    template_name = 'socialregistration/foursquare/foursquare.html'
    
    def get_redirect(self):
        return reverse('socialregistration:foursquare:setup')

class FoursquareSetup(SetupCallback):
    client = Foursquare
    profile = FoursquareProfile
    template_name = 'socialregistration/foursquare/foursquare.html'
    
    def get_lookup_kwargs(self, request, client):
        return {'foursquare': client.get_user_info()['id']}
    

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from socialregistration.contrib.github.models import GithubProfile

admin.site.register(GithubProfile)

########NEW FILE########
__FILENAME__ = auth
from django.contrib.sites.models import Site
from socialregistration.contrib.github.models import GithubProfile
from django.contrib.auth.backends import ModelBackend


class GithubAuth(ModelBackend):
    def authenticate(self, github = None):
        try:
            return GithubProfile.objects.get(
                github = github,
                site = Site.objects.get_current()).user
        except GithubProfile.DoesNotExist:
            return None

########NEW FILE########
__FILENAME__ = client
from django.conf import settings
from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse
from socialregistration.clients.oauth import OAuth2
from socialregistration.settings import SESSION_KEY
import json


class Github(OAuth2):
    client_id = getattr(settings, 'GITHUB_CLIENT_ID', '')
    secret = getattr(settings, 'GITHUB_CLIENT_SECRET', '')
    scope = getattr(settings, 'GITHUB_REQUEST_PERMISSIONS', '')
    
    auth_url = 'https://github.com/login/oauth/authorize'
    access_token_url = 'https://github.com/login/oauth/access_token'
    
    _user_info = None
    
    def get_callback_url(self, **kwargs):
        if self.is_https():
            return 'https://%s%s' % (Site.objects.get_current().domain,
                reverse('socialregistration:github:callback'))
        return 'http://%s%s' % (Site.objects.get_current().domain,
            reverse('socialregistration:github:callback'))
        
    def get_user_info(self):
        if self._user_info is None:
            resp, content = self.request('https://api.github.com/user')
            self._user_info = json.loads(content)
        return self._user_info
    
    @staticmethod
    def get_session_key():
        return '%sgithub' % SESSION_KEY

########NEW FILE########
__FILENAME__ = models
from django.conf import settings
from django.contrib.auth import authenticate
from django.contrib.sites.models import Site
from django.db import models
from socialregistration.signals import connect

AUTH_USER_MODEL = getattr(settings, 'AUTH_USER_MODEL', 'auth.User')

class GithubProfile(models.Model):
    user = models.ForeignKey(AUTH_USER_MODEL, unique=True)
    site = models.ForeignKey(Site, default=Site.objects.get_current)
    github = models.CharField(max_length = 255)

    def __unicode__(self):
        try:
            return u'%s: %s' % (self.user, self.github)
        except models.ObjectDoesNotExist:
            return u'None'

    def authenticate(self):
        return authenticate(github=self.github)

class GithubAccessToken(models.Model):
    profile = models.OneToOneField(GithubProfile, related_name='access_token')
    access_token = models.CharField(max_length=255)

def save_github_token(sender, user, profile, client, **kwargs):
    try:
        GithubAccessToken.objects.get(profile=profile).delete()
    except GithubAccessToken.DoesNotExist:
        pass

    GithubAccessToken.objects.create(access_token = client.get_access_token(),
        profile = profile)


connect.connect(save_github_token, sender=GithubProfile,
    dispatch_uid='socialregistration_github_token')

########NEW FILE########
__FILENAME__ = github
from django import template
from socialregistration.templatetags import button

register = template.Library()

register.tag('github_button', button('socialregistration/github/github_button.html'))
########NEW FILE########
__FILENAME__ = tests
from django.conf import settings
from django.core.urlresolvers import reverse
from django.test import TestCase
from socialregistration.contrib.github.models import GithubProfile
from socialregistration.tests import TemplateTagTest, OAuth2Test
import json
import urllib

class TestTemplateTag(TemplateTagTest, TestCase):
    def get_tag(self):
        return 'github', 'github_button'


class TestGithub(OAuth2Test, TestCase):
    profile = GithubProfile
    
    def get_redirect_url(self):
        return reverse('socialregistration:github:redirect')
    
    def get_callback_url(self):
        return reverse('socialregistration:github:callback')

    def get_setup_callback_url(self):
        return reverse('socialregistration:github:setup')
    
    def get_callback_mock_response(self, *args, **kwargs):
        return {'status': '200'}, urllib.urlencode({
            'access_token': '456'})
    
    def get_setup_callback_mock_response(self, *args, **kwargs):
        return {'status': '200'}, json.dumps({'login': '123'})
    
    def create_profile(self, user):
        GithubProfile.objects.create(user=user, github='123')

class TestAuthenticationBackend(TestCase):
    def test_authentication_backend_should_be_configured_in_settings(self):
        self.assertTrue('socialregistration.contrib.github.auth.GithubAuth' in settings.AUTHENTICATION_BACKENDS)

########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from socialregistration.compat.urls import *
from socialregistration.contrib.github.views import GithubRedirect, \
    GithubCallback, GithubSetup
 
urlpatterns = patterns('',
    url('^redirect/$', GithubRedirect.as_view(), name='redirect'),
    url('^callback/$', GithubCallback.as_view(), name='callback'),
    url('^setup/$', GithubSetup.as_view(), name='setup'),
)

########NEW FILE########
__FILENAME__ = views
from django.core.urlresolvers import reverse
from socialregistration.contrib.github.client import Github
from socialregistration.contrib.github.models import GithubProfile
from socialregistration.views import OAuthRedirect, OAuthCallback, SetupCallback

class GithubRedirect(OAuthRedirect):
    client = Github
    template_name = 'socialregistration/github/github.html'

class GithubCallback(OAuthCallback):
    client = Github
    template_name = 'socialregistration/github/github.html'
    
    def get_redirect(self):
        return reverse('socialregistration:github:setup')

class GithubSetup(SetupCallback):
    client = Github
    profile = GithubProfile
    template_name = 'socialregistration/github/github.html'
    
    def get_lookup_kwargs(self, request, client):
        return {'github': client.get_user_info()['login']}
    

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from socialregistration.contrib.google.models import GoogleProfile

admin.site.register(GoogleProfile)

########NEW FILE########
__FILENAME__ = auth
from django.contrib.sites.models import Site
from socialregistration.contrib.google.models import GoogleProfile
from django.contrib.auth.backends import ModelBackend


class GoogleAuth(ModelBackend):
    supports_object_permissions = False
    supports_anonymous_user = False

    def authenticate(self, **kwargs):
        uid = kwargs.get('google_id')
        try:
            return GoogleProfile.objects.get(
                google_id = uid,
                site = Site.objects.get_current()).user
        except GoogleProfile.DoesNotExist:
            return None

########NEW FILE########
__FILENAME__ = client
from django.conf import settings
from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse
from socialregistration.clients.oauth import OAuth2, OAuthError
from socialregistration.settings import SESSION_KEY
import json
import httplib2
import urllib

class Google(OAuth2):
    client_id = getattr(settings, 'GOOGLE_CLIENT_ID', '')
    secret = getattr(settings, 'GOOGLE_CLIENT_SECRET', '')
    scope = getattr(settings, 'GOOGLE_REQUEST_PERMISSIONS', 'https://www.googleapis.com/auth/userinfo.profile')
    
    auth_url = 'https://accounts.google.com/o/oauth2/auth'
    access_token_url = 'https://accounts.google.com/o/oauth2/token'
    
    _user_info = None
    
    def get_callback_url(self, **kwargs):
        if self.is_https():
            return 'https://%s%s' % (Site.objects.get_current().domain,
                reverse('socialregistration:google:callback'))
        return 'http://%s%s' % (Site.objects.get_current().domain,
            reverse('socialregistration:google:callback'))
    
    def parse_access_token(self, content):
        """ 
        Forsquare returns JSON instead of url encoded data.
        """
        return json.loads(content)
    
    def request_access_token(self, params):
        """ 
        Google requires correct content-type for POST requests
        """
        return self.client().request(self.access_token_url, method="POST", body=urllib.urlencode(params), headers={'Content-Type':'application/x-www-form-urlencoded'})
    
    def get_access_token(self, **params):
        """
        Google requires grant_type
        """
        return super(Google, self).get_access_token(grant_type='authorization_code', **params)
    
    def get_user_info(self):
        if self._user_info is None:
            resp, content = self.request('https://www.googleapis.com/oauth2/v1/userinfo', params={'access_token': self._access_token})
            self._user_info = json.loads(content)
        return self._user_info
    
    @staticmethod
    def get_session_key():
        return '%sgoogle' % SESSION_KEY

########NEW FILE########
__FILENAME__ = models
from django.contrib.auth import authenticate
from django.contrib.auth.models import User
from django.contrib.sites.models import Site
from django.db import models
from socialregistration.signals import connect

class GoogleProfile(models.Model):
    user = models.ForeignKey(User, unique=True)
    site = models.ForeignKey(Site, default=Site.objects.get_current)
    google_id = models.CharField(max_length = 255)

    def __unicode__(self):
        try:
            return u'%s: %s' % (self.user, self.google_id)
        except User.DoesNotExist:
            return u'None'

    def authenticate(self):
        return authenticate(google_id=self.google_id)

class GoogleAccessToken(models.Model):
    profile = models.OneToOneField(GoogleProfile, related_name='access_token')
    access_token = models.CharField(max_length=255)

def save_google_token(sender, user, profile, client, **kwargs):
    try:
        GoogleAccessToken.objects.get(profile=profile).delete()
    except GoogleAccessToken.DoesNotExist:
        pass
    
    GoogleAccessToken.objects.create(access_token = client.get_access_token(),
        profile = profile)


connect.connect(save_google_token, sender=GoogleProfile,
    dispatch_uid='socialregistration_google_token')

########NEW FILE########
__FILENAME__ = google
from django import template
from socialregistration.templatetags import button

register = template.Library()

register.tag('google_button', button('socialregistration/google/google_button.html'))
########NEW FILE########
__FILENAME__ = tests

########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from django.conf.urls.defaults import *
from socialregistration.contrib.google.views import GoogleRedirect, \
    GoogleCallback, GoogleSetup
 
urlpatterns = patterns('',
    url('^redirect/$', GoogleRedirect.as_view(), name='redirect'),
    url('^callback/$', GoogleCallback.as_view(), name='callback'),
    url('^setup/$', GoogleSetup.as_view(), name='setup'),
)

########NEW FILE########
__FILENAME__ = views
from django.core.urlresolvers import reverse
from socialregistration.contrib.google.client import Google
from socialregistration.contrib.google.models import GoogleProfile
from socialregistration.views import OAuthRedirect, OAuthCallback, SetupCallback

class GoogleRedirect(OAuthRedirect):
    client = Google
    template_name = 'socialregistration/google/google.html'

class GoogleCallback(OAuthCallback):
    client = Google
    template_name = 'socialregistration/google/google.html'
    
    def get_redirect(self):
        return reverse('socialregistration:google:setup')

class GoogleSetup(SetupCallback):
    client = Google
    profile = GoogleProfile
    template_name = 'socialregistration/google/google.html'
    
    def get_lookup_kwargs(self, request, client):
        return {'google_id': client.get_user_info()['id']}
    

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from socialregistration.contrib.instagram.models import InstagramProfile

admin.site.register(InstagramProfile)

########NEW FILE########
__FILENAME__ = auth
from django.contrib.sites.models import Site
from socialregistration.contrib.instagram.models import InstagramProfile
from django.contrib.auth.backends import ModelBackend


class InstagramAuth(ModelBackend):
    def authenticate(self, instagram = None):
        try:
            return InstagramProfile.objects.get(
                instagram = instagram,
                site = Site.objects.get_current()).user
        except InstagramProfile.DoesNotExist:
            return None

########NEW FILE########
__FILENAME__ = client
from django.conf import settings
from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse
from socialregistration.clients.oauth import OAuth2
from socialregistration.settings import SESSION_KEY
import json


class Instagram(OAuth2):
    client_id = getattr(settings, 'INSTAGRAM_CLIENT_ID', '')
    secret = getattr(settings, 'INSTAGRAM_CLIENT_SECRET', '')
    scope = getattr(settings, 'INSTAGRAM_REQUEST_PERMISSIONS', 'basic')
    
    auth_url = 'https://api.instagram.com/oauth/authorize/'
    access_token_url = 'https://api.instagram.com/oauth/access_token/'
    
    _user_info = None
    
    def get_callback_url(self, **kwargs):
        if self.is_https():
            return 'https://%s%s' % (Site.objects.get_current().domain,
                reverse('socialregistration:instagram:callback'))
        return 'http://%s%s' % (Site.objects.get_current().domain,
            reverse('socialregistration:instagram:callback'))

    def get_access_token(self, **params):
        """
        Instagram requires a `grant_type` parameter when requesting the access
        token. 
        """
        return super(Instagram, self).get_access_token(grant_type='authorization_code', **params)


    def parse_access_token(self, content):
        return json.loads(content)
        
    def get_user_info(self):
        return self.access_token_dict['user']['id']

    
    @staticmethod
    def get_session_key():
        return '%sinstagram' % SESSION_KEY

########NEW FILE########
__FILENAME__ = models
from django.conf import settings
from django.contrib.auth import authenticate
from django.contrib.sites.models import Site
from django.db import models
from socialregistration.signals import connect

AUTH_USER_MODEL = getattr(settings, 'AUTH_USER_MODEL', 'auth.User')

class InstagramProfile(models.Model):
    user = models.ForeignKey(AUTH_USER_MODEL, unique=True)
    site = models.ForeignKey(Site, default=Site.objects.get_current)
    instagram = models.CharField(max_length = 255)

    def __unicode__(self):
        try:
            return u'%s: %s' % (self.user, self.instagram)
        except models.ObjectDoesNotExist:
            return u'None'

    def authenticate(self):
        return authenticate(instagram=self.instagram)

class InstagramAccessToken(models.Model):
    profile = models.OneToOneField(InstagramProfile, related_name='access_token')
    access_token = models.CharField(max_length=255)

def save_instagram_token(sender, user, profile, client, **kwargs):
    try:
        InstagramAccessToken.objects.get(profile=profile).delete()
    except InstagramAccessToken.DoesNotExist:
        pass

    InstagramAccessToken.objects.create(access_token = client.get_access_token(),
        profile = profile)


connect.connect(save_instagram_token, sender=InstagramProfile,
    dispatch_uid='socialregistration_instagram_token')

########NEW FILE########
__FILENAME__ = instagram
from django import template
from socialregistration.templatetags import button

register = template.Library()

register.tag('instagram_button', button('socialregistration/instagram/instagram_button.html'))
########NEW FILE########
__FILENAME__ = tests
from django.conf import settings
from django.core.urlresolvers import reverse
from django.test import TestCase
from socialregistration.contrib.instagram.models import InstagramProfile
from socialregistration.tests import TemplateTagTest, OAuth2Test
import json


class TestTemplateTag(TemplateTagTest, TestCase):
    def get_tag(self):
        return 'instagram', 'instagram_button'


class TestInstagram(OAuth2Test, TestCase):
    profile = InstagramProfile
    
    def get_redirect_url(self):
        return reverse('socialregistration:instagram:redirect')
    
    def get_callback_url(self):
        return reverse('socialregistration:instagram:callback')

    def get_setup_callback_url(self):
        return reverse('socialregistration:instagram:setup')
    
    def get_callback_mock_response(self, *args, **kwargs):
        return {'status': '200'}, json.dumps({
            "access_token": "fb2e77d.47a0479900504cb3ab4a1f626d174d2d",
            "user": {
                "id": "1574083",
                "username": "snoopdogg",
                "full_name": "Snoop Dogg",
            }
        })
    
    def get_setup_callback_mock_response(self, *args, **kwargs):
        return {'status': '200'}, json.dumps({'user': {'id': '1574083'}})
    
    def create_profile(self, user):
        InstagramProfile.objects.create(user=user, instagram='1574083')

class TestAuthenticationBackend(TestCase):
    def test_authentication_backend_should_be_configured_in_settings(self):
        self.assertTrue('socialregistration.contrib.instagram.auth.InstagramAuth' in settings.AUTHENTICATION_BACKENDS)

########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from socialregistration.compat.urls import *
from socialregistration.contrib.instagram.views import InstagramRedirect, \
    InstagramCallback, InstagramSetup
 
urlpatterns = patterns('',
    url('^redirect/$', InstagramRedirect.as_view(), name='redirect'),
    url('^callback/$', InstagramCallback.as_view(), name='callback'),
    url('^setup/$', InstagramSetup.as_view(), name='setup'),
)

########NEW FILE########
__FILENAME__ = views
from django.core.urlresolvers import reverse
from socialregistration.contrib.instagram.client import Instagram
from socialregistration.contrib.instagram.models import InstagramProfile
from socialregistration.views import OAuthRedirect, OAuthCallback, SetupCallback

class InstagramRedirect(OAuthRedirect):
    client = Instagram
    template_name = 'socialregistration/instagram/instagram.html'

class InstagramCallback(OAuthCallback):
    client = Instagram
    template_name = 'socialregistration/instagram/instagram.html'
    
    def get_redirect(self):
        return reverse('socialregistration:instagram:setup')

class InstagramSetup(SetupCallback):
    client = Instagram
    profile = InstagramProfile
    template_name = 'socialregistration/instagram/instagram.html'
    
    def get_lookup_kwargs(self, request, client):
        return {'instagram': client.get_user_info()}
    

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from socialregistration.contrib.linkedin.models import LinkedInProfile

admin.site.register(LinkedInProfile)

########NEW FILE########
__FILENAME__ = auth
from django.contrib.auth.backends import ModelBackend
from django.contrib.sites.models import Site
from socialregistration.contrib.linkedin.models import LinkedInProfile


class LinkedInAuth(ModelBackend):
    supports_object_permissions = False
    supports_anonymous_user = False
    
    def authenticate(self, linkedin_id=None):
        try:
            return LinkedInProfile.objects.get(
                linkedin_id=linkedin_id,
                site=Site.objects.get_current()
            ).user
        except LinkedInProfile.DoesNotExist:
            return None

########NEW FILE########
__FILENAME__ = client
from django.conf import settings
from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse
from socialregistration.clients.oauth import OAuth
from socialregistration.settings import SESSION_KEY
import json
import urlparse

class LinkedIn(OAuth):
    api_key = getattr(settings, 'LINKEDIN_CONSUMER_KEY', '')
    secret_key = getattr(settings, 'LINKEDIN_CONSUMER_SECRET_KEY', '')
    
    request_token_url = 'https://api.linkedin.com/uas/oauth/requestToken'
    access_token_url = 'https://api.linkedin.com/uas/oauth/accessToken'
    auth_url = 'https://www.linkedin.com/uas/oauth/authenticate'
    
    _user_info = None
    
    def get_callback_url(self, **kwargs):
        if self.is_https():
            return urlparse.urljoin(
                'https://%s' % Site.objects.get_current().domain,
                reverse('socialregistration:linkedin:callback'))
        return urlparse.urljoin(
            'http://%s' % Site.objects.get_current().domain,
            reverse('socialregistration:linkedin:callback'))
    
    def get_user_info(self):
        if self._user_info is None:
            self._user_info = json.loads(
                self.request("http://api.linkedin.com/v1/people/~:(id)?format=json"))
            
        return self._user_info

    @staticmethod
    def get_session_key():
        return '%slinkedin' % SESSION_KEY

########NEW FILE########
__FILENAME__ = models
from django.conf import settings
from django.contrib.auth import authenticate
from django.contrib.sites.models import Site
from django.db import models
from socialregistration.signals import connect

AUTH_USER_MODEL = getattr(settings, 'AUTH_USER_MODEL', 'auth.User')

class LinkedInProfile(models.Model):
    user = models.ForeignKey(AUTH_USER_MODEL, unique=True)
    site = models.ForeignKey(Site, default=Site.objects.get_current)
    linkedin_id = models.CharField(max_length=25)

    def __unicode__(self):
        try:
            return u'%s: %s' % (self.user, self.linkedin_id)
        except models.ObjectDoesNotExist:
            return u'None'

    def authenticate(self):
        return authenticate(linkedin_id=self.linkedin_id)

class LinkedInRequestToken(models.Model):
    profile = models.OneToOneField(LinkedInProfile, related_name='request_token')
    oauth_token = models.CharField(max_length=80)
    oauth_token_secret = models.CharField(max_length=80)

class LinkedInAccessToken(models.Model):
    profile = models.OneToOneField(LinkedInProfile, related_name='access_token')
    oauth_token = models.CharField(max_length=80)
    oauth_token_secret = models.CharField(max_length=80)


def save_linkedin_token(sender, user, profile, client, **kwargs):
    try:
        LinkedInRequestToken.objects.get(profile=profile).delete()
    except LinkedInRequestToken.DoesNotExist:
        pass
    try:
        LinkedInAccessToken.objects.get(profile=profile).delete()
    except LinkedInAccessToken.DoesNotExist:
        pass

    LinkedInRequestToken.objects.create(profile=profile,
        oauth_token=client.get_request_token().key,
        oauth_token_secret=client.get_request_token().secret)

    LinkedInAccessToken.objects.create(profile=profile,
        oauth_token=client.get_access_token().key,
        oauth_token_secret=client.get_access_token().secret)


connect.connect(save_linkedin_token, sender=LinkedInProfile,
    dispatch_uid='socialregistration_linkedin_token')

########NEW FILE########
__FILENAME__ = linkedin
from django import template
from socialregistration.templatetags import button

register = template.Library()

register.tag('linkedin_button', button('socialregistration/linkedin/linkedin_button.html'))
########NEW FILE########
__FILENAME__ = linkedin_tags
import warnings 

warnings.warn("{% load linkedin_tags %} will be removed. Use {% load linkedin %} instead")

from linkedin import *

########NEW FILE########
__FILENAME__ = tests
from django.conf import settings
from django.core.urlresolvers import reverse
from django.test import TestCase
from socialregistration.contrib.linkedin.models import LinkedInProfile
from socialregistration.tests import TemplateTagTest, OAuthTest
import json
import urllib


class TestTemplateTag(TemplateTagTest, TestCase):
    def get_tag(self):
        return 'linkedin', 'linkedin_button'

class TestLinkedIn(OAuthTest, TestCase):
    profile = LinkedInProfile
    
    def get_redirect_url(self):
        return reverse('socialregistration:linkedin:redirect')
    
    def get_callback_url(self):
        return reverse('socialregistration:linkedin:callback')

    def get_setup_callback_url(self):
        return reverse('socialregistration:linkedin:setup')
    
    def get_redirect_mock_response(self, *args, **kwargs):
        return {'status': '200'}, urllib.urlencode({
            'oauth_token': '123',
            'oauth_token_secret': '456'})
    
    def get_callback_mock_response(self, *args, **kwargs):
        return {'status': '200'}, urllib.urlencode({
            'oauth_token': '456',
            'oauth_token_secret': '789'})
    
    def get_setup_callback_mock_response(self, *args, **kwargs):
        return {'status': '200'}, json.dumps({
            'id': '123'})
    
    def create_profile(self, user):
        LinkedInProfile.objects.create(user=user, linkedin_id='123')


class TestAuthenticationBackend(TestCase):
    def test_authentication_backend_should_be_configured_in_settings(self):
        self.assertTrue('socialregistration.contrib.linkedin.auth.LinkedInAuth' in settings.AUTHENTICATION_BACKENDS)

########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from socialregistration.compat.urls import *
from socialregistration.contrib.linkedin.views import LinkedInRedirect, \
    LinkedInCallback, LinkedInSetup
 
urlpatterns = patterns('',
    url('^redirect/$', LinkedInRedirect.as_view(), name='redirect'),
    url('^callback/$', LinkedInCallback.as_view(), name='callback'),
    url('^setup/$', LinkedInSetup.as_view(), name='setup'),
)

########NEW FILE########
__FILENAME__ = views
from django.core.urlresolvers import reverse
from socialregistration.contrib.linkedin.client import LinkedIn
from socialregistration.contrib.linkedin.models import LinkedInProfile
from socialregistration.views import OAuthRedirect, OAuthCallback, SetupCallback

class LinkedInRedirect(OAuthRedirect):
    client = LinkedIn
    template_name = 'socialregistration/linkedin/linkedin.html'

class LinkedInCallback(OAuthCallback):
    client = LinkedIn
    template_name = 'socialregistration/linkedin/linkedin.html'
    
    def get_redirect(self):
        return reverse('socialregistration:linkedin:setup')

class LinkedInSetup(SetupCallback):
    client = LinkedIn
    profile = LinkedInProfile
    template_name = 'socialregistration/linkedin/linkedin.html'
    
    def get_lookup_kwargs(self, request, client):
        return {'linkedin_id': client.get_user_info()['id']}
    

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from socialregistration.contrib.openid.models import OpenIDProfile

admin.site.register(OpenIDProfile)

########NEW FILE########
__FILENAME__ = auth
from django.contrib.auth.backends import ModelBackend
from django.contrib.sites.models import Site
from socialregistration.contrib.openid.models import OpenIDProfile



class OpenIDAuth(ModelBackend):
    def authenticate(self, identity=None):
        try:
            return OpenIDProfile.objects.get(
                identity=identity,
                site=Site.objects.get_current()
            ).user
        except OpenIDProfile.DoesNotExist:
            return None

########NEW FILE########
__FILENAME__ = client
from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse
from openid.consumer import consumer
from socialregistration.clients import Client
from socialregistration.contrib.openid.storage import OpenIDStore
from socialregistration.settings import SESSION_KEY
import urlparse

class OpenIDClient(Client):
    def __init__(self, session_data, endpoint_url):
        self.endpoint_url = endpoint_url
        self.store = OpenIDStore()
        self.consumer = consumer.Consumer(session_data, self.store)
    
    def get_realm(self):
        if self.is_https():
            return 'https://%s/' % Site.objects.get_current().domain
        return 'http://%s/' % Site.objects.get_current().domain
    
    def get_callback_url(self, **kwargs):
        return urlparse.urljoin(self.get_realm(),
            reverse('socialregistration:openid:callback'))
    
    def get_redirect_url(self):
        auth_request = self.consumer.begin(self.endpoint_url)
        
        redirect_url = auth_request.redirectURL(self.get_realm(),
            self.get_callback_url())
        
        return redirect_url
    
    def complete(self, GET, path):
        self.result = self.consumer.complete(GET, urlparse.urljoin(self.get_realm(),
            path))
    
    def is_valid(self):
        return self.result.status == consumer.SUCCESS
    
    def get_identity(self):
        return self.result.identity_url
    
    @staticmethod
    def get_session_key():
        return '%sopenid' % SESSION_KEY

########NEW FILE########
__FILENAME__ = models
from django.conf import settings
from django.db import models
from django.contrib.sites.models import Site
from django.contrib.auth import authenticate

AUTH_USER_MODEL = getattr(settings, 'AUTH_USER_MODEL', 'auth.User')

class OpenIDProfile(models.Model):
    user = models.ForeignKey(AUTH_USER_MODEL)
    site = models.ForeignKey(Site, default=Site.objects.get_current)
    identity = models.TextField()

    def __unicode__(self):
        try:
            return 'OpenID profile for %s, via provider %s' % (self.user, self.identity)
        except models.ObjectDoesNotExist:
            return 'OpenID profile for None, via provider None'

    def authenticate(self):
        return authenticate(identity=self.identity)

class OpenIDStore(models.Model):
    site = models.ForeignKey(Site, default=Site.objects.get_current)
    server_url = models.CharField(max_length=255)
    handle = models.CharField(max_length=255)
    secret = models.TextField()
    issued = models.IntegerField()
    lifetime = models.IntegerField()
    assoc_type = models.TextField()

    def __unicode__(self):
        return u'OpenID Store %s for %s' % (self.server_url, self.site)

class OpenIDNonce(models.Model):
    server_url = models.CharField(max_length=255)
    timestamp = models.IntegerField()
    salt = models.CharField(max_length=255)
    date_created = models.DateTimeField(auto_now_add=True)

    def __unicode__(self):
        return u'OpenID Nonce for %s' % self.server_url

########NEW FILE########
__FILENAME__ = storage
import base64
from openid.association import Association
from openid.store.interface import OpenIDStore
from socialregistration.contrib.openid.models import (OpenIDNonce,
    OpenIDStore as OpenIDStoreModel)

class OpenIDStore(OpenIDStore):
    max_nonce_age = 6 * 60 * 60

    def storeAssociation(self, server_url, assoc=None):
        stored_assoc = OpenIDStoreModel.objects.create(
            server_url=server_url,
            handle=assoc.handle,
            secret=base64.encodestring(assoc.secret),
            issued=assoc.issued,
            lifetime=assoc.issued,
            assoc_type=assoc.assoc_type
        )


    def getAssociation(self, server_url, handle=None):
        stored_assocs = OpenIDStoreModel.objects.filter(
            server_url=server_url
        )
        if handle:
            stored_assocs = stored_assocs.filter(handle=handle)

        stored_assocs.order_by('-issued')

        if stored_assocs.count() == 0:
            return None

        return_val = None

        for stored_assoc in stored_assocs:
            assoc = Association(
                stored_assoc.handle, base64.decodestring(stored_assoc.secret),
                stored_assoc.issued, stored_assoc.lifetime, stored_assoc.assoc_type
            )

            if assoc.getExpiresIn() == 0:
                stored_assoc.delete()
            else:
                if return_val is None:
                    return_val = assoc

        return return_val

    def removeAssociation(self, server_url, handle):
        stored_assocs = OpenIDStoreModel.objects.filter(
            server_url=server_url
        )
        if handle:
            stored_assocs = stored_assocs.filter(handle=handle)

        stored_assocs.delete()

    def useNonce(self, server_url, timestamp, salt):
        try:
            nonce = OpenIDNonce.objects.get(
                server_url=server_url,
                timestamp=timestamp,
                salt=salt
            )
        except OpenIDNonce.DoesNotExist:
            nonce = OpenIDNonce.objects.create(
                server_url=server_url,
                timestamp=timestamp,
                salt=salt
            )
            return True

        return False

########NEW FILE########
__FILENAME__ = openid
from django import template
from socialregistration.templatetags import resolve, get_bits

register = template.Library()

@register.tag
def openid_form(parser, token):
    """
    Render OpenID form. Allows to pre set the provider::

    	{% openid_form "https://www.google.com/accounts/o8/id" %}

    Also creates custom button URLs by concatenating all arguments
    after the provider's URL

    	{% openid_form "https://www.google.com/accounts/o8/id" STATIC_URL "image/for/google.jpg" %}

    """

    bits = get_bits(token)

    if len(bits) > 1:
        return FormNode(bits[0], bits[1:])
    if len(bits) == 1:
        return FormNode(bits[0])
    return FormNode(None)

class FormNode(template.Node):
    def __init__(self, provider, params = []):
        self.provider = provider
        self.params = params

    def render(self, context):
        if self.provider:
            provider = resolve(self.provider, context)
        else:
            provider = None

        if self.params:
            button = ''.join([resolve(bit, context) for bit in self.params])
        else:
            button = None

        return template.loader.render_to_string(
            'socialregistration/openid/form.html',{
                'provider': provider,
                'button': button},
            context_instance = context)

########NEW FILE########
__FILENAME__ = openid_tags
import warnings 

warnings.warn("{% load openid_tags %} will be removed. Use {% load openid %} instead")

from openid import *

########NEW FILE########
__FILENAME__ = tests
from django import template
from django.conf import settings
from django.test import TestCase


class TestTemplateTag(TestCase):
    def test_tag_renders_correctly(self):
        render = lambda tpl: template.Template(
            tpl).render(template.Context({'request':None}))
        
        tpl = """{% load openid %}{% openid_form %}"""
       
        rendered = render(tpl)

        self.assertTrue('form' in rendered)
        
        tpl = """
	{% load openid %}
	{% openid_form "https://www.google.com/accounts/o8/id" "image/for/google.jpg" %}
	"""
        
        rendered = render(tpl)

        self.assertTrue('https://www.google.com/accounts/o8/id' in rendered)

        self.assertTrue('image/for/google.jpg' in rendered)



class TestAuthenticationBackend(TestCase):
    def test_authentication_backend_should_be_configured_in_settings(self):
        self.assertTrue('socialregistration.contrib.openid.auth.OpenIDAuth' in settings.AUTHENTICATION_BACKENDS)

########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from socialregistration.compat.urls import *
from socialregistration.contrib.openid.views import OpenIDRedirect, \
    OpenIDCallback, OpenIDSetup

urlpatterns = patterns('',
    url('^redirect/$', OpenIDRedirect.as_view(), name='redirect'),
    url('^callback/$', OpenIDCallback.as_view(), name='callback'),
    url('^setup/$', OpenIDSetup.as_view(), name='setup'),
)

########NEW FILE########
__FILENAME__ = views
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect
from django.utils.translation import ugettext_lazy as _
from django.views.generic.base import View
from socialregistration.contrib.openid.client import OpenIDClient
from socialregistration.contrib.openid.models import OpenIDProfile
from socialregistration.mixins import SocialRegistration
from socialregistration.views import SetupCallback

class OpenIDRedirect(SocialRegistration, View):
    client = OpenIDClient
    
    def post(self, request):
        request.session['next'] = self.get_next(request)

        # We don't want to pass in the whole session object as this might not 
        # be pickleable depending on what session backend one is using. 
        # See issue #73
        client = self.get_client()(dict(request.session.items()),
            request.POST.get('openid_provider'))
        
        request.session[self.get_client().get_session_key()] = client
        
        return HttpResponseRedirect(client.get_redirect_url())

class OpenIDCallback(SocialRegistration, View):
    template_name = 'socialregistration/openid/openid.html'
    profile = OpenIDProfile
    client = OpenIDClient
    
    def get(self, request):
        
        client = request.session[self.get_client().get_session_key()]
        
        client.complete(dict(request.GET.items()), request.get_full_path())
        
        if not client.is_valid():
            if hasattr(client.result, 'message'):
                msg = _("Unfortunately we couldn't validate your identity: %s") % client.result.message
            else:
                msg = _("Unfortunately we couldn't validate your identity")
            return self.error_to_response(request, {'error': msg})
        
        # Save the client back to the session or we're not carrying the result
        # to the next view.
        request.session[self.get_client().get_session_key()] = client
        
        return HttpResponseRedirect(reverse('socialregistration:openid:setup'))

class OpenIDSetup(SetupCallback):
    template_name = 'socialregistration/openid/openid.html'
    profile = OpenIDProfile
    client = OpenIDClient
    
    def get_lookup_kwargs(self, request, client):
        return {'identity': client.get_identity()} 

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from socialregistration.contrib.tumblr.models import TumblrProfile

admin.site.register(TumblrProfile)

########NEW FILE########
__FILENAME__ = auth
from django.contrib.auth.backends import ModelBackend
from django.contrib.sites.models import Site
from socialregistration.contrib.tumblr.models import TumblrProfile


class TumblrAuth(ModelBackend):
    def authenticate(self, tumblr=None):
        try:
            return TumblrProfile.objects.get(
                tumblr=tumblr,
                site=Site.objects.get_current()
            ).user
        except TumblrProfile.DoesNotExist:
            return None

########NEW FILE########
__FILENAME__ = client
from django.conf import settings
from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse
from socialregistration.clients.oauth import OAuth
from socialregistration.settings import SESSION_KEY
import json
import urlparse

class Tumblr(OAuth):
    api_key = getattr(settings, 'TUMBLR_CONSUMER_KEY', '')
    secret_key = getattr(settings, 'TUMBLR_CONSUMER_SECRET_KEY', '')
    
    request_token_url = 'http://www.tumblr.com/oauth/request_token'
    access_token_url = 'http://www.tumblr.com/oauth/access_token'
    auth_url = 'http://www.tumblr.com/oauth/authorize'
    
    def get_callback_url(self, **kwargs):
        if self.is_https():
            return urlparse.urljoin(
                'https://%s' % Site.objects.get_current().domain,
                reverse('socialregistration:tumblr:callback'))
        return urlparse.urljoin(
            'http://%s' % Site.objects.get_current().domain,
            reverse('socialregistration:tumblr:callback'))

    def get_user_info(self):
        if self._user_info is None:
            self._user_info = json.loads(
                self.request('http://api.tumblr.com/v2/user/info'))['response']['user']
        return self._user_info
    
    @staticmethod
    def get_session_key():
        return '%stumblr' % SESSION_KEY



########NEW FILE########
__FILENAME__ = models
from django.conf import settings
from django.contrib.auth import authenticate
from django.contrib.sites.models import Site
from django.db import models
from socialregistration.signals import connect

AUTH_USER_MODEL = getattr(settings, 'AUTH_USER_MODEL', 'auth.User')

class TumblrProfile(models.Model):
    user = models.ForeignKey(AUTH_USER_MODEL, unique=True)
    site = models.ForeignKey(Site, default=Site.objects.get_current)
    tumblr = models.CharField(max_length=100)

    def __unicode__(self):
        try:
            return u'%s: %s' % (self.user, self.tumblr)
        except models.ObjectDoesNotExist:
            return u'None'

    def authenticate(self):
        return authenticate(tumblr=self.tumblr)

class TumblrRequestToken(models.Model):
    profile = models.OneToOneField(TumblrProfile, related_name='request_token')
    oauth_token = models.CharField(max_length=80)
    oauth_token_secret = models.CharField(max_length=80)

class TumblrAccessToken(models.Model):
    profile = models.OneToOneField(TumblrProfile, related_name='access_token')
    oauth_token = models.CharField(max_length=80)
    oauth_token_secret = models.CharField(max_length=80)

def save_tumblr_token(sender, user, profile, client, **kwargs):
    try:
        TumblrRequestToken.objects.get(profile=profile).delete()
    except TumblrRequestToken.DoesNotExist:
        pass
    try:
        TumblrAccessToken.objects.get(profile=profile).delete()
    except TumblrAccessToken.DoesNotExist:
        pass

    TumblrRequestToken.objects.create(profile=profile,
        oauth_token=client.get_request_token().key,
        oauth_token_secret=client.get_request_token().secret)

    TumblrAccessToken.objects.create(profile=profile,
        oauth_token=client.get_access_token().key,
        oauth_token_secret=client.get_access_token().secret)

connect.connect(save_tumblr_token, sender=TumblrProfile,
    dispatch_uid='socialregistration_tumblr_token')

########NEW FILE########
__FILENAME__ = tumblr
from django import template
from socialregistration.templatetags import button

register = template.Library()

register.tag('tumblr_button', button('socialregistration/tumblr/tumblr_button.html'))

########NEW FILE########
__FILENAME__ = tests
from django.conf import settings
from django.core.urlresolvers import reverse
from django.test import TestCase
from socialregistration.contrib.tumblr.models import TumblrProfile
from socialregistration.tests import TemplateTagTest, OAuthTest
import json
import urllib


class TestTemplateTag(TemplateTagTest, TestCase):
    def get_tag(self):
        return 'tumblr', 'tumblr_button'

class TestTumblr(OAuthTest, TestCase):
    profile = TumblrProfile
    
    def get_redirect_url(self):
        return reverse('socialregistration:tumblr:redirect')
    
    def get_callback_url(self):
        return reverse('socialregistration:tumblr:callback')

    def get_setup_callback_url(self):
        return reverse('socialregistration:tumblr:setup')
    
    def get_redirect_mock_response(self, *args, **kwargs):
        return {'status': '200'}, urllib.urlencode({
            'oauth_token': '123',
            'oauth_token_secret': '456'})
    
    def get_callback_mock_response(self, *args, **kwargs):
        return {'status': '200'}, urllib.urlencode({
            'oauth_token': '456',
            'oauth_token_secret': '789'})
    
    def get_setup_callback_mock_response(self, *args, **kwargs):
        return {'status': '200'}, json.dumps({ 
            'response': {
                'user': {
                    'name': '123'}}})

    def create_profile(self, user):
        TumblrProfile.objects.create(user=user, tumblr='123')

class TestAuthenticationBackend(TestCase):
    def test_authentication_backend_should_be_configured_in_settings(self):
        self.assertTrue('socialregistration.contrib.tumblr.auth.TumblrAuth' in settings.AUTHENTICATION_BACKENDS)

########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from socialregistration.compat.urls import *
from socialregistration.contrib.tumblr.views import TumblrRedirect, \
    TumblrCallback, TumblrSetup


urlpatterns = patterns('',
    url('^redirect/$', TumblrRedirect.as_view(), name='redirect'),
    url('^callback/$', TumblrCallback.as_view(), name='callback'),
    url('^setup/$', TumblrSetup.as_view(), name='setup'),
)

########NEW FILE########
__FILENAME__ = views
from django.core.urlresolvers import reverse
from socialregistration.contrib.tumblr.client import Tumblr
from socialregistration.contrib.tumblr.models import TumblrProfile
from socialregistration.views import OAuthRedirect, OAuthCallback, SetupCallback

class TumblrRedirect(OAuthRedirect):
    client = Tumblr
    template_name = 'socialregistration/tumblr/tumblr.html'

class TumblrCallback(OAuthCallback):
    client = Tumblr
    template_name = 'socialregistration/tumblr/tumblr.html'
    
    def get_redirect(self):
        return reverse('socialregistration:tumblr:setup')

class TumblrSetup(SetupCallback):
    client = Tumblr
    profile = TumblrProfile
    template_name = 'socialregistration/tumblr/tumblr.html'
    
    def get_lookup_kwargs(self, request, client):
        return {'tumblr': client.get_user_info()['name']}
    

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from socialregistration.contrib.twitter.models import TwitterProfile

admin.site.register(TwitterProfile)

########NEW FILE########
__FILENAME__ = auth
from django.contrib.auth.backends import ModelBackend
from django.contrib.sites.models import Site
from socialregistration.contrib.twitter.models import TwitterProfile


class TwitterAuth(ModelBackend):
    
    def authenticate(self, twitter_id=None):
        try:
            return TwitterProfile.objects.get(
                twitter_id=twitter_id,
                site=Site.objects.get_current()
            ).user
        except TwitterProfile.DoesNotExist:
            return None

########NEW FILE########
__FILENAME__ = client
from django.conf import settings
from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse
from socialregistration.clients.oauth import OAuth, OAuthError
from socialregistration.settings import SESSION_KEY
import urlparse
import json

class Twitter(OAuth):
    api_key = getattr(settings, 'TWITTER_CONSUMER_KEY', '')
    secret_key = getattr(settings, 'TWITTER_CONSUMER_SECRET_KEY', '')
    
    request_token_url = 'https://api.twitter.com/oauth/request_token'
    access_token_url = 'https://api.twitter.com/oauth/access_token'
    auth_url = 'https://api.twitter.com/oauth/authenticate'
    
    info_url = 'https://api.twitter.com/1/account/verify_credentials.json'

    def get_callback_url(self, **kwargs):
        if self.is_https():
            return urlparse.urljoin(
                'https://%s' % Site.objects.get_current().domain,
                reverse('socialregistration:twitter:callback'))
        return urlparse.urljoin(
            'http://%s' % Site.objects.get_current().domain,
            reverse('socialregistration:twitter:callback'))
    
    def get_user_info(self):
        dct = self._access_token_dict or {}

        try:
            dct.update(json.loads(self.request(self.info_url)))
        except OAuthError:
            pass

        return dct

    @staticmethod
    def get_session_key():
        return '%stwitter' % SESSION_KEY


########NEW FILE########
__FILENAME__ = models
from django.conf import settings
from django.contrib.auth import authenticate
from django.contrib.sites.models import Site
from django.db import models
from socialregistration.signals import connect

AUTH_USER_MODEL = getattr(settings, 'AUTH_USER_MODEL', 'auth.User')

class TwitterProfile(models.Model):
    user = models.ForeignKey(AUTH_USER_MODEL, unique=True)
    site = models.ForeignKey(Site, default=Site.objects.get_current)
    twitter_id = models.PositiveIntegerField()

    def __unicode__(self):
        try:
            return u'%s: %s' % (self.user, self.twitter_id)
        except models.ObjectDoesNotExist:
            return u'None'

    def authenticate(self):
        return authenticate(twitter_id=self.twitter_id)

class TwitterRequestToken(models.Model):
    profile = models.OneToOneField(TwitterProfile, related_name='request_token')
    oauth_token = models.CharField(max_length=80)
    oauth_token_secret = models.CharField(max_length=80)

class TwitterAccessToken(models.Model):
    profile = models.OneToOneField(TwitterProfile, related_name='access_token')
    oauth_token = models.CharField(max_length=80)
    oauth_token_secret = models.CharField(max_length=80)

def save_twitter_token(sender, user, profile, client, **kwargs):
    try:
        TwitterRequestToken.objects.get(profile=profile).delete()
    except TwitterRequestToken.DoesNotExist:
        pass
    try:
        TwitterAccessToken.objects.get(profile=profile).delete()
    except TwitterAccessToken.DoesNotExist:
        pass

    TwitterRequestToken.objects.create(profile=profile,
        oauth_token=client.get_request_token().key,
        oauth_token_secret=client.get_request_token().secret)

    TwitterAccessToken.objects.create(profile=profile,
        oauth_token=client.get_access_token().key,
        oauth_token_secret=client.get_access_token().secret)

connect.connect(save_twitter_token, sender=TwitterProfile,
    dispatch_uid='socialregistration_twitter_token')

########NEW FILE########
__FILENAME__ = twitter
from django import template
from socialregistration.templatetags import button

register = template.Library()

register.tag('twitter_button', button('socialregistration/twitter/twitter_button.html'))
########NEW FILE########
__FILENAME__ = twitter_tags
import warnings 

warnings.warn("{% load twitter_tags %} will be removed. Use {% load twitter %} instead")

from twitter import *

########NEW FILE########
__FILENAME__ = tests
from django.conf import settings
from django.core.urlresolvers import reverse
from django.test import TestCase
from socialregistration.contrib.twitter.models import TwitterProfile
from socialregistration.tests import TemplateTagTest, OAuthTest
import urllib
import json

class TestTemplateTag(TemplateTagTest, TestCase):
    def get_tag(self):
        return 'twitter', 'twitter_button'

class TestTwitter(OAuthTest, TestCase):
    profile = TwitterProfile

    def get_redirect_url(self):
        return reverse('socialregistration:twitter:redirect')
    
    def get_callback_url(self):
        return reverse('socialregistration:twitter:callback')

    def get_setup_callback_url(self):
        return reverse('socialregistration:twitter:setup')
    
    def get_redirect_mock_response(self, *args, **kwargs):
        return {'status': '200'}, urllib.urlencode({
            'oauth_token': '123',
            'oauth_token_secret': '456'})
    
    def get_callback_mock_response(self, *args, **kwargs):
        return {'status': '200'}, urllib.urlencode({
            'oauth_token': '456',
            'oauth_token_secret': '789',
            'user_id': '123'})
    
    def get_setup_callback_mock_response(self, *args, **kwargs):
        return {'status': '200'}, json.dumps({})
    
    def create_profile(self, user):
        TwitterProfile.objects.create(user=user, twitter_id='123')


class TestAuthenticationBackend(TestCase):
    def test_authentication_backend_should_be_configured_in_settings(self):
        self.assertTrue('socialregistration.contrib.twitter.auth.TwitterAuth' in settings.AUTHENTICATION_BACKENDS)

########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from socialregistration.compat.urls import *
from socialregistration.contrib.twitter.views import TwitterRedirect, \
    TwitterCallback, TwitterSetup

urlpatterns = patterns('',
    url('^redirect/$', TwitterRedirect.as_view(), name='redirect'),
    url('^callback/$', TwitterCallback.as_view(), name='callback'),
    url('^setup/$', TwitterSetup.as_view(), name='setup'),
)

########NEW FILE########
__FILENAME__ = views
from django.core.urlresolvers import reverse
from socialregistration.contrib.twitter.client import Twitter
from socialregistration.contrib.twitter.models import TwitterProfile
from socialregistration.views import OAuthRedirect, OAuthCallback, SetupCallback

class TwitterRedirect(OAuthRedirect):
    client = Twitter
    template_name = 'socialregistration/twitter/twitter.html'

class TwitterCallback(OAuthCallback):
    client = Twitter
    template_name = 'socialregistration/twitter/twitter.html'
    
    def get_redirect(self):
        return reverse('socialregistration:twitter:setup')

class TwitterSetup(SetupCallback):
    client = Twitter
    profile = TwitterProfile
    template_name = 'socialregistration/twitter/twitter.html'
    
    def get_lookup_kwargs(self, request, client):
        return {'twitter_id': client.get_user_info()['user_id']}
    

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.utils.translation import gettext as _

from django.contrib.auth.models import User

class UserForm(forms.Form):
    """
    Default user creation form. Can be altered with the 
    `SOCIALREGISTRATION_SETUP_FORM` setting.
    """
    username = forms.RegexField(r'^\w+$', max_length=32)
    email = forms.EmailField(required=False)

    def clean_username(self):
        username = self.cleaned_data.get('username')
        try:
            user = User.objects.get(username=username)
        except User.DoesNotExist:
            return username
        else:
            raise forms.ValidationError(_('This username is already in use.'))

    def save(self, request, user, profile, client):
        user.username = self.cleaned_data.get('username')
        user.email = self.cleaned_data.get('email')
        user.set_unusable_password()
        user.save()
        profile.user = user
        profile.save()
        return user, profile

########NEW FILE########
__FILENAME__ = middleware
import warnings

from socialregistration.contrib.facebook.middleware import FacebookMiddleware

warnings.warn("'socialregistration.middleware.FacebookMiddleware' will be removed. "
    "Use 'socialregistration.contrib.facebook.middleware.FacebookMiddleware' instead.")


########NEW FILE########
__FILENAME__ = mixins
from django.conf import settings
from django.contrib.auth import authenticate, login
from django.contrib.auth.models import User
from django.http import HttpResponseRedirect
from django.utils import importlib
from django.utils.translation import ugettext_lazy as _
from django.views.generic.base import TemplateResponseMixin
from socialregistration import signals
from socialregistration.settings import SESSION_KEY
import urlparse

ERROR_VIEW = getattr(settings, 'SOCIALREGISTRATION_ERROR_VIEW_FUNCTION',
    None)

class CommonMixin(TemplateResponseMixin):
    """
    Provides default functionality used such as authenticating and signing
    in users, redirecting etc.
    """

    def import_attribute(self, path):
        """
        Import an attribute from a module.
        """
        module = '.'.join(path.split('.')[:-1])
        function = path.split('.')[-1]

        module = importlib.import_module(module)
        return getattr(module, function)

    def get_next(self, request):
        """
        Returns a url to redirect to after the login / signup.
        """
        if 'next' in request.session: 
            next = request.session['next']
            del request.session['next']
        elif 'next' in request.GET:
            next = request.GET.get('next')
        elif 'next' in request.POST:
            next = request.POST.get('next')
        else:
            next = getattr(settings, 'LOGIN_REDIRECT_URL', '/')
        
        netloc = urlparse.urlparse(next)[1]
        
        if netloc and netloc != request.get_host():
            next = getattr(settings, 'LOGIN_REDIRECT_URL', '/')

        return next

    def authenticate(self, **kwargs):
        """
        Authenticate a user against all configured authentication backends.
        """
        return authenticate(**kwargs)

    def login(self, request, user):
        """
        Sign a user in.
        """
        return login(request, user)

    def inactive_response(self, request):
        """
        Return an inactive message.
        """
        inactive_url = getattr(settings, 'LOGIN_INACTIVE_REDIRECT_URL', '')
        if inactive_url:
            return HttpResponseRedirect(inactive_url)
        else:
            return self.error_to_response(request, {'error': _("This user account is marked as inactive.")})

    def redirect(self, request):
        """
        Redirect the user back to the ``next`` session/request variable.
        """
        return HttpResponseRedirect(self.get_next(request))

class ClientMixin(object):
    """
    Views such as ``OAuthRedirectView`` require a client to work with. This is
    the interface to it.

    """
    #: The client class we'll be working with
    client = None

    def get_client(self):
        """
        Return the client class or raise an ``AttributeError`` if
        ``self.client`` is not set.
        """
        if self.client is None:
            raise AttributeError('`self.client` is `None`')
        return self.client

class ProfileMixin(object):
    """
    Views such as ``SetupCallback`` require a profile model to work with. This is
    the interface to it.

    """
    #: The profile model that we'll be working with
    profile = None

    def get_lookup_kwargs(self, request, client):
        """
        Return a dictionary to look up a profile object.
        """
        raise NotImplementedError

    def get_model(self):
        """
        Return the profile model or raise an ``AttributeError``
        if ``self.profile`` is not set.
        """
        if self.profile is None:
            raise AttributeError('`self.profile` is `None`')
        return self.profile

    def create_user(self):
        """
        Create and return an empty user model.
        """
        return User()

    def create_profile(self, user, save=False, **kwargs):
        """
        Create a profile model.

        :param user: A user object
        :param save: If this is set, the profile will
            be saved to DB straight away
        :type save: bool
        """
        profile = self.get_model()(user=user, **kwargs)

        if save:
            profile.save()

        return profile

    def get_profile(self, **kwargs):
        """
        Return a profile object
        """
        return self.get_model().objects.get(**kwargs)

    def get_or_create_profile(self, user, save=False, **kwargs):
        """
        Return a profile from DB or if there is none, create a new one.

        :param user: A user object
        :param save: If set, a new profile will be saved.
        :type save: bool
        """
        try:
            profile = self.get_model().objects.get(user=user, **kwargs)
            return profile, False
        except self.get_model().DoesNotExist:
            profile = self.create_profile(user, save=save, **kwargs)
            return profile, True

class SessionMixin(object):
    """
    When a new user is signing up the user and profile models and api client
    need to be carried accross two views via session. This mixin handles
    storage, retrieval and cleanup of said values.
    """

    def store_profile(self, request, profile):
        """
        Store the profile data to the session
        """
        request.session['%sprofile' % SESSION_KEY] = profile

    def store_user(self, request, user):
        """
        Store the user data to the session
        """
        request.session['%suser' % SESSION_KEY] = user

    def store_client(self, request, client):
        """
        Store the client to the session
        """
        request.session['%sclient' % SESSION_KEY] = client

    def get_session_data(self, request):
        """
        Return a tuple ``(user, profile, client)`` from the session.
        """
        user = request.session['%suser' % SESSION_KEY]
        profile = request.session['%sprofile' % SESSION_KEY]
        client = request.session['%sclient' % SESSION_KEY]
        return user, profile, client

    def delete_session_data(self, request):
        """
        Clear all session data.
        """
        for key in ['user', 'profile', 'client']:
            try: del request.session['%s%s' % (SESSION_KEY, key)]
            except KeyError: pass
        

class SignalMixin(object):
    """
    When signing users up or signing users in we need to send out signals to
    notify other parts of the code. This mixin provides an interface for sending
    the signals.
    """
    def send_login_signal(self, request, user, profile, client):
        """
        Send a signal that a user logged in. This signal should be sent only if
        the user was *not* logged into Django.
        """
        signals.login.send(sender=profile.__class__, user=user,
            profile=profile, client=client, request=request)

    def send_connect_signal(self, request, user, profile, client):
        """
        Send a signal that a user connected a social profile to his Django
        account. This signal should be sent *only* when the a new social
        connection was created.
        """
        signals.connect.send(sender=profile.__class__, user=user, profile=profile,
            client=client, request=request)

class ErrorMixin(object):
    def error_to_response(self, request, error_dict, **context):
        if ERROR_VIEW:
            return self.import_attribute(ERROR_VIEW)(request, error_dict, **context)
        return self.render_to_response(error_dict, **context)

class SocialRegistration(CommonMixin, ClientMixin, ProfileMixin, SessionMixin,
    SignalMixin, ErrorMixin):
    """
    Combine all mixins into a single class.
    """
    pass

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = settings
from django.conf import settings

SESSION_KEY = getattr(settings, 'SOCIALREGISTRATION_SESSION_KEY', 'socialreg:')
########NEW FILE########
__FILENAME__ = signals
from django import dispatch

login = dispatch.Signal(providing_args = ["user", "profile", "client"])
connect = dispatch.Signal(providing_args = ["user", "profile", "client"])

########NEW FILE########
__FILENAME__ = tests
from django import template
from django.conf import settings
from django.contrib.auth.models import User
from django.core.urlresolvers import reverse
from django.test import TestCase
from oauth2 import Client
from socialregistration.signals import login, connect
import mock
import urllib
import urlparse

class TemplateTagTest(object):
    def get_tag(self):
        """
        Return the appropriate {% load %} and {% button %} tag to try rendering
        as a tuple:
        
                ('facebook', 'facebook_button')

        """
        raise NotImplementedError
    
    def test_tag_renders_correctly(self):
        load, button = self.get_tag()

        tpl = """{%% load %s %%}{%% %s %%}""" % (load, button)
        
        self.assertTrue('form' in template.Template(tpl).render(template.Context({'request': None})))
        
        tpl = """{%% load %s %%}{%% %s STATIC_URL 'custom/button/url.jpg' %%}""" % (load, button)
        
        rendered = template.Template(tpl).render(template.Context({
                    'request': None,
                    'STATIC_URL': '/static/'}))

        self.assertTrue('custom/button/url.jpg' in rendered)
        self.assertTrue('/static/' in rendered)


def get_mock_func(func):
    def wrapped(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapped


class OAuthTest(object):
    """
    Mixin for OAuth tests. This does not go out to the services that we're 
    testing but mocks instead the responses we *should* get back.
    """
    
    # The profile model to be used
    profile = None
    
    def get_redirect_url(self):
        raise NotImplementedError
    
    def get_callback_url(self):
        raise NotImplementedError
    
    def get_callback_setup_url(self):
        raise NotImplementedError
    
    def get_redirect_mock_response(self, *args, **kwargs):
        """
        If the redirect view does any requests, this is the method that returns
        the mocked response. In case of OAuth1 this will be the request token
        response.
        """
        raise NotImplementedError
    
    def get_callback_mock_response(self, *args, **kwargs):
        """
        If the callback view does any request, this is the method that returns
        the mocked response. In case of OAuth{1,2} this will be the access token.
        """
        raise NotImplementedError
    
    def get_setup_callback_mock_response(self, *args, **kwargs):
        """
        If the setup callback view does any requests, this is the method that
        returns the mocked response. In case of OAuth{1,2} this will be the 
        user information that we'll be authenticating with.
        """
        raise NotImplementedError
    
    def create_profile(self, user):
        raise NotImplementedError
    
    def create_user(self, is_active=True):
        user = User.objects.create(username='alen')
        user.set_password('test')
        user.is_active = is_active
        user.save()
        return user
    
    def login(self):
        self.client.login(username='alen', password='test')
        
    def get_counter(self):
        return type('Counter', (object,), {'counter' : 0})()
        
    @mock.patch('oauth2.Client.request')
    def redirect(self, MockRequest):
        MockRequest.side_effect = get_mock_func(self.get_redirect_mock_response)
        response = self.client.post(self.get_redirect_url())
        return response
    
    @mock.patch('oauth2.Client.request')
    def callback(self, MockRequest):
        MockRequest.side_effect = get_mock_func(self.get_callback_mock_response)
        response = self.client.get(self.get_callback_url(), {'oauth_verifier': 'abc'})
        return response
    
    @mock.patch('oauth2.Client.request')
    def setup_callback(self, MockRequest):
        MockRequest.side_effect = get_mock_func(self.get_setup_callback_mock_response)
        response = self.client.get(self.get_setup_callback_url())
        return response
    
    def flow(self):
        self.redirect()
        self.callback()
        return self.setup_callback()
    
    def test_redirect_should_redirect_a_user(self,):
        response = self.redirect()
        self.assertEqual(302, response.status_code, response.content)        
    
    def test_callback_should_redirect_a_user(self):
        self.redirect()
        response = self.callback()
        self.assertEqual(302, response.status_code, response.content)

    def test_setup_callback_should_redirect_a_new_user(self):
        self.redirect()
        self.callback()
        response = self.setup_callback()
        self.assertEqual(302, response.status_code, response.content)
        self.assertEqual(urlparse.urlparse(response['Location']).path, reverse('socialregistration:setup'))
    
    def test_setup_callback_should_redirect_a_logged_in_user(self):
        self.create_user()
        self.login()
        
        self.redirect()
        self.callback()
        response = self.setup_callback()
        self.assertEqual(302, response.status_code, response.content)
        self.assertNotEqual(urlparse.urlparse(response['Location']).path, reverse('socialregistration:setup'))

    def test_connected_user_should_be_logged_in(self):
        user = self.create_user()
        
        self.assertFalse(self.client.session.get('_auth_user_id', False))
        
        self.create_profile(user)

        self.flow()
        
        self.assertEqual(1, self.client.session['_auth_user_id'])
    
    def test_logged_in_user_should_be_connected(self):
        user = self.create_user()
        self.login()
        
        self.assertEqual(0, self.profile.objects.filter(user=user).count())
        
        self.flow()
        
        self.assertEqual(1, self.profile.objects.filter(user=user).count())
    
    def test_only_one_user_can_connect_with_a_provider(self):
        user = self.create_user()
        self.create_profile(user)
        
        other = User.objects.create(username='other')
        other.is_active = True 
        other.set_password('test')
        other.save()
        
        self.client.login(username='other', password='test')
        
        response = self.flow()
        
        self.assertEqual(200, response.status_code, response.content)
        self.assertContains(response, 'This profile is already connected to another user account')
        
    
    def test_logging_in_should_send_the_login_signal(self):
        counter = self.get_counter()
        
        user = self.create_user()
        self.create_profile(user)
        
        def handler(sender, **kwargs):
            counter.counter += 1
            self.assertEqual(self.profile, sender)
            
        login.connect(handler, sender=self.profile, dispatch_uid='socialreg.test.login')
        
        self.flow()
        
        self.assertEqual(1, counter.counter)

    def test_connecting_should_send_the_connect_signal(self):
        counter = self.get_counter()
        
        user = self.create_user()
        self.login()
        
        def handler(sender, **kwargs):
            counter.counter += 1
            self.assertEqual(self.profile, sender)
        
        connect.connect(handler, sender=self.profile, dispatch_uid='socialreg.test.connect')
        
        self.flow()
        
        self.assertEqual(1, counter.counter)
    
    def test_setup_callback_should_indicate_an_inactive_user(self):
        user = self.create_user(is_active=False)
        self.create_profile(user)

        self.redirect()
        self.callback()
        response = self.setup_callback()

        self.assertEqual(200, response.status_code, response.content)
        self.assertContains(response, "inactive", 1)

    def test_setup_callback_should_redirect_an_inactive_user(self):
        settings.LOGIN_INACTIVE_REDIRECT_URL = '/inactive/'

        user = self.create_user(is_active=False)
        self.create_profile(user)

        self.redirect()
        self.callback()
        response = self.setup_callback()

        self.assertEqual(302, response.status_code, response.content)
        self.assertTrue('/inactive/' in response['Location'])

        settings.LOGIN_INACTIVE_REDIRECT_URL = False

class OAuth2Test(OAuthTest):

    def redirect(self):
        response = self.client.post(self.get_redirect_url())
        return response
    
    @mock.patch('socialregistration.clients.oauth.OAuth2.request')
    def callback(self, MockRequest):
        MockRequest.side_effect = get_mock_func(self.get_callback_mock_response)
        response = self.client.get(self.get_callback_url(), {'code': 'abc'})
        return response
    
    @mock.patch('socialregistration.clients.oauth.OAuth2.request')
    def setup_callback(self, MockRequest):
        MockRequest.side_effect = get_mock_func(self.get_setup_callback_mock_response)
        response = self.client.get(self.get_setup_callback_url())
        return response

    
    
class TestContextProcessors(TestCase):
    def test_request_is_in_context(self):
        self.assertTrue('django.core.context_processors.request' in settings.TEMPLATE_CONTEXT_PROCESSORS)


########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from socialregistration.compat.urls import *
from socialregistration.views import Logout, Setup

urlpatterns = patterns('',)

if 'socialregistration.contrib.openid' in settings.INSTALLED_APPS:
    urlpatterns = urlpatterns + patterns('',
        url(r'^openid/', include('socialregistration.contrib.openid.urls',
            namespace='openid')))

if 'socialregistration.contrib.twitter' in settings.INSTALLED_APPS:
    urlpatterns = urlpatterns + patterns('',
        url(r'^twitter/', include('socialregistration.contrib.twitter.urls',
            namespace='twitter')))

if 'socialregistration.contrib.linkedin' in settings.INSTALLED_APPS:
    urlpatterns = urlpatterns + patterns('',
        url(r'^linkedin/', include('socialregistration.contrib.linkedin.urls',
            namespace='linkedin')))

if 'socialregistration.contrib.facebook' in settings.INSTALLED_APPS:
    urlpatterns = urlpatterns + patterns('',
        url(r'^facebook/', include('socialregistration.contrib.facebook.urls',
            namespace='facebook')))

if 'socialregistration.contrib.github' in settings.INSTALLED_APPS:
    urlpatterns = urlpatterns + patterns('',
        url(r'^github/', include('socialregistration.contrib.github.urls',
            namespace='github')))

if 'socialregistration.contrib.foursquare' in settings.INSTALLED_APPS:
    urlpatterns = urlpatterns + patterns('',
        url(r'^foursquare/', include('socialregistration.contrib.foursquare.urls',
            namespace='foursquare')))

if 'socialregistration.contrib.tumblr' in settings.INSTALLED_APPS:
    urlpatterns = urlpatterns + patterns('',
        url(r'^tumblr/', include('socialregistration.contrib.tumblr.urls',
            namespace='tumblr')))
    
if 'socialregistration.contrib.instagram' in settings.INSTALLED_APPS:
    urlpatterns = urlpatterns + patterns('',
        url(r'^instagram/', include('socialregistration.contrib.instagram.urls',
            namespace='instagram')))

if 'socialregistration.contrib.google' in settings.INSTALLED_APPS:
    urlpatterns = urlpatterns + patterns('',
        url(r'^google/', include('socialregistration.contrib.google.urls',
            namespace='google')))

urlpatterns = urlpatterns + patterns('',
    url(r'^setup/$', Setup.as_view(), name='setup'),
    url(r'^logout/$', Logout.as_view(), name='logout'),
)



########NEW FILE########
__FILENAME__ = utils
import uuid

def generate_username(user, profile, client):
    """
    Default function to generate usernames using the built in `uuid` library.
    """
    return str(uuid.uuid4())[:30]

########NEW FILE########
__FILENAME__ = views
from django.conf import settings
from django.contrib.auth import logout
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect
from django.utils.translation import ugettext_lazy as _
from django.views.generic.base import View, TemplateView
from socialregistration.clients.oauth import OAuthError
from socialregistration.contrib.openid.client import OpenIDClient
from socialregistration.mixins import SocialRegistration

import logging
import socket



GENERATE_USERNAME = getattr(settings, 'SOCIALREGISTRATION_GENERATE_USERNAME', False)

USERNAME_FUNCTION = getattr(settings, 'SOCIALREGISTRATION_GENERATE_USERNAME_FUNCTION',
    'socialregistration.utils.generate_username')

FORM_CLASS = getattr(settings, 'SOCIALREGISTRATION_SETUP_FORM',
    'socialregistration.forms.UserForm')

INITAL_DATA_FUNCTION = getattr(settings, 'SOCIALREGISTRATION_INITIAL_DATA_FUNCTION',
    None)

CONTEXT_FUNCTION = getattr(settings, 'SOCIALREGISTRATION_SETUP_CONTEXT_FUNCTION',
    None)

ALLOW_OPENID_SIGNUPS = getattr(settings, 'SOCIALREGISTRATION_ALLOW_OPENID_SIGNUPS',
    True)

logger = logging.getLogger(__name__)

class Setup(SocialRegistration, View):
    """
    Setup view to create new Django users from third party APIs.
    """
    template_name = 'socialregistration/setup.html'

    def get_form(self):
        """
        Return the form to be used. The return form is controlled
        with ``SOCIALREGISTRATION_SETUP_FORM``.
        """
        return self.import_attribute(FORM_CLASS)
    
    def get_username_function(self):
        """
        Return a function that can generate a username. The function
        is controlled with ``SOCIALREGISTRATION_GENERATE_USERNAME_FUNCTION``.
        """
        return self.import_attribute(USERNAME_FUNCTION)
    
    def get_initial_data(self, request, user, profile, client):
        """
        Return initial data for the setup form. The function can be
        controlled with ``SOCIALREGISTRATION_INITIAL_DATA_FUNCTION``.

        :param request: The current request object
        :param user: The unsaved user object
        :param profile: The unsaved profile object
        :param client: The API client
        """
        if INITAL_DATA_FUNCTION:
            func = self.import_attribute(INITAL_DATA_FUNCTION)
            return func(request, user, profile, client)
        return {}

    def get_context(self, request, user, profile, client):
        """
        Return additional context for the setup view. The function can
        be controlled with ``SOCIALREGISTRATION_SETUP_CONTEXT_FUNCTION``.

        :param request: The current request object
        :param user: The unsaved user object
        :param profile: The unsaved profile object
        :param client: The API client
        """
        if CONTEXT_FUNCTION:
            func = self.import_attribute(CONTEXT_FUNCTION)
            return func(request, user, profile, client)
        return {}

    def generate_username_and_redirect(self, request, user, profile, client):
        """
        Generate a username and then redirect the user to the correct place.
        This method is called when ``SOCIALREGISTRATION_GENERATE_USERNAME`` 
        is set. 

        :param request: The current request object
        :param user: The unsaved user object
        :param profile: The unsaved profile object
        :param client: The API client
        """
        func = self.get_username_function()
        
        user.username = func(user, profile, client)
        user.set_unusable_password()
        user.save()
        
        profile.user = user
        profile.save()
        
        user = profile.authenticate()
        
        self.send_connect_signal(request, user, profile, client)
        
        self.login(request, user)
        
        self.send_login_signal(request, user, profile, client)
        
        self.delete_session_data(request)
        
        return HttpResponseRedirect(self.get_next(request))
        
    def get(self, request):
        """
        When signing a new user up - either display a setup form, or
        generate the username automatically.
        """

        if request.user.is_authenticated():
            return HttpResponseRedirect(self.get_next(request))

        try:
            user, profile, client = self.get_session_data(request)
        except KeyError:
            return self.error_to_response(request, dict(
                error=_("Social profile is missing from your session.")))
         
        if GENERATE_USERNAME:
            return self.generate_username_and_redirect(request, user, profile, client)
            
        form = self.get_form()(initial=self.get_initial_data(request, user, profile, client))
        
        additional_context = self.get_context(request, user, profile, client)
        return self.render_to_response(dict({'form': form}, **additional_context))
        
    def post(self, request):
        """
        Save the user and profile, login and send the right signals.
        """

        if request.user.is_authenticated():
            return self.error_to_response(request, dict(
                error=_("You are already logged in.")))

        try:
            user, profile, client = self.get_session_data(request)
        except KeyError:
            return self.error_to_response(request, dict(
                error=_("A social profile is missing from your session.")))
        
        form = self.get_form()(request.POST, request.FILES,
            initial=self.get_initial_data(request, user, profile, client))
        
        if not form.is_valid():
            additional_context = self.get_context(request, user, profile, client)
            return self.render_to_response(dict({'form': form}, **additional_context))
        
        user, profile = form.save(request, user, profile, client)
        
        user = profile.authenticate()
        
        self.send_connect_signal(request, user, profile, client)
        
        self.login(request, user)
        
        self.send_login_signal(request, user, profile, client)
        
        self.delete_session_data(request)
        
        return HttpResponseRedirect(self.get_next(request))


class Logout(View):
    """
    Log the user out of Django. This **does not** log the user out
    of third party sites.
    """
    def get(self, request):
        logout(request)
        url = getattr(settings, 'LOGOUT_REDIRECT_URL', '/')
        return HttpResponseRedirect(url)


class OAuthRedirect(SocialRegistration, View):
    """
    Base class for both OAuth and OAuth2 redirects.

    :param client: The API client class that should be used.
    :param template_name: The error template.
    """
    
    # The OAuth{1,2} client to be used
    client = None
    
    # The template to render in case of errors
    template_name = None
    
    def post(self, request):
        """
        Create a client, store it in the user's session and redirect the user
        to the API provider to authorize our app and permissions.
        """
        request.session['next'] = self.get_next(request)
        client = self.get_client()()
        request.session[self.get_client().get_session_key()] = client
        url = client.get_redirect_url(request=request)
        logger.debug("Redirecting to %s", url)
        try:
            return HttpResponseRedirect(url)
        except OAuthError, error:
            return self.error_to_response(request, {'error': error})
        except socket.timeout:
            return self.error_to_response(request, {'error': 
                _('Could not connect to service (timed out)')})


class OAuthCallback(SocialRegistration, View):
    """
    Base class for OAuth and OAuth2 callback views.

    :param client: The API client class that should be used.
    :param template_name: The error template.
    """
    
    # The OAuth{1,2} client to be used
    client = None
    
    # The template to render in case of errors
    template_name = None
    
    def get_redirect(self):
        """
        Return a URL that will set up the correct models if the 
        OAuth flow succeeded. Subclasses **must** override this
        method.
        """
        raise NotImplementedError
    
    def get(self, request):
        """
        Called after the user is redirected back to our application. 
        Tries to:

        - Complete the OAuth / OAuth2 flow 
        - Redirect the user to another view that deals with login, connecting
          or user creation.

        """
        try:
            client = request.session[self.get_client().get_session_key()]
            logger.debug("API returned: %s", request.GET)            
            client.complete(dict(request.GET.items()))
            request.session[self.get_client().get_session_key()] = client
            return HttpResponseRedirect(self.get_redirect())
        except KeyError:
            return self.error_to_response(request, {'error': "Session expired."})
        except OAuthError, error:
            return self.error_to_response(request, {'error': error})
        except socket.timeout:
            return self.error_to_response(request, {'error':
                _('Could not connect to service (timed out)')})

class SetupCallback(SocialRegistration, TemplateView):
    """
    Base class for OAuth and OAuth2 login / connects / registration.
    """
    template_name = 'socialregistration/setup.error.html'
    
    def get(self, request):
        """
        Called after authorization was granted and the OAuth flow 
        successfully completed. 
        
        Tries to:

        - Connect the remote account if the user is logged in already
        - Log the user in if a local profile of the remote account 
          exists already
        - Create a user and profile object if none of the above succeed
          and redirect the user further to either capture some data via
          form or generate a username automatically
        """
        
        try:
            client = request.session[self.get_client().get_session_key()]
        except KeyError:
            return self.error_to_response(request, {'error': "Session expired."})
        
        # Get the lookup dictionary to find the user's profile
        lookup_kwargs = self.get_lookup_kwargs(request, client)

        # Logged in user (re-)connecting an account
        if request.user.is_authenticated():
            try:
                profile = self.get_profile(**lookup_kwargs)
                
                # Make sure that there is only *one* account per profile.                
                if not profile.user == request.user:
                    self.delete_session_data(request)
                    return self.error_to_response(request, {
                        'error': _('This profile is already connected to another user account.')
                    })
                
            except self.get_model().DoesNotExist: 
                profile, created = self.get_or_create_profile(request.user,
                    save=True, **lookup_kwargs) 

            self.send_connect_signal(request, request.user, profile, client)

            return self.redirect(request)

        # Logged out user - let's see if we've got the identity saved already.
        # If so - just log the user in. If not, create profile and redirect
        # to the setup view 
        
        user = self.authenticate(**lookup_kwargs)
        
        # No user existing - create a new one and redirect to the final setup view
        if user is None:
            if not ALLOW_OPENID_SIGNUPS and self.client is OpenIDClient:
                return self.error_to_response(request, {
                    'error': _('We are not currently accepting new OpenID signups.')
                })
            user = self.create_user()
            profile = self.create_profile(user, **lookup_kwargs)
            
            self.store_user(request, user)
            self.store_profile(request, profile)
            self.store_client(request, client)
            
            return HttpResponseRedirect(reverse('socialregistration:setup'))

        # Inactive user - displaying / redirect to the appropriate place.
        if not user.is_active:
            return self.inactive_response(request)
        
        # Active user with existing profile: login, send signal and redirect
        self.login(request, user)
        
        profile = self.get_profile(user=user, **lookup_kwargs)
        
        self.send_login_signal(request, user, profile, client)
        
        return self.redirect(request)

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)

########NEW FILE########
__FILENAME__ = views
from django.http import HttpResponseRedirect
from django.shortcuts import render_to_response
from django.template import RequestContext
from socialregistration.contrib.facebook.models import FacebookProfile
from socialregistration.contrib.foursquare.models import FoursquareProfile
from socialregistration.contrib.github.models import GithubProfile
from socialregistration.contrib.instagram.models import InstagramProfile
from socialregistration.contrib.linkedin.models import LinkedInProfile
from socialregistration.contrib.openid.models import OpenIDProfile
from socialregistration.contrib.tumblr.models import TumblrProfile
from socialregistration.contrib.twitter.models import TwitterProfile

def index(request):
    return render_to_response(
        'index.html', dict(
            facebook=FacebookProfile.objects.all(),
            twitter=TwitterProfile.objects.all(),
            openid=OpenIDProfile.objects.all(),
            linkedin=LinkedInProfile.objects.all(),
            github=GithubProfile.objects.all(),
            foursquare=FoursquareProfile.objects.all(),
            tumblr=TumblrProfile.objects.all(),
            instagram=InstagramProfile.objects.all(),
    ), context_instance=RequestContext(request))
    

########NEW FILE########
__FILENAME__ = settings
# Django settings for example project.

import os

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    ('Tester', 'test@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': '%s/db.sqlite' % os.path.dirname(__file__), # Or path to database file if using sqlite3.
        'USER': '', # Not used with sqlite3.
        'PASSWORD': '', # Not used with sqlite3.
        'HOST': '', # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '', # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'Europe/London'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-gb'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = '%s/media/' % os.path.dirname(__file__)

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = '/media/'

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = '%s/static/' % os.path.dirname(__file__)

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# URL prefix for admin static files -- CSS, JavaScript and images.
# Make sure to use a trailing slash.
# Examples: "http://foo.com/static/admin/", "/static/admin/".
ADMIN_MEDIA_PREFIX = '/static/admin/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = '^@qj2z043lalviucgjjf7sl440^@)u7b^q^h^ik(t@-exze96h'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

ROOT_URLCONF = 'tests.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    '%s/templates' % os.path.dirname(__file__)
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.admin',
    'socialregistration',
    'socialregistration.contrib.facebook',
    'socialregistration.contrib.foursquare',
    'socialregistration.contrib.github',
    'socialregistration.contrib.instagram',
    'socialregistration.contrib.linkedin',
    'socialregistration.contrib.tumblr',
    'socialregistration.contrib.twitter',
    'socialregistration.contrib.openid',
    'tests.app',
)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}


# Socialregistration specific settings - including extended settings

AUTHENTICATION_BACKENDS = (
    'django.contrib.auth.backends.ModelBackend',
    'socialregistration.contrib.openid.auth.OpenIDAuth',
    'socialregistration.contrib.twitter.auth.TwitterAuth',
    'socialregistration.contrib.linkedin.auth.LinkedInAuth',
    'socialregistration.contrib.github.auth.GithubAuth',
    'socialregistration.contrib.facebook.auth.FacebookAuth',
    'socialregistration.contrib.foursquare.auth.FoursquareAuth',
    'socialregistration.contrib.tumblr.auth.TumblrAuth',
    'socialregistration.contrib.instagram.auth.InstagramAuth',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'socialregistration.contrib.facebook.middleware.FacebookMiddleware',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    "django.core.context_processors.static",
    "django.contrib.messages.context_processors.messages",
    "django.core.context_processors.request",
)

# Add your Facebook API keys here
FACEBOOK_APP_ID = ''
FACEBOOK_SECRET_KEY = ''
FACEBOOK_REQUEST_PERMISSIONS = ''

# Add your Twitter API keys here
TWITTER_CONSUMER_KEY = ''
TWITTER_CONSUMER_SECRET_KEY = ''

# Add your LinkedIn API keys here
LINKEDIN_CONSUMER_KEY = ''
LINKEDIN_CONSUMER_SECRET_KEY = ''

# Add your Github API keys here
GITHUB_CLIENT_ID = ''
GITHUB_CLIENT_SECRET = ''
GITHUB_REQUEST_PERMISSIONS = ''

# Add your Foursquare API keys here
FOURSQUARE_CLIENT_ID = ''
FOURSQUARE_CLIENT_SECRET = ''
FOURSQUARE_REQUEST_PERMISSIONS = ''

# Add your Tumblr API keys here
TUMBLR_CONSUMER_KEY = ''
TUMBLR_CONSUMER_SECRET_KEY = ''

# Add your Instagram API keys here
INSTAGRAM_CLIENT_ID = ''
INSTAGRAM_CLIENT_SECRET = ''
INSTAGRAM_REQUEST_PERMISSIONS = 'basic'


SOCIALREGISTRATION_USE_HTTPS = False
SOCIALREGISTRATION_GENERATE_USERNAME = False


LOGIN_REDIRECT_URL = '/'


########NEW FILE########
__FILENAME__ = urls
from socialregistration.compat.urls import *
from django.contrib import admin


admin.autodiscover()

urlpatterns = patterns('',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^social/', include('socialregistration.urls', namespace='socialregistration')),
    url(r'^$', 'tests.app.views.index', name='index'),
)

########NEW FILE########
