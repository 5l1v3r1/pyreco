__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# simpleapi documentation build configuration file, created by
# sphinx-quickstart on Wed Apr 21 21:02:02 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo', 'sphinx.ext.coverage', 
    'sphinx.ext.graphviz']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'simpleapi'
copyright = u'2010, Florian Schlachter'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.

import simpleapi
version = simpleapi.get_version()
# The full version, including alpha/beta/rc tags.
release = simpleapi.get_version()

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_theme']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'simpleapidoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'simpleapi.tex', u'simpleapi Documentation',
   u'Florian Schlachter', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = testclient
# -*- coding: utf-8 -*-

import sys
sys.path.append("../../../../")

from simpleapi.client import Client, RemoteException

calculator = Client(ns='http://localhost:5000/api/',
                    transport_type='xml', timeout=60)

print "5 + 5 =", calculator.add(a=5, b=16)
########NEW FILE########
__FILENAME__ = formatters
try:
    import json
except ImportError:
    import simplejson as json

from simpleapi.message import formatters, Formatter, PythonToXML

from message import Message

class JSONFormatter(Formatter):
    __mime__ = "application/json"

    def build(self, value):
        if not isinstance(value, Message):
            raise TypeError('You MUST use a Message to build your response')
        return value.to_json(as_dict=False)

    def kwargs(self, value, action='build'):
        if action == 'build':
            return json.dumps(value)
        elif action == 'parse':
            return json.loads(value)

    def parse(self, value):
        return Message.parse_json(value)

class JSONPFormatter(Formatter):
    __mime__ = "application/javascript"

    def build(self, value):
        if not isinstance(value, Message):
            raise TypeError('You MUST use a Message to build your response')

        func = self.callback or 'simpleapiCallback'
        return u'%(func)s(%(data)s)' % {'func': func,
                                        'data': value.to_json(as_dict=False)}

    def kwargs(self, value, action='build'):
        if action == 'build':
            return json.dumps(value)
        elif action == 'parse':
            return json.loads(value)

    def parse(self, value):
        return Message.parse_json(value)

class XMLFormatter(Formatter):
    __mime__ = "application/xml"

    def build(self, value):
        if not isinstance(value, Message):
            raise TypeError('You MUST use a Message to build your response')

        return value.to_xml()

    def kwargs(self, value, action='build'):
        if action == 'build':
            return PythonToXML().build(value)
        elif action == 'parse':
            return PythonToXML().parse(value)

    def parse(self, value):
        return Message.parse_xml(value)

formatters.register('json', JSONFormatter, override=True)
formatters.register('jsonp', JSONPFormatter, override=True)
formatters.register('xml', XMLFormatter, override=True)
########NEW FILE########
__FILENAME__ = message
#This is common between the client & server
__all__ = ['MessageElement', 'Message', 'BaseMessage']

import string, sys, re, json
from xml.etree import cElementTree as ET

def _validate_element(el):
    if not isinstance(el, MessageElement):
        raise TypeError("element must be a MessageElement")

class BaseMessage(dict):
    pass

class MessageElement(BaseMessage):
    """
    MessageElement class. This is used for all items to be sent across
    the network and is wrapped in a Message before being sent across
    So you should only ever be working with this class directly

    @public attributes
        tag
            The primary identifier for the element.
        text
            Any text contents of this message
        children
            Is a readonly list of the children of this element
            Though this is a list modifying it directly to it will
            have no effect on the actual children
        parent
            Is a readonly attribute that holds the parent of this element
            If you append this element to another the parent is reset
        root
            Is a readonly attribute containing the root element that this
            element belongs to. If this is the root element it will return
            itself
    """
    _tag = None
    _text = None
    _parent = None
    _root = None
    _children = None

    def __init__(self, tag, text=None, **kwargs):
        """
        Generate the MessageElement

        @param tag Is the elements tag, which is the primary identifier
        @param text The text contents of this element
        @param **kwargs Is a key, value set of attributes for this element

        @usage;
            MessageElement('example')
            MessageElement('example', 'some text contents')
            MessageElement('example', 'some text contents', attr1=1, ...)
        """
        super(MessageElement, self).__init__(**kwargs)
        self.tag = tag
        self._root = self
        self._children = list()
        if text:
            self.text = text

    def __repr__(self):
        return "<MessageElement(%(tag)s) at 0x%(id)x}>" % {'tag': self.tag,
                                                           'id' : id(self)}

    def __len__(self):
        """
        Returns the number of children

        @return the number of children
        """
        return len(self._children)

    def __getattr__(self, attr):
        """
        Gets an element attribute.

        @return The attribute value, or None
        """
        return self.get(attr, None)

    def __setattr__(self, attr, value):
        """
        Sets an element attribute.
        """
        if attr not in ['_tag', 'tag', '_text', 'text', '_parent', 'parent',
                 '_root', 'root', '_children', 'children']:
            super(MessageElement, self).__setitem__(attr, value)
        else:
            super(MessageElement, self).__setattr__(attr, value)

    def __getitem__(self, index):
        """
        Returns the given subelement.

        @param index What subelement to return.
        @return The given subelement.
        @exception IndexError If the given element does not exist.
        """
        return self._children[index]

    def __setitem__(self, index, element):
        """
        Replaces the given subelement.

        @param index What subelement to replace.
        @param element The new element value.
        @exception IndexError If the given element does not exist.
        @exception TypeError If element is not a valid object.
        """
        _validate_element(element)
        element._adjust_parent_root(self, self.root)
        self._children[index] = element

    def __delitem__(self, index):
        """
        Deletes the given subelement.

        @param index What subelement to delete.
        @exception IndexError If the given element does not exist.
        """
        del self._children[index]

    def __getslice__(self, start, stop):
        """
        Returns a list containing subelements in the given range.

        @param start The first subelement to return.
        @param stop The first subelement that shouldn't be returned.
        @return A sequence object containing subelements.
        """
        return self._children[start:stop]

    def __setslice__(self, start, stop, elements):
        """
        Replaces a number of subelements with elements from a sequence.

        @param start The first subelement to replace.
        @param stop The first subelement that shouldn't be replaced.
        @param elements A sequence object with zero or more elements.
        @exception TypeError If a sequence member is not a valid object.
        """
        for element in elements:
            _validate_element(element)
            element._adjust_parent_root(self, self.root)
        self._children[start:stop] = list(elements)

    def __delslice__(self, start, stop):
        """
        Deletes a number of subelements.

        @param start The first subelement to delete.
        @param stop The first subelement to leave in there.
        """
        del self._children[start:stop]

    def _adjust_parent_root(self, parent, root):
        self._parent = parent
        self._root = root
        for child in self._children:
            child._adjust_parent_root(self, root)

    def to_json(self, as_dict=True):
        _ = {u'tag': self.tag,
             u'attrs': dict(self.iteritems()),
             u'text': self.text,
             u'children': [child.to_json() for child in self._children]}

        if as_dict:
            return _

        return json.dumps(_, ensure_ascii=False)

    def to_xml(self):
        e = ET.Element(self.tag)
        e.text = self.text

        for attr, value in self.iteritems():
            if not isinstance(value, basestring):
                value = str(value)
            e.set(attr, value)

        for child in self._children:
            child_el = child.to_xml()
            e.append(child_el)

        return e

    def append(self, element):
        """
        Adds a subelement to the end of this element.

        @param element The element to add.
        @exception TypeError If the element is not a valid object.
        """
        _validate_element(element)
        element._adjust_parent_root(self, self.root)
        self._children.append(element)

    def insert(self, index, element):
        """
        Inserts a subelement at the given position in this element.

        @param index Where to insert the new subelement.
        @exception TypeError If the element is not a valid object.
        """
        _validate_element(element)
        element._adjust_parent_root(self, self.root)
        self._children.insert(index, element)

    def remove(self, element):
        """
        Removes a matching subelement.  Unlike the <b>find</b> methods,
        this method compares elements based on identity, not on tag
        value or contents.

        @param element What element to remove.
        @exception ValueError If a matching element could not be found.
        @exception TypeError If the element is not a valid object.
        """
        _validate_element(element)
        element._adjust_parent_root(None, element)
        self._children.remove(element)

    def clear(self):
        """
        Resets an element.  This function removes all subelements, clears
        all attributes, and sets the text attribute to None.
        """
        super(MessageElement, self).clear()
        self._children = []
        self.text = None

    def set(self, key, value):
        """
        Sets an element attribute.

        @param key What attribute to set.
        @param value The attribute value.
        """
        self.__setattr__(key, value)

    def find(self, tag):
        """
        Finds the first matching subelement, by tag name.

        @param tag What element to look for.
        @return The first matching element, or None if no element was found.
        @defreturn MessageElement or None
        """
        for child in self._children:
            if child.tag == tag:
                return child

        return None

    def iter_find(self, tag):
        """
        Finds the first matching subelement, by tag name.
        Does so recursivly

        @param tag What element to look for.
        @return The first matching element, or None if no element was found.
        @defreturn MessageElement or None
        """
        for child in self._children:
            if child.tag == tag:
                return child
            check = child.iterfind(tag)
            if check is not None:
                return check

        return None

    def findtext(self, tag, default=""):
        """
        Finds text for the first matching subelement, by tag name.

        @param tag What element to look for.
        @param default What to return if the element was not found.
        @return The text content of the first matching element, or the
            default value no element was found.  Note that if the element
            has is found, but has no text content, this method returns an
            empty string.
        @defreturn string
        """
        el = self.find(tag)
        if el is not None:
            if not el.text:
                return default
            return el.text

        return None

    def iter_findtext(self, tag, default=""):
        """
        Finds text for the first matching subelement, by tag name.
        Does so recursivly

        @param tag What element to look for.
        @param default What to return if the element was not found.
        @return The text content of the first matching element, or the
            default value no element was found.  Note that if the element
            has is found, but has no text content, this method returns an
            empty string.
        @defreturn string
        """
        el = self.iterfind(tag)
        if el is not None:
            if not el.text:
                return default
            return el.text

        return None

    def findall(self, tag):
        """
        Finds all matching elements, by tag name.

        @param tag What element to look for.
        @return A list or iterator containing all matching elements,
           in document order.
        @defreturn list of Element instances
        """
        found = []
        for child in self.children:
            if child.tag == tag:
                found.append(child)
            found.extend(child.findall(tag))
        return found

    def getiterator(self, tag=None):
        """
        Creates a tree iterator.  The iterator loops over this element
        and all subelements, in document order, and returns all elements
        with a matching tag.

        If the tree structure is modified during iteration, the result
        is undefined.

        @param tag What tags to look for (default is to return all elements).
        @return A list or iterator containing all the matching elements.
        @defreturn list or iterator
        """
        if tag == "*" or tag is None or self.tag == tag:
            yield self

        for node in self._children:
            for item in node.getiterator(tag):
                yield item

    @classmethod
    def parse_json(cls, source):
        """
        Parse the source and turn it into a proper MessageElement

        @param source A string or dict
        @return The MessageElement
        @defreturn MessageElement
        """
        if isinstance(source, basestring):
            source = json.loads(source, encoding='utf-8')

        el = cls(source['tag'], **source.get('attrs', {}))
        if source.get('text'):
            el.text = source['text']

        for child in source.get('children', []):
            el.append(cls.parse_json(child))

        return el

    @classmethod
    def parse_xml(cls, source):
        """
        Parses a xml String into a MessageElement

        @param source A json string.
        @return The MessageElement.
        @defreturn MessageElement
        """
        if isinstance(source, basestring):
            source = ET.fromstring(source)

        el = cls(source.tag, **source.attrib)
        if source.text:
            el.text = source.text

        children = source.getchildren()
        for child in children:
            el.append(cls.parse_xml(child))

        return el

    #Properties
    def _get_tag(self):
        return self._tag
    def _set_tag(self, value):
        if not isinstance(value, basestring):
            raise TypeError("tag must be a string")

        self._tag = value
    tag = property(_get_tag, _set_tag, doc="The MessageElement tag")

    def _get_text(self):
        return self._text
    def _set_text(self, value):
        if not isinstance(value, basestring):
            raise TypeError("text must be a string")

        self._text = value
    def _del_text(self):
        self._text = None
    text = property(_get_text, _set_text, _del_text,
                    doc="The MessageElement text")

    def _get_children(self):
        if self._children is None:
            self._children = []
        return list(self._children)
    children = property(_get_children, None, doc="The MessageElements children")

    def _get_parent(self):
        return self._parent
    def _del_parent(self):
        self._parent = None
    parent = property(_get_parent, None, _del_parent,
                      doc="The MessageElements parent")

    def _get_root(self):
        return self._root
    def _del_root(self):
        self._root = self
    root = property(_get_root, None, _del_root,
                    doc="The MessageElements root")

class Message(BaseMessage):
    """
    Message wrapper class.  This class represents an entire message
    hierarchy, and adds some extra support for serialization to and from
    standard json.

    @param element Optional root element.
    """
    _root = None
    _errors = None
    _text = None

    def __init__(self, element=None, **kwargs):
        super(Message, self).__init__(**kwargs)

        self._errors = list()

        if element is not None:
            _validate_element(element)
            self._root = element

    def __getattr__(self, attr):
        """
        Gets an element attribute.

        @return The attribute value, or None
        """
        return self.get(attr, None)

    def __setattr__(self, attr, value):
        """
        Sets an element attribute.
        """
        if attr not in ['_text', 'text', '_root', 'root', '_errors', 'errors']:
            super(Message, self).__setitem__(attr, value)
        else:
            super(Message, self).__setattr__(attr, value)

    def __repr__(self):
        return '<Message at 0x%x>' % id(self)


    def to_json(self, as_dict=True):
        _ = {u'simpleapi': 'response',
             u'error': True if self._errors else False,
             u'errors': tuple(self.errors),
             u'attrs': dict(self.iteritems()),
             u'text': self.text,
             u'root': self.root.to_json() if self.root else None}

        if as_dict:
            return _

        return json.dumps(_, ensure_ascii=False)

    def to_xml(self):
        e = ET.Element('response')
        for attr, value in self.iteritems():
            if not isinstance(value, basestring):
                value = str(value)
            e.set(attr, value)
        e.text = self._text

        if self.errors:
            errs = ET.Element('errors')
            for error in self.errors:
                err = ET.Element('error')
                err.text = error
                errs.append(err)
            e.append(errs)

        if self._root:
            root_el = self._root.to_xml()
            e.append(root_el)

        return ET.tostring(e)

    def clear(self):
        """
        Resets an element.  This function removes all subelements, clears
        all attributes, and sets the text attribute to None.
        """
        super(Message, self).clear()
        self._errors = list()
        self.text = None
        self._root = None

    def get(self, attr, default=None):
        if attr == 'result':
            return self
        elif attr == 'errors':
            return self.errors

        return super(Message, self).get(attr, default)

    def set(self, key, value):
        """
        Sets an element attribute.

        @param key What attribute to set.
        @param value The attribute value.
        """
        self.__setattr__(key, value)

    def add_error(self, message):
        self._errors.append(message)

    def getiterator(self, tag=None):
        """
        Creates a tree iterator for the root element.  The iterator loops
        over all elements in this tree, in document order.

        @param tag What tags to look for (default is to return all elements)
        @return An iterator.
        @defreturn iterator
        """
        if self._root is not None:
            for item in self._root.getiterator(tag):
                yield item

    def find(self, tag):
        """
        Finds the first toplevel element with given tag.
        Same as root.find(tag).

        @param tag What element to look for.
        @return The first matching element, or None if no element was found.
        @defreturn MessageElement or None
        """
        if self._root is None:
            return

        return self._root.find(tag)

    def iter_find(self, tag):
        """
        Finds the first toplevel element with given tag.
        Same as getroot().find(tag).

        @param tag What element to look for.
        @return The first matching element, or None if no element was found.
        @defreturn MessageElement or None
        """
        if self._root is None:
            return

        return self._root.iter_find(tag)

    def findtext(self, tag, default=None):
        """
        Finds the element text for the first toplevel element with given
        tag.  Same as root.findtext(tag).

        @param tag What toplevel element to look for.
        @param default What to return if the element was not found.
        @return The text content of the first matching element, or the
            default value no element was found.  Note that if the element
            has is found, but has no text content, this method returns an
            empty string.
        @defreturn string
        """
        if self._root is None:
            return

        return self._root.findtext(tag, default)

    def iter_findtext(self, tag, default=None):
        """
        Finds the element text for the first toplevel element with given
        tag.  Same as root.findtext(tag).

        @param tag What toplevel element to look for.
        @param default What to return if the element was not found.
        @return The text content of the first matching element, or the
            default value no element was found.  Note that if the element
            has is found, but has no text content, this method returns an
            empty string.
        @defreturn string
        """
        if self._root is None:
            return

        return self._root.iter_findtext(tag, default)

    def findall(self, tag):
        """
        Finds all toplevel elements with the given tag.
        Same as root.findall(tag).

        @param tag What element to look for.
        @return A list or iterator containing all matching elements,
           in document order.
        @defreturn list of MessageElement instances
        """
        if self._root is None:
            return []

        return self._root.findall(tag)

    @classmethod
    def parse_json(cls, source):
        """
        Parses a json String into a Message

        @param source A json string.
        @return The Message.
        @defreturn Message
        """
        if isinstance(source, basestring):
            source = json.loads(source, encoding='utf-8')

        if source.get('root'):
            ret = cls(MessageElement.parse_json(source['root']),
                      **source.get('attrs', {}))
        else:
            ret = cls(**source.get('attrs', {}))

        if source.get('text'):
            ret.text = source['text']

        for error in source.get('errors', []):
            ret.add_error(error)

        for attr, value in source.get('attrs', {}).iteritems():
            ret.set(attr, value)

        return ret

    @classmethod
    def parse_xml(cls, source):
        """
        Parses a xml String into a Message

        @param source A json string.
        @return The Message.
        @defreturn Message
        """
        if isinstance(source, basestring):
            source = ET.fromstring(source)

        if source.tag != 'response':
            raise TypeError('Message does not know how to decode this')

        ret = cls()

        for attr, value in source.attrib.iteritems():
            ret.set(attr, value)

        for err in source.findall('error'):
            ret.add_error(err.text)
            source.remove(err)

        for errs in source.findall('errors'):
            source.remove(errs)

        children = source.getchildren()
        child = children[0] if len(children) else None
        if child is not None:
            c = MessageElement.parse_xml(child)
            ret._root = c

        return ret

    #Properties
    def _get_root(self):
        return self._root
    root = property(_get_root, None, doc="The root MessageElement or None")

    def _get_text(self):
        return self._text
    def _set_text(self, value):
        if not isinstance(value, basestring):
            raise TypeError("text must be a string")

        self._text = value
    def _del_text(self):
        self._text = None
    text = property(_get_text, _set_text, _del_text,
                    doc="The text contents of this message")

    def _get_errors(self):
        if self._errors is None:
            self._errors = list()
        return list(self._errors)
    errors = property(_get_errors)

    def _get_has_errors(self):
        return True if self._errors else False
    has_errors = property(_get_has_errors)

########NEW FILE########
__FILENAME__ = wrappers
from simpleapi import wrappers, DefaultWrapper

from message import Message

class MessageWrapper(DefaultWrapper):
    def build(self, result, errors):
        if not isinstance(result, Message):
            result = Message(result)

        if errors:
            result.success = False
        else:
            result.success = True

        result._errors = errors
        return result
wrappers.register('message', MessageWrapper)

########NEW FILE########
__FILENAME__ = testclient
# -*- coding: utf-8 -*-

import time

import sys
sys.path.append("/Users/flosch/devlibs/3rdparty/")

from simpleapi.client import Client, RemoteException

calculator = Client(ns='http://localhost:8888/api/calculator/multiple/',
                    access_key="91d9f7763572c7ebcce49b183454aeb0",
                    transport_type='xml', timeout=60)

print "(v2) 5 + 5 =", calculator.add(a=5, b=5)

# change api version to 1
calculator.set_version(1)
print "(v1) 5 + 5 =", calculator.add(a=5, b=5)

print "5 * 5 =", calculator.multiply(a=5, b=5)

# change namespace from multiple versions to Route with only one version
calculator.set_ns('http://localhost:8888/api/calculator/one/')
print "5 ** 5 =", calculator.power(a=5, b=5)

print "This call sums up a list of arguments:", calculator.sum_up(a=1, b=5, c=99, d=1895, e=1895.12, f=8925.125)
print "This call fails due to constraints:", 
try:
    calculator.sum_up(a=1, b=5, c=99, d=1895, e=1895.12, f='abc')
except RemoteException, e:
    print unicode(e)

access_keys = calculator.get_access_keys()
print "Access keys:", access_keys[0], access_keys[1], access_keys[0] == access_keys[1] 

some_functions = Client(ns='http://localhost:8888/api/functions/', transport_type='pickle')

print
print "Function will delay 3 seconds."
print some_functions.delayed_function(a=5, b=6)
print
print "Function will NOT delay 3 seconds (because it's cached):"
print some_functions.delayed_function(a=5, b=6)
print

print "Function will delay 3 seconds (because it's NOT cached):"
print some_functions.delayed_function(a=5, b=6, c=1)
print

print "Client's ip address:", some_functions.get_remote_ip()

print "This call should fail due to regex-constraints: ", 
try:
    some_functions.regex_constraint(value='abcdef')
except RemoteException, e:
    print unicode(e)

print "This call should NOT fail due to regex-constraints: ", some_functions.regex_constraint(value='16548-abc')

# works only with simpleapi's python client because it's using cPickle functionality. JSON doesn't support to serialize date objects
print "Today's datetime:", some_functions.today()

print "Add a day, remotely by passing a datetime object to the function:", some_functions.add_a_day(dt=some_functions.today())

print "Finally, this method call fails:", 
try:
    some_functions.fail()
except RemoteException, e:
    print unicode(e)

json_functions = Client(ns='http://localhost:8888/api/misc/')

print json_functions.return_my_value(val={1:2, 5:6, 'test': 'hehe'})

print
print
print "Testing throttling... (calling until we get an exception)"
print 
stime = time.time()
count = 0
while True:
    try:
        some_functions.throttled_function()
        count += 1
    except RemoteException, e:
        etime = time.time()
        count = float(count)
        print "- Stopped, remote error message:", e
        ttime = etime-stime
        print "  performed secs: %.2fs" % ttime
        print "  performed #/sec:", int(count/ttime)
        break

print "Done."
print
########NEW FILE########
__FILENAME__ = testclient2
import sys
import os
root = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                    '../../../'))
sys.path.append(root)

from sapi import formatters, wrappers

from simpleapi import Client

def run(output='json'):
    example = Client(ns='http://127.0.0.1:8888/api/example/', version=1,
                     transport_type=output, wrapper_type='message')

    #messages should be a Message object, which is models after ElementTree
    messages = example.test(username=u'Digitalxero')

    print "Messages for:", messages.to
    for msg in messages.findall('message'):
        print "    Message From:", msg.get('from')
        print "        ", msg.text

print "Using JSON"
run()
print
print "Using XML"
run('xml')


########NEW FILE########
__FILENAME__ = testclient3
# -*- coding: utf-8 -*-

import sys
import os
root = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                    '../../../'))
sys.path.append(root)

from simpleapi import Client

client = Client(ns='http://localhost:8888/api/', transport_type='json')

print "Creating new contact..."
print client.new(name=u'Florian Müller', phone='+49 555 444')
print
print "Creating another contact..."
print client.new(name=u'Florian Maier', phone='+49 555 444', fax='+48 444 555')
print
print "Searching for 'Florian'..."
search_result = client.search(pattern='Florian')
print " - Found %s results" % search_result['count']
if search_result['count'] > 4:
    print "(Showing only the first 4 items)"
print

print "First item is:", search_result['first_item']
print

print "Second item is:", search_result['second_item']
print

for search_item in search_result['items'][:4]:
    print u"Found: %(name)s (phone: %(phone)s, fax: %(fax)s)" % search_item
########NEW FILE########
__FILENAME__ = testclient4
# -*- coding: utf-8 -*-

import sys
import os
root = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                    '../../../'))
sys.path.append(root)

from simpleapi import Client

client = Client(ns='http://localhost:8888/api/', transport_type='xml')

print "Creating new contact..."
print client.new(name=u'Florian Müller', phone='+49 555 444')
print
print "Creating another contact..."
print client.new(name=u'Florian Maier', phone='+49 555 444', fax='+48 444 555')
print
print "Searching for 'Florian'..."
search_result = client.search(pattern='Florian')
print " - Found %s results" % search_result['count']
if search_result['count'] > 4:
    print "(Showing only the first 4 items)"
print

print "First item is:", search_result['first_item']
print

print "Second item is:", search_result['second_item']
print

for search_item in search_result['items'][:4]:
    print u"Found: %(name)s (phone: %(phone)s, fax: %(fax)s)" % search_item
########NEW FILE########
__FILENAME__ = app
import sys
import os
import time

root = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                    '../../../'))
sys.path.append(root)

from simpleapi import Route, DummyClient, RemoteException
from handlers import MyAPI

client = DummyClient(Route(MyAPI, framework='dummy'))
for i in xrange(5):
    try:
        print len(client.download(url="http://www.pizzabus.de"))
    except RemoteException, e:
        print "Failure during request:", e
        time.sleep(.5)
########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

import time
import urllib

from simpleapi import Namespace

class MyAPI(Namespace):
    __authentication__ = 'auth_access'

    def auth_access(self, access_key):
        if (int(time.time()) % 2) == 0:
            self.error(u'No access - no no!')
        return True

    def download(self, url):
        return urllib.urlopen(url).read()
    download.published = True
########NEW FILE########
__FILENAME__ = app
import sys
import os

root = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                    '../../../'))
sys.path.append(root)

from simpleapi import Route, DummyClient, RemoteException
from handlers import MyAPI

client = DummyClient(Route(MyAPI, framework='dummy', debug=True))
try:
    client.add_one(a=1, b=5)
except RemoteException, e:
    print "Exception raised:", e
client.download(url="http://www.pizzabus.de")
########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

import urllib

from simpleapi import Namespace

class MyAPI(Namespace):
    def add_one(self, a, b):
        # Raises an error since c doesn't exist (thanks to debug=True in the
        # Route configuration the python debugger will came up for debugging)
        a = c + 1
        return a + b
    add_one.published = True
    add_one.constraints = lambda ns, key, val: int(val)

    def download(self, url):
        return urllib.urlopen(url).read()
    download.published = True
########NEW FILE########
__FILENAME__ = app
import sys
import os
os.environ['SIMPLEAPI_DEBUG'] = '1' # activate simpleapi-wide debug
os.environ['SIMPLEAPI_DEBUG_LEVEL'] = 'call' # either call (for profiling every call) or all (for profiling all calls accumulated)

root = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                    '../../../'))
sys.path.append(root)

from simpleapi import Route, DummyClient, RemoteException
from handlers import MyAPI

client = DummyClient(Route(MyAPI, framework='dummy'))
for i in xrange(3):
    client.add_one(a=1, b=5)
########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

import urllib

from simpleapi import Namespace

class MyAPI(Namespace):
    def add_one(self, a, b):
        a = a + 1
        return a + b
    add_one.published = True
    add_one.constraints = lambda ns, key, val: int(val)

    def download(self, url):
        return urllib.urlopen(url).read()
    download.published = True
########NEW FILE########
__FILENAME__ = app
import sys
import os

root = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                    '../../../'))
sys.path.append(root)

from simpleapi import Route, DummyClient, RemoteException
from handlers import MyAPI

"""
Let's assume we want access our in-app API. This is what DummyClient is for.
"""

client = DummyClient(Route(MyAPI, framework='dummy'),
                     access_key='secret key')
print "5 + 2 =", client.add(a=5, b=2)
try:
    print client.test()
except RemoteException, e:
    print "Remote exception raised:", unicode(e)
########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

from simpleapi import Namespace

class MyAPI(Namespace):
    __authentication__ = lambda ns, key: key == "secret key"
    
    def add(self, a, b):
        return a + b
    add.published = True
    add.constraints = lambda ns, key, value: int(value)

    def test(self):
        self.error(u'This is an exception.')
    test.published = True
########NEW FILE########
__FILENAME__ = app
from mongoengine import connect
import sys
import os
import time

connect('simpleapitest')

root = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                    '../../../'))
sys.path.append(root)

from simpleapi import Route, DummyClient, RemoteException
from handlers import MyAPI

client = DummyClient(Route(MyAPI, framework='dummy'))
print "Add?", client.add()
print "Get?", client.get()
########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

import time
import urllib

from simpleapi import Namespace, serialize

from models import *

class MyAPI(Namespace):
    def add(self):
        schema = [TestItem2(name='field1', type='string'),
            TestItem2(name='field2', type='string') ]

        info = InfoDoc(title='testtitel', owner='myTitle')
        m = Table(info=info, schema=schema)
        m.save()
        return m
    add.published = True

    def get(self):
        t = Table.objects[Table.objects.count()-1]
        return t.info
    get.published = True
########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

from datetime import datetime
from mongoengine import *

class TestItem2(EmbeddedDocument):
    name = StringField()
    type = StringField()
    typespecific = DictField(default={})
 
class Entry(EmbeddedDocument):
    created = DateTimeField(default=datetime.now())
 
class StringEntry(Entry):
    value = StringField()
 
class InfoDoc(EmbeddedDocument):
    title = StringField()
    created = DateTimeField(default=datetime.now())

class Table(Document):
    info    = EmbeddedDocumentField(InfoDoc)
    schema  = ListField(EmbeddedDocumentField(TestItem2))
    entries = ListField(EmbeddedDocumentField(Entry))

########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

from simpleapi import Namespace

class MyAPI(Namespace):
    def add(self, a, b):
        return a + b
    add.published = True
    add.constraints = lambda ns, key, value: int(value)

    def get_method(self):
        return self.session.request.method
    get_method.published = True
########NEW FILE########
__FILENAME__ = main
#!/usr/bin/env python

from google.appengine.ext import webapp
from google.appengine.ext.webapp import util

from simpleapi import Route
from handlers import MyAPI

def main():
    application = webapp.WSGIApplication(
        [('/api/', Route(MyAPI, framework='appengine'))]
    )
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

from django.conf.urls.defaults import *
from django.views.generic.simple import direct_to_template

urlpatterns = patterns('',
    (r'^$', direct_to_template, {'template': 'ajax_client/index.html'}),
)
########NEW FILE########
__FILENAME__ = views

########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

import re
from simpleapi import Namespace, Feature

class FunFeature(Feature):
    
    __config__ = ('fun', bool)
    
    def handle_response(self, response):
        config = self.get_config(response)
        if config:
            if response.result == 50:
                # we're funny :D, if the result of our calculator is 50 we add 1
                response.result += 1

class Calculator(Namespace):
    
    __features__ = [FunFeature, ]
    __ip_restriction__ = ["127.0.0.*", "78.47.135.*"]
    __authentication__ = lambda self, access_key: access_key == "91d9f7763572c7ebcce49b183454aeb0"
    
    # activates fun mode (FunFeature), thanks to __config__ this is also possible on a method basis!
    # e.g.: power.fun = True
    fun = True
    
    def get_access_keys(self):
        return self.__authentication__, self.session.access_key
    get_access_keys.published = True
    
    def multiply(self, a, b):
        return a*b  
    multiply.published = True
    multiply.constraints = {'a': float, 'b': float}
    multiply.fun = False # disable fun modus for multiply
    
    def power(self, a, b):
        return a**b 
    power.published = True
    power.constraints = {'a': float, 'b': lambda b: float(b)}
    
    def verify_sum_up(self, key, value):
        return float(value) # verifiies also all kwargs!
    
    def sum_up(self, **kwargs):
        return sum(kwargs.values())
    sum_up.published = True
    sum_up.constraints = verify_sum_up
    
    def verifiy_get_max(self, key, value):
        return float(value)
    verifiy_get_max.name = 'float'
    
    def get_max(self, a, b):
        return max(a, b)
    get_max.published = True
    get_max.constraints = {'a': verifiy_get_max, 'b': verifiy_get_max}
    
class OldCalculator(Calculator):
    
    __authentication__ = "91d9f7763572c7ebcce49b183454aeb0"
    
    __version__ = 1
    
    def add(self, a, b):
        return a+b
    add.published = True
    add.constraints = {'a': float, 'b': float}

class AdjustmentFeature(Feature):
    
    # the Feature will automatically triggered when __function_config__ applies
    __function_config__ = ('adjustment', int)
    
    def handle_response(self, response):
        # adjust results by `adjustment`-config (ie. see add.adjustment)
        # we use the new Feature-system of simpleapi 0.0.3
        config = self.get_config(response)
        response.result += config

class NewCalculator(Calculator):
    
    __version__ = 2
    __features__ = [AdjustmentFeature]
    
    def add(self, a, b):
        return a+b+1
    add.published = True
    add.constraints = {'a': float, 'b': float}
    add.adjustment = -1

class SomeFunctions(Namespace):
    
    __features__ = ['throttling', 'caching']
    __input__ = ['pickle'] # restrict input to pickle only (since we're using datetime objects as input and use only the simpleapi client)
    __output__ = ['pickle'] # restrict output to pickle only
    
    def regex_constraint(self, value):
        return True
    regex_constraint.published = True
    regex_constraint.constraints = {'value': re.compile(r'^\d{5}\-\w{3,7}$')}
    
    def get_remote_ip(self):
        return self.session.request.META.get('REMOTE_ADDR')
    get_remote_ip.published = True
    
    def today(self):
        import datetime
        return datetime.datetime.now()
    today.published = True
    
    def fail(self):
        self.error('This fails remotely!')
    fail.published = True
    
    def add_a_day(self, dt):
        import datetime
        return dt+datetime.timedelta(days=1)
    add_a_day.published = True
    
    def delayed_function(self, a, b, c=95):
        import time
        time.sleep(3)
        return True
    delayed_function.published = True
    delayed_function.caching = {
        'timeout': 15, # in seconds
    } # Caching is available because 'caching' is added to the list of __features__ (see above)!
    
    def throttled_function(self):
        return True
    throttled_function.published = True
    throttled_function.throttling = {
        # you can combine several throttling options 
        'rps': 50,  # requests per second
        'rpm': 500, # requests per minute
        'rph': 5000, # requests per hour
    }

class Misc(Namespace):
    
    def return_my_value(self, val):
        return val
    return_my_value.published = True
########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

from django.conf.urls.defaults import *

from simpleapi import Route
from handlers import OldCalculator, NewCalculator, SomeFunctions, Misc

urlpatterns = patterns('',
    (r'^calculator/multiple/$', Route(OldCalculator, NewCalculator, debug=True)),
    (r'^calculator/one/$', Route(OldCalculator, debug=True)),
    (r'^functions/$', Route(SomeFunctions, debug=True)),
    (r'^misc/$', Route(Misc))
)
########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-

import sys
import os

# just for me: :-)
sys.path.append("/Users/flosch/devlibs/3rdparty/")

PROJECT_ROOT = os.path.dirname(__file__)

ROOT_URLCONF = 'django_server.urls'

DEBUG = True

# used by simpleapi.features.CacheFeature:
CACHE_BACKEND = 'locmem://'

#
# Language / localization
#

TIME_ZONE = 'Europe/Berlin'

INSTALLED_APPS = (
    'api',
    'ajax_client'
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.core.context_processors.request",
    "django.core.context_processors.auth",
)

#
# Secret key
#

try:
    SECRET_KEY
except NameError:
    SECRET_FILE = os.path.join(PROJECT_ROOT, 'secret.txt')
    try:
        SECRET_KEY = open(SECRET_FILE).read().strip()
    except IOError:
        try:
            from random import choice
            SECRET_KEY = ''.join([choice('abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)') for i in range(50)])
            secret = file(SECRET_FILE, 'w')
            secret.write(SECRET_KEY)
            secret.close()
        except IOError:
            Exception('Please create a %s file with random characters to generate your secret key!' % SECRET_FILE)
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from django.views.generic.simple import redirect_to

urlpatterns = patterns('',
    (r'^$', redirect_to, {'url': '/ajax/'}),
	(r'^api/', include('api.urls')),
	(r'^ajax/', include('ajax_client.urls')),
)

########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

import re, random
from simpleapi import Namespace
from sapi.message import Message, MessageElement

class Example(Namespace):
    __version__ = 1

    def test(self, username):
        root = MessageElement('messages', to=username)

        for i in xrange(random.randint(1, 10)):
            el = MessageElement('message')
            el.text = 'Message #%s' % random.randint(1, 5000)
            el.set('type', 'public')
            if random.randint(1, 5000) > 3000:
                el.set('type', 'private')
            el.set('from', random.choice(['Al', 'Dj', 'Frank', 'John']))
            root.append(el)

        return Message(root)
    test.published = True
    test.methods = ('POST',)

########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

from django.conf.urls.defaults import *

from simpleapi import Route
from handlers import Example

from sapi import formatters, wrappers

urlpatterns = patterns('',
    (r'^example/$', Route(Example, debug=True))
)
########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = formatters
try:
    import json
except ImportError:
    import simplejson as json

from simpleapi.message import formatters, Formatter, PythonToXML

from message import Message

class JSONFormatter(Formatter):
    __mime__ = "application/json"

    def build(self, value):
        if not isinstance(value, Message):
            raise TypeError('You MUST use a Message to build your response')
        return value.to_json(as_dict=False)

    def kwargs(self, value, action='build'):
        if action == 'build':
            return json.dumps(value)
        elif action == 'parse':
            return json.loads(value)

    def parse(self, value):
        return Message.parse_json(value)

class JSONPFormatter(Formatter):
    __mime__ = "application/javascript"

    def build(self, value):
        if not isinstance(value, Message):
            raise TypeError('You MUST use a Message to build your response')

        func = self.callback or 'simpleapiCallback'
        return u'%(func)s(%(data)s)' % {'func': func,
                                        'data': value.to_json(as_dict=False)}

    def kwargs(self, value, action='build'):
        if action == 'build':
            return json.dumps(value)
        elif action == 'parse':
            return json.loads(value)

    def parse(self, value):
        return Message.parse_json(value)

class XMLFormatter(Formatter):
    __mime__ = "application/xml"

    def build(self, value):
        if not isinstance(value, Message):
            raise TypeError('You MUST use a Message to build your response')

        return value.to_xml()

    def kwargs(self, value, action='build'):
        if action == 'build':
            return PythonToXML().build(value)
        elif action == 'parse':
            return PythonToXML().parse(value)

    def parse(self, value):
        return Message.parse_xml(value)

formatters.register('json', JSONFormatter, override=True)
formatters.register('jsonp', JSONPFormatter, override=True)
formatters.register('xml', XMLFormatter, override=True)
########NEW FILE########
__FILENAME__ = message
#This is common between the client & server
__all__ = ['MessageElement', 'Message', 'BaseMessage']

import string, sys, re, json
from xml.etree import cElementTree as ET

def _validate_element(el):
    if not isinstance(el, MessageElement):
        raise TypeError("element must be a MessageElement")

class BaseMessage(dict):
    pass

class MessageElement(BaseMessage):
    """
    MessageElement class. This is used for all items to be sent across
    the network and is wrapped in a Message before being sent across
    So you should only ever be working with this class directly

    @public attributes
        tag
            The primary identifier for the element.
        text
            Any text contents of this message
        children
            Is a readonly list of the children of this element
            Though this is a list modifying it directly to it will
            have no effect on the actual children
        parent
            Is a readonly attribute that holds the parent of this element
            If you append this element to another the parent is reset
        root
            Is a readonly attribute containing the root element that this
            element belongs to. If this is the root element it will return
            itself
    """
    _tag = None
    _text = None
    _parent = None
    _root = None
    _children = None

    def __init__(self, tag, text=None, **kwargs):
        """
        Generate the MessageElement

        @param tag Is the elements tag, which is the primary identifier
        @param text The text contents of this element
        @param **kwargs Is a key, value set of attributes for this element

        @usage;
            MessageElement('example')
            MessageElement('example', 'some text contents')
            MessageElement('example', 'some text contents', attr1=1, ...)
        """
        super(MessageElement, self).__init__(**kwargs)
        self.tag = tag
        self._root = self
        self._children = list()
        if text:
            self.text = text


    def __repr__(self):
        return "<MessageElement(%(tag)s) at 0x%(id)x}>" % {'tag': self.tag,
                                                           'id' : id(self)}

    def __len__(self):
        """
        Returns the number of children

        @return the number of children
        """
        return len(self._children)

    def __getattr__(self, attr):
        """
        Gets an element attribute.

        @return The attribute value, or None
        """
        return self.get(attr, None)

    def __setattr__(self, attr, value):
        """
        Sets an element attribute.
        """
        if attr not in ['_tag', 'tag', '_text', 'text', '_parent', 'parent',
                 '_root', 'root', '_children', 'children']:
            super(MessageElement, self).__setitem__(attr, value)
        else:
            super(MessageElement, self).__setattr__(attr, value)

    def __getitem__(self, index):
        """
        Returns the given subelement.

        @param index What subelement to return.
        @return The given subelement.
        @exception IndexError If the given element does not exist.
        """
        return self._children[index]

    def __setitem__(self, index, element):
        """
        Replaces the given subelement.

        @param index What subelement to replace.
        @param element The new element value.
        @exception IndexError If the given element does not exist.
        @exception TypeError If element is not a valid object.
        """
        _validate_element(element)
        element._adjust_parent_root(self, self.root)
        self._children[index] = element

    def __delitem__(self, index):
        """
        Deletes the given subelement.

        @param index What subelement to delete.
        @exception IndexError If the given element does not exist.
        """
        del self._children[index]

    def __getslice__(self, start, stop):
        """
        Returns a list containing subelements in the given range.

        @param start The first subelement to return.
        @param stop The first subelement that shouldn't be returned.
        @return A sequence object containing subelements.
        """
        return self._children[start:stop]

    def __setslice__(self, start, stop, elements):
        """
        Replaces a number of subelements with elements from a sequence.

        @param start The first subelement to replace.
        @param stop The first subelement that shouldn't be replaced.
        @param elements A sequence object with zero or more elements.
        @exception TypeError If a sequence member is not a valid object.
        """
        for element in elements:
            _validate_element(element)
            element._adjust_parent_root(self, self.root)
        self._children[start:stop] = list(elements)

    def __delslice__(self, start, stop):
        """
        Deletes a number of subelements.

        @param start The first subelement to delete.
        @param stop The first subelement to leave in there.
        """
        del self._children[start:stop]

    def _adjust_parent_root(self, parent, root):
        self._parent = parent
        self._root = root
        for child in self._children:
            child._adjust_parent_root(self, root)

    def to_json(self, as_dict=True):
        _ = {u'tag': self.tag,
             u'attrs': dict(self.iteritems()),
             u'text': self.text,
             u'children': [child.to_json() for child in self._children]}

        if as_dict:
            return _

        return json.dumps(_, ensure_ascii=False)

    def to_xml(self):
        e = ET.Element(self.tag)
        e.text = self.text

        for attr, value in self.iteritems():
            if not isinstance(value, basestring):
                value = str(value)
            e.set(attr, value)

        for child in self._children:
            child_el = child.to_xml()
            e.append(child_el)

        return e

    def append(self, element):
        """
        Adds a subelement to the end of this element.

        @param element The element to add.
        @exception TypeError If the element is not a valid object.
        """
        _validate_element(element)
        element._adjust_parent_root(self, self.root)
        self._children.append(element)

    def insert(self, index, element):
        """
        Inserts a subelement at the given position in this element.

        @param index Where to insert the new subelement.
        @exception TypeError If the element is not a valid object.
        """
        _validate_element(element)
        element._adjust_parent_root(self, self.root)
        self._children.insert(index, element)

    def remove(self, element):
        """
        Removes a matching subelement.  Unlike the <b>find</b> methods,
        this method compares elements based on identity, not on tag
        value or contents.

        @param element What element to remove.
        @exception ValueError If a matching element could not be found.
        @exception TypeError If the element is not a valid object.
        """
        _validate_element(element)
        element._adjust_parent_root(None, element)
        self._children.remove(element)

    def clear(self):
        """
        Resets an element.  This function removes all subelements, clears
        all attributes, and sets the text attribute to None.
        """
        super(MessageElement, self).clear()
        self._children = []
        self.text = None

    def set(self, key, value):
        """
        Sets an element attribute.

        @param key What attribute to set.
        @param value The attribute value.
        """
        self.__setattr__(key, value)

    def find(self, tag):
        """
        Finds the first matching subelement, by tag name.

        @param tag What element to look for.
        @return The first matching element, or None if no element was found.
        @defreturn MessageElement or None
        """
        for child in self._children:
            if child.tag == tag:
                return child

        return None

    def iter_find(self, tag):
        """
        Finds the first matching subelement, by tag name.
        Does so recursivly

        @param tag What element to look for.
        @return The first matching element, or None if no element was found.
        @defreturn MessageElement or None
        """
        for child in self._children:
            if child.tag == tag:
                return child
            check = child.iterfind(tag)
            if check is not None:
                return check

        return None

    def findtext(self, tag, default=""):
        """
        Finds text for the first matching subelement, by tag name.

        @param tag What element to look for.
        @param default What to return if the element was not found.
        @return The text content of the first matching element, or the
            default value no element was found.  Note that if the element
            has is found, but has no text content, this method returns an
            empty string.
        @defreturn string
        """
        el = self.find(tag)
        if el is not None:
            if not el.text:
                return default
            return el.text

        return None

    def iter_findtext(self, tag, default=""):
        """
        Finds text for the first matching subelement, by tag name.
        Does so recursivly

        @param tag What element to look for.
        @param default What to return if the element was not found.
        @return The text content of the first matching element, or the
            default value no element was found.  Note that if the element
            has is found, but has no text content, this method returns an
            empty string.
        @defreturn string
        """
        el = self.iterfind(tag)
        if el is not None:
            if not el.text:
                return default
            return el.text

        return None

    def findall(self, tag):
        """
        Finds all matching elements, by tag name.

        @param tag What element to look for.
        @return A list or iterator containing all matching elements,
           in document order.
        @defreturn list of Element instances
        """
        found = []
        for child in self.children:
            if child.tag == tag:
                found.append(child)
            found.extend(child.findall(tag))
        return found

    def getiterator(self, tag=None):
        """
        Creates a tree iterator.  The iterator loops over this element
        and all subelements, in document order, and returns all elements
        with a matching tag.

        If the tree structure is modified during iteration, the result
        is undefined.

        @param tag What tags to look for (default is to return all elements).
        @return A list or iterator containing all the matching elements.
        @defreturn list or iterator
        """
        if tag == "*" or tag is None or self.tag == tag:
            yield self

        for node in self._children:
            for item in node.getiterator(tag):
                yield item

    @classmethod
    def parse_json(cls, source):
        """
        Parse the source and turn it into a proper MessageElement

        @param source A string or dict
        @return The MessageElement
        @defreturn MessageElement
        """
        if isinstance(source, basestring):
            source = json.loads(source, encoding='utf-8')

        el = cls(source['tag'], **source.get('attrs', {}))
        if source.get('text'):
            el.text = source['text']

        for child in source.get('children', []):
            el.append(cls.parse_json(child))

        return el

    @classmethod
    def parse_xml(cls, source):
        """
        Parses a xml String into a MessageElement

        @param source A json string.
        @return The MessageElement.
        @defreturn MessageElement
        """
        if isinstance(source, basestring):
            source = ET.fromstring(source)

        el = cls(source.tag, **source.attrib)
        if source.text:
            el.text = source.text

        children = source.getchildren()
        for child in children:
            el.append(cls.parse_xml(child))

        return el

    #Properties
    def _get_tag(self):
        return self._tag
    def _set_tag(self, value):
        if not isinstance(value, basestring):
            raise TypeError("tag must be a string")

        self._tag = value
    tag = property(_get_tag, _set_tag, doc="The MessageElement tag")

    def _get_text(self):
        return self._text
    def _set_text(self, value):
        if not isinstance(value, basestring):
            raise TypeError("text must be a string")

        self._text = value
    def _del_text(self):
        self._text = None
    text = property(_get_text, _set_text, _del_text,
                    doc="The MessageElement text")

    def _get_children(self):
        if self._children is None:
            self._children = []
        return list(self._children)
    children = property(_get_children, None, doc="The MessageElements children")

    def _get_parent(self):
        return self._parent
    def _del_parent(self):
        self._parent = None
    parent = property(_get_parent, None, _del_parent,
                      doc="The MessageElements parent")

    def _get_root(self):
        return self._root
    def _del_root(self):
        self._root = self
    root = property(_get_root, None, _del_root,
                    doc="The MessageElements root")

class Message(BaseMessage):
    """
    Message wrapper class.  This class represents an entire message
    hierarchy, and adds some extra support for serialization to and from
    standard json.

    @param element Optional root element.
    """
    _root = None
    _errors = None
    _text = None

    def __init__(self, element=None, **kwargs):
        super(Message, self).__init__(**kwargs)

        self._errors = list()

        if element is not None:
            _validate_element(element)
            self._root = element

    def __getattr__(self, attr):
        """
        Gets an element attribute.

        @return The attribute value, or None
        """
        return self.get(attr, None)

    def __setattr__(self, attr, value):
        """
        Sets an element attribute.
        """
        if attr not in ['_text', 'text', '_root', 'root', '_errors', 'errors']:
            super(Message, self).__setitem__(attr, value)
        else:
            super(Message, self).__setattr__(attr, value)

    def __repr__(self):
        return '<Message at 0x%x>' % id(self)

    def to_json(self, as_dict=True):
        _ = {u'simpleapi': 'response',
             u'error': True if self._errors else False,
             u'errors': tuple(self.errors),
             u'attrs': dict(self.iteritems()),
             u'text': self.text,
             u'root': self.root.to_json() if self.root else None}

        if as_dict:
            return _

        return json.dumps(_, ensure_ascii=False)

    def to_xml(self):
        e = ET.Element('response')
        for attr, value in self.iteritems():
            if not isinstance(value, basestring):
                value = str(value)
            e.set(attr, value)
        e.text = self._text

        if self.errors:
            errs = ET.Element('errors')
            for error in self.errors:
                err = ET.Element('error')
                err.text = error
                errs.append(err)
            e.append(errs)

        if self._root:
            root_el = self._root.to_xml()
            e.append(root_el)

        return ET.tostring(e)

    def clear(self):
        """
        Resets an element.  This function removes all subelements, clears
        all attributes, and sets the text attribute to None.
        """
        super(Message, self).clear()
        self._errors = list()
        self.text = None
        self._root = None

    def get(self, attr, default=None):
        if attr == 'result':
            return self
        elif attr == 'errors':
            return self.errors

        return super(Message, self).get(attr, default)

    def set(self, key, value):
        """
        Sets an element attribute.

        @param key What attribute to set.
        @param value The attribute value.
        """
        self.__setattr__(key, value)

    def add_error(self, message):
        self._errors.append(message)

    def getiterator(self, tag=None):
        """
        Creates a tree iterator for the root element.  The iterator loops
        over all elements in this tree, in document order.

        @param tag What tags to look for (default is to return all elements)
        @return An iterator.
        @defreturn iterator
        """
        if self._root is not None:
            for item in self._root.getiterator(tag):
                yield item

    def find(self, tag):
        """
        Finds the first toplevel element with given tag.
        Same as root.find(tag).

        @param tag What element to look for.
        @return The first matching element, or None if no element was found.
        @defreturn MessageElement or None
        """
        if self._root is None:
            return

        return self._root.find(tag)

    def iter_find(self, tag):
        """
        Finds the first toplevel element with given tag.
        Same as getroot().find(tag).

        @param tag What element to look for.
        @return The first matching element, or None if no element was found.
        @defreturn MessageElement or None
        """
        if self._root is None:
            return

        return self._root.iter_find(tag)

    def findtext(self, tag, default=None):
        """
        Finds the element text for the first toplevel element with given
        tag.  Same as root.findtext(tag).

        @param tag What toplevel element to look for.
        @param default What to return if the element was not found.
        @return The text content of the first matching element, or the
            default value no element was found.  Note that if the element
            has is found, but has no text content, this method returns an
            empty string.
        @defreturn string
        """
        if self._root is None:
            return

        return self._root.findtext(tag, default)

    def iter_findtext(self, tag, default=None):
        """
        Finds the element text for the first toplevel element with given
        tag.  Same as root.findtext(tag).

        @param tag What toplevel element to look for.
        @param default What to return if the element was not found.
        @return The text content of the first matching element, or the
            default value no element was found.  Note that if the element
            has is found, but has no text content, this method returns an
            empty string.
        @defreturn string
        """
        if self._root is None:
            return

        return self._root.iter_findtext(tag, default)

    def findall(self, tag):
        """
        Finds all toplevel elements with the given tag.
        Same as root.findall(tag).

        @param tag What element to look for.
        @return A list or iterator containing all matching elements,
           in document order.
        @defreturn list of MessageElement instances
        """
        if self._root is None:
            return []

        return self._root.findall(tag)

    @classmethod
    def parse_json(cls, source):
        """
        Parses a json String into a Message

        @param source A json string.
        @return The Message.
        @defreturn Message
        """
        if isinstance(source, basestring):
            source = json.loads(source, encoding='utf-8')

        if source.get('root'):
            ret = cls(MessageElement.parse_json(source['root']),
                      **source.get('attrs', {}))
        else:
            ret = cls(**source.get('attrs', {}))

        if source.get('text'):
            ret.text = source['text']

        for error in source.get('errors', []):
            ret.add_error(error)

        for attr, value in source.get('attrs', {}).iteritems():
            ret.set(attr, value)

        return ret

    @classmethod
    def parse_xml(cls, source):
        """
        Parses a xml String into a Message

        @param source A json string.
        @return The Message.
        @defreturn Message
        """
        if isinstance(source, basestring):
            source = ET.fromstring(source)

        if source.tag != 'response':
            raise TypeError('Message does not know how to decode this')

        ret = cls()

        for attr, value in source.attrib.iteritems():
            ret.set(attr, value)

        for err in source.findall('error'):
            ret.add_error(err.text)
            source.remove(err)

        for errs in source.findall('errors'):
            source.remove(errs)

        children = source.getchildren()
        child = children[0] if len(children) else None
        if child is not None:
            c = MessageElement.parse_xml(child)
            ret._root = c

        return ret

    #Properties
    def _get_root(self):
        return self._root
    root = property(_get_root, None, doc="The root MessageElement or None")

    def _get_text(self):
        return self._text
    def _set_text(self, value):
        if not isinstance(value, basestring):
            raise TypeError("text must be a string")

        self._text = value
    def _del_text(self):
        self._text = None
    text = property(_get_text, _set_text, _del_text,
                    doc="The text contents of this message")

    def _get_errors(self):
        if self._errors is None:
            self._errors = list()
        return list(self._errors)
    errors = property(_get_errors)

    def _get_has_errors(self):
        return True if self._errors else False
    has_errors = property(_get_has_errors)

########NEW FILE########
__FILENAME__ = wrappers
from simpleapi import wrappers, DefaultWrapper

from message import Message

class MessageWrapper(DefaultWrapper):
    def build(self, result, errors):
        if not isinstance(result, Message):
            result = Message(result)

        if errors:
            result.success = False
        else:
            result.success = True

        result._errors = errors
        return result
wrappers.register('message', MessageWrapper)

########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-

import sys
import os
root = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                    '../../../'))
sys.path.append(root)

PROJECT_ROOT = os.path.dirname(__file__)

ROOT_URLCONF = 'urls'

DEBUG = True

# used by simpleapi.features.CacheFeature:
CACHE_BACKEND = 'locmem://'

#
# Language / localization
#

TIME_ZONE = 'Europe/Berlin'

INSTALLED_APPS = (
    'api',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.core.context_processors.request",
    "django.core.context_processors.auth",
)

#
# Secret key
#

try:
    SECRET_KEY
except NameError:
    SECRET_FILE = os.path.join(PROJECT_ROOT, 'secret.txt')
    try:
        SECRET_KEY = open(SECRET_FILE).read().strip()
    except IOError:
        try:
            from random import choice
            SECRET_KEY = ''.join([choice('abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)') for i in range(50)])
            secret = file(SECRET_FILE, 'w')
            secret.write(SECRET_KEY)
            secret.close()
        except IOError:
            Exception('Please create a %s file with random characters to generate your secret key!' % SECRET_FILE)
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from django.views.generic.simple import redirect_to

urlpatterns = patterns('',
	(r'^api/', include('api.urls')),
)

########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

import re
from simpleapi import Namespace, Feature, serialize

from models import Contact, Author

class ContactAPI(Namespace):

    def new(self, name, phone=None, fax=None):
        obj, created = Author.objects.get_or_create(name='Testauthor')
        contact = Contact.objects.create(
            name=name,
            phone=phone,
            fax=fax,
            author=obj
        )
        return serialize(contact, excludes=[re.compile(r'^datetime_'),], include_pk=True)
    new.published = True

    def search(self, pattern):
        qs = Contact.objects.filter(
            name__icontains=pattern
        )
        return {
            'count': qs.count(),

            # use serialize if you want to exclude or define fields
            'items': serialize(qs, excludes=['datetime_added',]),

            # inline objects are no problem without serialize
            'first_item': (qs.count() > 0) and qs[0] or None,

            # define fields if you want to restrict output to specific fields
            'second_item': (qs.count() > 1) and \
                serialize(qs[1], fields=[re.compile('^name')]) or None
        }
    search.published = True
########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

import datetime

from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=150)

    def natural_key(self):
        return self.name

class Contact(models.Model):
    
    name = models.CharField(max_length=150)
    phone = models.CharField(blank=True, null=True, max_length=50)
    fax = models.CharField(blank=True, null=True, max_length=50)
    datetime_added = models.DateTimeField(default=datetime.datetime.now)

    time_changed = models.TimeField(auto_now=True, auto_now_add=True)
    date_changed = models.DateField(auto_now=True, auto_now_add=True)
    
    author = models.ForeignKey(Author)
########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

from django.conf.urls.defaults import *

from simpleapi import Route
from handlers import ContactAPI

urlpatterns = patterns('',
    (r'^$', Route(ContactAPI)),
)
########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-

import sys
import os

# just for me: :-)
sys.path.append("/Users/flosch/dev/simpleapi/")

PROJECT_ROOT = os.path.dirname(__file__)

ROOT_URLCONF = 'django_server3.urls'

DEBUG = True

# used by simpleapi.features.CacheFeature:
CACHE_BACKEND = 'locmem://'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'testdb.db'
    }
}

#
# Language / localization
#

TIME_ZONE = 'Europe/Berlin'

INSTALLED_APPS = (
    'api',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.core.context_processors.request",
    "django.core.context_processors.auth",
)

#
# Secret key
#

try:
    SECRET_KEY
except NameError:
    SECRET_FILE = os.path.join(PROJECT_ROOT, 'secret.txt')
    try:
        SECRET_KEY = open(SECRET_FILE).read().strip()
    except IOError:
        try:
            from random import choice
            SECRET_KEY = ''.join([choice('abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)') for i in range(50)])
            secret = file(SECRET_FILE, 'w')
            secret.write(SECRET_KEY)
            secret.close()
        except IOError:
            Exception('Please create a %s file with random characters to generate your secret key!' % SECRET_FILE)
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from django.views.generic.simple import redirect_to

urlpatterns = patterns('',
    (r'^api/', include('api.urls')),
)

########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

import re
from simpleapi import Namespace, Feature, serialize

from models import Contact

class ContactAPI(Namespace):

    def new(self, name, phone=None, fax=None):
        contact = Contact(
            name=name,
            phone=phone,
            fax=fax
        )
        contact.save()
        return serialize(contact, excludes=[re.compile(r'^datetime_'),])
    new.published = True

    def search(self, pattern):
        qs = Contact.objects.filter(
            name__icontains=pattern
        )
        return {
            'count': qs.count(),
            
            # use serialize if you want to exclude or define fields
            'items': serialize(qs, excludes=['datetime_added',]), 
            
            # inline objects are no problem without serialize
            'first_item': (qs.count() > 0) and qs[0] or None,
            
            # define fields if you want to restrict output to specific fields
            'second_item': (qs.count() > 1) and \
                serialize(qs[1], fields=[re.compile('^name')]) or None
        }
    search.published = True
########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

import datetime

from mongoengine import *

class DetailedInformation(EmbeddedDocument):
    status = StringField(choices=('sent', 'failed', 'progress'), default='progress')    

class Contact(Document):
    
    name = StringField()
    phone = StringField()
    fax = StringField()
    datetime_added = DateTimeField(default=datetime.datetime.now)
    
    details = EmbeddedDocumentField(DetailedInformation,
                                    default=DetailedInformation)
    
    testdict = DictField()
########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

from django.conf.urls.defaults import *

from simpleapi import Route
from handlers import ContactAPI

urlpatterns = patterns('',
    (r'^$', Route(ContactAPI)),
)
########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-

import sys
import os

# just for me: :-)
sys.path.append("/Users/flosch/devlibs/3rdparty/")

from mongoengine import connect

PROJECT_ROOT = os.path.dirname(__file__)

ROOT_URLCONF = 'django_server4.urls'

DEBUG = True

# used by simpleapi.features.CacheFeature:
CACHE_BACKEND = 'locmem://'

connect('simpleapi_test')

TIME_ZONE = 'Europe/Berlin'

INSTALLED_APPS = (
    'api',
)

MIDDLEWARE_CLASSES = ()
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from django.views.generic.simple import redirect_to

urlpatterns = patterns('',
    (r'^api/', include('api.urls')),
)

########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

import re
from simpleapi import Namespace, Feature, serialize

from models import Contact

class ContactAPI(Namespace):
    def get(self, id):
        return Contact.objects.get(id=id)
    get.constraints = {'id': int}
    get.published = True

    def post(self, name, phone=None, fax=None):
        return Contact.objects.create(
            name=name,
            phone=phone,
            fax=fax
        )
    post.published = True
########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

import datetime

from django.db import models

class Contact(models.Model):
    
    name = models.CharField(max_length=150)
    phone = models.CharField(blank=True, null=True, max_length=50)
    fax = models.CharField(blank=True, null=True, max_length=50)
    datetime_added = models.DateTimeField(default=datetime.datetime.now)

    time_changed = models.TimeField(auto_now=True, auto_now_add=True)
    date_changed = models.DateField(auto_now=True, auto_now_add=True)
########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

from django.conf.urls.defaults import *

from simpleapi import Route
from handlers import ContactAPI

urlpatterns = patterns('',
    (r'^$', Route(ContactAPI, restful=True)),
    (r'^(?P<id>[\d]+)/$', Route(ContactAPI, restful=True)),
)
########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-

import sys
import os

# just for me: :-)
sys.path.append("/Users/flosch/devlibs/3rdparty/")

PROJECT_ROOT = os.path.dirname(__file__)

ROOT_URLCONF = 'django_server5.urls'

DEBUG = True

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'testdb.db'
    }
}

TIME_ZONE = 'Europe/Berlin'

INSTALLED_APPS = (
    'api',
)

MIDDLEWARE_CLASSES = ()
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from django.views.generic.simple import redirect_to

urlpatterns = patterns('',
    (r'^api/', include('api.urls')),
)

########NEW FILE########
__FILENAME__ = app
import sys
import os

from flask import Flask
root = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                    '../../../'))
sys.path.append(root)

from simpleapi import Route
from handlers import MyAPI

app = Flask(__name__)

app.route('/api/', methods=['GET', 'POST'])(Route(MyAPI, framework='flask'))

if __name__ == '__main__':
    app.run(debug=True)
########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

from simpleapi import Namespace

class MyAPI(Namespace):
    
    def add(self, a, b):
        return a + b
    add.published = True
    add.constraints = lambda ns, key, value: int(value)

    def test(self):
        self.error(u'Yay.')
    test.published = True

########NEW FILE########
__FILENAME__ = app
import sys
import os

root = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                    '../../../'))
sys.path.append(root)

from simpleapi import Route
from handlers import MyAPI

__all__ = ('route', )

route = Route(MyAPI, framework='wsgi', path=r'^/api/')
print route

# Simply start the server with e. g. 5 workers:
# $ gunicorn -w 5 app:route
########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

from simpleapi import Namespace
import time

class MyAPI(Namespace):
    def add(self, a, b):
        return a + b
    add.published = True
    add.constraints = lambda ns, key, value: int(value)

    def test(self):
        time.sleep(5)
        self.error(u'Yay.')
    test.published = True
########NEW FILE########
__FILENAME__ = app
import sys
import os

root = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                    '../../../'))
sys.path.append(root)

from simpleapi import Route
from handlers import MyAPI

route = Route(MyAPI, framework='standalone', path=r'^/api/')
route.serve() # start the WSGI Server on Port 5050
########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

from simpleapi import Namespace

class MyAPI(Namespace):
    def add(self, a, b):
        return a + b
    add.published = True
    add.constraints = lambda ns, key, value: int(value)

    def test(self):
        self.error(u'Yay.')
    test.published = True
########NEW FILE########
__FILENAME__ = client
# -*- coding: utf-8 -*-

__all__ = ('Client', 'ClientException', 'ConnectionException', 'RemoteException', )

import socket
import urllib
import cPickle
from simpleapi.message import formatters, wrappers

class ClientException(Exception): pass
class ConnectionException(ClientException): pass
class RemoteException(ClientException): pass
class Client(object):
    """simpleapi's client library. 
    
    :param ns: URL of your :class:`~simpleapi.Route`'s endpoint
    :param access_key: string key used for authentication
    :param version: Namespace version to be used (default is highest)
    :param transport_type: encoding/decoding type for request/response (default
                           is json)
    :param wrapper_type: wrapper used for formatting the response
    :param timeout: connection timeout in secs (default is system parameter)
    """

    def __init__(self, ns, access_key=None, version='default',
                 transport_type='json', wrapper_type='default', timeout=None):

        if timeout is not None:
            socket.setdefaulttimeout(timeout)

        self.ns = ns
        self.access_key = access_key
        self.version = version

        assert transport_type in formatters
        self.transport_type = transport_type

        assert wrapper_type in wrappers
        self.wrapper_type = wrapper_type

    def _handle_remote_call(self, fname):
        def do_call(**kwargs):
            data = {
                '_call': fname,
                '_output': self.transport_type,
                '_input': self.transport_type,
                '_wrapper': self.wrapper_type,
                '_access_key': self.access_key or '',
                '_version': self.version
            }

            formatter = formatters[self.transport_type](None, None)

            for key, value in kwargs.iteritems():
                kwargs[key] = formatter.kwargs(value)

            data.update(kwargs)

            try:
                response = urllib.urlopen(self.ns,
                                          urllib.urlencode(data))

                assert response.getcode() in [200,], \
                    u'HTTP-Server returned http code %s (expected: 200) ' % \
                    response.getcode()

                response_buffer = response.read()
            except IOError, e:
                raise ConnectionException(e)

            try:
                response = formatter.parse(response_buffer)
            except (cPickle.UnpicklingError, EOFError), _:
                raise ClientException(
                    u'Couldn\'t unpickle response ' \
                    'data. Did you added "pickle" to the namespace\'s' \
                    ' __features__ list?'
                )
            except ValueError, e:
                raise ConnectionException, e

            if response.get('success'):
                return response.get('result')
            else:
                raise RemoteException(". ".join(response.get('errors')))

        return do_call

    def __getattr__(self, name):
        return self._handle_remote_call(name)

    def set_version(self, version):
        """uses a different version for further requests"""
        self.version = int(version)

    def set_ns(self, ns):
        """changes the URL for the Route's endpoint"""
        self.ns = ns
########NEW FILE########
__FILENAME__ = dummy
# -*- coding: utf-8 -*- 

from simpleapi.message import formatters
from simpleapi.client import ConnectionException, RemoteException

__all__ = ('DummyClient', )

TRANSPORT_TYPE = 'json'

class DummyRequest(object): pass
class DummyClientException(Exception): pass
class DummyClient(object):
    
    def __init__(self, route, version='default', access_key=None):
        self.route = route
        self.access_key = access_key
        self.version = version

    def _handle_remote_call(self, fname):
        def do_call(**kwargs):
            data = {
                '_call': fname,
                '_access_key': self.access_key or '',
                '_version': self.version,
                '_input': TRANSPORT_TYPE,
                '_output': TRANSPORT_TYPE
            }

            formatter = formatters[TRANSPORT_TYPE](None, None)

            for key, value in kwargs.iteritems():
                kwargs[key] = formatter.kwargs(value)

            data.update(kwargs)
            
            # Build DummyRequest
            request = DummyRequest()
            request.method = 'POST'
            request.data = data
            request.remote_addr = '127.0.0.1'
            
            # Do request
            response_buffer = self.route(request)

            try:
                response = formatter.parse(response_buffer['result'])
            except ValueError, e:
                raise ConnectionException, e

            if response.get('success'):
                return response.get('result')
            else:
                raise RemoteException(". ".join(response.get('errors')))

        return do_call

    def __getattr__(self, name):
        return self._handle_remote_call(name)

    def set_version(self, version):
        """uses a different version for further requests"""
        self.version = version

    def set_access_key(self, access_key):
        """uses a different access key for further requests"""
        self.access_key = access_key
########NEW FILE########
__FILENAME__ = common
# -*- coding: utf-8 -*-

try:
    import json
except ImportError:
    try:
        from django.utils import simplejson as json
    except Exception, e:
        import simplejson as json

__all__ = ('json', 'SAException')

class SAException(Exception):
    def __init__(self, msg=None):
        super(Exception, self).__init__()
        self._message = msg

    def _get_message(self):
        return self._message

    def _set_message(self, message):
        self._message = message

    message = property(_get_message, _set_message)

    def __repr__(self):
        return self.message
########NEW FILE########
__FILENAME__ = extjs
# -*- coding: utf-8 -*-


__all__ = ('ExtDirectStore', )

class ExtDirectStore(object):
    
    pass
########NEW FILE########
__FILENAME__ = formatter
# -*- coding: utf-8 -*-

import cPickle
from common import json

try:
    import yaml
    has_yaml = True
except ImportError:
    has_yaml = False

from py2xml import PythonToXML

from sajson import SimpleAPIEncoder, SimpleAPIDecoder

__all__ = ('formatters', 'Formatter')

class FormattersSingleton(object):
    """This singleton takes care of all registered formatters. You can easily 
    register your own formatter for use in both the Namespace and python client.
    """
    _formatters = {}

    def __new__(cls):
        it = cls.__dict__.get("__it__")
        if it is not None:
            return it
        cls.__it__ = it = object.__new__(cls)
        return it

    def register(self, name, formatter, override=False):
        """Register the given formatter. If there's already an formatter with
        the given `name`, you can override by setting `override` to ``True``.
        """
        if not isinstance(formatter(None, None), Formatter):
            raise TypeError(u"You can only register a Formatter not a %s" % formatter)

        if name in self._formatters and not override:
            raise AttributeError(u"%s is already a valid format type, try a new name" % name)

        self._formatters[name] = formatter

    def get_defaults(self):
        result = filter(lambda item: getattr(item[1], '__active_by_default__', True), 
            self._formatters.items())
        return dict(result).keys()

    def copy(self):
        return dict(**self._formatters)

    def __contains__(self, value):
        return value in self._formatters

    def __getitem__(self, name):
        return self._formatters.get(name)

    def __setitem__(self, *args):
        raise AttributeError

formatters = FormattersSingleton()

class Formatter(object):
    """Baseclass for Formatter-implementations"""

    def __init__(self, sapi_request, callback):
        """A Formatter takes the original http request (Django's one) and a
        callback name, e. g. for JSONP."""
        self.sapi_request = sapi_request
        self.callback = callback

    def build(self, value):
        """Takes care of the building process and returns the encoded data."""
        raise NotImplementedError

    def kwargs(self, value, action='build'):
        """Is called within ``simpleapi``. This method invokes both the parse
        and build function when needed."""
        raise NotImplementedError

    def parse(self, value):
        """Takes care of the parsing proccess and returns the decoded data."""
        raise NotImplementedError

class JSONFormatter(Formatter):
    """Formatter for the JSON-format. Used by default by the python client and 
    by many Javascript-Frameworks."""
    
    __mime__ = "application/json"

    def build(self, value):
        return json.dumps(value, cls=SimpleAPIEncoder)

    def kwargs(self, value, action='build'):
        if action == 'build':
            return self.build(value)
        elif action == 'parse':
            return self.parse(value)

    def parse(self, value):
        return json.loads(value, cls=SimpleAPIDecoder)

class JSONPFormatter(Formatter):
    """Formatter for JSONP-format. Used for cross-domain requests. If `callback`
    isn't provided, `simpleapiCallback` is used."""
    
    __mime__ = "application/javascript"

    def build(self, value):
        func = self.callback or 'simpleapiCallback'
        result = u'%(func)s(%(data)s)' % {'func': func.decode("utf-8"), 'data': json.dumps(value)}
        return result.encode("utf-8")

    def kwargs(self, value):
        if action == 'build':
            return json.dumps(value, cls=SimpleAPIEncoder)
        elif action == 'parse':
            return self.parse(value)

    def parse(self, value):
        return json.loads(value, cls=SimpleAPIDecoder)

class ValueFormatter(Formatter):
    """Basic formatter for simple, fast and tiny transports (it has a lot of
    limitations, though)."""
    
    __mime__ = "text/html"

    def build(self, value):
        return value

    def kwargs(self, value, action='build'):
        if action == 'build':
            return self.build(value)
        elif action == 'parse':
            return self.parse(value)

    def parse(self, value):
        return unicode(value)

class PickleFormatter(Formatter):
    """Formatter for use the cPickle python module which supports python object
    serialization. It has the fewest limitations (ie. it can also serialize 
    datetime objects), but is a security risk and should only be used in a 
    trusted environment. It's strongly recommended that you use authentication
    mechanismen to protect your namespace. The formatter is not activated by
    default and can be enabled by putting 'pickle' into Namespace's ``__input__``
    and ``__output__`` configuration. """
    
    __mime__ = "application/octet-stream"
    __active_by_default__ = False

    def build(self, value):
        return cPickle.dumps(value)

    def kwargs(self, value, action='build'):
        if action == 'build':
            return self.build(value)
        elif action == 'parse':
            return self.parse(value)

    def parse(self, value):
        if isinstance(value, unicode):
            value = value.encode("utf-8")
        return cPickle.loads(value)

class XMLFormatter(Formatter):
    __mime__ = "text/xml"

    def build(self, value):
        return PythonToXML().build(value)

    def kwargs(self, value, action='build'):
        if action == 'build':
            return self.build(value)
        elif action == 'parse':
            return self.parse(value)

    def parse(self, value):
        return PythonToXML().parse(value)

class YAMLFormatter(Formatter):
    __mime__ = "application/x-yaml"

    def build(self, value):
        return yaml.safe_dump(value)

    def kwargs(self, value, action='build'):
        if action == 'build':
            return self.build(value)
        elif action == 'parse':
            return self.parse(value)

    def parse(self, value):
        return yaml.safe_load(value)

formatters.register('json', JSONFormatter)
formatters.register('jsonp', JSONPFormatter)
formatters.register('value', ValueFormatter)
formatters.register('pickle', PickleFormatter)
formatters.register('xml', XMLFormatter)
if has_yaml:
    formatters.register('yaml', YAMLFormatter)

########NEW FILE########
__FILENAME__ = py2xml
# -*- coding: utf-8 -*-

from xml.etree import cElementTree as ET
from dateutil.parser import parse

__all__ = ('PythonToXML',)

class PythonToXML(object):
    def handle(self, value, op='build'):
        if op == 'build':
            return getattr(self, 'build_%s' % type(value).__name__)(value)
        elif op == 'parse':
            type_name = value.get('type')
            return getattr(self, 'parse_%s' % type_name)(value)

    def create_item(self, type_name):
        element = ET.Element('item')
        element.set('type', type_name)
        return element

    # Builder methods

    def build_NoneType(self, value):
        element = self.create_item('NoneType')
        return element

    def build_time(self, value):
        element = self.create_item('time')
        element.text = value.isoformat()
        return element

    def build_date(self, value):
        element = self.create_item('date')
        element.text = value.isoformat()
        return element

    def build_datetime(self, value):
        element = self.create_item('datetime')
        element.text = value.ctime()
        return element

    def build_str(self, value):
        element = self.create_item('str')
        element.text = str(value)
        return element

    def build_unicode(self, value):
        element = self.create_item('unicode')
        element.text = value #.encode("utf-8")
        return element

    def build_int(self, value):
        element = self.create_item('int')
        element.text = str(int(value))
        return element

    def build_long(self, value):
        element = self.create_item('long')
        element.text = str(long(value))
        return element

    def build_float(self, value):
        element = self.create_item('float')
        element.text = str(float(value))
        return element

    def build_bool(self, value):
        element = self.create_item('bool')
        element.text = str(int(value))
        return element

    def build_list(self, value):
        root = self.create_item('list')
        for item in value:
            root.append(self.handle(item))
        return root

    def build_tuple(self, value):
        root = self.create_item('tuple')
        for item in value:
            root.append(self.handle(item))
        return root

    def build_dict(self, value):
        root = self.create_item('dict')
        for key, value in value.iteritems():
            element = self.handle(value)
            element.set('name', key)
            root.append(element)
        return root

    def build_set(self, value):
        root = self.create_item('set')
        for item in list(value):
            root.append(self.handle(item))
        return root

    # Parser methods

    def parse_datetime(self, element):
        return parse(element.text)

    def parse_date(self, element):
        return parse(element.text).date()

    def parse_time(self, element):
        return parse(element.text).time()

    def parse_dict(self, element):
        tmp = {}
        for item in element.getchildren():
            tmp[item.get('name')] = self.handle(item, 'parse')
        return tmp

    def parse_list(self, element):
        tmp = []
        for item in element.getchildren():
            tmp.append(self.handle(item, 'parse'))
        return tmp

    def parse_set(self, element):
        tmp = []
        for item in element.getchildren():
            tmp.append(self.handle(item, 'parse'))
        return set(tmp)

    def parse_tuple(self, element):
        tmp = []
        for item in element.getchildren():
            tmp.append(self.handle(item, 'parse'))
        return tuple(tmp)

    def parse_unicode(self, element):
        return element.text

    def parse_str(self, element):
        return element.text

    def parse_int(self, element):
        return int(element.text)

    def parse_long(self, element):
        return long(element.text)

    def parse_float(self, element):
        return float(element.text)

    def parse_bool(self, element):
        return bool(int(element.text))

    def parse_NoneType(self, element):
        return None

    # generic methods

    def build(self, value):
        root = self.handle(value)
        return ET.tostring(root)

    def parse(self, value):
        root = ET.fromstring(value)
        return self.handle(root, op='parse')
########NEW FILE########
__FILENAME__ = sajson
# -*- coding: utf-8 -*-

import re
import datetime
from dateutil.parser import parse
from common import json

__all__ = ('SimpleAPIEncoder', 'SimpleAPIDecoder')

date_re = re.compile(r'\w{2,}\ \w{2,} \d{1,}')
#Sun May 30 00:00:00 2010

time_re = re.compile(r'\d{1,2}\:\d{1,2}\:\d{1,2}')
#19:36:20.412047

class SimpleAPIEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, (datetime.datetime, datetime.date)):
            return obj.ctime()
        elif isinstance(obj, datetime.time):
            return obj.isoformat()
        return json.JSONEncoder.default(self, obj)

class SimpleAPIDecoder(json.JSONDecoder):
    def __init__(self, *args, **kwargs):
        super(SimpleAPIDecoder, self).__init__(*args, **kwargs)
        self.object_hook = self.hook

    def hook(self, obj):
        for key, val in obj.iteritems():
            if isinstance(val, basestring) and (date_re.match(val) \
                or time_re.match(val)):
                try:
                    obj[key] = parse(val)
                except ValueError:
                    pass
                else:
                    if time_re.match(val):
                        obj[key] = obj[key].time()
        return obj
########NEW FILE########
__FILENAME__ = wrapper
# -*- coding: utf-8 -*-

from simpleapi.message.common import json

__all__ = ('wrappers', 'Wrapper', 'DefaultWrapper')

class WrappersSingleton(object):
    """This singleton takes care of all registered wrappers. You can easily 
    register your own wrapper for use in both the Namespace and python client.
    """

    _wrappers = {}

    def __new__(cls):
        it = cls.__dict__.get("__it__")
        if it is not None:
            return it
        cls.__it__ = it = object.__new__(cls)
        return it

    def register(self, name, wrapper, override=False):
        """
            Register the given wrapper
        """
        if not isinstance(wrapper(None, ), Wrapper):
            raise TypeError(u"You can only register a Wrapper not a %s" % wrapper)

        if name in self._wrappers and not override:
            raise AttributeError(u"%s is already a valid wrapper type, try a new name" % name)

        self._wrappers[name] = wrapper

    def copy(self):
        return dict(**self._wrappers)

    def __contains__(self, value):
        return value in self._wrappers

    def __getitem__(self, name):
        return self._wrappers.get(name)

    def __setitem__(self, *args):
        raise AttributeError

wrappers = WrappersSingleton()

class Wrapper(object):
    """The baseclass wrapper you can use as a basis for your own wrapper"""

    def __init__(self, sapi_request):
        self.sapi_request = sapi_request
        self.session = getattr(sapi_request, 'session', None)

    def _build(self, errors, result):
        if isinstance(errors, basestring):
            errors = [errors,]

        if errors:
            assert isinstance(errors, (list, tuple))

        return self.build(errors=errors, result=result)

    def _parse(self, items):
        return self.parse(items=items)

    def parse(self, items):
        raise NotImplementedError

    def build(self, errors, result):
        raise NotImplementedError

class DefaultWrapper(Wrapper):
    def parse(self, items):
        return items

    def build(self, errors, result):
        r = {}
        if errors:
            r['success'] = False
        else:
            r['success'] = True
        if errors:
            r['errors'] = errors
        if result is not None:
            r['result'] = result
        return r

class ExtJSWrapper(Wrapper):
    @staticmethod
    def build_errors(errors):
        assert isinstance(errors, (basestring, tuple, list))
        
        if isinstance(errors, basestring) or \
            (isinstance(errors, (tuple, list)) and \
            len(errors) == 1):
            return {
                'msg': isinstance(errors, (tuple, list)) and errors[0] or errors
            }
        elif isinstance(errors, (tuple, list)) and \
            len(errors) > 0:
            errmsg, errors = errors[0], errors[1]
            assert isinstance(errmsg, basestring)
            assert isinstance(errors, dict)
            
            return {
                'msg': errmsg,
                'errors': errors,
            }

    def parse(self, items):
        return items

    def build(self, errors, result):
        r = {}
        if errors:
            r['success'] = False
        else:
            r['success'] = True
        if errors:
            r.update(self.build_errors(errors))

        if result is not None:
            for key, value in self.build_result(result):
                r[key] = value

        return r

class ExtJSFormWrapper(ExtJSWrapper):
    def build_result(self, result):
        yield ('data', result)

class ExtJSStoreWrapper(ExtJSWrapper):
    def build_result(self, result):
        yield ('rows', result)
        yield ('results', len(result))

class ExtJSDirectWrapper(Wrapper):
    def build(self, errors, result):
        if hasattr(self.session._internal, 'extdirect'):
            db = self.session._internal.extdirect[0]
            self.session._internal.extdirect = \
                self.session._internal.extdirect[1:]
        else:
            db = {}
        if db['formHandler'] == True:
            r = {
                'type': db['type'],
                'tid': db['tid'],
                'action': db['action'],
                'method': db['method'],
                'result': {}
            }
            
            if errors:
                r['result'].update(ExtJSWrapper.build_errors(errors))
                r['result']['success'] = False
            else:
                r['result']['success'] = True
                r['result']['data'] = result
            
            return r
        else:
            if errors:
                errors = ExtJSWrapper.build_errors(errors)
                return {
                    'type': 'exception',
                    'message': errors['msg'],
                    'where': 'n/a'
                }
            else:
                return {
                    'result': result,
                    'type': db['type'],
                    'tid': db['tid'],
                    'action': db['action'],
                    'method': db['method'],
                }

    def parse(self, items):
        if len(items) == 1:
            # check for a batch request
            key, value = items.items()[0]
            if value == '':
                data = json.loads(key)
                if isinstance(data, dict):
                    yield self.parse_item(data)
                elif isinstance(data, (tuple, list)):
                    for item in data:
                        yield self.parse_item(item)
                else:
                    raise ValueError(u'Unsupported input format.')
            else:
                raise ValueError(u'Unsupported input format.')
        else:
            s = self.parse_item(items)
            yield s
    
    def parse_item(self, data):
        if data.has_key('extMethod'):
            # formHandler true
            d = {
                '_call': data.pop('extMethod', ''),
            }
            
            tid = data.pop('extTID', '')
            action = data.pop('extAction', '')
            method = d['_call']
            type = data.pop('extType', '')

            if not hasattr(self.session._internal, 'extdirect'):
                self.session._internal.extdirect = []

            db = {}
            db['formHandler'] = True
            db['type'] = type
            db['action'] = action
            db['method'] = method
            db['tid'] = tid
            self.session._internal.extdirect.append(db)

            d.update(data)
            return d
        else:
            # formHandle false
            d = {
                '_call': data.pop('method', ''),
            }

            if data.get('data') and len(data['data']) > 0 and \
                not isinstance(data['data'][0], dict):
                raise ValueError(u'data must be a hashable/an array of key/value arguments')

            tid = data.pop('tid', '')
            action = data.pop('action', '')
            method = d['_call']
            type = data.pop('type', '')

            if not hasattr(self.session._internal, 'extdirect'):
                self.session._internal.extdirect = []

            db = {}
            db['formHandler'] = False
            db['type'] = type
            db['action'] = action
            db['method'] = method
            db['tid'] = tid
            self.session._internal.extdirect.append(db)

            data = data.get('data')
            if data:
                data = data[0]
            else:
                data = {}
            d.update(data)
            return d

wrappers.register('default', DefaultWrapper)
wrappers.register('extjsform', ExtJSFormWrapper)
wrappers.register('extjsstore', ExtJSStoreWrapper)
wrappers.register('extjsdirect', ExtJSDirectWrapper)
########NEW FILE########
__FILENAME__ = feature
# -*- coding: utf-8 -*-

import cPickle
import hashlib

from simpleapi.message.common import SAException

try:
    from django.core.cache import cache

    has_django = True
except:
    has_django = False

__all__ = ('__features__', 'Feature', 'FeatureException', 'FeatureContentResponse')


class FeatureException(SAException): pass


class FeatureContentResponse(FeatureException): pass


class Feature(object):
    def __init__(self, ns_config):
        self.ns_config = ns_config
        self.setup()

    def error(self, errmsg):
        raise FeatureException(errmsg)

    def get_config_scope(self, request):
        assert self.has_config()

        conf_name, conf_type = self._get_config_values()

        if hasattr(self, '__config__'):
            function_location = hasattr(request.session.function['method'], conf_name)

            if function_location:
                return u'local:%s' % request.session.function['name']
            else:
                return 'global'
        elif hasattr(self, '__function_config__'):
            return u'local:%s' % request.session.function['name']
        elif hasattr(self, '__class_config__'):
            return 'global'

    def has_config(self):
        return hasattr(self, '__config__') or hasattr(self, '__class_config__') or \
               hasattr(self, '__function_config__')

    def get_config(self, request):
        assert self.has_config()

        conf_name, conf_type = self._get_config_values()

        if hasattr(self, '__config__'):
            class_value = getattr(request.session.namespace['nmap']['class'], conf_name, None)
            function_value = getattr(request.session.function['method'], conf_name, None)

            # prefer function based conf. over class based conf.
            if function_value is not None:
                return function_value
            else:
                return class_value
        elif hasattr(self, '__function_config__'):
            return getattr(request.session.function['method'], conf_name, None)
        elif hasattr(self, '__class_config__'):
            return getattr(request.session.namespace['nmap']['class'], conf_name, None)

    def _get_config_values(self):
        if hasattr(self, '__config__'):
            conf_name, conf_type = self.__config__
        elif hasattr(self, '__function_config__'):
            conf_name, conf_type = self.__function_config__
        elif hasattr(self, '__class_config__'):
            conf_name, conf_type = self.__class_config__

        return conf_name, conf_type

    def is_triggered(self, request):
        if self.has_config():
            conf_name, conf_type = self._get_config_values()
            conf_value = self.get_config(request)
            if isinstance(conf_value, conf_type):
                return True
            else:
                return False
        else:
            return True

    def _handle_request(self, request):
        if self.is_triggered(request):
            self.handle_request(request)

    def _handle_response(self, response):
        if self.is_triggered(response):
            self.handle_response(response)

    def setup(self):
        pass

    def handle_request(self, request):
        pass

    def handle_response(self, response):
        pass


class CachingFeature(Feature):
    __config__ = ('caching', (dict, bool))

    def setup(self):
        assert has_django, 'Works currently with django only'

    def handle_request(self, request):
        caching_config = self.get_config(request)

        if caching_config:
            arg_signature = hashlib.md5(cPickle.dumps(
                request.session.arguments)).hexdigest()

            timeout = 60 * 60
            prefix = None

            if isinstance(caching_config, dict):
                timeout = caching_config.get('timeout', timeout)
                prefix = caching_config.get('key', None)
                if callable(prefix):
                    prefix = prefix(request)

            key = '%s_%s' % (
                prefix or ('simpleapi_%s' % request.session.function['name']),
                arg_signature,
            )

            content = cache.get(key)

            if content:
                raise FeatureContentResponse(cPickle.loads(content))
            else:
                request.session.cache_timeout = timeout
                request.session.cache_key = key
                request.session.want_cached = True

    def handle_response(self, response):
        # only cache if function returns no errors!
        if hasattr(response.session, 'want_cached') and not response.errors:
            cache.set(
                response.session.cache_key,
                cPickle.dumps(response.result),
                response.session.cache_timeout
            )


class ThrottlingFeature(Feature):
    __config__ = ('throttling', dict)

    def setup(self):
        assert has_django, 'Works currently with django only'

    def handle_request(self, request):
        throttling_config = self.get_config(request)
        scope = self.get_config_scope(request)

        rps = throttling_config.get('rps', 0)
        rpm = throttling_config.get('rpm', 0)
        rph = throttling_config.get('rph', 0)

        assert rps >= 0
        assert rpm >= 0
        assert rph >= 0

        remote_addr = request.session.request.remote_addr
        key = 'simpleapi_throttling_%s:%s' % (scope, remote_addr)
        rps_key = '%s_rps' % key
        rpm_key = '%s_rpm' % key
        rph_key = '%s_rph' % key

        # increment + check limits
        if rps > 0:
            no = cache.get(rps_key, 1)
            if no >= rps:
                self.error(u'Throttling active (exceeded %s #/sec.)' % no)
            else:
                try:
                    cache.incr(rps_key) # FIXME: using incr() eliminates the timeout!
                except ValueError:
                    cache.set(rps_key, 1, 1)

        if rpm > 0:
            no = cache.get(rpm_key, 1)
            if no >= rpm:
                self.error(u'Throttling active (exceeded %s #/min.)' % no)
            else:
                try:
                    cache.incr(rpm_key)
                except ValueError:
                    cache.set(rpm_key, 1, 60)

        if rph > 0:
            no = cache.get(rph_key, 1)
            if no >= rph:
                self.error(u'Throttling active (exceeded %s #/hour)' % no)
            else:
                try:
                    cache.incr(rph_key)
                except ValueError:
                    cache.set(rph_key, 1, 60 * 60)


__features__ = {
    'caching': CachingFeature,
    'throttling': ThrottlingFeature
}
########NEW FILE########
__FILENAME__ = namespace
# -*- coding: utf-8 -*-

from simpleapi.message.common import json, SAException
from response import UnformattedResponse

__all__ = ('Namespace', 'NamespaceException')

class NamespaceException(SAException): pass
class Namespace(object):

    def __init__(self, request):
        self.request = request
        self.session = request.session

    def error(self, *errors):
        errors = list(errors)
        if len(errors) == 1:
            errors = errors[0]
        raise NamespaceException(errors)

    def introspect(self, framework='default', provider='Ext.app',
                   namespace=None):
        if framework not in ['default', 'extjsdirect']:
            self.error('Framework unknown.')

        version = getattr(self, '__version__', 'default')
        function_map = self.request.route.nmap[version]['functions']

        if framework == 'extjsdirect':
            functions = {}
            for cls in ('forms', 'direct'):
                functions[cls] = []
                for fn in function_map.iterkeys():
                    if len(function_map[fn]['args']['all']) > 0:
                        fnlen = 1
                    else:
                        fnlen = 0

                    functions[cls].append({
                        'name': fn,
                        'len': fnlen,
                        'formHandler': cls == 'forms',
                    })

            result = {
                'actions': {
                    self.request.route.name: functions['direct'],
                    u'%s_forms' % self.request.route.name: functions['forms'],
                }
            }

            result['type'] = 'remoting'
            result['url'] = u'%s?_wrapper=extjsdirect' % \
                self.session.request.path_info
            if namespace:
                result['namespace'] = namespace
            return UnformattedResponse(
                content=u'%s.%s_REMOTING_API = %s;' %\
                    (provider, self.request.route.name.upper(),
                     json.dumps(result)),
                mimetype='text/javascript'
            )
        else:
            functions = []
            for fn in function_map.iterkeys():
                print function_map[fn]['args']
                optionals = list(set(function_map[fn]['args']['all']) - \
                    set(function_map[fn]['args']['obligatory']))
                functions.append({
                    'name': fn,
                    'args': {
                        'len': len(function_map[fn]['args']['all']),
                        'obligatory': {
                            'len': len(function_map[fn]['args']['obligatory']),
                            'names': function_map[fn]['args']['obligatory'],
                        },
                        'optional': {
                            'len': len(optionals),
                            'names': optionals,
                        },
                        'kwargs_allowed': function_map[fn]['args']['kwargs_allowed'],
                    },
                })

            result = {
                'actions': {
                    self.request.route.name: functions
                }
            }

        return result
########NEW FILE########
__FILENAME__ = preformat
# -*- coding: utf-8 -*-

try:
    from django.db.models import Model
    from django.db.models.query import QuerySet
    has_django = True
except:
    has_django = False

try:
    import mongoengine
    has_mongoengine = True
except ImportError:
    has_mongoengine = False

from serializer import SerializedObject

__all__ = ()

class Preformatter(object):
    def handle_value(self, value):
        if getattr(type(value), '__name__', 'n/a') == 'dict':
            return self.handle_dict(value)
        elif getattr(type(value), '__name__', 'n/a') == 'list':
            return self.handle_list(value)
        else:
            return self.parse_value(value)

    def parse_value(self, value):
        if has_django and isinstance(value, (Model, QuerySet)):
            value = SerializedObject(value)

        if has_mongoengine and isinstance(value,
           (mongoengine.document.BaseDocument,
                mongoengine.queryset.QuerySet)):
            value = SerializedObject(value)

        if isinstance(value, SerializedObject):
            return value.to_python()

        return value

    def handle_list(self, old_list):
        new_list = []
        for item in old_list:
            new_list.append(self.handle_value(item))
        return new_list

    def handle_dict(self, old_dict):
        new_dict = {}
        for key, value in old_dict.iteritems():
            new_dict[key] = self.handle_value(value)
        return new_dict

    def run(self, result):
        return self.handle_value(result)
########NEW FILE########
__FILENAME__ = request
# -*- coding: utf-8 -*-

import tempfile
import pprint
try:
    import cProfile
    import pstats
    has_debug = True
except ImportError:
    has_debug = False

from response import Response
from feature import FeatureContentResponse
from simpleapi.message import formatters
from simpleapi.message.common import SAException

try:
    from django.core.exceptions import ObjectDoesNotExist as django_notexist
    has_django = True
except:
    has_django = False

try:
    from mongoengine.queryset import DoesNotExist as mongoengine_notexist
    has_mongoengine = True
except ImportError:
    has_mongoengine = False

__all__ = ('Request', 'RequestException')

class RequestException(SAException): pass
class Request(object):

    def __init__(self, sapi_request, namespace, input_formatter,
                 output_formatter, wrapper, callback, mimetype, restful,
                 debug, route, ignore_unused_args):
        self.sapi_request = sapi_request
        self.namespace = namespace
        self.input_formatter = input_formatter
        self.output_formatter = output_formatter
        self.wrapper = wrapper
        self.callback = callback
        self.mimetype = mimetype
        self.restful = restful
        self.debug = debug
        self.route = route
        self.ignore_unused_args = ignore_unused_args
        self.session = sapi_request.session

    def process_request(self, request_items):
        # set all required simpleapi arguments
        access_key = request_items.pop('_access_key', None)
        method = request_items.pop('_call', None)

        if self.restful:
            method = self.sapi_request.method.lower()

        data = request_items.pop('_data', None)

        # update session
        self.session.request = self.sapi_request
        self.session.mimetype = self.mimetype
        self.session.callback = self.callback
        self.session.access_key = access_key

        # make all uploaded files available
        if self.route.is_django():
            self.session.files = self.sapi_request.FILES

        # instantiate namespace
        local_namespace = self.namespace['class'](self)
        self.session._internal.namespace = {
            'nmap': self.namespace,
            'instance': local_namespace
        }

        # check the method
        if not method:
            raise RequestException(u'Method must be provided.')

        # check whether method exists
        if not self.namespace['functions'].has_key(method):
            raise RequestException(u'Method %s does not exist.' % method)

        # check authentication
        if not self.namespace['authentication'](local_namespace, access_key):
            raise RequestException(u'Authentication failed.')

        # check ip address
        if not self.namespace['ip_restriction'](local_namespace, \
                                                self.sapi_request.remote_addr):
            raise RequestException(u'You are not allowed to access.')

        function = self.namespace['functions'][method]
        self.session.function = function

        # check allowed HTTP methods
        if not function['methods']['function'](self.sapi_request.method, function['methods']['allowed_methods']):
            raise RequestException(u'Method not allowed: %s' % self.sapi_request.method)

        # if data is set, make sure input formatter is not ValueFormatter
        if data:
            if isinstance(self.input_formatter, formatters['value']):
                raise RequestException(u'If you\'re using _data please make ' \
                                        'sure you set _input and _input is not ' \
                                        '\'value\'.')
            try:
                request_items = self.input_formatter.kwargs(data, 'parse')
            except ValueError, _:
                raise RequestException(u'Data couldn\'t be decoded. ' \
                                        'Please check _input and your _data')
            else:
                if not isinstance(request_items, dict):
                    raise RequestException(u'_data must be an array/dictionary')

        # check whether all obligatory arguments are given
        ungiven_obligatory_args = list(set(function['args']['obligatory']) - \
            set(request_items.keys()))
        if ungiven_obligatory_args:
            raise RequestException(u'Obligatory argument(s) missing: %s' % \
                ", ".join(ungiven_obligatory_args))

        # check whether there are more arguments than needed
        if not function['args']['kwargs_allowed']:
            unused_arguments = list(set(request_items.keys()) - \
                set(function['args']['all']))

            if unused_arguments:
                if not self.ignore_unused_args:
                    raise RequestException(u'Unused arguments: %s' % \
                    ", ".join(unused_arguments))
                else:
                    for key in unused_arguments:
                        del request_items[key]

        # decode incoming variables (only if _data is not set!)
        if not data:
            new_request_items = {}
            for key, value in request_items.iteritems():
                try:
                    new_request_items[str(key)] = self.input_formatter.kwargs(value, 'parse')
                except ValueError, _:
                    raise
                    raise RequestException(u'Value for %s couldn\'t be decoded.' % \
                        key)
            request_items = new_request_items
        else:
            # make sure all keys are strings, not unicodes (for compatibility 
            # issues: Python < 2.6.5)
            new_request_items = {}
            for key, value in request_items.iteritems():
                new_request_items[str(key)] = value
            request_items = new_request_items

        # check constraints
        for key, value in request_items.iteritems():
            try:
                request_items[key] = function['constraints']['function'](
                    local_namespace, key, value)
            except (ValueError,):
                raise RequestException(u'Constraint failed for argument: %s' % key)

        # we're done working on arguments, pass it to the session
        self.session.arguments = request_items

        # call feature: handle_request
        try:
            for feature in self.namespace['features']:
                feature._handle_request(self)
        except FeatureContentResponse, e:
            result = e
        else:
            # call before_request
            if hasattr(local_namespace, 'before_request'):
                getattr(local_namespace, 'before_request')(self, self.session)
            
            # make the call
            try:
                if self.debug:
                    _, fname = tempfile.mkstemp()
                    self.route.logger.debug(u"Profiling call '%s': %s" % \
                        (method, fname))

                    self.route.logger.debug(u"Calling parameters: %s" % \
                        pprint.pformat(request_items))

                    profile = cProfile.Profile()
                    result = profile.runcall(getattr(local_namespace, method),
                        **request_items)
                    profile.dump_stats(fname)
                    
                    self.route.logger.debug(u"Loading stats...")
                    stats = pstats.Stats(fname)
                    stats.strip_dirs().sort_stats('time', 'calls') \
                        .print_stats(25)
                else:
                    result = getattr(local_namespace, method)(**request_items)
            except Exception, e:
                if has_django and isinstance(e, django_notexist):
                    raise RequestException(e)
                elif has_mongoengine and isinstance(e, mongoengine_notexist):
                    raise RequestException(e)
                else:
                    raise

        # if result is not a Response, create one
        if not isinstance(result, Response):
            response = Response(
                sapi_request=self.sapi_request,
                namespace=self.namespace,
                result=result,
                output_formatter=self.output_formatter,
                wrapper=self.wrapper,
                mimetype=self.mimetype,
                function=function
            )
        else:
            response = result

        return response
########NEW FILE########
__FILENAME__ = response
# -*- coding: utf-8 -*-

try:
    from django.http import HttpResponse as DjangoHttpResponse

    has_django = True
except:
    has_django = False

try:
    from flask import Response as FlaskResponse

    has_flask = True
except ImportError:
    has_flask = False

from simpleapi.message import formatters, wrappers
from preformat import Preformatter

__all__ = ('Response', 'ResponseMerger', 'ResponseException', 'UnformattedResponse')


class UnformattedResponse(object):
    def __init__(self, content, mimetype="text/html"):
        self.content = content
        self.mimetype = mimetype


class ResponseMerger(object):
    def __init__(self, sapi_request, responses):
        self.sapi_request = sapi_request
        self.responses = responses

    def build(self):
        if len(self.responses) == 1:
            return self.responses[0].build()
        else:
            results = []
            for response in self.responses:
                if response.has_errors():
                    results.append(response.build(
                        managed=True,
                        skip_features=True
                    ))
                else:
                    results.append(response.build(
                        managed=True
                    ))

            # TODO FIXME XXX: only JSON is supported
            result = u'[%s]' % u','.join(map(lambda x: x['result'], results))

            return Response._build_response_obj(
                sapi_request=self.sapi_request,
                response={
                    'result': result,
                    'mimetype': results[0]['mimetype']
                }
            )


class ResponseException(object): pass


class Response(object):
    def __init__(self, sapi_request, namespace=None, output_formatter=None,
                 wrapper=None, errors=None, result=None, mimetype=None,
                 callback=None, function=None):
        assert isinstance(errors, (basestring, list)) or errors is None

        self.sapi_request = sapi_request
        self.namespace = namespace
        self.errors = errors
        self.result = self._preformat(result)
        self.mimetype = mimetype
        self.callback = None
        self.function = function

        self.output_formatter = output_formatter or formatters['json']
        self.wrapper = wrapper or wrappers['default']
        self.mimetype = mimetype or self.output_formatter.__mime__

        self.session = self.sapi_request.session

    def has_errors(self):
        return self.errors is not None

    def add_error(self, errmsg):
        if self.errors is None:
            self.errors = [errmsg, ]
        else:
            if isinstance(self.errors, list):
                self.errors.append(errmsg)
            elif isinstance(self.errors, basestring):
                self.errors = [self.errors, errmsg]

    def _preformat(self, value):
        if not isinstance(value, UnformattedResponse):
            # don't preformat UnformattedResponse
            preformatter = Preformatter()
            return preformatter.run(value)
        return value

    def build(self, skip_features=False, managed=False):
        # call after_request
        if hasattr(self.session._internal, 'namespace'):
            namespace_instance = self.session._internal.namespace['instance']
            if hasattr(namespace_instance, 'after_request'):
                getattr(namespace_instance, 'after_request')(self, self.session)

        # call feature: handle_response
        if self.namespace and not skip_features:
            for feature in self.namespace['features']:
                feature._handle_response(self)

        if not isinstance(self.result, UnformattedResponse):
            # pass result to custom format function
            if self.function:
                self.result = self.function['format'](self.result)

            if isinstance(self.output_formatter, type):
                self.output_formatter = self.output_formatter(
                    sapi_request=self.sapi_request,
                    callback=self.callback
                )

            if isinstance(self.wrapper, type):
                self.wrapper = self.wrapper(
                    sapi_request=self.sapi_request
                )

            wrapper_result = self.wrapper._build(
                errors=self.errors,
                result=self.result,
            )
            formatter_result = self.output_formatter.build(wrapper_result)
        else:
            self.mimetype = self.result.mimetype
            formatter_result = self.result.content

        result = {'result': formatter_result, 'mimetype': self.mimetype}
        if managed:
            return result
        else:
            return self._build_response_obj(self.sapi_request, result)

    @staticmethod
    def _build_response_obj(sapi_request, response):
        if sapi_request.route.is_flask():
            assert has_flask, \
                'Flask is required (or change framework Route-setting)'
            return FlaskResponse(
                response=response['result'],
                mimetype=response['mimetype']
            )
        elif sapi_request.route.is_django():
            assert has_django, \
                'Django is required (or change framework Route-setting)'
            return DjangoHttpResponse(
                response['result'],
                content_type=response['mimetype']
            )
        else:
            return response
########NEW FILE########
__FILENAME__ = route
# -*- coding: utf-8 -*-

import types
import copy
import inspect
import pprint
import re
import sys
import os
import pdb
import warnings
import logging

try:
    import cProfile
    import pstats
    has_debug = True
except ImportError:
    has_debug = False

import urlparse
import cgi
from wsgiref.simple_server import make_server
from wsgiref.handlers import SimpleHandler

SIMPLEAPI_DEBUG = bool(int(os.environ.get('SIMPLEAPI_DEBUG', 0)))
SIMPLEAPI_DEBUG_FILENAME = os.environ.get('SIMPLEAPI_DEBUG_FILENAME',
    'simpleapi.profile')
SIMPLEAPI_DEBUG_LEVEL = os.environ.get('SIMPLEAPI_DEBUG_LEVEL', 'all')
assert SIMPLEAPI_DEBUG_LEVEL in ['all', 'call'], \
    u'SIMPLEAPI_DEBUG_LEVEL must be one of these: all, call'

if SIMPLEAPI_DEBUG and not has_debug:
    SIMPLEAPI_DEBUG = False
    warnings.warn("Debugging disabled since packages pstats/cProfile not found (maybe you have to install it).")

TRIGGERED_METHODS = ['get', 'post', 'put', 'delete']
FRAMEWORKS = ['flask', 'django', 'appengine', 'dummy', 'standalone', 'wsgi']
MAX_CONTENT_LENGTH = 1024 * 1024 * 16 # 16 megabytes

restricted_functions = [
    'before_request',
    'after_request'
]

try:
    from google.appengine.ext.webapp import RequestHandler as AE_RequestHandler
    has_appengine = True
except ImportError:
    has_appengine = False

from simpleapi.message.common import SAException
from sapirequest import SAPIRequest
from request import Request, RequestException
from response import Response, ResponseMerger, ResponseException
from namespace import NamespaceException
from feature import __features__, Feature, FeatureException
from simpleapi.message import formatters, wrappers
from utils import glob_list

__all__ = ('Route', )

class Route(object):

    def __new__(cls, *args, **kwargs):
        if kwargs.get('framework') == 'appengine':
            assert has_appengine
            class AppEngineRouter(AE_RequestHandler):
                def __getattribute__(self, name):
                    if name in TRIGGERED_METHODS:
                        self.request.method = name
                        return self
                    else:
                        return AE_RequestHandler.__getattribute__(self, name)
                                
                def __call__(self):
                    result = self.router(self.request)
                    self.response.out.write(result['result'])
            
            AppEngineRouter.router = Router(*args, **kwargs)
            return AppEngineRouter
        elif kwargs.get('framework') == 'flask':
            obj = Router(*args, **kwargs)
            obj.__name__ = 'Route'
            return obj
        elif kwargs.get('framework') == 'wsgi':
            router = Router(*args, **kwargs)
            class WSGIHandler(object):
                def __call__(self, *args, **kwargs):
                    return self.router.handle_request(*args, **kwargs)
            handler = WSGIHandler()
            handler.router = router
            return handler
        else:
            return Router(*args, **kwargs)

class StandaloneRequest(object): pass
class RouterException(SAException): pass
class Router(object):

    def __init__(self, *namespaces, **kwargs):
        """Takes at least one namespace. 
        """
        self.name = kwargs.pop('name', str(id(self)))
        self.logger = logging.getLogger("simpleapi.%s" % self.name)
        self.nmap = {}
        self.debug = kwargs.pop('debug', False)
        self.ignore_unused_args = kwargs.pop('ignore_unused_args', False)

        if self.debug and not has_debug:
            self.debug = False
            warnings.warn("Debugging disabled since packages pstats/cProfile not found (maybe you have to install it).")

        self.restful = kwargs.pop('restful', False)
        self.framework = kwargs.pop('framework', 'django')
        self.path = re.compile(kwargs.pop('path', r'^/'))

        assert len(kwargs) == 0, u'Unknown Route configuration(s) (%s)' % \
            ", ".join(kwargs.keys())

        # make shortcut 
        self._caller = self.__call__

        assert self.framework in FRAMEWORKS
        assert (self.debug ^ SIMPLEAPI_DEBUG) or \
            not (self.debug and SIMPLEAPI_DEBUG), \
            u'You can either activate Route-debug or simpleapi-debug, not both.'

        if self.debug or SIMPLEAPI_DEBUG:
            self.logger.setLevel(logging.DEBUG)
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                "%(asctime)s - %(name)s - %(levelname)s - %(message)s")
            handler.setFormatter(formatter)
            self.logger.addHandler(handler)
        else:
            self.logger.setLevel(logging.WARNING)
        
        if SIMPLEAPI_DEBUG and SIMPLEAPI_DEBUG_LEVEL == 'all':
            self.profile_start()

        for namespace in namespaces:
            self.add_namespace(namespace)

    def handle_request(self, environ, start_response):
        if not self.path.match(environ.get('PATH_INFO')): 
            status = '404 Not found'
            start_response(status, [])
            return ["Entry point not found"]
        else:
            content_type = environ.get('CONTENT_TYPE')
            try:
                content_length = int(environ['CONTENT_LENGTH'])
            except (KeyError, ValueError):
                content_length = 0

            # make sure we ignore too large requests for security and stability
            # reasons
            if content_length > MAX_CONTENT_LENGTH:
                status = '413 Request entity too large'
                start_response(status, [])
                return ["Request entity too large"]

            request_method = environ.get('REQUEST_METHOD', '').lower()

            # make sure we only support methods we care
            if not request_method in TRIGGERED_METHODS:
                status = '501 Not Implemented'
                start_response(status, [])
                return ["Not Implemented"]

            query_get = urlparse.parse_qs(environ.get('QUERY_STRING'))
            for key, value in query_get.iteritems():
                query_get[key] = value[0] # respect the first value only

            query_post = {}
            if content_type in ['application/x-www-form-urlencoded', 
                'application/x-url-encoded']:
                post_env = environ.copy()
                post_env['QUERY_STRING'] = ''
                fs = cgi.FieldStorage(
                    fp=environ['wsgi.input'],
                    environ=post_env,
                    keep_blank_values=True
                )
                query_post = {}
                for key in fs:
                    query_post[key] = fs.getvalue(key)
            elif content_type == 'multipart/form-data':
                # XXX TODO
                raise NotImplementedError, u'Currently not supported.' 
            
            # GET + POST 
            query_data = query_get
            query_data.update(query_post)

            # Make request
            request = StandaloneRequest()
            request.method = request_method
            request.data = query_data
            request.remote_addr = environ.get('REMOTE_ADDR', '')

            # Make call
            result = self._caller(request)

            status = '200 OK'
            headers = [('Content-type', result['mimetype'])]
            start_response(status, headers)
            return [result['result'],]

    def serve(self, host='', port=5050):
        httpd = make_server(host, port, self.handle_request)
        self.logger.info(u"Started serving on port %d..." % port)
        try:
            httpd.serve_forever()
        except KeyboardInterrupt:
            self.logger.info(u"Server stopped.")

    def profile_start(self):
        assert has_debug
        self.profile = cProfile.Profile()
        self.profile.enable()
    
    def profile_stop(self):
        assert has_debug
        self.profile.disable()
        self.profile.dump_stats(SIMPLEAPI_DEBUG_FILENAME)

    def profile_stats(self):
        assert has_debug
        self.logger.debug(u"Loading stats...")
        stats = pstats.Stats(SIMPLEAPI_DEBUG_FILENAME)
        stats.strip_dirs().sort_stats('time', 'calls') \
            .print_stats()

    def __del__(self):
        if SIMPLEAPI_DEBUG and SIMPLEAPI_DEBUG_LEVEL == 'all':
            self.profile_stop()
            self.profile_stats()

    def is_standalone(self):
        return self.framework in ['standalone', 'wsgi']

    def is_dummy(self):
        return self.framework == 'dummy'

    def is_appengine(self):
        return self.framework == 'appengine'

    def is_flask(self):
        return self.framework == 'flask'

    def is_django(self):
        return self.framework == 'django'

    def _redefine_default_namespace(self):
        # - recalculate default namespace version -
        # if map has no default version, determine namespace with the
        # highest version
        if self.nmap.has_key('default'):
            del self.nmap['default']
        self.nmap['default'] = self.nmap[max(self.nmap.keys())]

    def remove_namespace(self, version):
        if self.nmap.has_key(version):
            del self.nmap[version]
            self._redefine_default_namespace()
            return True
        else:
            return False

    def add_namespace(self, namespace):
        version = getattr(namespace, '__version__', 1)
        assert isinstance(version, int), \
            u'version must be either an integer or not set'

        # make sure no version is assigned twice
        assert not self.nmap.has_key(version), u'version is assigned twice'

        allowed_functions = []

        # check for introspection allowed
        if getattr(namespace, '__introspection__', False):
            allowed_functions.append('introspect')

        # determine public and published functions
        functions = filter(lambda item: '__' not in item[0] and item[0] not in 
            restricted_functions and ((getattr(item[1], 'published', False) ==
            True) or item[0] in allowed_functions),
            inspect.getmembers(namespace))

        # determine arguments of each function
        functions = dict(functions)
        for function_name, function_method in functions.iteritems():
            # check for reserved function names
            assert function_name not in ['error', '__init__', 'get_name'],\
                u'Name %s is reserved.' % function_name
            
            # ArgSpec(args=['self', 'a', 'b'], varargs=None, keywords=None, defaults=None)
            raw_args = inspect.getargspec(function_method)

            # does the function allows kwargs?
            kwargs_allowed = raw_args[2] is not None

            # get all arguments
            all_args = raw_args[0][1:] # exclude `self´

            # build a dict of optional arguments
            if raw_args[3] is not None:
                default_args = zip(
                    raw_args[0][-len(raw_args[3]):],
                    raw_args[3]
                )
                default_args = dict(default_args)
            else:
                default_args = {}

            # build a list of obligatory arguments
            obligatory_args = list(set(all_args) - set(default_args.keys()))

            # determine constraints for function
            if hasattr(function_method, 'constraints'):
                constraints = function_method.constraints
                assert isinstance(constraints, dict) or callable(constraints)

                if isinstance(constraints, dict):
                    def check_constraint(constraints):
                        def check(namespace, key, value):
                            constraint = constraints.get(key)
                            if not constraint:
                                return value
                            if hasattr(constraint, 'match'):
                                if constraint.match(value):
                                    return value
                                else:
                                    raise ValueError(u'%s does not match constraint')
                            else:
                                if isinstance(constraint, bool):
                                    return bool(int(value))
                                else:
                                    return constraint(value)
                        return check

                    constraint_function = check_constraint(constraints)
                elif callable(constraints):
                    constraint_function = constraints
            else:
                constraints = None
                constraint_function = lambda namespace, key, value: value

            # determine allowed methods
            if hasattr(function_method, 'methods'):
                allowed_methods = function_method.methods
                assert isinstance(allowed_methods, (list, tuple))
                method_function = lambda method, methods: method in methods
            else:
                allowed_methods = None
                method_function = lambda method, methods: True

            # determine format
            format = getattr(function_method, 'format', lambda val: val)

            functions[function_name] = {
                'method': function_method,
                'name': function_name,
                'args': {
                    'raw': raw_args,
                    'all': all_args,

                    'obligatory': obligatory_args,
                    'defaults': default_args,

                    'kwargs_allowed': kwargs_allowed
                },
                'constraints': {
                    'function': constraint_function,
                    'raw': constraints,
                },
                'format': format,
                'methods': {
                    'function': method_function,
                    'allowed_methods': allowed_methods,
                }
            }

        # configure authentication
        if hasattr(namespace, '__authentication__'):
            authentication = namespace.__authentication__
            if isinstance(authentication, basestring):
                if hasattr(namespace, authentication):
                    authentication = getattr(namespace, authentication)
                else:
                    authentication = lambda namespace, access_key: \
                        namespace.__authentication__ == access_key
        else:
            # grant allow everyone access
            authentication = lambda namespace, access_key: True

        # configure ip address based access rights
        if hasattr(namespace, '__ip_restriction__'):
            ip_restriction = namespace.__ip_restriction__
            assert isinstance(ip_restriction, list) or callable(ip_restriction)

            if isinstance(ip_restriction, list):
                # make the ip address list wildcard searchable
                namespace.__ip_restriction__ = \
                    glob_list(namespace.__ip_restriction__)

                # restrict access to the given ip address list
                ip_restriction = lambda namespace, ip: ip in \
                    namespace.__ip_restriction__
        else:
            # accept every ip address
            ip_restriction = lambda namespace, ip: True

        # configure input formatters
        input_formatters = formatters.copy()
        allowed_formatters = getattr(namespace, '__input__', 
            formatters.get_defaults())
        input_formatters = filter(lambda i: i[0] in allowed_formatters,
            input_formatters.items())
        input_formatters = dict(input_formatters)

        # configure output formatters
        output_formatters = formatters.copy()
        allowed_formatters = getattr(namespace, '__output__',
            formatters.get_defaults())
        output_formatters = filter(lambda i: i[0] in allowed_formatters,
            output_formatters.items())
        output_formatters = dict(output_formatters)

        # configure wrappers
        useable_wrappers = wrappers.copy()
        if hasattr(namespace, '__wrapper__'):
            allowed_wrapper = namespace.__wrapper__
            useable_wrappers = filter(lambda i: i[0] in allowed_wrapper,
                useable_wrappers.items())
            useable_wrappers = dict(useable_wrappers)

        self.nmap[version] = {
            'class': namespace,
            'functions': functions,
            'ip_restriction': ip_restriction,
            'authentication': authentication,
            'input_formatters': input_formatters,
            'output_formatters': output_formatters,
            'wrappers': useable_wrappers,
        }

        # set up all features
        features = []
        if hasattr(namespace, '__features__'):
            raw_features = namespace.__features__
            for feature in raw_features:
                assert isinstance(feature, basestring) or \
                    issubclass(feature, Feature)

                if isinstance(feature, basestring):
                    assert feature in __features__.keys(), \
                        u'%s is not a built-in feature' % feature

                    features.append(__features__[feature](self.nmap[version]))
                elif issubclass(feature, Feature):
                    features.append(feature(self.nmap[version]))

        self.nmap[version]['features'] = features
        self._redefine_default_namespace()

        return version

    def __call__(self, http_request=None, **urlparameters):
        sapi_request = SAPIRequest(self, http_request)
        request_items = dict(sapi_request.REQUEST.items())
        request_items.update(urlparameters)

        if SIMPLEAPI_DEBUG and SIMPLEAPI_DEBUG_LEVEL == 'call':
            self.logger.info(pprint.pformat(request_items))
            self.profile_start()

        version = request_items.pop('_version', 'default')
        callback = request_items.pop('_callback', None)
        output_formatter = request_items.pop('_output', None)

        # let's activate JSONP automatically if _callback is given
        if callback and not output_formatter:
            output_formatter = 'jsonp'
        elif not output_formatter:
            output_formatter = 'json'

        input_formatter = request_items.pop('_input', 'value')
        wrapper = request_items.pop('_wrapper', 'default')
        mimetype = request_items.pop('_mimetype', None)

        input_formatter_instance = None
        output_formatter_instance = None
        wrapper_instance = None

        try:
            try:
                version = int(version)
            except (ValueError, TypeError):
                pass
            if not self.nmap.has_key(version):
                # continue with wrong version to get the formatters/wrappers
                # raise the error later!
                namespace = self.nmap['default']
            else:
                namespace = self.nmap[version]

            # check input formatter
            if input_formatter not in namespace['input_formatters']:
                raise RequestException(u'Input formatter not allowed or ' \
                                        'unknown: %s' % input_formatter)

            # get input formatter
            input_formatter_instancec = namespace['input_formatters'][input_formatter](sapi_request, callback)

            # check output formatter
            if output_formatter not in namespace['output_formatters']:
                raise RequestException(u'Output formatter not allowed or ' \
                                        'unknown: %s' % output_formatter)

            # get output formatter
            output_formatter_instance = namespace['output_formatters'][output_formatter](sapi_request, callback)

            # check wrapper
            if wrapper not in namespace['wrappers']:
                raise RequestException(u'Wrapper unknown or not allowed: %s' % \
                    wrapper)

            # get wrapper
            wrapper_instance = namespace['wrappers'][wrapper]

            # check whether version exists or not
            if not self.nmap.has_key(version):
                raise RouterException(u'Version %s not found (possible: %s)' % \
                    (version, ", ".join(map(lambda i: str(i), self.nmap.keys()))))

            request = Request(
                sapi_request=sapi_request,
                namespace=namespace,
                input_formatter=input_formatter_instancec,
                output_formatter=output_formatter_instance,
                wrapper=wrapper_instance,
                callback=callback,
                mimetype=mimetype,
                restful=self.restful,
                debug=self.debug,
                route=self,
                ignore_unused_args=self.ignore_unused_args,
            )

            # map request items to the correct names
            wi = wrapper_instance(sapi_request=sapi_request)
            request_items = wi._parse(request_items)
            if not isinstance(request_items,
                (list, tuple, types.GeneratorType)):
                request_items = [request_items, ]

            responses = []
            for request_item in request_items:
                # clear session (except _internal)
                sapi_request.session.clear()

                # process request
                try:
                    responses.append(request.process_request(request_item))
                except (NamespaceException, RequestException, \
                        ResponseException, RouterException, FeatureException),e:
                    response = Response(
                        sapi_request,
                        errors=e.message,
                        output_formatter=output_formatter_instance,
                        wrapper=wrapper_instance,
                        mimetype=mimetype
                    )
                    responses.append(response)

            rm = ResponseMerger(
                sapi_request=sapi_request,
                responses=responses,
            )
            http_response = rm.build()
        except Exception, e:
            if isinstance(e, (NamespaceException, RequestException, \
                              ResponseException, RouterException, \
                              FeatureException)):
                err_msg = repr(e)
            else:
                err_msg = u'An internal error occurred during your request.'
            
            trace = inspect.trace()
            msgs = []
            msgs.append('')
            msgs.append(u"******* Exception raised *******")
            msgs.append(u'Exception type: %s' % type(e))
            msgs.append(u'Exception msg: %s' % repr(e))
            msgs.append('')
            msgs.append(u'------- Traceback follows -------')
            for idx, item in enumerate(trace):
                msgs.append(u"(%s)\t%s:%s (%s)" % 
                    (idx+1, item[3], item[2], item[1]))
                if item[4]:
                    for line in item[4]:
                        msgs.append(u"\t\t%s" % line.strip())
                msgs.append('') # blank line
            msgs.append('     -- End of traceback --     ')
            msgs.append('')
            self.logger.error("\n".join(msgs))

            if self.debug:
                e, m, tb = sys.exc_info()
                pdb.post_mortem(tb)

            response = Response(
                sapi_request,
                errors=err_msg,
                output_formatter=output_formatter_instance,
                wrapper=wrapper_instance,
                mimetype=mimetype
            )
            http_response = response.build(skip_features=True)

        if SIMPLEAPI_DEBUG and SIMPLEAPI_DEBUG_LEVEL == 'call':
            self.profile_stop()
            self.profile_stats()

        return http_response
########NEW FILE########
__FILENAME__ = routemgr
# -*- coding: utf-8 -*-

from simpleapi.message.common import SAException

__all__ = ('RouteMgr', )

class RouteMgrException(SAException): pass
class RouteNotFound(RouteMgrException): pass
class RouteMgr(object):
    def __init__(self, *routes):
        self.routes = {}
        for route in routes:
            self.routes[route.name] = route
    
    def __call__(self, *args, **kwargs):
        route_name = kwargs.pop('name')
        if self.routes.has_key(route_name):
            return self.routes[route_name](*args, **kwargs)
        raise RouteNotFound(route_name)
########NEW FILE########
__FILENAME__ = sapirequest
# -*- coding: utf-8 -*-

try:
    from flask import request as flask_request
    has_flask = True
except ImportError:
    has_flask = False

from session import Session

__all__ = ('SAPIRequest', )

class SAPIRequest(object):
    
    def __init__(self, route, request=None):
        self.session = Session()
        self.route = route

        if not request:
            if route.is_flask():
                assert has_flask
                request = flask_request
            elif route.is_appengine():
                request = route.request
            else:
                raise ValueError(u'HttpRequest-object is missing')

        self.request = request

    @property
    def GET(self):
        if self.route.is_flask():
            return self.request.args
        elif self.route.is_django():
            return self.request.GET
        elif self.route.is_appengine():
            return self.request.REQUEST
        elif self.route.is_dummy() or self.route.is_standalone():
            return self.request.data
        raise NotImplementedError

    @property
    def POST(self):
        if self.route.is_flask():
            return self.request.form or self.request.args
        elif self.route.is_django():
            return self.request.POST
        elif self.route.is_appengine():
            return self.request.REQUEST
        elif self.route.is_dummy() or self.route.is_standalone():
            return self.request.data
        raise NotImplementedError

    @property
    def REQUEST(self):
        if self.route.is_flask():
            return self.request.form or self.request.args
        elif self.route.is_django():
            return self.request.REQUEST
        elif self.route.is_appengine():
            return dict(map(lambda i: (i, self.request.get(i)), \
                self.request.arguments()))
        elif self.route.is_dummy() or self.route.is_standalone():
            return self.request.data
        raise NotImplementedError

    @property
    def FILES(self):
        if self.route.is_django():
            return self.request.FILES
        
        # TODO XXX
        # FILES access to other frameworks? flask? GAE?
        
        raise NotImplementedError

    @property
    def META(self):
        if self.route.is_flask():
            return self.request.environ
        elif self.route.is_django():
            return self.request.META
        
        raise NotImplementedError

    @property
    def remote_addr(self):
        if self.route.is_flask() or self.route.is_django():
            return self.META.get('REMOTE_ADDR')
        elif self.route.is_appengine():
            return self.request.remote_addr
        elif self.route.is_dummy() or self.route.is_standalone():
            return self.request.remote_addr
        raise NotImplementedError

    @property
    def method(self):
        if self.route.is_flask():
            return self.request.method
        elif self.route.is_django():
            return self.request.method
        elif self.route.is_appengine():
            return self.request.method
        elif self.route.is_dummy() or self.route.is_standalone():
            return self.request.method
        raise NotImplementedError
    
    @property
    def path_info(self):
        if self.route.is_flask() or self.route.is_django():
            return self.META.get('PATH_INFO')
        # TODO XXX FIXME:
        #elif self.route.is_appengine():
        #    return self.request.path_info
        #elif self.route.is_dummy() or self.route.is_standalone():
        #    return self.request.path_info
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = serializer
# -*- coding: utf-8 -*-

try:
    from django.db.models import Model
    from django.db.models.query import QuerySet
    from django.utils.encoding import smart_unicode, is_protected_type
    has_django = True
except Exception, e:
    has_django = False

try:
    import mongoengine
    import pymongo
    has_mongoengine = True
except ImportError:
    has_mongoengine = False

__all__ = ('serialize',)

class SerializedObject(object):

    def __init__(self, obj, **options):
        self.obj = obj
        self.options = options

    def to_python(self):
        if has_django and isinstance(self.obj, Model):
            serializer = DjangoModelSerializer(self.obj, **self.options)
        elif has_django and isinstance(self.obj, QuerySet):
            serializer = DjangoQuerySetSerializer(self.obj, **self.options)
        elif has_mongoengine and isinstance(self.obj, \
            mongoengine.document.BaseDocument):
            serializer = MongoDocumentSerializer(self.obj, **self.options)
        elif has_mongoengine and isinstance(self.obj, \
            mongoengine.queryset.QuerySet):
            serializer = MongoQuerySetSerializer(self.obj, **self.options)
        else:
            raise NotImplementedError
        return serializer.serialize()

def serialize(obj, **options):
    return SerializedObject(
        obj=obj,
        **options
    )

class SerializerList(list):
    def __contains__(self, value):
        for item in self:
            if hasattr(item, 'match'):
                # regular expression
                if item.match(value):
                    return True
            else:
                if item == value:
                    return True
        return False

class Serializer(object):
    def __init__(self, obj, **options):
        self.obj = obj
        self.options = options
        self.fields = SerializerList(options.get('fields', []))
        self.excludes = SerializerList(options.get('excludes', []))

        assert isinstance(self.fields, (tuple, list))
        assert isinstance(self.excludes, (tuple, list))

class MongoDocumentSerializer(Serializer):

    def serialize(self):
        assert isinstance(self.obj, mongoengine.document.BaseDocument)

        result = {}
        self.handle_document(self.obj, result)
        return result

    def handle_field(self, doc, field, scope):
        value = getattr(doc, field)

        if isinstance(value, pymongo.objectid.ObjectId):
            scope[field] = str(value)
        elif isinstance(value, mongoengine.document.BaseDocument):
            scope[field] = {}
            self.handle_document(value, scope[field])
        elif isinstance(value, list):
            scope[field] = []
            for item in value:
                scope[field] = []
                self.handle_list_field(value, scope[field])
        else:
            scope[field] = value

    def handle_list_field(self, items, scope=[]):
        for i, item in enumerate(items):
            if isinstance(item, mongoengine.document.BaseDocument):
                scope.append({})
                self.handle_document(item, scope[i])
            else:
                scope.append(item)

    def handle_document(self, doc, scope):
        for field in doc._fields:
            if (not self.fields or field in self.fields) and \
               not field in self.excludes:
                self.handle_field(doc, field, scope)

class MongoQuerySetSerializer(Serializer):

    def serialize(self):
        assert isinstance(self.obj, mongoengine.queryset.QuerySet)

        result = []
        for obj in self.obj:
            model_serializer = MongoDocumentSerializer(obj, **self.options)
            result.append(model_serializer.serialize())
        return result

class DjangoModelSerializer(Serializer):

    def __init__(self, *args, **kwargs):
        self.use_natural_keys = True
        super(DjangoModelSerializer, self).__init__(*args, **kwargs)

    def serialize(self):
        assert isinstance(self.obj, Model)

        self.result = {}
        for field in self.obj._meta.local_fields:
            if field.serialize:
                if field.rel is None:
                    if (not self.fields or field.attname in self.fields) and \
                        not field.attname in self.excludes:
                        self.handle_field(field)
                else:
                    if (not self.fields or field.attname[:-3] in self.fields) \
                        and not field.attname in self.excludes:
                        self.handle_fk_field(field)
        for field in self.obj._meta.many_to_many:
            if field.serialize:
                if (not self.fields or field.attname in self.fields) \
                    and not field.attname in self.excludes:
                    self.handle_m2m_field(field)

        if self.options.get('include_pk'):
            self.result['pk'] = self.obj.pk
        return self.result

    def handle_field(self, field):
        value = field._get_val_from_obj(self.obj)
        if is_protected_type(value):
            self.result[field.name] = value
        else:
            self.result[field.name] = field.value_to_string(self.obj)

    def handle_fk_field(self, field):
        related = getattr(self.obj, field.name)
        if related is not None:
            if self.use_natural_keys and hasattr(related, 'natural_key'):
                related = related.natural_key()
            else:
                if field.rel.field_name == related._meta.pk.name:
                    # Related to remote object via primary key
                    related = related._get_pk_val()
                else:
                    # Related to remote object via other field
                    related = smart_unicode(getattr(related, field.rel.field_name), strings_only=True)
        self.result[field.name] = related

    def handle_m2m_field(self, field):
        if field.rel.through._meta.auto_created:
            if self.use_natural_keys and hasattr(field.rel.to, 'natural_key'):
                m2m_value = lambda value: value.natural_key()
            else:
                m2m_value = lambda value: smart_unicode(value._get_pk_val(), strings_only=True)
            self.result[field.name] = [m2m_value(related)
                               for related in getattr(self.obj, field.name).iterator()]

class DjangoQuerySetSerializer(Serializer):
    def serialize(self):
        assert isinstance(self.obj, QuerySet)

        result = []
        for obj in self.obj:
            model_serializer = DjangoModelSerializer(obj, **self.options)
            result.append(model_serializer.serialize())
        return result

########NEW FILE########
__FILENAME__ = session
# -*- coding: utf-8 -*-

__all__ = ('Session', )

class SessionObj(object): pass

class Session(object):
    def __init__(self):
        self._internal = SessionObj()

    def clear(self):
        for key in self.__dict__.keys():
            if not key.startswith('_'):
                del self.__dict__[key]
########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-

from fnmatch import fnmatch

__all__ = ('glob_list', )

class glob_list(list):
    """A list which is Unix shell-style wildcards searchable"""
    def __contains__(self, key):
        for elt in self:
            if fnmatch(key, elt): return True
        return False

########NEW FILE########
__FILENAME__ = formatter_wrapper

########NEW FILE########
__FILENAME__ = namespace
# -*- coding: utf-8 -*-

import unittest

from simpleapi import *

class NamespaceTest(unittest.TestCase):

    def setUp(self):

        class TestNamespace(Namespace):
            pass

        self.namespace = TestNamespace()

    def tearDown(self):
        pass

if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = route
# -*- coding: utf-8 -*-

import re
import copy
import unittest
try:
    import json
except ImportError:
    import simplejson as json
import cPickle

try:
    import django
except ImportError:
    raise Exception, 'Django is required for running the tests'

import os
os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.settings'

from simpleapi import *

class RouteTest(unittest.TestCase):

    _value_simple = 5592.61

    # in JSON key values of dict items must be of type string
    _value_complex = {
        'test1': u'test äöüß',
        'test2': 592,
        'test3': 1895.29596,
        'test4': {
            'sub': 'yes',
            'list': ['1', 2, 3.4, [5, 6], {'7': '8', '9': 10}]
        },
        '5': [6, 7, '8', '9', 10.11],
        '6': True,
        'test7': False,
        'test8': [True, 0, False, 1],
        u'täst9': 9
    }

    def setUp(self):

        class TestNamespace(Namespace):

            __input__ = ['pickle', 'json',]
            __output__ = ['pickle', 'json',]

            def return_value(self, val):
                return val
            return_value.published = True

            def non_published(self):
                return True

            def power(self, a, b):
                return a ** b
            power.published = True
            power.constraints = {'a': lambda value: float(value), 'b': int}

            def sum_up(self, a, d=0, **kwargs):
                return a + sum(kwargs.values()) - d
            sum_up.published = True
            sum_up.constraints = lambda namespace, key, value: int(value)

            def get_version(self):
                return self.__version__
            get_version.published = True

            def call_phone(self, phone_number):
                return True
            call_phone.published = True
            call_phone.constraints = {
                'phone_number': re.compile(r"^\+\d{1,} \d{2,} \d{2,}$"),
            }

        class TestNamespace1(TestNamespace):
            __version__ = 1

        class TestNamespace2(TestNamespace):
            __version__ = 2
            __authentication__ = "abc"

        class TestNamespace3(TestNamespace):
            __version__ = 3
            __authentication__ = lambda namespace, access_key: \
                access_key == 'a' * 5

        class TestNamespace4(TestNamespace):
            __version__ = 4

        self.route1 = Route(TestNamespace)
        self.route2 = Route(
            TestNamespace1,
            TestNamespace2,
            TestNamespace3,
            TestNamespace4
        )

    def call(self, route, method, version='default', access_key=None,
             transporttypes=None, **kwargs):
        """Simulates a call to the API."""

        class Request(object):
            pass

        request = Request()
        request.method = 'POST'
        request.REQUEST = {}
        request.FILES = {}
        request.META = {
            'REMOTE_ADDR': '127.0.0.1'
        }

        # set simpleapi parameters
        request.REQUEST['_call'] = method
        request.REQUEST['_version'] = version
        if access_key:
            request.REQUEST['_access_key'] = access_key

        # make sure every transporttype returns the same result after
        # decoding the response content
        transporttypes = transporttypes or ['json', 'pickle',]
        first_response = None
        for transporttype in transporttypes:
            # encode query parameters
            local_kwargs = copy.deepcopy(kwargs)
            for key, value in local_kwargs.iteritems():
                if transporttype == 'json':
                    local_kwargs[key] = json.dumps(value)
                elif transporttype == 'pickle':
                    local_kwargs[key] = cPickle.dumps(value)

            request.REQUEST.update(local_kwargs)

            # set encoding/decoding parameters
            request.REQUEST['_input'] = transporttype
            request.REQUEST['_output'] = transporttype

            # fire it up!
            http_response = route(request)
            if transporttype == 'json':
                response = json.loads(http_response.content)
            elif transporttype == 'pickle':
                response = cPickle.loads(http_response.content)
            else:
                self.fail(u'unknown transport type: %s' % transporttype)

            if not first_response:
                first_response = response
            else:
                self.failUnlessEqual(response, first_response)

        return (
            response.get('success'),
            response.get('errors'),
            response.get('result')
        )

    def test_published(self):
        # test: published-flag
        success, errors, result = self.call(self.route1, 'non_published')
        self.failIf(success)

        success, errors, result = self.call(self.route1, 'return_value',
            val=self._value_complex)
        self.failUnless(success)
        self.failUnlessEqual(result, self._value_complex)

    def test_data(self):
        # test: _data
        success, errors, result = self.call(self.route1, 'power', _data={'a': 3, 'b': 10})
        self.failUnlessEqual(result, 59049)

    def test_authentication(self):
        # test: __authentication__

        # __authentication__ == "abc"
        success, errors, result = self.call(
            route=self.route2,
            method='power',
            version='2'
        )
        self.failIf(success)
        self.failUnlessEqual(u'Authentication failed.', errors[0])

        success, errors, result = self.call(
            route=self.route2,
            method='power',
            version='2',
            access_key='abc',
            a=1,
            b=2
        )
        self.failUnless(success)

        # __authentication__ == lambda namespace, access_key: access_key == 'a' * 5
        success, errors, result = self.call(
            route=self.route2,
            method='power',
            version='3'
        )
        self.failIf(success)
        self.failUnlessEqual(u'Authentication failed.', errors[0])

        success, errors, result = self.call(
            route=self.route2,
            method='power',
            version='3',
            access_key='a' * 5,
            a=1,
            b=2
        )
        self.failUnless(success)

    def test_kwargs(self):
        # test: kwargs
        success, errors, result = self.call(
            route=self.route1,
            method='sum_up',
            a=5,
            b=7,
            c=99,
            e=100
        )
        self.failUnless(success)
        self.failUnlessEqual(result, 211)

        success, errors, result = self.call(
            route=self.route1,
            method='power',
            a=5,
            b=7,
            c=99
        )
        self.failIf(success)
        self.failUnlessEqual(u'Unused arguments: c', errors[0])

    def test_default_args(self):
        success, errors, result = self.call(
            route=self.route1,
            method='sum_up',
            a='5',
            d=5,
            c='99',
            e='100'
        )
        self.failUnless(success)
        self.failUnlessEqual(result, 199)

    def test_constraints(self):
        # test: constraints[phone_number] = regular expression
        success, errors, result = self.call(
            route=self.route1,
            method='call_phone',
            phone_number='0176123456'
        )
        self.failIf(success)
        self.failUnlessEqual(u'Constraint failed for argument: phone_number', errors[0])

        success, errors, result = self.call(
            route=self.route1,
            method='call_phone',
            phone_number='+49 176 123456'
        )
        self.failUnless(success)
        self.failUnlessEqual(result, True)

        # test: constraints = lambda namespace, key, value: int(value)
        success, errors, result = self.call(
            route=self.route1,
            method='sum_up',
            a='afs',
            d=5,
            c=99,
            e=100
        )
        self.failIf(success)
        self.failUnlessEqual(u'Constraint failed for argument: a', errors[0])

        # test: type conversion
        success, errors, result = self.call(
            route=self.route1,
            method='sum_up',
            a='19',
            d='5',
            c='99',
            e='1020'
        )
        self.failUnless(success)
        self.failUnlessEqual(result, 1133)

        # test: constraints[a] = lambda value: float(value), b = int
        success, errors, result = self.call(
            route=self.route1,
            method='power',
            a='19.95',
            b='4'
        )
        self.failUnless(success)
        self.failUnlessEqual(result, 158405.99000624998)

        success, errors, result = self.call(
            route=self.route1,
            method='power',
            a='19.95',
            b='4.5'
        )
        self.failIf(success)
        self.failUnlessEqual(u'Constraint failed for argument: b', errors[0])


    def test_versions(self):
        # test: __version__
        success, errors, result = self.call(
            route=self.route1,
            method='power',
            version='3'
        )
        self.failIf(success)
        self.failUnless(u'Version 3 not found' in errors[0])

        success, errors, result = self.call(
            route=self.route2,
            method='get_version',
            version='1'
        )
        self.failUnless(success)
        self.failUnlessEqual(result, 1)

        success, errors, result = self.call(
            route=self.route2,
            method='get_version',
            version='4'
        )
        self.failUnless(success)
        self.failUnlessEqual(result, 4)

        success, errors, result = self.call(
            route=self.route2,
            method='get_version',
            version='default'
        )
        self.failUnless(success)
        self.failUnlessEqual(result, 4)

        # add new namespace with same version
        class TestNamespace(Namespace):
            __version__ = 4
        self.failUnlessRaises(AssertionError, lambda: self.route2.add_namespace(TestNamespace))

        # add new namespace with new version
        class TestNamespace(Namespace):
            __version__ = 999
            def get_version(self):
                return self.__version__
            get_version.published = True

        self.failUnlessEqual(self.route2.add_namespace(TestNamespace), 999)

        success, errors, result = self.call(
            route=self.route2,
            method='get_version',
            version='default',
            transporttypes=['json',]
        )
        self.failUnless(success)
        self.failUnlessEqual(result, 999)

        # remove added namespace again
        self.failUnless(self.route2.remove_namespace(999))
        self.failIf(self.route2.remove_namespace(999))

        success, errors, result = self.call(
            route=self.route2,
            method='get_version',
            version='default'
        )
        self.failUnless(success)
        self.failUnlessEqual(result, 4)

    def test_pickle(self):
        # test: pickle
        # UnpicklingError

        class Test(Namespace):
            def return_val(self, val):
                return val
            return_val.published = True
        self.route3 = Route(Test)
        self.failUnlessRaises(
            cPickle.UnpicklingError,
            lambda: self.call(route=self.route3, method='return_val')
        )
        del self.route3

    def test_global_options(self):
        pass

    def tearDown(self):
        pass

if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = settings
SECRET_KEY = "foo"
########NEW FILE########
__FILENAME__ = xml

########NEW FILE########
