__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# FormEncode documentation build configuration file, created by
# sphinx-quickstart on Tue Aug 30 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.coverage']

# Add any paths that contain templates here, relative to this directory.
#templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.txt'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'FormEncode'
copyright = u'2008-2012, Ian Bicking and Contributors'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.3'
# The full version, including alpha/beta/rc tags.
release = '1.3.0dev'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#html_theme = 'old'
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'FormEncode_doc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'FormEncode.tex', u'FormEncode Documentation',
   u'Ian Bicking', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'formencode', u'FormEncode Documentation',
     [u'Ian Bicking'], 1)
]

########NEW FILE########
__FILENAME__ = index
from formencode import Invalid, htmlfill, Schema, validators

from WebKit.Page import Page


page_style = '''
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Tell me about yourself</title>
  <style type="text/css">
    .error {background-color: #ffdddd}
    .error-message {border: 2px solid #f00}
  </style>
 </head>
 <body>

 <h1>Tell me about yourself</h1>
 <p><i>A FormEncode example</i></p>

 %s

 </body></html>'''

form_template = '''
<form action="" method="POST">

<p>Your name:<br>
<form:error name="name">
<input type="text" name="name"></p>

<p>Your age:<br>
<form:error name="age">
<input type="text" name="age"></p>

<p>Your favorite color:<br>
<form:error name="color">
<input type="checkbox" value="red" name="color"> Red<br>
<input type="checkbox" value="blue" name="color"> Blue<br>
<input type="checkbox" value="black" name="color"> Black<br>
<input type="checkbox" value="green" name="color"> Green<br>
<input type="checkbox" value="pink" name="color"> Pink</p>

<input type="submit" name="_action_save" value="Submit">
</form>'''

response_template = '''
<h2>Hello, %(name)s!</h2>
<p>You are %(age)d years old
and your favorite color is %(color)s.</p>'''


class FormSchema(Schema):
    name = validators.String(not_empty=True)
    age = validators.Int(min=13, max=99)
    color = validators.OneOf(['red', 'blue', 'black', 'green'])
    filter_extra_fields = True
    allow_extra_fields = True


class index(Page):

    def awake(self, trans):
        Page.awake(self, trans)
        self.rendered_form = None

    def actions(self):
        return ['save']

    def save(self):
        fields = self.request().fields()
        try:
            fields = FormSchema.to_python(fields, self)
        except Invalid, e:
            errors = dict((k, v.encode('utf-8'))
                for k, v in e.unpack_errors().iteritems())
            print "Errors:", errors
            self.rendered_form = htmlfill.render(form_template,
                defaults=fields, errors=errors)
            self.writeHTML()
        else:
            self.doAction(fields)

    def doAction(self, fields):
        print "Fields:", fields
        self.rendered_form = response_template % fields
        self.writeHTML()

    def writeHTML(self):
        if self.rendered_form is None:
            self.rendered_form = htmlfill.render(form_template,
                defaults=self.getDefaults())
        self.write(page_style % self.rendered_form)

    def getDefaults(self):
        return dict(age='enter your age', color=['blue'])

    def preAction(self, trans):
        pass
    postAction = preAction

########NEW FILE########
__FILENAME__ = api
"""
Core classes for validation.
"""

from . import declarative
import gettext
import os
import re
import textwrap
import warnings

try:
    from pkg_resources import resource_filename
except ImportError:
    resource_filename = None

__all__ = ['NoDefault', 'Invalid', 'Validator', 'Identity',
           'FancyValidator', 'is_empty', 'is_validator']


def get_localedir():
    """Retrieve the location of locales.

    If we're built as an egg, we need to find the resource within the egg.
    Otherwise, we need to look for the locales on the filesystem or in the
    system message catalog.

    """
    locale_dir = ''
    # Check the egg first
    if resource_filename is not None:
        try:
            locale_dir = resource_filename(__name__, "/i18n")
        except NotImplementedError:
            # resource_filename doesn't work with non-egg zip files
            pass
    if not hasattr(os, 'access'):
        # This happens on Google App Engine
        return os.path.join(os.path.dirname(__file__), 'i18n')
    if os.access(locale_dir, os.R_OK | os.X_OK):
        # If the resource is present in the egg, use it
        return locale_dir

    # Otherwise, search the filesystem
    locale_dir = os.path.join(os.path.dirname(__file__), 'i18n')
    if not os.access(locale_dir, os.R_OK | os.X_OK):
        # Fallback on the system catalog
        locale_dir = os.path.normpath('/usr/share/locale')

    return locale_dir


def set_stdtranslation(domain="FormEncode", languages=None,
                       localedir=get_localedir()):

    t = gettext.translation(domain=domain,
                            languages=languages,
                            localedir=localedir, fallback=True)
    global _stdtrans
    try:
        _stdtrans = t.ugettext
    except AttributeError:  # Python 3
        _stdtrans = t.gettext

set_stdtranslation()

# Dummy i18n translation function, nothing is translated here.
# Instead this is actually done in api.Validator.message.
# The surrounding _('string') of the strings is only for extracting
# the strings automatically.
# If you run pygettext with this source comment this function out temporarily.
_ = lambda s: s


def deprecation_warning(old, new=None, stacklevel=3):
    """Show a deprecation warning."""
    msg = '%s is deprecated' % old
    if new:
        msg += '; use %s instead' % new
    warnings.warn(msg, DeprecationWarning, stacklevel=stacklevel)


def deprecated(old=None, new=None):
    """A decorator which can be used to mark functions as deprecated."""
    def outer(func):
        def inner(*args, **kwargs):
            deprecation_warning(old or func.__name__, new)
            return func(*args, **kwargs)
        return inner
    return outer


class NoDefault(object):
    """A dummy value used for parameters with no default."""


def is_empty(value):
    """Check whether the given value should be considered "empty"."""
    return value is None or value == '' or (
        isinstance(value, (list, tuple, dict)) and not value)


def is_validator(obj):
    """Check whether obj is a Validator instance or class."""
    return (isinstance(obj, Validator) or
        (isinstance(obj, type) and issubclass(obj, Validator)))


class Invalid(Exception):

    """
    This is raised in response to invalid input.  It has several
    public attributes:

    ``msg``:
        The message, *without* values substituted.  For instance, if
        you want HTML quoting of values, you can apply that.
    ``substituteArgs``:
        The arguments (a dictionary) to go with ``msg``.
    ``str(self)``:
        The message describing the error, with values substituted.
    ``value``:
        The offending (invalid) value.
    ``state``:
        The state that went with this validator.  This is an
        application-specific object.
    ``error_list``:
        If this was a compound validator that takes a repeating value,
        and sub-validator(s) had errors, then this is a list of those
        exceptions.  The list will be the same length as the number of
        values -- valid values will have None instead of an exception.
    ``error_dict``:
        Like ``error_list``, but for dictionary compound validators.
    """

    def __init__(self, msg,
                 value, state, error_list=None, error_dict=None):
        Exception.__init__(self, msg, value, state, error_list, error_dict)
        self.msg = msg
        self.value = value
        self.state = state
        self.error_list = error_list
        self.error_dict = error_dict
        assert (not self.error_list or not self.error_dict), (
                "Errors shouldn't have both error dicts and lists "
                "(error %s has %s and %s)"
                % (self, self.error_list, self.error_dict))

    def __str__(self):
        val = self.msg
        return val

    if unicode is not str:  # Python 2

        def __unicode__(self):
            if isinstance(self.msg, unicode):
                return self.msg
            elif isinstance(self.msg, str):
                return self.msg.decode('utf8')
            else:
                return unicode(self.msg)

    def unpack_errors(self, encode_variables=False, dict_char='.',
                      list_char='-'):
        """
        Returns the error as a simple data structure -- lists,
        dictionaries, and strings.

        If ``encode_variables`` is true, then this will return a flat
        dictionary, encoded with variable_encode
        """
        if self.error_list:
            assert not encode_variables, (
                "You can only encode dictionary errors")
            assert not self.error_dict
            return [item.unpack_errors() if item else item
                for item in self.error_list]
        if self.error_dict:
            result = {}
            for name, item in self.error_dict.iteritems():
                result[name] = item if isinstance(
                    item, basestring) else item.unpack_errors()
            if encode_variables:
                from . import variabledecode
                result = variabledecode.variable_encode(
                    result, add_repetitions=False,
                    dict_char=dict_char, list_char=list_char)
                for key in result.keys():
                    if not result[key]:
                        del result[key]
            return result
        assert not encode_variables, (
            "You can only encode dictionary errors")
        return self.msg


############################################################
## Base Classes
############################################################

class Validator(declarative.Declarative):

    """
    The base class of most validators.  See ``IValidator`` for more, and
    ``FancyValidator`` for the more common (and more featureful) class.
    """

    _messages = {}
    if_missing = NoDefault
    repeating = False
    compound = False
    accept_iterator = False
    gettextargs = {}
    # In case you don't want to use __builtins__._
    # although it may be defined, set use_builtins_gettext to False:
    use_builtins_gettext = True

    __singletonmethods__ = (
        'to_python', 'from_python', 'message', 'all_messages', 'subvalidators')

    @staticmethod
    def __classinit__(cls, new_attrs):
        if 'messages' in new_attrs:
            cls._messages = cls._messages.copy()
            cls._messages.update(cls.messages)
            del cls.messages
        cls._initialize_docstring()

    def __init__(self, *args, **kw):
        if 'messages' in kw:
            self._messages = self._messages.copy()
            self._messages.update(kw.pop('messages'))
        declarative.Declarative.__init__(self, *args, **kw)

    def to_python(self, value, state=None):
        return value

    def from_python(self, value, state=None):
        return value

    def message(self, msgName, state, **kw):
        # determine translation function
        try:
            trans = state._
        except AttributeError:
            try:
                if self.use_builtins_gettext:
                    import __builtin__
                    trans = __builtin__._
                else:
                    trans = _stdtrans
            except AttributeError:
                trans = _stdtrans

        if not callable(trans):
            trans = _stdtrans

        msg = self._messages[msgName]
        msg = trans(msg, **self.gettextargs)

        try:
            return msg % kw
        except KeyError as e:
            raise KeyError(
                "Key not found (%s) for %r=%r %% %r (from: %s)"
                % (e, msgName, self._messages.get(msgName), kw,
                   ', '.join(self._messages)))

    def all_messages(self):
        """
        Return a dictionary of all the messages of this validator, and
        any subvalidators if present.  Keys are message names, values
        may be a message or list of messages.  This is really just
        intended for documentation purposes, to show someone all the
        messages that a validator or compound validator (like Schemas)
        can produce.

        @@: Should this produce a more structured set of messages, so
        that messages could be unpacked into a rendered form to see
        the placement of all the messages?  Well, probably so.
        """
        msgs = self._messages.copy()
        for v in self.subvalidators():
            inner = v.all_messages()
            for key, msg in inner:
                if key in msgs:
                    if msgs[key] == msg:
                        continue
                    if isinstance(msgs[key], list):
                        msgs[key].append(msg)
                    else:
                        msgs[key] = [msgs[key], msg]
                else:
                    msgs[key] = msg
        return msgs

    def subvalidators(self):
        """
        Return any validators that this validator contains.  This is
        not useful for functional, except to inspect what values are
        available.  Specifically the ``.all_messages()`` method uses
        this to accumulate all possible messages.
        """
        return []

    @classmethod
    def _initialize_docstring(cls):
        """
        This changes the class's docstring to include information
        about all the messages this validator uses.
        """
        doc = cls.__doc__ or ''
        doc = [textwrap.dedent(doc).rstrip()]
        messages = sorted(cls._messages.iteritems())
        doc.append('\n\n**Messages**\n\n')
        for name, default in messages:
            default = re.sub(r'(%\(.*?\)[rsifcx])', r'``\1``', default)
            doc.append('``' + name + '``:\n')
            doc.append('  ' + default + '\n\n')
        cls.__doc__ = ''.join(doc)


class _Identity(Validator):

    def __repr__(self):
        return 'validators.Identity'

Identity = _Identity()


class FancyValidator(Validator):

    """
    FancyValidator is the (abstract) superclass for various validators
    and converters.  A subclass can validate, convert, or do both.
    There is no formal distinction made here.

    Validators have two important external methods:

    ``.to_python(value, state)``:
      Attempts to convert the value.  If there is a problem, or the
      value is not valid, an Invalid exception is raised.  The
      argument for this exception is the (potentially HTML-formatted)
      error message to give the user.

    ``.from_python(value, state)``:
      Reverses ``.to_python()``.

    These two external methods make use of the following four
    important internal methods that can be overridden.  However,
    none of these *have* to be overridden, only the ones that
    are appropriate for the validator.

    ``._convert_to_python(value, state)``:
      This method converts the source to a Python value.  It returns
      the converted value, or raises an Invalid exception if the
      conversion cannot be done.  The argument to this exception
      should be the error message.  Contrary to ``.to_python()`` it is
      only meant to convert the value, not to fully validate it.

    ``._convert_from_python(value, state)``:
      Should undo ``._convert_to_python()`` in some reasonable way, returning
      a string.

    ``._validate_other(value, state)``:
      Validates the source, before ``._convert_to_python()``, or after
      ``._convert_from_python()``.  It's usually more convenient to use
      ``._validate_python()`` however.

    ``._validate_python(value, state)``:
      Validates a Python value, either the result of ``._convert_to_python()``,
      or the input to ``._convert_from_python()``.

    You should make sure that all possible validation errors are
    raised in at least one these four methods, not matter which.

    Subclasses can also override the ``__init__()`` method
    if the ``declarative.Declarative`` model doesn't work for this.

    Validators should have no internal state besides the
    values given at instantiation.  They should be reusable and
    reentrant.

    All subclasses can take the arguments/instance variables:

    ``if_empty``:
      If set, then this value will be returned if the input evaluates
      to false (empty list, empty string, None, etc), but not the 0 or
      False objects.  This only applies to ``.to_python()``.

    ``not_empty``:
      If true, then if an empty value is given raise an error.
      (Both with ``.to_python()`` and also ``.from_python()``
      if ``._validate_python`` is true).

    ``strip``:
      If true and the input is a string, strip it (occurs before empty
      tests).

    ``if_invalid``:
      If set, then when this validator would raise Invalid during
      ``.to_python()``, instead return this value.

    ``if_invalid_python``:
      If set, when the Python value (converted with
      ``.from_python()``) is invalid, this value will be returned.

    ``accept_python``:
      If True (the default), then ``._validate_python()`` and
      ``._validate_other()`` will not be called when
      ``.from_python()`` is used.

    These parameters are handled at the level of the external
    methods ``.to_python()`` and ``.from_python`` already;
    if you overwrite one of the internal methods, you usually
    don't need to care about them.

    """

    if_invalid = NoDefault
    if_invalid_python = NoDefault
    if_empty = NoDefault
    not_empty = False
    accept_python = True
    strip = False

    messages = dict(
        empty=_("Please enter a value"),
        badType=_("The input must be a string (not a %(type)s: %(value)r)"),
        noneType=_("The input must be a string (not None)"))

    _inheritance_level = 0
    _deprecated_methods = (
        ('_to_python', '_convert_to_python'),
        ('_from_python', '_convert_from_python'),
        ('validate_python', '_validate_python'),
        ('validate_other', '_validate_other'))

    @staticmethod
    def __classinit__(cls, new_attrs):
        Validator.__classinit__(cls, new_attrs)
        # account for deprecated methods
        cls._inheritance_level += 1
        if '_deprecated_methods' in new_attrs:
            cls._deprecated_methods = cls._deprecated_methods + new_attrs[
                '_deprecated_methods']
        for old, new in cls._deprecated_methods:
            if old in new_attrs:
                if new not in new_attrs:
                    deprecation_warning(old, new,
                        stacklevel=cls._inheritance_level + 2)
                    setattr(cls, new, new_attrs[old])
            elif new in new_attrs:
                    setattr(cls, old, deprecated(old=old, new=new)(
                        new_attrs[new]))

    def to_python(self, value, state=None):
        try:
            if self.strip and isinstance(value, basestring):
                value = value.strip()
            elif hasattr(value, 'mixed'):
                # Support Paste's MultiDict
                value = value.mixed()
            if self.is_empty(value):
                if self.not_empty:
                    raise Invalid(self.message('empty', state), value, state)
                if self.if_empty is not NoDefault:
                    return self.if_empty
                return self.empty_value(value)
            vo = self._validate_other
            if vo and vo is not self._validate_noop:
                vo(value, state)
            tp = self._convert_to_python
            if tp:
                value = tp(value, state)
            vp = self._validate_python
            if vp and vp is not self._validate_noop:
                vp(value, state)
        except Invalid:
            value = self.if_invalid
            if value is NoDefault:
                raise
        return value

    def from_python(self, value, state=None):
        try:
            if self.strip and isinstance(value, basestring):
                value = value.strip()
            if not self.accept_python:
                if self.is_empty(value):
                    if self.not_empty:
                        raise Invalid(self.message('empty', state),
                                      value, state)
                    return self.empty_value(value)
                vp = self._validate_python
                if vp and vp is not self._validate_noop:
                    vp(value, state)
                fp = self._convert_from_python
                if fp:
                    value = fp(value, state)
                vo = self._validate_other
                if vo and vo is not self._validate_noop:
                    vo(value, state)
            else:
                if self.is_empty(value):
                    return self.empty_value(value)
                fp = self._convert_from_python
                if fp:
                    value = fp(value, state)
        except Invalid:
            value = self.if_invalid_python
            if value is NoDefault:
                raise
        return value

    def is_empty(self, value):
        return is_empty(value)

    def empty_value(self, value):
        return None

    def assert_string(self, value, state):
        if not isinstance(value, basestring):
            raise Invalid(self.message('badType', state,
                                       type=type(value), value=value),
                          value, state)

    def base64encode(self, value):
        """
        Encode a string in base64, stripping whitespace and removing
        newlines.
        """
        return value.encode('base64').strip().replace('\n', '')

    def _validate_noop(self, value, state=None):
        """
        A validation method that doesn't do anything.
        """
        pass

    _validate_python = _validate_other = _validate_noop
    _convert_to_python = _convert_from_python = None

########NEW FILE########
__FILENAME__ = compound
"""
Validators for applying validations in sequence.
"""

from .api import (FancyValidator, Identity, Invalid, NoDefault, Validator,
    is_validator)

__all__ = ['CompoundValidator', 'Any', 'All', 'Pipe']

############################################################
## Compound Validators
############################################################


def to_python(validator, value, state):
    return validator.to_python(value, state)


def from_python(validator, value, state):
    return validator.from_python(value, state)


class CompoundValidator(FancyValidator):
    """Base class for all compound validators."""

    if_invalid = NoDefault
    accept_iterator = False

    validators = []

    __unpackargs__ = ('*', 'validatorArgs')

    __mutableattributes__ = ('validators',)

    _deprecated_methods = (
        ('attempt_convert', '_attempt_convert'),)

    @staticmethod
    def __classinit__(cls, new_attrs):
        FancyValidator.__classinit__(cls, new_attrs)
        toAdd = []
        for name, value in new_attrs.iteritems():
            if is_validator(value) and value is not Identity:
                toAdd.append((name, value))
                # @@: Should we really delete too?
                delattr(cls, name)
        toAdd.sort()
        cls.validators.extend([value for _name, value in toAdd])

    def __init__(self, *args, **kw):
        Validator.__init__(self, *args, **kw)
        self.validators = self.validators[:]
        self.validators.extend(self.validatorArgs)

    @staticmethod
    def _repr_vars(names):
        return [n for n in Validator._repr_vars(names)
                if n != 'validatorArgs']

    def _attempt_convert(self, value, state, convertFunc):
        raise NotImplementedError("Subclasses must implement _attempt_convert")

    def _convert_to_python(self, value, state=None):
        return self._attempt_convert(value, state,
                                    to_python)

    def _convert_from_python(self, value, state=None):
        return self._attempt_convert(value, state,
                                    from_python)

    def subvalidators(self):
        return self.validators


class Any(CompoundValidator):
    """Check if any of the specified validators is valid.

    This class is like an 'or' operator for validators.  The first
    validator/converter in the order of evaluation that validates the value
    will be used.

    The order of evaluation differs depending on if you are validating to
    Python or from Python as follows:

    The validators are evaluated right to left when validating to Python.

    The validators are evaluated left to right when validating from Python.

    Examples::

        >>> from formencode.validators import DictConverter
        >>> av = Any(validators=[DictConverter({2: 1}),
        ... DictConverter({3: 2}), DictConverter({4: 3})])
        >>> av.to_python(3)
        2
        >>> av.from_python(2)
        3

    """

    def _attempt_convert(self, value, state, validate):
        lastException = None
        validators = self.validators
        if validate is to_python:
            validators = reversed(validators)
        for validator in validators:
            try:
                return validate(validator, value, state)
            except Invalid as e:
                lastException = e
        if self.if_invalid is NoDefault:
            raise lastException
        return self.if_invalid

    @property
    def not_empty(self):
        not_empty = True
        for validator in self.validators:
            not_empty = not_empty and getattr(validator, 'not_empty', False)
        return not_empty

    def is_empty(self, value):
        # sub-validators should handle emptiness.
        return False

    @property
    def accept_iterator(self):
        accept_iterator = False
        for validator in self.validators:
            accept_iterator = accept_iterator or getattr(
                validator, 'accept_iterator', False)
        return accept_iterator


class All(CompoundValidator):
    """Check if all of the specified validators are valid.

    This class is like an 'and' operator for validators.  All
    validators must work, and the results are passed in turn through
    all validators for conversion in the order of evaluation. All
    is the same as `Pipe` but operates in the reverse order.

    The order of evaluation differs depending on if you are validating to
    Python or from Python as follows:

    The validators are evaluated right to left when validating to Python.

    The validators are evaluated left to right when validating from Python.

    `Pipe` is more intuitive when predominantly validating to Python.

    Examples::

        >>> from formencode.validators import DictConverter
        >>> av = All(validators=[DictConverter({2: 1}),
        ... DictConverter({3: 2}), DictConverter({4: 3})])
        >>> av.to_python(4)
        1
        >>> av.from_python(1)
        4

    """

    def __repr__(self):
        return '<All %s>' % self.validators

    def _attempt_convert(self, value, state, validate):
        # To preserve the order of the transformations, we do them
        # differently when we are converting to and from Python.
        validators = self.validators
        if validate is to_python:
            validators = reversed(validators)
        try:
            for validator in validators:
                value = validate(validator, value, state)
        except Invalid:
            if self.if_invalid is NoDefault:
                raise
            return self.if_invalid
        return value

    def with_validator(self, validator):
        """Add another validator.

        Adds the validator (or list of validators) to a copy of
        this validator.
        """
        new = self.validators[:]
        if isinstance(validator, (list, tuple)):
            new.extend(validator)
        else:
            new.append(validator)
        return self.__class__(*new, **dict(if_invalid=self.if_invalid))

    @classmethod
    def join(cls, *validators):
        """Join the specified validators.

        Joins several validators together as a single validator,
        filtering out None and trying to keep `All` validators from
        being nested (which isn't needed).
        """
        validators = filter(lambda v: v and v is not Identity, validators)
        if not validators:
            return Identity
        if len(validators) == 1:
            return validators[0]
        if isinstance(validators[0], All):
            return validators[0].with_validator(validators[1:])
        return cls(*validators)

    @property
    def if_missing(self):
        for validator in self.validators:
            v = validator.if_missing
            if v is not NoDefault:
                return v
        return NoDefault

    @property
    def not_empty(self):
        not_empty = False
        for validator in self.validators:
            not_empty = not_empty or getattr(validator, 'not_empty', False)
        return not_empty

    def is_empty(self, value):
        # sub-validators should handle emptiness.
        return False

    @property
    def accept_iterator(self):
        accept_iterator = True
        for validator in self.validators:
            accept_iterator = accept_iterator and getattr(
                validator, 'accept_iterator', False)
        return accept_iterator


class Pipe(All):
    """Pipe value through all specified validators.

    This class works like `All` but the order of evaluation is opposite. All
    validators must work, and the results are passed in turn through
    each validator for conversion in the order of evaluation.  A behaviour
    known to Unix and GNU users as 'pipe'.

    The order of evaluation differs depending on if you are validating to
    Python or from Python as follows:

    The validators are evaluated left to right when validating to Python.

    The validators are evaluated right to left when validating from Python.

    Examples::

        >>> from formencode.validators import DictConverter
        >>> pv = Pipe(validators=[DictConverter({1: 2}),
        ... DictConverter({2: 3}), DictConverter({3: 4})])
        >>> pv.to_python(1)
        4
        >>> pv.from_python(4)
        1

    """

    def __repr__(self):
        return '<Pipe %s>' % self.validators

    def _attempt_convert(self, value, state, validate):
        # To preserve the order of the transformations, we do them
        # differently when we are converting to and from Python.
        validators = self.validators
        if validate is from_python:
            validators = reversed(self.validators)
        try:
            for validator in validators:
                value = validate(validator, value, state)
        except Invalid:
            if self.if_invalid is NoDefault:
                raise
            return self.if_invalid
        return value

########NEW FILE########
__FILENAME__ = context
"""
A dynamic-scope-like system, aka fluid variables.

The idea behind dynamic scoped variables is for when, at one level,
you want to change the behavior of something you call.  Except you
can't pass in any new arguments (e.g., there's some function or object
inbetween you and the thing you want to change), or you can't predict
exactly what you will want to change.

You should use it like::

    context = Context()

    def do_stuff():
        state = context.set(inside='do_stuff')
        try:
            do stuff...
        finally:
            state.restore()

Then ``context.inside`` will be set to ``'do_stuff'`` inside that try
block.  If a value isn't set, you'll get an attribute error.

Note that all values are thread local; this means you cannot use a
context object to pass information to another thread.  In a
single-thread environment it doesn't really matter.

Typically you will create ``Context`` instances for your application,
environment, etc.  These should be global module-level variables, that
may be imported by any interested module; each instance is a namespace
of its own.

Sometimes it's nice to have default values, instead of getting
attribute errors.  This makes it easier to put in new variables that
are intended to be used elsewhere, without having to use
``getattr(context, 'var', default)`` to avoid AttributeErrors.
There are two ways (that can be used together) to do this.

First, when instantiating a ``Context`` object, you can give it a
``default`` value.  If given, then all variables will default to that
value.  ``None`` is a typical value for that.

Another is ``context.set_default(**vars)``, which will set only those
variables to default values.  This will not effect the stack of
scopes, but will only add defaults.

When Python 2.5 comes out, this syntax would certainly be useful::

    with context(page='view'):
        do stuff...

And ``page`` will be set to ``'view'`` only inside that ``with`` block.
"""

import threading

from itertools import count

__all__ = ['Context', 'ContextRestoreError']

_restore_ids = count()


class NoDefault(object):
    """A dummy value used for parameters with no default."""


class ContextRestoreError(Exception):
    """Raised when something is restored out-of-order."""


class Context(object):

    def __init__(self, default=NoDefault):
        self.__dict__['_local'] = threading.local()
        self.__dict__['_default'] = default

    def __getattr__(self, attr):
        if attr.startswith('_'):
            raise AttributeError
        try:
            stack = self._local.stack
        except AttributeError:
            stack = []
        for i in range(len(stack) - 1, -1, -1):
            if attr in stack[i][0]:
                return stack[i][0][attr]
        if self._default is NoDefault:
            raise AttributeError(
                "The attribute %s has not been set on %r"
                % (attr, self))
        return self._default

    def __setattr__(self, attr, value):
        raise AttributeError(
            "You can only write attribute on context object with the .set() method")

    def set(self, **kw):
        state_id = _restore_ids.next()
        try:
            stack = self._local.stack
        except AttributeError:
            stack = self._local.stack = [({}, -1)]
        restorer = RestoreState(self, state_id)
        stack.append((kw, state_id))
        return restorer

    def _restore(self, state_id):
        try:
            stack = self._local.stack
        except AttributeError:
            raise ContextRestoreError(
                "Tried to restore context %r (to state ID %s) but no variables have been set in context"
                % (self, state_id))
        if stack[-1][1] == -1:
            raise ContextRestoreError(
                "Out of order restoration of context %r (to state ID %s); the stack state is empty"
                % (self, state_id))
        if stack[-1][1] != state_id:
            raise ContextRestoreError(
                "Out of order restoration of context %r (to state ID %s) when last state is %s"
                % (self, state_id, stack[-1][1]))
        stack.pop()

    def set_default(self, **kw):
        try:
            stack = self._local.stack
        except AttributeError:
            stack = self._local.stack = [({}, -1)]
        stack[0][0].update(kw)

    def __repr__(self):
        try:
            stack = self._local.stack
        except AttributeError:
            stack = []
        myid = hex(abs(id(self)))[2:]
        if not stack:
            return '<%s %s (empty)>' % (self.__class__.__name__, myid)
        cur = {}
        for kw, _state_id in stack:
            cur.update(kw)
        keys = sorted(cur)
        varlist = []
        for key in keys:
            rep = repr(cur[key])
            if len(rep) > 10:
                rep = rep[:9] + '...' + rep[-1]
            varlist.append('%s=%s' % (key, rep))
        return '<%s %s %s>' % (
            self.__class__.__name__, myid, ' '.join(varlist))


class RestoreState(object):

    def __init__(self, context, state_id):
        self.state_id = state_id
        self.context = context
        self.restored = False

    def restore(self):
        if self.restored:
            # @@: Should this really be allowed?
            return
        self.context._restore(self.state_id)
        self.restored = True

########NEW FILE########
__FILENAME__ = declarative
"""
Declarative objects for FormEncode.

Declarative objects have a simple protocol: you can use classes in
lieu of instances and they are equivalent, and any keyword arguments
you give to the constructor will override those instance variables.
(So if a class is received, we'll simply instantiate an instance with
no arguments).

You can provide a variable __unpackargs__ (a list of strings), and if
the constructor is called with non-keyword arguments they will be
interpreted as the given keyword arguments.

If __unpackargs__ is ('*', name), then all the arguments will be put
in a variable by that name.

Also, you can define a __classinit__(cls, new_attrs) method, which
will be called when the class is created (including subclasses).
"""

import copy
import types

from itertools import count


class classinstancemethod(object):
    """
    Acts like a class method when called from a class, like an
    instance method when called by an instance.  The method should
    take two arguments, 'self' and 'cls'; one of these will be None
    depending on how the method was called.
    """

    def __init__(self, func):
        self.func = func

    def __get__(self, obj, cls=None):
        return _methodwrapper(self.func, obj=obj, cls=cls)


class _methodwrapper(object):

    def __init__(self, func, obj, cls):
        self.func = func
        self.obj = obj
        self.cls = cls

    def __call__(self, *args, **kw):
        assert 'self' not in kw and 'cls' not in kw, (
            "You cannot use 'self' or 'cls' arguments to a "
            "classinstancemethod")
        return self.func(*((self.obj, self.cls) + args), **kw)

    def __repr__(self):
        if self.obj is None:
            return ('<bound class method %s.%s>'
                    % (self.cls.__name__, self.func.func_name))
        return ('<bound method %s.%s of %r>'
                % (self.cls.__name__, self.func.func_name, self.obj))


class DeclarativeMeta(type):

    def __new__(meta, class_name, bases, new_attrs):
        cls = type.__new__(meta, class_name, bases, new_attrs)
        for name in cls.__mutableattributes__:
            setattr(cls, name, copy.copy(getattr(cls, name)))
        cls.declarative_count = cls.counter.next()
        if ('__classinit__' in new_attrs and not isinstance(cls.__classinit__,
                (staticmethod, types.FunctionType))):
            setattr(cls, '__classinit__',
                    staticmethod(cls.__classinit__.im_func))
        cls.__classinit__(cls, new_attrs)
        names = getattr(cls, '__singletonmethods__', None)
        if names:
            for name in names:
                meth = cls.__dict__.get(name)
                if meth and not isinstance(meth, singletonmethod):
                    setattr(cls, name, singletonmethod(meth))
        return cls


class singletonmethod(object):
    """
    For Declarative subclasses, this decorator will call the method
    on the cls.singleton() object if called as a class method (or
    as normal if called as an instance method).
    """

    def __init__(self, func):
        self.func = func

    def __get__(self, obj, cls=None):
        if obj is None:
            obj = cls.singleton()
        return types.MethodType(self.func, obj)


class Declarative(object):

    __unpackargs__ = ()

    __mutableattributes__ = ()

    __metaclass__ = DeclarativeMeta

    __singletonmethods__ = ()

    counter = count()

    @staticmethod
    def __classinit__(cls, new_attrs):
        pass

    def __init__(self, *args, **kw):
        if self.__unpackargs__ and self.__unpackargs__[0] == '*':
            assert len(self.__unpackargs__) == 2, (
                "When using __unpackargs__ = ('*', varname),"
                " you must only provide a single variable name"
                " (you gave %r)" % self.__unpackargs__)
            name = self.__unpackargs__[1]
            if name in kw:
                if args:
                    raise TypeError(
                        "keyword parameter '%s' was given by position and name"
                        % name)
            else:
                kw[name] = args
        else:
            if len(args) > len(self.__unpackargs__):
                raise TypeError(
                    '%s() takes at most %i arguments (%i given)'
                    % (self.__class__.__name__,
                       len(self.__unpackargs__),
                       len(args)))
            for name, arg in zip(self.__unpackargs__, args):
                if name in kw:
                    raise TypeError(
                        "keyword parameter '%s' was given by position and name"
                        % name)
                kw[name] = arg
        for name in self.__mutableattributes__:
            if name not in kw:
                setattr(self, name, copy.copy(getattr(self, name)))
        for name, value in kw.iteritems():
            setattr(self, name, value)
        if 'declarative_count' not in kw:
            self.declarative_count = self.counter.next()
        self.__initargs__(kw)

    def __initargs__(self, new_attrs):
        pass

    def __call__(self, *args, **kw):
        current = self.__dict__.copy()
        current.update(kw)
        return self.__class__(*args, **current)

    @classmethod
    def singleton(cls):
        name = '_%s__singleton' % cls.__name__
        if not hasattr(cls, name):
            try:
                setattr(cls, name, cls(
                    declarative_count=cls.declarative_count))
            except TypeError:  # takes arguments
                setattr(cls, name, cls)
        return getattr(cls, name)

    def __sourcerepr__(self, source, binding=None):
        if binding and len(self.__dict__) > 3:
            return self._source_repr_class(source, binding=binding)
        vals = self.__dict__.copy()
        if 'declarative_count' in vals:
            del vals['declarative_count']
        args = []
        if (self.__unpackargs__ and self.__unpackargs__[0] == '*'
                and self.__unpackargs__[1] in vals):
            v = vals[self.__unpackargs__[1]]
            if isinstance(v, (list, int)):
                args.extend(map(source.makeRepr, v))
                del v[self.__unpackargs__[1]]
        for name in self.__unpackargs__:
            if name in vals:
                args.append(source.makeRepr(vals[name]))
                del vals[name]
            else:
                break
        args.extend('%s=%s' % (name, source.makeRepr(value))
                     for (name, value) in vals.iteritems())
        return '%s(%s)' % (self.__class__.__name__,
                           ', '.join(args))

    def _source_repr_class(self, source, binding=None):
        d = self.__dict__.copy()
        if 'declarative_count' in d:
            del d['declarative_count']
        return source.makeClass(self, binding, d,
                                (self.__class__,))

    @classmethod
    def __classsourcerepr__(cls, source, binding=None):
        d = cls.__dict__.copy()
        del d['declarative_count']
        return source.makeClass(cls, binding or cls.__name__, d,
                                cls.__bases__)

    @classinstancemethod
    def __repr__(self, cls):
        if self:
            name = '%s object' % self.__class__.__name__
            v = self.__dict__.copy()
        else:
            name = '%s class' % cls.__name__
            v = cls.__dict__.copy()
        if 'declarative_count' in v:
            name = '%s %i' % (name, v.pop('declarative_count'))
        names = sorted(v)
        args = ['%s=self' % n if v[n] is self else '%s=%r' % (n, v[n])
            for n in self._repr_vars(names)]
        if not args:
            return '<%s>' % name
        return '<%s %s>' % (name, ' '.join(args))

    @staticmethod
    def _repr_vars(dictNames):
        return sorted(n for n in dictNames
            if not n.startswith('_') and n != 'declarative_count')

########NEW FILE########
__FILENAME__ = doctest_xml_compare

import doctest
import xml.etree.ElementTree as ET
try:
    XMLParseError = ET.ParseError
except AttributeError:  # Python < 2.7
    from xml.parsers.expat import ExpatError as XMLParseError

RealOutputChecker = doctest.OutputChecker


def debug(*msg):
    import sys
    print >> sys.stderr, ' '.join(map(str, msg))


class HTMLOutputChecker(RealOutputChecker):

    def check_output(self, want, got, optionflags):
        normal = RealOutputChecker.check_output(self, want, got, optionflags)
        if normal or not got:
            return normal
        try:
            want_xml = make_xml(want)
        except XMLParseError:
            pass
        else:
            try:
                got_xml = make_xml(got)
            except XMLParseError:
                pass
            else:
                if xml_compare(want_xml, got_xml):
                    return True
        return False

    def output_difference(self, example, got, optionflags):
        actual = RealOutputChecker.output_difference(
            self, example, got, optionflags)
        want_xml = got_xml = None
        try:
            want_xml = make_xml(example.want)
            want_norm = make_string(want_xml)
        except XMLParseError as e:
            if example.want.startswith('<'):
                want_norm = '(bad XML: %s)' % e
                #  '<xml>%s</xml>' % example.want
            else:
                return actual
        try:
            got_xml = make_xml(got)
            got_norm = make_string(got_xml)
        except XMLParseError as e:
            if example.want.startswith('<'):
                got_norm = '(bad XML: %s)' % e
            else:
                return actual
        s = '%s\nXML Wanted: %s\nXML Got   : %s\n' % (
            actual, want_norm, got_norm)
        if got_xml and want_xml:
            result = []
            xml_compare(want_xml, got_xml, result.append)
            s += 'Difference report:\n%s\n' % '\n'.join(result)
        return s


def xml_compare(x1, x2, reporter=None):
    if x1.tag != x2.tag:
        if reporter:
            reporter('Tags do not match: %s and %s' % (x1.tag, x2.tag))
        return False
    for name, value in x1.attrib.iteritems():
        if x2.attrib.get(name) != value:
            if reporter:
                reporter('Attributes do not match: %s=%r, %s=%r'
                         % (name, value, name, x2.attrib.get(name)))
            return False
    for name in x2.attrib:
        if name not in x1.attrib:
            if reporter:
                reporter('x2 has an attribute x1 is missing: %s'
                         % name)
            return False
    if not text_compare(x1.text, x2.text):
        if reporter:
            reporter('text: %r != %r' % (x1.text, x2.text))
        return False
    if not text_compare(x1.tail, x2.tail):
        if reporter:
            reporter('tail: %r != %r' % (x1.tail, x2.tail))
        return False
    cl1 = list(x1)
    cl2 = list(x2)
    if len(cl1) != len(cl2):
        if reporter:
            reporter('children length differs, %i != %i'
                     % (len(cl1), len(cl2)))
        return False
    i = 0
    for c1, c2 in zip(cl1, cl2):
        i += 1
        if not xml_compare(c1, c2, reporter=reporter):
            if reporter:
                reporter('children %i do not match: %s'
                         % (i, c1.tag))
            return False
    return True


def text_compare(t1, t2):
    if not t1 and not t2:
        return True
    if t1 == '*' or t2 == '*':
        return True
    return (t1 or '').strip() == (t2 or '').strip()


def make_xml(s):
    return ET.XML('<xml>%s</xml>' % s)


def make_string(xml):
    if isinstance(xml, basestring):
        xml = make_xml(xml)
    s = ET.tostring(xml)
    if s == '<xml />':
        return ''
    assert s.startswith('<xml>') and s.endswith('</xml>'), repr(s)
    return s[5:-6]


def install():
    doctest.OutputChecker = HTMLOutputChecker

########NEW FILE########
__FILENAME__ = exc
"""
Custom exceptions and warnings.
"""

__all__ = ['FERunTimeWarning']


class FERuntimeWarning(RuntimeWarning):
    """ Run time warning. """
    pass

########NEW FILE########
__FILENAME__ = fieldstorage
## FormEncode, a  Form processor
## Copyright (C) 2003, Ian Bicking <ianb@colorstudy.com>
"""
Wrapper class for use with cgi.FieldStorage types for file uploads
"""

import cgi


def convert_fieldstorage(fs):
    return fs if fs.filename else None

########NEW FILE########
__FILENAME__ = foreach
"""
Validator for repeating items.
"""

from .api import NoDefault, Invalid
from .compound import CompoundValidator, from_python

__all__ = ['ForEach']


class ForEach(CompoundValidator):
    """
    Use this to apply a validator/converter to each item in a list.

    For instance::

        ForEach(AsInt(), InList([1, 2, 3]))

    Will take a list of values and try to convert each of them to
    an integer, and then check if each integer is 1, 2, or 3.  Using
    multiple arguments is equivalent to::

        ForEach(All(AsInt(), InList([1, 2, 3])))

    Use convert_to_list=True if you want to force the input to be a
    list.  This will turn non-lists into one-element lists, and None
    into the empty list.  This tries to detect sequences by iterating
    over them (except strings, which aren't considered sequences).

    ForEach will try to convert the entire list, even if errors are
    encountered.  If errors are encountered, they will be collected
    and a single Invalid exception will be raised at the end (with
    error_list set).

    If the incoming value is a set, then we return a set.
    """

    convert_to_list = True
    if_empty = NoDefault
    accept_iterator = True
    repeating = True
    _if_missing = ()

    def _attempt_convert(self, value, state, validate):
        if self.convert_to_list:
            value = self._convert_to_list(value)
        if self.if_empty is not NoDefault and not value:
            return self.if_empty
        if self.not_empty and not value:
            if validate is from_python and self.accept_python:
                return []
            raise Invalid(
                self.message('empty', state),
                value, state)
        new_list = []
        errors = []
        all_good = True
        is_set = isinstance(value, set)
        if state is not None:
            previous_index = getattr(state, 'index', NoDefault)
            previous_full_list = getattr(state, 'full_list', NoDefault)
            index = 0
            state.full_list = value
        try:
            for sub_value in value:
                if state:
                    state.index = index
                    index += 1
                good_pass = True
                for validator in self.validators:
                    try:
                        sub_value = validate(validator, sub_value, state)
                    except Invalid as e:
                        errors.append(e)
                        all_good = False
                        good_pass = False
                        break
                if good_pass:
                    errors.append(None)
                new_list.append(sub_value)
            if all_good:
                if is_set:
                    new_list = set(new_list)
                return new_list
            else:
                raise Invalid('Errors:\n%s' % '\n'.join(unicode(e)
                    for e in errors if e), value, state, error_list=errors)
        finally:
            if state is not None:
                if previous_index is NoDefault:
                    try:
                        del state.index
                    except AttributeError:
                        pass
                else:
                    state.index = previous_index
                if previous_full_list is NoDefault:
                    try:
                        del state.full_list
                    except AttributeError:
                        pass
                else:
                    state.full_list = previous_full_list

    def empty_value(self, value):
        return []

    class _IfMissing(object):

        def __get__(self, obj, cls=None):
            if obj is None:
                return []
            elif obj._if_missing is ForEach._if_missing:
                return []
            else:
                return obj._if_missing

        def __set__(self, obj, value):
            obj._if_missing = value

        def __delete__(self, obj):
            obj._if_missing = NoDefault

    if_missing = _IfMissing()
    del _IfMissing

    def _convert_to_list(self, value):
        if isinstance(value, basestring):
            return [value]
        elif value is None:
            return []
        elif isinstance(value, (list, tuple)):
            return value
        try:
            for _n in value:
                break
            return value
        ## @@: Should this catch any other errors?:
        except TypeError:
            return [value]

########NEW FILE########
__FILENAME__ = htmlfill
"""
Parser for HTML forms, that fills in defaults and errors.  See ``render``.
"""

import re

from formencode.rewritingparser import RewritingParser, html_quote

__all__ = ['render', 'htmlliteral', 'default_formatter',
           'none_formatter', 'escape_formatter',
           'FillingParser']


def render(form, defaults=None, errors=None, use_all_keys=False,
           error_formatters=None, add_attributes=None,
           auto_insert_errors=True, auto_error_formatter=None,
           text_as_default=False, checkbox_checked_if_present=False,
           listener=None, encoding=None,
           error_class='error', prefix_error=True,
           force_defaults=True, skip_passwords=False):
    """
    Render the ``form`` (which should be a string) given the ``defaults``
    and ``errors``.  Defaults are the values that go in the input fields
    (overwriting any values that are there) and errors are displayed
    inline in the form (and also effect input classes).  Returns the
    rendered string.

    If ``auto_insert_errors`` is true (the default) then any errors
    for which ``<form:error>`` tags can't be found will be put just
    above the associated input field, or at the top of the form if no
    field can be found.

    If ``use_all_keys`` is true, if there are any extra fields from
    defaults or errors that couldn't be used in the form it will be an
    error.

    ``error_formatters`` is a dictionary of formatter names to
    one-argument functions that format an error into HTML.  Some
    default formatters are provided if you don't provide this.

    ``error_class`` is the class added to input fields when there is
    an error for that field.

    ``add_attributes`` is a dictionary of field names to a dictionary
    of attribute name/values.  If the name starts with ``+`` then the
    value will be appended to any existing attribute (e.g.,
    ``{'+class': ' important'}``).

    ``auto_error_formatter`` is used to create the HTML that goes
    above the fields.  By default it wraps the error message in a span
    and adds a ``<br>``.

    If ``text_as_default`` is true (default false) then ``<input
    type="unknown">`` will be treated as text inputs.

    If ``checkbox_checked_if_present`` is true (default false) then
    ``<input type="checkbox">`` will be set to ``checked`` if any
    corresponding key is found in the ``defaults`` dictionary, even
    a value that evaluates to False (like an empty string).  This
    can be used to support pre-filling of checkboxes that do not have
    a ``value`` attribute, since browsers typically will only send
    the name of the checkbox in the form submission if the checkbox
    is checked, so simply the presence of the key would mean the box
    should be checked.

    ``listener`` can be an object that watches fields pass; the only
    one currently is in ``htmlfill_schemabuilder.SchemaBuilder``

    ``encoding`` specifies an encoding to assume when mixing str and
    unicode text in the template.

    ``prefix_error`` specifies if the HTML created by auto_error_formatter is
    put before the input control (default) or after the control.

    ``force_defaults`` specifies if a field default is not given in
    the ``defaults`` dictionary then the control associated with the
    field should be set as an unsuccessful control. So checkboxes will
    be cleared, radio and select controls will have no value selected,
    and textareas will be emptied. This defaults to ``True``, which is
    appropriate the defaults are the result of a form submission.

    ``skip_passwords`` specifies if password fields should be skipped when
    rendering form-content.  If disabled the password fields will not be filled
    with anything, which is useful when you don't want to return a user's
    password in plain-text source.
    """
    if defaults is None:
        defaults = {}
    if auto_insert_errors and auto_error_formatter is None:
        auto_error_formatter = default_formatter
    p = FillingParser(
        defaults=defaults, errors=errors,
        use_all_keys=use_all_keys,
        error_formatters=error_formatters,
        add_attributes=add_attributes,
        auto_error_formatter=auto_error_formatter,
        text_as_default=text_as_default,
        checkbox_checked_if_present=checkbox_checked_if_present,
        listener=listener, encoding=encoding,
        prefix_error=prefix_error,
        error_class=error_class,
        force_defaults=force_defaults,
        skip_passwords=skip_passwords,
        )
    p.feed(form)
    p.close()
    return p.text()


class htmlliteral(object):

    def __init__(self, html, text=None):
        if text is None:
            text = re.sub(r'<.*?>', '', html)
            text = html.replace('&gt;', '>')
            text = html.replace('&lt;', '<')
            text = html.replace('&quot;', '"')
            # @@: Not very complete
        self.html = html
        self.text = text

    def __str__(self):
        return self.text

    def __repr__(self):
        return '<%s html=%r text=%r>' % (
            self.__class__.__name__, self.html, self.text)

    def __html__(self):
        return self.html


def default_formatter(error):
    """
    Formatter that escapes the error, wraps the error in a span with
    class ``error-message``, and adds a ``<br>``
    """
    return '<span class="error-message">%s</span><br />\n' % html_quote(error)


def none_formatter(error):
    """
    Formatter that does nothing, no escaping HTML, nothin'
    """
    return error


def escape_formatter(error):
    """
    Formatter that escapes HTML, no more.
    """
    return html_quote(error)


def escapenl_formatter(error):
    """
    Formatter that escapes HTML, and translates newlines to ``<br>``
    """
    error = html_quote(error)
    error = error.replace('\n', '<br>\n')
    return error


def ignore_formatter(error):
    """
    Formatter that emits nothing, regardless of the error.
    """
    return ''


class FillingParser(RewritingParser):
    r"""
    Fills HTML with default values, as in a form.

    Examples::

        >>> defaults = dict(name='Bob Jones',
        ...             occupation='Crazy Cultist',
        ...             address='14 W. Canal\nNew Guinea',
        ...             living='no',
        ...             nice_guy=0)
        >>> parser = FillingParser(defaults)
        >>> parser.feed('''<input type="text" name="name" value="fill">
        ... <select name="occupation"> <option value="">Default</option>
        ... <option value="Crazy Cultist">Crazy cultist</option> </select>
        ... <textarea cols="20" style="width: 100%" name="address">
        ... An address</textarea>
        ... <input type="radio" name="living" value="yes">
        ... <input type="radio" name="living" value="no">
        ... <input type="checkbox" name="nice_guy" checked="checked">''')
        >>> parser.close()
        >>> print parser.text() # doctest: +NORMALIZE_WHITESPACE
        <input type="text" name="name" value="Bob Jones">
        <select name="occupation">
        <option value="">Default</option>
        <option value="Crazy Cultist" selected="selected">Crazy cultist</option>
        </select>
        <textarea cols="20" style="width: 100%" name="address">14 W. Canal
        New Guinea</textarea>
        <input type="radio" name="living" value="yes">
        <input type="radio" name="living" value="no" checked="checked">
        <input type="checkbox" name="nice_guy">

    """

    default_encoding = 'utf8'

    text_input_types = set("text hidden search tel url email datetime date"
        " month week time datetime-local number range color".split())

    def __init__(self, defaults, errors=None, use_all_keys=False,
                 error_formatters=None, error_class='error',
                 add_attributes=None, listener=None,
                 auto_error_formatter=None,
                 text_as_default=False, checkbox_checked_if_present=False,
                 encoding=None, prefix_error=True,
                 force_defaults=True, skip_passwords=False):
        RewritingParser.__init__(self)
        self.source = None
        self.lines = None
        self.source_pos = None
        self.defaults = defaults
        self.in_textarea = None
        self.skip_textarea = False
        self.last_textarea_name = None
        self.in_select = None
        self.skip_next = False
        self.errors = errors or {}
        if isinstance(self.errors, basestring):
            self.errors = {None: self.errors}
        self.in_error = None
        self.skip_error = False
        self.use_all_keys = use_all_keys
        self.used_keys = set()
        self.used_errors = set()
        if error_formatters is None:
            self.error_formatters = default_formatter_dict
        else:
            self.error_formatters = error_formatters
        self.error_class = error_class
        self.add_attributes = add_attributes or {}
        self.listener = listener
        self.auto_error_formatter = auto_error_formatter
        self.text_as_default = text_as_default
        self.checkbox_checked_if_present = checkbox_checked_if_present
        self.encoding = encoding
        self.prefix_error = prefix_error
        self.force_defaults = force_defaults
        self.skip_passwords = skip_passwords

    def str_compare(self, str1, str2):
        """
        Compare the two objects as strings (coercing to strings if necessary).
        Also uses encoding to compare the strings.
        """
        if not isinstance(str1, basestring):
            if hasattr(str1, '__unicode__'):
                str1 = unicode(str1)
            else:
                str1 = str(str1)
        if type(str1) == type(str2):
            return str1 == str2
        if isinstance(str1, unicode):
            str1 = str1.encode(self.encoding or self.default_encoding)
        else:
            str2 = str2.encode(self.encoding or self.default_encoding)
        return str1 == str2

    def close(self):
        self.handle_misc(None)
        RewritingParser.close(self)
        unused_errors = self.errors.copy()
        for key in self.used_errors:
            if key in unused_errors:
                del unused_errors[key]
        if self.auto_error_formatter:
            for key, value in unused_errors.iteritems():
                error_message = self.auto_error_formatter(value)
                error_message = '<!-- for: %s -->\n%s' % (key, error_message)
                self.insert_at_marker(
                    key, error_message)
            unused_errors = {}
        if self.use_all_keys:
            unused = self.defaults.copy()
            for key in self.used_keys:
                if key in unused:
                    del unused[key]
            assert not unused, (
                "These keys from defaults were not used in the form: %s"
                % ', '.join(unused))
            if unused_errors:
                error_text = ['%s: %s' % (key, self.errors[key])
                    for key in sorted(unused_errors)]
                assert False, (
                    "These errors were not used in the form: %s"
                    % ', '.join(error_text))
        if self.encoding is not None:
            new_content = []
            for item in self._content:
                if (unicode is not str  # Python 2
                        and isinstance(item, str)):
                    item = item.decode(self.encoding)
                new_content.append(item)
            self._content = new_content
        self._text = self._get_text()

    def skip_output(self):
        return (self.in_textarea and self.skip_textarea) or self.skip_error

    def add_key(self, key):
        self.used_keys.add(key)

    def handle_starttag(self, tag, attrs, startend=False):
        self.write_pos()
        if tag == 'input':
            self.handle_input(attrs, startend)
        elif tag == 'textarea':
            self.handle_textarea(attrs)
        elif tag == 'select':
            self.handle_select(attrs)
        elif tag == 'option':
            self.handle_option(attrs)
            return
        elif tag == 'form:error':
            self.handle_error(attrs)
            return
        elif tag == 'form:iferror':
            self.handle_iferror(attrs)
            return
        else:
            return
        if self.listener:
            self.listener.listen_input(self, tag, attrs)

    def handle_endtag(self, tag):
        self.write_pos()
        if tag == 'textarea':
            self.handle_end_textarea()
        elif tag == 'select':
            self.handle_end_select()
        elif tag == 'form:error':
            self.handle_end_error()
        elif tag == 'form:iferror':
            self.handle_end_iferror()

    def handle_startendtag(self, tag, attrs):
        return self.handle_starttag(tag, attrs, True)

    def handle_iferror(self, attrs):
        name = self.get_attr(attrs, 'name')
        assert name, (
            "Name attribute in <iferror> required at %i:%i" % self.getpos())
        notted = name.startswith('not ')
        if notted:
            name = name.split(None, 1)[1]
        self.in_error = name
        ok = self.errors.get(name)
        if notted:
            ok = not ok
        if not ok:
            self.skip_error = True
        self.skip_next = True

    def handle_end_iferror(self):
        self.in_error = None
        self.skip_error = False
        self.skip_next = True

    def handle_error(self, attrs):
        name = self.get_attr(attrs, 'name')
        if name is None:
            name = self.in_error
        assert name is not None, (
            "Name attribute in <form:error> required"
            " if not contained in <form:iferror> at %i:%i" % self.getpos())
        formatter = self.get_attr(attrs, 'format') or 'default'
        error = self.errors.get(name, '')
        if error:
            error = self.error_formatters[formatter](error)
            self.write_text(error)
        self.skip_next = True
        self.used_errors.add(name)

    def handle_end_error(self):
        self.skip_next = True

    def handle_input(self, attrs, startend):
        t = (self.get_attr(attrs, 'type') or 'text').lower()
        name = self.get_attr(attrs, 'name')
        if self.prefix_error:
            self.write_marker(name)
        value = self.defaults.get(name)
        if (unicode is not str  # Python 2
                and isinstance(name, unicode) and isinstance(value, str)):
            value = value.decode(self.encoding or self.default_encoding)
        if name in self.add_attributes:
            for attr_name, attr_value in self.add_attributes[name].iteritems():
                if attr_name.startswith('+'):
                    attr_name = attr_name[1:]
                    self.set_attr(attrs, attr_name,
                        self.get_attr(attrs, attr_name, '') + attr_value)
                else:
                    self.set_attr(attrs, attr_name, attr_value)
        if (self.error_class
                and self.errors.get(self.get_attr(attrs, 'name'))):
            self.add_class(attrs, self.error_class)
        if t in self.text_input_types:
            if value is None and not self.force_defaults:
                value = self.get_attr(attrs, 'value', '')
            self.set_attr(attrs, 'value', value)
            self.write_tag('input', attrs, startend)
            self.skip_next = True
            self.add_key(name)
        elif t == 'checkbox':
            if self.force_defaults:
                selected = False
            else:
                selected = self.get_attr(attrs, 'checked')
            if not self.get_attr(attrs, 'value'):
                if self.checkbox_checked_if_present:
                    selected = name in self.defaults
                else:
                    selected = value
            elif self.selected_multiple(value,
                                        self.get_attr(attrs, 'value', '')):
                selected = True
            if selected:
                self.set_attr(attrs, 'checked', 'checked')
            else:
                self.del_attr(attrs, 'checked')
            self.write_tag('input', attrs, startend)
            self.skip_next = True
            self.add_key(name)
        elif t == 'radio':
            if self.str_compare(value, self.get_attr(attrs, 'value', '')):
                self.set_attr(attrs, 'checked', 'checked')
            elif self.force_defaults or name in self.defaults:
                self.del_attr(attrs, 'checked')
            self.write_tag('input', attrs, startend)
            self.skip_next = True
            self.add_key(name)
        elif t == 'password':
            if self.skip_passwords:
                return
            if value is None and not self.force_defaults:
                value = value or self.get_attr(attrs, 'value', '')
            self.set_attr(attrs, 'value', value)
            self.write_tag('input', attrs, startend)
            self.skip_next = True
            self.add_key(name)
        elif t in ('file', 'image'):
            self.write_tag('input', attrs, startend)
            self.skip_next = True
            self.add_key(name)
        elif t in ('submit', 'reset', 'button'):
            self.set_attr(attrs, 'value', value or
                          self.get_attr(attrs, 'value', ''))
            self.write_tag('input', attrs, startend)
            self.skip_next = True
            self.add_key(name)
        elif self.text_as_default:
            if value is None:
                value = self.get_attr(attrs, 'value', '')
            self.set_attr(attrs, 'value', value)
            self.write_tag('input', attrs, startend)
            self.skip_next = True
            self.add_key(name)
        else:
            assert False, ("I don't know about this kind of <input>:"
                " %s at %i:%i" % ((t,) + self.getpos()))
        if not self.prefix_error:
            self.write_marker(name)

    def handle_textarea(self, attrs):
        name = self.get_attr(attrs, 'name')
        if self.prefix_error:
            self.write_marker(name)
        if (self.error_class
                and self.errors.get(name)):
            self.add_class(attrs, self.error_class)
        value = self.defaults.get(name, '')
        if value or self.force_defaults:
            self.write_tag('textarea', attrs)
            self.write_text(html_quote(value))
            self.write_text('</textarea>')
            self.skip_textarea = True
        self.in_textarea = True
        self.last_textarea_name = name
        self.add_key(name)

    def handle_end_textarea(self):
        if self.skip_textarea:
            self.skip_textarea = False
        else:
            self.write_text('</textarea>')
        self.in_textarea = False
        self.skip_next = True
        if not self.prefix_error:
            self.write_marker(self.last_textarea_name)
        self.last_textarea_name = None

    def handle_select(self, attrs):
        name = self.get_attr(attrs, 'name', False)
        if name and self.prefix_error:
            self.write_marker(name)
        if (self.error_class
                and self.errors.get(name)):
            self.add_class(attrs, self.error_class)
        self.in_select = self.get_attr(attrs, 'name', False)
        self.write_tag('select', attrs)
        self.skip_next = True
        self.add_key(self.in_select)

    def handle_end_select(self):
        self.write_text('</select>')
        self.skip_next = True
        if not self.prefix_error and self.in_select:
            self.write_marker(self.in_select)
        self.in_select = None

    def handle_option(self, attrs):
        assert self.in_select is not None, (
            "<option> outside of <select> at %i:%i" % self.getpos())
        if self.in_select is not False:
            if self.force_defaults or self.in_select in self.defaults:
                if self.selected_multiple(self.defaults.get(self.in_select),
                                          self.get_attr(attrs, 'value', '')):
                    self.set_attr(attrs, 'selected', 'selected')
                    self.add_key(self.in_select)
                else:
                    self.del_attr(attrs, 'selected')
        self.write_tag('option', attrs)
        self.skip_next = True

    def selected_multiple(self, obj, value):
        """
        Returns true/false if obj indicates that value should be
        selected.  If obj has a __contains__ method it is used, otherwise
        identity is used.
        """
        if obj is None:
            return False
        if isinstance(obj, basestring):
            return obj == value
        if hasattr(obj, '__contains__'):
            if value in obj:
                return True
        if hasattr(obj, '__iter__'):
            for inner in obj:
                if self.str_compare(inner, value):
                    return True
        return self.str_compare(obj, value)

    def write_marker(self, marker):
        self._content.append((marker,))

    def insert_at_marker(self, marker, text):
        for i, item in enumerate(self._content):
            if item == (marker,):
                self._content.insert(i, text)
                break
        else:
            self._content.insert(0, text)


# This can potentially be extended globally
default_formatter_dict = dict(
    default=default_formatter,
    none=none_formatter,
    escape=escape_formatter,
    escapenl=escapenl_formatter,
    ignore=ignore_formatter)

########NEW FILE########
__FILENAME__ = htmlfill_schemabuilder
"""
Extension to ``htmlfill`` that can parse out schema-defining
statements.

You can either pass ``SchemaBuilder`` to ``htmlfill.render`` (the
``listen`` argument), or call ``parse_schema`` to just parse out a
``Schema`` object.
"""

from . import validators
from . import schema
from . import compound
from . import htmlfill

__all__ = ['parse_schema', 'SchemaBuilder']


def parse_schema(form):
    """
    Given an HTML form, parse out the schema defined in it and return
    that schema.
    """
    listener = SchemaBuilder()
    p = htmlfill.FillingParser(
        defaults={}, listener=listener)
    p.feed(form)
    p.close()
    return listener.schema()


default_validators = dict(
    [(name.lower(), getattr(validators, name))
     for name in dir(validators)])


def get_messages(cls, message):
    if not message:
        return {}
    else:
        return dict([(k, message) for k in cls._messages])


def to_bool(value):
    value = value.strip().lower()
    if value in ('true', 't', 'yes', 'y', 'on', '1'):
        return True
    elif value in ('false', 'f', 'no', 'n', 'off', '0'):
        return False
    else:
        raise ValueError("Not a boolean value: %r (use 'true'/'false')")


def force_list(v):
    """
    Force single items into a list. This is useful for checkboxes.
    """
    if isinstance(v, list):
        return v
    elif isinstance(v, tuple):
        return list(v)
    else:
        return [v]


class SchemaBuilder(object):

    def __init__(self, validators=default_validators):
        self.validators = validators
        self._schema = None

    def reset(self):
        self._schema = schema.Schema()

    def schema(self):
        return self._schema

    def listen_input(self, parser, tag, attrs):
        get_attr = parser.get_attr
        name = get_attr(attrs, 'name')
        if not name:
            # @@: should warn if you try to validate unnamed fields
            return
        v = compound.All(validators.Identity())
        add_to_end = None
        # for checkboxes, we must set if_missing = False
        if tag.lower() == "input":
            type_attr = get_attr(attrs, "type").lower().strip()
            if type_attr == "submit":
                v.validators.append(validators.Bool())
            elif type_attr == "checkbox":
                v.validators.append(validators.Wrapper(to_python=force_list))
            elif type_attr == "file":
                add_to_end = validators.FieldStorageUploadConverter()
        message = get_attr(attrs, 'form:message')
        required = to_bool(get_attr(attrs, 'form:required', 'false'))
        if required:
            v.validators.append(
                validators.NotEmpty(
                messages=get_messages(validators.NotEmpty, message)))
        else:
            v.validators[0].if_missing = False
        if add_to_end:
            v.validators.append(add_to_end)
        v_type = get_attr(attrs, 'form:validate', None)
        if v_type:
            pos = v_type.find(':')
            if pos != -1:
                # @@: should parse args
                args = (v_type[pos + 1:],)
                v_type = v_type[:pos]
            else:
                args = ()
            v_type = v_type.lower()
            v_class = self.validators.get(v_type)
            if not v_class:
                raise ValueError("Invalid validation type: %r" % v_type)
            kw_args = {'messages': get_messages(v_class, message)}
            v_inst = v_class(
                *args, **kw_args)
            v.validators.append(v_inst)
        self._schema.add_field(name, v)

########NEW FILE########
__FILENAME__ = htmlgen
"""
Kind of like htmlgen, only much simpler.  The only important symbol
that is exported is ``html``.

This builds ElementTree nodes, but with some extra useful methods.
(Open issue: should it use ``ElementTree`` more, and the raw
``Element`` stuff less?)

You create tags with attribute access.  I.e., the ``A`` anchor tag is
``html.a``.  The attributes of the HTML tag are done with keyword
arguments.  The contents of the tag are the non-keyword arguments
(concatenated).  You can also use the special ``c`` keyword, passing a
list, tuple, or single tag, and it will make up the contents (this is
useful because keywords have to come after all non-keyword arguments,
which is non-intuitive).  Or you can chain them, adding the keywords
with one call, then the body with a second call, like::

    >>> str(html.a(href='http://yahoo.com')('<Yahoo>'))
    '<a href="http://yahoo.com">&lt;Yahoo&gt;</a>'

Note that strings will be quoted; only tags given explicitly will
remain unquoted.

If the value of an attribute is None, then no attribute
will be inserted.  So::

    >>> str(html.a(href='http://www.yahoo.com', name=None,
    ...              c='Click Here'))
    '<a href="http://www.yahoo.com">Click Here</a>'

If the value is None, then the empty string is used.  Otherwise str()
is called on the value.

``html`` can also be called, and it will produce a special list from
its arguments, which adds a ``__str__`` method that does ``html.str``
(which handles quoting, flattening these lists recursively, and using
'' for ``None``).

``html.comment`` will generate an HTML comment, like
``html.comment('comment text')`` -- note that it cannot take keyword
arguments (because they wouldn't mean anything).

Examples::

    >>> str(html.html(
    ...    html.head(html.title("Page Title")),
    ...    html.body(
    ...    bgcolor='#000066',
    ...    text='#ffffff',
    ...    c=[html.h1('Page Title'),
    ...       html.p('Hello world!')],
    ...    )))
    '<html><head><title>Page Title</title></head><body bgcolor="#000066" text="#ffffff"><h1>Page Title</h1><p>Hello world!</p></body></html>'
    >>> str(html.a(href='#top')('return to top'))
    '<a href="#top">return to top</a>'

"""

import xml.etree.ElementTree as ET

try:
    from html import escape
except ImportError:  # Python < 3.2
    from cgi import escape


__all__ = ['html']

default_encoding = 'utf-8'


class _HTML:

    def __getattr__(self, attr):
        if attr.startswith('_'):
            raise AttributeError
        attr = attr.lower()
        if attr.endswith('_'):
            attr = attr[:-1]
        if '__' in attr:
            attr = attr.replace('__', ':')
        if attr == 'comment':
            return Element(ET.Comment, {})
        else:
            return Element(attr, {})

    def __call__(self, *args):
        return ElementList(args)

    def quote(self, arg):
        if arg is None:
            return ''
        if unicode is not str:  # Python 2
            arg = unicode(arg).encode(default_encoding)
        return escape(arg, True)

    def str(self, arg, encoding=None):
        if isinstance(arg, basestring):
            if not isinstance(arg, str):
                arg = arg.encode(default_encoding)
            return arg
        elif arg is None:
            return ''
        elif isinstance(arg, (list, tuple)):
            return ''.join(map(self.str, arg))
        elif isinstance(arg, Element):
            return str(arg)
        else:
            arg = unicode(arg)
            if not isinstance(arg, str):  # Python 2
                arg = arg.encode(default_encoding)
            return arg

html = _HTML()


class Element(ET.Element
        if isinstance(ET.Element, type) else ET._ElementInterface):

    def __call__(self, *args, **kw):
        el = self.__class__(self.tag, self.attrib)
        if 'c' in kw:
            if args:
                raise ValueError(
                    "You may either provide positional arguments or a "
                    "'c' keyword argument, but not both")
            args = kw.pop('c')
            if not isinstance(args, (list, tuple)):
                args = (args,)
        for name, value in kw.items():
            if value is None:
                del kw[name]
                continue
            kw[name] = unicode(value)
            if name.endswith('_'):
                kw[name[:-1]] = value
                del kw[name]
            if '__' in name:
                new_name = name.replace('__', ':')
                kw[new_name] = value
                del kw[name]
        el.attrib.update(kw)
        el.text = self.text
        last = None
        for item in list(self):
            last = item
            el.append(item)
        for arg in flatten(args):
            if arg is None:
                continue
            if not ET.iselement(arg):
                if last is None:
                    if el.text is None:
                        el.text = unicode(arg)
                    else:
                        el.text += unicode(arg)
                else:
                    if last.tail is None:
                        last.tail = unicode(arg)
                    else:
                        last.tail += unicode(arg)
            else:
                last = arg
                el.append(last)
        return el

    if unicode is str:  # Python 3

        def __str__(self):
            return ET.tostring(
                self, default_encoding).decode(default_encoding)

    else:

        def __str__(self):
            return ET.tostring(self, default_encoding)

        def __unicode__(self):
            # This is lame!
            return str(self).decode(default_encoding)

    def __repr__(self):
        content = str(self)
        if len(content) > 25:
            content = repr(content[:25]) + '...'
        else:
            content = repr(content)
        return '<Element %r>' % content


class ElementList(list):

    def __str__(self):
        return html.str(self)

    def __repr__(self):
        return 'ElementList(%s)' % list.__repr__(self)


def flatten(items):
    for item in items:
        if isinstance(item, (list, tuple)):
            for sub in flatten(item):
                yield sub
        else:
            yield item

########NEW FILE########
__FILENAME__ = htmlrename
"""
Module to rename form fields
"""

from formencode.rewritingparser import RewritingParser

__all__ = ['rename', 'add_prefix']


def rename(form, rename_func):
    """
    Rename all the form fields in the form (a string), using rename_func

    rename_func will be called with one argument, the name of the
    field, and should return a new name.
    """
    p = RenamingParser(rename_func)
    p.feed(form)
    p.close()
    return p.text()


def add_prefix(form, prefix, dotted=False):
    """
    Add the given prefix to all the fields in the form.

    If dotted is true, then add a dot between prefix and the previous
    name.  Empty fields will use the prefix as the name (with no dot).
    """
    def rename_func(field_name):
        if dotted:
            if field_name:
                return prefix + '.' + field_name
            else:
                return prefix
        else:
            return prefix + field_name
    return rename(form, rename_func)


class RenamingParser(RewritingParser):

    def __init__(self, rename_func):
        RewritingParser.__init__(self)
        self.rename_func = rename_func

    def close(self):
        self.handle_misc(None)
        RewritingParser.close(self)
        self._text = self._get_text()

    def text(self):
        try:
            return self._text
        except AttributeError:
            raise Exception(
                "You must .close() a parser instance before getting "
                "the text from it")

    def handle_starttag(self, tag, attrs, startend=False):
        self.write_pos()
        if tag in ('input', 'textarea', 'select'):
            self.handle_field(tag, attrs, startend)
        else:
            return

    def handle_startendtag(self, tag, attrs):
        return self.handle_starttag(tag, attrs, True)

    def handle_field(self, tag, attrs, startend):
        name = self.get_attr(attrs, 'name', '')
        new_name = self.rename_func(name)
        if name is None:
            self.del_attr(attrs, 'name')
        else:
            self.set_attr(attrs, 'name', new_name)
        self.write_tag(tag, attrs)
        self.skip_next = True

########NEW FILE########
__FILENAME__ = interfaces
"""
Interfaces for FormEncode (for documentation purposes only)
"""


class Attribute(object):

    def __init__(self, description, name=None):
        self.description = description
        self.name = name


class Interface(object):
    pass


class IDeclarative(Interface):

    def __init__(**kw):
        """
        Instantiates this class with all the keywords being used to
        update the instance variables.
        """

    def __call__(**kw):
        """
        Returns a copy with all attributes using the given keywords,
        being updated.
        """


class IValidator(IDeclarative):

    messages = Attribute("""
    A dictionary of messages (with formatting strings) for error
    responses""", name='messages')
    if_missing = Attribute("""
    If the source that this validator would handle is missing (e.g.,
    a field that was not specified), use this value.  If
    Validator.NoDefault, then if the field is missing an exception
    should be raised.""", name='ifMissing')
    repeating = Attribute("""
    A boolean; this object accepts lists if true, subvalidators can be
    found in the validators attribute.""", name='repeating')
    compound = Attribute("""
    A boolean; this object has a dictionary of validators if this is
    true, subvalidators can be found in the field attribute (a
    dictionary).""", name='compound')

    def to_python(value, state=None):
        """
        Convert `value` from its foreign representation to its Python
        representation.  `state` is for application-specific hooks.
        """

    def from_python(value, state=None):
        """
        Convert `value` from its Python representation to the foreign
        representation.  `state` is for application-specific hooks.
        """

    def message(name, default):
        """
        Return the message (from the `messages` attribute) that goes
        with `name`, or return default if `name` not found `default`.
        """


class ISchema(IValidator):

    fields = Attribute('A dictionary of (field name: validator)',
        name='fields')

########NEW FILE########
__FILENAME__ = national
"""
Country specific validators for use with FormEncode.
"""
import re

from .api import FancyValidator
from .compound import Any
from .validators import Regex, Invalid, _

try:
    import pycountry
except ImportError:
    pycountry = None
try:
    from turbogears.i18n import format as tgformat
except ImportError:
    tgformat = None

if pycountry or tgformat:
    no_country = False
else:
    import warnings
    no_country = ('Please easy_install pycountry or validators handling'
                  ' country names and/or languages will not work.')

############################################################
## country lists and functions
############################################################

country_additions = [
    ('BY', _('Belarus')),
    ('ME', _('Montenegro')),
    ('AU', _('Tasmania')),
]

fuzzy_countrynames = [
    ('US', 'U.S.A'),
    ('US', 'USA'),
    ('GB', _('Britain')),
    ('GB', _('Great Britain')),
    ('CI', _('Cote de Ivoire')),
]

if tgformat:

    def get_countries():
        c1 = tgformat.get_countries('en')
        c2 = tgformat.get_countries()
        if len(c1) > len(c2):
            d = dict(country_additions)
            d.update(dict(c1))
            d.update(dict(c2))
        else:
            d = dict(country_additions)
            d.update(dict(c2))
        ret = d.items() + fuzzy_countrynames
        return ret

    def get_country(code):
        return dict(get_countries())[code]

    def get_languages():
        c1 = tgformat.get_languages('en')
        c2 = tgformat.get_languages()
        if len(c1) > len(c2):
            d = dict(c1)
            d.update(dict(c2))
            return d.items()
        else:
            return c2

    def get_language(code):
        try:
            return tgformat.get_language(code)
        except KeyError:
            return tgformat.get_language(code, 'en')

elif pycountry:

    # @@ mark: interestingly, common gettext notation does not work here
    import gettext
    gettext.bindtextdomain('iso3166', pycountry.LOCALES_DIR)
    _c = lambda t: gettext.dgettext('iso3166', t)
    gettext.bindtextdomain('iso639', pycountry.LOCALES_DIR)
    _l = lambda t: gettext.dgettext('iso639', t)

    def get_countries():
        c1 = set([(e.alpha2, _c(e.name)) for e in pycountry.countries])
        ret = c1.union(country_additions + fuzzy_countrynames)
        return ret

    def get_country(code):
        return _c(pycountry.countries.get(alpha2=code).name)

    def get_languages():
        return [(e.alpha2, _l(e.name)) for e in pycountry.languages
            if e.name and getattr(e, 'alpha2', None)]

    def get_language(code):
        return _l(pycountry.languages.get(alpha2=code).name)


############################################################
## country, state and postal code validators
############################################################

class DelimitedDigitsPostalCode(Regex):
    """
    Abstraction of common postal code formats, such as 55555, 55-555 etc.
    With constant amount of digits. By providing a single digit as partition
    you can obtain a trivial 'x digits' postal code validator.

    ::

        >>> german = DelimitedDigitsPostalCode(5)
        >>> german.to_python('55555')
        '55555'
        >>> german.to_python('5555')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a zip code (5 digits)
        >>> polish = DelimitedDigitsPostalCode([2, 3], '-')
        >>> polish.to_python('55555')
        '55-555'
        >>> polish.to_python('55-555')
        '55-555'
        >>> polish.to_python('5555')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a zip code (nn-nnn)
        >>> nicaragua = DelimitedDigitsPostalCode([3, 3, 1], '-')
        >>> nicaragua.to_python('5554443')
        '555-444-3'
        >>> nicaragua.to_python('555-4443')
        '555-444-3'
        >>> nicaragua.to_python('5555')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a zip code (nnn-nnn-n)
    """

    strip = True

    def assembly_formatstring(self, partition_lengths, delimiter):
        if len(partition_lengths) == 1:
            return _('%d digits') % partition_lengths[0]
        else:
            return delimiter.join('n' * l for l in partition_lengths)

    def assembly_regex(self, partition_lengths, delimiter):
        mg = [r'(\d{%d})' % l for l in partition_lengths]
        rd = r'\%s?' % delimiter
        return rd.join(mg)

    def __init__(self, partition_lengths, delimiter=None,
                 *args, **kw):
        if isinstance(partition_lengths, (int, long)):
            partition_lengths = [partition_lengths]
        if not delimiter:
            delimiter = ''
        self.format = self.assembly_formatstring(partition_lengths, delimiter)
        self.regex = self.assembly_regex(partition_lengths, delimiter)
        self.partition_lengths, self.delimiter = partition_lengths, delimiter
        Regex.__init__(self, *args, **kw)

    messages = dict(
        invalid=_('Please enter a zip code (%(format)s)'))

    def _convert_to_python(self, value, state):
        self.assert_string(value, state)
        match = self.regex.search(value)
        if not match:
            raise Invalid(
                self.message('invalid', state, format=self.format),
                value, state)
        return self.delimiter.join(match.groups())


def USPostalCode(*args, **kw):
    """
    US Postal codes (aka Zip Codes).

    ::

        >>> uspc = USPostalCode()
        >>> uspc.to_python('55555')
        '55555'
        >>> uspc.to_python('55555-5555')
        '55555-5555'
        >>> uspc.to_python('5555')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a zip code (5 digits)
    """
    return Any(DelimitedDigitsPostalCode(5, None, *args, **kw),
               DelimitedDigitsPostalCode([5, 4], '-', *args, **kw))


def GermanPostalCode(*args, **kw):
    return DelimitedDigitsPostalCode(5, None, *args, **kw)


def FourDigitsPostalCode(*args, **kw):
    return DelimitedDigitsPostalCode(4, None, *args, **kw)


def PolishPostalCode(*args, **kw):
    return DelimitedDigitsPostalCode([2, 3], '-', *args, **kw)


class ArgentinianPostalCode(Regex):
    """
    Argentinian Postal codes.

    ::

        >>> ArgentinianPostalCode.to_python('C1070AAM')
        'C1070AAM'
        >>> ArgentinianPostalCode.to_python('c 1070 aam')
        'C1070AAM'
        >>> ArgentinianPostalCode.to_python('5555')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a zip code (LnnnnLLL)
    """

    format = _('LnnnnLLL')
    regex = re.compile(r'^([a-zA-Z]{1})\s*(\d{4})\s*([a-zA-Z]{3})$')
    strip = True

    messages = dict(
        invalid=_('Please enter a zip code (%(format)s)'))

    def _convert_to_python(self, value, state):
        self.assert_string(value, state)
        match = self.regex.search(value)
        if not match:
            raise Invalid(
                self.message('invalid', state, format=self.format),
                value, state)
        return '%s%s%s' % (match.group(1).upper(),
                           match.group(2),
                           match.group(3).upper())


class CanadianPostalCode(Regex):
    """
    Canadian Postal codes.

    ::

        >>> CanadianPostalCode.to_python('V3H 1Z7')
        'V3H 1Z7'
        >>> CanadianPostalCode.to_python('v3h1z7')
        'V3H 1Z7'
        >>> CanadianPostalCode.to_python('5555')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a zip code (LnL nLn)
    """

    format = _('LnL nLn')
    regex = re.compile(r'^([a-zA-Z]\d[a-zA-Z])\s?(\d[a-zA-Z]\d)$')
    strip = True

    messages = dict(
        invalid=_('Please enter a zip code (%(format)s)'))

    def _convert_to_python(self, value, state):
        self.assert_string(value, state)
        match = self.regex.search(value)
        if not match:
            raise Invalid(
                self.message('invalid', state, format=self.format),
                value, state)
        return '%s %s' % (match.group(1).upper(), match.group(2).upper())


class UKPostalCode(Regex):
    """
    UK Postal codes. Please see BS 7666.

    ::

        >>> UKPostalCode.to_python('BFPO 3')
        'BFPO 3'
        >>> UKPostalCode.to_python('LE11 3GR')
        'LE11 3GR'
        >>> UKPostalCode.to_python('l1a 3gr')
        'L1A 3GR'
        >>> UKPostalCode.to_python('5555')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a valid postal code (for format see BS 7666)
    """

    regex = re.compile(r'^((ASCN|BBND|BIQQ|FIQQ|PCRN|SIQQ|STHL|TDCU|TKCA)'
        ' 1ZZ|BFPO (c\/o )?[1-9]{1,4}|GIR 0AA|[A-PR-UWYZ]'
        '([0-9]{1,2}|([A-HK-Y][0-9]|[A-HK-Y][0-9]([0-9]|[ABEHMNPRV-Y]))'
        '|[0-9][A-HJKS-UW]) [0-9][ABD-HJLNP-UW-Z]{2})$', re.I)
    strip = True

    messages = dict(
        invalid=_('Please enter a valid postal code (for format see BS 7666)'))

    def _convert_to_python(self, value, state):
        self.assert_string(value, state)
        match = self.regex.search(value)
        if not match:
            raise Invalid(
                self.message('invalid', state),
                value, state)
        return match.group(1).upper()


class CountryValidator(FancyValidator):
    """
    Will convert a country's name into its ISO-3166 abbreviation for unified
    storage in databases etc. and return a localized country name in the
    reverse step.

    @See http://www.iso.org/iso/country_codes/iso_3166_code_lists.htm

    ::

        >>> CountryValidator.to_python('Germany')
        u'DE'
        >>> CountryValidator.to_python('Finland')
        u'FI'
        >>> CountryValidator.to_python('UNITED STATES')
        u'US'
        >>> CountryValidator.to_python('Krakovia')
        Traceback (most recent call last):
            ...
        Invalid: That country is not listed in ISO 3166
        >>> CountryValidator.from_python('DE')
        u'Germany'
        >>> CountryValidator.from_python('FI')
        u'Finland'
    """

    key_ok = True

    messages = dict(
        valueNotFound=_('That country is not listed in ISO 3166'))

    def __init__(self, *args, **kw):
        FancyValidator.__init__(self, *args, **kw)
        if no_country:
            warnings.warn(no_country, Warning, 2)

    def _convert_to_python(self, value, state):
        upval = value.upper()
        if self.key_ok:
            try:
                get_country(upval)
            except Exception:
                pass
            else:
                return upval
        for k, v in get_countries():
            if v.upper() == upval:
                return k
        raise Invalid(self.message('valueNotFound', state), value, state)

    def _convert_from_python(self, value, state):
        try:
            return get_country(value.upper())
        except KeyError:
            return value


class PostalCodeInCountryFormat(FancyValidator):
    """
    Makes sure the postal code is in the country's format by chosing postal
    code validator by provided country code. Does convert it into the preferred
    format, too.

    ::

        >>> fs = PostalCodeInCountryFormat('country', 'zip')
        >>> sorted(fs.to_python(dict(country='DE', zip='30167')).items())
        [('country', 'DE'), ('zip', '30167')]
        >>> fs.to_python(dict(country='DE', zip='3008'))
        Traceback (most recent call last):
            ...
        Invalid: Given postal code does not match the country's format.
        >>> sorted(fs.to_python(dict(country='PL', zip='34343')).items())
        [('country', 'PL'), ('zip', '34-343')]
        >>> fs = PostalCodeInCountryFormat('staat', 'plz')
        >>> sorted(fs.to_python(dict(staat='GB', plz='l1a 3gr')).items())
        [('plz', 'L1A 3GR'), ('staat', 'GB')]
    """

    country_field = 'country'
    zip_field = 'zip'

    __unpackargs__ = ('country_field', 'zip_field')

    messages = dict(
        badFormat=_("Given postal code does not match the country's format."))

    _vd = {
        'AR': ArgentinianPostalCode,
        'AT': FourDigitsPostalCode,
        'BE': FourDigitsPostalCode,
        'BG': FourDigitsPostalCode,
        'CA': CanadianPostalCode,
        'CL': lambda: DelimitedDigitsPostalCode(7),
        'CN': lambda: DelimitedDigitsPostalCode(6),
        'CR': FourDigitsPostalCode,
        'DE': GermanPostalCode,
        'DK': FourDigitsPostalCode,
        'DO': lambda: DelimitedDigitsPostalCode(5),
        'ES': lambda: DelimitedDigitsPostalCode(5),
        'FI': lambda: DelimitedDigitsPostalCode(5),
        'FR': lambda: DelimitedDigitsPostalCode(5),
        'GB': UKPostalCode,
        'GF': lambda: DelimitedDigitsPostalCode(5),
        'GR': lambda: DelimitedDigitsPostalCode([2, 3], ' '),
        'HN': lambda: DelimitedDigitsPostalCode(5),
        'HT': FourDigitsPostalCode,
        'HU': FourDigitsPostalCode,
        'IS': lambda: DelimitedDigitsPostalCode(3),
        'IT': lambda: DelimitedDigitsPostalCode(5),
        'JP': lambda: DelimitedDigitsPostalCode([3, 4], '-'),
        'KR': lambda: DelimitedDigitsPostalCode([3, 3], '-'),
        'LI': FourDigitsPostalCode,
        'LU': FourDigitsPostalCode,
        'MC': lambda: DelimitedDigitsPostalCode(5),
        'NI': lambda: DelimitedDigitsPostalCode([3, 3, 1], '-'),
        'NO': FourDigitsPostalCode,
        'PL': PolishPostalCode,
        'PT': lambda: DelimitedDigitsPostalCode([4, 3], '-'),
        'PY': FourDigitsPostalCode,
        'RO': lambda: DelimitedDigitsPostalCode(6),
        'SE': lambda: DelimitedDigitsPostalCode([3, 2], ' '),
        'SG': lambda: DelimitedDigitsPostalCode(6),
        'US': USPostalCode,
        'UY': lambda: DelimitedDigitsPostalCode(5),
    }

    def _validate_python(self, fields_dict, state):
        if fields_dict[self.country_field] in self._vd:
            zip_validator = self._vd[fields_dict[self.country_field]]()
            try:
                fields_dict[self.zip_field] = zip_validator.to_python(
                    fields_dict[self.zip_field], state=state)
            except Invalid as e:
                message = self.message('badFormat', state)
                raise Invalid(message, fields_dict, state,
                    error_dict={self.zip_field: e.msg,
                        self.country_field: message})


class USStateProvince(FancyValidator):
    """
    Valid state or province code (two-letter).

    Well, for now I don't know the province codes, but it does state
    codes.  Give your own `states` list to validate other state-like
    codes; give `extra_states` to add values without losing the
    current state values.

    ::

        >>> s = USStateProvince('XX')
        >>> s.to_python('IL')
        'IL'
        >>> s.to_python('XX')
        'XX'
        >>> s.to_python('xx')
        'XX'
        >>> s.to_python('YY')
        Traceback (most recent call last):
            ...
        Invalid: That is not a valid state code
    """

    states = ['AK', 'AL', 'AR', 'AZ', 'CA', 'CO', 'CT', 'DC', 'DE',
              'FL', 'GA', 'HI', 'IA', 'ID', 'IN', 'IL', 'KS', 'KY',
              'LA', 'MA', 'MD', 'ME', 'MI', 'MN', 'MO', 'MS', 'MT',
              'NC', 'ND', 'NE', 'NH', 'NJ', 'NM', 'NV', 'NY', 'OH',
              'OK', 'OR', 'PA', 'RI', 'SC', 'SD', 'TN', 'TX', 'UT',
              'VA', 'VT', 'WA', 'WI', 'WV', 'WY']

    extra_states = []

    __unpackargs__ = ('extra_states',)

    messages = dict(
        empty=_('Please enter a state code'),
        wrongLength=_('Please enter a state code with TWO letters'),
        invalid=_('That is not a valid state code'))

    def _validate_python(self, value, state):
        value = str(value).strip().upper()
        if not value:
            raise Invalid(
                self.message('empty', state),
                value, state)
        if not value or len(value) != 2:
            raise Invalid(
                self.message('wrongLength', state),
                value, state)
        if value not in self.states and not (
                self.extra_states and value in self.extra_states):
            raise Invalid(
                self.message('invalid', state),
                value, state)

    def _convert_to_python(self, value, state):
        return str(value).strip().upper()


############################################################
## phone number validators
############################################################

class USPhoneNumber(FancyValidator):
    """
    Validates, and converts to ###-###-####, optionally with extension
    (as ext.##...).  Only support US phone numbers.  See
    InternationalPhoneNumber for support for that kind of phone number.

    ::

        >>> p = USPhoneNumber()
        >>> p.to_python('333-3333')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a number, with area code, in the form ###-###-####, optionally with "ext.####"
        >>> p.to_python('555-555-5555')
        '555-555-5555'
        >>> p.to_python('1-393-555-3939')
        '1-393-555-3939'
        >>> p.to_python('321.555.4949')
        '321.555.4949'
        >>> p.to_python('3335550000')
        '3335550000'
    """
    # for emacs: "

    _phoneRE = re.compile(r'^\s*(?:1-)?(\d\d\d)[\- \.]?(\d\d\d)[\- \.]?'
        '(\d\d\d\d)(?:\s*ext\.?\s*(\d+))?\s*$', re.I)

    messages = dict(
        phoneFormat=_('Please enter a number, with area code,'
            ' in the form ###-###-####, optionally with "ext.####"'))

    def _convert_to_python(self, value, state):
        self.assert_string(value, state)
        match = self._phoneRE.search(value)
        if not match:
            raise Invalid(
                self.message('phoneFormat', state),
                value, state)
        return value

    def _convert_from_python(self, value, state):
        self.assert_string(value, state)
        match = self._phoneRE.search(value)
        if not match:
            raise Invalid(self.message('phoneFormat', state),
                          value, state)
        result = '%s-%s-%s' % (match.group(1), match.group(2), match.group(3))
        if match.group(4):
            result += " ext.%s" % match.group(4)
        return result


class InternationalPhoneNumber(FancyValidator):
    """
    Validates, and converts phone numbers to +##-###-#######.
    Adapted from RFC 3966

    @param  default_cc      country code for prepending if none is provided
                            can be a paramerless callable

    ::

        >>> c = InternationalPhoneNumber(default_cc=lambda: 49)
        >>> c.to_python('0555/8114100')
        '+49-555-8114100'
        >>> p = InternationalPhoneNumber(default_cc=49)
        >>> p.to_python('333-3333')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a number, with area code, in the form +##-###-#######.
        >>> p.to_python('0555/4860-300')
        '+49-555-4860-300'
        >>> p.to_python('0555-49924-51')
        '+49-555-49924-51'
        >>> p.to_python('0555 / 8114100')
        '+49-555-8114100'
        >>> p.to_python('0555/8114100')
        '+49-555-8114100'
        >>> p.to_python('0555 8114100')
        '+49-555-8114100'
        >>> p.to_python(' +49 (0)555 350 60 0')
        '+49-555-35060-0'
        >>> p.to_python('+49 555 350600')
        '+49-555-350600'
        >>> p.to_python('0049/ 555/ 871 82 96')
        '+49-555-87182-96'
        >>> p.to_python('0555-2 50-30')
        '+49-555-250-30'
        >>> p.to_python('0555 43-1200')
        '+49-555-43-1200'
        >>> p.to_python('(05 55)4 94 33 47')
        '+49-555-49433-47'
        >>> p.to_python('(00 48-555)2 31 72 41')
        '+48-555-23172-41'
        >>> p.to_python('+973-555431')
        '+973-555431'
        >>> p.to_python('1-393-555-3939')
        '+1-393-555-3939'
        >>> p.to_python('+43 (1) 55528/0')
        '+43-1-55528-0'
        >>> p.to_python('+43 5555 429 62-0')
        '+43-5555-42962-0'
        >>> p.to_python('00 218 55 33 50 317 321')
        '+218-55-3350317-321'
        >>> p.to_python('+218 (0)55-3636639/38')
        '+218-55-3636639-38'
        >>> p.to_python('032 555555 367')
        '+49-32-555555-367'
        >>> p.to_python('(+86) 555 3876693')
        '+86-555-3876693'
    """

    strip = True
    # Use if there's a default country code you want to use:
    default_cc = None
    _mark_chars_re = re.compile(r"[_.!~*'/]")
    _preTransformations = [
        (re.compile(r'^(\(?)(?:00\s*)(.+)$'), '%s+%s'),
        (re.compile(r'^\(\s*(\+?\d+)\s*(\d+)\s*\)(.+)$'), '(%s%s)%s'),
        (re.compile(r'^\((\+?[-\d]+)\)\s?(\d.+)$'), '%s-%s'),
        (re.compile(r'^(?:1-)(\d+.+)$'), '+1-%s'),
        (re.compile(r'^(\+\d+)\s+\(0\)\s*(\d+.+)$'), '%s-%s'),
        (re.compile(r'^([0+]\d+)[-\s](\d+)$'), '%s-%s'),
        (re.compile(r'^([0+]\d+)[-\s](\d+)[-\s](\d+)$'), '%s-%s-%s'),
        ]
    _ccIncluder = [
        (re.compile(r'^\(?0([1-9]\d*)[-)](\d.*)$'), '+%d-%s-%s'),
        ]
    _postTransformations = [
        (re.compile(r'^(\+\d+)[-\s]\(?(\d+)\)?[-\s](\d+.+)$'), '%s-%s-%s'),
        (re.compile(r'^(.+)\s(\d+)$'), '%s-%s'),
        ]
    _phoneIsSane = re.compile(r'^(\+[1-9]\d*)-([\d\-]+)$')

    messages = dict(
        phoneFormat=_('Please enter a number, with area code,'
            ' in the form +##-###-#######.'))

    def _perform_rex_transformation(self, value, transformations):
        for rex, trf in transformations:
            match = rex.search(value)
            if match:
                value = trf % match.groups()
        return value

    def _prepend_country_code(self, value, transformations, country_code):
        for rex, trf in transformations:
            match = rex.search(value)
            if match:
                return trf % ((country_code,) + match.groups())
        return value

    def _convert_to_python(self, value, state):
        self.assert_string(value, state)
        try:
            value = value.encode('ascii', 'strict')
        except UnicodeEncodeError:
            raise Invalid(self.message('phoneFormat', state), value, state)
        if unicode is str:  # Python 3
            value = value.decode('ascii')
        value = self._mark_chars_re.sub('-', value)
        for f, t in [('  ', ' '),
                ('--', '-'), (' - ', '-'), ('- ', '-'), (' -', '-')]:
            value = value.replace(f, t)
        value = self._perform_rex_transformation(
            value, self._preTransformations)
        if self.default_cc:
            if callable(self.default_cc):
                cc = self.default_cc()
            else:
                cc = self.default_cc
            value = self._prepend_country_code(value, self._ccIncluder, cc)
        value = self._perform_rex_transformation(
            value, self._postTransformations)
        value = value.replace(' ', '')
        # did we successfully transform that phone number? Thus, is it valid?
        if not self._phoneIsSane.search(value):
            raise Invalid(self.message('phoneFormat', state), value, state)
        return value


############################################################
## language validators
############################################################

class LanguageValidator(FancyValidator):
    """
    Converts a given language into its ISO 639 alpha 2 code, if there is any.
    Returns the language's full name in the reverse.

    Warning: ISO 639 neither differentiates between languages such as Cantonese
    and Mandarin nor does it contain all spoken languages. E.g., Lechitic
    languages are missing.
    Warning: ISO 639 is a smaller subset of ISO 639-2

    @param  key_ok  accept the language's code instead of its name for input
                    defaults to True

    ::

        >>> l = LanguageValidator()
        >>> l.to_python('German')
        u'de'
        >>> l.to_python('Chinese')
        u'zh'
        >>> l.to_python('Klingonian')
        Traceback (most recent call last):
            ...
        Invalid: That language is not listed in ISO 639
        >>> l.from_python('de')
        u'German'
        >>> l.from_python('zh')
        u'Chinese'
    """

    key_ok = True

    messages = dict(
        valueNotFound=_('That language is not listed in ISO 639'))

    def __init__(self, *args, **kw):
        FancyValidator.__init__(self, *args, **kw)
        if no_country:
            warnings.warn(no_country, Warning, 2)

    def _convert_to_python(self, value, state):
        upval = value.upper()
        if self.key_ok:
            try:
                get_language(value)
            except Exception:
                pass
            else:
                return value
        for k, v in get_languages():
            if v.upper() == upval:
                return k
        raise Invalid(self.message('valueNotFound', state), value, state)

    def _convert_from_python(self, value, state):
        try:
            return get_language(value.lower())
        except KeyError:
            return value


def validators():
    """Return the names of all validators in this module."""
    return [name for name, value in globals().items()
        if isinstance(value, type) and issubclass(value, FancyValidator)]

__all__ = ['Invalid'] + validators()

########NEW FILE########
__FILENAME__ = rewritingparser

import HTMLParser
import re

try:
    from html import escape
except ImportError:  # Python < 3.2
    from cgi import escape

from htmlentitydefs import name2codepoint


def html_quote(v):
    if v is None:
        return ''
    if hasattr(v, '__html__'):
        return v.__html__()
    if isinstance(v, basestring):
        return escape(v, True)
    if hasattr(v, '__unicode__'):
        v = unicode(v)
    else:
        v = str(v)
    return escape(v, True)


class RewritingParser(HTMLParser.HTMLParser):

    listener = None
    skip_next = False

    def __init__(self):
        self._content = []
        HTMLParser.HTMLParser.__init__(self)

    def feed(self, data):
        self.data_is_str = isinstance(data, str)
        self.source = data
        self.lines = data.split('\n')
        self.source_pos = 1, 0
        if self.listener:
            self.listener.reset()
        HTMLParser.HTMLParser.feed(self, data)

    _entityref_re = re.compile('&([a-zA-Z][-.a-zA-Z\d]*);')
    _charref_re = re.compile('&#(\d+|[xX][a-fA-F\d]+);')

    def unescape(self, s):
        s = self._entityref_re.sub(self._sub_entityref, s)
        s = self._charref_re.sub(self._sub_charref, s)
        return s

    def _sub_entityref(self, match):
        name = match.group(1)
        if name not in name2codepoint:
            # If we don't recognize it, pass it through as though it
            # wasn't an entity ref at all
            return match.group(0)
        return unichr(name2codepoint[name])

    def _sub_charref(self, match):
        num = match.group(1)
        if num.lower().startswith('x'):
            num = int(num[1:], 16)
        else:
            num = int(num)
        return unichr(num)

    def handle_misc(self, whatever):
        self.write_pos()
    handle_charref = handle_misc
    handle_entityref = handle_misc
    handle_data = handle_misc
    handle_comment = handle_misc
    handle_decl = handle_misc
    handle_pi = handle_misc
    unknown_decl = handle_misc
    handle_endtag = handle_misc

    def write_tag(self, tag, attrs, startend=False):
        attr_text = ''.join(' %s="%s"' % (n, html_quote(v))
            for (n, v) in attrs if not n.startswith('form:'))
        if startend:
            attr_text += " /"
        self.write_text('<%s%s>' % (tag, attr_text))

    def skip_output(self):
        return False

    def write_pos(self):
        cur_line, cur_offset = self.getpos()
        if self.skip_output():
            self.source_pos = self.getpos()
            return
        if self.skip_next:
            self.skip_next = False
            self.source_pos = self.getpos()
            return
        if cur_line == self.source_pos[0]:
            self.write_text(
                self.lines[cur_line - 1][self.source_pos[1]:cur_offset])
        else:
            self.write_text(
                self.lines[self.source_pos[0] - 1][self.source_pos[1]:])
            self.write_text('\n')
            for i in range(self.source_pos[0] + 1, cur_line):
                self.write_text(self.lines[i - 1])
                self.write_text('\n')
            self.write_text(self.lines[cur_line - 1][:cur_offset])
        self.source_pos = self.getpos()

    def write_text(self, text):
        self._content.append(text)

    def has_attr(self, attr, name):
        for a in attr:
            if a[0].lower() == name:
                return True
        return False

    def get_attr(self, attr, name, default=None):
        for a in attr:
            if a[0].lower() == name:
                return a[1]
        return default

    def set_attr(self, attr, name, value):
        for i, a in enumerate(attr):
            if a[0].lower() == name:
                attr[i] = (name, value)
                return
        attr.append((name, value))

    def del_attr(self, attr, name):
        for i, a in enumerate(attr):
            if a[0].lower() == name:
                del attr[i]
                break

    def add_class(self, attr, class_name):
        current = self.get_attr(attr, 'class', '')
        new = current + ' ' + class_name
        self.set_attr(attr, 'class', new.strip())

    def text(self):
        try:
            return self._text
        except AttributeError:
            raise Exception(
                "You must .close() a parser instance before getting "
                "the text from it")

    def _get_text(self):
        try:
            return ''.join(
                t for t in self._content if not isinstance(t, tuple))
        except UnicodeDecodeError as e:
            if self.data_is_str:
                e.reason += (
                    " the form was passed in as an encoded string, but"
                    " some data or error messages were unicode strings;"
                    " the form should be passed in as a unicode string")
            else:
                e.reason += (
                    " the form was passed in as an unicode string, but"
                    " some data or error message was an encoded string;"
                    " the data and error messages should be passed in as"
                    " unicode strings")
            raise

########NEW FILE########
__FILENAME__ = schema
import warnings

from .api import _, is_validator, FancyValidator, Invalid, NoDefault
from . import declarative
from .exc import FERuntimeWarning

__all__ = ['Schema']


class Schema(FancyValidator):

    """
    A schema validates a dictionary of values, applying different
    validators (be key) to the different values.  If
    allow_extra_fields=True, keys without validators will be allowed;
    otherwise they will raise Invalid. If filter_extra_fields is
    set to true, then extra fields are not passed back in the results.

    Validators are associated with keys either with a class syntax, or
    as keyword arguments (class syntax is usually easier).  Something
    like::

        class MySchema(Schema):
            name = Validators.PlainText()
            phone = Validators.PhoneNumber()

    These will not be available as actual instance variables, but will
    be collected in a dictionary.  To remove a validator in a subclass
    that is present in a superclass, set it to None, like::

        class MySubSchema(MySchema):
            name = None

    Note that missing fields are handled at the Schema level.  Missing
    fields can have the 'missing' message set to specify the error
    message, or if that does not exist the *schema* message
    'missingValue' is used.
    """

    # These validators will be applied before this schema:
    pre_validators = []
    # These validators will be applied after this schema:
    chained_validators = []
    # If true, then it is not an error when keys that aren't
    # associated with a validator are present:
    allow_extra_fields = False
    # If true, then keys that aren't associated with a validator
    # are removed:
    filter_extra_fields = False
    # If this is given, then any keys that aren't available but
    # are expected  will be replaced with this value (and then
    # validated!)  This does not override a present .if_missing
    # attribute on validators:
    if_key_missing = NoDefault
    # If true, then missing keys will be missing in the result,
    # if the validator doesn't have if_missing on it already:
    ignore_key_missing = False
    compound = True
    fields = {}
    order = []
    accept_iterator = True

    messages = dict(
        notExpected=_('The input field %(name)s was not expected.'),
        missingValue=_('Missing value'),
        badDictType=_('The input must be dict-like'
            ' (not a %(type)s: %(value)r)'),
        singleValueExpected=_('Please provide only one value'),)

    __mutableattributes__ = ('fields', 'chained_validators',
                             'pre_validators')

    @staticmethod
    def __classinit__(cls, new_attrs):
        FancyValidator.__classinit__(cls, new_attrs)
        # Don't bother doing anything if this is the most parent
        # Schema class (which is the only class with just
        # FancyValidator as a superclass):
        if cls.__bases__ == (FancyValidator,):
            return cls
        # Scan through the class variables we've defined *just*
        # for this subclass, looking for validators (both classes
        # and instances):
        for key, value in new_attrs.iteritems():
            if key in ('pre_validators', 'chained_validators'):
                if is_validator(value):
                    msg = "Any validator with the name %s will be ignored." % \
                            (key,)
                    warnings.warn(msg, FERuntimeWarning)
                continue
            if is_validator(value):
                cls.fields[key] = value
                delattr(cls, key)
            # This last case means we're overwriting a validator
            # from a superclass:
            elif key in cls.fields:
                del cls.fields[key]

        for name, value in cls.fields.iteritems():
            cls.add_field(name, value)

    def __initargs__(self, new_attrs):
        self.fields = self.fields.copy()
        for key, value in new_attrs.iteritems():
            if key in ('pre_validators', 'chained_validators'):
                if is_validator(value):
                    msg = "Any validator with the name %s will be ignored." % \
                            (key,)
                    warnings.warn(msg, FERuntimeWarning)
                continue
            if is_validator(value):
                self.fields[key] = value
                delattr(self, key)
            # This last case means we're overwriting a validator
            # from a superclass:
            elif key in self.fields:
                del self.fields[key]

    def assert_dict(self, value, state):
        """
        Helper to assure we have proper input
        """
        if not hasattr(value, 'items'):
            # Not a dict or dict-like object
            raise Invalid(
                self.message('badDictType', state,
                    type=type(value), value=value), value, state)

    def _convert_to_python(self, value_dict, state):
        if not value_dict:
            if self.if_empty is not NoDefault:
                return self.if_empty
            value_dict = {}

        for validator in self.pre_validators:
            value_dict = validator.to_python(value_dict, state)

        self.assert_dict(value_dict, state)

        new = {}
        errors = {}
        unused = self.fields.keys()
        if state is not None:
            previous_key = getattr(state, 'key', None)
            previous_full_dict = getattr(state, 'full_dict', None)
            state.full_dict = value_dict
        try:
            for name, value in value_dict.items():
                try:
                    unused.remove(name)
                except ValueError:
                    if not self.allow_extra_fields:
                        raise Invalid(self.message('notExpected',
                            state, name=repr(name)), value_dict, state)
                    if not self.filter_extra_fields:
                        new[name] = value
                    continue
                validator = self.fields[name]

                # are iterators (list, tuple, set, etc) allowed?
                if self._value_is_iterator(value) and not getattr(
                        validator, 'accept_iterator', False):
                    errors[name] = Invalid(self.message(
                        'singleValueExpected', state), value_dict, state)

                if state is not None:
                    state.key = name
                try:
                    new[name] = validator.to_python(value, state)
                except Invalid as e:
                    errors[name] = e

            for name in unused:
                validator = self.fields[name]
                try:
                    if_missing = validator.if_missing
                except AttributeError:
                    if_missing = NoDefault
                if if_missing is NoDefault:
                    if self.ignore_key_missing:
                        continue
                    if self.if_key_missing is NoDefault:
                        try:
                            message = validator.message('missing', state)
                        except KeyError:
                            message = self.message('missingValue', state)
                        errors[name] = Invalid(message, None, state)
                    else:
                        if state is not None:
                            state.key = name
                        try:
                            new[name] = validator.to_python(
                                self.if_key_missing, state)
                        except Invalid as e:
                            errors[name] = e
                else:
                    new[name] = validator.if_missing

            if state is not None:
                state.key = previous_key
            for validator in self.chained_validators:
                if (not hasattr(validator, 'validate_partial') or not getattr(
                        validator, 'validate_partial_form', False)):
                    continue
                try:
                    validator.validate_partial(value_dict, state)
                except Invalid as e:
                    sub_errors = e.unpack_errors()
                    if not isinstance(sub_errors, dict):
                        # Can't do anything here
                        continue
                    merge_dicts(errors, sub_errors)

            if errors:
                raise Invalid(
                    format_compound_error(errors),
                    value_dict, state, error_dict=errors)

            for validator in self.chained_validators:
                new = validator.to_python(new, state)

            return new

        finally:
            if state is not None:
                state.key = previous_key
                state.full_dict = previous_full_dict

    def _convert_from_python(self, value_dict, state):
        chained = self.chained_validators[:]
        chained.reverse()
        finished = []
        for validator in chained:
            __traceback_info__ = (
                'for_python chained_validator %s (finished %s)') % (
                validator, ', '.join(map(repr, finished)) or 'none')
            finished.append(validator)
            value_dict = validator.from_python(value_dict, state)
        self.assert_dict(value_dict, state)
        new = {}
        errors = {}
        unused = self.fields.keys()
        if state is not None:
            previous_key = getattr(state, 'key', None)
            previous_full_dict = getattr(state, 'full_dict', None)
            state.full_dict = value_dict
        try:
            __traceback_info__ = None
            for name, value in value_dict.iteritems():
                __traceback_info__ = 'for_python in %s' % name
                try:
                    unused.remove(name)
                except ValueError:
                    if not self.allow_extra_fields:
                        raise Invalid(self.message('notExpected',
                            state, name=repr(name)), value_dict, state)
                    if not self.filter_extra_fields:
                        new[name] = value
                else:
                    if state is not None:
                        state.key = name
                    try:
                        new[name] = self.fields[name].from_python(value, state)
                    except Invalid as e:
                        errors[name] = e

            del __traceback_info__

            for name in unused:
                validator = self.fields[name]
                if state is not None:
                    state.key = name
                try:
                    new[name] = validator.from_python(None, state)
                except Invalid as e:
                    errors[name] = e

            if errors:
                raise Invalid(
                    format_compound_error(errors),
                    value_dict, state, error_dict=errors)

            pre = self.pre_validators[:]
            pre.reverse()
            if state is not None:
                state.key = previous_key

            for validator in pre:
                __traceback_info__ = 'for_python pre_validator %s' % validator
                new = validator.from_python(new, state)

            return new

        finally:
            if state is not None:
                state.key = previous_key
                state.full_dict = previous_full_dict

    @declarative.classinstancemethod
    def add_chained_validator(self, cls, validator):
        if self is not None:
            if self.chained_validators is cls.chained_validators:
                self.chained_validators = cls.chained_validators[:]
            self.chained_validators.append(validator)
        else:
            cls.chained_validators.append(validator)

    @declarative.classinstancemethod
    def add_field(self, cls, name, validator):
        if self is not None:
            if self.fields is cls.fields:
                self.fields = cls.fields.copy()
            self.fields[name] = validator
        else:
            cls.fields[name] = validator

    @declarative.classinstancemethod
    def add_pre_validator(self, cls, validator):
        if self is not None:
            if self.pre_validators is cls.pre_validators:
                self.pre_validators = cls.pre_validators[:]
            self.pre_validators.append(validator)
        else:
            cls.pre_validators.append(validator)

    def subvalidators(self):
        result = []
        result.extend(self.pre_validators)
        result.extend(self.chained_validators)
        result.extend(self.fields.itervalues())
        return result

    def is_empty(self, value):
        ## Generally nothing is empty for us
        return False

    def empty_value(self, value):
        return {}

    def _value_is_iterator(self, value):
        if isinstance(value, basestring):
            return False
        elif isinstance(value, (list, tuple)):
            return True

        try:
            for _v in value:
                break
            return True
        ## @@: Should this catch any other errors?:
        except TypeError:
            return False


def format_compound_error(v, indent=0):
    if isinstance(v, Exception):
        try:
            return str(v)
        except (UnicodeDecodeError, UnicodeEncodeError):
            # There doesn't seem to be a better way to get a str()
            # version if possible, and unicode() if necessary, because
            # testing for the presence of a __unicode__ method isn't
            # enough
            return unicode(v)
    elif isinstance(v, dict):
        return ('%s\n' % (' ' * indent)).join(
            '%s: %s' % (k, format_compound_error(value, indent=len(k) + 2))
            for k, value in sorted(v.iteritems()) if value is not None)
    elif isinstance(v, list):
        return ('%s\n' % (' ' * indent)).join(
            '%s' % (format_compound_error(value, indent=indent))
            for value in v if value is not None)
    elif isinstance(v, basestring):
        return v
    else:
        assert False, "I didn't expect something like %s" % repr(v)


def merge_dicts(d1, d2):
    for key in d2:
        d1[key] = merge_values(d1[key], d2[key]) if key in d1 else d2[key]
    return d1


def merge_values(v1, v2):
    if isinstance(v1, basestring) and isinstance(v2, basestring):
        return v1 + '\n' + v2
    elif isinstance(v1, (list, tuple)) and isinstance(v2, (list, tuple)):
        return merge_lists(v1, v2)
    elif isinstance(v1, dict) and isinstance(v2, dict):
        return merge_dicts(v1, v2)
    else:
        # @@: Should we just ignore errors?  Seems we do...
        return v1


def merge_lists(l1, l2):
    if len(l1) < len(l2):
        l1 = l1 + [None] * (len(l2) - len(l1))
    elif len(l2) < len(l1):
        l2 = l2 + [None] * (len(l1) - len(l2))
    result = []
    for l1item, l2item in zip(l1, l2):
        item = None
        if l1item is None:
            item = l2item
        elif l2item is None:
            item = l1item
        else:
            item = merge_values(l1item, l2item)
        result.append(item)
    return result


class SimpleFormValidator(FancyValidator):
    """
    This validator wraps a simple function that validates the form.

    The function looks something like this::

      >>> def validate(form_values, state, validator):
      ...     if form_values.get('country', 'US') == 'US':
      ...         if not form_values.get('state'):
      ...             return dict(state='You must enter a state')
      ...     if not form_values.get('country'):
      ...         form_values['country'] = 'US'

    This tests that the field 'state' must be filled in if the country
    is US, and defaults that country value to 'US'.  The ``validator``
    argument is the SimpleFormValidator instance, which you can use to
    format messages or keep configuration state in if you like (for
    simple ad hoc validation you are unlikely to need it).

    To create a validator from that function, you would do::

      >>> from formencode.schema import SimpleFormValidator
      >>> validator = SimpleFormValidator(validate)
      >>> validator.to_python({'country': 'US', 'state': ''}, None)
      Traceback (most recent call last):
          ...
      Invalid: state: You must enter a state
      >>> sorted(validator.to_python({'state': 'IL'}, None).items())
      [('country', 'US'), ('state', 'IL')]

    The validate function can either return a single error message
    (that applies to the whole form), a dictionary that applies to the
    fields, None which means the form is valid, or it can raise
    Invalid.

    Note that you may update the value_dict *in place*, but you cannot
    return a new value.

    Another way to instantiate a validator is like this::

      >>> @SimpleFormValidator.decorate()
      ... def MyValidator(value_dict, state):
      ...     return None # or some more useful validation

    After this ``MyValidator`` will be a ``SimpleFormValidator``
    instance (it won't be your function).
    """

    __unpackargs__ = ('func',)

    validate_partial_form = False

    def __initargs__(self, new_attrs):
        self.__doc__ = getattr(self.func, '__doc__', None)

    def to_python(self, value_dict, state):
        # Since we aren't really supposed to modify things in-place,
        # we'll give the validation function a copy:
        value_dict = value_dict.copy()
        errors = self.func(value_dict, state, self)
        if not errors:
            return value_dict
        if isinstance(errors, basestring):
            raise Invalid(errors, value_dict, state)
        elif isinstance(errors, dict):
            raise Invalid(
                format_compound_error(errors),
                value_dict, state, error_dict=errors)
        elif isinstance(errors, Invalid):
            raise errors
        else:
            raise TypeError(
                "Invalid error value: %r" % errors)
        return value_dict

    validate_partial = to_python

    @classmethod
    def decorate(cls, **kw):
        def decorator(func):
            return cls(func, **kw)
        return decorator

########NEW FILE########
__FILENAME__ = test_cc
# -*- coding: utf-8 -*-

import unittest

from formencode import Invalid
from formencode.validators import CreditCardValidator, CreditCardExpires


class TestCreditCardValidator(unittest.TestCase):

    def setUp(self):
        self.validator = CreditCardValidator()

    def validate(self, cctype, ccnumber):
        try:
            self.validator.to_python(
                dict(ccNumber=ccnumber, ccType=cctype), None)
        except Invalid as e:
            return e.unpack_errors()['ccNumber']

    def message(self, key):
        return self.validator.message(key, None)

    def test_validate(self):
        validate, message = self.validate, self.message
        self.assertTrue(validate('visa', '4' + '1' * 15) is None)
        self.assertEqual(validate('visa', '5' + '1' * 12),
            message('invalidNumber'))
        self.assertEqual(validate('visa', '4' + '1' * 11 + '2'),
            message('invalidNumber'))
        self.assertEqual(validate('visa', 'test'),
            message('notANumber'))
        self.assertEqual(validate('visa', '4' + '1' * 10),
            message('badLength'))


class TestCreditCardExpires(unittest.TestCase):

    def setUp(self):
        self.validator = CreditCardExpires()

    def validate(self, month, year):
        try:
            self.validator.to_python(
                dict(ccExpiresMonth=month, ccExpiresYear=year), None)
        except Invalid as e:
            return e.unpack_errors()['ccExpiresMonth']

    def message(self, key):
        return self.validator.message(key, None)

    def test_validate(self):
        validate, message = self.validate, self.message
        self.assertTrue(validate('11', '2250') is None)
        self.assertEqual(validate('11', 'test'), message('notANumber'))
        self.assertEqual(validate('test', '2250'), message('notANumber'))
        self.assertEqual(validate('10', '2005'), message('invalidNumber'))
        self.assertEqual(validate('10', '05'), message('invalidNumber'))

########NEW FILE########
__FILENAME__ = test_compound
# -*- coding: utf-8 -*-

import unittest

from formencode import compound, Invalid
from formencode.validators import DictConverter


class TestCompoundValidator(unittest.TestCase):

    def setUp(self):
        self.validator = compound.CompoundValidator()

    def test_repr(self):
        r = repr(self.validator)
        self.assertFalse('validatorArgs' in r)
        self.assertTrue('validators=[]' in r)

    def test_to_python(self):
        self.assertRaises(NotImplementedError,
            self.validator.to_python, 1)

    def test_from_python(self):
        self.assertRaises(NotImplementedError,
            self.validator.from_python, 1)

    def test_clone(self):
        clone = self.validator()
        self.assertEqual(type(clone), type(self.validator))


class TestAllCompoundValidator(unittest.TestCase):

    def setUp(self):
        self.validator = compound.All(
            validators=[DictConverter({2: 1}), DictConverter({3: 2})])

    def test_repr(self):
        r = repr(self.validator)
        self.assertFalse('validatorArgs' in r)
        self.assertEqual(r.count('DictConverter'), 2)

    def test_to_python(self):
        self.assertEqual(self.validator.to_python(3), 1)

    def test_from_python(self):
        self.assertEqual(self.validator.from_python(1), 3)

    def test_clone(self):
        clone = self.validator()
        self.assertEqual(clone.to_python(3), 1)


class TestAnyCompoundValidator(unittest.TestCase):

    def setUp(self):
        self.validator = compound.Any(
            validators=[DictConverter({2: 'c'}), DictConverter({2: 'b'}),
                DictConverter({1: 'b'})])

    def test_repr(self):
        r = repr(self.validator)
        self.assertFalse('validatorArgs' in r)
        self.assertEqual(r.count('DictConverter'), 3)

    def test_to_python(self):
        # Should stop before 'c' coming from the right.
        self.assertEqual(self.validator.to_python(2), 'b')

    def test_from_python(self):
        # Should stop before 1 coming from the left.
        self.assertEqual(self.validator.from_python('b'), 2)

    def test_to_python_error(self):
        try:
            self.validator.to_python(3)
        except Invalid as e:
            self.assertTrue('Enter a value from: 2' in str(e))
        else:
            self.fail('Invalid should be raised when no validator succeeds.')

    def test_clone(self):
        clone = self.validator()
        self.assertEqual(clone.to_python(2), 'b')


class TestPipeCompoundValidator(unittest.TestCase):

    def setUp(self):
        self.validator = compound.Pipe(
            validators=[DictConverter({1: 2}), DictConverter({2: 3})])

    def test_repr(self):
        r = repr(self.validator)
        self.assertFalse('validatorArgs' in r)
        self.assertEqual(r.count('DictConverter'), 2)

    def test_to_python(self):
        self.assertEqual(self.validator.to_python(1), 3)

    def test_from_python(self):
        self.assertEqual(self.validator.from_python(3), 1)

    def test_clone(self):
        clone = self.validator()
        self.assertEqual(clone.to_python(1), 3)

########NEW FILE########
__FILENAME__ = test_context
from nose.tools import assert_raises

from formencode.context import Context, ContextRestoreError

c1 = Context(default=None)
c2 = Context()


def test_one():
    state = c1.set(foo=1)
    assert_is(c1, 'foo', 1)
    state.restore()
    assert_is(c1, 'foo', None)
    state = c1.set(foo=2)
    state2 = c2.set(foo='test')
    assert_is(c1, 'foo', 2)
    assert_is(c2, 'foo', 'test')
    change_state(c1, assert_is, c1, 'foo', 3, foo=3)
    assert_is(c1, 'foo', 2)
    state.restore()
    state2.restore()


def change_state(context, func, *args, **change):
    state = context.set(**change)
    try:
        return func(*args)
    finally:
        state.restore()


def test_fail():
    c3 = Context()
    res1 = c3.set(a=1)
    res2 = c3.set(b=2)
    assert_raises(ContextRestoreError, res1.restore)
    assert c3.b == 2
    assert c3.a == 1
    res2.restore()
    res1.restore()


def assert_is(ob, attr, value):
    assert getattr(ob, attr) == value


def test_default():
    con = Context()
    res = con.set(a=2)
    con.set_default(a=4, b=1)
    assert con.b == 1
    assert con.a == 2
    res.restore()
    assert con.a == 4

########NEW FILE########
__FILENAME__ = test_declarative
# -*- coding: utf-8 -*-

import unittest
import re

from formencode import declarative


class TestDeclarative(unittest.TestCase):

    def test_init(self):
        D = declarative.Declarative
        obj = D()
        self.assertEqual(getattr(obj, 'foo', 'none'), 'none')
        obj = D(foo='bar')
        self.assertEqual(obj.foo, 'bar')
        self.assertEqual(getattr(obj, 'foobar', 'none'), 'none')
        obj = D(foo='bar', woo='par')
        self.assertEqual(obj.foo, 'bar')
        self.assertEqual(obj.woo, 'par')

    def test_call(self):
        D = declarative.Declarative
        obj_bar = D(foo='bar', woo='par')
        obj_baz = obj_bar(foo='baz')
        self.assertTrue(type(obj_bar) is type(obj_baz))
        self.assertTrue(obj_bar is not obj_baz)
        self.assertEqual(obj_baz.foo, 'baz')
        self.assertEqual(obj_baz.woo, 'par')

    def test_repr(self):
        D = declarative.Declarative
        obj_bar = D(foo='bar')
        obj_baz = D(foo='baz')
        obj = D(bar=obj_bar, baz=obj_baz)
        self.assertTrue(re.match("<Declarative object \d+"
            " bar=<Declarative object \d+ foo='bar'>"
            " baz=<Declarative object \d+ foo='baz'>>", repr(obj)))

    def test_repr_recursive(self):
        D = declarative.Declarative
        obj = D(foo='bar')
        obj.bar = obj
        self.assertTrue(re.match("<Declarative object \d+"
            " bar=self foo='bar'>", repr(obj)))

########NEW FILE########
__FILENAME__ = test_doctests
import os
import sys
import doctest

from formencode import compound
from formencode import htmlfill
from formencode import htmlgen
from formencode import national
from formencode import schema
from formencode import validators


"""Modules that will have their doctests tested."""
modules = [compound, htmlfill, htmlgen, national, schema, validators]


"""Text files that will have their doctests tested."""
text_files = [
    'docs/htmlfill.txt',
    'docs/Validator.txt',
    'formencode/tests/non_empty.txt',
    ]


"""Used to resolve text files to absolute paths."""
base = os.path.dirname(os.path.dirname(os.path.dirname(
    os.path.abspath(__file__))))


if unicode is str:  # Python 3

    OutputChecker = doctest.OutputChecker

    class OutputChecker3(OutputChecker):

        def check_output(self, want, got, optionflags):
            if want.startswith("u'"):
                want = want[1:]
            elif want.startswith('set(['):
                want = want[3:].replace(
                    '([', '{').replace('])', '}').replace('{}', 'set()')
            return OutputChecker.check_output(self, want, got, optionflags)

    doctest.OutputChecker = OutputChecker3


def doctest_file(document, verbose, raise_error):
    failure_count, test_count = doctest.testfile(document,
            module_relative=False,
            optionflags=doctest.ELLIPSIS | doctest.IGNORE_EXCEPTION_DETAIL,
            verbose=verbose)
    if raise_error:
        assert test_count > 0
        assert failure_count == 0


def doctest_module(document, verbose, raise_error):
    failure_count, test_count = doctest.testmod(document,
            optionflags=doctest.ELLIPSIS | doctest.IGNORE_EXCEPTION_DETAIL,
            verbose=verbose)
    if raise_error:
        assert test_count > 0
        assert failure_count == 0


def set_func_description(fn, description):
    """Wrap function and set description attr for nosetests to display."""
    def _wrapper(*a_test_args):
        fn(*a_test_args)
    _wrapper.description = description
    return _wrapper


def test_doctests():
    """Generate each doctest."""
    # TODO Can we resolve this from nose?
    verbose = False
    raise_error = True
    for document in text_files + modules:
        if isinstance(document, str):
            name = "Doctests for %s" % (document,)
            if not document.startswith(os.sep):
                document = os.path.join(base, document)
            yield set_func_description(doctest_file, name), document, \
                     verbose, raise_error
        else:
            name = "Doctests for %s" % (document.__name__,)
            yield set_func_description(doctest_module, name), document, \
                    verbose, raise_error


if __name__ == '__main__':
    # Call this file directly if you want to test doctests.
    args = sys.argv[1:]
    verbose = False
    if '-v' in args:
        args.remove('-v')
        verbose = True
    if not args:
        args = text_files + modules
    raise_error = False
    for fn in args:
        if isinstance(fn, str):
            fn = os.path.join(base, fn)
            doctest_file(fn, verbose, raise_error)
        else:
            doctest_module(fn, verbose, raise_error)

########NEW FILE########
__FILENAME__ = test_doctest_xml_compare
import sys

import formencode.doctest_xml_compare as dxml


XML = dxml.ET.XML
tostring = dxml.ET.tostring


def test_xml_compare():
    t1 = XML('<test />')
    t2 = XML('<test/>')
    assert dxml.xml_compare(t1, t2, sys.stdout.write)
    assert dxml.xml_compare(XML('''<hey>
    <you>!!</you>  </hey>'''), XML('<hey><you>!!</you></hey>'),
                            sys.stdout.write)

########NEW FILE########
__FILENAME__ = test_email
# -*- coding: utf-8 -*-

import unittest

from formencode import Invalid
from formencode.validators import Email


class TestEmail(unittest.TestCase):

    def setUp(self):
        self.validator = Email()

    def validate(self, *args):
        try:
            return self.validator.to_python(*args)
        except Invalid as e:
            return unicode(e)

    def message(self, message_name, username, domain):
        email = '@'.join((username, domain))
        return self.validator.message(
            message_name, email, username=username, domain=domain)

    def test_invalid_email_addresses(self):
        invalid_usernames = [
            # (username, domain, message_name),
            ('foo\tbar', 'formencode.org', 'badUsername'),
            ('foo\nbar', 'formencode.org', 'badUsername'),
            ('test', '', 'noAt'),
            ('test', 'foobar', 'badDomain'),
            ('test', 'foobar.5', 'badDomain'),
            ('test', 'foo..bar.com', 'badDomain'),
            ('test', '.foo.bar.com', 'badDomain'),
            ('foo,bar', 'formencode.org', 'badUsername')]

        for username, domain, message_name in invalid_usernames:
            email = '@'.join(el for el in (username, domain) if el)
            error = self.validate(email)
            expected = self.message(message_name, username, domain)
            self.assertEqual(error, expected)

    def test_valid_email_addresses(self):
        valid_email_addresses = [
            # (email address, expected email address),
            (' test@foo.com ', 'test@foo.com'),
            ('Test@foo.com', 'Test@foo.com'),
            ('nobody@xn--m7r7ml7t24h.com', 'nobody@xn--m7r7ml7t24h.com'),
            ('o*reilly@test.com', 'o*reilly@test.com'),
            ('foo+bar@example.com', 'foo+bar@example.com'),
            ('foo.bar@example.com', 'foo.bar@example.com'),
            ('foo!bar@example.com', 'foo!bar@example.com'),
            ('foo{bar}@example.com', 'foo{bar}@example.com'),
            # examples from RFC 3696
            #   punting on the difficult and extremely uncommon ones
            #('"Abc\@def"@example.com', '"Abc\@def"@example.com'),
            #('"Fred Bloggs"@example.com', '"Fred Bloggs"@example.com'),
            #('"Joe\\Blow"@example.com', '"Joe\\Blow"@example.com'),
            #('"Abc@def"@example.com', '"Abc@def"@example.com'),
            ('customer/department=shipping@example.com',
                'customer/department=shipping@example.com'),
            ('$A12345@example.com', '$A12345@example.com'),
            ('!def!xyz%abc@example.com', '!def!xyz%abc@example.com'),
            ('_somename@example.com', '_somename@example.com')]

        for email, expected in valid_email_addresses:
            self.assertEqual(self.validate(email), expected)


class TestUnicodeEmailWithResolveDomain(unittest.TestCase):

    def setUp(self):
        self.validator = Email(resolve_domain=True)

    def test_unicode_ascii_subgroup(self):
        self.assertEqual(self.validator.to_python(
            u'foo@yandex.com'), 'foo@yandex.com')

    def test_cyrillic_email(self):
        self.assertEqual(self.validator.to_python(
            u'me@письмо.рф'), u'me@письмо.рф')

########NEW FILE########
__FILENAME__ = test_htmlfill
# -*- coding: utf-8 -*-

import os
import re
import sys

import xml.etree.ElementTree as ET
try:
    XMLParseError = ET.ParseError
except AttributeError:  # Python < 2.7
    from xml.parsers.expat import ExpatError as XMLParseError

from htmlentitydefs import name2codepoint

base_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(
    os.path.abspath(__file__)))))
if base_dir not in sys.path:
    sys.path.insert(0, base_dir)

from formencode import htmlfill, htmlfill_schemabuilder
from formencode.doctest_xml_compare import xml_compare


def test_inputoutput():
    data_dir = os.path.join(os.path.dirname(__file__), 'htmlfill_data')
    for fn in os.listdir(data_dir):
        if fn.startswith('data-'):
            fn = os.path.join(data_dir, fn)
            yield run_filename, fn


def run_filename(filename):
    f = open(filename)
    content = f.read()
    f.close()
    parts = re.split(r'---*', content)
    template = parts[0]
    expected = parts[1]
    if len(parts) == 3:
        data_content = parts[2].strip()
    elif len(parts) > 3:
        assert False, "Too many sections: %s" % parts[3:]
    else:
        data_content = ''
    namespace = {}
    if data_content:
        exec data_content in namespace
    data = namespace.copy()
    data['defaults'] = data.get('defaults', {})
    if 'check' in data:
        checker = data.pop('check')
    else:
        def checker(p, s):
            pass
    for name in data.keys():
        if name.startswith('_') or hasattr('__builtin__', name):
            del data[name]
    listener = htmlfill_schemabuilder.SchemaBuilder()
    p = htmlfill.FillingParser(listener=listener, **data)
    p.feed(template)
    p.close()
    output = p.text()

    def reporter(v):
        print v

    try:
        output_xml = ET.XML(output)
        expected_xml = ET.XML(expected)
    except XMLParseError:
        comp = output.strip() == expected.strip()
    else:
        comp = xml_compare(output_xml, expected_xml, reporter)
    if not comp:
        print '---- Output:   ----'
        print output
        print '---- Expected: ----'
        print expected
        assert False
    checker(p, listener.schema())
    checker(p, htmlfill_schemabuilder.parse_schema(template))


def test_no_trailing_newline():
    assert (htmlfill.render('<html><body></body></html>', {}, {})
            == '<html><body></body></html>')


def test_escape_defaults():
    rarr = unichr(name2codepoint['rarr'])
    assert (htmlfill.render('<input type="submit" value="next&gt;&rarr;">', {}, {})
            == '<input type="submit" value="next&gt;%s">' % rarr)
    assert (htmlfill.render('<input type="submit" value="1&amp;2">', {}, {})
            == '<input type="submit" value="1&amp;2">')
    assert (htmlfill.render('<input type="submit" value="Japan - &#x65E5;&#x672C; Nihon" />',
                            {}, {}) ==
            u'<input type="submit" value="Japan - 日本 Nihon" />')


def test_xhtml():
    result = htmlfill.render('<form:error name="code"/>', errors={'code': 'an error'})
    assert 'an error' in result


def test_html5():
    result = htmlfill.render('<input type="number" name="quantity">', {'quantity': '10'})
    assert result == '<input type="number" name="quantity" value="10">'
    try:
        result = htmlfill.render('<input type="unknown" name="quantity">', {'quantity': '10'})
    except AssertionError as e:
        assert "I don't know about this kind of <input>: unknown at 1:0" in str(e)
    result = htmlfill.render('<input type="unknown" name="quantity">', {'quantity': '10'}, text_as_default=True)
    assert result == '<input type="unknown" name="quantity" value="10">'


def test_trailing_error():
    assert (htmlfill.render('<input type="text" name="email">', errors={'email': 'error'},
                            prefix_error=False)
            == '<input type="text" name="email" class="error" value=""><!-- for: email -->\n<span class="error-message">error</span><br />\n')
    assert (htmlfill.render('<textarea name="content"></textarea>', errors={'content': 'error'},
                            prefix_error=False)
            == '<textarea name="content" class="error"></textarea><!-- for: content -->\n<span class="error-message">error</span><br />\n')
    assert (htmlfill.render('<select name="type"><option value="foo">foo</option></select>', errors={'type': 'error'},
                            prefix_error=False)
            == '<select name="type" class="error"><option value="foo">foo</option></select><!-- for: type -->\n<span class="error-message">error</span><br />\n')


def test_iferror():
    assert (htmlfill.render('<form:iferror name="field1">an error</form:iferror>', errors={}, auto_insert_errors=False)
            == '')
    assert (htmlfill.render('<form:iferror name="field1">an error</form:iferror>', errors={'field1': 'foo'}, auto_insert_errors=False)
            == 'an error')
    assert (htmlfill.render('<form:iferror name="not field1">no errors</form:iferror>', errors={}, auto_insert_errors=False)
            == 'no errors')
    assert (htmlfill.render('<form:iferror name="not field1">no errors</form:iferror>', errors={'field1': 'foo'}, auto_insert_errors=False)
            == '')
    assert (htmlfill.render('<form:iferror name="field1">errors</form:iferror><form:iferror name="not field1">no errors</form:iferror>',
                            errors={}, auto_insert_errors=False)
            == 'no errors')
    assert (htmlfill.render('<form:iferror name="field1">errors</form:iferror><form:iferror name="not field1">no errors</form:iferror>',
                            errors={'field1': 'foo'}, auto_insert_errors=False)
            == 'errors')
    try:
        htmlfill.render('<form:iferror noname="nothing">errors</form:iferror>')
    except AssertionError as e:
        assert str(e) == "Name attribute in <iferror> required at 1:0"


def test_literal():
    assert (htmlfill.render('<form:error name="foo" />',
                            errors={'foo': htmlfill.htmlliteral('<test>')})
            == '<span class="error-message"><test></span><br />\n')


def test_image_submit():
    assert (htmlfill.render('<input name="image-submit" type="image" src="foo.jpg" value="bar">',
                            defaults={'image-submit': 'blahblah'})
            == '<input name="image-submit" type="image" src="foo.jpg" value="bar">')


def test_checkbox():
    assert (htmlfill.render('<input name="checkbox" type="checkbox" value="bar">',
                            defaults={'checkbox': 'bar'})
            == '<input name="checkbox" type="checkbox" value="bar" checked="checked">')
    assert (htmlfill.render('<input name="checkbox" type="checkbox">',
                            defaults={'checkbox': ''})
            == '<input name="checkbox" type="checkbox">')
    assert (htmlfill.render('<input name="checkbox" type="checkbox">',
                            defaults={'checkbox': ''}, checkbox_checked_if_present=True)
            == '<input name="checkbox" type="checkbox" checked="checked">')
    assert (htmlfill.render('<input name="checkbox" type="checkbox" value="bar">',
                            defaults={'checkbox': ''}, checkbox_checked_if_present=True)
            == '<input name="checkbox" type="checkbox" value="bar">')
    assert (htmlfill.render('<input name="checkbox" type="checkbox" value="">',
                            defaults={'checkbox': ''}, checkbox_checked_if_present=True)
            == '<input name="checkbox" type="checkbox" value="" checked="checked">')
    assert (htmlfill.render('<input name="checkbox" type="checkbox" value="">',
                            defaults={'checkbox': ''})
            == '<input name="checkbox" type="checkbox" value="">')


def test_unicode():
    assert (htmlfill.render(u'<input type="checkbox" name="tags" value="2" />',
                           dict(tags=[])) ==
            '<input type="checkbox" name="tags" value="2" />')


def test_password():
    assert (htmlfill.render('<input name="password" type="password" value="">',
                            defaults={'password': 'secure passwd'})
            == '<input name="password" type="password" value="secure passwd">')
    assert (htmlfill.render('<input name="password" type="password" value="">',
                            defaults={'password': 'secure passwd'},
                            skip_passwords=True)
            == '<input name="password" type="password" value="">')
    assert (htmlfill.render('<input name="password" type="password">',
                            defaults={'password': 'secure passwd'})
            == '<input name="password" type="password" value="secure passwd">')
    assert (htmlfill.render('<input name="password" type="password">',
                            defaults={'password': 'secure passwd'},
                            skip_passwords=True)
            == '<input name="password" type="password">')


def test_not_force_defaults_text():
    html = """<input type="text" name="text-1" class="my_text" value="i like this text" />"""
    rendered_html = htmlfill.render(html, defaults=dict(),
                                    force_defaults=False)
    assert html == rendered_html, rendered_html


def test_not_force_defaults_text_value():
    html = """<input type="text" name="text-1" class="my_text" value="i like this text" />"""
    expected_html = """<input type="text" name="text-1" class="my_text" value="this text is better" />"""
    rendered_html = htmlfill.render(html, defaults={"text-1": "this text is better"},
                                    force_defaults=False)
    assert expected_html == rendered_html, rendered_html


def test_not_force_defaults_text_explicit_empty_value():
    html = """<input type="text" name="text-1" class="my_text" value="i like this text" />"""
    expected_html = """<input type="text" name="text-1" class="my_text" value="" />"""
    rendered_html = htmlfill.render(html, defaults={"text-1": ""},
                                    force_defaults=False)
    assert expected_html == rendered_html, rendered_html


def test_force_defaults_text():
    html = """<input type="text" name="text-1" class="my_text" value="i like this text" />"""
    expected_html = """<input type="text" name="text-1" class="my_text" value="" />"""
    rendered_html = htmlfill.render(html, defaults=dict())
    assert expected_html == rendered_html, rendered_html


def test_not_force_defaults_textarea():
    html = """<textarea name="textarea-1" class="my_textarea">i like this text</textarea>"""
    rendered_html = htmlfill.render(html, defaults=dict(),
                                    force_defaults=False)
    assert html == rendered_html, rendered_html


def test_not_force_defaults_textarea_value():
    html = """<textarea name="textarea-1" class="my_textarea">i like this text</textarea>"""
    expected_html = """<textarea name="textarea-1" class="my_textarea">this text is better</textarea>"""
    rendered_html = htmlfill.render(html, defaults={"textarea-1": "this text is better"},
                                    force_defaults=False)
    assert expected_html == rendered_html, rendered_html


def test_force_defaults_textarea():
    html = """<textarea name="textarea-1" class="my_textarea">i like this text</textarea>"""
    expected_html = \
        """<textarea name="textarea-1" class="my_textarea"></textarea>"""
    rendered_html = htmlfill.render(html, defaults=dict())
    assert expected_html == rendered_html, rendered_html


def test_not_force_defaults_password():
    html = """<input type="password" name="password-1" class="my_password" value="i like this password" />"""
    rendered_html = htmlfill.render(html, defaults=dict(),
                                    force_defaults=False)
    assert html == rendered_html, rendered_html


def test_not_force_defaults_password_value():
    html = """<input type="password" name="password-1" class="my_password" value="i like this password" />"""
    expected_html = """<input type="password" name="password-1" class="my_password" value="this password is better" />"""
    rendered_html = htmlfill.render(html, defaults={"password-1": "this password is better"},
                                    force_defaults=False)
    assert expected_html == rendered_html, rendered_html


def test_not_force_defaults_password_explicit_empty_value():
    html = """<input type="password" name="password-1" class="my_password" value="i like this password" />"""
    expected_html = """<input type="password" name="password-1" class="my_password" value="" />"""
    rendered_html = htmlfill.render(html, defaults={"password-1": ""},
                                    force_defaults=False)
    assert expected_html == rendered_html, rendered_html


def test_force_defaults_password():
    html = """<input type="password" name="password-1" class="my_password" value="i like this password" />"""
    expected_html = """<input type="password" name="password-1" class="my_password" value="" />"""
    rendered_html = htmlfill.render(html, defaults=dict())
    assert expected_html == rendered_html, rendered_html


def test_not_force_defaults_checkbox():
    html = """<input type="checkbox" name="checkbox-1" class="my_checkbox" checked="checked" value="cb">"""
    rendered_html = htmlfill.render(html, defaults=dict(),
                                    force_defaults=False)
    assert html == rendered_html, rendered_html


def test_force_defaults_checkbox():
    html = """<input type="checkbox" name="checkbox-1" class="my_checkbox" checked="checked" value="cb">"""
    expected_html = \
        """<input type="checkbox" name="checkbox-1" class="my_checkbox" value="cb">"""
    rendered_html = htmlfill.render(html, defaults=dict())
    assert expected_html == rendered_html, rendered_html


def test_not_force_defaults_checkbox_default_unchecked():
    html = """<input type="checkbox" name="checkbox-1" class="my_checkbox" checked="checked" value="cb">"""
    expected_html = \
        """<input type="checkbox" name="checkbox-1" class="my_checkbox" value="cb">"""
    rendered_html = htmlfill.render(html, defaults={"checkbox-1": False})
    assert expected_html == rendered_html, rendered_html


def test_not_force_defaults_checkbox_default_checked():
    html = """<input type="checkbox" name="checkbox-1" class="my_checkbox" value="cb">"""
    expected_html = \
        """<input type="checkbox" name="checkbox-1" class="my_checkbox" value="cb" checked="checked">"""
    rendered_html = htmlfill.render(html, defaults={"checkbox-1": "cb"},
                                    force_defaults=False)
    assert expected_html == rendered_html, rendered_html


def test_not_force_defaults_radio():
    html = """<input type="radio" name="radio-1" class="my_radio" checked="checked" value="cb">"""
    rendered_html = htmlfill.render(html, defaults=dict(),
                                    force_defaults=False)
    assert html == rendered_html, rendered_html


def test_not_force_defaults_radio_unchecked():
    html = """<input type="radio" name="radio-1" class="my_radio" checked="checked" value="cb">"""
    expected_html = """<input type="radio" name="radio-1" class="my_radio" value="cb">"""
    rendered_html = htmlfill.render(html, defaults={"radio-1": "ba"},
                                    force_defaults=False)
    assert expected_html == rendered_html, rendered_html


def test_not_force_defaults_radio_checked():
    html = """<input type="radio" name="radio-1" class="my_radio" value="cb">"""
    expected_html = """<input type="radio" name="radio-1" class="my_radio" value="cb" checked="checked">"""
    rendered_html = htmlfill.render(html, defaults={"radio-1": "cb"},
                                    force_defaults=False)
    assert expected_html == rendered_html, rendered_html


def test_force_defaults_radio():
    html = """<input type="radio" name="radio-1" class="my_radio" checked="checked" value="cb">"""
    expected_html = """<input type="radio" name="radio-1" class="my_radio" value="cb">"""
    rendered_html = htmlfill.render(html, defaults=dict())
    assert expected_html == rendered_html, rendered_html


def test_not_force_defaults_select():
    html = """
<select name="select-1" class="my_select">
  <option value="option-1" selected="selected">this is option-1</option>
</select>
"""
    rendered_html = htmlfill.render(html, defaults=dict(),
                                    force_defaults=False)
    assert html == rendered_html, rendered_html


def test_not_force_defaults_select_selected():
    html = """
<select name="select-1" class="my_select">
  <option value="option-1">this is option-1</option>
</select>
"""
    expected_html = """
<select name="select-1" class="my_select">
  <option value="option-1" selected="selected">this is option-1</option>
</select>
"""
    rendered_html = htmlfill.render(html, defaults={"select-1": "option-1"},
                                    force_defaults=False)
    assert expected_html == rendered_html, rendered_html


def test_not_force_defaults_select_not_selected():
    html = """
<select name="select-1" class="my_select">
  <option value="option-1" selected="selected">this is option-1</option>
</select>
"""
    expected_html = """
<select name="select-1" class="my_select">
  <option value="option-1">this is option-1</option>
</select>
"""
    rendered_html = htmlfill.render(html, defaults={"select-1": "option-2"},
                                    force_defaults=False)
    assert expected_html == rendered_html, rendered_html


def test_force_defaults_select():
    html = """
<select name="select-1" class="my_select">
  <option value="option-1" selected="selected">this is option-1</option>
</select>
"""
    expected_html = """
<select name="select-1" class="my_select">
  <option value="option-1">this is option-1</option>
</select>
"""
    rendered_html = htmlfill.render(html, defaults=dict())
    assert expected_html == rendered_html, rendered_html


def test_select_empty_option_value_selected():
    html = """
<select name="select-1" class="my_select">
  <option value="">this is option-1</option>
</select>
"""
    expected_html = """
<select name="select-1" class="my_select">
  <option value="" selected="selected">this is option-1</option>
</select>
"""
    rendered_html = htmlfill.render(html, defaults={"select-1": ""})
    assert expected_html == rendered_html, rendered_html


def test_select_empty_option_value_not_selected():
    html = """
<select name="select-1" class="my_select">
  <option value="">this is option-1</option>
</select>
"""
    expected_html = """
<select name="select-1" class="my_select">
  <option value="">this is option-1</option>
</select>
"""
    rendered_html = htmlfill.render(html, defaults={})
    assert expected_html == rendered_html, rendered_html


def test_script_quoting():
    html = """
<script>Some <weird JS</script>
Then a form <input type="text" name="name">
"""
    expected_html = """
<script>Some <weird JS</script>
Then a form <input type="text" name="name" value="foo">
"""
    rendered_html = htmlfill.render(html, defaults=dict(name="foo"))
    assert expected_html == rendered_html, rendered_html


def test_error_class_textarea():
    assert (htmlfill.render('<textarea name="content"></textarea>', errors={'content': 'error'})
            == '<!-- for: content -->\n<span class="error-message">error</span><br />\n<textarea name="content" class="error"></textarea>')


def test_mix_str_and_unicode():
    html = '<input type="text" name="cheese">'
    uhtml = unicode(html)
    cheese = dict(cheese='Käse')
    ucheese = dict(cheese=u'Käse')
    expected = u'<input type="text" name="cheese" value="Käse">'
    rendered = htmlfill.render(html, defaults=cheese, encoding='utf-8')
    assert expected == rendered
    rendered = htmlfill.render(html, defaults=ucheese, encoding='utf-8')
    assert expected == rendered
    rendered = htmlfill.render(uhtml, defaults=cheese, encoding='utf-8')
    assert expected == rendered
    rendered = htmlfill.render(uhtml, defaults=ucheese, encoding='utf-8')
    assert expected == rendered

########NEW FILE########
__FILENAME__ = test_htmlgen

import doctest

from formencode.htmlgen import html

# A test value that can't be encoded as ascii:
uni_value = u'\xff'
str_value = uni_value if str is unicode else uni_value.encode('utf-8')


def test_basic():
    output = '<a href="test">hey there</a>'
    assert str(html.a(href='test')('hey there')) == output
    assert str(html.a('hey there')(href='test')) == output
    assert str(html.a(href='test', c='hey there')) == output
    assert str(html.a('hey there', href='test')) == output
    assert str(html.a(href='test')('hey ', 'there')) == output
    assert str(html.a(href='test')(['hey ', 'there'])) == output


def test_compound():
    output = '<b>Hey <i>you</i>!</b>'
    assert str(html.b('Hey ', html.i('you'), '!')) == output
    assert str(html.b()('Hey ')(html.i()('you'))('!')) == output
    inner = html('Hey ', html.i('you'), '!')
    assert html.str(inner) == 'Hey <i>you</i>!'
    assert str(inner) == 'Hey <i>you</i>!'
    assert str(html.b(inner)) == output


def test_unicode():
    try:
        uni_value.encode('ascii')
    except ValueError:
        pass
    else:
        assert False, (
            "We need something that can't be ASCII-encoded: %r (%r)"
            % (uni_value, uni_value.encode('ascii')))
    assert unicode(html.b(uni_value)) == u'<b>%s</b>' % uni_value


def test_quote():
    assert html.quote('<hey>!') == '&lt;hey&gt;!'
    assert html.quote(uni_value) == str_value
    assert html.quote(None) == ''
    assert html.str(None) == ''
    assert str(html.b('<hey>')) == '<b>&lt;hey&gt;</b>'


def test_comment():

    def strip(s):
        """ElementTree in Py < 2.7 adds whitespace, strip this."""
        s = str(s).strip()
        if s.startswith('<!--') and s.endswith('-->'):
            s = '<!--%s-->' % s[4:-3].strip()
        return s

    assert strip(html.comment('test')) == '<!--test-->'
    assert strip(html.comment(uni_value)) == '<!--%s-->' % str_value
    assert strip(html.comment('test')('this')) == '<!--testthis-->'


def test_none():
    assert html.str(None) == ''
    assert str(html.b(class_=None)('hey')) == '<b>hey</b>'
    assert str(html.b(class_=' ')(None)) == '<b class=" " />'


def test_namespace():
    output = '<b tal:content="options/whatever" />'
    assert str(html.b(**{'tal:content': 'options/whatever'})) == output
    assert str(html.b(tal__content='options/whatever')) == output


if __name__ == '__main__':
    # It's like a super-mini py.test...
    for name, value in globals().iteritems():
        if name.startswith('test'):
            print name
            value()
    from formencode import htmlgen
    doctest.testmod(htmlgen)
    print 'doctest'

########NEW FILE########
__FILENAME__ = test_htmlrename
from formencode.htmlrename import rename, add_prefix


def test_rename():
    assert (rename('<input type="text" name="a_name">', lambda name: name.upper())
            == '<input type="text" name="A_NAME">')
    assert (add_prefix('<input type="text" name="a_name"><input type="text" name="">', 'test', dotted=True)
            == '<input type="text" name="test.a_name"><input type="text" name="test">')
    assert (add_prefix('text<textarea name="a_name">value</textarea>text2', 'prefix.')
            == 'text<textarea name="prefix.a_name">value</textarea>text2')
    assert (add_prefix('<textarea name="" rows=2 style="width: 100%" id="field-0"></textarea>',
                       'street', dotted=True)
            == '<textarea name="street" rows="2" style="width: 100%" id="field-0"></textarea>')

########NEW FILE########
__FILENAME__ = test_i18n
# -*- coding: utf-8 -*-

import formencode

ne = formencode.validators.NotEmpty()


def _test_builtins(func):
    def dummy(s):
        return "builtins dummy"
    import __builtin__
    __builtin__._ = dummy

    try:
        ne.to_python("")
    except formencode.api.Invalid as e:
        func(e)

    del __builtin__._


def test_builtins():
    def withbuiltins(e):
        assert str(e) == "builtins dummy"

    _test_builtins(withbuiltins)


def test_bultins_disabled():
    def withoutbuiltins(e):
        assert str(e) != "builtins dummy"

    ne.use_builtins_gettext = False
    _test_builtins(withoutbuiltins)


def test_state():
    class st(object):
        def _(self, s):
            return "state dummy"

    try:
        ne.to_python("", state=st())
    except formencode.api.Invalid as e:
        assert str(e) == "state dummy"


def _test_lang(language, notemptytext):

    formencode.api.set_stdtranslation(languages=[language])

    try:
        ne.to_python("")
    except formencode.api.Invalid as e:
        assert unicode(e) == notemptytext

    formencode.api.set_stdtranslation()  # set back to defaults


def test_de():
    _test_lang("de", u"Bitte einen Wert eingeben")


def test_es():
    _test_lang("es", u"Por favor introduzca un valor")


def test_pt_BR():
    _test_lang("pt_BR", u"Por favor digite um valor")


def test_zh_TW():
    _test_lang("zh_TW", u"請輸入一個值")


def test_sk():
    _test_lang("sk", u"Zadajte hodnotu, prosím")


def test_ru():
    _test_lang("ru", u"Необходимо ввести значение")


def test_sl():
    _test_lang("sl", u"Prosim, izpolnite polje")


def test_pt_PT():
    _test_lang("pt_PT", u"Por favor insira um valor")


def test_fr():
    _test_lang("fr", u"Saisissez une valeur")


def test_nl():
    _test_lang("nl", u"Voer een waarde in")


def test_pl():
    _test_lang("pl", u"Proszę podać wartość")


def test_el():
    _test_lang("el", u"Παρακαλούμε εισάγετε μια τιμή")


def test_zh_CN():
    _test_lang("zh_CN", u"请输入一个值")


def test_cs():
    _test_lang("cs", u"Prosím zadejte hodnotu")


def test_fi():
    _test_lang("fi", u"Anna arvo")


def test_nb_NO():
    _test_lang("nb_NO", u"Venligst fyll inn en verdi")


def test_it():
    _test_lang("it", u"Inserire un dato")


def test_et():
    _test_lang("et", u"Palun sisestada väärtus")


def test_lt():
    _test_lang("lt", u"Prašome įvesti reikšmę")


def test_ja():
    _test_lang("ja", u"入力してください")


def test_tr():
    _test_lang("tr", u"Lütfen bir değer giriniz")

########NEW FILE########
__FILENAME__ = test_schema
import unittest

from urlparse import parse_qsl

from formencode import Invalid, Validator, compound, foreach, validators
from formencode.schema import Schema, merge_dicts, SimpleFormValidator
from formencode.variabledecode import NestedVariables


def _notranslation(s):
    return s


def setup_module(module):
    """Disable i18n translation"""

    import __builtin__
    __builtin__._ = _notranslation


def teardown_module(module):
    """Remove translation function"""
    import __builtin__
    del __builtin__._


def d(**kw):
    return kw


def cgi_parse(qs):
    """Parse a query string and returns the usually dictionary."""
    d = {}
    for key, value in parse_qsl(qs, True):
        if key in d:
            if isinstance(d[key], list):
                d[key].append(value)
            else:
                d[key] = [d[key], value]
        else:
            d[key] = value
    return d


class DecodeCase(object):

    error_expected = False

    def __init__(self, schema, input, **output):
        self.raw_input = input
        self.schema = schema
        if isinstance(input, str):
            input = cgi_parse(input)
        self.input = input
        self.output = output
        all_cases.append(self)

    def test(self):
        print 'input', repr(self.input)
        actual = self.schema.to_python(self.input)
        print 'output', repr(actual)
        assert actual == self.output


class BadCase(DecodeCase):

    error_expected = True

    def __init__(self, *args, **kw):
        DecodeCase.__init__(self, *args, **kw)
        if len(self.output) == 1 and 'text' in self.output:
            self.output = self.output['text']

    def test(self):
        print repr(self.raw_input)
        try:
            print repr(self.schema.to_python(self.input))
        except Invalid as e:
            actual = e.unpack_errors()
            assert actual == self.output
        else:
            assert False, "Exception expected"


class Name(Schema):
    fname = validators.String(not_empty=True)
    mi = validators.String(max=1, if_missing=None, if_empty=None)
    lname = validators.String(not_empty=True)


all_cases = []

DecodeCase(Name, 'fname=Ian&mi=S&lname=Bicking',
           fname='Ian', mi='S', lname='Bicking')

DecodeCase(Name, 'fname=Ian&lname=Bicking',
           fname='Ian', mi=None, lname='Bicking')

BadCase(Name, 'fname=&lname=',
        fname='Please enter a value',
        lname='Please enter a value')

BadCase(Name, 'fname=Franklin&mi=Delano&lname=Roosevelt',
        mi="Enter a value not more than 1 characters long")

BadCase(Name, '',
        fname='Missing value',
        lname='Missing value')


class AddressesForm(Schema):

    pre_validators = [NestedVariables()]

    class addresses(foreach.ForEach):

        class schema(Schema):
            name = Name()
            email = validators.Email()


DecodeCase(AddressesForm,
           'addresses-2.name.fname=Jill&addresses-1.name.fname=Bob&'
           'addresses-1.name.lname=Briscoe&'
           'addresses-1.email=bob@bobcom.com&'
           'addresses-2.name.lname=Hill&addresses-2.email=jill@hill.com&'
           'addresses-2.name.mi=J',
           addresses=[d(name=d(fname='Bob', mi=None, lname='Briscoe'),
                        email='bob@bobcom.com'),
                      d(name=d(fname='Jill', mi='J', lname='Hill'),
                        email='jill@hill.com')])

DecodeCase(AddressesForm,
           '',
           addresses=[])

BadCase(AddressesForm,
        'addresses-1.name.fname=&addresses-1.name.lname=x&'
        'addresses-1.email=x@domain.com',
        addresses=[d(name=d(fname="Please enter a value"))])

BadCase(AddressesForm,
        'whatever=nothing',
        text="The input field 'whatever' was not expected.")


def test_this():

    for case in all_cases:
        yield (case.test,)


def test_merge():
    assert (merge_dicts(dict(a='a'), dict(b='b'))
            == dict(a='a', b='b'))
    assert (merge_dicts(dict(a='a', c='c'), dict(a='a', b='b'))
            == dict(a='a\na', b='b', c='c'))
    assert (merge_dicts(dict(a=['a1', 'a2'], b=['b'], c=['c']),
                        dict(a=['aa1'],
                             b=['bb', 'bbb'],
                             c='foo'))
            == dict(a=['a1\naa1', 'a2'], b=['b\nbb', 'bbb'],
                    c=['c']))


class ChainedTest(Schema):
    a = validators.String()
    a_confirm = validators.String()

    b = validators.String()
    b_confirm = validators.String()

    chained_validators = [validators.FieldsMatch('a', 'a_confirm'),
                            validators.FieldsMatch('b', 'b_confirm')]


def test_multiple_chained_validators_errors():
    s = ChainedTest()
    try:
        s.to_python({'a': '1', 'a_confirm': '2', 'b': '3', 'b_confirm': '4'})
    except Invalid as e:
        assert 'a_confirm' in e.error_dict and 'b_confirm' in e.error_dict
    try:
        s.to_python({})
    except Invalid:
        pass
    else:
        assert False


def test_SimpleFormValidator_doc():
    """
    Verify SimpleFormValidator preserves the decorated function's docstring.
    """

    BOGUS_DOCSTRING = "blah blah blah"

    def f(value_dict, state, validator):
        value_dict['f'] = 99

    f.__doc__ = BOGUS_DOCSTRING
    g = SimpleFormValidator(f)

    assert f.__doc__ == g.__doc__, "Docstrings don't match!"


class State(object):
    pass


def test_state_manipulation():
    """
    Verify that full_dict push and pop works
    """
    state = State()
    old_dict = state.full_dict = {'a': 1}
    old_key = state.key = 'a'
    new_dict = {'b': 2}

    class MyValidator(Validator):
        check_key = None
        pre_validator = False
        post_validator = False
        __unpackargs__ = ('check_key',)

        def to_python(self, value, state):
            if not self.pre_validator:
                assert getattr(
                    state, 'full_dict', {}) == new_dict, "full_dict not added"
            assert state.key == self.check_key, "key not updated"

            return value

        def from_python(self, value, state):
            if not self.post_validator:
                assert getattr(
                    state, 'full_dict', {}) == new_dict, "full_dict not added"
            assert state.key == self.check_key, "key not updated"

            return value

    s = Schema(if_key_missing=None, b=MyValidator('b'), c=MyValidator('c'),
               pre_validators=[MyValidator('a', pre_validator=True)],
               chained_validators=[MyValidator('a', post_validator=True)])

    s.to_python(new_dict, state)

    assert state.full_dict == old_dict, "full_dict not restored"
    assert state.key == old_key, "key not restored"

    s.from_python(new_dict, state)

    assert state.full_dict == old_dict, "full_dict not restored"
    assert state.key == old_key, "key not restored"


class TestAtLeastOneCheckboxIsChecked(object):
    """Tests to address SourceForge bug #1777245

    The reporter is trying to enforce agreement to a Terms of Service
    agreement, with failure to check the 'I agree' checkbox handled as
    a validation failure. The tests below illustrate a working approach.

    """

    def setup(self):
        self.not_empty_messages = {'missing': 'a missing value message'}

        class CheckForCheckboxSchema(Schema):
            agree = validators.StringBool(messages=self.not_empty_messages)

        self.schema = CheckForCheckboxSchema()

    def test_Schema_with_input_present(self):
        # <input type="checkbox" name="agree" value="yes" checked="checked">
        result = self.schema.to_python({'agree': 'yes'})
        assert result['agree'] is True

    def test_Schema_with_input_missing(self):
        # <input type="checkbox" name="agree" value="yes">
        try:
            self.schema.to_python({})
        except Invalid as exc:
            error_message = exc.error_dict['agree'].msg
            assert self.not_empty_messages['missing'] == error_message, \
                error_message
        else:
            assert False, 'missing input not detected'


class TestStrictSchemaWithMultipleEqualInputFields(unittest.TestCase):
    """Tests to address github bug #13"""

    def setUp(self):

        class StrictSchema(Schema):
            allow_extra_fields = False

        class IntegerTestSchema(StrictSchema):
            field = validators.Int(not_empty=True)

        class StringTestSchema(StrictSchema):
            field = validators.UnicodeString(not_empty=True)

        class CorrectForEachStringTestSchema(StrictSchema):
            field = foreach.ForEach(validators.UnicodeString(not_empty=True))

        class CorrectSetTestSchema(StrictSchema):
            field = validators.Set(not_empty=True)

        class CorrectSetTestPipeSchema(StrictSchema):
            field = compound.Pipe(validators.Set(not_empty=True),
                foreach.ForEach(validators.UnicodeString(not_empty=True)))

        self.int_schema = IntegerTestSchema()
        self.string_schema = StringTestSchema()
        self.foreach_schema = CorrectForEachStringTestSchema()
        self.set_schema = CorrectSetTestSchema()
        self.pipe_schema = CorrectSetTestPipeSchema()

    def test_single_integer_value(self):
        params = cgi_parse('field=111')
        data = self.int_schema.to_python(params)
        self.assertEqual(data, dict(field=111))

    def test_multiple_integer_value(self):
        params = cgi_parse('field=111&field=222')
        self.assertRaises(Invalid, self.int_schema.to_python, params)

    def test_single_string_value(self):
        params = cgi_parse('field=string')
        data = self.string_schema.to_python(params)
        self.assertEqual(data, dict(field='string'))

    def test_multiple_string_value(self):
        params = cgi_parse('field=string1&field=string2')
        self.assertRaises(Invalid, self.string_schema.to_python, params)

    def test_correct_multiple_string_value_foreach(self):
        params = cgi_parse('field=string1&field=string2')
        data = self.foreach_schema.to_python(params)
        self.assertEqual(data, dict(field=['string1', 'string2']))

    def test_correct_multiple_string_value_set(self):
        params = cgi_parse('field=string1&field=string2')
        data = self.set_schema.to_python(params)
        self.assertEqual(data, dict(field=['string1', 'string2']))

    def test_correct_multiple_string_value_pipe(self):
        params = cgi_parse('field=string1&field=string2')
        data = self.pipe_schema.to_python(params)
        self.assertEqual(data, dict(field=['string1', 'string2']))


def test_copy():
    assert 'mi' in Name.fields
    NoTitleName = Name()
    assert 'mi' in NoTitleName.fields
    TitleName = NoTitleName(title=validators.String())
    assert 'mi' in TitleName.fields
    assert 'title' in TitleName.fields
    assert 'title' not in NoTitleName.fields

########NEW FILE########
__FILENAME__ = test_subclassing
# -*- coding: utf-8 -*-

import unittest

from formencode.api import is_validator, FancyValidator, Invalid
from formencode.compound import CompoundValidator, All
from formencode.validators import Int


class CustomValidator(FancyValidator):
    """A custom validator based directly on FancyValidator."""

    messages = {
        'custom': "%(number)s is invalid",
    }

    def _convert_to_python(self, value, state):
        if value == '1':
            raise Invalid(self.message(
                'custom', state, number='one'), value, state)
        return int(value)

    def _convert_from_python(self, value, state):
        if value == 2:
            raise Invalid(self.message(
                'custom', state, number='two'), value, state)
        return str(value)

    def _validate_other(self, value, state):
        if value == '3':
            raise Invalid(self.message(
                'custom', state, number='three'), value, state)

    def _validate_python(self, value, state):
        if value == 4:
            raise Invalid(self.message(
                'custom', state, number='four'), value, state)


class TestCustomValidator(unittest.TestCase):

    def test_is_validator(self):
        self.assertTrue(is_validator(CustomValidator))
        self.assertTrue(is_validator(CustomValidator()))

    def test_to_python(self):
        cv = CustomValidator()
        self.assertEqual(cv.to_python('0'), 0)
        try:
            cv.to_python('1')
        except Invalid as e:
            self.assertTrue(
                'one is invalid' in str(e), e)
        else:
            self.fail("one should be invalid")
        self.assertEqual(cv.to_python('2'), 2)
        try:
            cv.to_python('3')
        except Invalid as e:
            self.assertTrue(
                'three is invalid' in str(e), e)
        else:
            self.fail("three should be invalid")
        try:
            cv.to_python('4')
        except Invalid as e:
            self.assertTrue(
                'four is invalid' in str(e), e)
        else:
            self.fail("four should be invalid")
        self.assertEqual(cv.to_python('5'), 5)

    def test_from_python(self):
        cv = CustomValidator()
        self.assertEqual(cv.from_python(0), '0')
        self.assertEqual(cv.from_python(1), '1')
        try:
            cv.from_python(2)
        except Invalid as e:
            self.assertTrue(
                'two is invalid' in str(e), e)
        else:
            self.fail("two should be invalid")
        self.assertEqual(cv.from_python(3), '3')
        self.assertEqual(cv.from_python(4), '4')
        self.assertEqual(cv.from_python(5), '5')

    def test_from_python_no_accept(self):
        cv = CustomValidator(accept_python=False)
        self.assertEqual(cv.from_python(0), '0')
        self.assertEqual(cv.from_python(1), '1')
        try:
            cv.from_python(2)
        except Invalid as e:
            self.assertTrue(
                'two is invalid' in str(e), e)
        else:
            self.fail("two should be invalid")
        try:
            cv.from_python(3)
        except Invalid as e:
            self.assertTrue(
                'three is invalid' in str(e), e)
        else:
            self.fail("three should be invalid")
        try:
            cv.from_python(4)
        except Invalid as e:
            self.assertTrue(
                'four is invalid' in str(e), e)
        else:
            self.fail("four should be invalid")
        self.assertEqual(cv.from_python(5), '5')


class NotOneValidator(Int):
    """A custom validator based on an existing validator."""

    messages = {
        'custom': "must not be %(number)d",
    }

    number = 1

    def _convert_to_python(self, value, state):
        value = super(NotOneValidator, self)._convert_to_python(value, state)
        if value == self.number:
            raise Invalid(self.message(
                'custom', state, number=self.number), value, state)
        return value


class TestNotOneValidator(unittest.TestCase):

    def test_is_validator(self):
        self.assertTrue(is_validator(NotOneValidator))
        self.assertTrue(is_validator(NotOneValidator()))
        self.assertTrue(is_validator(NotOneValidator(one=2)))

    def test_to_python(self):
        nov = NotOneValidator()
        self.assertEqual(nov.to_python('0'), 0)
        try:
            nov.to_python('1')
        except Invalid as e:
            self.assertTrue(
                'must not be 1' in str(e), e)
        else:
            self.fail("1 should be invalid")
        self.assertEqual(nov.to_python('2'), 2)
        self.assertEqual(nov.to_python('42'), 42)

    def test_to_python_number(self):
        nov = NotOneValidator(number=42)
        self.assertEqual(nov.to_python('0'), 0)
        self.assertEqual(nov.to_python('1'), 1)
        self.assertEqual(nov.to_python('2'), 2)
        try:
            nov.to_python('42')
        except Invalid as e:
            self.assertTrue(
                'must not be 42' in str(e), e)
        else:
            self.fail("42 should be invalid")

    def test_to_python_range(self):
        nov = NotOneValidator(min=40, max=49, number=42)
        self.assertRaises(Invalid, nov.to_python, '0')
        self.assertRaises(Invalid, nov.to_python, '1')
        self.assertRaises(Invalid, nov.to_python, '2')
        self.assertRaises(Invalid, nov.to_python, '39')
        self.assertEqual(nov.to_python('40'), 40)
        self.assertEqual(nov.to_python('41'), 41)
        try:
            nov.to_python('42')
        except Invalid as e:
            self.assertTrue(
                'must not be 42' in str(e), e)
        else:
            self.fail("42 should be invalid")
        self.assertEqual(nov.to_python('43'), 43)
        self.assertEqual(nov.to_python('49'), 49)
        self.assertRaises(Invalid, nov.to_python, '50')


class CustomCompoundValidator(CompoundValidator):
    """A custom validator based directly on CompoundValidator."""

    def _attempt_convert(self, value, state, validate):
        return validate(self.validators[1], value, state)


class TestCustomCompoundValidator(unittest.TestCase):

    def setUp(self):
        self.validator = CustomCompoundValidator(
            validators=[Int(min=3), Int(max=5)])

    def test_is_validator(self):
        self.assertTrue(is_validator(CustomCompoundValidator))
        self.assertTrue(is_validator(self.validator))

    def test_to_python(self):
        ccv = self.validator
        self.assertEqual(ccv.to_python('2'), 2)
        self.assertEqual(ccv.to_python('4'), 4)
        self.assertRaises(Invalid, ccv.to_python, '6')


class AllAndNotOneValidator(All):
    """A custom validator based on an existing CompoundValidator."""

    messages = {
        'custom': "must not be %(number)d",
    }

    number = 1

    def _attempt_convert(self, value, state, validate):
        value = super(AllAndNotOneValidator, self)._attempt_convert(
            value, state, validate)
        if value == self.number:
            raise Invalid(self.message(
                'custom', state, number=self.number), value, state)
        return value


class TestAllAndNotOneValidator(unittest.TestCase):

    def setUp(self):
        self.validator = AllAndNotOneValidator(
            validators=[Int(min=3), Int(max=5)], number=4)

    def test_is_validator(self):
        self.assertTrue(is_validator(AllAndNotOneValidator))
        self.assertTrue(is_validator(self.validator))

    def test_to_python(self):
        cav = self.validator
        self.assertRaises(Invalid, cav.to_python, '1')
        self.assertRaises(Invalid, cav.to_python, '2')
        self.assertEqual(cav.to_python('3'), 3)
        try:
            cav.to_python('4')
        except Invalid as e:
            self.assertTrue(
                'must not be 4' in str(e), e)
        else:
            self.fail("4 should be invalid")
        self.assertEqual(cav.to_python('5'), 5)
        self.assertRaises(Invalid, cav.to_python, '6')
        self.assertRaises(Invalid, cav.to_python, '7')


class DeclarativeAllValidator(All):
    """A CompoundValidator with subvalidators given as attributes."""

    first_validator = Int(min=3)
    second_validator = Int(max=5)


class TestDeclarativeAllValidator(unittest.TestCase):

    def test_is_validator(self):
        self.assertTrue(is_validator(DeclarativeAllValidator))
        self.assertTrue(is_validator(DeclarativeAllValidator()))

    def test_attrs_deleted(self):
        self.assertFalse(hasattr(DeclarativeAllValidator, 'first_validator'))
        self.assertFalse(hasattr(DeclarativeAllValidator, 'second_validator'))

    def test_to_python(self):
        dav = DeclarativeAllValidator()
        self.assertRaises(Invalid, dav.to_python, '1')
        self.assertRaises(Invalid, dav.to_python, '2')
        self.assertEqual(dav.to_python('3'), 3)
        self.assertEqual(dav.to_python('4'), 4)
        self.assertEqual(dav.to_python('5'), 5)
        self.assertRaises(Invalid, dav.to_python, '6')
        self.assertRaises(Invalid, dav.to_python, '7')

########NEW FILE########
__FILENAME__ = test_subclassing_old
# -*- coding: utf-8 -*-

import unittest
import warnings

from formencode.api import is_validator, FancyValidator, Invalid
from formencode.compound import CompoundValidator, All
from formencode.validators import Int


with warnings.catch_warnings(record=True) as custom_warnings:
    warnings.simplefilter('default')

    class DeprecatedCustomValidator(FancyValidator):
        """A custom validator based directly on FancyValidator."""

        messages = {
            'custom': "%(number)s is invalid",
        }

        def _to_python(self, value, state):
            if value == '1':
                raise Invalid(self.message(
                    'custom', state, number='one'), value, state)
            return int(value)

        def _from_python(self, value, state):
            if value == 2:
                raise Invalid(self.message(
                    'custom', state, number='two'), value, state)
            return str(value)

        def validate_other(self, value, state):
            if value == '3':
                raise Invalid(self.message(
                    'custom', state, number='three'), value, state)

        def validate_python(self, value, state):
            if value == 4:
                raise Invalid(self.message(
                    'custom', state, number='four'), value, state)


class TestDeprecatedCustomValidator(unittest.TestCase):

    def test_1_warnings(self):
        deprecated = (
            ('_to_python', '_convert_to_python'),
            ('_from_python', '_convert_from_python'),
            ('validate_other', '_validate_other'),
            ('validate_python', '_validate_python'))
        output = '\n'.join(map(str, custom_warnings))
        for old, new in deprecated:
            msg = '%s is deprecated; use %s instead' % (old, new)
            self.assertTrue(msg in output, output or 'no warnings')

    def test_is_validator(self):
        self.assertTrue(is_validator(DeprecatedCustomValidator))
        self.assertTrue(is_validator(DeprecatedCustomValidator()))

    def test_to_python(self):
        cv = DeprecatedCustomValidator()
        self.assertEqual(cv.to_python('0'), 0)
        try:
            cv.to_python('1')
        except Invalid as e:
            self.assertTrue(
                'one is invalid' in str(e), e)
        else:
            self.fail("one should be invalid")
        self.assertEqual(cv.to_python('2'), 2)
        try:
            cv.to_python('3')
        except Invalid as e:
            self.assertTrue(
                'three is invalid' in str(e), e)
        else:
            self.fail("three should be invalid")
        try:
            cv.to_python('4')
        except Invalid as e:
            self.assertTrue(
                'four is invalid' in str(e), e)
        else:
            self.fail("four should be invalid")
        self.assertEqual(cv.to_python('5'), 5)

    def test_from_python(self):
        cv = DeprecatedCustomValidator()
        self.assertEqual(cv.from_python(0), '0')
        self.assertEqual(cv.from_python(1), '1')
        try:
            cv.from_python(2)
        except Invalid as e:
            self.assertTrue(
                'two is invalid' in str(e), e)
        else:
            self.fail("two should be invalid")
        self.assertEqual(cv.from_python(3), '3')
        self.assertEqual(cv.from_python(4), '4')
        self.assertEqual(cv.from_python(5), '5')

    def test_from_python_no_accept(self):
        cv = DeprecatedCustomValidator(accept_python=False)
        self.assertEqual(cv.from_python(0), '0')
        self.assertEqual(cv.from_python(1), '1')
        try:
            cv.from_python(2)
        except Invalid as e:
            self.assertTrue(
                'two is invalid' in str(e), e)
        else:
            self.fail("two should be invalid")
        try:
            cv.from_python(3)
        except Invalid as e:
            self.assertTrue(
                'three is invalid' in str(e), e)
        else:
            self.fail("three should be invalid")
        try:
            cv.from_python(4)
        except Invalid as e:
            self.assertTrue(
                'four is invalid' in str(e), e)
        else:
            self.fail("four should be invalid")
        self.assertEqual(cv.from_python(5), '5')


with warnings.catch_warnings(record=True) as not_one_warnings:
    warnings.simplefilter('default')

    class DeprecatedNotOneValidator(Int):
        """A custom validator based on an existing validator."""

        messages = {
            'custom': "must not be %(number)d",
        }

        number = 1

        def _to_python(self, value, state):
            value = super(DeprecatedNotOneValidator, self)._to_python(
                value, state)
            if value == self.number:
                raise Invalid(self.message(
                    'custom', state, number=self.number), value, state)
            return value


class TestDeprecatedNotOneValidator(unittest.TestCase):

    def test_1_warnings(self):  # must run first
        with warnings.catch_warnings(record=True) as runtime_warnings:
            warnings.simplefilter('default')
            DeprecatedNotOneValidator().to_python('2')
        for output in runtime_warnings, not_one_warnings:
            output = '\n'.join(map(str, output))
            msg = '_to_python is deprecated; use _convert_to_python instead'
            self.assertTrue(msg in output, output or 'no warnings')

    def test_is_validator(self):
        self.assertTrue(is_validator(DeprecatedNotOneValidator))
        self.assertTrue(is_validator(DeprecatedNotOneValidator()))
        self.assertTrue(is_validator(DeprecatedNotOneValidator(one=2)))

    def test_to_python(self):
        nov = DeprecatedNotOneValidator()
        self.assertEqual(nov.to_python('0'), 0)
        try:
            nov.to_python('1')
        except Invalid as e:
            self.assertTrue(
                'must not be 1' in str(e), e)
        else:
            self.fail("1 should be invalid")
        self.assertEqual(nov.to_python('2'), 2)
        self.assertEqual(nov.to_python('42'), 42)

    def test_to_python_number(self):
        nov = DeprecatedNotOneValidator(number=42)
        self.assertEqual(nov.to_python('0'), 0)
        self.assertEqual(nov.to_python('1'), 1)
        self.assertEqual(nov.to_python('2'), 2)
        try:
            nov.to_python('42')
        except Invalid as e:
            self.assertTrue(
                'must not be 42' in str(e), e)
        else:
            self.fail("42 should be invalid")

    def test_to_python_range(self):
        nov = DeprecatedNotOneValidator(min=40, max=49, number=42)
        self.assertRaises(Invalid, nov.to_python, '0')
        self.assertRaises(Invalid, nov.to_python, '1')
        self.assertRaises(Invalid, nov.to_python, '2')
        self.assertRaises(Invalid, nov.to_python, '39')
        self.assertEqual(nov.to_python('40'), 40)
        self.assertEqual(nov.to_python('41'), 41)
        try:
            nov.to_python('42')
        except Invalid as e:
            self.assertTrue(
                'must not be 42' in str(e), e)
        else:
            self.fail("42 should be invalid")
        self.assertEqual(nov.to_python('43'), 43)
        self.assertEqual(nov.to_python('49'), 49)
        self.assertRaises(Invalid, nov.to_python, '50')


with warnings.catch_warnings(record=True) as custom_compound_warnings:
    warnings.simplefilter('default')

    class DeprecatedCustomCompoundValidator(CompoundValidator):
        """A custom validator based directly on CompoundValidator."""

        def attempt_convert(self, value, state, validate):
            return validate(self.validators[1], value, state)


class TestDeprecatedCustomCompoundValidator(unittest.TestCase):

    def setUp(self):
        self.validator = DeprecatedCustomCompoundValidator(
            validators=[Int(min=3), Int(max=5)])

    def test_1_warnings(self):
        output = '\n'.join(map(str, custom_compound_warnings))
        msg = 'attempt_convert is deprecated; use _attempt_convert instead'
        self.assertTrue(msg in output, output or 'no warnings')

    def test_is_validator(self):
        self.assertTrue(is_validator(DeprecatedCustomCompoundValidator))
        self.assertTrue(is_validator(self.validator))

    def test_to_python(self):
        with warnings.catch_warnings(record=True) as _ignore:
            ccv = self.validator
            self.assertEqual(ccv.to_python('2'), 2)
            self.assertEqual(ccv.to_python('4'), 4)
            self.assertRaises(Invalid, ccv.to_python, '6')


with warnings.catch_warnings(record=True) as all_and_not_one_warnings:
    warnings.simplefilter('default')

    class DeprecatedAllAndNotOneValidator(All):
        """A custom validator based on an existing CompoundValidator."""

        messages = {
            'custom': "must not be %(number)d",
        }

        number = 1

        def attempt_convert(self, value, state, validate):
            value = super(DeprecatedAllAndNotOneValidator,
                self).attempt_convert(value, state, validate)
            if value == self.number:
                raise Invalid(self.message(
                    'custom', state, number=self.number), value, state)
            return value


class TestDeprecatedAllAndNotOneValidator(unittest.TestCase):

    def setUp(self):
        self.validator = DeprecatedAllAndNotOneValidator(
            validators=[Int(min=3), Int(max=5)], number=4)

    def test_1_warnings(self):  # must run first
        with warnings.catch_warnings(record=True) as runtime_warnings:
            warnings.simplefilter('default')
            self.validator.to_python('3')
        for output in runtime_warnings, all_and_not_one_warnings:
            output = '\n'.join(map(str, output))
            msg = 'attempt_convert is deprecated; use _attempt_convert instead'
            self.assertTrue(msg in output, output or 'no warnings')

    def test_is_validator(self):
        self.assertTrue(is_validator(DeprecatedAllAndNotOneValidator))
        self.assertTrue(is_validator(self.validator))

    def test_to_python(self):
        cav = self.validator
        self.assertRaises(Invalid, cav.to_python, '1')
        self.assertRaises(Invalid, cav.to_python, '2')
        self.assertEqual(cav.to_python('3'), 3)
        try:
            cav.to_python('4')
        except Invalid as e:
            self.assertTrue(
                'must not be 4' in str(e), e)
        else:
            self.fail("4 should be invalid")
        self.assertEqual(cav.to_python('5'), 5)
        self.assertRaises(Invalid, cav.to_python, '6')
        self.assertRaises(Invalid, cav.to_python, '7')

########NEW FILE########
__FILENAME__ = test_validators
# -*- coding: utf-8 -*-

import datetime
import unittest
from nose.plugins.skip import SkipTest

from formencode import validators
from formencode.validators import Invalid
from formencode.variabledecode import NestedVariables
from formencode.schema import Schema
from formencode.foreach import ForEach
from formencode.api import NoDefault


def validate(validator, value):
    try:
        return validator.to_python(value)
        return None
    except Invalid as e:
        return e.unpack_errors()


def validate_from(validator, value):
    try:
        validator.from_python(value)
        return None
    except Invalid as e:
        return e.unpack_errors()


class TestValidators(unittest.TestCase):

    def testHelp(self):
        from pydoc import text, plain
        s = plain(text.document(validators))
        self.assertTrue('Validator/Converters for use with FormEncode.' in s)
        self.assertTrue('class Bool' in s)
        self.assertTrue('Always Valid, returns True or False' in s)
        self.assertTrue('class Email' in s)
        self.assertTrue('Validate an email address.' in s)
        self.assertTrue('class FieldsMatch' in s)
        self.assertTrue('Tests that the given fields match' in s)


class TestByteStringValidator(unittest.TestCase):

    def setUp(self):
        self.validator = validators.ByteString
        self.messages = self.validator.message

    def test_alias(self):
        if str is not unicode:  # Python 2
            self.assertTrue(self.validator is validators.String)

    def test_docstring(self):
        doc = self.validator.__doc__
        self.assertTrue(
            'Enter a value not more than ``%(max)i`` characters long' in doc)

    def test_sv_min(self):
        sv = self.validator(min=2, accept_python=False)
        self.assertEqual(sv.to_python("foo"), "foo")
        self.assertEqual(validate(sv, "x"),
            self.messages('tooShort', None, min=2))
        self.assertEqual(validate(sv, None), self.messages('empty', None))
        # should be completely invalid?
        self.assertEqual(validate(sv, []), self.messages('empty', None, min=2))
        self.assertEqual(sv.from_python(['x', 'y']), 'x, y')

    def test_sv_not_empty(self):
        sv = self.validator(not_empty=True)
        self.assertEqual(validate(sv, ""), self.messages('empty', None))
        self.assertEqual(validate(sv, None), self.messages('empty', None))
        # should be completely invalid?
        self.assertEqual(validate(sv, []), self.messages('empty', None))
        self.assertEqual(validate(sv, {}), self.messages('empty', None))

    def test_sv_string_conversion(self):
        sv = self.validator(not_empty=False)
        self.assertEqual(sv.from_python(2), "2")
        self.assertEqual(sv.from_python([]), "")


class TestUnicodeStringValidator(unittest.TestCase):

    def setUp(self):
        self.validator = validators.UnicodeString

    def test_alias(self):
        if str is unicode:  # Python 3
            self.assertTrue(self.validator is validators.String)

    def test_docstring(self):
        doc = self.validator.__doc__
        self.assertTrue('Invalid data or incorrect encoding' in doc)

    def test_unicode(self):
        un = self.validator()
        self.assertEqual(un.to_python(12), u'12')
        self.assertTrue(type(un.to_python(12)) is unicode)
        self.assertEqual(un.from_python(12), u'12'.encode('ascii'))
        self.assertTrue(type(un.from_python(12)) is bytes)

    def test_unicode_encoding(self):
        uv = self.validator()
        us = u'käse'
        u7s, u8s = us.encode('utf-7'), us.encode('utf-8')
        self.assertEqual(uv.to_python(u8s), us)
        self.assertTrue(type(uv.to_python(u8s)) is unicode)
        self.assertEqual(uv.from_python(us), u8s)
        self.assertTrue(type(uv.from_python(us)) is bytes)
        uv = self.validator(encoding='utf-7')
        self.assertEqual(uv.to_python(u7s), us)
        self.assertTrue(type(uv.to_python(u7s)) is unicode)
        self.assertEqual(uv.from_python(us), u7s)
        self.assertTrue(type(uv.from_python(us)) is bytes)
        uv = self.validator(inputEncoding='utf-7')
        self.assertEqual(uv.to_python(u7s), us)
        self.assertTrue(type(uv.to_python(u7s)) is unicode)
        uv = self.validator(outputEncoding='utf-7')
        self.assertEqual(uv.from_python(us), u7s)
        self.assertTrue(type(uv.from_python(us)) is bytes)
        uv = self.validator(inputEncoding=None)
        self.assertEqual(uv.to_python(us), us)
        self.assertTrue(type(uv.to_python(us)) is unicode)
        self.assertEqual(uv.from_python(us), u8s)
        self.assertTrue(type(uv.from_python(us)) is bytes)
        uv = self.validator(outputEncoding=None)
        self.assertEqual(uv.to_python(u8s), us)
        self.assertTrue(type(uv.to_python(u8s)) is unicode)
        self.assertEqual(uv.from_python(us), us)
        self.assertTrue(type(uv.from_python(us)) is unicode)

        def test_unicode_empty(self):
            iv = self.validator()
            for value in [None, "", u""]:
                result = iv.to_python(value)
                self.assertEqual(result, u"")
                self.assertTrue(isinstance(result, unicode))


class TestIntValidator(unittest.TestCase):

    def setUp(self):
        self.validator = validators.Int
        self.messages = self.validator.message

    def test_docstring(self):
        doc = self.validator.__doc__
        self.assertTrue('Please enter an integer value' in doc)

    def test_int_min(self):
        iv = self.validator(min=5)
        self.assertEqual(iv.to_python("5"), 5)
        self.assertEqual(validate(iv, "1"),
            self.messages('tooLow', None, min=5))

    def test_int_max(self):
        iv = self.validator(max=10)
        self.assertEqual(iv.to_python("10"), 10)
        self.assertEqual(validate(iv, "15"),
            self.messages('tooHigh', None, max=10))

    def test_int_minmax_optional(self):
        iv = self.validator(min=5, max=10, if_empty=None)
        self.assertTrue(iv.to_python("") is None)
        self.assertTrue(iv.to_python(None) is None)
        self.assertEqual(iv.to_python('7'), 7)
        self.assertEqual(validate(iv, "1"),
            self.messages('tooLow', None, min=5))
        self.assertEqual(validate(iv, "15"),
            self.messages('tooHigh', None, max=10))

    def test_int_minmax_mandatory(self):
        iv = validators.Int(min=5, max=10, not_empty=True)
        self.assertEqual(validate(iv, None),
            self.messages('empty', None))
        self.assertEqual(validate(iv, "1"),
            self.messages('tooLow', None, min=5))
        self.assertEqual(validate(iv, "15"),
            self.messages('tooHigh', None, max=10))


class TestNumberValidator(unittest.TestCase):
    def setUp(self):
        self.validator = validators.Number

    def test_inf(self):
        """Validate infinity if system supports it."""
        # Ability to convert to infinity depends on your C
        # Float library as well as the python version.
        try:
            inf = float('infinity')
        except ValueError:
            raise SkipTest
        self.assertEqual(self.validator.to_python('infinity'), inf)


class TestDateConverterValidator(unittest.TestCase):

    def setUp(self):
        self.validator = validators.DateConverter

    def test_bad_dates(self):
        dc = self.validator(month_style='dd/mm/yyyy')
        try:
            dc.to_python('20/12/150')
        except Invalid as e:
            self.assertTrue(
                'Please enter a four-digit year after 1899' in str(e))
        else:
            self.fail('Date should be invalid')
        try:
            dc.to_python('oh/happy/day')
        except Invalid as e:
            self.assertTrue(
                'Please enter the date in the form DD/MM/YYYY' in str(e))
        else:
            self.fail('Date should be invalid')

    def test_month_style_alias(self):
        dc = self.validator()
        self.assertEqual(dc.month_style, 'mdy')
        for style in 'mdy mm/dd/yyyy MM/DD/YYYY US American'.split():
            dc = self.validator(month_style=style)
            self.assertEqual(dc.month_style, 'mdy')
        for style in 'dmy dd/mm/yyyy DD/MM/YYYY Euro European'.split():
            dc = self.validator(month_style=style)
            self.assertEqual(dc.month_style, 'dmy')
        for style in 'ymd yyyy/mm/dd YYYY/MM/DD ISO China Chinese'.split():
            dc = self.validator(month_style=style)
            self.assertEqual(dc.month_style, 'ymd')
        try:
            dc = self.validator(month_style='Klingon')
        except TypeError as e:
            self.assertTrue(
                str(e) == "Bad month_style: 'klingon'")
        else:
            self.fail('month_style should be invalid')
        try:
            dc = self.validator(month_style='ydm')
        except TypeError as e:
            self.assertTrue(
                str(e) == "Bad month_style: 'ydm'")
        else:
            self.fail('month_style should be invalid')

    def test_us_style(self):
        d = datetime.date(2007, 12, 20)
        dc = self.validator()
        self.assertEqual(dc.to_python('12/20/2007'), d)
        self.assertEqual(dc.from_python(d), '12/20/2007')
        self.assertEqual(dc.to_python('Dec/20/2007'), d)
        self.assertEqual(dc.to_python('December/20/2007'), d)
        try:
            self.assertEqual(dc.to_python('20/12/2007'), d)
        except Invalid as e:
            self.assertTrue('Please enter a month from 1 to 12' in str(e))
        else:
            self.fail('Date should be invalid')
        try:
            self.assertEqual(dc.to_python('12/Dec/2007'), d)
        except Invalid as e:
            self.assertTrue(
                'Please enter the date in the form MM/DD/YYYY' in str(e))
        else:
            self.fail('Date should be invalid')

    def test_euro_style(self):
        d = datetime.date(2007, 12, 20)
        dc = self.validator(month_style='dd/mm/yyyy')
        self.assertEqual(dc.to_python('20/12/2007'), d)
        self.assertEqual(dc.from_python(d), '20/12/2007')
        self.assertEqual(dc.to_python('20/Dec/2007'), d)
        self.assertEqual(dc.to_python('20/December/2007'), d)
        try:
            self.assertEqual(dc.to_python('12/20/2007'), d)
        except Invalid as e:
            self.assertTrue('Please enter a month from 1 to 12' in str(e))
        else:
            self.fail('Date should be invalid')
        try:
            self.assertEqual(dc.to_python('Dec/12/2007'), d)
        except Invalid as e:
            self.assertTrue(
                'Please enter the date in the form DD/MM/YYYY' in str(e))
        else:
            self.fail('Date should be invalid')

    def test_iso_style(self):
        d = datetime.date(2013, 6, 30)
        dc = self.validator(month_style='yyyy/mm/dd')
        self.assertEqual(dc.to_python('2013/06/30'), d)
        self.assertEqual(dc.from_python(d), '2013/06/30')
        self.assertEqual(dc.to_python('2013/Jun/30'), d)
        self.assertEqual(dc.to_python('2013/June/30'), d)
        try:
            self.assertEqual(dc.to_python('2013/30/06'), d)
        except Invalid as e:
            self.assertTrue('Please enter a month from 1 to 12' in str(e))
        else:
            self.fail('Date should be invalid')
        try:
            self.assertEqual(dc.to_python('2013/06/Jun'), d)
        except Invalid as e:
            self.assertTrue(
                'Please enter the date in the form YYYY/MM/DD' in str(e))
        else:
            self.fail('Date should be invalid')

    def test_no_day(self):
        d = datetime.date(2007, 12, 1)
        dc = self.validator(accept_day=False)
        self.assertEqual(dc.to_python('12/2007'), d)
        self.assertEqual(dc.from_python(d), '12/2007')
        self.assertEqual(dc.to_python('Dec/2007'), d)
        self.assertEqual(dc.to_python('December/2007'), d)
        try:
            self.assertEqual(dc.to_python('20/2007'), d)
        except Invalid as e:
            self.assertTrue('Please enter a month from 1 to 12' in str(e))
        else:
            self.fail('Date should be invalid')
        try:
            self.assertEqual(dc.to_python('12/20/2007'), d)
        except Invalid as e:
            self.assertTrue(
                'Please enter the date in the form MM/YYYY' in str(e))
        else:
            self.fail('Date should be invalid')
        try:
            self.assertEqual(dc.to_python('2007/Dec'), d)
        except Invalid as e:
            self.assertTrue(
                'Please enter the date in the form MM/YYYY' in str(e))
        else:
            self.fail('Date should be invalid')

    def test_from_python(self):
        d = datetime.date(2013, 6, 30)
        dc = self.validator()
        self.assertEqual(dc.from_python(d), '06/30/2013')
        dc = self.validator(month_style='dd/mm/yyyy')
        self.assertEqual(dc.from_python(d), '30/06/2013')
        dc = self.validator(month_style='dd/mm/yyyy', separator='.')
        self.assertEqual(dc.from_python(d), '30.06.2013')
        dc = self.validator(month_style='yyyy/mm/dd')
        self.assertEqual(dc.from_python(d), '2013/06/30')
        dc = self.validator(month_style='yyyy/mm/dd', separator='-')
        self.assertEqual(dc.from_python(d), '2013-06-30')

    def test_from_python_no_day(self):
        d = datetime.date(2013, 6, 30)
        dc = self.validator(accept_day=False)
        self.assertEqual(dc.from_python(d), '06/2013')
        dc = self.validator(month_style='dd/mm/yyyy', accept_day=False)
        self.assertEqual(dc.from_python(d), '06/2013')
        dc = self.validator(month_style='yyyy/mm/dd', accept_day=False)
        self.assertEqual(dc.from_python(d), '2013/06')
        dc = self.validator(month_style='yyyy/mm/dd',
            separator='-', accept_day=False)
        self.assertEqual(dc.from_python(d), '2013-06')

    def test_auto_separator(self):
        d = datetime.date(2013, 6, 30)
        dc = self.validator(month_style='us', separator=None)
        self.assertEqual(dc.from_python(d), '06/30/2013')
        dc = self.validator(month_style='euro', separator=None)
        self.assertEqual(dc.from_python(d), '30.06.2013')
        dc = self.validator(month_style='iso', separator=None)
        self.assertEqual(dc.from_python(d), '2013-06-30')


class TestTimeConverterValidator(unittest.TestCase):

    def setUp(self):
        self.validator = validators.TimeConverter

    def test_time(self):
        tc = self.validator()
        self.assertEqual(tc.to_python('20:30:15'), (20, 30, 15))
        try:
            tc.to_python('25:30:15')
        except Invalid as e:
            self.assertTrue(
                'You must enter an hour in the range 0-23' in str(e))
        else:
            self.fail('Time should be invalid')
        try:
            tc.to_python('20:75:15')
        except Invalid as e:
            self.assertTrue(
                'You must enter a minute in the range 0-59' in str(e))
        else:
            self.fail('Time should be invalid')
        try:
            tc.to_python('20:30:75')
        except Invalid as e:
            self.assertTrue(
                'You must enter a second in the range 0-59' in str(e))
        else:
            self.fail('Time should be invalid')
        try:
            tc.to_python('20:30:zx')
        except Invalid as e:
            self.assertTrue(
                'The second value you gave is not a number' in str(e))
            self.assertTrue('zx' in str(e))
        else:
            self.fail('Time should be invalid')


class TestForEachValidator(unittest.TestCase):

    def test_foreach_if_missing(self):

        class SubSchema(Schema):
            age = validators.Int()
            name = validators.String(not_empty=True)

        class MySchema(Schema):
            pre_validators = [NestedVariables()]
            people = ForEach(SubSchema(), if_missing=NoDefault,
                messages={'missing': 'Please add a person'})

        validator = MySchema()

        self.assertFalse(validator.fields['people'].not_empty)

        class State:
            pass

        start_values = {}
        state = State()

        try:
            values = validator.to_python(start_values, state)
        except Invalid as e:
            self.assertEqual(e.unpack_errors(),
                {'people': u'Please add a person'})
        else:
            raise Exception("Shouldn't be valid data", values, start_values)


class TestXRIValidator(unittest.TestCase):
    """Generic tests for the XRI validator"""

    def setUp(self):
        self.validator = validators.XRI

    def test_creation_valid_params(self):
        """The creation of an XRI validator with valid parameters must
        succeed"""
        self.validator()
        self.validator(True, "i-name")
        self.validator(True, "i-number")
        self.validator(False, "i-name")
        self.validator(False, "i-number")

    def test_creation_invalid_xri(self):
        """Only "i-name" and "i-number" are valid XRIs"""
        self.assertRaises(AssertionError, self.validator, True, 'i-something')

    def test_valid_simple_individual_iname_without_type(self):
        """XRIs must start with either an equals sign or an at sign"""
        validator = self.validator(True, "i-name")
        self.assertRaises(Invalid, validator.to_python, 'Gustavo')

    def test_valid_iname_with_schema(self):
        """XRIs may have their schema in the beggining"""
        validator = self.validator()
        self.assertEqual(validator.to_python('xri://=Gustavo'),
                         'xri://=Gustavo')

    def test_schema_is_added_if_asked(self):
        """The schema must be added to an XRI if explicitly asked"""
        validator = self.validator(True)
        self.assertEqual(validator.to_python('=Gustavo'),
                         'xri://=Gustavo')

    def test_schema_not_added_if_not_asked(self):
        """The schema must not be added to an XRI unless explicitly asked"""
        validator = self.validator()
        self.assertEqual(validator.to_python('=Gustavo'), '=Gustavo')

    def test_spaces_are_trimmed(self):
        """Spaces at the beggining or end of the XRI are removed"""
        validator = self.validator()
        self.assertEqual(validator.to_python('    =Gustavo  '), '=Gustavo')


class TestINameValidator(unittest.TestCase):
    """Tests for the XRI i-names validator"""

    def setUp(self):
        self.validator = validators.XRI(xri_type="i-name")

    def test_valid_global_individual_iname(self):
        """Global & valid individual i-names must pass validation"""
        self.validator.to_python('=Gustavo')

    def test_valid_global_organizational_iname(self):
        """Global & valid organizational i-names must pass validation"""
        self.validator.to_python('@Canonical')

    def test_invalid_iname(self):
        """Non-string i-names are rejected"""
        self.assertRaises(Invalid, self.validator._validate_python, None)

    def test_exclamation_in_inames(self):
        """Exclamation marks at the beggining of XRIs is something specific
        to i-numbers and must be rejected in i-names"""
        self.assertRaises(Invalid, self.validator.to_python,
                          "!!1000!de21.4536.2cb2.8074")

    def test_repeated_characters(self):
        """Dots and dashes must not be consecutively repeated in i-names"""
        self.assertRaises(Invalid, self.validator.to_python,
                          "=Gustavo--Narea")
        self.assertRaises(Invalid, self.validator.to_python,
                          "=Gustavo..Narea")

    def test_punctuation_marks_at_beggining(self):
        """Punctuation marks at the beggining of i-names are forbidden"""
        self.assertRaises(Invalid, self.validator.to_python,
                          "=.Gustavo")
        self.assertRaises(Invalid, self.validator.to_python,
                          "=-Gustavo.Narea")

    def test_numerals_at_beggining(self):
        """Numerals at the beggining of i-names are forbidden"""
        self.assertRaises(Invalid, self.validator.to_python,
                          "=1Gustavo")

    def test_non_english_inames(self):
        """i-names with non-English characters are valid"""
        self.validator.to_python(u'=Gustavo.Narea.García')
        self.validator.to_python(u'@名前.例')

    def test_inames_plus_paths(self):
        """i-names with paths are valid but not supported"""
        self.assertRaises(Invalid, self.validator.to_python,
                          "=Gustavo/(+email)")

    def test_communities(self):
        """i-names may have so-called 'communities'"""
        self.validator.to_python(u'=María*Yolanda*Liliana*Gustavo')
        self.validator.to_python(u'=Gustavo*Andreina')
        self.validator.to_python(u'@IBM*Lenovo')


class TestINumberValidator(unittest.TestCase):
    """Tests for the XRI i-number validator"""

    def setUp(self):
        self.validator = validators.XRI(xri_type="i-number")

    def test_valid_global_personal_inumber(self):
        """Global & valid personal i-numbers must pass validation"""
        self.validator.to_python('=!1000.a1b2.93d2.8c73')

    def test_valid_global_organizational_inumber(self):
        """Global & valid organizational i-numbers must pass validation"""
        self.validator.to_python('@!1000.a1b2.93d2.8c73')

    def test_valid_global_network_inumber(self):
        """Global & valid network i-numbers must pass validation"""
        self.validator.to_python('!!1000')

    def test_valid_community_personal_inumbers(self):
        """Community & valid personal i-numbers must pass validation"""
        self.validator.to_python('=!1000.a1b2.93d2.8c73!3ae2!1490')

    def test_valid_community_organizational_inumber(self):
        """Community & valid organizational i-numbers must pass validation"""
        self.validator.to_python('@!1000.9554.fabd.129c!2847.df3c')

    def test_valid_community_network_inumber(self):
        """Community & valid network i-numbers must pass validation"""
        self.validator.to_python('!!1000!de21.4536.2cb2.8074')


class TestOpenIdValidator(unittest.TestCase):
    """Tests for the OpenId validator"""

    def setUp(self):
        self.validator = validators.OpenId(add_schema=False)

    def test_url(self):
        self.assertEqual(self.validator.to_python('http://example.org'),
                         'http://example.org')

    def test_iname(self):
        self.assertEqual(self.validator.to_python('=Gustavo'), '=Gustavo')

    def test_inumber(self):
        self.assertEqual(self.validator.to_python('!!1000'), '!!1000')

    def test_email(self):
        """Email addresses are not valid OpenIds!"""
        self.assertRaises(Invalid, self.validator.to_python,
                          "wait@busstop.com")

    def test_prepending_schema(self):
        validator = validators.OpenId(add_schema=True)
        self.assertEqual(validator.to_python("example.org"),
                         "http://example.org")
        self.assertEqual(validator.to_python("=Gustavo"),
                         "xri://=Gustavo")
        self.assertEqual(validator.to_python("!!1000"),
                         "xri://!!1000")


class TestOneOfValidator(unittest.TestCase):

    def test_docstring(self):
        doc = validators.OneOf.__doc__
        self.assertTrue(
            'Value must be one of: ``%(items)s`` (not ``%(value)r``)' in doc)

    def test_unicode_list(self):
        o = validators.OneOf([u'ö', u'a'])
        self.assertRaises(Invalid, o.to_python, u"ä")

    def test_ascii_list(self):
        o = validators.OneOf(['a', 'b'])
        self.assertRaises(Invalid, o.to_python, 'c')

    def test_int_list_list(self):

        class foo(Schema):
            bar = validators.OneOf((1, 2, 3), testValueList=True)

        expected = {'bar': (1, 2, 3)}
        value = foo.to_python(expected)

        self.assertEqual(expected, value)


class TestIPAddressValidator(unittest.TestCase):

    def setUp(self):
        self.validator = validators.IPAddress

    def test_valid_address(self):
        self.validator().to_python('127.0.0.1')

    def test_address_is_none(self):
        self.assertRaises(Invalid, self.validator()._validate_python, None)

    def test_invalid_address(self):
        validate = self.validator().to_python
        self.assertRaises(Invalid, validate, '127.0.1')
        self.assertRaises(Invalid, validate, '271.0.0.1')
        self.assertRaises(Invalid, validate, '127.0.0.0.1')

    def test_leading_zeros(self):
        validate = self.validator().to_python
        try:
            validate('1.2.3.037')
        except Invalid as e:
            self.assertTrue('The octets must not have leading zeros' in str(e))
        else:
            self.fail('IP address octets with leading zeros should be invalid')
        try:
            validate('1.2.3.0377')
        except Invalid as e:
            self.assertTrue('The octets must not have leading zeros' in str(e))
        else:
            self.fail('IP octets with leading zeros should be invalid')

    def test_leading_zeros_allowed(self):
        validate = self.validator(leading_zeros=True).to_python
        try:
            validate('1.2.3.037')
        except Invalid as e:
            self.fail('IP address octets with leading zeros should be valid')
        try:
            validate('1.2.3.0377')
        except Invalid as e:
            self.assertTrue("The octets must be within the range of 0-255"
                " (not '377')" in str(e))
        else:
            self.fail(
                'IP address octets should not be interpreted as octal numbers')


class TestURLValidator(unittest.TestCase):

    def setUp(self):
        self.validator = validators.URL()

    def test_cojp(self):
        self.assertEqual(self.validator.to_python('http://domain.co.jp'),
                         'http://domain.co.jp')

    def test_1char_thirdlevel(self):
        self.assertEqual(self.validator.to_python(
            'http://c.somewhere.pl/wi16677/5050f81b001f9e5f45902c1b/'),
            'http://c.somewhere.pl/wi16677/5050f81b001f9e5f45902c1b/')

    def test_ip_validator(self):
        self.assertEqual(validators.URL(require_tld=False).to_python(
            "http://65.18.195.155/cgi-ordoro/bo/start.cgi"),
            "http://65.18.195.155/cgi-ordoro/bo/start.cgi")


class TestRequireIfMissingValidator(unittest.TestCase):

    def setUp(self):
        self.validator = validators.RequireIfMissing

    def test_missing(self):
        v = self.validator('phone_type', missing='mail')
        self.assertEqual(
            validate(v, dict(phone_type='')),
            dict(phone_type=u'Please enter a value'))
        self.assertEqual(
            validate(v, dict(phone_type='', mail='foo@bar.org')),
            dict(phone_type='', mail='foo@bar.org'))

    def test_present(self):
        v = self.validator('phone_type', present='phone')
        self.assertEqual(
            validate(v, dict(phone_type='', phone='510 420  4577')),
            dict(phone_type=u'Please enter a value'))
        self.assertEqual(
            validate(v, dict(phone='')), dict(phone=''))

    def test_zero(self):
        v = self.validator('operator', present='operand')
        self.assertEqual(
            validate(v, dict(operator='', operand=0)),
            dict(operator=u'Please enter a value'))


class TestCondfirmType(unittest.TestCase):

    def test_schema_dict(self):
        class foo(Schema):
            bar = validators.ConfirmType(subclass=(dict,))

        validator = foo()
        value = {'bar': {}}
        self.assertEqual(value, validator.to_python(value))

        self.assertRaises(validators.Invalid, validator.to_python, ({'bar': 1},))

    def test_schema_int(self):
        class foo(Schema):
            bar = validators.ConfirmType(subclass=(int,))

        validator = foo()
        value = {'bar': 1}
        self.assertEqual(value, validator.to_python(value))

        self.assertRaises(validators.Invalid, validator.to_python, ({'bar': {}},))

########NEW FILE########
__FILENAME__ = test_variabledecode
import unittest

from formencode.variabledecode import variable_decode, variable_encode


class TestVariableDecode(unittest.TestCase):

    def test_list_decode(self):
        src = {'a-0': 'a', 'a-1': 'b', 'a-2': 'c'}
        expect = {'a': ['a', 'b', 'c']}

        self.assertEqual(expect, variable_decode(src))

    def test_list_decode_non_int(self):
        src = {'a-0': 'a', 'a-a': 'b', 'a-2': 'c'}
        expect = {'a': ['a', 'c'], 'a-a': 'b'}

        self.assertEqual(expect, variable_decode(src))

    def test_list_decode_double_dash(self):
        src = {'a-0': 'a', 'a-1-2': 'b', 'a-3': 'c'}
        expect = {'a': ['a', 'c'], 'a-1-2': 'b'}

        self.assertEqual(expect, variable_decode(src))

    def test_list_decode_non_int_nested(self):
        src = {'a-0.name': 'a', 'a-a.name': 'b', 'a-2.name': 'c'}
        expect = {'a': [{'name': 'a'}, {'name': 'c'}], 'a-a': {'name': 'b'}}

        self.assertEqual(expect, variable_decode(src))

    def test_dict_decode(self):
        src = {'a.a': 'a', 'a.b': 'b', 'a.c': 'c'}
        expect = {'a': {'a': 'a', 'b': 'b', 'c': 'c'}}

        self.assertEqual(expect, variable_decode(src))

    def test_list_dict(self):
        src = {'a-0.name': 'a', 'a-1.name': 'b', 'a-2.name': 'c'}
        expect = {'a': [{'name': 'a'}, {'name': 'b'}, {'name': 'c'}]}

        self.assertEqual(expect, variable_decode(src))

    def test_dict_list_dict(self):
        src = {'a.b-0.name': 'a', 'a.b-1.name': 'b', 'a.b-2.name': 'c'}
        expect = {'a': {'b': [{'name': 'a'}, {'name': 'b'}, {'name': 'c'}]}}

        self.assertEqual(expect, variable_decode(src))


class TestVariableEncode(unittest.TestCase):

    def test_list_encode(self):
        src = {'a': ['a', 'b', 'c']}
        expect = {'a--repetitions': '3', 'a-0': 'a', 'a-1': 'b', 'a-2': 'c'}

        self.assertEqual(expect, variable_encode(src))

    def test_list_encode_non_int(self):
        src = {'a': ['a', 'c'], 'a-a': 'b'}
        expect = {'a--repetitions': '2', 'a-0': 'a', 'a-a': 'b', 'a-1': 'c'}

        self.assertEqual(expect, variable_encode(src))

    def test_dict_encode(self):
        src = {'a': {'a': 'a', 'b': 'b', 'c': 'c'}}
        expect = {'a.a': 'a', 'a.b': 'b', 'a.c': 'c'}

        self.assertEqual(expect, variable_encode(src))

########NEW FILE########
__FILENAME__ = validators
## FormEncode, a  Form processor
## Copyright (C) 2003, Ian Bicking <ianb@colorstudy.com>

"""
Validator/Converters for use with FormEncode.
"""

import cgi
import locale
import re
import warnings
from encodings import idna

try:  # import dnspython
    import dns.resolver
    import dns.exception
except (IOError, ImportError):
    have_dns = False
else:
    have_dns = True


# These are only imported when needed
httplib = None
random = None
sha1 = None
socket = None
urlparse = None

from .api import (FancyValidator, Identity, Invalid, NoDefault, Validator,
    deprecation_warning, is_empty)

assert Identity and Invalid and NoDefault  # silence unused import warnings

# Dummy i18n translation function, nothing is translated here.
# Instead this is actually done in api.message.
# The surrounding _('string') of the strings is only for extracting
# the strings automatically.
# If you run pygettext with this source comment this function out temporarily.
_ = lambda s: s


############################################################
## Utility methods
############################################################

# These all deal with accepting both datetime and mxDateTime modules and types
datetime_module = None
mxDateTime_module = None


def import_datetime(module_type):
    global datetime_module, mxDateTime_module
    module_type = module_type.lower() if module_type else 'datetime'
    if module_type == 'datetime':
        if datetime_module is None:
            import datetime as datetime_module
        return datetime_module
    elif module_type == 'mxdatetime':
        if mxDateTime_module is None:
            from mx import DateTime as mxDateTime_module
        return mxDateTime_module
    else:
        raise ImportError('Invalid datetime module %r' % module_type)


def datetime_now(module):
    if module.__name__ == 'datetime':
        return module.datetime.now()
    else:
        return module.now()


def datetime_makedate(module, year, month, day):
    if module.__name__ == 'datetime':
        return module.date(year, month, day)
    else:
        try:
            return module.DateTime(year, month, day)
        except module.RangeError as e:
            raise ValueError(str(e))


def datetime_time(module):
    if module.__name__ == 'datetime':
        return module.time
    else:
        return module.Time


def datetime_isotime(module):
    if module.__name__ == 'datetime':
        return module.time.isoformat
    else:
        return module.ISO.Time


############################################################
## Wrapper Validators
############################################################

class ConfirmType(FancyValidator):
    """
    Confirms that the input/output is of the proper type.

    Uses the parameters:

    subclass:
        The class or a tuple of classes; the item must be an instance
        of the class or a subclass.
    type:
        A type or tuple of types (or classes); the item must be of
        the exact class or type.  Subclasses are not allowed.

    Examples::

        >>> cint = ConfirmType(subclass=int)
        >>> cint.to_python(True)
        True
        >>> cint.to_python('1')
        Traceback (most recent call last):
            ...
        Invalid: '1' is not a subclass of <type 'int'>
        >>> cintfloat = ConfirmType(subclass=(float, int))
        >>> cintfloat.to_python(1.0), cintfloat.from_python(1.0)
        (1.0, 1.0)
        >>> cintfloat.to_python(1), cintfloat.from_python(1)
        (1, 1)
        >>> cintfloat.to_python(None)
        Traceback (most recent call last):
            ...
        Invalid: None is not a subclass of one of the types <type 'float'>, <type 'int'>
        >>> cint2 = ConfirmType(type=int)
        >>> cint2(accept_python=False).from_python(True)
        Traceback (most recent call last):
            ...
        Invalid: True must be of the type <type 'int'>
    """

    accept_iterator = True

    subclass = None
    type = None

    messages = dict(
        subclass=_('%(object)r is not a subclass of %(subclass)s'),
        inSubclass=_('%(object)r is not a subclass of one of the types %(subclassList)s'),
        inType=_('%(object)r must be one of the types %(typeList)s'),
        type=_('%(object)r must be of the type %(type)s'))

    def __init__(self, *args, **kw):
        FancyValidator.__init__(self, *args, **kw)
        if self.subclass:
            if isinstance(self.subclass, list):
                self.subclass = tuple(self.subclass)
            elif not isinstance(self.subclass, tuple):
                self.subclass = (self.subclass,)
            self._validate_python = self.confirm_subclass
        if self.type:
            if isinstance(self.type, list):
                self.type = tuple(self.type)
            elif not isinstance(self.type, tuple):
                self.type = (self.type,)
            self._validate_python = self.confirm_type

    def confirm_subclass(self, value, state):
        if not isinstance(value, self.subclass):
            if len(self.subclass) == 1:
                msg = self.message('subclass', state, object=value,
                                   subclass=self.subclass[0])
            else:
                subclass_list = ', '.join(map(str, self.subclass))
                msg = self.message('inSubclass', state, object=value,
                                   subclassList=subclass_list)
            raise Invalid(msg, value, state)

    def confirm_type(self, value, state):
        for t in self.type:
            if type(value) is t:
                break
        else:
            if len(self.type) == 1:
                msg = self.message('type', state, object=value,
                                   type=self.type[0])
            else:
                msg = self.message('inType', state, object=value,
                                   typeList=', '.join(map(str, self.type)))
            raise Invalid(msg, value, state)
        return value

    def is_empty(self, value):
        return False


class Wrapper(FancyValidator):
    """
    Used to convert functions to validator/converters.

    You can give a simple function for `_convert_to_python`,
    `_convert_from_python`, `_validate_python` or `_validate_other`.
    If that function raises an exception, the value is considered invalid.
    Whatever value the function returns is considered the converted value.

    Unlike validators, the `state` argument is not used.  Functions
    like `int` can be used here, that take a single argument.

    Note that as Wrapper will generate a FancyValidator, empty
    values (those who pass ``FancyValidator.is_empty)`` will return ``None``.
    To override this behavior you can use ``Wrapper(empty_value=callable)``.
    For example passing ``Wrapper(empty_value=lambda val: val)`` will return
    the value itself when is considered empty.

    Examples::

        >>> def downcase(v):
        ...     return v.lower()
        >>> wrap = Wrapper(convert_to_python=downcase)
        >>> wrap.to_python('This')
        'this'
        >>> wrap.from_python('This')
        'This'
        >>> wrap.to_python('') is None
        True
        >>> wrap2 = Wrapper(
        ...     convert_from_python=downcase, empty_value=lambda value: value)
        >>> wrap2.from_python('This')
        'this'
        >>> wrap2.to_python('')
        ''
        >>> wrap2.from_python(1)
        Traceback (most recent call last):
          ...
        Invalid: 'int' object has no attribute 'lower'
        >>> wrap3 = Wrapper(validate_python=int)
        >>> wrap3.to_python('1')
        '1'
        >>> wrap3.to_python('a') # doctest: +ELLIPSIS
        Traceback (most recent call last):
          ...
        Invalid: invalid literal for int()...
    """

    func_convert_to_python = None
    func_convert_from_python = None
    func_validate_python = None
    func_validate_other = None

    _deprecated_methods = (
        ('func_to_python', 'func_convert_to_python'),
        ('func_from_python', 'func_convert_from_python'))

    def __init__(self, *args, **kw):
        # allow old method names as parameters
        if 'to_python' in kw and 'convert_to_python' not in kw:
            kw['convert_to_python'] = kw.pop('to_python')
        if 'from_python' in kw and 'convert_from_python' not in kw:
            kw['convert_from_python'] = kw.pop('from_python')
        for n in ('convert_to_python', 'convert_from_python',
                  'validate_python', 'validate_other'):
            if n in kw:
                kw['func_%s' % n] = kw.pop(n)
        FancyValidator.__init__(self, *args, **kw)
        self._convert_to_python = self.wrap(self.func_convert_to_python)
        self._convert_from_python = self.wrap(self.func_convert_from_python)
        self._validate_python = self.wrap(self.func_validate_python)
        self._validate_other = self.wrap(self.func_validate_other)

    def wrap(self, func):
        if not func:
            return None

        def result(value, state, func=func):
            try:
                return func(value)
            except Exception as e:
                raise Invalid(str(e), value, state)

        return result


class Constant(FancyValidator):
    """
    This converter converts everything to the same thing.

    I.e., you pass in the constant value when initializing, then all
    values get converted to that constant value.

    This is only really useful for funny situations, like::

      # Any evaluates sub validators in reverse order for to_python
      fromEmailValidator = Any(
                            Constant('unknown@localhost'),
                               Email())

    In this case, the if the email is not valid
    ``'unknown@localhost'`` will be used instead.  Of course, you
    could use ``if_invalid`` instead.

    Examples::

        >>> Constant('X').to_python('y')
        'X'
    """

    __unpackargs__ = ('value',)

    def _convert_to_python(self, value, state):
        return self.value

    _convert_from_python = _convert_to_python


############################################################
## Normal validators
############################################################

class MaxLength(FancyValidator):
    """
    Invalid if the value is longer than `maxLength`.  Uses len(),
    so it can work for strings, lists, or anything with length.

    Examples::

        >>> max5 = MaxLength(5)
        >>> max5.to_python('12345')
        '12345'
        >>> max5.from_python('12345')
        '12345'
        >>> max5.to_python('123456')
        Traceback (most recent call last):
          ...
        Invalid: Enter a value less than 5 characters long
        >>> max5(accept_python=False).from_python('123456')
        Traceback (most recent call last):
          ...
        Invalid: Enter a value less than 5 characters long
        >>> max5.to_python([1, 2, 3])
        [1, 2, 3]
        >>> max5.to_python([1, 2, 3, 4, 5, 6])
        Traceback (most recent call last):
          ...
        Invalid: Enter a value less than 5 characters long
        >>> max5.to_python(5)
        Traceback (most recent call last):
          ...
        Invalid: Invalid value (value with length expected)
    """

    __unpackargs__ = ('maxLength',)

    messages = dict(
        tooLong=_('Enter a value less than %(maxLength)i characters long'),
        invalid=_('Invalid value (value with length expected)'))

    def _validate_python(self, value, state):
        try:
            if value and len(value) > self.maxLength:
                raise Invalid(
                    self.message('tooLong', state,
                        maxLength=self.maxLength), value, state)
            else:
                return None
        except TypeError:
            raise Invalid(
                self.message('invalid', state), value, state)


class MinLength(FancyValidator):
    """
    Invalid if the value is shorter than `minlength`.  Uses len(), so
    it can work for strings, lists, or anything with length.  Note
    that you **must** use ``not_empty=True`` if you don't want to
    accept empty values -- empty values are not tested for length.

    Examples::

        >>> min5 = MinLength(5)
        >>> min5.to_python('12345')
        '12345'
        >>> min5.from_python('12345')
        '12345'
        >>> min5.to_python('1234')
        Traceback (most recent call last):
          ...
        Invalid: Enter a value at least 5 characters long
        >>> min5(accept_python=False).from_python('1234')
        Traceback (most recent call last):
          ...
        Invalid: Enter a value at least 5 characters long
        >>> min5.to_python([1, 2, 3, 4, 5])
        [1, 2, 3, 4, 5]
        >>> min5.to_python([1, 2, 3])
        Traceback (most recent call last):
          ...
        Invalid: Enter a value at least 5 characters long
        >>> min5.to_python(5)
        Traceback (most recent call last):
          ...
        Invalid: Invalid value (value with length expected)

    """

    __unpackargs__ = ('minLength',)

    messages = dict(
        tooShort=_('Enter a value at least %(minLength)i characters long'),
        invalid=_('Invalid value (value with length expected)'))

    def _validate_python(self, value, state):
        try:
            if len(value) < self.minLength:
                raise Invalid(
                    self.message('tooShort', state,
                        minLength=self.minLength), value, state)
        except TypeError:
            raise Invalid(
                self.message('invalid', state), value, state)


class NotEmpty(FancyValidator):
    """
    Invalid if value is empty (empty string, empty list, etc).

    Generally for objects that Python considers false, except zero
    which is not considered invalid.

    Examples::

        >>> ne = NotEmpty(messages=dict(empty='enter something'))
        >>> ne.to_python('')
        Traceback (most recent call last):
          ...
        Invalid: enter something
        >>> ne.to_python(0)
        0
    """
    not_empty = True

    messages = dict(
        empty=_('Please enter a value'))

    def _validate_python(self, value, state):
        if value == 0:
            # This isn't "empty" for this definition.
            return value
        if not value:
            raise Invalid(self.message('empty', state), value, state)


class Empty(FancyValidator):
    """
    Invalid unless the value is empty.  Use cleverly, if at all.

    Examples::

        >>> Empty.to_python(0)
        Traceback (most recent call last):
          ...
        Invalid: You cannot enter a value here
    """

    messages = dict(
        notEmpty=_('You cannot enter a value here'))

    def _validate_python(self, value, state):
        if value or value == 0:
            raise Invalid(self.message('notEmpty', state), value, state)


class Regex(FancyValidator):
    """
    Invalid if the value doesn't match the regular expression `regex`.

    The regular expression can be a compiled re object, or a string
    which will be compiled for you.

    Use strip=True if you want to strip the value before validation,
    and as a form of conversion (often useful).

    Examples::

        >>> cap = Regex(r'^[A-Z]+$')
        >>> cap.to_python('ABC')
        'ABC'

    Note that ``.from_python()`` calls (in general) do not validate
    the input::

        >>> cap.from_python('abc')
        'abc'
        >>> cap(accept_python=False).from_python('abc')
        Traceback (most recent call last):
          ...
        Invalid: The input is not valid
        >>> cap.to_python(1)
        Traceback (most recent call last):
          ...
        Invalid: The input must be a string (not a <type 'int'>: 1)
        >>> Regex(r'^[A-Z]+$', strip=True).to_python('  ABC  ')
        'ABC'
        >>> Regex(r'this', regexOps=('I',)).to_python('THIS')
        'THIS'
    """

    regexOps = ()
    strip = False
    regex = None

    __unpackargs__ = ('regex',)

    messages = dict(
        invalid=_('The input is not valid'))

    def __init__(self, *args, **kw):
        FancyValidator.__init__(self, *args, **kw)
        if isinstance(self.regex, basestring):
            ops = 0
            assert not isinstance(self.regexOps, basestring), (
                "regexOps should be a list of options from the re module "
                "(names, or actual values)")
            for op in self.regexOps:
                if isinstance(op, basestring):
                    ops |= getattr(re, op)
                else:
                    ops |= op
            self.regex = re.compile(self.regex, ops)

    def _validate_python(self, value, state):
        self.assert_string(value, state)
        if self.strip and isinstance(value, basestring):
            value = value.strip()
        if not self.regex.search(value):
            raise Invalid(self.message('invalid', state), value, state)

    def _convert_to_python(self, value, state):
        if self.strip and isinstance(value, basestring):
            return value.strip()
        return value


class PlainText(Regex):
    """
    Test that the field contains only letters, numbers, underscore,
    and the hyphen.  Subclasses Regex.

    Examples::

        >>> PlainText.to_python('_this9_')
        '_this9_'
        >>> PlainText.from_python('  this  ')
        '  this  '
        >>> PlainText(accept_python=False).from_python('  this  ')
        Traceback (most recent call last):
          ...
        Invalid: Enter only letters, numbers, or _ (underscore)
        >>> PlainText(strip=True).to_python('  this  ')
        'this'
        >>> PlainText(strip=True).from_python('  this  ')
        'this'
    """

    regex = r"^[a-zA-Z_\-0-9]*$"

    messages = dict(
        invalid=_('Enter only letters, numbers, or _ (underscore)'))


class OneOf(FancyValidator):
    """
    Tests that the value is one of the members of a given list.

    If ``testValueList=True``, then if the input value is a list or
    tuple, all the members of the sequence will be checked (i.e., the
    input must be a subset of the allowed values).

    Use ``hideList=True`` to keep the list of valid values out of the
    error message in exceptions.

    Examples::

        >>> oneof = OneOf([1, 2, 3])
        >>> oneof.to_python(1)
        1
        >>> oneof.to_python(4)
        Traceback (most recent call last):
          ...
        Invalid: Value must be one of: 1; 2; 3 (not 4)
        >>> oneof(testValueList=True).to_python([2, 3, [1, 2, 3]])
        [2, 3, [1, 2, 3]]
        >>> oneof.to_python([2, 3, [1, 2, 3]])
        Traceback (most recent call last):
          ...
        Invalid: Value must be one of: 1; 2; 3 (not [2, 3, [1, 2, 3]])
    """

    list = None
    testValueList = False
    hideList = False

    __unpackargs__ = ('list',)

    messages = dict(
        invalid=_('Invalid value'),
        notIn=_('Value must be one of: %(items)s (not %(value)r)'))

    def _validate_python(self, value, state):
        if self.testValueList and isinstance(value, (list, tuple)):
            for v in value:
                self._validate_python(v, state)
        else:
            if not value in self.list:
                if self.hideList:
                    raise Invalid(self.message('invalid', state), value, state)
                else:
                    try:
                        items = '; '.join(map(str, self.list))
                    except UnicodeError:
                        items = '; '.join(map(unicode, self.list))
                    raise Invalid(
                        self.message('notIn', state,
                            items=items, value=value), value, state)

    @property
    def accept_iterator(self):
        return self.testValueList


class DictConverter(FancyValidator):
    """
    Converts values based on a dictionary which has values as keys for
    the resultant values.

    If ``allowNull`` is passed, it will not balk if a false value
    (e.g., '' or None) is given (it will return None in these cases).

    to_python takes keys and gives values, from_python takes values and
    gives keys.

    If you give hideDict=True, then the contents of the dictionary
    will not show up in error messages.

    Examples::

        >>> dc = DictConverter({1: 'one', 2: 'two'})
        >>> dc.to_python(1)
        'one'
        >>> dc.from_python('one')
        1
        >>> dc.to_python(3)
        Traceback (most recent call last):
            ....
        Invalid: Enter a value from: 1; 2
        >>> dc2 = dc(hideDict=True)
        >>> dc2.hideDict
        True
        >>> dc2.dict
        {1: 'one', 2: 'two'}
        >>> dc2.to_python(3)
        Traceback (most recent call last):
            ....
        Invalid: Choose something
        >>> dc.from_python('three')
        Traceback (most recent call last):
            ....
        Invalid: Nothing in my dictionary goes by the value 'three'.  Choose one of: 'one'; 'two'
    """

    messages = dict(
        keyNotFound=_('Choose something'),
        chooseKey=_('Enter a value from: %(items)s'),
        valueNotFound=_('That value is not known'),
        chooseValue=_('Nothing in my dictionary goes by the value %(value)s.'
            '  Choose one of: %(items)s'))

    dict = None
    hideDict = False

    __unpackargs__ = ('dict',)

    def _convert_to_python(self, value, state):
        try:
            return self.dict[value]
        except KeyError:
            if self.hideDict:
                raise Invalid(self.message('keyNotFound', state), value, state)
            else:
                items = sorted(self.dict)
                items = '; '.join(map(repr, items))
                raise Invalid(self.message('chooseKey',
                    state, items=items), value, state)

    def _convert_from_python(self, value, state):
        for k, v in self.dict.iteritems():
            if value == v:
                return k
        if self.hideDict:
            raise Invalid(self.message('valueNotFound', state), value, state)
        else:
            items = '; '.join(map(repr, self.dict.itervalues()))
            raise Invalid(
                self.message('chooseValue', state,
                    value=repr(value), items=items), value, state)


class IndexListConverter(FancyValidator):
    """
    Converts a index (which may be a string like '2') to the value in
    the given list.

    Examples::

        >>> index = IndexListConverter(['zero', 'one', 'two'])
        >>> index.to_python(0)
        'zero'
        >>> index.from_python('zero')
        0
        >>> index.to_python('1')
        'one'
        >>> index.to_python(5)
        Traceback (most recent call last):
        Invalid: Index out of range
        >>> index(not_empty=True).to_python(None)
        Traceback (most recent call last):
        Invalid: Please enter a value
        >>> index.from_python('five')
        Traceback (most recent call last):
        Invalid: Item 'five' was not found in the list
    """

    list = None

    __unpackargs__ = ('list',)

    messages = dict(
        integer=_('Must be an integer index'),
        outOfRange=_('Index out of range'),
        notFound=_('Item %(value)s was not found in the list'))

    def _convert_to_python(self, value, state):
        try:
            value = int(value)
        except (ValueError, TypeError):
            raise Invalid(self.message('integer', state), value, state)
        try:
            return self.list[value]
        except IndexError:
            raise Invalid(self.message('outOfRange', state), value, state)

    def _convert_from_python(self, value, state):
        for i, v in enumerate(self.list):
            if v == value:
                return i
        raise Invalid(
            self.message('notFound', state, value=repr(value)), value, state)


class DateValidator(FancyValidator):
    """
    Validates that a date is within the given range.  Be sure to call
    DateConverter first if you aren't expecting mxDateTime input.

    ``earliest_date`` and ``latest_date`` may be functions; if so,
    they will be called each time before validating.

    ``after_now`` means a time after the current timestamp; note that
    just a few milliseconds before now is invalid!  ``today_or_after``
    is more permissive, and ignores hours and minutes.

    Examples::

        >>> from datetime import datetime, timedelta
        >>> d = DateValidator(earliest_date=datetime(2003, 1, 1))
        >>> d.to_python(datetime(2004, 1, 1))
        datetime.datetime(2004, 1, 1, 0, 0)
        >>> d.to_python(datetime(2002, 1, 1))
        Traceback (most recent call last):
            ...
        Invalid: Date must be after Wednesday, 01 January 2003
        >>> d.to_python(datetime(2003, 1, 1))
        datetime.datetime(2003, 1, 1, 0, 0)
        >>> d = DateValidator(after_now=True)
        >>> now = datetime.now()
        >>> d.to_python(now+timedelta(seconds=5)) == now+timedelta(seconds=5)
        True
        >>> d.to_python(now-timedelta(days=1))
        Traceback (most recent call last):
            ...
        Invalid: The date must be sometime in the future
        >>> d.to_python(now+timedelta(days=1)) > now
        True
        >>> d = DateValidator(today_or_after=True)
        >>> d.to_python(now) == now
        True

    """

    earliest_date = None
    latest_date = None
    after_now = False
    # Like after_now, but just after this morning:
    today_or_after = False
    # Use None or 'datetime' for the datetime module in the standard lib,
    # or 'mxDateTime' to force the mxDateTime module
    datetime_module = None

    messages = dict(
        after=_('Date must be after %(date)s'),
        before=_('Date must be before %(date)s'),
        # Double %'s, because this will be substituted twice:
        date_format=_('%%A, %%d %%B %%Y'),
        future=_('The date must be sometime in the future'))

    def _validate_python(self, value, state):
        date_format = self.message('date_format', state)
        if (str is not unicode  # Python 2
                and isinstance(date_format, unicode)):
            # strftime uses the locale encoding, not Unicode
            encoding = locale.getlocale(locale.LC_TIME)[1] or 'utf-8'
            date_format = date_format.encode(encoding)
        else:
            encoding = None
        if self.earliest_date:
            if callable(self.earliest_date):
                earliest_date = self.earliest_date()
            else:
                earliest_date = self.earliest_date
            if value < earliest_date:
                date_formatted = earliest_date.strftime(date_format)
                if encoding:
                    date_formatted = date_formatted.decode(encoding)
                raise Invalid(
                    self.message('after', state, date=date_formatted),
                    value, state)
        if self.latest_date:
            if callable(self.latest_date):
                latest_date = self.latest_date()
            else:
                latest_date = self.latest_date
            if value > latest_date:
                date_formatted = latest_date.strftime(date_format)
                if encoding:
                    date_formatted = date_formatted.decode(encoding)
                raise Invalid(
                    self.message('before', state, date=date_formatted),
                    value, state)
        if self.after_now:
            dt_mod = import_datetime(self.datetime_module)
            now = datetime_now(dt_mod)
            if value < now:
                date_formatted = now.strftime(date_format)
                if encoding:
                    date_formatted = date_formatted.decode(encoding)
                raise Invalid(
                    self.message('future', state, date=date_formatted),
                    value, state)
        if self.today_or_after:
            dt_mod = import_datetime(self.datetime_module)
            now = datetime_now(dt_mod)
            today = datetime_makedate(dt_mod,
                                      now.year, now.month, now.day)
            value_as_date = datetime_makedate(
                dt_mod, value.year, value.month, value.day)
            if value_as_date < today:
                date_formatted = now.strftime(date_format)
                if encoding:
                    date_formatted = date_formatted.decode(encoding)
                raise Invalid(
                    self.message('future', state, date=date_formatted),
                    value, state)


class Bool(FancyValidator):
    """
    Always Valid, returns True or False based on the value and the
    existance of the value.

    If you want to convert strings like ``'true'`` to booleans, then
    use ``StringBool``.

    Examples::

        >>> Bool.to_python(0)
        False
        >>> Bool.to_python(1)
        True
        >>> Bool.to_python('')
        False
        >>> Bool.to_python(None)
        False
    """

    if_missing = False

    def _convert_to_python(self, value, state):
        return bool(value)

    _convert_from_python = _convert_to_python

    def empty_value(self, value):
        return False


class RangeValidator(FancyValidator):
    """This is an abstract base class for Int and Number.

    It verifies that a value is within range.  It accepts min and max
    values in the constructor.

    (Since this is an abstract base class, the tests are in Int and Number.)

    """

    messages = dict(
        tooLow=_('Please enter a number that is %(min)s or greater'),
        tooHigh=_('Please enter a number that is %(max)s or smaller'))

    min = None
    max = None

    def _validate_python(self, value, state):
        if self.min is not None:
            if value < self.min:
                msg = self.message('tooLow', state, min=self.min)
                raise Invalid(msg, value, state)
        if self.max is not None:
            if value > self.max:
                msg = self.message('tooHigh', state, max=self.max)
                raise Invalid(msg, value, state)


class Int(RangeValidator):
    """Convert a value to an integer.

    Example::

        >>> Int.to_python('10')
        10
        >>> Int.to_python('ten')
        Traceback (most recent call last):
            ...
        Invalid: Please enter an integer value
        >>> Int(min=5).to_python('6')
        6
        >>> Int(max=10).to_python('11')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a number that is 10 or smaller

    """

    messages = dict(
        integer=_('Please enter an integer value'))

    def _convert_to_python(self, value, state):
        try:
            return int(value)
        except (ValueError, TypeError):
            raise Invalid(self.message('integer', state), value, state)

    _convert_from_python = _convert_to_python


class Number(RangeValidator):
    """Convert a value to a float or integer.

    Tries to convert it to an integer if no information is lost.

    Example::

        >>> Number.to_python('10')
        10
        >>> Number.to_python('10.5')
        10.5
        >>> Number.to_python('ten')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a number
        >>> Number.to_python([1.2])
        Traceback (most recent call last):
            ...
        Invalid: Please enter a number
        >>> Number(min=5).to_python('6.5')
        6.5
        >>> Number(max=10.5).to_python('11.5')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a number that is 10.5 or smaller

    """

    messages = dict(
        number=_('Please enter a number'))

    def _convert_to_python(self, value, state):
        try:
            value = float(value)
            try:
                int_value = int(value)
            except OverflowError:
                int_value = None
            if value == int_value:
                return int_value
            return value
        except (ValueError, TypeError):
            raise Invalid(self.message('number', state), value, state)


class ByteString(FancyValidator):
    """Convert to byte string, treating empty things as the empty string.

    Under Python 2.x you can also use the alias `String` for this validator.

    Also takes a `max` and `min` argument, and the string length must fall
    in that range.

    Also you may give an `encoding` argument, which will encode any unicode
    that is found.  Lists and tuples are joined with `list_joiner`
    (default ``', '``) in ``from_python``.

    ::

        >>> ByteString(min=2).to_python('a')
        Traceback (most recent call last):
            ...
        Invalid: Enter a value 2 characters long or more
        >>> ByteString(max=10).to_python('xxxxxxxxxxx')
        Traceback (most recent call last):
            ...
        Invalid: Enter a value not more than 10 characters long
        >>> ByteString().from_python(None)
        ''
        >>> ByteString().from_python([])
        ''
        >>> ByteString().to_python(None)
        ''
        >>> ByteString(min=3).to_python(None)
        Traceback (most recent call last):
            ...
        Invalid: Please enter a value
        >>> ByteString(min=1).to_python('')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a value

    """

    min = None
    max = None
    not_empty = None
    encoding = None
    list_joiner = ', '

    messages = dict(
        tooLong=_('Enter a value not more than %(max)i characters long'),
        tooShort=_('Enter a value %(min)i characters long or more'))

    def __initargs__(self, new_attrs):
        if self.not_empty is None and self.min:
            self.not_empty = True

    def _convert_to_python(self, value, state):
        if value is None:
            value = ''
        elif not isinstance(value, basestring):
            try:
                value = bytes(value)
            except UnicodeEncodeError:
                value = unicode(value)
        if self.encoding is not None and isinstance(value, unicode):
            value = value.encode(self.encoding)
        return value

    def _convert_from_python(self, value, state):
        if value is None:
            value = ''
        elif not isinstance(value, basestring):
            if isinstance(value, (list, tuple)):
                value = self.list_joiner.join(
                    self._convert_from_python(v, state) for v in value)
            try:
                value = str(value)
            except UnicodeEncodeError:
                value = unicode(value)
        if self.encoding is not None and isinstance(value, unicode):
            value = value.encode(self.encoding)
        if self.strip:
            value = value.strip()
        return value

    def _validate_other(self, value, state):
        if self.max is None and self.min is None:
            return
        if value is None:
            value = ''
        elif not isinstance(value, basestring):
            try:
                value = str(value)
            except UnicodeEncodeError:
                value = unicode(value)
        if self.max is not None and len(value) > self.max:
            raise Invalid(
                self.message('tooLong', state, max=self.max), value, state)
        if self.min is not None and len(value) < self.min:
            raise Invalid(
                self.message('tooShort', state, min=self.min), value, state)

    def empty_value(self, value):
        return ''


class UnicodeString(ByteString):
    """Convert things to unicode string.

    This is implemented as a specialization of the ByteString class.

    Under Python 3.x you can also use the alias `String` for this validator.

    In addition to the String arguments, an encoding argument is also
    accepted. By default the encoding will be utf-8. You can overwrite
    this using the encoding parameter. You can also set inputEncoding
    and outputEncoding differently. An inputEncoding of None means
    "do not decode", an outputEncoding of None means "do not encode".

    All converted strings are returned as Unicode strings.

    ::

        >>> UnicodeString().to_python(None)
        u''
        >>> UnicodeString().to_python([])
        u''
        >>> UnicodeString(encoding='utf-7').to_python('Ni Ni Ni')
        u'Ni Ni Ni'

    """
    encoding = 'utf-8'
    inputEncoding = NoDefault
    outputEncoding = NoDefault
    messages = dict(
        badEncoding=_('Invalid data or incorrect encoding'))

    def __init__(self, **kw):
        ByteString.__init__(self, **kw)
        if self.inputEncoding is NoDefault:
            self.inputEncoding = self.encoding
        if self.outputEncoding is NoDefault:
            self.outputEncoding = self.encoding

    def _convert_to_python(self, value, state):
        if not value:
            return u''
        if isinstance(value, unicode):
            return value
        if not isinstance(value, unicode):
            if hasattr(value, '__unicode__'):
                value = unicode(value)
                return value
            if not (unicode is str  # Python 3
                    and isinstance(value, bytes) and self.inputEncoding):
                value = str(value)
        if self.inputEncoding and not isinstance(value, unicode):
            try:
                value = unicode(value, self.inputEncoding)
            except UnicodeDecodeError:
                raise Invalid(self.message('badEncoding', state), value, state)
            except TypeError:
                raise Invalid(
                    self.message('badType', state,
                        type=type(value), value=value), value, state)
        return value

    def _convert_from_python(self, value, state):
        if not isinstance(value, unicode):
            if hasattr(value, '__unicode__'):
                value = unicode(value)
            else:
                value = str(value)
        if self.outputEncoding and isinstance(value, unicode):
            value = value.encode(self.outputEncoding)
        return value

    def empty_value(self, value):
        return u''


# Provide proper alias for native strings

String = UnicodeString if str is unicode else ByteString


class Set(FancyValidator):
    """
    This is for when you think you may return multiple values for a
    certain field.

    This way the result will always be a list, even if there's only
    one result.  It's equivalent to ForEach(convert_to_list=True).

    If you give ``use_set=True``, then it will return an actual
    ``set`` object.

    ::

       >>> Set.to_python(None)
       []
       >>> Set.to_python('this')
       ['this']
       >>> Set.to_python(('this', 'that'))
       ['this', 'that']
       >>> s = Set(use_set=True)
       >>> s.to_python(None)
       set([])
       >>> s.to_python('this')
       set(['this'])
       >>> s.to_python(('this',))
       set(['this'])
    """

    use_set = False

    if_missing = ()
    accept_iterator = True

    def _convert_to_python(self, value, state):
        if self.use_set:
            if isinstance(value, set):
                return value
            elif isinstance(value, (list, tuple)):
                return set(value)
            elif value is None:
                return set()
            else:
                return set([value])
        else:
            if isinstance(value, list):
                return value
            elif isinstance(value, set):
                return list(value)
            elif isinstance(value, tuple):
                return list(value)
            elif value is None:
                return []
            else:
                return [value]

    def empty_value(self, value):
        if self.use_set:
            return set()
        else:
            return []


class Email(FancyValidator):
    r"""
    Validate an email address.

    If you pass ``resolve_domain=True``, then it will try to resolve
    the domain name to make sure it's valid.  This takes longer, of
    course. You must have the `dnspython <http://www.dnspython.org/>`__ modules
    installed to look up DNS (MX and A) records.

    ::

        >>> e = Email()
        >>> e.to_python(' test@foo.com ')
        'test@foo.com'
        >>> e.to_python('test')
        Traceback (most recent call last):
            ...
        Invalid: An email address must contain a single @
        >>> e.to_python('test@foobar')
        Traceback (most recent call last):
            ...
        Invalid: The domain portion of the email address is invalid (the portion after the @: foobar)
        >>> e.to_python('test@foobar.com.5')
        Traceback (most recent call last):
            ...
        Invalid: The domain portion of the email address is invalid (the portion after the @: foobar.com.5)
        >>> e.to_python('test@foo..bar.com')
        Traceback (most recent call last):
            ...
        Invalid: The domain portion of the email address is invalid (the portion after the @: foo..bar.com)
        >>> e.to_python('test@.foo.bar.com')
        Traceback (most recent call last):
            ...
        Invalid: The domain portion of the email address is invalid (the portion after the @: .foo.bar.com)
        >>> e.to_python('nobody@xn--m7r7ml7t24h.com')
        'nobody@xn--m7r7ml7t24h.com'
        >>> e.to_python('o*reilly@test.com')
        'o*reilly@test.com'
        >>> e = Email(resolve_domain=True)
        >>> e.resolve_domain
        True
        >>> e.to_python('doesnotexist@colorstudy.com')
        'doesnotexist@colorstudy.com'
        >>> e.to_python('test@nyu.edu')
        'test@nyu.edu'
        >>> # NOTE: If you do not have dnspython installed this example won't work:
        >>> e.to_python('test@thisdomaindoesnotexistithinkforsure.com')
        Traceback (most recent call last):
            ...
        Invalid: The domain of the email address does not exist (the portion after the @: thisdomaindoesnotexistithinkforsure.com)
        >>> e.to_python(u'test@google.com')
        u'test@google.com'
        >>> e = Email(not_empty=False)
        >>> e.to_python('')

    """

    resolve_domain = False
    resolve_timeout = 10  # timeout in seconds when resolving domains

    usernameRE = re.compile(r"^[\w!#$%&'*+\-/=?^`{|}~.]+$")
    domainRE = re.compile(r'''
        ^(?:[a-z0-9][a-z0-9\-]{,62}\.)+        # subdomain
        (?:[a-z]{2,63}|xn--[a-z0-9\-]{2,59})$  # top level domain
    ''', re.I | re.VERBOSE)

    messages = dict(
        empty=_('Please enter an email address'),
        noAt=_('An email address must contain a single @'),
        badUsername=_('The username portion of the email address is invalid'
            ' (the portion before the @: %(username)s)'),
        socketError=_('An error occured when trying to connect to the server:'
            ' %(error)s'),
        badDomain=_('The domain portion of the email address is invalid'
            ' (the portion after the @: %(domain)s)'),
        domainDoesNotExist=_('The domain of the email address does not exist'
            ' (the portion after the @: %(domain)s)'))

    def __init__(self, *args, **kw):
        FancyValidator.__init__(self, *args, **kw)
        if self.resolve_domain:
            if not have_dns:
                warnings.warn(
                    "dnspython <http://www.dnspython.org/> is not installed on"
                    " your system (or the dns.resolver package cannot be found)."
                    " I cannot resolve domain names in addresses")
                raise ImportError("no module named dns.resolver")

    def _validate_python(self, value, state):
        if not value:
            raise Invalid(self.message('empty', state), value, state)
        value = value.strip()
        splitted = value.split('@', 1)
        try:
            username, domain = splitted
        except ValueError:
            raise Invalid(self.message('noAt', state), value, state)
        if not self.usernameRE.search(username):
            raise Invalid(
                self.message('badUsername', state, username=username),
                value, state)
        try:
            idna_domain = [idna.ToASCII(p) for p in domain.split('.')]
            if unicode is str:  # Python 3
                idna_domain = [p.decode('ascii') for p in idna_domain]
            idna_domain = '.'.join(idna_domain)
        except UnicodeError:
            # UnicodeError: label empty or too long
            # This exception might happen if we have an invalid domain name part 
            # (for example test@.foo.bar.com)
            raise Invalid(
                self.message('badDomain', state, domain=domain),
                value, state)
        if not self.domainRE.search(idna_domain):
            raise Invalid(
                self.message('badDomain', state, domain=domain),
                value, state)
        if self.resolve_domain:
            assert have_dns, "dnspython should be available"
            global socket
            if socket is None:
                import socket
            try:
                try:
                    dns.resolver.query(domain, 'MX')
                except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer) as e:
                    try:
                        dns.resolver.query(domain, 'A')
                    except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer) as e:
                        raise Invalid(
                            self.message('domainDoesNotExist',
                                state, domain=domain), value, state)
            except (socket.error, dns.exception.DNSException) as e:
                raise Invalid(
                    self.message('socketError', state, error=e), value, state)

    def _convert_to_python(self, value, state):
        return value.strip()


class URL(FancyValidator):
    """
    Validate a URL, either http://... or https://.  If check_exists
    is true, then we'll actually make a request for the page.

    If add_http is true, then if no scheme is present we'll add
    http://

    ::

        >>> u = URL(add_http=True)
        >>> u.to_python('foo.com')
        'http://foo.com'
        >>> u.to_python('http://hahaha.ha/bar.html')
        'http://hahaha.ha/bar.html'
        >>> u.to_python('http://xn--m7r7ml7t24h.com')
        'http://xn--m7r7ml7t24h.com'
        >>> u.to_python('http://xn--c1aay4a.xn--p1ai')
        'http://xn--c1aay4a.xn--p1ai'
        >>> u.to_python('http://foo.com/test?bar=baz&fleem=morx')
        'http://foo.com/test?bar=baz&fleem=morx'
        >>> u.to_python('http://foo.com/login?came_from=http%3A%2F%2Ffoo.com%2Ftest')
        'http://foo.com/login?came_from=http%3A%2F%2Ffoo.com%2Ftest'
        >>> u.to_python('http://foo.com:8000/test.html')
        'http://foo.com:8000/test.html'
        >>> u.to_python('http://foo.com/something\\nelse')
        Traceback (most recent call last):
            ...
        Invalid: That is not a valid URL
        >>> u.to_python('https://test.com')
        'https://test.com'
        >>> u.to_python('http://test')
        Traceback (most recent call last):
            ...
        Invalid: You must provide a full domain name (like test.com)
        >>> u.to_python('http://test..com')
        Traceback (most recent call last):
            ...
        Invalid: That is not a valid URL
        >>> u = URL(add_http=False, check_exists=True)
        >>> u.to_python('http://google.com')
        'http://google.com'
        >>> u.to_python('google.com')
        Traceback (most recent call last):
            ...
        Invalid: You must start your URL with http://, https://, etc
        >>> u.to_python('http://www.formencode.org/does/not/exist/page.html')
        Traceback (most recent call last):
            ...
        Invalid: The server responded that the page could not be found
        >>> u.to_python('http://this.domain.does.not.exist.example.org/test.html')
        ... # doctest: +ELLIPSIS
        Traceback (most recent call last):
            ...
        Invalid: An error occured when trying to connect to the server: ...

    If you want to allow addresses without a TLD (e.g., ``localhost``) you can do::

        >>> URL(require_tld=False).to_python('http://localhost')
        'http://localhost'

    By default, internationalized domain names (IDNA) in Unicode will be
    accepted and encoded to ASCII using Punycode (as described in RFC 3490).
    You may set allow_idna to False to change this behavior::

        >>> URL(allow_idna=True).to_python(
        ... u'http://\u0433\u0443\u0433\u043b.\u0440\u0444')
        'http://xn--c1aay4a.xn--p1ai'
        >>> URL(allow_idna=True, add_http=True).to_python(
        ... u'\u0433\u0443\u0433\u043b.\u0440\u0444')
        'http://xn--c1aay4a.xn--p1ai'
        >>> URL(allow_idna=False).to_python(
        ... u'http://\u0433\u0443\u0433\u043b.\u0440\u0444')
        Traceback (most recent call last):
        ...
        Invalid: That is not a valid URL

    """

    add_http = True
    allow_idna = True
    check_exists = False
    require_tld = True

    url_re = re.compile(r'''
        ^(http|https)://
        (?:[%:\w]*@)?                              # authenticator
        (?:                                        # ip or domain
        (?P<ip>(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))|
        (?P<domain>[a-z0-9][a-z0-9\-]{,62}\.)*     # subdomain
        (?P<tld>[a-z]{2,63}|xn--[a-z0-9\-]{2,59})  # top level domain
        )
        (?::[0-9]{1,5})?                           # port
        # files/delims/etc
        (?P<path>/[a-z0-9\-\._~:/\?#\[\]@!%\$&\'\(\)\*\+,;=]*)?
        $
    ''', re.I | re.VERBOSE)

    scheme_re = re.compile(r'^[a-zA-Z]+:')

    messages = dict(
        noScheme=_('You must start your URL with http://, https://, etc'),
        badURL=_('That is not a valid URL'),
        httpError=_('An error occurred when trying to access the URL:'
            ' %(error)s'),
        socketError=_('An error occured when trying to connect to the server:'
            ' %(error)s'),
        notFound=_('The server responded that the page could not be found'),
        status=_('The server responded with a bad status code (%(status)s)'),
        noTLD=_('You must provide a full domain name (like %(domain)s.com)'))

    def _convert_to_python(self, value, state):
        value = value.strip()
        if self.add_http:
            if not self.scheme_re.search(value):
                value = 'http://' + value
        if self.allow_idna:
            value = self._encode_idna(value)
        match = self.scheme_re.search(value)
        if not match:
            raise Invalid(self.message('noScheme', state), value, state)
        value = match.group(0).lower() + value[len(match.group(0)):]
        match = self.url_re.search(value)
        if not match:
            raise Invalid(self.message('badURL', state), value, state)
        if self.require_tld and not match.group('domain'):
            raise Invalid(
                self.message('noTLD', state, domain=match.group('tld')),
                value, state)
        if self.check_exists and value.startswith(('http://', 'https://')):
            self._check_url_exists(value, state)
        return value

    def _encode_idna(self, url):
        global urlparse
        if urlparse is None:
            import urlparse
        scheme, netloc, path, params, query, fragment = urlparse.urlparse(
            url)
        try:
            netloc = netloc.encode('idna')
            if unicode is str:  # Python 3
                netloc = netloc.decode('ascii')
            return str(urlparse.urlunparse((scheme, netloc,
                path, params, query, fragment)))
        except UnicodeError:
            return url

    def _check_url_exists(self, url, state):
        global httplib, urlparse, socket
        if httplib is None:
            import httplib
        if urlparse is None:
            import urlparse
        if socket is None:
            import socket
        scheme, netloc, path, params, query, fragment = urlparse.urlparse(
            url, 'http')
        if scheme == 'https':
            ConnClass = httplib.HTTPSConnection
        else:
            ConnClass = httplib.HTTPConnection
        try:
            conn = ConnClass(netloc)
            if params:
                path += ';' + params
            if query:
                path += '?' + query
            conn.request('HEAD', path)
            res = conn.getresponse()
        except httplib.HTTPException as e:
            raise Invalid(
                self.message('httpError', state, error=e), state, url)
        except socket.error as e:
            raise Invalid(
                self.message('socketError', state, error=e), state, url)
        else:
            if res.status == 404:
                raise Invalid(
                    self.message('notFound', state), state, url)
            if not 200 <= res.status < 500:
                raise Invalid(
                    self.message('status', state, status=res.status),
                    state, url)


class XRI(FancyValidator):
    r"""
    Validator for XRIs.

    It supports both i-names and i-numbers, of the first version of the XRI
    standard.

    ::

        >>> inames = XRI(xri_type="i-name")
        >>> inames.to_python("   =John.Smith ")
        '=John.Smith'
        >>> inames.to_python("@Free.Software.Foundation")
        '@Free.Software.Foundation'
        >>> inames.to_python("Python.Software.Foundation")
        Traceback (most recent call last):
            ...
        Invalid: The type of i-name is not defined; it may be either individual or organizational
        >>> inames.to_python("http://example.org")
        Traceback (most recent call last):
            ...
        Invalid: The type of i-name is not defined; it may be either individual or organizational
        >>> inames.to_python("=!2C43.1A9F.B6F6.E8E6")
        Traceback (most recent call last):
            ...
        Invalid: "!2C43.1A9F.B6F6.E8E6" is an invalid i-name
        >>> iname_with_schema = XRI(True, xri_type="i-name")
        >>> iname_with_schema.to_python("=Richard.Stallman")
        'xri://=Richard.Stallman'
        >>> inames.to_python("=John Smith")
        Traceback (most recent call last):
            ...
        Invalid: "John Smith" is an invalid i-name
        >>> inumbers = XRI(xri_type="i-number")
        >>> inumbers.to_python("!!1000!de21.4536.2cb2.8074")
        '!!1000!de21.4536.2cb2.8074'
        >>> inumbers.to_python("@!1000.9554.fabd.129c!2847.df3c")
        '@!1000.9554.fabd.129c!2847.df3c'

    """

    iname_valid_pattern = re.compile(r"""
    ^
    [\w]+                  # A global alphanumeric i-name
    (\.[\w]+)*             # An i-name with dots
    (\*[\w]+(\.[\w]+)*)*   # A community i-name
    $
    """, re.VERBOSE | re.UNICODE)

    iname_invalid_start = re.compile(r"^[\d\.-]", re.UNICODE)
    """@cvar: These characters must not be at the beggining of the i-name"""

    inumber_pattern = re.compile(r"""
    ^
    (
    [=@]!       # It's a personal or organization i-number
    |
    !!          # It's a network i-number
    )
    [\dA-F]{1,4}(\.[\dA-F]{1,4}){0,3}       # A global i-number
    (![\dA-F]{1,4}(\.[\dA-F]{1,4}){0,3})*   # Zero or more sub i-numbers
    $
    """, re.VERBOSE | re.IGNORECASE)

    messages = dict(
        noType=_('The type of i-name is not defined;'
            ' it may be either individual or organizational'),
        repeatedChar=_('Dots and dashes may not be repeated consecutively'),
        badIname=_('"%(iname)s" is an invalid i-name'),
        badInameStart=_('i-names may not start with numbers'
            ' nor punctuation marks'),
        badInumber=_('"%(inumber)s" is an invalid i-number'),
        badType=_('The XRI must be a string (not a %(type)s: %(value)r)'),
        badXri=_('"%(xri_type)s" is not a valid type of XRI'))

    def __init__(self, add_xri=False, xri_type="i-name", **kwargs):
        """Create an XRI validator.

        @param add_xri: Should the schema be added if not present?
            Officially it's optional.
        @type add_xri: C{bool}
        @param xri_type: What type of XRI should be validated?
            Possible values: C{i-name} or C{i-number}.
        @type xri_type: C{str}

        """
        self.add_xri = add_xri
        assert xri_type in ('i-name', 'i-number'), (
            'xri_type must be "i-name" or "i-number"')
        self.xri_type = xri_type
        super(XRI, self).__init__(**kwargs)

    def _convert_to_python(self, value, state):
        """Prepend the 'xri://' schema if needed and remove trailing spaces"""
        value = value.strip()
        if self.add_xri and not value.startswith('xri://'):
            value = 'xri://' + value
        return value

    def _validate_python(self, value, state=None):
        """Validate an XRI

        @raise Invalid: If at least one of the following conditions in met:
            - C{value} is not a string.
            - The XRI is not a personal, organizational or network one.
            - The relevant validator (i-name or i-number) considers the XRI
                is not valid.

        """
        if not isinstance(value, basestring):
            raise Invalid(
                self.message('badType', state,
                    type=str(type(value)), value=value), value, state)

        # Let's remove the schema, if any
        if value.startswith('xri://'):
            value = value[6:]

        if not value[0] in ('@', '=') and not (
                self.xri_type == 'i-number' and value[0] == '!'):
            raise Invalid(self.message('noType', state), value, state)

        if self.xri_type == 'i-name':
            self._validate_iname(value, state)
        else:
            self._validate_inumber(value, state)

    def _validate_iname(self, iname, state):
        """Validate an i-name"""
        # The type is not required here:
        iname = iname[1:]
        if '..' in iname or '--' in iname:
            raise Invalid(self.message('repeatedChar', state), iname, state)
        if self.iname_invalid_start.match(iname):
            raise Invalid(self.message('badInameStart', state), iname, state)
        if not self.iname_valid_pattern.match(iname) or '_' in iname:
            raise Invalid(
                self.message('badIname', state, iname=iname), iname, state)

    def _validate_inumber(self, inumber, state):
        """Validate an i-number"""
        if not self.__class__.inumber_pattern.match(inumber):
            raise Invalid(
                self.message('badInumber', state,
                    inumber=inumber, value=inumber), inumber, state)


class OpenId(FancyValidator):
    r"""
    OpenId validator.

    ::
        >>> v = OpenId(add_schema=True)
        >>> v.to_python(' example.net ')
        'http://example.net'
        >>> v.to_python('@TurboGears')
        'xri://@TurboGears'
        >>> w = OpenId(add_schema=False)
        >>> w.to_python(' example.net ')
        Traceback (most recent call last):
        ...
        Invalid: "example.net" is not a valid OpenId (it is neither an URL nor an XRI)
        >>> w.to_python('!!1000')
        '!!1000'
        >>> w.to_python('look@me.com')
        Traceback (most recent call last):
        ...
        Invalid: "look@me.com" is not a valid OpenId (it is neither an URL nor an XRI)

    """

    messages = dict(
        badId=_('"%(id)s" is not a valid OpenId'
            ' (it is neither an URL nor an XRI)'))

    def __init__(self, add_schema=False, **kwargs):
        """Create an OpenId validator.

        @param add_schema: Should the schema be added if not present?
        @type add_schema: C{bool}

        """
        self.url_validator = URL(add_http=add_schema)
        self.iname_validator = XRI(add_schema, xri_type="i-name")
        self.inumber_validator = XRI(add_schema, xri_type="i-number")

    def _convert_to_python(self, value, state):
        value = value.strip()
        try:
            return self.url_validator.to_python(value, state)
        except Invalid:
            try:
                return self.iname_validator.to_python(value, state)
            except Invalid:
                try:
                    return self.inumber_validator.to_python(value, state)
                except Invalid:
                    pass
        # It's not an OpenId!
        raise Invalid(self.message('badId', state, id=value), value, state)

    def _validate_python(self, value, state):
        self._convert_to_python(value, state)


def StateProvince(*kw, **kwargs):
    deprecation_warning("please use formencode.national.USStateProvince")
    from formencode.national import USStateProvince
    return USStateProvince(*kw, **kwargs)


def PhoneNumber(*kw, **kwargs):
    deprecation_warning("please use formencode.national.USPhoneNumber")
    from formencode.national import USPhoneNumber
    return USPhoneNumber(*kw, **kwargs)


def IPhoneNumberValidator(*kw, **kwargs):
    deprecation_warning(
        "please use formencode.national.InternationalPhoneNumber")
    from formencode.national import InternationalPhoneNumber
    return InternationalPhoneNumber(*kw, **kwargs)


class FieldStorageUploadConverter(FancyValidator):
    """
    Handles cgi.FieldStorage instances that are file uploads.

    This doesn't do any conversion, but it can detect empty upload
    fields (which appear like normal fields, but have no filename when
    no upload was given).
    """
    def _convert_to_python(self, value, state=None):
        if isinstance(value, cgi.FieldStorage):
            if getattr(value, 'filename', None):
                return value
            raise Invalid('invalid', value, state)
        else:
            return value

    def is_empty(self, value):
        if isinstance(value, cgi.FieldStorage):
            return not bool(getattr(value, 'filename', None))
        return FancyValidator.is_empty(self, value)


class FileUploadKeeper(FancyValidator):
    """
    Takes two inputs (a dictionary with keys ``static`` and
    ``upload``) and converts them into one value on the Python side (a
    dictionary with ``filename`` and ``content`` keys).  The upload
    takes priority over the static value.  The filename may be None if
    it can't be discovered.

    Handles uploads of both text and ``cgi.FieldStorage`` upload
    values.

    This is basically for use when you have an upload field, and you
    want to keep the upload around even if the rest of the form
    submission fails.  When converting *back* to the form submission,
    there may be extra values ``'original_filename'`` and
    ``'original_content'``, which may want to use in your form to show
    the user you still have their content around.

    To use this, make sure you are using variabledecode, then use
    something like::

      <input type="file" name="myfield.upload">
      <input type="hidden" name="myfield.static">

    Then in your scheme::

      class MyScheme(Scheme):
          myfield = FileUploadKeeper()

    Note that big file uploads mean big hidden fields, and lots of
    bytes passed back and forth in the case of an error.
    """

    upload_key = 'upload'
    static_key = 'static'

    def _convert_to_python(self, value, state):
        upload = value.get(self.upload_key)
        static = value.get(self.static_key, '').strip()
        filename = content = None
        if isinstance(upload, cgi.FieldStorage):
            filename = upload.filename
            content = upload.value
        elif isinstance(upload, basestring) and upload:
            filename = None
            # @@: Should this encode upload if it is unicode?
            content = upload
        if not content and static:
            filename, content = static.split(None, 1)
            filename = '' if filename == '-' else filename.decode('base64')
            content = content.decode('base64')
        return {'filename': filename, 'content': content}

    def _convert_from_python(self, value, state):
        filename = value.get('filename', '')
        content = value.get('content', '')
        if filename or content:
            result = self.pack_content(filename, content)
            return {self.upload_key: '',
                    self.static_key: result,
                    'original_filename': filename,
                    'original_content': content}
        else:
            return {self.upload_key: '',
                    self.static_key: ''}

    def pack_content(self, filename, content):
        enc_filename = self.base64encode(filename) or '-'
        enc_content = (content or '').encode('base64')
        result = '%s %s' % (enc_filename, enc_content)
        return result


class DateConverter(FancyValidator):
    """
    Validates and converts a string date, like mm/yy, dd/mm/yy,
    dd-mm-yy, etc.  Using ``month_style`` you can support
    ``'mm/dd/yyyy'`` or ``'dd/mm/yyyy'``.  Only these two general
    styles are supported.

    Accepts English month names, also abbreviated.  Returns value as a
    datetime object (you can get mx.DateTime objects if you use
    ``datetime_module='mxDateTime'``).  Two year dates are assumed to
    be within 1950-2020, with dates from 21-49 being ambiguous and
    signaling an error.

    Use accept_day=False if you just want a month/year (like for a
    credit card expiration date).

    ::

        >>> d = DateConverter()
        >>> d.to_python('12/3/09')
        datetime.date(2009, 12, 3)
        >>> d.to_python('12/3/2009')
        datetime.date(2009, 12, 3)
        >>> d.to_python('2/30/04')
        Traceback (most recent call last):
            ...
        Invalid: That month only has 29 days
        >>> d.to_python('13/2/05')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a month from 1 to 12
        >>> d.to_python('1/1/200')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a four-digit year after 1899

    If you change ``month_style`` you can get European-style dates::

        >>> d = DateConverter(month_style='dd/mm/yyyy')
        >>> date = d.to_python('12/3/09')
        >>> date
        datetime.date(2009, 3, 12)
        >>> d.from_python(date)
        '12/03/2009'
    """

    # set to False if you want only month and year
    accept_day = True
    # allowed month styles: 'mdy' = 'us', 'dmy' = 'euro', 'ymd' = 'iso'
    # also allowed: 'mm/dd/yyyy', 'dd/mm/yyyy', 'yyyy/mm/dd'
    month_style = 'mdy'
    # preferred separator for reverse conversion: '/', '.' or '-'
    separator = '/'

    # Use 'datetime' to force the Python datetime module, or
    # 'mxDateTime' to force the mxDateTime module (None means use
    # datetime, or if not present mxDateTime)
    datetime_module = None

    _month_names = {
        'jan': 1, 'january': 1,
        'feb': 2, 'febuary': 2,
        'mar': 3, 'march': 3,
        'apr': 4, 'april': 4,
        'may': 5,
        'jun': 6, 'june': 6,
        'jul': 7, 'july': 7,
        'aug': 8, 'august': 8,
        'sep': 9, 'sept': 9, 'september': 9,
        'oct': 10, 'october': 10,
        'nov': 11, 'november': 11,
        'dec': 12, 'december': 12,
        }

    _date_re = dict(
        dmy=re.compile(
            r'^\s*(\d\d?)[\-\./\\](\d\d?|%s)[\-\./\\](\d\d\d?\d?)\s*$'
                % '|'.join(_month_names), re.I),
        mdy=re.compile(
            r'^\s*(\d\d?|%s)[\-\./\\](\d\d?)[\-\./\\](\d\d\d?\d?)\s*$'
                % '|'.join(_month_names), re.I),
        ymd=re.compile(
            r'^\s*(\d\d\d?\d?)[\-\./\\](\d\d?|%s)[\-\./\\](\d\d?)\s*$'
                % '|'.join(_month_names), re.I),
        my=re.compile(
            r'^\s*(\d\d?|%s)[\-\./\\](\d\d\d?\d?)\s*$'
                % '|'.join(_month_names), re.I),
        ym=re.compile(
            r'^\s*(\d\d\d?\d?)[\-\./\\](\d\d?|%s)\s*$'
                % '|'.join(_month_names), re.I))

    _formats = dict(d='%d', m='%m', y='%Y')

    _human_formats = dict(d=_('DD'), m=_('MM'), y=_('YYYY'))

    # Feb. should be leap-year aware (but mxDateTime does catch that)
    _monthDays = {
        1: 31, 2: 29, 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31,
        9: 30, 10: 31, 11: 30, 12: 31}

    messages = dict(
        badFormat=_('Please enter the date in the form %(format)s'),
        monthRange=_('Please enter a month from 1 to 12'),
        invalidDay=_('Please enter a valid day'),
        dayRange=_('That month only has %(days)i days'),
        invalidDate=_('That is not a valid day (%(exception)s)'),
        unknownMonthName=_('Unknown month name: %(month)s'),
        invalidYear=_('Please enter a number for the year'),
        fourDigitYear=_('Please enter a four-digit year after 1899'),
        wrongFormat=_('Please enter the date in the form %(format)s'))

    def __init__(self, *args, **kw):
        super(DateConverter, self).__init__(*args, **kw)
        month_style = (self.month_style or DateConverter.month_style).lower()
        accept_day = bool(self.accept_day)
        self.accept_day = self.accept_day
        if month_style in ('mdy',
                'md', 'mm/dd/yyyy', 'mm/dd', 'us', 'american'):
            month_style = 'mdy'
        elif month_style in ('dmy',
                'dm', 'dd/mm/yyyy', 'dd/mm', 'euro', 'european'):
            month_style = 'dmy'
        elif month_style in ('ymd',
                'ym', 'yyyy/mm/dd', 'yyyy/mm', 'iso', 'china', 'chinese'):
            month_style = 'ymd'
        else:
            raise TypeError('Bad month_style: %r' % month_style)
        self.month_style = month_style
        separator = self.separator
        if not separator or separator == 'auto':
            separator = dict(mdy='/', dmy='.', ymd='-')[month_style]
        elif separator not in ('-', '.', '/', '\\'):
            raise TypeError('Bad separator: %r' % separator)
        self.separator = separator
        self.format = separator.join(self._formats[part]
            for part in month_style if part != 'd' or accept_day)
        self.human_format = separator.join(self._human_formats[part]
            for part in month_style if part != 'd' or accept_day)

    def _convert_to_python(self, value, state):
        self.assert_string(value, state)
        month_style = self.month_style
        if not self.accept_day:
            month_style = 'ym' if month_style == 'ymd' else 'my'
        match = self._date_re[month_style].search(value)
        if not match:
            raise Invalid(
                self.message('badFormat', state,
                    format=self.human_format), value, state)
        groups = match.groups()
        if self.accept_day:
            if month_style == 'mdy':
                month, day, year = groups
            elif month_style == 'dmy':
                day, month, year = groups
            else:
                year, month, day = groups
            day = int(day)
            if not 1 <= day <= 31:
                raise Invalid(self.message('invalidDay', state), value, state)
        else:
            day = 1
            if month_style == 'my':
                month, year = groups
            else:
                year, month = groups
        month = self.make_month(month, state)
        if not 1 <= month <= 12:
            raise Invalid(self.message('monthRange', state), value, state)
        if self._monthDays[month] < day:
            raise Invalid(
                self.message('dayRange', state,
                    days=self._monthDays[month]), value, state)
        year = self.make_year(year, state)
        dt_mod = import_datetime(self.datetime_module)
        try:
            return datetime_makedate(dt_mod, year, month, day)
        except ValueError as v:
            raise Invalid(
                self.message('invalidDate', state,
                    exception=str(v)), value, state)

    def make_month(self, value, state):
        try:
            return int(value)
        except ValueError:
            try:
                return self._month_names[value.lower().strip()]
            except KeyError:
                raise Invalid(
                    self.message('unknownMonthName', state,
                        month=value), value, state)

    def make_year(self, year, state):
        try:
            year = int(year)
        except ValueError:
            raise Invalid(self.message('invalidYear', state), year, state)
        if year <= 20:
            year += 2000
        elif 50 <= year < 100:
            year += 1900
        if 20 < year < 50 or 99 < year < 1900:
            raise Invalid(self.message('fourDigitYear', state), year, state)
        return year

    def _convert_from_python(self, value, state):
        if self.if_empty is not NoDefault and not value:
            return ''
        return value.strftime(self.format)


class TimeConverter(FancyValidator):
    """
    Converts times in the format HH:MM:SSampm to (h, m, s).
    Seconds are optional.

    For ampm, set use_ampm = True.  For seconds, use_seconds = True.
    Use 'optional' for either of these to make them optional.

    Examples::

        >>> tim = TimeConverter()
        >>> tim.to_python('8:30')
        (8, 30)
        >>> tim.to_python('20:30')
        (20, 30)
        >>> tim.to_python('30:00')
        Traceback (most recent call last):
            ...
        Invalid: You must enter an hour in the range 0-23
        >>> tim.to_python('13:00pm')
        Traceback (most recent call last):
            ...
        Invalid: You must enter an hour in the range 1-12
        >>> tim.to_python('12:-1')
        Traceback (most recent call last):
            ...
        Invalid: You must enter a minute in the range 0-59
        >>> tim.to_python('12:02pm')
        (12, 2)
        >>> tim.to_python('12:02am')
        (0, 2)
        >>> tim.to_python('1:00PM')
        (13, 0)
        >>> tim.from_python((13, 0))
        '13:00:00'
        >>> tim2 = tim(use_ampm=True, use_seconds=False)
        >>> tim2.from_python((13, 0))
        '1:00pm'
        >>> tim2.from_python((0, 0))
        '12:00am'
        >>> tim2.from_python((12, 0))
        '12:00pm'

    Examples with ``datetime.time``::

        >>> v = TimeConverter(use_datetime=True)
        >>> a = v.to_python('18:00')
        >>> a
        datetime.time(18, 0)
        >>> b = v.to_python('30:00')
        Traceback (most recent call last):
            ...
        Invalid: You must enter an hour in the range 0-23
        >>> v2 = TimeConverter(prefer_ampm=True, use_datetime=True)
        >>> v2.from_python(a)
        '6:00:00pm'
        >>> v3 = TimeConverter(prefer_ampm=True,
        ...                    use_seconds=False, use_datetime=True)
        >>> a = v3.to_python('18:00')
        >>> a
        datetime.time(18, 0)
        >>> v3.from_python(a)
        '6:00pm'
        >>> a = v3.to_python('18:00:00')
        Traceback (most recent call last):
            ...
        Invalid: You may not enter seconds
    """

    use_ampm = 'optional'
    prefer_ampm = False
    use_seconds = 'optional'
    use_datetime = False
    # This can be set to make it prefer mxDateTime:
    datetime_module = None

    messages = dict(
        noAMPM=_('You must indicate AM or PM'),
        tooManyColon=_('There are too many :\'s'),
        noSeconds=_('You may not enter seconds'),
        secondsRequired=_('You must enter seconds'),
        minutesRequired=_('You must enter minutes (after a :)'),
        badNumber=_('The %(part)s value you gave is not a number: %(number)r'),
        badHour=_('You must enter an hour in the range %(range)s'),
        badMinute=_('You must enter a minute in the range 0-59'),
        badSecond=_('You must enter a second in the range 0-59'))

    def _convert_to_python(self, value, state):
        result = self._to_python_tuple(value, state)
        if self.use_datetime:
            dt_mod = import_datetime(self.datetime_module)
            time_class = datetime_time(dt_mod)
            return time_class(*result)
        else:
            return result

    def _to_python_tuple(self, value, state):
        time = value.strip()
        explicit_ampm = False
        if self.use_ampm:
            last_two = time[-2:].lower()
            if last_two not in ('am', 'pm'):
                if self.use_ampm != 'optional':
                    raise Invalid(self.message('noAMPM', state), value, state)
                offset = 0
            else:
                explicit_ampm = True
                offset = 12 if last_two == 'pm' else 0
                time = time[:-2]
        else:
            offset = 0
        parts = time.split(':', 3)
        if len(parts) > 3:
            raise Invalid(self.message('tooManyColon', state), value, state)
        if len(parts) == 3 and not self.use_seconds:
            raise Invalid(self.message('noSeconds', state), value, state)
        if (len(parts) == 2
                and self.use_seconds and self.use_seconds != 'optional'):
            raise Invalid(self.message('secondsRequired', state), value, state)
        if len(parts) == 1:
            raise Invalid(self.message('minutesRequired', state), value, state)
        try:
            hour = int(parts[0])
        except ValueError:
            raise Invalid(
                self.message('badNumber', state,
                    number=parts[0], part='hour'), value, state)
        if explicit_ampm:
            if not 1 <= hour <= 12:
                raise Invalid(
                    self.message('badHour', state,
                        number=hour, range='1-12'), value, state)
            if hour == 12 and offset == 12:
                # 12pm == 12
                pass
            elif hour == 12 and offset == 0:
                # 12am == 0
                hour = 0
            else:
                hour += offset
        else:
            if not 0 <= hour < 24:
                raise Invalid(
                    self.message('badHour', state,
                        number=hour, range='0-23'), value, state)
        try:
            minute = int(parts[1])
        except ValueError:
            raise Invalid(
                self.message('badNumber', state,
                    number=parts[1], part='minute'), value, state)
        if not 0 <= minute < 60:
            raise Invalid(
                self.message('badMinute', state, number=minute),
                value, state)
        if len(parts) == 3:
            try:
                second = int(parts[2])
            except ValueError:
                raise Invalid(
                    self.message('badNumber', state,
                        number=parts[2], part='second'), value, state)
            if not 0 <= second < 60:
                raise Invalid(
                    self.message('badSecond', state, number=second),
                    value, state)
        else:
            second = None
        if second is None:
            return (hour, minute)
        else:
            return (hour, minute, second)

    def _convert_from_python(self, value, state):
        if isinstance(value, basestring):
            return value
        if hasattr(value, 'hour'):
            hour, minute = value.hour, value.minute
            second = value.second
        elif len(value) == 3:
            hour, minute, second = value
        elif len(value) == 2:
            hour, minute = value
            second = 0
        ampm = ''
        if (self.use_ampm == 'optional' and self.prefer_ampm) or (
                self.use_ampm and self.use_ampm != 'optional'):
            ampm = 'am'
            if hour > 12:
                hour -= 12
                ampm = 'pm'
            elif hour == 12:
                ampm = 'pm'
            elif hour == 0:
                hour = 12
        if self.use_seconds:
            return '%i:%02i:%02i%s' % (hour, minute, second, ampm)
        else:
            return '%i:%02i%s' % (hour, minute, ampm)


def PostalCode(*kw, **kwargs):
    deprecation_warning("please use formencode.national.USPostalCode")
    from formencode.national import USPostalCode
    return USPostalCode(*kw, **kwargs)


class StripField(FancyValidator):
    """
    Take a field from a dictionary, removing the key from the dictionary.

    ``name`` is the key.  The field value and a new copy of the dictionary
    with that field removed are returned.

    >>> StripField('test').to_python({'a': 1, 'test': 2})
    (2, {'a': 1})
    >>> StripField('test').to_python({})
    Traceback (most recent call last):
        ...
    Invalid: The name 'test' is missing

    """

    __unpackargs__ = ('name',)

    messages = dict(
        missing=_('The name %(name)s is missing'))

    def _convert_to_python(self, valueDict, state):
        v = valueDict.copy()
        try:
            field = v.pop(self.name)
        except KeyError:
            raise Invalid(
                self.message('missing', state, name=repr(self.name)),
                valueDict, state)
        return field, v

    def is_empty(self, value):
        # empty dictionaries don't really apply here
        return False


class StringBool(FancyValidator):  # originally from TurboGears 1
    """
    Converts a string to a boolean.

    Values like 'true' and 'false' are considered True and False,
    respectively; anything in ``true_values`` is true, anything in
    ``false_values`` is false, case-insensitive).  The first item of
    those lists is considered the preferred form.

    ::

        >>> s = StringBool()
        >>> s.to_python('yes'), s.to_python('no')
        (True, False)
        >>> s.to_python(1), s.to_python('N')
        (True, False)
        >>> s.to_python('ye')
        Traceback (most recent call last):
            ...
        Invalid: Value should be 'true' or 'false'
    """

    true_values = ['true', 't', 'yes', 'y', 'on', '1']
    false_values = ['false', 'f', 'no', 'n', 'off', '0']

    messages = dict(
        string=_('Value should be %(true)r or %(false)r'))

    def _convert_to_python(self, value, state):
        if isinstance(value, basestring):
            value = value.strip().lower()
            if value in self.true_values:
                return True
            if not value or value in self.false_values:
                return False
            raise Invalid(
                self.message('string', state,
                    true=self.true_values[0], false=self.false_values[0]),
                value, state)
        return bool(value)

    def _convert_from_python(self, value, state):
        return (self.true_values if value else self.false_values)[0]

# Should deprecate:
StringBoolean = StringBool


class SignedString(FancyValidator):
    """
    Encodes a string into a signed string, and base64 encodes both the
    signature string and a random nonce.

    It is up to you to provide a secret, and to keep the secret handy
    and consistent.
    """

    messages = dict(
        malformed=_('Value does not contain a signature'),
        badsig=_('Signature is not correct'))

    secret = None
    nonce_length = 4

    def _convert_to_python(self, value, state):
        global sha1
        if not sha1:
            from hashlib import sha1
        assert self.secret is not None, "You must give a secret"
        parts = value.split(None, 1)
        if not parts or len(parts) == 1:
            raise Invalid(self.message('malformed', state), value, state)
        sig, rest = parts
        sig = sig.decode('base64')
        rest = rest.decode('base64')
        nonce = rest[:self.nonce_length]
        rest = rest[self.nonce_length:]
        expected = sha1(str(self.secret) + nonce + rest).digest()
        if expected != sig:
            raise Invalid(self.message('badsig', state), value, state)
        return rest

    def _convert_from_python(self, value, state):
        global sha1
        if not sha1:
            from hashlib import sha1
        nonce = self.make_nonce()
        value = str(value)
        digest = sha1(self.secret + nonce + value).digest()
        return self.encode(digest) + ' ' + self.encode(nonce + value)

    def encode(self, value):
        return value.encode('base64').strip().replace('\n', '')

    def make_nonce(self):
        global random
        if not random:
            import random
        return ''.join(chr(random.randrange(256))
            for _i in xrange(self.nonce_length))


class IPAddress(FancyValidator):
    """
    Formencode validator to check whether a string is a correct IP address.

    Examples::

        >>> ip = IPAddress()
        >>> ip.to_python('127.0.0.1')
        '127.0.0.1'
        >>> ip.to_python('299.0.0.1')
        Traceback (most recent call last):
            ...
        Invalid: The octets must be within the range of 0-255 (not '299')
        >>> ip.to_python('192.168.0.1/1')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a valid IP address (a.b.c.d)
        >>> ip.to_python('asdf')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a valid IP address (a.b.c.d)
    """

    messages = dict(
        badFormat=_('Please enter a valid IP address (a.b.c.d)'),
        leadingZeros=_('The octets must not have leading zeros'),
        illegalOctets=_('The octets must be within the range of 0-255'
            ' (not %(octet)r)'))

    leading_zeros = False

    def _validate_python(self, value, state=None):
        try:
            if not value:
                raise ValueError
            octets = value.split('.', 5)
            # Only 4 octets?
            if len(octets) != 4:
                raise ValueError
            # Correct octets?
            for octet in octets:
                if octet.startswith('0') and octet != '0':
                    if not self.leading_zeros:
                        raise Invalid(
                            self.message('leadingZeros', state), value, state)
                    # strip zeros so this won't be an octal number
                    octet = octet.lstrip('0')
                if not 0 <= int(octet) < 256:
                    raise Invalid(
                        self.message('illegalOctets', state, octet=octet),
                        value, state)
        # Splitting faild: wrong syntax
        except ValueError:
            raise Invalid(self.message('badFormat', state), value, state)


class CIDR(IPAddress):
    """
    Formencode validator to check whether a string is in correct CIDR
    notation (IP address, or IP address plus /mask).

    Examples::

        >>> cidr = CIDR()
        >>> cidr.to_python('127.0.0.1')
        '127.0.0.1'
        >>> cidr.to_python('299.0.0.1')
        Traceback (most recent call last):
            ...
        Invalid: The octets must be within the range of 0-255 (not '299')
        >>> cidr.to_python('192.168.0.1/1')
        Traceback (most recent call last):
            ...
        Invalid: The network size (bits) must be within the range of 8-32 (not '1')
        >>> cidr.to_python('asdf')
        Traceback (most recent call last):
            ...
        Invalid: Please enter a valid IP address (a.b.c.d) or IP network (a.b.c.d/e)
    """

    messages = dict(IPAddress._messages,
        badFormat=_('Please enter a valid IP address (a.b.c.d)'
            ' or IP network (a.b.c.d/e)'),
        illegalBits=_('The network size (bits) must be within the range'
            ' of 8-32 (not %(bits)r)'))

    def _validate_python(self, value, state):
        try:
            # Split into octets and bits
            if '/' in value:  # a.b.c.d/e
                addr, bits = value.split('/')
            else:  # a.b.c.d
                addr, bits = value, 32
            # Use IPAddress validator to validate the IP part
            IPAddress._validate_python(self, addr, state)
            # Bits (netmask) correct?
            if not 8 <= int(bits) <= 32:
                raise Invalid(
                    self.message('illegalBits', state, bits=bits),
                    value, state)
        # Splitting faild: wrong syntax
        except ValueError:
            raise Invalid(self.message('badFormat', state), value, state)


class MACAddress(FancyValidator):
    """
    Formencode validator to check whether a string is a correct hardware
    (MAC) address.

    Examples::

        >>> mac = MACAddress()
        >>> mac.to_python('aa:bb:cc:dd:ee:ff')
        'aabbccddeeff'
        >>> mac.to_python('aa:bb:cc:dd:ee:ff:e')
        Traceback (most recent call last):
            ...
        Invalid: A MAC address must contain 12 digits and A-F; the value you gave has 13 characters
        >>> mac.to_python('aa:bb:cc:dd:ee:fx')
        Traceback (most recent call last):
            ...
        Invalid: MAC addresses may only contain 0-9 and A-F (and optionally :), not 'x'
        >>> MACAddress(add_colons=True).to_python('aabbccddeeff')
        'aa:bb:cc:dd:ee:ff'
    """

    strip = True
    valid_characters = '0123456789abcdefABCDEF'
    add_colons = False

    messages = dict(
        badLength=_('A MAC address must contain 12 digits and A-F;'
            ' the value you gave has %(length)s characters'),
        badCharacter=_('MAC addresses may only contain 0-9 and A-F'
            ' (and optionally :), not %(char)r'))

    def _convert_to_python(self, value, state):
        address = value.replace(':', '').lower()  # remove colons
        if len(address) != 12:
            raise Invalid(
                self.message('badLength', state,
                    length=len(address)), address, state)
        for char in address:
            if char not in self.valid_characters:
                raise Invalid(
                    self.message('badCharacter', state,
                        char=char), address, state)
        if self.add_colons:
            address = '%s:%s:%s:%s:%s:%s' % (
                address[0:2], address[2:4], address[4:6],
                address[6:8], address[8:10], address[10:12])
        return address

    _convert_from_python = _convert_to_python


class FormValidator(FancyValidator):
    """
    A FormValidator is something that can be chained with a Schema.

    Unlike normal chaining the FormValidator can validate forms that
    aren't entirely valid.

    The important method is .validate(), of course.  It gets passed a
    dictionary of the (processed) values from the form.  If you have
    .validate_partial_form set to True, then it will get the incomplete
    values as well -- check with the "in" operator if the form was able
    to process any particular field.

    Anyway, .validate() should return a string or a dictionary.  If a
    string, it's an error message that applies to the whole form.  If
    not, then it should be a dictionary of fieldName: errorMessage.
    The special key "form" is the error message for the form as a whole
    (i.e., a string is equivalent to {"form": string}).

    Returns None on no errors.
    """

    validate_partial_form = False

    validate_partial_python = None
    validate_partial_other = None

    def is_empty(self, value):
        return False

    def field_is_empty(self, value):
        return is_empty(value)


class RequireIfMissing(FormValidator):
    """
    Require one field based on another field being present or missing.

    This validator is applied to a form, not an individual field (usually
    using a Schema's ``pre_validators`` or ``chained_validators``) and is
    available under both names ``RequireIfMissing`` and ``RequireIfPresent``.

    If you provide a ``missing`` value (a string key name) then
    if that field is missing the field must be entered.
    This gives you an either/or situation.

    If you provide a ``present`` value (another string key name) then
    if that field is present, the required field must also be present.

    ::

        >>> from formencode import validators
        >>> v = validators.RequireIfPresent('phone_type', present='phone')
        >>> v.to_python(dict(phone_type='', phone='510 420  4577'))
        Traceback (most recent call last):
            ...
        Invalid: You must give a value for phone_type
        >>> v.to_python(dict(phone=''))
        {'phone': ''}

    Note that if you have a validator on the optionally-required
    field, you should probably use ``if_missing=None``.  This way you
    won't get an error from the Schema about a missing value.  For example::

        class PhoneInput(Schema):
            phone = PhoneNumber()
            phone_type = String(if_missing=None)
            chained_validators = [RequireIfPresent('phone_type', present='phone')]
    """

    # Field that potentially is required:
    required = None
    # If this field is missing, then it is required:
    missing = None
    # If this field is present, then it is required:
    present = None

    __unpackargs__ = ('required',)

    def _convert_to_python(self, value_dict, state):
        is_empty = self.field_is_empty
        if is_empty(value_dict.get(self.required)) and (
                (self.missing and is_empty(value_dict.get(self.missing))) or
                (self.present and not is_empty(value_dict.get(self.present)))):
            raise Invalid(
                _('You must give a value for %s') % self.required,
                value_dict, state,
                error_dict={self.required:
                    Invalid(self.message('empty', state),
                        value_dict.get(self.required), state)})
        return value_dict

RequireIfPresent = RequireIfMissing


class FieldsMatch(FormValidator):
    """
    Tests that the given fields match, i.e., are identical.  Useful
    for password+confirmation fields.  Pass the list of field names in
    as `field_names`.

    ::

        >>> f = FieldsMatch('pass', 'conf')
        >>> sorted(f.to_python({'pass': 'xx', 'conf': 'xx'}).items())
        [('conf', 'xx'), ('pass', 'xx')]
        >>> f.to_python({'pass': 'xx', 'conf': 'yy'})
        Traceback (most recent call last):
            ...
        Invalid: conf: Fields do not match
    """

    show_match = False
    field_names = None
    validate_partial_form = True

    __unpackargs__ = ('*', 'field_names')

    messages = dict(
        invalid=_('Fields do not match (should be %(match)s)'),
        invalidNoMatch=_('Fields do not match'),
        notDict=_('Fields should be a dictionary'))

    def __init__(self, *args, **kw):
        super(FieldsMatch, self).__init__(*args, **kw)
        if len(self.field_names) < 2:
            raise TypeError('FieldsMatch() requires at least two field names')

    def validate_partial(self, field_dict, state):
        for name in self.field_names:
            if name not in field_dict:
                return
        self._validate_python(field_dict, state)

    def _validate_python(self, field_dict, state):
        try:
            ref = field_dict[self.field_names[0]]
        except TypeError:
            # Generally because field_dict isn't a dict
            raise Invalid(self.message('notDict', state), field_dict, state)
        except KeyError:
            ref = ''
        errors = {}
        for name in self.field_names[1:]:
            if field_dict.get(name, '') != ref:
                if self.show_match:
                    errors[name] = self.message('invalid', state,
                                                match=ref)
                else:
                    errors[name] = self.message('invalidNoMatch', state)
        if errors:
            error_list = sorted(errors.iteritems())
            error_message = '<br>\n'.join(
                '%s: %s' % (name, value) for name, value in error_list)
            raise Invalid(error_message, field_dict, state, error_dict=errors)


class CreditCardValidator(FormValidator):
    """
    Checks that credit card numbers are valid (if not real).

    You pass in the name of the field that has the credit card
    type and the field with the credit card number.  The credit
    card type should be one of "visa", "mastercard", "amex",
    "dinersclub", "discover", "jcb".

    You must check the expiration date yourself (there is no
    relation between CC number/types and expiration dates).

    ::

        >>> cc = CreditCardValidator()
        >>> sorted(cc.to_python({'ccType': 'visa', 'ccNumber': '4111111111111111'}).items())
        [('ccNumber', '4111111111111111'), ('ccType', 'visa')]
        >>> cc.to_python({'ccType': 'visa', 'ccNumber': '411111111111111'})
        Traceback (most recent call last):
            ...
        Invalid: ccNumber: You did not enter a valid number of digits
        >>> cc.to_python({'ccType': 'visa', 'ccNumber': '411111111111112'})
        Traceback (most recent call last):
            ...
        Invalid: ccNumber: You did not enter a valid number of digits
        >>> cc().to_python({})
        Traceback (most recent call last):
            ...
        Invalid: The field ccType is missing
    """

    validate_partial_form = True

    cc_type_field = 'ccType'
    cc_number_field = 'ccNumber'

    __unpackargs__ = ('cc_type_field', 'cc_number_field')

    messages = dict(
        notANumber=_('Please enter only the number, no other characters'),
        badLength=_('You did not enter a valid number of digits'),
        invalidNumber=_('That number is not valid'),
        missing_key=_('The field %(key)s is missing'))

    def validate_partial(self, field_dict, state):
        if not field_dict.get(self.cc_type_field, None) \
           or not field_dict.get(self.cc_number_field, None):
            return None
        self._validate_python(field_dict, state)

    def _validate_python(self, field_dict, state):
        errors = self._validateReturn(field_dict, state)
        if errors:
            error_list = sorted(errors.iteritems())
            raise Invalid(
                '<br>\n'.join('%s: %s' % (name, value)
                    for name, value in error_list),
                field_dict, state, error_dict=errors)

    def _validateReturn(self, field_dict, state):
        for field in self.cc_type_field, self.cc_number_field:
            if field not in field_dict:
                raise Invalid(
                    self.message('missing_key', state, key=field),
                    field_dict, state)
        ccType = field_dict[self.cc_type_field].lower().strip()
        number = field_dict[self.cc_number_field].strip()
        number = number.replace(' ', '')
        number = number.replace('-', '')
        try:
            long(number)
        except ValueError:
            return {self.cc_number_field: self.message('notANumber', state)}
        assert ccType in self._cardInfo, (
            "I can't validate that type of credit card")
        foundValid = False
        validLength = False
        for prefix, length in self._cardInfo[ccType]:
            if len(number) == length:
                validLength = True
                if number.startswith(prefix):
                    foundValid = True
                    break
        if not validLength:
            return {self.cc_number_field: self.message('badLength', state)}
        if not foundValid:
            return {self.cc_number_field: self.message('invalidNumber', state)}
        if not self._validateMod10(number):
            return {self.cc_number_field: self.message('invalidNumber', state)}
        return None

    def _validateMod10(self, s):
        """Check string with the mod 10 algorithm (aka "Luhn formula")."""
        checksum, factor = 0, 1
        for c in reversed(s):
            for c in str(factor * int(c)):
                checksum += int(c)
            factor = 3 - factor
        return checksum % 10 == 0

    _cardInfo = {
        "visa": [('4', 16),
                 ('4', 13)],
        "mastercard": [('51', 16),
                       ('52', 16),
                       ('53', 16),
                       ('54', 16),
                       ('55', 16)],
        "discover": [('6011', 16)],
        "amex": [('34', 15),
                 ('37', 15)],
        "dinersclub": [('300', 14),
                       ('301', 14),
                       ('302', 14),
                       ('303', 14),
                       ('304', 14),
                       ('305', 14),
                       ('36', 14),
                       ('38', 14)],
        "jcb": [('3', 16),
                ('2131', 15),
                ('1800', 15)],
            }


class CreditCardExpires(FormValidator):
    """
    Checks that credit card expiration date is valid relative to
    the current date.

    You pass in the name of the field that has the credit card
    expiration month and the field with the credit card expiration
    year.

    ::

        >>> ed = CreditCardExpires()
        >>> sorted(ed.to_python({'ccExpiresMonth': '11', 'ccExpiresYear': '2250'}).items())
        [('ccExpiresMonth', '11'), ('ccExpiresYear', '2250')]
        >>> ed.to_python({'ccExpiresMonth': '10', 'ccExpiresYear': '2005'})
        Traceback (most recent call last):
            ...
        Invalid: ccExpiresMonth: Invalid Expiration Date<br>
        ccExpiresYear: Invalid Expiration Date
    """

    validate_partial_form = True

    cc_expires_month_field = 'ccExpiresMonth'
    cc_expires_year_field = 'ccExpiresYear'

    __unpackargs__ = ('cc_expires_month_field', 'cc_expires_year_field')

    datetime_module = None

    messages = dict(
        notANumber=_('Please enter numbers only for month and year'),
        invalidNumber=_('Invalid Expiration Date'))

    def validate_partial(self, field_dict, state):
        if not field_dict.get(self.cc_expires_month_field, None) \
           or not field_dict.get(self.cc_expires_year_field, None):
            return None
        self._validate_python(field_dict, state)

    def _validate_python(self, field_dict, state):
        errors = self._validateReturn(field_dict, state)
        if errors:
            error_list = sorted(errors.iteritems())
            raise Invalid(
                '<br>\n'.join('%s: %s' % (name, value)
                    for name, value in error_list),
                field_dict, state, error_dict=errors)

    def _validateReturn(self, field_dict, state):
        ccExpiresMonth = str(field_dict[self.cc_expires_month_field]).strip()
        ccExpiresYear = str(field_dict[self.cc_expires_year_field]).strip()

        try:
            ccExpiresMonth = int(ccExpiresMonth)
            ccExpiresYear = int(ccExpiresYear)
            dt_mod = import_datetime(self.datetime_module)
            now = datetime_now(dt_mod)
            today = datetime_makedate(dt_mod, now.year, now.month, now.day)
            next_month = ccExpiresMonth % 12 + 1
            next_month_year = ccExpiresYear
            if next_month == 1:
                next_month_year += 1
            expires_date = datetime_makedate(
                dt_mod, next_month_year, next_month, 1)
            assert expires_date > today
        except ValueError:
            return {self.cc_expires_month_field:
                        self.message('notANumber', state),
                    self.cc_expires_year_field:
                        self.message('notANumber', state)}
        except AssertionError:
            return {self.cc_expires_month_field:
                        self.message('invalidNumber', state),
                    self.cc_expires_year_field:
                        self.message('invalidNumber', state)}


class CreditCardSecurityCode(FormValidator):
    """
    Checks that credit card security code has the correct number
    of digits for the given credit card type.

    You pass in the name of the field that has the credit card
    type and the field with the credit card security code.

    ::

        >>> code = CreditCardSecurityCode()
        >>> sorted(code.to_python({'ccType': 'visa', 'ccCode': '111'}).items())
        [('ccCode', '111'), ('ccType', 'visa')]
        >>> code.to_python({'ccType': 'visa', 'ccCode': '1111'})
        Traceback (most recent call last):
            ...
        Invalid: ccCode: Invalid credit card security code length
    """

    validate_partial_form = True

    cc_type_field = 'ccType'
    cc_code_field = 'ccCode'

    __unpackargs__ = ('cc_type_field', 'cc_code_field')

    messages = dict(
        notANumber=_('Please enter numbers only for credit card security code'),
        badLength=_('Invalid credit card security code length'))

    def validate_partial(self, field_dict, state):
        if (not field_dict.get(self.cc_type_field, None)
                or not field_dict.get(self.cc_code_field, None)):
            return None
        self._validate_python(field_dict, state)

    def _validate_python(self, field_dict, state):
        errors = self._validateReturn(field_dict, state)
        if errors:
            error_list = sorted(errors.iteritems())
            raise Invalid(
                '<br>\n'.join('%s: %s' % (name, value)
                    for name, value in error_list),
                field_dict, state, error_dict=errors)

    def _validateReturn(self, field_dict, state):
        ccType = str(field_dict[self.cc_type_field]).strip()
        ccCode = str(field_dict[self.cc_code_field]).strip()
        try:
            int(ccCode)
        except ValueError:
            return {self.cc_code_field: self.message('notANumber', state)}
        length = self._cardInfo[ccType]
        if len(ccCode) != length:
            return {self.cc_code_field: self.message('badLength', state)}

    # key = credit card type, value = length of security code
    _cardInfo = dict(visa=3, mastercard=3, discover=3, amex=4)


def validators():
    """Return the names of all validators in this module."""
    return [name for name, value in globals().iteritems()
        if isinstance(value, type) and issubclass(value, Validator)]

__all__ = ['Invalid'] + validators()

########NEW FILE########
__FILENAME__ = variabledecode
"""
Takes GET/POST variable dictionary, as might be returned by ``cgi``,
and turns them into lists and dictionaries.

Keys (variable names) can have subkeys, with a ``.`` and
can be numbered with ``-``, like ``a.b-3=something`` means that
the value ``a`` is a dictionary with a key ``b``, and ``b``
is a list, the third(-ish) element with the value ``something``.
Numbers are used to sort, missing numbers are ignored.

This doesn't deal with multiple keys, like in a query string of
``id=10&id=20``, which returns something like ``{'id': ['10',
'20']}``.  That's left to someplace else to interpret.  If you want to
represent lists in this model, you use indexes, and the lists are
explicitly ordered.

If you want to change the character that determines when to split for
a dict or list, both variable_decode and variable_encode take dict_char
and list_char keyword args. For example, to have the GET/POST variables,
``a_1=something`` as a list, you would use a ``list_char='_'``.
"""

from .api import FancyValidator

__all__ = ['variable_decode', 'variable_encode', 'NestedVariables']


def variable_decode(d, dict_char='.', list_char='-'):
    """
    Decode the flat dictionary d into a nested structure.
    """
    result = {}
    dicts_to_sort = set()
    known_lengths = {}
    for key, value in d.iteritems():
        keys = key.split(dict_char)
        new_keys = []
        was_repetition_count = False
        for key in keys:
            if key.endswith('--repetitions'):
                key = key[:-len('--repetitions')]
                new_keys.append(key)
                known_lengths[tuple(new_keys)] = int(value)
                was_repetition_count = True
                break
            elif list_char in key:
                maybe_key, index = key.split(list_char, 1)
                if not index.isdigit():
                    new_keys.append(key)
                else:
                    key = maybe_key
                    new_keys.append(key)
                    dicts_to_sort.add(tuple(new_keys))
                    new_keys.append(int(index))
            else:
                new_keys.append(key)
        if was_repetition_count:
            continue

        place = result
        for i in range(len(new_keys) - 1):
            try:
                if not isinstance(place[new_keys[i]], dict):
                    place[new_keys[i]] = {None: place[new_keys[i]]}
                place = place[new_keys[i]]
            except KeyError:
                place[new_keys[i]] = {}
                place = place[new_keys[i]]
        if new_keys[-1] in place:
            if isinstance(place[new_keys[-1]], dict):
                place[new_keys[-1]][None] = value
            elif isinstance(place[new_keys[-1]], list):
                if isinstance(value, list):
                    place[new_keys[-1]].extend(value)
                else:
                    place[new_keys[-1]].append(value)
            else:
                if isinstance(value, list):
                    place[new_keys[-1]] = [place[new_keys[-1]]]
                    place[new_keys[-1]].extend(value)
                else:
                    place[new_keys[-1]] = [place[new_keys[-1]], value]
        else:
            place[new_keys[-1]] = value

    to_sort_list = sorted(dicts_to_sort, key=len, reverse=True)
    for key in to_sort_list:
        to_sort = result
        source = None
        last_key = None
        for sub_key in key:
            source = to_sort
            last_key = sub_key
            to_sort = to_sort[sub_key]
        if None in to_sort:
            noneVals = [(0, x) for x in to_sort.pop(None)]
            noneVals.extend(to_sort.iteritems())
            to_sort = noneVals
        else:
            to_sort = to_sort.iteritems()
        to_sort = [x[1] for x in sorted(to_sort)]
        if key in known_lengths:
            if len(to_sort) < known_lengths[key]:
                to_sort.extend([''] * (known_lengths[key] - len(to_sort)))
        source[last_key] = to_sort

    return result


def variable_encode(d, prepend='', result=None, add_repetitions=True,
                    dict_char='.', list_char='-'):
    """
    Encode a nested structure into a flat dictionary.
    """
    if result is None:
        result = {}
    if isinstance(d, dict):
        for key, value in d.iteritems():
            if key is None:
                name = prepend
            elif not prepend:
                name = key
            else:
                name = "%s%s%s" % (prepend, dict_char, key)
            variable_encode(value, name, result, add_repetitions,
                            dict_char=dict_char, list_char=list_char)
    elif isinstance(d, list):
        for i, value in enumerate(d):
            variable_encode(value, "%s%s%i" % (prepend, list_char, i), result,
                add_repetitions, dict_char=dict_char, list_char=list_char)
        if add_repetitions:
            repName = ('%s--repetitions' % prepend
                if prepend else '__repetitions__')
            result[repName] = str(len(d))
    else:
        result[prepend] = d
    return result


class NestedVariables(FancyValidator):

    def _convert_to_python(self, value, state):
        return variable_decode(value)

    def _convert_from_python(self, value, state):
        return variable_encode(value)

    def empty_value(self, value):
        return {}

########NEW FILE########
