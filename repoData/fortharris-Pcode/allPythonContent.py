__FILENAME__ = dist
import distutils.command.bdist_rpm
import distutils.command.build
import distutils.command.install
import distutils.core
import distutils.dir_util
import distutils.dist
import distutils.errors
import distutils.log
import distutils.util
import distutils.version
import os
import sys

import cx_Freeze

__all__ = [ "bdist_rpm", "build", "build_exe", "install", "install_exe",
            "setup" ]

class Distribution(distutils.dist.Distribution):

    def __init__(self, attrs):
        self.executables = []
        distutils.dist.Distribution.__init__(self, attrs)


class bdist_rpm(distutils.command.bdist_rpm.bdist_rpm):

    def finalize_options(self):
        distutils.command.bdist_rpm.bdist_rpm.finalize_options(self)
        self.use_rpm_opt_flags = 1

    def _make_spec_file(self):
        contents = distutils.command.bdist_rpm.bdist_rpm._make_spec_file(self)
        contents.append('%define __prelink_undo_cmd %{nil}')
        return [c for c in contents if c != 'BuildArch: noarch']


class build(distutils.command.build.build):
    user_options = distutils.command.build.build.user_options + [
        ('build-exe=', None, 'build directory for executables')
    ]

    def get_sub_commands(self):
        subCommands = distutils.command.build.build.get_sub_commands(self)
        if self.distribution.executables:
            subCommands.append("build_exe")
        return subCommands

    def initialize_options(self):
        distutils.command.build.build.initialize_options(self)
        self.build_exe = None

    def finalize_options(self):
        distutils.command.build.build.finalize_options(self)
        if self.build_exe is None:
            dirName = "exe.%s-%s" % \
                    (distutils.util.get_platform(), sys.version[0:3])
            self.build_exe = os.path.join(self.build_base, dirName)


class build_exe(distutils.core.Command):
    description = "build executables from Python scripts"
    user_options = [
        ('build-exe=', 'b',
         'directory for built executables'),
        ('optimize=', 'O',
         'optimization level: -O1 for "python -O", '
         '-O2 for "python -OO" and -O0 to disable [default: -O0]'),
        ('excludes=', 'e',
         'comma-separated list of modules to exclude'),
        ('includes=', 'i',
         'comma-separated list of modules to include'),
        ('packages=', 'p',
         'comma-separated list of packages to include'),
        ('namespace-packages=', None,
         'comma-separated list of namespace packages to include'),
        ('replace-paths=', None,
         'comma-separated list of paths to replace in included modules'),
        ('path=', None,
         'comma-separated list of paths to search'),
        ('init-script=', 'i',
         'name of script to use during initialization'),
        ('base=', None,
         'name of base executable to use'),
        ('compressed', 'c',
         'create a compressed zipfile'),
        ('copy-dependent-files', None,
         'copy all dependent files'),
        ('create-shared-zip', None,
         'create a shared zip file containing shared modules'),
        ('append-script-to-exe', None,
         'append the script module to the exe'),
        ('include-in-shared-zip', None,
         'include the script module in the shared zip file'),
        ('icon', None,
         'include the icon along with the frozen executable(s)'),
        ('constants=', None,
         'comma-separated list of constants to include'),
        ('include-files=', 'f',
         'list of tuples of additional files to include in distribution'),
        ('include-msvcr=', None,
         'include the Microsoft Visual C runtime files'),
        ('zip-includes=', None,
         'list of tuples of additional files to include in zip file'),
        ('bin-includes', None,
         'list of names of files to include when determining dependencies'),
        ('bin-excludes', None,
         'list of names of files to exclude when determining dependencies'),
        ('bin-path-includes', None,
         'list of paths from which to include files when determining '
         'dependencies'),
        ('bin-path-excludes', None,
         'list of paths from which to exclude files when determining '
         'dependencies'),
        ('silent', 's',
         'suppress all output except warnings')
    ]
    boolean_options = ["compressed", "copy_dependent_files",
            "create_shared_zip", "append_script_to_exe",
            "include_in_shared_zip", "include_msvcr", "silent"]

    def _normalize(self, attrName):
        value = getattr(self, attrName)
        if value is None:
            normalizedValue = []
        elif isinstance(value, str):
            normalizedValue = value.split()
        else:
            normalizedValue = list(value)
        setattr(self, attrName, normalizedValue)

    def add_to_path(self, name):
        sourceDir = getattr(self, name.lower())
        if sourceDir is not None:
            sys.path.insert(0, sourceDir)

    def build_extension(self, name, moduleName = None):
        if moduleName is None:
            moduleName = name
        sourceDir = getattr(self, name.lower())
        if sourceDir is None:
            return
        origDir = os.getcwd()
        scriptArgs = ["build"]
        command = self.distribution.get_command_obj("build")
        if command.compiler is not None:
            scriptArgs.append("--compiler=%s" % command.compiler)
        os.chdir(sourceDir)
        distutils.log.info("building '%s' extension in '%s'", name, sourceDir)
        distribution = distutils.core.run_setup("setup.py", scriptArgs)
        modules = [m for m in distribution.ext_modules if m.name == moduleName]
        if not modules:
            messageFormat = "no module named '%s' in '%s'"
            raise distutils.errors.DistutilsSetupError(messageFormat %
                    (moduleName, sourceDir))
        command = distribution.get_command_obj("build_ext")
        command.ensure_finalized()
        if command.compiler is None:
            command.run()
        else:
            command.build_extensions()
        dirName = os.path.join(sourceDir, command.build_lib)
        os.chdir(origDir)
        if dirName not in sys.path:
            sys.path.insert(0, dirName)
        return os.path.join(sourceDir, command.build_lib,
                command.get_ext_filename(moduleName))

    def initialize_options(self):
        self.optimize = 0
        self.build_exe = None
        self.excludes = []
        self.includes = []
        self.packages = []
        self.namespace_packages = []
        self.replace_paths = []
        self.compressed = None
        self.copy_dependent_files = None
        self.init_script = None
        self.base = None
        self.path = None
        self.create_shared_zip = None
        self.append_script_to_exe = None
        self.include_in_shared_zip = None
        self.include_msvcr = None
        self.icon = None
        self.constants = []
        self.include_files = []
        self.zip_includes = []
        self.bin_excludes = []
        self.bin_includes = []
        self.bin_path_includes = []
        self.bin_path_excludes = []
        self.silent = None

    def finalize_options(self):
        self.set_undefined_options('build', ('build_exe', 'build_exe'))
        self.optimize = int(self.optimize)
        if self.silent is None:
            self.silent = False
        self._normalize("excludes")
        self._normalize("includes")
        self._normalize("packages")
        self._normalize("namespace_packages")
        self._normalize("constants")

    def run(self):
        metadata = self.distribution.metadata
        constantsModule = cx_Freeze.ConstantsModule(metadata.version)
        for constant in self.constants:
            parts = constant.split("=")
            if len(parts) == 1:
                name = constant
                value = None
            else:
                name, stringValue = parts
                value = eval(stringValue)
            constantsModule.values[name] = value
        freezer = cx_Freeze.Freezer(self.distribution.executables,
                [constantsModule], self.includes, self.excludes, self.packages,
                self.replace_paths, self.compressed, self.optimize,
                self.copy_dependent_files, self.init_script, self.base,
                self.path, self.create_shared_zip, self.append_script_to_exe,
                self.include_in_shared_zip, self.build_exe, icon = self.icon,
                includeMSVCR = self.include_msvcr,
                includeFiles = self.include_files,
                binIncludes = self.bin_includes,
                binExcludes = self.bin_excludes,
                zipIncludes = self.zip_includes,
                silent = self.silent,
                namespacePackages = self.namespace_packages,
                binPathIncludes = self.bin_path_includes,
                binPathExcludes = self.bin_path_excludes,
                metadata = metadata)
        freezer.Freeze()

    def set_source_location(self, name, *pathParts):
        envName = "%s_BASE" % name.upper()
        attrName = name.lower()
        sourceDir = getattr(self, attrName)
        if sourceDir is None:
            baseDir = os.environ.get(envName)
            if baseDir is None:
                return
            sourceDir = os.path.join(baseDir, *pathParts)
            if os.path.isdir(sourceDir):
                setattr(self, attrName, sourceDir)


class install(distutils.command.install.install):
    user_options = distutils.command.install.install.user_options + [
            ('install-exe=', None,
             'installation directory for executables')
    ]

    def expand_dirs(self):
        distutils.command.install.install.expand_dirs(self)
        self._expand_attrs(['install_exe'])

    def get_sub_commands(self):
        subCommands = distutils.command.install.install.get_sub_commands(self)
        if self.distribution.executables:
            subCommands.append("install_exe")
        return [s for s in subCommands if s != "install_egg_info"]

    def initialize_options(self):
        distutils.command.install.install.initialize_options(self)
        self.install_exe = None

    def finalize_options(self):
        if self.prefix is None and sys.platform == "win32":
            try:
                import winreg
            except:
                import _winreg as winreg
            key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE,
                    r"Software\Microsoft\Windows\CurrentVersion")
            prefix = str(winreg.QueryValueEx(key, "ProgramFilesDir")[0])
            metadata = self.distribution.metadata
            self.prefix = "%s/%s" % (prefix, metadata.name)
        distutils.command.install.install.finalize_options(self)
        self.convert_paths('exe')
        if self.root is not None:
            self.change_roots('exe')

    def select_scheme(self, name):
        distutils.command.install.install.select_scheme(self, name)
        if self.install_exe is None:
            if sys.platform == "win32":
                self.install_exe = '$base'
            else:
                metadata = self.distribution.metadata
                dirName = "%s-%s" % (metadata.name, metadata.version)
                self.install_exe = '$base/lib/%s' % dirName


class install_exe(distutils.core.Command):
    description = "install executables built from Python scripts"
    user_options = [
        ('install-dir=', 'd', 'directory to install executables to'),
        ('build-dir=', 'b', 'build directory (where to install from)'),
        ('force', 'f', 'force installation (overwrite existing files)'),
        ('skip-build', None, 'skip the build steps')
    ]

    def initialize_options(self):
        self.install_dir = None
        self.force = 0
        self.build_dir = None
        self.skip_build = None

    def finalize_options(self):
        self.set_undefined_options('build', ('build_exe', 'build_dir'))
        self.set_undefined_options('install',
                ('install_exe', 'install_dir'),
                ('force', 'force'),
                ('skip_build', 'skip_build'))

    def run(self):
        if not self.skip_build:
            self.run_command('build_exe')
        self.outfiles = self.copy_tree(self.build_dir, self.install_dir)
        if sys.platform != "win32":
            baseDir = os.path.dirname(os.path.dirname(self.install_dir))
            binDir = os.path.join(baseDir, "bin")
            if not os.path.exists(binDir):
                os.makedirs(binDir)
            sourceDir = os.path.join("..", self.install_dir[len(baseDir) + 1:])
            for executable in self.distribution.executables:
                name = os.path.basename(executable.targetName)
                source = os.path.join(sourceDir, name)
                target = os.path.join(binDir, name)
                if os.path.exists(target):
                    os.unlink(target)
                os.symlink(source, target)
                self.outfiles.append(target)

    def get_inputs(self):
        return self.distribution.executables or []

    def get_outputs(self):
        return self.outfiles or []


def _AddCommandClass(commandClasses, name, cls):
    if name not in commandClasses:
        commandClasses[name] = cls


def setup(**attrs):
    attrs.setdefault("distclass", Distribution)
    commandClasses = attrs.setdefault("cmdclass", {})
    if sys.platform == "win32":
        if sys.version_info[:2] >= (2, 5):
            _AddCommandClass(commandClasses, "bdist_msi", cx_Freeze.bdist_msi)
    elif sys.platform == "darwin":
        _AddCommandClass(commandClasses, "bdist_dmg", cx_Freeze.bdist_dmg)
        _AddCommandClass(commandClasses, "bdist_mac", cx_Freeze.bdist_mac)
    else:
        _AddCommandClass(commandClasses, "bdist_rpm", cx_Freeze.bdist_rpm)
    _AddCommandClass(commandClasses, "build", build)
    _AddCommandClass(commandClasses, "build_exe", build_exe)
    _AddCommandClass(commandClasses, "install", install)
    _AddCommandClass(commandClasses, "install_exe", install_exe)
    distutils.core.setup(**attrs)


########NEW FILE########
__FILENAME__ = finder
"""
Base class for finding modules.
"""

import dis
import imp
import marshal
import opcode
import os
import pkgutil
import re
import sys
import types
import zipfile

import cx_Freeze.hooks

BUILD_LIST = opcode.opmap["BUILD_LIST"]
INPLACE_ADD = opcode.opmap["INPLACE_ADD"]
LOAD_CONST = opcode.opmap["LOAD_CONST"]
IMPORT_NAME = opcode.opmap["IMPORT_NAME"]
IMPORT_FROM = opcode.opmap["IMPORT_FROM"]
IMPORT_STAR = opcode.opmap["IMPORT_STAR"]
STORE_FAST = opcode.opmap["STORE_FAST"]
STORE_NAME = opcode.opmap["STORE_NAME"]
STORE_GLOBAL = opcode.opmap["STORE_GLOBAL"]
STORE_OPS = (STORE_NAME, STORE_GLOBAL)

__all__ = [ "Module", "ModuleFinder" ]

try:
    isidentifier = str.isidentifier  # Built in method in Python 3
except AttributeError:
    # Check with regex for Python 2
    _identifier_re = re.compile(r'^[a-z_]\w*$', re.I)
    def isidentifier(s):
        return bool(_identifier_re.match(s))

class ModuleFinder(object):

    def __init__(self, includeFiles = None, excludes = [], path = None,
            replacePaths = None, copyDependentFiles = True, bootstrap = False,
            compress = True):
        self.includeFiles = includeFiles
        if includeFiles is None:
            self.includeFiles = []
        self.excludes = dict.fromkeys(excludes)
        self.replacePaths = replacePaths
        if replacePaths is None:
            self.replacePaths = []
        self.copyDependentFiles = copyDependentFiles
        self.compress = compress
        self.path = path or sys.path
        self.modules = []
        self.aliases = {}
        self._modules = dict.fromkeys(excludes)
        self._builtinModules = dict.fromkeys(sys.builtin_module_names)
        self._badModules = {}
        self._zipFileEntries = {}
        self._zipFiles = {}
        cx_Freeze.hooks.initialize(self)
        initialExcludedModules = self.excludes.copy()
        self._AddBaseModules()
        if not bootstrap:
            self._ClearBaseModuleCode(initialExcludedModules)

    def _AddBaseModules(self):
        """Add the base modules to the finder. These are the modules that
           Python imports itself during initialization and, if not found,
           can result in behavior that differs from running from source;
           also include modules used within the bootstrap code"""
        self.ExcludeModule("cStringIO")
        self.ExcludeModule("doctest")
        self.ExcludeModule("getopt")
        self.ExcludeModule("logging")
        if sys.version_info[0] < 3:
            # On Python 3, traceback -> linecache -> tokenize -> re, so
            # we need to let it be loaded.
            self.ExcludeModule("re")
        self.ExcludeModule("subprocess")
        self.IncludeModule("traceback")
        self.IncludeModule("warnings")
        self.IncludePackage("encodings")
        if sys.version_info[0] >= 3:
            self.IncludeModule("io")
        if sys.version_info[:2] >= (3, 3):
            self.AddAlias("_frozen_importlib", "importlib._bootstrap")
            self.IncludeModule("_frozen_importlib")
        if self.copyDependentFiles:
            self.IncludeModule("imp")
            self.IncludeModule("os")
            self.IncludeModule("sys")
            self.IncludeModule("zlib")

    def _AddModule(self, name):
        """Add a module to the list of modules but if one is already found,
           then return it instead; this is done so that packages can be
           handled properly."""
        module = self._modules.get(name)
        if module is None:
            module = self._modules[name] = Module(name)
            self.modules.append(module)
            if name in self._badModules:
                del self._badModules[name]
        return module

    def _ClearBaseModuleCode(self, initialExcludedModules):
        """Clear the code for all of the base modules. This is done when not in
           bootstrap mode so that the base modules are not included in the
           zip file."""
        for name in self.excludes:
            if name in initialExcludedModules:
                continue
            del self._modules[name]
        self.excludes = initialExcludedModules
        for module in self._modules.values():
            if module is None:
                continue
            if module.code is not None:
                module.code = None
                module.file = None

    def _DetermineParent(self, caller):
        """Determine the parent to use when searching packages."""
        if caller is not None:
            if caller.path is not None:
                return caller
            return self._GetParentByName(caller.name)

    def _EnsureFromList(self, caller, packageModule, fromList,
            deferredImports):
        """Ensure that the from list is satisfied. This is only necessary for
           package modules. If the package module has not been completely
           imported yet, defer the import until it has been completely imported
           in order to avoid spurious errors about missing modules."""
        if packageModule.inImport and caller is not packageModule:
            deferredImports.append((caller, packageModule, fromList))
        else:
            for name in fromList:
                if name in packageModule.globalNames:
                    continue
                subModuleName = "%s.%s" % (packageModule.name, name)
                self._ImportModule(subModuleName, deferredImports, caller)

    def _FindModule(self, name, path, namespace):
        try:
            return imp.find_module(name, path)
        except ImportError:
            if namespace and name in sys.modules:
                module = sys.modules[name]
                info = ("", "", imp.PKG_DIRECTORY)
                return None, module.__path__[0], info
            if path is None:
                path = []
            for location in path:
                if name in self._zipFileEntries:
                    break
                if location in self._zipFiles:
                    continue
                if os.path.isdir(location) or not zipfile.is_zipfile(location):
                    self._zipFiles[location] = None
                    continue
                zip = zipfile.ZipFile(location)
                for archiveName in zip.namelist():
                    baseName, ext = os.path.splitext(archiveName)
                    if ext not in ('.pyc', '.pyo'):
                        continue
                    moduleName = ".".join(baseName.split("/"))
                    if moduleName in self._zipFileEntries:
                        continue
                    self._zipFileEntries[moduleName] = (zip, archiveName)
                self._zipFiles[location] = None
            info = self._zipFileEntries.get(name)
            if info is not None:
                zip, archiveName = info
                fp = zip.read(archiveName)
                info = (".pyc", "rb", imp.PY_COMPILED)
                return fp, os.path.join(zip.filename, archiveName), info
            raise

    def _GetParentByName(self, name):
        """Return the parent module given the name of a module."""
        pos = name.rfind(".")
        if pos > 0:
            parentName = name[:pos]
            return self._modules[parentName]

    def _ImportAllSubModules(self, module, deferredImports, recursive = True):
        """Import all sub modules to the given package."""
        suffixes = [s[0] for s in imp.get_suffixes()]
        for path in module.path:
            try:
                fileNames = os.listdir(path)
            except os.error:
                continue
            
            for fileName in fileNames:
                fullName = os.path.join(path, fileName)
                if os.path.isdir(fullName):
                    initFile = os.path.join(fullName, "__init__.py")
                    if not os.path.exists(initFile):
                        continue
                    name = fileName
                else:
                    # We need to run through these in order to correctly pick
                    # up PEP 3149 library names (e.g. .cpython-32mu.so).
                    for suffix in suffixes:
                        if fileName.endswith(suffix):
                            name = fileName[:-len(suffix)]
                            # Only modules with valid Python names are importable
                            if isidentifier(name):
                                break
                    else:
                        continue
                    if name == "__init__":
                        continue
                    
                subModuleName = "%s.%s" % (module.name, name)
                subModule = self._InternalImportModule(subModuleName,
                                deferredImports)
                if subModule is None:
                    raise ImportError("No module named %r" % subModuleName)
                module.globalNames[name] = None
                if subModule.path and recursive:
                    self._ImportAllSubModules(subModule, deferredImports,
                            recursive)

    def _ImportDeferredImports(self, deferredImports, skipInImport = False):
        """Import any sub modules that were deferred, if applicable."""
        while deferredImports:
            newDeferredImports = []
            for caller, packageModule, subModuleNames in deferredImports:
                if packageModule.inImport and skipInImport:
                    continue
                self._EnsureFromList(caller, packageModule, subModuleNames,
                        newDeferredImports)
            deferredImports = newDeferredImports

    def _ImportModule(self, name, deferredImports, caller = None,
            relativeImportIndex = 0, namespace = False):
        """Attempt to find the named module and return it or None if no module
           by that name could be found."""

        # absolute import (available in Python 2.5 and up)
        # the name given is the only name that will be searched
        if relativeImportIndex == 0:
            module = self._InternalImportModule(name,
                    deferredImports, namespace = namespace)

        # old style relative import (only possibility in Python 2.4 and prior)
        # the name given is tried in all parents until a match is found and if
        # no match is found, the global namespace is searched
        elif relativeImportIndex < 0:
            parent = self._DetermineParent(caller)
            while parent is not None:
                fullName = "%s.%s" % (parent.name, name)
                module = self._InternalImportModule(fullName,
                        deferredImports, namespace = namespace)
                if module is not None:
                    parent.globalNames[name] = None
                    return module
                parent = self._GetParentByName(parent.name)
            module = self._InternalImportModule(name,
                    deferredImports, namespace = namespace)

        # new style relative import (available in Python 2.5 and up)
        # the index indicates how many levels to traverse and only that level
        # is searched for the named module
        elif relativeImportIndex > 0:
            parent = caller
            if parent.path is not None:
                relativeImportIndex -= 1
            while parent is not None and relativeImportIndex > 0:
                parent = self._GetParentByName(parent.name)
                relativeImportIndex -= 1
            if parent is None:
                module = None
            elif not name:
                module = parent
            else:
                name = "%s.%s" % (parent.name, name)
                module = self._InternalImportModule(name,
                        deferredImports, namespace = namespace)

        # if module not found, track that fact
        if module is None:
            if caller is None:
                raise ImportError("No module named %r" % name)
            self._RunHook("missing", name, caller)
            if name not in caller.ignoreNames:
                callers = self._badModules.setdefault(name, {})
                callers[caller.name] = None

        return module

    def _InternalImportModule(self, name, deferredImports, namespace = False):
        """Internal method used for importing a module which assumes that the
           name given is an absolute name. None is returned if the module
           cannot be found."""
        try:
            # Check in module cache before trying to import it again.
            return self._modules[name]
        except KeyError:
            pass
        
        if name in self._builtinModules:
            module = self._AddModule(name)
            self._RunHook("load", module.name, module)
            module.inImport = False
            return module
        
        pos = name.rfind(".")
        if pos < 0:  # Top-level module
            path = self.path
            searchName = name
            parentModule = None
        else:        # Dotted module name - look up the parent module
            parentName = name[:pos]
            parentModule = \
                    self._InternalImportModule(parentName, deferredImports,
                            namespace = namespace)
            if parentModule is None:
                return None
            if namespace:
                parentModule.ExtendPath()
            path = parentModule.path
            searchName = name[pos + 1:]
        
        if name in self.aliases:
            actualName = self.aliases[name]
            module = self._InternalImportModule(actualName, deferredImports)
            self._modules[name] = module
            return module
        
        try:
            fp, path, info = self._FindModule(searchName, path, namespace)
            module = self._LoadModule(name, fp, path, info, deferredImports,
                    parentModule, namespace)
        except ImportError:
            self._modules[name] = None
            return None
        return module

    def _LoadModule(self, name, fp, path, info, deferredImports,
            parent = None, namespace = False):
        """Load the module, given the information acquired by the finder."""
        suffix, mode, type = info
        if type == imp.PKG_DIRECTORY:
            return self._LoadPackage(name, path, parent, deferredImports,
                    namespace)
        module = self._AddModule(name)
        module.file = path
        module.parent = parent
        
        if type == imp.PY_SOURCE:
            # Load & compile Python source code
            if sys.version_info[0] >= 3:
                # For Python 3, read the file with the correct encoding
                import tokenize
                fp = open(path, "rb")
                encoding, lines = tokenize.detect_encoding(fp.readline)
                fp = open(path, "U", encoding = encoding)
            codeString = fp.read()
            if codeString and codeString[-1] != "\n":
                codeString = codeString + "\n"
            module.code = compile(codeString, path, "exec")
        
        elif type == imp.PY_COMPILED:
            # Load Python bytecode
            if isinstance(fp, str):
                magic = fp[:4]
            else:
                magic = fp.read(4)
            if magic != imp.get_magic():
                raise ImportError("Bad magic number in %s" % path)
            if isinstance(fp, str):
                module.code = marshal.loads(fp[8:])
                module.inZipFile = True
            else:
                fp.read(4)
                module.code = marshal.load(fp)
        
        # If there's a custom hook for this module, run it.
        self._RunHook("load", module.name, module)
        
        if module.code is not None:
            if self.replacePaths:
                topLevelModule = module
                while topLevelModule.parent is not None:
                    topLevelModule = topLevelModule.parent
                module.code = self._ReplacePathsInCode(topLevelModule,
                        module.code)
            
            # Scan the module code for import statements
            self._ScanCode(module.code, module, deferredImports)
        
        module.inImport = False
        return module

    def _LoadPackage(self, name, path, parent, deferredImports, namespace):
        """Load the package, given its name and path."""
        module = self._AddModule(name)
        module.path = [path]
        try:
            fp, path, info = imp.find_module("__init__", module.path)
            self._LoadModule(name, fp, path, info, deferredImports, parent)
        except ImportError:
            if not namespace:
                raise
            fileName = os.path.join(path, "__init__.py")
            module.code = compile("", fileName, "exec")
        return module

    def _ReplacePathsInCode(self, topLevelModule, co):
        """Replace paths in the code as directed, returning a new code object
           with the modified paths in place."""
        # Prepare the new filename.
        origFileName = newFileName = os.path.normpath(co.co_filename)
        for searchValue, replaceValue in self.replacePaths:
            if searchValue == "*":
                searchValue = os.path.dirname(topLevelModule.file)
                if topLevelModule.path:
                    searchValue = os.path.dirname(searchValue)
                if searchValue:
                    searchValue = searchValue + os.pathsep
            elif not origFileName.startswith(searchValue):
                continue
            newFileName = replaceValue + origFileName[len(searchValue):]
            break
        
        # Run on subordinate code objects from function & class definitions.
        constants = list(co.co_consts)
        for i, value in enumerate(constants):
            if isinstance(value, type(co)):
                constants[i] = self._ReplacePathsInCode(topLevelModule, value)
        
        # Build the new code object.
        if sys.version_info[0] < 3:
            return types.CodeType(co.co_argcount, co.co_nlocals,
                    co.co_stacksize, co.co_flags, co.co_code, tuple(constants),
                    co.co_names, co.co_varnames, newFileName, co.co_name,
                    co.co_firstlineno, co.co_lnotab, co.co_freevars,
                    co.co_cellvars)
        return types.CodeType(co.co_argcount, co.co_kwonlyargcount,
                co.co_nlocals, co.co_stacksize, co.co_flags, co.co_code,
                tuple(constants), co.co_names, co.co_varnames, newFileName,
                co.co_name, co.co_firstlineno, co.co_lnotab, co.co_freevars,
                co.co_cellvars)

    def _RunHook(self, hookName, moduleName, *args):
        """Run hook for the given module if one is present."""
        name = "%s_%s" % (hookName, moduleName.replace(".", "_"))
        method = getattr(cx_Freeze.hooks, name, None)
        if method is not None:
            method(self, *args)

    def _ScanCode(self, co, module, deferredImports, topLevel = True):
        """Scan code, looking for imported modules and keeping track of the
           constants that have been created in order to better tell which
           modules are truly missing."""
        opIndex = 0
        arguments = []
        code = co.co_code
        numOps = len(code)
        is3 = sys.version_info[0] >= 3
        while opIndex < numOps:
            if is3:
                op = code[opIndex]
            else:
                op = ord(code[opIndex])
            opIndex += 1
            if op >= dis.HAVE_ARGUMENT:
                if is3:
                    opArg = code[opIndex] + code[opIndex + 1] * 256
                else:
                    opArg = ord(code[opIndex]) + ord(code[opIndex + 1]) * 256
                opIndex += 2
            
            if op == LOAD_CONST:
                # Store an argument to be used later by an IMPORT_NAME operation.
                arguments.append(co.co_consts[opArg])
            
            elif op == IMPORT_NAME:
                name = co.co_names[opArg]
                if len(arguments) >= 2:
                    relativeImportIndex, fromList = arguments[-2:]
                else:
                    relativeImportIndex = -1
                    fromList, = arguments
                
                if name not in module.excludeNames:
                    # Load the imported module
                    importedModule = self._ImportModule(name, deferredImports,
                            module, relativeImportIndex)
                    if importedModule is not None:
                        if fromList and fromList != ("*",) \
                                and importedModule.path is not None:
                            self._EnsureFromList(module, importedModule,
                                    fromList, deferredImports)
            
            elif op == IMPORT_FROM and topLevel:
                if is3:
                    op = code[opIndex]
                    opArg = code[opIndex + 1] + code[opIndex + 2] * 256
                else:
                    op = ord(code[opIndex])
                    opArg = ord(code[opIndex + 1]) + \
                            ord(code[opIndex + 2]) * 256
                opIndex += 3
                if op == STORE_FAST:
                    name = co.co_varnames[opArg]
                else:
                    name = co.co_names[opArg]
                storeName = True
                if deferredImports:
                    deferredCaller, deferredPackage, deferredFromList = \
                            deferredImports[-1]
                    storeName = deferredCaller is not module
                if storeName:
                    module.globalNames[name] = None
            
            elif op == IMPORT_STAR and topLevel and importedModule is not None:
                module.globalNames.update(importedModule.globalNames)
                arguments = []
            
            elif op not in (BUILD_LIST, INPLACE_ADD):
                # The stack was used for something else, so we clear it.
                if topLevel and op in STORE_OPS:
                    name = co.co_names[opArg]
                    module.globalNames[name] = None
                arguments = []
        
        # Scan the code objects from function & class definitions
        for constant in co.co_consts:
            if isinstance(constant, type(co)):
                self._ScanCode(constant, module, deferredImports,
                        topLevel = False)

    def AddAlias(self, name, aliasFor):
        """Add an alias for a particular module; when an attempt is made to
           import a module using the alias name, import the actual name
           instead."""
        self.aliases[name] = aliasFor

    def ExcludeModule(self, name):
        """Exclude the named module from the resulting frozen executable."""
        self.excludes[name] = None
        self._modules[name] = None

    def IncludeFile(self, path, moduleName = None):
        """Include the named file as a module in the frozen executable."""
        name, ext = os.path.splitext(os.path.basename(path))
        if moduleName is None:
            moduleName = name
        info = (ext, "r", imp.PY_SOURCE)
        deferredImports = []
        module = self._LoadModule(moduleName, open(path, "U"), path, info,
                deferredImports)
        self._ImportDeferredImports(deferredImports)
        return module

    def IncludeFiles(self, sourcePath, targetPath):
        """Include the files in the given directory in the target build."""
        if self.copyDependentFiles:
            self.includeFiles.append((sourcePath, targetPath))

    def IncludeModule(self, name, namespace = False):
        """Include the named module in the frozen executable."""
        deferredImports = []
        module = self._ImportModule(name, deferredImports,
                namespace = namespace)
        self._ImportDeferredImports(deferredImports, skipInImport = True)
        return module

    def IncludePackage(self, name):
        """Include the named package and any submodules in the frozen
           executable."""
        deferredImports = []
        module = self._ImportModule(name, deferredImports)
        if module.path:
            self._ImportAllSubModules(module, deferredImports)
        self._ImportDeferredImports(deferredImports, skipInImport = True)
        return module

    def ReportMissingModules(self):
        return
        """Display a list of modules that weren't found."""
        if self._badModules:
            sys.stdout.write("Missing modules:\n")
            names = list(self._badModules.keys())
            names.sort()
            for name in names:
                callers = list(self._badModules[name].keys())
                callers.sort()
                sys.stdout.write("? %s imported from %s\n" % \
                        (name, ", ".join(callers)))
            sys.stdout.write("This is not necessarily a problem - the modules "
                             "may not be needed on this platform.\n")
            sys.stdout.write("\n")

    def WriteSourceFile(self, fileName):
        dirName = os.path.dirname(fileName)
        if not os.path.isdir(dirName):
            os.makedirs(dirName)
        outfp = open(fileName, "w")
        names = list(self._modules.keys())
        names.sort()
        modulesWritten = []
        for name in names:
            module = self._modules[name]
            if module is None or module.code is None:
                continue
            mangledName = "__".join(name.split("."))
            sys.stdout.write("adding base module named %s\n" % name)
            code = marshal.dumps(module.code)
            size = len(code)
            if module.path:
                size = -size
            modulesWritten.append((name, mangledName, size))
            outfp.write("unsigned char M_%s[] = {" % mangledName)
            for i in range(0, len(code), 16):
                outfp.write("\n\t")
                for op in code[i:i + 16]:
                    if not isinstance(op, int):
                        op = ord(op)
                    outfp.write("%d," % op)
            outfp.write("\n};\n\n");
        outfp.write("static struct _frozen gFrozenModules[] = {\n")
        for name, mangledName, size in modulesWritten:
            outfp.write('    {"%s", M_%s, %d},\n' % (name, mangledName, size))
        outfp.write("    {0, 0, 0}\n};\n")


class Module(object):

    def __init__(self, name):
        self.name = name
        self.file = None
        self.path = None
        self.code = None
        self.parent = None
        self.globalNames = {}
        self.excludeNames = {}
        self.ignoreNames = {}
        self.inZipFile = False
        self.inImport = True

    def __repr__(self):
        parts = ["name=%s" % repr(self.name)]
        if self.file is not None:
            parts.append("file=%s" % repr(self.file))
        if self.path is not None:
            parts.append("path=%s" % repr(self.path))
        return "<Module %s>" % ", ".join(parts)

    def AddGlobalName(self, name):
        self.globalNames[name] = None

    def ExcludeName(self, name):
        self.excludeNames[name] = None

    def ExtendPath(self):
        self.path = pkgutil.extend_path(self.path, self.name)
        if self.parent is not None:
            self.parent.ExtendPath()

    def IgnoreName(self, name):
        self.ignoreNames[name] = None


########NEW FILE########
__FILENAME__ = freezer
"""
Base class for freezing scripts into executables.
"""

import datetime
import distutils.sysconfig
import imp
import marshal
import os
import shutil
import socket
import stat
import struct
import sys
import time
import zipfile

# Pcode Additions
import platform

import cx_Freeze

__all__ = [ "ConfigError", "ConstantsModule", "Executable", "Freezer" ]

EXTENSION_LOADER_SOURCE = \
"""
def __bootstrap__():
    import imp, os, sys
    global __bootstrap__, __loader__
    __loader__ = None; del __bootstrap__, __loader__

    found = False
    for p in sys.path:
        if not os.path.isdir(p):
            continue
        f = os.path.join(p, "%s")
        if not os.path.exists(f):
            continue
        m = imp.load_dynamic(__name__, f)
        import sys
        sys.modules[__name__] = m
        found = True
        break
    if not found:
        del sys.modules[__name__]
        raise ImportError("No module named %%s" %% __name__)
__bootstrap__()
"""


MSVCR_MANIFEST_TEMPLATE = """
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
<noInheritable/>
<assemblyIdentity
    type="win32"
    name="Microsoft.VC90.CRT"
    version="9.0.21022.8"
    processorArchitecture="{PROC_ARCH}"
    publicKeyToken="1fc8b3b9a1e18e3b"/>
<file name="MSVCR90.DLL"/>
<file name="MSVCM90.DLL"/>
<file name="MSVCP90.DLL"/>
</assembly>
"""


class Freezer(object):

    def __init__(self, executables, constantsModules = [], includes = [],
            excludes = [], packages = [], replacePaths = [], compress = None,
            optimizeFlag = 0, copyDependentFiles = None, initScript = None,
            base = None, path = None, createLibraryZip = None,
            appendScriptToExe = None, appendScriptToLibrary = None,
            targetDir = None, binIncludes = [], binExcludes = [],
            binPathIncludes = [], binPathExcludes = [], icon = None,
            includeFiles = [], zipIncludes = [], silent = False,
            namespacePackages = [], metadata = None,
            includeMSVCR = False):
        self.executables = list(executables)
        self.constantsModules = list(constantsModules)
        self.includes = list(includes)
        self.excludes = list(excludes)
        self.packages = list(packages)
        self.namespacePackages = list(namespacePackages)
        self.replacePaths = list(replacePaths)
        self.compress = compress
        self.optimizeFlag = optimizeFlag
        self.copyDependentFiles = copyDependentFiles
        self.initScript = initScript
        self.base = base
        self.path = path
        self.createLibraryZip = createLibraryZip
        self.includeMSVCR = includeMSVCR
        self.appendScriptToExe = appendScriptToExe
        self.appendScriptToLibrary = appendScriptToLibrary
        self.targetDir = targetDir
        self.binIncludes = [os.path.normcase(n) \
                for n in self._GetDefaultBinIncludes() + binIncludes]
        self.binExcludes = [os.path.normcase(n) \
                for n in self._GetDefaultBinExcludes() + binExcludes]
        self.binPathIncludes = [os.path.normcase(n) for n in binPathIncludes]
        self.binPathExcludes = [os.path.normcase(n) \
                for n in self._GetDefaultBinPathExcludes() + binPathExcludes]
        self.icon = icon
        self.includeFiles = list(includeFiles)
        self.includeFiles = self._ProcessPathSpecs(includeFiles)
        self.zipIncludes = self._ProcessPathSpecs(zipIncludes)
        self.silent = silent
        self.metadata = metadata
        self._VerifyConfiguration()

    def _AddVersionResource(self, fileName):
        try:
            from win32verstamp import stamp
        except:
            print("*** WARNING *** unable to create version resource")
            print("install pywin32 extensions first")
            return
        versionInfo = VersionInfo(self.metadata.version,
                comments = self.metadata.long_description,
                description = self.metadata.description,
                company = self.metadata.author,
                product = self.metadata.name)
        stamp(fileName, versionInfo)

    def _CopyFile(self, source, target, copyDependentFiles = False,
            includeMode = False):
        normalizedSource = os.path.normcase(os.path.normpath(source))
        normalizedTarget = os.path.normcase(os.path.normpath(target))
        if normalizedTarget in self.filesCopied:
            return
        if normalizedSource == normalizedTarget:
            return
        self._RemoveFile(target)
        targetDir = os.path.dirname(target)
        self._CreateDirectory(targetDir)
        if not self.silent:
            sys.stdout.write("copying %s -> %s\n" % (source, target))
        shutil.copyfile(source, target)
        shutil.copystat(source, target)
        if includeMode:
            shutil.copymode(source, target)
        self.filesCopied[normalizedTarget] = None
        if copyDependentFiles:
            for source in self._GetDependentFiles(source):
                target = os.path.join(targetDir, os.path.basename(source))
                self._CopyFile(source, target, copyDependentFiles)

    def _CreateDirectory(self, path):
        if not os.path.isdir(path):
            if not self.silent:
                sys.stdout.write("creating directory %s\n" % path)
            os.makedirs(path)

    def _FreezeExecutable(self, exe):
        if self.createLibraryZip:
            finder = self.finder
        else:
            finder = self._GetModuleFinder(exe)
        if exe.script is None:
            scriptModule = None
        else:
            scriptModule = finder.IncludeFile(exe.script, exe.moduleName)
        self._CopyFile(exe.base, exe.targetName, exe.copyDependentFiles,
                includeMode = True)
        if self.includeMSVCR:
            self._IncludeMSVCR(exe)
        if exe.icon is not None:
            if sys.platform == "win32":
                import cx_Freeze.util
                cx_Freeze.util.AddIcon(exe.targetName, exe.icon)
            else:
                targetName = os.path.join(os.path.dirname(exe.targetName),
                        os.path.basename(exe.icon))
                self._CopyFile(exe.icon, targetName,
                        copyDependentFiles = False)
        if not os.access(exe.targetName, os.W_OK):
            mode = os.stat(exe.targetName).st_mode
            os.chmod(exe.targetName, mode | stat.S_IWUSR)
        if self.metadata is not None and sys.platform == "win32":
            self._AddVersionResource(exe.targetName)
        if not exe.appendScriptToLibrary:
            if exe.appendScriptToExe:
                fileName = exe.targetName
            else:
                baseFileName, ext = os.path.splitext(exe.targetName)
                fileName = baseFileName + ".zip"
                self._RemoveFile(fileName)
            if not self.createLibraryZip and exe.copyDependentFiles:
                scriptModule = None
            self._WriteModules(fileName, exe.initScript, finder, exe.compress,
                    exe.copyDependentFiles, scriptModule)

    def _GetBaseFileName(self, argsSource = None):
        if argsSource is None:
            argsSource = self
        name = argsSource.base
        if name is None:
            if argsSource.copyDependentFiles:
                name = "Console"
            else:
                name = "ConsoleKeepPath"
        ext = ".exe" if sys.platform == "win32" else ""
        argsSource.base = self._GetFileName("bases", name, ext)
        if argsSource.base is None:
            raise ConfigError("no base named %s", name)

    def _GetDefaultBinExcludes(self):
        """Return the file names of libraries that need not be included because
           they would normally be expected to be found on the target system or
           because they are part of a package which requires independent
           installation anyway."""
        if sys.platform == "win32":
            return ["comctl32.dll", "oci.dll", "cx_Logging.pyd"]
        else:
            return ["libclntsh.so", "libwtc9.so"]

    def _GetDefaultBinIncludes(self):
        """Return the file names of libraries which must be included for the
           frozen executable to work."""
        if sys.platform == "win32":
            pythonDll = "python%s%s.dll" % sys.version_info[:2]
            return [pythonDll, "gdiplus.dll", "mfc71.dll", "msvcp71.dll",
                    "msvcr71.dll"]
        else:
            soName = distutils.sysconfig.get_config_var("INSTSONAME")
            if soName is None:
                return []
            pythonSharedLib = self._RemoveVersionNumbers(soName)
            return [pythonSharedLib]

    def _GetDefaultBinPathExcludes(self):
        """Return the paths of directories which contain files that should not
           be included, generally because they contain standard system
           libraries."""
        if sys.platform == "win32":
            import cx_Freeze.util
            systemDir = cx_Freeze.util.GetSystemDir()
            windowsDir = cx_Freeze.util.GetWindowsDir()
            return [windowsDir, systemDir, os.path.join(windowsDir, "WinSxS")]
        elif sys.platform == "darwin":
            return ["/lib", "/usr/lib", "/System/Library/Frameworks"]
        else:
            return ["/lib", "/lib32", "/lib64", "/usr/lib", "/usr/lib32",
                    "/usr/lib64"]

    def _GetDependentFiles(self, path):
        """Return the file's dependencies using platform-specific tools (the
           imagehlp library on Windows, otool on Mac OS X and ldd on Linux);
           limit this list by the exclusion lists as needed"""
        dependentFiles = self.dependentFiles.get(path)
        if dependentFiles is None:
            if sys.platform == "win32":
                origPath = os.environ["PATH"]
                os.environ["PATH"] = origPath + os.pathsep + \
                        os.pathsep.join(sys.path)
                import cx_Freeze.util
                dependentFiles = cx_Freeze.util.GetDependentFiles(path)
                os.environ["PATH"] = origPath
            else:
                dependentFiles = []
                if sys.platform == "darwin":
                    command = 'otool -L "%s"' % path
                    splitString = " (compatibility"
                    dependentFileIndex = 0
                else:
                    command = 'ldd "%s"' % path
                    splitString = " => "
                    dependentFileIndex = 1
                for line in os.popen(command):
                    parts = line.expandtabs().strip().split(splitString)
                    if len(parts) != 2:
                        continue
                    dependentFile = parts[dependentFileIndex].strip()
                    if dependentFile in ("not found", "(file not found)"):
                        fileName = parts[0]
                        if fileName not in self.linkerWarnings:
                            self.linkerWarnings[fileName] = None
                            message = "WARNING: cannot find %s\n" % fileName
                            sys.stdout.write(message)
                        continue
                    if dependentFile.startswith("("):
                        continue
                    pos = dependentFile.find(" (")
                    if pos >= 0:
                        dependentFile = dependentFile[:pos].strip()
                    if dependentFile:
                        dependentFiles.append(dependentFile)
            dependentFiles = self.dependentFiles[path] = \
                    [f for f in dependentFiles if self._ShouldCopyFile(f)]
        return dependentFiles

    def _GetFileName(self, dirName, name, ext):
        if os.path.isabs(name):
            return name
        name = os.path.normcase(name)
        if platform.architecture()[0] == "64bit":
            fullDir = os.path.join("Resources", "build", "64bit", dirName)
        else:
            fullDir = os.path.join("Resources", "build", "32bit", dirName)
        if os.path.isdir(fullDir):
            for fileName in os.listdir(fullDir):
                checkName, checkExt = \
                        os.path.splitext(os.path.normcase(fileName))
                if name == checkName and ext == checkExt:
                    return os.path.join(fullDir, fileName)

    def _GetInitScriptFileName(self, argsSource = None):
        if argsSource is None:
            argsSource = self
        name = argsSource.initScript
        if name is None:
            if argsSource.copyDependentFiles:
                name = "Console"
            else:
                name = "ConsoleKeepPath"
            if sys.version_info[0] >= 3:
                name += "3"
        argsSource.initScript = self._GetFileName("initscripts", name, ".py")
        if argsSource.initScript is None:
            raise ConfigError("no initscript named %s", name)

    def _GetModuleFinder(self, argsSource = None):
        if argsSource is None:
            argsSource = self
        finder = cx_Freeze.ModuleFinder(self.includeFiles, argsSource.excludes,
                argsSource.path, argsSource.replacePaths,
                argsSource.copyDependentFiles, compress = argsSource.compress)
        for name in argsSource.namespacePackages:
            package = finder.IncludeModule(name, namespace = True)
            package.ExtendPath()
        for name in argsSource.includes:
            finder.IncludeModule(name)
        for name in argsSource.packages:
            finder.IncludePackage(name)
        return finder

    def _IncludeMSVCR(self, exe):
        msvcRuntimeDll = None
        targetDir = os.path.dirname(exe.targetName)
        for fullName in self.filesCopied:
            path, name = os.path.split(os.path.normcase(fullName))
            if name.startswith("msvcr") and name.endswith(".dll"):
                msvcRuntimeDll = name
                for otherName in [name.replace("r", c) for c in "mp"]:
                    sourceName = os.path.join(self.msvcRuntimeDir, otherName)
                    if not os.path.exists(sourceName):
                        continue
                    targetName = os.path.join(targetDir, otherName)
                    self._CopyFile(sourceName, targetName)
                break
        if msvcRuntimeDll is not None and msvcRuntimeDll == "msvcr90.dll":
            if struct.calcsize("P") == 4:
                arch = "x86"
            else:
                arch = "amd64"
            manifest = MSVCR_MANIFEST_TEMPLATE.strip().replace("{PROC_ARCH}",
                    arch)
            fileName = os.path.join(targetDir, "Microsoft.VC90.CRT.manifest")
            sys.stdout.write("creating %s\n" % fileName)
            open(fileName, "w").write(manifest)

    def _PrintReport(self, fileName, modules):
        sys.stdout.write("writing zip file %s\n\n" % fileName)
        sys.stdout.write("  %-25s %s\n" % ("Name", "File"))
        sys.stdout.write("  %-25s %s\n" % ("----", "----"))
        for module in modules:
            if module.path:
                sys.stdout.write("P")
            else:
                sys.stdout.write("m")
            sys.stdout.write(" %-25s %s\n" % (module.name, module.file or ""))
        sys.stdout.write("\n")

    def _ProcessPathSpecs(self, specs):
        processedSpecs = []
        for spec in specs:
            if not isinstance(spec, (list, tuple)):
                source = target = spec
            elif len(spec) != 2:
                raise ConfigError("path spec must be a list or tuple of "
                        "length two")
            else:
                source, target = spec
            source = os.path.normpath(source)
            if not target:
                dirName, target = os.path.split(source)
            elif os.path.isabs(target):
                raise ConfigError("target path for include file may not be "
                        "an absolute path")
            processedSpecs.append((source, target))
        return processedSpecs

    def _RemoveFile(self, path):
        if os.path.exists(path):
            os.chmod(path, stat.S_IWRITE)
            os.remove(path)

    def _RemoveVersionNumbers(self, libName):
        tweaked = False
        parts = libName.split(".")
        while parts:
            if not parts[-1].isdigit():
                break
            parts.pop(-1)
            tweaked = True
        if tweaked:
            libName = ".".join(parts)
        return libName

    def _ShouldCopyFile(self, path):
        """Return true if the file should be copied to the target machine. This
           is done by checking the binPathIncludes, binPathExcludes,
           binIncludes and binExcludes configuration variables using first the
           full file name, then just the base file name, then the file name
           without any version numbers.
           
           Files are included unless specifically excluded but inclusions take
           precedence over exclusions."""

        # check for C runtime, if desired
        path = os.path.normcase(path)
        dirName, fileName = os.path.split(path)
        if fileName.startswith("msvcr") and fileName.endswith(".dll"):
            self.msvcRuntimeDir = dirName
            return self.includeMSVCR

        # check the full path
        if path in self.binIncludes:
            return True
        if path in self.binExcludes:
            return False

        # check the file name by itself (with any included version numbers)
        if fileName in self.binIncludes:
            return True
        if fileName in self.binExcludes:
            return False

        # check the file name by itself (version numbers removed)
        name = self._RemoveVersionNumbers(fileName)
        if name in self.binIncludes:
            return True
        if name in self.binExcludes:
            return False

        # check the path for inclusion/exclusion
        for path in self.binPathIncludes:
            if dirName.startswith(path):
                return True
        for path in self.binPathExcludes:
            if dirName.startswith(path):
                return False

        return True

    def _VerifyCanAppendToLibrary(self):
        if not self.createLibraryZip:
            raise ConfigError("script cannot be appended to library zip if "
                    "one is not being created")

    def _VerifyConfiguration(self):
        if self.compress is None:
            self.compress = True
        if self.copyDependentFiles is None:
            self.copyDependentFiles = True
        if self.createLibraryZip is None:
            self.createLibraryZip = True
        if self.appendScriptToExe is None:
            self.appendScriptToExe = False
        if self.appendScriptToLibrary is None:
            self.appendScriptToLibrary = \
                    self.createLibraryZip and not self.appendScriptToExe
        if self.targetDir is None:
            self.targetDir = os.path.abspath("dist")
        self._GetInitScriptFileName()
        self._GetBaseFileName()
        if self.path is None:
            self.path = sys.path
        if self.appendScriptToLibrary:
            self._VerifyCanAppendToLibrary()
        for sourceFileName, targetFileName in \
                self.includeFiles + self.zipIncludes:
            if not os.path.exists(sourceFileName):
                raise ConfigError("cannot find file/directory named %s",
                        sourceFileName)
            if os.path.isabs(targetFileName):
                raise ConfigError("target file/directory cannot be absolute")
        for executable in self.executables:
            executable._VerifyConfiguration(self)

    def _WriteModules(self, fileName, initScript, finder, compress,
            copyDependentFiles, scriptModule = None):
        initModule = finder.IncludeFile(initScript, "cx_Freeze__init__")
        if scriptModule is None:
            for module in self.constantsModules:
                module.Create(finder)
            modules = [m for m in finder.modules \
                    if m.name not in self.excludeModules]
        else:
            modules = [initModule, scriptModule]
            self.excludeModules[initModule.name] = None
            self.excludeModules[scriptModule.name] = None
        itemsToSort = [(m.name, m) for m in modules]
        itemsToSort.sort()
        modules = [m for n, m in itemsToSort]
        if not self.silent:
            self._PrintReport(fileName, modules)
        if scriptModule is None:
            finder.ReportMissingModules()
        targetDir = os.path.dirname(fileName)
        self._CreateDirectory(targetDir)
        filesToCopy = []
        if os.path.exists(fileName):
            mode = "a"
        else:
            mode = "w"
        outFile = zipfile.PyZipFile(fileName, mode, zipfile.ZIP_DEFLATED)
        for module in modules:
            if module.code is None and module.file is not None:
                fileName = os.path.basename(module.file)
                baseFileName, ext = os.path.splitext(fileName)
                if baseFileName != module.name and module.name != "zlib":
                    if "." in module.name:
                        fileName = module.name + ext
                    generatedFileName = "ExtensionLoader_%s.py" % \
                            module.name.replace(".", "_")
                    module.code = compile(EXTENSION_LOADER_SOURCE % fileName,
                            generatedFileName, "exec")
                target = os.path.join(targetDir, fileName)
                filesToCopy.append((module, target))
            if module.code is None:
                continue
            fileName = "/".join(module.name.split("."))
            if module.path:
                fileName += "/__init__"
            if module.file is not None and os.path.exists(module.file):
                mtime = os.stat(module.file).st_mtime
            else:
                mtime = time.time()
            zipTime = time.localtime(mtime)[:6]
            # starting with Python 3.3 the pyc file format contains the source
            # size; it is not actually used for anything except determining if
            # the file is up to date so we can safely set this value to zero
            if sys.version_info[:2] < (3, 3):
                header = imp.get_magic() + struct.pack("<i", int(mtime))
            else:
                header = imp.get_magic() + struct.pack("<ii", int(mtime), 0)
            data = header + marshal.dumps(module.code)
            zinfo = zipfile.ZipInfo(fileName + ".pyc", zipTime)
            if compress:
                zinfo.compress_type = zipfile.ZIP_DEFLATED
            outFile.writestr(zinfo, data)

        for sourceFileName, targetFileName in self.zipIncludes:
            outFile.write(sourceFileName, targetFileName)

        outFile.close()

        origPath = os.environ["PATH"]
        for module, target in filesToCopy:
            try:
                if module.parent is not None:
                    path = os.pathsep.join([origPath] + module.parent.path)
                    os.environ["PATH"] = path
                self._CopyFile(module.file, target, copyDependentFiles)
            finally:
                os.environ["PATH"] = origPath

    def Freeze(self):
        self.finder = None
        self.excludeModules = {}
        self.dependentFiles = {}
        self.filesCopied = {}
        self.linkerWarnings = {}
        self.msvcRuntimeDir = None
        import cx_Freeze.util
        cx_Freeze.util.SetOptimizeFlag(self.optimizeFlag)
        if self.createLibraryZip:
            self.finder = self._GetModuleFinder()
        for executable in self.executables:
            self._FreezeExecutable(executable)
        if self.createLibraryZip:
            fileName = os.path.join(self.targetDir, "library.zip")
            self._RemoveFile(fileName)
            self._WriteModules(fileName, self.initScript, self.finder,
                    self.compress, self.copyDependentFiles)
        for sourceFileName, targetFileName in self.includeFiles:
            if os.path.isdir(sourceFileName):
                for path, dirNames, fileNames in os.walk(sourceFileName):
                    shortPath = path[len(sourceFileName) + 1:]
                    if ".svn" in dirNames:
                        dirNames.remove(".svn")
                    if "CVS" in dirNames:
                        dirNames.remove("CVS")
                    fullTargetDir = os.path.join(self.targetDir,
                            targetFileName, shortPath)
                    self._CreateDirectory(fullTargetDir)
                    for fileName in fileNames:
                        fullSourceName = os.path.join(path, fileName)
                        fullTargetName = os.path.join(fullTargetDir, fileName)
                        self._CopyFile(fullSourceName, fullTargetName,
                                copyDependentFiles = False)
            else:
                fullName = os.path.join(self.targetDir, targetFileName)
                self._CopyFile(sourceFileName, fullName,
                        copyDependentFiles = False)


class ConfigError(Exception):

    def __init__(self, format, *args):
        self.what = format % args

    def __str__(self):
        return self.what


class Executable(object):

    def __init__(self, script, initScript = None, base = None, path = None,
            targetDir = None, targetName = None, includes = None,
            excludes = None, packages = None, replacePaths = None,
            compress = None, copyDependentFiles = None,
            appendScriptToExe = None, appendScriptToLibrary = None,
            icon = None, namespacePackages = None, shortcutName = None,
            shortcutDir = None):
        self.script = script
        self.initScript = initScript
        self.base = base
        self.path = path
        self.targetDir = targetDir
        self.targetName = targetName
        self.includes = includes
        self.excludes = excludes
        self.packages = packages
        self.namespacePackages = namespacePackages
        self.replacePaths = replacePaths
        self.compress = compress
        self.copyDependentFiles = copyDependentFiles
        self.appendScriptToExe = appendScriptToExe
        self.appendScriptToLibrary = appendScriptToLibrary
        self.icon = icon
        self.shortcutName = shortcutName
        self.shortcutDir = shortcutDir

    def __repr__(self):
        return "<Executable script=%s>" % self.script

    def _VerifyConfiguration(self, freezer):
        if self.path is None:
            self.path = freezer.path
        if self.targetDir is None:
            self.targetDir = freezer.targetDir
        if self.includes is None:
            self.includes = freezer.includes
        if self.excludes is None:
            self.excludes = freezer.excludes
        if self.packages is None:
            self.packages = freezer.packages
        if self.namespacePackages is None:
            self.namespacePackages = freezer.namespacePackages
        if self.replacePaths is None:
            self.replacePaths = freezer.replacePaths
        if self.compress is None:
            self.compress = freezer.compress
        if self.copyDependentFiles is None:
            self.copyDependentFiles = freezer.copyDependentFiles
        if self.appendScriptToExe is None:
            self.appendScriptToExe = freezer.appendScriptToExe
        if self.appendScriptToLibrary is None:
            self.appendScriptToLibrary = freezer.appendScriptToLibrary
        if self.initScript is None:
            self.initScript = freezer.initScript
        else:
            freezer._GetInitScriptFileName(self)
        if self.base is None:
            self.base = freezer.base
        else:
            freezer._GetBaseFileName(self)
        if self.appendScriptToLibrary:
            freezer._VerifyCanAppendToLibrary()
        if self.icon is None:
            self.icon = freezer.icon
        if self.targetName is None:
            name, ext = os.path.splitext(os.path.basename(self.script))
            baseName, ext = os.path.splitext(self.base)
            self.targetName = name + ext
        if self.appendScriptToLibrary:
            name, ext = os.path.splitext(self.targetName)
            self.moduleName = "%s__main__" % os.path.normcase(name)
        else:
            self.moduleName = "__main__"
        self.targetName = os.path.join(self.targetDir, self.targetName)


class ConstantsModule(object):

    def __init__(self, releaseString = None, copyright = None,
            moduleName = "BUILD_CONSTANTS", timeFormat = "%B %d, %Y %H:%M:%S"):
        self.moduleName = moduleName
        self.timeFormat = timeFormat
        self.values = {}
        self.values["BUILD_RELEASE_STRING"] = releaseString
        self.values["BUILD_COPYRIGHT"] = copyright

    def Create(self, finder):
        """Create the module which consists of declaration statements for each
           of the values."""
        today = datetime.datetime.today()
        sourceTimestamp = 0
        for module in finder.modules:
            if module.file is None:
                continue
            if module.inZipFile:
                continue
            if not os.path.exists(module.file):
                raise ConfigError("no file named %s (for module %s)",
                        module.file, module.name)
            timestamp = os.stat(module.file).st_mtime
            sourceTimestamp = max(sourceTimestamp, timestamp)
        sourceTimestamp = datetime.datetime.fromtimestamp(sourceTimestamp)
        self.values["BUILD_TIMESTAMP"] = today.strftime(self.timeFormat)
        self.values["BUILD_HOST"] = socket.gethostname().split(".")[0]
        self.values["SOURCE_TIMESTAMP"] = \
                sourceTimestamp.strftime(self.timeFormat)
        module = finder._AddModule(self.moduleName)
        sourceParts = []
        names = list(self.values.keys())
        names.sort()
        for name in names:
            value = self.values[name]
            sourceParts.append("%s = %r" % (name, value))
        source = "\n".join(sourceParts)
        module.code = compile(source, "%s.py" % self.moduleName, "exec")
        return module


class VersionInfo(object):

    def __init__(self, version, internalName = None, originalFileName = None,
            comments = None, company = None, description = None,
            copyright = None, trademarks = None, product = None, dll = False,
            debug = False, verbose = True):
        parts = version.split(".")
        while len(parts) < 4:
            parts.append("0")
        self.version = ".".join(parts)
        self.internal_name = internalName
        self.original_filename = originalFileName
        self.comments = comments
        self.company = company
        self.description = description
        self.copyright = copyright
        self.trademarks = trademarks
        self.product = product
        self.dll = dll
        self.debug = debug
        self.verbose = verbose


########NEW FILE########
__FILENAME__ = hooks
import os
import sys

def initialize(finder):
    """upon initialization of the finder, this routine is called to set up some
       automatic exclusions for various platforms."""
    finder.ExcludeModule("FCNTL")
    finder.ExcludeModule("os.path")
    if os.name == "nt":
        finder.ExcludeModule("fcntl")
        finder.ExcludeModule("grp")
        finder.ExcludeModule("pwd")
        finder.ExcludeModule("termios")
    else:
        finder.ExcludeModule("_subprocess")
        finder.ExcludeModule("_winreg")
        finder.ExcludeModule("msilib")
        finder.ExcludeModule("msvcrt")
        finder.ExcludeModule("multiprocessing._multiprocessing")
        finder.ExcludeModule("nt")
        if os.name not in ("os2", "ce"):
            finder.ExcludeModule("ntpath")
        finder.ExcludeModule("nturl2path")
        finder.ExcludeModule("pyHook")
        finder.ExcludeModule("pythoncom")
        finder.ExcludeModule("pywintypes")
        finder.ExcludeModule("winerror")
        finder.ExcludeModule("winsound")
        finder.ExcludeModule("win32api")
        finder.ExcludeModule("win32con")
        finder.ExcludeModule("win32gui")
        finder.ExcludeModule("win32event")
        finder.ExcludeModule("win32evtlog")
        finder.ExcludeModule("win32evtlogutil")
        finder.ExcludeModule("win32file")
        finder.ExcludeModule("win32pdh")
        finder.ExcludeModule("win32pipe")
        finder.ExcludeModule("win32process")
        finder.ExcludeModule("win32security")
        finder.ExcludeModule("win32service")
        finder.ExcludeModule("wx.activex")
    if os.name != "posix":
        finder.ExcludeModule("posix")
    if sys.platform != "darwin":
        finder.ExcludeModule("Carbon")
        finder.ExcludeModule("gestalt")
        finder.ExcludeModule("ic")
        finder.ExcludeModule("mac")
        finder.ExcludeModule("MacOS")
        finder.ExcludeModule("macostools")
        finder.ExcludeModule("macpath")
        finder.ExcludeModule("macurl2path")
        finder.ExcludeModule("_scproxy")
        if os.name != "nt":
            finder.ExcludeModule("EasyDialogs")
    if os.name != "os2":
        finder.ExcludeModule("os2")
        finder.ExcludeModule("os2emxpath")
        finder.ExcludeModule("_emx_link")
    if os.name != "ce":
        finder.ExcludeModule("ce")
    if os.name != "riscos":
        finder.ExcludeModule("riscos")
        finder.ExcludeModule("riscosenviron")
        finder.ExcludeModule("riscospath")
        finder.ExcludeModule("rourl2path")
    if sys.platform[:4] != "java":
        finder.ExcludeModule("java.lang")
        finder.ExcludeModule("org.python.core")
    if sys.platform[:4] != "OpenVMS":
        finder.ExcludeModule("vms_lib")
    if sys.version_info[0] >= 3:
        finder.ExcludeModule("new")
        finder.ExcludeModule("Tkinter")
    else:
        finder.ExcludeModule("tkinter")


def load_cElementTree(finder, module):
    """the cElementTree module implicitly loads the elementtree.ElementTree
       module; make sure this happens."""
    finder.IncludeModule("elementtree.ElementTree")


def load_ceODBC(finder, module):
    """the ceODBC module implicitly imports both datetime and decimal; make
       sure this happens."""
    finder.IncludeModule("datetime")
    finder.IncludeModule("decimal")


def load_cx_Oracle(finder, module):
    """the cx_Oracle module implicitly imports datetime; make sure this
       happens."""
    finder.IncludeModule("datetime")
    try:
        finder.IncludeModule("decimal")
    except ImportError:
        pass


def load_datetime(finder, module):
    """the datetime module implicitly imports time; make sure this happens."""
    finder.IncludeModule("time")


def load_docutils_frontend(finder, module):
    """The optik module is the old name for the optparse module; ignore the
       module if it cannot be found."""
    module.IgnoreName("optik")


def load_dummy_threading(finder, module):
    """the dummy_threading module plays games with the name of the threading
       module for its own purposes; ignore that here"""
    finder.ExcludeModule("_dummy_threading")


def load_email(finder, module):
    """the email package has a bunch of aliases as the submodule names were
       all changed to lowercase in Python 2.5; mimic that here."""
    if sys.version_info[:2] >= (2, 5):
        for name in ("Charset", "Encoders", "Errors", "FeedParser",
                "Generator", "Header", "Iterators", "Message", "Parser",
                "Utils", "base64MIME", "quopriMIME"):
            finder.AddAlias("email.%s" % name, "email.%s" % name.lower())


def load_ftplib(finder, module):
    """the ftplib module attempts to import the SOCKS module; ignore this
       module if it cannot be found"""
    module.IgnoreName("SOCKS")


def load_GifImagePlugin(finder, module):
    """The GifImagePlugin module optionally imports the _imaging_gif module"""
    module.IgnoreName("_imaging_gif")


def load_glib(finder, module):
    """Ignore globals that are imported."""
    module.AddGlobalName("GError")
    module.AddGlobalName("IOChannel")
    module.AddGlobalName("IO_ERR")
    module.AddGlobalName("IO_FLAG_APPEND")
    module.AddGlobalName("IO_FLAG_GET_MASK")
    module.AddGlobalName("IO_FLAG_IS_READABLE")
    module.AddGlobalName("IO_FLAG_IS_SEEKABLE")
    module.AddGlobalName("IO_FLAG_IS_WRITEABLE")
    module.AddGlobalName("IO_FLAG_MASK")
    module.AddGlobalName("IO_FLAG_NONBLOCK")
    module.AddGlobalName("IO_FLAG_SET_MASK")
    module.AddGlobalName("IO_HUP")
    module.AddGlobalName("IO_IN")
    module.AddGlobalName("IO_NVAL")
    module.AddGlobalName("IO_OUT")
    module.AddGlobalName("IO_PRI")
    module.AddGlobalName("IO_STATUS_AGAIN")
    module.AddGlobalName("IO_STATUS_EOF")
    module.AddGlobalName("IO_STATUS_ERROR")
    module.AddGlobalName("IO_STATUS_NORMAL")
    module.AddGlobalName("Idle")
    module.AddGlobalName("MainContext")
    module.AddGlobalName("MainLoop")
    module.AddGlobalName("OPTION_ERROR")
    module.AddGlobalName("OPTION_ERROR_BAD_VALUE")
    module.AddGlobalName("OPTION_ERROR_FAILED")
    module.AddGlobalName("OPTION_ERROR_UNKNOWN_OPTION")
    module.AddGlobalName("OPTION_FLAG_FILENAME")
    module.AddGlobalName("OPTION_FLAG_HIDDEN")
    module.AddGlobalName("OPTION_FLAG_IN_MAIN")
    module.AddGlobalName("OPTION_FLAG_NOALIAS")
    module.AddGlobalName("OPTION_FLAG_NO_ARG")
    module.AddGlobalName("OPTION_FLAG_OPTIONAL_ARG")
    module.AddGlobalName("OPTION_FLAG_REVERSE")
    module.AddGlobalName("OPTION_REMAINING")
    module.AddGlobalName("OptionContext")
    module.AddGlobalName("OptionGroup")
    module.AddGlobalName("PRIORITY_DEFAULT")
    module.AddGlobalName("PRIORITY_DEFAULT_IDLE")
    module.AddGlobalName("PRIORITY_HIGH")
    module.AddGlobalName("PRIORITY_HIGH_IDLE")
    module.AddGlobalName("PRIORITY_LOW")
    module.AddGlobalName("Pid")
    module.AddGlobalName("PollFD")
    module.AddGlobalName("SPAWN_CHILD_INHERITS_STDIN")
    module.AddGlobalName("SPAWN_DO_NOT_REAP_CHILD")
    module.AddGlobalName("SPAWN_FILE_AND_ARGV_ZERO")
    module.AddGlobalName("SPAWN_LEAVE_DESCRIPTORS_OPEN")
    module.AddGlobalName("SPAWN_SEARCH_PATH")
    module.AddGlobalName("SPAWN_STDERR_TO_DEV_NULL")
    module.AddGlobalName("SPAWN_STDOUT_TO_DEV_NULL")
    module.AddGlobalName("Source")
    module.AddGlobalName("Timeout")
    module.AddGlobalName("child_watch_add")
    module.AddGlobalName("filename_display_basename")
    module.AddGlobalName("filename_display_name")
    module.AddGlobalName("filename_from_utf8")
    module.AddGlobalName("get_application_name")
    module.AddGlobalName("get_current_time")
    module.AddGlobalName("get_prgname")
    module.AddGlobalName("glib_version")
    module.AddGlobalName("idle_add")
    module.AddGlobalName("io_add_watch")
    module.AddGlobalName("main_context_default")
    module.AddGlobalName("main_depth")
    module.AddGlobalName("markup_escape_text")
    module.AddGlobalName("set_application_name")
    module.AddGlobalName("set_prgname")
    module.AddGlobalName("source_remove")
    module.AddGlobalName("spawn_async")
    module.AddGlobalName("timeout_add")
    module.AddGlobalName("timeout_add_seconds")


def load_gtk__gtk(finder, module):
    """the gtk._gtk module has a number of implicit imports"""
    finder.IncludeModule("atk")
    finder.IncludeModule("cairo")
    finder.IncludeModule("gio")
    finder.IncludeModule("pango")
    finder.IncludeModule("pangocairo")


def load_hashlib(finder, module):
    """hashlib's fallback modules don't exist if the equivalent OpenSSL
    algorithms are loaded from _hashlib, so we can ignore the error."""
    module.IgnoreName("_md5")
    module.IgnoreName("_sha")
    module.IgnoreName("_sha256")
    module.IgnoreName("_sha512")


def load_h5py(finder, module):
    """h5py module has a number of implicit imports"""
    finder.IncludeModule('h5py.defs')
    finder.IncludeModule('h5py.utils')
    finder.IncludeModule('h5py._proxy')
    finder.IncludeModule('h5py.api_gen')


def load_matplotlib(finder, module):
    """the matplotlib module requires data to be found in mpl-data in the
       same directory as the frozen executable so oblige it"""
    dir = os.path.join(module.path[0], "mpl-data")
    finder.IncludeFiles(dir, "mpl-data")


def load_matplotlib_numerix(finder, module):
    """the numpy.numerix module loads a number of modules dynamically"""
    for name in ("ma", "fft", "linear_algebra", "random_array", "mlab"):
        finder.IncludeModule("%s.%s" % (module.name, name))


def load_Numeric(finder, module):
    """the Numeric module optionally loads the dotblas module; ignore the error
       if this modules does not exist."""
    module.IgnoreName("dotblas")


def load_numpy_core_multiarray(finder, module):
    """the numpy.core.multiarray module is an extension module and the numpy
       module imports * from this module; define the list of global names
       available to this module in order to avoid spurious errors about missing
       modules"""
    module.AddGlobalName("arange")


def load_numpy_core_numerictypes(finder, module):
    """the numpy.core.numerictypes module adds a number of items to itself
       dynamically; define these to avoid spurious errors about missing
       modules"""
    module.AddGlobalName("bool_")
    module.AddGlobalName("cdouble")
    module.AddGlobalName("complexfloating")
    module.AddGlobalName("csingle")
    module.AddGlobalName("double")
    module.AddGlobalName("float64")
    module.AddGlobalName("float_")
    module.AddGlobalName("inexact")
    module.AddGlobalName("intc")
    module.AddGlobalName("int32")
    module.AddGlobalName("number")
    module.AddGlobalName("single")


def load_numpy_core_umath(finder, module):
    """the numpy.core.umath module is an extension module and the numpy module
       imports * from this module; define the list of global names available
       to this module in order to avoid spurious errors about missing
       modules"""
    module.AddGlobalName("add")
    module.AddGlobalName("absolute")
    module.AddGlobalName("arccos")
    module.AddGlobalName("arccosh")
    module.AddGlobalName("arcsin")
    module.AddGlobalName("arcsinh")
    module.AddGlobalName("arctan")
    module.AddGlobalName("arctanh")
    module.AddGlobalName("bitwise_and")
    module.AddGlobalName("bitwise_or")
    module.AddGlobalName("bitwise_xor")
    module.AddGlobalName("ceil")
    module.AddGlobalName("conj")
    module.AddGlobalName("conjugate")
    module.AddGlobalName("cosh")
    module.AddGlobalName("divide")
    module.AddGlobalName("fabs")
    module.AddGlobalName("floor")
    module.AddGlobalName("floor_divide")
    module.AddGlobalName("fmod")
    module.AddGlobalName("greater")
    module.AddGlobalName("hypot")
    module.AddGlobalName("invert")
    module.AddGlobalName("isfinite")
    module.AddGlobalName("isinf")
    module.AddGlobalName("isnan")
    module.AddGlobalName("less")
    module.AddGlobalName("left_shift")
    module.AddGlobalName("log")
    module.AddGlobalName("logical_and")
    module.AddGlobalName("logical_not")
    module.AddGlobalName("logical_or")
    module.AddGlobalName("logical_xor")
    module.AddGlobalName("maximum")
    module.AddGlobalName("minimum")
    module.AddGlobalName("multiply")
    module.AddGlobalName("negative")
    module.AddGlobalName("not_equal")
    module.AddGlobalName("power")
    module.AddGlobalName("remainder")
    module.AddGlobalName("right_shift")
    module.AddGlobalName("sign")
    module.AddGlobalName("sinh")
    module.AddGlobalName("sqrt")
    module.AddGlobalName("tan")
    module.AddGlobalName("tanh")
    module.AddGlobalName("true_divide")


def load_numpy_distutils_command_scons(finder, module):
    """the numpy.distutils.command.scons module optionally imports the numscons
       module; ignore the error if the module cannot be found."""
    module.IgnoreName("numscons")


def load_numpy_distutils_misc_util(finder, module):
    """the numpy.distutils.misc_util module optionally imports the numscons
       module; ignore the error if the module cannot be found."""
    module.IgnoreName("numscons")


def load_numpy_distutils_system_info(finder, module):
    """the numpy.distutils.system_info module optionally imports the Numeric
       module; ignore the error if the module cannot be found."""
    module.IgnoreName("Numeric")


def load_numpy_f2py___version__(finder, module):
    """the numpy.f2py.__version__ module optionally imports the __svn_version__
       module; ignore the error if the module cannot be found."""
    module.IgnoreName("__svn_version__")


def load_numpy_linalg(finder, module):
    """the numpy.linalg module implicitly loads the lapack_lite module; make
       sure this happens"""
    finder.IncludeModule("numpy.linalg.lapack_lite")


def load_numpy_random_mtrand(finder, module):
    """the numpy.random.mtrand module is an extension module and the numpy
       module imports * from this module; define the list of global names
       available to this module in order to avoid spurious errors about missing
       modules"""
    module.AddGlobalName("rand")
    module.AddGlobalName("randn")


def load_postgresql_lib(finder, module):
    """the postgresql.lib module requires the libsys.sql file to be included
       so make sure that file is included"""
    fileName = os.path.join(module.path[0], "libsys.sql")
    finder.IncludeFiles(fileName, os.path.basename(fileName))


def load_pty(finder, module):
    """The sgi module is not needed for this module to function."""
    module.IgnoreName("sgi")


def load_pydoc(finder, module):
    """The pydoc module will work without the Tkinter module so ignore the
       error if that module cannot be found."""
    module.IgnoreName("Tkinter")


def load_pythoncom(finder, module):
    """the pythoncom module is actually contained in a DLL but since those
       cannot be loaded directly in Python 2.5 and higher a special module is
       used to perform that task; simply use that technique directly to
       determine the name of the DLL and ensure it is included as a normal
       extension; also load the pywintypes module which is implicitly
       loaded."""
    import pythoncom
    module.file = pythoncom.__file__
    module.code = None
    finder.IncludeModule("pywintypes")


def load_pywintypes(finder, module):
    """the pywintypes module is actually contained in a DLL but since those
       cannot be loaded directly in Python 2.5 and higher a special module is
       used to perform that task; simply use that technique directly to
       determine the name of the DLL and ensure it is included as a normal
       extension."""
    import pywintypes
    module.file = pywintypes.__file__
    module.code = None

# PyQt5 and PyQt4 can't both be loaded in the same process, so we cache the
# QtCore module so we can still return something sensible if we try to load
# both.
_qtcore = None
def _qt_implementation(module):
    """Helper function to get name (PyQt4, PyQt5, PySide) and the QtCore module
    """
    global _qtcore
    name = module.name.split('.')[0]
    try:
        _qtcore = __import__(name, fromlist=['QtCore']).QtCore
    except RuntimeError:
        print("WARNING: Tried to load multiple incompatible Qt wrappers. "
              "Some incorrect files may be copied.")
    return name, _qtcore

def copy_qt_plugins(plugins, finder, QtCore):
    """Helper function to find and copy Qt plugins."""
    
    # Qt Plugins can either be in a plugins directory next to the Qt libraries,
    # or in other locations listed by QCoreApplication.libraryPaths()
    dir0 = os.path.join(os.path.dirname(QtCore.__file__), "plugins")
    for libpath in QtCore.QCoreApplication.libraryPaths() + [dir0]:
        sourcepath = os.path.join(str(libpath), plugins)
        if os.path.exists(sourcepath):
            finder.IncludeFiles(sourcepath, plugins)


def load_PyQt4_phonon(finder, module):
    """In Windows, phonon4.dll requires an additional dll phonon_ds94.dll to
       be present in the build directory inside a folder phonon_backend."""
    name, QtCore = _qt_implementation(module)
    if sys.platform == "win32":
        copy_qt_plugins("phonon_backend", finder, QtCore)

load_PySide_phonon = load_PyQt5_phonon = load_PyQt4_phonon

def load_PyQt4_QtCore(finder, module):
    """the PyQt4.QtCore module implicitly imports the sip module and,
       depending on configuration, the PyQt4._qt module."""
    name, QtCore = _qt_implementation(module)
    finder.IncludeModule("sip")
    try:
        finder.IncludeModule("%s._qt" % name)
    except ImportError:
        pass

load_PyQt5_QtCore = load_PyQt4_QtCore

def load_PySide_QtCore(finder, module):
    """PySide.QtCore dynamically loads the stdlib atexit module."""
    finder.IncludeModule("atexit")

def load_PyQt4_Qt(finder, module):
    """the PyQt4.Qt module is an extension module which imports a number of
       other modules and injects their namespace into its own. It seems a
       foolish way of doing things but perhaps there is some hidden advantage
       to this technique over pure Python; ignore the absence of some of
       the modules since not every installation includes all of them."""
    name, QtCore = _qt_implementation(module)
    finder.IncludeModule("%s.QtCore" % name)
    finder.IncludeModule("%s.QtGui" % name)
    for mod in ("_qt", "QtSvg", "Qsci", "QtAssistant", "QtNetwork", "QtOpenGL",
                "QtScript", "QtSql", "QtSvg", "QtTest", "QtXml"):
        try:
            finder.IncludeModule(name + '.' + mod)
        except ImportError:
            pass

load_PyQt5_Qt = load_PyQt4_Qt

def load_PyQt4_uic(finder, module):
    """The uic module makes use of "plugins" that need to be read directly and
       cannot be frozen; the PyQt4.QtWebKit and PyQt4.QtNetwork modules are
       also implicity loaded."""
    name, QtCore = _qt_implementation(module)
    dir = os.path.join(module.path[0], "widget-plugins")
    finder.IncludeFiles(dir, "%s.uic.widget-plugins" % name)
    finder.IncludeModule("%s.QtNetwork" % name)
    finder.IncludeModule("%s.QtWebKit" % name)

load_PyQt5_uic = load_PyQt4_uic

def _QtGui(finder, module, version_str):
    name, QtCore = _qt_implementation(module)
    finder.IncludeModule("%s.QtCore" % name)
    copy_qt_plugins("imageformats", finder, QtCore)
    if version_str >= '5':
        # On Qt5, we need the platform plugins. For simplicity, we just copy any
        # that are installed.
        copy_qt_plugins("platforms", finder, QtCore)

def load_PyQt4_QtGui(finder, module):
    """There is a chance that GUI will use some image formats
    add the image format plugins
    """
    name, QtCore = _qt_implementation(module)
    _QtGui(finder, module, QtCore.QT_VERSION_STR)

load_PyQt5_QtGui = load_PyQt4_QtGui

def load_PySide_QtGui(finder, module):
    """There is a chance that GUI will use some image formats
    add the image format plugins
    """
    from PySide import QtCore
    # Pyside.__version* is PySide version, PySide.QtCore.__version* is Qt version
    _QtGui(finder, module, QtCore.__version__)

def load_PyQt5_QtWidgets(finder, module):
    finder.IncludeModule('PyQt5.QtGui')

def load_scipy(finder, module):
    """the scipy module loads items within itself in a way that causes
       problems without the entire package and a number of other subpackages
       being present."""
    finder.IncludePackage("scipy.lib")
    finder.IncludePackage("scipy.misc")


def load_scipy_linalg(finder, module):
    """the scipy.linalg module loads items within itself in a way that causes
       problems without the entire package being present."""
    module.AddGlobalName("norm")
    finder.IncludePackage("scipy.linalg")


def load_scipy_linalg_interface_gen(finder, module):
    """the scipy.linalg.interface_gen module optionally imports the pre module;
       ignore the error if this module cannot be found"""
    module.IgnoreName("pre")


def load_scipy_sparse_linalg_dsolve_linsolve(finder, module):
    """the scipy.linalg.dsolve.linsolve optionally loads scikits.umfpack"""
    module.IgnoreName("scikits.umfpack")


def load_scipy_special__cephes(finder, module):
    """the scipy.special._cephes is an extension module and the scipy module
       imports * from it in places; advertise the global names that are used
       in order to avoid spurious errors about missing modules."""
    module.AddGlobalName("gammaln")


def load_setuptools_extension(finder, module):
    """the setuptools.extension module optionally loads
       Pyrex.Distutils.build_ext but its absence is not considered an error."""
    module.IgnoreName("Pyrex.Distutils.build_ext")


def load_site(finder, module):
    """the site module optionally loads the sitecustomize and usercustomize
       modules; ignore the error if these modules do not exist."""
    module.IgnoreName("sitecustomize")
    module.IgnoreName("usercustomize")


def load_tkinter(finder, module):
    """the tkinter module has data files that are required to be loaded so
       ensure that they are copied into the directory that is expected at
       runtime."""
    if sys.platform == "win32":
        import tkinter
        import _tkinter
        tclSourceDir = os.environ["TCL_LIBRARY"]
        tkSourceDir = os.environ["TK_LIBRARY"]
        finder.IncludeFiles(tclSourceDir, "tcl")
        finder.IncludeFiles(tkSourceDir, "tk")


def load_Tkinter(finder, module):
    """the Tkinter module has data files that are required to be loaded so
       ensure that they are copied into the directory that is expected at
       runtime."""
    import Tkinter
    import _tkinter
    tk = _tkinter.create()
    tclDir = os.path.dirname(tk.call("info", "library"))
    # on OS X, Tcl and Tk are organized in frameworks, different layout
    if sys.platform == 'darwin' and tk.call('tk', 'windowingsystem') == 'aqua':
        tclSourceDir=os.path.join(os.path.split(tclDir)[0], 'Tcl')
        tkSourceDir = tclSourceDir.replace('Tcl', 'Tk')
    else:
        tclSourceDir = os.path.join(tclDir, "tcl%s" % _tkinter.TCL_VERSION)
        tkSourceDir = os.path.join(tclDir, "tk%s" % _tkinter.TK_VERSION)
    finder.IncludeFiles(tclSourceDir, "tcl")
    finder.IncludeFiles(tkSourceDir, "tk")


def load_tempfile(finder, module):
    """the tempfile module attempts to load the fcntl and thread modules but
       continues if these modules cannot be found; ignore these modules if they
       cannot be found."""
    module.IgnoreName("fcntl")
    module.IgnoreName("thread")


def load_time(finder, module):
    """the time module implicitly loads _strptime; make sure this happens."""
    finder.IncludeModule("_strptime")


def load_twisted_conch_ssh_transport(finder, module):
    """the twisted.conch.ssh.transport module uses __import__ builtin to
       dynamically load different ciphers at runtime."""
    finder.IncludePackage("Crypto.Cipher")


def load_twitter(finder, module):
    """the twitter module tries to load the simplejson, json and django.utils
       module in an attempt to locate any module that will implement the
       necessary protocol; ignore these modules if they cannot be found."""
    module.IgnoreName("json")
    module.IgnoreName("simplejson")
    module.IgnoreName("django.utils")


def load_win32api(finder, module):
    """the win32api module implicitly loads the pywintypes module; make sure
       this happens."""
    finder.IncludeModule("pywintypes")


def load_win32com(finder, module):
    """the win32com package manipulates its search path at runtime to include
       the sibling directory called win32comext; simulate that by changing the
       search path in a similar fashion here."""
    baseDir = os.path.dirname(os.path.dirname(module.file))
    module.path.append(os.path.join(baseDir, "win32comext"))


def load_win32file(finder, module):
    """the win32api module implicitly loads the pywintypes module; make sure
       this happens."""
    finder.IncludeModule("pywintypes")


def load_wx_lib_pubsub_core(finder, module):
    """the wx.lib.pubsub.core module modifies the search path which cannot
       be done in a frozen application in the same way; modify the module
       search path here instead so that the right modules are found; note
       that this only works if the import of wx.lib.pubsub.setupkwargs
       occurs first."""
    dirName = os.path.dirname(module.file)
    module.path.insert(0, os.path.join(dirName, "kwargs"))


def load_Xlib_display(finder, module):
    """the Xlib.display module implicitly loads a number of extension modules;
       make sure this happens."""
    finder.IncludeModule("Xlib.ext.xtest")
    finder.IncludeModule("Xlib.ext.shape")
    finder.IncludeModule("Xlib.ext.xinerama")
    finder.IncludeModule("Xlib.ext.record")
    finder.IncludeModule("Xlib.ext.composite")
    finder.IncludeModule("Xlib.ext.randr")


def load_Xlib_support_connect(finder, module):
    """the Xlib.support.connect module implicitly loads a platform specific
       module; make sure this happens."""
    if sys.platform.split("-")[0] == "OpenVMS":
        moduleName = "vms_connect"
    else:
        moduleName = "unix_connect"
    finder.IncludeModule("Xlib.support.%s" % moduleName)


def load_Xlib_XK(finder, module):
    """the Xlib.XK module implicitly loads some keysymdef modules; make sure
       this happens."""
    finder.IncludeModule("Xlib.keysymdef.miscellany")
    finder.IncludeModule("Xlib.keysymdef.latin1")


def load_xml(finder, module):
    """the builtin xml package attempts to load the _xmlplus module to see if
       that module should take its role instead; ignore the failure to find
       this module, though."""
    module.IgnoreName("_xmlplus")


def load_xml_etree_cElementTree(finder, module):
    """the xml.etree.cElementTree module implicitly loads the
       xml.etree.ElementTree module; make sure this happens."""
    finder.IncludeModule("xml.etree.ElementTree")


def load_xmlrpclib(finder, module):
    """the xmlrpclib optionally imports the _xmlrpclib and sgmlop modules;
       ignore the error if these modules cannot be found."""
    module.IgnoreName("_xmlrpclib")
    module.IgnoreName("sgmlop")


def load_zope(finder, module):
    """the zope package is distributed in multiple packages and they need to be
       stitched back together again."""
    module.ExtendPath()


def load_zope_component(finder, module):
    """the zope.component package requires the presence of the pkg_resources
       module but it uses a dynamic, not static import to do its work."""
    finder.IncludeModule("pkg_resources")


def missing_cElementTree(finder, caller):
    """the cElementTree has been incorporated into the standard library in
       Python 2.5 so ignore its absence if it cannot found."""
    if sys.version_info[:2] >= (2, 5):
        caller.IgnoreName("cElementTree")


def missing_EasyDialogs(finder, caller):
    """the EasyDialogs module is not normally present on Windows but it also
       may be so instead of excluding it completely, ignore it if it can't be
       found"""
    if sys.platform == "win32":
        caller.IgnoreName("EasyDialogs")


def missing_gdk(finder, caller):
    """the gdk module is buried inside gtk so there is no need to concern
       ourselves with an error saying that it cannot be found"""
    caller.IgnoreName("gdk")


def missing_ltihooks(finder, caller):
    """this module is not necessairly present so ignore it when it cannot be
       found"""
    caller.IgnoreName("ltihooks")


def missing_readline(finder, caller):
    """the readline module is not normally present on Windows but it also may
       be so instead of excluding it completely, ignore it if it can't be
       found"""
    if sys.platform == "win32":
        caller.IgnoreName("readline")


def missing_xml_etree(finder, caller):
    """the xml.etree package is new for Python 2.5 but it is common practice
       to use a try..except.. block in order to support versions earlier than
       Python 2.5 transparently; ignore the absence of the package in this
       situation."""
    if sys.version_info[:2] < (2, 5):
        caller.IgnoreName("xml.etree")


########NEW FILE########
__FILENAME__ = macdist
from distutils.core import Command
import distutils.errors
import distutils.util
import os
import stat
import subprocess

__all__ = [ "bdist_dmg", "bdist_mac" ]

PLIST_TEMPLATE = \
"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleIconFile</key>
	<string>icon.icns</string>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleExecutable</key>
	<string>%(bundle_executable)s</string>
</dict>
</plist>
"""

class bdist_dmg(Command):
    description = "create a Mac DMG disk image containing the Mac " \
            "application bundle"
    user_options = [
        ('volume-label=', None, 'Volume label of the DMG disk image'),
        ('applications-shortcut=', None, 'Boolean for whether to include ' \
            'shortcut to Applications in the DMG disk image'),
    ]

    def initialize_options(self):
        self.volume_label = self.distribution.get_fullname()
        self.applications_shortcut = False

    def finalize_options(self):
        pass

    def buildDMG(self):
        # Remove DMG if it already exists
        if os.path.exists(self.dmgName):
            os.unlink(self.dmgName)

        createargs = [
            'hdiutil', 'create', '-fs', 'HFSX', '-format', 'UDZO',
            self.dmgName, '-imagekey', 'zlib-level=9', '-srcfolder',
            self.bundleDir, '-volname', self.volume_label
        ]

        if self.applications_shortcut:
            scriptargs = [
                'osascript', '-e', 'tell application "Finder" to make alias \
                file to POSIX file "/Applications" at POSIX file "%s"' %
                os.path.realpath(self.buildDir)
            ]

            if os.spawnvp(os.P_WAIT, 'osascript', scriptargs) != 0:
                raise OSError('creation of Applications shortcut failed')

            createargs.append('-srcfolder')
            createargs.append(self.buildDir + '/Applications')

        # Create the dmg
        if os.spawnvp(os.P_WAIT, 'hdiutil', createargs) != 0:
            raise OSError('creation of the dmg failed')

    def run(self):
        # Create the application bundle
        self.run_command('bdist_mac')

        # Find the location of the application bundle and the build dir
        self.bundleDir = self.get_finalized_command('bdist_mac').bundleDir
        self.buildDir = self.get_finalized_command('build').build_base

        # Set the file name of the DMG to be built
        self.dmgName = os.path.join(self.buildDir,
                self.distribution.get_fullname() + '.dmg')

        self.execute(self.buildDMG,())


class bdist_mac(Command):
    description = "create a Mac application bundle"

    user_options = [
        ('iconfile=', None, 'Path to an icns icon file for the application.'),
        ('qt-menu-nib=', None, 'Location of qt_menu.nib folder for Qt ' \
                'applications. Will be auto-detected by default.'),
        ('bundle-name=', None, 'File name for the bundle application ' \
                'without the .app extension.')
    ]

    def initialize_options(self):
        self.iconfile = None
        self.qt_menu_nib = False
        self.bundle_name = self.distribution.get_fullname()

    def finalize_options(self):
        pass

    def create_plist(self):
        """Create the Contents/Info.plist file"""
        plist = open(os.path.join(self.contentsDir, 'Info.plist'),'w')
        plist.write(PLIST_TEMPLATE % self.__dict__)
        plist.close()

    def setRelativeReferencePaths(self):
        """ For all files in Contents/MacOS, check if they are binaries
            with references to other files in that dir. If so, make those
            references relative. The appropriate commands are applied to all
            files; they will just fail for files on which they do not apply."""
        files = os.listdir(self.binDir)
        for fileName in files:

            # install_name_tool can't handle zip files or directories
            filePath = os.path.join(self.binDir, fileName)
            if fileName.endswith('.zip') or os.path.isdir(filePath):
                continue

            # ensure write permissions
            mode = os.stat(filePath).st_mode
            if not (mode & stat.S_IWUSR):
                os.chmod(filePath, mode | stat.S_IWUSR)

            # let the file itself know its place
            subprocess.call(('install_name_tool', '-id',
                    '@executable_path/' + fileName, filePath))

            # find the references: call otool -L on the file
            otool = subprocess.Popen(('otool', '-L', filePath),
                    stdout = subprocess.PIPE)
            references = otool.stdout.readlines()[1:]

            for reference in references:

                # find the actual referenced file name
                referencedFile = reference.decode().strip().split()[0]

                if referencedFile.startswith('@'):
                    # the referencedFile is already a relative path
                    continue

                path, name = os.path.split(referencedFile)

                # see if we provide the referenced file;
                # if so, change the reference
                if name in files:
                    newReference = '@executable_path/' + name
                    subprocess.call(('install_name_tool', '-change',
                            referencedFile, newReference, filePath))

    def find_qt_menu_nib(self):
        """Returns a location of a qt_menu.nib folder, or None if this is not
           a Qt application."""
        if self.qt_menu_nib:
            return self.qt_menu_nib
        elif any(n.startswith("PyQt4.QtCore") \
                for n in os.listdir(self.binDir)):
            from PyQt4 import QtCore
        elif any(n.startswith("PySide.QtCore") \
                for n in os.listdir(self.binDir)):
            from PySide import QtCore
        else:
            return None

        libpath = str(QtCore.QLibraryInfo.location( \
                QtCore.QLibraryInfo.LibrariesPath))
        for subpath in ['QtGui.framework/Resources/qt_menu.nib',
                'Resources/qt_menu.nib']:
            path = os.path.join(libpath, subpath)
            if os.path.exists(path):
                return path

        # Last resort: fixed paths (macports)
        for path in ['/opt/local/Library/Frameworks/QtGui.framework/Versions/4/Resources/qt_menu.nib']:
            if os.path.exists(path):
                return path

        print ("Could not find qt_menu.nib")
        raise IOError("Could not find qt_menu.nib")

    def prepare_qt_app(self):
        """Add resource files for a Qt application. Should do nothing if the
           application does not use QtCore."""
        nib_locn = self.find_qt_menu_nib()
        if nib_locn is None:
            return

        # Copy qt_menu.nib
        self.copy_tree(nib_locn, os.path.join(self.resourcesDir,
                'qt_menu.nib'))

        # qt.conf needs to exist, but needn't have any content
        f = open(os.path.join(self.resourcesDir, 'qt.conf'), "w")
        f.close()

    def run(self):
        self.run_command('build')
        build = self.get_finalized_command('build')

        # Define the paths within the application bundle
        self.bundleDir = os.path.join(build.build_base,
                                      self.bundle_name + ".app")
        self.contentsDir = os.path.join(self.bundleDir, 'Contents')
        self.resourcesDir = os.path.join(self.contentsDir, 'Resources')
        self.binDir = os.path.join(self.contentsDir, 'MacOS')

        #Find the executable name
        executable = self.distribution.executables[0].targetName
        _, self.bundle_executable=os.path.split(executable)

        # Build the app directory structure
        self.mkpath(self.resourcesDir)
        self.mkpath(self.binDir)

        self.copy_tree(build.build_exe, self.binDir)

        # Copy the icon
        if self.iconfile:
            self.copy_file(self.iconfile, os.path.join(self.resourcesDir, 'icon.icns'))

        # Create the Info.plist file
        self.execute(self.create_plist,())

        # Make all references to libraries relative
        self.execute(self.setRelativeReferencePaths,())

        # For a Qt application, run some tweaks
        self.execute(self.prepare_qt_app, ())


########NEW FILE########
__FILENAME__ = main
import optparse
import os
import shutil
import stat
import sys

import cx_Freeze

__all__ = ["main"]

USAGE = \
"""
%prog [options] [SCRIPT]

Freeze a Python script and all of its referenced modules to a base
executable which can then be distributed without requiring a Python
installation."""

VERSION = \
"""
%%prog %s
Copyright (c) 2007-2013 Anthony Tuininga. All rights reserved.
Copyright (c) 2001-2006 Computronix Corporation. All rights reserved.""" % \
        cx_Freeze.version


def ParseCommandLine():
    parser = optparse.OptionParser(version = VERSION.strip(),
            usage = USAGE.strip())
    parser.add_option("-O",
            action = "count",
            default = 0,
            dest = "optimized",
            help = "optimize generated bytecode as per PYTHONOPTIMIZE; "
                   "use -OO in order to remove doc strings")
    parser.add_option("-c", "--compress",
            action = "store_true",
            dest = "compress",
            help = "compress byte code in zip files")
    parser.add_option("-s", "--silent",
            action = "store_true",
            dest = "silent",
            help = "suppress all output except warnings and errors")
    parser.add_option("--base-name",
            dest = "baseName",
            metavar = "NAME",
            help = "file on which to base the target file; if the name of the "
                   "file is not an absolute file name, the subdirectory bases "
                   "(rooted in the directory in which the freezer is found) "
                   "will be searched for a file matching the name")
    parser.add_option("--init-script",
            dest = "initScript",
            metavar = "NAME",
            help = "script which will be executed upon startup; if the name "
                   "of the file is not an absolute file name, the "
                   "subdirectory initscripts (rooted in the directory in "
                   "which the cx_Freeze package is found) will be searched "
                   "for a file matching the name")
    parser.add_option("--target-dir", "--install-dir",
            dest = "targetDir",
            metavar = "DIR",
            help = "the directory in which to place the target file and "
                   "any dependent files")
    parser.add_option("--target-name",
            dest = "targetName",
            metavar = "NAME",
            help = "the name of the file to create instead of the base name "
                   "of the script and the extension of the base binary")
    parser.add_option("--no-copy-deps",
            dest = "copyDeps",
            default = True,
            action = "store_false",
            help = "do not copy the dependent files (extensions, shared "
                   "libraries, etc.) to the target directory; this also "
                   "modifies the default init script to ConsoleKeepPath.py "
                   "and means that the target executable requires a Python "
                   "installation to execute properly")
    parser.add_option("--default-path",
            action = "append",
            dest = "defaultPath",
            metavar = "DIRS",
            help = "list of paths separated by the standard path separator "
                   "for the platform which will be used to initialize "
                   "sys.path prior to running the module finder")
    parser.add_option("--include-path",
            action = "append",
            dest = "includePath",
            metavar = "DIRS",
            help = "list of paths separated by the standard path separator "
                   "for the platform which will be used to modify sys.path "
                   "prior to running the module finder")
    parser.add_option("--replace-paths",
            dest = "replacePaths",
            metavar = "DIRECTIVES",
            help = "replace all the paths in modules found in the given paths "
                   "with the given replacement string; multiple values are "
                   "separated by the standard path separator and each value "
                   "is of the form path=replacement_string; path can be * "
                   "which means all paths not already specified")
    parser.add_option("--include-modules",
            dest = "includeModules",
            metavar = "NAMES",
            help = "comma separated list of modules to include")
    parser.add_option("--exclude-modules",
            dest = "excludeModules",
            metavar = "NAMES",
            help = "comma separated list of modules to exclude")
    parser.add_option("--ext-list-file",
            dest = "extListFile",
            metavar = "NAME",
            help = "name of file in which to place the list of dependent files "
                   "which were copied into the target directory")
    parser.add_option("-z", "--zip-include",
            dest = "zipIncludes",
            action = "append",
            default = [],
            metavar = "SPEC",
            help = "name of file to add to the zip file or a specification of "
                   "the form name=arcname which will specify the archive name "
                   "to use; multiple --zip-include arguments can be used")
    parser.add_option("--icon",
            dest = "icon",
            help = "name of the icon file for the application")
    options, args = parser.parse_args()
    if len(args) == 0:
        options.script = None
    elif len(args) == 1:
        options.script, = args
    else:
        parser.error("only one script can be specified")
    if not args and options.includeModules is None and options.copyDeps:
        parser.error("script or a list of modules must be specified")
    if not args and options.targetName is None:
        parser.error("script or a target name must be specified")
    if options.excludeModules:
        options.excludeModules = options.excludeModules.split(",")
    else:
        options.excludeModules = []
    if options.includeModules:
        options.includeModules = options.includeModules.split(",")
    else:
        options.includeModules = []
    replacePaths = []
    if options.replacePaths:
        for directive in options.replacePaths.split(os.pathsep):
            fromPath, replacement = directive.split("=")
            replacePaths.append((fromPath, replacement))
    options.replacePaths = replacePaths
    if options.defaultPath is not None:
        sys.path = [p for mp in options.defaultPath \
                for p in mp.split(os.pathsep)]
    if options.includePath is not None:
        paths = [p for mp in options.includePath for p in mp.split(os.pathsep)]
        sys.path = paths + sys.path
    if options.script is not None:
        sys.path.insert(0, os.path.dirname(options.script))
    zipIncludes = []
    if options.zipIncludes:
        for spec in options.zipIncludes:
            if '=' in spec:
                zipIncludes.append(spec.split('=', 1))
            else:
                zipIncludes.append(spec)
    options.zipIncludes = zipIncludes
    return options


def main():
    options = ParseCommandLine()
    executables = [cx_Freeze.Executable(options.script,
            targetName = options.targetName)]
    freezer = cx_Freeze.Freezer(executables,
            includes = options.includeModules,
            excludes = options.excludeModules,
            replacePaths = options.replacePaths,
            compress = options.compress,
            optimizeFlag = options.optimized,
            copyDependentFiles = options.copyDeps,
            initScript = options.initScript,
            base = options.baseName,
            path = None,
            createLibraryZip = False,
            appendScriptToExe = True,
            targetDir = options.targetDir,
            zipIncludes = options.zipIncludes,
            icon = options.icon,
            silent = options.silent)
    freezer.Freeze()


########NEW FILE########
__FILENAME__ = windist
import distutils.command.bdist_msi
import distutils.errors
import distutils.util
import msilib
import os

__all__ = [ "bdist_msi" ]

# force the remove existing products action to happen first since Windows
# installer appears to be braindead and doesn't handle files shared between
# different "products" very well
sequence = msilib.sequence.InstallExecuteSequence
for index, info in enumerate(sequence):
    if info[0] == 'RemoveExistingProducts':
        sequence[index] = (info[0], info[1], 1450)


class bdist_msi(distutils.command.bdist_msi.bdist_msi):
    user_options = distutils.command.bdist_msi.bdist_msi.user_options + [
        ('add-to-path=', None, 'add target dir to PATH environment variable'),
        ('upgrade-code=', None, 'upgrade code to use'),
        ('initial-target-dir=', None, 'initial target directory'),
        ('target-name=', None, 'name of the file to create'),
        ('directories=', None, 'list of 3-tuples of directories to create'),
        ('data=', None, 'dictionary of data indexed by table name')
    ]
    x = y = 50
    width = 370
    height = 300
    title = "[ProductName] Setup"
    modeless = 1
    modal = 3

    def add_config(self, fullname):
        if self.add_to_path:
            msilib.add_data(self.db, 'Environment',
                    [("E_PATH", "Path", r"[~];[TARGETDIR]", "TARGETDIR")])
        if self.directories:
            msilib.add_data(self.db, "Directory", self.directories)
        msilib.add_data(self.db, 'CustomAction',
                [("A_SET_TARGET_DIR", 256 + 51, "TARGETDIR",
                        self.initial_target_dir)])
        msilib.add_data(self.db, 'InstallExecuteSequence',
                [("A_SET_TARGET_DIR", 'TARGETDIR=""', 401)])
        msilib.add_data(self.db, 'InstallUISequence',
                [("PrepareDlg", None, 140),
                 ("A_SET_TARGET_DIR", 'TARGETDIR=""', 401),
                 ("SelectDirectoryDlg", "not Installed", 1230),
                 ("MaintenanceTypeDlg",
                        "Installed and not Resume and not Preselected", 1250),
                 ("ProgressDlg", None, 1280)
                ])
        for index, executable in enumerate(self.distribution.executables):
            if executable.shortcutName is not None \
                    and executable.shortcutDir is not None:
                baseName = os.path.basename(executable.targetName)
                msilib.add_data(self.db, "Shortcut",
                        [("S_APP_%s" % index, executable.shortcutDir,
                                executable.shortcutName, "TARGETDIR",
                                "[TARGETDIR]%s" % baseName, None, None, None,
                                None, None, None, None)])
        for tableName, data in self.data.items():
            msilib.add_data(self.db, tableName, data)

    def add_cancel_dialog(self):
        dialog = msilib.Dialog(self.db, "CancelDlg", 50, 10, 260, 85, 3,
                self.title, "No", "No", "No")
        dialog.text("Text", 48, 15, 194, 30, 3,
                "Are you sure you want to cancel [ProductName] installation?")
        button = dialog.pushbutton("Yes", 72, 57, 56, 17, 3, "Yes", "No")
        button.event("EndDialog", "Exit")
        button = dialog.pushbutton("No", 132, 57, 56, 17, 3, "No", "Yes")
        button.event("EndDialog", "Return")

    def add_error_dialog(self):
        dialog = msilib.Dialog(self.db, "ErrorDlg", 50, 10, 330, 101, 65543,
                self.title, "ErrorText", None, None)
        dialog.text("ErrorText", 50, 9, 280, 48, 3, "")
        for text, x in [("No", 120), ("Yes", 240), ("Abort", 0),
                ("Cancel", 42), ("Ignore", 81), ("Ok", 159), ("Retry", 198)]:
            button = dialog.pushbutton(text[0], x, 72, 81, 21, 3, text, None)
            button.event("EndDialog", "Error%s" % text)

    def add_exit_dialog(self):
        dialog = distutils.command.bdist_msi.PyDialog(self.db, "ExitDialog",
                self.x, self.y, self.width, self.height, self.modal,
                self.title, "Finish", "Finish", "Finish")
        dialog.title("Completing the [ProductName] installer")
        dialog.back("< Back", "Finish", active = False)
        dialog.cancel("Cancel", "Back", active = False)
        dialog.text("Description", 15, 235, 320, 20, 0x30003,
                "Click the Finish button to exit the installer.")
        button = dialog.next("Finish", "Cancel", name = "Finish")
        button.event("EndDialog", "Return")

    def add_fatal_error_dialog(self):
        dialog = distutils.command.bdist_msi.PyDialog(self.db, "FatalError",
                self.x, self.y, self.width, self.height, self.modal,
                self.title, "Finish", "Finish", "Finish")
        dialog.title("[ProductName] installer ended prematurely")
        dialog.back("< Back", "Finish", active = False)
        dialog.cancel("Cancel", "Back", active = False)
        dialog.text("Description1", 15, 70, 320, 80, 0x30003,
                "[ProductName] setup ended prematurely because of an error. "
                "Your system has not been modified. To install this program "
                "at a later time, please run the installation again.")
        dialog.text("Description2", 15, 155, 320, 20, 0x30003,
                "Click the Finish button to exit the installer.")
        button = dialog.next("Finish", "Cancel", name = "Finish")
        button.event("EndDialog", "Exit")

    def add_files(self):
        db = self.db
        cab = msilib.CAB("distfiles")
        f = msilib.Feature(db, "default", "Default Feature", "Everything", 1,
                directory="TARGETDIR")
        f.set_current()
        rootdir = os.path.abspath(self.bdist_dir)
        root = msilib.Directory(db, cab, None, rootdir, "TARGETDIR",
                "SourceDir")
        db.Commit()
        todo = [root]
        while todo:
            dir = todo.pop()
            for file in os.listdir(dir.absolute):
                if os.path.isdir(os.path.join(dir.absolute, file)):
                    newDir = msilib.Directory(db, cab, dir, file, file,
                            "%s|%s" % (dir.make_short(file), file))
                    todo.append(newDir)
                else:
                    dir.add_file(file)
        cab.commit(db)

    def add_files_in_use_dialog(self):
        dialog = distutils.command.bdist_msi.PyDialog(self.db, "FilesInUse",
                self.x, self.y, self.width, self.height, 19, self.title,
                "Retry", "Retry", "Retry", bitmap = False)
        dialog.text("Title", 15, 6, 200, 15, 0x30003,
                r"{\DlgFontBold8}Files in Use")
        dialog.text("Description", 20, 23, 280, 20, 0x30003,
                "Some files that need to be updated are currently in use.")
        dialog.text("Text", 20, 55, 330, 50, 3,
                "The following applications are using files that need to be "
                "updated by this setup. Close these applications and then "
                "click Retry to continue the installation or Cancel to exit "
                "it.")
        dialog.control("List", "ListBox", 20, 107, 330, 130, 7,
                "FileInUseProcess", None, None, None)
        button = dialog.back("Exit", "Ignore", name = "Exit")
        button.event("EndDialog", "Exit")
        button = dialog.next("Ignore", "Retry", name = "Ignore")
        button.event("EndDialog", "Ignore")
        button = dialog.cancel("Retry", "Exit", name = "Retry")
        button.event("EndDialog", "Retry")

    def add_maintenance_type_dialog(self):
        dialog = distutils.command.bdist_msi.PyDialog(self.db,
                "MaintenanceTypeDlg", self.x, self.y, self.width, self.height,
                self.modal, self.title, "Next", "Next", "Cancel")
        dialog.title("Welcome to the [ProductName] Setup Wizard")
        dialog.text("BodyText", 15, 63, 330, 42, 3,
                "Select whether you want to repair or remove [ProductName].")
        group = dialog.radiogroup("RepairRadioGroup", 15, 108, 330, 60, 3,
                "MaintenanceForm_Action", "", "Next")
        group.add("Repair", 0, 18, 300, 17, "&Repair [ProductName]")
        group.add("Remove", 0, 36, 300, 17, "Re&move [ProductName]")
        dialog.back("< Back", None, active = False)
        button = dialog.next("Finish", "Cancel")
        button.event("[REINSTALL]", "ALL",
                'MaintenanceForm_Action="Repair"', 5)
        button.event("[Progress1]", "Repairing",
                'MaintenanceForm_Action="Repair"', 6)
        button.event("[Progress2]", "repairs",
                'MaintenanceForm_Action="Repair"', 7)
        button.event("Reinstall", "ALL",
                'MaintenanceForm_Action="Repair"', 8)
        button.event("[REMOVE]", "ALL",
                'MaintenanceForm_Action="Remove"', 11)
        button.event("[Progress1]", "Removing",
                'MaintenanceForm_Action="Remove"', 12)
        button.event("[Progress2]", "removes",
                'MaintenanceForm_Action="Remove"', 13)
        button.event("Remove", "ALL",
                'MaintenanceForm_Action="Remove"', 14)
        button.event("EndDialog", "Return",
                'MaintenanceForm_Action<>"Change"', 20)
        button = dialog.cancel("Cancel", "RepairRadioGroup")
        button.event("SpawnDialog", "CancelDlg")

    def add_prepare_dialog(self):
        dialog = distutils.command.bdist_msi.PyDialog(self.db, "PrepareDlg",
                self.x, self.y, self.width, self.height, self.modeless,
                self.title, "Cancel", "Cancel", "Cancel")
        dialog.text("Description", 15, 70, 320, 40, 0x30003,
                "Please wait while the installer prepares to guide you through"
                "the installation.")
        dialog.title("Welcome to the [ProductName] installer")
        text = dialog.text("ActionText", 15, 110, 320, 20, 0x30003,
                "Pondering...")
        text.mapping("ActionText", "Text")
        text = dialog.text("ActionData", 15, 135, 320, 30, 0x30003, None)
        text.mapping("ActionData", "Text")
        dialog.back("Back", None, active = False)
        dialog.next("Next", None, active = False)
        button = dialog.cancel("Cancel", None)
        button.event("SpawnDialog", "CancelDlg")

    def add_progress_dialog(self):
        dialog = distutils.command.bdist_msi.PyDialog(self.db, "ProgressDlg",
                self.x, self.y, self.width, self.height, self.modeless,
                self.title, "Cancel", "Cancel", "Cancel", bitmap = False)
        dialog.text("Title", 20, 15, 200, 15, 0x30003,
                r"{\DlgFontBold8}[Progress1] [ProductName]")
        dialog.text("Text", 35, 65, 300, 30, 3,
                "Please wait while the installer [Progress2] [ProductName].")
        dialog.text("StatusLabel", 35, 100 ,35, 20, 3, "Status:")
        text = dialog.text("ActionText", 70, 100, self.width - 70, 20, 3,
                "Pondering...")
        text.mapping("ActionText", "Text")
        control = dialog.control("ProgressBar", "ProgressBar", 35, 120, 300,
                10, 65537, None, "Progress done", None, None)
        control.mapping("SetProgress", "Progress")
        dialog.back("< Back", "Next", active = False)
        dialog.next("Next >", "Cancel", active = False)
        button = dialog.cancel("Cancel", "Back")
        button.event("SpawnDialog", "CancelDlg")

    def add_properties(self):
        metadata = self.distribution.metadata
        props = [
                ('DistVersion', metadata.get_version()),
                ('DefaultUIFont', 'DlgFont8'),
                ('ErrorDialog', 'ErrorDlg'),
                ('Progress1', 'Install'),
                ('Progress2', 'installs'),
                ('MaintenanceForm_Action', 'Repair'),
                ('ALLUSERS', '1')
        ]
        email = metadata.author_email or metadata.maintainer_email
        if email:
            props.append(("ARPCONTACT", email))
        if metadata.url:
            props.append(("ARPURLINFOABOUT", metadata.url))
        if self.upgrade_code is not None:
            props.append(("UpgradeCode", self.upgrade_code))
        msilib.add_data(self.db, 'Property', props)

    def add_select_directory_dialog(self):
        dialog = distutils.command.bdist_msi.PyDialog(self.db,
                "SelectDirectoryDlg", self.x, self.y, self.width, self.height,
                self.modal, self.title, "Next", "Next", "Cancel")
        dialog.title("Select destination directory")
        dialog.back("< Back", None, active = False)
        button = dialog.next("Next >", "Cancel")
        button.event("SetTargetPath", "TARGETDIR", ordering = 1)
        button.event("SpawnWaitDialog", "WaitForCostingDlg", ordering = 2)
        button.event("EndDialog", "Return", ordering = 3)
        button = dialog.cancel("Cancel", "DirectoryCombo")
        button.event("SpawnDialog", "CancelDlg")
        dialog.control("DirectoryCombo", "DirectoryCombo", 15, 70, 272, 80,
                393219, "TARGETDIR", None, "DirectoryList", None)
        dialog.control("DirectoryList", "DirectoryList", 15, 90, 308, 136, 3,
                "TARGETDIR", None, "PathEdit", None)
        dialog.control("PathEdit", "PathEdit", 15, 230, 306, 16, 3,
                "TARGETDIR", None, "Next", None)
        button = dialog.pushbutton("Up", 306, 70, 18, 18, 3, "Up", None)
        button.event("DirectoryListUp", "0")
        button = dialog.pushbutton("NewDir", 324, 70, 30, 18, 3, "New", None)
        button.event("DirectoryListNew", "0")

    def add_text_styles(self):
        msilib.add_data(self.db, 'TextStyle',
                [("DlgFont8", "Tahoma", 9, None, 0),
                 ("DlgFontBold8", "Tahoma", 8, None, 1),
                 ("VerdanaBold10", "Verdana", 10, None, 1),
                 ("VerdanaRed9", "Verdana", 9, 255, 0)
                ])

    def add_ui(self):
        self.add_text_styles()
        self.add_error_dialog()
        self.add_fatal_error_dialog()
        self.add_cancel_dialog()
        self.add_exit_dialog()
        self.add_user_exit_dialog()
        self.add_files_in_use_dialog()
        self.add_wait_for_costing_dialog()
        self.add_prepare_dialog()
        self.add_select_directory_dialog()
        self.add_progress_dialog()
        self.add_maintenance_type_dialog()

    def add_upgrade_config(self, sversion):
        if self.upgrade_code is not None:
            msilib.add_data(self.db, 'Upgrade',
                    [(self.upgrade_code, None, sversion, None, 513, None,
                            "REMOVEOLDVERSION"),
                     (self.upgrade_code, sversion, None, None, 257, None,
                            "REMOVENEWVERSION")
                    ])

    def add_user_exit_dialog(self):
        dialog = distutils.command.bdist_msi.PyDialog(self.db, "UserExit",
                self.x, self.y, self.width, self.height, self.modal,
                self.title, "Finish", "Finish", "Finish")
        dialog.title("[ProductName] installer was interrupted")
        dialog.back("< Back", "Finish", active = False)
        dialog.cancel("Cancel", "Back", active = False)
        dialog.text("Description1", 15, 70, 320, 80, 0x30003,
                "[ProductName] setup was interrupted. Your system has not "
                "been modified. To install this program at a later time, "
                "please run the installation again.")
        dialog.text("Description2", 15, 155, 320, 20, 0x30003,
                "Click the Finish button to exit the installer.")
        button = dialog.next("Finish", "Cancel", name = "Finish")
        button.event("EndDialog", "Exit")

    def add_wait_for_costing_dialog(self):
        dialog = msilib.Dialog(self.db, "WaitForCostingDlg", 50, 10, 260, 85,
                self.modal, self.title, "Return", "Return", "Return")
        dialog.text("Text", 48, 15, 194, 30, 3,
                "Please wait while the installer finishes determining your "
                "disk space requirements.")
        button = dialog.pushbutton("Return", 102, 57, 56, 17, 3, "Return",
                None)
        button.event("EndDialog", "Exit")

    def finalize_options(self):
        distutils.command.bdist_msi.bdist_msi.finalize_options(self)
        name = self.distribution.get_name()
        fullname = self.distribution.get_fullname()
        if self.initial_target_dir is None:
            if distutils.util.get_platform() == "win-amd64":
                programFilesFolder = "ProgramFiles64Folder"
            else:
                programFilesFolder = "ProgramFilesFolder"
            self.initial_target_dir = r"[%s]\%s" % (programFilesFolder, name)
        if self.add_to_path is None:
            self.add_to_path = False
        if self.target_name is None:
            self.target_name = fullname
        if not self.target_name.lower().endswith(".msi"):
            platform = distutils.util.get_platform().replace("win-", "")
            self.target_name = "%s-%s.msi" % (self.target_name, platform)
        if not os.path.isabs(self.target_name):
            self.target_name = os.path.join(self.dist_dir, self.target_name)
        if self.directories is None:
            self.directories = []
        if self.data is None:
            self.data = {}

    def initialize_options(self):
        distutils.command.bdist_msi.bdist_msi.initialize_options(self)
        self.upgrade_code = None
        self.add_to_path = None
        self.initial_target_dir = None
        self.target_name = None
        self.directories = None
        self.data = None

    def run(self):
        if not self.skip_build:
            self.run_command('build')
        install = self.reinitialize_command('install', reinit_subcommands = 1)
        install.prefix = self.bdist_dir
        install.skip_build = self.skip_build
        install.warn_dir = 0
        distutils.log.info("installing to %s", self.bdist_dir)
        install.ensure_finalized()
        install.run()
        self.mkpath(self.dist_dir)
        fullname = self.distribution.get_fullname()
        if os.path.exists(self.target_name):
            os.unlink(self.target_name)
        metadata = self.distribution.metadata
        author = metadata.author or metadata.maintainer or "UNKNOWN"
        version = metadata.get_version()
        sversion = "%d.%d.%d" % \
                distutils.version.StrictVersion(version).version
        self.db = msilib.init_database(self.target_name, msilib.schema,
                self.distribution.metadata.name, msilib.gen_uuid(), sversion,
                author)
        msilib.add_tables(self.db, msilib.sequence)
        self.add_properties()
        self.add_config(fullname)
        self.add_upgrade_config(sversion)
        self.add_ui()
        self.add_files()
        self.db.Commit()
        if not self.keep_temp:
            distutils.dir_util.remove_tree(self.bdist_dir,
                    dry_run = self.dry_run)


########NEW FILE########
__FILENAME__ = About
import os

from PyQt4 import QtGui, QtCore

from Xtra import autopep8
from Xtra import pep8
import pyflakes
import rope
import cx_Freeze


class About(QtGui.QDialog):

    def __init__(self, parent=None):
        QtGui.QDialog.__init__(self, parent,
                               QtCore.Qt.Window | QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle("About")

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setMargin(0)
        self.setLayout(mainLayout)

        self.setFixedSize(500, 270)

        form = QtGui.QFormLayout()
        form.setMargin(10)
        form.addRow("<b>Version</b>", QtGui.QLabel("0.1"))
        form.addRow("<b>Author</b>", QtGui.QLabel("Amoatey Harrison"))
        form.addRow("<b>Email</b>", QtGui.QLabel("fortharris@gmail.com"))

        mainLayout.addLayout(form)

        hbox = QtGui.QHBoxLayout()
        hbox.setContentsMargins(5, 0, 5, 0)
        mainLayout.addLayout(hbox)

        self.label = QtGui.QLabel("External Libraries:")
        hbox.addWidget(self.label)

        hbox.addStretch(1)

        licenseButton = QtGui.QPushButton("License")
        licenseButton.setCheckable(True)
        licenseButton.clicked.connect(self.showLicense)
        hbox.addWidget(licenseButton)

        self.view = QtGui.QStackedWidget()
        mainLayout.addWidget(self.view)

        table = QtGui.QTreeWidget()
        table.setMinimumHeight(150)
        table.setIndentation(0)
        table.setHeaderLabels(["Name", "Version", "Author"])
        table.setColumnWidth(0, 150)
        table.addTopLevelItem(QtGui.QTreeWidgetItem(
            ["Rope", rope.VERSION, "Ali Gholami Rudi"]))
        table.addTopLevelItem(QtGui.QTreeWidgetItem(
            ["PyFlakes", pyflakes.__version__, "Florent Xicluna"]))
        table.addTopLevelItem(QtGui.QTreeWidgetItem(
            ["Pep8", pep8.__version__, "Florent Xicluna"]))
        table.addTopLevelItem(QtGui.QTreeWidgetItem(
            ["PyQt4", "4.10", "Riverbank Computing Limited"]))
        table.addTopLevelItem(QtGui.QTreeWidgetItem(
            ["AutoPep8", autopep8.__version__, "Hideo Hattori"]))
        table.addTopLevelItem(QtGui.QTreeWidgetItem(
            ["CxFreeze", cx_Freeze.version, "Anthony Tuininga"]))
        self.view.addWidget(table)

        self.licenseEdit = QtGui.QTextEdit()
        file = open(os.path.join("Resources", "LICENSE"), "r")
        self.licenseEdit.setText(file.read())
        file.close()

        self.view.addWidget(self.licenseEdit)

        self.hide()

    def showLicense(self, checked):
        if checked:
            self.view.setCurrentIndex(1)
            self.label.hide()
        else:
            self.view.setCurrentIndex(0)
            self.label.show()

########NEW FILE########
__FILENAME__ = BaseScintilla
import re
from PyQt4 import QtGui, QtCore
from PyQt4.Qsci import QsciScintilla


class FindOccurenceThread(QtCore.QThread):

    markOccurrence = QtCore.pyqtSignal(list)

    def run(self):
        word = re.escape(self.word)
        if self.wholeWord:
            word = "\\b{0}\\b".format(word)
        flags = re.UNICODE | re.LOCALE
        search = re.compile(word, flags)

        lineno = 0
        foundList = []
        for lineText in self.source.splitlines():
            for i in search.finditer(lineText):
                start = i.start()
                end = i.end()
                foundList.append([lineno, start, end])
            lineno += 1
        self.markOccurrence.emit(foundList)

    def find(self, word, wholeWord, source):
        self.source = source
        self.word = word
        self.wholeWord = wholeWord

        self.start()


class BaseScintilla(QsciScintilla):

    def __init__(self, parent=None):
        QsciScintilla.__init__(self, parent)

    def enableMarkOccurrence(self, useData):
        self.useData = useData

        self.matchIndicator = self.indicatorDefine(QsciScintilla.INDIC_BOX, 9)
        self.setIndicatorForegroundColor(
            QtGui.QColor("#FFCC00"), self.matchIndicator)
        self.setIndicatorDrawUnder(True, self.matchIndicator)

        self.findOccurenceThread = FindOccurenceThread()
        self.findOccurenceThread.markOccurrence.connect(self.markOccurence)

        self.occurrencesTimer = QtCore.QTimer()
        self.occurrencesTimer.setSingleShot(True)
        self.occurrencesTimer.timeout.connect(self.findOccurrences)

        self.cursorPositionChanged.connect(self.startOccurrencesTimer)
        
    def startOccurrencesTimer(self):
        self.occurrencesTimer.start(500)

    def updateKeymap(self, useData):
        standardCommands = self.standardCommands()

        for i, v in useData.DEFAULT_SHORTCUTS["Editor"].items():
            command = standardCommands.find(v[1])
            command.setKey(useData.CUSTOM_SHORTCUTS["Editor"][i][1])

    def findOccurrences(self):
        self.clearAllIndicators(self.matchIndicator)
        if self.useData.SETTINGS['MarkSearchOccurrence'] == 'True':
            wholeWord = True
            if self.hasSelectedText():
                lineFrom_, indexFrom_, lineTo_, indexTo_ = self.getSelection()
                if lineFrom_ != lineTo_:
                    return
                word = self.selectedText().strip()
                if word == '':
                    return
                wholeWord = False
            else:
                word = self.get_current_word()
                if not word:
                    self.clearMatchIndicators()
                    return
            self.findOccurenceThread.find(word, wholeWord, self.text())

    def markOccurence(self, foundList):
        self.clearAllIndicators(self.matchIndicator)
        if len(foundList) == 1:
            return
        for i in foundList:
            self.fillIndicatorRange(
                i[0], i[1], i[0], i[2], self.matchIndicator)

    def moveRightOneWordPart(self):
        """
        Move right one word part.
        """
        self.SendScintilla(QsciScintilla.SCI_WORDPARTRIGHT)

    def moveToEndOfDisplayLine(self):
        """
        Move to the end of the displayed line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINEENDDISPLAY)

    def moveToEndOfNextWord(self):
        """
        Move to the end of the next word.
        """
        self.SendScintilla(QsciScintilla.SCI_WORDRIGHTEND)

    def moveToStartOfDisplayLine(self):
        """
        Move to the start of the displayed line.
        """
        self.SendScintilla(QsciScintilla.SCI_HOMEDISPLAY)

    def moveToFirstVisibleCharacterOfDisplayInDocumentLine(self):
        """
        Move to the first visible character of the displayed or document
        line.
        """
        self.SendScintilla(QsciScintilla.SCI_VCHOMEWRAP)

    def moveToStartOfDisplayOrDocumentLine(self):
        """
        Move to the start of the displayed or document line.
        """
        self.SendScintilla(QsciScintilla.SCI_HOMEWRAP)

    def deletePreviousCharacterIfNotAtStartOfLine(self):
        """
        Delete the previous character if not at start of line.
        """
        self.SendScintilla(QsciScintilla.SCI_DELETEBACKNOTLINE)

    def extendRectangularSelectionDownOnePage(self):
        """
        Extend the rectangular selection down one page.
        """
        self.SendScintilla(QsciScintilla.SCI_PAGEDOWNRECTEXTEND)

    def extendRectangularSelectionUpOnePage(self):
        """
        Extend the rectangular selection up one page.
        """
        self.SendScintilla(QsciScintilla.SCI_PAGEUPRECTEXTEND)

    def extendSelectionToEndOfDocumentLine(self):
        """
        Extend the selection to the end of the document line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINEENDEXTEND)

    def extendSelectionToEndOfDisplayLine(self):
        """
        Extend the selection to the end of the displayed line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINEENDDISPLAYEXTEND)

    def stutteredExtendSelectionUpOnePage(self):
        """
        Stuttered extend the selection up one page.
        """
        self.SendScintilla(QsciScintilla.SCI_STUTTEREDPAGEUPEXTEND)

    def extendSelectionToEndOfNextWord(self):
        """
        Extend the selection to the end of the next word.
        """
        self.SendScintilla(QsciScintilla.SCI_WORDRIGHTENDEXTEND)

    def extendSelectionToFirstVisibleCharacterInDisplayOrDocumentLine(self):
        """
        Extend the selection to the first visible character of the
        displayed or document line.
        """
        self.SendScintilla(QsciScintilla.SCI_VCHOMEWRAPEXTEND)

    def extendSelectionRightOneWordPart(self):
        """
        Extend the selection right one word part.
        """
        self.SendScintilla(QsciScintilla.SCI_WORDPARTRIGHTEXTEND)

    def deleteCurrentLine(self):
        """
        Delete the current line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINEDELETE)

    def extendSelectionToStartOfDisplayOrDocumentLine(self):
        """
        Extend the selection to the start of the displayed or document
        line.
        """
        self.SendScintilla(QsciScintilla.SCI_HOMEWRAPEXTEND)

    def extendSelectionToFirstVisibleCharacterInDocumentLine(self):
        """
        Extend the selection to the first visible character in the document
        line.
        """
        self.SendScintilla(QsciScintilla.SCI_VCHOMEEXTEND)

    def moveToEndOfPreviousWord(self):
        """
        Move to the end of the previous word.
        """
        self.SendScintilla(QsciScintilla.SCI_WORDLEFTEND)

    def moveToEndOfDisplayOrDocumentLine(self):
        """
        Move to the end of the displayed or document line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINEENDWRAP)

    def extendRectangularSelectionToEndOfDocumentLine(self):
        """
        Extend the rectangular selection to the end of the document line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINEENDRECTEXTEND)

    def extendSelectionToEndOfDisplayOrDocumentLine(self):
        """
        Extend the selection to the start of the displayed line.
        """
        self.SendScintilla(QsciScintilla.SCI_HOMEDISPLAYEXTEND)

    def stutteredExtendSelectionDownOnePage(self):
        """
        Stuttered extend the selection down one page.
        """
        self.SendScintilla(QsciScintilla.SCI_STUTTEREDPAGEDOWNEXTEND)

    def extendSelectionToStartOfDocumentLine(self):
        """
        Extend the selection to the start of the document line.
        """
        self.SendScintilla(QsciScintilla.SCI_HOMEEXTEND)

    def extendSelectionToEndOfPreviousWord(self):
        """
        Extend the selection to the end of the previous word.
        """
        self.SendScintilla(QsciScintilla.SCI_WORDLEFTENDEXTEND)

    def extendSelectionLeftOneWordPart(self):
        """
        Extend the selection left one word part.
        """
        self.SendScintilla(QsciScintilla.SCI_WORDPARTLEFTEXTEND)

    def extendRectangularSelectionToStartOfDocumentLine(self):
        """
        Extend the rectangular selection to the start of the document line.
        """
        self.SendScintilla(QsciScintilla.SCI_HOMERECTEXTEND)

    def extendRectangularSelectionToFirstVisibleCharacterInDocumentLine(self):
        """
        Extend the rectangular selection to the first visible character in
        the document line.
        """
        self.SendScintilla(QsciScintilla.SCI_VCHOMERECTEXTEND)

    def moveToFirstVisibleCharacterInDocumentLine(self):
        """
        Move to the first visible character in the document line.
        """
        self.SendScintilla(QsciScintilla.SCI_VCHOME)

    def extendRectangularSelectionUpOneLine(self):
        """
        Extend the rectangular selection up one line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINEUPRECTEXTEND)

    def extendSelectionToStartOfDisplayLine(self):
        """
        Extend the selection to the start of the displayed line.
        """
        self.SendScintilla(QsciScintilla.SCI_HOMEDISPLAYEXTEND)

    def deleteRightToEndOfNextWord(self):
        """
        Delete right to the end of the next word.
        """
        self.SendScintilla(QsciScintilla.SCI_DELWORDRIGHTEND)

    def toggleInsertOrOvertype(self):
        """
        Toggle insert/overtype.
        """
        self.SendScintilla(QsciScintilla.SCI_EDITTOGGLEOVERTYPE)

    def deleteCurrentCharacter(self):
        """
        Delete the current character.
        """
        self.SendScintilla(QsciScintilla.SCI_CLEAR)

    def moveUpOneLine(self):
        """
        Move up one line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINEUP)

    def moveDownOneLine(self):
        """
        Move down one line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINEDOWN)

    def scrollVerticallyToCentreCurrentLine(self):
        """
        Scroll vertically to centre the current line.
        """
        self.SendScintilla(QsciScintilla.SCI_VERTICALCENTRECARET)

    def scrollToEndOfDocument(self):
        """
        Scroll to the end of the document.
        """
        self.SendScintilla(QsciScintilla.SCI_SCROLLTOEND)

    def scrollToStartOfDocument(self):
        """
        Scroll to the start of the document.
        """
        self.SendScintilla(QsciScintilla.SCI_SCROLLTOSTART)

    def scrollViewUpOneLine(self):
        """
        Scroll the view up one line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINESCROLLUP)

    def scrollViewDownOneLine(self):
        """
        Scroll the view down one line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINESCROLLDOWN)

    def cancel(self):
        """
        Cancel any current operation.
        """
        self.SendScintilla(QsciScintilla.SCI_CANCEL)

    def formfeed(self):
        """
        Insert a formfeed.
        """
        self.SendScintilla(QsciScintilla.SCI_FORMFEED)

    def extendSelectionToEndOfDocument(self):
        """
        Extend the selection to the end of the document.
        """
        self.SendScintilla(QsciScintilla.SCI_DOCUMENTENDEXTEND)

    def extendSelectionToStartOfDocument(self):
        """
        Extend the selection to the start of the document.
        """
        self.SendScintilla(QsciScintilla.SCI_DOCUMENTSTARTEXTEND)

    def extendRectangularSelectionLeftOneCharacter(self):
        """
        Extend the rectangular selection left one character.
        """
        self.SendScintilla(QsciScintilla.SCI_CHARLEFTRECTEXTEND)

    def extendRectangularSelectionRightOneCharacter(self):
        """
        Extend the rectangular selection right one character.
        """
        self.SendScintilla(QsciScintilla.SCI_CHARRIGHTRECTEXTEND)

    def moveSelectedLinesUpOneLine(self):
        """
        Move the selected lines up one line.
        """
        self.SendScintilla(QsciScintilla.SCI_MOVESELECTEDLINESUP)

    def moveSelectedLinesDownOneLine(self):
        """
        Move the selected lines down one line.
        """
        self.SendScintilla(QsciScintilla.SCI_MOVESELECTEDLINESDOWN)

    def transposeCurrentAndPreviousLines(self):
        """
        Transpose the current and previous lines.
        """
        self.SendScintilla(QsciScintilla.SCI_LINETRANSPOSE)

    def duplicateSelection(self):
        """
        Duplicate the selection.
        """
        self.SendScintilla(QsciScintilla.SCI_SELECTIONDUPLICATE)

    def duplicateTheCurrentLine(self):
        """
        Duplicate the current line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINEDUPLICATE)

    def cutCurrentLine(self):
        """
        Cut the current line to the clipboard.
        """
        self.SendScintilla(QsciScintilla.SCI_LINECUT)

    def copyCurrentLine(self):
        """
        Copy the current line to the clipboard.
        """
        self.SendScintilla(QsciScintilla.SCI_LINECOPY)

    def extendRectangularSelectionDownOneLine(self):
        """
        Extend the rectangular selection down one line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINEDOWNRECTEXTEND)

    def extendSelectionDownOnePage(self):
        """
        Extend the selection down one page.
        """
        self.SendScintilla(QsciScintilla.SCI_PAGEDOWNEXTEND)

    def extendSelectionUpOnePage(self):
        """
        Extend the selection up one page.
        """
        self.SendScintilla(QsciScintilla.SCI_PAGEUPEXTEND)

    def extendSelectionRightOneCharacter(self):
        """
        Extend the selection right one character.
        """
        self.SendScintilla(QsciScintilla.SCI_CHARRIGHTEXTEND)

    def extendSelectionLeftOneCharacter(self):
        """
        Extend the selection left one character.
        """
        self.SendScintilla(QsciScintilla.SCI_CHARLEFTEXTEND)

    def extendSelectionUpOneLine(self):
        """
        Extend the selection up one line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINEUPEXTEND)

    def extendSelectionDownOneLine(self):
        """
        Extend the selection down one line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINEDOWNEXTEND)

    def extendSelectionDownOneParagraph(self):
        """
        Extend the selection down one paragraph.
        """
        self.SendScintilla(QsciScintilla.SCI_PARADOWNEXTEND)

    def extendSelectionUpOneParagraph(self):
        """
        Extend the selection up one paragraph.
        """
        self.SendScintilla(QsciScintilla.SCI_PARAUPEXTEND)

    def moveDownOneParagraph(self):
        """
        Move down one paragraph.
        """
        self.SendScintilla(QsciScintilla.SCI_PARADOWN)

    def moveUpOneParagraph(self):
        """
        Move up one paragraph.
        """
        self.SendScintilla(QsciScintilla.SCI_PARAUP)

    def moveToStartOfDocument(self):
        """
        Move to the start of the document.
        """
        self.SendScintilla(QsciScintilla.SCI_DOCUMENTSTART)

    def moveToEndOfDocument(self):
        """
        Move to the end of the document.
        """
        self.SendScintilla(QsciScintilla.SCI_DOCUMENTEND)

    def scrollVertical(self, lines):
        self.SendScintilla(QsciScintilla.SCI_LINESCROLL, 0, lines)

    def moveCursorToEndOfDocumentLine(self):
        """
        Move to the end of the document line.
        """
        self.SendScintilla(QsciScintilla.SCI_LINEEND)

    def moveCursorToStartOfDocumentLine(self):
        """
        Move to the start of the displayed or document line.
        """
        self.SendScintilla(QsciScintilla.SCI_HOMEWRAP)

    def moveLeftOneCharacter(self):
        """
        Move left one character.
        """
        self.SendScintilla(QsciScintilla.SCI_CHARLEFT)

    def moveCursorRight(self):
        """
        Move right one character.
        """
        self.SendScintilla(QsciScintilla.SCI_CHARRIGHT)

    def moveCursorWordLeft(self):
        """
        Move left one word.
        """
        self.SendScintilla(QsciScintilla.SCI_WORDLEFT)

    def moveCursorWordRight(self):
        """
        Move right one word.
        """
        self.SendScintilla(QsciScintilla.SCI_WORDRIGHT)

    def insertNewline(self):
        """
        Insert a platform dependent newline.
        """
        self.SendScintilla(QsciScintilla.SCI_NEWLINE)

    def deletePreviousCharacter(self):
        """
        Delete the previous character.
        """
        self.SendScintilla(QsciScintilla.SCI_DELETEBACK)

    def delete(self):
        """
        Delete the current character.
        """
        self.SendScintilla(QsciScintilla.SCI_CLEAR)

    def deleteWordToLeft(self):
        """
        Delete the word to the left.
        """
        self.SendScintilla(QsciScintilla.SCI_DELWORDLEFT)

    def deleteWordToRight(self):
        """
        Delete the word to the right.
        """
        self.SendScintilla(QsciScintilla.SCI_DELWORDRIGHT)

    def deleteLineLeft(self):
        """
        Delete the line to the left.
        """
        self.SendScintilla(QsciScintilla.SCI_DELLINELEFT)

    def deleteLineToRight(self):
        """
        Delete the line to the right.
        """
        self.SendScintilla(QsciScintilla.SCI_DELLINERIGHT)

    def extendSelectionLeftOneWord(self):
        """
        Extend the selection left one word.
        """
        self.SendScintilla(QsciScintilla.SCI_WORDLEFTEXTEND)

    def extendSelectionWordRight(self):
        """
        Extend the selection right one word.
        """
        self.SendScintilla(QsciScintilla.SCI_WORDRIGHTEXTEND)

    def extendSelectionToBOL(self):
        """
        Extend the selection to the first visible character in the document
        line.
        """
        self.SendScintilla(QsciScintilla.SCI_VCHOMEEXTEND)

    def moveLeftOneWordPart(self):
        """
        Move left one word part.
        """
        self.SendScintilla(QsciScintilla.SCI_WORDPARTLEFT)

    def stutteredMoveUpOnePage(self):
        """
        Stuttered move up one page.
        """
        self.SendScintilla(QsciScintilla.SCI_STUTTEREDPAGEUP)

    def stutteredMoveDownOnePage(self):
        """
        Stuttered move down one page.
        """
        self.SendScintilla(QsciScintilla.SCI_STUTTEREDPAGEDOWN)

    def increaseIndent(self):
        if self.hasSelectedText() == False:
            pos = self.getCursorPosition()
            line = pos[0]
            self.indent(line)
        else:
            self.SendScintilla(QsciScintilla.SCI_TAB)

    def decreaseIndent(self):
        if self.hasSelectedText() == False:
            pos = self.getCursorPosition()
            line = pos[0]
            self.unindent(line)
        else:
            self.SendScintilla(QsciScintilla.SCI_BACKTAB)

    def toLowerCase(self):
        self.SendScintilla(QsciScintilla.SCI_LOWERCASE)

    def toUpperCase(self):
        self.SendScintilla(QsciScintilla.SCI_UPPERCASE)

    def showLineNumbers(self):
        if self.useData.SETTINGS["ShowLineNumbers"] == 'True':
            # Line numbers
            # conventionnaly, margin 0 is for line numbers
            self.setMarginLineNumbers(0, True)
            self.setMarginWidth(0, self.fontMetrics.width("0000") + 5)
        else:
            self.setMarginLineNumbers(0, False)
            self.setMarginWidth(0, 0)

    def position(self, position):
        if position == 'cursor':
            return self.getCursorPosition()
        elif position == 'sol':
            line, _index = self.getCursorPosition()
            return (line, 0)
        elif position == 'eol':
            line, _index = self.getCursorPosition()
            pos = self.SendScintilla(
                QsciScintilla.SCI_GETLINEENDPOSITION, line)
            _, index = self.lineIndexFromPosition(pos)
            return (line, index)
        elif position == 'eof':
            line = self.lines() - 1
            return (line, len(self.text(line)))
        elif position == 'sof':
            return (0, 0)
        else:
            return position

    def coordinates(self, position):
        line, index = self.position(position)

        pos = self.positionFromLineIndex(line, index)
        x_pt = self.SendScintilla(QsciScintilla.SCI_POINTXFROMPOSITION, 0, pos)
        y_pt = self.SendScintilla(QsciScintilla.SCI_POINTYFROMPOSITION, 0, pos)
        return x_pt, y_pt

    def currentPosition(self):
        return self.SendScintilla(QsciScintilla.SCI_GETCURRENTPOS)

    def positionFromPoint(self, point):
        return self.SendScintilla(QsciScintilla.SCI_POSITIONFROMPOINTCLOSE,
                                  point.x(), point.y())

    def getText(self, positionFrom=None, positionTo=None):
        """
        Return text between *positionFrom* and *positionTo*
        Positions may be positions or 'sol', 'eol', 'sof', 'eof' or 'cursor'
        """
        if positionFrom is None and positionTo is None:
            return self.text()
        self.selectText(positionFrom, positionTo)
        text = self.selectedText()

        # Clear current selection
        line, index = self.getCursorPosition()
        self.setSelection(line, index, line, index)

        return text

    def selectText(self, position_from, position_to):
        line_from, index_from = self.position(position_from)
        line_to, index_to = self.position(position_to)
        self.setSelection(line_from, index_from, line_to, index_to)

    def get_absolute_coordinates(self):
        cx, cy = self.coordinates('cursor')
        qPoint = QtCore.QPoint(cx, cy)
        point = self.mapToGlobal(qPoint)
        return point

    def get_current_word(self):
        """
        Return current word at cursor position
        """
        line, index = self.getCursorPosition()
        text = self.text(line)
        wc = self.wordCharacters()
        if wc is None:
            regexp = QtCore.QRegExp('[^\w_]')
        else:
            regexp = QtCore.QRegExp('[^{0}]'.format(re.escape(wc)))
        start = regexp.lastIndexIn(text, index) + 1
        end = regexp.indexIn(text, index)
        if start == end + 1 and index > 0:
            # we are on a word boundary, try again
            start = regexp.lastIndexIn(text, index - 1) + 1
        if start == -1:
            start = 0
        if end == -1:
            end = len(text)
        if end > start:
            word = text[start:end]
        else:
            word = ''
        return word

    def clearAllIndicators(self, indicator):
        self.clearIndicatorRange(0, 0, self.lines(), 0, indicator)

    def setFoldMarkersColors(self, foreground, background):
        self.SendScintilla(QsciScintilla.SCI_MARKERSETFORE,
                           QsciScintilla.SC_MARKNUM_FOLDER, foreground)
        self.SendScintilla(QsciScintilla.SCI_MARKERSETBACK,
                           QsciScintilla.SC_MARKNUM_FOLDER, background)

        self.SendScintilla(QsciScintilla.SCI_MARKERSETFORE,
                           QsciScintilla.SC_MARKNUM_FOLDEROPEN, foreground)
        self.SendScintilla(QsciScintilla.SCI_MARKERSETBACK,
                           QsciScintilla.SC_MARKNUM_FOLDEROPEN, background)

        self.SendScintilla(QsciScintilla.SCI_MARKERSETFORE,
                           QsciScintilla.SC_MARKNUM_FOLDEROPENMID, foreground)
        self.SendScintilla(QsciScintilla.SCI_MARKERSETBACK,
                           QsciScintilla.SC_MARKNUM_FOLDEROPENMID, background)

        self.SendScintilla(QsciScintilla.SCI_MARKERSETFORE,
                           QsciScintilla.SC_MARKNUM_FOLDERSUB, foreground)
        self.SendScintilla(QsciScintilla.SCI_MARKERSETBACK,
                           QsciScintilla.SC_MARKNUM_FOLDERSUB, background)

        self.SendScintilla(QsciScintilla.SCI_MARKERSETFORE,
                           QsciScintilla.SC_MARKNUM_FOLDERTAIL, foreground)
        self.SendScintilla(QsciScintilla.SCI_MARKERSETBACK,
                           QsciScintilla.SC_MARKNUM_FOLDERTAIL, background)

        self.SendScintilla(QsciScintilla.SCI_MARKERSETFORE,
                           QsciScintilla.SC_MARKNUM_FOLDERMIDTAIL, foreground)
        self.SendScintilla(QsciScintilla.SCI_MARKERSETBACK,
                           QsciScintilla.SC_MARKNUM_FOLDERMIDTAIL, background)

        self.SendScintilla(QsciScintilla.SCI_MARKERSETFORE,
                           QsciScintilla.SC_MARKNUM_FOLDEREND, foreground)
        self.SendScintilla(QsciScintilla.SCI_MARKERSETBACK,
                           QsciScintilla.SC_MARKNUM_FOLDEREND, background)

    def clearMatchIndicators(self):
        self.clearAllIndicators(self.matchIndicator)

########NEW FILE########
__FILENAME__ = Assistant
import os
import ast
from PyQt4 import QtCore, QtGui
from pyflakes.checker import Checker as flakeChecker
from Xtra import pep8
from Xtra import autopep8


class ErrorCheckerThread(QtCore.QThread):

    newAlerts = QtCore.pyqtSignal(list, bool)

    def run(self):
        messages = []
        try:
            warnings = flakeChecker(ast.parse(self.source))
            warnings.messages.sort(key=lambda a: a.lineno)
            for warning in warnings.messages:
                fname = warning.filename
                lineno = warning.lineno
                message = warning.message
                args = warning.message_args
                messages.append((lineno, message % (args), args))
            self.newAlerts.emit(messages, False)
        except Exception as err:
            error_text = err.args[1][3]
            msg = err.msg.capitalize() + '.'
            line = err.lineno
            offset = err.args[1][2]

            messages.append((1, line, msg, None, offset))
            self.newAlerts.emit(messages, True)

    def runCheck(self, source):
        self.source = source

        self.start()


class Pep8CheckerThread(QtCore.QThread):

    newAlerts = QtCore.pyqtSignal(list)

    def run(self):
        checkList = []
        try:
            styleGuide = pep8.StyleGuide(reporter=Pep8Report)
            report = styleGuide.check_files([os.path.join("temp", "temp8.py")])
            for i in report.all_errors:
                fname = i[0]
                lineno = i[1]
                offset = i[2]
                code = i[3]
                error = i[4]

                if code is None:
                    # means the code has been marked to be ignored
                    continue
                checkList.append((fname, lineno, offset, code, error))
        except:
            pass
        self.newAlerts.emit(checkList)

    def runCheck(self):
        self.start()


class Pep8Report (pep8.BaseReport):

    def __init__(self, options):
        super(Pep8Report, self).__init__(options)

        self.all_errors = []

    def error(self, line_number, offset, text, check):
        code = super(Pep8Report, self).error(line_number, offset, text, check)

        err = (self.filename, line_number, offset, code, text)
        self.all_errors.append(err)
#
# class AutoPep8FixerOtions(object):
#    def __init__(self):
# self.verbose = 0 #
# self.diff # print the diff for the fixed source
# self.in_place # make changes to files in place
# self.recursive # run recursively; must be used with --in-place or diff
# self.list_fixes # list codes for fixes; used by --ignore and --select
# self.exclude # exclude files/directories that match these comma-separated globs
# self.max_line_length = infinite # maximum number of additional pep8 passes (default: infinite)
# self.select # fix only these errors/warnings (e.g. E4,W)
# self.ignore # do not fix these errors/warnings '
# self.aggressive # enable non-whitespace changes; multiple -a result in more aggressive changes
# self.jobs # number of parallel jobs; match CPU count if value is less than 1
#


class AutoPep8FixerThread(QtCore.QThread):

    new = QtCore.pyqtSignal(str)

    def run(self):
        try:
            options = {
                'in_place': None, 'pep8_passes': 100, 'list_fixes': None,
                'jobs': 1, 'ignore': ['E226', 'E24'], 'verbose': 0,
                'diff': None, 'select': '', 'exclude': [], 'aggressive': 0,
                'recursive': None, 'max_line_length': 79}

            fixed = autopep8.fix_string(self.editorTabWidget.getSource())
            self.new.emit(fixed)
        except:
            pass

    def runFix(self, editorTabWidget):
        self.editorTabWidget = editorTabWidget
        self.start()


class Pep8View(QtGui.QTreeWidget):

    def __init__(self, editorTabWidget, parent=None):
        QtGui.QTreeWidget.__init__(self, parent)

        self.editorTabWidget = editorTabWidget

        self.fixerThread = AutoPep8FixerThread()
        self.fixerThread.new.connect(self.autoPep8Done)

        self.setColumnCount(3)
        self.setHeaderLabels(["", "#", "Style Guide"])
        self.setAutoScroll(True)
        self.setColumnWidth(0, 50)
        self.setColumnWidth(1, 50)

        self.createActions()

    def autoPep8Done(self, fixedCode):
        self.editorTabWidget.busyWidget.showBusy(False)
        
        editor = self.editorTabWidget.getEditor()
        editor.setText(fixedCode)
        self.editorTabWidget.getEditor().removeBookmarks()
        self.editorTabWidget.enableBookmarkButtons(False)

    def contextMenuEvent(self, event):
        selectedItems = self.selectedItems()
        if len(selectedItems) > 0:
            item = selectedItems[0]
            fixable = item.data(9, 2)
            # self.fixAct.setEnabled(fixable)
            # self.fixAllAct.setEnabled(fixable)
            self.contextMenu.exec_(event.globalPos())

    def fixErrors(self):
        self.fixerThread.runFix(self.editorTabWidget)
        self.editorTabWidget.busyWidget.showBusy(True,
                                                 "Applying Style Guide... please wait!")

    def createActions(self):
        self.fixAct = QtGui.QAction(
            "Fix Selected (Not Ready)", self, statusTip="Fix Selected")
        self.fixAct.setDisabled(True)

        self.fixAllAct = \
            QtGui.QAction(
                "Fix All Occurrences (Not Ready)", self, statusTip="Fix All Occurrences")
        self.fixAllAct.setDisabled(True)

        self.fixModuleAct = \
            QtGui.QAction(
                "Fix All Issues", self, statusTip="Fix All Issues",
                triggered=self.fixErrors)

        self.contextMenu = QtGui.QMenu()
        self.contextMenu.addAction(self.fixAct)
        self.contextMenu.addAction(self.fixAllAct)
        self.contextMenu.addSeparator()
        self.contextMenu.addAction(self.fixModuleAct)


class NoAssistanceWidget(QtGui.QWidget):

    def __init__(self, parent=None):
        QtGui.QWidget.__init__(self, parent)

        mainLayout = QtGui.QHBoxLayout()
        self.setLayout(mainLayout)

        mainLayout.addStretch(1)

        label = QtGui.QLabel('No Assistance')
        label.setScaledContents(True)
        label.setMinimumWidth(200)
        label.setMinimumHeight(25)
        label.setAlignment(QtCore.Qt.AlignHCenter)
        mainLayout.addWidget(label)

        mainLayout.addStretch(1)


class Assistant(QtGui.QStackedWidget):

    def __init__(self, editorTabWidget, bottomStackSwitcher, parent=None):
        QtGui.QStackedWidget.__init__(self, parent)

        self.useData = editorTabWidget.useData
        self.refactor = editorTabWidget.refactor

        self.currentCodeIsPython = False

        supportedFixes = autopep8.supported_fixes()
        self.autopep8SupportDict = {}
        for i in supportedFixes:
            self.autopep8SupportDict[i[0]] = i[1]

        self.addWidget(NoAssistanceWidget())

        self.errorView = QtGui.QTreeWidget()
        self.errorView.setColumnCount(3)
        self.errorView.setHeaderLabels(["", "#", "Alerts"])
        self.errorView.setAutoScroll(True)
        self.errorView.setColumnWidth(0, 50)
        self.errorView.setColumnWidth(1, 50)
        self.errorView.itemPressed.connect(self.alertPressed)

        self.addWidget(self.errorView)

        self.pep8View = Pep8View(editorTabWidget)
        self.pep8View.itemPressed.connect(self.pep8Pressed)
        self.addWidget(self.pep8View)

        self.codeCheckerTimer = QtCore.QTimer()
        self.codeCheckerTimer.setSingleShot(True)
        self.codeCheckerTimer.timeout.connect(self.runCheck)

        self.editorTabWidget = editorTabWidget
        self.editorTabWidget.currentEditorTextChanged.connect(
            self.startCodeCheckerTimer)
        self.editorTabWidget.currentChanged.connect(self.changeWorkingMode)

        self.bottomStackSwitcher = bottomStackSwitcher

        self.codeCheckerThread = ErrorCheckerThread()
        self.codeCheckerThread.newAlerts.connect(self.updateAlertsView)

        self.pep8CheckerThread = Pep8CheckerThread()
        self.pep8CheckerThread.newAlerts.connect(self.updatePep8View)

        if self.useData.SETTINGS["EnableAssistance"] == "False":
            self.setCurrentIndex(0)
        else:
            if self.useData.SETTINGS["EnableAlerts"] == "True":
                self.setCurrentIndex(1)
            if self.useData.SETTINGS["enableStyleGuide"] == "True":
                self.setCurrentIndex(2)

        self.extendedErrorsCount = 0
        self.alertsCount = 0

    def startCodeCheckerTimer(self):
        self.codeCheckerTimer.start(500)

    def setAssistance(self, index=None):
        if index is None:
            if self.useData.SETTINGS["EnableAlerts"] == "True":
                self.setCurrentIndex(1)
            if self.useData.SETTINGS["enableStyleGuide"] == "True":
                self.setCurrentIndex(2)
        else:
            self.setCurrentIndex(index)

        self.bottomStackSwitcher.setCount(self, '')

        self.startTimer()

    def changeWorkingMode(self):
        if self.editorTabWidget.getEditorData("fileType") == "python":
            self.currentCodeIsPython = True
            self.codeCheckerTimer.start()
        else:
            self.currentCodeIsPython = False
            self.errorView.clear()
            self.pep8View.clear()
            self.bottomStackSwitcher.setCount(self, '')

    def startTimer(self):
        if self.currentCodeIsPython:
            self.codeCheckerTimer.start()

    def updateAlertsView(self, alertsList, critical):
        if self.currentCodeIsPython:
            self.errorView.clear()
            editor = self.editorTabWidget.getEditor()
            editor.clearErrorMarkerAndIndicator()
            if critical:
                item = alertsList[0]
                item = self.createItem(item[0], item[
                                       1], item[2], item[3], item[4])
                self.errorView.addTopLevelItem(item)

                lineno = int(item.text(1)) - 1
                offset = item.data(10, 2)
                msg = item.text(2)

                lineText = editor.text(lineno)
                l = len(lineText)
                startPos = l - len(lineText.lstrip())

                editor.markerAdd(lineno, 9)
                self.editorTabWidget.updateEditorData("errorLine", lineno)
                editor.fillIndicatorRange(lineno, startPos, lineno,
                                          offset, editor.syntaxErrorIndicator)
                editor.annotate(lineno, msg.capitalize(),
                                editor.annotationErrorStyle)
                self.bottomStackSwitcher.setCurrentWidget(self)
            else:
                for i in alertsList:
                    item = self.createItem(0, i[0], i[1], i[2])
                    self.errorView.addTopLevelItem(item)
                self.editorTabWidget.updateEditorData("errorLine", None)
            self.bottomStackSwitcher.setCount(self, str(len(alertsList)))
            if len(alertsList) == 0:
                parentItem = QtGui.QTreeWidgetItem()
                item = QtGui.QTreeWidgetItem()
                item.setText(2, "<No Alerts>")
                item.setFlags(QtCore.Qt.NoItemFlags)
                parentItem.addChild(item)
                self.errorView.addTopLevelItem(parentItem)
                parentItem.setExpanded(True)

    def createItem(self, itemType, line, message, args=None, offset=None):
        item = QtGui.QTreeWidgetItem(itemType)
        if itemType == 0:
            item.setIcon(0, QtGui.QIcon(
                os.path.join("Resources", "images", "alerts", "_0035_Flashlight")))
        elif itemType == 1:
            item.setIcon(0, QtGui.QIcon(
                os.path.join("Resources", "images", "alerts", "construction")))
        item.setText(1, str(line))
        item.setText(2, message)
        item.setData(10, 2, offset)
        item.setData(10, 3, args)

        return item

    def updatePep8View(self, checkList):
        if self.currentCodeIsPython:
            self.pep8View.clear()
            for i in checkList:
                item = QtGui.QTreeWidgetItem()
                if i[3] in self.autopep8SupportDict:
                    icon = QtGui.QIcon(
                        os.path.join("Resources", "images", "security", "allowed"))
                    item.setData(9, 2, True)
                else:
                    icon = QtGui.QIcon(
                        os.path.join("Resources", "images", "security", "requesting"))
                    item.setData(9, 2, False)
                item.setIcon(0, icon)
                item.setText(1, str(i[1]))
                item.setText(2, i[4])
                item.setData(10, 2, i[2])
                item.setData(11, 2, i[3])
                self.pep8View.addTopLevelItem(item)
            if len(checkList) == 0:
                parentItem = QtGui.QTreeWidgetItem()
                item = QtGui.QTreeWidgetItem()
                item.setText(2, "<No Issues>")
                item.setFlags(QtCore.Qt.NoItemFlags)
                parentItem.addChild(item)
                self.pep8View.addTopLevelItem(parentItem)
                parentItem.setExpanded(True)
            self.bottomStackSwitcher.setCount(self,
                                              str(len(checkList)))

    def alertPressed(self, item):
        # XXX: Fixme this only works if args is not empty
        lineno = int(item.text(1)) - 1
        word = item.data(10, 3)
        editor = self.editorTabWidget.focusedEditor()
        text = editor.text(lineno)
        if word is None:
            editor.showLine(lineno)
        else:
            word = word[0]
            start = text.find(word)
            end = start + len(word)
            editor.setSelection(lineno, start, lineno, end)
        editor.ensureLineVisible(lineno)

    def pep8Pressed(self, item):
        lineno = int(item.text(1)) - 1
        self.editorTabWidget.showLine(lineno)

    def runCheck(self):
        if self.useData.SETTINGS["EnableAssistance"] == "False":
            return
        if self.useData.SETTINGS["EnableAlerts"] == "True":
            self.codeCheckerThread.runCheck(self.editorTabWidget.getSource())
        if self.useData.SETTINGS["enableStyleGuide"] == "True":
            saved = self.editorTabWidget.saveToTemp('pep8')
            if saved:
                self.pep8CheckerThread.runCheck()

########NEW FILE########
__FILENAME__ = BookmarkWidget
from PyQt4 import QtCore, QtGui


class BookmarkWidget(QtGui.QTreeWidget):

    def __init__(self, editorTabWidget, bottomStackSwitcher, parent=None):
        QtGui.QTreeWidget.__init__(self, parent)

        self.markersLineList = []
        self.editorTabWidget = editorTabWidget
        self.bottomStackSwitcher = bottomStackSwitcher

        self.setColumnCount(3)
        self.setHeaderLabels(["#", "Line", "Text"])
        self.itemPressed.connect(self.locateItem)

        self.setColumnWidth(0, 50)
        self.setColumnWidth(1, 80)

        self.loadTimer = QtCore.QTimer()
        self.loadTimer.setSingleShot(True)
        self.loadTimer.timeout.connect(self.load)

        self.editorTabWidget.currentEditorTextChanged.connect(
            self.startLoadTimer)
        self.editorTabWidget.bookmarksChanged.connect(self.loadTimer.start)

    def startLoadTimer(self):
        self.loadTimer.start(1000)

    def load(self):
        markerLines = []
        editor = self.editorTabWidget.getEditor()
        bookmarks = editor.getBookmarks()
        for line in bookmarks:
            markerLines.append((line, editor.text(line).strip()))
        if markerLines != self.markersLineList:
            self.markersLineList = markerLines
            self.clear()
            m = 1
            for i in markerLines:
                item = QtGui.QTreeWidgetItem()
                item.setText(0, str(m))
                item.setText(1, str(i[0] + 1))
                item.setToolTip(2, i[1])
                item.setText(2, i[1])
                self.addTopLevelItem(item)

                m += 1
        self.bottomStackSwitcher.setCount(self, str(len(markerLines)))

    def locateItem(self, item):
        lineNum = int(item.data(1, 0)) - 1
        self.editorTabWidget.showLine(lineNum)

########NEW FILE########
__FILENAME__ = FindInFiles
import os
import ctypes
import re
from PyQt4 import QtCore, QtGui

from Extensions import Global
from Extensions.Diff import DiffWindow


class FinderThread(QtCore.QThread):

    listItemAvailable = QtCore.pyqtSignal()
    currentDir = QtCore.pyqtSignal(str)

    def run(self):
        for dirname, _, files in os.walk(self.directory):
            self.currentDir.emit(dirname)
            if self.stop:
                break
            for f in files:
                if self.stop:
                    break
                if re.match(self.filterRe, f):
                    file = os.path.join(dirname, f)
                    parentItem = QtGui.QTreeWidgetItem()
                    # read the file and split it into textlines
                    try:
                        text = open(file, 'r').read()
                        lines = text.splitlines(True)
                    except:
                        continue

                    # now perform the search and display the lines found
                    count = 0
                    for line in lines:
                        if self.stop:
                            break

                        count += 1
                        contains = self.search.search(line)
                        if contains:
                            start = contains.start()
                            end = contains.end()
                            line = line.replace("\r", "").replace("\n", "")
                            childItem = self.createChild(
                                str(count), line, (start, end))
                            parentItem.addChild(childItem)
                    if parentItem.childCount() > 0:
                        parentItem.setText(0, file)
                        parentItem.setForeground(0, QtGui.QBrush(
                            QtGui.QColor("#003366")))
                        self.found.append(parentItem)
                        self.listItemAvailable.emit()
            if self.recursive is False:
                return

    def find(self, directory, filterRe, search, recursive):
        self.directory = directory
        self.filterRe = filterRe
        self.search = search
        self.recursive = recursive

        self.stop = False
        self.found = []

        self.start()

    def createChild(self, line, text, pos):
        childItem = QtGui.QTreeWidgetItem()
        childItem.setText(0, line)
        childItem.setText(1, text)
        childItem.setToolTip(1, text)
        childItem.setData(0, 3, pos)

        return childItem

    def stopThread(self):
        self.stop = True


class ConfirmReplaceDialog(QtGui.QDialog):

    def __init__(self, path, text, replaceText, search, parent=None):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle(path)
        self.resize(700, 400)

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setContentsMargins(0, 0, 0, 5)
        self.setLayout(mainLayout)

        diff = DiffWindow()

        self.path = path
        self.text = text
        self.replaceText = replaceText
        self.search = search

        a = open(path, 'r').read().splitlines()
        b = open(path, 'r').read().splitlines()
        for i in range(len(b)):
            b[i] = search.sub(replaceText, b[i])

        diffExists = diff.generateUnifiedDiff(a, b)

        if diffExists:
            mainLayout.addWidget(diff)
        else:
            message = QtGui.QMessageBox.information(
                self, "Replace", "There is nothing to replace.")
            return

        hbox = QtGui.QHBoxLayout()
        hbox.addStretch(1)
        mainLayout.addLayout(hbox)

        self.replaceButton = QtGui.QPushButton("Replace")
        self.replaceButton.clicked.connect(self.replace)
        hbox.addWidget(self.replaceButton)

        self.cancelButton = QtGui.QPushButton("Cancel")
        self.cancelButton.pressed.connect(self.close)
        hbox.addWidget(self.cancelButton)

        hbox.addStretch(1)

        self.replaced = False
        self.exec_()

    def replace(self):
        QtGui.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)

        file = open(self.path, 'r')
        new = self.search.sub(self.replaceText, file.read())
        file.close()

        file = open(self.path, 'w')
        file.write(new)
        file.close()

        QtGui.QApplication.restoreOverrideCursor()

        self.replaced = True
        self.close()


class FoundFilesView(QtGui.QTreeWidget):

    def __init__(self, parent):
        QtGui.QTreeWidget.__init__(self, parent)

        self.setHeaderHidden(True)
        self.setColumnCount(2)
        self.itemSelectionChanged.connect(self.updateActions)

        self.parent = parent
        self.createActions()

        self.updateActions()

    def updateActions(self):
        state = (len(self.selectedItems()) != 0)
        self.viewAct.setEnabled(state)
        self.locateAct.setEnabled(state)

    def contextMenuEvent(self, event):
        selected = self.selectedItems()
        if len(selected) == 0:
            pass
        else:
            item = selected[0]
            if item.parent() is None:
                self.viewAct.setEnabled(False)
        self.contextMenu.exec_(event.globalPos())

    def createActions(self):
        self.viewAct = QtGui.QAction(
            "View", self, statusTip="View", triggered=self.parent.viewFile)

        self.locateAct = \
            QtGui.QAction(
                "Open Containing Folder", self, statusTip="Open Containing Folder", triggered=self.parent.locateFile)

        self.contextMenu = QtGui.QMenu()
        self.contextMenu.addAction(self.viewAct)
        self.contextMenu.addAction(self.locateAct)


class FindInFiles(QtGui.QWidget):

    def __init__(self, useData, editorTabWidget, projectPathDict, bottomStackSwitcher):
        super(FindInFiles, self).__init__()

        self.useData = useData
        self.projectPathDict = projectPathDict
        self.findThread = FinderThread()
        self.editorTabWidget = editorTabWidget
        self.bottomStackSwitcher = bottomStackSwitcher

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setMargin(0)
        self.setLayout(mainLayout)

        self.statusWidget = QtGui.QWidget()
        self.statusWidget.setMaximumHeight(25)
        mainLayout.addWidget(self.statusWidget)

        hbox = QtGui.QHBoxLayout()
        hbox.setContentsMargins(0, 5, 0, 0)
        self.statusWidget.setLayout(hbox)

        label = QtGui.QLabel()
        label.setMaximumWidth(25)
        label.setMaximumHeight(25)
        label.setScaledContents(True)
        label.setPixmap(
            QtGui.QPixmap(os.path.join("Resources", "images", "cascade")))
        hbox.addWidget(label)

        self.dirLabel = QtGui.QLabel()
        hbox.addWidget(self.dirLabel)

        self.statusWidget.hide()

        self.filesView = FoundFilesView(self)
        self.filesView.activated.connect(self.viewFile)
        mainLayout.addWidget(self.filesView)

        # create finder controls

        self.dashboard = QtGui.QWidget()

        vbox = QtGui.QVBoxLayout()
        self.dashboard.setLayout(vbox)

        hbox = QtGui.QHBoxLayout()
        vbox.addLayout(hbox)

        label = QtGui.QLabel("Find:        ")  # extra space is for alignment
        label.setMinimumWidth(30)

        hbox.addWidget(label)

        self.findtextLine = QtGui.QLineEdit()
        hbox.addWidget(self.findtextLine)

        self.replaceLabel = QtGui.QLabel("Replace With:")
        hbox.addWidget(self.replaceLabel)

        self.replaceLine = QtGui.QLineEdit()
        hbox.addWidget(self.replaceLine)

        hbox.setStretch(1, 1)
        hbox.setStretch(3, 1)

        hbox.addWidget(QtGui.QLabel("Extensions (*.ext; ...)"))

        self.filterEdit = QtGui.QLineEdit()
        self.filterEdit.setText('*')
        self.filterEdit.setMaximumWidth(72)
        hbox.addWidget(self.filterEdit)

        hbox = QtGui.QHBoxLayout()

        hbox.addWidget(QtGui.QLabel("Directory:"))

        self.directoryLine = QtGui.QLineEdit()
        hbox.addWidget(self.directoryLine)

        hbox.setStretch(1, 1)

        self.projectBox = QtGui.QCheckBox(
            "Project  ")  # extra space is for alignment
        self.projectBox.toggled.connect(self.projectBoxToggled)
        hbox.addWidget(self.projectBox)

        self.browseButton = QtGui.QPushButton('...')
        self.browseButton.clicked.connect(self.setPath)
        hbox.addWidget(self.browseButton)

        self.stopButton = QtGui.QPushButton("Stop")
        self.stopButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "stop")))
        self.stopButton.clicked.connect(self.stopFinder)
        self.stopButton.hide()
        hbox.addWidget(self.stopButton)

        self.findButton = QtGui.QPushButton("Find")
        self.findButton.clicked.connect(self.find)
        hbox.addWidget(self.findButton)

        vbox.addLayout(hbox)

        hbox = QtGui.QHBoxLayout()
        vbox.addLayout(hbox)

        self.matchCaseBox = QtGui.QCheckBox("MC")
        self.matchCaseBox.setToolTip("Match Case")
        self.matchCaseBox.stateChanged.connect(self.searchOptionsChanged)
        hbox.addWidget(self.matchCaseBox)

        self.matchWholeWordBox = QtGui.QCheckBox("WW")
        self.matchWholeWordBox.setToolTip("Whole Word")
        self.matchWholeWordBox.stateChanged.connect(self.searchOptionsChanged)
        hbox.addWidget(self.matchWholeWordBox)

        self.regExpBox = QtGui.QCheckBox("RE")
        self.regExpBox.setToolTip("Regular Expression")
        self.regExpBox.stateChanged.connect(self.searchOptionsChanged)
        hbox.addWidget(self.regExpBox)

        self.recursiveBox = QtGui.QCheckBox("Recursive")
        self.recursiveBox.setChecked(True)
        self.recursiveBox.stateChanged.connect(self.searchOptionsChanged)
        hbox.addWidget(self.recursiveBox)

        self.replaceBox = QtGui.QCheckBox("Replace")
        self.replaceBox.stateChanged.connect(self.toggleReplace)
        hbox.addWidget(self.replaceBox)

        hbox.addStretch(1)

        self.hideButton = QtGui.QToolButton()
        self.hideButton.setAutoRaise(True)
        self.hideButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "exit")))
        self.hideButton.clicked.connect(self.dashboard.hide)
        hbox.addWidget(self.hideButton)

        self.searchOptionsChanged()

        self.findtextLine.setFocus(True)

        self.findThread.listItemAvailable.connect(self.updateFilesTable)
        self.findThread.currentDir.connect(self.displayCurrentSearchDir)
        self.findThread.started.connect(self.searchStarted)
        self.findThread.finished.connect(self.searchEnded)

        self.toggleReplace(False)

    def manageSplitter(self):
        count = self.viewTab.count()
        if count == 0:
            self.splitter.widget(1).hide()
        else:
            self.splitter.widget(1).show()

    def viewFile(self, item):
        item = self.filesView.selectedItems()[0]
        if item.parent() is None:
            return
        path = item.parent().text(0)
        if self.replaceBox.isChecked():
            name = os.path.basename(
                path) + " ( '" + self.text + "' --> '" + self.replaceLine.text() + "' )"
            replaced = confirmReplaceDialog = ConfirmReplaceDialog(
                path, self.text, self.replaceLine.text(), self.search, self)
            if replaced.replaced:
                if self.editorTabWidget.alreadyOpened(path):
                    message = QtGui.QMessageBox.information(
                        self, "Reload", "This file has changed on disk. You may want to reload it.")
        else:
            line = int(item.text(0)) - 1
            pos = item.data(0, 3)
            if not self.editorTabWidget.loadfile(path):
                return
            editor = self.editorTabWidget.getEditor()
            editor.setSelection(line, pos[0], line, pos[1])

    def locateFile(self):
        item = self.filesView.selectedItems()[0]
        if item.parent() is None:
            path = item.text(0)
        else:
            path = item.parent().text(0)
        path = os.path.normpath(path)
        ctypes.windll.shell32.ShellExecuteW(None, 'open', 'explorer.exe',
                                            '/n,/select, ' + path, None, 1)

    def setPath(self):
        options = QtGui.QFileDialog.DontResolveSymlinks | QtGui.QFileDialog.ShowDirsOnly
        directory = QtGui.QFileDialog.getExistingDirectory(self,
                                                           "Select Folder", self.useData.getLastOpenedDir(), options)
        if directory:
            directory = os.path.normpath(directory)
            self.useData.saveLastOpenedDir(directory)
            self.directoryLine.setText(directory)

    def projectBoxToggled(self, state):
        self.directoryLine.setDisabled(state)
        self.browseButton.setDisabled(state)

    def displayCurrentSearchDir(self, dir):
        self.dirLabel.setText(dir)

    def searchOptionsChanged(self):
        self.matchCase = self.matchCaseBox.isChecked()
        self.matchWholeWord = self.matchWholeWordBox.isChecked()
        self.regExp = self.regExpBox.isChecked()
        self.recursive = self.recursiveBox.isChecked()

    def toggleReplace(self, state):
        self.replaceLine.setVisible(state)
        self.replaceLabel.setVisible(state)

    def find(self):
        self.text = self.findtextLine.text()
        if self.regExp:
            text = self.text
        else:
            text = re.escape(self.text)
        if self.matchWholeWord:
            text = "\\b{0}\\b".format(text)
        flags = re.UNICODE | re.LOCALE
        if not self.matchCase:
            flags |= re.IGNORECASE
        try:
            self.search = re.compile(text, flags)
        except re.error as err:
            message = QtGui.QMessageBox.warning(self, "Find-in-Files",
                                                "Wrong regular expression: {0}!".format(str(err).capitalize()))
            return
        fileFilter = self.filterEdit.text()
        fileFilterList = \
            ["^{0}$".format(filter.replace(".", "\.").replace("*", ".*"))
             for filter in fileFilter.split(";")]
        filterRe = re.compile("|".join(fileFilterList))
        if self.projectBox.isChecked():
            dirName = self.projectPathDict["sourcedir"]
        else:
            dirName = self.directoryLine.text().strip()
            if dirName == '':
                message = QtGui.QMessageBox.warning(self, "Find-in-Files",
                                                    "Please specify a directory!")
                return
        if not os.path.exists(dirName):
            message = QtGui.QMessageBox.warning(self, "Find-in-Files",
                                                "Path does not exist!")
        if not os.path.isdir(dirName):
            message = QtGui.QMessageBox.warning(self, "Find-in-Files",
                                                "Path is not a directory!")
            return
        else:
            self.filesView.clear()
            self.findThread.find(
                dirName, filterRe, self.search, self.recursive)
        self.bottomStackSwitcher.setCurrentWidget(self)

    def updateFilesTable(self):
        self.stopButton.setHidden(True)
        while len(self.findThread.found) != 0:
            item = self.findThread.found.pop(0)
            icon = Global.iconFromPath(item.text(0))
            item.setIcon(0, icon)
            self.filesView.addTopLevelItem(item)
            item.setFirstColumnSpanned(True)
            item.setExpanded(True)
        self.stopButton.setHidden(False)

    def searchStarted(self):
        self.findButton.setDisabled(True)
        self.findButton.hide()
        self.stopButton.show()
        self.statusWidget.show()

    def searchEnded(self):
        self.findButton.setDisabled(False)
        self.stopButton.hide()
        self.findButton.show()
        self.dirLabel.clear()
        self.statusWidget.hide()

    def stopFinder(self):
        self.findThread.stopThread()

########NEW FILE########
__FILENAME__ = Messages
import os
from PyQt4 import QtGui, QtCore


class MessagesWidget(QtGui.QTreeWidget):

    def __init__(self, bottomStackSwitcher, vSplitter, parent=None):
        QtGui.QTreeWidget.__init__(self, parent)

        self.bottomStackSwitcher = bottomStackSwitcher
        self.vSplitter = vSplitter

        self.setHeaderLabels(["Message", "Time"])
        self.setColumnWidth(0, 400)
        self.setColumnWidth(1, 40)

    def addMessage(self, messType, title, messageList):
        parentItem = QtGui.QTreeWidgetItem(self)
        if messType == 0:
            parentItem.setIcon(0, QtGui.QIcon(
                os.path.join("Resources", "images", "security", "attention")))
        elif messType == 1:
            parentItem.setIcon(0, QtGui.QIcon(
                os.path.join("Resources", "images", "security", "warning")))
        elif messType == 2:
            parentItem.setIcon(0, QtGui.QIcon(
                os.path.join("Resources", "images", "security", "danger")))
        parentItem.setText(0, title)
        parentItem.setText(1, QtCore.QDateTime().currentDateTime().toString())
        for i in messageList:
            item = QtGui.QTreeWidgetItem(parentItem)
            item.setFirstColumnSpanned(True)
            item.setText(0, i)
            parentItem.addChild(item)
        parentItem.setExpanded(True)
        self.scrollToItem(parentItem, 1)

        self.vSplitter.showMessageAvailable()
        self.bottomStackSwitcher.setCount(self, str(self.topLevelItemCount()))
        self.bottomStackSwitcher.setCurrentWidget(self)

########NEW FILE########
__FILENAME__ = Profiler
import os
import locale
import pstats
from PyQt4 import QtCore, QtGui


class Profiler(QtGui.QTreeWidget):

    def __init__(self, useData, bottomStackSwitcher, parent=None):
        QtGui.QTreeWidget.__init__(self, parent)

        self.useData = useData
        self.bottomStackSwitcher = bottomStackSwitcher

        self.setHeaderLabels(["ncalls", "tottime", "percall",
                              "cumtime", "filename", "# line", "function"])
        self.setSortingEnabled(True)
        self.sortByColumn(4, QtCore.Qt.AscendingOrder)

    def changeView(self, index):
        self.viewStack.setCurrentIndex(index)

    def processStarted(self):
        self.errorLabel.clear()
        self.errooIconLabel.hide()
        self.errorLabel.hide()
        self.profileButton.setDisabled(True)

    def writeProcessError(self):
        default_encoding = locale.getpreferredencoding()
        text = \
            self.process.readAllStandardError().data().decode(default_encoding)
        self.errorLabel.setText(text)
        self.errooIconLabel.show()
        self.errorLabel.show()

    def viewProfile(self, file=None):
        if file is None:
            file = os.path.join("temp", "profile")
        self.p = pstats.Stats(file)
        self.p.calc_callees()
        self.stats = self.p.stats
        # self.saveButton.setDisabled(False)

        self.clear()

        for func, (cc, nc, tt, ct, callers) in self.stats.items():
            item = QtGui.QTreeWidgetItem()
            item.setText(0, str(cc))
            item.setText(1, str(nc))
            item.setText(2, str(tt))
            item.setText(3, str(ct))

            item.setText(4, str(func[0]))
            item.setText(5, str(func[1]))
            item.setText(6, str(func[2]))

            child = QtGui.QTreeWidgetItem()
            for caller, (cc1, nc1, tt1, ct1) in callers.items():
                child.setIcon(
                    0, QtGui.QIcon(os.path.join("Resources", "images", "lightning")))
                child.setText(0, str(cc))
                child.setText(1, str(nc1))
                child.setText(2, str(tt1))
                child.setText(3, str(ct1))

                child.setText(4, caller[0])
                child.setText(5, str(caller[1]))
                child.setText(6, caller[2])
            for i in range(7):
                child.setForeground(i, QtGui.QBrush(QtGui.QColor("#FF0000")))
            item.addChild(child)
            self.addTopLevelItem(item)
        self.bottomStackSwitcher.setCurrentWidget(self)

    def saveProfile(self):
        options = QtGui.QFileDialog.Options()
        savepath = os.path.join(self.useData.getLastOpenedDir(),
                                self.projectWindowStack.currentWidget().projectPathDict["name"] + '_' + QtCore.QDateTime().currentDateTime().toString().replace(' ', '_').replace(':', '-'))
        savepath = os.path.normpath(savepath)
        fileName = QtGui.QFileDialog.getSaveFileName(self,
                                                     "Save profile", savepath,
                                                     "Profiles (*.cProfile)", options)
        if fileName:
            try:
                self.useData.saveLastOpenedDir(os.path.split(fileName)[0])
                self.p.dump_stats(fileName)
            except Exception as err:
                message = QtGui.QMessageBox.warning(
                    self, "Save Profile", str(err))

    def openProfile(self):
        options = QtGui.QFileDialog.Options()
        fileName = QtGui.QFileDialog.getOpenFileName(self,
                                                     "Open profile", self.useData.getLastOpenedDir(
                                                     ),
                                                     "Profiles (*.cProfile)", options)
        if fileName:
            try:
                self.useData.saveLastOpenedDir(os.path.split(fileName)[0])
                self.viewProfile(fileName)
            except Exception as err:
                message = QtGui.QMessageBox.warning(
                    self, "Open Profile", str(err))

########NEW FILE########
__FILENAME__ = RunWidget
import os
import re
import sys
import locale
from PyQt4 import QtCore, QtGui
from PyQt4.Qsci import QsciScintilla, QsciScintillaBase, QsciLexerCustom


from Extensions.BaseScintilla import BaseScintilla
from Extensions.PathLineEdit import PathLineEdit
from Extensions import Global
from Extensions import StyleSheet

default_encoding = locale.getpreferredencoding()


class SetRunParameters(QtGui.QLabel):

    def __init__(self, projectSettings, projectPathDict, useData, parent=None):
        QtGui.QLabel.__init__(self, parent)

        self.setMinimumSize(400, 220)

        self.setBackgroundRole(QtGui.QPalette.Background)
        self.setAutoFillBackground(True)
        self.setObjectName("containerLabel")
        self.setStyleSheet(StyleSheet.toolWidgetStyle)

        self.projectSettings = projectSettings
        self.useData = useData
        self.projectPathDict = projectPathDict

        mainLayout = QtGui.QVBoxLayout()

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        label = QtGui.QLabel("Run Parameters")
        label.setObjectName("toolWidgetNameLabel")
        hbox.addWidget(label)

        hbox.addStretch(1)

        self.hideButton = QtGui.QToolButton()
        self.hideButton.setAutoRaise(True)
        self.hideButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "cross_")))
        self.hideButton.clicked.connect(self.hide)
        hbox.addWidget(self.hideButton)

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        self.runTypeBox = QtGui.QComboBox()
        self.runTypeBox.addItem("Run")
        self.runTypeBox.addItem("Profiler")
        self.runTypeBox.addItem("Trace")
        if self.projectSettings["RunType"] == 'Profiler':
            self.runTypeBox.setCurrentIndex(1)
        elif self.projectSettings["RunType"] == 'Trace':
            self.runTypeBox.setCurrentIndex(2)
        self.runTypeBox.currentIndexChanged.connect(self.saveArguments)
        self.runTypeBox.currentIndexChanged.connect(self.runTypeChanged)
        hbox.addWidget(self.runTypeBox)

        self.traceTypeBox = QtGui.QComboBox()
        self.traceTypeBox.addItem("Calling relationships")
        self.traceTypeBox.addItem("Functions called")
        self.traceTypeBox.addItem("Times lines are called")
        self.traceTypeBox.addItem("View currently running line of code")
        self.traceTypeBox.setCurrentIndex(int(
            self.projectSettings["TraceType"]))
        self.traceTypeBox.currentIndexChanged.connect(self.saveArguments)
        hbox.addWidget(self.traceTypeBox)

        if self.runTypeBox.currentIndex() != 2:
            self.traceTypeBox.hide()

        self.runWithArgsBox = QtGui.QCheckBox("Arguments:")
        if self.projectSettings["RunWithArguments"] == 'True':
            self.runWithArgsBox.setChecked(True)
        self.runWithArgsBox.toggled.connect(self.saveArguments)
        mainLayout.addWidget(self.runWithArgsBox)

        self.argumentsLine = PathLineEdit()
        self.argumentsLine.setText(self.projectSettings["RunArguments"])
        self.argumentsLine.textChanged.connect(self.saveArguments)
        mainLayout.addWidget(self.argumentsLine)

        hbox = QtGui.QHBoxLayout()

        self.clearOutputBox = QtGui.QCheckBox("Clear output window")
        if self.projectSettings["ClearOutputWindowOnRun"] == 'True':
            self.clearOutputBox.setChecked(True)
        self.clearOutputBox.toggled.connect(self.saveArguments)
        hbox.addWidget(self.clearOutputBox)

        hbox.addStretch(1)

        hbox.addWidget(QtGui.QLabel("Max Output Size <lines>"))

        self.bufferSizeBox = QtGui.QSpinBox()
        self.bufferSizeBox.setMaximum(999)
        self.bufferSizeBox.setMinimumWidth(100)
        self.bufferSizeBox.setValue(int(self.projectSettings['BufferSize']))
        self.bufferSizeBox.valueChanged.connect(self.saveArguments)
        hbox.addWidget(self.bufferSizeBox)

        mainLayout.addLayout(hbox)

        self.runPointBox = QtGui.QComboBox()
        self.runPointBox.addItem("Internal Console")
        self.runPointBox.addItem("External Console")
        if self.projectSettings["RunInternal"] == 'False':
            self.runPointBox.setCurrentIndex(1)
        self.runPointBox.currentIndexChanged.connect(self.saveArguments)
        mainLayout.addWidget(self.runPointBox)

        self.useVirtualEnvBox = QtGui.QCheckBox("Use Virtual Environment")
        if self.projectSettings["UseVirtualEnv"] == 'True':
            self.useVirtualEnvBox.setChecked(True)
        self.useVirtualEnvBox.toggled.connect(self.setDefaultInterpreter)
        mainLayout.addWidget(self.useVirtualEnvBox)

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        self.installedPythonVersionBox = QtGui.QComboBox()
        self.installedPythonVersionBox.setMinimumWidth(200)
        self.updateInstalledInterpreters()
        self.installedPythonVersionBox.currentIndexChanged.connect(
            self.setDefaultInterpreter)
        hbox.addWidget(self.installedPythonVersionBox)

        hbox.addStretch(1)

        label = QtGui.QLabel("Installed Python")
        hbox.addWidget(label)

        self.setLayout(mainLayout)

        self.setDefaultInterpreter()

    def updateInstalledInterpreters(self):
        self.installedPythonVersionBox.clear()
        if len(self.useData.SETTINGS["InstalledInterpreters"]) > 0:
            for i in self.useData.SETTINGS["InstalledInterpreters"]:
                self.installedPythonVersionBox.addItem(i)
                if self.projectSettings["UseVirtualEnv"] == 'False':
                    index = self.installedPythonVersionBox.findText(
                        self.projectSettings["DefaultInterpreter"])
                    if index != -1:
                        self.installedPythonVersionBox.setCurrentIndex(index)
        else:
            self.installedPythonVersionBox.addItem("<No Python installed>")

    def runTypeChanged(self, index):
        if index == 2:
            self.traceTypeBox.show()
        else:
            self.traceTypeBox.hide()

    def saveArguments(self):
        self.projectSettings["RunWithArguments"] = str(
            self.runWithArgsBox.isChecked())
        self.projectSettings[
            "RunArguments"] = self.argumentsLine.text().strip()
        self.projectSettings["ClearOutputWindowOnRun"] = str(
            self.clearOutputBox.isChecked())
        self.projectSettings["BufferSize"] = str(self.bufferSizeBox.value())
        self.projectSettings["RunType"] = self.runTypeBox.currentText()
        self.projectSettings["RunInternal"] = str(
            self.runPointBox.currentIndex() == 0)
        self.projectSettings["TraceType"] = str(
            self.traceTypeBox.currentIndex())

    def setDefaultInterpreter(self):
        if self.useVirtualEnvBox.isChecked():
            # FIXME: Needs to be corrected for each platform
            if sys.platform == 'win32':
                self.projectSettings["DefaultInterpreter"] = \
                    os.path.join(self.projectPathDict["venvdir"],
                                     "Scripts", "python.exe")
            elif sys.platform == 'darwin':
                self.projectSettings["DefaultInterpreter"] = \
                    os.path.join(self.projectPathDict["venvdir"],
                                     "Scripts", "python.exe")
            else:
                self.projectSettings["DefaultInterpreter"] = \
                    os.path.join(self.projectPathDict["venvdir"],
                                     "Scripts", "python.exe")
        else:
            if len(self.useData.SETTINGS["InstalledInterpreters"]) > 0:
                self.projectSettings["DefaultInterpreter"] = \
                    self.installedPythonVersionBox.currentText()
            else:
                self.projectSettings["DefaultInterpreter"] = 'None'
        self.projectSettings["UseVirtualEnv"] = str(
            self.useVirtualEnvBox.isChecked())


class OutputLexer(QsciLexerCustom):

    def __init__(self, parent=None):
        QsciLexerCustom.__init__(self, parent)

        self._styles = {
            0: 'Default',
            1: 'ErrorInfo',
            2: 'OutputInfo',
            3: 'ExitInfo',
            4: 'Start'
            }
        for key in self._styles:
            setattr(self, self._styles[key], key)

    def description(self, style):
        return self._styles.get(style, '')

    def defaultColor(self, style):
        if style == self.Default:
            return QtGui.QColor('#ffffff')
        elif style == self.ErrorInfo:
            return QtGui.QColor('#E6DB74')
        elif style == self.OutputInfo:
            return QtGui.QColor('#FFFFFF')
        elif style == self.ExitInfo:
            return QtGui.QColor('#3DA3EF')
        elif style == self.Start:
            return QtGui.QColor('#7FE22A')
        return QsciLexerCustom.defaultColor(self, style)

    def defaultFont(self, style):
        if style == self.Default:
            return Global.getDefaultFont()
        elif style == self.ErrorInfo:
            return Global.getDefaultFont()
        elif style == self.OutputInfo:
            return Global.getDefaultFont()
        elif style == self.ExitInfo:
            return Global.getDefaultFont()
        elif style == self.Start:
            return Global.getDefaultFont()
        return QsciLexerCustom.defaultFont(self, style)

    def defaultPaper(self, style):
        return QtGui.QColor('#000000')

    def defaultEolFill(self, style):
        return True

    def styleText(self, start, end):
        editor = self.editor()
        if editor is None:
            return

        # scintilla works with encoded bytes, not decoded characters.
        # this matters if the source contains non-ascii characters and
        # a multi-byte encoding is used (e.g. utf-8)
        source = ''
        if end > editor.length():
            end = editor.length()
        if end > start:
            if sys.hexversion >= 0x02060000:
                # faster when styling big files, but needs python 2.6
                source = bytearray(end - start)
                editor.SendScintilla(
                    editor.SCI_GETTEXTRANGE, start, end, source)
            else:
                source = editor.text().encode('utf-8')
        if not source:
            return

        set_style = self.setStyling
        self.startStyling(start, 0x1f)


class RunWidget(BaseScintilla):

    loadProfile = QtCore.pyqtSignal()

    def __init__(
        self, bottomStackSwitcher, projectData, useData, editorTabWidget, vSplitter, runProjectAct, stopRunAct,
            runFileAct, parent=None):
        BaseScintilla.__init__(self, parent)

        self.projectData = projectData
        self.runProjectAct = runProjectAct
        self.stopRunAct = stopRunAct
        self.runFileAct = runFileAct
        self.editorTabWidget = editorTabWidget
        self.parent = parent
        self.vSplitter = vSplitter
        self.bottomStackSwitcher = bottomStackSwitcher
        self.useData = useData

        self.profileMode = False
        self.tracebackRe = re.compile(r'(\s)*File "(.*?)", line \d.+')

        self.setMarginWidth(1, 0)
        self.toggleInsertOrOvertype()

        self.linkIndicator = self.indicatorDefine(
            QsciScintilla.INDIC_PLAIN, 8)
        self.setIndicatorForegroundColor(QtGui.QColor(
            "#474747"), self.linkIndicator)
        self.setIndicatorDrawUnder(True, self.linkIndicator)

        self.lexer = OutputLexer(self)
        self.setLexer(self.lexer)
        self.setFont(Global.getDefaultFont())
        self.openMode = QtCore.QIODevice.ReadWrite
        self.currentProcess = None

        self.setCaretForegroundColor(QtGui.QColor("#ffffff"))
        self.setWrapMode(QsciScintilla.WrapWord)
        self.setSelectionBackgroundColor(QtGui.QColor("#391EE8"))
        self.setSelectionForegroundColor(QtGui.QColor("#FFFFFF"))

        self.runProcess = QtCore.QProcess(self)
        self.runProcess.error.connect(self.writeProcessError)
        self.runProcess.stateChanged.connect(self.stateChanged)
        self.runProcess.readyReadStandardOutput.connect(self.writeOutput)
        self.runProcess.readyReadStandardError.connect(self.writeError)
        self.runProcess.started.connect(self.processStarted)
        self.runProcess.finished.connect(self.writeExitStatus)
        self.runProcess.finished.connect(self.processEnded)

        self.copyAct = QtGui.QAction("Copy", self,
                                     statusTip="Copy", triggered=self.copyText)
        self.contextMenu = QtGui.QMenu()
        self.contextMenu.addAction(self.copyAct)

        self.setReadOnly(True)
        self.blocking_cursor_pos = (0, 0)

        self.setStyleSheet("QsciScintilla {border: none;}")

    def leaveEvent(self, event):
        self.clearAllIndicators(self.linkIndicator)

        super(RunWidget, self).leaveEvent(event)

    def mouseMoveEvent(self, event):
        x = event.x()
        y = event.y()

        line = self.getHoveredLine(x, y)
        lineText = self.text(line)

        l = len(lineText)
        offset = l - len(lineText.lstrip())

        self.clearAllIndicators(self.linkIndicator)

        if self.tracebackRe.match(lineText):
            self.fillIndicatorRange(
                line, offset, line, (l - 1), self.linkIndicator)

        super(RunWidget, self).mouseMoveEvent(event)

    def copyText(self):
        cb = self.editorTabWidget.app.clipboard()
        if self.hasSelectedText():
            cb.setText(self.selectedText())
        else:
            cb.setText(self.text())

    def stateChanged(self, newState):
        if newState == 2:
            self.vSplitter.showRunning()
            self.setReadOnly(False)
        else:
            self.setReadOnly(True)

    def insertInput(self, text):
        self.append('\n')
        data = QtCore.QByteArray()
        data.append(bytes(text + '\n', encoding="utf-8"))
        self.runProcess.write(data)

    def writeProcessError(self, processError):
        self.writeOutput()
        self.writeError()
        if processError == 0:
            self.printout(">>> FailedToStart!\n", 3)
        elif processError == 1:
            self.printout(">>> Crashed!\n", 3)
        elif processError == 2:
            self.printout(">>> Timedout!\n", 3)
        elif processError == 3:
            self.printout(">>> WriteError!\n", 3)
        elif processError == 4:
            self.printout(">>> ReadError!\n", 3)
        elif processError == 5:
            self.printout(">>> UnknownError!\n", 3)
        self.bottomStackSwitcher.setCurrentWidget(self)

    def writeOutput(self):
        while self.runProcess.canReadLine():
            if self.currentProcess is None:
                break
            text = self.runProcess.readLine().data().decode(
                default_encoding)
            self.printout(text, 2)

    def writeError(self):
        text = \
            self.runProcess.readAllStandardError().data().decode(
                default_encoding)
        self.printout(text, 1)
        self.bottomStackSwitcher.setCurrentWidget(self)

    def writeExitStatus(self, exitCode, exitStatus):
        self.writeOutput()
        self.writeError()
        if exitStatus == QtCore.QProcess.NormalExit:
            self.printout(">>> Exit: {0}\n".format(str(exitCode)), 3)
        else:
            # error will be displayed instead by writeProcessError
            pass
        self.currentProcess = None
        if exitCode == 1:
            self.vSplitter.showError()
        else:
            self.vSplitter.showNormal()

    def processStarted(self):
        self.runProjectAct.setVisible(False)
        self.stopRunAct.setVisible(True)
        self.runFileAct.setEnabled(False)

    def processEnded(self):
        self.runProjectAct.setVisible(True)
        self.stopRunAct.setVisible(False)
        self.runFileAct.setEnabled(True)

        self.currentProcess = None
        if self.profileMode:
            self.loadProfile.emit()
            self.profileMode = False

    def printout(self, text, styleNum):
        start = self.length()
        self.SendScintilla(QsciScintillaBase.SCI_STARTSTYLING, start)
        self.append(text)
        self.recolor(start, -1)
        self.SendScintilla(QsciScintillaBase.SCI_SETSTYLING, len(text),
                           styleNum)
        QtCore.QCoreApplication.processEvents()
        self.setFirstVisibleLine(self.lines())
        self.blocking_cursor_pos = self.position('eof')
        self.setCursorPosition(self.blocking_cursor_pos[
                               0], self.blocking_cursor_pos[1])

    def pythonPath(self):
        if self.projectData["DefaultInterpreter"] == "None":
            message = QtGui.QMessageBox.critical(
                self, "Run", "No Python interpreter to run your code. Please install Python.")
            return None
        else:
            if os.path.exists(self.projectData["DefaultInterpreter"]):
                if len(self.useData.SETTINGS["InstalledInterpreters"]) == 0:
                    message = QtGui.QMessageBox.critical(
                        self, "Run", "Python must be installed for virtual environment to work.")
                    return None
                else:
                    return self.projectData["DefaultInterpreter"]
            else:
                message = QtGui.QMessageBox.critical(
                    self, "Run", "The current Python interpreter is not available.")
                return None

    def runModule(self, runScript, fileName, run_internal, run_with_args, args):
        pythonPath = self.pythonPath()
        if pythonPath is None:
            return
        env = QtCore.QProcessEnvironment().systemEnvironment()
        self.runProcess.setProcessEnvironment(env)

        if run_internal:
            self.currentProcess = fileName
            if run_with_args:
                self.printout(">>> Running: {0} <arguments={1}>\n".format(
                    self.currentProcess, args), 4)
                self.runProcess.start(pythonPath, [
                                      runScript, args], self.openMode)
            else:
                self.printout(">>> Running: {0} <arguments=None>\n".format(
                    self.currentProcess), 4)
                self.runProcess.start(pythonPath, [runScript], self.openMode)
            self.runProcess.waitForStarted()
        else:
            if run_with_args:
                self.runProcess.startDetached(
                    pythonPath, ["-i", runScript, args])
            else:
                self.runProcess.startDetached(pythonPath, ["-i", runScript])
            # -i ensures that the shell program remains even after the source program
            # has finished or has been terminated in order for debugging to be
            # done

    def runTrace(self, runScript, fileName, run_internal, run_with_args, args, option):
        pythonPath = self.pythonPath()
        if pythonPath is None:
            return

        env = QtCore.QProcessEnvironment().systemEnvironment()
        self.runProcess.setProcessEnvironment(env)

        if run_internal:
            self.currentProcess = fileName
            if run_with_args:
                self.printout(">>> Trace Execution: {0} <arguments={1}>\n".format(
                    self.currentProcess, args), 4)
            else:
                self.printout(">>> Trace Execution: {0} <arguments=None>\n".format(
                    self.currentProcess), 4)
            if option == 0:
                # calling relationships
                if run_with_args:
                    self.runProcess.start(pythonPath, ['-m', "trace",
                                                       '--trackcalls', runScript, args], self.openMode)
                else:
                    self.runProcess.start(pythonPath, ['-m', "trace",
                                                       '--trackcalls', runScript], self.openMode)
            elif option == 1:
                # functions called
                if run_with_args:
                    self.runProcess.start(pythonPath, ['-m', "trace",
                                                       '--listfuncs', runScript, args], self.openMode)
                else:
                    self.runProcess.start(pythonPath, ['-m', "trace",
                                                       '--listfuncs', runScript], self.openMode)
            elif option == 2:
                # creates a file with same code but showing how many times
                # each line of code args
                countfile = os.path.abspath(os.path.join("temp", "count.txt"))
                file = open(countfile, 'w')
                file.close()
                if run_with_args:
                    self.runProcess.start(pythonPath, ['-m', "trace",
                                                       '--count', '--file={0}'.format(countfile), runScript, args], self.openMode)
                else:
                    self.runProcess.start(pythonPath, ['-m', "trace",
                                                       '--count', '--file={0}'.format(countfile), runScript], self.openMode)
            elif option == 3:
                # show in real time what lines of code are currently being
                # executed
                if run_with_args:
                    self.runProcess.start(
                        pythonPath, ['-m', "trace", '--timing',
                                     '--trace', runScript, args], self.openMode)
                else:
                    self.runProcess.start(
                        pythonPath, ['-m', "trace", '--timing',
                                     '--trace', runScript], self.openMode)
        else:
            if option == 0:
                # calling relationships
                if run_with_args:
                    self.runProcess.startDetached(
                        pythonPath, ['-i', '-m', "trace",
                                                 '--trackcalls', runScript, args], self.openMode)
                else:
                    self.runProcess.startDetached(
                        pythonPath, ['-i', '-m', "trace",
                                                 '--trackcalls', runScript])
            elif option == 1:
                # functions called
                if run_with_args:
                    self.runProcess.startDetached(
                        pythonPath, ['-i', '-m', "trace",
                                                 '--listfuncs', runScript, args])
                else:
                    self.runProcess.startDetached(
                        pythonPath, ['-i', '-m', "trace",
                                                 '--listfuncs', runScript])
            elif option == 2:
                # creates a file with same code but showing how many times each
                # line of code runs
                if run_with_args:
                    self.runProcess.startDetached(
                        pythonPath, ['-i', '-m', "trace",
                                                 '--count', runScript, args])
                else:
                    self.runProcess.startDetached(
                        pythonPath, ['-i', '-m', "trace",
                                                 '--count', runScript])
            elif option == 3:
                # show in real time what lines of code are currently being
                # executed
                if run_with_args:
                    self.runProcess.startDetached(
                        pythonPath, ['-i', '-m', "trace",
                                                 '--timing', '--trace', runScript, args])
                else:
                    self.runProcess.startDetached(
                        pythonPath, ['-i', '-m', "trace",
                                                 '--timing', '--trace', runScript])

    def runProfiler(self, runScript, fileName, run_internal, run_with_args, args):
        pythonPath = self.pythonPath()
        if pythonPath is None:
            return
        env = QtCore.QProcessEnvironment().systemEnvironment()
        self.runProcess.setProcessEnvironment(env)

        p_args = ['-m', 'cProfile', '-o',
                  os.path.abspath(os.path.join("temp", "profile"))]
        if os.name == 'nt':
            # On Windows, one has to replace backslashes by slashes to avoid
            # confusion with escape characters (otherwise, for example, '\t'
            # will be interpreted as a tabulation):
            p_args.append(os.path.normpath(runScript).replace(os.sep, '/'))
        else:
            p_args.append(runScript)

        self.profileMode = True
        if run_internal:
            self.currentProcess = fileName
            if run_with_args:
                self.printout(">>> Profiling: {0} <arguments={1}>\n".format(
                    self.currentProcess, args), 4)
            else:
                self.printout(">>> Profiling: {0} <arguments=None>\n".format(
                    self.currentProcess), 4)
            self.runProcess.start(pythonPath, p_args)
            self.runProcess.waitForStarted()
        else:
            p_args.insert(0, "-i")
            self.runProcess.startDetached(pythonPath, p_args)
            # -i ensures that the shell program remains even after the source program
            # has finished or has been terminated in order for debugging to be
            # done

    def reRunFile(self):
        self.run(False, True)

    def runFile(self):
        saved = self.editorTabWidget.save()
        if saved:
            self.run(False)

    def runProject(self):
        if self.editorTabWidget.errorsInProject():
            reply = QtGui.QMessageBox.warning(self, "Run Project",
                                              "There are errors in your project. Run anyway?",
                                              QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
            if reply == QtGui.QMessageBox.Yes:
                pass
            else:
                return
        saved = self.editorTabWidget.saveProject()
        if saved:
            pass
        else:
            return
        self.run(True)

    def run(self, project, rerun=False):
        if project:
            filePath = self.editorTabWidget.projectPathDict["mainscript"]
            fileName = self.editorTabWidget.projectPathDict["name"]
            if os.path.exists(filePath) is not True:
                message = QtGui.QMessageBox.warning(self, "Run Project",
                                                    "Main script is missing: " + fileName)
                return
        else:
            if self.editorTabWidget.getSource().strip() == '':
                message = QtGui.QMessageBox.warning(self, "Run",
                                                    "Source code must be present!")
                return
            if rerun is False:
                self.filePath = self.editorTabWidget.getEditorData("filePath")
                filePath = self.filePath
                self.fileName = self.editorTabWidget.getTabName()
                fileName = self.fileName
                self.runFileAct.setEnabled(True)
            else:
                filePath = self.filePath
                fileName = self.fileName
        cwd = os.path.dirname(filePath)
        self.runProcess.setWorkingDirectory(cwd)

        if self.projectData["RunInternal"] == "True":
            run_internal = True
        else:
            run_internal = False
        run_with_args = self.projectData["RunWithArguments"]
        if run_with_args == "True":
            run_with_args = True
        else:
            run_with_args = False
        args = self.projectData["RunArguments"]
        bufferSize = int(self.projectData["BufferSize"])

        clearOutput = self.projectData["ClearOutputWindowOnRun"]

        if clearOutput == "True":
            self.clear()
        elif self.lines() >= bufferSize:
            self.clear()
        runType = self.projectData["RunType"]
        if runType == "Run":
            self.runModule(filePath, fileName, run_internal, run_with_args,
                           args)
        if runType == "Profiler":
            self.runProfiler(filePath, fileName, run_internal, run_with_args,
                             args)
        elif runType == "Trace":
            option = int(self.projectData["TraceType"])
            self.runTrace(filePath, fileName, run_internal, run_with_args,
                          args, option)

    def stopProcess(self):
        self.runProcess.kill()
        self.currentProcess = None

    def contextMenuEvent(self, event):
        if self.isReadOnly():
            self.contextMenu.exec_(event.globalPos())
        else:
            event.ignore()

    def getHoveredLine(self, x, y):
        position = self.SendScintilla(
            QsciScintilla.SCI_POSITIONFROMPOINT, x, y)
        line = self.SendScintilla(QsciScintilla.SCI_LINEFROMPOSITION, position)

        return line

    def mouseDoubleClickEvent(self, event):
        x = event.x()
        y = event.y()

        line = self.getHoveredLine(x, y)
        lineText = self.text(line)

        if self.tracebackRe.match(lineText):
            file_word_index = lineText.find('File')
            min_index = lineText.find('"') + 1
            max_index = lineText.find('"', min_index)
            path = lineText[min_index:max_index]

            max_index += 7
            line_end_index = lineText.find(',', max_index)
            lineno = int(lineText[max_index:line_end_index]) - 1

            self.editorTabWidget.loadfile(path)
            self.editorTabWidget.showLine(lineno)

        event.ignore()

    def mousePressEvent(self, event):
        if self.isReadOnly():
            super(RunWidget, self).mousePressEvent(event)
        else:
            event.ignore()

    def keyPressEvent(self, event):
        """
        Reimplemented to create a console-like interface.
        """
        line, index = self.getCursorPosition()
        key = event.key()
        ctrl = event.modifiers() & QtCore.Qt.ControlModifier
        alt = event.modifiers() & QtCore.Qt.AltModifier
        shift_down = event.modifiers() & QtCore.Qt.ShiftModifier
        if ctrl:
            pass
        elif alt:
            pass
        elif key == QtCore.Qt.Key_Backspace:
            if self.getCursorPosition() == self.blocking_cursor_pos:
                pass
            else:
                QsciScintilla.keyPressEvent(self, event)
        elif key == QtCore.Qt.Key_Left:
            if self.getCursorPosition() == self.blocking_cursor_pos:
                pass
            else:
                QsciScintilla.keyPressEvent(self, event)
        elif key == QtCore.Qt.Key_Up:
            self.scrollVertical(-1)
        elif key == QtCore.Qt.Key_Down:
            self.scrollVertical(1)
        elif key == QtCore.Qt.Key_Return:
            # get input text
            text = self.getText(
                self.blocking_cursor_pos, self.position("eof"))
            self.insertInput(text)
        else:
            QsciScintilla.keyPressEvent(self, event)

########NEW FILE########
__FILENAME__ = TasksWidget
import re
import os
from PyQt4 import QtCore, QtGui


class TaskFinderThread(QtCore.QThread):

    TASKS_PATTERN = r"(^|#)[ ]*(TODO|FIXME|XXX|HINT|TIP)( |:)([^#]*)"
    newTasks = QtCore.pyqtSignal(list)
    results = []

    def run(self):
        # TODO: this is a test for the following function
        """
        Find tasks in source code (TODO, FIXME, XXX, ...)
        """
        results = []
        for line, text in enumerate(self.source.splitlines()):
            for todo in re.findall(self.TASKS_PATTERN, text):
                results.append((todo[1], line + 1, todo[
                               -1].strip().capitalize()))
        if results != self.results:
            self.results = []
            self.results.extend(results)
            self.newTasks.emit(results)

    def findTasks(self, source):
        self.source = source

        self.start()


class Tasks(QtGui.QTreeWidget):

    def __init__(self, editorTabWidget, bottomStackSwitcher, parent=None):
        QtGui.QTreeWidget.__init__(self, parent)

        self.setColumnCount(4)
        self.setHeaderLabels(["#", "Type", "Line", "Task"])
        self.setAutoScroll(True)

        self.setColumnWidth(0, 60)
        self.setColumnWidth(1, 80)
        self.setColumnWidth(2, 80)
        self.itemPressed.connect(self.taskPressed)

        self.editorTabWidget = editorTabWidget
        self.bottomStackSwitcher = bottomStackSwitcher
        self.taskFinder = TaskFinderThread()

        self.taskFinderTimer = QtCore.QTimer()
        self.taskFinderTimer.setSingleShot(True)
        self.taskFinderTimer.timeout.connect(self.findTasks)

        self.editorTabWidget.currentEditorTextChanged.connect(self.startTimer)
        self.editorTabWidget.currentChanged.connect(self.startTimer)
        self.taskFinder.newTasks.connect(self.updateTasks)

        self.setStyleSheet("""
                    QTreeView {
                         show-decoration-selected: 1; /* make the selection span the entire width of the view */
                         border: none;
                    }
                    """)

    def startTimer(self):
        self.taskFinderTimer.start(1000)

    def updateTasks(self, results):
        self.clear()
        self.bottomStackSwitcher.setCount(self, str(len(results)))
        for i in results:
            item = QtGui.QTreeWidgetItem()
            item.setIcon(0, QtGui.QIcon(
                os.path.join("Resources", "images", "Clear Green Button")))
            item.setText(1, i[0])
            item.setText(2, str(i[1]))
            item.setText(3, i[2])
            self.addTopLevelItem(item)

    def taskPressed(self, item):
        lineno = int(item.text(2)) - 1
        self.editorTabWidget.showLine(lineno)

    def findTasks(self):
        self.taskFinder.findTasks(self.editorTabWidget.getSource())

########NEW FILE########
__FILENAME__ = BusyWidget
from PyQt4 import QtCore, QtGui


class BusyWidget(QtGui.QDialog):

    cancel = QtCore.pyqtSignal()

    def __init__(self, app, useData, parent=None):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.FramelessWindowHint)
        self.setAttribute(QtCore.Qt.WA_TranslucentBackground, True)

        self.setFixedSize(250, 60)

        self.app = app
        self.useData = useData

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setMargin(0)
        mainLayout.setSpacing(0)
        self.setLayout(mainLayout)

        mainLabel = QtGui.QLabel()
        mainLabel.setStyleSheet(
            """background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                                 stop: 0 #343434,
                                                 stop: 0.7 #343434);

                                border: 1px solid #C9EAFB;
                                border-radius: 0px;
                            """)
        mainLayout.addWidget(mainLabel)

        vbox = QtGui.QVBoxLayout()
        mainLabel.setLayout(vbox)

        self.captionLabel = QtGui.QLabel()
        self.captionLabel.setAlignment(QtCore.Qt.AlignHCenter)
        self.captionLabel.setStyleSheet(
            "color: white; background: none; border: none;")
        vbox.addWidget(self.captionLabel)
        vbox.addStretch(1)

        self.progressBar = QtGui.QProgressBar()
        self.progressBar.setMaximumHeight(15)
        self.progressBar.setStyleSheet(
            """
                          QProgressBar {
                             border: 1px solid #707070;
                             text-align: center;
                             font-size: 10px;
                             padding: 1px;
                             border-radius: 0px;
                             background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                                       stop:0 #333333, stop:1 #666666);
                         }

                         QProgressBar::chunk {
                              color: black;
                              border-radius: 0px;
                              background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                                       stop:0 #95c4f0, stop:1 #5d7a96);
                         }

                    """
            )
        self.progressBar.setRange(0, 0)
        vbox.addWidget(self.progressBar)

        hbox = QtGui.QHBoxLayout()
        hbox.addStretch(1)
        vbox.addLayout(hbox)

        self.cancelButton = QtGui.QPushButton("Cancel")
        self.cancelButton.clicked.connect(self.stop)
        self.cancelButton.setStyleSheet("""
                    QPushButton {
                        color: white;
                        background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #6B6B6B,stop: 0.3 #636363,stop: 1 #525252);
                        border-radius: 0px;
                        border: 1px solid 1E1E1E;
                    }

                    QPushButton:hover {
                        background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #878787,stop: 0.3 #787878,stop: 1 #5C5C5C);
                    }

                    QPushButton:pressed {
                        background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #3E3E3E,stop: 1 #353535);
                        padding-top: 1px;
                    }
                            """)
        hbox.addWidget(self.cancelButton)

        hbox.addStretch(1)

    def keyPressEvent(self, event):
        event.ignore()

    def stop(self):
        self.cancel.emit()

    def showBusy(self, show, mess=None, enableCancel=False):
        if show:
            self.progressBar.setRange(0, 0)
            self.captionLabel.setText(mess)
            if enableCancel:
                self.setFixedSize(250, 75)
                self.cancelButton.show()
            else:
                self.cancelButton.hide()
                self.setFixedSize(250, 60)
            self.exec_()
        else:
            self.progressBar.setRange(1, 1)
            self.hide()
            if self.useData.SETTINGS['SoundsEnabled'] == "True":
                self.app.beep()

########NEW FILE########
__FILENAME__ = CodeEditor
import os
import io
import sys
from zipimport import zipimporter
import tokenize
from io import StringIO

from PyQt4 import QtCore, QtGui
from PyQt4.Qsci import QsciScintilla

from Extensions.BaseScintilla import BaseScintilla
from Extensions.ZoomWidget import ZoomWidget
from Extensions.Notification import Notification
from Extensions import StyleSheet

from rope.contrib import codeassist


class TokenizeThread(QtCore.QThread):

    def run(self):
        self.tokenList = []
        try:
            for type, rep, begin, end, expr in \
                    tokenize.generate_tokens(StringIO(self.source).readline):
                if type == tokenize.OP:
                    line = begin[0]
                    if line not in self.tokenList:
                        self.tokenList.append(line - 1)
        except:
            pass

    def tokenize(self, source):
        self.source = source

        self.start()


class DocThread(QtCore.QThread):

    docAvailable = QtCore.pyqtSignal(str, int)

    def run(self):
        try:
            doc = codeassist.get_doc(self.ropeProject,
                                     self.source, self.hoverOffset)
            self.docAvailable.emit(doc, self.hoverOffset)
        except:
            pass

    def doc(self, ropeProject, source, hoverOffset):
        self.ropeProject = ropeProject
        self.source = source
        self.hoverOffset = hoverOffset

        self.start()


class AutoCompletionThread(QtCore.QThread):

    completionsAvailable = QtCore.pyqtSignal(list)

    def run(self):
        completions = self.completions()
        if completions is None:
            return
        self.completionsAvailable.emit(completions)

    def rope_completions(self):
        """
        Returns list of completions based on the current project contents
        """
        try:
            proposals = codeassist.code_assist(self.ropeProject,
                                               self.source, self.offset)
            proposals = codeassist.sorted_proposals(proposals)
            if len(proposals) > 0:
                completions = []
                for i in proposals:
                    completions.append(str(i))

                return completions
            else:
                return []
        except:
            pass

    def completions(self):
        self.completionType = 3
        wordList = self.lineText.split(' ')
        
        if len(wordList) == 1 and wordList[0] == 'from':
            return []

        if len(wordList) == 3 and wordList[0] == 'from':
            # from x i, or from x ''
            if wordList[2].startswith('i') or wordList[2] == '':
                return ['import ']
            else:
                return []

        if len(wordList) < 3 and (wordList[0] == 'from'):
            # from x 
            if len(wordList) == 1:
                # from 
                return self.dirModules()

            return self.pkg_completions(wordList[1])

        if len(wordList) >= 3 and wordList[0] == 'from':
            absolutePath = os.path.join(
                self.sourcedir, wordList[1].replace('.', '//'))
            absolutePath = os.path.normpath(absolutePath)
            
            if wordList[2] == 'import':
                if os.path.isdir(absolutePath):
                    return self.dirModules(absolutePath)
                else:
                    # from x import y
                    completionList = self.module_classes(absolutePath)
                    if '(' in wordList[-1]:
                        wordList = wordList[:-2] + wordList[-1].split('(')
                    if ',' in wordList[-1]:
                        wordList = wordList[:-2] + wordList[-1].split(',')
                    return list(set(filter(lambda x: x.startswith(wordList[-1]), completionList)))
                
        if wordList[0] == 'import':
            if len(wordList) == 2 and wordList[1] == '':
                return self.dirModules()

            if ',' == wordList[-1]:
                return [' ']

            return self.pkg_completions(wordList[-1])

        if self.column != 0:
            if len(self.lineText.strip()) >= 2:  # Autocompletion threshold
                completions = self.rope_completions()
                self.completionType = 2
                return completions

    def dirModules(self, path=None):
        """
        Return list of modules in a directory
        """
        if path is None:
            # return list of modules in the main project directory
            
            modules = []
            modules += self.dirModules(self.sourcedir)

            modules += sys.builtin_module_names

            modules = list(set(modules))
            if '__init__' in modules:
                modules.remove('__init__')
            modules = list(set(modules))

            return sorted(modules)
        else:
            if os.path.isdir(path):
                folderList = os.listdir(path)
            elif path.endswith('.egg'):
                try:
                    folderList = [f for f in zipimporter(path)._files]
                except:
                    folderList = []
            else:
                folderList = []
            moduleList = []
            for p in folderList:
                if os.path.exists(os.path.join(path, p, '__init__.py')) \
                    or p[-3:] in ('.py', '.so') \
                        or p[-4:] in ('.pyc', '.pyo', '.pyd'):
                    if os.path.isdir(os.path.join(path, p)):
                        moduleList.append(p + os.path.sep)
                    else:
                        moduleList.append(os.path.splitext(p)[0])

            return moduleList

    def module_classes(self, absolutePath):
        """
        Return list of classes in a module. 
        """
        completionList = []
        try:
            absolutePath = absolutePath + '.py'

            file = open(absolutePath, "r")
            f = io.StringIO(file.read())
            file.close()

            g = tokenize.generate_tokens(f.readline)
            for tokentype, token, start, _end, _line in g:
                if token == 'class':
                    tokentype, class_name, start = next(g)[0:3]
                    completionList.append(class_name)
        except:
            return []
        return completionList

    def pkg_completions(self, dottedPath):
        # return completions from packages
        pathElements = dottedPath.split('.')
        if len(pathElements) < 2:
            return sorted(list(set(filter(lambda x: x.startswith(pathElements[0]),
                         self.dirModules()))))

        relativePath = '.'.join(pathElements[:-1])
        absolutePath = os.path.join(
            self.sourcedir, relativePath.replace('.', '//'))
        absolutePath = os.path.normpath(absolutePath)
        
        try:
            completionList = []
            
            contents = os.listdir(absolutePath)
            for item in contents:
                path = os.path.join(absolutePath, item)
                if os.path.isfile(path):
                    completionList.append(os.path.splitext(item)[0])
                else:
                    if '__init__.py' in os.listdir(path):
                        completionList.append(item + os.path.sep)
            completionList.remove('__init__')
        except:
            pass

        completionList = list(set(filter(lambda x: x.startswith(pathElements[-1]),
                             completionList)))

        return sorted(completionList)

    def complete(self, sourcedir, ropeProject,
                offset, source, lineText, col):
        self.sourcedir = sourcedir
        self.ropeProject = ropeProject
        self.offset = offset
        self.source = source
        self.lineText = lineText
        self.column = col

        self.start()


class CodeEditor(BaseScintilla):

    def __init__(self, useData, refactor, colorScheme,
                 DATA, editorTabWidget, parent=None):
        BaseScintilla.__init__(self, parent)

        self.useData = useData
        self.refactor = refactor
        self.DATA = DATA
        self.colorScheme = colorScheme
        self.editorTabWidget = editorTabWidget

        self.setObjectName("editor")
        self.enableMarkOccurrence(useData)

        self.setMouseTracking(True)
        self.middleMousePressed = False
        self.mousePosition = QtCore.QPointF()

        self.autoCompletionThread = AutoCompletionThread()
        self.autoCompletionThread.completionsAvailable.connect(self.showCompletions)

        self.docThread = DocThread()
        self.docThread.docAvailable.connect(
            self.showDoc)

        self.docThreadTimer = QtCore.QTimer()
        self.docThreadTimer.setSingleShot(True)
        self.docThreadTimer.timeout.connect(self.getDoc)

        self.tokenizeThread = TokenizeThread()
        self.tokenizeThread.finished.connect(
            self.displayTokenLines)

        self.tokenizeTimer = QtCore.QTimer()
        self.tokenizeTimer.setSingleShot(True)
        self.tokenizeTimer.timeout.connect(self.getOperationTokens)

        self.completionThreadTimer = QtCore.QTimer()
        self.completionThreadTimer.setSingleShot(True)
        self.completionThreadTimer.timeout.connect(self.startCompletion)

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setMargin(0)
        self.setLayout(mainLayout)

        mainLayout.addStretch(1)

        #

        hbox = QtGui.QHBoxLayout()
        hbox.addStretch(1)
        hbox.setContentsMargins(0, 0, 20, 0)
        mainLayout.addLayout(hbox)

        self.zoomWidget = ZoomWidget(self.useData, self)
        hbox.addWidget(self.zoomWidget)

        #

        hbox = QtGui.QHBoxLayout()
        hbox.addStretch(1)
        hbox.setContentsMargins(5, 0, 10, 20)
        mainLayout.addLayout(hbox)

        self.notification = Notification()
        hbox.addWidget(self.notification)
        self.notification.hide()

        #

        self.createActions()

        self.setAutoCompletion()

        " Initialises indicators "
        self.syntaxErrorIndicator = self.indicatorDefine(
            QsciScintilla.INDIC_SQUIGGLE, 8)
        self.setIndicatorForegroundColor(QtGui.QColor(
            "#FF0000"), self.syntaxErrorIndicator)
        self.setIndicatorDrawUnder(True, self.syntaxErrorIndicator)

        self.searchIndicator = self.indicatorDefine(
            QsciScintilla.INDIC_ROUNDBOX, 10)
        self.setIndicatorForegroundColor(
            QtGui.QColor("#FFDB4A"), self.searchIndicator)
        self.setIndicatorDrawUnder(True, self.searchIndicator)

        self.userListActivated.connect(self.insertText)

        self.copyAvailableTimer = QtCore.QTimer()
        self.copyAvailableTimer.setSingleShot(True)
        self.copyAvailableTimer.setInterval(0)
        self.copyAvailableTimer.timeout.connect(self.copyActModifier)

        self.copyAvailable.connect(self.copyAvailableTimer.start)

        self.textChangedTimer = QtCore.QTimer()
        self.textChangedTimer.setSingleShot(True)
        self.textChangedTimer.setInterval(0)
        self.textChangedTimer.timeout.connect(self.undoActModifier)
        self.textChangedTimer.timeout.connect(self.redoActModifier)

        self.textChanged.connect(self.textChangedTimer.start)
        self.textChanged.connect(self.startTokenizeTimer)
        self.textChanged.connect(self.startCompletionTimer)

        self.linesChanged.connect(self.updateLineCount)
        self.marginClicked.connect(self.toggleBookmark)

        # define the font to use
        font = QtGui.QFont("Courier New")
        font.setFixedPitch(True)
        font.setPointSize(10)
        # the font metrics here will help
        # building the margin width later
        self.fontMetrics = QtGui.QFontMetrics(font)

        self.setUtf8(True)
        self.setAutoIndent(True)
        self.setIndentationsUseTabs(False)
        self.setBackspaceUnindents(True)
        self.setIndentationWidth(4)
        self.setTabWidth(4)
#        self.setAnnotationDisplay(QsciScintilla.AnnotationStandard)

        # Line numbers
        # conventionnaly, margin 0 is for line numbers
        self.setMarginWidth(0, self.fontMetrics.width("0000") + 5)

        self.setAutoCompletionReplaceWord(True)
        # minimum number of letters to be typed before list is displayed
        self.setAutoCompletionThreshold(2)

        if self.useData.SETTINGS["EnableFolding"] == "True":
            self.setFolding(QsciScintilla.BoxedTreeFoldStyle, 2)

        # Braces matching
        # TODO: Causes flicker when selecting text. I suspect it has
        # the layout and widgets placed on top of it
        if self.useData.SETTINGS["MatchBraces"] == "True":
            self.setBraceMatching(QsciScintilla.SloppyBraceMatch)

        if self.useData.SETTINGS["ShowEdgeLine"] == 'True':
            if self.useData.SETTINGS["EdgeMode"] == 'Line':
                self.setEdgeMode(QsciScintilla.EdgeLine)
            elif self.useData.SETTINGS["EdgeMode"] == 'Background':
                self.setEdgeMode(QsciScintilla.EdgeBackground)

        if self.useData.SETTINGS["ShowCaretLine"] == 'True':
            self.setCaretLineVisible(True)

        self.showWhiteSpaces()
        # set annotation display
        # the annotation font can be changed by changing the default lexer font
        self.setAnnotationDisplay(QsciScintilla.AnnotationBoxed)

        # Edge Mode shows a vetical bar at specific number of chars
        if self.useData.SETTINGS["ShowEdgeLine"] == 'True':
            if self.useData.SETTINGS['EdgeMode'] == "Line":
                self.setEdgeMode(QsciScintilla.EdgeLine)
            else:
                self.setEdgeMode(QsciScintilla.EdgeBackground)
        self.setEdgeColumn(int(self.useData.SETTINGS["EdgeColumn"]))

        # define markers
        # the background markers will not show until the editor has focus
        self.breakpointMarker = self.markerDefine(QsciScintilla.Background)
        self.setMarkerForegroundColor(QtGui.QColor("#000000"),
                                      self.breakpointMarker)
        self.setMarkerBackgroundColor(QtGui.QColor("#ffe1e1"),
                                      self.breakpointMarker)

        self.markerDefine(QtGui.QPixmap(
            os.path.join("Resources", "images", "ui-button-navigation")), 8)
        self.setMarkerBackgroundColor(QtGui.QColor("#ee1111"), 8)

        self.markerDefine(
            QtGui.QPixmap(os.path.join("Resources", "images", "err_mark")), 9)
        self.setMarkerBackgroundColor(QtGui.QColor("#ee1111"), 9)

        self.markerDefine(
            QtGui.QPixmap(os.path.join("Resources", "images", "brk_point")), 10)
        self.setMarkerBackgroundColor(QtGui.QColor("#ee1111"), 10)

        self.markerDefine(QsciScintilla.VerticalLine, 11)
        self.setMarkerBackgroundColor(QtGui.QColor("#EEEE11"), 11)
        self.setMarkerForegroundColor(QtGui.QColor("#EEEE11"), 11)
        self.setMarginWidth(3, self.fontMetrics.width("0"))

        mask = (1 << 8) | (1 << 9)
        self.setMarginMarkerMask(1, mask)
        self.setMarginSensitivity(1, True)
        mask = (1 << 11)
        self.setMarginMarkerMask(3, mask)

        self.showLineNumbers()
        self.setMarkOperationalLines()

        if self.useData.SETTINGS["ShowCaretLine"] == 'True':
            self.setCaretLineVisible(True)

        self.lexer = self.colorScheme.styleEditor(self)
        self.setStyleSheet(StyleSheet.editorStyle)

        self.setKeymap()
        
    def startTokenizeTimer(self):
        self.tokenizeTimer.start(1000)
        
    def startDocTimer(self):
        self.docThreadTimer.start(500)
        
    def startCompletionTimer(self):
        self.completionThreadTimer.start(500)

    def getOperationTokens(self):
        if self.useData.SETTINGS['MarkOperationalLines'] == 'True':
            self.tokenizeThread.tokenize(self.text())

    def displayTokenLines(self):
        self.markerDeleteAll(11)

        for line in self.tokenizeThread.tokenList:
            self.markerAdd(line, 11)

    def showDoc(self, doc, pos):
        if self.isListActive():
            return
        if doc is not None:
            QtGui.QToolTip.showText(self.lastHoverPos, doc, self)

    def getDoc(self):
        self.docThread.doc(
            self.refactor.getProject(), self.text(), self.hoverOffset)

    def mouseReleaseEvent(self, event):
        self.middleMousePressed = False
        super(CodeEditor, self).mouseReleaseEvent(event)

    def mousePressEvent(self, event):
        button = event.button()
        if button == QtCore.Qt.MidButton or button == QtCore.Qt.MiddleButton:
            self.middleMousePressed = True
        else:
            self.middleMousePressed = False

        super(CodeEditor, self).mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self.useData.SETTINGS["DocOnHover"] == "True":
            self.lastHoverPos = event.globalPos()
            self.hoverOffset = self.positionFromPoint(event.pos())

            QtGui.QToolTip.hideText()
            self.startDocTimer()

        # resize view if middle mouse button is held down
        if self.middleMousePressed:
            pos = event.pos()
            delta = pos - self.mousePosition

            x = delta.x()
            y = delta.y()
            if x > 0:
                x = 1
            elif x < 0:
                x = -1
            if y > 0:
                y = 1
            elif y < 0:
                y = -1

            self.editorTabWidget.resizeView(x, y)

        self.mousePosition = event.posF()
        super(CodeEditor, self).mouseMoveEvent(event)

    def createActions(self):
        self.cutAct = QtGui.QAction(
            "Cut", self,
            statusTip="Cut selected text", triggered=self.cut)

        self.copyAct = QtGui.QAction(
            "Copy", self,
            statusTip="Copy selected text", triggered=self.copy)

        self.pasteAct = QtGui.QAction(
            "Paste", self,
            statusTip="Paste text from clipboard",
            triggered=self.paste)

        self.selectToMatchingBraceAct = \
            QtGui.QAction(
                "Select to Matching Brace", self,
                statusTip="Select to Matching Brace",
                          triggered=self.selectToMatchingBrace)

        self.snippetsAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "edit2")),
                "Insert Snippet...", self,
                statusTip="Insert Snippet...",
                          triggered=self.showSnippets)

        self.toggleBookmarkAct = \
            QtGui.QAction(
                "Toggle Bookmark", self,
                statusTip="Toggle Bookmark",
                triggered=self._toggleBookmark)

        self.toggleBreakpointAct = \
            QtGui.QAction(
                "Toggle Line Breakpoint", self,
                statusTip="Toggle Line Breakpoint",
                triggered=self.toggleLineBreakpoint)

        self.takeSnapshotAct = \
            QtGui.QAction("Take Snapshot", self,
                          statusTip="Take Snapshot",
                          triggered=self.takeSnapshot)

        self.zoomAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "zoom")),
            "Zoom", self,
            statusTip="Zoom", triggered=self.showZoomWidget)

        self.indentationGuideAct = \
            QtGui.QAction(
                "Indentation Guide", self,
                statusTip="Indentation Guide",
                          triggered=self.showIndentationGuide)
        self.indentationGuideAct.setCheckable(True)

        self.contextMenu = QtGui.QMenu()
        self.contextMenu.addAction(self.snippetsAct)
        self.contextMenu.addSeparator()
        self.contextMenu.addAction(self.cutAct)
        self.contextMenu.addAction(self.copyAct)
        self.contextMenu.addAction(self.pasteAct)
        self.contextMenu.addAction(self.selectToMatchingBraceAct)
        self.contextMenu.addAction(self.toggleBookmarkAct)
#        self.contextMenu.addAction(self.toggleBreakpointAct)

        self.contextMenu.addSeparator()
        self.contextMenu.addAction(self.refactor.findDefAct)
        self.contextMenu.addAction(self.refactor.findOccurrencesAct)

        self.contextMenu.addMenu(self.refactor.refactorMenu)

        self.viewMenu = self.contextMenu.addMenu("View")
        self.viewMenu.addAction(self.editorTabWidget.vSplitEditorAct)
        self.viewMenu.addAction(self.editorTabWidget.hSplitEditorAct)
        self.viewMenu.addAction(self.editorTabWidget.noSplitEditorAct)
        self.viewMenu.addSeparator()
        self.viewMenu.addAction(self.indentationGuideAct)
        self.viewMenu.addSeparator()
        self.viewMenu.addAction(self.zoomAct)
        self.contextMenu.addSeparator()
        self.contextMenu.addAction(self.takeSnapshotAct)

    def contextMenuEvent(self, event):
        filePath = self.DATA['filePath']
        isProjectFile = self.editorTabWidget.isProjectFile(filePath)
        self.refactor.refactorMenu.setEnabled(isProjectFile)
        self.refactor.findOccurrencesAct.setEnabled(isProjectFile)

        hasSelection = self.hasSelectedText()
        self.copyAct.setEnabled(hasSelection)
        self.cutAct.setEnabled(hasSelection)

        self.contextMenu.exec_(event.globalPos())

    def undoActModifier(self):
        state = self.isUndoAvailable()
        self.editorTabWidget.undoAct.setEnabled(state)

    def redoActModifier(self):
        state = self.isRedoAvailable()
        self.editorTabWidget.redoAct.setEnabled(state)

    def copyActModifier(self):
        state = self.hasSelectedText()
        self.editorTabWidget.copyAct.setEnabled(state)
        self.editorTabWidget.cutAct.setEnabled(state)

    def updateLineCount(self):
        lines = self.lines()
        self.editorTabWidget.updateLinesCount.emit(lines)

    def startCompletion(self):
        if self.useData.SETTINGS["EnableAutoCompletion"] == "True":
            if self.useData.SETTINGS["AutoCompletion"] == "Api":
                lineno, col = self.getCursorPosition()
                self.completionCallPos = self.getCursorPosition()
                lineText = self.text(lineno)[:col]

                ropeProject = self.refactor.getProject()
                offset = self.getOffset()

                self.autoCompletionThread.complete(
                    self.refactor.root,
                        ropeProject, offset, self.text(), lineText, col)

    def showCompletions(self, result):
        if len(result) > 0:
            if self.hasFocus():
                self.showUserList(
                    self.autoCompletionThread.completionType, result)
        else:
            self.cancelList()

    def insertText(self, id, text):
        word = self.get_current_word()
        if not word:
            pass
        else:
            self.deleteWordToLeft()
        self.removeSelectedText()
        if id == 1:
            file = open(os.path.join(self.useData.appPathDict[
                        "snippetsdir"], text), 'r')
            cmpl = file.readlines()
            file.close()
            line, col = self.getCursorPosition()
            if self.text(line).strip() == '':
                padding = ' ' * col
                paddedText = ''
                for i in range(len(cmpl)):
                    textLine = padding + cmpl[i]
                    paddedText += textLine
                self.setCursorPosition(line, 0)
                self.insert(paddedText)
            else:
                self.insert(cmpl[0])
        elif id == 2:
            # TODO: Insert must check for brackets after inserting functions.
            x = text.split()
            cmpl = x[0]
            type = x[2].strip(")")
            self.insert(cmpl)
        elif id == 3:
            cmpl = text.rstrip(os.path.sep)
            self.insert(cmpl)
        self.moveCursorWordRight()

    def takeSnapshot(self):
        reply = QtGui.QMessageBox.warning(self, "Snapshot",
                                          "Take a snapshot of the current module state?",
                                          QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            subStack = self.editorTabWidget.currentWidget()
            subStack.widget(1).setText(self.text())
        else:
            return

    def toggleLineBreakpoint(self):
        line, index = self.getCursorPosition()
        if self.markersAtLine(line) != 0:
            self.markerDelete(line, self.breakpointMarker)
        else:
            self.markerAdd(line, self.breakpointMarker)
        self.ensureLineVisible(line - 1)

    def updateLexer(self, lexer):
        self.lexer = lexer
        self.setLexer(lexer)

    def _toggleBookmark(self):
        nmargin = 0
        nline = self.getCursorPosition()[0]

        self.toggleBookmark(nmargin, nline)

    def toggleBookmark(self, nmargin, nline, modifiers=None):
        for handle in self.DATA["bookmarkList"]:
            if self.markerLine(handle) == nline:
                self.DATA["bookmarkList"].remove(handle)
                self.markerDeleteHandle(handle)

                markersExist = self.bookmarksExist()
                self.editorTabWidget.enableBookmarkButtons(markersExist)
                return
        handle = self.markerAdd(nline, 8)
        self.DATA["bookmarkList"].append(handle)

        markersExist = self.bookmarksExist()
        self.editorTabWidget.enableBookmarkButtons(markersExist)

    def bookmarksExist(self):
        markersExist = (len(self.DATA["bookmarkList"]) > 0)
        return markersExist

    def getBookmarks(self):
        bookmarkLines = []
        for handle in self.DATA["bookmarkList"]:
            line = self.markerLine(handle)
            bookmarkLines.append(line)

        return bookmarkLines

    def showSnippets(self):
        try:
            snippetList = os.listdir(
                self.useData.appPathDict["snippetsdir"])
        except:
            self.notification.showMessage("Could not fetch snippets.")
            return
        if len(snippetList) > 0:
            self.showUserList(1, snippetList)
        else:
            self.notification.showMessage("No snippets available.")

    def clearErrorMarkerAndIndicator(self):
        self.clearAllIndicators(self.syntaxErrorIndicator)
        self.clearAnnotations()
        self.markerDeleteAll(9)

    def setAutoCompletion(self):
        if self.useData.SETTINGS["EnableAutoCompletion"] == "False":
            self.setAutoCompletionSource(QsciScintilla.AcsNone)
            return
        if self.useData.SETTINGS["AutoCompletion"] == "Api":
            self.setAutoCompletionSource(QsciScintilla.AcsNone)
        elif self.useData.SETTINGS["AutoCompletion"] == "Document":
            self.setAutoCompletionSource(QsciScintilla.AcsDocument)

    def setMarkOperationalLines(self):
        if self.useData.SETTINGS["MarkOperationalLines"] == 'True':
            self.setMarginWidth(3, self.fontMetrics.width("0"))
            self.getOperationTokens()
        else:
            self.markerDeleteAll(11)
            self.setMarginWidth(3, 0)

    def getOffset(self):
        offset = self.currentPosition()
        return offset

    def showLine(self, lineNum, highlight=True):
        if highlight:
            self.setSelection(
                lineNum, 0, lineNum, self.lineLength(lineNum) - 1)
        self.ensureLineVisible(lineNum)

    def showIndentationGuide(self):
        if self.indentationGuides():
            self.setIndentationGuides(False)
        else:
            self.setIndentationGuides(True)

    def showZoomWidget(self):
        self.zoomWidget.show()

    def showWhiteSpaces(self):
        if self.useData.SETTINGS["ShowWhiteSpaces"] == 'True':
            self.setWhitespaceVisibility(QsciScintilla.WsVisible)
        else:
            self.setWhitespaceVisibility(QsciScintilla.WsInvisible)

    def findNextBookmark(self):
        cursorLine = self.getCursorPosition()[0]
        lineNum = self.markerFindNext(cursorLine + 1, 256)
        if lineNum == -1:
            lineNum = self.markerFindNext(0, 256)
            if lineNum == -1:
                return
        self.showLine(lineNum)

    def findPreviousBookmark(self):
        cursorLine = self.getCursorPosition()[0]
        lineNum = self.markerFindPrevious(cursorLine - 1, 256)
        if lineNum == -1:
            lineNum = self.markerFindPrevious(self.lines(), 256)
            if lineNum == -1:
                return
        self.showLine(lineNum)

    def removeBookmarks(self):
        if len(self.DATA["bookmarkList"]) > 0:
            self.DATA["bookmarkList"] = []
            self.markerDeleteAll(8)

    def addCommentPrefix(self, line):
        if self.text(line).strip().startswith('#'):
            pass
        else:
            self.insertAt('#', line, 0)

    def removeCommentPrefix(self, line):
        if self.text(line).strip().startswith('#'):
            lineText = self.text(line)
            commentIndex = lineText.find('#')
            self.setSelection(line, commentIndex, line, commentIndex + 1)
            self.replaceSelectedText('')
        else:
            pass

    def comment(self):
        if self.hasSelectedText():
            lineFrom, indexFrom, lineTo, indexTo = self.getSelection()
            if lineFrom == lineTo:
                self.addCommentPrefix(lineFrom)
            else:
                self.beginUndoAction()
                for i in range(lineFrom, lineTo + 1):
                    self.addCommentPrefix(i)
                self.endUndoAction()
            self.setSelection(lineFrom, indexFrom, lineTo, indexTo)
        else:
            line, index = self.getCursorPosition()
            self.addCommentPrefix(line)

    def unComment(self):
        if self.hasSelectedText():
            lineFrom, indexFrom, lineTo, indexTo = self.getSelection()
            if lineFrom == lineTo:
                self.removeCommentPrefix(lineFrom)
            else:
                self.beginUndoAction()
                for i in range(lineFrom, lineTo + 1):
                    self.removeCommentPrefix(i)
                self.endUndoAction()
            self.setSelection(lineFrom, indexFrom, lineTo, indexTo)
        else:
            line, index = self.getCursorPosition()
            self.removeCommentPrefix(line)

    def replaceTabsWithSpaces(self):
        text = self.text()
        text = text.replace('\t', ' ' * 4)
        self.selectAll()
        self.replaceSelectedText(text)

    def removeTrailingWhitespaces(self):
        self.beginUndoAction()
        for i in range(self.lines()):
            text = self.text(i)
            white_len = len(text) - len(text.rstrip())
            if white_len > 1:
                self.setSelection(i, self.lineLength(i) - white_len, i,
                                  self.lineLength(i) - 1)
                self.removeSelectedText()
        self.endUndoAction()

    def setKeymap(self):
        self.updateKeymap(self.useData)

        shortcuts = self.useData.CUSTOM_SHORTCUTS

        self.cutAct.setShortcut(shortcuts["Editor"]["Cut-Selection"][0])
        self.copyAct.setShortcut(shortcuts["Editor"]["Copy-Selection"][0])
        self.pasteAct.setShortcut(shortcuts["Editor"]["Paste"][0])

        self.shortSnippets = QtGui.QShortcut(
            shortcuts["Ide"]["Snippets"], self)
        self.shortSnippets.activated.connect(self.showSnippets)

        self.shortIndentationGuide = QtGui.QShortcut(
            shortcuts["Ide"]["Toggle-Indentation-Guide"], self)
        self.shortIndentationGuide.activated.connect(self.showIndentationGuide)

        self.shortShowCompletion = QtGui.QShortcut(
            shortcuts["Ide"]["Show-Completion"], self)
        self.shortShowCompletion.activated.connect(self.startCompletion)

        self.shortToggleBreakpoint = QtGui.QShortcut(
            shortcuts["Ide"]["Toggle-Breakpoint"], self)
        self.shortToggleBreakpoint.activated.connect(self.toggleLineBreakpoint)

        self.shortNextBookmark = QtGui.QShortcut(
            shortcuts["Ide"]["Next-Bookmark"], self)
        self.shortNextBookmark.activated.connect(self.findNextBookmark)

        self.shortPreviousBookmark = QtGui.QShortcut(
            shortcuts["Ide"]["Previous-Bookmark"], self)
        self.shortPreviousBookmark.activated.connect(self.findPreviousBookmark)

        self.shortComment = QtGui.QShortcut(
            shortcuts["Ide"]["Comment"], self)
        self.shortComment.activated.connect(self.comment)

        self.shortUncomment = QtGui.QShortcut(
            shortcuts["Ide"]["Uncomment"], self)
        self.shortUncomment.activated.connect(self.unComment)

        self.shortZoomIn = QtGui.QShortcut(
            shortcuts["Editor"]["Zoom-In"][0], self)
        self.shortZoomIn.activated.connect(self.zoomWidget.zoomIn)

        self.shortZoomOut = QtGui.QShortcut(
            shortcuts["Editor"]["Zoom-Out"][0], self)
        self.shortZoomOut.activated.connect(self.zoomWidget.zoomOut)

########NEW FILE########
__FILENAME__ = CodeSnapshot
import os

from PyQt4 import QtGui

from Extensions.BaseScintilla import BaseScintilla
from Extensions import StyleSheet


class CodeSnapshot(BaseScintilla):

    def __init__(self, useData, colorScheme, parent=None):
        BaseScintilla.__init__(self, parent)

        self.colorScheme = colorScheme
        self.DATA = {"fileType": "python"}

        self.setObjectName("editor")
        self.enableMarkOccurrence(useData)

        self.createContextMenu()

        self.colorScheme.styleEditor(self)
        self.setMarginLineNumbers(0, True)

    def updateLexer(self, lexer):
        self.setLexer(lexer)

    def contextMenuEvent(self, event):
        state = self.hasSelectedText()
        self.copyAct.setEnabled(state)

        self.contextMenu.exec_(event.globalPos())

    def createContextMenu(self):
        self.copyAct = QtGui.QAction(
            "Copy", self,
            statusTip="Copy selected text", triggered=self.copy)

        self.selectAllAct = QtGui.QAction("Select All", self,
                                          statusTip="Select All",
                                          triggered=self.selectAllText)

        self.selectToMatchingBraceAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "compose")),
                "Select to Matching Brace", self,
                statusTip="Select to Matching Brace",
                          triggered=self.selectToMatchingBrace)

        self.contextMenu = QtGui.QMenu()
        self.contextMenu.addSeparator()
        self.contextMenu.addAction(self.copyAct)
        self.contextMenu.addAction(self.selectAllAct)
        self.contextMenu.addAction(self.selectToMatchingBraceAct)

    def selectAllText(self):
        self.selectAll()

########NEW FILE########
__FILENAME__ = Diff
import sys
import difflib

from PyQt4 import QtCore, QtGui
from PyQt4.Qsci import QsciScintillaBase, QsciLexerCustom

from Extensions.BaseScintilla import BaseScintilla
from Extensions import Global


class FormatLexer(QsciLexerCustom):

    def __init__(self, parent=None):
        QsciLexerCustom.__init__(self, parent)

        self._styles = {
            0: 'Default',
            1: 'NewText',
            2: 'DeletedText',
            3: 'ReplacedText',
            4: 'LineNumber'
            }
        for key in self._styles:
            setattr(self, self._styles[key], key)

    def description(self, style):
        return self._styles.get(style, '')

    def defaultColor(self, style):
        return QtGui.QColor('#000000')

    def defaultPaper(self, style):
        if style == self.Default:
            return QtGui.QColor('#ffffff')
        elif style == self.NewText:
            return QtGui.QColor('#DDFFDD')
        elif style == self.DeletedText:
            return QtGui.QColor('#FFDDDD')
        elif style == self.ReplacedText:
            return QtGui.QColor('#BED6ED')
        elif style == self.LineNumber:
            return QtGui.QColor('#EAF2F5')
        return QtGui.QColor('#ffffff')

    def defaultFont(self, style):
        if style == self.Default:
            return Global.getDefaultFont()
        elif style == self.NewText:
            return Global.getDefaultFont()
        elif style == self.DeletedText:
            return Global.getDefaultFont()
        elif style == self.ReplacedText:
            return Global.getDefaultFont()
        elif style == self.LineNumber:
            return Global.getDefaultFont()
        return QsciLexerCustom.defaultFont(self, style)

    def defaultEolFill(self, style):
        return True

    def styleText(self, start, end):
        editor = self.editor()
        if editor is None:
            return

        # scintilla works with encoded bytes, not decoded characters.
        # this matters if the source contains non-ascii characters and
        # a multi-byte encoding is used (e.g. utf-8)
        source = ''
        if end > editor.length():
            end = editor.length()
        if end > start:
            if sys.hexversion >= 0x02060000:
                # faster when styling big files, but needs python 2.6
                source = bytearray(end - start)
                editor.SendScintilla(
                    editor.SCI_GETTEXTRANGE, start, end, source)
            else:
                source = editor.text().encode('utf-8')
        if not source:
            return

        self.startStyling(start, 0x1f)


class DiffWindow(BaseScintilla):

    def __init__(self, editor=None, snapShot=None, parent=None):
        QtGui.QTextEdit.__init__(self, parent)

        self.setReadOnly(True)
        self.setMarginWidth(1, 0)
        self.lexer = FormatLexer(self)
        self.setLexer(self.lexer)
        self.setObjectName("editor")

        self.editor = editor
        self.snapShot = snapShot

        self.setStyleSheet("QsciScintilla {border: none;}")

    def generateUnifiedDiff(self, a=None, b=None):
        self.clear()

        if a is None:
            a = self.snapShot.text().splitlines()
        if b is None:
            b = self.editor.text().splitlines()

        QtGui.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        lines = 0
        for line in difflib.unified_diff(a, b, "Deleted", "Added"):
            if line.startswith('+') or line.startswith('>'):
                styleType = 1
            elif line.startswith('-') or line.startswith('<'):
                styleType = 2
            elif line.startswith('@@'):
                styleType = 4
            else:
                styleType = 0
            self.appendText(line, styleType)
            lines += 1

        if lines == 0:
            self.appendText('Nothing has changed.', 0)

        QtGui.QApplication.restoreOverrideCursor()

        return (lines != 0)

    def generateContextDiff(self):
        self.clear()

        a = self.snapShot.text().splitlines()
        b = self.editor.text().splitlines()

        QtGui.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        lines = 0
        for line in difflib.context_diff(a, b, "Original", "Current"):
            if line.startswith('+'):
                styleType = 1
            elif line.startswith('-'):
                styleType = 2
            elif line.startswith('!'):
                styleType = 3
            elif line.startswith('*** '):
                styleType = 4
            else:
                styleType = 0
            self.appendText(line, styleType)
            lines += 1

        if lines == 0:
            self.appendText('Nothing has changed.', 0)

        QtGui.QApplication.restoreOverrideCursor()

    def appendText(self, text, styleType):
        start = self.length()
        self.SendScintilla(QsciScintillaBase.SCI_STARTSTYLING, start)
        self.append(text + "\n")
        self.recolor(start, -1)
        self.SendScintilla(QsciScintillaBase.SCI_SETSTYLING, len(text),
                           styleType)

########NEW FILE########
__FILENAME__ = EditorSplitter
from PyQt4 import QtGui


class EditorSplitter(QtGui.QSplitter):

    def __init__(self, editor, editor2, DATA, editorTabWidget, parent):
        QtGui.QSplitter.__init__(self, parent)

        self.editorTabWidget = editorTabWidget
        self.DATA = DATA
        self.parent = parent

        self.editor = editor
        self.editor2 = editor2

        self.addWidget(self.editor)
        self.addWidget(self.editor2)
        editor2.hide()

        self.setCollapsible(0, False)
        self.setCollapsible(1, False)

        self.editor.modificationChanged.connect(self.textModified)
        self.editor2.modificationChanged.connect(self.textModified)

    def getEditor(self, index=None):
        if index is None:
            index = 0
        return self.widget(index)

    def getFocusedEditor(self):
        f = self.focusWidget()
        if f is None:
            return self.getEditor()
        return f

    def textModified(self, modified):
        index = self.editorTabWidget.indexOf(self.parent)
        self.editorTabWidget.updateTabName(index)

########NEW FILE########
__FILENAME__ = EditorTabWidget
import os
import sys
import ctypes
import time
import traceback
import logging

from PyQt4 import QtCore, QtGui, QtXml
from PyQt4.Qsci import QsciScintilla

from Extensions.Diff import DiffWindow
from Extensions.CodeEditor import CodeEditor
from Extensions.TextEditor import TextEditor
from Extensions.ViewSwitcher import ViewSwitcher
from Extensions.TextSnapshot import TextSnapshot
from Extensions.CodeSnapshot import CodeSnapshot
from Extensions.GotoLineWidget import GotoLineWidget
from Extensions.EditorSplitter import EditorSplitter
from Extensions import Global
from Extensions.Refactor.Refactor import Refactor
from Extensions.BottomWidgets.RunWidget import SetRunParameters
from Extensions.Projects.ProjectManager.ConfigureProject import ConfigureProject
from Extensions import StyleSheet


class EditorTabBar(QtGui.QTabBar):

    def __init__(self, app, renameFileAct,
                 moduleToPackageAct, parent):
        QtGui.QTabBar.__init__(self, parent)

        self.setExpanding(True)
        self.setDrawBase(False)

        self.editorTabWidget = parent
        self.app = app
        self.renameFileAct = renameFileAct
        self.moduleToPackageAct = moduleToPackageAct

        self.createActions()

    def setKeymap(self):
        shortcuts = self.editorTabWidget.useData.CUSTOM_SHORTCUTS

        self.shortSplitFileReload = QtGui.QShortcut(
            shortcuts["Ide"]["Reload-File"], self)
        self.shortSplitFileReload.activated.connect(
            self.reload)
        self.reloadTabAct.setShortcut(shortcuts["Ide"]["Reload-File"])

    def contextMenuEvent(self, event):
        filePath = self.editorTabWidget.getEditorData('filePath')
        isProjectFile = self.editorTabWidget.isProjectFile(filePath)

        isPyFile = (self.editorTabWidget.getEditorData("fileType") == "python")
        self.cloneTabAct.setEnabled(isPyFile)
        if isProjectFile:
            self.moduleToPackageAct.setEnabled(isPyFile)
            self.renameFileAct.setEnabled(isPyFile)
        else:
            self.moduleToPackageAct.setEnabled(False)
            self.renameFileAct.setEnabled(False)

        state = (filePath is not None)
        self.copyPathAct.setEnabled(state)
        self.openFileLocationAct.setEnabled(state)
        self.favouritesAct.setEnabled(state)
        self.reloadTabAct.setEnabled(state)

        self.menu.exec_(event.globalPos())

    def createActions(self):
        self.closeTabAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "cross_")),
            "Close", self, statusTip="Close Tab", triggered=self.closeTab)

        self.copyPathAct = QtGui.QAction("Copy File Path", self,
                                         statusTip="Copy File Path", triggered=self.copyPath)

        self.openFileLocationAct = \
            QtGui.QAction(
                "Open File Location", self, statusTip="Open File Location",
                triggered=self.openFileLocation)

        self.cloneTabAct = \
            QtGui.QAction(
                "Clone", self, statusTip="Create a copy of current tab",
                triggered=self.cloneTab)

        self.reloadTabAct = \
            QtGui.QAction(
                "Reload", self, statusTip="Reload",
                triggered=self.reload)

        self.favouritesAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "plus")),
                "Add to Favourites", self,
                statusTip="Add to Favourites",
                          triggered=self.editorTabWidget.addToFavourites)

        self.menu = QtGui.QMenu(self)
        self.menu.addAction(self.closeTabAct)
        self.menu.addSeparator()
        self.menu.addAction(self.cloneTabAct)
        self.menu.addAction(self.editorTabWidget.writeLockAct)
        self.moduleToPackageAct = self.moduleToPackageAct
        self.menu.addAction(self.moduleToPackageAct)
        self.renameFileAct = self.renameFileAct
        self.menu.addAction(self.reloadTabAct)
        self.menu.addAction(self.renameFileAct)
        self.menu.addSeparator()
        self.menu.addAction(self.copyPathAct)
        self.menu.addAction(self.openFileLocationAct)
        self.menu.addSeparator()
        self.menu.addAction(self.favouritesAct)

    def reload(self):
        reply = QtGui.QMessageBox.warning(self, "Reload",
                                          "Do you really want to reload?",
                                          QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            self.editorTabWidget.reloadModules()
        else:
            return

    def closeTab(self):
        index = self.currentIndex()
        self.editorTabWidget.closeEditorTab(index)

    def copyPath(self):
        filePath = self.editorTabWidget.getEditorData('filePath')
        cb = self.app.clipboard()
        cb.setText(filePath)

    def openFileLocation(self):
        filePath = self.editorTabWidget.getEditorData('filePath')
        ctypes.windll.shell32.ShellExecuteW(None, 'open', 'explorer.exe',
                                            '/n,/select, ' + filePath, None, 1)

    def cloneTab(self):
        index = self.currentIndex()
        name = self.tabText(index)
        new_index = index + 1
        subStack = self.editorTabWidget.newEditor(new_index, name)
        self.editorTabWidget.setCurrentIndex(new_index)
        self.editorTabWidget.updateTabName(new_index)
        editor = subStack.widget(0).widget(0)
        editor.setText(self.editorTabWidget.getEditor(index).text())


class EditorTabWidget(QtGui.QTabWidget):

    currentEditorTextChanged = QtCore.pyqtSignal()
    bookmarksChanged = QtCore.pyqtSignal()
    updateLinesCount = QtCore.pyqtSignal(int)
    updateRecentFilesList = QtCore.pyqtSignal(str)
    updateWindowTitle = QtCore.pyqtSignal(str)
    updateEncodingLabel = QtCore.pyqtSignal(str)
    cursorPositionChanged = QtCore.pyqtSignal()

    def __init__(
        self, useData, projectPathDict, projectSettings, messagesWidget, colorScheme, busyWidget, bookmarkToolbar,
            app, manageFavourites, externalLauncher, editorWindow, parent=None):
        QtGui.QTabWidget.__init__(self, parent)

        self.setElideMode(1)

        self.useData = useData
        self.projectPathDict = projectPathDict
        self.colorScheme = colorScheme
        self.messagesWidget = messagesWidget
        self.app = app
        self.busyWidget = busyWidget
        self.projectSettings = projectSettings
        self.bookmarkToolbar = bookmarkToolbar
        self.editorWindow = editorWindow

        self.toolWidgetList = []
        # backup keys are generated from the system time, but sometimes
        # tabs are loaded so fast they end up having same backup keys.
        # this variable is an int that will will be incremented for every
        # backup kry that is generated and will be used to prevent key
        # collision
        self.backupKeyDiferentiator = 0

        self.backupTimer = QtCore.QTimer()
        self.backupTimer.setSingleShot(False)
        self.backupTimer.setInterval(60000)
        self.backupTimer.timeout.connect(self.createBackup)

        self.configDialog = ConfigureProject(
            projectPathDict, projectSettings, useData, self)

        self.manageFavourites = manageFavourites
        self.manageFavourites.showMe.connect(self.showFavouritesManager)

        self.externalLauncher = externalLauncher
        self.externalLauncher.showMe.connect(self.showExternalLauncher)

        self.setRunParameters = SetRunParameters(
            self.projectSettings, self.projectPathDict, self.useData)

        self.refactor = Refactor(
            self, self.busyWidget, self)

        self.viewSwitcher = ViewSwitcher(self)
        self.gotoLineWidget = GotoLineWidget(self)

        self.mainLayout = QtGui.QVBoxLayout()
        self.setLayout(self.mainLayout)
        if self.useData.SETTINGS["UI"] == "Custom":
            self.adjustToStyleSheet(True)
        else:
            self.adjustToStyleSheet(False)

        self.topVBox = QtGui.QVBoxLayout()
        self.mainLayout.addLayout(self.topVBox)

        self.mainLayout.addStretch(1)

        self.addToolWidget(self.configDialog)
        self.addToolWidget(self.externalLauncher)
        self.addToolWidget(self.manageFavourites)
        self.addToolWidget(self.setRunParameters)
        self.addToolWidget(self.viewSwitcher)
        self.addToolWidget(self.gotoLineWidget)

        self.filesWatch = QtCore.QFileSystemWatcher()
        self.filesWatch.fileChanged.connect(self.fileChanged)

        self.createActions()

        self.tabBar = EditorTabBar(self.app,
                                   self.refactor.renameModuleAct,
                                   self.refactor.moduleToPackageAct, self)
        self.tabBar.setMovable(True)
        self.tabBar.setTabsClosable(True)

        self.openedTabsMenu = QtGui.QMenu()

        self.tabSelectButton = QtGui.QToolButton()
        self.tabSelectButton.setAutoRaise(True)
        self.tabSelectButton.setPopupMode(2)
        self.tabSelectButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "tile")))
        self.tabSelectButton.setMenu(self.openedTabsMenu)

        self.setTabBar(self.tabBar)
        self.setAcceptDrops(True)
        self.setUsesScrollButtons(True)
        self.setCornerWidget(self.tabSelectButton)
        self.currentChanged.connect(self.editorTabChanged)
        self.tabCloseRequested.connect(self.closeEditorTab)

        self.setKeymap()
        self.backupTimer.start()

        self.newFileMenu = QtGui.QMenu("New File")
        self.newFileMenu.addAction(self.newPythonFileAct)
        self.newFileMenu.addAction(self.newXmlFileAct)
        self.newFileMenu.addAction(self.newHtmlFileAct)
        self.newFileMenu.addAction(self.newCssFileAct)

    def resizeView(self, hview, vview):
        self.editorWindow.resizeView(hview, vview)

    def adjustToStyleSheet(self, adjust):
        if adjust:
            self.mainLayout.setContentsMargins(0, 22, 14, 12)
        else:
            self.mainLayout.setContentsMargins(0, 24, 25, 12)

    def addToolWidget(self, widget):
        hbox = QtGui.QHBoxLayout()
        hbox.addStretch(1)
        hbox.addWidget(widget)
        self.topVBox.addLayout(hbox)

        self.toolWidgetList.append(widget)
        widget.hide()

    def createActions(self):
        self.undoAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "undo")),
            "Undo", self,
            statusTip="Undo last edit action",
            triggered=self.undoAction)

        self.redoAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "redo")),
            "Redo", self,
            statusTip="Redo last edit action",
            triggered=self.redoAction)

        self.cutAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "cut")),
            "Cut", self,
            statusTip="Cut selected text", triggered=self.cutItem)

        self.copyAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "copy")),
            "Copy", self,
            statusTip="Copy selected text", triggered=self.copyItem)

        self.pasteAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "paste")),
            "Paste", self,
            statusTip="Paste text from clipboard",
            triggered=self.pasteFromClipboard)

        #----------------------------------------------------------------------

        self.indentAct = \
            QtGui.QAction(
                QtGui.QIcon(
                    os.path.join("Resources", "images", "increase_indent")),
                "Indent", self,
                statusTip="Indent Region",
                triggered=self.increaseIndent)

        self.dedentAct = \
            QtGui.QAction(
                QtGui.QIcon(
                    os.path.join("Resources", "images", "decrease_indent")),
                "Unindent", self,
                statusTip="Unindent Region",
                triggered=self.decreaseIndent)

        self.writeLockAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "block")),
                "Write Lock", self,
                statusTip="Write Lock",
                          triggered=self.writeLock)

        self.findNextBookmarkAct = \
            QtGui.QAction(
                QtGui.QIcon(
                    os.path.join("Resources", "images", "Arrow2-down")),
                "Next Bookmark", self, statusTip="Next Bookmark",
                triggered=self.findNextBookmark)

        self.findPrevBookmarkAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "Arrow2-up")),
                "Previous Bookmark", self, statusTip="Previous Bookmark",
                triggered=self.findPreviousBookmark)

        self.removeBookmarksAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "block__")),
                "Remove Bookmarks", self, statusTip="Remove Bookmarks",
                triggered=self.removeBookmarks)
        #---------------------------------------------------------------------
        self.newPythonFileAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "new")),
            "New Python File", self,
            statusTip="Create a new python file",
            triggered=self._newPythonFile)

        self.newXmlFileAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "new")),
            "Xml", self,
            statusTip="Create a new Xml file",
            triggered=self._newXmlFile)

        self.newHtmlFileAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "new")),
            "Html", self,
            statusTip="Create a new Html file",
            triggered=self._newHtmlFile)

        self.newCssFileAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "new")),
            "Css", self,
            statusTip="Create a new Css file",
            triggered=self._newCssFile)

        self.openFileAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "open_file")),
                "Open File...", self,
                statusTip="Open python file",
                          triggered=self.openFile)

        self.saveAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "save_")),
            "Save", self,
            statusTip="Save", triggered=self._save)

        self.saveAllAct = \
            QtGui.QAction(
                QtGui.QIcon(
                    os.path.join("Resources", "images", "disks-black")),
                "Save All", self,
                statusTip="Save All",
                          triggered=self.saveAll)

        self.saveAsAct = QtGui.QAction("Save As...", self, statusTip="Save",
                                       triggered=self.saveAs)

        self.saveCopyAsAct = QtGui.QAction("Save Copy As...",
                                           self, statusTip="Save Copy As",
                                           triggered=self.saveCopyAs)

        self.printAct = \
            QtGui.QAction(
                QtGui.QIcon(
                    os.path.join("Resources", "images", "_0013_Printer")),
                "Print", self,
                statusTip="Print", triggered=self.printCode)
        #----------------------------------------------------------------------

        self.vSplitEditorAct = \
            QtGui.QAction(
                QtGui.QIcon(
                    os.path.join("Resources", "images", "border-horizontal")),
                "Split Vertical", self,
                statusTip="Split Vertical", triggered=self.splitVertical)

        self.hSplitEditorAct = \
            QtGui.QAction(
                QtGui.QIcon(
                    os.path.join("Resources", "images", "border-vertical")),
                "Split Horizontal", self,
                statusTip="Split Horizontal", triggered=self.splitHorizontal)

        self.noSplitEditorAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "border")),
                "Remove Split", self,
                statusTip="Remove Split", triggered=self.removeSplit)

    def addToFavourites(self):
        path = self.getEditorData("filePath")
        self.manageFavourites.addToFavourites(path)

    def fileChanged(self, file):
        if os.path.exists(file):
            pass
        else:
            for i in range(self.count()):
                path = self.getEditorData("filePath", i)
                if path == file:
                    self.updateEditorData("filePath", None, i)
                    self.showNotification(
                        "File renamed or moved.", i)
                    break

    def focusedEditor(self, index=None):
        if index is None:
            index = self.currentIndex()
        subStack = self.widget(index)
        return subStack.widget(0).getFocusedEditor()

    def getEditor(self, index=None):
        if index is None:
            index = self.currentIndex()
        subStack = self.widget(index)
        return subStack.widget(0).getEditor(0)

    def getCloneEditor(self, index=None):
        if index is None:
            index = self.currentIndex()
        return self.widget(index).widget(0).getEditor(1)

    def getSnapshot(self, index=None):
        if index is None:
            index = self.currentIndex()
        return self.widget(index).widget(1)

    def getUnifiedDiff(self, index=None):
        if index is None:
            index = self.currentIndex()
        return self.widget(index).widget(2)

    def getContextDiff(self, index=None):
        if index is None:
            index = self.currentIndex()
        return self.widget(index).widget(3)

    def clearMarkerAndIndicators(self):
        self.currentEditor.clearMarkerAndIndicators()

    def splitVertical(self):
        splitter = self.currentWidget().widget(0)
        splitter.setOrientation(2)
        splitter.widget(1).show()

    def splitHorizontal(self):
        splitter = self.currentWidget().widget(0)
        splitter.setOrientation(1)
        splitter.widget(1).show()

    def removeSplit(self):
        splitter = self.currentWidget().widget(0)
        splitter.widget(1).hide()

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            if os.path.isfile(urls[0].toLocalFile()):
                event.acceptProposedAction()
            else:
                event.ignore()
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        event.acceptProposedAction()

    def dropEvent(self, event):
        mimeData = event.mimeData()
        if mimeData.hasUrls():
            urls = event.mimeData().urls()
            fname = urls[0].toLocalFile()
            self.loadfile(os.path.normpath(fname))
        else:
            pass
        event.acceptProposedAction()

    def showNotification(self, message, index=None):
        if index is None:
            index = self.currentIndex()
        self.focusedEditor(index).notification.showMessage(message)

    def undoAction(self):
        self.currentEditor.undo()

    def redoAction(self):
        self.currentEditor.redo()

    def cutItem(self):
        self.currentEditor.cut()

    def copyItem(self):
        self.currentEditor.copy()

    def deleteItem(self):
        self.currentEditor.removeSelectedText()

    def selectAll(self):
        self.currentEditor.selectAll()

    def selectToMatchingBrace(self):
        self.currentEditor.selectToMatchingBrace()

    def clearBackups(self):
        # empty backups
        for i in os.listdir(self.projectPathDict["backupdir"]):
            remPath = os.path.join(self.projectPathDict["backupdir"], i)
            try:
                os.remove(remPath)
            except:
                pass

    def createBackup(self):
        for i in range(self.count()):
            key = self.getEditorData("backupKey", i)
            editor = self.getEditor(i)

            savePath = os.path.join(self.projectPathDict["backupdir"], key)

            file = open(savePath, 'w')
            file.write(editor.text())
            file.close()
        self.saveSession(True)

    def saveSession(self, backup=False):
        dom_document = QtXml.QDomDocument("session")

        session = dom_document.createElement("session")
        dom_document.appendChild(session)

        for i in range(self.count()):
            editor = self.getEditor(i)

            tag = dom_document.createElement("file")
            path = self.getEditorData("filePath", i)
            if not backup:
                if path is None:
                    continue
            tag.setAttribute("path", path)

            path = str(self.getEditorData("filePath", i))
            tag.setAttribute("active", str(
                self.currentEditor == editor))

            locked = editor.isReadOnly()
            tag.setAttribute("locked", str(locked))

            tag.setAttribute("lines", str(editor.lines()))

            line, index = editor.getCursorPosition()
            tag.setAttribute("cursorPosition", str(line) + ',' + str(index))

            firstVisibleLine = editor.firstVisibleLine()
            tag.setAttribute("firstVisibleLine", str(firstVisibleLine))

            bookmarkLines = editor.getBookmarks()
            tag.setAttribute("bookmarks",
                             str(bookmarkLines).replace(', ', '-').strip('[]'))

            folds = editor.contractedFolds()
            tag.setAttribute("folds",
                             str(folds).replace(', ', '-').strip('[]'))

            if backup:
                key = self.getEditorData("backupKey", i)
                tag.setAttribute("backupKey", key)
                tag.setAttribute("baseName", self.tabText(i))

            session.appendChild(tag)

        if backup:
            savePath = self.projectPathDict["backupfile"]
        else:
            savePath = self.projectPathDict["session"]
        file = open(savePath, "w")
        file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
        file.write(dom_document.toString())
        file.close()

    def restoreSession(self):
        # TODO: When backup is True and it turns out empty because
        # it previousely loaded from backup, cleared it's backup
        # cache and was instantly shut down again, the previous
        # session must be reloaded.
        backup = self.projectSettings["LastCloseSuccessful"] == "False"

        if backup:
            loadPath = self.projectPathDict["backupfile"]
        else:
            self.clearBackups()
            loadPath = self.projectPathDict["session"]

        file = open(loadPath, "r")
        dom_document = QtXml.QDomDocument()
        dom_document.setContent(file.read())
        file.close()

        elements = dom_document.documentElement()
        node = elements.firstChild()
        activeIndex = 0
        currentIindex = 0
        restoredBackups = 0
        while node.isNull() is False:
            try:
                tag = node.toElement()
                if backup:
                    backupKey = tag.attribute("backupKey")
                    basename = tag.attribute("baseName")
                    backupPath = os.path.join(
                        self.projectPathDict["backupdir"], backupKey)
                    realPath = tag.attribute("path")
                    if realPath == '':
                        file = open(backupPath, 'r')
                        backupText = file.read()
                        file.close()

                        subStack = self.newEditor(currentIindex)
                        editor = subStack.widget(0).widget(0)
                        editor.setText(backupText)
                        editor.setModified(False)
                        editor.setFocus()

                        restoredBackups += 1
                    else:
                        real_mod_time = os.stat(realPath).st_mtime
                        backup_mod_time = os.stat(backupPath).st_mtime
                        if real_mod_time > backup_mod_time:
                            pass
                        else:
                            file = open(backupPath, 'r')
                            backupText = file.read()
                            file.close()

                            file = open(realPath, "w")
                            file.write(backupText)
                            file.close()

                            restoredBackups += 1

                        path = tag.attribute("path")
                        loaded = self.loadfile(path, False, currentIindex)
                else:
                    path = tag.attribute("path")
                    loaded = self.loadfile(path, False, currentIindex)
                if loaded is False:
                    node = node.nextSibling()
                    continue

                locked = tag.attribute("locked")
                if locked == 'True':
                    self.writeLock()
                lines = tag.attribute("lines")
                active = tag.attribute("active")
                if active == 'True':
                    activeIndex = currentIindex
                cp = tag.attribute("cursorPosition").split(',')
                line = int(cp[0])
                index = int(cp[1])

                firstVisibleLine = int(tag.attribute("firstVisibleLine"))

                editor = self.getEditor()
                editor.setCursorPosition(line, 0)
                editor.setFirstVisibleLine(firstVisibleLine)

                m = tag.attribute("bookmarks")
                if m != '':
                    bookmarks = list(map(int, m.split('-')))
                    for line in bookmarks:
                        editor.toggleBookmark(1, line)

                folds = tag.attribute("folds")
                if folds != '':
                    folds = list(map(int, folds.split('-')))
                    editor.setContractedFolds(folds)

                currentIindex += 1
                node = node.nextSibling()
            except:
                exc_type, exc_value, exc_traceback = sys.exc_info()
                logging.error(repr(traceback.format_exception(exc_type, exc_value,
                             exc_traceback)))
                node = node.nextSibling()
        if self.count() != 0:
            self.setCurrentIndex(activeIndex)
        if self.count() == 0:
            self._newPythonFile()

        self.clearBackups()
        if restoredBackups > 0:
            self.messagesWidget.addMessage(
                0, "Restored", [str(restoredBackups) + ' file(s) restored from previous crash.'])

    def getSource(self, index=None):
        if index is None:
            return self.getEditor().text()
        else:
            return self.getEditor(index).text()

    def getSelection(self):
        return self.currentEditor.selectedText()

    def closeEditorTab(self, index):
        if self.getEditor(index).isModified():
            self.requestSaveMess(index)
        else:
            if self.count() == 1:
                self._newPythonFile()
            self.removeTabBackup(index)
            path = self.getEditorData('filePath')
            if path is None:
                self.filesWatch.removePath(path)
            self.removeTab(index)
            self.updateOpenedTabsMenu()

    def editorTabChanged(self, index):
        self.currentEditor = self.getEditor()
        self.cloneEditor = self.getCloneEditor()
        self.currentEditor.undoActModifier()
        self.currentEditor.redoActModifier()
        self.currentEditor.copyActModifier()

        if self.getEditorData("filePath") is None:
            self.updateWindowTitle.emit("Unsaved")
            self.updateEncodingLabel.emit("Coding: {0}".format(
                self.getEditorData("codingFormat")))
        else:
            self.updateWindowTitle.emit(self.getEditorData("filePath"))
            self.updateEncodingLabel.emit("Coding: {0}".format(
                self.getEditorData("codingFormat")))

        self.enableBookmarkButtons(self.currentEditor.bookmarksExist())
        self.currentEditor.updateLineCount()
        self.cursorPositionChanged.emit()
        self.updateOpenedTabsMenu()

    def enableBookmarkButtons(self, enable):
        self.bookmarkToolbar.setEnabled(enable)
        self.bookmarksChanged.emit()

    def makeCurrentTab(self, action):
        self.setCurrentIndex(action.data())

    def updateOpenedTabsMenu(self):
        self.openedTabsActionGroup = QtGui.QActionGroup(self)
        self.openedTabsActionGroup.setExclusive(True)
        self.openedTabsActionGroup.triggered.connect(self.makeCurrentTab)
        self.openedTabsMenu.clear()
        for i in range(self.count()):
            name = self.tabText(i)
            action = QtGui.QAction(name, self)
            action.setCheckable(True)
            if self.currentIndex() == i:
                action.setChecked(True)
            action.setData(i)
            self.openedTabsActionGroup.addAction(action)
            self.openedTabsMenu.addAction(action)

    def pasteFromClipboard(self):
        self.focusedEditor().paste()

    def increaseIndent(self):
        self.focusedEditor().increaseIndent()

    def decreaseIndent(self):
        self.focusedEditor().decreaseIndent()

    def showMe(self, widget):
        for toolWidget in self.toolWidgetList:
            toolWidget.hide()
        widget.show()

    def showProjectConfiguration(self):
        self.showMe(self.configDialog)

    def showGotoLineWidget(self):
        self.showMe(self.gotoLineWidget)
        self.gotoLineWidget.lineNumberLine.setFocus(True)

    def showSnapShotSwitcher(self):
        self.showMe(self.viewSwitcher)

    def showSetRunParameters(self):
        if self.setRunParameters.isVisible():
            self.setRunParameters.hide()
        else:
            self.showMe(self.setRunParameters)

    def showFavouritesManager(self):
        self.showMe(self.manageFavourites)

    def showExternalLauncher(self):
        self.showMe(self.externalLauncher)

    def showLine(self, lineNum, highlight=True):
        self.focusedEditor().showLine(lineNum, highlight)

    def writeLock(self):
        if self.focusedEditor().isReadOnly() is False:
            self.focusedEditor().setReadOnly(True)
            self.setTabIcon(self.currentIndex(),
                            QtGui.QIcon(os.path.join("Resources", "images", "locked_script")))
        else:
            self.focusedEditor().setReadOnly(False)
            if self.getEditorData("fileType") == "python":
                if self.focusedEditor().isModified():
                    self.setTabIcon(self.currentIndex(),
                                    QtGui.QIcon(os.path.join("Resources", "images", "script_grey")))
                else:
                    self.setTabIcon(self.currentIndex(),
                                    QtGui.QIcon(os.path.join("Resources", "images", "script")))
            else:
                self.setTabIcon(self.currentIndex(),
                                Global.iconFromPath(self.getEditorData("filePath")))

    def findNextBookmark(self):
        editor = self.focusedEditor()
        editor.findNextBookmark()

    def findPreviousBookmark(self):
        editor = self.focusedEditor()
        editor.findPreviousBookmark()

    def removeBookmarks(self):
        reply = QtGui.QMessageBox.warning(self, "Remove Bookmarks",
                                          "Do you really want to remove all bookmarks?",
                                          QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            pass
        else:
            return
        self.currentEditor.removeBookmarks()
        self.enableBookmarkButtons(False)

    def goToCursorPosition(self):
        line, index = self.focusedEditor().getCursorPosition()
        self.focusedEditor().showLine(line, False)

    def comment(self):
        self.focusedEditor().comment()

    def unComment(self):
        self.focusedEditor().unComment()

    def errorsInProject(self):
        errors = False
        for i in range(self.count()):
            path = self.getEditorData("filePath", i)
            if path is not None:
                if self.isProjectFile(path):
                    if self.getEditorData("fileType", i) == "python":
                        errorLine = self.getEditorData("errorLine", i)
                        if errorLine is not None:
                            errors = True
                            self.setCurrentIndex(i)
                            break
        return errors

    def isProjectFile(self, filePath):
        if filePath is None:
            return False
        return filePath.startswith(self.projectPathDict["sourcedir"])

    def getTabName(self, tabIndex=None):
        if tabIndex is None:
            name = self.tabText(self.currentIndex())
        else:
            name = self.tabText(tabIndex)
        return name

    def getEditorData(self, attrib, tabIndex=None):
        if tabIndex is None:
            tabIndex = self.currentIndex()
        else:
            pass
        data = self.widget(tabIndex).widget(0).DATA[attrib]
        return data

    def updateEditorData(self, attrib, value, tabIndex=None):
        if tabIndex is None:
            tabIndex = self.currentIndex()
        else:
            pass
        self.getEditor(tabIndex).DATA[attrib] = value
        if attrib == "filePath":
            if value is None:
                self.updateWindowTitle.emit("Unsaved")
            else:
                self.setTabText(tabIndex, os.path.basename(value))
                self.updateWindowTitle.emit(value)

    def updateTabName(self, index=None):
        if index is None:
            index = self.currentIndex()
        else:
            pass
        path = self.getEditorData("filePath", index)
        if path is None:
            return
        text = os.path.basename(path)
        editor = self.getEditor(index)
        if editor.isModified():
            text = text + " *"
        self.setTabText(index, text)
        self.setTabToolTip(index, path)

    def removeTabBackup(self, tabIndex):
        key = self.getEditorData("backupKey", tabIndex)
        try:
            os.remove(os.path.join(self.projectPathDict["backupdir"], key))
        except:
            pass

    def requestSaveMess(self, tabIndex):
        mess = "Save changes to '{0}'?".format(self.tabText(tabIndex))
        reply = QtGui.QMessageBox.information(self, "Save", mess,
                                              QtGui.QMessageBox.Save | QtGui.QMessageBox.Discard |
                                              QtGui.QMessageBox.Cancel)
        if reply == QtGui.QMessageBox.Save:
            self.save()
        elif reply == QtGui.QMessageBox.Discard:
            if self.count() == 1:
                self.newFile()
            self.removeTabBackup(tabIndex)
            self.removeTab(tabIndex)

    def _save(self):
        self.save()

    def save(self, index=None):
        if index is None:
            index = self.currentIndex()
        savePath = self.getEditorData("filePath", index)
        if savePath is None:
            saved = self.saveAs(index)
            return saved
        else:
            try:
                file = open(savePath, "w")
                editor = self.getEditor(index)
                file.write(editor.text())
                file.close()
                editor.setModified(False)

                return True
            except Exception as err:
                exc_type, exc_value, exc_traceback = sys.exc_info()
                logging.error(repr(traceback.format_exception(exc_type, exc_value,
                             exc_traceback)))
                self.saveErrorMess(str(err))

                return False

    def saveToTemp(self, type, index=None):
        if index is None:
            index = self.currentIndex()
        try:
            if type == 'pep8':
                file = open(os.path.join("temp", "temp8.py"), "w")
            editor = self.getEditor(index)
            file.write(editor.text())
            file.close()
            return True
        except:
            return False

    def saveAs(self, index=None, copyOnly=False):
        options = QtGui.QFileDialog.Options()
        filter = self.getFilter()
        fileName = QtGui.QFileDialog.getSaveFileName(self,
                                                     "Save As", os.path.join(self.useData.getLastOpenedDir(),
                                                                             self.getTabName()), filter, options)
        if fileName:
            self.useData.saveLastOpenedDir(os.path.split(fileName)[0])
            try:
                if index is None:
                    index = self.currentIndex()
                fileName = os.path.normpath(fileName)
                editor = self.getEditor(index)
                file = open(fileName, "w")
                file.write(editor.text())
                file.close()
                editor.setModified(False)
                self.updateTabName(index)
                if not copyOnly:
                    self.updateEditorData("filePath", fileName)
                self.filesWatch.addPath(fileName)
                return True
            except Exception as err:
                exc_type, exc_value, exc_traceback = sys.exc_info()
                logging.error(repr(traceback.format_exception(exc_type, exc_value,
                             exc_traceback)))
                self.saveErrorMess(str(err.args[1]))
                return False
        else:
            return False

    def saveCopyAs(self):
        self.saveAs(copyOnly=True)

    def getFilter(self):
        fileType = self.getEditorData("fileType")
        if fileType == "python":
            filter = "Console (*.py);;No Console (*.pyw)"
        elif fileType == ".xml":
            filter = "Xml (*.xml)"
        elif fileType == ".html":
            filter = "Html (*.html)"
        elif fileType == ".css":
            filter = "Css (*.css)"
        else:
            filter = "All Files (*)"
        return filter

    def saveAll(self):
        for i in range(self.count()):
            self.save(i)

    def saveProject(self):
        saved = True
        source_dir = self.projectPathDict["sourcedir"]
        for i in range(self.count()):
            path = self.getEditorData("filePath", i)
            if path is not None:
                if self.isProjectFile(path):
                    # its a project file
                    editor = self.getEditor(i)
                    if editor.isModified():
                        saved = self.save(i)
                        if not saved:
                            break
        return saved

    def saveErrorMess(self, mess):

        message = QtGui.QMessageBox.critical(self,
                                             "Save", "Error saving file!\n\n" + mess)

    def printCode(self):
        document = self.currentEditor.document()
        printer = QtGui.QPrinter()

        dlg = QtGui.QPrintDialog(printer, self)
        if dlg.exec_() != QtGui.QDialog.Accepted:
            return
        document.print_(printer)

    def openFile(self):
        fileName = QtGui.QFileDialog.getOpenFileName(self,
                                                     "Select File", self.useData.getLastOpenedDir(
                                                     ),
                                                     "All Files (*);;Console (*.py);;No Console (*.pyw);;Xml (*.xml);;Html (*.html);;Css (*.css)")
        if fileName:
            self.useData.saveLastOpenedDir(os.path.split(fileName)[0])
            self.loadfile(os.path.normpath(fileName))

    def _newPythonFile(self):
        self.newEditor()

    def _newXmlFile(self):
        self.newEditor(fileName="Untitled.xml")

    def _newHtmlFile(self):
        self.newEditor(fileName="Untitled.html")

    def _newCssFile(self):
        self.newEditor(fileName="Untitled.css")

    def newEditor(self, index=None, fileName="Untitled.py",
                  filePath=None, encoding=None):
        extension = os.path.splitext(fileName)[1].lower()
        pyFile = extension in [".py", ".pyw"]
        if pyFile:
            extension = "python"

        DATA = {}
        DATA["filePath"] = filePath
        DATA["backupKey"] = str(time.time()) + '.' + str(
            self.backupKeyDiferentiator)
        self.backupKeyDiferentiator += 1
        DATA["bookmarkList"] = []

        if encoding is None:
            DATA["codingFormat"] = "utf-8"
        else:
            DATA["codingFormat"] = encoding
        if pyFile:
            DATA["errorLine"] = None
            DATA["fileType"] = "python"
            editor = CodeEditor(self.useData, self.refactor, self.colorScheme,
                                DATA, self)
            editor2 = CodeEditor(self.useData, self.refactor, self.colorScheme,
                                 DATA, self)
            snapShot = CodeSnapshot(self.useData, self.colorScheme)
        else:
            if extension in [".htm", ".html"]:
                extension = ".html"
            DATA["fileType"] = extension
            editor = TextEditor(self.useData, DATA, self.colorScheme, self,
                                encoding)
            editor2 = TextEditor(self.useData, DATA, self.colorScheme, self,
                                 encoding)
            snapShot = TextSnapshot(self.useData, self.colorScheme, extension)
        mode = QsciScintilla.EolUnix
        editor.setEolMode(mode)
        editor2.setEolMode(mode)
        snapShot.setEolMode(mode)

        snapShot.setReadOnly(True)
        subStack = QtGui.QStackedWidget()
        editorSplitter = EditorSplitter(editor, editor2, DATA, self, subStack)
        editor2.setDocument(editor.document())
        subStack.addWidget(editorSplitter)
        subStack.addWidget(snapShot)
        diffWindow = DiffWindow(editor, snapShot)
        diffWindow.setStyleSheet(StyleSheet.editorStyle)
        subStack.addWidget(diffWindow)
        diffWindow = DiffWindow(editor, snapShot)
        diffWindow.setStyleSheet(StyleSheet.editorStyle)
        subStack.addWidget(diffWindow)

        if extension in self.useData.supportedFileTypes:
            icon = QtGui.QIcon(os.path.join("Resources", "images", "script"))
        else:
            icon = Global.iconFromPath(filePath)
        if index is None:
            index = self.currentIndex()
        self.insertTab(index, subStack, icon, fileName)

        if filePath is None:
            pass
        else:
            self.filesWatch.addPath(filePath)

        editor.textChanged.connect(self.currentEditorTextChanged.emit)
        editor.cursorPositionChanged.connect(self.cursorPositionChanged.emit)
        editor2.cursorPositionChanged.connect(self.cursorPositionChanged.emit)

        self.setCurrentWidget(subStack)

        return subStack

    def reloadModules(self, pathList=[]):
        index_list = []
        currentIndex = self.currentIndex()
        if len(pathList) == 0:
            index_list.append(currentIndex)
        else:
            for i in range(self.count()):
                path = self.getEditorData("filePath", i)
                if path in pathList:
                    index_list.append(i)
        for i in index_list:
            filePath = self.getEditorData("filePath", i)
            editor = self.getEditor(i)
            text, encoding, eolMode = self.useData.readFile(filePath)
            firstLine = editor.firstVisibleLine()
            editor.setText(text)
            editor.convertEols(eolMode)
            editor.setEolMode(eolMode)
            editor.setFirstVisibleLine(firstLine)
            editor.setModified(False)
            if i == currentIndex:
                self.getEditor(i).removeBookmarks()
                self.enableBookmarkButtons(False)

    def alreadyOpened(self, filePath):
        for i in range(self.count()):
            fpath = self.getEditorData("filePath", i)
            if fpath is None:
                pass
            else:
                if os.path.samefile(fpath, filePath):
                    self.setCurrentIndex(i)
                    return True
        return False

    def loadfile(self, filePath, showError=True, index=None):

        filePath = os.path.normpath(filePath)
        # prevent same file from being opened more than once
        if self.alreadyOpened(filePath):
            return True

        QtGui.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        try:
            text, encoding, eolMode = self.useData.readFile(filePath)
            baseName = os.path.basename(filePath)
            subStack = self.newEditor(index, baseName, filePath, encoding)

            editor = subStack.widget(0).widget(0)
            editor.setText(text)
            editor.convertEols(eolMode)
            editor.setEolMode(eolMode)

            snapshotWidget = subStack.widget(1)
            snapshotWidget.setText(text)
            snapshotWidget.convertEols(eolMode)
            snapshotWidget.setEolMode(eolMode)
        except Exception as err:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                         exc_traceback)))
            QtGui.QApplication.restoreOverrideCursor()
            if showError:
                message = QtGui.QMessageBox.warning(self, "Open", str(err))
            else:
                pass
            return False

        QtGui.QApplication.restoreOverrideCursor()

        editor.setModified(False)
        editor.setFocus()
        self.updateRecentFilesList.emit(filePath)
        self.updateOpenedTabsMenu()

        return True

    def get_current_word(self):
        current_word = self.focusedEditor().get_current_word()
        return current_word

    def getOffset(self):
        offset = self.focusedEditor().getOffset()
        return offset

    def changeTab(self):
        if (self.count() - 1) != self.currentIndex():
            self.setCurrentIndex(self.currentIndex() + 1)
        else:
            self.setCurrentIndex(0)

    def reverseTab(self):
        if self.currentIndex() != 0:
            self.setCurrentIndex(self.currentIndex() - 1)
        else:
            self.setCurrentIndex(self.count() - 1)

    def changeSplitFocus(self):
        splitter = self.currentWidget().widget(0)
        firstEditor = splitter.widget(0)
        if firstEditor.hasFocus():
            splitter.widget(1).setFocus()
        else:
            firstEditor.setFocus()

    def setKeymap(self):
        self.tabBar.setKeymap()
        shortcuts = self.useData.CUSTOM_SHORTCUTS

        self.shortSplitVertical = QtGui.QShortcut(
            shortcuts["Ide"]["Split-Vertical"], self)
        self.shortSplitVertical.activatedAmbiguously.connect(
            self.splitVertical)
        self.vSplitEditorAct.setShortcut(shortcuts["Ide"]["Split-Vertical"])

        self.shortSplitHorizontal = QtGui.QShortcut(
            shortcuts["Ide"]["Split-Horizontal"], self)
        self.shortSplitHorizontal.activatedAmbiguously.connect(
            self.splitHorizontal)
        self.hSplitEditorAct.setShortcut(
            shortcuts["Ide"]["Split-Horizontal"])

        self.shortRemoveSplit = QtGui.QShortcut(
            shortcuts["Ide"]["Remove-Split"], self)
        self.shortRemoveSplit.activatedAmbiguously.connect(self.removeSplit)
        self.noSplitEditorAct.setShortcut(shortcuts["Ide"]["Remove-Split"])

        self.shortChangeTab = QtGui.QShortcut(
            shortcuts["Ide"]["Change-Tab"], self)
        self.shortChangeTab.activated.connect(self.changeTab)

        self.shortReverseTab = QtGui.QShortcut(
            shortcuts["Ide"]["Change-Tab-Reverse"], self)
        self.shortReverseTab.activated.connect(self.reverseTab)

        self.shortChangeSplitFocus = QtGui.QShortcut(
            shortcuts["Ide"]["Change-Split-Focus"], self)
        self.shortChangeSplitFocus.activated.connect(self.changeSplitFocus)

        self.shortNewFile = QtGui.QShortcut(
            shortcuts["Ide"]["New-File"], self)
        self.shortNewFile.activatedAmbiguously.connect(self._newPythonFile)
        self.newPythonFileAct.setShortcut(shortcuts["Ide"]["New-File"])

        self.shortOpenFile = QtGui.QShortcut(
            shortcuts["Ide"]["Open-File"], self)
        self.shortOpenFile.activatedAmbiguously.connect(self.openFile)
        self.openFileAct.setShortcut(shortcuts["Ide"]["New-File"])

        self.shortSaveFile = QtGui.QShortcut(
            shortcuts["Ide"]["Save-File"], self)
        self.shortSaveFile.activatedAmbiguously.connect(self._save)
        self.saveAct.setShortcut(shortcuts["Ide"]["Save-File"])

        self.shortSaveAll = QtGui.QShortcut(
            shortcuts["Ide"]["Save-All"], self)
        self.shortSaveAll.activatedAmbiguously.connect(self.saveAll)
        self.saveAllAct.setShortcut(shortcuts["Ide"]["Save-All"])

        self.shortPrint = QtGui.QShortcut(shortcuts["Ide"]["Print"], self)
        self.shortPrint.activatedAmbiguously.connect(self.printCode)
        self.printAct.setShortcut(shortcuts["Ide"]["Print"])

########NEW FILE########
__FILENAME__ = BuildStatusWidget
from PyQt4 import QtCore, QtGui


class BuildStatusWidget(QtGui.QWidget):

    cancel = QtCore.pyqtSignal()

    def __init__(self, app, useData, parent=None):
        QtGui.QDialog.__init__(self, parent)

        self.useData = useData
        self.app = app

        mainLayout = QtGui.QHBoxLayout()
        mainLayout.setMargin(0)
        self.setLayout(mainLayout)

        mainLayout.addWidget(QtGui.QLabel("Build Started..."))

        self.progressBar = QtGui.QProgressBar()
        self.progressBar.setMaximumHeight(10)
        self.progressBar.setMinimumWidth(100)
        self.progressBar.setStyleSheet("""
                                         QProgressBar {
                                             border: none;
                                             background: transparent;
                                             border-top: 1px solid #6570EA;
                                             border-radius: 0px;
                                         }

                                         QProgressBar::chunk {
                                             background-color: #65B0EA;
                                             width: 15px;
                                         }
                                        """)
        mainLayout.addWidget(self.progressBar)

        self.hide()

    def showBusy(self, busy):
        if busy:
            self.show()
            self.progressBar.setRange(0, 0)
        else:
            self.hide()
            self.progressBar.setRange(0, 1)
            if self.useData.SETTINGS['SoundsEnabled'] == "True":
                self.app.beep()

########NEW FILE########
__FILENAME__ = EditorWindow
import os
import re
import sys
import traceback
import logging

from PyQt4 import QtCore, QtGui, QtXml

from Extensions.FileExplorer import FileExplorer
from Extensions.BottomWidgets.FindInFiles import FindInFiles
from Extensions.Projects.ProjectManager.ProjectManager import ProjectManager
from Extensions.SearchWidget import SearchWidget
from Extensions.Outline.Outline import Outline
from Extensions.EditorTabWidget import EditorTabWidget
from Extensions.WritePad import WritePad
from Extensions.Favourites import Favourites
from Extensions.ExternalLauncher import ExternalLauncher
from Extensions.BottomWidgets.Assistant import Assistant
from Extensions.BottomWidgets.TasksWidget import Tasks
from Extensions.BottomWidgets.BookmarkWidget import BookmarkWidget
from Extensions.BottomWidgets.RunWidget import RunWidget
from Extensions.BottomWidgets.Messages import MessagesWidget
from Extensions.StackSwitcher import StackSwitcher
from Extensions import StyleSheet
from Extensions.EditorWindow.BuildStatusWidget import BuildStatusWidget
from Extensions.EditorWindow.VerticalSplitter import VerticalSplitter
from Extensions.BottomWidgets.Profiler import Profiler


class EditorWindow(QtGui.QWidget):

    def __init__(self, projectPathDict, library, busyWidget,
                 colorScheme, useData, app, parent):
        QtGui.QWidget.__init__(self, parent)

        self.app = app
        self.useData = useData
        self.library = library
        self.projects = parent
        self.colorScheme = colorScheme

        self.projectPathDict = projectPathDict
        self.loadProjectData()

        self.busyWidget = busyWidget
        self.buildStatusWidget = BuildStatusWidget(self.app, self.useData)

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setMargin(0)
        mainLayout.setSpacing(0)
        self.setLayout(mainLayout)

        self.standardToolbar = QtGui.QToolBar("Standard")
        self.standardToolbar.setMovable(False)
        self.standardToolbar.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
        self.standardToolbar.setMaximumHeight(26)
        self.standardToolbar.setObjectName("StandardToolBar")
        mainLayout.addWidget(self.standardToolbar)

        widget = QtGui.QWidget()
        vbox = QtGui.QVBoxLayout()
        vbox.setMargin(0)
        vbox.setSpacing(0)
        widget.setLayout(vbox)

        self.vSplitter = VerticalSplitter()
        mainLayout.addWidget(self.vSplitter)

        self.hSplitter = QtGui.QSplitter()
        self.hSplitter.setObjectName("hSplitter")

        self.vSplitter.addWidget(self.hSplitter)

        self.bottomStack = QtGui.QStackedWidget()
        self.vSplitter.addWidget(self.bottomStack)

        self.hSplitter.addWidget(widget)

        self.bottomStackSwitcher = StackSwitcher(self.bottomStack)
        self.bottomStackSwitcher.setStyleSheet(StyleSheet.bottomSwitcherStyle)

        self.messagesWidget = MessagesWidget(
            self.bottomStackSwitcher, self.vSplitter)

        self.createActions()

        self.manageFavourites = Favourites(

            self.projectData['favourites'], self.messagesWidget, self)

        self.externalLauncher = ExternalLauncher(
            self.projectData["launchers"], self)

        self.writePad = WritePad(self.projectPathDict[
                                 "notes"], self.projectPathDict["name"], self)

        self.bookmarkToolbar = QtGui.QToolBar("Bookmarks")
        self.bookmarkToolbar.setMovable(False)
        self.bookmarkToolbar.setFloatable(False)
        self.bookmarkToolbar.setContextMenuPolicy(QtCore.Qt.PreventContextMenu)
        self.bookmarkToolbar.setObjectName("Bookmarks")
        self.bookmarkToolbar.addSeparator()

        self.editorTabWidget = EditorTabWidget(
            self.useData, self.projectPathDict, self.projectData[
                "settings"], self.messagesWidget,
            self.colorScheme, self.busyWidget, self.bookmarkToolbar, self.app, self.manageFavourites,
            self.externalLauncher, self)
        vbox.addWidget(self.editorTabWidget)

        self.manageFavourites.openFile.connect(self.editorTabWidget.loadfile)

        self.editorTabWidget.updateRecentFilesList.connect(
            self.updateRecentFiles)
        self.editorTabWidget.updateLinesCount.connect(self.updateLineCount)
        self.editorTabWidget.updateEncodingLabel.connect(
            self.updateEncodingLabel)
        self.editorTabWidget.cursorPositionChanged.connect(
            self.showCursorPosition)

        self.searchWidget = SearchWidget(
            self.useData, self.editorTabWidget)
        vbox.addWidget(self.searchWidget)

        self.findInFiles = FindInFiles(
            self.useData, self.editorTabWidget, projectPathDict, self.bottomStackSwitcher)
        vbox.addWidget(self.findInFiles.dashboard)
        self.findInFiles.dashboard.hide()

        self.projectManager = ProjectManager(
            self.editorTabWidget, self.messagesWidget, projectPathDict, self.projectData[
                "settings"], self.useData, app,
            self.busyWidget, self.buildStatusWidget, self.projects)
        self.projectManager.projectView.fileActivated.connect(
            self.editorTabWidget.loadfile)

        self.outline = Outline(
            self.useData, self.editorTabWidget)

        self.sideSplitter = QtGui.QSplitter()
        self.sideSplitter.setObjectName("sidebarItem")
        self.sideSplitter.setOrientation(0)
        self.hSplitter.addWidget(self.sideSplitter)

        self.sideSplitter.addWidget(self.outline)

        self.sideBottomTab = QtGui.QTabWidget()
        self.sideBottomTab.setObjectName("sideBottomTab")
        self.sideSplitter.addWidget(self.sideBottomTab)

        self.sideBottomTab.addTab(self.projectManager.projectView, QtGui.QIcon(
            os.path.join("Resources", "images", "tree")), "Project")

        self.fileExplorer = FileExplorer(
            self.useData, self.projectData['shortcuts'], self.messagesWidget, self.editorTabWidget)
        self.fileExplorer.fileActivated.connect(self.editorTabWidget.loadfile)
        self.sideBottomTab.addTab(self.fileExplorer, QtGui.QIcon(
            os.path.join("Resources", "images", "tree")), "File System")

        # create menus
        self.mainMenu = QtGui.QMenu()
        self.mainMenu.addMenu(self.editorTabWidget.newFileMenu)
        self.mainMenu.addAction(self.editorTabWidget.openFileAct)
        self.mainMenu.addAction(self.editorTabWidget.saveAct)
        self.mainMenu.addAction(self.editorTabWidget.saveAllAct)
        self.mainMenu.addAction(self.editorTabWidget.saveAsAct)
        self.mainMenu.addAction(self.editorTabWidget.saveCopyAsAct)
        self.mainMenu.addAction(self.editorTabWidget.printAct)

        self.projectMenu = QtGui.QMenu("Project")
        if projectPathDict["type"] == "Desktop Application":
            self.projectMenu.addAction(self.buildAct)
            self.projectMenu.addAction(self.openBuildAct)
        self.projectMenu.addAction(self.configureAct)
        self.projectMenu.addSeparator()
        self.projectMenu.addAction(self.exportProjectAct)
        self.projectMenu.addAction(self.closeProjectAct)
        self.mainMenu.addMenu(self.projectMenu)

        self.mainMenu.addSeparator()
        self.mainMenu.addAction(self.gotoLineAct)
        self.mainMenu.addAction(self.viewSwitcherAct)
        helpMenu = self.mainMenu.addMenu("Help")
        helpMenu.addAction(self.userGuideAct)
        helpMenu.addAction(self.pythonManualsAct)
        helpMenu.addSeparator()
        helpMenu.addAction(self.feedbackAct)
        helpMenu.addAction(self.checkUpdatesAct)
        self.mainMenu.addSeparator()
        self.mainMenu.addMenu(self.manageFavourites.favouritesMenu)
        self.recentFilesMenu = self.mainMenu.addMenu("Recent Files")
        self.recentFilesMenu.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "history")))
        self.loadRecentFiles()
        self.mainMenu.addMenu(self.externalLauncher.launcherMenu)
        self.mainMenu.addSeparator()
        self.mainMenu.addAction(self.exitAct)

        self.createToolbars()

        # create StatusBar
        self.statusbar = QtGui.QStatusBar()

        self.statusbar.addPermanentWidget(self.buildStatusWidget)

        #*** Position
        self.cursorPositionButton = QtGui.QToolButton()
        self.cursorPositionButton.setAutoRaise(True)
        self.cursorPositionButton.clicked.connect(
            self.editorTabWidget.goToCursorPosition)
        self.statusbar.addPermanentWidget(self.cursorPositionButton)
        #*** lines
        self.linesLabel = QtGui.QLabel("Lines: 0")
        self.linesLabel.setMinimumWidth(50)
        self.statusbar.addPermanentWidget(self.linesLabel)
        #*** encoding
        self.encodingLabel = QtGui.QLabel("Coding: utf-8")
        self.statusbar.addPermanentWidget(self.encodingLabel)
        #*** uptime
        self.uptimeLabel = QtGui.QLabel()
        self.uptimeLabel.setText("Uptime: 0min")
        self.statusbar.addPermanentWidget(self.uptimeLabel)

        self.runWidget = RunWidget(
            self.bottomStackSwitcher, self.projectData[
                "settings"], self.useData,
            self.editorTabWidget, self.vSplitter,
            self.runProjectAct, self.stopRunAct, self.runFileAct)
        self.addBottomWidget(self.runWidget,
                             QtGui.QIcon(os.path.join("Resources", "images", "graphic-design")),  "Output")

        self.assistantWidget = Assistant(
            self.editorTabWidget, self.bottomStackSwitcher)
        self.addBottomWidget(self.assistantWidget,
                             QtGui.QIcon(os.path.join("Resources", "images", "flag")), "Alerts")

        bookmarkWidget = BookmarkWidget(
            self.editorTabWidget, self.bottomStackSwitcher)
        self.addBottomWidget(bookmarkWidget,
                             QtGui.QIcon(os.path.join("Resources", "images", "tag")), "Bookmarks")

        tasksWidget = Tasks(self.editorTabWidget, self.bottomStackSwitcher)
        self.addBottomWidget(tasksWidget,
                             QtGui.QIcon(os.path.join("Resources", "images", "issue")), "Tasks")

        self.addBottomWidget(self.messagesWidget,
                             QtGui.QIcon(os.path.join("Resources", "images", "speech_bubble")), "Messages")

        self.profiler = Profiler(self.useData, self.bottomStackSwitcher)
        self.addBottomWidget(self.profiler,
                             QtGui.QIcon(os.path.join("Resources", "images", "settings")), "Profiler")
        self.runWidget.loadProfile.connect(
            self.profiler.viewProfile)

        self.addBottomWidget(self.findInFiles,
                             QtGui.QIcon(os.path.join("Resources", "images", "attibutes")), "Find-in-Files")

        self.bottomStackSwitcher.setDefault()

        hbox = QtGui.QHBoxLayout()
        hbox.setMargin(0)
        hbox.setSpacing(0)
        hbox.addWidget(self.bottomStackSwitcher)
        hbox.addStretch(1)
        hbox.addWidget(self.statusbar)
        mainLayout.addLayout(hbox)

        self.uptime = 0
        self.uptimeTimer = QtCore.QTimer()
        self.uptimeTimer.setInterval(60000)
        self.uptimeTimer.timeout.connect(self.updateUptime)
        self.uptimeTimer.start()

        # remember layout
        if projectPathDict['root'] in self.useData.OPENED_PROJECTS:
            settings = QtCore.QSettings("Clean Code Inc.", "Pcode")
            settings.beginGroup(projectPathDict['root'])
            self.hSplitter.restoreState(settings.value('hsplitter'))
            self.vSplitter.restoreState(settings.value('vsplitter'))
            self.sideSplitter.restoreState(
                settings.value('sidesplitter'))
            self.vSplitter.updateStatus()
            self.writePad.setGeometry(settings.value('writepad'))
            settings.endGroup()

        self.setKeymap()

    def resizeView(self, hview, vview):
        hSizes = self.hSplitter.sizes()
        vSizes = self.vSplitter.sizes()
        if hview == 1:
            self.hSplitter.setSizes([hSizes[0] + 2, hSizes[1] - 2])
        elif hview == -1:
            self.hSplitter.setSizes([hSizes[0] - 2, hSizes[1] + 2])

        if vview == 1:
            self.vSplitter.setSizes([vSizes[0] + 2, vSizes[1] - 2])
        elif vview == -1:
            self.vSplitter.setSizes([vSizes[0] - 2, vSizes[1] + 2])

    def createActions(self):
        self.gotoLineAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "mail_check")),
                "Goto Line", self,
                statusTip="Goto Line", triggered=self.showGotoLineWidget)

        self.viewSwitcherAct = QtGui.QAction(
            "Switch Views", self, statusTip="Switch Views",
            triggered=self.showSnapShotSwitcher)

        self.exitAct = \
            QtGui.QAction("Exit", self, statusTip="Exit",
                          triggered=self.projects.closeProgram)

        # Menubar Actions ----------------------------------------------------

        self.userGuideAct = QtGui.QAction(
            "User Guide", self, statusTip="User Guide",
                                         triggered=self.launchHelp)

        self.pythonManualsAct = QtGui.QAction("Python Manuals", self,
                                              statusTip="Python Manuals",
                                              triggered=self.launchPythonHelp)

        self.checkUpdatesAct = QtGui.QAction("Check For Updates", self,
                                             statusTip="Check For Updates",
                                             triggered=self.visitHomepage)

        self.feedbackAct = QtGui.QAction("Send Feedback", self,
                                         statusTip="Send Feedback",
                                        triggered=self.openFeedbackLink)
        #----------------------------------------------------------------------
        self.runFileAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "rerun")),
            "Run File", self,
            statusTip="Run current file", triggered=self.runFile)

        self.runProjectAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "run")),
            "Run Project", self,
            statusTip="Run Project", triggered=self.runProject)

        self.stopRunAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "stop")),
            "Stop", self,
            statusTip="Stop execution",
            triggered=self.stopProcess)

        self.runParamAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "shell")),
            "Set Run Parameters", self,
            statusTip="Set Run Parameters",
            triggered=self.setRunParameters)

        #---------------------------------------------------------------------

        self.finderAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "scope")),
            "Find", self,
            statusTip="Find", triggered=self.showFinderWidget)

        self.replaceAct = \
            QtGui.QAction(
                QtGui.QIcon(
                    os.path.join("Resources", "images", "edit-replace")),
                "Replace", self,
                statusTip="Replace",
                          triggered=self.showReplaceWidget)

        self.findInFilesAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "find_in_files")),
            "Find-in-Files", self,
            statusTip="Find-in-Files", triggered=self.showFindInFilesWidget)

        self.addToLibraryAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "add")),
                "Add To Library", self,
                statusTip="Add current module to Library",
                          triggered=self.addToLibrary)

        self.clearRecentFilesAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "clear")),
                "Clear History", self, statusTip="Clear History",
                triggered=self.clearRecentFiles)

        self.writePadAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "pencil")),
                "Writepad", self, statusTip="Writepad",
                triggered=self.showWritePad)

        self.buildAct = \
            QtGui.QAction(
                "Build", self,
                statusTip="Build",
                triggered=self.buildProject)

        self.openBuildAct = \
            QtGui.QAction(
                "Open Build", self, statusTip="Open Build",
                triggered=self.openBuild)

        self.configureAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "settings")),
                "Configuration", self, statusTip="Configuration",
                triggered=self.showProjectConfiguration)

        self.exportProjectAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "archive")),
                "Export as Zip...", self, statusTip="Export as Zip",
                triggered=self.exportProject)

        self.closeProjectAct = \
            QtGui.QAction(
                QtGui.QIcon(
                    os.path.join("Resources", "images", "inbox--minus")),
                "Close Project", self, statusTip="Close Project",
                triggered=self.closeProject)

    def visitHomepage(self):
        QtGui.QDesktopServices().openUrl(QtCore.QUrl(
            """https://github.com/fortharris/Pcode"""))

    def showProjectConfiguration(self):
        self.editorTabWidget.showProjectConfiguration()

    def buildProject(self):
        self.projectManager.buildProject()

    def openBuild(self):
        self.projectManager.openBuild()

    def exportProject(self):
        self.projectManager.exportProject()

    def closeProject(self):
        self.projects.closeProject()

    def updateEncodingLabel(self, text):
        self.encodingLabel.setText(text)

    def showGotoLineWidget(self):
        self.editorTabWidget.showGotoLineWidget()

    def showSnapShotSwitcher(self):
        self.editorTabWidget.showSnapShotSwitcher()

    def addBottomWidget(self, widget, icon, name):
        self.bottomStack.addWidget(widget)
        self.bottomStackSwitcher.addButton(toolTip=name, icon=icon)

    def showWritePad(self):
        self.writePad.show()

    def showFinderWidget(self):
        self.findInFiles.dashboard.hide()
        self.searchWidget.showFinder()

    def showReplaceWidget(self):
        self.findInFiles.dashboard.hide()
        self.searchWidget.showReplaceWidget()

    def showFindInFilesWidget(self):
        self.searchWidget.hide()
        self.findInFiles.dashboard.show()

    def createToolbars(self):

        self.editorMenuButton = QtGui.QToolButton()
        self.editorMenuButton.setText("Menu")
        self.editorMenuButton.setToolButtonStyle(2)
        self.editorMenuButton.setAutoRaise(True)
        self.editorMenuButton.setPopupMode(2)
        self.editorMenuButton.setIcon(QtGui.QIcon(
            os.path.join("Resources", "images", "Dashboard")))
        self.editorMenuButton.setMenu(self.mainMenu)

        self.standardToolbar.addWidget(self.editorMenuButton)
        self.standardToolbar.addAction(self.editorTabWidget.openFileAct)
        self.standardToolbar.addAction(self.editorTabWidget.newPythonFileAct)
        self.standardToolbar.addSeparator()
        self.standardToolbar.addAction(self.editorTabWidget.saveAct)
        self.standardToolbar.addAction(self.editorTabWidget.saveAllAct)
        self.standardToolbar.addAction(self.editorTabWidget.undoAct)
        self.editorTabWidget.undoAct.setDisabled(True)
        self.standardToolbar.addAction(self.editorTabWidget.redoAct)
        self.editorTabWidget.redoAct.setDisabled(True)
        self.standardToolbar.addSeparator()
        self.standardToolbar.addAction(self.editorTabWidget.cutAct)
        self.editorTabWidget.cutAct.setDisabled(True)
        self.standardToolbar.addAction(self.editorTabWidget.copyAct)
        self.editorTabWidget.copyAct.setDisabled(True)
        self.standardToolbar.addAction(self.editorTabWidget.pasteAct)
        self.standardToolbar.addSeparator()
        self.standardToolbar.addAction(self.editorTabWidget.dedentAct)
        self.standardToolbar.addAction(self.editorTabWidget.indentAct)

        self.standardToolbar.addSeparator()
        self.standardToolbar.addAction(self.runFileAct)
        self.standardToolbar.addAction(self.runProjectAct)
        self.standardToolbar.addAction(self.stopRunAct)
        self.stopRunAct.setVisible(False)
        self.standardToolbar.addAction(self.runParamAct)
        self.standardToolbar.addSeparator()
        self.standardToolbar.addAction(self.finderAct)
        self.standardToolbar.addAction(self.replaceAct)
        self.standardToolbar.addAction(self.findInFilesAct)
        self.standardToolbar.addSeparator()
        self.standardToolbar.addAction(self.addToLibraryAct)
        self.standardToolbar.addAction(self.writePadAct)

        self.bookmarkToolbar.addAction(
            self.editorTabWidget.findNextBookmarkAct)
        self.bookmarkToolbar.addAction(
            self.editorTabWidget.findPrevBookmarkAct)
        self.bookmarkToolbar.addAction(self.editorTabWidget.removeBookmarksAct)
        self.standardToolbar.addWidget(self.bookmarkToolbar)

    def recentFileActivated(self, action):
        path = action.text().split('  ', 1)[1]
        if os.path.exists(path):
            self.editorTabWidget.loadfile(path)
        else:
            message = QtGui.QMessageBox.warning(self, "Open",
                                                "File is unavailable!")

    def loadRecentFiles(self):
        if len(self.projectData['recentfiles']) > 0:
            self.recentFile_actionGroup = QtGui.QActionGroup(self)
            self.recentFile_actionGroup.triggered.connect(
                self.recentFileActivated)
            self.recentFilesMenu.clear()
            c = 1
            for i in self.projectData['recentfiles']:
                action = QtGui.QAction(str(c) + '  ' + i, self)
                self.recentFile_actionGroup.addAction(action)
                self.recentFilesMenu.addAction(action)
                c += 1
            self.recentFilesMenu.addSeparator()
            self.recentFilesMenu.addAction(self.clearRecentFilesAct)
        else:
            self.recentFilesMenu.addAction("No Recent Files")

    def updateRecentFiles(self, filePath):
        if filePath in self.projectData['recentfiles']:
            self.projectData['recentfiles'].remove(filePath)
            self.projectData['recentfiles'].insert(0, filePath)
        else:
            if len(self.projectData['recentfiles']) < 15:
                self.projectData['recentfiles'].insert(0, filePath)
            else:
                del self.projectData['recentfiles'][-1]
                self.projectData['recentfiles'].insert(0, filePath)
        self.loadRecentFiles()

    def clearRecentFiles(self):
        self.projectData['recentfiles'] = []
        self.recentFilesMenu.clear()
        self.loadRecentFiles()
        self.messagesWidget.addMessage(0, 'Recent Files:',
                                       ["Recent files history has been cleared!"])

    def addToLibrary(self):
        self.library.addToLibrary(self.editorTabWidget)

    def openFeedbackLink(self):
        QtGui.QDesktopServices().openUrl(QtCore.QUrl(
            """https://twitter.com/PcodeIDE"""))

    def updateUptime(self):
        self.uptime += 1
        if self.uptime == 60:
            new_time = "1hr"
        elif self.uptime > 60:
            t = int(str(self.uptime / 60).split('.')[0])
            h = str(t) + "hr"
            m = str(self.uptime - (t * 60)) + "min"
            new_time = h + m
        else:
            new_time = str(self.uptime) + "min"
        self.uptimeLabel.setText("Uptime: " + new_time)

    def saveAll(self):
        self.editorTabWidget.saveAll()

    def fileUrl(self, fname):
        """Select the right file url scheme according to the operating system"""
        if os.name == 'nt':
            # Local file
            if re.search(r'^[a-zA-Z]:', fname):
                return 'file:///' + fname
            # UNC based path
            else:
                return 'file://' + fname
        else:
            return 'file://' + fname

    def getPythonDocPath(self):
        """
        Return Python documentation path
        (Windows: return the PythonXX.chm path if available)
        """
        if os.name == 'nt':
            path = os.path.dirname(
                self.projectData['settings']["DefaultInterpreter"])
            doc_path = os.path.join(path, "Doc")
            if not os.path.isdir(doc_path):
                return
            python_chm = [path for path in os.listdir(doc_path)
                          if re.match(r"(?i)Python[0-9]{3}.chm", path)]
            if python_chm:
                return self.fileUrl(os.path.join(doc_path, python_chm[0]))
        else:
            vinf = sys.version_info
            doc_path = '/usr/share/doc/python%d.%d/html' % (vinf[0], vinf[1])
        python_doc = os.path.join(doc_path, "index.html")
        if os.path.isfile(python_doc):
            return self.fileUrl(python_doc)

    def launchHelp(self):
        message = QtGui.QMessageBox.warning(
            self, "User Guide", "Will be available when i am out of beta.")

    def launchPythonHelp(self):
        try:
            doc_path = self.getPythonDocPath()
            os.startfile(doc_path)
        except Exception as err:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                         exc_traceback)))
            message = QtGui.QMessageBox.critical(self, "Python Manuals",
                                                 ("Failed to launch the Python Manuals!\n\n"
                                                  "It is either not available for the current python "
                                                  "version or Python is not installed in your system."))

    def setRunParameters(self):
        self.editorTabWidget.showSetRunParameters()

    def runFile(self):
        self.runWidget.runFile()

    def runProject(self):
        self.runWidget.runProject()

    def stopProcess(self):
        self.runWidget.stopProcess()

    def showPythonInterpreter(self):
        process = QtCore.QProcess()
        process.startDetached(self.useData.SETTINGS["DefaultInterpreter"])

    def showCommandPrompt(self):
        prompt = os.environ["COMSPEC"]
        process = QtCore.QProcess()
        process.startDetached(prompt, [], QtCore.QDir().rootPath())

    def showCursorPosition(self):
        line, index = self.editorTabWidget.currentEditor.getCursorPosition()
        self.cursorPositionButton.setText(
            "Line {0} : Column {1}".format(line + 1, index + 1))

    def updateLineCount(self, lines):
        self.linesLabel.setText("Lines: " + str(lines))

    def saveUiState(self):
        name = self.projectPathDict["root"]
        settings = QtCore.QSettings("Clean Code Inc.", "Pcode")
        settings.beginGroup(name)
        settings.setValue('hsplitter', self.hSplitter.saveState())
        settings.setValue('vsplitter', self.vSplitter.saveState())
        settings.setValue('sidesplitter', self.sideSplitter.saveState())
        settings.setValue('writepad', self.writePad.geometry())
        settings.endGroup()

    def restoreSession(self):
        self.editorTabWidget.restoreSession()

    def closeWindow(self):
        if self.runWidget.currentProcess is not None:
            mess = "Close running program?"
            reply = QtGui.QMessageBox.warning(self, "Close",
                                              mess, QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
            if reply == QtGui.QMessageBox.Yes:
                self.runWidget.stopProcess()
            else:
                return False
        modified = []
        for i in range(self.editorTabWidget.count()):
            if self.editorTabWidget.getEditor(i).isModified():
                modified.append(i)
        if len(modified) == 0:
            pass
        else:
            for i in range(len(modified)):
                v = modified.pop(-1)
                self.editorTabWidget.setCurrentIndex(v)
                mess = 'Save changes to "{0}"?'.format(
                    self.editorTabWidget.tabText(v))
                reply = QtGui.QMessageBox.warning(self, "Close", mess,
                                                  QtGui.QMessageBox.Yes | QtGui.QMessageBox.No |
                                                  QtGui.QMessageBox.Cancel)
                if reply == QtGui.QMessageBox.No:
                    if len(modified) == 0:
                        pass
                elif reply == QtGui.QMessageBox.Yes:
                    saved = self.editorTabWidget.save()
                    if saved:
                        pass
                    else:
                        return False
                elif reply == QtGui.QMessageBox.Cancel:
                    return False
        self.saveUiState()
        self.editorTabWidget.saveSession()
        self.projectData["settings"]["Closed"] = "True"
        self.saveProjectData()
        self.editorTabWidget.refactor.closeRope()

        return True

    def loadProjectData(self):
        dom_document = QtXml.QDomDocument()
        file = open(os.path.join(self.projectPathDict[
                    "root"], "Data", "projectdata.xml"), "r")
        x = dom_document.setContent(file.read())
        file.close()

        elements = dom_document.documentElement()
        node = elements.firstChild()

        shortcuts = []
        recentfiles = []
        favourites = []
        launchers = {}

        settingsList = []
        while node.isNull() is False:
            property = node.toElement()
            sub_node = property.firstChild()
            while sub_node.isNull() is False:
                sub_prop = sub_node.toElement()
                if node.nodeName() == "shortcuts":
                    shortcuts.append(sub_prop.text())
                elif node.nodeName() == "recentfiles":
                    if os.path.exists(sub_prop.text()):
                        recentfiles.append(sub_prop.text())
                    else:
                        pass
                elif node.nodeName() == "favourites":
                    favourites.append(sub_prop.text())
                elif node.nodeName() == "settings":
                    settingsList.append((tuple(sub_prop.text().split('=', 1))))
                elif node.nodeName() == "launchers":
                    tag = sub_prop.toElement()
                    path = tag.attribute("path")
                    param = tag.attribute("param")
                    launchers[path] = param
                sub_node = sub_node.nextSibling()
            node = node.nextSibling()
        settingsDict = dict(settingsList)

        settingsDict['LastCloseSuccessful'] = settingsDict['Closed']
        settingsDict['Closed'] = "False"

        self.projectData = {}
        self.projectData["shortcuts"] = shortcuts
        self.projectData["favourites"] = favourites
        self.projectData["recentfiles"] = recentfiles
        self.projectData["settings"] = settingsDict
        self.projectData["launchers"] = launchers

        # in order that a crash can be reported
        self.saveProjectData()

    def saveProjectData(self):
        domDocument = QtXml.QDomDocument("projectdata")

        projectdata = domDocument.createElement("projectdata")
        domDocument.appendChild(projectdata)

        root = domDocument.createElement("shortcuts")
        projectdata.appendChild(root)

        for i in self.projectData['shortcuts']:
            tag = domDocument.createElement("shortcut")
            root.appendChild(tag)

            t = domDocument.createTextNode(i)
            tag.appendChild(t)

        root = domDocument.createElement("recentfiles")
        projectdata.appendChild(root)

        for i in self.projectData['recentfiles']:
            tag = domDocument.createElement("recent")
            root.appendChild(tag)

            t = domDocument.createTextNode(i)
            tag.appendChild(t)

        root = domDocument.createElement("favourites")
        projectdata.appendChild(root)

        for i in self.projectData['favourites']:
            tag = domDocument.createElement("fav")
            root.appendChild(tag)

            t = domDocument.createTextNode(i)
            tag.appendChild(t)

        root = domDocument.createElement("launchers")
        projectdata.appendChild(root)

        for path, param in self.projectData['launchers'].items():
            tag = domDocument.createElement("item")
            tag.setAttribute("path", path)
            tag.setAttribute("param", param)
            root.appendChild(tag)

        root = domDocument.createElement("settings")
        projectdata.appendChild(root)

        s = 0
        for key, value in self.projectData['settings'].items():
            tag = domDocument.createElement("key")
            root.appendChild(tag)

            t = domDocument.createTextNode(key + '=' + value)
            tag.appendChild(t)
            s += 1

        path = os.path.join(
            self.projectPathDict["root"], "Data", "projectdata.xml")
        file = open(path, "w")
        file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
        file.write(domDocument.toString())
        file.close()

    def setKeymap(self):
        shortcuts = self.useData.CUSTOM_SHORTCUTS

        self.shortGotoLine = QtGui.QShortcut(
            shortcuts["Ide"]["Go-to-Line"], self)
        self.shortGotoLine.activatedAmbiguously.connect(
            self.showGotoLineWidget)
        self.gotoLineAct.setShortcut(shortcuts["Ide"]["Go-to-Line"])

        self.shortBuild = QtGui.QShortcut(shortcuts["Ide"]["Build"], self)
        self.shortBuild.activatedAmbiguously.connect(self.buildProject)
        self.buildAct.setShortcut(shortcuts["Ide"]["Build"])

        self.shortFind = QtGui.QShortcut(shortcuts["Ide"]["Find"], self)
        self.shortFind.activated.connect(self.showFinderWidget)

        self.shortReplace = QtGui.QShortcut(
            shortcuts["Ide"]["Replace"], self)
        self.shortReplace.activated.connect(self.showReplaceWidget)

        self.shortRunFile = QtGui.QShortcut(
            shortcuts["Ide"]["Run-File"], self)
        self.shortRunFile.activated.connect(self.runFile)

        self.shortRunProject = QtGui.QShortcut(
            shortcuts["Ide"]["Run-Project"], self)
        self.shortRunProject.activated.connect(self.runProject)

        self.shortStopRun = QtGui.QShortcut(
            shortcuts["Ide"]["Stop-Execution"], self)
        self.shortStopRun.activated.connect(self.stopProcess)

        self.shortPythonManuals = QtGui.QShortcut(
            shortcuts["Ide"]["Python-Manuals"], self)
        self.shortPythonManuals.activatedAmbiguously.connect(
            self.launchPythonHelp)
        self.pythonManualsAct.setShortcut(
            shortcuts["Ide"]["Python-Manuals"])

########NEW FILE########
__FILENAME__ = VerticalSplitter
from PyQt4 import QtGui


class VerticalSplitter(QtGui.QSplitter):

    def __init__(self, parent=None):
        QtGui.QSplitter.__init__(self, parent)

        self.setObjectName("vSplitter")
        self.setOrientation(2)

        self.bottomTabCollapsed = False
        self.splitterMoved.connect(self.updateStatus)

    def updateStatus(self):
        bottomTabSize = self.sizes()[1]
        self.bottomTabCollapsed = (bottomTabSize == 0)
        if self.bottomTabCollapsed:
            self.showNormal()

    def showMessageAvailable(self):
        if not self.bottomTabCollapsed:
            return
        self.setStyleSheet("""

                                 QSplitter#vSplitter::handle {
                                     background: none;
                                 }

                                 QSplitter#vSplitter::handle:horizontal {
                                     width: 5px;
                                 }

                                 QSplitter#vSplitter::handle:vertical {
                                     background: #1281CB;
                                 }

                                 QSplitter#vSplitter::handle:pressed {
                                     background: gray;
                                 }

                              """)

    def showRunning(self):
        if not self.bottomTabCollapsed:
            return
        self.setStyleSheet("""

                                 QSplitter#vSplitter::handle {
                                     background: none;
                                 }

                                 QSplitter#vSplitter::handle:horizontal {
                                     width: 5px;
                                 }

                                 QSplitter#vSplitter::handle:vertical {
                                     background: #4EC24E;
                                 }

                                 QSplitter#vSplitter::handle:pressed {
                                     background: gray;
                                 }

                              """)

    def showError(self):
        if not self.bottomTabCollapsed:
            return
        self.setStyleSheet("""

                                 QSplitter#vSplitter::handle {
                                     background: none;
                                 }

                                 QSplitter#vSplitter::handle:horizontal {
                                     width: 5px;
                                 }

                                 QSplitter#vSplitter::handle:vertical {
                                     background: #FD6500;
                                 }

                                 QSplitter#vSplitter::handle:pressed {
                                     background: gray;
                                 }

                              """)

    def showNormal(self):
        self.setStyleSheet("""

                                 QSplitter#vSplitter::handle {
                                     background: none;
                                 }

                                 QSplitter#vSplitter::handle:vertical {
                                     background: lightgray;
                                 }

                                 QSplitter#vSplitter::handle:pressed {
                                     background: gray;
                                 }

                              """)

########NEW FILE########
__FILENAME__ = ExternalLauncher
import os
from PyQt4 import QtCore, QtGui

from Extensions import Global
from Extensions.PathLineEdit import PathLineEdit
from Extensions import StyleSheet


class ExternalLauncher(QtGui.QLabel):

    showMe = QtCore.pyqtSignal()

    def __init__(self, externalLaunchList, parent=None):
        super(ExternalLauncher, self).__init__(parent)

        self.externalLaunchList = externalLaunchList

        self.setMinimumSize(600, 230)
        self.setObjectName("containerLabel")
        self.setStyleSheet(StyleSheet.toolWidgetStyle)

        self.setBackgroundRole(QtGui.QPalette.Background)
        self.setAutoFillBackground(True)
        self.setObjectName("containerLabel")

        mainLayout = QtGui.QVBoxLayout()

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        label = QtGui.QLabel("Manage Launchers")
        label.setObjectName("toolWidgetNameLabel")
        hbox.addWidget(label)

        hbox.addStretch(1)

        self.hideButton = QtGui.QToolButton()
        self.hideButton.setAutoRaise(True)
        self.hideButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "cross_")))
        self.hideButton.clicked.connect(self.hide)
        hbox.addWidget(self.hideButton)

        self.listWidget = QtGui.QListWidget()
        mainLayout.addWidget(self.listWidget)

        formLayout = QtGui.QFormLayout()
        mainLayout.addLayout(formLayout)

        self.pathLine = PathLineEdit()
        formLayout.addRow("Path:", self.pathLine)

        self.parametersLine = QtGui.QLineEdit()
        formLayout.addRow("Parameters:", self.parametersLine)

        hbox = QtGui.QHBoxLayout()
        formLayout.addRow('', hbox)

        self.removeButton = QtGui.QPushButton("Remove")
        self.removeButton.clicked.connect(self.removeLauncher)
        hbox.addWidget(self.removeButton)

        self.addButton = QtGui.QPushButton("Add")
        self.addButton.clicked.connect(self.addLauncher)
        hbox.addWidget(self.addButton)

        hbox.addStretch(1)

        self.setLayout(mainLayout)

        self.manageLauncherAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "settings")),
                "Manage Launchers", self, statusTip="Manage Launchers",
                triggered=self.showMe.emit)

        self.launcherMenu = QtGui.QMenu("Launch External...")
        self.loadExternalLaunchers()

    def removeLauncher(self):
        path = self.listWidget.currentItem().text()
        del self.externalLaunchList[path]
        self.loadExternalLaunchers()

    def addLauncher(self):
        path = self.pathLine.text().strip()
        if path != '':
            if os.path.exists(path):
                if path not in self.externalLaunchList:
                    self.externalLaunchList[
                        path] = self.parametersLine.text().strip()
                    self.loadExternalLaunchers()
                else:
                    message = QtGui.QMessageBox.warning(
                        self, "Add Launcher", "Path already exists in launchers!")
            else:
                message = QtGui.QMessageBox.warning(
                    self, "Add Launcher", "Path does not exists!")
        else:
            message = QtGui.QMessageBox.warning(
                self, "Add Launcher", "Path cannot be empty!")

    def loadExternalLaunchers(self):
        self.launcherMenu.clear()
        self.listWidget.clear()
        if len(self.externalLaunchList) > 0:
            self.actionGroup = QtGui.QActionGroup(self)
            self.actionGroup.triggered.connect(
                self.launcherActivated)
            for path, param in self.externalLaunchList.items():
                action = QtGui.QAction(Global.iconFromPath(path), path, self)
                self.actionGroup.addAction(action)
                self.launcherMenu.addAction(action)

                item = QtGui.QListWidgetItem(Global.iconFromPath(path), path)
                item.setToolTip(path)
                self.listWidget.addItem(item)

            self.launcherMenu.addSeparator()
            self.launcherMenu.addAction(self.manageLauncherAct)
        else:
            self.launcherMenu.addAction(self.manageLauncherAct)

        if len(self.externalLaunchList) == 0:
            self.removeButton.setDisabled(True)
        else:
            self.removeButton.setDisabled(False)

    def launcherActivated(self, action):
        path = action.text()
        param = self.externalLaunchList[path]
        if os.path.exists(path):
            if os.path.isdir(path):
                os.startfile(path)
            else:
                if param == '':
                    os.startfile(path)
                else:
                    process = QtCore.QProcess(self)
                    process.startDetached(path, [param])
        else:
            message = QtGui.QMessageBox.warning(self, "Launch",
                                                "Path is not available.")

########NEW FILE########
__FILENAME__ = Favourites
import os
from PyQt4 import QtCore, QtGui

from Extensions import StyleSheet


class Favourites(QtGui.QLabel):

    showMe = QtCore.pyqtSignal()

    openFile = QtCore.pyqtSignal(str)

    def __init__(self, favouritesList, messagesWidget, parent=None):
        super(Favourites, self).__init__(parent)

        self.setMinimumSize(600, 230)
        self.setObjectName("containerLabel")
        self.setStyleSheet(StyleSheet.toolWidgetStyle)

        self.setBackgroundRole(QtGui.QPalette.Background)
        self.setAutoFillBackground(True)

        self.messagesWidget = messagesWidget
        self.favouritesList = favouritesList

        self.manageFavAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "settings")),
                          "Manage Favourites", self, statusTip="Manage Favourites",
                          triggered=self.showMe.emit)

        mainLayout = QtGui.QVBoxLayout()

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        label = QtGui.QLabel("Manage Favourites")
        label.setObjectName("toolWidgetNameLabel")
        hbox.addWidget(label)

        hbox.addStretch(1)

        self.hideButton = QtGui.QToolButton()
        self.hideButton.setAutoRaise(True)
        self.hideButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "cross_")))
        self.hideButton.clicked.connect(self.hide)
        hbox.addWidget(self.hideButton)

        self.favouritesListWidget = QtGui.QListWidget()
        mainLayout.addWidget(self.favouritesListWidget)

        hbox = QtGui.QHBoxLayout()

        self.removeButton = QtGui.QPushButton("Remove")
        self.removeButton.clicked.connect(self.removeFavourite)
        hbox.addWidget(self.removeButton)

        hbox.addStretch(1)

        mainLayout.addLayout(hbox)

        self.setLayout(mainLayout)

        self.favouritesMenu = QtGui.QMenu("Favourites")
        self.favouritesMenu.setIcon(QtGui.QIcon(
            os.path.join("Resources", "images", "bookmarked_url")))
        self.loadFavourites()

    def removeFavourite(self):
        row = self.favouritesListWidget.currentRow()
        del self.favouritesList[row]
        self.loadFavourites()

    def addToFavourites(self, path):
        if path in self.favouritesList:
            pass
        else:
            self.favouritesList.append(path)
            self.favouritesList.sort()
            self.loadFavourites()
            self.messagesWidget.addMessage(0, "Favourites",
                                           ["'{0}' added!".format(path)])

    def loadFavourites(self):
        self.favouritesMenu.clear()
        self.favouritesListWidget.clear()
        if len(self.favouritesList) > 0:
            self.favouritesActionGroup = QtGui.QActionGroup(self)
            self.favouritesActionGroup.triggered.connect(
                self.favouriteActivated)
            for i in self.favouritesList:
                action = QtGui.QAction(QtGui.QIcon(
                    os.path.join("Resources", "images", "star")), i, self)
                self.favouritesActionGroup.addAction(action)
                self.favouritesMenu.addAction(action)

                item = QtGui.QListWidgetItem(i.strip())
                item.setToolTip(i)
                item.setSizeHint(QtCore.QSize(20, 20))
                self.favouritesListWidget.addItem(item)

            self.favouritesMenu.addSeparator()
            self.favouritesMenu.addAction(self.manageFavAct)
            self.removeButton.setDisabled(False)
        else:
            action = QtGui.QAction("No Favourites", self)
            self.favouritesMenu.addAction(action)
            self.favouritesMenu.addAction(action)
            self.removeButton.setDisabled(True)

    def favouriteActivated(self, action):
        path = action.text()
        if os.path.exists(path):
            self.openFile.emit(path)
        else:
            message = QtGui.QMessageBox.warning(self, "Open",
                                                "File is no longer available.")

########NEW FILE########
__FILENAME__ = FileExplorer
import os
import ctypes
from PyQt4 import QtCore, QtGui

from Extensions import StyleSheet


class ManageShortcuts(QtGui.QLabel):

    updateShortcuts = QtCore.pyqtSignal()

    def __init__(self, useData, FILE_EXPLORER_SHORTCUTS, parent=None):
        super(ManageShortcuts, self).__init__(parent)

        self.setMinimumSize(600, 230)

        self.setBackgroundRole(QtGui.QPalette.Background)
        self.setAutoFillBackground(True)
        self.setObjectName("containerLabel")
        self.setStyleSheet(StyleSheet.toolWidgetStyle)

        self.useData = useData
        self.FILE_EXPLORER_SHORTCUTS = FILE_EXPLORER_SHORTCUTS

        mainLayout = QtGui.QVBoxLayout()

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        label = QtGui.QLabel("Manage Shortcuts")
        label.setObjectName("toolWidgetNameLabel")
        hbox.addWidget(label)

        hbox.addStretch(1)

        self.hideButton = QtGui.QToolButton()
        self.hideButton.setAutoRaise(True)
        self.hideButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "cross_")))
        self.hideButton.clicked.connect(self.hide)
        hbox.addWidget(self.hideButton)

        self.shortcutsWidget = QtGui.QListWidget()
        self.shortcutsWidget.itemSelectionChanged.connect(
            self.setButtonsVisibility)
        mainLayout.addWidget(self.shortcutsWidget)

        hbox = QtGui.QHBoxLayout()

        self.removeShortcutButton = QtGui.QToolButton()
        self.removeShortcutButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "minus")))
        self.removeShortcutButton.clicked.connect(self.removeShorcut)
        hbox.addWidget(self.removeShortcutButton)

        self.addShortcutButton = QtGui.QToolButton()
        self.addShortcutButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "add")))
        self.addShortcutButton.clicked.connect(self.addShortcut)
        hbox.addWidget(self.addShortcutButton)

        hbox.addStretch(1)

        self.moveDownButton = QtGui.QToolButton()
        self.moveDownButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "down")))
        self.moveDownButton.clicked.connect(self.moveDown)
        hbox.addWidget(self.moveDownButton)

        self.moveUpButton = QtGui.QToolButton()
        self.moveUpButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "up")))
        self.moveUpButton.clicked.connect(self.moveUp)
        hbox.addWidget(self.moveUpButton)

        hbox.addStretch(1)

        mainLayout.addLayout(hbox)

        self.setLayout(mainLayout)

        self.loadShortcuts()

    def loadShortcuts(self):
        self.shortcutsWidget.clear()
        for i in self.FILE_EXPLORER_SHORTCUTS:
            s = i.strip()
            item = QtGui.QListWidgetItem(s)
            item.setToolTip(s)
            self.shortcutsWidget.addItem(item)
        self.updateShortcuts.emit()

    def removeShorcut(self):
        text = self.shortcutsWidget.currentItem().text()
        self.FILE_EXPLORER_SHORTCUTS.remove(text)
        self.loadShortcuts()

    def addShortcut(self):
        options = QtGui.QFileDialog.DontResolveSymlinks | QtGui.QFileDialog.ShowDirsOnly
        directory = QtGui.QFileDialog.getExistingDirectory(self,
                                                           "Select directory", self.useData.getLastOpenedDir(), options)
        if directory:
            directory = os.path.normpath(directory)
            if directory in self.FILE_EXPLORER_SHORTCUTS:
                pass
            else:
                # save shortcut
                self.FILE_EXPLORER_SHORTCUTS.append(directory)
                self.useData.saveLastOpenedDir(directory)
                self.loadShortcuts()

    def moveUp(self):
        row = self.shortcutsWidget.currentRow()
        if row == 0:
            pass
        else:
            text = self.shortcutsWidget.currentItem().text()
            self.FILE_EXPLORER_SHORTCUTS.remove(text)
            self.FILE_EXPLORER_SHORTCUTS.insert(row - 1, text)
            self.loadShortcuts()
            self.shortcutsWidget.setCurrentRow(row - 1)

    def moveDown(self):
        row = self.shortcutsWidget.currentRow()
        if (row + 1) == self.shortcutsWidget.count():
            return
        text = self.shortcutsWidget.currentItem().text()
        self.FILE_EXPLORER_SHORTCUTS.remove(text)
        self.FILE_EXPLORER_SHORTCUTS.insert(row + 1, text)
        self.loadShortcuts()
        self.shortcutsWidget.setCurrentRow(row + 1)

    def setButtonsVisibility(self):
        if len(self.shortcutsWidget.selectedItems()) == 0:
            self.removeShortcutButton.setDisabled(True)
            self.moveUpButton.setDisabled(True)
            self.moveDownButton.setDisabled(True)
        else:
            self.removeShortcutButton.setDisabled(False)
            self.moveUpButton.setDisabled(False)
            self.moveDownButton.setDisabled(False)


class FileExplorer(QtGui.QTreeView):

    fileActivated = QtCore.pyqtSignal(str)

    def __init__(self, useData, FILE_EXPLORER_SHORTCUTS, messagesWidget, editorTabWidget, parent=None):
        QtGui.QTreeView.__init__(self, parent)

        self.setAcceptDrops(True)

        self.setAnimated(True)
        self.setAutoScroll(True)
        self.activated.connect(self.treeItemActivated)
        self.setObjectName("sidebarItem")

        self.fileSystemModel = QtGui.QFileSystemModel()
        self.fileSystemModel.setRootPath(QtCore.QDir.rootPath())
        self.fileSystemModel.setNameFilterDisables(False)
        self.setModel(self.fileSystemModel)
        self.setColumnWidth(0, 300)

        self.useData = useData
        self.FILE_EXPLORER_SHORTCUTS = FILE_EXPLORER_SHORTCUTS
        self.messagesWidget = messagesWidget
        self.editorTabWidget = editorTabWidget

        self.manageShortcuts = ManageShortcuts(
            useData, self.FILE_EXPLORER_SHORTCUTS, self)
        self.manageShortcuts.updateShortcuts.connect(
            self.updateShortcutsActionGroup)
        editorTabWidget.addToolWidget(self.manageShortcuts)

        self.createActions()
        self.shortcutsMenu = QtGui.QMenu("Shortcuts")
        self.updateShortcutsActionGroup()

    def contextMenuEvent(self, event):
        self.contextMenu = QtGui.QMenu()

        self.contextMenu.addAction(self.homeAct)
        self.contextMenu.addAction(self.showAllFilesAct)
        self.contextMenu.addAction(self.collapseAllAct)
        indexList = self.selectedIndexes()
        if len(indexList) != 0:
            self.contextMenu.addAction(self.createShortcutAct)
            self.contextMenu.addAction(self.locateAct)
        self.contextMenu.addSeparator()
        self.contextMenu.addMenu(self.shortcutsMenu)
        self.contextMenu.addAction(self.manageShortcutsAct)

        self.contextMenu.exec_(event.globalPos())

    def createActions(self):
        self.homeAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "home")),
            "Home", self,
            statusTip="Home", triggered=self.refreshFileSytemModel)

        self.collapseAllAct = \
            QtGui.QAction(
                "Collapse All", self,
                statusTip="Collapse Tree", triggered=self.collapseAll)

        self.showAllFilesAct = \
            QtGui.QAction(
                "Show All Files", self, statusTip="Show All Files",
                toggled=self.showAllFiles)
        self.showAllFilesAct.setCheckable(True)
        self.showAllFilesAct.setChecked(True)

        self.locateAct = \
            QtGui.QAction("Locate", self, statusTip="Locate",
                          triggered=self.locate)

        self.createShortcutAct = \
            QtGui.QAction(
                QtGui.QIcon(
                    os.path.join("Resources", "images", "brainstorming")),
                "Create Shortcut", self, statusTip="Create Shortcut",
                triggered=self.createShortcut)

        self.manageShortcutsAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "settings")),
                "Manage Shortcuts", self, statusTip="Manage Shortcuts",
                triggered=self.showManageShortcuts)

    def showManageShortcuts(self):
        self.editorTabWidget.showMe(self.manageShortcuts)

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            if os.path.isdir(urls[0].toLocalFile()):
                event.acceptProposedAction()
            else:
                event.ignore()
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        event.acceptProposedAction()

    def dropEvent(self, event):
        mimeData = event.mimeData()
        if mimeData.hasUrls():
            urls = event.mimeData().urls()
            dirname = urls[0].toLocalFile()
            self.loadShortcut(dirname)
        else:
            pass
        event.acceptProposedAction()

    def updateShortcutsActionGroup(self):
        if len(self.FILE_EXPLORER_SHORTCUTS) > 0:
            self.shortcuts_actionGroup = QtGui.QActionGroup(self)
            self.shortcuts_actionGroup.triggered.connect(
                self.shortcutActivated)
            self.shortcutsMenu.clear()
            for i in self.FILE_EXPLORER_SHORTCUTS:
                action = QtGui.QAction(i, self)
                self.shortcuts_actionGroup.addAction(action)
                self.shortcutsMenu.addAction(action)
            self.shortcutsMenu.addSeparator()
        else:
            self.shortcutsMenu.addAction("No Shortcuts")
        # TODO findInFiles.updateShortcutsList()

    def shortcutActivated(self, action):
        path = action.text()
        self.loadShortcut(path)

    def loadShortcut(self, path):
        if os.path.exists(path):
            self.setRootIndex(self.fileSystemModel.index(path))
        else:
            message = QtGui.QMessageBox.warning(self, "Open",
                                                "Directory is not available.")

    def showAllFiles(self):
        if self.showAllFilesAct.isChecked():
            self.fileSystemModel.setNameFilters([])
        else:
            self.fileSystemModel.setNameFilters(['*.py', '*.pyw'])

    def refreshFileSytemModel(self):
        self.fileSystemModel = QtGui.QFileSystemModel()
        self.fileSystemModel.setRootPath(QtCore.QDir.rootPath())
        if self.showAllFilesAct.isChecked():
            self.fileSystemModel.setNameFilters(['*.py', '*.pyw'])
        self.fileSystemModel.setNameFilterDisables(False)
        self.setModel(self.fileSystemModel)
        self.setColumnWidth(0, 300)

    def treeItemActivated(self, modelIndex):
        if self.fileSystemModel.isDir(modelIndex) is False:
            filePath = os.path.normpath(
                self.fileSystemModel.filePath(modelIndex))
            self.fileActivated.emit(filePath)
        else:
            if self.isExpanded(modelIndex):
                self.collapse(modelIndex)
            else:
                self.expand(modelIndex)

    def createShortcut(self):
        indexList = self.selectedIndexes()
        if len(indexList) == 0:
            path_index = self.rootIndex()
        else:
            path_index = indexList[0]
        path = os.path.normpath(self.fileSystemModel.filePath(path_index))
        if os.path.isfile(path):
            # save in parent directory
            path = os.path.normpath(
                self.fileSystemModel.filePath(path_index.parent()))
        else:
            pass
        mess = 'Create shortcut to "{0}"?'.format(path)
        reply = QtGui.QMessageBox.information(self, "Create Shortcut",
                                              mess, QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            # save shortcut
            if path in self.FILE_EXPLORER_SHORTCUTS:
                return
            self.FILE_EXPLORER_SHORTCUTS.append(path)
            self.updateShortcutsActionGroup()
            self.messagesWidget.addMessage(0, "Shortcuts",
                                           ["'{0}' added!".format(path)])

    def locate(self):
        indexList = self.selectedIndexes()
        if len(indexList) == 0:
            path_index = self.rootIndex()
            file_path = \
                os.path.normpath(self.fileSystemModel.filePath(path_index))
        else:
            path_index = indexList[0]
            file_path = \
                os.path.normpath(self.fileSystemModel.filePath(path_index))
        ctypes.windll.shell32.ShellExecuteW(None, 'open', 'explorer.exe',
                                            '/n,/select, ' + file_path, None, 1)

########NEW FILE########
__FILENAME__ = Global

import sys
from PyQt4 import QtGui, QtCore


def getDefaultFont():
    # Platform specific fonts
    if sys.platform == 'win32':
        font = 'Lucida Console'
        font_size = 9
    elif sys.platform == 'darwin':
        font = 'Monaco'
        font_size = 10
    else:
        font = 'Bitstream Vera Sans Mono'
        font_size = 10

    return QtGui.QFont(font, font_size)


def iconFromPath(path):
    fileInfo = QtCore.QFileInfo(path)
    iconProvider = QtGui.QFileIconProvider()
    icon = iconProvider.icon(fileInfo)

    return icon

########NEW FILE########
__FILENAME__ = GotoLineWidget
import os

from PyQt4 import QtGui


class GotoLineWidget(QtGui.QLabel):

    def __init__(self, editorTabWidget, parent=None):
        QtGui.QLabel.__init__(self, parent=None)

        self.editorTabWidget = editorTabWidget

        self.setMinimumHeight(35)
        self.setMaximumHeight(35)
        self.setMinimumWidth(200)
        self.setMaximumWidth(200)

        self.gotoLineAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "mail_check")),
                "Goto Line", self, statusTip="Goto Line",
                triggered=self.gotoLine)

        mainLayout = QtGui.QHBoxLayout()
        mainLayout.setMargin(3)
        mainLayout.setSpacing(2)
        self.setLayout(mainLayout)

        self.hideButton = QtGui.QToolButton()
        self.hideButton.setAutoRaise(True)
        self.hideButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "exit")))
        self.hideButton.clicked.connect(self.hide)
        mainLayout.addWidget(self.hideButton)

        self.lineNumberLine = QtGui.QSpinBox()
        self.lineNumberLine.setMinimumHeight(25)
        self.lineNumberLine.setMinimum(1)
        self.lineNumberLine.setMaximum(100000000)
        self.lineNumberLine.valueChanged.connect(self.gotoLine)
        mainLayout.addWidget(self.lineNumberLine)

        self.goButton = QtGui.QToolButton()
        self.goButton.setAutoRaise(True)
        self.goButton.setDefaultAction(self.gotoLineAct)
        mainLayout.addWidget(self.goButton)

        mainLayout.setStretch(1, 1)

        self.setStyleSheet("""
                            QLabel {
                                background: rgba(138, 201, 255, 200);
                                border-radius: 0px;
                            }
                             """)

    def gotoLine(self, lineno):
        if lineno is False:
            lineno = self.lineNumberLine.value()
        self.editorTabWidget.focusedEditor().showLine(lineno - 1)

########NEW FILE########
__FILENAME__ = AdvancedSearch
import os
import re
from PyQt4 import QtCore, QtGui, QtXml


class FinderThread(QtCore.QThread):

    searchSoFar = QtCore.pyqtSignal(int)

    def find(self, text, matchCase, matchWholeWord, regExp, searchLoc, libraryDir):
        self.text = text
        self.cs = matchCase
        self.wo = matchWholeWord
        self.reg = regExp
        self.searchLoc = searchLoc
        self.libraryDir = libraryDir

        self.stop = False
        self.found = []

        self.start()

    def run(self):
        self.found = []
        if self.reg:
            txt = self.text
        else:
            txt = re.escape(self.text)
        if self.wo:
            txt = "\\b{0}\\b".format(txt)
        flags = re.UNICODE | re.LOCALE
        if not self.cs:
            flags |= re.IGNORECASE
        try:
            search = re.compile(txt, flags)
        except re.error as why:
            print(why)

        files = os.listdir(self.libraryDir)
        dom_document = QtXml.QDomDocument()
        for i in range(len(files)):
            if self.stop:
                break
            file = os.path.abspath(os.path.join(self.libraryDir, files[i]))

            try:
                text = open(file, 'r').read()
            except:
                continue
            dom_document.setContent(text)

            documentElement = dom_document.documentElement()
            childElement = documentElement.firstChild().toElement()
            while childElement.isNull() is False:
                if childElement.nodeName() == 'comments':
                    if (self.searchLoc == 0) or (self.searchLoc == 2):
                        comments = childElement.firstChild().nodeValue()
                        contains = search.search(comments)
                        if contains:
                            self.found.append(files[i])
                elif childElement.nodeName() == 'code':
                    if (self.searchLoc == 0) or (self.searchLoc == 1):
                        code = childElement.firstChild().nodeValue()
                        contains = search.search(code)
                        if contains:
                            if files[i] not in self.found:
                                self.found.append(files[i])
                childElement = childElement.nextSibling()
            self.searchSoFar.emit(i)

    def stopFind(self):
        self.stop = True


class AdvancedSearch(QtGui.QWidget):

    def __init__(self, parent):
        QtGui.QWidget.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle("Advanced Search")
        self.resize(400, 120)

        self.library = parent
        self.finderThread = FinderThread()

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setMargin(0)

        self.searchResultsListWidget = QtGui.QListWidget()
        self.searchResultsListWidget.itemPressed.connect(
            self.library.viewSearchItem)
        self.searchResultsListWidget.itemActivated.connect(
            self.library.viewSearchItem)
        mainLayout.addWidget(self.searchResultsListWidget)

        mainLayout.addWidget(QtGui.QLabel("Find:"))

        self.searchLine = QtGui.QLineEdit()
        self.searchLine.returnPressed.connect(self.startSearch)
        mainLayout.addWidget(self.searchLine)

        mainLayout.addWidget(QtGui.QLabel("Location:"))

        self.searchLocBox = QtGui.QComboBox()
        self.searchLocBox.addItem("Comments AND Source Code")
        self.searchLocBox.addItem("Source Code")
        self.searchLocBox.addItem("Comments")
        mainLayout.addWidget(self.searchLocBox)

        hbox = QtGui.QHBoxLayout()

        self.matchCaseBox = QtGui.QCheckBox("Match Case")
        hbox.addWidget(self.matchCaseBox)

        self.matchWholeWordBox = QtGui.QCheckBox("Whole Word")
        hbox.addWidget(self.matchWholeWordBox)

        self.regExpBox = QtGui.QCheckBox("Regular Expression")
        hbox.addWidget(self.regExpBox)

        mainLayout.addLayout(hbox)

        frame = QtGui.QFrame()
        frame.setFrameShape(QtGui.QFrame.HLine)
        frame.setFrameShadow(QtGui.QFrame.Sunken)
        mainLayout.addWidget(frame)

        hbox = QtGui.QHBoxLayout()

        self.searchLabel = QtGui.QLabel("Searching...")
        hbox.addWidget(self.searchLabel)

        self.progressBar = QtGui.QProgressBar()
        self.progressBar.setMaximumHeight(15)
        self.progressBar.setMinimumWidth(100)
        hbox.addWidget(self.progressBar)

        self.searchLabel.hide()
        self.progressBar.hide()

        self.foundLabel = QtGui.QLabel()
        hbox.addWidget(self.foundLabel)
        self.foundLabel.hide()

        hbox.addStretch(1)

        searchButton = QtGui.QPushButton("Search")
        searchButton.clicked.connect(self.startSearch)
        hbox.addWidget(searchButton)

        mainLayout.addLayout(hbox)

        mainLayout.setStretch(0, 1)

        self.setLayout(mainLayout)

        self.finderThread.searchSoFar.connect(self.updateProgress)
        self.connect(self.finderThread, QtCore.SIGNAL('started()'),
                     self.searchStarted)
        self.connect(self.finderThread, QtCore.SIGNAL('finished()'),
                     self.searchStopped)

    def startSearch(self):
        searchText = self.searchLine.text()
        self.progressBar.setMaximum(len(os.listdir(
            self.library.useData.appPathDict["librarydir"])))
        self.finderThread.find(searchText, self.matchCaseBox.isChecked(),
                               self.matchWholeWordBox.isChecked(),
                               self.regExpBox.isChecked(),
                               self.searchLocBox.currentIndex(),
                               self.library.useData.appPathDict["librarydir"])

    def searchStarted(self):
        self.foundLabel.hide()
        self.searchLabel.show()
        self.progressBar.setValue(0)
        self.progressBar.show()

    def searchStopped(self):
        self.searchLabel.hide()
        self.progressBar.hide()
        self.foundLabel.show()
        self.foundLabel.setText(str(len(self.finderThread.found)) + " found!")

        self.searchResultsListWidget.clear()
        for i in self.finderThread.found:
            self.searchResultsListWidget.addItem(QtGui.QListWidgetItem(i))

    def updateProgress(self, value):
        self.progressBar.setValue(value)

########NEW FILE########
__FILENAME__ = Library
import os
import shutil
from PyQt4 import QtCore, QtGui, QtXml

from Extensions.Library.LibraryAddDialog import LibraryAddDialog
from Extensions.Library.AdvancedSearch import AdvancedSearch
from Extensions.BaseScintilla import BaseScintilla


def sizeformat(size):
    byteSize = len(str(size))
    if byteSize < 4:
        return str(size) + "Bytes"
    elif 3 < byteSize < 7:
        return str(round(size / 1024, 2)) + "KB"
    elif 6 < byteSize < 10:
        return str(round(size / 1048576, 2)) + "MB"
    else:
        return str(round(size / 1073741824, 2)) + "GB"


class EditComment(QtGui.QDialog):

    def __init__(self, text, parent=None):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.resize(400, 200)
        self.setWindowTitle("Edit Comment")

        mainLayout = QtGui.QVBoxLayout()

        self.commentEdit = QtGui.QPlainTextEdit()
        self.commentEdit.setPlainText(text)
        mainLayout.addWidget(self.commentEdit)

        hbox = QtGui.QHBoxLayout()
        hbox.addStretch(1)

        self.okButton = QtGui.QPushButton("OK")
        self.okButton.clicked.connect(self.accept)
        hbox.addWidget(self.okButton)

        self.cancelButton = QtGui.QPushButton("Cancel")
        self.cancelButton.clicked.connect(self.close)
        hbox.addWidget(self.cancelButton)

        mainLayout.addLayout(hbox)

        self.setLayout(mainLayout)

        self.accepted = False

    def accept(self):
        self.close()
        self.accepted = True


class GetName(QtGui.QDialog):

    def __init__(self, caption, path, defaultText=None, parent=None):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle(caption)

        self.path = path

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.addWidget(QtGui.QLabel("Name:"))

        self.nameLine = QtGui.QLineEdit()
        if defaultText is not None:
            self.nameLine.setText(defaultText)
            self.nameLine.selectAll()
        self.nameLine.textChanged.connect(self.enableAcceptButton)
        mainLayout.addWidget(self.nameLine)

        hbox = QtGui.QHBoxLayout()

        self.statusLabel = QtGui.QLabel()
        hbox.addWidget(self.statusLabel)

        self.statusLabel = QtGui.QLabel("")
        hbox.addWidget(self.statusLabel)

        hbox.addStretch(1)

        self.acceptButton = QtGui.QPushButton("Ok")
        self.acceptButton.setDisabled(True)
        self.acceptButton.clicked.connect(self.accept)
        hbox.addWidget(self.acceptButton)

        self.cancelButton = QtGui.QPushButton("Cancel")
        self.cancelButton.clicked.connect(self.close)
        hbox.addWidget(self.cancelButton)

        mainLayout.addLayout(hbox)

        self.setLayout(mainLayout)

        self.resize(300, 20)
        self.enableAcceptButton()

        self.accepted = False

        self.exec_()

    def enableAcceptButton(self):
        text = self.nameLine.text().strip()
        if text == '':
            self.acceptButton.setDisabled(True)
        else:
            preExistNames = os.listdir(self.path)
            if text in preExistNames:
                self.statusLabel.setText("Unavailable")
                self.acceptButton.setDisabled(True)
            else:
                self.statusLabel.setText("Available")
                self.acceptButton.setDisabled(False)

    def accept(self):
        self.accepted = True
        self.name = self.nameLine.text().strip()
        self.close()


class CodeViewer(BaseScintilla):

    def __init__(self, parent=None):
        BaseScintilla.__init__(self, parent)

        self.setReadOnly(True)
        self.setMarginLineNumbers(0, True)
        self.setCaretLineVisible(True)

        self.DATA = {"fileType": "python"}

        self.setStyleSheet("""

                 QsciScintilla {
                         border: none;
                         border-top: 1px solid grey;
                 }

                              """)

    def updateLexer(self, lexer):
        self.setLexer(lexer)


class Library(QtGui.QMainWindow):

    def __init__(self, useData):
        super(Library, self).__init__()

        self.useData = useData
        self.mainSplitter = QtGui.QSplitter()

        self.advancedSearch = AdvancedSearch(self)

        # define the font to use
        self.font = QtGui.QFont("Courier New")
        self.font.setFixedPitch(True)
        self.font.setPointSize(10)
        # the font metrics here will help
        # building the margin width later
        self.fontMetrics = QtGui.QFontMetrics(self.font)

        self.codeViewer = CodeViewer()
        self.mainSplitter.addWidget(self.codeViewer)

        self.subSplitter = QtGui.QSplitter(QtCore.Qt.Vertical)

        widget = QtGui.QWidget()
        vbox = QtGui.QVBoxLayout()
        vbox.setContentsMargins(0, 0, 5, 0)

        self.tabWidget = QtGui.QTabWidget()

        self.libraryCountLabel = QtGui.QLabel()
        self.tabWidget.setCornerWidget(self.libraryCountLabel)

        snippetsWidget = QtGui.QWidget()
        snippetsVbox = QtGui.QVBoxLayout()
        snippetsVbox.setMargin(0)

        self.snippetsListWidget = QtGui.QTreeWidget()
        self.snippetsListWidget.setAutoScroll(False)
        self.snippetsListWidget.setRootIsDecorated(True)
        self.snippetsListWidget.setHeaderLabels(["Name", "Size"])
        self.snippetsListWidget.setColumnWidth(0, 300)
        self.snippetsListWidget.itemPressed.connect(self.viewLibraryItem)
        self.snippetsListWidget.itemPressed.connect(self.selectionChanged)
        self.snippetsListWidget.itemActivated.connect(self.viewLibraryItem)
        self.snippetsListWidget.setStyleSheet("""
                    QTreeView {
                         show-decoration-selected: 1; /* make the selection span the entire width of the view */
                         border: none;
                    }
                    """ )
        self.snippetsListWidget.itemSelectionChanged.connect(
            self.selectionChanged)
        snippetsVbox.addWidget(self.snippetsListWidget)

        snippetsWidget.setLayout(snippetsVbox)

        self.tabWidget.addTab(snippetsWidget,
                              QtGui.QIcon(os.path.join("Resources", "images", "envelope")), "Modules")
        self.tabWidget.addTab(self.advancedSearch,
                              QtGui.QIcon(os.path.join("Resources", "images", "search")), "Search")

        vbox.addWidget(self.tabWidget)
        widget.setLayout(vbox)

        hbox = QtGui.QHBoxLayout()
        hbox.setContentsMargins(0, 0, 0, 5)
        vbox.addLayout(hbox)

        self.showDetailsButton = QtGui.QToolButton()
        self.showDetailsButton.setAutoRaise(True)
        self.showDetailsButton.setToolButtonStyle(2)
        self.showDetailsButton.setText("More")
        self.showDetailsButton.setIcon(QtGui.QIcon(
            os.path.join("Resources", "images", "extender-up")))
        self.showDetailsButton.clicked.connect(self.showComments)
        hbox.addWidget(self.showDetailsButton)

        hbox.addStretch(1)

        self.alphaSearchBox = QtGui.QComboBox()
        self.alphaSearchBox.setMinimumWidth(73)
        self.alphaSearchBox.activated.connect(self.gotoAlpha)
        hbox.addWidget(self.alphaSearchBox)

        self.subSplitter.addWidget(widget)

        self.detailsWidget = QtGui.QWidget()
        layout = QtGui.QVBoxLayout()
        layout.setContentsMargins(0, 5, 5, 0)

        layout.addWidget(QtGui.QLabel("Comments:"))

        self.commentViewer = QtGui.QPlainTextEdit()
        self.commentViewer.setReadOnly(True)
        layout.addWidget(self.commentViewer)

        layout.addWidget(QtGui.QLabel("Source:"))

        self.sourceLine = QtGui.QLineEdit()
        self.sourceLine.setReadOnly(True)
        layout.addWidget(self.sourceLine)

        self.detailsWidget.setLayout(layout)
        self.detailsWidget.hide()

        self.subSplitter.addWidget(self.detailsWidget)
        self.mainSplitter.addWidget(self.subSplitter)

        self.setCentralWidget(self.mainSplitter)

        # create menu widget
        menuWidget = QtGui.QLabel()
        menuWidget.setMinimumHeight(30)
        menuWidget.setScaledContents(True)

        hbox = QtGui.QHBoxLayout()
        hbox.setContentsMargins(5, 0, 5, 0)

        self.createActions()

        self.exportButton = QtGui.QToolButton()
        self.exportButton.setAutoRaise(True)
        self.exportButton.setDefaultAction(self.exportAct)
        hbox.addWidget(self.exportButton)

        self.renameButton = QtGui.QToolButton()
        self.renameButton.setAutoRaise(True)
        self.renameButton.setDefaultAction(self.renameAct)
        hbox.addWidget(self.renameButton)

        self.printButton = QtGui.QToolButton()
        self.printButton.setAutoRaise(True)
        self.printButton.setDefaultAction(self.printAct)
        hbox.addWidget(self.printButton)

        self.editCommentButton = QtGui.QToolButton()
        self.editCommentButton.setAutoRaise(True)
        self.editCommentButton.setDefaultAction(self.editCommentAct)
        hbox.addWidget(self.editCommentButton)

        self.removeButton = QtGui.QToolButton()
        self.removeButton.setAutoRaise(True)
        self.removeButton.setDefaultAction(self.removeAct)
        hbox.addWidget(self.removeButton)

        hbox.addStretch(1)

        self.toggleSidebarViewButton = QtGui.QToolButton()
        self.toggleSidebarViewButton.setAutoRaise(True)
        self.toggleSidebarViewButton.setDefaultAction(
            self.toggleSidebarViewAct)
        hbox.addWidget(self.toggleSidebarViewButton)

        menuWidget.setLayout(hbox)
        self.setMenuWidget(menuWidget)

        # create StatusBar
        self.statusbar = self.statusBar()

        self.currentSnippetNameLabel = QtGui.QLabel()
        self.currentSnippetNameLabel.setIndent(5)
        self.statusbar.addWidget(self.currentSnippetNameLabel)

        self.loadLibrary()
        self.selectionChanged()

    def createActions(self):
        self.editCommentAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "edit")),
                "Edit Comment", self,
                statusTip="Edit Comment", triggered=self.editComment)

        self.removeAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "remove")),
                "Remove", self,
                statusTip="Remove", triggered=self.removeItem)

        self.renameAct = \
            QtGui.QAction(
                QtGui.QIcon(
                    os.path.join("Resources", "images", "ui-text-field")),
                "Rename", self,
                statusTip="Rename", triggered=self.rename)

        self.printAct = \
            QtGui.QAction(
                QtGui.QIcon(
                    os.path.join("Resources", "images", "_0013_Printer")),
                "Print", self,
                statusTip="Print", triggered=self.printFile)

        self.exportAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "archive")),
                "Export Library", self,
                statusTip="Export Library", triggered=self.export)

        self.toggleSidebarViewAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "out")),
                "Toggle Sidebar View", self,
                statusTip="Toggle Sidebar View", triggered=self.viewSideBar)

    def gotoAlpha(self):
        alpha = self.alphaSearchBox.currentText()
        found = self.snippetsListWidget.findItems(alpha,
                                                  QtCore.Qt.MatchStartsWith | QtCore.Qt.MatchCaseSensitive)
        item = found[0]
        self.snippetsListWidget.setCurrentItem(item)
        self.snippetsListWidget.scrollToItem(item, 3)

    def selectionChanged(self):
        selected = self.snippetsListWidget.selectedItems()
        if len(selected) == 0:
            self.removeButton.setDisabled(True)
            self.renameButton.setDisabled(True)
            self.printButton.setDisabled(True)
            self.editCommentButton.setDisabled(True)
        else:
            if selected[0].type() == 1:
                self.removeButton.setDisabled(False)
                self.renameButton.setDisabled(False)
                self.printButton.setDisabled(False)
                self.editCommentButton.setDisabled(False)
            else:
                self.removeButton.setDisabled(True)
                self.renameButton.setDisabled(True)
                self.printButton.setDisabled(True)
                self.editCommentButton.setDisabled(True)

    def findSnippet(self):
        text = self.searchLine.text().strip()
        found = self.snippetsListWidget.findItems(text,
                                                  QtCore.Qt.MatchStartsWith | QtCore.Qt.MatchRecursive |
                                                  QtCore.Qt.MatchCaseSensitive)
        if len(found) != 0:
            item = found[0]
            self.snippetsListWidget.setCurrentItem(item)
            self.snippetsListWidget.scrollToItem(item, 3)

    def editComment(self):
        edit = EditComment(self.commentViewer.toPlainText(), self)
        edit.exec_()

        if edit.accepted:
            comment = edit.commentEdit.toPlainText()
            source = self.sourceLine.text()
            snippetName = self.currentSnippetNameLabel.text()
            path = os.path.join(self.useData.appPathDict[
                                "librarydir"], snippetName)

            dom_document = QtXml.QDomDocument()
            file = open(path, "r")
            dom_document.setContent(file.read())
            file.close()

            # save changes
            dom_document = QtXml.QDomDocument("snippet")
            root = dom_document.createElement("snippet")
            dom_document.appendChild(root)

            tag = dom_document.createElement('comments')
            root.appendChild(tag)

            t = dom_document.createCDATASection(comment)
            tag.appendChild(t)

            tag = dom_document.createElement('source')
            root.appendChild(tag)

            t = dom_document.createCDATASection(source)
            tag.appendChild(t)

            tag = dom_document.createElement('code')
            root.appendChild(tag)

            t = dom_document.createCDATASection(self.codeViewer.text())
            tag.appendChild(t)

            file = open(path, "w")
            file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            file.write(dom_document.toString())
            file.close()
            self.viewLibraryItem(self.currentSnippetItem)

    def showComments(self):
        if self.commentViewer.isVisible():
            self.detailsWidget.hide()
            self.showDetailsButton.setText("More")
            self.showDetailsButton.setIcon(QtGui.QIcon(
                os.path.join("Resources", "images", "extender-up")))
        else:
            self.detailsWidget.show()
            self.showDetailsButton.setText("Less")
            self.showDetailsButton.setIcon(QtGui.QIcon(
                os.path.join("Resources", "images", "extender-down")))

    def viewSideBar(self):
        if self.subSplitter.isHidden() is False:
            self.subSplitter.hide()
            self.toggleSidebarViewAct.setIcon(
                QtGui.QIcon(os.path.join("Resources", "images", "in")))
        else:
            self.subSplitter.show()
            self.toggleSidebarViewAct.setIcon(
                QtGui.QIcon(os.path.join("Resources", "images", "out")))

    def loadLibrary(self):
        self.snippetsListWidget.clear()
        files = sorted(os.listdir(self.useData.appPathDict["librarydir"]))
        alpha = {}
        for i in files:
            c = list(i)[0].upper()
            if c not in alpha:
                alpha[c] = []
        for i in files:
            c = list(i)[0].upper()
            alpha[c].append(i)
        # sort top level alphabets in descending order
        alpha = sorted(alpha.items(), key=lambda member: member[0])
        self.alphaSearchBox.clear()
        for v in alpha:
            self.alphaSearchBox.addItem(v[0])
            parent = QtGui.QTreeWidgetItem(0)
            parent.setText(0, v[0])
            parent.setForeground(0, QtGui.QBrush(QtGui.QColor("#FF0000")))
            self.snippetsListWidget.addTopLevelItem(parent)
            for i in sorted(v[1]):
                item = QtGui.QTreeWidgetItem(1)
                item.setText(0, i)
                item.setToolTip(0, i)
                itemSize = os.path.getsize(os.path.join(
                    self.useData.appPathDict["librarydir"], i))
                item.setText(1, sizeformat(itemSize))
                item.setToolTip(1, "")
                parent.addChild(item)
        self.snippetsListWidget.expandAll()
        self.snippetsListWidget.resizeColumnToContents(1)

        count = len(files)
        if count == 0:
            self.removeAct.setDisabled(True)
            self.renameAct.setDisabled(True)
            self.printAct.setDisabled(True)
        else:
            self.removeAct.setDisabled(False)
            self.renameAct.setDisabled(False)
            self.printAct.setDisabled(False)
        self.libraryCountLabel.setText(str(count) + " items")

    def viewLibraryItem(self, item):
        if item.type() == 0:
            return
        self.currentSnippetItem = item
        path = os.path.join(self.useData.appPathDict[
                            "librarydir"], item.data(0, 0))
        self.showExtraData(path)

        self.currentSnippetNameLabel.setText(item.data(0, 0))

    def viewSearchItem(self, item):
        self.currentSnippetItem = item
        path = os.path.join(self.useData.appPathDict[
                            "librarydir"], item.text())
        self.showExtraData(path)

        self.currentSnippetNameLabel.setText(item.text())

    def showExtraData(self, path):
        dom_document = QtXml.QDomDocument()
        file = open(path, "r")
        dom_document.setContent(file.read())
        file.close()

        documentElement = dom_document.documentElement()
        childElement = documentElement.firstChild().toElement()
        source = ''  # for compatibilty with older versions of library files
        while childElement.isNull() is False:
            if childElement.nodeName() == 'comments':
                comments = childElement.firstChild().nodeValue()
            elif childElement.nodeName() == 'code':
                code = childElement.firstChild().nodeValue()
            elif childElement.nodeName() == 'source':
                source = childElement.firstChild().nodeValue()
            childElement = childElement.nextSibling()

        self.commentViewer.setPlainText(comments)
        self.codeViewer.setText(code)
        self.sourceLine.setText(source)

    def removeItem(self):
        mess = 'Remove "{0}" from library?'.format(
            self.currentSnippetItem.text(0))
        reply = QtGui.QMessageBox.warning(self, "Remove", mess,
                                          QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            path = os.path.join(self.useData.appPathDict["librarydir"],
                                self.currentSnippetNameLabel.text())
            try:
                os.remove(path)
                self.loadLibrary()
            except:
                message = QtGui.QMessageBox.warning(self, "Remove",
                                                    "Failed to remove item!")

    def printFile(self):
        document = self.codeViewer.document()
        printer = QtGui.QPrinter()

        dlg = QtGui.QPrintDialog(printer, self)
        if dlg.exec_() != QtGui.QDialog.Accepted:
            return
        document.print_(printer)

    def rename(self):
        old_path = os.path.join(self.useData.appPathDict["librarydir"],
                                self.currentSnippetItem.text(0))
        base_dir = os.path.dirname(old_path)
        c = os.path.splitext(os.path.basename(old_path))
        head = c[0]
        extension = c[1]

        newName = GetName("Rename", self.useData.appPathDict["librarydir"],
                          head, self)
        if newName.accepted:
            text = newName.name.strip()
            new_path = os.path.join(base_dir, text + extension)
            try:
                os.rename(old_path, new_path)
                self.loadLibrary()
            except Exception as err:
                message = QtGui.QMessageBox.warning(self, "Rename",
                                                    "Renaming failed!\n\n{0}".format(str(err)))

    def selectAll(self):
        self.codeViewer.selectAll()

    def export(self):
        options = QtGui.QFileDialog.Options()
        fileName = QtGui.QFileDialog.getSaveFileName(self,
                                                     "Export Library",
                                                     os.path.join(
                                                         self.useData.getLastOpenedDir(
                                                         ),
                                                         "Pcode_Library"'_' + QtCore.QDateTime().currentDateTime().toString().replace(' ', '_').replace(':', '-') + '.pcdlib'),
                                                     "Pcode Library (*.pcdlib);", options)
        if fileName:
            self.useData.saveLastOpenedDir(os.path.split(fileName)[0])
            try:
                QtGui.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
                fileName = os.path.normpath(fileName)
                shutil.make_archive(fileName, "zip",
                                    self.useData.appPathDict["librarydir"])
            except Exception as err:
                mess = str(err.args[1])
                QtGui.QApplication.restoreOverrideCursor()
                message = QtGui.QMessageBox.critical(self,
                                                     "Export Library", mess)
            QtGui.QApplication.restoreOverrideCursor()
        else:
            return False

    def addToLibrary(self, editorTabWidget):
        if editorTabWidget.getSource().strip() == '':
            message = QtGui.QMessageBox.warning(self, "Library Add",
                                                "Source code must be present to add to library!")
            return
        add = LibraryAddDialog(editorTabWidget, self)
        if add.accepted:
            path = os.path.join(self.useData.appPathDict[
                                "librarydir"], add.name)
            if os.path.exists(path):
                mess = "File already exists in Library.\n\nReplace it?"
                reply = QtGui.QMessageBox.warning(self, "Library Add",
                                                  mess, QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
                if reply == QtGui.QMessageBox.Yes:
                    pass
                else:
                    return
            try:
                dom_document = QtXml.QDomDocument("snippet")
                root = dom_document.createElement("snippet")
                dom_document.appendChild(root)

                tag = dom_document.createElement('comments')
                root.appendChild(tag)

                t = dom_document.createCDATASection(
                    add.commentEntry.toPlainText())
                tag.appendChild(t)

                tag = dom_document.createElement('source')
                root.appendChild(tag)

                if add.entireModuleButton.isChecked():
                    t = dom_document.createCDATASection("Main")
                    tag.appendChild(t)
                else:
                    t = dom_document.createCDATASection(
                        editorTabWidget.getTabName())
                    tag.appendChild(t)

                tag = dom_document.createElement('code')
                root.appendChild(tag)

                if add.entireModuleButton.isChecked():
                    t = dom_document.createCDATASection(
                        editorTabWidget.getSource())
                else:
                    t = dom_document.createCDATASection(
                        editorTabWidget.focusedEditor().selectedText())
                tag.appendChild(t)

                file = open(path, "w")
                file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
                file.write(dom_document.toString())
                file.close()
                self.loadLibrary()
                self.close()
            except Exception as err:
                message = QtGui.QMessageBox.warning(self, "Library Add",
                                                    "Adding to Library failed!\n\n{0}".format(str(err)))

########NEW FILE########
__FILENAME__ = LibraryAddDialog
import os
from PyQt4 import QtCore, QtGui


class LibraryAddDialog(QtGui.QDialog):

    def __init__(self, editorTabWidget, parent):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle("Library Add")
        self.setFixedSize(400, 120)

        self.editorTabWidget = editorTabWidget
        self.library = parent

        head = os.path.splitext(self.editorTabWidget.getTabName())[0]

        mainLayout = QtGui.QVBoxLayout()

        mainLayout.addWidget(QtGui.QLabel("Name in library:"))

        self.nameLine = QtGui.QLineEdit()
        self.nameLine.setText(head)
        self.nameLine.selectAll()
        self.nameLine.textChanged.connect(self.textChanged)
        mainLayout.addWidget(self.nameLine)

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        self.entireModuleButton = QtGui.QRadioButton("Entire Module")
        self.entireModuleButton.setChecked(True)
        hbox.addWidget(self.entireModuleButton)

        self.selectionButton = QtGui.QRadioButton("Selection Only")
        if self.editorTabWidget.focusedEditor().selectedText().strip() == '':
            self.selectionButton.setDisabled(True)
        hbox.addWidget(self.selectionButton)
        
        hbox.addStretch(1)
        
        self.showDetailsButton = QtGui.QToolButton()
        self.showDetailsButton.setAutoRaise(True)
        self.showDetailsButton.setToolButtonStyle(2)
        self.showDetailsButton.setText("Comments")
        self.showDetailsButton.setIcon(QtGui.QIcon(
            os.path.join("Resources", "images", "extender-down")))
        self.showDetailsButton.clicked.connect(self.showComments)
        hbox.addWidget(self.showDetailsButton)

        self.moreWidget = QtGui.QWidget()
        vbox = QtGui.QVBoxLayout()
        vbox.setMargin(0)

        self.commentEntry = QtGui.QPlainTextEdit()
        vbox.addWidget(self.commentEntry)

        self.moreWidget.setLayout(vbox)
        mainLayout.addWidget(self.moreWidget)

        self.moreWidget.hide()

        hbox = QtGui.QHBoxLayout()

        hbox.addStretch(1)

        self.okButton = QtGui.QPushButton("OK")
        self.okButton.clicked.connect(self.accept)
        hbox.addWidget(self.okButton)

        cancelButton = QtGui.QPushButton("Cancel")
        cancelButton.clicked.connect(self.close)
        hbox.addWidget(cancelButton)

        mainLayout.addLayout(hbox)
        self.setLayout(mainLayout)

        self.accepted = False

        self.exec_()

    def showComments(self):
        if self.moreWidget.isVisible():
            self.moreWidget.hide()
            self.setFixedSize(400, 120)
            self.showDetailsButton.setIcon(QtGui.QIcon(
                os.path.join("Resources", "images", "extender-down")))
        else:
            self.moreWidget.show()
            self.setFixedSize(400, 300)
            self.showDetailsButton.setIcon(QtGui.QIcon(
                os.path.join("Resources", "images", "extender-up")))

    def textChanged(self):
        if self.nameLine.text().strip() == '':
            self.okButton.setDisabled(True)
        else:
            self.okButton.setDisabled(False)

    def accept(self):
        self.accepted = True

        file_name = self.nameLine.text().strip()
        self.name = os.path.splitext(file_name)[0]

        self.close()

########NEW FILE########
__FILENAME__ = Notification
from PyQt4 import QtGui, QtCore


class Notification(QtGui.QLabel):

    def __init__(self, parent=None):
        QtGui.QLabel.__init__(self, parent)

        self.setMinimumHeight(25)
        self.setMargin(5)
        
        self.easingCurve = QtCore.QEasingCurve.OutCubic

        self.showAnimation = QtCore.QPropertyAnimation(self, 'maximumWidth')
        self.showAnimation.setDuration(200)
        self.showAnimation.setEasingCurve(self.easingCurve)

        self.setStyleSheet("""background: #1A1A1A;
                                color: white;
                                border: 1px solid #72A4CE;
                                border-radius: 0px;
                                border-left: 5px solid #72A4CE;
                            """)

    def mousePressEvent(self, event):
        self.hide()

    def showMessage(self, mess):
        self.hide()
        self.setText(mess)
        self.adjustSize()
        
        max_width = self.geometry().width()
        self.showAnimation.setEndValue(max_width + 10)
        self.setMaximumWidth(0)
        self.show()
        self.showAnimation.start()
        
        

########NEW FILE########
__FILENAME__ = Outline
import os
from operator import itemgetter

from PyQt4 import QtCore, QtGui
from Extensions.Outline.Python import pyclbr


class PythonOutlineThread(QtCore.QThread):

    updateNavigator = QtCore.pyqtSignal(dict)

    def run(self):
        outlineDict = pyclbr._readmodule(self.source)
        self.updateNavigator.emit(outlineDict)

    def startNavigator(self, source):
        self.source = source
        self.start()


class Outline(QtGui.QTreeWidget):

    def __init__(self, useData, editorTabWidget, parent=None):
        QtGui.QTreeWidget.__init__(self, parent)

        self.pythonOutlineThread = PythonOutlineThread()
        self.useData = useData
        self.editorTabWidget = editorTabWidget

        self.setObjectName("sidebarItem")
        self.setStyleSheet("QTreeView {margin-top: 23px;}")

        self.navigatorTimer = QtCore.QTimer()
        self.navigatorTimer.setSingleShot(True)
        self.navigatorTimer.timeout.connect(self.startOutline)

        self.editorTabWidget.currentChanged.connect(self.startNavigatorTimer)
        self.editorTabWidget.currentEditorTextChanged.connect(
            self.startNavigatorTimer)

        self.pythonOutlineThread.updateNavigator.connect(self.updateOutline)

        self.setAutoScroll(True)
        self.setAnimated(True)
        self.setAutoScrollMargin(1)
        self.setHeaderHidden(True)
        self.activated.connect(self.navigatorItemActivated)
        self.itemPressed.connect(self.navigatorItemActivated)
        
    def startNavigatorTimer(self):
        self.navigatorTimer.start(500)

    def startOutline(self):
        self.pythonOutlineThread.startNavigator(
            self.editorTabWidget.getSource())

    def updateOutline(self, outlineDict):
        self.clear()

        objs = list(outlineDict.values())
        objs.sort(key=lambda a: getattr(a, 'lineno', 0))
        for obj in objs:
            if obj.objectType == "Class":
                # obj.name, obj.super, obj.lineno
                classItem = QtGui.QTreeWidgetItem()
                classItem.setText(0, obj.name)
                classItem.setIcon(0,
                                 QtGui.QIcon(os.path.join("Resources", "images", "class")))
                classItem.setForeground(0,
                                         QtGui.QBrush(QtGui.QColor("#FF0000")))
                classItem.setData(0, 3, obj.lineno)
                self.addTopLevelItem(classItem)
                classItem.setExpanded(True)

                methods = sorted(obj.methods.items(), key=itemgetter(1))
                for name, lineno in methods:
                    # obj.name, obj.lineno
                    functionItem = QtGui.QTreeWidgetItem(classItem)
                    functionItem.setText(0, name)
                    functionItem.setData(0, 3, lineno)
                    functionItem.setIcon(0,
                                        QtGui.QIcon(os.path.join("Resources", "images", "function")))
                    self.addTopLevelItem(functionItem)
            elif obj.objectType == "Function":
               # obj.name, obj.lineno
                functionItem = QtGui.QTreeWidgetItem()
                functionItem.setText(0, obj.name)
                functionItem.setData(0, 3, obj.lineno)
                functionItem.setIcon(0,
                                    QtGui.QIcon(os.path.join("Resources", "images", "function")))
                self.addTopLevelItem(functionItem)
            elif obj.objectType == "GlobalVariable":
               # obj.name, obj.lineno
                globalItem = QtGui.QTreeWidgetItem()
                globalItem.setText(0, obj.name)
                globalItem.setData(0, 3, obj.lineno)
                globalItem.setIcon(0,
                                    QtGui.QIcon(os.path.join("Resources", "images", "led")))
                self.addTopLevelItem(globalItem)

        if len(outlineDict) == 0:
            item = QtGui.QTreeWidgetItem()
            item.setText(0, "<Empty>")
            item.setFlags(QtCore.Qt.NoItemFlags)
            self.addTopLevelItem(item)
            item.setExpanded(True)

    def navigatorItemActivated(self):
        currentEditor = self.editorTabWidget.focusedEditor()
        item = self.selectedItems()[0]
        if item is None:
            selection = currentEditor.selectedItems()
            if len(selection) == 0:
                return
            else:
                item = selection[0]
        if item.data(0, 3) is None:
            return
        else:
            line = item.data(0, 3) - 1
            currentEditor.setSelection(line, 0, line,
                                       currentEditor.lineLength(line) - 1)
            currentEditor.setFirstVisibleLine(line)

########NEW FILE########
__FILENAME__ = pyclbr
"""
Class Outline based on the python 3 pyclbr
"""

import re
import io
import tokenize
from token import NAME, DEDENT, OP

_modules = {}
# cache of modules we've seen

spacesFirstWordRe = re.compile(r"^(\s*)(\w*)")
getSpacesFirstWord = lambda s, c=spacesFirstWordRe: c.match(s).groups()

# each Python class is represented by an instance of this class


class Class:

    '''Class to represent a Python class.'''

    def __init__(self, name, super, lineno):
        self.name = name
        if super is None:
            super = []
        self.super = super
        self.methods = {}
        self.lineno = lineno

        self.objectType = "Class"

    def _addmethod(self, name, lineno):
        self.methods[name] = lineno


class Function:

    '''Class to represent a top-level Python function'''

    def __init__(self, name, lineno):
        self.name = name
        self.lineno = lineno

        self.objectType = "Function"


class GlobalVariable:

    '''Class to represent a top-level Python global variable'''

    def __init__(self, name, lineno):
        self.name = name
        self.lineno = lineno

        self.objectType = "GlobalVariable"


def readmodule(source):

    res = {}
    for key, value in _readmodule(source).items():
        if isinstance(value, Class):
            res[key] = value
    return res


def _readmodule(source):
    outlineDict = {}

    f = io.StringIO(source)

    stack = []  # stack of (class, indent) pairs

    g = tokenize.generate_tokens(f.readline)
    try:
        for tokentype, token, start, _end, _line in g:
            if tokentype == DEDENT:
                lineno, thisindent = start
                # close nested classes and defs
                while stack and stack[-1][1] >= thisindent:
                    del stack[-1]
            elif token == 'def':
                lineno, thisindent = start
                # close previous nested classes and defs
                while stack and stack[-1][1] >= thisindent:
                    del stack[-1]
                tokentype, meth_name, start = next(g)[0:3]
                if tokentype != NAME:
                    continue  # Syntax error
                if stack:
                    cur_class = stack[-1][0]
                    if isinstance(cur_class, Class):
                        # it's a method
                        cur_class._addmethod(meth_name, lineno)
                    # else it's a nested def
                else:
                    # it's a function
                    outlineDict[meth_name] = Function(meth_name, lineno)
                stack.append((None, thisindent))  # Marker for nested fns
            elif token == 'class':
                lineno, thisindent = start
                # close previous nested classes and defs
                while stack and stack[-1][1] >= thisindent:
                    del stack[-1]
                tokentype, class_name, start = next(g)[0:3]
                if tokentype != NAME:
                    continue  # Syntax error
                # parse what follows the class name
                tokentype, token, start = next(g)[0:3]
                inherit = None
                if token == '(':
                    names = []  # List of superclasses
                    # there's a list of superclasses
                    level = 1
                    super = []  # Tokens making up current superclass
                    while True:
                        tokentype, token, start = next(g)[0:3]
                        if token in (')', ',') and level == 1:
                            n = "".join(super)
                            if n in outlineDict:
                                # we know this super class
                                n = outlineDict[n]
                            else:
                                c = n.split('.')
                                if len(c) > 1:
                                    # super class is of the form
                                    # module.class: look in module for
                                    # class
                                    m = c[-2]
                                    c = c[-1]
                                    if m in _modules:
                                        d = _modules[m]
                                        if c in d:
                                            n = d[c]
                            names.append(n)
                            super = []
                        if token == '(':
                            level += 1
                        elif token == ')':
                            level -= 1
                            if level == 0:
                                break
                        elif token == ',' and level == 1:
                            pass
                        # only use NAME and OP (== dot) tokens for type name
                        elif tokentype in (NAME, OP) and level == 1:
                            super.append(token)
                        # expressions in the base list are not supported
                    inherit = names
                cur_class = Class(class_name, inherit,
                                  lineno)
                if not stack:
                    outlineDict[class_name] = cur_class
                stack.append((cur_class, thisindent))
            elif token == '=':
                # get global variables
                spaces, firstword = getSpacesFirstWord(_line)
                if (len(spaces) == 0) and (_line.lstrip(spaces + firstword).lstrip().startswith('=')):
                    # it's a global variable
                    lineno, thisindent = start
                    outlineDict[firstword] = GlobalVariable(firstword, lineno)
    except:
        pass

    f.close()
    return outlineDict

########NEW FILE########
__FILENAME__ = PathLineEdit
import os
from PyQt4 import QtCore, QtGui


class PathLineEdit(QtGui.QLineEdit):

    def __init__(self, parent=None):
        super(PathLineEdit, self).__init__(parent)

        self.setTextMargins(0, 0, 42, 0)

        hbox = QtGui.QHBoxLayout()
        self.setLayout(hbox)
        hbox.setMargin(0)
        hbox.setSpacing(0)
        hbox.addStretch(1)

        self.fileButton = QtGui.QToolButton()
        self.fileButton.setToolTip("Insert File Path")
        self.fileButton.setAutoRaise(True)
        self.fileButton.setIcon(QtGui.QIcon(os.path.join("Resources", "images", "page")))
        self.fileButton.clicked.connect(self.insertFilePath)
        hbox.addWidget(self.fileButton)

        self.dirButton = QtGui.QToolButton()
        self.dirButton.setToolTip("Insert Directory Path")
        self.dirButton.setAutoRaise(True)
        self.dirButton.setIcon(QtGui.QIcon(os.path.join("Resources", "images", "folder_closed")))
        self.dirButton.clicked.connect(self.insertDirPath)
        hbox.addWidget(self.dirButton)

    def insertDirPath(self):
        directory = QtGui.QFileDialog.getExistingDirectory(
            self, QtCore.QDir.homePath())
        if directory:
            self.setText(os.path.normpath(directory))

    def insertFilePath(self):
        fileName = QtGui.QFileDialog.getOpenFileName(self,
                                                     "File", QtCore.QDir.homePath(),
                                                     "All Files (*)")
        if fileName:
            self.setText(os.path.normpath(fileName))

########NEW FILE########
__FILENAME__ = NewProjectDialog
import os
from PyQt4 import QtCore, QtGui


class GetPathLine(QtGui.QWidget):

    textChanged = QtCore.pyqtSignal(str)

    def __init__(self, useData, defaultText=None, parent=None):
        QtGui.QWidget.__init__(self, parent)

        self.useData = useData

        mainLayout = QtGui.QHBoxLayout()
        mainLayout.setMargin(0)
        self.setLayout(mainLayout)

        self.locationLine = QtGui.QLineEdit()
        if defaultText is not None:
            self.locationLine.setText(defaultText)
        self.locationLine.textChanged.connect(self.textChanged.emit)
        mainLayout.addWidget(self.locationLine)

        self.browseButton = QtGui.QPushButton('...')
        self.browseButton.clicked.connect(self.browsePath)
        mainLayout.addWidget(self.browseButton)

    def browsePath(self):
        directory = QtGui.QFileDialog.getExistingDirectory(
            self, "Select Folder",
            self.useData.getLastOpenedDir())
        if directory:
            self.useData.saveLastOpenedDir(directory)
            self.locationLine.setText(os.path.normpath(directory))

    def text(self):
        return self.locationLine.text()


class NewProjectDialog(QtGui.QDialog):

    projectDataReady = QtCore.pyqtSignal(dict)

    def __init__(self, useData, parent=None):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle('New Project')
        self.resize(500, 100)

        self.useData = useData

        mainLayout = QtGui.QVBoxLayout()
        self.setLayout(mainLayout)

        form = QtGui.QFormLayout()

        self.nameLine = QtGui.QLineEdit()
        self.nameLine.setText("PythonApp")
        self.nameLine.textChanged.connect(self.validateFields)
        form.addRow("Name: ", self.nameLine)

        self.typeBox = QtGui.QComboBox()
        self.typeBox.addItem("Desktop Application")
        self.typeBox.addItem("Python Package")
        self.typeBox.currentIndexChanged.connect(self.showWindowTypeBox)
        form.addRow("Type: ", self.typeBox)

        self.windowTypeBox = QtGui.QComboBox()
        self.windowTypeBox.addItem("GUI")
        self.windowTypeBox.addItem("Console")
        form.addRow('', self.windowTypeBox)

        self.destinationBox = GetPathLine(
            self.useData, self.useData.appPathDict["projectsdir"])
        self.destinationBox.textChanged.connect(self.validateFields)
        form.addRow("Destination: ", self.destinationBox)

        self.sourcesLine = GetPathLine(self.useData)
        self.sourcesLine.textChanged.connect(self.validateFields)
        form.addRow("Import Sources: ", self.sourcesLine)

        mainLayout.addLayout(form)
        mainLayout.addStretch(1)

        hbox = QtGui.QHBoxLayout()
        hbox.addStretch(1)

        self.okButton = QtGui.QPushButton("Ok")
        self.okButton.clicked.connect(self.sendData)
        hbox.addWidget(self.okButton)

        self.cancelButton = QtGui.QPushButton("Cancel")
        self.cancelButton.clicked.connect(self.close)
        hbox.addWidget(self.cancelButton)

        self.helpButton = QtGui.QPushButton("Help")
        hbox.addWidget(self.helpButton)

        mainLayout.addLayout(hbox)

        self.validateFields()

    def showWindowTypeBox(self):
        if self.typeBox.currentText() == "Desktop Application":
            self.windowTypeBox.show()
        else:
            self.windowTypeBox.hide()

    def validateFields(self):
        self.projectName = self.nameLine.text().strip()
        self.projectLocation = self.destinationBox.text().strip()
        self.importPath = self.sourcesLine.text().strip()
        if self.projectName == '':
            self.okButton.setDisabled(True)
            return
        elif self.projectLocation == '':
            self.okButton.setDisabled(True)
            return
        if os.path.exists(self.projectLocation) is False:
            self.okButton.setDisabled(True)
            return
        if self.importPath != '':
            if os.path.exists(self.importPath) is False:
                self.okButton.setDisabled(True)
                return
        if os.path.exists(os.path.join(self.projectLocation, self.projectName)):
            self.okButton.setDisabled(True)
            return
        self.okButton.setDisabled(False)

    def sendData(self):
        if self.typeBox.currentText() == "Desktop Application":
            mainScript = self.nameLine.text() + '.py'
        elif self.typeBox.currentText() == "Python Package":
            mainScript = "__init__.py"
        data = {
            "mainscript": mainScript,
            "name": self.projectName,
            "type": self.typeBox.currentText(),
            "windowtype": self.windowTypeBox.currentText(),
            "location": self.projectLocation,
            "importdir": self.importPath
            }
        self.close()
        self.projectDataReady.emit(data)

########NEW FILE########
__FILENAME__ = Build
import os
import sys
import traceback
import logging
import cx_Freeze
from cx_Freeze import Freezer
from PyQt4 import QtCore, QtGui


class Metadata(object):
    def __init__(self):
        object.__init__(self)


class BuildThread(QtCore.QThread):
    def run(self):
        self.error = None

        metadata = Metadata()
        metadata.version = self.profile["version"]
        metadata.long_description = self.profile["comments"]
        metadata.description = self.profile["description"]
        metadata.author = self.profile["author"]
        metadata.name = self.profile["name"]

        if self.profile["base"] == "Console":
            base = "ConsoleKeepPath"
        else:
            base = "Win32GUI"
        initScript = None

        if self.profile["icon"] in os.listdir(self.projectPathDict['iconsdir']):
            iconPath = os.path.join(self.projectPathDict['iconsdir'], self.profile["icon"])
        else:
            iconPath = None

        if self.profile["compress"] == 'Compress':
            compress = True
        else:
            compress = False

        if self.profile["optimize"] == "Don't Optimize":
            optimizeFlag = 0
        elif self.profile["optimize"] == 'Optimize':
            optimizeFlag = 1
        elif self.profile["optimize"] == "Optimize (Remove Doc Strings)":
            optimizeFlag = 2

        if self.profile["copydeps"] == 'Copy Dependencies':
            copyDependentFiles = True
        else:
            copyDependentFiles = False

        if self.profile["appendscripttoexe"] == 'Append Script to Exe':
            appendScriptToExe = True
        else:
            appendScriptToExe = False

        if self.profile["appendscripttolibrary"] == 'Append Script to Library':
            appendScriptToLibrary = True
        else:
            appendScriptToLibrary = False

        includes = self.profile["Includes"]
        excludes = self.profile["Excludes"]
        replacePaths = self.profile["Replace Paths"]
        binIncludes = self.profile["Bin Includes"]
        binExcludes = self.profile["Bin Excludes"]
        binPathIncludes = self.profile["Bin Path Includes"]
        binPathExcludes = self.profile["Bin Path Excludes"]
        includeFiles = self.profile["Include Files"]
        zipIncludes = self.profile["Zip Includes"]
        namespacePackages = self.profile["Namespace Packages"]
        constantsModules = self.profile["Constants Modules"]
        packages = self.profile["Packages"]

        try:
            executables = [cx_Freeze.Executable(
                           self.projectPathDict['mainscript'],
                           icon=iconPath,
                           targetDir=self.projectPathDict['builddir'],
                           initScript=initScript,
                           base=base)]
            if self.projectSettings["UseVirtualEnv"] == "True":
                venv_path = self.projectPathDict["venvdir"]
                path = [self.projectPathDict['sourcedir'],
                        os.path.join(venv_path, "Scripts"),
                        os.path.join(venv_path, "Lib"),
                        os.path.join(venv_path, "Lib", "site-packages"),
                        os.path.join(venv_path, "Include")]
            else:
                py_path = os.path.dirname(self.projectSettings["DefaultInterpreter"])
                path = [self.projectPathDict['sourcedir'],
                        py_path,
                        os.path.join(py_path, "DLLs"),
                        os.path.join(py_path, "libs"),
                        os.path.join(py_path, "Lib"),
                        os.path.join(py_path, "Lib", "site-packages"),
                        os.path.join(py_path, "include")]
            extraPathList = []
            for i in path:
                extraPathList.extend(self.pathListFromDir(i))
            path.extend(extraPathList)
            
            freezer = Cx_Freeze(executables,
                                self.projectPathDict,
                                self.useData,
                                base=base,
                                icon=iconPath,
                                metadata=metadata,
                                initScript=initScript,
                                path=path,
                                compress=compress,
                                optimizeFlag=optimizeFlag,
                                copyDependentFiles=copyDependentFiles,
                                appendScriptToExe=appendScriptToExe,
                                appendScriptToLibrary=appendScriptToLibrary,
                                includes=includes,
                                excludes=excludes,
                                replacePaths=replacePaths,
                                binIncludes=binIncludes,
                                binExcludes=binExcludes,
                                binPathIncludes=binPathIncludes,
                                binPathExcludes=binPathExcludes,
                                includeFiles=includeFiles,
                                zipIncludes=zipIncludes,
                                namespacePackages=namespacePackages,
                                constantsModules=constantsModules,
                                packages=packages)
            freezer.Freeze()

            badModules = freezer.finder._badModules
            names = list(badModules.keys())
            names.sort()
            self.missing = []
            for name in names:
                callers = list(badModules[name].keys())
                callers.sort()
                self.missing.append("? {0} imported from {1}".format
                                   (name, ", ".join(callers)))
        except Exception as err:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                                      exc_traceback)))
            self.error = str(err)
            
    def pathListFromDir(self, dirPath):
        """
        This is to get the list of module search paths from .pth files
        """
        pathList = []
        for i in  os.listdir(dirPath):
            path = os.path.join(dirPath, i)
            if os.path.isfile(path):
                if i.endswith('.pth'):
                    file = open(path, 'r')
                    lines = file.readlines()
                    file.close()
                    for line in lines:
                        lineText = line.rstrip()
                        if os.path.exists(lineText):
                            pathList.append(lineText)
                        else:
                            fullPath = os.path.join(dirPath, lineText)
                            if os.path.exists(fullPath):
                                pathList.append(fullPath)
                                
        return pathList

    def build(self, profile, projectPathDict, projectSettings, useData):
        self.profile = profile
        self.projectPathDict = projectPathDict
        self.useData = useData
        self.projectSettings = projectSettings

        self.start()


class Cx_Freeze(Freezer):
    def __init__(self, executables,
                 projectPathDict,
                 useData,
                 base,
                 icon,
                 metadata,
                 initScript,
                 path,
                 compress,
                 optimizeFlag,
                 copyDependentFiles,
                 appendScriptToExe,
                 appendScriptToLibrary,
                 includes,
                 excludes,
                 replacePaths,
                 binIncludes,
                 binExcludes,
                 binPathIncludes,
                 binPathExcludes,
                 includeFiles,
                 zipIncludes,
                 namespacePackages,
                 constantsModules,
                 packages):
        Freezer.__init__(self, executables,
                         silent=True,
                         icon=icon,
                         metadata=metadata,
                         includeMSVCR=True,
                         targetDir=projectPathDict['builddir'],
                         initScript=initScript,
                         path=path,
                         base=base,
                         compress=compress,
                         optimizeFlag=optimizeFlag,
                         copyDependentFiles=copyDependentFiles,
                         appendScriptToExe=appendScriptToExe,
                         appendScriptToLibrary=appendScriptToLibrary,
                         includes=includes,
                         excludes=excludes,
                         replacePaths=replacePaths,
                         binIncludes=binIncludes,
                         binExcludes=binExcludes,
                         binPathIncludes=binPathIncludes,
                         binPathExcludes=binPathExcludes,
                         includeFiles=includeFiles,
                         zipIncludes=zipIncludes,
                         namespacePackages=namespacePackages,
                         constantsModules=constantsModules,
                         packages=packages
                         )


class Build(QtGui.QWidget):
    def __init__(self, busyWidget, messagesWidget, projectPathDict, projectSettings, useData,
                 buildConfig, editorTabWidget, parent=None):
        QtGui.QWidget.__init__(self, parent)

        self.useData = useData
        self.projectPathDict = projectPathDict
        self.buildConfig = buildConfig
        self.projectSettings = projectSettings

        self.messagesWidget = messagesWidget
        self.busyWidget = busyWidget
        self.editorTabWidget = editorTabWidget
        self.busyWidget.cancel.connect(self.cancelBuild)

        self.buildThread = BuildThread()
        self.buildThread.finished.connect(self.buildFinished)

        self.durationTime = QtCore.QTime()

    def openDir(self):
        if os.path.exists(self.projectPathDict["builddir"]) == True:
            os.startfile(self.projectPathDict["builddir"], 'explore')
        else:
            message = QtGui.QMessageBox.critical(self, "Open",
                                                 "Build folder is missing!")

    def cancelBuild(self):
        self.buildThread.exit()

    def build(self):
        saved = self.editorTabWidget.saveProject()
        if saved:
            profile = self.buildConfig.load()
            self.durationTime.start()
            self.buildThread.build(profile, self.projectPathDict, self.projectSettings, self.useData)
            self.busyWidget.showBusy(True)

    def buildFinished(self):
        elapsed = self.durationTime.elapsed()
        if elapsed >= 60000:
            min = int(elapsed / 60000)
            sec = int((elapsed - (60000 * min)) / 1000)
            elapsed = "{0}m{1}s".format(str(min), str(sec))
        else:
            elapsed = str(round(elapsed / 1000, 1)) + 's'
        self.busyWidget.showBusy(False)
        if self.buildThread.error:
            self.messagesWidget.addMessage(
                1, "Build Completed in {0} [Errors]".format(str(elapsed)), 
                    [self.buildThread.error])
        else:
            if len(self.buildThread.missing) > 0:
                self.messagesWidget.addMessage(
                    1, "Build Completed in {0} [missing modules]".format(elapsed), 
                        self.buildThread.missing)
            else:
                self.messagesWidget.addMessage(
                    0, "Build Completed in {0} ".format(elapsed), 
                        ["Build Completed Successfully!"])

########NEW FILE########
__FILENAME__ = ConfigureProject
import os
import sys
import shutil

from PyQt4 import QtCore, QtGui, QtXml

from Extensions.Projects.ProjectManager.ProjectView.ProjectView import IconProvider
from venv import EnvBuilder

from Extensions import StyleSheet

class SelectBox(QtGui.QDialog):

    def __init__(self, caption, itemsList, parent=None):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle(caption)

        mainLayout = QtGui.QVBoxLayout()

        self.itemBox = QtGui.QComboBox()
        self.itemBox.addItem()
        for i in itemsList:
            self.itemBox.addItems(itemsList)
        self.itemBox.currentIndexChanged.connect(self.enableAcceptButton)
        mainLayout.addWidget(self.itemBox)

        hbox = QtGui.QHBoxLayout()

        hbox.addStretch(1)

        self.acceptButton = QtGui.QPushButton("Ok")
        self.acceptButton.setDisabled(True)
        self.acceptButton.clicked.connect(self.accept)
        hbox.addWidget(self.acceptButton)

        self.cancelButton = QtGui.QPushButton("Cancel")
        self.cancelButton.clicked.connect(self.cancel)
        hbox.addWidget(self.cancelButton)

        mainLayout.addLayout(hbox)

        self.setLayout(mainLayout)

        self.resize(400, 20)
        self.enableAcceptButton()

        self.exec_()

    def enableAcceptButton(self):
        if self.itemBox.currentIndex() == 0:
            self.acceptButton.setDisabled(True)
        else:
            self.acceptButton.setDisabled(False)

    def accept(self):
        self.accepted = True
        self.item = self.itemBox.currentText()
        self.close()

    def cancel(self):
        self.accepted = False
        self.close()


class GetText(QtGui.QDialog):

    def __init__(self, caption, format, parent=None):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle(caption)

        mainLayout = QtGui.QVBoxLayout()

        mainLayout.addWidget(QtGui.QLabel(format))

        self.nameLine = QtGui.QLineEdit()
        self.nameLine.selectAll()
        self.nameLine.textChanged.connect(self.enableAcceptButton)
        mainLayout.addWidget(self.nameLine)

        hbox = QtGui.QHBoxLayout()

        self.statusLabel = QtGui.QLabel()
        hbox.addWidget(self.statusLabel)

        hbox.addStretch(1)

        self.acceptButton = QtGui.QPushButton("Ok")
        self.acceptButton.setDisabled(True)
        self.acceptButton.clicked.connect(self.accept)
        hbox.addWidget(self.acceptButton)

        self.cancelButton = QtGui.QPushButton("Cancel")
        self.cancelButton.clicked.connect(self.cancel)
        hbox.addWidget(self.cancelButton)

        mainLayout.addLayout(hbox)

        self.setLayout(mainLayout)

        self.resize(400, 20)
        self.enableAcceptButton()

        self.exec_()

    def enableAcceptButton(self):
        text = self.nameLine.text().strip()
        if text == '':
            self.acceptButton.setDisabled(True)
        else:
            self.acceptButton.setDisabled(False)

    def accept(self):
        self.accepted = True
        self.text = self.nameLine.text().strip()
        self.close()

    def cancel(self):
        self.accepted = False
        self.close()


class RopeConfig(QtGui.QWidget):

    def __init__(self, projectPathDict, useData, parent=None):
        QtGui.QWidget.__init__(self, parent)

        mainLayout = QtGui.QVBoxLayout()
        self.setLayout(mainLayout)

        self.ignoreSyntaxErrorsBox = QtGui.QComboBox()
        self.ignoreSyntaxErrorsBox.addItem("Ignore Syntax Errors")
        self.ignoreSyntaxErrorsBox.addItem("Don't Ignore Syntax Errors")
#        self.ignoreSyntaxErrorsBox.setCurrentIndex(
# self.ignoreSyntaxErrorsBox.findText(profileData["appendscripttolibrary"]))
        mainLayout.addWidget(self.ignoreSyntaxErrorsBox)

        self.ignoreBadImportsBox = QtGui.QComboBox()
        self.ignoreBadImportsBox.addItem("Ignore Bad Imports")
        self.ignoreBadImportsBox.addItem("Don't Ignore Bad Imports")
#        self.ignoreBadImportsBox.setCurrentIndex(
# self.ignoreBadImportsBox.findText(profileData["appendscripttolibrary"]))
        mainLayout.addWidget(self.ignoreBadImportsBox)

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        hbox.addWidget(QtGui.QLabel("Max History Items: "))
        self.maxHistoryBox = QtGui.QSpinBox()
        hbox.addWidget(self.maxHistoryBox)

        frame = QtGui.QFrame()
        frame.setGeometry(1, 1, 1, 2)
        frame.setFrameShape(frame.HLine)
        frame.setFrameShadow(frame.Sunken)
        mainLayout.addWidget(frame)

        self.listSelectorBox = QtGui.QComboBox()
        self.listSelectorBox.addItem("Extensions")
        self.listSelectorBox.addItem("Ignored Resources")
        self.listSelectorBox.addItem("Custom Folders")
#        self.listSelectorBox.activated.connect(self.viewList)
#        self.listSelectorBox.currentIndexChanged.connect(self.viewList)
        mainLayout.addWidget(self.listSelectorBox)

        self.listWidget = QtGui.QListWidget()
        mainLayout.addWidget(self.listWidget)

        self.helpDict = {
            "Extensions": "Specify which files should be considered python files.",
            "Ignored Resources": "Specify which files and folders to ignore in the project.",
            "Custom Folders": (
                "By default rope searches the project for finding source folders\n"
                "(folders that should be searched for finding modules).\n"
                "You can add paths to that list. Note that rope guesses project \n"
                "source folders correctly most of the time; use this if you have \n"
                "any problems.\n"
                "The folders should be relative to project root and use '/' for\n"
                "separating folders regardless of the platform rope is running on.\n"
                "src/my_source_folder' for instance."
                )
            }

        self.docLabel = QtGui.QLabel()
        self.docLabel.setWordWrap(True)
        mainLayout.addWidget(self.docLabel)

        hbox = QtGui.QHBoxLayout()
        hbox.addStretch(1)
        mainLayout.addLayout(hbox)

        self.addButton = QtGui.QPushButton()
        self.addButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "add")))
#        self.addButton.clicked.connect(self.appendToList)
        hbox.addWidget(self.addButton)

        self.removeButton = QtGui.QPushButton()
        self.removeButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "minus")))
#        self.removeButton.clicked.connect(self.removeItem)
        hbox.addWidget(self.removeButton)

        hbox.addStretch(1)

    def save(self):
        fileName = self.projectPathDict["ropeprofile"]

        dom_document = QtXml.QDomDocument("rope_profile")

        main_data = dom_document.createElement("rope")
        dom_document.appendChild(main_data)

        root = dom_document.createElement("ignoresyntaxerrors")
        attrib = dom_document.createTextNode(
            self.ignoreSyntaxErrorsBox.currentText())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("ignorebadimports")
        attrib = dom_document.createTextNode(
            self.ignoreBadImportsBox.currentText())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("maxhistoryitems")
        attrib = dom_document.createTextNode(str(self.maxHistoryBox.value()))
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("Extensions")
        main_data.appendChild(root)

        defExt = ['*.py', '*.pyw']
        for i in defExt:
            tag = dom_document.createElement("item")
            root.appendChild(tag)

            t = dom_document.createTextNode(i)
            tag.appendChild(t)

        root = dom_document.createElement("IgnoredResources")
        main_data.appendChild(root)

        defIgnore = ["*.pyc", "*~", ".ropeproject",
                     ".hg", ".svn", "_svn", ".git", "__pycache__"]
        for i in defIgnore:
            tag = dom_document.createElement("item")
            root.appendChild(tag)

            t = dom_document.createTextNode(i)
            tag.appendChild(t)

        root = dom_document.createElement("CustomFolders")
        main_data.appendChild(root)

        file = open(fileName, "w")
        file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
        file.write(dom_document.toString())
        file.close()


class VenvSetup(QtGui.QWidget):

    def __init__(self, projectPathDict, projectSettings, useData, parent=None):
        QtGui.QWidget.__init__(self, parent)

        self.projectPathDict = projectPathDict
        self.useData = useData
        self.projectSettings = projectSettings

        mainLayout = QtGui.QVBoxLayout()
        self.setLayout(mainLayout)

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        hbox.addWidget(QtGui.QLabel("Version: "))

        self.currentVersionLabel = QtGui.QLabel()
        hbox.addWidget(self.currentVersionLabel)

        self.openButton = QtGui.QPushButton("Open")
        self.openButton.clicked.connect(self.openVenv)
        hbox.addWidget(self.openButton)

        hbox.setStretch(1, 1)

        self.treeView = QtGui.QTreeView()

        self.iconProvider = IconProvider()

        self.treeView.setModel(self.newFileSystemModel())
        self.treeView.setColumnWidth(0, 300)
        mainLayout.addWidget(self.treeView)

        self.packagesPath = os.path.join(
            self.projectPathDict["venvdir"], "Lib", "site-packages")
        if os.path.exists(self.projectPathDict["venvdir"]):
            self.currentVersionLabel.setText(self.setVesionFromVenv())
            self.treeView.setRootIndex(
                self.treeView.model().index(self.packagesPath))

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        self.installVenvButton = QtGui.QPushButton("Install")
        self.installVenvButton.clicked.connect(self.install)
        hbox.addWidget(self.installVenvButton)

        self.upgradeVenvButton = QtGui.QPushButton("Upgrade")
        self.upgradeVenvButton.clicked.connect(self.upgrade)
        hbox.addWidget(self.upgradeVenvButton)

        self.uninstallVenvButton = QtGui.QPushButton("Uninstall")
        self.uninstallVenvButton.clicked.connect(self.uninstall)
        hbox.addWidget(self.uninstallVenvButton)

    def openVenv(self):
        if os.path.exists(self.projectPathDict["venvdir"]):
            os.startfile(self.projectPathDict["venvdir"])

    def setVesionFromVenv(self):
        path = os.path.join(self.projectPathDict["venvdir"], 'pyvenv.cfg')
        tempList = []
        file = open(path, 'r')
        for i in file.readlines():
            v = i.strip()
            if v == '':
                pass
            else:
                tempList.append(tuple(v.split(' = ')))
        file.close()
        settings = dict(tempList)
        return settings['version']

    def newFileSystemModel(self):
        fileSystemModel = QtGui.QFileSystemModel()
        fileSystemModel.setRootPath(QtCore.QDir.rootPath())
        fileSystemModel.setNameFilterDisables(False)
        fileSystemModel.setIconProvider(self.iconProvider)

        return fileSystemModel

    def install(self):
        if os.path.exists(self.projectPathDict["venvdir"]):
            message = QtGui.QMessageBox.information(
                self, "Install", "Virtual environment already installed.")
            return
        reply = QtGui.QMessageBox.warning(self, "Install",
                                         "This will install a new virtual environment.\n\nProceed?",
                                         QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            if len(self.useData.SETTINGS["InstalledInterpreters"]) == 0:
                message = QtGui.QMessageBox.information(
                    self, "Install", "There is no Python installation to install against.\n\nPlease make sure Python is installed.")
                return
            if len(self.useData.SETTINGS["InstalledInterpreters"]) == 1:
                pythonPath = self.useData.SETTINGS["InstalledInterpreters"][0]
            else:
                pythonPath = SelectBox(
                    "Choose Python installation", self.useData.SETTINGS["InstalledInterpreters"], self)
                if pythonPath.accepted:
                    pythonPath = pythonPath.item
                else:
                    return
            try:
                builder = EnvBuilder(pythonPath)
                builder.create(self.projectPathDict["venvdir"])
                self.treeView.setModel(self.newFileSystemModel())
                self.treeView.setRootIndex(
                    self.treeView.model().index(self.packagesPath))
                self.currentVersionLabel.setText(self.setVesionFromVenv())

                message = QtGui.QMessageBox.information(
                    self, "Install", "Install virtual environment completed.")
            except Exception as err:
                message = QtGui.QMessageBox.warning(
                    self, "Failed Install", str(err))
        else:
            return

    def upgrade(self):
        if not os.path.exists(self.projectPathDict["venvdir"]):
            message = QtGui.QMessageBox.information(
                self, "Install", "No virtual environment to upgrade.")
            return
        reply = QtGui.QMessageBox.warning(self, "Install",
                                         "This will upgrade the current the virtual environment.\n\nProceed?",
                                         QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            if len(self.useData.SETTINGS["InstalledInterpreters"]) == 0:
                message = QtGui.QMessageBox.information(
                    self, "Install", "There is no Python installation to install against.\n\nPlease make sure Python is installed.")
                return
            if len(self.useData.SETTINGS["InstalledInterpreters"]) == 1:
                pythonPath = self.useData.SETTINGS["InstalledInterpreters"][0]
            else:
                pythonPath = SelectBox(
                    "Choose Python installation", self.useData.SETTINGS["InstalledInterpreters"], self)
                if pythonPath.accepted:
                    pythonPath = pythonPath.item
                else:
                    return
            try:
                builder = EnvBuilder(pythonPath, upgrade=True)
                builder.create(self.projectPathDict["venvdir"])
                self.treeView.setModel(self.newFileSystemModel())
                self.treeView.setRootIndex(
                    self.treeView.model().index(self.packagesPath))
                self.currentVersionLabel.setText(self.setVesionFromVenv())
                message = QtGui.QMessageBox.information(
                    self, "Upgrade", "Upgrade virtual environment completed.")
            except Exception as err:
                message = QtGui.QMessageBox.warning(
                    self, "Failed Upgrade", str(err))
        else:
            return

    def uninstall(self):
        if not os.path.exists(self.projectPathDict["venvdir"]):
            message = QtGui.QMessageBox.information(
                self, "Uninstall", "No virtual environment to uninstall.")
            return
        reply = QtGui.QMessageBox.warning(self, "Uninstall",
                                         "This will uninstall the current virtual environment.\n\nProceed?",
                                         QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            try:
                self.treeView.setModel(self.newFileSystemModel())
                if os.path.exists(self.projectPathDict["venvdir"]):
                    shutil.rmtree(self.projectPathDict["venvdir"])
                self.currentVersionLabel.clear()
                message = QtGui.QMessageBox.information(
                    self, "Uninstall", "Uninstall virtual environment completed.")
            except Exception as err:
                message = QtGui.QMessageBox.warning(
                    self, "Failed Uninstall", str(err))
        else:
            return


class BuildConfig(QtGui.QWidget):

    def __init__(self, projectPathDict, useData, parent=None):
        QtGui.QWidget.__init__(self, parent)

        self.projectPathDict = projectPathDict
        self.useData = useData
        
        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setMargin(0)
        self.setLayout(mainLayout)

        self.lists = {"Includes": [],
                      "Excludes": [],
                      "Constants Modules": [],
                      "Packages": [],
                      "Replace Paths": [],
                      "Bin Includes": [],
                      "Bin Excludes": [],
                      "Bin Path Includes": [],
                      "Bin Path Excludes": [],
                      "Zip Includes": [],
                      "Include Files": [],
                      "Namespace Packages": []}

        self.profileData = self.load()
        
        self.tabWidget = QtGui.QTabWidget()
        self.tabWidget.setObjectName("buildTab")
        mainLayout.addWidget(self.tabWidget)

        versionWidget = QtGui.QWidget()
        self.tabWidget.addTab(versionWidget,
                        QtGui.QIcon(os.path.join("Resources", "images", "arrow-045")),
                            "Version Information")

        versionLayout = QtGui.QFormLayout()
        versionWidget.setLayout(versionLayout)

        self.itemLine = QtGui.QLineEdit()
        self.itemLine.setText(self.profileData["name"])
        versionLayout.addRow("Name", self.itemLine)

        self.authorLine = QtGui.QLineEdit()
        self.authorLine.setText(self.profileData["author"])
        versionLayout.addRow("Author", self.authorLine)

        self.versionLine = QtGui.QLineEdit()
        self.versionLine.setText(self.profileData["version"])
        versionLayout.addRow("Version", self.versionLine)

        self.descriptionLine = QtGui.QLineEdit()
        self.descriptionLine.setText(self.profileData["description"])
        versionLayout.addRow("Description", self.descriptionLine)

        self.commentsLine = QtGui.QLineEdit()
        self.commentsLine.setText(self.profileData["comments"])
        versionLayout.addRow("Comments", self.commentsLine)

        self.companyLine = QtGui.QLineEdit()
        self.companyLine.setText(self.profileData["company"])
        versionLayout.addRow("Company", self.companyLine)

        self.copyrightLine = QtGui.QLineEdit()
        self.copyrightLine.setText(self.profileData["copyright"])
        versionLayout.addRow("Copyright", self.copyrightLine)

        self.trademarksLine = QtGui.QLineEdit()
        versionLayout.addRow("Trademarks", self.trademarksLine)

        self.productLine = QtGui.QLineEdit()
        self.productLine.setText(self.profileData["product"])
        versionLayout.addRow("Product", self.productLine)

        #-------------------------------------------------------------------

        optionsWidget = QtGui.QWidget()
        self.tabWidget.addTab(optionsWidget, QtGui.QIcon(
            os.path.join("Resources", "images", "arrow-045")), "Options")

        optionsLayout = QtGui.QFormLayout()
        optionsWidget.setLayout(optionsLayout)

        self.optimizeBox = QtGui.QComboBox()
        self.optimizeBox.addItem("Don't Optimize")
        self.optimizeBox.addItem("Optimize")
        self.optimizeBox.addItem("Optimize (Remove Doc Strings)")
        self.optimizeBox.setCurrentIndex(
            self.optimizeBox.findText(self.profileData["optimize"]))
        optionsLayout.addRow('', self.optimizeBox)

        self.compressBox = QtGui.QComboBox()
        self.compressBox.addItem("Compress")
        self.compressBox.addItem("Don't Compress")
        optionsLayout.addRow('',  self.compressBox)

        self.copyDepsBox = QtGui.QComboBox()
        self.copyDepsBox.addItem("Copy Dependencies")
        self.copyDepsBox.addItem("Don't Copy Dependencies")
        self.copyDepsBox.setCurrentIndex(
            self.copyDepsBox.findText(self.profileData["copydeps"]))
        optionsLayout.addRow('', self.copyDepsBox)

        self.appendScriptToExeBox = QtGui.QComboBox()
        self.appendScriptToExeBox.addItem("Append Script to Exe")
        self.appendScriptToExeBox.addItem("Don't Append Script to Exe")
        self.appendScriptToExeBox.setCurrentIndex(
            self.appendScriptToExeBox.findText(self.profileData["appendscripttoexe"]))
        optionsLayout.addRow('', self.appendScriptToExeBox)

        self.appendScriptToLibraryBox = QtGui.QComboBox()
        self.appendScriptToLibraryBox.addItem("Append Script to Library")
        self.appendScriptToLibraryBox.addItem("Don't Append Script to Library")
        self.appendScriptToLibraryBox.setCurrentIndex(
            self.appendScriptToLibraryBox.findText(self.profileData["appendscripttolibrary"]))
        optionsLayout.addRow('', self.appendScriptToLibraryBox)

        self.windowTypeBox = QtGui.QComboBox()
        self.windowTypeBox.addItem("GUI")
        self.windowTypeBox.addItem("Console")
        if self.profileData["base"] == "Win32GUI.exe":
            self.windowTypeBox.setCurrentIndex(0)
        elif self.profileData["base"] == "Console.exe":
            self.windowTypeBox.setCurrentIndex(1)
        optionsLayout.addRow("Window Type", self.windowTypeBox)

        hbox = QtGui.QHBoxLayout()
        self.iconBox = QtGui.QComboBox()
        self.updateIconBox()
        f = self.iconBox.findText(self.profileData["icon"])
        if f != -1:
            self.iconBox.setCurrentIndex(f)
        hbox.addWidget(self.iconBox)

        self.addButton = QtGui.QToolButton()
        self.addButton.setAutoRaise(True)
        self.addButton.setToolTip("Add")
        self.addButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "add")))
        self.addButton.clicked.connect(self.addIcon)
        hbox.addWidget(self.addButton)

        self.removeButton = QtGui.QToolButton()
        self.removeButton.setAutoRaise(True)
        self.removeButton.setToolTip("Remove")
        self.removeButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "minus")))
        self.removeButton.clicked.connect(self.removeIcon)
        hbox.addWidget(self.removeButton)

        optionsLayout.addRow("Icon", hbox)

        #-------------------------------------------------------------------

        advancedWidget = QtGui.QWidget()
        self.tabWidget.addTab(advancedWidget, QtGui.QIcon(
            os.path.join("Resources", "images", "arrow-045")), "Advanced")

        advancedLayout = QtGui.QVBoxLayout()
        advancedWidget.setLayout(advancedLayout)

        self.listSelectorBox = QtGui.QComboBox()
        for i in self.lists:
            self.listSelectorBox.addItem(i)
        self.listSelectorBox.activated.connect(self.viewList)
        self.listSelectorBox.currentIndexChanged.connect(self.viewList)
        advancedLayout.addWidget(self.listSelectorBox)

        self.listWidget = QtGui.QListWidget()
        advancedLayout.addWidget(self.listWidget)

        self.helpDict = {
            "Includes": "List of modules to include",
            "Excludes": "List of modules to exclude",
            "Constants Modules": "List of constants to include",
            "Packages": "List of packages to include",
            "Replace Paths": (
                "Replace all the paths in modules found in the given paths "
                "with the given replacement string; each value "
                "is of the form path=replacement_string; path can be * "
                "which means all paths not already specified"),
            "Include Files": "List of files to include",
            "Zip Includes": (
                "Name of file to add to the zip file or a specification of "
                "the form name=arcname which will specify the archive name "
                "to use"),
            "Namespace Packages": "List of packages to include",
            "Bin Includes": (
                "Libraries that need not be included because"
                "they would normally be expected to be found on the target system or"
                "because they are part of a package which requires independent"
                "installation anyway."),
            "Bin Excludes": (
                "File names of libraries which must be included for the"
                "frozen executable to work."),
            "Bin Path Includes": (
                "Paths of directories which contain files that should "
                "be included."),
            "Bin Path Excludes": (
                "Paths of directories which contain files that should not"
                "be included, generally because they contain standard system libraries."),
            }

        hbox = QtGui.QHBoxLayout()
        advancedLayout.addLayout(hbox)

        self.itemLine = QtGui.QLineEdit()
        self.itemLine.selectAll()
        self.itemLine.textChanged.connect(self.enableAddButton)
        hbox.addWidget(self.itemLine)

        self.addButton = QtGui.QPushButton()
        self.addButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "add")))
        self.addButton.clicked.connect(self.appendToList)
        hbox.addWidget(self.addButton)

        self.removeButton = QtGui.QPushButton()
        self.removeButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "minus")))
        self.removeButton.clicked.connect(self.removeItem)
        hbox.addWidget(self.removeButton)
        self.enableAddButton()

        self.docLabel = QtGui.QLabel()
        self.docLabel.setWordWrap(True)
        advancedLayout.addWidget(self.docLabel)

        self.viewList()
        
        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        self.saveButton = QtGui.QPushButton("Save")
        self.saveButton.clicked.connect(self.save)
        hbox.addWidget(self.saveButton)

    def updateIconBox(self):
        self.iconBox.clear()
        for i in os.listdir(self.projectPathDict['iconsdir']):
            path = os.path.join(self.projectPathDict['iconsdir'], i)
            self.iconBox.addItem(QtGui.QIcon(path), i)

    def enableAddButton(self):
        text = self.itemLine.text().strip()
        if text == '':
            self.addButton.setDisabled(True)
        elif text in self.lists[self.listSelectorBox.currentText()]:
            self.addButton.setDisabled(True)
        else:
            self.addButton.setDisabled(False)

    def viewList(self):
        self.docLabel.setText(self.helpDict[
                              self.listSelectorBox.currentText()])
        self.listWidget.clear()
        for i in self.lists[self.listSelectorBox.currentText()]:
            self.listWidget.addItem(QtGui.QListWidgetItem(i))

    def updateList(self):
        itemsList = []
        for i in range(self.listWidget.count()):
            item = self.listWidget.item(i)
            itemsList.append(item.text())
        self.lists[self.listSelectorBox.currentText()] = itemsList

    def appendToList(self):
        item = self.itemLine.text()
        self.listWidget.addItem(QtGui.QListWidgetItem(item))
        self.updateList()
        self.enableAddButton()

    def removeItem(self):
        self.listWidget.takeItem(self.listWidget.currentRow())
        self.updateList()
        self.enableAddButton()

    def addIcon(self):
        options = QtGui.QFileDialog.Options()
        if sys.platform == "win32":
            filter = "Icon Files (*.ico)"
        elif sys.platform == "darwin":
            filter = "Icon Files (*.icns)"
        else:
            filter = "Icon Files (*.png)"
        filePath = QtGui.QFileDialog.getOpenFileName(self,
                                                    "Select Icon", self.useData.getLastOpenedDir(
                                                    ), filter, options)
        if filePath:
            destPath = os.path.join(self.projectPathDict['iconsdir'],
                                   os.path.basename(filePath))
            if os.path.exists(destPath):
                reply = QtGui.QMessageBox.warning(self, "Add Icon",
                                                 "Icon with same name already exists. Replace?",
                                                 QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
                if reply == QtGui.QMessageBox.Yes:
                    pass
                else:
                    return
            shutil.copyfile(filePath, destPath)
            self.updateIconBox()
            f = self.iconBox.findText(os.path.basename(filePath))
            if f != -1:
                self.iconBox.setCurrentIndex(f)
            self.useData.saveLastOpenedDir(os.path.dirname(filePath))

    def removeIcon(self):
        currentIcon = self.iconBox.currentText()
        if currentIcon != '':
            path = os.path.join(self.projectPathDict['iconsdir'], currentIcon)
            if os.path.exists(path):
                try:
                    os.remove(path)
                    self.updateIconBox()
                except Exception as err:
                    message = QtGui.QMessageBox.warning(
                        self, "Failed Remove", str(err))

    def save(self):
        fileName = self.projectPathDict["buildprofile"]

        dom_document = QtXml.QDomDocument("build_profile")

        main_data = dom_document.createElement("build")
        dom_document.appendChild(main_data)

        root = dom_document.createElement("name")
        attrib = dom_document.createTextNode(self.itemLine.text().strip())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("author")
        attrib = dom_document.createTextNode(self.authorLine.text().strip())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("version")
        attrib = dom_document.createTextNode(self.versionLine.text().strip())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("comments")
        attrib = dom_document.createTextNode(self.commentsLine.text().strip())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("description")
        attrib = dom_document.createTextNode(
            self.descriptionLine.text().strip())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("company")
        attrib = dom_document.createTextNode(self.companyLine.text().strip())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("copyright")
        attrib = dom_document.createTextNode(self.copyrightLine.text().strip())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("trademarks")
        attrib = dom_document.createTextNode(
            self.trademarksLine.text().strip())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("product")
        attrib = dom_document.createTextNode(self.productLine.text().strip())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("base")
        attrib = dom_document.createTextNode(self.windowTypeBox.currentText())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("icon")
        attrib = dom_document.createTextNode(self.iconBox.currentText())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("compress")
        attrib = dom_document.createTextNode(self.compressBox.currentText())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("optimize")
        attrib = dom_document.createTextNode(self.optimizeBox.currentText())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("copydeps")
        attrib = dom_document.createTextNode(self.copyDepsBox.currentText())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("appendscripttoexe")
        attrib = dom_document.createTextNode(
            self.appendScriptToExeBox.currentText())
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("appendscripttolibrary")
        attrib = dom_document.createTextNode(
            self.appendScriptToLibraryBox.currentText())
        root.appendChild(attrib)
        main_data.appendChild(root)

        for key, value in self.lists.items():
            root = dom_document.createElement(key.replace(' ', '-'))
            main_data.appendChild(root)
            for i in value:
                tag = dom_document.createElement("item")
                root.appendChild(tag)

                t = dom_document.createTextNode(i)
                tag.appendChild(t)

        try:
            file = open(fileName, "w")
            file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            file.write(dom_document.toString())
            file.close()
        except:
            message = QtGui.QMessageBox.warning(
                self, "Save Profile", "Saving failed!")

    def load(self):
        dom_document = QtXml.QDomDocument()
        file = open(self.projectPathDict["buildprofile"], "r")
        dom_document.setContent(file.read())
        file.close()

        dataDict = {}

        elements = dom_document.documentElement()
        node = elements.firstChild()
        while node.isNull() is False:
            name = node.nodeName()
            expandedName = name.replace('-', ' ')
            if expandedName in self.lists:
                sub_node = node.firstChild()
                while sub_node.isNull() is False:
                    sub_prop = sub_node.toElement()
                    self.lists[expandedName].append(sub_prop.text())
                    sub_node = sub_node.nextSibling()
                dataDict[expandedName] = self.lists[expandedName]
            else:
                sub_prop = node.toElement()
                dataDict[name] = sub_prop.text()
            node = node.nextSibling()
        return dataDict


class ConfigureProject(QtGui.QLabel):

    def __init__(self, projectPathDict, projectSettings, useData, parent=None):
        QtGui.QLabel.__init__(self, parent)

        self.setBackgroundRole(QtGui.QPalette.Background)
        self.setAutoFillBackground(True)
        self.setObjectName("containerLabel")
        self.setStyleSheet(StyleSheet.toolWidgetStyle)

        self.setMinimumSize(500, 350)
        self.pagesList = []

        mainLayout = QtGui.QVBoxLayout()
        self.setLayout(mainLayout)
        
        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        label = QtGui.QLabel("Project Configuration")
        label.setObjectName("toolWidgetNameLabel")
        hbox.addWidget(label)
        
        hbox.addStretch(1)
        
        self.hideButton = QtGui.QToolButton()
        self.hideButton.setAutoRaise(True)
        self.hideButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "cross_")))
        self.hideButton.clicked.connect(self.hide)
        hbox.addWidget(self.hideButton)

        self.tabWidget = QtGui.QTabWidget()

        if projectPathDict["type"] == "Desktop Application":
            self.buildConfig = BuildConfig(projectPathDict, useData)
            self.tabWidget.addTab(self.buildConfig,
                                  QtGui.QIcon(os.path.join("Resources", "images", "build")), "Build")

        self.venvSetup = VenvSetup(projectPathDict, projectSettings, useData)
        self.tabWidget.addTab(self.venvSetup,
                                  QtGui.QIcon(os.path.join("Resources", "images", "script_grey")), "Virtual Environment")

        self.refactorConfig = RopeConfig(projectPathDict, useData)
        # self.tabWidget.addTab(self.refactorConfig,
                              # QtGui.QIcon(os.path.join("Resources", "images", "erase"), "Refactor")
#        self.pagesList.append(self.libraries)

        mainLayout.addWidget(self.tabWidget)

########NEW FILE########
__FILENAME__ = ProjectManager
import os
import shutil
from PyQt4 import QtCore, QtGui

from Extensions.Projects.ProjectManager.ProjectView.ProjectView import ProjectView
from Extensions.Projects.ProjectManager.Build import Build


class ExportThread(QtCore.QThread):

    def run(self):
        self.error = None
        try:
            shutil.make_archive(self.fileName, "zip", self.path)
        except Exception as err:
            self.error = str(err)

    def export(self, fileName, path):
        self.fileName = fileName
        self.path = path

        self.start()


class ProjectManager(QtGui.QWidget):

    def __init__(
        self, editorTabWidget, messagesWidget, projectPathDict, projectSettings,
            useData, app,
            busyWidget, buildStatusWidget, parent):
        QtGui.QWidget.__init__(self, parent)

        self.busyWidget = busyWidget
        self.editorTabWidget = editorTabWidget

        self.useData = useData
        self.projects = parent
        self.projects = parent

        self.configDialog = editorTabWidget.configDialog

        if projectPathDict["type"] == "Desktop Application":
            self.build = Build(
                buildStatusWidget, messagesWidget, projectPathDict, projectSettings, useData,
                self.configDialog.buildConfig, editorTabWidget, self)

        self.exportThread = ExportThread()
        self.exportThread.finished.connect(self.finishExport)

        self.projectView = ProjectView(
            self.editorTabWidget, projectPathDict["sourcedir"], app, projectSettings)

    def buildProject(self):
        if self.editorTabWidget.errorsInProject():
            reply = QtGui.QMessageBox.warning(self, "Build",
                                              "There are errors in your project. Build anyway?",
                                              QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
            if reply == QtGui.QMessageBox.Yes:
                self.build.build()
            else:
                return
        else:
            self.build.build()

    def configureProject(self):
        self.configDialog.exec_()

    def openBuild(self):
        self.build.openDir()

    def exportProject(self):
        curren_window = self.projects.projectWindowStack.currentWidget()
        name = curren_window.projectPathDict["name"]
        path = curren_window.projectPathDict["root"]

        options = QtGui.QFileDialog.Options()
        savepath = os.path.join(self.useData.getLastOpenedDir(), name)
        savepath = os.path.normpath(savepath)
        fileName = QtGui.QFileDialog.getSaveFileName(self,
                                                     "Export", savepath,
                                                     "All files (*)", options)
        if fileName:
            self.useData.saveLastOpenedDir(os.path.split(fileName)[0])

            self.exportThread.export(fileName, path)
            self.busyWidget.showBusy(True, "Exporting project... please wait!")

    def finishExport(self):
        self.busyWidget.showBusy(False)
        if self.exportThread.error is not None:
            message = QtGui.QMessageBox.warning(
                self, "Export Failed", self.exportThread.error)

########NEW FILE########
__FILENAME__ = ProgressWidget
import os

from PyQt4 import QtCore, QtGui


class ProgressWidget(QtGui.QLabel):

    updateProgress = QtCore.pyqtSignal(int)

    def __init__(self, parent=None):
        QtGui.QLabel.__init__(self, parent)

        self.setMinimumHeight(25)
        self.setObjectName("mainLabel")

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setSpacing(0)
        mainLayout.setMargin(2)
        self.setLayout(mainLayout)
        
        self.progressBar = QtGui.QProgressBar()
        self.progressBar.setTextVisible(False)
        self.progressBar.setRange(0, 100)
        self.updateProgress.connect(self.updateValue)
        mainLayout.addWidget(self.progressBar)
        

        hbox = QtGui.QHBoxLayout()
        hbox.setMargin(2)
        hbox.setSpacing(0)
        self.progressBar.setLayout(hbox)

        hbox.addWidget(QtGui.QLabel("Copying: "))

        self.captionLabel = QtGui.QLabel()
        self.captionLabel.setStyleSheet("""
                                          QLabel  {
                                              color: #003366;
                                          }
                                        """)
        hbox.addWidget(self.captionLabel)

        hbox.addStretch(1)

        self.cancelButton = QtGui.QToolButton()
        self.cancelButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "cross")))
        hbox.addWidget(self.cancelButton)

        self.setStyleSheet("""
                              QLabel#mainLabel  {
                                  background: #ffffff;
                                  border: none;
                              }

                              QProgressBar {
                                 border: None;
                                 text-align: center;
                                 padding: 0px;
                                 border-radius: 0px;
                                 background-color: Transparent;
                             }

                             QProgressBar::chunk {
                                  color: black;
                                  border-radius: 0px;
                                  background-color: #EDEDED;
                             }

                            """)

    def reset(self):
        self.progressBar.setValue(0)

    def updateCurrentJob(self, job):
        self.captionLabel.setText(job)

    def updateValue(self, newValue):
        self.progressBar.setValue(newValue)

    def showBusy(self, show, mess=None):
        if show:
            self.captionLabel.setText(mess)
            self.cancelButton.show()
            self.show()
        else:
            self.hide()
            self.reset()

########NEW FILE########
__FILENAME__ = ProjectView
import os
import ctypes
import shutil
from PyQt4 import QtGui, QtCore, QtXml

from Extensions import Global
from Extensions.Projects.ProjectManager.ProjectView.ProgressWidget import ProgressWidget


class GetName(QtGui.QDialog):

    def __init__(self, caption, path, parent=None):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle(caption)

        self.path = path

        mainLayout = QtGui.QVBoxLayout()
        self.setLayout(mainLayout)
        mainLayout.addWidget(QtGui.QLabel("Name:"))

        self.nameLine = QtGui.QLineEdit()
        self.nameLine.selectAll()
        self.nameLine.textChanged.connect(self.enableAcceptButton)
        mainLayout.addWidget(self.nameLine)

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        self.statusLabel = QtGui.QLabel()
        hbox.addWidget(self.statusLabel)

        hbox.addStretch(1)

        self.acceptButton = QtGui.QPushButton("Ok")
        self.acceptButton.setDisabled(True)
        self.acceptButton.clicked.connect(self.accept)
        hbox.addWidget(self.acceptButton)

        self.cancelButton = QtGui.QPushButton("Cancel")
        self.cancelButton.clicked.connect(self.cancel)
        hbox.addWidget(self.cancelButton)

        self.resize(300, 20)
        self.enableAcceptButton()

        self.exec_()

    def enableAcceptButton(self):
        text = self.nameLine.text().strip()
        if text == '':
            self.acceptButton.setDisabled(True)
        else:
            preExistNames = os.listdir(self.path)
            if text in preExistNames:
                self.statusLabel.setText("Unavailable")
                self.acceptButton.setDisabled(True)
            else:
                self.statusLabel.setText("Available")
                self.acceptButton.setDisabled(False)

    def accept(self):
        self.accepted = True
        self.text = self.nameLine.text().strip()
        self.close()

    def cancel(self):
        self.accepted = False
        self.close()


class CopyThread(QtCore.QThread):

    currentJobChanged = QtCore.pyqtSignal(str)
    copyingSizeChanged = QtCore.pyqtSignal(int)

    def run(self):
        try:
            for path in self.itemList:
                if self.stopThread is False:
                    destPath = os.path.join(
                        self.destDir, os.path.basename(path))
                    if os.path.isfile(path):
                        self.copyFile(path, destPath)
                    else:
                        self.copyDir(path, destPath)
                else:
                    break
        except Exception as err:
            self.errors = str(err)

    def copyDir(self, sourceDir, destDir):
        if not os.path.exists(destDir):
            os.mkdir(destDir)

        for i in os.listdir(sourceDir):
            path = os.path.join(sourceDir, i)
            if os.path.isfile(path):
                self.copyFile(path, os.path.join(destDir, i))
            else:
                self.copyDir(path, os.path.join(destDir, i))

    def copyFile(self, source, dest):
        self.currentJobChanged.emit(os.path.basename(source))
        sourceFile = open(source, 'rb')
        destFile = open(dest, 'wb')
        while True:
            if self.stopThread is not False:
                sourceFile.close()
                destFile.close()
                os.remove(dest)
                return
            chunk = sourceFile.read(1024)
            if len(chunk) == 0:
                sourceFile.close()
                destFile.close()
                break
            destFile.write(chunk)
            self.totalChunkCopied += len(chunk)

            value = self.totalChunkCopied * 100 / self.totalSize
            self.copyingSizeChanged.emit(value)

    def getTotalSize(self, itemList):
        # calculate size of items in the list
        totalSize = 0
        for item in itemList:
            if os.path.isfile(item):
                try:
                    size = os.path.getsize(item)
                    totalSize += size
                except:
                    pass
            else:
                for root, dirs, files in os.walk(item):
                    for i in files:
                        try:
                            size = os.path.getsize(os.path.join(root, i))
                            totalSize += size
                        except:
                            pass
        return totalSize

    def copy(self, itemList, destDir):
        self.itemList = itemList
        self.destDir = destDir

        self.totalChunkCopied = 0
        self.totalSize = self.getTotalSize(itemList)
        self.stopThread = False
        self.errors = None

        self.start()

    def stop(self):
        self.stopThread = True


class IconProvider(QtGui.QFileIconProvider):

    def __init__(self, parent=None):
        QtGui.QFileIconProvider.__init__(self)

    def icon(self, icontype_or_qfileinfo):
        """Reimplement Qt method"""
        if isinstance(icontype_or_qfileinfo, QtGui.QFileIconProvider.IconType):
            return super(IconProvider, self).icon(icontype_or_qfileinfo)
        else:
            qfileinfo = icontype_or_qfileinfo
            fname = os.path.normpath(qfileinfo.absoluteFilePath())
            if os.path.isdir(fname):
                dir = QtCore.QDir(fname)
                dirList = dir.entryList(QtCore.QDir.Files)
                if "__init__.py" in dirList:
                    icon = QtGui.QIcon(
                        os.path.join("Resources", "images", "box"))
                else:
                    icon = QtGui.QIcon(
                        os.path.join("Resources", "images", "folder-horizontal"))
                return icon
            else:
                if os.path.basename(fname) == "__init__.py":
                    return QtGui.QIcon(os.path.join("Resources", "images", "haiku-wide"))
                ext = os.path.splitext(fname)[1][1:]
                if ext == "py" or ext == "pyw":
                    return QtGui.QIcon(os.path.join("Resources", "images", "gear"))
                else:
                    return super(IconProvider, self).icon(qfileinfo)


class ProjectTree(QtGui.QTreeView):

    fileActivated = QtCore.pyqtSignal(str)

    def __init__(self, editorTabWidget, root, app, projectSettings, progressWidget, parent):
        QtGui.QTreeView.__init__(self, parent)

        self.root = root
        self.app = app
        self.editorTabWidget = editorTabWidget
        self.refactor = editorTabWidget.refactor
        self.parent = parent
        self.progressWidget = progressWidget
        self.projectSettings = projectSettings
        self.projectPathDict = self.editorTabWidget.projectPathDict

        self.setObjectName("sidebarItem")

        self.setAcceptDrops(True)
        self.setAnimated(True)
        self.setAutoScroll(True)
        self.activated.connect(self.treeItemActivated)

        self.copyThread = CopyThread()
        self.copyThread.copyingSizeChanged.connect(self.updateCopySize)
        self.copyThread.currentJobChanged.connect(self.updateCurrentJob)
        self.copyThread.finished.connect(self.copyFinished)

        self.progressWidget.cancelButton.clicked.connect(
            self.copyThread.stop)

        iconProvider = IconProvider()

        self.fileSystemModel = QtGui.QFileSystemModel()
        self.fileSystemModel.setRootPath(QtCore.QDir.rootPath())
        self.fileSystemModel.setNameFilterDisables(False)
        self.fileSystemModel.setIconProvider(iconProvider)
        self.setModel(self.fileSystemModel)
        self.setColumnWidth(0, 300)

        self.createActions()
        self.loadShortcut(self.root)

        if self.projectSettings["ShowAllFiles"] == 'False':
            self.fileSystemModel.setNameFilters(['*.py', '*.pyw'])
        self.showAllFilesAct.setChecked(
            self.projectSettings["ShowAllFiles"] == 'True')

    def contextMenuEvent(self, event):
        indexList = self.selectedIndexes()
        selection = len(indexList) != 0

        self.contextMenu = QtGui.QMenu()
        self.newMenu = self.contextMenu.addMenu("New...")
        self.newMenu.addAction(self.addFileAct)
        self.newMenu.addAction(self.addDirAct)
        self.newMenu.addAction(self.addPackageAct)
        self.addExistingMenu = self.contextMenu.addMenu("Add Existing...")
        self.addExistingMenu.addAction(self.addExistingFilesAct)
        self.addExistingMenu.addAction(self.addExistingDirectoriesAct)
        self.contextMenu.addSeparator()
        self.contextMenu.addAction(self.showAllFilesAct)
        self.contextMenu.addAction(self.collapseAllAct)
        self.contextMenu.addAction(self.expandAllAct)
        self.contextMenu.addSeparator()

        if selection:
            self.contextMenu.addAction(self.copyAct)
            self.contextMenu.addAction(self.pasteAct)
            self.contextMenu.addAction(self.deleteAct)

        if selection:
            path_index = indexList[0]
            if self.fileSystemModel.isDir(path_index):
                pass
            else:
                path = \
                    os.path.normpath(self.fileSystemModel.filePath(path_index))
                if path.endswith((".py", ".pyw")):
                    self.contextMenu.addSeparator()
                    self.contextMenu.addAction(self.mainScriptsAct)

        self.contextMenu.exec_(event.globalPos())

    def createActions(self):
        self.addFileAct = QtGui.QAction(
            "File", self,
            statusTip="File", triggered=self.newFile)

        self.addDirAct = QtGui.QAction(
            "Directory", self,
            statusTip="Directory", triggered=self.newDirectory)

        self.addPackageAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "box")),
            "Package", self,
            statusTip="Package", triggered=self.newPackage)

        self.copyAct = QtGui.QAction(
            "Copy", self, shortcut=QtGui.QKeySequence.Copy,
            statusTip="Copy", triggered=self.copyItem)

        self.pasteAct = QtGui.QAction(
            "Paste", self, shortcut=QtGui.QKeySequence.Paste,
            statusTip="Paste", triggered=self.pasteItem)

        self.deleteAct = QtGui.QAction(
            "Delete", self, shortcut=QtGui.QKeySequence.Delete,
            statusTip="Delete Selection", triggered=self.deleteItem)

        self.addExistingFilesAct = \
            QtGui.QAction(
                "Files", self,
                statusTip="Files", triggered=self.addExistingFiles)

        self.addExistingDirectoriesAct = \
            QtGui.QAction(
                "Directory", self,
                statusTip="Directory", triggered=self.addExistingDirectory)

        self.mainScriptsAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "location")),
            "Set as Main Script", self, statusTip="Set as Main Script",
            triggered=self.setMainScript)

        self.collapseAllAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "collapse")),
                "Collapse All", self,
                statusTip="Collapse Tree", triggered=self.collapseAll)

        self.expandAllAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "expand")),
                "Expand All", self,
                statusTip="Expand Tree", triggered=self.expandAll)

        self.showAllFilesAct = \
            QtGui.QAction(
                "Show All Files", self, statusTip="Show All Files",
                triggered=self.showAllFiles)
        self.showAllFilesAct.setCheckable(True)
        self.showAllFilesAct.setChecked(True)

    def getCurrentFilePath(self):
        indexList = self.selectedIndexes()
        path_index = indexList[0]
        path = \
            os.path.normpath(self.fileSystemModel.filePath(path_index))
        return path

    def getCurrentDirectory(self):
        indexList = self.selectedIndexes()
        if len(indexList) == 0:
            path = self.root
        else:
            path_index = indexList[0]
            if self.fileSystemModel.isDir(path_index):
                pass
            else:
                path_index = path_index.parent()
            path = \
                os.path.normpath(self.fileSystemModel.filePath(path_index))
        return path

    def copyItem(self):
        path = self.getCurrentFilePath()
        url = QtCore.QUrl.fromLocalFile(path)
        data = QtCore.QMimeData()
        data.setUrls([url])

        clipboard = self.app.clipboard()
        clipboard.setMimeData(data)

    def pasteItem(self):
        destDir = self.getCurrentDirectory()
        clipboard = self.app.clipboard()
        mimeData = clipboard.mimeData()
        if mimeData.hasUrls():
            urls = mimeData.urls()
            pathList = []
            for url in urls:
                path = url.toLocalFile()
                dest = os.path.join(destDir, os.path.basename(path))
                if os.path.exists(dest):
                    reply = QtGui.QMessageBox.warning(self, "Paste",
                                                      "'" + os.path.basename(
                                                          dest) + "' already exists in the destination directory.\n\nWould you like to replace it?",
                                                      QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
                    if reply == QtGui.QMessageBox.Yes:
                        pass
                    else:
                        continue
                pathList.append(path)
            self.copyThread.copy(pathList, destDir)
            self.progressWidget.showBusy(True, "Preparing to copy...")

    def newFile(self):
        path = self.getCurrentDirectory()
        fileName = GetName("New File", path, self)
        if fileName.accepted:
            path = os.path.join(path, fileName.text)
            try:
                file = open(path, 'w')
                file.close()
                self.editorTabWidget.loadfile(path)
            except:
                message = QtGui.QMessageBox.warning(self, "New File",
                                                    "File creation failed!")

    def newDirectory(self):
        path = self.getCurrentDirectory()
        dirName = GetName("New Directory", path, self)
        if dirName.accepted:
            path = os.path.join(path, dirName.text)
            try:
                os.mkdir(path)
            except:
                message = QtGui.QMessageBox.warning(self, "New Directory",
                                                    "Failed to create directory!")

    def newPackage(self):
        path = self.getCurrentDirectory()
        packageName = GetName("New Package", path, self)
        if packageName.accepted:
            path = os.path.join(path, packageName.text)
            try:
                os.mkdir(path)
                f = os.path.join(path, "__init__.py")
                file = open(f, "w")
                file.close()
                self.editorTabWidget.loadfile(f)
            except:
                message = QtGui.QMessageBox.warning(self, "New Package",
                                                    "Package creation failed!")

    def addExistingFiles(self):
        options = QtGui.QFileDialog.Options()
        files = QtGui.QFileDialog.getOpenFileNames(self,
                                                  "Select Files", QtCore.QDir.homePath(
                                                  ),
            "All Files (*);;Text Files (*.txt)", options)
        if files:
            destDir = self.getCurrentDirectory()
            pathList = []
            for file in files:
                destPathName = os.path.join(destDir, os.path.basename(file))
                if os.path.exists(destPathName):
                    reply = QtGui.QMessageBox.warning(
                        self, "Add Existing Files",
                        "'" + os.path.basename(
                            destPathName) + "' already exists in the destination directory.\n\nWould you like to replace it?",
                        QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
                    if reply == QtGui.QMessageBox.Yes:
                        pass
                    else:
                        continue
                pathList.append(file)
            self.copyThread.copy(pathList, destDir)
            self.progressWidget.showBusy(True, "Preparing to copy...")

    def addExistingDirectory(self):
        options = QtGui.QFileDialog.DontResolveSymlinks | QtGui.QFileDialog.ShowDirsOnly
        directory = QtGui.QFileDialog.getExistingDirectory(self,
                                                          "Select Directory", QtCore.QDir.homePath(
                                                          ), options)
        if directory:
            destDir = self.getCurrentDirectory()
            destPathName = os.path.join(destDir, os.path.basename(directory))
            if os.path.exists(destPathName):
                reply = QtGui.QMessageBox.warning(
                    self, "Add Existing Directory",
                                                  "'" + os.path.basename(
                                                      destPathName) + "' already exists in the destination directory.\n\nWould you like to replace it?",
                                                  QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
                if reply == QtGui.QMessageBox.Yes:
                    pass
                else:
                    return
            self.copyThread.copy([directory], destDir)
            self.progressWidget.showBusy(True, "Preparing to copy...")

    def updateCopySize(self, value):
        self.progressWidget.updateValue(value)

    def updateCurrentJob(self, job):
        self.progressWidget.updateCurrentJob(job)

    def copyFinished(self):
        self.progressWidget.showBusy(False)
        if self.copyThread.errors is not None:
            message = QtGui.QMessageBox.warning(
                    self, "Add Existing Items", "Failed to complete copy!\n\n" + str(self.copyThread.errors))

    def deleteItem(self):
        path = self.getCurrentFilePath()
        reply = QtGui.QMessageBox.warning(self, "Delete",
                                          "Permanently delete '" + os.path.basename(
                                              path) + "' from the project?",
                                          QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            try:
                if os.path.isdir(path):
                    shutil.rmtree(path)
                else:
                    os.remove(path)
            except Exception as err:
                message = QtGui.QMessageBox.warning(self, "Delete",
                                                    "Failed to delete item!\n\n" + str(err))
        else:
            return

    def loadShortcut(self, path):
        if os.path.exists(path):
            self.setRootIndex(self.fileSystemModel.index(path))
        else:
            message = QtGui.QMessageBox.warning(self, "Open",
                                                "Directory not found!")

    def showAllFiles(self):
        checked = self.showAllFilesAct.isChecked()
        self.projectSettings["ShowAllFiles"] = str(checked)
        if checked:
            self.fileSystemModel.setNameFilters([])
        else:
            self.fileSystemModel.setNameFilters(['*.py', '*.pyw'])

    def treeItemActivated(self, modelIndex):
        if self.fileSystemModel.isDir(modelIndex) is False:
            path = self.getCurrentFilePath()
            self.parent.fileActivated.emit(path)
        else:
            if self.isExpanded(modelIndex):
                self.collapse(modelIndex)
            else:
                self.expand(modelIndex)

    def openExternal(self):
        path = self.getCurrentDirectory()
        ctypes.windll.shell32.ShellExecuteW(None, 'open', 'explorer.exe',
                                            '/n,/select, ' + path, None, 1)

    def setMainScript(self):
        fileName = self.getCurrentFilePath()
        self.projectPathDict["mainscript"] = fileName

        dom_document = QtXml.QDomDocument()
        file = open(self.projectPathDict["projectmainfile"], "r")
        x = dom_document.setContent(file.read())
        file.close()

        elements = dom_document.documentElement()
        node = elements.firstChild()

        settingsDict = {}
        while node.isNull() is False:
            tag = node.toElement()

            settingsDict["Type"] = tag.attribute("Type")
            settingsDict["Name"] = tag.attribute("Name")
            settingsDict["MainScript"] = tag.attribute("MainScript")
            settingsDict["Version"] = tag.attribute("Version")

            node = node.nextSibling()

        settingsDict["MainScript"] = fileName

        # save data
        dom_document = QtXml.QDomDocument("Project")
        properties = dom_document.createElement("properties")
        dom_document.appendChild(properties)

        tag = dom_document.createElement("pcode_project")
        for key, value in settingsDict.items():
            tag.setAttribute(key, value)
        properties.appendChild(tag)

        file = open(self.projectPathDict["projectmainfile"], "w")
        file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
        file.write(dom_document.toString())
        file.close()


class SearchThread(QtCore.QThread):

    foundList = QtCore.pyqtSignal(dict)

    def run(self):
        resultsDict = {}

        for root, dirs, files in os.walk(self.projectDir):
            for i in files:
                if not self.filterDisabled:
                    if not i.endswith('.py') or i.endswith('.pyw'):
                        continue

                if i.startswith(self.searchName):
                    if root in resultsDict:
                        resultsDict[root].append(i)
                    else:
                        resultsDict[root] = [i]
        self.foundList.emit(resultsDict)

    def search(self, searchItem, projectDir, filterEnabled):
        self.projectDir = projectDir
        self.searchName = searchItem
        self.filterDisabled = filterEnabled

        self.start()


class LineEdit(QtGui.QLineEdit):

    fileActivated = QtCore.pyqtSignal(str)

    def __init__(self, viewStack, searchResultsTree, parent=None):
        QtGui.QWidget.__init__(self, parent)

        self.searchResultsTree = searchResultsTree
        self.viewStack = viewStack

        self.setPlaceholderText("Search")

        hbox = QtGui.QHBoxLayout()
        hbox.setMargin(1)
        hbox.addStretch(1)
        self.setLayout(hbox)

        self.clearButton = QtGui.QToolButton()
        self.clearButton.setAutoRaise(True)
        self.clearButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "disabled")))
        self.clearButton.clicked.connect(self.clearSearch)
        hbox.addWidget(self.clearButton)

    def keyPressEvent(self, event):
        key = event.key()

        ctrl = event.modifiers() & QtCore.Qt.ControlModifier
        alt = event.modifiers() & QtCore.Qt.AltModifier
        shift_down = event.modifiers() & QtCore.Qt.ShiftModifier

        if ctrl:
            pass
        elif alt:
            pass
        elif key == QtCore.Qt.Key_Up:
            currentItem = self.currentItem()
            if currentItem is not None:
                itemAbove = self.searchResultsTree.itemAbove(currentItem)
                if itemAbove is None:
                    return
                self.searchResultsTree.setCurrentItem(itemAbove)
                self.setFocus(True)
        elif key == QtCore.Qt.Key_Down:
            currentItem = self.currentItem()
            if currentItem is not None:
                itemBelow = self.searchResultsTree.itemBelow(currentItem)
                if itemBelow is None:
                    return
                self.searchResultsTree.setCurrentItem(itemBelow)
                self.setFocus(True)
        else:
            QtGui.QLineEdit.keyPressEvent(self, event)

    def clearSearch(self):
        self.clear()
        self.viewStack.setCurrentIndex(0)

    def currentItem(self):
        if self.searchResultsTree.topLevelItemCount() > 0:
            item = self.searchResultsTree.selectedItems()[0]
            return item
        else:
            return None


class ProjectView(QtGui.QWidget):

    fileActivated = QtCore.pyqtSignal(str)

    def __init__(self, editorTabWidget, root, app, projectSettings, parent=None):
        QtGui.QWidget.__init__(self, parent)

        self.refactor = editorTabWidget.refactor
        self.root = root

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setContentsMargins(0, 0, 2, 2)
        self.setLayout(mainLayout)

        self.progressWidget = ProgressWidget()
        mainLayout.addWidget(self.progressWidget)
        self.progressWidget.hide()

        self.viewStack = QtGui.QStackedWidget()
        mainLayout.addWidget(self.viewStack)

        self.projectTree = ProjectTree(
            editorTabWidget, root, app, projectSettings, self.progressWidget, self)
        self.viewStack.addWidget(self.projectTree)

        self.searchResultsTree = QtGui.QTreeWidget(self)
        self.searchResultsTree.setObjectName("sidebarItem")
        self.searchResultsTree.setHeaderItem(
            QtGui.QTreeWidgetItem(["Search Results:"]))
        self.searchResultsTree.activated.connect(self.loadFile)
        self.viewStack.addWidget(self.searchResultsTree)

        self.searchThread = SearchThread()
        self.searchThread.foundList.connect(self.updateSearchTree)

        self.searchTimer = QtCore.QTimer()
        self.searchTimer.setSingleShot(True)
        self.searchTimer.timeout.connect(self.search)
        
        vbox = QtGui.QVBoxLayout()
        vbox.setSpacing(0)
        mainLayout.addLayout(vbox)

        self.searchLine = LineEdit(self.viewStack, self.searchResultsTree)
        self.searchLine.textChanged.connect(self.startSearchTimer)
        self.searchLine.returnPressed.connect(self.loadFile)
        vbox.addWidget(self.searchLine)

        self.progressBar = QtGui.QProgressBar()
        self.progressBar.setMaximumHeight(2)
        self.progressBar.setStyleSheet(
            """

                                  QProgressBar {
                                     border: None;
                                     text-align: center;
                                     padding: 0px;
                                     border-radius: 0px;
                                     background-color: Transparent;
                                 }

                                 QProgressBar::chunk {
                                      color: black;
                                      border-radius: 0px;
                                      background-color: #65B0EA;
                                 }

                                """
            )
        self.progressBar.setRange(0, 0)
        vbox.addWidget(self.progressBar)
        self.progressBar.hide()
        
    def startSearchTimer(self):
        self.searchTimer.start(300)

    def loadFile(self):
        if len(self.searchResultsTree.selectedItems()) > 0:
            item = self.searchResultsTree.selectedItems()[0]
            if item.parent() is None:
                pass
            else:
                parentDir = item.parent().text(0)
                path = os.path.join(self.root, parentDir, item.text(0))
                self.fileActivated.emit(path)

    def search(self):
        text = self.searchLine.text().strip()
        if text == '':
            self.viewStack.setCurrentIndex(0)
            return
        self.searchThread.search(text, self.refactor.root,
                                self.projectTree.showAllFilesAct.isChecked())
        self.progressBar.show()

    def updateSearchTree(self, resultsDict):
        self.progressBar.hide()
        self.searchResultsTree.clear()
        self.viewStack.setCurrentIndex(1)
        if len(resultsDict) > 0:
            for folder, fileList in resultsDict.items():
                folderItem = QtGui.QTreeWidgetItem(self.searchResultsTree)
                pathRelativeToProject = folder.partition(
                    self.root + os.path.sep)[-1]
                folderItem.setText(0, pathRelativeToProject)
                folderItem.setForeground(0, QtGui.QBrush(
                    QtGui.QColor("#003366")))
                for i in fileList:
                    fileItem = QtGui.QTreeWidgetItem(folderItem)
                    icon = Global.iconFromPath(os.path.join(folder, i))
                    fileItem.setText(0, i)
                    fileItem.setIcon(0, QtGui.QIcon(icon))
                folderItem.setExpanded(True)

            item = self.searchResultsTree.topLevelItem(0)
            self.searchResultsTree.setCurrentItem(item.child(0))
        else:
            folderItem = QtGui.QTreeWidgetItem()
            item = QtGui.QTreeWidgetItem()
            item.setText(0, "<No results found>")
            item.setFlags(QtCore.Qt.NoItemFlags)
            folderItem.addChild(item)
            self.searchResultsTree.addTopLevelItem(folderItem)
            folderItem.setExpanded(True)

########NEW FILE########
__FILENAME__ = Projects
"""
Manages all opened projects such as the creation and closing of projects
"""

import os
import sys
import shutil
import traceback
import logging
from PyQt4 import QtCore, QtGui, QtXml

from Extensions.EditorWindow.EditorWindow import EditorWindow
from Extensions.Projects.NewProjectDialog import NewProjectDialog


class CreateProjectThread(QtCore.QThread):

    def run(self):
        self.error = False
        try:
            self.projectPath = os.path.join(self.projDataDict["location"],
                                            self.projDataDict["name"])
            os.mkdir(self.projectPath)

            data = os.path.join(self.projectPath, "Data")
            os.mkdir(data)
            file = open(os.path.join(data, "wpad.txt"), "w")
            file.close()

            ropeFolder = os.path.join(self.projectPath, "Rope")
            os.mkdir(ropeFolder)
            shutil.copy(os.path.join("Resources", "default_config.py"),
                        os.path.join(ropeFolder, "config.py"))

            os.mkdir(os.path.join(self.projectPath, "Resources"))
            os.mkdir(os.path.join(self.projectPath, "Resources", "VirtualEnv"))
            os.mkdir(
                os.path.join(self.projectPath, "Resources", "VirtualEnv", "Linux"))
            os.mkdir(
                os.path.join(self.projectPath, "Resources", "VirtualEnv", "Mac"))
            os.mkdir(
                os.path.join(self.projectPath, "Resources", "VirtualEnv", "Windows"))
            os.mkdir(os.path.join(self.projectPath, "Resources", "Icons"))

            os.mkdir(os.path.join(self.projectPath, "temp"))
            os.mkdir(os.path.join(self.projectPath, "temp", "Backup"))
            os.mkdir(os.path.join(self.projectPath, "temp", "Backup", "Files"))

            sourceDir = os.path.join(self.projectPath, "src")
            if self.projDataDict["importdir"] != '':
                shutil.copytree(self.projDataDict["importdir"], sourceDir)
            else:
                os.mkdir(os.path.join(self.projectPath, "src"))

            if self.projDataDict["type"] == "Desktop Application":
                build = os.path.join(self.projectPath, "Build")
                os.mkdir(build)
                os.mkdir(os.path.join(build, "Linux"))
                os.mkdir(os.path.join(build, "Mac"))
                os.mkdir(os.path.join(build, "Windows"))

            self.mainScript = os.path.join(self.projectPath, "src",
                                           self.projDataDict["mainscript"])
            file = open(self.mainScript, 'w')
            file.close()

            if self.projDataDict["type"] == "Desktop Application":
                self.writeBuildProfile()
            self.writeDefaultSession()
            self.writeProjectData()
            self.writeRopeProfile()
        except Exception as err:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                         exc_traceback)))
            self.error = str(err)

    def writeProjectData(self):
        dom_document = QtXml.QDomDocument("Project")

        properties = dom_document.createElement("properties")
        dom_document.appendChild(properties)

        tag = dom_document.createElement("pcode_project")

        tag.setAttribute("Version", "0.1")
        tag.setAttribute("Name", self.projDataDict["name"])
        tag.setAttribute("Type", self.projDataDict["type"])
        tag.setAttribute("MainScript", self.projDataDict["mainscript"])

        properties.appendChild(tag)

        file = open(os.path.join(self.projectPath, "project.xml"), "w")
        file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
        file.write(dom_document.toString())
        file.close()

        domDocument = QtXml.QDomDocument("projectdata")

        projectdata = domDocument.createElement("projectdata")
        domDocument.appendChild(projectdata)

        root = domDocument.createElement("shortcuts")
        projectdata.appendChild(root)

        root = domDocument.createElement("recentfiles")
        projectdata.appendChild(root)

        root = domDocument.createElement("favourites")
        projectdata.appendChild(root)

        root = domDocument.createElement("settings")
        projectdata.appendChild(root)

        s = 0
        defaults = {

            'ClearOutputWindowOnRun': 'False',
            'LastOpenedPath': '',
            'RunType': 'Run',
            'BufferSize': '900',
            'RunArguments': '',
            'DefaultInterpreter': '',
            'TraceType': '3',
            'RunWithArguments': 'False',
            'RunInternal': 'True',
            'UseVirtualEnv': 'False',
            'Closed': 'True',
            'Icon': '',
            'ShowAllFiles': 'True',
            'LastCloseSuccessful': 'True'
            }
        for key, value in defaults.items():
            tag = domDocument.createElement("key")
            root.appendChild(tag)

            t = domDocument.createTextNode(key + '=' + value)
            tag.appendChild(t)
            s += 1

        path = os.path.join(self.projectPath, "Data", "projectdata.xml")
        file = open(path, "w")
        file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
        file.write(domDocument.toString())
        file.close()

    def writeDefaultSession(self):
        dom_document = QtXml.QDomDocument("session")

        session = dom_document.createElement("session")
        dom_document.appendChild(session)

        file = open(os.path.join(self.projectPath, "Data", "session.xml"), "w")
        file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
        file.write(dom_document.toString())
        file.close()

    def writeRopeProfile(self):
        dom_document = QtXml.QDomDocument("rope_profile")

        main_data = dom_document.createElement("rope")
        dom_document.appendChild(main_data)

        root = dom_document.createElement("ignoresyntaxerrors")
        attrib = dom_document.createTextNode('')
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("ignorebadimports")
        attrib = dom_document.createTextNode('')
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("maxhistoryitems")
        attrib = dom_document.createTextNode('32')
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("Extensions")
        main_data.appendChild(root)

        defExt = ['*.py', '*.pyw']
        for i in defExt:
            tag = dom_document.createElement("item")
            root.appendChild(tag)

            t = dom_document.createTextNode(i)
            tag.appendChild(t)

        root = dom_document.createElement("IgnoredResources")
        main_data.appendChild(root)

        defIgnore = ["*.pyc", "*~", ".ropeproject",
                     ".hg", ".svn", "_svn", ".git", "__pycache__"]
        for i in defIgnore:
            tag = dom_document.createElement("item")
            root.appendChild(tag)

            t = dom_document.createTextNode(i)
            tag.appendChild(t)

        root = dom_document.createElement("CustomFolders")
        main_data.appendChild(root)

        file = open(os.path.join(self.projectPath, "Rope", "profile.xml"), "w")
        file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
        file.write(dom_document.toString())
        file.close()

    def writeBuildProfile(self):
        dom_document = QtXml.QDomDocument("build_profile")

        main_data = dom_document.createElement("build")
        dom_document.appendChild(main_data)

        root = dom_document.createElement("name")
        attrib = dom_document.createTextNode('')
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("author")
        attrib = dom_document.createTextNode('')
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("version")
        attrib = dom_document.createTextNode('0.1')
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("comments")
        attrib = dom_document.createTextNode('')
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("description")
        attrib = dom_document.createTextNode('')
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("company")
        attrib = dom_document.createTextNode('')
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("copyright")
        attrib = dom_document.createTextNode('')
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("trademarks")
        attrib = dom_document.createTextNode('')
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("product")
        attrib = dom_document.createTextNode('')
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("base")
        attrib = dom_document.createTextNode(self.projDataDict["windowtype"])
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("icon")
        attrib = dom_document.createTextNode('')
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("compress")
        attrib = dom_document.createTextNode("Compress")
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("optimize")
        attrib = dom_document.createTextNode("Optimize")
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("copydeps")
        attrib = dom_document.createTextNode("Copy Dependencies")
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("appendscripttoexe")
        attrib = dom_document.createTextNode("Append Script to Exe")
        root.appendChild(attrib)
        main_data.appendChild(root)

        root = dom_document.createElement("appendscripttolibrary")
        attrib = dom_document.createTextNode("Append Script to Library")
        root.appendChild(attrib)
        main_data.appendChild(root)

        lists = ["Includes",
                 "Excludes",
                 "Constants Modules",
                 "Packages",
                 "Replace Paths",
                 "Bin Includes",
                 "Bin Excludes",
                 "Bin Path Includes",
                 "Bin Path Excludes",
                 "Zip Includes",
                 "Include Files",
                 "Namespace Packages"]

        for i in lists:
            root = dom_document.createElement(i.replace(' ', '-'))
            main_data.appendChild(root)

        file = open(
            os.path.join(self.projectPath, "Build", "profile.xml"), "w")
        file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
        file.write(dom_document.toString())
        file.close()

    def create(self, data):
        self.projDataDict = data

        self.start()


class Projects(QtGui.QWidget):

    def __init__(self, useData, busyWidget, library, settingsWidget, app,
                 projectWindowStack, projectTitleBox, parent):
        QtGui.QWidget.__init__(self, parent)

        self.createProjectThread = CreateProjectThread()
        self.createProjectThread.finished.connect(self.finalizeNewProject)

        self.newProjectDialog = NewProjectDialog(useData, self)
        self.newProjectDialog.projectDataReady.connect(self.createProject)

        self.busyWidget = busyWidget
        self.useData = useData
        self.app = app
        self.projectWindowStack = projectWindowStack
        self.projectTitleBox = projectTitleBox
        self.library = library
        self.settingsWidget = settingsWidget
        self.pcode = parent

    def closeProgram(self):
        self.pcode.close()

    def readProject(self, path):
        # validate project
        project_file = os.path.join(path, "project.xml")
        if os.path.exists(project_file) is False:
            return False
        dom_document = QtXml.QDomDocument()
        file = open(os.path.join(path, "project.xml"), "r")
        dom_document.setContent(file.read())
        file.close()

        data = {}

        elements = dom_document.documentElement()
        node = elements.firstChild()
        while node.isNull() is False:
            tag = node.toElement()
            name = tag.tagName()
            data["Version"] = tag.attribute("Version")
            data["Type"] = tag.attribute("Type")
            data["Name"] = tag.attribute("Name")
            data["MainScript"] = tag.attribute("MainScript")
            node = node.nextSibling()

        if name != "pcode_project":
            return False
        else:
            return name, data

    def loadProject(self, path, show, new):
        if not self.pcode.showProject(path):
            QtGui.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
            projectPathDict = {
                "notes": os.path.join(path, "Data", "wpad.txt"),
                "session": os.path.join(path, "Data", "session.xml"),
                "usedata": os.path.join(path, "Data", "usedata.xml"),
                "windata": os.path.join(path, "Data", "windata.xml"),
                "projectdata": os.path.join(path, "Data", "projectdata.xml"),
                "snippetsdir": os.path.join(path, "Data", "templates"),
                "tempdir": os.path.join(path, "temp"),
                "backupdir": os.path.join(path, "temp", "Backup", "Files"),
                "backupfile": os.path.join(path, "temp", "Backup", "bak"),
                "sourcedir": os.path.join(path, "src"),
                "ropeFolder": os.path.join(path, "Rope"),
                "buildprofile": os.path.join(path, "Build", "profile.xml"),
                "ropeprofile": os.path.join(path, "Rope", "profile.xml"),
                "projectmainfile": os.path.join(path, "project.xml"),
                "iconsdir": os.path.join(path, "Resources", "Icons"),
                "root": path
                }

            if sys.platform == 'win32':
                projectPathDict["venvdir"] = os.path.join(path,
                               "Resources", "VirtualEnv", "Windows", "Venv")
            elif sys.platform == 'darwin':
                projectPathDict["venvdir"] = os.path.join(path,
                               "Resources", "VirtualEnv", "Mac", "Venv")
            else:
                projectPathDict["venvdir"] = os.path.join(path,
                               "Resources", "VirtualEnv", "Linux", "Venv")

            try:
                project_data = self.readProject(path)
                if project_data is False:
                    QtGui.QApplication.restoreOverrideCursor()
                    message = QtGui.QMessageBox.warning(self, "Open Project",
                                                        "Failed:\n\n" + path)
                    return
                projectPathDict["name"] = project_data[1]["Name"]
                projectPathDict["type"] = project_data[1]["Type"]
                projectPathDict["mainscript"] = os.path.join(path, "src",
                               project_data[1]["MainScript"])
                if sys.platform == 'win32':
                    projectPathDict["builddir"] = os.path.join(
                        path, "Build", "Windows")
                elif sys.platform == 'darwin':
                    projectPathDict["builddir"] = os.path.join(
                        path, "Build", "Mac")
                else:
                    projectPathDict["builddir"] = os.path.join(
                        path, "Build", "Linux")

                p_name = os.path.basename(path)

                projectWindow = EditorWindow(projectPathDict, self.library,
                                             self.busyWidget, self.settingsWidget.colorScheme,
                                             self.useData, self.app, self)
                if new:
                    projectWindow.editorTabWidget.loadfile(
                        projectPathDict["mainscript"])
                else:
                    projectWindow.restoreSession()
                projectWindow.editorTabWidget.updateWindowTitle.connect(
                    self.pcode.updateWindowTitle)

                self.pcode.addProject(projectWindow, p_name)

                if path in self.useData.OPENED_PROJECTS:
                    self.useData.OPENED_PROJECTS.remove(path)
                    self.useData.OPENED_PROJECTS.insert(0, path)
                else:
                    self.useData.OPENED_PROJECTS.insert(0, path)
                if show:
                    self.pcode.showProject(path)
            except Exception as err:
                exc_type, exc_value, exc_traceback = sys.exc_info()
                logging.error(
                    repr(traceback.format_exception(exc_type, exc_value,
                             exc_traceback)))
                QtGui.QApplication.restoreOverrideCursor()
                message = QtGui.QMessageBox.warning(self, "Failed Open",
                                                    "Problem opening project: \n\n" + str(err))
            QtGui.QApplication.restoreOverrideCursor()

    def closeProject(self):
        window = self.projectWindowStack.currentWidget()
        path = window.projectPathDict["root"]
        closed = window.closeWindow()
        if closed:
            self.pcode.removeProject(window)
            self.useData.OPENED_PROJECTS.remove(path)

    def createProject(self, data):
        self.createProjectThread.create(data)
        self.busyWidget.showBusy(True, "Creating project... please wait!")

    def finalizeNewProject(self):
        self.busyWidget.showBusy(False)
        if self.createProjectThread.error is not False:
            message = QtGui.QMessageBox.warning(self, "New Project",
                                                "Failed to create project:\n\n" + self.createProjectThread.error)
        else:
            projectPath = os.path.normpath(
                self.createProjectThread.projectPath)  # otherwise an error will occur in rope
            self.loadProject(projectPath, True, True)

########NEW FILE########
__FILENAME__ = Refactor
import sys
import os
import traceback
import logging

from PyQt4 import QtGui, QtCore

# rope
from rope.refactor.rename import Rename
from rope.refactor.topackage import ModuleToPackage
from rope.refactor import inline
from rope.refactor.localtofield import LocalToField
from rope.base.project import Project
from rope.base import libutils

from rope.contrib.findit import (find_occurrences, find_implementations,
                                 find_definition)
from Extensions.Refactor.UsageDialog import UsageDialog


class GetName(QtGui.QDialog):

    def __init__(self, caption, defaultText, parent=None):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle(caption)

        mainLayout = QtGui.QVBoxLayout()

        mainLayout.addWidget(QtGui.QLabel("New name:"))

        self.nameLine = QtGui.QLineEdit()
        self.nameLine.setText(defaultText)
        self.nameLine.selectAll()
        self.nameLine.textChanged.connect(self.enableAcceptButton)
        mainLayout.addWidget(self.nameLine)

        hbox = QtGui.QHBoxLayout()

        self.statusLabel = QtGui.QLabel()
        hbox.addWidget(self.statusLabel)

        hbox.addStretch(1)

        self.acceptButton = QtGui.QPushButton("Ok")
        self.acceptButton.setDisabled(True)
        self.acceptButton.clicked.connect(self.accept)
        hbox.addWidget(self.acceptButton)

        self.cancelButton = QtGui.QPushButton("Cancel")
        self.cancelButton.clicked.connect(self.cancel)
        hbox.addWidget(self.cancelButton)

        mainLayout.addLayout(hbox)

        self.setLayout(mainLayout)

        self.resize(300, 20)
        self.enableAcceptButton()

        self.exec_()

    def enableAcceptButton(self):
        text = self.nameLine.text().strip()
        if text == '':
            self.acceptButton.setDisabled(True)
        else:
            self.acceptButton.setDisabled(False)

    def accept(self):
        self.accepted = True
        self.text = self.nameLine.text().strip()
        self.close()

    def cancel(self):
        self.accepted = False
        self.close()


class FindUsageThread(QtCore.QThread):

    def run(self):
        self.error = None
        self.foundList = []
        try:
            resource = self.ropeProject.get_file(self.path)
            result = find_occurrences(self.ropeProject, resource, self.offset)
            self.itemsDict = {}
            if len(result) == 0:
                self.error = "No usages found."
            else:
                for i in result:
                    line = i.lineno
                    path = i.resource.path
                    if path in self.itemsDict:
                        self.itemsDict[path].append(line)
                    else:
                        self.itemsDict[path] = [line]
        except Exception as err:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                         exc_traceback)))

            self.error = str(err)

    def find(self, path, ropeProject, offset):
        self.path = path
        self.ropeProject = ropeProject
        self.offset = offset

        self.start()


class RenameThread(QtCore.QThread):

    def run(self):
        self.error = None
        self.changedFiles = []
        try:
            self.ropeProject.validate()
            rename = Rename(self.ropeProject, libutils.path_to_resource(
                self.ropeProject, self.path), self.offset)
            changes = rename.get_changes(self.new_name)
            self.ropeProject.do(changes)
            changed = changes.get_changed_resources()
            # changed is a set
            for i in changed:
                self.changedFiles.append(i.real_path)
        except Exception as err:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                         exc_traceback)))
                             
            self.error = str(err)

    def rename(self, new_name, path, ropeProject, offset):
        self.new_name = new_name
        self.path = path
        self.ropeProject = ropeProject
        self.offset = offset

        self.start()


class InlineThread(QtCore.QThread):

    def run(self):
        self.error = None
        self.changedFiles = []
        try:
            inlined = inline.create_inline(
                self.ropeProject, self.resource, self.offset)
            changes = inlined.get_changes()
            self.ropeProject.do(changes)
            changed = changes.get_changed_resources()
            # changed is a set
            for i in changed:
                self.changedFiles.append(i.real_path)
        except Exception as err:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                         exc_traceback)))
            
            self.error = str(err)

    def inline(self, project, resource, offset):
        self.resource = resource
        self.ropeProject = project
        self.offset = offset

        self.start()


class LocalToFieldThread(QtCore.QThread):

    def run(self):
        self.error = None
        self.changedFiles = []
        try:
            convert = LocalToField(
                self.ropeProject, self.resource, self.offset)
            changes = convert.get_changes()
            self.ropeProject.do(changes)
            changed = changes.get_changed_resources()
            # changed is a set
            for i in changed:
                self.changedFiles.append(i.real_path)
        except Exception as err:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                         exc_traceback)))

            self.error = str(err)

    def convert(self, project, resource, offset):
        self.resource = resource
        self.ropeProject = project
        self.offset = offset

        self.start()


class ModuleToPackageThread(QtCore.QThread):

    def run(self):
        self.error = None
        try:
            convert = ModuleToPackage(self.ropeProject,
                                      libutils.path_to_resource(self.ropeProject, self.path))
            changes = convert.get_changes()
            self.ropeProject.do(changes)
        except Exception as err:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                         exc_traceback)))

            self.error = str(err)

    def convert(self, path, ropeProject):
        self.path = path
        self.ropeProject = ropeProject

        self.start()


class Refactor(QtGui.QWidget):

    def __init__(self, editorTabWidget, busyWidget, parent=None):
        QtGui.QWidget.__init__(self, parent)

        self.editorTabWidget = editorTabWidget
        self.busyWidget = busyWidget
        self.root = editorTabWidget.projectPathDict["sourcedir"]
        self.useData = editorTabWidget.useData
        ropeFolder = editorTabWidget.projectPathDict["ropeFolder"]

        libraryList = []
        for i, v in self.useData.libraryDict.items():
            libraryList.extend(v[0])
        prefs = {
            'ignored_resources': ['*.pyc', '*~', '.ropeproject',
                                  '.hg', '.svn', '_svn', '.git',
                                  '__pycache__'],
            'python_files': ['*.py', '*.pyw'],
            'save_objectdb': True,
            'compress_objectdb': False,
            'automatic_soa': True,
            'soa_followed_calls': 0,
            'perform_doa': True,
            'validate_objectdb': True,
            'max_history_items': 32,
            'save_history': True,
            'compress_history': False,
            'indent_size': 4,
            'extension_modules': libraryList,
            'import_dynload_stdmods': True,
            'ignore_syntax_errors': True,
            'ignore_bad_imports': True
            }

        self.ropeProject = Project(
            projectroot=self.root, ropefolder=ropeFolder, **prefs)
        self.ropeProject.prefs.add('python_path', 'c:/Python33')
        self.ropeProject.prefs.add('source_folders', 'c:/Python33/Lib')
        self.ropeProject.validate()

        self.noProject = Project(projectroot="temp", ropefolder=None)

        self.findThread = FindUsageThread()
        self.findThread.finished.connect(self.findOccurrencesFinished)

        self.renameThread = RenameThread()
        self.renameThread.finished.connect(self.renameFinished)

        self.inlineThread = InlineThread()
        self.inlineThread.finished.connect(self.inlineFinished)

        self.localToFieldThread = LocalToFieldThread()
        self.localToFieldThread.finished.connect(self.localToFieldFinished)

        self.moduleToPackageThread = ModuleToPackageThread()
        self.moduleToPackageThread.finished.connect(
            self.moduleToPackageFinished)

        self.createActions()

        self.refactorMenu = QtGui.QMenu("Refactor")
        self.refactorMenu.addAction(self.renameAttributeAct)
        self.refactorMenu.addAction(self.inlineAct)
        self.refactorMenu.addAction(self.localToFieldAct)

    def closeRope(self):
        self.ropeProject.close()

    def createActions(self):
        self.findDefAct = \
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "map_marker")),
                "Go-to Definition", self, statusTip="Go-to Definition",
                triggered=self.findDefinition)

        self.findOccurrencesAct = \
            QtGui.QAction("Usages", self, statusTip="Usages",
                          triggered=self.findOccurrences)

        self.moduleToPackageAct = \
            QtGui.QAction(
                "Convert to Package", self, statusTip="Convert to Package",
                triggered=self.moduleToPackage)

        self.renameModuleAct = \
            QtGui.QAction("Rename", self, statusTip="Rename",
                          triggered=self.renameModule)

        self.renameAttributeAct = \
            QtGui.QAction("Rename", self, statusTip="Rename",
                          triggered=self.renameAttribute)

        self.inlineAct = \
            QtGui.QAction("Inline", self, statusTip="Inline",
                          triggered=self.inline)

        self.localToFieldAct = \
            QtGui.QAction("Local-to-Field", self, statusTip="Local-to-Field",
                          triggered=self.localToField)

    def renameModule(self):
        index = self.editorTabWidget.currentIndex()
        moduleName = self.editorTabWidget.tabText(index)
        moduleName = os.path.splitext(moduleName)[0]
        newName = GetName("Rename", moduleName, self)
        project = self.getProject()
        if newName.accepted:
            saved = self.editorTabWidget.saveProject()
            if saved:
                path = self.editorTabWidget.getEditorData("filePath")
                self.renameThread.rename(newName.text, path, project, None)
                self.busyWidget.showBusy(True, "Renaming... please wait!")

    def renameAttribute(self):
        objectName = self.editorTabWidget.get_current_word()
        if objectName == '':
            self.editorTabWidget.showNotification(
                "No word under cursor.")
            return
        newName = GetName("Rename", objectName, self)
        if newName.accepted:
            project = self.getProject()
            saved = self.editorTabWidget.saveProject()
            if saved:
                offset = self.getOffset()
                path = self.editorTabWidget.getEditorData("filePath")
                self.renameThread.rename(newName.text, path, project, offset)
                self.busyWidget.showBusy(True, "Renaming... please wait!")

    def renameFinished(self):
        self.busyWidget.showBusy(False)
        if self.renameThread.error is not None:
            message = QtGui.QMessageBox.warning(self, "Failed Rename",
                                                self.renameThread.error)
            return
        if self.renameThread.offset is None:
            # filename has been changed
            oldPath = self.editorTabWidget.getEditorData("filePath")
            ext = os.path.splitext(oldPath)[1]
            newPath = os.path.join(os.path.dirname(oldPath),
                                   self.renameThread.new_name + ext)
            self.editorTabWidget.updateEditorData("filePath", newPath)
        else:
            if len(self.renameThread.changedFiles) > 0:
                self.editorTabWidget.reloadModules(
                    self.renameThread.changedFiles)

    def inline(self):
        offset = self.getOffset()
        path = self.editorTabWidget.getEditorData("filePath")
        project = self.getProject()
        resource = project.get_file(path)
        saved = self.editorTabWidget.saveProject()
        if saved:
            self.inlineThread.inline(project, resource, offset)
            self.busyWidget.showBusy(True, "Inlining... please wait!")

    def inlineFinished(self):
        self.busyWidget.showBusy(False)
        if self.inlineThread.error is not None:
            message = QtGui.QMessageBox.warning(self, "Failed Inline",
                                                self.inlineThread.error)
            return
        if len(self.inlineThread.changedFiles) > 0:
            self.editorTabWidget.reloadModules(self.inlineThread.changedFiles)

    def localToField(self):
        offset = self.getOffset()
        path = self.editorTabWidget.getEditorData("filePath")
        project = self.getProject()
        resource = project.get_file(path)
        saved = self.editorTabWidget.saveProject()
        if saved:
            self.localToFieldThread.convert(project, resource, offset)
            self.busyWidget.showBusy(
                True, "Converting Local to Field... please wait!")

    def localToFieldFinished(self):
        self.busyWidget.showBusy(False)
        if self.localToFieldThread.error is not None:
            message = QtGui.QMessageBox.warning(self, "Failed Local-to-Field",
                                                self.localToFieldThread.error)
            return
        if len(self.localToFieldThread.changedFiles) > 0:
            self.editorTabWidget.reloadModules(
                self.localToFieldThread.changedFiles)

    def findDefinition(self):
        saved = self.editorTabWidget.saveProject()
        if saved:
            offset = self.getOffset()
            path = self.editorTabWidget.getEditorData("filePath")
            project = self.getProject()
            resource = project.get_file(path)
            try:
                result = find_definition(project,
                                         self.editorTabWidget.getSource(), offset, resource)
                if result is None:
                    self.editorTabWidget.showNotification(
                        "No definition found.")
                else:
                    start, end = result.region
                    offset = result.offset
                    line = result.lineno
                    result_path = result.resource.path
                    sourcePath = self.editorTabWidget.projectPathDict[
                        "sourcedir"]
                    if not os.path.isabs(result_path):
                        result_path = os.path.join(sourcePath, result_path)
                    if os.path.samefile(result_path, path):
                        pass
                    else:
                        self.editorTabWidget.loadfile(result_path)
                    editor = self.editorTabWidget.focusedEditor()
                    start = editor.lineIndexFromPosition(start)
                    end = editor.lineIndexFromPosition(end)
                    editor.setSelection(start[0], start[1], end[0], end[1])
                    editor.ensureLineVisible(line - 1)
            except Exception as err:
                self.editorTabWidget.showNotification(str(err))

    def moduleToPackage(self):
        path = self.editorTabWidget.getEditorData("filePath")
        project = self.getProject()
        saved = self.editorTabWidget.saveProject()
        if saved:
            self.moduleToPackageThread.convert(path, project)
            self.busyWidget.showBusy(True, "Converting... please wait!")

    def moduleToPackageFinished(self):
        self.busyWidget.showBusy(False)
        if self.moduleToPackageThread.error is not None:
            message = QtGui.QMessageBox.warning(self, "Failed to convert",
                                                self.moduleToPackageThread.error)

    def findOccurrences(self):
        self.objectName = self.editorTabWidget.get_current_word()
        if self.objectName == '':
            self.editorTabWidget.showNotification(
                "No word under cursor.")
            return
        offset = self.getOffset()
        project = self.getProject()
        saved = self.editorTabWidget.saveProject()
        if saved:
            path = self.editorTabWidget.getEditorData("filePath")
            self.findThread.find(path, project, offset)
            self.busyWidget.showBusy(True, "Finding usages... please wait!")

    def findOccurrencesFinished(self):
        self.busyWidget.showBusy(False)
        if self.findThread.error is not None:
            self.editorTabWidget.showNotification(self.findThread.error)
            return
        if len(self.findThread.itemsDict) > 0:
            foundList = []
            for parent, lines in self.findThread.itemsDict.items():
                parentItem = QtGui.QTreeWidgetItem()
                parentItem.setForeground(0, QtGui.QBrush(
                    QtGui.QColor("#003366")))
                parentItem.setText(0, parent)
                for line in lines:
                    childItem = QtGui.QTreeWidgetItem()
                    childItem.setText(0, str(line))
                    childItem.setFirstColumnSpanned(True)
                    parentItem.addChild(childItem)
                    foundList.append(parentItem)
            usageDialog = UsageDialog(
                self.editorTabWidget, "Usages: " + self.objectName, foundList, self)
        else:
            self.editorTabWidget.showNotification("No usages found.")

    def getOffset(self):
        return self.editorTabWidget.getOffset()

    def get_absolute_coordinates(self):
        editor = self.editorTabWidget.focusedEditor()
        point = editor.get_absolute_coordinates()
        return point

    def getProject(self):
        path = self.editorTabWidget.getEditorData("filePath")
        if path is None:
            return self.noProject
        if path.startswith(self.editorTabWidget.projectPathDict["sourcedir"]):
            return self.ropeProject
        else:
            return self.noProject

########NEW FILE########
__FILENAME__ = UsageDialog
import os
from PyQt4 import QtCore, QtGui


class UsageDialog(QtGui.QDialog):

    def __init__(self, editorTabWidget, title, itemsList, parent=None):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle(title)
        self.resize(600, 300)

        self.editorTabWidget = editorTabWidget

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setMargin(0)
        self.setLayout(mainLayout)

        self.view = QtGui.QTreeWidget()
        self.view.setHeaderLabels(["#"])
        self.view.setColumnWidth(0, 300)
        self.view.setSortingEnabled(True)
        self.view.sortByColumn(0, QtCore.Qt.AscendingOrder)
        self.view.itemActivated.connect(self.showLine)
        mainLayout.addWidget(self.view)

        for item in itemsList:
            self.view.addTopLevelItem(item)

        self.exec_()

    def showLine(self, item):
        if item.parent() is None:
            return
        path = item.parent().text(0)
        fullPath = os.path.join(
            self.editorTabWidget.projectPathDict["sourcedir"], path)
        self.editorTabWidget.loadfile(fullPath)
        line = int(item.text(0)) - 1
        self.editorTabWidget.showLine(line)

########NEW FILE########
__FILENAME__ = SearchWidget
import os
from PyQt4 import QtCore, QtGui


class SearchWidget(QtGui.QLabel):

    def __init__(self, useData, editorTabWidget, parent=None):
        QtGui.QDialog.__init__(self, parent)

        self.useData = useData
        self.editorTabWidget = editorTabWidget

        self.mainLayout = QtGui.QVBoxLayout()
        self.mainLayout.setContentsMargins(5, 0, 0, 0)

        self.createFindWidget()
        self.createReplaceWidget()

        self.setLayout(self.mainLayout)

        self.matchCase = False
        self.matchWholeWord = False
        self.matchRegExp = False
        self.wrapAround = False

        self.hide()

    def createFindWidget(self):
        self.textFinderWidget = QtGui.QWidget()

        hbox = QtGui.QHBoxLayout()
        hbox.setMargin(0)
        hbox.addWidget(QtGui.QLabel("Find:"))

        self.findLine = QtGui.QLineEdit()
        self.findLine.textEdited.connect(self.find)
        self.previousWordLength = 0
        hbox.addWidget(self.findLine)

        self.findDownButton = QtGui.QToolButton()
        self.findDownButton.setAutoRaise(True)
        self.findDownButton.setIconSize(QtCore.QSize(20, 20))
        self.findDownButton.setDefaultAction(
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "findDown")),
                "Find Next", self, triggered=self.findNext))
        hbox.addWidget(self.findDownButton)

        self.findUpButton = QtGui.QToolButton()
        self.findUpButton.setAutoRaise(True)
        self.findUpButton.setIconSize(QtCore.QSize(20, 20))
        self.findUpButton.setDefaultAction(
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "findUp")),
                "Find Previous", self,
                triggered=self.findPrevious))
        hbox.addWidget(self.findUpButton)

        self.matchCaseBox = QtGui.QCheckBox("MC")
        self.matchCaseBox.setToolTip("Match Case")
        self.matchCaseBox.stateChanged.connect(self.updateFindOptions)
        hbox.addWidget(self.matchCaseBox)

        self.matchWholeWordBox = QtGui.QCheckBox("WW")
        self.matchWholeWordBox.setToolTip("Whole Word")
        self.matchWholeWordBox.stateChanged.connect(
            self.updateFindOptions)
        hbox.addWidget(self.matchWholeWordBox)

        self.matchRegExpBox = QtGui.QCheckBox("RE")
        self.matchRegExpBox.setToolTip("Regular Expression")
        self.matchRegExpBox.stateChanged.connect(self.updateFindOptions)
        hbox.addWidget(self.matchRegExpBox)

        self.wrapAroundBox = QtGui.QCheckBox("WA")
        self.wrapAroundBox.setToolTip("Wrap Around")
        self.wrapAroundBox.stateChanged.connect(self.updateFindOptions)
        hbox.addWidget(self.wrapAroundBox)

        hbox.addStretch(1)

        self.hideFindWidgetButton = QtGui.QToolButton()
        self.hideFindWidgetButton.setAutoRaise(True)
        self.hideFindWidgetButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "exit")))
        self.hideFindWidgetButton.clicked.connect(self.hideFindWidget)
        hbox.addWidget(self.hideFindWidgetButton)

        self.textFinderWidget.setLayout(hbox)
        hbox.setStretch(1, 1)
        self.mainLayout.addWidget(self.textFinderWidget)

    def createReplaceWidget(self):
        self.replacerWidget = QtGui.QWidget()

        hbox = QtGui.QHBoxLayout()
        hbox.setMargin(0)
        hbox.addStretch(1)

        label = QtGui.QLabel("Replace with:")
        hbox.addWidget(label)

        self.replaceLine = QtGui.QLineEdit()
        hbox.addWidget(self.replaceLine)

        self.replaceButton = QtGui.QPushButton("Replace")
        self.replaceButton.clicked.connect(self.replace)
        hbox.addWidget(self.replaceButton)

        self.replaceAllButton = QtGui.QPushButton("Replace All")
        self.replaceAllButton.clicked.connect(self.replaceAll)
        hbox.addWidget(self.replaceAllButton)

        hbox.addStretch(1)

        self.replacerWidget.setLayout(hbox)
        hbox.setStretch(2, 1)
        self.mainLayout.addWidget(self.replacerWidget)

    def showFinder(self):
        self.mainLayout.setContentsMargins(5, 0, 5, 0)
        self.setMinimumHeight(30)
        self.setMaximumHeight(30)
        self.replacerWidget.hide()

        self.show()
        self.fixTextAtCursor()
        self.textFinderWidget.show()
        self.findLine.selectAll()
        self.findLine.setFocus()

    def fixTextAtCursor(self):
        editor = self.editorTabWidget.focusedEditor()
        self.findLine.selectAll()
        if editor.hasSelectedText():
            selection = editor.selectedText()
            self.findLine.insert(selection)

    def showReplaceWidget(self):
        self.mainLayout.setContentsMargins(5, 5, 5, 5)
        self.setMinimumHeight(70)
        self.setMaximumHeight(70)
        self.findLine.setText(self.editorTabWidget.get_current_word())
        self.show()
        self.fixTextAtCursor()
        self.replacerWidget.show()
        self.findLine.selectAll()
        self.findLine.setFocus()

    def hideFindWidget(self):
        self.hide()

    def updateFindOptions(self):
        self.matchCase = self.matchCaseBox.isChecked()
        self.matchWholeWord = self.matchWholeWordBox.isChecked()
        self.matchRegExp = self.matchRegExpBox.isChecked()
        self.wrapAround = self.wrapAroundBox.isChecked()

        self.find()

    def find(self):
        text = self.findLine.text()
        editor = self.editorTabWidget.focusedEditor()
        if text == '':
            self.findLine.setStyleSheet(
                "QLineEdit {border-bottom: 1px solid lightgrey;}")
            editor.clearAllIndicators(editor.searchIndicator)
        else:
            if self.useData.SETTINGS['DynamicSearch'] == 'True':
                editor.clearAllIndicators(editor.searchIndicator)
                found = editor.findFirst(text, self.matchRegExp,
                                         self.matchCase, self.matchWholeWord, self.wrapAround, True, 0, 0, True)
                if found:
                    self.findLine.setStyleSheet(
                        "QLineEdit {border-bottom: 1px solid lightgrey;}")
                else:
                    self.findLine.setStyleSheet(
                        "QLineEdit {border-bottom: 2px solid #FF6666;}")

    def findNext(self):
        text = self.findLine.text()
        editor = self.editorTabWidget.focusedEditor()
        if text == '':
            pass
        else:
            editor.findFirst(text, self.matchRegExp,
                             self.matchCase, self.matchWholeWord, self.wrapAround,
                             True, -1, -1, True)

    def findPrevious(self):
        text = self.findLine.text()
        editor = self.editorTabWidget.focusedEditor()
        if text == '':
            pass
        else:
            editor.findFirst(text, self.matchRegExp,
                             self.matchCase, self.matchWholeWord,
                             self.wrapAround, False, -1, -1, True)
            editor.findNext()

    def replace(self):
        # FIXME Text replace only works after finding next
        # not after finding previous
        text = self.findLine.text()
        replaceText = self.replaceLine.text()
        editor = self.editorTabWidget.focusedEditor()
        if editor.hasSelectedText():
            pass
        else:
            editor.findFirst(text, self.matchRegExp,
                             self.matchCase, self.matchWholeWord, self.wrapAround,
                             True, -1, -1, True)
        editor.replace(replaceText)
        found = editor.findFirst(text, self.matchRegExp,
                                 self.matchCase, self.matchWholeWord, self.wrapAround,
                                 True, -1, -1, True)

    def replaceAll(self):
        text = self.findLine.text()
        replaceText = self.replaceLine.text()
        editor = self.editorTabWidget.focusedEditor()
        editor.setCursorPosition(0, 0)
        find = editor.findFirst(text,
                                self.matchRegExp,
                                self.matchCase, self.matchWholeWord, self.wrapAround,
                                True, 1, 1, True)
        editor.beginUndoAction()
        while find:
            editor.replace(replaceText)
            find = editor.findNext()
        editor.endUndoAction()

########NEW FILE########
__FILENAME__ = ColorChooser
from PyQt4 import QtCore, QtGui


class ColorChooser(QtGui.QWidget):

    colorChanged = QtCore.pyqtSignal(str)

    def __init__(self, parent=None):
        QtGui.QWidget.__init__(self, parent)

        hbox = QtGui.QHBoxLayout()
        hbox.setMargin(0)
        self.setLayout(hbox)

        self.colorHexLine = QtGui.QLineEdit()
        self.colorHexLine.textChanged.connect(self.updateColor)
        hbox.addWidget(self.colorHexLine)

        self.colorButton = QtGui.QPushButton()
        self.colorButton.clicked.connect(self.chooseColor)
        hbox.addWidget(self.colorButton)

    def updateColor(self):
        self.styleButton()
        self.colorChanged.emit(self.colorHexLine.text())

    def setColor(self, color):
        self.colorHexLine.setText(color)

    def chooseColor(self):
        color = self.colorHexLine.text()
        color = QtGui.QColorDialog.getColor(QtGui.QColor(color), self)
        if not color.isValid():
            return
        self.colorHexLine.setText(color.name())

    def styleButton(self):
        colorHex = self.colorHexLine.text()
        color = QtGui.QColor(colorHex)
        if color.isValid():
            self.colorButton.setAutoFillBackground(True)
            style = ("""background: {0};
                         min-width: 70;
                         max-height: 30;
                         border: 1px solid lightgrey;
                         border-radius: 0px;""".format(colorHex))
            self.colorButton.setStyleSheet(style)

########NEW FILE########
__FILENAME__ = ColorScheme
import os
from PyQt4 import QtCore, QtGui, QtXml

from Extensions.Settings.ColorScheme.StyleEditor import StyleEditor
from Extensions.Settings.ColorScheme.StyleLexer import StyleLexer


class GetName(QtGui.QDialog):

    def __init__(self, caption, path, defaultText=None, parent=None):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle(caption)

        self.path = path

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.addWidget(QtGui.QLabel("Name:"))

        self.nameLine = QtGui.QLineEdit()
        if defaultText is not None:
            self.nameLine.setText(defaultText)
        self.nameLine.selectAll()
        self.nameLine.textChanged.connect(self.enableAcceptButton)
        mainLayout.addWidget(self.nameLine)

        hbox = QtGui.QHBoxLayout()

        self.statusLabel = QtGui.QLabel()
        hbox.addWidget(self.statusLabel)

        hbox.addStretch(1)

        self.acceptButton = QtGui.QPushButton("Ok")
        self.acceptButton.setDisabled(True)
        self.acceptButton.clicked.connect(self.accept)
        hbox.addWidget(self.acceptButton)

        self.closeButton = QtGui.QPushButton("Cancel")
        self.closeButton.clicked.connect(self.close)
        hbox.addWidget(self.closeButton)

        mainLayout.addLayout(hbox)

        self.setLayout(mainLayout)

        self.resize(300, 20)
        self.enableAcceptButton()

        self.accepted = False

        self.exec_()

    def enableAcceptButton(self):
        text = self.nameLine.text().strip()
        if text == '':
            self.acceptButton.setDisabled(True)
        else:
            preExistNames = os.listdir(self.path)
            if text in preExistNames:
                self.statusLabel.setText("Unavailable")
                self.acceptButton.setDisabled(True)
            else:
                self.acceptButton.setDisabled(False)
                preExistNames = os.listdir(self.path)
                if (text in preExistNames) or (text == 'Default'):
                    self.statusLabel.setText("Unavailable")
                    self.acceptButton.setDisabled(True)
                else:
                    self.statusLabel.setText("Available")
                    self.acceptButton.setDisabled(False)

    def accept(self):
        self.accepted = True
        self.name = self.nameLine.text().strip()
        self.close()


class ColorScheme(QtGui.QDialog):

    def __init__(self, useData, projectWindowStack, libraryViewer, parent=None):
        super(ColorScheme, self).__init__(parent)

        self.useData = useData
        self.projectWindowStack = projectWindowStack
        self.libraryViewer = libraryViewer

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setMargin(5)
        self.setLayout(mainLayout)

        optionsTab = QtGui.QTabWidget()

        self.editorStyler = StyleEditor(self.useData)
        self.lexerStyler = StyleLexer(self.editorStyler, self.useData)
        self.editorStyler.paperChanged.connect(
            self.lexerStyler.reloadStyles.emit)

        optionsTab.addTab(self.lexerStyler,
                          QtGui.QIcon(os.path.join("Resources", "images", "edit-color")), "Lexer")
        optionsTab.addTab(self.editorStyler,
                          QtGui.QIcon(os.path.join("Resources", "images", "ui-scroll-pane-blog")), "Editor")

        mainLayout.addWidget(optionsTab)

        self.schemeTypeBox = QtGui.QComboBox()
        self.schemeTypeBox.addItem("Python")
        self.schemeTypeBox.addItem("Xml")
        self.schemeTypeBox.addItem("Html")
        self.schemeTypeBox.addItem("Css")
        self.schemeTypeBox.currentIndexChanged.connect(self.groupChanged)
        mainLayout.addWidget(self.schemeTypeBox)

        hbox = QtGui.QHBoxLayout()

        self.schemeNameBox = QtGui.QComboBox()
        self.schemeNameBox.setMinimumWidth(180)
        self.loadSchemeNames()
        self.schemeNameBox.currentIndexChanged.connect(self.updateScheme)
        hbox.addWidget(self.schemeNameBox)

        self.newButton = QtGui.QToolButton()
        self.newButton.setAutoRaise(True)
        self.newButton.setDefaultAction(
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "add")),
                "New", self, triggered=self.newScheme))
        hbox.addWidget(self.newButton)

        self.renameButton = QtGui.QToolButton()
        self.renameButton.setAutoRaise(True)
        self.renameButton.setDefaultAction(
            QtGui.QAction(
                QtGui.QIcon(
                    os.path.join("Resources", "images", "ui-text-field")),
                "Rename", self, triggered=self.rename))
        self.renameButton.setDisabled(True)
        hbox.addWidget(self.renameButton)

        self.removeButton = QtGui.QToolButton()
        self.removeButton.setAutoRaise(True)
        self.removeButton.setDefaultAction(
            QtGui.QAction(
                QtGui.QIcon(os.path.join("Resources", "images", "minus")),
                "Remove", self, triggered=self.remove))
        self.removeButton.setDisabled(True)
        hbox.addWidget(self.removeButton)

        hbox.addStretch(1)

        self.saveButton = QtGui.QPushButton("Save")
        self.saveButton.clicked.connect(self.saveStyleChanges)
        self.saveButton.setDisabled(True)
        hbox.addWidget(self.saveButton)

        self.applyButton = QtGui.QPushButton("Apply")
        self.applyButton.clicked.connect(self.applyScheme)
        hbox.addWidget(self.applyButton)

        mainLayout.addLayout(hbox)

        index = self.schemeNameBox.findText(
            self.useData.SETTINGS["EditorStylePython"])
        self.schemeNameBox.setCurrentIndex(index)

    def groupChanged(self):
        self.loadSchemeNames()
        self.updateScheme()

    def loadSchemeNames(self):
        self.schemeNameBox.clear()
        self.schemeNameBox.addItem(
            QtGui.QIcon(os.path.join("Resources", "images", "mail_pinned")),
            "Default")
        groupName = self.schemeTypeBox.currentText()
        path = os.path.join(self.useData.appPathDict["stylesdir"], groupName)
        for i in os.listdir(path):
            self.schemeNameBox.addItem(QtGui.QIcon(
                os.path.join("Resources", "images", "foaf")), os.path.splitext(i)[0])
        self.lexerStyler.updatePropertyListWidget(groupName)

    def updateScheme(self):
        name = self.schemeNameBox.currentText()
        groupName = self.schemeTypeBox.currentText()
        if name == '':
            return
        self.editorStyler.setCurrentProperty(name, groupName)
        self.lexerStyler.setCurrentStyle(name, groupName)
        if name == "Default":
            self.saveButton.setDisabled(True)
            self.removeButton.setDisabled(True)
            self.renameButton.setDisabled(True)
        else:
            self.saveButton.setDisabled(False)
            self.removeButton.setDisabled(False)
            self.renameButton.setDisabled(False)

        self.editorStyler.propertyListWidget.setCurrentRow(0)

    def save(self, name=None):
        # save style
        dom_document = QtXml.QDomDocument("Scheme")

        main = dom_document.createElement("Attributes")
        dom_document.appendChild(main)

        root = dom_document.createElement("lexer")
        main.appendChild(root)

        for key, value in self.lexerStyler.currentStyle.items():
            tag = dom_document.createElement("property")
            tag.setAttribute("font", value[0])
            tag.setAttribute("color", value[1])
            tag.setAttribute("size", value[2])
            tag.setAttribute("bold", str(value[3]))
            tag.setAttribute("italic", str(value[4]))
            tag.setAttribute("paper", value[5])

            t = dom_document.createTextNode(key)
            tag.appendChild(t)
            root.appendChild(tag)

        root = dom_document.createElement("editor")
        main.appendChild(root)

        for key, value in self.editorStyler.currentProperties.items():
            tag = dom_document.createElement("property")
            root.appendChild(tag)

            tag.setAttribute("background", value[0])
            tag.setAttribute("foreground", value[1])
            if key == "Calltips":
                tag.setAttribute("highLight", value[2])
            if key == "Number Margin":
                tag.setAttribute("font", value[2])
                tag.setAttribute("size", str(value[3]))
                tag.setAttribute("bold", str(value[4]))
                tag.setAttribute("italic", str(value[5]))

            t = dom_document.createTextNode(key)
            tag.appendChild(t)

        if name is None:
            name = self.schemeNameBox.currentText()
        groupName = self.schemeTypeBox.currentText()
        path = os.path.join(
            self.useData.appPathDict["stylesdir"], groupName, name + '.xml')
        try:
            file = open(path, "w")
            file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            file.write(dom_document.toString())
            file.close()
        except Exception as err:
            message = QtGui.QMessageBox.warning(self, "Save",
                                                "Saving failed: {0}".format(str(err)))
            file.close()
            return

    def saveStyleChanges(self):
        currentScheme = self.schemeNameBox.currentText()
        self.save()
        f = self.schemeNameBox.findText(currentScheme)
        self.schemeNameBox.setCurrentIndex(f)

    def newScheme(self):
        themeName = GetName(
            "New Scheme", self.useData.appPathDict["stylesdir"],
            None, self)
        if themeName.accepted:
            self.save(themeName.name)
            self.loadSchemeNames()
            f = self.schemeNameBox.findText(themeName.name)
            self.schemeNameBox.setCurrentIndex(f)

    def rename(self):
        old_name = self.schemeNameBox.currentText()
        newName = GetName("Rename", self.useData.appPathDict["stylesdir"],
                          old_name, self)
        old_name = old_name + '.xml'
        if newName.accepted:
            groupName = self.schemeTypeBox.currentText()
            new_path = os.path.join(
                self.useData.appPathDict["stylesdir"], groupName,
                newName.name + '.xml')
            old_path = os.path.join(
                self.useData.appPathDict["stylesdir"], groupName,
                old_name)
            try:
                os.rename(old_path, new_path)
                self.loadSchemeNames()
                f = self.schemeNameBox.findText(newName.name)
                self.schemeNameBox.setCurrentIndex(f)
                if self.useData.SETTINGS["EditorStyle" + self.schemeTypeBox.currentText()] == old_name:
                    self.useData.SETTINGS[
                        "EditorStyle" + self.schemeTypeBox.currentText()] = newName.name
                    self.useData.saveUseData()
            except Exception as err:
                message = QtGui.QMessageBox.warning(self, "Rename",
                                                    "Rename failed!\n\n{0}".format(str(err)))

    def remove(self):
        index = self.schemeNameBox.currentIndex()
        currentScheme = self.schemeNameBox.currentText()

        mess = "Do you really want to remove '{0}'?".format(currentScheme)
        reply = QtGui.QMessageBox.warning(self, "Remove",
                                          mess, QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            schemeFullName = currentScheme + '.xml'
            groupName = self.schemeTypeBox.currentText()
            path = os.path.join(
                self.useData.appPathDict["stylesdir"], groupName,
                schemeFullName)
            try:
                os.remove(path)
                self.schemeNameBox.removeItem(index)
                self.updateScheme()
                if self.useData.SETTINGS["EditorStyle" + self.schemeTypeBox.currentText()] == currentScheme:
                    self.useData.SETTINGS[
                        "EditorStyle" + self.schemeTypeBox.currentText()] = self.schemeNameBox.currentText()
                    self.useData.saveUseData()
            except Exception as err:
                message = QtGui.QMessageBox.warning(self, "Remove",
                                                    "Removing failed!\n\n{0}".format(str(err)))
        elif reply == QtGui.QMessageBox.No:
            pass

    def applyScheme(self):
        schemeType = self.schemeTypeBox.currentText()
        schemeName = self.schemeNameBox.currentText()
        if self.schemeNameBox.currentIndex() != 0:
            self.save()
        self.useData.SETTINGS[
            "EditorStyle" + schemeType] = schemeName
        for i in range(self.projectWindowStack.count() - 1):
            window = self.projectWindowStack.widget(i)
            editorTabWidget = window.editorTabWidget
            for i in range(window.editorTabWidget.count()):
                editor = editorTabWidget.getEditor(i)
                if editor.DATA["fileType"] == 'python':
                    if schemeType != "Python":
                        continue
                elif editor.DATA["fileType"] == '.xml':
                    if schemeType != "Xml":
                        continue
                elif editor.DATA["fileType"] == '.html':
                    if schemeType != "Html":
                        continue
                elif editor.DATA["fileType"] == '.css':
                    if schemeType != "Css":
                        continue
                self.styleEditor(editor)
                editor2 = editorTabWidget.getCloneEditor(i)
                self.styleEditor(editor2)
                snapshot = editorTabWidget.getSnapshot(i)
                self.styleEditor(snapshot)
        self.styleEditor(self.libraryViewer)

    def styleEditor(self, editor):
        fileType = editor.DATA["fileType"]
        if fileType not in self.useData.supportedFileTypes:
            return None
        if fileType == "python":
            style_name = self.useData.SETTINGS["EditorStylePython"]
            groupName = "Python"
        elif fileType == ".xml":
            style_name = self.useData.SETTINGS["EditorStyleXml"]
            groupName = "Xml"
        elif fileType == ".html":
            style_name = self.useData.SETTINGS["EditorStyleHtml"]
            groupName = "Html"
        elif fileType == ".css":
            style_name = self.useData.SETTINGS["EditorStyleCss"]
            groupName = "Css"

        properties = self.editorStyler.loadProperties(style_name, groupName)
        paper = self.editorStyler.applyChanges(editor, properties)
        lexer = self.lexerStyler.createLexer(paper, style_name, groupName)
        editor.updateLexer(lexer)

        return lexer

########NEW FILE########
__FILENAME__ = CssLexer
import sys

from PyQt4 import QtGui
from PyQt4.Qsci import QsciLexerCSS

# Platform specific fonts
if sys.platform == 'win32':
    defaultFont = 'Consolas'
elif sys.platform == 'darwin':
    defaultFont = 'Monaco'
else:
    defaultFont = 'Bitstream Vera Sans Mono'

propertyID = {
                'UnknownPseudoClass': 4, 
                'DoubleQuotedString': 13, 
                'Tag': 1, 
                'Comment': 9, 
                'AtRule': 12, 
                'CSS1Property': 6, 
                'UnknownProperty': 7, 
                'Attribute': 16, 
                'CSS2Property': 15, 
                'PseudoElement': 18, 
                'Operator': 5, 
                'PseudoClass': 3, 
                'ExtendedCSSProperty': 19, 
                'Value': 8, 
                'MediaRule': 22, 
                'Variable': 23, 
                'ExtendedPseudoClass': 20, 
                'CSS3Property': 17, 
                'IDSelector': 10, 
                'Important': 11, 
                'ExtendedPseudoElement': 21, 
                'Default': 0, 
                'SingleQuotedString': 14
                }


def styleDescriptions():
    return propertyID.keys()


def defaultStyle():
    defaultStyle = {
        'UnknownPseudoClass': [defaultFont, '#D9007E', 10, False, False, '#ffffff'],
        'DoubleQuotedString': [defaultFont, '#00cc00', 10, False, False, '#ffffff'],
        'Tag': [defaultFont, '#E72500', 10, False, False, '#ffffff'],
        'Comment': [defaultFont, '#00CC00', 10, False, False, '#ffffff'],
        'AtRule': [defaultFont, '#0000ff', 10, False, False, '#ffffff'],
        'CSS1Property': [defaultFont, '#0000ff', 10, False, False, '#ffffff'],
        'UnknownProperty': [defaultFont, '#00aa00', 10, False, False, '#ffffff'],
        'Attribute': [defaultFont, '#000000', 10, False, False, '#ffffff'],
        'CSS2Property': [defaultFont, '#00aa00', 10, False, False, '#ffffff'],
        'PseudoElement': [defaultFont, '#000000', 10, False, False, '#ffffff'],
        'Operator': [defaultFont, '#0000ff', 10, False, False, '#ffffff'],
        'PseudoClass': [defaultFont, '#000000', 10, False, False, '#ffffff'],
        'ExtendedCSSProperty': [defaultFont, '#0000ff', 10, False, False, '#ffffff'],
        'Value': [defaultFont, '#000000', 10, False, False, '#ffffff'],
        'MediaRule': [defaultFont, '#00aa00', 10, False, False, '#ffffff'],
        'Variable': [defaultFont, '#0000ff', 10, False, False, '#ffffff'],
        'ExtendedPseudoClass': [defaultFont, '#0000ff', 10, False, False, '#ffffff'],
        'CSS3Property': [defaultFont, '#0000ff', 10, False, False, '#ffffff'],
        'IDSelector': [defaultFont, '#71AB71', 10, False, False, '#ffffff'],
        'Important': [defaultFont, '#0000ff', 10, False, False, '#ffffff'],
        'ExtendedPseudoElement': [defaultFont, '#0000ff', 10, False, False, '#ffffff'],
        'Default': [defaultFont, '#0000ff', 10, False, False, '#ffffff'],
        'SingleQuotedString': [defaultFont, '#00cc00', 10, False, False, '#ffffff'],
        }

    return defaultStyle


class CssLexer(QsciLexerCSS):

    def __init__(self, style, paper):
        QsciLexerCSS.__init__(self)

        self.lexerPaper = paper

        for key, attrib in style.items():
            value = propertyID[key]
            self.setColor(QtGui.QColor(attrib[1]), value)
            self.setEolFill(True, value)
            self.setPaper(QtGui.QColor(attrib[5]), value)
            if self.lexerPaper[0] == "Plain":
                self.setPaper(QtGui.QColor(attrib[5]), value)
            else:
                self.setPaper(QtGui.QColor(self.lexerPaper[1]), value)

            font = QtGui.QFont(attrib[0], attrib[2])
            font.setBold(attrib[3])
            font.setItalic(attrib[4])
            self.setFont(font, value)

        if self.lexerPaper[0] == "Plain":
            self.setDefaultPaper(QtGui.QColor("#ffffff"))
        else:
            self.setDefaultPaper(QtGui.QColor(self.lexerPaper[1]))

########NEW FILE########
__FILENAME__ = HtmlLexer
import sys


from PyQt4 import QtGui
from PyQt4.Qsci import QsciLexerHTML

# Platform specific fonts
if sys.platform == 'win32':
    defaultFont = 'Consolas'
elif sys.platform == 'darwin':
    defaultFont = 'Monaco'
else:
    defaultFont = 'Bitstream Vera Sans Mono'

propertyID = {'ASPPythonTripleSingleQuotedString': 112, 
                'JavaScriptCommentDoc': 44, 
                'PHPKeyword': 121, 
                'ASPPythonTripleDoubleQuotedString': 113, 
                'VBScriptUnclosedString': 77, 
                'ASPJavaScriptNumber': 60, 
                'PHPOperator': 127, 
                'PythonFunctionMethodName': 100, 
                'PythonTripleDoubleQuotedString': 98, 
                'PythonIdentifier': 102, 
                'ASPJavaScriptWord': 61, 
                'PHPVariable': 123, 
                'ASPPythonKeyword': 111, 
                'ASPPythonFunctionMethodName': 115, 
                'HTMLValue': 19, 
                'HTMLNumber': 5, 
                'HTMLSingleQuotedString': 7, 
                'JavaScriptNumber': 45, 
                'PythonTripleSingleQuotedString': 97, 
                'CDATA': 17, 
                'ASPJavaScriptStart': 55, 
                'ASPVBScriptComment': 82, 
                'HTMLComment': 9, 
                'ASPVBScriptNumber': 83, 
                'ASPJavaScriptSymbol': 65, 
                'JavaScriptSymbol': 50, 
                'PHPSingleQuotedString': 120, 
                'Attribute': 3, 
                'VBScriptStart': 70, 
                'PHPDefault': 118, 
                'ASPVBScriptUnclosedString': 87, 
                'PythonNumber': 93, 
                'ASPVBScriptStart': 80, 
                'SGMLParameterComment': 30, 
                'PHPCommentLine': 125, 
                'ASPStart': 16, 
                'ASPVBScriptIdentifier': 86, 
                'SGMLEntity': 28, 
                'VBScriptKeyword': 74, 
                'HTMLDoubleQuotedString': 6, 
                'Script': 14, 
                'XMLEnd': 13, 
                'Tag': 1, 
                'SGMLError': 26, 
                'ASPVBScriptKeyword': 84, 
                'JavaScriptKeyword': 47, 
                'JavaScriptWord': 46, 
                'ASPPythonOperator': 116, 
                'ASPJavaScriptKeyword': 62, 
                'ASPVBScriptDefault': 81, 
                'PythonKeyword': 96, 
                'UnknownTag': 2, 
                'ASPJavaScriptUnclosedString': 66, 
                'Entity': 10, 
                'ASPPythonComment': 107, 
                'VBScriptIdentifier': 76, 
                'PHPDoubleQuotedString': 119, 
                'XMLTagEnd': 11, 
                'ASPXCComment': 20, 
                'SGMLDoubleQuotedString': 24, 
                'VBScriptString': 75, 
                'JavaScriptComment': 42, 
                'ASPPythonStart': 105, 
                'JavaScriptDefault': 41, 
                'PHPDoubleQuotedVariable': 126, 
                'SGMLBlockDefault': 31, 
                'PythonDefault': 91, 
                'ASPPythonIdentifier': 117, 
                'ASPPythonNumber': 108, 
                'JavaScriptDoubleQuotedString': 48, 
                'JavaScriptSingleQuotedString': 49, 
                'PythonDoubleQuotedString': 94, 
                'ASPJavaScriptSingleQuotedString': 64, 
                'PHPStart': 18, 
                'SGMLParameter': 23, 
                'SGMLSpecial': 27, 
                'VBScriptNumber': 73, 
                'SGMLComment': 29, 
                'ASPJavaScriptRegex': 67, 
                'JavaScriptUnclosedString': 51, 
                'SGMLDefault': 21, 
                'SGMLSingleQuotedString': 25, 
                'Default': 0, 
                'ASPJavaScriptComment': 57, 
                'SGMLCommand': 22, 
                'PythonClassName': 99, 
                'ASPJavaScriptDoubleQuotedString': 63, 
                'ASPPythonClassName': 114, 
                'OtherInTag': 8, 
                'PHPNumber': 122, 
                'VBScriptComment': 72, 
                'ASPPythonDoubleQuotedString': 109, 
                'ASPPythonSingleQuotedString': 110, 
                'PHPComment': 124, 
                'PythonOperator': 101, 
                'VBScriptDefault': 71, 
                'PythonComment': 92, 
                'JavaScriptRegex': 52, 
                'ASPVBScriptString': 85, 
                'UnknownAttribute': 4, 
                'ASPJavaScriptDefault': 56, 
                'ASPAtStart': 15, 
                'ASPJavaScriptCommentLine': 58, 
                'ASPPythonDefault': 106, 
                'PythonStart': 90, 
                'JavaScriptCommentLine': 43, 
                'PythonSingleQuotedString': 95, 
                'XMLStart': 12, 'JavaScriptStart': 40, 
                'ASPJavaScriptCommentDoc': 59}

def styleDescriptions():
    return propertyID.keys()


def defaultStyle():
    defaultStyle = {'Entity': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PHPComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'Script': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPVBScriptComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'XMLEnd': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptCommentDoc': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'PythonNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPPythonIdentifier': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'VBScriptKeyword': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLBlockDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPVBScriptDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLSpecial': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPXCComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'JavaScriptRegex': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'PHPDoubleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'PythonTripleDoubleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'SGMLDoubleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptDoubleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'PHPDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLError': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptKeyword': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPPythonTripleDoubleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'PHPCommentLine': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPPythonStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptWord': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonTripleSingleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'HTMLValue': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPPythonComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'JavaScriptSymbol': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptCommentLine': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPPythonDoubleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPVBScriptString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'HTMLComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'VBScriptNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'HTMLDoubleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'PythonIdentifier': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLEntity': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonFunctionMethodName': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptUnclosedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptSymbol': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPAtStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPPythonDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'UnknownAttribute': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPVBScriptUnclosedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'PythonClassName': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLParameter': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'XMLStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonDoubleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'PHPStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPVBScriptStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptSingleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'OtherInTag': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptUnclosedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'VBScriptIdentifier': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'Default': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'VBScriptDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLSingleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPPythonNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'Attribute': [defaultFont, '#0000ff', 10, False, False, '#ffffff'], 
                    'ASPPythonOperator': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'Tag': [defaultFont, '#E72500', 10, False, False, '#ffffff'], 
                    'CDATA': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPPythonSingleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPVBScriptIdentifier': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'UnknownTag': [defaultFont, '#71AB71', 10, False, False, '#ffffff'], 
                    'VBScriptComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptCommentLine': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'VBScriptUnclosedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'PHPNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptDoubleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptWord': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'XMLTagEnd': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'SGMLParameterComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'VBScriptStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PHPSingleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPPythonFunctionMethodName': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonKeyword': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PHPKeyword': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLCommand': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptSingleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'PHPDoubleQuotedVariable': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptCommentDoc': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPVBScriptKeyword': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PHPOperator': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'VBScriptString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPPythonKeyword': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptKeyword': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonSingleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'JavaScriptStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'HTMLSingleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'PHPVariable': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPPythonClassName': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPPythonTripleSingleQuotedString': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPVBScriptNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptRegex': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'HTMLNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonOperator': [defaultFont, '#000000', 10, False, False, '#ffffff']}

    return defaultStyle


class HtmlLexer(QsciLexerHTML):

    def __init__(self, style, paper):
        QsciLexerHTML.__init__(self)

        self.lexerPaper = paper

        for key, attrib in style.items():
            value = propertyID[key]
            self.setColor(QtGui.QColor(attrib[1]), value)
            self.setEolFill(True, value)
            self.setPaper(QtGui.QColor(attrib[5]), value)
            if self.lexerPaper[0] == "Plain":
                self.setPaper(QtGui.QColor(attrib[5]), value)
            else:
                self.setPaper(QtGui.QColor(self.lexerPaper[1]), value)

            font = QtGui.QFont(attrib[0], attrib[2])
            font.setBold(attrib[3])
            font.setItalic(attrib[4])
            self.setFont(font, value)

        if self.lexerPaper[0] == "Plain":
            self.setDefaultPaper(QtGui.QColor("#ffffff"))
        else:
            self.setDefaultPaper(QtGui.QColor(self.lexerPaper[1]))

########NEW FILE########
__FILENAME__ = PythonLexer
import keyword
import sys

from PyQt4 import QtGui
from PyQt4.Qsci import QsciLexerPython

# Platform specific fonts
if sys.platform == 'win32':
    defaultFont = 'Consolas'
elif sys.platform == 'darwin':
    defaultFont = 'Monaco'
else:
    defaultFont = 'Bitstream Vera Sans Mono'






propertyID = {
    'Default': 0,
    'Comment': 1,
    'Number': 2,
    'DoubleQuotedString': 3,
    'SingleQuotedString': 4,
    'Keyword': 5,
    'TripleSingleQuotedString': 6,
    'TripleDoubleQuotedString': 7,
    'ClassName': 8,
    'FunctionMethodName': 9,
    'Operator': 10,
    'Identifier': 11,
    'CommentBlock': 12,
    'UnclosedString': 13,
    'HighlightedIdentifier': 14,
    'Decorator': 15,
}


def styleDescriptions():
    return propertyID.keys()


def defaultStyle():
    defaultStyle = {
        'UnclosedString': [defaultFont, '#000000', 10, False, False, '#00fd00'],
        'Decorator': [defaultFont, '#00cc00', 10, False, False, '#ffffff'],
        'Default': [defaultFont, '#000000', 10, False, False, '#ffffff'],
        'HighlightedIdentifier': [defaultFont, '#900090', 10, False, False, '#ffffff'],
        'CommentBlock': [defaultFont, '#0000ff', 10, False, False, '#ffffff'],
        'FunctionMethodName': [defaultFont, '#0000ff', 10, False, False, '#ffffff'],
        'DoubleQuotedString': [defaultFont, '#00aa00', 10, False, False, '#ffffff'],
        'Operator': [defaultFont, '#000000', 10, False, False, '#ffffff'],
        'TripleSingleQuotedString': [defaultFont, '#00aa00', 10, False, False, '#ffffff'],
        'Number': [defaultFont, '#000000', 10, False, False, '#ffffff'],
        'Keyword': [defaultFont, '#0000ff', 10, False, False, '#ffffff'],
        'Identifier': [defaultFont, '#000000', 10, False, False, '#ffffff'],
        'ClassName': [defaultFont, '#0000ff', 10, False, False, '#ffffff'],
        'SingleQuotedString': [defaultFont, '#00aa00', 10, False, False, '#ffffff'],
        'TripleDoubleQuotedString': [defaultFont, '#00aa00', 10, False, False, '#ffffff'],
        'Comment': [defaultFont, '#0000ff', 10, False, False, '#ffffff']}

    return defaultStyle


class PythonLexer(QsciLexerPython):

    def __init__(self, style, paper):
        QsciLexerPython.__init__(self)

        self.lexerPaper = paper

        for key, attrib in style.items():
            value = propertyID[key]
            self.setColor(QtGui.QColor(attrib[1]), value)
            self.setEolFill(True, value)
            self.setPaper(QtGui.QColor(attrib[5]), value)
            if self.lexerPaper[0] == "Plain":
                self.setPaper(QtGui.QColor(attrib[5]), value)
            else:
                self.setPaper(QtGui.QColor(self.lexerPaper[1]), value)

            font = QtGui.QFont(attrib[0], attrib[2])
            font.setBold(attrib[3])
            font.setItalic(attrib[4])
            self.setFont(font, value)

        if self.lexerPaper[0] == "Plain":
            self.setDefaultPaper(QtGui.QColor("#ffffff"))
        else:
            self.setDefaultPaper(QtGui.QColor(self.lexerPaper[1]))

    def keywords(self, set):
        # 1 to 9 sets
        if set == 1:
            k = keyword.kwlist
            s = k[0]
            for i in k[1:]:
                s += ' ' + i
            return s
        elif set == 2:
            s = ''
            for i in dir(__builtins__):
                s += ' ' + i
            return s

########NEW FILE########
__FILENAME__ = XmlLexer
import sys

from PyQt4 import QtGui
from PyQt4.Qsci import QsciLexerXML

# Platform specific fonts
if sys.platform == 'win32':
    defaultFont = 'Consolas'
elif sys.platform == 'darwin':
    defaultFont = 'Monaco'
else:
    defaultFont = 'Bitstream Vera Sans Mono'

propertyID = {'ASPPythonTripleSingleQuotedString': 112, 
                'JavaScriptCommentDoc': 44, 
                'PHPKeyword': 121, 
                'ASPPythonTripleDoubleQuotedString': 113, 
                'VBScriptUnclosedString': 77, 
                'ASPJavaScriptNumber': 60, 
                'PHPOperator': 127, 
                'PythonFunctionMethodName': 100, 
                'PythonTripleDoubleQuotedString': 98, 
                'PythonIdentifier': 102, 
                'ASPJavaScriptWord': 61, 
                'PHPVariable': 123, 
                'ASPPythonKeyword': 111, 
                'ASPPythonFunctionMethodName': 115, 
                'HTMLValue': 19, 
                'HTMLNumber': 5, 
                'HTMLSingleQuotedString': 7, 
                'JavaScriptNumber': 45, 
                'PythonTripleSingleQuotedString': 97, 
                'CDATA': 17, 
                'ASPJavaScriptStart': 55, 
                'ASPVBScriptComment': 82, 
                'HTMLComment': 9, 
                'ASPVBScriptNumber': 83, 
                'ASPJavaScriptSymbol': 65, 
                'JavaScriptSymbol': 50, 
                'PHPSingleQuotedString': 120, 
                'Attribute': 3, 
                'VBScriptStart': 70, 
                'PHPDefault': 118, 
                'ASPVBScriptUnclosedString': 87, 
                'PythonNumber': 93, 
                'ASPVBScriptStart': 80, 
                'SGMLParameterComment': 30, 
                'PHPCommentLine': 125, 
                'ASPStart': 16, 
                'ASPVBScriptIdentifier': 86, 
                'SGMLEntity': 28, 
                'VBScriptKeyword': 74, 
                'HTMLDoubleQuotedString': 6, 
                'Script': 14, 
                'XMLEnd': 13, 
                'Tag': 1, 
                'SGMLError': 26, 
                'ASPVBScriptKeyword': 84, 
                'JavaScriptKeyword': 47, 
                'JavaScriptWord': 46, 
                'ASPPythonOperator': 116, 
                'ASPJavaScriptKeyword': 62, 
                'ASPVBScriptDefault': 81, 
                'PythonKeyword': 96, 
                'UnknownTag': 2, 
                'ASPJavaScriptUnclosedString': 66, 
                'Entity': 10, 
                'ASPPythonComment': 107, 
                'VBScriptIdentifier': 76, 
                'PHPDoubleQuotedString': 119, 
                'XMLTagEnd': 11, 
                'ASPXCComment': 20, 
                'SGMLDoubleQuotedString': 24, 
                'VBScriptString': 75, 
                'JavaScriptComment': 42, 
                'ASPPythonStart': 105, 
                'JavaScriptDefault': 41, 
                'PHPDoubleQuotedVariable': 126, 
                'SGMLBlockDefault': 31, 
                'PythonDefault': 91, 
                'ASPPythonIdentifier': 117, 
                'ASPPythonNumber': 108, 
                'JavaScriptDoubleQuotedString': 48, 
                'JavaScriptSingleQuotedString': 49, 
                'PythonDoubleQuotedString': 94, 
                'ASPJavaScriptSingleQuotedString': 64, 
                'PHPStart': 18, 
                'SGMLParameter': 23, 
                'SGMLSpecial': 27, 
                'VBScriptNumber': 73, 
                'SGMLComment': 29, 
                'ASPJavaScriptRegex': 67, 
                'JavaScriptUnclosedString': 51, 
                'SGMLDefault': 21, 
                'SGMLSingleQuotedString': 25, 
                'Default': 0, 
                'ASPJavaScriptComment': 57, 
                'SGMLCommand': 22, 
                'PythonClassName': 99, 
                'ASPJavaScriptDoubleQuotedString': 63, 
                'ASPPythonClassName': 114, 
                'OtherInTag': 8, 
                'PHPNumber': 122, 
                'VBScriptComment': 72, 
                'ASPPythonDoubleQuotedString': 109, 
                'ASPPythonSingleQuotedString': 110, 
                'PHPComment': 124, 
                'PythonOperator': 101, 
                'VBScriptDefault': 71, 
                'PythonComment': 92, 
                'JavaScriptRegex': 52, 
                'ASPVBScriptString': 85, 
                'UnknownAttribute': 4, 
                'ASPJavaScriptDefault': 56, 
                'ASPAtStart': 15, 
                'ASPJavaScriptCommentLine': 58, 
                'ASPPythonDefault': 106, 
                'PythonStart': 90, 
                'JavaScriptCommentLine': 43, 
                'PythonSingleQuotedString': 95, 
                'XMLStart': 12, 'JavaScriptStart': 40, 
                'ASPJavaScriptCommentDoc': 59}

def styleDescriptions():
    return propertyID.keys()


def defaultStyle():
    defaultStyle = {'Entity': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PHPComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'Script': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPVBScriptComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'XMLEnd': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptCommentDoc': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'PythonNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPPythonIdentifier': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'VBScriptKeyword': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLBlockDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPVBScriptDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLSpecial': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPXCComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'JavaScriptRegex': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'PHPDoubleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'PythonTripleDoubleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'SGMLDoubleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptDoubleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'PHPDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLError': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptKeyword': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPPythonTripleDoubleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'PHPCommentLine': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPPythonStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptWord': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonTripleSingleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'HTMLValue': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPPythonComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'JavaScriptSymbol': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptCommentLine': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPPythonDoubleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'ASPVBScriptString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'HTMLComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'VBScriptNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'HTMLDoubleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'PythonIdentifier': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLEntity': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonFunctionMethodName': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptUnclosedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptSymbol': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPAtStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPPythonDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'UnknownAttribute': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPVBScriptUnclosedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'PythonClassName': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLParameter': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'XMLStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonDoubleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'PHPStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPVBScriptStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptSingleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'OtherInTag': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptUnclosedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'VBScriptIdentifier': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'Default': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'VBScriptDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLSingleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'ASPPythonNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'Attribute': [defaultFont, '#0000ff', 10, False, False, '#ffffff'], 
                    'ASPPythonOperator': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'Tag': [defaultFont, '#E72500', 10, False, True, '#ffffff'], 
                    'CDATA': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPPythonSingleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'ASPVBScriptIdentifier': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'UnknownTag': [defaultFont, '#71AB71', 10, False, False, '#ffffff'], 
                    'VBScriptComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptCommentLine': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'VBScriptUnclosedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'PHPNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptDoubleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptWord': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'XMLTagEnd': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'SGMLParameterComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'VBScriptStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PHPSingleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'ASPPythonFunctionMethodName': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonKeyword': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PHPKeyword': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLCommand': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptSingleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'PHPDoubleQuotedVariable': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptCommentDoc': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPVBScriptKeyword': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'SGMLDefault': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PHPOperator': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'VBScriptString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'ASPPythonKeyword': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptKeyword': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonSingleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'JavaScriptStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptStart': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'HTMLSingleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'PHPVariable': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptComment': [defaultFont, '#00B500', 10, False, False, '#ffffff'], 
                    'ASPPythonClassName': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'JavaScriptNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPPythonTripleSingleQuotedString': [defaultFont, '#008100', 10, False, False, '#ffffff'], 
                    'ASPVBScriptNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'ASPJavaScriptRegex': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'HTMLNumber': [defaultFont, '#000000', 10, False, False, '#ffffff'], 
                    'PythonOperator': [defaultFont, '#000000', 10, False, False, '#ffffff']}


    return defaultStyle


class XmlLexer(QsciLexerXML):

    def __init__(self, style, paper):
        QsciLexerXML.__init__(self)

        self.lexerPaper = paper

        for key, attrib in style.items():
            value = propertyID[key]
            self.setColor(QtGui.QColor(attrib[1]), value)
            self.setEolFill(True, value)
            self.setPaper(QtGui.QColor(attrib[5]), value)
            if self.lexerPaper[0] == "Plain":
                self.setPaper(QtGui.QColor(attrib[5]), value)
            else:
                self.setPaper(QtGui.QColor(self.lexerPaper[1]), value)

            font = QtGui.QFont(attrib[0], attrib[2])
            font.setBold(attrib[3])
            font.setItalic(attrib[4])
            self.setFont(font, value)

        if self.lexerPaper[0] == "Plain":
            self.setDefaultPaper(QtGui.QColor("#ffffff"))
        else:
            self.setDefaultPaper(QtGui.QColor(self.lexerPaper[1]))

########NEW FILE########
__FILENAME__ = StyleEditor
import sys
import os
from PyQt4 import QtCore, QtGui, QtXml
from PyQt4.Qsci import QsciScintilla

from Extensions.Settings.ColorScheme.ColorChooser import ColorChooser


class StyleEditor(QtGui.QWidget):

    paperChanged = QtCore.pyqtSignal()

    def __init__(self, useData, parent=None):
        QtGui.QWidget.__init__(self, parent)

        self.useData = useData

        mainLayout = QtGui.QHBoxLayout()
        self.setLayout(mainLayout)
        mainLayout.setMargin(0)

        properties = self.loadDefaultProperties()
        self.propertyListWidget = QtGui.QListWidget()
        self.propertyListWidget.setSortingEnabled(True)
        for key, value in properties.items():
            if key != "Paper":
                self.propertyListWidget.addItem(QtGui.QListWidgetItem(key))
        self.propertyListWidget.itemSelectionChanged.connect(
            self.newPropertySelected)
        mainLayout.addWidget(self.propertyListWidget)

        vbox = QtGui.QVBoxLayout()
        mainLayout.addLayout(vbox)

        label = QtGui.QLabel("Background")
        label.setStyleSheet("background: lightgrey; padding: 2px;")
        vbox.addWidget(label)

        self.backgroundColorChooser = ColorChooser()
        self.backgroundColorChooser.colorChanged.connect(self.updateBackground)
        vbox.addWidget(self.backgroundColorChooser)

        label = QtGui.QLabel("Foreground")
        label.setStyleSheet("background: lightgrey; padding: 2px;")
        vbox.addWidget(label)

        self.foregroundColorChooser = ColorChooser()
        self.foregroundColorChooser.colorChanged.connect(self.updateForeground)
        vbox.addWidget(self.foregroundColorChooser)

        # Additional settings for elements that need them -------------------

        self.extra_settings_stack = QtGui.QStackedLayout()
        vbox.addLayout(self.extra_settings_stack)

        # empty stack for display when current property has no need of extra
        # settings
        stackWidget = QtGui.QWidget()
        self.extra_settings_stack.addWidget(stackWidget)

        # CALLTIP Highlight Color

        stackWidget = QtGui.QWidget()
        stackBox = QtGui.QVBoxLayout()
        stackBox.setMargin(0)
        stackWidget.setLayout(stackBox)
        self.extra_settings_stack.addWidget(stackWidget)

        label = QtGui.QLabel("Highlight Text")
        label.setStyleSheet("background: lightgrey; padding: 2px;")
        stackBox.addWidget(label)

        hbox = QtGui.QHBoxLayout()
        stackBox.addLayout(hbox)

        self.callTipHighlightColorChooser = ColorChooser()
        self.callTipHighlightColorChooser.colorChanged.connect(
            self.updateCalltipHighlight)
        hbox.addWidget(self.callTipHighlightColorChooser)

        # MARGIN FONT

        stackWidget = QtGui.QWidget()
        stackBox = QtGui.QVBoxLayout()
        stackBox.setMargin(0)
        stackWidget.setLayout(stackBox)
        self.extra_settings_stack.addWidget(stackWidget)

        label = QtGui.QLabel("Margin Font")
        label.setStyleSheet("background: lightgrey; padding: 2px;")
        stackBox.addWidget(label)

        self.fontButton = QtGui.QPushButton("Font")
        self.fontButton.clicked.connect(self.fontChanged)
        stackBox.addWidget(self.fontButton)

        # ----------------------------------------------------------------
        vbox.addStretch(1)

        self.paperBG = QtGui.QButtonGroup()

        label = QtGui.QLabel("Paper")
        label.setStyleSheet("background: lightgrey; padding: 2px;")
        vbox.addWidget(label)

        hbox = QtGui.QHBoxLayout()
        vbox.addLayout(hbox)

        self.paperPlainButton = QtGui.QRadioButton("Plain")
        self.paperBG.addButton(self.paperPlainButton)
        self.paperPlainButton.toggled.connect(self.paperScopeChanged)
        hbox.addWidget(self.paperPlainButton)

        self.paperCustomButton = QtGui.QRadioButton("Custom")
        self.paperBG.addButton(self.paperCustomButton)
        self.paperCustomButton.setChecked(True)
        self.paperCustomButton.toggled.connect(self.paperScopeChanged)
        hbox.addWidget(self.paperCustomButton)

        self.paperColorChooser = ColorChooser()
        self.paperColorChooser.colorChanged.connect(self.updatePaper)
        hbox.addWidget(self.paperColorChooser)

        self.setCurrentProperty("Default", "Python")

        self.paperColorChooser.setColor(self.currentProperties["Paper"][1])
        if self.currentProperties["Paper"][0] == "Plain":
            self.paperColorChooser.setDisabled(True)

        self.propertyListWidget.setCurrentRow(0)

    def paperScopeChanged(self):
        if self.paperBG.checkedButton().text() == 'Plain':
            self.paperColorChooser.setDisabled(True)
        else:
            self.paperColorChooser.setDisabled(False)
        self.currentProperties["Paper"][
            0] = self.paperBG.checkedButton().text()
        self.paperColorChooser.setColor(self.currentProperties["Paper"][1])
        self.paperChanged.emit()

    def loadDefaultProperties(self):
        # Platform specific fonts
        if sys.platform == 'win32':
            defaultFont = 'Consolas'
        elif sys.platform == 'darwin':
            defaultFont = 'Monaco'
        else:
            defaultFont = 'Bitstream Vera Sans Mono'

        properties = {"Edge Line": ['#aa557f', '#ffc6c2'],
                      "Number Margin": ['#ffffff', '#949494', defaultFont, 8, False, False],
                      "Fold Margin": ['#ffffff', '#ffffff'],
                      "Fold Markers": ['#ffffff', '#bababa'],
                      "Active Line": ['#d4ffd4', '#101010'],
                      "Selection": ['#aaddff', '#1e1e1e'],
                      "White Spaces": ['#ffffff', '#000000'],
                      "Matched Braces": ['#CCCCCC', '#000000'],
                      "Unmatched Braces": ['#ff5555', '#000000'],
                      "Calltips": ["#000000", "#ffffff", "#FF3333"],
                      "Indentation Guide": ['#ffffff', '#a8a8a8'],
                      "Warnings": ['#000000', '#ffffa9'],
                      "Errors": ['#000000', '#ffaaa7'],
                      "Paper": ['Plain', '#7FE87F']}
        return properties

    def newPropertySelected(self):
        self.currentPropertyName = \
            self.propertyListWidget.currentItem().text()
        self.currentPropertyAttrib = \
            self.currentProperties[
                self.currentPropertyName]

        self.backgroundColorChooser.setColor(self.currentPropertyAttrib[0])
        self.foregroundColorChooser.setColor(self.currentPropertyAttrib[1])

        if self.currentPropertyName == "Calltips":
            self.callTipHighlightColorChooser.setColor(
                self.currentPropertyAttrib[2])
            self.extra_settings_stack.setCurrentIndex(1)
        elif self.currentPropertyName == "Number Margin":
            self.extra_settings_stack.setCurrentIndex(2)
        else:
            self.extra_settings_stack.setCurrentIndex(0)

    def updateBackground(self, color):
        self.currentPropertyAttrib[0] = color

    def updateNumberMarginFont(self):
        self.currentProperties["Number Margin"][2] = self.fontBox.currentText()
        self.currentProperties["Number Margin"][
            3] = self.fontSizeBox.currentText()

    def showLineBackground(self):
        color = QtGui.QColor(self.backgroundHexLine.text())
        if color.isValid():
            self.updateBackground(color)

    def updateCalltipHighlight(self, color):
        self.currentPropertyAttrib[2] = color

    def updateForeground(self, color):
        self.currentPropertyAttrib[1] = color

    def updatePaper(self, color):
        self.currentProperties["Paper"][1] = color
        self.paperChanged.emit()

    def setCurrentProperty(self, propertyName, groupName):
        self.currentProperties = self.loadProperties(propertyName, groupName)
        if self.currentProperties["Paper"][0] == "Plain":
            self.paperPlainButton.setChecked(True)
        else:
            self.paperCustomButton.setChecked(True)

    def fontChanged(self):
        currentfont = QtGui.QFont(self.currentPropertyAttrib[
                                  2], self.currentPropertyAttrib[3])
        currentfont.setBold(self.currentPropertyAttrib[4])
        currentfont.setItalic(self.currentPropertyAttrib[5])
        font = QtGui.QFontDialog().getFont(currentfont, self)
        if font[1]:
            font = font[0]
            name = font.rawName()
            size = font.pointSize()
            bold = font.bold()
            italic = font.italic()
            self.currentPropertyAttrib[2] = name
            self.currentPropertyAttrib[3] = size
            self.currentPropertyAttrib[4] = bold
            self.currentPropertyAttrib[5] = italic

    def applyChanges(self, viewWidget, properties=None):
        if properties == None:
            properties = self.currentProperties

        viewWidget.setSelectionBackgroundColor(
            QtGui.QColor(properties["Selection"][0]))
        viewWidget.setSelectionForegroundColor(
            QtGui.QColor(properties["Selection"][1]))

        viewWidget.setIndentationGuidesBackgroundColor(
            QtGui.QColor(properties["Indentation Guide"][0]))
        viewWidget.setIndentationGuidesForegroundColor(
            QtGui.QColor(properties["Indentation Guide"][1]))

        viewWidget.setCallTipsBackgroundColor(
            QtGui.QColor(properties["Calltips"][0]))
        viewWidget.setCallTipsForegroundColor(
            QtGui.QColor(properties["Calltips"][1]))
        viewWidget.setCallTipsHighlightColor(QtGui.QColor(
            properties["Calltips"][2]))

        # Margins colors
        # line numbers margin
        viewWidget.setMarginsBackgroundColor(
            QtGui.QColor(properties["Number Margin"][0]))
        viewWidget.setMarginsForegroundColor(
            QtGui.QColor(properties["Number Margin"][1]))

        marginFont = QtGui.QFont(properties["Number Margin"][2],
                                 properties["Number Margin"][3])
        marginFont.setBold(properties["Number Margin"][4])
        marginFont.setItalic(properties["Number Margin"][5])
        viewWidget.setMarginsFont(marginFont)

        # folding margin colors (foreground, background)
        viewWidget.setFoldMarginColors(
            QtGui.QColor(properties["Fold Margin"][0]),
            QtGui.QColor(properties["Fold Margin"][1]))

        # Edge Mode shows a vertical bar at specific number of chars
        viewWidget.setEdgeColor(QtGui.QColor(
            properties["Edge Line"][1]))

        # Folding visual : we will use boxes
        viewWidget.setFoldMarkersColors(
            QtGui.QColor(properties["Fold Markers"][0]),
            QtGui.QColor(properties["Fold Markers"][1]))

        # Braces matching
        viewWidget.setMatchedBraceBackgroundColor(
            QtGui.QColor(properties["Matched Braces"][0]))
        viewWidget.setMatchedBraceForegroundColor(
            QtGui.QColor(properties["Matched Braces"][1]))
        viewWidget.setUnmatchedBraceBackgroundColor(
            QtGui.QColor(properties["Unmatched Braces"][0]))
        viewWidget.setUnmatchedBraceForegroundColor(
            QtGui.QColor(properties["Unmatched Braces"][1]))

        # Editing line color
        viewWidget.setCaretWidth(2)
        viewWidget.setCaretLineBackgroundColor(
            QtGui.QColor(properties["Active Line"][0]))
        viewWidget.setCaretForegroundColor(
            QtGui.QColor(properties["Active Line"][1]))

        viewWidget.setWhitespaceBackgroundColor(
            QtGui.QColor(properties["White Spaces"][0]))
        viewWidget.setWhitespaceForegroundColor(
            QtGui.QColor(properties["White Spaces"][1]))

        viewWidget.annotationWarningStyle = QsciScintilla.STYLE_LASTPREDEFINED + 1
        viewWidget.SendScintilla(QsciScintilla.SCI_STYLESETFORE,
                                 viewWidget.annotationWarningStyle, QtGui.QColor(properties["Warnings"][0]))
        viewWidget.SendScintilla(QsciScintilla.SCI_STYLESETBACK,
                                 viewWidget.annotationWarningStyle, QtGui.QColor(properties["Warnings"][1]))

        viewWidget.annotationErrorStyle = viewWidget.annotationWarningStyle + 1
        viewWidget.SendScintilla(QsciScintilla.SCI_STYLESETFORE,
                                 viewWidget.annotationErrorStyle, QtGui.QColor(properties["Errors"][0]))
        viewWidget.SendScintilla(QsciScintilla.SCI_STYLESETBACK,
                                 viewWidget.annotationErrorStyle, QtGui.QColor(properties["Errors"][1]))

        return properties["Paper"]

    def loadProperties(self, style_name, groupName):
        if style_name == "Default":
            properties = self.loadDefaultProperties()

            return properties

        dom_document = QtXml.QDomDocument()
        path = os.path.join(self.useData.appPathDict[
                            "stylesdir"], groupName, style_name + ".xml")
        file = open(path, "r")
        dom_document.setContent(file.read())
        file.close()

        properties = {}

        rootElement = dom_document.documentElement()
        propertyElement = rootElement.firstChild()
        propertyElement = propertyElement.nextSiblingElement().toElement()
        node = propertyElement.firstChild()
        while node.isNull() is False:
            tag = node.toElement()
            name = tag.text()
            background = tag.attribute("background")
            foreground = tag.attribute("foreground")

            properties[name] = [background, foreground]
            if name == "Calltips":
                properties[name].append(tag.attribute("highLight"))
            if name == "Number Margin":
                properties[name].append(tag.attribute("font"))
                properties[name].append(int(tag.attribute("size")))
                bold = (tag.attribute("bold") == "True")
                properties[name].append(bold)
                italic = (tag.attribute("italic") == "True")
                properties[name].append(italic)
            node = node.nextSibling()

        return properties

########NEW FILE########
__FILENAME__ = StyleLexer
import os
from PyQt4 import QtCore, QtGui, QtXml

from Extensions.Settings.ColorScheme.Lexers import PythonLexer
from Extensions.Settings.ColorScheme.Lexers import CssLexer
from Extensions.Settings.ColorScheme.Lexers import HtmlLexer
from Extensions.Settings.ColorScheme.Lexers import XmlLexer
from Extensions.Settings.ColorScheme.ColorChooser import ColorChooser


class StyleLexer(QtGui.QWidget):

    reloadStyles = QtCore.pyqtSignal()

    def __init__(self, styleProperties, useData, parent=None):
        super(StyleLexer, self).__init__(parent)

        self.styleProperties = styleProperties
        self.useData = useData

        self.setCurrentStyle("Default", "Python")

        mainLayout = QtGui.QHBoxLayout()
        mainLayout.setMargin(0)

        # style properties
        self.propertyListWidget = QtGui.QListWidget()
        self.propertyListWidget.setSortingEnabled(True)
        self.propertyListWidget.currentRowChanged.connect(
            self.newPropertySelected)
        mainLayout.addWidget(self.propertyListWidget)

        self.setLayout(mainLayout)

        # settings
        vbox = QtGui.QVBoxLayout()
        mainLayout.addLayout(vbox)

        self.fontColorScopeBG = QtGui.QButtonGroup()

        hbox = QtGui.QHBoxLayout()
        label = QtGui.QLabel("Foreground")
        label.setStyleSheet("background: lightgrey; padding: 2px;")
        hbox.addWidget(label)
        vbox.addLayout(hbox)

        hbox = QtGui.QHBoxLayout()
        vbox.addLayout(hbox)
        fontColorScopeAll = QtGui.QRadioButton("All")
        self.fontColorScopeBG.addButton(fontColorScopeAll)
        hbox.addWidget(fontColorScopeAll)

        fontColorScopeCurrent = QtGui.QRadioButton("Selected")
        self.fontColorScopeBG.addButton(fontColorScopeCurrent)
        fontColorScopeCurrent.setChecked(True)
        hbox.addWidget(fontColorScopeCurrent)

        self.fontColorChooser = ColorChooser()
        self.fontColorChooser.colorChanged.connect(self.updateColor)
        hbox.addWidget(self.fontColorChooser)

        self.backgroundColorScopeBG = QtGui.QButtonGroup()

        hbox = QtGui.QHBoxLayout()
        label = QtGui.QLabel("Background")
        label.setStyleSheet("background: lightgrey; padding: 2px;")
        hbox.addWidget(label)
        vbox.addLayout(hbox)

        hbox = QtGui.QHBoxLayout()
        vbox.addLayout(hbox)
        backgroundColorScopeAll = QtGui.QRadioButton("All")
        self.backgroundColorScopeBG.addButton(backgroundColorScopeAll)
        hbox.addWidget(backgroundColorScopeAll)

        backgroundColorScopeCurrent = QtGui.QRadioButton("Selected")
        self.backgroundColorScopeBG.addButton(backgroundColorScopeCurrent)
        backgroundColorScopeCurrent.setChecked(True)
        hbox.addWidget(backgroundColorScopeCurrent)

        self.backgroundColorChooser = ColorChooser()
        self.backgroundColorChooser.colorChanged.connect(self.updatePaper)
        hbox.addWidget(self.backgroundColorChooser)

        self.fontScopeBG = QtGui.QButtonGroup()

        hbox = QtGui.QHBoxLayout()
        label = QtGui.QLabel("Font")
        label.setStyleSheet("background: lightgrey; padding: 2px;")
        hbox.addWidget(label)
        vbox.addLayout(hbox)

        hbox = QtGui.QHBoxLayout()
        vbox.addLayout(hbox)
        fontScopeAll = QtGui.QRadioButton("All")
        self.fontScopeBG.addButton(fontScopeAll)
        hbox.addWidget(fontScopeAll)

        fontScopeCurrent = QtGui.QRadioButton("Selected")
        self.fontScopeBG.addButton(fontScopeCurrent)
        fontScopeCurrent.setChecked(True)
        hbox.addWidget(fontScopeCurrent)

        hbox.addStretch(1)

        self.fontButton = QtGui.QPushButton("Font")
        self.fontButton.clicked.connect(self.fontChanged)
        hbox.addWidget(self.fontButton)

        vbox.addStretch(1)

    def updatePropertyListWidget(self, groupName):
        if groupName == "Python":
            styles = PythonLexer.styleDescriptions()
        elif groupName == "Css":
            styles = CssLexer.styleDescriptions()
        elif groupName == "Xml":
            styles = XmlLexer.styleDescriptions()
        elif groupName == "Html":
            styles = HtmlLexer.styleDescriptions()

        self.propertyListWidget.clear()
        for i in styles:
            self.propertyListWidget.addItem(i)
        self.propertyListWidget.setCurrentRow(0)

    def createLexer(self, paper, style_name, groupName):
        style = self.loadStyle(style_name, groupName)
        if groupName == "Python":
            lexer = PythonLexer.PythonLexer(style, paper)
        elif groupName == "Xml":
            lexer = XmlLexer.XmlLexer(style, paper)
        elif groupName == "Html":
            lexer = HtmlLexer.HtmlLexer(style, paper)
        elif groupName == "Css":
            lexer = CssLexer.CssLexer(style, paper)
        return lexer

    def setCurrentStyle(self, styleName, groupName):
        self.currentStyle = self.loadStyle(styleName, groupName)

    def loadStyle(self, styleName, groupName):
        if styleName == "Default":
            if groupName == "Python":
                return PythonLexer.defaultStyle()
            elif groupName == "Css":
                return CssLexer.defaultStyle()
            elif groupName == "Xml":
                return XmlLexer.defaultStyle()
            elif groupName == "Html":
                return HtmlLexer.defaultStyle()
        else:
            pass

        style = {}

        stylePath = os.path.join(self.useData.appPathDict["stylesdir"],
                                 groupName, styleName + ".xml")
        dom_document = QtXml.QDomDocument()
        file = open(stylePath, "r")
        x = dom_document.setContent(file.read())
        file.close()

        rootElement = dom_document.documentElement()
        lexerElement = rootElement.firstChild().toElement()
        node = lexerElement.firstChild()

        while node.isNull() is False:
            tag = node.toElement()

            name = tag.text()
            font = tag.attribute("font")
            color = tag.attribute("color")
            size = int(tag.attribute("size"))
            bold = (tag.attribute("bold") == "True")
            italic = (tag.attribute("italic") == "True")
            paper = tag.attribute("paper")

            style[name] = [font, color, size, bold, italic, paper]

            node = node.nextSibling()
        return style

    def updateFontSizeBox(self, widget):
        for i in self.fontSizeList:
            widget.addItem(str(i))

    def newPropertySelected(self):
        currentItem = self.propertyListWidget.currentItem()
        if currentItem is None:
            return
        self.currentPropertyName = currentItem.text()
        self.currentPropertyAttrib = \
            self.currentStyle[self.currentPropertyName]

        color = QtGui.QColor(self.currentPropertyAttrib[1])
        self.fontColorChooser.setColor(self.currentPropertyAttrib[1])

        color = QtGui.QColor(self.currentPropertyAttrib[5])
        self.backgroundColorChooser.setColor(self.currentPropertyAttrib[5])

    def fontChanged(self):
        currentfont = QtGui.QFont(self.currentPropertyAttrib[
                                  0], self.currentPropertyAttrib[2])
        currentfont.setBold(self.currentPropertyAttrib[3])
        currentfont.setItalic(self.currentPropertyAttrib[4])
        font = QtGui.QFontDialog().getFont(currentfont, self)
        if font[1]:
            font = font[0]
            name = font.rawName()
            size = font.pointSize()
            bold = font.bold()
            italic = font.italic()
            if self.fontScopeBG.checkedButton().text() == 'All':
                for key, value in self.currentStyle.items():
                    value[0] = name
                    value[2] = size
                    value[3] = bold
                    value[4] = italic
                    self.currentStyle[key] = value
            else:
                self.currentPropertyAttrib[0] = name
                self.currentPropertyAttrib[2] = size
                self.currentPropertyAttrib[3] = bold
                self.currentPropertyAttrib[4] = italic
                self.currentStyle[self.currentPropertyName] = \
                    self.currentPropertyAttrib

    def updateColor(self, color):
        self.currentPropertyAttrib[1] = color
        if self.fontColorScopeBG.checkedButton().text() == 'All':
            for key, value in self.currentStyle.items():
                value[1] = color
                self.currentStyle[key] = value
        else:
            self.currentStyle[
                self.currentPropertyName] = self.currentPropertyAttrib
        self.newPropertySelected()

    def updatePaper(self, color):
        self.currentPropertyAttrib[5] = color
        if self.backgroundColorScopeBG.checkedButton().text() == 'All':
            for key, value in self.currentStyle.items():
                value[5] = color
                self.currentStyle[key] = value
        else:
            self.currentStyle[self.currentPropertyName] = \
                self.currentPropertyAttrib
        self.newPropertySelected()

########NEW FILE########
__FILENAME__ = GeneralSettings
import os
import shutil
from PyQt4 import QtCore, QtGui
from PyQt4.Qsci import QsciScintilla
from Extensions import StyleSheet


class GeneralSettings(QtGui.QDialog):

    def __init__(self, useData, mainApp, projectWindowStack, parent=None):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle("Settings")
        self.useData = useData
        self.mainApp = mainApp
        self.projectWindowStack = projectWindowStack

        mainLayout = QtGui.QHBoxLayout()
        self.setLayout(mainLayout)

        # AUTO COMPLETION
        mainVbox = QtGui.QVBoxLayout()
        mainLayout.addLayout(mainVbox)

        self.autoCompGbox = QtGui.QGroupBox("Auto-Completion")
        self.autoCompGbox.setFlat(True)
        self.autoCompGbox.setCheckable(True)
        mainVbox.addWidget(self.autoCompGbox)

        vbox = QtGui.QVBoxLayout()
        self.autoCompGbox.setLayout(vbox)

        self.autoCompButtonGroup = QtGui.QButtonGroup()
        self.autoCompButtonGroup.setExclusive(True)

        self.autoCompApiBox = QtGui.QCheckBox("Project")
        if (self.useData.SETTINGS["AutoCompletion"] == "Api"):
            self.autoCompApiBox.setChecked(True)
        self.autoCompButtonGroup.addButton(self.autoCompApiBox)
        self.autoCompApiBox.toggled.connect(self.setAutoCompletion)
        vbox.addWidget(self.autoCompApiBox)

        self.autoCompDocBox = QtGui.QCheckBox("Current Module")
        if (self.useData.SETTINGS["AutoCompletion"] == "Document"):
            self.autoCompDocBox.setChecked(True)
        self.autoCompButtonGroup.addButton(self.autoCompDocBox)
        self.autoCompDocBox.toggled.connect(self.setAutoCompletion)
        vbox.addWidget(self.autoCompDocBox)

        if self.useData.SETTINGS["EnableAutoCompletion"] == "True":
            self.autoCompGbox.setChecked(True)
        else:
            self.autoCompGbox.setChecked(False)
        self.autoCompGbox.toggled.connect(self.enableAutoCompletion)

        # SEARCH

        gbox = QtGui.QGroupBox("Search")
        gbox.setFlat(True)

        vbox = QtGui.QVBoxLayout()
        gbox.setLayout(vbox)
        mainVbox.addWidget(gbox)

        self.dynamicSearchBox = QtGui.QCheckBox("Dynamic Search")
        if self.useData.SETTINGS["DynamicSearch"] == "True":
            self.dynamicSearchBox.setChecked(True)
        self.dynamicSearchBox.toggled.connect(self.setDynamicSearch)
        vbox.addWidget(self.dynamicSearchBox)

        self.markWordOccurrenceBox = QtGui.QCheckBox("Mark Word Occurrence")
        if self.useData.SETTINGS["MarkSearchOccurrence"] == "True":
            self.markWordOccurrenceBox.setChecked(True)
        self.markWordOccurrenceBox.toggled.connect(
            self.setMarkSearchOccurrence)
        vbox.addWidget(self.markWordOccurrenceBox)

        vbox.addStretch(1)

        # EDITOR VIEW

        mainVbox = QtGui.QVBoxLayout()
        mainLayout.addLayout(mainVbox)

        vbox = QtGui.QVBoxLayout()

        gbox = QtGui.QGroupBox("Editor")
        gbox.setFlat(True)
        gbox.setLayout(vbox)
        mainVbox.addWidget(gbox)

        self.showCalltipsBox = QtGui.QCheckBox("Calltips")
        if self.useData.SETTINGS["CallTips"] == "True":
            self.showCalltipsBox.setChecked(True)
        self.showCalltipsBox.toggled.connect(self.setShowCalltip)
        vbox.addWidget(self.showCalltipsBox)

        self.showWhiteSpacesBox = QtGui.QCheckBox("White Spaces")
        if self.useData.SETTINGS["ShowWhiteSpaces"] == "True":
            self.showWhiteSpacesBox.setChecked(True)
        self.showWhiteSpacesBox.toggled.connect(self.setShowWhiteSpaces)
        vbox.addWidget(self.showWhiteSpacesBox)

        # ACTIVE LINE

        activeLineBox = QtGui.QCheckBox("Active Line")
        if self.useData.SETTINGS["ShowCaretLine"] == 'True':
            activeLineBox.setChecked(True)
        else:
            activeLineBox.setChecked(False)
        activeLineBox.toggled.connect(self.setShowCaretLine)
        vbox.addWidget(activeLineBox)

        # LINE NUMBERS

        self.showLineNumbersBox = QtGui.QCheckBox("Line Numbers")
        if self.useData.SETTINGS["ShowLineNumbers"] == "True":
            self.showLineNumbersBox.setChecked(True)
        self.showLineNumbersBox.toggled.connect(self.setShowLineNumbers)
        vbox.addWidget(self.showLineNumbersBox)

        # BRACE MATCHING

        self.matchBracesBox = QtGui.QCheckBox("Match Braces")
        if self.useData.SETTINGS["MatchBraces"] == "True":
            self.matchBracesBox.setChecked(True)
        self.matchBracesBox.toggled.connect(self.setMatchBraces)
        vbox.addWidget(self.matchBracesBox)

        # FOLDING

        self.foldingBox = QtGui.QCheckBox("Folding")
        if self.useData.SETTINGS["EnableFolding"] == "True":
            self.foldingBox.setChecked(True)
        self.foldingBox.toggled.connect(self.setFolding)
        vbox.addWidget(self.foldingBox)

        # DOC ON HOVER

        self.docOnHoverBox = QtGui.QCheckBox("Doc on hover")
        if self.useData.SETTINGS["DocOnHover"] == "True":
            self.docOnHoverBox.setChecked(True)
        self.docOnHoverBox.toggled.connect(self.setDocOnHover)
        vbox.addWidget(self.docOnHoverBox)

        # MARK OPERATIONAL LINES

        self.markOperationalLinesBox = QtGui.QCheckBox("Mark Operation Lines")
        if self.useData.SETTINGS["MarkOperationalLines"] == "True":
            self.markOperationalLinesBox.setChecked(True)
        self.markOperationalLinesBox.toggled.connect(
            self.setMarkOperationalLines)
        vbox.addWidget(self.markOperationalLinesBox)

        vbox.addStretch(1)

        # EDGE LINE ATTRIBUTES

        mainVbox = QtGui.QVBoxLayout()
        mainLayout.addLayout(mainVbox)

        gbox = QtGui.QGroupBox("Edge Line")
        gbox.setFlat(True)
        gbox.setCheckable(True)
        mainVbox.addWidget(gbox)

        if self.useData.SETTINGS["ShowEdgeLine"] == "True":
            gbox.setChecked(True)
        else:
            gbox.setChecked(False)
        gbox.toggled.connect(self.setShowEdgeLine)

        vbox = QtGui.QVBoxLayout()
        gbox.setLayout(vbox)

        self.positionBox = QtGui.QSpinBox()
        self.positionBox.setRange(1, 200)
        self.positionBox.setValue(int(self.useData.SETTINGS["EdgeColumn"]))
        self.positionBox.valueChanged.connect(self.setEdgeColumn)
        vbox.addWidget(self.positionBox)

        vbox.addWidget(QtGui.QLabel("Edge Mode"))

        self.edgeModeBox = QtGui.QComboBox()
        self.edgeModeBox.addItem("Line")
        self.edgeModeBox.addItem("Background")
        self.edgeModeBox.setCurrentIndex(
            self.edgeModeBox.findText(self.useData.SETTINGS['EdgeMode']))
        self.edgeModeBox.activated.connect(self.setEdgeMode)
        self.edgeModeBox.currentIndexChanged.connect(self.setEdgeMode)
        vbox.addWidget(self.edgeModeBox)

        mainVbox.addStretch(1)

        # ASSISTANT

        mainVbox = QtGui.QVBoxLayout()
        mainLayout.addLayout(mainVbox)

        gbox = QtGui.QGroupBox("Assistant")
        gbox.setFlat(True)
        gbox.setCheckable(True)
        mainVbox.addWidget(gbox)

        vbox = QtGui.QVBoxLayout()
        gbox.setLayout(vbox)

        self.assistantButtonGroup = QtGui.QButtonGroup()
        self.assistantButtonGroup.setExclusive(True)

        self.enableAlertsBox = QtGui.QCheckBox("Alerts")
        if self.useData.SETTINGS["EnableAlerts"] == "True":
            self.enableAlertsBox.setChecked(True)
        self.assistantButtonGroup.addButton(self.enableAlertsBox)
        self.enableAlertsBox.toggled.connect(self.setAssistant)
        vbox.addWidget(self.enableAlertsBox)

        self.enableStyleGuideBox = QtGui.QCheckBox("Style Guide")
        if self.useData.SETTINGS["enableStyleGuide"] == "True":
            self.enableStyleGuideBox.setChecked(True)
        self.assistantButtonGroup.addButton(self.enableStyleGuideBox)
        self.enableStyleGuideBox.toggled.connect(self.enableStyleGuide)
        vbox.addWidget(self.enableStyleGuideBox)

        if self.useData.SETTINGS["EnableAssistance"] == "True":
            gbox.setChecked(True)
        else:
            gbox.setChecked(False)
        gbox.toggled.connect(self.enableAssistance)

        vbox.addStretch(1)

        # MANAGEMENT

        mainVbox.addWidget(QtGui.QLabel("UI"))

        self.uiBox = QtGui.QComboBox()
        self.uiBox.addItem("Custom")
        self.uiBox.addItem("Native")
        if self.useData.SETTINGS["UI"] == 'Native':
            self.uiBox.setCurrentIndex(1)
        self.uiBox.currentIndexChanged.connect(self.setUI)
        mainVbox.addWidget(self.uiBox)

        self.enableSoundsBox = QtGui.QCheckBox("Enable Sounds")
        if self.useData.SETTINGS["SoundsEnabled"] == 'True':
            self.enableSoundsBox.setChecked(True)
        self.enableSoundsBox.toggled.connect(self.setSoundsEnabled)
        mainVbox.addWidget(self.enableSoundsBox)

        self.exportButton = QtGui.QPushButton("Export Settings")
        self.exportButton.clicked.connect(self.exportSettings)
        mainVbox.addWidget(self.exportButton)

    def setUI(self, index):
        self.useData.SETTINGS["UI"] = self.uiBox.currentText()
        if index == 0:
            self.mainApp.setStyleSheet(StyleSheet.globalStyle)
        else:
            self.mainApp.setStyleSheet(None)
        isCustom = (index == 0)
        for i in range(self.projectWindowStack.count() - 1):
            editorTabWidget = self.projectWindowStack.widget(i).editorTabWidget
            if isCustom:
                editorTabWidget.adjustToStyleSheet(True)
            else:
                editorTabWidget.adjustToStyleSheet(False)

    def exportSettings(self):
        options = QtGui.QFileDialog.Options()
        savepath = os.path.join(self.useData.getLastOpenedDir(),
                                "Pcode_Settings" + '_' + QtCore.QDateTime().currentDateTime().toString().replace(' ', '_').replace(':', '-'))
        savepath = os.path.normpath(savepath)
        fileName = QtGui.QFileDialog.getSaveFileName(self,
                                                     "Choose Folder", savepath,
                                                     "Pcode Settings (*)", options)
        if fileName:
            try:
                QtGui.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
                self.useData.saveLastOpenedDir(os.path.split(fileName)[0])
                shutil.make_archive(fileName, "zip",
                                    self.useData.appPathDict["settingsdir"])
            except Exception as err:
                QtGui.QApplication.restoreOverrideCursor()
                message = QtGui.QMessageBox.warning(self, "Export", str(err))
            QtGui.QApplication.restoreOverrideCursor()

    def enableAssistance(self, state):
        self.useData.SETTINGS["EnableAssistance"] = str(state)
        for i in range(self.projectWindowStack.count() - 1):
            alertsWidget = self.projectWindowStack.widget(i).assistantWidget
            if state:
                alertsWidget.setAssistance()
            else:
                alertsWidget.setAssistance(0)

    def setAssistant(self, state):
        self.useData.SETTINGS["EnableAlerts"] = str(state)
        for i in range(self.projectWindowStack.count() - 1):
            alertsWidget = self.projectWindowStack.widget(i).assistantWidget
            alertsWidget.setAssistance(1)
            if state is False:
                editorTabWidget = self.projectWindowStack.widget(
                    i).editorTabWidget
                for i in range(editorTabWidget.count()):
                    editor = editorTabWidget.getEditor(i)
                    if editor.DATA["fileType"] == "python":
                        editor2 = editorTabWidget.getCloneEditor(i)

                        editor.clearErrorMarkerAndIndicator()
                        editor2.clearErrorMarkerAndIndicator()

    def enableStyleGuide(self, state):
        self.useData.SETTINGS["enableStyleGuide"] = str(state)
        for i in range(self.projectWindowStack.count() - 1):
            alertsWidget = self.projectWindowStack.widget(i).assistantWidget
            alertsWidget.setAssistance(2)

    def setEdgeMode(self):
        self.useData.SETTINGS['EdgeMode'] = self.edgeModeBox.currentText()
        for i in range(self.projectWindowStack.count() - 1):
            editorTabWidget = self.projectWindowStack.widget(i).editorTabWidget
            for i in range(editorTabWidget.count()):
                editor = editorTabWidget.getEditor(i)
                if editor.DATA["fileType"] == "python":
                    editor2 = editorTabWidget.getCloneEditor(i)
                    if self.edgeModeBox.currentText() == "Line":
                        editor.setEdgeMode(QsciScintilla.EdgeLine)
                        editor2.setEdgeMode(QsciScintilla.EdgeLine)
                    elif self.edgeModeBox.currentText() == "Background":
                        editor.setEdgeMode(QsciScintilla.EdgeBackground)
                        editor2.setEdgeMode(QsciScintilla.EdgeBackground)

    def setEdgeColumn(self, value):
        self.useData.SETTINGS['EdgeColumn'] = str(value)
        for i in range(self.projectWindowStack.count() - 1):
            editorTabWidget = self.projectWindowStack.widget(i).editorTabWidget
            for i in range(editorTabWidget.count()):
                editor = editorTabWidget.getEditor(i)
                if editor.DATA["fileType"] == "python":
                    editor2 = editorTabWidget.getCloneEditor(i)
                    editor.setEdgeColumn(value)
                    editor2.setEdgeColumn(value)

    def setSoundsEnabled(self, state):
        self.useData.SETTINGS["SoundsEnabled"] = str(state)

    def setShowCaretLine(self, state):
        self.useData.SETTINGS["ShowCaretLine"] = str(state)
        for i in range(self.projectWindowStack.count() - 1):
            editorTabWidget = self.projectWindowStack.widget(i).editorTabWidget
            for i in range(editorTabWidget.count()):
                editor = editorTabWidget.getEditor(i)
                if editor.DATA["fileType"] in self.useData.supportedFileTypes:
                    editor2 = editorTabWidget.getCloneEditor(i)
                    editor.setCaretLineVisible(state)
                    editor2.setCaretLineVisible(state)

    def setShowCalltip(self, state):
        self.useData.SETTINGS["CallTips"] = str(state)

    def setShowLineNumbers(self, state):
        self.useData.SETTINGS["ShowLineNumbers"] = str(state)
        for i in range(self.projectWindowStack.count() - 1):
            editorTabWidget = self.projectWindowStack.widget(i).editorTabWidget
            for i in range(editorTabWidget.count()):
                editor = editorTabWidget.getEditor(i)
                editor2 = editorTabWidget.getCloneEditor(i)
                editor.showLineNumbers()
                editor2.showLineNumbers()

    def setMatchBraces(self, state):
        self.useData.SETTINGS["MatchBraces"] = str(state)
        for i in range(self.projectWindowStack.count() - 1):
            editorTabWidget = self.projectWindowStack.widget(i).editorTabWidget
            for i in range(editorTabWidget.count()):
                editor = editorTabWidget.getEditor(i)
                editor2 = editorTabWidget.getCloneEditor(i)
                if state:
                    editor.setBraceMatching(QsciScintilla.SloppyBraceMatch)
                    editor2.setBraceMatching(
                        QsciScintilla.SloppyBraceMatch)
                else:
                    editor.setBraceMatching(QsciScintilla.NoBraceMatch)
                    editor2.setBraceMatching(QsciScintilla.NoBraceMatch)

    def setFolding(self, state):
        self.useData.SETTINGS["EnableFolding"] = str(state)
        for i in range(self.projectWindowStack.count() - 1):
            editorTabWidget = self.projectWindowStack.widget(i).editorTabWidget
            for i in range(editorTabWidget.count()):
                editor = editorTabWidget.getEditor(i)
                if editor.DATA["fileType"] == "python":
                    editor2 = editorTabWidget.getCloneEditor(i)
                    if state:
                        editor.setFolding(QsciScintilla.BoxedTreeFoldStyle, 2)
                        editor2.setFolding(QsciScintilla.BoxedTreeFoldStyle, 2)
                    else:
                        editor.setFolding(QsciScintilla.NoFoldStyle, 2)
                        editor2.setFolding(QsciScintilla.NoFoldStyle, 2)

    def setShowWhiteSpaces(self, state):
        self.useData.SETTINGS["ShowWhiteSpaces"] = str(state)
        for i in range(self.projectWindowStack.count() - 1):
            editorTabWidget = self.projectWindowStack.widget(i).editorTabWidget
            for i in range(editorTabWidget.count()):
                editor = editorTabWidget.getEditor(i)
                if editor.DATA["fileType"] == "python":
                    editor2 = editorTabWidget.getCloneEditor(i)
                    editor.showWhiteSpaces()
                    editor2.showWhiteSpaces()

    def enableAutoCompletion(self, state):
        self.useData.SETTINGS["EnableAutoCompletion"] = str(state)
        for i in range(self.projectWindowStack.count() - 1):
            editorTabWidget = self.projectWindowStack.widget(i).editorTabWidget
            for i in range(editorTabWidget.count()):
                editorTabWidget.getEditor(i).setAutoCompletion()
                editorTabWidget.getCloneEditor(i).setAutoCompletion()

    def setAutoCompletion(self):
        if self.autoCompDocBox.isChecked():
            self.useData.SETTINGS["AutoCompletion"] = "Document"
        elif self.autoCompApiBox.isChecked():
            self.useData.SETTINGS["AutoCompletion"] = "Api"
        for i in range(self.projectWindowStack.count() - 1):
            editorTabWidget = self.projectWindowStack.widget(i).editorTabWidget
            for i in range(editorTabWidget.count()):
                editor = editorTabWidget.getEditor(i)
                editor.setAutoCompletion()
                editor2 = editorTabWidget.getCloneEditor(i)
                editor2.setAutoCompletion()

    def setDynamicSearch(self, state):
        self.useData.SETTINGS["DynamicSearch"] = str(state)

    def setMarkSearchOccurrence(self, state):
        self.useData.SETTINGS["MarkSearchOccurrence"] = str(state)
        for i in range(self.projectWindowStack.count() - 1):
            editorTabWidget = self.projectWindowStack.widget(i).editorTabWidget
            for i in range(editorTabWidget.count()):
                editor = editorTabWidget.getEditor(i)
                snapshot = editorTabWidget.getSnapshot(i)

                editor.clearMatchIndicators()
                snapshot.clearMatchIndicators()

    def setShowEdgeLine(self, state):
        self.useData.SETTINGS["ShowEdgeLine"] = str(state)
        for i in range(self.projectWindowStack.count() - 1):
            editorTabWidget = self.projectWindowStack.widget(i).editorTabWidget
            for i in range(editorTabWidget.count()):
                editor = editorTabWidget.getEditor(i)
                if editor.DATA["fileType"] == "python":
                    editor2 = editorTabWidget.getCloneEditor(i)
                    editor.showWhiteSpaces()
                    editor2.showWhiteSpaces()
                    if state:
                        editor.setEdgeMode(QsciScintilla.EdgeLine)
                        editor2.setEdgeMode(QsciScintilla.EdgeLine)
                    else:
                        editor.setEdgeMode(QsciScintilla.EdgeNone)
                        editor2.setEdgeMode(QsciScintilla.EdgeNone)

    def setDocOnHover(self, state):
        self.useData.SETTINGS["DocOnHover"] = str(state)

    def setMarkOperationalLines(self, state):
        self.useData.SETTINGS["MarkOperationalLines"] = str(state)
        for i in range(self.projectWindowStack.count() - 1):
            editorTabWidget = self.projectWindowStack.widget(i).editorTabWidget
            for i in range(editorTabWidget.count()):
                editor = editorTabWidget.getEditor(i)
                if editor.DATA["fileType"] == "python":
                    editor2 = editorTabWidget.getCloneEditor(i)
                    editor.setMarkOperationalLines()
                    editor2.setMarkOperationalLines()

    def updateStyleBox(self):
        self.themeBox.clear()
        self.themeBox.addItem('Default')
        self.themeBox.insertSeparator(1)
        for i in os.listdir(self.useData.appPathDict["stylesdir"]):
            self.themeBox.addItem(os.path.splitext(i)[0])

########NEW FILE########
__FILENAME__ = Keymap
from PyQt4 import QtCore, QtGui, QtXml
from PyQt4.Qsci import QsciScintilla


class GetShortcut(QtGui.QDialog):

    def __init__(self, parent=None):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)
        self.setWindowTitle("New Shortcut")

        self.accepted = False
        self.keyValue = None

        # Keyword modifiers!
        self.keyword_modifiers = (
            QtCore.Qt.Key_Control, QtCore.Qt.Key_Meta, QtCore.Qt.Key_Shift,
            QtCore.Qt.Key_Alt, QtCore.Qt.Key_Menu)

        mainLayout = QtGui.QVBoxLayout(self)

        self.keyLine = QtGui.QLineEdit()
        self.keyLine.setReadOnly(True)
        self.keyLine.installEventFilter(self)
        mainLayout.addWidget(self.keyLine)

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        okButton = QtGui.QPushButton("Accept")
        okButton.clicked.connect(self.saveShortcut)
        hbox.addWidget(okButton)

        cancelButton = QtGui.QPushButton("Cancel")
        cancelButton.clicked.connect(self.close)
        hbox.addWidget(cancelButton)

    def saveShortcut(self):
        self.close()
        self.keysequence = QtGui.QKeySequence(self.keyLine.text())
        self.accepted = True

    def setShortcut(self, txt):
        self.keyLine.setText(txt)

    def eventFilter(self, watched, event):
        if event.type() == QtCore.QEvent.KeyPress:
            self.keyPressEvent(event)
            return True
        return False

    def keyPressEvent(self, event):
        # modifier can not be used as shortcut
        if event.key() in self.keyword_modifiers:
            return

        if event.key() == QtCore.Qt.Key_Backtab and event.modifiers() & QtCore.Qt.ShiftModifier:
            self.keyValue = QtCore.Qt.Key_Tab
        else:
            self.keyValue = event.key()
        if event.modifiers() & QtCore.Qt.ShiftModifier:
            self.keyValue += QtCore.Qt.SHIFT
        if event.modifiers() & QtCore.Qt.ControlModifier:
            self.keyValue += QtCore.Qt.CTRL
        if event.modifiers() & QtCore.Qt.AltModifier:
            self.keyValue += QtCore.Qt.ALT
        if event.modifiers() & QtCore.Qt.MetaModifier:
            self.keyValue += QtCore.Qt.META
        # set the keys
        self.setShortcut(QtGui.QKeySequence(self.keyValue).toString())


class Keymap(QtGui.QDialog):

    def __init__(self, useData, projectWindowStack, parent):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle('Keymap')
        self.resize(500, 400)

        self.parent = parent
        self.useData = useData
        self.projectWindowStack = projectWindowStack

        mainLayout = QtGui.QVBoxLayout()
        self.setLayout(mainLayout)

        self.shortcutsView = QtGui.QTreeWidget()
        self.shortcutsView.setHeaderLabels(["Function", "Shortcut"])
        self.shortcutsView.setColumnWidth(0, 450)
        self.shortcutsView.setSortingEnabled(True)
        self.shortcutsView.sortByColumn(0, QtCore.Qt.AscendingOrder)
        self.shortcutsView.itemDoubleClicked.connect(self.newShortcut)
        mainLayout.addWidget(self.shortcutsView)

        hbox = QtGui.QHBoxLayout()
        hbox.setMargin(0)
        mainLayout.addLayout(hbox)

        hbox.addStretch(1)
        load_defaults_button = QtGui.QPushButton(self.tr("Default"))
        load_defaults_button.clicked.connect(self.setDefaultShortcuts)
        hbox.addWidget(load_defaults_button)

        self.applyButton = QtGui.QPushButton("Apply")
        self.applyButton.clicked.connect(self.save)
        hbox.addWidget(self.applyButton)

        self.updateShortcutsView()

    def validateShortcut(self, keysequence):
        """
        Validate a shortcut
        """
        if keysequence.isEmpty():
            return True

        currentItem = self.shortcutsView.currentItem()
        keystr = keysequence.toString()

        for index in range(self.shortcutsView.topLevelItemCount()):
            topLevelItem = self.shortcutsView.topLevelItem(index)

            for i in range(topLevelItem.childCount()):
                item = topLevelItem.child(i)
                if item.text(1) == keystr:
                    if currentItem != item:
                        reply = QtGui.QMessageBox.warning(self,
                                                          'Shortcut',
                                                          "Shortcut already in use by '{0}'\n\nReplace it?".format(
                                                              item.text(0)),
                                                          QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
                        if reply == QtGui.QMessageBox.Yes:
                            item.setText(1, "")
                            return True
                        else:
                            return False

        return True

    def newShortcut(self, item, column):
        if item.childCount():
            return
        shortcut = GetShortcut(self)
        shortcut.setShortcut(QtGui.QKeySequence(item.text(1)).toString())
        shortcut.exec_()
        if shortcut.accepted:
            if self.validateShortcut(shortcut.keysequence):
                item = self.shortcutsView.currentItem()
                topLevelItem = item.parent()
                item.setText(
                    1, shortcut.keysequence.toString())
                group = topLevelItem.text(0)
                shortName = shortcut.keysequence.toString()
                self.useData.CUSTOM_SHORTCUTS[group][
                    item.text(0)][0] = shortName
                if group == "Editor":
                    if shortcut.keyValue is None:
                        return
                    self.useData.CUSTOM_SHORTCUTS[group][
                        item.text(0)][1] = shortcut.keyValue

    def save(self):
        self.bindKeymap()
        self.saveKeymap()

    def saveKeymap(self, path=None):
        dom_document = QtXml.QDomDocument("keymap")

        keymap = dom_document.createElement("keymap")
        dom_document.appendChild(keymap)

        for key, value in self.useData.CUSTOM_SHORTCUTS.items():
            root = dom_document.createElement(key)
            keymap.appendChild(root)

            for short, func in value.items():
                tag = dom_document.createElement(short)
                if key == "Editor":
                    shortName = func[0]
                    keyValue = str(func[1])
                    tag.setAttribute("shortcut", shortName)
                    tag.setAttribute("value", keyValue)
                else:
                    tag.setAttribute("shortcut", func)
                root.appendChild(tag)

        if path is None:
            path = self.useData.appPathDict["keymap"]
        file = open(path, "w")
        file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
        file.write(dom_document.toString())
        file.close()

    def bindKeymap(self):
        for i in range(self.projectWindowStack.count() - 1):
            window = self.projectWindowStack.widget(i)
            window.setKeymap()
            editorTabWidget = window.editorTabWidget
            editorTabWidget.setKeymap()
            for i in range(editorTabWidget.count()):
                editor = editorTabWidget.getEditor(i)
                editor2 = editorTabWidget.getCloneEditor(i)
                editor.setKeymap()
                editor2.setKeymap()

    def updateShortcutsView(self):
        self.shortcutsView.clear()
        keyList = ['Editor', 'Ide']
        for i in keyList:
            mainItem = QtGui.QTreeWidgetItem(self.shortcutsView)
            mainItem.setText(0, i)
            if i == "Editor":
                for function, action in self.useData.CUSTOM_SHORTCUTS[i].items():
                    item = QtGui.QTreeWidgetItem(
                        mainItem, [function, action[0]])
            else:
                for function, action in self.useData.CUSTOM_SHORTCUTS[i].items():
                    item = QtGui.QTreeWidgetItem(mainItem, [function, action])
            mainItem.setExpanded(True)

    def setDefaultShortcuts(self):
        reply = QtGui.QMessageBox.warning(self, "Default Keymap",
                                          "Setting keymap to default will wipe away your current keymap.\n\nProceed?",
                                          QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            for key, value in self.useData.DEFAULT_SHORTCUTS['Ide'].items():
                default = self.useData.DEFAULT_SHORTCUTS['Ide'][key]
                self.useData.CUSTOM_SHORTCUTS['Ide'][key] = default

            sc = QsciScintilla()
            standardCommands = sc.standardCommands()

            for key, value in self.useData.DEFAULT_SHORTCUTS['Editor'].items():
                default = self.useData.DEFAULT_SHORTCUTS['Editor'][key]
                command = standardCommands.find(default[1])
                keyValue = command.key()
                self.useData.CUSTOM_SHORTCUTS[
                    'Editor'][key] = [default[0], keyValue]
            self.save()
            self.useData.loadKeymap()
            self.updateShortcutsView()
        else:
            return

########NEW FILE########
__FILENAME__ = ModuleCompletion
from PyQt4 import QtCore, QtGui


class ModuleCompletion(QtGui.QTreeWidget):

    def __init__(self, useData, parent=None):
        QtGui.QTreeWidget.__init__(self, parent)

        self.useData = useData

        self.setHeaderLabel("Modules")
        for i, v in self.useData.libraryDict.items():
            item = QtGui.QTreeWidgetItem(self)
            item.setCheckState(0, False)
            item.setText(0, i)
            item.setCheckState(0, 2)

            for sub in v[0]:
                subItem = QtGui.QTreeWidgetItem(item)
                subItem.setText(0, sub)

        self.createActions()

    def createActions(self):
        self.addItemAct = QtGui.QAction(
            "Add Library", self, statusTip="Add Library", triggered=self.addLibrary)

        self.removeItemAct = \
            QtGui.QAction(
                "Remove Library", self, statusTip="Remove Library", triggered=self.removeLibrary)

        self.addModuleAct = \
            QtGui.QAction(
                "Add Module", self, statusTip="Add Module", triggered=self.addModule)

        self.removeModuleAct = \
            QtGui.QAction(
                "Remove Module", self, statusTip="Remove Module", triggered=self.removeModule)

        self.contextMenu = QtGui.QMenu()
        self.contextMenu.addAction(self.addItemAct)
        self.contextMenu.addAction(self.removeItemAct)
        self.contextMenu.addSeparator()
        self.contextMenu.addAction(self.addModuleAct)
        self.contextMenu.addAction(self.removeModuleAct)

    def contextMenuEvent(self, event):
        selected = self.selectedItems()
        self.selectedItem = selected[0]
        self.selectedParent = self.selectedItem.parent()

        self.contextMenu.exec_(event.globalPos())

    def addLibrary(self):
        return
        if self.selectedParent is None:
            parent = self.selectedItem
        else:
            parent = self.selectedParent
        newItem = QtGui.QTreeWidgetItem()
        newItem.setFlags(QtCore.Qt.ItemIsEditable |
                         QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
        parent.insertChild(self.cu, newItem)
        self.editItem(newItem)

    def removeLibrary(self):
        if self.selectedParent != None:
            itemText = self.selectedItem.text(0)
            parentText = self.selectedParent.text(0)
            self.useData.libraryDict[parentText][0].remove(itemText)
            self.setItemHidden(self.selectedItem, True)

    def addModule(self):
        return
        if self.selectedParent is None:
            parent = self.selectedItem
        else:
            parent = self.selectedParent
        newItem = QtGui.QTreeWidgetItem()
        newItem.setFlags(QtCore.Qt.ItemIsEditable |
                         QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
        parent.insertChild(self.cu, newItem)
        self.editItem(newItem)

    def removeModule(self):
        if self.selectedParent != None:
            itemText = self.selectedItem.text(0)
            parentText = self.selectedParent.text(0)
            self.useData.libraryDict[parentText][0].remove(itemText)
            self.setItemHidden(self.selectedItem, True)
########NEW FILE########
__FILENAME__ = SettingsWidget
from PyQt4 import QtCore, QtGui

from Extensions.Settings.ColorScheme.ColorScheme import ColorScheme
from Extensions.Settings.Keymap import Keymap
from Extensions.Settings.SnippetsManager import SnippetsManager
from Extensions.Settings.GeneralSettings import GeneralSettings
from Extensions.Settings.ModuleCompletion import ModuleCompletion


class SettingsWidget(QtGui.QDialog):

    def __init__(self, useData, mainApp, projectWindowStack, libraryViewer, parent=None):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle("Settings")

        self.useData = useData
        self.libraryViewer = libraryViewer
        self.projectWindowStack = projectWindowStack

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setMargin(0)
        self.setLayout(mainLayout)

        self.settingsTab = QtGui.QTabWidget()
        self.settingsTab.setObjectName("settingsTab")
        mainLayout.addWidget(self.settingsTab)

        self.generalSettings = GeneralSettings(useData, mainApp, projectWindowStack)
        self.settingsTab.addTab(self.generalSettings, "General")

        self.snippetEditor = SnippetsManager(
            self.useData.appPathDict["snippetsdir"], self)
        self.settingsTab.addTab(self.snippetEditor, "Snippets")

        self.keymapWidget = Keymap(self.useData, projectWindowStack, self)
        self.settingsTab.addTab(self.keymapWidget, "Shortcuts")

        self.colorScheme = ColorScheme(self.useData, projectWindowStack,
                                       libraryViewer)
        self.settingsTab.addTab(self.colorScheme, "Color Scheme")

        self.libraries = ModuleCompletion(self.useData)
        self.settingsTab.addTab(self.libraries, "Module Completion")

########NEW FILE########
__FILENAME__ = SnippetsManager
import os
from PyQt4 import QtCore, QtGui


class GetName(QtGui.QDialog):

    def __init__(self, caption, path, parent=None):
        QtGui.QDialog.__init__(self, parent, QtCore.Qt.Window |
                               QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle(caption)

        self.path = path

        mainLayout = QtGui.QVBoxLayout()
        self.setLayout(mainLayout)
        mainLayout.addWidget(QtGui.QLabel("Name:"))

        self.nameLine = QtGui.QLineEdit()
        self.nameLine.selectAll()
        self.nameLine.textChanged.connect(self.enableAcceptButton)
        mainLayout.addWidget(self.nameLine)

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        self.statusLabel = QtGui.QLabel()
        hbox.addWidget(self.statusLabel)

        self.statusLabel = QtGui.QLabel("")
        hbox.addWidget(self.statusLabel)

        hbox.addStretch(1)

        self.acceptButton = QtGui.QPushButton("Ok")
        self.acceptButton.setDisabled(True)
        self.acceptButton.clicked.connect(self.accept)
        hbox.addWidget(self.acceptButton)

        self.cancelButton = QtGui.QPushButton("Cancel")
        self.cancelButton.clicked.connect(self.close)
        hbox.addWidget(self.cancelButton)

        self.resize(300, 20)
        self.enableAcceptButton()

        self.accepted = False

        self.exec_()

    def enableAcceptButton(self):
        text = self.nameLine.text().strip()
        if text == '':
            self.acceptButton.setDisabled(True)
        else:
            preExistNames = os.listdir(self.path)
            if text in preExistNames:
                self.statusLabel.setText("Unavailable")
                self.acceptButton.setDisabled(True)
            else:
                self.statusLabel.setText("Available")
                self.acceptButton.setDisabled(False)

    def accept(self):
        self.accepted = True
        self.name = self.nameLine.text().strip()
        self.close()


class SnippetsManager(QtGui.QDialog):

    def __init__(self, path, parent):
        QtGui.QDialog.__init__(self, parent)

        self.setWindowTitle("Snippets")
        self.setAcceptDrops(True)
        self.resize(500, 300)

        self.path = path

        mainLayout = QtGui.QVBoxLayout()

        self.mainSplitter = QtGui.QSplitter()

        self.snippetsListWidget = QtGui.QListWidget()
        self.snippetsListWidget.setSortingEnabled(True)
        self.snippetsListWidget.itemPressed.connect(self.loadSnippet)
        self.snippetsListWidget.currentItemChanged.connect(self.loadSnippet)

        self.mainSplitter.addWidget(self.snippetsListWidget)

        self.snippetViewer = QtGui.QTextEdit()
        self.snippetViewer.setReadOnly(True)
        self.mainSplitter.addWidget(self.snippetViewer)
        mainLayout.addWidget(self.mainSplitter)
        self.setLayout(mainLayout)

        mainLayout.addWidget(self.mainSplitter)

        hbox = QtGui.QHBoxLayout()

        self.addButton = QtGui.QToolButton()
        self.addButton.setAutoRaise(True)
        self.addButton.setToolTip("Add")
        self.addButton.setIcon(QtGui.QIcon(os.path.join("Resources", "images", "add")))
        self.addButton.clicked.connect(self.addSnippet)
        hbox.addWidget(self.addButton)

        self.removeButton = QtGui.QToolButton()
        self.removeButton.setAutoRaise(True)
        self.removeButton.setToolTip("Remove")
        self.removeButton.setIcon(QtGui.QIcon(os.path.join("Resources", "images", "minus")))
        self.removeButton.clicked.connect(self.removeSnippet)
        hbox.addWidget(self.removeButton)

        self.renameButton = QtGui.QToolButton()
        self.renameButton.setAutoRaise(True)
        self.renameButton.setToolTip("Rename")
        self.renameButton.setIcon(QtGui.QIcon(
            os.path.join("Resources", "images", "ui-text-field")))
        self.renameButton.clicked.connect(self.renameSnippet)
        hbox.addWidget(self.renameButton)

        hbox.addStretch(1)

        self.saveButton = QtGui.QPushButton("Save")
        self.saveButton.clicked.connect(self.saveSnippet)
        hbox.addWidget(self.saveButton)

        mainLayout.addLayout(hbox)

        self.mainSplitter.setSizes([10, 400])

        self.mainSplitter.setCollapsible(0, False)
        self.mainSplitter.setCollapsible(1, False)

        self.loadSnippetList()

    def dragEnterEvent(self, event):
        if event.mimeData().hasText():
            if event.source() in self.children():
                event.setDropAction(QtCore.Qt.CopyAction)
                event.accept()
            else:
                event.acceptProposedAction()
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        event.acceptProposedAction()

    def dropEvent(self, event):
        # FIXME: Dragging only works when dropped anywhere else but the editor.
        # Have to find a way to get the editor to accept drop actions that
        # have to do with text
        if event.mimeData().hasText():
            mime = event.mimeData()
            event.setDropAction(QtCore.Qt.CopyAction)
            snippet = GetName("Add Snippet", self.path, self)
            if snippet.accepted:
                file = open(os.path.join(self.path, snippet.name), 'w')
                file.write(mime.text())
                file.close()

                self.loadSnippetList()
                found = self.snippetsListWidget.findItems(snippet.name,
                                                          QtCore.Qt.MatchCaseSensitive)
                item = found[0]
                self.snippetsListWidget.setCurrentItem(item)
        else:
            event.ignore()

    def addSnippet(self):
        snippet = GetName("Add Snippet", self.path, self)
        if snippet.accepted:
            file = open(os.path.join(self.path, snippet.name), 'w')
            file.close()

            self.loadSnippetList()
            found = self.snippetsListWidget.findItems(snippet.name,
                                                      QtCore.Qt.MatchCaseSensitive)
            item = found[0]
            self.snippetsListWidget.setCurrentItem(item)

    def saveSnippet(self):
        name = self.snippetsListWidget.currentItem().text()
        path = os.path.join(self.path, name)
        file = open(path, 'w')
        file.write(self.snippetViewer.toPlainText())
        file.close()

    def renameSnippet(self):
        snippet = GetName("Rename Snippet", self.path, self)
        if snippet.accepted:
            old_name = self.snippetsListWidget.currentItem().text()
            new_name = snippet.name
            old_path = os.path.join(self.path, old_name)
            new_path = os.path.join(self.path, new_name)
            os.rename(old_path, new_path)

            self.loadSnippetList()
            found = self.snippetsListWidget.findItems(new_name,
                                                      QtCore.Qt.MatchCaseSensitive)
            item = found[0]
            self.snippetsListWidget.setCurrentItem(item)

    def removeSnippet(self):
        name = self.snippetsListWidget.currentItem().text()

        mess = 'Remove "{0}" from snippets?'.format(name)
        reply = QtGui.QMessageBox.warning(self, "Remove", mess,
                                          QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            os.remove(os.path.join(self.path, name))
            self.loadSnippetList()
        elif reply == QtGui.QMessageBox.No:
            pass

    def loadSnippetList(self):
        self.snippetViewer.clear()
        self.snippetsListWidget.clear()
        for i in os.listdir(self.path):
            self.snippetsListWidget.addItem(i)
        if self.snippetsListWidget.count() == 0:
            self.snippetViewer.setReadOnly(True)
            self.removeButton.setDisabled(True)
        else:
            self.snippetViewer.setReadOnly(False)
            self.removeButton.setDisabled(False)
            self.snippetsListWidget.setCurrentRow(0)

    def loadSnippet(self):
        if self.snippetsListWidget.count() == 0:
            return
        currentItem = self.snippetsListWidget.currentItem()
        if currentItem is None:
            return
        key = currentItem.text()
        file = open(os.path.join(self.path, key), 'r')
        self.snippetViewer.setText(file.read())
        file.close()

########NEW FILE########
__FILENAME__ = StackSwitcher
from PyQt4 import QtGui, QtCore


class StackSwitcher(QtGui.QWidget):

    changed = QtCore.pyqtSignal(str)

    def __init__(self, stack, parent=None):
        QtGui.QDialog.__init__(self, parent)

        self.stack = stack
        self.lastIndex = 0

        self.mainLayout = QtGui.QHBoxLayout()
        self.mainLayout.setMargin(0)
        self.mainLayout.setSpacing(0)
        self.setLayout(self.mainLayout)

        self.buttonGroup = QtGui.QButtonGroup()
        self.buttonGroup.setExclusive(True)
        self.buttonGroup.buttonPressed.connect(self.setIndex)

    def addButton(self, name=None, icon=None, toolTip=None):
        button = QtGui.QPushButton()
        if name is not None:
            button.setText(name)
        if toolTip is not None:
            button.setToolTip(toolTip)
        button.setCheckable(True)
        if icon is not None:
            button.setIcon(icon)
        self.buttonGroup.addButton(button)
        self.buttonGroup.setId(button, self.lastIndex)
        self.mainLayout.addWidget(button)

        self.lastIndex += 1

    def setIndex(self, button):
        index = self.buttonGroup.id(button)
        self.stack.setCurrentIndex(index)
        self.changed.emit(button.text())

    def setCount(self, widget, text):
        index = self.stack.indexOf(widget)
        self.buttonGroup.button(index).setText(text)

    def setCurrentWidget(self, widget):
        index = self.stack.indexOf(widget)
        button = self.buttonGroup.button(index)
        button.setChecked(True)
        self.stack.setCurrentWidget(widget)

        self.changed.emit(button.text())

    def setDefault(self):
        """
        Shows the active button after initialization
        """
        button = self.buttonGroup.button(0)
        button.setChecked(True)
        self.changed.emit(button.text())

########NEW FILE########
__FILENAME__ = Start
import os
from PyQt4 import QtGui, QtCore


class Start(QtGui.QLabel):

    def __init__(self, useData,  parent):
        QtGui.QLabel.__init__(self)

        self.pcode = parent
        self.useData = useData

        mainLayout = QtGui.QHBoxLayout()
        mainLayout.setMargin(0)
        self.setScaledContents(True)
        self.setObjectName("mainlabel")
        self.setLayout(mainLayout)

        mainLayout.addStretch(1)

        vbox = QtGui.QVBoxLayout()
        mainLayout.addLayout(vbox)

        vbox.addStretch(1)

        centerLabel = QtGui.QLabel()
        centerLabel.setObjectName("centerlabel")
        centerLabel.setMinimumWidth(500)
        centerLabel.setMinimumHeight(300)
        centerLabel.setScaledContents(True)
        centerLabel.setStyleSheet("""
                            QListView {
                                 show-decoration-selected: 1; /* make the selection span the entire width of the view */
                                 border: none;
                            }

                            QListView::item {
                                 min-height: 20px;
                            }

                            QListView::item:hover {
                                 border: none;
                                 background: #E3E3E3;
                            }

                            QListView::item:selected:!active {
                                 border: 1px solid white;
                                 background: #E3E3E3;
                            }

                            QListView::item:selected:active {
                                 color: white;
                                 background: #3F3F3F;
                            }""")
        vbox.addWidget(centerLabel)

        vbox.addStretch(2)

        shadowEffect = QtGui.QGraphicsDropShadowEffect()
        shadowEffect.setColor(QtGui.QColor("#000000"))
        shadowEffect.setXOffset(0)
        shadowEffect.setYOffset(0)
        shadowEffect.setBlurRadius(20)
        centerLabel.setGraphicsEffect(shadowEffect)

        centralLayout = QtGui.QVBoxLayout()
        centerLabel.setLayout(centralLayout)

        hbox = QtGui.QHBoxLayout()
        centralLayout.addLayout(hbox)

        label = QtGui.QLabel("Getting started...")
        label.setFont(QtGui.QFont("Consolas", 20))
        hbox.addWidget(label)

        hbox.addStretch(1)

        label = QtGui.QLabel()
        label.setScaledContents(True)
        label.setMaximumWidth(35)
        label.setMinimumWidth(35)
        label.setMaximumHeight(35)
        label.setMinimumHeight(35)
        label.setPixmap(QtGui.QPixmap(os.path.join("Resources", "images", "compass")))
        hbox.addWidget(label)

        frame = QtGui.QFrame()
        frame.setGeometry(1, 1, 1, 1)
        frame.setFrameShape(frame.HLine)
        frame.setFrameShadow(frame.Plain)
        centralLayout.addWidget(frame)

        label = QtGui.QLabel(
            "For the sake of convenience, most tasks are handled in the "
            "context of a project. Start editing your files by first "
            "creating a project or opening an existing one.")
        label.setWordWrap(True)
        label.setFont(QtGui.QFont("Consolas", 10))
        centralLayout.addWidget(label)

        centralLayout.addStretch(1)

        label = QtGui.QLabel("Recent Projects:")
        label.setStyleSheet("color: #0063A6; font: 12px;")
        centralLayout.addWidget(label)

        self.recentProjectsListWidget = QtGui.QListWidget()
        for i in useData.OPENED_PROJECTS:
            self.recentProjectsListWidget.addItem(QtGui.QListWidgetItem(i))
        self.recentProjectsListWidget.itemDoubleClicked.connect(
            self.openProjectFromList)
        centralLayout.addWidget(self.recentProjectsListWidget)

        frame = QtGui.QFrame()
        frame.setGeometry(1, 1, 1, 1)
        frame.setFrameShape(frame.HLine)
        frame.setFrameShadow(frame.Plain)
        centralLayout.addWidget(frame)

        hbox = QtGui.QHBoxLayout()
        centralLayout.addLayout(hbox)

        openButton = QtGui.QPushButton("Open Project")
        openButton.setIcon(QtGui.QIcon(os.path.join("Resources", "images", "wooden-box")))
        openButton.clicked.connect(self.openProject)
        hbox.addWidget(openButton)

        newButton = QtGui.QPushButton("New Project")
        newButton.setIcon(QtGui.QIcon(os.path.join("Resources", "images", "inbox--plus")))
        newButton.clicked.connect(self.createProject)
        hbox.addWidget(newButton)

        hbox.addStretch(1)

        homePageButton = QtGui.QPushButton("Visit Homepage")
        homePageButton.setIcon(QtGui.QIcon(os.path.join("Resources", "images", "Web")))
        homePageButton.clicked.connect(self.visitHomepage)
        hbox.addWidget(homePageButton)

        mainLayout.addStretch(1)

        style = """
            QLabel#mainlabel {background: #565656;
                    }

            QLabel#centerlabel {border-radius: 2px;
                background: #FFFFFF;
                     }

            QPushButton {min-width: 105;}
            """

        self.setStyleSheet(style)

    def visitHomepage(self):
        QtGui.QDesktopServices().openUrl(QtCore.QUrl(
            """https://github.com/fortharris/Pcode"""))

    def createProject(self):
        self.pcode.newProject()

    def openProject(self):
        options = QtGui.QFileDialog.DontResolveSymlinks | QtGui.QFileDialog.ShowDirsOnly
        directory = QtGui.QFileDialog.getExistingDirectory(self,
                                                           "Project Folder", self.useData.getLastOpenedDir(), options)
        if directory:
            directory = os.path.normpath(directory)
            self.useData.saveLastOpenedDir(directory)
            self.pcode.loadProject(directory, True)

    def openProjectFromList(self, item):
        self.pcode.loadProject(item.text(), True)

########NEW FILE########
__FILENAME__ = StyleSheet
globalStyle = """

                 QsciScintilla#editor {
                         border: none;
                         border-top: 2px solid #007ACC;
                 }

                QToolButton {
                    background: transparent;
                    border-radius: 0px;
                    padding: 1px;
                    border: none;
                }

                QToolButton:hover {
                    background: white;
                }

                QToolButton:pressed {
                    background: #007ACC;
                }

                QToolButton:checked {
                    background: #007ACC;
                }

                QToolButton:disabled {
                    background: transparent;
                }

                 QToolButton::menu-button {
                     color: black;
                 }

             QGroupBox {
                 background-color: none;
                 border: none;
                 font: bold;
                 border-radius: 0px;
                 margin-top: 5ex; /* leave space at the top for the title */
             }

             QGroupBox::title {
                 padding-left: 8px;
                 subcontrol-origin: margin;
                 subcontrol-position: top left; /* position at the top left */
                 background-color: none;
             }

             QComboBox {
                 color: #003366;
                 border-top: transparent;
                 border-right: transparent;
                 border-left: transparent;
                 border-bottom: 1px solid #007ACC;
                 border-radius: 0px;
                 padding: 2px 2px 2px 3px;
             }

             QComboBox:disabled {
                 color: gray;
             }

             QComboBox:editable {
                 background: white;
             }

             QComboBox:!editable, QComboBox::drop-down:editable {
                  background: lightgrey;
                  border-radius: 0px;
             }

             /* QComboBox gets the "on" state when the popup is open */
             QComboBox:!editable:on, QComboBox::drop-down:editable:on {
                 background: darkgray;
             }

             QComboBox:on { /* shift the text when the popup opens */
             
             }

             QComboBox::drop-down {
                 subcontrol-origin: padding;
                 subcontrol-position: top right;
                 width: 15px;
                 border: none;
             }

             QComboBox::down-arrow {
                 image: url(Resources/style/images/downarrow.png);
             }

             QComboBox::down-arrow:on { /* shift the arrow when popup is open */
                 top: 1px;
                 left: 0px;
             }

             QComboBox QAbstractItemView {
                 border: 1px solid lightgray;
                 selection-background-color: #2B2BFF;
             }

             QComboBox QAbstractItemView::item {
                 min-height: 25px;
             }

        QTabWidget::pane { /* The tab widget frame */
             border-top: none;
        }

        QTabWidget#settingsTab::pane { /* The tab widget frame */
             border-top: 1px solid #007ACC;
             position: absolute;
        }

        QTabWidget::pane#buildTab { /* The tab widget frame */
             border-top: 2px solid #007ACC;
        }

        QTabWidget::pane#sideBottomTab { /* The tab widget frame */
             border-top: 2px solid #007ACC;
        }

        QTabWidget::tab-bar {
             left: 0px; /* move to the right by 0px */
        }

        QTabWidget#sideBottomTab::tab-bar {
             left: 0px; /* move to the right by 0px */
        }

        QTabWidget#settingsTab::tab-bar {
             left: 10px; /* move to the right by 0px */
        }

        /* Style the tab using the tab sub-control. Note that
             it reads QTabBar _not_ QTabWidget */
        QTabBar::tab {
             background: none;
             border: none;
             min-width: 24ex;
             min-height: 5ex;
             padding: 2px;
             padding-left: 5px;
             padding-right: 5px;
        }

        QTabBar::tab:hover {
             background: #70A7DC;
             color: black;
        }

        QTabBar::tab:selected{
             background: #007ACC;
             color: white;
        }

        QTabBar::tab:!selected {
             margin-top: 0px; /* make non-selected tabs look smaller */
        }

        QTabBar::tab:first {
             border-left: none;
         }

        QTabBar::tab:only-one {
             border-left: none;
        }

        QTabBar::tear {
             image: url(Resources/style/images/tear.png);
        }

        QTabBar::scroller { /* the width of the scroll buttons */
             width: 20px;
        }

        QTabBar QToolButton { /* the scroll buttons are tool buttons */
             border-image: url(Resources/style/images/scrollbutton.png) 2;

        }

        QTabBar QToolButton::right-arrow { /* the arrow mark in the tool buttons */
             image: url(Resources/style/images/Arrow Right.png);
        }

        QTabBar QToolButton::left-arrow {
             image: url(Resources/style/images/Arrow Left.png);
        }


        QTabBar::close-button {
             image: url(Resources/style/images/close1.png)

         }

        QTabBar::close-button:hover {
             image: url(Resources/style/images/close-hover.png)
        }

        QTabBar::close-button:pressed {
             image: url(Resources/style/images/close-pressed.png)
        }

        QToolBar {
            border: none;
            background-color: transparent;
        }

        QToolBar QToolButton {
            border: 1px solid transparent;
            background: transparent;
            padding: 1px;
        }

        QToolBar QToolButton:hover:enabled { /* when selected using mouse or keyboard */
             background-color: white;
        }

        QToolBar QToolButton:pressed:enabled {
             background-color: #007ACC;
        }

        QToolBar QToolButton:disabled {
             background-color: transparent;
        }

        QToolBar QToolButton:checked {
             background-color: #007ACC;
        }

        QStatusBar {
             background: transparent;
        }

        QStatusBar::item {
             border-radius: 3px;
        }


        QDockWidget {
             color: white;
             titlebar-close-icon: url(Resources/style/images/close_black.png);
             titlebar-normal-icon: url(Resources/style/images/undock.png);
        }

        QDockWidget::title {
             border: none;
             text-align: left; /* align the text to the left */
             background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                               stop:0 #585858, stop:1 #3F3F3F);
             padding-left: 5px;
        }

        QDockWidget::close-button, QDockWidget::float-button {
             border: none;
             background: transparent;
             padding: 2px;
        }

        QDockWidget::close-button:hover, QDockWidget::float-button:hover {
             background: transparent;
        }

        QDockWidget::close-button:pressed, QDockWidget::float-button:pressed {
             padding: 1px -1px -1px 1px;
        }

        QToolTip {
             color: white;
             border: none;
             opacity: 200;
             border-radius: 3px;
             background: #333333;
        }

        QMenuBar {
             background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                           stop:0 lightgray, stop:1 darkgray);
        }

        QMenuBar {
             background-color: #F0F0F0;
             border-bottom: 1px solid darkgrey;
        }

        QMenuBar::item {
             spacing: 3px; /* spacing between menu bar items */
             padding: 3px 8px;
             background: none;
             border-radius: 0px;
        }

        QMenuBar::item:selected { /* when selected using mouse or keyboard */
             background: rgba(255, 0, 0, 80);
        }

        QMenuBar::item:pressed {
             background: rgba(255, 0, 0, 80);
        }

        QMenu {
             background: #E6E6E6;
             padding: 2px;
        }

        QMenu::item {
             padding: 5px 30px 5px 30px;
             border: none;
        }

        QMenu::item:selected:enabled {
             border-color: none;
             background: #FAFAFA;
        }

        QMenu::separator {
             height: 1px;
             background-color: lightgrey;
        }

        QMenu::indicator {
             width: 13px;
             height: 13px;
        }

        QListView {
             show-decoration-selected: 1; /* make the selection span the entire width of the view */
        }

        QListView::item:selected:!active {
             color: black;
             border: 1px solid white;
             background: lightgray;
        }

        QListView::item:selected:active {
             color: white;
             background: #337BFF;
        }

         QHeaderView::section {
             background: none;
             color: black;
             padding-left: 2px;
             border: none;
             border-bottom: 1px solid lightgray;
             height: 20px;
         }

         QHeaderView::section:checked
         {
             background-color: red;
         }

         /* style the sort indicator */
         QHeaderView::down-arrow {
             image: url(Resources/style/images/downarrow.png);
         }

         QHeaderView::up-arrow {
             image: url(Resources/style/images/uparrow.png);
         }


        QTreeView {
             show-decoration-selected: 1; /* make the selection span the entire width of the view */
             background: #E6E6E6;
             border: none;
        }

        QTreeView#sidebarItem {
             border: none;
             show-decoration-selected: 1; /* make the selection span the entire width of the view */
             background: #E6E6E6;
        }

        QTreeView::item:selected:!active {
             font: bold 20px;
             color: black;
             background: lightgrey;}

        QTreeView::item:selected:active {
             font: bold 20px;
             color: white;
             background: grey;
        }

        QTreeView::item:hover {
             border: none;
             background: #CCCCCC;
        }

        QSlider::groove:horizontal {
             border: 1px inset #999999;
             height: 8px; /* the groove expands to the size of the slider by default. by giving it a height, it has a fixed size */
             background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                                 stop:0 #B3B3B3, stop:1 #FFFFFF);
             margin: 2px 7px 0 7px;
             border-radius: 5px;
        }

        QSlider::handle:horizontal {
             background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                                                 stop:0 #D2D2D2, stop:1 #C3C3C3);
             border: 1px solid #5c5c5c;
             width: 18px;
             margin: -2px 0; /* handle is placed by default on the contents rect of the groove. Expand outside the groove */
             border-radius: 3px;
        }

        QScrollBar:vertical{
            padding-left: 0px;
            padding-right: 1px;
            border-left-width: 1px;
            background: #f1f1f1;
            width: 12px;
        }

        QScrollBar:horizontal{
            padding-top: 0px;
            padding-bottom: 1px;
            border-top-width: 1px;
            border-style:solid;
            border: none;
            background: #E7E7E7;
            height: 10px;
        }

        QScrollBar::handle:vertical{
            margin-top: 15px;
            margin-bottom: 15px;
            background: #B2B8BE;
            border-radius: 0px;
            border: 1px solid #FFFFFF;
            min-height: 30px;
        }

        QScrollBar::handle:horizontal{
            margin-left: 15px;
            margin-right: 15px;
            background: #B2B8BE;
            border-radius: 0px;
            border: none;
            min-width: 30px;
        }

        QScrollBar::handle:hover{
            background: #6F767D;
        }

        QScrollBar::handle:pressed{
            background: #141414;
        }

        QScrollBar::add-line:vertical,
        QScrollBar::sub-line:vertical,
        QScrollBar::add-page:vertical,
        QScrollBar::sub-page:vertical,
        QScrollBar::add-line:horizontal,
        QScrollBar::sub-line:horizontal,
        QScrollBar::add-page:horizontal,
        QScrollBar::sub-page:horizontal{
            background: none;
            border: none;
        }
        
        QScrollBar::add-line:vertical:pressed,
        QScrollBar::sub-line:vertical:pressed,
        QScrollBar::add-page:vertical:pressed,
        QScrollBar::sub-page:vertical:pressed,
        QScrollBar::add-line:horizontal:pressed,
        QScrollBar::sub-line:horizontal:pressed,
        QScrollBar::add-page:horizontal:pressed,
        QScrollBar::sub-page:horizontal:pressed{
            background: lightgrey;
            border: none;
        }

        QScrollBar::up-arrow:vertical {
          border: none;
          width: 10px;
          height: 10px;
          margin-left: 0px;
          image: url(Resources/style/images/uparrow.png);
        }

        QScrollBar::down-arrow:vertical {
          border: none;
          width: 10px;
          height: 10px;
          margin-left: 0px;
          image: url(Resources/style/images/downarrow.png);
        }

        QScrollBar::left-arrow:horizontal {
          border: none;
          width: 10px;
          height: 10px;
          image: url(Resources/style/images/leftarrow.png);
        }

        QScrollBar::right-arrow:horizontal {
          border: none;
          width: 10px;
          height: 10px;
          image: url(Resources/style/images/rightarrow.png);
        }

        QPushButton {
            min-width: 70px;
            min-height: 20px;
            color: black;
            background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                stop: 0 #F1F1F1, stop: 1 #DFDFDF);
            border-radius: 2px;
            border: 1px solid #A8A8A8;
        }

        QPushButton:hover {
            border: 1px solid #AAAAAA;
            background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                stop: 0 #F1F1F1, stop: 1 #F0F0F0);
        }

        QPushButton:pressed {
            background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                stop: 0 #D7D7D7, stop: 1 #BDBDBD);
            padding-top: 2px;
            border: 1px solid #A1A1A1;
        }

        QPushButton:checked {
            background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                stop: 0 #D7D7D7, stop: 1 #BDBDBD);
            padding-top: 2px;
            border: 1px solid #A1A1A1;
        }

        QPushButton:disabled {
            color: black;
            background: #FFFFFF;
        }

         QSplitter::handle {
             background: none;
         }

         QSplitter::handle:horizontal {
             width: 5px;
             background: #E6E6E6;
         }

         QSplitter::handle:vertical {
             height: 5px;
             background: lightgray;
         }

         QSplitter::handle:hover {
             background: lightgray;
         }

         QSplitter::handle:pressed {
             background: gray;
         }

         QLineEdit {
             border: 1px solid lightgrey;
             min-height: 20px;
             border-radius: 0px;
             padding: 0 4px;
             background: none;
         }

         QLineEdit:disabled {
             border: 1px solid lightgray;
         }

        """

projectTitleBoxStyle = """

        QListView {
            border: none;
            border-top: 1px solid lightgray;
            show-decoration-selected: 1; /* make the selection span the entire width of the view */
        }

        QListView::item:selected:!active {
             color: black;
             border: none;
             background: none;
        }

        QListView::item:selected:active {
             color: white;
             border: none;
             background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #5a91d4, stop: 1 #1a57ad);;
        }

        """

bottomSwitcherStyle = """

        QPushButton {
             min-height: 17px;
             background: none;
             border: none;
             border-radius: 0px;
             min-width: 13ex;
             padding: 2px;
        }

        QPushButton:hover {
             color: black;
             background: none;
        }

        QPushButton:pressed {
            background: none;
        }

        QPushButton:checked {
             color: black;
             border-left: 1px solid lightgray;
             border-right: 1px solid lightgray;
        }

        QPushButton:disabled {
            color: black;
            background: #FFFFFF;
        }
        """

editorStyle = """
                 QListView {
                        border: 1px solid black;
                        color: lightgrey;
                        min-width: 500px;
                        min-height: 190px;
                        background: #1C1C1C;
                        show-decoration-selected: 1; /* make the selection span the entire width of the view */
                 }

                 QListView::item:alternate {
                        background: #EEEEEE;
                 }

                 QListView::item:selected {
                        color: white;
                        font: bold;
                        border: none;
                        background: #363636;
                 }

                 QListView::item:selected:!active {
                        color: white;
                        font: bold;
                        border: none;
                        background: #363636;
                 }

                 QListView::item:selected:active {
                        color: white;
                        background: #575757;
                 }

                 QListView::item:hover {
                        border-bottom:  none;
                 }
                """

mainMenuStyle = """

                QPushButton {
                    padding: 2px 6px 2px 6px;
                    color: grey;
                    background: transparent;
                    border: none;
                    border-radius: 0px;
                }

                QPushButton:hover {
                    color: black;
                }

                QPushButton:pressed {

                }

                QPushButton:checked {
                    color: black;
                }

                """

toolWidgetStyle = """

                QLabel#containerLabel { border-left: 1px solid #0099FF;
                                       border-right: 1px solid #0099FF;
                                       border-bottom: 1px solid #0099FF;
                                       background: #F0F0F0;
                                       }

                QLabel#toolWidgetNameLabel { font: 14px; color: grey;}

                """

viewSwitcherStyle = """

                    QLabel {
                        background:  rgba(138, 201, 255, 200);
                        padding: 1px;
                    }

                    QToolButton {
                        min-width: 30px;
                        min-height: 30px;
                        background: #A3D5FF;
                        border-radius: 0px;
                        border: none;
                    }

                    QToolButton:hover {
                        background: white;
                        border: none;
                        border-bottom: 3px solid #A3D5FF;
                    }

                    QToolButton:checked {
                        background: white;
                        border-bottom: 3px solid #3DA7FF;
                    }

                    QToolButton:disabled {
                        background: #FFFFFF;
                    }
                """

########NEW FILE########
__FILENAME__ = TextEditor
import os
from PyQt4 import QtCore, QtGui
from PyQt4.Qsci import QsciScintilla

from Extensions.BaseScintilla import BaseScintilla
from Extensions.ZoomWidget import ZoomWidget
from Extensions import Global
from Extensions.Notification import Notification
from Extensions import StyleSheet


class TextEditor(BaseScintilla):

    def __init__(self, useData, DATA, colorScheme, editorTabWidget,
                 encoding=None, parent=None):
        BaseScintilla.__init__(self, parent)

        self.useData = useData
        self.encoding = encoding
        self.DATA = DATA
        self.colorScheme = colorScheme
        self.editorTabWidget = editorTabWidget

        self.setObjectName("editor")
        self.enableMarkOccurrence(useData)

        self.setFont(Global.getDefaultFont())
        self.setWrapMode(QsciScintilla.WrapWord)

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setMargin(0)
        self.setLayout(mainLayout)

        mainLayout.addStretch(1)

        #

        hbox = QtGui.QHBoxLayout()
        hbox.addStretch(1)
        hbox.setContentsMargins(0, 0, 20, 0)
        mainLayout.addLayout(hbox)

        self.zoomWidget = ZoomWidget(self.useData, self)
        hbox.addWidget(self.zoomWidget)

        #

        hbox = QtGui.QHBoxLayout()
        hbox.addStretch(1)
        hbox.setContentsMargins(5, 0, 20, 20)
        mainLayout.addLayout(hbox)

        self.notification = Notification()
        hbox.addWidget(self.notification)
        self.notification.hide()

        #

        self.createContextMenu()

        # setup
        # define the font to use
        self.font = Global.getDefaultFont()
        self.font.setFixedPitch(True)
        self.font.setPointSize(10)
        # the font metrics here will help
        # building the margin width later
        self.fontMetrics = QtGui.QFontMetrics(self.font)

        # Line numbers
        # conventionnaly, margin 0 is for line numbers
        self.setMarginWidth(0, self.fontMetrics.width("0000") + 5)

        self.setUtf8(True)
        self.setAutoIndent(True)
        self.setIndentationsUseTabs(False)
        self.setBackspaceUnindents(True)
        self.setIndentationWidth(4)
        self.setTabWidth(4)
        # Clickable margin 1 for showing markers
        self.setMarginSensitivity(1, True)

        # Braces matching
        if self.useData.SETTINGS["MatchBraces"] == "True":
            self.setBraceMatching(QsciScintilla.SloppyBraceMatch)

        if self.DATA["fileType"] in self.useData.supportedFileTypes:
            if self.useData.SETTINGS["ShowCaretLine"] == 'True':
                self.setCaretLineVisible(True)

        self.setAutoCompletionReplaceWord(True)
        # minimum number of letters to be typed before list is displayed
        self.setAutoCompletionThreshold(2)

        self.setEdgeMode(QsciScintilla.EdgeNone)
        self.showWhiteSpaces()

        # Margins colors
        # line numbers margin
        self.setMarginsBackgroundColor(QtGui.QColor("#FFFFFF"))
        self.setMarginsForegroundColor(QtGui.QColor("#666666"))

        # define markers

        self.markerDefine(QtGui.QPixmap(
            os.path.join("Resources", "images", "ui-button-navigation")), 8)
        self.setMarkerBackgroundColor(QtGui.QColor("#ee1111"), 8)

        self.markerDefine(
            QtGui.QPixmap(os.path.join("Resources", "images", "err_mark")), 9)
        self.setMarkerBackgroundColor(QtGui.QColor("#ee1111"), 9)

        self.markerDefine(
            QtGui.QPixmap(os.path.join("Resources", "images", "brk_point")), 10)
        self.setMarkerBackgroundColor(QtGui.QColor("#ee1111"), 10)

        self.showLineNumbers()
        self.setAutoCompletionSource(QsciScintilla.AcsDocument)

        self.setEolMode(QsciScintilla.EolUnix)

        self.searchIndicator = self.indicatorDefine(
            QsciScintilla.INDIC_ROUNDBOX, 10)
        self.setIndicatorForegroundColor(
            QtGui.QColor("#FFDB4A"), self.searchIndicator)
        self.setIndicatorDrawUnder(True, self.searchIndicator)

        self.setAutoCompletion()

        self.copyAvailableTimer = QtCore.QTimer()
        self.copyAvailableTimer.setSingleShot(True)
        self.copyAvailableTimer.setInterval(0)
        self.copyAvailableTimer.timeout.connect(self.copyActModifier)

        self.copyAvailable.connect(self.copyAvailableTimer.start)

        self.textChangedTimer = QtCore.QTimer()
        self.textChangedTimer.setSingleShot(True)
        self.textChangedTimer.setInterval(0)
        self.textChangedTimer.timeout.connect(self.undoActModifier)
        self.textChangedTimer.timeout.connect(self.redoActModifier)

        self.textChanged.connect(self.textChangedTimer.start)
        self.linesChanged.connect(self.updateLineCount)
        self.marginClicked.connect(self.toggleBookmark)

        self.lexer = self.colorScheme.styleEditor(self)
        self.setStyleSheet(StyleSheet.editorStyle)

        self.setKeymap()

    def updateLexer(self, lexer):
        self.lexer = lexer
        self.setLexer(lexer)

    def createContextMenu(self):
        self.cutAct = QtGui.QAction(
            "Cut", self, shortcut=QtGui.QKeySequence.Cut,
            statusTip="Cut selected text", triggered=self.cut)

        self.copyAct = QtGui.QAction(
            "Copy", self, shortcut=QtGui.QKeySequence.Copy,
            statusTip="Copy selected text", triggered=self.copy)

        self.pasteAct = QtGui.QAction(
            "Paste", self, shortcut=QtGui.QKeySequence.Paste,
            statusTip="Paste text from clipboard",
            triggered=self.paste)

        self.deleteAct = QtGui.QAction(
            "Delete", self, shortcut=QtGui.QKeySequence.Delete,
            statusTip="Delete Selection",
            triggered=self.removeSelectedText)

        self.selectAllAct = QtGui.QAction("Select All", self,
                                          shortcut=QtGui.QKeySequence.SelectAll,
                                          statusTip="Select All",
                                          triggered=self.selectAllText)

        self.selectToMatchingBraceAct = \
            QtGui.QAction(
                QtGui.QIcon(
                    os.path.join("Resources", "images", "text_select")),
                "Select to Matching Brace", self,
                statusTip="Select to Matching Brace",
                          triggered=self.selectToMatchingBrace)

        self.zoomAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "zoom")),
            "Zoom", self,
            statusTip="Zoom", triggered=self.showZoomWidget)

        self.contextMenu = QtGui.QMenu()
        self.contextMenu.addAction(self.cutAct)
        self.contextMenu.addAction(self.copyAct)
        self.contextMenu.addAction(self.pasteAct)
        self.contextMenu.addAction(self.deleteAct)
        self.contextMenu.addAction(self.selectAllAct)
        self.contextMenu.addAction(self.selectToMatchingBraceAct)
        self.contextMenu.addSeparator()
        self.viewMenu = self.contextMenu.addMenu("View")
        self.viewMenu.addAction(self.editorTabWidget.vSplitEditorAct)
        self.viewMenu.addAction(self.editorTabWidget.hSplitEditorAct)
        self.viewMenu.addAction(self.editorTabWidget.noSplitEditorAct)
        self.viewMenu.addSeparator()
        self.viewMenu.addAction(self.zoomAct)

    def setAutoCompletion(self):
        if self.useData.SETTINGS["EnableAutoCompletion"] == "True":
            self.setAutoCompletionSource(QsciScintilla.AcsDocument)
        else:
            self.setAutoCompletionSource(QsciScintilla.AcsNone)

    def contextMenuEvent(self, event):
        state = self.hasSelectedText()

        self.copyAct.setEnabled(state)
        self.cutAct.setEnabled(state)
        self.deleteAct.setEnabled(state)

        self.contextMenu.exec_(event.globalPos())

    def undoActModifier(self):
        state = self.isUndoAvailable()
        self.editorTabWidget.undoAct.setEnabled(state)

    def redoActModifier(self):
        state = self.isRedoAvailable()
        self.editorTabWidget.redoAct.setEnabled(state)

    def copyActModifier(self):
        state = self.hasSelectedText()
        self.editorTabWidget.copyAct.setEnabled(state)
        self.editorTabWidget.cutAct.setEnabled(state)

    def updateLineCount(self):
        lines = self.lines()
        self.editorTabWidget.updateLinesCount.emit(lines)

    def selectAllText(self):
        self.selectAll()

    def showZoomWidget(self):
        self.zoomWidget.show()

    def showLine(self, lineNum, highlight=True):
        if highlight:
            self.setSelection(
                lineNum, 0, lineNum, self.lineLength(lineNum) - 1)
        self.ensureLineVisible(lineNum)

    def showWhiteSpaces(self):
        if self.useData.SETTINGS["ShowWhiteSpaces"] == 'True':
            self.setWhitespaceVisibility(QsciScintilla.WsVisible)
        else:
            self.setWhitespaceVisibility(QsciScintilla.WsInvisible)

    def findMarkerDown(self):
        lineNum = self.markerFindNext(self.getCursorPosition()[0] + 1, 256)
        if lineNum == -1:
            lineNum = self.markerFindNext(0, 256)
        self.setSelection(lineNum, 0, lineNum, self.lineLength(lineNum) - 1)
        self.ensureLineVisible(lineNum)

    def findMarkerUp(self):
        lineNum = self.markerFindPrevious(self.getCursorPosition()[0] - 1, 256)
        if lineNum == -1:
            lineNum = self.markerFindPrevious(self.lines(), 256)
        self.setSelection(lineNum, 0, lineNum, self.lineLength(lineNum) - 1)
        self.ensureLineVisible(lineNum)

    def removeMarkers(self):
        self.markerDeleteAll(8)

    def findNextBookmark(self):
        cursorLine = self.getCursorPosition()[0]
        lineNum = self.markerFindNext(cursorLine + 1, 256)
        if lineNum == -1:
            lineNum = self.markerFindNext(0, 256)
            if lineNum == -1:
                return
        self.showLine(lineNum)

    def findPreviousBookmark(self):
        cursorLine = self.getCursorPosition()[0]
        lineNum = self.markerFindPrevious(cursorLine - 1, 256)
        if lineNum == -1:
            lineNum = self.markerFindPrevious(self.lines(), 256)
            if lineNum == -1:
                return
        self.showLine(lineNum)

    def toggleBookmark(self, nmargin, nline, modifiers=None):
        if self.markersAtLine(nline) == 0:
            handle = self.markerAdd(nline, 8)
            self.DATA["bookmarkList"].append(handle)
        else:
            for handle in self.DATA["bookmarkList"]:
                if self.markerLine(handle) == nline:
                    self.DATA["bookmarkList"].remove(handle)
                    self.markerDeleteHandle(handle)

        markersExist = self.bookmarksExist()
        self.editorTabWidget.enableBookmarkButtons(markersExist)

    def bookmarksExist(self):
        markersExist = (len(self.DATA["bookmarkList"]) > 0)
        return markersExist

    def getBookmarks(self):
        bookmarkLines = []
        for handle in self.DATA["bookmarkList"]:
            line = self.markerLine(handle)
            bookmarkLines.append(line)

        return bookmarkLines

    def removeBookmarks(self):
        if len(self.DATA["bookmarkList"]) > 0:
            self.DATA["bookmarkList"] = []
            self.markerDeleteAll(8)

    def setKeymap(self):
        self.updateKeymap(self.useData)

        shortcuts = self.useData.CUSTOM_SHORTCUTS

        self.cutAct.setShortcut(shortcuts["Editor"]["Cut-Selection"][0])
        self.copyAct.setShortcut(shortcuts["Editor"]["Copy-Selection"][0])
        self.pasteAct.setShortcut(shortcuts["Editor"]["Paste"][0])

        self.shortNextBookmark = QtGui.QShortcut(
            shortcuts["Ide"]["Next-Bookmark"], self)
        self.shortNextBookmark.activated.connect(self.findNextBookmark)

        self.shortPreviousBookmark = QtGui.QShortcut(
            shortcuts["Ide"]["Previous-Bookmark"], self)
        self.shortPreviousBookmark.activated.connect(self.findPreviousBookmark)

        self.shortZoomIn = QtGui.QShortcut(
            shortcuts["Editor"]["Zoom-In"][0], self)
        self.shortZoomIn.activated.connect(self.zoomWidget.zoomIn)

        self.shortZoomOut = QtGui.QShortcut(
            shortcuts["Editor"]["Zoom-Out"][0], self)
        self.shortZoomOut.activated.connect(self.zoomWidget.zoomOut)

########NEW FILE########
__FILENAME__ = TextSnapshot
import os

from PyQt4 import QtGui

from Extensions.BaseScintilla import BaseScintilla
from Extensions import Global
from Extensions import StyleSheet


class TextSnapshot(BaseScintilla):

    def __init__(self, useData, colorScheme, fileType, parent=None):
        BaseScintilla.__init__(self, parent)

        self.setFont(Global.getDefaultFont())
        self.setMarginLineNumbers(0, True)
        self.createContextMenu()

        self.DATA = {"fileType": fileType}
        self.setObjectName("editor")
        self.enableMarkOccurrence(useData)

        self.colorScheme = colorScheme
        self.colorScheme.styleEditor(self)

    def updateLexer(self, lexer):
        self.setLexer(lexer)

    def createContextMenu(self):
        self.copyAct = QtGui.QAction(
            "Copy", self, shortcut=QtGui.QKeySequence.Copy,
            statusTip="Copy selected text", triggered=self.copy)

        self.selectAllAct = QtGui.QAction("Select All", self,
                                          shortcut=QtGui.QKeySequence.SelectAll,
                                          statusTip="Select All",
                                          triggered=self.selectAllText)

        self.selectToMatchingBraceAct = \
            QtGui.QAction(QtGui.QIcon(os.path.join("Resources", "images", "text_select")),
                          "Select to Matching Brace", self,
                          statusTip="Select to Matching Brace",
                          triggered=self.selectToMatchingBrace)

        self.contextMenu = QtGui.QMenu()
        self.contextMenu.addAction(self.copyAct)
        self.contextMenu.addAction(self.selectAllAct)
        self.contextMenu.addAction(self.selectToMatchingBraceAct)

    def contextMenuEvent(self, event):
        state = self.hasSelectedText()

        self.copyAct.setEnabled(state)
        self.contextMenu.exec_(event.globalPos())

    def selectAllText(self):
        self.selectAll()

########NEW FILE########
__FILENAME__ = UseData
import os
import sys
import re
import codecs
import traceback
import logging

from PyQt4 import QtCore, QtXml
from PyQt4.Qsci import QsciScintilla

from Extensions.Workspace import WorkSpace


def textEncoding(bb):
    """ Get the encoding used to encode a file.
    Accepts the bytes of the file. Returns the codec name. If the
    codec could not be determined, uses UTF-8.
    """

    # Get first two lines
    parts = bb.split(b'\n', 2)

    # Init to default encoding
    encoding = 'UTF-8'

    # Determine encoding from first two lines
    for i in range(len(parts) - 1):

        # Get line
        try:
            line = parts[i].decode('ASCII')
        except Exception:
            continue

        # Search for encoding directive

        # Has comment?
        if line and line[0] == '#':

            # Matches regular expression given in PEP 0263?
            expression = "coding[:=]\s*([-\w.]+)"
            result = re.search(expression, line)
            if result:

                # Is it a known encoding? Correct name if it is
                candidate_encoding = result.group(1)
                try:
                    c = codecs.lookup(candidate_encoding)
                    candidate_encoding = c.name
                except Exception:
                    pass
                else:
                    encoding = candidate_encoding

    # Done
    return encoding


def lineEnding(text):
    c_win = text.count("\r\n")
    c_mac = text.count("\r") - c_win
    c_lin = text.count("\n") - c_win

    if c_win > c_mac and c_win > c_lin:
        mode = QsciScintilla.EolWindows
    elif c_mac > c_win and c_mac > c_lin:
        mode = QsciScintilla.EolMac
    else:
        mode = QsciScintilla.EolUnix

    return mode


class FindInstalledPython(QtCore.QObject):

    def __init__(self, parent=None):
        super().__init__(parent)

    # Find all python executables

    def python_executables(self):
        try:
            if sys.platform.startswith('win'):
                return self.windows()
            else:
                return self.posix()
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                         exc_traceback)))

            return []

    def windows(self):

        import winreg

        # Open base key
        base = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)
        try:
            key = winreg.OpenKey(
                base, 'SOFTWARE\\Python\\PythonCore', 0, winreg.KEY_READ)
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                         exc_traceback)))

            return []

        # Get info about subkeys
        nsub, nval, modified = winreg.QueryInfoKey(key)

        # Query Python versions from registry
        versionList = []
        for i in range(nsub):
            try:
                # Get name and subkey
                name = winreg.EnumKey(key, i)
                subkey = winreg.OpenKey(
                    key, name + '\\InstallPath', 0, winreg.KEY_READ)
                # Get install location and store
                location = winreg.QueryValue(subkey, '')
                versionList.append(os.path.normpath(location))
                # Close
                winreg.CloseKey(subkey)
            except:
                exc_type, exc_value, exc_traceback = sys.exc_info()
                logging.error(
                    repr(traceback.format_exception(exc_type, exc_value,
                             exc_traceback)))

        # Close keys
        winreg.CloseKey(key)
        winreg.CloseKey(base)

        # Query Python versions from file system
        for rootname in ['C:/', 'C:/Program Files', 'C:/Program Files (x86)']:
            if not os.path.isdir(rootname):
                continue
            for dir_item in os.listdir(rootname):
                if dir_item.lower().startswith('python'):
                    path = os.path.normpath(os.path.join(rootname, dir_item))
                    if path not in versionList:
                        versionList.append(path)

        # Append "python.exe" and check if that file exists
        versions3 = []

        for path in versionList:
            exe_name = os.path.join(path, 'python.exe')
            if os.path.isfile(exe_name):
                versions3.append(exe_name)

        return versions3

    def posix(self):
        found = []
        for searchpath in ['/usr/bin', '/usr/local/bin', '/opt/local/bin']:
            # Get files
            try:
                files = os.listdir(searchpath)
            except:
                continue

            # Search for python executables
            for fname in files:
                if fname.startswith('python') and not fname.count('config'):
                    found.append(os.path.join(searchpath, fname))
        # Done
        return found


class UseData(QtCore.QObject):

    def __init__(self, parent=None):
        super().__init__(parent)

        # usedata lists
        self.SETTINGS = {}
        self.OPENED_PROJECTS = []
        self.supportedFileTypes = ["python", ".xml", ".css", ".html"]

        # default shortcuts
        self.DEFAULT_SHORTCUTS = {
            'Ide': {
                "Go-to-Line": "Alt+G",
                "New-File": "Ctrl+N",
                "Open-File": "Ctrl+O",
                "Save-File": "Ctrl+S",
                "Save-All": "Ctrl+Shift+S",
                "Print": "Ctrl+P",
                "Run-File": "F4",
                "Run-Project": "F5",
                "Build": "Ctrl+Shift+B",
                "Stop-Execution": "F6",
                "Fullscreen": "F8",
                "Find": "Ctrl+F",
                "Replace": "Ctrl+H",
                "Find-Next": "Ctrl+G",
                "Find-Previous": "Shift+F3",
                "Help": "F2",
                "Python-Manuals": "F1",
                "Split-Horizontal": "F10",
                "Split-Vertical": "F9",
                "Remove-Split": "F11",
                "Reload-File": "F7",
                "Change-Tab": "F12",
                "Change-Tab-Reverse": "Ctrl+Tab",
                "Change-Split-Focus": "Ctrl+M",
                "Fold-Code": "",
                "Snippets": "Ctrl+K",
                "Toggle-Indentation-Guide": "Alt+I",
                "Toggle-Breakpoint": "Alt+B",
                "Select-to-Matching-Brace": "",
                "Next-Bookmark": "",
                "Previous-Bookmark": "",
                "Comment": "Ctrl+E",
                "Uncomment": "Alt+E",
                "Show-Completion": "Ctrl+Space",
                },
            'Editor': {'Move-To-End-Of-Document': ['Ctrl+End', 2318],
                       'Zoom-Out': ['Ctrl+-', 2334],
                       'Extend-Rectangular-Selection-Left-One-Character': ['Alt+Shift+Left', 2428],
                       'Move-Down-One-Paragraph': ['Ctrl+]', 2413],
                       'Move-To-Start-Of-Document': ['Ctrl+Home', 2316],
                       'Extend-Selection-To-Start-Of-Display-Line': ['', 2346],
                       'De-indent-One-Level': ['Shift+Tab', 2328],
                       'Delete-Right-To-End-Of-Next-Word': ['', 2518],
                       'Extend-Selection-Down-One-Line': ['Shift+Down', 2301],
                       'Scroll-Vertically-To-Centre-Current-Line': ['', 2619],
                       'Toggle-Insert-or-Overtype': ['Ins', 2324],
                       'Extend-Rectangular-Selection-Up-One-Line': ['Alt+Shift+Up', 2427],
                       'Extend-Rectangular-Selection-Down-One-Line': ['Alt+Shift+Down', 2426],
                       'Extend-Selection-Left-One-Character': ['Shift+Left', 2305],
                       'Select-All': ['Ctrl+A', 2013],
                       'Convert-Selection-To-Upper-Case': ['Ctrl+Shift+U', 2341],
                       'Insert-Newline': ['Return', 2329],
                       'Move-Right-One-Word-Part': ['Ctrl+\\', 2392],
                       'Move-To-First-Visible-Character-In-Document-Line': ['Home', 2331],
                       'Extend-Rectangular-Selection-To-First-Visible-Character-In-Document-Line': ['Alt+Shift+Home', 2431],
                       'Extend-Selection-Down-One-Page': ['Shift+PgDown', 2323],
                       'Move-Selected-Lines-Down-One-Line': ['', 2621],
                       'Move-Right-One-Word': ['Ctrl+Right', 2310],
                       'Move-Up-One-Page': ['PgUp', 2320],
                       'Extend-Rectangular-Selection-To-Start-Of-Document-Line': ['', 2430],
                       'Extend-Selection-Left-One-Word': ['Ctrl+Shift+Left', 2309],
                       'Scroll-View-Down-One-Line': ['Ctrl+Down', 2342],
                       'Extend-Selection-Left-One-Word-Part': ['Ctrl+Shift+/', 2391],
                       'Duplicate-Selection': ['Ctrl+D', 2469],
                       'Cut-Selection': ['Ctrl+X', 2177],
                       'Extend-Selection-Down-One-Paragraph': ['Ctrl+Shift+]', 2414],
                       'Extend-Selection-To-End-Of-Previous-Word': ['', 2440],
                       'Extend-Selection-To-Start-Of-Document-Line': ['', 2313],
                       'Move-Selected-Lines-Up-One-Line': ['', 2620],
                       'Stuttered-Move-Up-One-Page': ['', 2435],
                       'Extend-Selection-Right-One-Character': ['Shift+Right', 2307],
                       'Cancel': ['Esc', 2325],
                       'Scroll-View-Up-One-Line': ['Ctrl+Up', 2343],
                       'Cut-Current-Line': ['Ctrl+L', 2337],
                       'Stuttered-Extend-Selection-Down-One-Page': ['', 2438],
                       'Extend-Selection-To-End-Of-Display-Or-Document-Line': ['', 2452],
                       'Move-Up-One-Paragraph': ['Ctrl+[', 2415],
                       'Move-Left-One-Word': ['Ctrl+Left', 2308],
                       'Formfeed': ['', 2330],
                       'Undo-Last-Command': ['Ctrl+Z', 2176],
                       'Delete-Line-To-Left': ['Ctrl+Shift+Backspace', 2395],
                       'Delete-Word-To-Left': ['Ctrl+Backspace', 2335],
                       'Extend-Rectangular-Selection-To-End-Of-Document-Line': ['Alt+Shift+End', 2432],
                       'Move-To-End-Of-Display-Or-Document-Line': ['', 2451],
                       'Delete-Current-Character': ['Del', 2180],
                       'Stuttered-Move-Down-One-Page': ['', 2437],
                       'Move-Right-One-Character': ['Right', 2306],
                       'Move-To-End-Of-Previous-Word': ['', 2439],
                       'Extend-Selection-To-First-Visible-Character-In-Document-Line': ['Shift+Home', 2332],
                       'Move-Down-One-Line': ['Down', 2300],
                       'Scroll-To-Start-Of-Document': ['', 2628],
                       'Extend-Selection-To-Start-Of-Display-Or-Document-Line': ['', 2450],
                       'Move-Down-One-Page': ['PgDown', 2322],
                       'Move-To-End-Of-Document-Line': ['End', 2314],
                       'Delete-Word-To-Right': ['Ctrl+Del', 2336],
                       'Convert-Selection-To-Lower-Case': ['Ctrl+U', 2340],
                       'Extend-Selection-Up-One-Paragraph': ['Ctrl+Shift+[', 2416],
                       'Move-Up-One-Line': ['Up', 2302],
                       'Extend-Selection-To-Start-Of-Document': ['Ctrl+Shift+Home', 2317],
                       'Delete-Current-Line': ['Ctrl+Shift+L', 2338],
                       'Paste': ['Ctrl+V', 2179],
                       'Extend-Selection-Right-One-Word-Part': ['Ctrl+Shift+\\', 2393],
                       'Extend-Selection-To-First-Visible-Character-In-Display-Or-Document-Line': ['', 2454],
                       'Extend-Selection-To-End-Of-Next-Word': ['', 2442],
                       'Move-Left-One-Character': ['Left', 2304],
                       'Redo-Last-Command': ['Ctrl+Y', 2011],
                       'Move-Left-One-Word-Part': ['Ctrl+/', 2390],
                       'Stuttered-Extend-Selection-Up-One-Page': ['', 2436],
                       'Delete-Line-To-Right': ['Ctrl+Shift+Del', 2396],
                       'Extend-Rectangular-Selection-Right-One-Character': ['Alt+Shift+Right', 2429],
                       'Transpose-Current-And-Previous-Lines': ['Ctrl+T', 2339],
                       'Indent-One-Level': ['Tab', 2327],
                       'Extend-Selection-Right-One-Word': ['Ctrl+Shift+Right', 2311],
                       'Copy-Selection': ['Ctrl+C', 2178],
                       'Extend-Selection-To-End-Of-Display-Line': ['', 2315],
                       'Extend-Selection-To-End-Of-Document-Line': ['Shift+End', 2315],
                       'Extend-Rectangular-Selection-Up-One-Page': ['Alt+Shift+PgUp', 2433],
                       'Extend-Rectangular-Selection-Down-One-Page': ['Alt+Shift+PgDown', 2434],
                       'Move-To-Start-Of-Document-Line': ['', 2312],
                       'Delete-Previous-Character': ['Backspace', 2326],
                       'Delete-Previous-Character-If-Not-At-Start-Of-Line': ['', 2344],
                       'Zoom-In': ['Ctrl++', 2333],
                       'Move-To-Start-Of-Display-Or-Document-Line': ['', 2349],
                       'Move-To-First-Visible-Character-Of-Display-In-Document-Line': ['', 2453],
                       'Extend-Selection-Up-One-Line': ['Shift+Up', 2303],
                       'Copy-Current-Line': ['Ctrl+Shift+T', 2455],
                       'Move-To-Start-Of-Display-Line': ['Alt+Home', 2345],
                       'Move-To-End-Of-Next-Word': ['', 2441],
                       'Duplicate-The-Current-Line': ['', 2404],
                       'Move-To-End-Of-Display-Line': ['Alt+End', 2347],
                       'Extend-Selection-To-End-Of-Document': ['Ctrl+Shift+End', 2319],
                       'Extend-Selection-Up-One-Page': ['Shift+PgUp', 2321],
                       'Scroll-To-End-Of-Document': ['', 2629]}
            }

        self.CUSTOM_SHORTCUTS = {'Ide': {}, 'Editor': {}}

        # load configuration from file
        tempList = []
        file = open("settings.ini", "r")
        for i in file.readlines():
            if i.strip() == '':
                pass
            else:
                tempList.append(tuple(i.strip().split('=')))
        file.close()
        self.settings = dict(tempList)

        self.loadAppData()
        self.loadUseData()

        self.SETTINGS["InstalledInterpreters"] = self.getPythonExecutables()

    def loadAppData(self):
        self.workspaceDir = self.settings["workspace"]
        if not os.path.exists(self.workspaceDir):
            newWorkspace = WorkSpace()
            if newWorkspace.created:
                self.workspaceDir = newWorkspace.path
                self.settings["workspace"] = self.workspaceDir
            else:
                sys.exit()
        self.appPathDict = {
            "logfile": os.path.join(self.workspaceDir, "LOG.txt"),
            "snippetsdir": os.path.join(self.workspaceDir, "Snippets"),
            "librarydir": os.path.join(self.workspaceDir, "Library"),
            "projectsdir": os.path.join(self.workspaceDir, "Projects"),
            "settingsdir": os.path.join(self.workspaceDir, "Settings"),
            "stylesdir": os.path.join(self.workspaceDir, "Settings", "ColorSchemes"),
            "usedata": os.path.join(self.workspaceDir, "Settings", "usedata.xml"),
            "modules": os.path.join(self.workspaceDir, "Settings", "modules.xml"),
            "keymap": os.path.join(self.workspaceDir, "Settings", "keymap.xml")
            }

    def loadUseData(self):
        dom_document = QtXml.QDomDocument()
        try:
            file = open(self.appPathDict["usedata"], "r")
            dom_document.setContent(file.read())
            file.close()
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                         exc_traceback)))
            return

        elements = dom_document.documentElement()
        node = elements.firstChild()

        settingsList = []
        while node.isNull() is False:
            property = node.toElement()
            sub_node = property.firstChild()
            while sub_node.isNull() is False:
                sub_prop = sub_node.toElement()
                if node.nodeName() == "openedprojects":
                    path = sub_prop.text()
                    if os.path.exists(path):
                        self.OPENED_PROJECTS.append(path)
                elif node.nodeName() == "settings":
                    settingsList.append((tuple(sub_prop.text().split('=', 1))))
                sub_node = sub_node.nextSibling()
            node = node.nextSibling()

        self.SETTINGS.update(dict(settingsList))
        # for compatibility with older versions of Pcode
        settingsKeys = self.SETTINGS.keys()
        if "MarkOperationalLines" not in settingsKeys:
            self.SETTINGS["MarkOperationalLines"] = "False"

        if "UI" not in settingsKeys:
            self.SETTINGS["UI"] = "Custom"

        self.loadKeymap()
        self.loadModulesForCompletion()

    def saveModulesForCompletion(self):
        dom_document = QtXml.QDomDocument("modules")

        modules = dom_document.createElement("modules")
        dom_document.appendChild(modules)

        for i, v in self.libraryDict.items():
            tag = dom_document.createElement(i)
            modules.appendChild(tag)
            tag.setAttribute("use", str(v[1]))

            for subModule in v[0]:
                item = dom_document.createElement("item")
                tag.appendChild(item)

                t = dom_document.createTextNode(subModule)
                item.appendChild(t)

        try:
            file = open(self.appPathDict["modules"], "w")
            file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            file.write(dom_document.toString())
            file.close()
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                         exc_traceback)))

    def loadModulesForCompletion(self):
        dom_document = QtXml.QDomDocument()
        try:
            file = open(self.appPathDict["modules"], "r")
            dom_document.setContent(file.read())
            file.close()
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                         exc_traceback)))
            return

        element = dom_document.documentElement()
        node = element.firstChild()

        self.libraryDict = {}
        while node.isNull() is False:
            property = node.toElement()
            sub_node = property.firstChild()

            moduleName = node.nodeName()
            use = property.attribute('use')

            itemList = []
            while sub_node.isNull() is False:
                sub_prop = sub_node.toElement()
                itemList.append(sub_prop.text())

                sub_node = sub_node.nextSibling()
            self.libraryDict[moduleName] = [itemList, use]
            node = node.nextSibling()

    def saveUseData(self):
        dom_document = QtXml.QDomDocument("usedata")

        usedata = dom_document.createElement("usedata")
        dom_document.appendChild(usedata)

        root = dom_document.createElement("openedprojects")
        usedata.appendChild(root)

        for i in self.OPENED_PROJECTS:
            tag = dom_document.createElement("project")
            root.appendChild(tag)

            t = dom_document.createTextNode(i)
            tag.appendChild(t)

        root = dom_document.createElement("settings")
        usedata.appendChild(root)

        s = 0
        for key, value in self.SETTINGS.items():
            if key == "InstalledInterpreters":
                continue
            tag = dom_document.createElement("key")
            root.appendChild(tag)

            t = dom_document.createTextNode(key + '=' + value)
            tag.appendChild(t)
            s += 1

        usedata = dom_document.createElement("usedata")
        dom_document.appendChild(usedata)

        try:    
            file = open(self.appPathDict["usedata"], "w")
            file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            file.write(dom_document.toString())
            file.close()
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                         exc_traceback)))
            return

        self.settings["running"] = 'False'
        self.saveSettings()
        self.saveModulesForCompletion()

    def loadKeymap(self):
        if self.settings["firstRun"] == "True":
            self.CUSTOM_SHORTCUTS = self.DEFAULT_SHORTCUTS
            return
        dom_document = QtXml.QDomDocument()
        try:
            file = open(self.appPathDict["keymap"], "r")
            x = dom_document.setContent(file.read())
            file.close()
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            logging.error(repr(traceback.format_exception(exc_type, exc_value,
                         exc_traceback)))
            return

        elements = dom_document.documentElement()
        node = elements.firstChild()
        while node.isNull() is False:
            property = node.toElement()
            sub_node = property.firstChild()
            group = node.nodeName()
            while sub_node.isNull() is False:
                sub_prop = sub_node.toElement()
                tag = sub_prop.toElement()
                name = tag.tagName()
                shortcut = tag.attribute("shortcut")
                if group == "Editor":
                    keyValue = int(tag.attribute("value"))
                    self.CUSTOM_SHORTCUTS[
                        group][name] = [shortcut, keyValue]
                else:
                    self.CUSTOM_SHORTCUTS[
                        group][name] = shortcut

                sub_node = sub_node.nextSibling()

            node = node.nextSibling()

    def getLastOpenedDir(self):
        if os.path.exists(self.SETTINGS["LastOpenedPath"]):
            pass
        else:
            self.SETTINGS["LastOpenedPath"] = QtCore.QDir().homePath()
        return self.SETTINGS["LastOpenedPath"]

    def saveLastOpenedDir(self, path):
        if self.SETTINGS["LastOpenedPath"] == path:
            pass
        else:
            self.SETTINGS["LastOpenedPath"] = path

    def saveSettings(self):
        file = open("settings.ini", "w")
        for key, value in self.settings.items():
            file.write('\n' + key + '=' + value)
        file.close()

    def readFile(self, fileName):
        file = open(fileName, 'rb')
        bb = file.read()
        file.close()
        encoding = textEncoding(bb)

        file = open(fileName, 'r')
        text = file.read()
        file.close()

        ending = lineEnding(text)

        return text, encoding, ending

    def getPythonExecutables(self):
        pythonExecutables = FindInstalledPython()
        interpreters = pythonExecutables.python_executables()

        return interpreters

########NEW FILE########
__FILENAME__ = ViewSwitcher
import os
from PyQt4 import QtGui

from Extensions import StyleSheet


class ViewSwitcher(QtGui.QLabel):

    def __init__(self, parent=None):
        QtGui.QLabel.__init__(self, parent)

        self.setMinimumHeight(35)
        self.setMaximumHeight(35)
        self.setMinimumWidth(175)
        self.setMaximumWidth(175)

        self.lastIndex = 0

        self.mainLayout = QtGui.QHBoxLayout()
        self.mainLayout.setMargin(0)
        self.mainLayout.setSpacing(0)
        self.setLayout(self.mainLayout)

        self.editorTabWidget = parent
        self.editorTabWidget.currentChanged.connect(self.setCurrentView)

        self.buttonGroup = QtGui.QButtonGroup()
        self.buttonGroup.setExclusive(True)
        self.buttonGroup.buttonPressed.connect(self.viewChanged)

        self.hideButton = QtGui.QToolButton()
        self.hideButton.setAutoRaise(True)
        self.hideButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "exit")))
        self.hideButton.clicked.connect(self.hide)
        self.mainLayout.addWidget(self.hideButton)

        self.setStyleSheet(StyleSheet.viewSwitcherStyle)

        self.addButton(QtGui.QIcon(
            os.path.join("Resources", "images", "notes_selected")), "Editor")
        self.addButton(QtGui.QIcon(
            os.path.join("Resources", "images", "notes")), "Snapshot")
        self.addButton(QtGui.QIcon(
            os.path.join("Resources", "images", "links_selected")), "Unified Diff")
        self.addButton(QtGui.QIcon(
            os.path.join("Resources", "images", "links")), "Context Diff")

    def setCurrentView(self):
        index = self.editorTabWidget.currentWidget().currentIndex()
        self.setIndex(None, index)

    def viewChanged(self, button):
        index = self.buttonGroup.id(button)
        self.setIndex(button, index)

        if index == 2:
            self.editorTabWidget.getUnifiedDiff().generateUnifiedDiff()
        elif index == 3:
            self.editorTabWidget.getContextDiff().generateContextDiff()

    def addButton(self, icon, toolTip):
        button = QtGui.QToolButton()
        button.setToolTip(toolTip)
        button.setCheckable(True)
        button.setIcon(icon)
        self.buttonGroup.addButton(button)
        self.buttonGroup.setId(button, self.lastIndex)
        self.mainLayout.addWidget(button)

        self.lastIndex += 1

    def setIndex(self, button, index=None):
        button = self.buttonGroup.button(index)
        button.setChecked(True)
        subStack = self.editorTabWidget.currentWidget()
        subStack.setCurrentIndex(index)

    def setDefault(self):
        """
        Shows the active button after initialization
        """
        button = self.buttonGroup.button(0)
        button.setChecked(True)
        self.changed.emit(button.text())

########NEW FILE########
__FILENAME__ = Workspace
import sys
import os
import zipfile
from PyQt4 import QtCore, QtGui


class CreateWorkSpaceThread(QtCore.QThread):

    def run(self):
        self.errors = None
        try:
            zip = zipfile.ZipFile(
                os.path.join("Resources", "PcodeProjects.zip"), 'r')
            zip.extractall(self.path)
        except Exception as err:
            self.errors = str(err)

    def createWorkspace(self, path):
        self.path = path

        self.start()


class GetPathLine(QtGui.QWidget):

    textChanged = QtCore.pyqtSignal(str)

    def __init__(self, parent=None):
        QtGui.QWidget.__init__(self, parent)

        mainLayout = QtGui.QHBoxLayout()
        mainLayout.setMargin(0)
        self.setLayout(mainLayout)

        self.destinationLine = QtGui.QLineEdit()
        self.destinationLine.textChanged.connect(self.textChanged.emit)
        mainLayout.addWidget(self.destinationLine)

        homePath = QtCore.QDir().homePath()

        # Todo: Workspace must unpack to the platform specific home
        # directory by default
        if sys.platform == 'win32':
            path = os.path.join(homePath,
                                "My Documents", "PcodeProjects")
        elif sys.platform == 'darwin':
            path = os.path.join(homePath,
                                "Documents", "PcodeProjects")
        else:
            path = os.path.join(homePath,
                                "My Documents", "PcodeProjects")
        path = os.path.normpath(path)
        self.destinationLine.setText(path)

        self.browseButton = QtGui.QPushButton('...')
        self.browseButton.clicked.connect(self.browsePath)
        mainLayout.addWidget(self.browseButton)

    def browsePath(self):
        homePath = QtCore.QDir().homePath()
        directory = QtGui.QFileDialog.getExistingDirectory(
            self, "Select Folder",
            homePath)
        if directory:
            self.destinationLine.setText(os.path.normpath(directory))

    def text(self):
        return self.destinationLine.text()


class WorkSpace(QtGui.QDialog):

    def __init__(self, parent=None):
        QtGui.QDialog.__init__(self, parent,
                               QtCore.Qt.Window | QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle("Workspace")
        self.setWindowIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "Icon")))
        self.setFixedSize(500, 130)

        self.createWorkSpaceThread = CreateWorkSpaceThread()
        self.createWorkSpaceThread.finished.connect(self.completeWorkspace)

        mainLayout = QtGui.QVBoxLayout()
        self.setLayout(mainLayout)

        mainLayout.addWidget(
            QtGui.QLabel("Choose the location of your Workspace:"))

        self.choiceBox = QtGui.QComboBox()
        self.choiceBox.addItem("Choose an existing one")
        self.choiceBox.addItem("Create new")
        mainLayout.addWidget(self.choiceBox)

        self.getPathLine = GetPathLine()
        mainLayout.addWidget(self.getPathLine)

        mainLayout.addStretch(1)

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        self.statusLabel = QtGui.QLabel()
        hbox.addWidget(self.statusLabel)

        hbox.addStretch(1)

        self.okButton = QtGui.QPushButton("Done")
        self.okButton.clicked.connect(self.accept)
        hbox.addWidget(self.okButton)

        self.cancelButton = QtGui.QPushButton("Cancel")
        self.cancelButton.clicked.connect(self.cancel)
        hbox.addWidget(self.cancelButton)

        self.created = False

        self.exec_()

    def completeWorkspace(self):
        QtGui.QApplication.restoreOverrideCursor()
        if self.createWorkSpaceThread.errors is None:
            self.path = os.path.join(
                self.createWorkSpaceThread.path, "PcodeProjects")
            self.created = True
            self.close()
        else:
            self.statusLabel.clear()
            message = QtGui.QMessageBox.warning(
                self, "Workspace", "Error creating workspace:\n\n{0}".format(self.createWorkSpaceThread.errors))
            self.okButton.setDisabled(False)
            self.cancelButton.setDisabled(False)
            self.getPathLine.setDisabled(False)
            self.choiceBox.setDisabled(False)

    def accept(self):
        path = self.getPathLine.text()
        if os.path.exists(path):
            if self.choiceBox.currentIndex() == 0:
                if os.path.basename(path) == "PcodeProjects":
                    self.path = path
                    self.created = True
                    self.close()
                else:
                    message = QtGui.QMessageBox.warning(
                        self, "Workspace", "The workspace is not valid!")
                    return
            else:
                self.okButton.setDisabled(True)
                self.cancelButton.setDisabled(True)
                self.getPathLine.setDisabled(True)
                self.choiceBox.setDisabled(True)
                self.statusLabel.setText("Creating workspace...")
                QtGui.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)

                self.createWorkSpaceThread.createWorkspace(path)
        else:
            message = QtGui.QMessageBox.warning(
                self, "Workspace", "Path does not exist.")

    def cancel(self):
        self.created = False
        self.close()

########NEW FILE########
__FILENAME__ = WritePad
from PyQt4 import QtCore, QtGui


class WritePad(QtGui.QMainWindow):

    def __init__(self, path, name, parent=None):
        QtGui.QMainWindow.__init__(self, parent)

        self.setWindowTitle(name + " - Notes")
        self.resize(600, 300)
        screen = QtGui.QDesktopWidget().screenGeometry()
        size = self.geometry()
        self.move((screen.width() - size.width()) / 2,
                 (screen.height() - size.height()) / 2)

        self.path = path
        self.setObjectName("writePad")

        self.noteSaveTimer = QtCore.QTimer()
        self.noteSaveTimer.setSingleShot(True)
        self.noteSaveTimer.timeout.connect(self.saveNotes)

        self.writePad = QtGui.QPlainTextEdit()
        self.writePad.setLineWrapMode(QtGui.QPlainTextEdit.NoWrap)
        self.writePad.setFont(QtGui.QFont("Ms Reference Sans Serif", 10.9))
        self.setCentralWidget(self.writePad)

        # load notes
        try:
            file = open(self.path, "r")
            self.writePad.setPlainText(file.read())
            file.close()
        except:
            file = open(path, "w")
            file.close()

        self.writePad.textChanged.connect(self.startSaveTimer)
        
    def startSaveTimer(self):
        self.noteSaveTimer.start(1000)

    def saveNotes(self):
        file = open(self.path, "w")
        file.write(self.writePad.toPlainText())
        file.close()

########NEW FILE########
__FILENAME__ = ZoomWidget
import os
from PyQt4 import QtCore, QtGui


class ZoomWidget(QtGui.QLabel):

    def __init__(self, useData, editor, parent=None):
        QtGui.QLabel.__init__(self, parent=None)

        self.useData = useData
        self.editor = editor
        self.prevValue = 0

        self.setMinimumHeight(130)
        self.setMaximumHeight(130)
        self.setMinimumWidth(38)
        self.setMaximumWidth(38)

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setMargin(1)
        mainLayout.setSpacing(0)
        self.setLayout(mainLayout)

        self.increaseButton = QtGui.QToolButton()
        self.increaseButton.setMaximumWidth(36)
        self.increaseButton.setText('+')
        self.increaseButton.setMaximumHeight(36)
        self.increaseButton.clicked.connect(self.zoomIn)
        mainLayout.addWidget(self.increaseButton)

        self.zoomBox = QtGui.QSpinBox()
        self.zoomBox.setMinimum(0)
        self.zoomBox.setReadOnly(True)
        self.zoomBox.setAlignment(QtCore.Qt.AlignHCenter)
        self.zoomBox.setButtonSymbols(2)
        self.zoomBox.setMaximum(100)
        self.zoomBox.setSingleStep(10)
        self.zoomBox.setSuffix("%")
        self.zoomBox.valueChanged.connect(self.changePosition)
        mainLayout.addWidget(self.zoomBox)

        self.decreaseButton = QtGui.QToolButton()
        self.decreaseButton.setMaximumWidth(36)
        self.decreaseButton.setText('-')
        self.decreaseButton.setMaximumHeight(36)
        self.decreaseButton.clicked.connect(self.zoomOut)
        mainLayout.addWidget(self.decreaseButton)

        self.hideButton = QtGui.QToolButton()
        self.hideButton.setMaximumWidth(36)
        self.hideButton.setMaximumHeight(36)
        self.hideButton.setAutoRaise(True)
        self.hideButton.setIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "exit")))
        self.hideButton.clicked.connect(self.hide)
        mainLayout.addWidget(self.hideButton)

        self.hide()

        self.setStyleSheet("""
                        QLabel {
                            background: rgba(138, 201, 255, 200);
                            border-radius: 0px;
                        }

                         """)

    def changePosition(self, value):
        if self.prevValue > value:
            self.editor.zoomOut()
        elif self.prevValue < value:
            self.editor.zoomIn()
        else:
            self.editor.zoomOut()
        self.prevValue = value

    def zoomIn(self):
        self.zoomBox.setValue(self.zoomBox.value() + 10)

    def zoomOut(self):
        self.zoomBox.setValue(self.zoomBox.value() - 10)

########NEW FILE########
__FILENAME__ = Pcode
import sys
import os
import logging

from PyQt4 import QtCore, QtGui

from Extensions.UseData import UseData
from Extensions.Library.Library import Library
from Extensions.About import About
from Extensions.Settings.SettingsWidget import SettingsWidget
from Extensions.Projects.Projects import Projects
from Extensions.BusyWidget import BusyWidget
from Extensions import StyleSheet
from Extensions.Start import Start
from Extensions.StackSwitcher import StackSwitcher


class Pcode(QtGui.QWidget):

    def __init__(self, parent=None):
        QtGui.QWidget.__init__(self, parent)

        self.setWindowIcon(QtGui.QIcon(os.path.join("Resources", "images", "Icon")))
        self.setWindowTitle("Pcode - Loading...")

        screen = QtGui.QDesktopWidget().screenGeometry()
        self.resize(screen.width() - 200, screen.height() - 200)
        size = self.geometry()
        self.move((screen.width() - size.width()) / 2, (
            screen.height() - size.height()) / 2)
        self.lastWindowGeometry = self.geometry()

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setSpacing(0)
        mainLayout.setMargin(0)
        self.setLayout(mainLayout)

        self.useData = UseData()

        logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', 
                            filename=self.useData.appPathDict["logfile"], level=logging.DEBUG)
        if sys.version_info.major < 3:
            logging.error("This application requires Python 3")
            sys.exit(1)
        
        self.library = Library(self.useData)
        self.busyWidget = BusyWidget(app, self.useData, self)
        
        if self.useData.SETTINGS["UI"] == "Custom":
            app.setStyleSheet(StyleSheet.globalStyle)

        self.projectWindowStack = QtGui.QStackedWidget()

        self.projectTitleBox = QtGui.QComboBox()
        self.projectTitleBox.setMinimumWidth(180)
        self.projectTitleBox.setStyleSheet(StyleSheet.projectTitleBoxStyle)
        self.projectTitleBox.setItemDelegate(QtGui.QStyledItemDelegate())
        self.projectTitleBox.currentIndexChanged.connect(self.projectChanged)
        self.projectTitleBox.activated.connect(self.projectChanged)

        self.settingsWidget = SettingsWidget(self.useData, app,
                                             self.projectWindowStack, self.library.codeViewer, self)
        self.settingsWidget.colorScheme.styleEditor(self.library.codeViewer)

        startWindow = Start(self.useData, self)
        self.addProject(startWindow, "Start",
                        "Start", os.path.join("Resources", "images", "flag-green"))

        self.projects = Projects(self.useData, self.busyWidget,
                                 self.library, self.settingsWidget, app,
                                 self.projectWindowStack, self.projectTitleBox, self)

        self.createActions()

        hbox = QtGui.QHBoxLayout()
        hbox.setContentsMargins(5, 3, 5, 3)
        mainLayout.addLayout(hbox)

        hbox.addStretch(1)

        self.pagesStack = QtGui.QStackedWidget()
        mainLayout.addWidget(self.pagesStack)

        self.projectSwitcher = StackSwitcher(self.pagesStack)
        self.projectSwitcher.setStyleSheet(StyleSheet.mainMenuStyle)
        hbox.addWidget(self.projectSwitcher)

        self.addPage(self.projectWindowStack, "EDITOR", QtGui.QIcon(
            os.path.join("Resources", "images", "hire-me")))

        self.addPage(self.library, "LIBRARY", QtGui.QIcon(
            os.path.join("Resources", "images", "library")))
        self.projectSwitcher.setDefault()

        hbox.addWidget(self.projectTitleBox)
        hbox.setSpacing(5)

        self.settingsButton = QtGui.QToolButton()
        self.settingsButton.setAutoRaise(True)
        self.settingsButton.setDefaultAction(self.settingsAct)
        hbox.addWidget(self.settingsButton)

        self.fullScreenButton = QtGui.QToolButton()
        self.fullScreenButton.setAutoRaise(True)
        self.fullScreenButton.setDefaultAction(self.showFullScreenAct)
        hbox.addWidget(self.fullScreenButton)

        self.aboutButton = QtGui.QToolButton()
        self.aboutButton.setAutoRaise(True)
        self.aboutButton.setDefaultAction(self.aboutAct)
        hbox.addWidget(self.aboutButton)

        self.setShortcuts()

        if self.useData.settings["firstRun"] == 'True':
            self.showMaximized()
        else:
            self.restoreUiState()

        self.useData.settings["running"] = 'True'
        self.useData.settings["firstRun"] = 'False'
        self.useData.saveSettings()

    def createActions(self):
        self.aboutAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "properties")),
            "About Pcode", self, statusTip="About Pcode",
            triggered=self.showAbout)

        self.showFullScreenAct = \
            QtGui.QAction(QtGui.QIcon(os.path.join("Resources", "images", "fullscreen")),
                          "Fullscreen", self,
                          statusTip="Fullscreen",
                          triggered=self.showFullScreenMode)

        self.settingsAct = QtGui.QAction(
            QtGui.QIcon(os.path.join("Resources", "images", "config")),
            "Settings", self,
            statusTip="Settings", triggered=self.showSettings)

    def addPage(self, pageWidget, name, iconPath):
        self.projectSwitcher.addButton(name=name, icon=iconPath)
        self.pagesStack.addWidget(pageWidget)

    def loadProject(self, path, show=False, new=False):
        self.projects.loadProject(path, show, new)

    def newProject(self):
        self.projects.newProjectDialog.exec_()

    def showProject(self, path):
        if not os.path.exists(path):
            message = QtGui.QMessageBox.warning(
                self, "Open Project", "Project cannot be be found!")
        else:
            if path in self.useData.OPENED_PROJECTS:
                for i in range(self.projectWindowStack.count() - 1):
                    window = self.projectWindowStack.widget(i)
                    p_path = window.projectPathDict["root"]
                    if os.path.samefile(path, p_path):
                        self.projectTitleBox.setCurrentIndex(i)
                        return True
        return False

    def addProject(self, window, name, type='Project', iconPath=None):
        self.projectWindowStack.insertWidget(0, window)
        if type == 'Project':
            self.projectTitleBox.insertItem(0, QtGui.QIcon(
                os.path.join("Resources", "images", "project")), name, [window, type])
        else:
            self.projectTitleBox.insertItem(0, QtGui.QIcon(
                iconPath), name, [window, type])

    def projectChanged(self, index):
        data = self.projectTitleBox.itemData(index)
        window = data[0]
        windowType = data[1]
        if windowType == "Start":
            self.setWindowTitle("Pcode - Start")
        elif windowType == "Project":
            title = window.editorTabWidget.getEditorData("filePath")
            self.updateWindowTitle(title)
        self.projectWindowStack.setCurrentWidget(window)

    def removeProject(self, window):
        for index in range(self.projectTitleBox.count() - 1):
            data = self.projectTitleBox.itemData(index)
            windowWidget = data[0]
            if windowWidget == window:
                self.projectWindowStack.removeWidget(window)
                self.projectTitleBox.removeItem(index)

    def updateWindowTitle(self, title):
        if title is None:
            title = "Pcode - " + "Unsaved"
        else:
            window = self.projectTitleBox.itemData(
                self.projectTitleBox.currentIndex())[0]
            if title.startswith(window.projectPathDict["sourcedir"]):
                src_dir = window.projectPathDict["sourcedir"]
                n = title.partition(src_dir)[-1]
                title = 'Pcode - ' + n
            else:
                title = "Pcode - " + title
        self.setWindowTitle(title)

    def showAbout(self):
        aboutPane = About(self)
        aboutPane.exec_()

    def showSettings(self):
        self.settingsWidget.show()

    def showFullScreenMode(self):
        if self.isFullScreen():
            self.showNormal()
            self.setGeometry(self.lastWindowGeometry)
        else:
            # get current size ahd show Fullscreen
            # so we can later restore to proper position
            self.lastWindowGeometry = self.geometry()
            self.showFullScreen()

    def saveUiState(self):
        settings = QtCore.QSettings("Clean Code Inc.", "Pcode")
        settings.beginGroup("MainWindow")
        settings.setValue("geometry", self.geometry())
        settings.setValue("lsplitter", self.library.mainSplitter.saveState())
        settings.setValue("snippetsMainsplitter",
                          self.settingsWidget.snippetEditor.mainSplitter.saveState())
        settings.setValue("windowMaximized", self.isMaximized())
        settings.endGroup()

    def restoreUiState(self):
        settings = QtCore.QSettings("Clean Code Inc.", "Pcode")
        settings.beginGroup("MainWindow")
        if settings.value("windowMaximized", True, type=bool):
            self.showMaximized()
        else:
            self.setGeometry(settings.value("geometry"))
            self.show()
        self.library.mainSplitter.restoreState(settings.value("lsplitter"))
        self.settingsWidget.snippetEditor.mainSplitter.restoreState(
            settings.value("snippetsMainsplitter"))
        settings.endGroup()

    def closeEvent(self, event):
        for i in range(self.projectWindowStack.count() - 1):
            window = self.projectWindowStack.widget(i)
            closed = window.closeWindow()
            if not closed:
                self.projectTitleBox.setCurrentIndex(i)
                event.ignore()
                return
            else:
                pass
        self.saveUiState()
        self.useData.saveUseData()
        app.closeAllWindows()

        event.accept()

    def setShortcuts(self):
        shortcuts = self.useData.CUSTOM_SHORTCUTS

        self.shortFullscreen = QtGui.QShortcut(
            shortcuts["Ide"]["Fullscreen"], self)
        self.shortFullscreen.activated.connect(self.showFullScreenMode)

app = QtGui.QApplication(sys.argv)

splash = QtGui.QSplashScreen(QtGui.QPixmap(os.path.join("Resources", "images", "splash")))
splash.show()

main = Pcode()

splash.finish(main)

sys.exit(app.exec_())

########NEW FILE########
__FILENAME__ = api
"""
API for the command-line I{pyflakes} tool.
"""
from __future__ import with_statement

import sys
import os
import _ast
from optparse import OptionParser

from pyflakes import checker, __version__
from pyflakes import reporter as modReporter

__all__ = ['check', 'checkPath', 'checkRecursive', 'iterSourceCode', 'main']


def check(codeString, filename, reporter=None):
    """
    Check the Python source given by C{codeString} for flakes.

    @param codeString: The Python source to check.
    @type codeString: C{str}

    @param filename: The name of the file the source came from, used to report
        errors.
    @type filename: C{str}

    @param reporter: A L{Reporter} instance, where errors and warnings will be
        reported.

    @return: The number of warnings emitted.
    @rtype: C{int}
    """
    if reporter is None:
        reporter = modReporter._makeDefaultReporter()
    # First, compile into an AST and handle syntax errors.
    try:
        tree = compile(codeString, filename, "exec", _ast.PyCF_ONLY_AST)
    except SyntaxError:
        value = sys.exc_info()[1]
        msg = value.args[0]

        (lineno, offset, text) = value.lineno, value.offset, value.text

        # If there's an encoding problem with the file, the text is None.
        if text is None:
            # Avoid using msg, since for the only known case, it contains a
            # bogus message that claims the encoding the file declared was
            # unknown.
            reporter.unexpectedError(filename, 'problem decoding source')
        else:
            reporter.syntaxError(filename, msg, lineno, offset, text)
        return 1
    except Exception:
        reporter.unexpectedError(filename, 'problem decoding source')
        return 1
    # Okay, it's syntactically valid.  Now check it.
    w = checker.Checker(tree, filename)
    w.messages.sort(key=lambda m: m.lineno)
    for warning in w.messages:
        reporter.flake(warning)
    return len(w.messages)


def checkPath(filename, reporter=None):
    """
    Check the given path, printing out any warnings detected.

    @param reporter: A L{Reporter} instance, where errors and warnings will be
        reported.

    @return: the number of warnings printed
    """
    if reporter is None:
        reporter = modReporter._makeDefaultReporter()
    try:
        with open(filename, 'U') as f:
            codestr = f.read() + '\n'
    except UnicodeError:
        reporter.unexpectedError(filename, 'problem decoding source')
        return 1
    except IOError:
        msg = sys.exc_info()[1]
        reporter.unexpectedError(filename, msg.args[1])
        return 1
    return check(codestr, filename, reporter)


def iterSourceCode(paths):
    """
    Iterate over all Python source files in C{paths}.

    @param paths: A list of paths.  Directories will be recursed into and
        any .py files found will be yielded.  Any non-directories will be
        yielded as-is.
    """
    for path in paths:
        if os.path.isdir(path):
            for dirpath, dirnames, filenames in os.walk(path):
                for filename in filenames:
                    if filename.endswith('.py'):
                        yield os.path.join(dirpath, filename)
        else:
            yield path


def checkRecursive(paths, reporter):
    """
    Recursively check all source files in C{paths}.

    @param paths: A list of paths to Python source files and directories
        containing Python source files.
    @param reporter: A L{Reporter} where all of the warnings and errors
        will be reported to.
    @return: The number of warnings found.
    """
    warnings = 0
    for sourcePath in iterSourceCode(paths):
        warnings += checkPath(sourcePath, reporter)
    return warnings


def main(prog=None):
    parser = OptionParser(prog=prog, version=__version__)
    __, args = parser.parse_args()
    reporter = modReporter._makeDefaultReporter()
    if args:
        warnings = checkRecursive(args, reporter)
    else:
        warnings = check(sys.stdin.read(), '<stdin>', reporter)
    raise SystemExit(warnings > 0)

########NEW FILE########
__FILENAME__ = checker
"""
Main module.

Implement the central Checker class.
Also, it models the Bindings and Scopes.
"""
import doctest
import os
import sys
try:
    builtin_vars = dir(__import__('builtins'))
    PY2 = False
except ImportError:
    builtin_vars = dir(__import__('__builtin__'))
    PY2 = True

try:
    import ast
    iter_child_nodes = ast.iter_child_nodes
except ImportError:     # Python 2.5
    import _ast as ast

    if 'decorator_list' not in ast.ClassDef._fields:
        # Patch the missing attribute 'decorator_list'
        ast.ClassDef.decorator_list = ()
        ast.FunctionDef.decorator_list = property(lambda s: s.decorators)

    def iter_child_nodes(node):
        """
        Yield all direct child nodes of *node*, that is, all fields that
        are nodes and all items of fields that are lists of nodes.
        """
        for name in node._fields:
            field = getattr(node, name, None)
            if isinstance(field, ast.AST):
                yield field
            elif isinstance(field, list):
                for item in field:
                    yield item
# Python >= 3.3 uses ast.Try instead of (ast.TryExcept + ast.TryFinally)
if hasattr(ast, 'Try'):
    ast_TryExcept = ast.Try
    ast_TryFinally = ()
else:
    ast_TryExcept = ast.TryExcept
    ast_TryFinally = ast.TryFinally

from pyflakes import messages


if PY2:
    def getNodeType(node_class):
        # workaround str.upper() which is locale-dependent
        return str(unicode(node_class.__name__).upper())
else:
    def getNodeType(node_class):
        return node_class.__name__.upper()


class Binding(object):
    """
    Represents the binding of a value to a name.

    The checker uses this to keep track of which names have been bound and
    which names have not. See L{Assignment} for a special type of binding that
    is checked with stricter rules.

    @ivar used: pair of (L{Scope}, line-number) indicating the scope and
                line number that this binding was last used
    """

    def __init__(self, name, source):
        self.name = name
        self.source = source
        self.used = False

    def __str__(self):
        return self.name

    def __repr__(self):
        return '<%s object %r from line %r at 0x%x>' % (self.__class__.__name__,
                                                        self.name,
                                                        self.source.lineno,
                                                        id(self))


class Importation(Binding):
    """
    A binding created by an import statement.

    @ivar fullName: The complete name given to the import statement,
        possibly including multiple dotted components.
    @type fullName: C{str}
    """
    def __init__(self, name, source):
        self.fullName = name
        name = name.split('.')[0]
        super(Importation, self).__init__(name, source)


class Argument(Binding):
    """
    Represents binding a name as an argument.
    """


class Definition(Binding):
    """
    A binding that defines a function or a class.
    """


class Assignment(Binding):
    """
    Represents binding a name with an explicit assignment.

    The checker will raise warnings for any Assignment that isn't used. Also,
    the checker does not consider assignments in tuple/list unpacking to be
    Assignments, rather it treats them as simple Bindings.
    """


class FunctionDefinition(Definition):
    pass


class ClassDefinition(Definition):
    pass


class ExportBinding(Binding):
    """
    A binding created by an C{__all__} assignment.  If the names in the list
    can be determined statically, they will be treated as names for export and
    additional checking applied to them.

    The only C{__all__} assignment that can be recognized is one which takes
    the value of a literal list containing literal strings.  For example::

        __all__ = ["foo", "bar"]

    Names which are imported and not otherwise used but appear in the value of
    C{__all__} will not have an unused import warning reported for them.
    """
    def names(self):
        """
        Return a list of the names referenced by this binding.
        """
        names = []
        if isinstance(self.source, ast.List):
            for node in self.source.elts:
                if isinstance(node, ast.Str):
                    names.append(node.s)
        return names


class Scope(dict):
    importStarred = False       # set to True when import * is found

    def __repr__(self):
        scope_cls = self.__class__.__name__
        return '<%s at 0x%x %s>' % (scope_cls, id(self), dict.__repr__(self))


class ClassScope(Scope):
    pass


class FunctionScope(Scope):
    """
    I represent a name scope for a function.

    @ivar globals: Names declared 'global' in this function.
    """
    usesLocals = False
    alwaysUsed = set(['__tracebackhide__',
                      '__traceback_info__', '__traceback_supplement__'])

    def __init__(self):
        super(FunctionScope, self).__init__()
        # Simplify: manage the special locals as globals
        self.globals = self.alwaysUsed.copy()

    def unusedAssignments(self):
        """
        Return a generator for the assignments which have not been used.
        """
        for name, binding in self.items():
            if (not binding.used and name not in self.globals
                    and not self.usesLocals
                    and isinstance(binding, Assignment)):
                yield name, binding


class GeneratorScope(Scope):
    pass


class ModuleScope(Scope):
    pass


# Globally defined names which are not attributes of the builtins module, or
# are only present on some platforms.
_MAGIC_GLOBALS = ['__file__', '__builtins__', 'WindowsError']


def getNodeName(node):
    # Returns node.id, or node.name, or None
    if hasattr(node, 'id'):     # One of the many nodes with an id
        return node.id
    if hasattr(node, 'name'):   # a ExceptHandler node
        return node.name


class Checker(object):
    """
    I check the cleanliness and sanity of Python code.

    @ivar _deferredFunctions: Tracking list used by L{deferFunction}.  Elements
        of the list are two-tuples.  The first element is the callable passed
        to L{deferFunction}.  The second element is a copy of the scope stack
        at the time L{deferFunction} was called.

    @ivar _deferredAssignments: Similar to C{_deferredFunctions}, but for
        callables which are deferred assignment checks.
    """

    nodeDepth = 0
    offset = None
    traceTree = False
    withDoctest = ('PYFLAKES_NODOCTEST' not in os.environ)

    builtIns = set(builtin_vars).union(_MAGIC_GLOBALS)
    _customBuiltIns = os.environ.get('PYFLAKES_BUILTINS')
    if _customBuiltIns:
        builtIns.update(_customBuiltIns.split(','))
    del _customBuiltIns

    def __init__(self, tree, filename='(none)', builtins=None):
        self._nodeHandlers = {}
        self._deferredFunctions = []
        self._deferredAssignments = []
        self.deadScopes = []
        self.messages = []
        self.filename = filename
        if builtins:
            self.builtIns = self.builtIns.union(builtins)
        self.scopeStack = [ModuleScope()]
        self.exceptHandlers = [()]
        self.futuresAllowed = True
        self.root = tree
        self.handleChildren(tree)
        self.runDeferred(self._deferredFunctions)
        # Set _deferredFunctions to None so that deferFunction will fail
        # noisily if called after we've run through the deferred functions.
        self._deferredFunctions = None
        self.runDeferred(self._deferredAssignments)
        # Set _deferredAssignments to None so that deferAssignment will fail
        # noisily if called after we've run through the deferred assignments.
        self._deferredAssignments = None
        del self.scopeStack[1:]
        self.popScope()
        self.checkDeadScopes()

    def deferFunction(self, callable):
        """
        Schedule a function handler to be called just before completion.

        This is used for handling function bodies, which must be deferred
        because code later in the file might modify the global scope. When
        `callable` is called, the scope at the time this is called will be
        restored, however it will contain any new bindings added to it.
        """
        self._deferredFunctions.append((callable, self.scopeStack[:], self.offset))

    def deferAssignment(self, callable):
        """
        Schedule an assignment handler to be called just after deferred
        function handlers.
        """
        self._deferredAssignments.append((callable, self.scopeStack[:], self.offset))

    def runDeferred(self, deferred):
        """
        Run the callables in C{deferred} using their associated scope stack.
        """
        for handler, scope, offset in deferred:
            self.scopeStack = scope
            self.offset = offset
            handler()

    @property
    def scope(self):
        return self.scopeStack[-1]

    def popScope(self):
        self.deadScopes.append(self.scopeStack.pop())

    def checkDeadScopes(self):
        """
        Look at scopes which have been fully examined and report names in them
        which were imported but unused.
        """
        for scope in self.deadScopes:
            export = isinstance(scope.get('__all__'), ExportBinding)
            if export:
                all = scope['__all__'].names()
                if not scope.importStarred and \
                   os.path.basename(self.filename) != '__init__.py':
                    # Look for possible mistakes in the export list
                    undefined = set(all) - set(scope)
                    for name in undefined:
                        self.report(messages.UndefinedExport,
                                    scope['__all__'].source, name)
            else:
                all = []

            # Look for imported names that aren't used.
            for importation in scope.values():
                if isinstance(importation, Importation):
                    if not importation.used and importation.name not in all:
                        self.report(messages.UnusedImport,
                                    importation.source, importation.name)

    def pushScope(self, scopeClass=FunctionScope):
        self.scopeStack.append(scopeClass())

    def pushFunctionScope(self):    # XXX Deprecated
        self.pushScope(FunctionScope)

    def pushClassScope(self):       # XXX Deprecated
        self.pushScope(ClassScope)

    def report(self, messageClass, *args, **kwargs):
        self.messages.append(messageClass(self.filename, *args, **kwargs))

    def hasParent(self, node, kind):
        while hasattr(node, 'parent'):
            node = node.parent
            if isinstance(node, kind):
                return True

    def getCommonAncestor(self, lnode, rnode, stop=None):
        if not stop:
            stop = self.root
        if lnode is rnode:
            return lnode
        if stop in (lnode, rnode):
            return stop

        if not hasattr(lnode, 'parent') or not hasattr(rnode, 'parent'):
            return
        if (lnode.level > rnode.level):
            return self.getCommonAncestor(lnode.parent, rnode, stop)
        if (rnode.level > lnode.level):
            return self.getCommonAncestor(lnode, rnode.parent, stop)
        return self.getCommonAncestor(lnode.parent, rnode.parent, stop)

    def descendantOf(self, node, ancestors, stop=None):
        for a in ancestors:
            if self.getCommonAncestor(node, a, stop) not in (stop, None):
                return True
        return False

    def onFork(self, parent, lnode, rnode, items):
        return (self.descendantOf(lnode, items, parent) ^
                self.descendantOf(rnode, items, parent))

    def differentForks(self, lnode, rnode):
        """True, if lnode and rnode are located on different forks of IF/TRY"""
        ancestor = self.getCommonAncestor(lnode, rnode)
        if isinstance(ancestor, ast.If):
            for fork in (ancestor.body, ancestor.orelse):
                if self.onFork(ancestor, lnode, rnode, fork):
                    return True
        elif isinstance(ancestor, ast_TryExcept):
            body = ancestor.body + ancestor.orelse
            for fork in [body] + [[hdl] for hdl in ancestor.handlers]:
                if self.onFork(ancestor, lnode, rnode, fork):
                    return True
        elif isinstance(ancestor, ast_TryFinally):
            if self.onFork(ancestor, lnode, rnode, ancestor.body):
                return True
        return False

    def addBinding(self, node, value, reportRedef=True):
        """
        Called when a binding is altered.

        - `node` is the statement responsible for the change
        - `value` is the optional new value, a Binding instance, associated
          with the binding; if None, the binding is deleted if it exists.
        - if `reportRedef` is True (default), rebinding while unused will be
          reported.
        """
        redefinedWhileUnused = False
        if not isinstance(self.scope, ClassScope):
            for scope in self.scopeStack[::-1]:
                existing = scope.get(value.name)
                if (isinstance(existing, Importation)
                        and not existing.used
                        and (not isinstance(value, Importation) or
                             value.fullName == existing.fullName)
                        and reportRedef
                        and not self.differentForks(node, existing.source)):
                    redefinedWhileUnused = True
                    self.report(messages.RedefinedWhileUnused,
                                node, value.name, existing.source)

        existing = self.scope.get(value.name)
        if not redefinedWhileUnused and self.hasParent(value.source, ast.ListComp):
            if (existing and reportRedef
                    and not self.hasParent(existing.source, (ast.For, ast.ListComp))
                    and not self.differentForks(node, existing.source)):
                self.report(messages.RedefinedInListComp,
                            node, value.name, existing.source)

        if (isinstance(existing, Definition)
                and not existing.used
                and not self.differentForks(node, existing.source)):
            self.report(messages.RedefinedWhileUnused,
                        node, value.name, existing.source)
        else:
            self.scope[value.name] = value

    def getNodeHandler(self, node_class):
        try:
            return self._nodeHandlers[node_class]
        except KeyError:
            nodeType = getNodeType(node_class)
        self._nodeHandlers[node_class] = handler = getattr(self, nodeType)
        return handler

    def handleNodeLoad(self, node):
        name = getNodeName(node)
        if not name:
            return
        # try local scope
        try:
            self.scope[name].used = (self.scope, node)
        except KeyError:
            pass
        else:
            return

        scopes = [scope for scope in self.scopeStack[:-1]
                  if isinstance(scope, (FunctionScope, ModuleScope))]
        if isinstance(self.scope, GeneratorScope) and scopes[-1] != self.scopeStack[-2]:
            scopes.append(self.scopeStack[-2])

        # try enclosing function scopes and global scope
        importStarred = self.scope.importStarred
        for scope in reversed(scopes):
            importStarred = importStarred or scope.importStarred
            try:
                scope[name].used = (self.scope, node)
            except KeyError:
                pass
            else:
                return

        # look in the built-ins
        if importStarred or name in self.builtIns:
            return
        if name == '__path__' and os.path.basename(self.filename) == '__init__.py':
            # the special name __path__ is valid only in packages
            return

        # protected with a NameError handler?
        if 'NameError' not in self.exceptHandlers[-1]:
            self.report(messages.UndefinedName, node, name)

    def handleNodeStore(self, node):
        name = getNodeName(node)
        if not name:
            return
        # if the name hasn't already been defined in the current scope
        if isinstance(self.scope, FunctionScope) and name not in self.scope:
            # for each function or module scope above us
            for scope in self.scopeStack[:-1]:
                if not isinstance(scope, (FunctionScope, ModuleScope)):
                    continue
                # if the name was defined in that scope, and the name has
                # been accessed already in the current scope, and hasn't
                # been declared global
                used = name in scope and scope[name].used
                if used and used[0] is self.scope and name not in self.scope.globals:
                    # then it's probably a mistake
                    self.report(messages.UndefinedLocal,
                                scope[name].used[1], name, scope[name].source)
                    break

        parent = getattr(node, 'parent', None)
        if isinstance(parent, (ast.For, ast.comprehension, ast.Tuple, ast.List)):
            binding = Binding(name, node)
        elif (parent is not None and name == '__all__' and
              isinstance(self.scope, ModuleScope)):
            binding = ExportBinding(name, parent.value)
        else:
            binding = Assignment(name, node)
        if name in self.scope:
            binding.used = self.scope[name].used
        self.addBinding(node, binding)

    def handleNodeDelete(self, node):
        name = getNodeName(node)
        if not name:
            return
        if isinstance(self.scope, FunctionScope) and name in self.scope.globals:
            self.scope.globals.remove(name)
        else:
            try:
                del self.scope[name]
            except KeyError:
                self.report(messages.UndefinedName, node, name)

    def handleChildren(self, tree):
        for node in iter_child_nodes(tree):
            self.handleNode(node, tree)

    def isDocstring(self, node):
        """
        Determine if the given node is a docstring, as long as it is at the
        correct place in the node tree.
        """
        return isinstance(node, ast.Str) or (isinstance(node, ast.Expr) and
                                             isinstance(node.value, ast.Str))

    def getDocstring(self, node):
        if isinstance(node, ast.Expr):
            node = node.value
        if not isinstance(node, ast.Str):
            return (None, None)
        # Computed incorrectly if the docstring has backslash
        doctest_lineno = node.lineno - node.s.count('\n') - 1
        return (node.s, doctest_lineno)

    def handleNode(self, node, parent):
        if node is None:
            return
        if self.offset and getattr(node, 'lineno', None) is not None:
            node.lineno += self.offset[0]
            node.col_offset += self.offset[1]
        if self.traceTree:
            print('  ' * self.nodeDepth + node.__class__.__name__)
        if self.futuresAllowed and not (isinstance(node, ast.ImportFrom) or
                                        self.isDocstring(node)):
            self.futuresAllowed = False
        self.nodeDepth += 1
        node.level = self.nodeDepth
        node.parent = parent
        try:
            handler = self.getNodeHandler(node.__class__)
            handler(node)
        finally:
            self.nodeDepth -= 1
        if self.traceTree:
            print('  ' * self.nodeDepth + 'end ' + node.__class__.__name__)

    _getDoctestExamples = doctest.DocTestParser().get_examples

    def handleDoctests(self, node):
        try:
            docstring, node_lineno = self.getDocstring(node.body[0])
            if not docstring:
                return
            examples = self._getDoctestExamples(docstring)
        except (ValueError, IndexError):
            # e.g. line 6 of the docstring for <string> has inconsistent
            # leading whitespace: ...
            return
        node_offset = self.offset or (0, 0)
        self.pushScope()
        for example in examples:
            try:
                tree = compile(example.source, "<doctest>", "exec", ast.PyCF_ONLY_AST)
            except SyntaxError:
                e = sys.exc_info()[1]
                position = (node_lineno + example.lineno + e.lineno,
                            example.indent + 4 + e.offset)
                self.report(messages.DoctestSyntaxError, node, position)
            else:
                self.offset = (node_offset[0] + node_lineno + example.lineno,
                               node_offset[1] + example.indent + 4)
                self.handleChildren(tree)
                self.offset = node_offset
        self.popScope()

    def ignore(self, node):
        pass

    # "stmt" type nodes
    RETURN = DELETE = PRINT = WHILE = IF = WITH = WITHITEM = RAISE = \
        TRYFINALLY = ASSERT = EXEC = EXPR = handleChildren

    CONTINUE = BREAK = PASS = ignore

    # "expr" type nodes
    BOOLOP = BINOP = UNARYOP = IFEXP = DICT = SET = YIELD = YIELDFROM = \
        COMPARE = CALL = REPR = ATTRIBUTE = SUBSCRIPT = LIST = TUPLE = \
        STARRED = handleChildren

    NUM = STR = BYTES = ELLIPSIS = ignore

    # "slice" type nodes
    SLICE = EXTSLICE = INDEX = handleChildren

    # expression contexts are node instances too, though being constants
    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore

    # same for operators
    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \
        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \
        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = ignore

    # additional node types
    COMPREHENSION = KEYWORD = handleChildren

    def GLOBAL(self, node):
        """
        Keep track of globals declarations.
        """
        if isinstance(self.scope, FunctionScope):
            self.scope.globals.update(node.names)

    NONLOCAL = GLOBAL

    def LISTCOMP(self, node):
        # handle generators before element
        for gen in node.generators:
            self.handleNode(gen, node)
        self.handleNode(node.elt, node)

    def GENERATOREXP(self, node):
        self.pushScope(GeneratorScope)
        # handle generators before element
        for gen in node.generators:
            self.handleNode(gen, node)
        self.handleNode(node.elt, node)
        self.popScope()

    SETCOMP = GENERATOREXP

    def DICTCOMP(self, node):
        self.pushScope(GeneratorScope)
        for gen in node.generators:
            self.handleNode(gen, node)
        self.handleNode(node.key, node)
        self.handleNode(node.value, node)
        self.popScope()

    def FOR(self, node):
        """
        Process bindings for loop variables.
        """
        vars = []

        def collectLoopVars(n):
            if isinstance(n, ast.Name):
                vars.append(n.id)
            elif isinstance(n, ast.expr_context):
                return
            else:
                for c in iter_child_nodes(n):
                    collectLoopVars(c)

        collectLoopVars(node.target)
        for varn in vars:
            if (isinstance(self.scope.get(varn), Importation)
                    # unused ones will get an unused import warning
                    and self.scope[varn].used):
                self.report(messages.ImportShadowedByLoopVar,
                            node, varn, self.scope[varn].source)

        self.handleChildren(node)

    def NAME(self, node):
        """
        Handle occurrence of Name (which can be a load/store/delete access.)
        """
        # Locate the name in locals / function / globals scopes.
        if isinstance(node.ctx, (ast.Load, ast.AugLoad)):
            self.handleNodeLoad(node)
            if (node.id == 'locals' and isinstance(self.scope, FunctionScope)
                    and isinstance(node.parent, ast.Call)):
                # we are doing locals() call in current scope
                self.scope.usesLocals = True
        elif isinstance(node.ctx, (ast.Store, ast.AugStore)):
            self.handleNodeStore(node)
        elif isinstance(node.ctx, ast.Del):
            self.handleNodeDelete(node)
        else:
            # must be a Param context -- this only happens for names in function
            # arguments, but these aren't dispatched through here
            raise RuntimeError("Got impossible expression context: %r" % (node.ctx,))

    def FUNCTIONDEF(self, node):
        for deco in node.decorator_list:
            self.handleNode(deco, node)
        self.addBinding(node, FunctionDefinition(node.name, node))
        self.LAMBDA(node)
        if self.withDoctest:
            self.deferFunction(lambda: self.handleDoctests(node))

    def LAMBDA(self, node):
        args = []

        if PY2:
            def addArgs(arglist):
                for arg in arglist:
                    if isinstance(arg, ast.Tuple):
                        addArgs(arg.elts)
                    else:
                        if arg.id in args:
                            self.report(messages.DuplicateArgument,
                                        node, arg.id)
                        args.append(arg.id)
            addArgs(node.args.args)
            defaults = node.args.defaults
        else:
            for arg in node.args.args + node.args.kwonlyargs:
                if arg.arg in args:
                    self.report(messages.DuplicateArgument,
                                node, arg.arg)
                args.append(arg.arg)
                self.handleNode(arg.annotation, node)
            if hasattr(node, 'returns'):    # Only for FunctionDefs
                for annotation in (node.args.varargannotation,
                                   node.args.kwargannotation, node.returns):
                    self.handleNode(annotation, node)
            defaults = node.args.defaults + node.args.kw_defaults

        # vararg/kwarg identifiers are not Name nodes
        for wildcard in (node.args.vararg, node.args.kwarg):
            if not wildcard:
                continue
            if wildcard in args:
                self.report(messages.DuplicateArgument, node, wildcard)
            args.append(wildcard)
        for default in defaults:
            self.handleNode(default, node)

        def runFunction():

            self.pushScope()
            for name in args:
                self.addBinding(node, Argument(name, node), reportRedef=False)
            if isinstance(node.body, list):
                # case for FunctionDefs
                for stmt in node.body:
                    self.handleNode(stmt, node)
            else:
                # case for Lambdas
                self.handleNode(node.body, node)

            def checkUnusedAssignments():
                """
                Check to see if any assignments have not been used.
                """
                for name, binding in self.scope.unusedAssignments():
                    self.report(messages.UnusedVariable, binding.source, name)
            self.deferAssignment(checkUnusedAssignments)
            self.popScope()

        self.deferFunction(runFunction)

    def CLASSDEF(self, node):
        """
        Check names used in a class definition, including its decorators, base
        classes, and the body of its definition.  Additionally, add its name to
        the current scope.
        """
        for deco in node.decorator_list:
            self.handleNode(deco, node)
        for baseNode in node.bases:
            self.handleNode(baseNode, node)
        if not PY2:
            for keywordNode in node.keywords:
                self.handleNode(keywordNode, node)
        self.pushScope(ClassScope)
        if self.withDoctest:
            self.deferFunction(lambda: self.handleDoctests(node))
        for stmt in node.body:
            self.handleNode(stmt, node)
        self.popScope()
        self.addBinding(node, ClassDefinition(node.name, node))

    def ASSIGN(self, node):
        self.handleNode(node.value, node)
        for target in node.targets:
            self.handleNode(target, node)

    def AUGASSIGN(self, node):
        self.handleNodeLoad(node.target)
        self.handleNode(node.value, node)
        self.handleNode(node.target, node)

    def IMPORT(self, node):
        for alias in node.names:
            name = alias.asname or alias.name
            importation = Importation(name, node)
            self.addBinding(node, importation)

    def IMPORTFROM(self, node):
        if node.module == '__future__':
            if not self.futuresAllowed:
                self.report(messages.LateFutureImport,
                            node, [n.name for n in node.names])
        else:
            self.futuresAllowed = False

        for alias in node.names:
            if alias.name == '*':
                self.scope.importStarred = True
                self.report(messages.ImportStarUsed, node, node.module)
                continue
            name = alias.asname or alias.name
            importation = Importation(name, node)
            if node.module == '__future__':
                importation.used = (self.scope, node)
            self.addBinding(node, importation)

    def TRY(self, node):
        handler_names = []
        # List the exception handlers
        for handler in node.handlers:
            if isinstance(handler.type, ast.Tuple):
                for exc_type in handler.type.elts:
                    handler_names.append(getNodeName(exc_type))
            elif handler.type:
                handler_names.append(getNodeName(handler.type))
        # Memorize the except handlers and process the body
        self.exceptHandlers.append(handler_names)
        for child in node.body:
            self.handleNode(child, node)
        self.exceptHandlers.pop()
        # Process the other nodes: "except:", "else:", "finally:"
        for child in iter_child_nodes(node):
            if child not in node.body:
                self.handleNode(child, node)

    TRYEXCEPT = TRY

    def EXCEPTHANDLER(self, node):
        # 3.x: in addition to handling children, we must handle the name of
        # the exception, which is not a Name node, but a simple string.
        if isinstance(node.name, str):
            self.handleNodeStore(node)
        self.handleChildren(node)

########NEW FILE########
__FILENAME__ = messages
"""
Provide the class Message and its subclasses.
"""


class Message(object):
    message = ''
    message_args = ()

    def __init__(self, filename, loc):
        self.filename = filename
        self.lineno = loc.lineno
        self.col = getattr(loc, 'col_offset', 0)

    def __str__(self):
        return '%s:%s: %s' % (self.filename, self.lineno,
                              self.message % self.message_args)


class UnusedImport(Message):
    message = '%r imported but unused'

    def __init__(self, filename, loc, name):
        Message.__init__(self, filename, loc)
        self.message_args = (name,)


class RedefinedWhileUnused(Message):
    message = 'redefinition of unused %r from line %r'

    def __init__(self, filename, loc, name, orig_loc):
        Message.__init__(self, filename, loc)
        self.message_args = (name, orig_loc.lineno)


class RedefinedInListComp(Message):
    message = 'list comprehension redefines %r from line %r'

    def __init__(self, filename, loc, name, orig_loc):
        Message.__init__(self, filename, loc)
        self.message_args = (name, orig_loc.lineno)


class ImportShadowedByLoopVar(Message):
    message = 'import %r from line %r shadowed by loop variable'

    def __init__(self, filename, loc, name, orig_loc):
        Message.__init__(self, filename, loc)
        self.message_args = (name, orig_loc.lineno)


class ImportStarUsed(Message):
    message = "'from %s import *' used; unable to detect undefined names"

    def __init__(self, filename, loc, modname):
        Message.__init__(self, filename, loc)
        self.message_args = (modname,)


class UndefinedName(Message):
    message = 'undefined name %r'

    def __init__(self, filename, loc, name):
        Message.__init__(self, filename, loc)
        self.message_args = (name,)


class DoctestSyntaxError(Message):
    message = 'syntax error in doctest'

    def __init__(self, filename, loc, position=None):
        Message.__init__(self, filename, loc)
        if position:
            (self.lineno, self.col) = position
        self.message_args = ()


class UndefinedExport(Message):
    message = 'undefined name %r in __all__'

    def __init__(self, filename, loc, name):
        Message.__init__(self, filename, loc)
        self.message_args = (name,)


class UndefinedLocal(Message):
    message = ('local variable %r (defined in enclosing scope on line %r) '
               'referenced before assignment')

    def __init__(self, filename, loc, name, orig_loc):
        Message.__init__(self, filename, loc)
        self.message_args = (name, orig_loc.lineno)


class DuplicateArgument(Message):
    message = 'duplicate argument %r in function definition'

    def __init__(self, filename, loc, name):
        Message.__init__(self, filename, loc)
        self.message_args = (name,)


class Redefined(Message):
    message = 'redefinition of %r from line %r'

    def __init__(self, filename, loc, name, orig_loc):
        Message.__init__(self, filename, loc)
        self.message_args = (name, orig_loc.lineno)


class LateFutureImport(Message):
    message = 'future import(s) %r after other statements'

    def __init__(self, filename, loc, names):
        Message.__init__(self, filename, loc)
        self.message_args = (names,)


class UnusedVariable(Message):
    """
    Indicates that a variable has been explicity assigned to but not actually
    used.
    """
    message = 'local variable %r is assigned to but never used'

    def __init__(self, filename, loc, names):
        Message.__init__(self, filename, loc)
        self.message_args = (names,)

########NEW FILE########
__FILENAME__ = reporter
"""
Provide the Reporter class.
"""

import sys


class Reporter(object):
    """
    Formats the results of pyflakes checks to users.
    """

    def __init__(self, warningStream, errorStream):
        """
        Construct a L{Reporter}.

        @param warningStream: A file-like object where warnings will be
            written to.  The stream's C{write} method must accept unicode.
            C{sys.stdout} is a good value.
        @param errorStream: A file-like object where error output will be
            written to.  The stream's C{write} method must accept unicode.
            C{sys.stderr} is a good value.
        """
        self._stdout = warningStream
        self._stderr = errorStream

    def unexpectedError(self, filename, msg):
        """
        An unexpected error occurred trying to process C{filename}.

        @param filename: The path to a file that we could not process.
        @ptype filename: C{unicode}
        @param msg: A message explaining the problem.
        @ptype msg: C{unicode}
        """
        self._stderr.write("%s: %s\n" % (filename, msg))

    def syntaxError(self, filename, msg, lineno, offset, text):
        """
        There was a syntax errror in C{filename}.

        @param filename: The path to the file with the syntax error.
        @ptype filename: C{unicode}
        @param msg: An explanation of the syntax error.
        @ptype msg: C{unicode}
        @param lineno: The line number where the syntax error occurred.
        @ptype lineno: C{int}
        @param offset: The column on which the syntax error occurred.
        @ptype offset: C{int}
        @param text: The source code containing the syntax error.
        @ptype text: C{unicode}
        """
        line = text.splitlines()[-1]
        if offset is not None:
            offset = offset - (len(text) - len(line))
        self._stderr.write('%s:%d: %s\n' % (filename, lineno, msg))
        self._stderr.write(line)
        self._stderr.write('\n')
        if offset is not None:
            self._stderr.write(" " * (offset + 1) + "^\n")

    def flake(self, message):
        """
        pyflakes found something wrong with the code.

        @param: A L{pyflakes.messages.Message}.
        """
        self._stdout.write(str(message))
        self._stdout.write('\n')


def _makeDefaultReporter():
    """
    Make a reporter that can be used when no reporter is specified.
    """
    return Reporter(sys.stdout, sys.stderr)

########NEW FILE########
__FILENAME__ = pyflakes
"""
Implementation of the command-line I{pyflakes} tool.
"""
from __future__ import absolute_import

# For backward compatibility
from pyflakes.api import check, checkPath, checkRecursive, iterSourceCode, main

########NEW FILE########
__FILENAME__ = harness

import sys
import textwrap
import unittest

from pyflakes import checker

__all__ = ['TestCase', 'skip', 'skipIf']

if sys.version_info < (2, 7):
    skip = lambda why: (lambda func: 'skip')  # not callable
    skipIf = lambda cond, why: (skip(why) if cond else lambda func: func)
else:
    skip = unittest.skip
    skipIf = unittest.skipIf
PyCF_ONLY_AST = 1024


class TestCase(unittest.TestCase):

    def flakes(self, input, *expectedOutputs, **kw):
        tree = compile(textwrap.dedent(input), "<test>", "exec", PyCF_ONLY_AST)
        w = checker.Checker(tree, **kw)
        outputs = [type(o) for o in w.messages]
        expectedOutputs = list(expectedOutputs)
        outputs.sort(key=lambda t: t.__name__)
        expectedOutputs.sort(key=lambda t: t.__name__)
        self.assertEqual(outputs, expectedOutputs, '''\
for input:
%s
expected outputs:
%r
but got:
%s''' % (input, expectedOutputs, '\n'.join([str(o) for o in w.messages])))
        return w

    if sys.version_info < (2, 7):

        def assertIs(self, expr1, expr2, msg=None):
            if expr1 is not expr2:
                self.fail(msg or '%r is not %r' % (expr1, expr2))

########NEW FILE########
__FILENAME__ = test_api
"""
Tests for L{pyflakes.scripts.pyflakes}.
"""

import os
import sys
import shutil
import subprocess
import tempfile

from pyflakes.messages import UnusedImport
from pyflakes.reporter import Reporter
from pyflakes.api import (
    checkPath,
    checkRecursive,
    iterSourceCode,
)
from pyflakes.test.harness import TestCase, skipIf

if sys.version_info < (3,):
    from cStringIO import StringIO
else:
    from io import StringIO
    unichr = chr


def withStderrTo(stderr, f, *args, **kwargs):
    """
    Call C{f} with C{sys.stderr} redirected to C{stderr}.
    """
    (outer, sys.stderr) = (sys.stderr, stderr)
    try:
        return f(*args, **kwargs)
    finally:
        sys.stderr = outer


class Node(object):
    """
    Mock an AST node.
    """
    def __init__(self, lineno, col_offset=0):
        self.lineno = lineno
        self.col_offset = col_offset


class LoggingReporter(object):
    """
    Implementation of Reporter that just appends any error to a list.
    """

    def __init__(self, log):
        """
        Construct a C{LoggingReporter}.

        @param log: A list to append log messages to.
        """
        self.log = log

    def flake(self, message):
        self.log.append(('flake', str(message)))

    def unexpectedError(self, filename, message):
        self.log.append(('unexpectedError', filename, message))

    def syntaxError(self, filename, msg, lineno, offset, line):
        self.log.append(('syntaxError', filename, msg, lineno, offset, line))


class TestIterSourceCode(TestCase):
    """
    Tests for L{iterSourceCode}.
    """

    def setUp(self):
        self.tempdir = tempfile.mkdtemp()

    def tearDown(self):
        shutil.rmtree(self.tempdir)

    def makeEmptyFile(self, *parts):
        assert parts
        fpath = os.path.join(self.tempdir, *parts)
        fd = open(fpath, 'a')
        fd.close()
        return fpath

    def test_emptyDirectory(self):
        """
        There are no Python files in an empty directory.
        """
        self.assertEqual(list(iterSourceCode([self.tempdir])), [])

    def test_singleFile(self):
        """
        If the directory contains one Python file, C{iterSourceCode} will find
        it.
        """
        childpath = self.makeEmptyFile('foo.py')
        self.assertEqual(list(iterSourceCode([self.tempdir])), [childpath])

    def test_onlyPythonSource(self):
        """
        Files that are not Python source files are not included.
        """
        self.makeEmptyFile('foo.pyc')
        self.assertEqual(list(iterSourceCode([self.tempdir])), [])

    def test_recurses(self):
        """
        If the Python files are hidden deep down in child directories, we will
        find them.
        """
        os.mkdir(os.path.join(self.tempdir, 'foo'))
        apath = self.makeEmptyFile('foo', 'a.py')
        os.mkdir(os.path.join(self.tempdir, 'bar'))
        bpath = self.makeEmptyFile('bar', 'b.py')
        cpath = self.makeEmptyFile('c.py')
        self.assertEqual(
            sorted(iterSourceCode([self.tempdir])),
            sorted([apath, bpath, cpath]))

    def test_multipleDirectories(self):
        """
        L{iterSourceCode} can be given multiple directories.  It will recurse
        into each of them.
        """
        foopath = os.path.join(self.tempdir, 'foo')
        barpath = os.path.join(self.tempdir, 'bar')
        os.mkdir(foopath)
        apath = self.makeEmptyFile('foo', 'a.py')
        os.mkdir(barpath)
        bpath = self.makeEmptyFile('bar', 'b.py')
        self.assertEqual(
            sorted(iterSourceCode([foopath, barpath])),
            sorted([apath, bpath]))

    def test_explicitFiles(self):
        """
        If one of the paths given to L{iterSourceCode} is not a directory but
        a file, it will include that in its output.
        """
        epath = self.makeEmptyFile('e.py')
        self.assertEqual(list(iterSourceCode([epath])),
                         [epath])


class TestReporter(TestCase):
    """
    Tests for L{Reporter}.
    """

    def test_syntaxError(self):
        """
        C{syntaxError} reports that there was a syntax error in the source
        file.  It reports to the error stream and includes the filename, line
        number, error message, actual line of source and a caret pointing to
        where the error is.
        """
        err = StringIO()
        reporter = Reporter(None, err)
        reporter.syntaxError('foo.py', 'a problem', 3, 4, 'bad line of source')
        self.assertEqual(
            ("foo.py:3: a problem\n"
             "bad line of source\n"
             "     ^\n"),
            err.getvalue())

    def test_syntaxErrorNoOffset(self):
        """
        C{syntaxError} doesn't include a caret pointing to the error if
        C{offset} is passed as C{None}.
        """
        err = StringIO()
        reporter = Reporter(None, err)
        reporter.syntaxError('foo.py', 'a problem', 3, None,
                             'bad line of source')
        self.assertEqual(
            ("foo.py:3: a problem\n"
             "bad line of source\n"),
            err.getvalue())

    def test_multiLineSyntaxError(self):
        """
        If there's a multi-line syntax error, then we only report the last
        line.  The offset is adjusted so that it is relative to the start of
        the last line.
        """
        err = StringIO()
        lines = [
            'bad line of source',
            'more bad lines of source',
        ]
        reporter = Reporter(None, err)
        reporter.syntaxError('foo.py', 'a problem', 3, len(lines[0]) + 5,
                             '\n'.join(lines))
        self.assertEqual(
            ("foo.py:3: a problem\n" +
             lines[-1] + "\n" +
             "     ^\n"),
            err.getvalue())

    def test_unexpectedError(self):
        """
        C{unexpectedError} reports an error processing a source file.
        """
        err = StringIO()
        reporter = Reporter(None, err)
        reporter.unexpectedError('source.py', 'error message')
        self.assertEqual('source.py: error message\n', err.getvalue())

    def test_flake(self):
        """
        C{flake} reports a code warning from Pyflakes.  It is exactly the
        str() of a L{pyflakes.messages.Message}.
        """
        out = StringIO()
        reporter = Reporter(out, None)
        message = UnusedImport('foo.py', Node(42), 'bar')
        reporter.flake(message)
        self.assertEqual(out.getvalue(), "%s\n" % (message,))


class CheckTests(TestCase):
    """
    Tests for L{check} and L{checkPath} which check a file for flakes.
    """

    def makeTempFile(self, content):
        """
        Make a temporary file containing C{content} and return a path to it.
        """
        _, fpath = tempfile.mkstemp()
        if not hasattr(content, 'decode'):
            content = content.encode('ascii')
        fd = open(fpath, 'wb')
        fd.write(content)
        fd.close()
        return fpath

    def assertHasErrors(self, path, errorList):
        """
        Assert that C{path} causes errors.

        @param path: A path to a file to check.
        @param errorList: A list of errors expected to be printed to stderr.
        """
        err = StringIO()
        count = withStderrTo(err, checkPath, path)
        self.assertEqual(
            (count, err.getvalue()), (len(errorList), ''.join(errorList)))

    def getErrors(self, path):
        """
        Get any warnings or errors reported by pyflakes for the file at C{path}.

        @param path: The path to a Python file on disk that pyflakes will check.
        @return: C{(count, log)}, where C{count} is the number of warnings or
            errors generated, and log is a list of those warnings, presented
            as structured data.  See L{LoggingReporter} for more details.
        """
        log = []
        reporter = LoggingReporter(log)
        count = checkPath(path, reporter)
        return count, log

    def test_legacyScript(self):
        from pyflakes.scripts import pyflakes as script_pyflakes
        self.assertIs(script_pyflakes.checkPath, checkPath)

    def test_missingTrailingNewline(self):
        """
        Source which doesn't end with a newline shouldn't cause any
        exception to be raised nor an error indicator to be returned by
        L{check}.
        """
        fName = self.makeTempFile("def foo():\n\tpass\n\t")
        self.assertHasErrors(fName, [])

    def test_checkPathNonExisting(self):
        """
        L{checkPath} handles non-existing files.
        """
        count, errors = self.getErrors('extremo')
        self.assertEqual(count, 1)
        self.assertEqual(
            errors,
            [('unexpectedError', 'extremo', 'No such file or directory')])

    def test_multilineSyntaxError(self):
        """
        Source which includes a syntax error which results in the raised
        L{SyntaxError.text} containing multiple lines of source are reported
        with only the last line of that source.
        """
        source = """\
def foo():
    '''

def bar():
    pass

def baz():
    '''quux'''
"""

        # Sanity check - SyntaxError.text should be multiple lines, if it
        # isn't, something this test was unprepared for has happened.
        def evaluate(source):
            exec(source)
        try:
            evaluate(source)
        except SyntaxError:
            e = sys.exc_info()[1]
            self.assertTrue(e.text.count('\n') > 1)
        else:
            self.fail()

        sourcePath = self.makeTempFile(source)
        self.assertHasErrors(
            sourcePath,
            ["""\
%s:8: invalid syntax
    '''quux'''
           ^
""" % (sourcePath,)])

    def test_eofSyntaxError(self):
        """
        The error reported for source files which end prematurely causing a
        syntax error reflects the cause for the syntax error.
        """
        sourcePath = self.makeTempFile("def foo(")
        self.assertHasErrors(
            sourcePath,
            ["""\
%s:1: unexpected EOF while parsing
def foo(
         ^
""" % (sourcePath,)])

    def test_nonDefaultFollowsDefaultSyntaxError(self):
        """
        Source which has a non-default argument following a default argument
        should include the line number of the syntax error.  However these
        exceptions do not include an offset.
        """
        source = """\
def foo(bar=baz, bax):
    pass
"""
        sourcePath = self.makeTempFile(source)
        last_line = '        ^\n' if sys.version_info >= (3, 2) else ''
        self.assertHasErrors(
            sourcePath,
            ["""\
%s:1: non-default argument follows default argument
def foo(bar=baz, bax):
%s""" % (sourcePath, last_line)])

    def test_nonKeywordAfterKeywordSyntaxError(self):
        """
        Source which has a non-keyword argument after a keyword argument should
        include the line number of the syntax error.  However these exceptions
        do not include an offset.
        """
        source = """\
foo(bar=baz, bax)
"""
        sourcePath = self.makeTempFile(source)
        last_line = '             ^\n' if sys.version_info >= (3, 2) else ''
        self.assertHasErrors(
            sourcePath,
            ["""\
%s:1: non-keyword arg after keyword arg
foo(bar=baz, bax)
%s""" % (sourcePath, last_line)])

    def test_invalidEscape(self):
        """
        The invalid escape syntax raises ValueError in Python 2
        """
        ver = sys.version_info
        # ValueError: invalid \x escape
        sourcePath = self.makeTempFile(r"foo = '\xyz'")
        if ver < (3,):
            decoding_error = "%s: problem decoding source\n" % (sourcePath,)
        else:
            last_line = '       ^\n' if ver >= (3, 2) else ''
            # Column has been "fixed" since 3.2.4 and 3.3.1
            col = 1 if ver >= (3, 3, 1) or ((3, 2, 4) <= ver < (3, 3)) else 2
            decoding_error = """\
%s:1: (unicode error) 'unicodeescape' codec can't decode bytes \
in position 0-%d: truncated \\xXX escape
foo = '\\xyz'
%s""" % (sourcePath, col, last_line)
        self.assertHasErrors(
            sourcePath, [decoding_error])

    def test_permissionDenied(self):
        """
        If the source file is not readable, this is reported on standard
        error.
        """
        sourcePath = self.makeTempFile('')
        os.chmod(sourcePath, 0)
        count, errors = self.getErrors(sourcePath)
        self.assertEqual(count, 1)
        self.assertEqual(
            errors,
            [('unexpectedError', sourcePath, "Permission denied")])

    def test_pyflakesWarning(self):
        """
        If the source file has a pyflakes warning, this is reported as a
        'flake'.
        """
        sourcePath = self.makeTempFile("import foo")
        count, errors = self.getErrors(sourcePath)
        self.assertEqual(count, 1)
        self.assertEqual(
            errors, [('flake', str(UnusedImport(sourcePath, Node(1), 'foo')))])

    @skipIf(sys.version_info >= (3,), "not relevant")
    def test_misencodedFileUTF8(self):
        """
        If a source file contains bytes which cannot be decoded, this is
        reported on stderr.
        """
        SNOWMAN = unichr(0x2603)
        source = ("""\
# coding: ascii
x = "%s"
""" % SNOWMAN).encode('utf-8')
        sourcePath = self.makeTempFile(source)
        self.assertHasErrors(
            sourcePath, ["%s: problem decoding source\n" % (sourcePath,)])

    def test_misencodedFileUTF16(self):
        """
        If a source file contains bytes which cannot be decoded, this is
        reported on stderr.
        """
        SNOWMAN = unichr(0x2603)
        source = ("""\
# coding: ascii
x = "%s"
""" % SNOWMAN).encode('utf-16')
        sourcePath = self.makeTempFile(source)
        self.assertHasErrors(
            sourcePath, ["%s: problem decoding source\n" % (sourcePath,)])

    def test_checkRecursive(self):
        """
        L{checkRecursive} descends into each directory, finding Python files
        and reporting problems.
        """
        tempdir = tempfile.mkdtemp()
        os.mkdir(os.path.join(tempdir, 'foo'))
        file1 = os.path.join(tempdir, 'foo', 'bar.py')
        fd = open(file1, 'wb')
        fd.write("import baz\n".encode('ascii'))
        fd.close()
        file2 = os.path.join(tempdir, 'baz.py')
        fd = open(file2, 'wb')
        fd.write("import contraband".encode('ascii'))
        fd.close()
        log = []
        reporter = LoggingReporter(log)
        warnings = checkRecursive([tempdir], reporter)
        self.assertEqual(warnings, 2)
        self.assertEqual(
            sorted(log),
            sorted([('flake', str(UnusedImport(file1, Node(1), 'baz'))),
                    ('flake',
                     str(UnusedImport(file2, Node(1), 'contraband')))]))


class IntegrationTests(TestCase):
    """
    Tests of the pyflakes script that actually spawn the script.
    """

    def setUp(self):
        self.tempdir = tempfile.mkdtemp()
        self.tempfilepath = os.path.join(self.tempdir, 'temp')

    def tearDown(self):
        shutil.rmtree(self.tempdir)

    def getPyflakesBinary(self):
        """
        Return the path to the pyflakes binary.
        """
        import pyflakes
        package_dir = os.path.dirname(pyflakes.__file__)
        return os.path.join(package_dir, '..', 'bin', 'pyflakes')

    def runPyflakes(self, paths, stdin=None):
        """
        Launch a subprocess running C{pyflakes}.

        @param args: Command-line arguments to pass to pyflakes.
        @param kwargs: Options passed on to C{subprocess.Popen}.
        @return: C{(returncode, stdout, stderr)} of the completed pyflakes
            process.
        """
        env = dict(os.environ)
        env['PYTHONPATH'] = os.pathsep.join(sys.path)
        command = [sys.executable, self.getPyflakesBinary()]
        command.extend(paths)
        if stdin:
            p = subprocess.Popen(command, env=env, stdin=subprocess.PIPE,
                                 stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            (stdout, stderr) = p.communicate(stdin)
        else:
            p = subprocess.Popen(command, env=env,
                                 stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            (stdout, stderr) = p.communicate()
        rv = p.wait()
        if sys.version_info >= (3,):
            stdout = stdout.decode('utf-8')
            stderr = stderr.decode('utf-8')
        return (stdout, stderr, rv)

    def test_goodFile(self):
        """
        When a Python source file is all good, the return code is zero and no
        messages are printed to either stdout or stderr.
        """
        fd = open(self.tempfilepath, 'a')
        fd.close()
        d = self.runPyflakes([self.tempfilepath])
        self.assertEqual(d, ('', '', 0))

    def test_fileWithFlakes(self):
        """
        When a Python source file has warnings, the return code is non-zero
        and the warnings are printed to stdout.
        """
        fd = open(self.tempfilepath, 'wb')
        fd.write("import contraband\n".encode('ascii'))
        fd.close()
        d = self.runPyflakes([self.tempfilepath])
        expected = UnusedImport(self.tempfilepath, Node(1), 'contraband')
        self.assertEqual(d, ("%s\n" % expected, '', 1))

    def test_errors(self):
        """
        When pyflakes finds errors with the files it's given, (if they don't
        exist, say), then the return code is non-zero and the errors are
        printed to stderr.
        """
        d = self.runPyflakes([self.tempfilepath])
        error_msg = '%s: No such file or directory\n' % (self.tempfilepath,)
        self.assertEqual(d, ('', error_msg, 1))

    def test_readFromStdin(self):
        """
        If no arguments are passed to C{pyflakes} then it reads from stdin.
        """
        d = self.runPyflakes([], stdin='import contraband'.encode('ascii'))
        expected = UnusedImport('<stdin>', Node(1), 'contraband')
        self.assertEqual(d, ("%s\n" % expected, '', 1))

########NEW FILE########
__FILENAME__ = test_doctests
import textwrap

from pyflakes import messages as m
from pyflakes.test.test_other import Test as TestOther
from pyflakes.test.test_imports import Test as TestImports
from pyflakes.test.test_undefined_names import Test as TestUndefinedNames
from pyflakes.test.harness import skip


class Test(TestOther, TestImports, TestUndefinedNames):

    def doctestify(self, input):
        lines = []
        for line in textwrap.dedent(input).splitlines():
            if line.strip() == '':
                pass
            elif (line.startswith(' ') or
                  line.startswith('except:') or
                  line.startswith('except ') or
                  line.startswith('finally:') or
                  line.startswith('else:') or
                  line.startswith('elif ')):
                line = "... %s" % line
            else:
                line = ">>> %s" % line
            lines.append(line)
        doctestificator = textwrap.dedent('''\
            def doctest_something():
                """
                   %s
                """
            ''')
        return doctestificator % "\n       ".join(lines)

    def flakes(self, input, *args, **kw):
        return super(Test, self).flakes(self.doctestify(input),
                                        *args, **kw)

    def test_doubleNestingReportsClosestName(self):
        """
        Lines in doctest are a bit different so we can't use the test
        from TestUndefinedNames
        """
        exc = super(Test, self).flakes('''
        def doctest_stuff():
            """
                >>> def a():
                ...     x = 1
                ...     def b():
                ...         x = 2 # line 7 in the file
                ...         def c():
                ...             x
                ...             x = 3
                ...             return x
                ...         return x
                ...     return x

            """
        ''', m.UndefinedLocal).messages[0]
        self.assertEqual(exc.message_args, ('x', 7))

    def test_futureImport(self):
        """XXX This test can't work in a doctest"""

    def test_importBeforeDoctest(self):
        super(Test, self).flakes("""
        import foo

        def doctest_stuff():
            '''
                >>> foo
            '''
        """)

    @skip("todo")
    def test_importBeforeAndInDoctest(self):
        super(Test, self).flakes('''
        import foo

        def doctest_stuff():
            """
                >>> import foo
                >>> foo
            """

        foo
        ''', m.Redefined)

    def test_importInDoctestAndAfter(self):
        super(Test, self).flakes('''
        def doctest_stuff():
            """
                >>> import foo
                >>> foo
            """

        import foo
        foo()
        ''')

    def test_offsetInDoctests(self):
        exc = super(Test, self).flakes('''

        def doctest_stuff():
            """
                >>> x # line 5
            """

        ''', m.UndefinedName).messages[0]
        self.assertEqual(exc.lineno, 5)
        self.assertEqual(exc.col, 12)

    def test_offsetInLambdasInDoctests(self):
        exc = super(Test, self).flakes('''

        def doctest_stuff():
            """
                >>> lambda: x # line 5
            """

        ''', m.UndefinedName).messages[0]
        self.assertEqual(exc.lineno, 5)
        self.assertEqual(exc.col, 20)

    def test_offsetAfterDoctests(self):
        exc = super(Test, self).flakes('''

        def doctest_stuff():
            """
                >>> x = 5
            """

        x

        ''', m.UndefinedName).messages[0]
        self.assertEqual(exc.lineno, 8)
        self.assertEqual(exc.col, 0)

    def test_syntaxErrorInDoctest(self):
        exceptions = super(Test, self).flakes(
            '''
            def doctest_stuff():
                """
                    >>> from # line 4
                    >>>     fortytwo = 42
                    >>> except Exception:
                """
            ''',
            m.DoctestSyntaxError,
            m.DoctestSyntaxError,
            m.DoctestSyntaxError).messages
        exc = exceptions[0]
        self.assertEqual(exc.lineno, 4)
        self.assertEqual(exc.col, 26)
        exc = exceptions[1]
        self.assertEqual(exc.lineno, 5)
        self.assertEqual(exc.col, 16)
        exc = exceptions[2]
        self.assertEqual(exc.lineno, 6)
        self.assertEqual(exc.col, 18)

    def test_indentationErrorInDoctest(self):
        exc = super(Test, self).flakes('''
        def doctest_stuff():
            """
                >>> if True:
                ... pass
            """
        ''', m.DoctestSyntaxError).messages[0]
        self.assertEqual(exc.lineno, 5)
        self.assertEqual(exc.col, 16)

    def test_offsetWithMultiLineArgs(self):
        (exc1, exc2) = super(Test, self).flakes(
            '''
            def doctest_stuff(arg1,
                              arg2,
                              arg3):
                """
                    >>> assert
                    >>> this
                """
            ''',
            m.DoctestSyntaxError,
            m.UndefinedName).messages
        self.assertEqual(exc1.lineno, 6)
        self.assertEqual(exc1.col, 19)
        self.assertEqual(exc2.lineno, 7)
        self.assertEqual(exc2.col, 12)

    def test_doctestCanReferToFunction(self):
        super(Test, self).flakes("""
        def foo():
            '''
                >>> foo
            '''
        """)

    def test_doctestCanReferToClass(self):
        super(Test, self).flakes("""
        class Foo():
            '''
                >>> Foo
            '''
            def bar(self):
                '''
                    >>> Foo
                '''
        """)

########NEW FILE########
__FILENAME__ = test_imports

from sys import version_info

from pyflakes import messages as m
from pyflakes.test.harness import TestCase, skip, skipIf


class Test(TestCase):

    def test_unusedImport(self):
        self.flakes('import fu, bar', m.UnusedImport, m.UnusedImport)
        self.flakes('from baz import fu, bar', m.UnusedImport, m.UnusedImport)

    def test_aliasedImport(self):
        self.flakes('import fu as FU, bar as FU',
                    m.RedefinedWhileUnused, m.UnusedImport)
        self.flakes('from moo import fu as FU, bar as FU',
                    m.RedefinedWhileUnused, m.UnusedImport)

    def test_usedImport(self):
        self.flakes('import fu; print(fu)')
        self.flakes('from baz import fu; print(fu)')
        self.flakes('import fu; del fu')

    def test_redefinedWhileUnused(self):
        self.flakes('import fu; fu = 3', m.RedefinedWhileUnused)
        self.flakes('import fu; fu, bar = 3', m.RedefinedWhileUnused)
        self.flakes('import fu; [fu, bar] = 3', m.RedefinedWhileUnused)

    def test_redefinedIf(self):
        """
        Test that importing a module twice within an if
        block does raise a warning.
        """
        self.flakes('''
        i = 2
        if i==1:
            import os
            import os
        os.path''', m.RedefinedWhileUnused)

    def test_redefinedIfElse(self):
        """
        Test that importing a module twice in if
        and else blocks does not raise a warning.
        """
        self.flakes('''
        i = 2
        if i==1:
            import os
        else:
            import os
        os.path''')

    def test_redefinedTry(self):
        """
        Test that importing a module twice in an try block
        does raise a warning.
        """
        self.flakes('''
        try:
            import os
            import os
        except:
            pass
        os.path''', m.RedefinedWhileUnused)

    def test_redefinedTryExcept(self):
        """
        Test that importing a module twice in an try
        and except block does not raise a warning.
        """
        self.flakes('''
        try:
            import os
        except:
            import os
        os.path''')

    def test_redefinedTryNested(self):
        """
        Test that importing a module twice using a nested
        try/except and if blocks does not issue a warning.
        """
        self.flakes('''
        try:
            if True:
                if True:
                    import os
        except:
            import os
        os.path''')

    def test_redefinedTryExceptMulti(self):
        self.flakes("""
        try:
            from aa import mixer
        except AttributeError:
            from bb import mixer
        except RuntimeError:
            from cc import mixer
        except:
            from dd import mixer
        mixer(123)
        """)

    def test_redefinedTryElse(self):
        self.flakes("""
        try:
            from aa import mixer
        except ImportError:
            pass
        else:
            from bb import mixer
        mixer(123)
        """, m.RedefinedWhileUnused)

    def test_redefinedTryExceptElse(self):
        self.flakes("""
        try:
            import funca
        except ImportError:
            from bb import funca
            from bb import funcb
        else:
            from bbb import funcb
        print(funca, funcb)
        """)

    def test_redefinedTryExceptFinally(self):
        self.flakes("""
        try:
            from aa import a
        except ImportError:
            from bb import a
        finally:
            a = 42
        print(a)
        """)

    def test_redefinedTryExceptElseFinally(self):
        self.flakes("""
        try:
            import b
        except ImportError:
            b = Ellipsis
            from bb import a
        else:
            from aa import a
        finally:
            a = 42
        print(a, b)
        """)

    def test_redefinedByFunction(self):
        self.flakes('''
        import fu
        def fu():
            pass
        ''', m.RedefinedWhileUnused)

    def test_redefinedInNestedFunction(self):
        """
        Test that shadowing a global name with a nested function definition
        generates a warning.
        """
        self.flakes('''
        import fu
        def bar():
            def baz():
                def fu():
                    pass
        ''', m.RedefinedWhileUnused, m.UnusedImport)

    def test_redefinedByClass(self):
        self.flakes('''
        import fu
        class fu:
            pass
        ''', m.RedefinedWhileUnused)

    def test_redefinedBySubclass(self):
        """
        If an imported name is redefined by a class statement which also uses
        that name in the bases list, no warning is emitted.
        """
        self.flakes('''
        from fu import bar
        class bar(bar):
            pass
        ''')

    def test_redefinedInClass(self):
        """
        Test that shadowing a global with a class attribute does not produce a
        warning.
        """
        self.flakes('''
        import fu
        class bar:
            fu = 1
        print(fu)
        ''')

    def test_usedInFunction(self):
        self.flakes('''
        import fu
        def fun():
            print(fu)
        ''')

    def test_shadowedByParameter(self):
        self.flakes('''
        import fu
        def fun(fu):
            print(fu)
        ''', m.UnusedImport)

        self.flakes('''
        import fu
        def fun(fu):
            print(fu)
        print(fu)
        ''')

    def test_newAssignment(self):
        self.flakes('fu = None')

    def test_usedInGetattr(self):
        self.flakes('import fu; fu.bar.baz')
        self.flakes('import fu; "bar".fu.baz', m.UnusedImport)

    def test_usedInSlice(self):
        self.flakes('import fu; print(fu.bar[1:])')

    def test_usedInIfBody(self):
        self.flakes('''
        import fu
        if True: print(fu)
        ''')

    def test_usedInIfConditional(self):
        self.flakes('''
        import fu
        if fu: pass
        ''')

    def test_usedInElifConditional(self):
        self.flakes('''
        import fu
        if False: pass
        elif fu: pass
        ''')

    def test_usedInElse(self):
        self.flakes('''
        import fu
        if False: pass
        else: print(fu)
        ''')

    def test_usedInCall(self):
        self.flakes('import fu; fu.bar()')

    def test_usedInClass(self):
        self.flakes('''
        import fu
        class bar:
            bar = fu
        ''')

    def test_usedInClassBase(self):
        self.flakes('''
        import fu
        class bar(object, fu.baz):
            pass
        ''')

    def test_notUsedInNestedScope(self):
        self.flakes('''
        import fu
        def bleh():
            pass
        print(fu)
        ''')

    def test_usedInFor(self):
        self.flakes('''
        import fu
        for bar in range(9):
            print(fu)
        ''')

    def test_usedInForElse(self):
        self.flakes('''
        import fu
        for bar in range(10):
            pass
        else:
            print(fu)
        ''')

    def test_redefinedByFor(self):
        self.flakes('''
        import fu
        for fu in range(2):
            pass
        ''', m.RedefinedWhileUnused)

    def test_shadowedByFor(self):
        """
        Test that shadowing a global name with a for loop variable generates a
        warning.
        """
        self.flakes('''
        import fu
        fu.bar()
        for fu in ():
            pass
        ''', m.ImportShadowedByLoopVar)

    def test_shadowedByForDeep(self):
        """
        Test that shadowing a global name with a for loop variable nested in a
        tuple unpack generates a warning.
        """
        self.flakes('''
        import fu
        fu.bar()
        for (x, y, z, (a, b, c, (fu,))) in ():
            pass
        ''', m.ImportShadowedByLoopVar)

    def test_usedInReturn(self):
        self.flakes('''
        import fu
        def fun():
            return fu
        ''')

    def test_usedInOperators(self):
        self.flakes('import fu; 3 + fu.bar')
        self.flakes('import fu; 3 % fu.bar')
        self.flakes('import fu; 3 - fu.bar')
        self.flakes('import fu; 3 * fu.bar')
        self.flakes('import fu; 3 ** fu.bar')
        self.flakes('import fu; 3 / fu.bar')
        self.flakes('import fu; 3 // fu.bar')
        self.flakes('import fu; -fu.bar')
        self.flakes('import fu; ~fu.bar')
        self.flakes('import fu; 1 == fu.bar')
        self.flakes('import fu; 1 | fu.bar')
        self.flakes('import fu; 1 & fu.bar')
        self.flakes('import fu; 1 ^ fu.bar')
        self.flakes('import fu; 1 >> fu.bar')
        self.flakes('import fu; 1 << fu.bar')

    def test_usedInAssert(self):
        self.flakes('import fu; assert fu.bar')

    def test_usedInSubscript(self):
        self.flakes('import fu; fu.bar[1]')

    def test_usedInLogic(self):
        self.flakes('import fu; fu and False')
        self.flakes('import fu; fu or False')
        self.flakes('import fu; not fu.bar')

    def test_usedInList(self):
        self.flakes('import fu; [fu]')

    def test_usedInTuple(self):
        self.flakes('import fu; (fu,)')

    def test_usedInTry(self):
        self.flakes('''
        import fu
        try: fu
        except: pass
        ''')

    def test_usedInExcept(self):
        self.flakes('''
        import fu
        try: fu
        except: pass
        ''')

    def test_redefinedByExcept(self):
        as_exc = ', ' if version_info < (2, 6) else ' as '
        self.flakes('''
        import fu
        try: pass
        except Exception%sfu: pass
        ''' % as_exc, m.RedefinedWhileUnused)

    def test_usedInRaise(self):
        self.flakes('''
        import fu
        raise fu.bar
        ''')

    def test_usedInYield(self):
        self.flakes('''
        import fu
        def gen():
            yield fu
        ''')

    def test_usedInDict(self):
        self.flakes('import fu; {fu:None}')
        self.flakes('import fu; {1:fu}')

    def test_usedInParameterDefault(self):
        self.flakes('''
        import fu
        def f(bar=fu):
            pass
        ''')

    def test_usedInAttributeAssign(self):
        self.flakes('import fu; fu.bar = 1')

    def test_usedInKeywordArg(self):
        self.flakes('import fu; fu.bar(stuff=fu)')

    def test_usedInAssignment(self):
        self.flakes('import fu; bar=fu')
        self.flakes('import fu; n=0; n+=fu')

    def test_usedInListComp(self):
        self.flakes('import fu; [fu for _ in range(1)]')
        self.flakes('import fu; [1 for _ in range(1) if fu]')

    def test_redefinedByListComp(self):
        self.flakes('import fu; [1 for fu in range(1)]', m.RedefinedWhileUnused)

    def test_usedInTryFinally(self):
        self.flakes('''
        import fu
        try: pass
        finally: fu
        ''')

        self.flakes('''
        import fu
        try: fu
        finally: pass
        ''')

    def test_usedInWhile(self):
        self.flakes('''
        import fu
        while 0:
            fu
        ''')

        self.flakes('''
        import fu
        while fu: pass
        ''')

    def test_usedInGlobal(self):
        self.flakes('''
        import fu
        def f(): global fu
        ''', m.UnusedImport)

    @skipIf(version_info >= (3,), 'deprecated syntax')
    def test_usedInBackquote(self):
        self.flakes('import fu; `fu`')

    def test_usedInExec(self):
        if version_info < (3,):
            exec_stmt = 'exec "print 1" in fu.bar'
        else:
            exec_stmt = 'exec("print(1)", fu.bar)'
        self.flakes('import fu; %s' % exec_stmt)

    def test_usedInLambda(self):
        self.flakes('import fu; lambda: fu')

    def test_shadowedByLambda(self):
        self.flakes('import fu; lambda fu: fu', m.UnusedImport)

    def test_usedInSliceObj(self):
        self.flakes('import fu; "meow"[::fu]')

    def test_unusedInNestedScope(self):
        self.flakes('''
        def bar():
            import fu
        fu
        ''', m.UnusedImport, m.UndefinedName)

    def test_methodsDontUseClassScope(self):
        self.flakes('''
        class bar:
            import fu
            def fun(self):
                fu
        ''', m.UnusedImport, m.UndefinedName)

    def test_nestedFunctionsNestScope(self):
        self.flakes('''
        def a():
            def b():
                fu
            import fu
        ''')

    def test_nestedClassAndFunctionScope(self):
        self.flakes('''
        def a():
            import fu
            class b:
                def c(self):
                    print(fu)
        ''')

    def test_importStar(self):
        self.flakes('from fu import *', m.ImportStarUsed)

    def test_packageImport(self):
        """
        If a dotted name is imported and used, no warning is reported.
        """
        self.flakes('''
        import fu.bar
        fu.bar
        ''')

    def test_unusedPackageImport(self):
        """
        If a dotted name is imported and not used, an unused import warning is
        reported.
        """
        self.flakes('import fu.bar', m.UnusedImport)

    def test_duplicateSubmoduleImport(self):
        """
        If a submodule of a package is imported twice, an unused import warning
        and a redefined while unused warning are reported.
        """
        self.flakes('''
        import fu.bar, fu.bar
        fu.bar
        ''', m.RedefinedWhileUnused)
        self.flakes('''
        import fu.bar
        import fu.bar
        fu.bar
        ''', m.RedefinedWhileUnused)

    def test_differentSubmoduleImport(self):
        """
        If two different submodules of a package are imported, no duplicate
        import warning is reported for the package.
        """
        self.flakes('''
        import fu.bar, fu.baz
        fu.bar, fu.baz
        ''')
        self.flakes('''
        import fu.bar
        import fu.baz
        fu.bar, fu.baz
        ''')

    def test_assignRHSFirst(self):
        self.flakes('import fu; fu = fu')
        self.flakes('import fu; fu, bar = fu')
        self.flakes('import fu; [fu, bar] = fu')
        self.flakes('import fu; fu += fu')

    def test_tryingMultipleImports(self):
        self.flakes('''
        try:
            import fu
        except ImportError:
            import bar as fu
        fu
        ''')

    def test_nonGlobalDoesNotRedefine(self):
        self.flakes('''
        import fu
        def a():
            fu = 3
            return fu
        fu
        ''')

    def test_functionsRunLater(self):
        self.flakes('''
        def a():
            fu
        import fu
        ''')

    def test_functionNamesAreBoundNow(self):
        self.flakes('''
        import fu
        def fu():
            fu
        fu
        ''', m.RedefinedWhileUnused)

    def test_ignoreNonImportRedefinitions(self):
        self.flakes('a = 1; a = 2')

    @skip("todo")
    def test_importingForImportError(self):
        self.flakes('''
        try:
            import fu
        except ImportError:
            pass
        ''')

    @skip("todo: requires evaluating attribute access")
    def test_importedInClass(self):
        """Imports in class scope can be used through self."""
        self.flakes('''
        class c:
            import i
            def __init__(self):
                self.i
        ''')

    def test_futureImport(self):
        """__future__ is special."""
        self.flakes('from __future__ import division')
        self.flakes('''
        "docstring is allowed before future import"
        from __future__ import division
        ''')

    def test_futureImportFirst(self):
        """
        __future__ imports must come before anything else.
        """
        self.flakes('''
        x = 5
        from __future__ import division
        ''', m.LateFutureImport)
        self.flakes('''
        from foo import bar
        from __future__ import division
        bar
        ''', m.LateFutureImport)


class TestSpecialAll(TestCase):
    """
    Tests for suppression of unused import warnings by C{__all__}.
    """
    def test_ignoredInFunction(self):
        """
        An C{__all__} definition does not suppress unused import warnings in a
        function scope.
        """
        self.flakes('''
        def foo():
            import bar
            __all__ = ["bar"]
        ''', m.UnusedImport, m.UnusedVariable)

    def test_ignoredInClass(self):
        """
        An C{__all__} definition does not suppress unused import warnings in a
        class scope.
        """
        self.flakes('''
        class foo:
            import bar
            __all__ = ["bar"]
        ''', m.UnusedImport)

    def test_warningSuppressed(self):
        """
        If a name is imported and unused but is named in C{__all__}, no warning
        is reported.
        """
        self.flakes('''
        import foo
        __all__ = ["foo"]
        ''')

    def test_unrecognizable(self):
        """
        If C{__all__} is defined in a way that can't be recognized statically,
        it is ignored.
        """
        self.flakes('''
        import foo
        __all__ = ["f" + "oo"]
        ''', m.UnusedImport)
        self.flakes('''
        import foo
        __all__ = [] + ["foo"]
        ''', m.UnusedImport)

    def test_unboundExported(self):
        """
        If C{__all__} includes a name which is not bound, a warning is emitted.
        """
        self.flakes('''
        __all__ = ["foo"]
        ''', m.UndefinedExport)

        # Skip this in __init__.py though, since the rules there are a little
        # different.
        for filename in ["foo/__init__.py", "__init__.py"]:
            self.flakes('''
            __all__ = ["foo"]
            ''', filename=filename)

    def test_importStarExported(self):
        """
        Do not report undefined if import * is used
        """
        self.flakes('''
        from foolib import *
        __all__ = ["foo"]
        ''', m.ImportStarUsed)

    def test_usedInGenExp(self):
        """
        Using a global in a generator expression results in no warnings.
        """
        self.flakes('import fu; (fu for _ in range(1))')
        self.flakes('import fu; (1 for _ in range(1) if fu)')

    def test_redefinedByGenExp(self):
        """
        Re-using a global name as the loop variable for a generator
        expression results in a redefinition warning.
        """
        self.flakes('import fu; (1 for fu in range(1))',
                    m.RedefinedWhileUnused, m.UnusedImport)

    def test_usedAsDecorator(self):
        """
        Using a global name in a decorator statement results in no warnings,
        but using an undefined name in a decorator statement results in an
        undefined name warning.
        """
        self.flakes('''
        from interior import decorate
        @decorate
        def f():
            return "hello"
        ''')

        self.flakes('''
        from interior import decorate
        @decorate('value')
        def f():
            return "hello"
        ''')

        self.flakes('''
        @decorate
        def f():
            return "hello"
        ''', m.UndefinedName)


class Python26Tests(TestCase):
    """
    Tests for checking of syntax which is valid in PYthon 2.6 and newer.
    """

    @skipIf(version_info < (2, 6), "Python >= 2.6 only")
    def test_usedAsClassDecorator(self):
        """
        Using an imported name as a class decorator results in no warnings,
        but using an undefined name as a class decorator results in an
        undefined name warning.
        """
        self.flakes('''
        from interior import decorate
        @decorate
        class foo:
            pass
        ''')

        self.flakes('''
        from interior import decorate
        @decorate("foo")
        class bar:
            pass
        ''')

        self.flakes('''
        @decorate
        class foo:
            pass
        ''', m.UndefinedName)

########NEW FILE########
__FILENAME__ = test_other
"""
Tests for various Pyflakes behavior.
"""

from sys import version_info

from pyflakes import messages as m
from pyflakes.test.harness import TestCase, skip, skipIf


class Test(TestCase):

    def test_duplicateArgs(self):
        self.flakes('def fu(bar, bar): pass', m.DuplicateArgument)

    @skip("todo: this requires finding all assignments in the function body first")
    def test_localReferencedBeforeAssignment(self):
        self.flakes('''
        a = 1
        def f():
            a; a=1
        f()
        ''', m.UndefinedName)

    def test_redefinedInListComp(self):
        """
        Test that shadowing a variable in a list comprehension raises
        a warning.
        """
        self.flakes('''
        a = 1
        [1 for a, b in [(1, 2)]]
        ''', m.RedefinedInListComp)
        self.flakes('''
        class A:
            a = 1
            [1 for a, b in [(1, 2)]]
        ''', m.RedefinedInListComp)
        self.flakes('''
        def f():
            a = 1
            [1 for a, b in [(1, 2)]]
        ''', m.RedefinedInListComp)
        self.flakes('''
        [1 for a, b in [(1, 2)]]
        [1 for a, b in [(1, 2)]]
        ''')
        self.flakes('''
        for a, b in [(1, 2)]:
            pass
        [1 for a, b in [(1, 2)]]
        ''')

    def test_redefinedInGenerator(self):
        """
        Test that reusing a variable in a generator does not raise
        a warning.
        """
        self.flakes('''
        a = 1
        (1 for a, b in [(1, 2)])
        ''')
        self.flakes('''
        class A:
            a = 1
            list(1 for a, b in [(1, 2)])
        ''')
        self.flakes('''
        def f():
            a = 1
            (1 for a, b in [(1, 2)])
        ''', m.UnusedVariable)
        self.flakes('''
        (1 for a, b in [(1, 2)])
        (1 for a, b in [(1, 2)])
        ''')
        self.flakes('''
        for a, b in [(1, 2)]:
            pass
        (1 for a, b in [(1, 2)])
        ''')

    @skipIf(version_info < (2, 7), "Python >= 2.7 only")
    def test_redefinedInSetComprehension(self):
        """
        Test that reusing a variable in a set comprehension does not raise
        a warning.
        """
        self.flakes('''
        a = 1
        {1 for a, b in [(1, 2)]}
        ''')
        self.flakes('''
        class A:
            a = 1
            {1 for a, b in [(1, 2)]}
        ''')
        self.flakes('''
        def f():
            a = 1
            {1 for a, b in [(1, 2)]}
        ''', m.UnusedVariable)
        self.flakes('''
        {1 for a, b in [(1, 2)]}
        {1 for a, b in [(1, 2)]}
        ''')
        self.flakes('''
        for a, b in [(1, 2)]:
            pass
        {1 for a, b in [(1, 2)]}
        ''')

    @skipIf(version_info < (2, 7), "Python >= 2.7 only")
    def test_redefinedInDictComprehension(self):
        """
        Test that reusing a variable in a dict comprehension does not raise
        a warning.
        """
        self.flakes('''
        a = 1
        {1: 42 for a, b in [(1, 2)]}
        ''')
        self.flakes('''
        class A:
            a = 1
            {1: 42 for a, b in [(1, 2)]}
        ''')
        self.flakes('''
        def f():
            a = 1
            {1: 42 for a, b in [(1, 2)]}
        ''', m.UnusedVariable)
        self.flakes('''
        {1: 42 for a, b in [(1, 2)]}
        {1: 42 for a, b in [(1, 2)]}
        ''')
        self.flakes('''
        for a, b in [(1, 2)]:
            pass
        {1: 42 for a, b in [(1, 2)]}
        ''')

    def test_redefinedFunction(self):
        """
        Test that shadowing a function definition with another one raises a
        warning.
        """
        self.flakes('''
        def a(): pass
        def a(): pass
        ''', m.RedefinedWhileUnused)

    def test_redefinedClassFunction(self):
        """
        Test that shadowing a function definition in a class suite with another
        one raises a warning.
        """
        self.flakes('''
        class A:
            def a(): pass
            def a(): pass
        ''', m.RedefinedWhileUnused)

    def test_redefinedIfElseFunction(self):
        """
        Test that shadowing a function definition twice in an if
        and else block does not raise a warning.
        """
        self.flakes('''
        if True:
            def a(): pass
        else:
            def a(): pass
        ''')

    def test_redefinedIfFunction(self):
        """
        Test that shadowing a function definition within an if block
        raises a warning.
        """
        self.flakes('''
        if True:
            def a(): pass
            def a(): pass
        ''', m.RedefinedWhileUnused)

    def test_redefinedTryExceptFunction(self):
        """
        Test that shadowing a function definition twice in try
        and except block does not raise a warning.
        """
        self.flakes('''
        try:
            def a(): pass
        except:
            def a(): pass
        ''')

    def test_redefinedTryFunction(self):
        """
        Test that shadowing a function definition within a try block
        raises a warning.
        """
        self.flakes('''
        try:
            def a(): pass
            def a(): pass
        except:
            pass
        ''', m.RedefinedWhileUnused)

    def test_redefinedIfElseInListComp(self):
        """
        Test that shadowing a variable in a list comprehension in
        an if and else block does not raise a warning.
        """
        self.flakes('''
        if False:
            a = 1
        else:
            [a for a in '12']
        ''')

    def test_redefinedElseInListComp(self):
        """
        Test that shadowing a variable in a list comprehension in
        an else (or if) block raises a warning.
        """
        self.flakes('''
        if False:
            pass
        else:
            a = 1
            [a for a in '12']
        ''', m.RedefinedInListComp)

    def test_functionDecorator(self):
        """
        Test that shadowing a function definition with a decorated version of
        that function does not raise a warning.
        """
        self.flakes('''
        from somewhere import somedecorator

        def a(): pass
        a = somedecorator(a)
        ''')

    def test_classFunctionDecorator(self):
        """
        Test that shadowing a function definition in a class suite with a
        decorated version of that function does not raise a warning.
        """
        self.flakes('''
        class A:
            def a(): pass
            a = classmethod(a)
        ''')

    @skipIf(version_info < (2, 6), "Python >= 2.6 only")
    def test_modernProperty(self):
        self.flakes("""
        class A:
            @property
            def t(self):
                pass
            @t.setter
            def t(self, value):
                pass
            @t.deleter
            def t(self):
                pass
        """)

    def test_unaryPlus(self):
        """Don't die on unary +."""
        self.flakes('+1')

    def test_undefinedBaseClass(self):
        """
        If a name in the base list of a class definition is undefined, a
        warning is emitted.
        """
        self.flakes('''
        class foo(foo):
            pass
        ''', m.UndefinedName)

    def test_classNameUndefinedInClassBody(self):
        """
        If a class name is used in the body of that class's definition and
        the name is not already defined, a warning is emitted.
        """
        self.flakes('''
        class foo:
            foo
        ''', m.UndefinedName)

    def test_classNameDefinedPreviously(self):
        """
        If a class name is used in the body of that class's definition and
        the name was previously defined in some other way, no warning is
        emitted.
        """
        self.flakes('''
        foo = None
        class foo:
            foo
        ''')

    def test_classRedefinition(self):
        """
        If a class is defined twice in the same module, a warning is emitted.
        """
        self.flakes('''
        class Foo:
            pass
        class Foo:
            pass
        ''', m.RedefinedWhileUnused)

    def test_functionRedefinedAsClass(self):
        """
        If a function is redefined as a class, a warning is emitted.
        """
        self.flakes('''
        def Foo():
            pass
        class Foo:
            pass
        ''', m.RedefinedWhileUnused)

    def test_classRedefinedAsFunction(self):
        """
        If a class is redefined as a function, a warning is emitted.
        """
        self.flakes('''
        class Foo:
            pass
        def Foo():
            pass
        ''', m.RedefinedWhileUnused)

    @skip("todo: Too hard to make this warn but other cases stay silent")
    def test_doubleAssignment(self):
        """
        If a variable is re-assigned to without being used, no warning is
        emitted.
        """
        self.flakes('''
        x = 10
        x = 20
        ''', m.RedefinedWhileUnused)

    def test_doubleAssignmentConditionally(self):
        """
        If a variable is re-assigned within a conditional, no warning is
        emitted.
        """
        self.flakes('''
        x = 10
        if True:
            x = 20
        ''')

    def test_doubleAssignmentWithUse(self):
        """
        If a variable is re-assigned to after being used, no warning is
        emitted.
        """
        self.flakes('''
        x = 10
        y = x * 2
        x = 20
        ''')

    def test_comparison(self):
        """
        If a defined name is used on either side of any of the six comparison
        operators, no warning is emitted.
        """
        self.flakes('''
        x = 10
        y = 20
        x < y
        x <= y
        x == y
        x != y
        x >= y
        x > y
        ''')

    def test_identity(self):
        """
        If a defined name is used on either side of an identity test, no
        warning is emitted.
        """
        self.flakes('''
        x = 10
        y = 20
        x is y
        x is not y
        ''')

    def test_containment(self):
        """
        If a defined name is used on either side of a containment test, no
        warning is emitted.
        """
        self.flakes('''
        x = 10
        y = 20
        x in y
        x not in y
        ''')

    def test_loopControl(self):
        """
        break and continue statements are supported.
        """
        self.flakes('''
        for x in [1, 2]:
            break
        ''')
        self.flakes('''
        for x in [1, 2]:
            continue
        ''')

    def test_ellipsis(self):
        """
        Ellipsis in a slice is supported.
        """
        self.flakes('''
        [1, 2][...]
        ''')

    def test_extendedSlice(self):
        """
        Extended slices are supported.
        """
        self.flakes('''
        x = 3
        [1, 2][x,:]
        ''')

    def test_varAugmentedAssignment(self):
        """
        Augmented assignment of a variable is supported.
        We don't care about var refs.
        """
        self.flakes('''
        foo = 0
        foo += 1
        ''')

    def test_attrAugmentedAssignment(self):
        """
        Augmented assignment of attributes is supported.
        We don't care about attr refs.
        """
        self.flakes('''
        foo = None
        foo.bar += foo.baz
        ''')


class TestUnusedAssignment(TestCase):
    """
    Tests for warning about unused assignments.
    """

    def test_unusedVariable(self):
        """
        Warn when a variable in a function is assigned a value that's never
        used.
        """
        self.flakes('''
        def a():
            b = 1
        ''', m.UnusedVariable)

    def test_unusedVariableAsLocals(self):
        """
        Using locals() it is perfectly valid to have unused variables
        """
        self.flakes('''
        def a():
            b = 1
            return locals()
        ''')

    def test_unusedVariableNoLocals(self):
        """
        Using locals() in wrong scope should not matter
        """
        self.flakes('''
        def a():
            locals()
            def a():
                b = 1
                return
        ''', m.UnusedVariable)

    def test_assignToGlobal(self):
        """
        Assigning to a global and then not using that global is perfectly
        acceptable. Do not mistake it for an unused local variable.
        """
        self.flakes('''
        b = 0
        def a():
            global b
            b = 1
        ''')

    @skipIf(version_info < (3,), 'new in Python 3')
    def test_assignToNonlocal(self):
        """
        Assigning to a nonlocal and then not using that binding is perfectly
        acceptable. Do not mistake it for an unused local variable.
        """
        self.flakes('''
        b = b'0'
        def a():
            nonlocal b
            b = b'1'
        ''')

    def test_assignToMember(self):
        """
        Assigning to a member of another object and then not using that member
        variable is perfectly acceptable. Do not mistake it for an unused
        local variable.
        """
        # XXX: Adding this test didn't generate a failure. Maybe not
        # necessary?
        self.flakes('''
        class b:
            pass
        def a():
            b.foo = 1
        ''')

    def test_assignInForLoop(self):
        """
        Don't warn when a variable in a for loop is assigned to but not used.
        """
        self.flakes('''
        def f():
            for i in range(10):
                pass
        ''')

    def test_assignInListComprehension(self):
        """
        Don't warn when a variable in a list comprehension is
        assigned to but not used.
        """
        self.flakes('''
        def f():
            [None for i in range(10)]
        ''')

    def test_generatorExpression(self):
        """
        Don't warn when a variable in a generator expression is
        assigned to but not used.
        """
        self.flakes('''
        def f():
            (None for i in range(10))
        ''')

    def test_assignmentInsideLoop(self):
        """
        Don't warn when a variable assignment occurs lexically after its use.
        """
        self.flakes('''
        def f():
            x = None
            for i in range(10):
                if i > 2:
                    return x
                x = i * 2
        ''')

    def test_tupleUnpacking(self):
        """
        Don't warn when a variable included in tuple unpacking is unused. It's
        very common for variables in a tuple unpacking assignment to be unused
        in good Python code, so warning will only create false positives.
        """
        self.flakes('''
        def f():
            (x, y) = 1, 2
        ''')

    def test_listUnpacking(self):
        """
        Don't warn when a variable included in list unpacking is unused.
        """
        self.flakes('''
        def f():
            [x, y] = [1, 2]
        ''')

    def test_closedOver(self):
        """
        Don't warn when the assignment is used in an inner function.
        """
        self.flakes('''
        def barMaker():
            foo = 5
            def bar():
                return foo
            return bar
        ''')

    def test_doubleClosedOver(self):
        """
        Don't warn when the assignment is used in an inner function, even if
        that inner function itself is in an inner function.
        """
        self.flakes('''
        def barMaker():
            foo = 5
            def bar():
                def baz():
                    return foo
            return bar
        ''')

    def test_tracebackhideSpecialVariable(self):
        """
        Do not warn about unused local variable __tracebackhide__, which is
        a special variable for py.test.
        """
        self.flakes("""
            def helper():
                __tracebackhide__ = True
        """)

    def test_ifexp(self):
        """
        Test C{foo if bar else baz} statements.
        """
        self.flakes("a = 'moo' if True else 'oink'")
        self.flakes("a = foo if True else 'oink'", m.UndefinedName)
        self.flakes("a = 'moo' if True else bar", m.UndefinedName)

    def test_withStatementNoNames(self):
        """
        No warnings are emitted for using inside or after a nameless C{with}
        statement a name defined beforehand.
        """
        self.flakes('''
        from __future__ import with_statement
        bar = None
        with open("foo"):
            bar
        bar
        ''')

    def test_withStatementSingleName(self):
        """
        No warnings are emitted for using a name defined by a C{with} statement
        within the suite or afterwards.
        """
        self.flakes('''
        from __future__ import with_statement
        with open('foo') as bar:
            bar
        bar
        ''')

    def test_withStatementAttributeName(self):
        """
        No warnings are emitted for using an attribute as the target of a
        C{with} statement.
        """
        self.flakes('''
        from __future__ import with_statement
        import foo
        with open('foo') as foo.bar:
            pass
        ''')

    def test_withStatementSubscript(self):
        """
        No warnings are emitted for using a subscript as the target of a
        C{with} statement.
        """
        self.flakes('''
        from __future__ import with_statement
        import foo
        with open('foo') as foo[0]:
            pass
        ''')

    def test_withStatementSubscriptUndefined(self):
        """
        An undefined name warning is emitted if the subscript used as the
        target of a C{with} statement is not defined.
        """
        self.flakes('''
        from __future__ import with_statement
        import foo
        with open('foo') as foo[bar]:
            pass
        ''', m.UndefinedName)

    def test_withStatementTupleNames(self):
        """
        No warnings are emitted for using any of the tuple of names defined by
        a C{with} statement within the suite or afterwards.
        """
        self.flakes('''
        from __future__ import with_statement
        with open('foo') as (bar, baz):
            bar, baz
        bar, baz
        ''')

    def test_withStatementListNames(self):
        """
        No warnings are emitted for using any of the list of names defined by a
        C{with} statement within the suite or afterwards.
        """
        self.flakes('''
        from __future__ import with_statement
        with open('foo') as [bar, baz]:
            bar, baz
        bar, baz
        ''')

    def test_withStatementComplicatedTarget(self):
        """
        If the target of a C{with} statement uses any or all of the valid forms
        for that part of the grammar (See
        U{http://docs.python.org/reference/compound_stmts.html#the-with-statement}),
        the names involved are checked both for definedness and any bindings
        created are respected in the suite of the statement and afterwards.
        """
        self.flakes('''
        from __future__ import with_statement
        c = d = e = g = h = i = None
        with open('foo') as [(a, b), c[d], e.f, g[h:i]]:
            a, b, c, d, e, g, h, i
        a, b, c, d, e, g, h, i
        ''')

    def test_withStatementSingleNameUndefined(self):
        """
        An undefined name warning is emitted if the name first defined by a
        C{with} statement is used before the C{with} statement.
        """
        self.flakes('''
        from __future__ import with_statement
        bar
        with open('foo') as bar:
            pass
        ''', m.UndefinedName)

    def test_withStatementTupleNamesUndefined(self):
        """
        An undefined name warning is emitted if a name first defined by a the
        tuple-unpacking form of the C{with} statement is used before the
        C{with} statement.
        """
        self.flakes('''
        from __future__ import with_statement
        baz
        with open('foo') as (bar, baz):
            pass
        ''', m.UndefinedName)

    def test_withStatementSingleNameRedefined(self):
        """
        A redefined name warning is emitted if a name bound by an import is
        rebound by the name defined by a C{with} statement.
        """
        self.flakes('''
        from __future__ import with_statement
        import bar
        with open('foo') as bar:
            pass
        ''', m.RedefinedWhileUnused)

    def test_withStatementTupleNamesRedefined(self):
        """
        A redefined name warning is emitted if a name bound by an import is
        rebound by one of the names defined by the tuple-unpacking form of a
        C{with} statement.
        """
        self.flakes('''
        from __future__ import with_statement
        import bar
        with open('foo') as (bar, baz):
            pass
        ''', m.RedefinedWhileUnused)

    def test_withStatementUndefinedInside(self):
        """
        An undefined name warning is emitted if a name is used inside the
        body of a C{with} statement without first being bound.
        """
        self.flakes('''
        from __future__ import with_statement
        with open('foo') as bar:
            baz
        ''', m.UndefinedName)

    def test_withStatementNameDefinedInBody(self):
        """
        A name defined in the body of a C{with} statement can be used after
        the body ends without warning.
        """
        self.flakes('''
        from __future__ import with_statement
        with open('foo') as bar:
            baz = 10
        baz
        ''')

    def test_withStatementUndefinedInExpression(self):
        """
        An undefined name warning is emitted if a name in the I{test}
        expression of a C{with} statement is undefined.
        """
        self.flakes('''
        from __future__ import with_statement
        with bar as baz:
            pass
        ''', m.UndefinedName)

        self.flakes('''
        from __future__ import with_statement
        with bar as bar:
            pass
        ''', m.UndefinedName)

    @skipIf(version_info < (2, 7), "Python >= 2.7 only")
    def test_dictComprehension(self):
        """
        Dict comprehensions are properly handled.
        """
        self.flakes('''
        a = {1: x for x in range(10)}
        ''')

    @skipIf(version_info < (2, 7), "Python >= 2.7 only")
    def test_setComprehensionAndLiteral(self):
        """
        Set comprehensions are properly handled.
        """
        self.flakes('''
        a = {1, 2, 3}
        b = {x for x in range(10)}
        ''')

    def test_exceptionUsedInExcept(self):
        as_exc = ', ' if version_info < (2, 6) else ' as '
        self.flakes('''
        try: pass
        except Exception%se: e
        ''' % as_exc)

        self.flakes('''
        def download_review():
            try: pass
            except Exception%se: e
        ''' % as_exc)

    def test_exceptWithoutNameInFunction(self):
        """
        Don't issue false warning when an unnamed exception is used.
        Previously, there would be a false warning, but only when the
        try..except was in a function
        """
        self.flakes('''
        import tokenize
        def foo():
            try: pass
            except tokenize.TokenError: pass
        ''')

    def test_exceptWithoutNameInFunctionTuple(self):
        """
        Don't issue false warning when an unnamed exception is used.
        This example catches a tuple of exception types.
        """
        self.flakes('''
        import tokenize
        def foo():
            try: pass
            except (tokenize.TokenError, IndentationError): pass
        ''')

    def test_augmentedAssignmentImportedFunctionCall(self):
        """
        Consider a function that is called on the right part of an
        augassign operation to be used.
        """
        self.flakes('''
        from foo import bar
        baz = 0
        baz += bar()
        ''')

    @skipIf(version_info < (3, 3), 'new in Python 3.3')
    def test_yieldFromUndefined(self):
        """
        Test C{yield from} statement
        """
        self.flakes('''
        def bar():
            yield from foo()
        ''', m.UndefinedName)

########NEW FILE########
__FILENAME__ = test_undefined_names

from _ast import PyCF_ONLY_AST
from sys import version_info

from pyflakes import messages as m, checker
from pyflakes.test.harness import TestCase, skip, skipIf


class Test(TestCase):
    def test_undefined(self):
        self.flakes('bar', m.UndefinedName)

    def test_definedInListComp(self):
        self.flakes('[a for a in range(10) if a]')

    def test_functionsNeedGlobalScope(self):
        self.flakes('''
        class a:
            def b():
                fu
        fu = 1
        ''')

    def test_builtins(self):
        self.flakes('range(10)')

    def test_builtinWindowsError(self):
        """
        C{WindowsError} is sometimes a builtin name, so no warning is emitted
        for using it.
        """
        self.flakes('WindowsError')

    def test_magicGlobalsFile(self):
        """
        Use of the C{__file__} magic global should not emit an undefined name
        warning.
        """
        self.flakes('__file__')

    def test_magicGlobalsBuiltins(self):
        """
        Use of the C{__builtins__} magic global should not emit an undefined
        name warning.
        """
        self.flakes('__builtins__')

    def test_magicGlobalsName(self):
        """
        Use of the C{__name__} magic global should not emit an undefined name
        warning.
        """
        self.flakes('__name__')

    def test_magicGlobalsPath(self):
        """
        Use of the C{__path__} magic global should not emit an undefined name
        warning, if you refer to it from a file called __init__.py.
        """
        self.flakes('__path__', m.UndefinedName)
        self.flakes('__path__', filename='package/__init__.py')

    def test_globalImportStar(self):
        """Can't find undefined names with import *."""
        self.flakes('from fu import *; bar', m.ImportStarUsed)

    def test_localImportStar(self):
        """
        A local import * still allows undefined names to be found
        in upper scopes.
        """
        self.flakes('''
        def a():
            from fu import *
        bar
        ''', m.ImportStarUsed, m.UndefinedName)

    @skipIf(version_info >= (3,), 'obsolete syntax')
    def test_unpackedParameter(self):
        """Unpacked function parameters create bindings."""
        self.flakes('''
        def a((bar, baz)):
            bar; baz
        ''')

    @skip("todo")
    def test_definedByGlobal(self):
        """
        "global" can make an otherwise undefined name in another function
        defined.
        """
        self.flakes('''
        def a(): global fu; fu = 1
        def b(): fu
        ''')

    def test_globalInGlobalScope(self):
        """
        A global statement in the global scope is ignored.
        """
        self.flakes('''
        global x
        def foo():
            print(x)
        ''', m.UndefinedName)

    def test_del(self):
        """Del deletes bindings."""
        self.flakes('a = 1; del a; a', m.UndefinedName)

    def test_delGlobal(self):
        """Del a global binding from a function."""
        self.flakes('''
        a = 1
        def f():
            global a
            del a
        a
        ''')

    def test_delUndefined(self):
        """Del an undefined name."""
        self.flakes('del a', m.UndefinedName)

    def test_globalFromNestedScope(self):
        """Global names are available from nested scopes."""
        self.flakes('''
        a = 1
        def b():
            def c():
                a
        ''')

    def test_laterRedefinedGlobalFromNestedScope(self):
        """
        Test that referencing a local name that shadows a global, before it is
        defined, generates a warning.
        """
        self.flakes('''
        a = 1
        def fun():
            a
            a = 2
            return a
        ''', m.UndefinedLocal)

    def test_laterRedefinedGlobalFromNestedScope2(self):
        """
        Test that referencing a local name in a nested scope that shadows a
        global declared in an enclosing scope, before it is defined, generates
        a warning.
        """
        self.flakes('''
            a = 1
            def fun():
                global a
                def fun2():
                    a
                    a = 2
                    return a
        ''', m.UndefinedLocal)

    def test_intermediateClassScopeIgnored(self):
        """
        If a name defined in an enclosing scope is shadowed by a local variable
        and the name is used locally before it is bound, an unbound local
        warning is emitted, even if there is a class scope between the enclosing
        scope and the local scope.
        """
        self.flakes('''
        def f():
            x = 1
            class g:
                def h(self):
                    a = x
                    x = None
                    print(x, a)
            print(x)
        ''', m.UndefinedLocal)

    def test_doubleNestingReportsClosestName(self):
        """
        Test that referencing a local name in a nested scope that shadows a
        variable declared in two different outer scopes before it is defined
        in the innermost scope generates an UnboundLocal warning which
        refers to the nearest shadowed name.
        """
        exc = self.flakes('''
            def a():
                x = 1
                def b():
                    x = 2 # line 5
                    def c():
                        x
                        x = 3
                        return x
                    return x
                return x
        ''', m.UndefinedLocal).messages[0]
        self.assertEqual(exc.message_args, ('x', 5))

    def test_laterRedefinedGlobalFromNestedScope3(self):
        """
        Test that referencing a local name in a nested scope that shadows a
        global, before it is defined, generates a warning.
        """
        self.flakes('''
            def fun():
                a = 1
                def fun2():
                    a
                    a = 1
                    return a
                return a
        ''', m.UndefinedLocal)

    def test_undefinedAugmentedAssignment(self):
        self.flakes(
            '''
            def f(seq):
                a = 0
                seq[a] += 1
                seq[b] /= 2
                c[0] *= 2
                a -= 3
                d += 4
                e[any] = 5
            ''',
            m.UndefinedName,    # b
            m.UndefinedName,    # c
            m.UndefinedName, m.UnusedVariable,  # d
            m.UndefinedName,    # e
        )

    def test_nestedClass(self):
        """Nested classes can access enclosing scope."""
        self.flakes('''
        def f(foo):
            class C:
                bar = foo
                def f(self):
                    return foo
            return C()

        f(123).f()
        ''')

    def test_badNestedClass(self):
        """Free variables in nested classes must bind at class creation."""
        self.flakes('''
        def f():
            class C:
                bar = foo
            foo = 456
            return foo
        f()
        ''', m.UndefinedName)

    def test_definedAsStarArgs(self):
        """Star and double-star arg names are defined."""
        self.flakes('''
        def f(a, *b, **c):
            print(a, b, c)
        ''')

    @skipIf(version_info < (3,), 'new in Python 3')
    def test_definedAsStarUnpack(self):
        """Star names in unpack are defined."""
        self.flakes('''
        a, *b = range(10)
        print(a, b)
        ''')
        self.flakes('''
        *a, b = range(10)
        print(a, b)
        ''')
        self.flakes('''
        a, *b, c = range(10)
        print(a, b, c)
        ''')

    @skipIf(version_info < (3,), 'new in Python 3')
    def test_keywordOnlyArgs(self):
        """Keyword-only arg names are defined."""
        self.flakes('''
        def f(*, a, b=None):
            print(a, b)
        ''')

        self.flakes('''
        import default_b
        def f(*, a, b=default_b):
            print(a, b)
        ''')

    @skipIf(version_info < (3,), 'new in Python 3')
    def test_keywordOnlyArgsUndefined(self):
        """Typo in kwonly name."""
        self.flakes('''
        def f(*, a, b=default_c):
            print(a, b)
        ''', m.UndefinedName)

    @skipIf(version_info < (3,), 'new in Python 3')
    def test_annotationUndefined(self):
        """Undefined annotations."""
        self.flakes('''
        from abc import note1, note2, note3, note4, note5
        def func(a: note1, *args: note2,
                 b: note3=12, **kw: note4) -> note5: pass
        ''')

        self.flakes('''
        def func():
            d = e = 42
            def func(a: {1, d}) -> (lambda c: e): pass
        ''')

    @skipIf(version_info < (3,), 'new in Python 3')
    def test_metaClassUndefined(self):
        self.flakes('''
        from abc import ABCMeta
        class A(metaclass=ABCMeta): pass
        ''')

    def test_definedInGenExp(self):
        """
        Using the loop variable of a generator expression results in no
        warnings.
        """
        self.flakes('(a for a in %srange(10) if a)' %
                    ('x' if version_info < (3,) else ''))

    def test_undefinedWithErrorHandler(self):
        """
        Some compatibility code checks explicitly for NameError.
        It should not trigger warnings.
        """
        self.flakes('''
        try:
            socket_map
        except NameError:
            socket_map = {}
        ''')
        self.flakes('''
        try:
            _memoryview.contiguous
        except (NameError, AttributeError):
            raise RuntimeError("Python >= 3.3 is required")
        ''')
        # If NameError is not explicitly handled, generate a warning
        self.flakes('''
        try:
            socket_map
        except:
            socket_map = {}
        ''', m.UndefinedName)
        self.flakes('''
        try:
            socket_map
        except Exception:
            socket_map = {}
        ''', m.UndefinedName)

    def test_definedInClass(self):
        """
        Defined name for generator expressions and dict/set comprehension.
        """
        self.flakes('''
        class A:
            T = range(10)

            Z = (x for x in T)
            L = [x for x in T]
            B = dict((i, str(i)) for i in T)
        ''')

        if version_info >= (2, 7):
            self.flakes('''
            class A:
                T = range(10)

                X = {x for x in T}
                Y = {x:x for x in T}
            ''')


class NameTests(TestCase):
    """
    Tests for some extra cases of name handling.
    """
    def test_impossibleContext(self):
        """
        A Name node with an unrecognized context results in a RuntimeError being
        raised.
        """
        tree = compile("x = 10", "<test>", "exec", PyCF_ONLY_AST)
        # Make it into something unrecognizable.
        tree.body[0].targets[0].ctx = object()
        self.assertRaises(RuntimeError, checker.Checker, tree)

########NEW FILE########
__FILENAME__ = __main__
from pyflakes.api import main

# python -m pyflakes (with Python >= 2.7)
if __name__ == '__main__':
    main(prog='pyflakes')

########NEW FILE########
__FILENAME__ = Console3
#------------------------------------------------------------------------------
# Console3.py
#   Initialization script for cx_Freeze which manipulates the path so that the
# directory in which the executable is found is searched for extensions but
# no other directory is searched. It also sets the attribute sys.frozen so that
# the Win32 extensions behave as expected.
#------------------------------------------------------------------------------

import os
import sys
import zipimport

sys.frozen = True
sys.path = sys.path[:4]

os.environ["TCL_LIBRARY"] = os.path.join(DIR_NAME, "tcl")
os.environ["TK_LIBRARY"] = os.path.join(DIR_NAME, "tk")

m = __import__("__main__")
importer = zipimport.zipimporter(INITSCRIPT_ZIP_FILE_NAME)
if INITSCRIPT_ZIP_FILE_NAME != SHARED_ZIP_FILE_NAME:
    moduleName = m.__name__
else:
    name, ext = os.path.splitext(os.path.basename(os.path.normcase(FILE_NAME)))
    moduleName = "%s__main__" % name
code = importer.get_code(moduleName)
exec(code, m.__dict__)


########NEW FILE########
__FILENAME__ = ConsoleKeepPath3
#------------------------------------------------------------------------------
# ConsoleKeepPath3.py
#   Initialization script for cx_Freeze which leaves the path alone and does
# not set the sys.frozen attribute.
#------------------------------------------------------------------------------

import sys
import zipimport

m = __import__("__main__")
importer = zipimport.zipimporter(INITSCRIPT_ZIP_FILE_NAME)
code = importer.get_code(m.__name__)
exec(code, m.__dict__)


########NEW FILE########
__FILENAME__ = Console3
#------------------------------------------------------------------------------
# Console3.py
#   Initialization script for cx_Freeze which manipulates the path so that the
# directory in which the executable is found is searched for extensions but
# no other directory is searched. It also sets the attribute sys.frozen so that
# the Win32 extensions behave as expected.
#------------------------------------------------------------------------------

import os
import sys
import zipimport

sys.frozen = True
sys.path = sys.path[:4]

os.environ["TCL_LIBRARY"] = os.path.join(DIR_NAME, "tcl")
os.environ["TK_LIBRARY"] = os.path.join(DIR_NAME, "tk")

m = __import__("__main__")
importer = zipimport.zipimporter(INITSCRIPT_ZIP_FILE_NAME)
if INITSCRIPT_ZIP_FILE_NAME != SHARED_ZIP_FILE_NAME:
    moduleName = m.__name__
else:
    name, ext = os.path.splitext(os.path.basename(os.path.normcase(FILE_NAME)))
    moduleName = "%s__main__" % name
code = importer.get_code(moduleName)
exec(code, m.__dict__)


########NEW FILE########
__FILENAME__ = ConsoleKeepPath3
#------------------------------------------------------------------------------
# ConsoleKeepPath3.py
#   Initialization script for cx_Freeze which leaves the path alone and does
# not set the sys.frozen attribute.
#------------------------------------------------------------------------------

import sys
import zipimport

m = __import__("__main__")
importer = zipimport.zipimporter(INITSCRIPT_ZIP_FILE_NAME)
code = importer.get_code(m.__name__)
exec(code, m.__dict__)


########NEW FILE########
__FILENAME__ = default_config
# The default ``config.py``


def set_prefs(prefs):
    """This function is called before opening the project"""

    # Specify which files and folders to ignore in the project.
    # Changes to ignored resources are not added to the history and
    # VCSs.  Also they are not returned in `Project.get_files()`.
    # Note that ``?`` and ``*`` match all characters but slashes.
    # '*.pyc': matches 'test.pyc' and 'pkg/test.pyc'
    # 'mod*.pyc': matches 'test/mod1.pyc' but not 'mod/1.pyc'
    # '.svn': matches 'pkg/.svn' and all of its children
    # 'build/*.o': matches 'build/lib.o' but not 'build/sub/lib.o'
    # 'build//*.o': matches 'build/lib.o' and 'build/sub/lib.o'
    prefs['ignored_resources'] = ['*.pyc', '*~', '.ropeproject',
                                  '.hg', '.svn', '_svn', '.git', 
                                  '__pycache__']

    # Specifies which files should be considered python files.  It is
    # useful when you have scripts inside your project.  Only files
    # ending with ``.py`` are considered to be python files by
    # default.
    #prefs['python_files'] = ['*.py']

    # Custom source folders:  By default rope searches the project
    # for finding source folders (folders that should be searched
    # for finding modules).  You can add paths to that list.  Note
    # that rope guesses project source folders correctly most of the
    # time; use this if you have any problems.
    # The folders should be relative to project root and use '/' for
    # separating folders regardless of the platform rope is running on.
    # 'src/my_source_folder' for instance.
    #prefs.add('source_folders', 'src')

    # You can extend python path for looking up modules
    #prefs.add('python_path', '~/python/')

    # Should rope save object information or not.
    prefs['save_objectdb'] = True
    prefs['compress_objectdb'] = False

    # If `True`, rope analyzes each module when it is being saved.
    prefs['automatic_soa'] = True
    # The depth of calls to follow in static object analysis
    prefs['soa_followed_calls'] = 0

    # If `False` when running modules or unit tests "dynamic object
    # analysis" is turned off.  This makes them much faster.
    prefs['perform_doa'] = True

    # Rope can check the validity of its object DB when running.
    prefs['validate_objectdb'] = True

    # How many undos to hold?
    prefs['max_history_items'] = 32

    # Shows whether to save history across sessions.
    prefs['save_history'] = True
    prefs['compress_history'] = False

    # Set the number spaces used for indenting.  According to
    # :PEP:`8`, it is best to use 4 spaces.  Since most of rope's
    # unit-tests use 4 spaces it is more reliable, too.
    prefs['indent_size'] = 4

    # Builtin and c-extension modules that are allowed to be imported
    # and inspected by rope.
    prefs['extension_modules'] = []

    # Add all standard c-extensions to extension_modules list.
    prefs['import_dynload_stdmods'] = True

    # If `True` modules with syntax errors are considered to be empty.
    # The default value is `False`; When `False` syntax errors raise
    # `rope.base.exceptions.ModuleSyntaxError` exception.
    prefs['ignore_syntax_errors'] = False

    # If `True`, rope ignores unresolvable imports.  Otherwise, they
    # appear in the importing namespace.
    prefs['ignore_bad_imports'] = False


def project_opened(project):
    """This function is called after opening the project"""
    # Do whatever you like here!

########NEW FILE########
__FILENAME__ = arguments
import rope.base.evaluate
from rope.base import ast


class Arguments(object):
    """A class for evaluating parameters passed to a function

    You can use the `create_arguments` factory.  It handles implicit
    first arguments.

    """

    def __init__(self, args, scope):
        self.args = args
        self.scope = scope
        self.instance = None

    def get_arguments(self, parameters):
        result = []
        for pyname in self.get_pynames(parameters):
            if pyname is None:
                result.append(None)
            else:
                result.append(pyname.get_object())
        return result

    def get_pynames(self, parameters):
        result = [None] * max(len(parameters), len(self.args))
        for index, arg in enumerate(self.args):
            if isinstance(arg, ast.keyword) and arg.arg in parameters:
                result[parameters.index(arg.arg)] = self._evaluate(arg.value)
            else:
                result[index] = self._evaluate(arg)
        return result

    def get_instance_pyname(self):
        if self.args:
            return self._evaluate(self.args[0])

    def _evaluate(self, ast_node):
        return rope.base.evaluate.eval_node(self.scope, ast_node)


def create_arguments(primary, pyfunction, call_node, scope):
    """A factory for creating `Arguments`"""
    args = list(call_node.args)
    args.extend(call_node.keywords)
    called = call_node.func
    # XXX: Handle constructors
    if _is_method_call(primary, pyfunction) and \
       isinstance(called, ast.Attribute):
        args.insert(0, called.value)
    return Arguments(args, scope)


class ObjectArguments(object):

    def __init__(self, pynames):
        self.pynames = pynames

    def get_arguments(self, parameters):
        result = []
        for pyname in self.pynames:
            if pyname is None:
                result.append(None)
            else:
                result.append(pyname.get_object())
        return result

    def get_pynames(self, parameters):
        return self.pynames

    def get_instance_pyname(self):
        return self.pynames[0]
class MixedArguments(object):

    def __init__(self, pyname, arguments, scope):
        """`argumens` is an instance of `Arguments`"""
        self.pyname = pyname
        self.args = arguments

    def get_pynames(self, parameters):
        return [self.pyname] + self.args.get_pynames(parameters[1:])

    def get_arguments(self, parameters):
        result = []
        for pyname in self.get_pynames(parameters):
            if pyname is None:
                result.append(None)
            else:
                result.append(pyname.get_object())
        return result

    def get_instance_pyname(self):
        return self.pyname


def _is_method_call(primary, pyfunction):
    if primary is None:
        return False
    pyobject = primary.get_object()
    if isinstance(pyobject.get_type(), rope.base.pyobjects.PyClass) and \
       isinstance(pyfunction, rope.base.pyobjects.PyFunction) and \
       isinstance(pyfunction.parent, rope.base.pyobjects.PyClass):
        return True
    if isinstance(pyobject.get_type(), rope.base.pyobjects.AbstractClass) and \
       isinstance(pyfunction, rope.base.builtins.BuiltinFunction):
        return True
    return False

########NEW FILE########
__FILENAME__ = ast
import _ast
from _ast import *

from rope.base import fscommands


def parse(source, filename='<string>'):
    # NOTE: the raw string should be given to `compile` function
    if isinstance(source, str):
        source = fscommands.unicode_to_file_data(source)
    source = source.decode()
    if '\r' in source:
        source = source.replace('\r\n', '\n').replace('\r', '\n')
    if not source.endswith('\n'):
        source += '\n'
    try:
        return compile(source.encode(), filename, 'exec', _ast.PyCF_ONLY_AST)
    except (TypeError, ValueError) as e:
        error = SyntaxError()
        error.lineno = 1
        error.filename = filename
        error.msg = str(e)
        raise error


def walk(node, walker):
    """Walk the syntax tree"""
    method_name = '_' + node.__class__.__name__
    method = getattr(walker, method_name, None)
    if method is not None:
        return method(node)
    for child in get_child_nodes(node):
        walk(child, walker)


def get_child_nodes(node):
    if isinstance(node, _ast.Module):
        return node.body
    result = []
    if node._fields is not None:
        for name in node._fields:
            child = getattr(node, name)
            if isinstance(child, list):
                for entry in child:
                    if isinstance(entry, _ast.AST):
                        result.append(entry)
            if isinstance(child, _ast.AST):
                result.append(child)
    return result


def call_for_nodes(node, callback, recursive=False):
    """If callback returns `True` the child nodes are skipped"""
    result = callback(node)
    if recursive and not result:
        for child in get_child_nodes(node):
            call_for_nodes(child, callback, recursive)


def get_children(node):
    result = []
    if node._fields is not None:
        for name in node._fields:
            if name in ['lineno', 'col_offset']:
                continue
            child = getattr(node, name)
            result.append(child)
    return result

########NEW FILE########
__FILENAME__ = astutils
from rope.base import ast


def get_name_levels(node):
    """Return a list of ``(name, level)`` tuples for assigned names

    The `level` is `None` for simple assignments and is a list of
    numbers for tuple assignments for example in::

      a, (b, c) = x

    The levels for for `a` is ``[0]``, for `b` is ``[1, 0]`` and for
    `c` is ``[1, 1]``.

    """
    visitor = _NodeNameCollector()
    ast.walk(node, visitor)
    return visitor.names


class _NodeNameCollector(object):

    def __init__(self, levels=None):
        self.names = []
        self.levels = levels
        self.index = 0

    def _add_node(self, node):
        new_levels = []
        if self.levels is not None:
            new_levels = list(self.levels)
            new_levels.append(self.index)
        self.index += 1
        self._added(node, new_levels)

    def _added(self, node, levels):
        if hasattr(node, 'id'):
            self.names.append((node.id, levels))

    def _Name(self, node):
        self._add_node(node)

    def _Tuple(self, node):
        new_levels = []
        if self.levels is not None:
            new_levels = list(self.levels)
            new_levels.append(self.index)
        self.index += 1
        visitor = _NodeNameCollector(new_levels)
        for child in ast.get_child_nodes(node):
            ast.walk(child, visitor)
        self.names.extend(visitor.names)

    def _Subscript(self, node):
        self._add_node(node)

    def _Attribute(self, node):
        self._add_node(node)

    def _Slice(self, node):
        self._add_node(node)

########NEW FILE########
__FILENAME__ = builtins
"""This module trys to support builtin types and functions."""
import inspect

import rope.base.evaluate
from rope.base import pynames, pyobjects, arguments, utils, ast


class BuiltinModule(pyobjects.AbstractModule):

    def __init__(self, name, pycore=None, initial={}):
        super(BuiltinModule, self).__init__()
        self.name = name
        self.pycore = pycore
        self.initial = initial

    parent = None

    def get_attributes(self):
        return self.attributes

    def get_doc(self):
        if self.module:
            return self.module.__doc__

    def get_name(self):
        return self.name.split('.')[-1]

    @property
    @utils.saveit
    def attributes(self):
        result = _object_attributes(self.module, self)
        result.update(self.initial)
        if self.pycore is not None:
            submodules = self.pycore._builtin_submodules(self.name)
            for name, module in submodules.items():
                result[name] = rope.base.builtins.BuiltinName(module)
        return result

    @property
    @utils.saveit
    def module(self):
        try:
            result = __import__(self.name)
            for token in self.name.split('.')[1:]:
                result = getattr(result, token, None)
            return result
        except ImportError:
            return


class _BuiltinElement(object):

    def __init__(self, builtin, parent=None):
        self.builtin = builtin
        self._parent = parent

    def get_doc(self):
        if self.builtin:
            return getattr(self.builtin, '__doc__', None)

    def get_name(self):
        if self.builtin:
            return getattr(self.builtin, '__name__', None)

    @property
    def parent(self):
        if self._parent is None:
            return builtins
        return self._parent


class BuiltinClass(_BuiltinElement, pyobjects.AbstractClass):

    def __init__(self, builtin, attributes, parent=None):
        _BuiltinElement.__init__(self, builtin, parent)
        pyobjects.AbstractClass.__init__(self)
        self.initial = attributes

    @utils.saveit
    def get_attributes(self):
        result = _object_attributes(self.builtin, self)
        result.update(self.initial)
        return result


class BuiltinFunction(_BuiltinElement, pyobjects.AbstractFunction):

    def __init__(self, returned=None, function=None, builtin=None,
                 argnames=[], parent=None):
        _BuiltinElement.__init__(self, builtin, parent)
        pyobjects.AbstractFunction.__init__(self)
        self.argnames = argnames
        self.returned = returned
        self.function = function

    def get_returned_object(self, args):
        if self.function is not None:
            return self.function(_CallContext(self.argnames, args))
        else:
            return self.returned

    def get_param_names(self, special_args=True):
        return self.argnames

    @utils.saveit
    def get_attributes(self):
        result = _object_attributes(self.builtin.__class__, self)
        return result


class BuiltinUnknown(_BuiltinElement, pyobjects.PyObject):

    def __init__(self, builtin):
        super(BuiltinUnknown, self).__init__(pyobjects.get_unknown())
        self.builtin = builtin
        self.type = pyobjects.get_unknown()

    def get_name(self):
        return getattr(type(self.builtin), '__name__', None)

    @utils.saveit
    def get_attributes(self):
        return _object_attributes(self.builtin, self)


def _object_attributes(obj, parent):
    attributes = {}
    for name in dir(obj):
        if name == 'None':
            continue
        try:
            child = getattr(obj, name)
        except AttributeError:
            # descriptors are allowed to raise AttributeError
            # even if they are in dir()
            continue
        pyobject = None
        if inspect.isclass(child):
            pyobject = BuiltinClass(child, {}, parent=parent)
        elif inspect.isroutine(child):
            if inspect.ismethoddescriptor(child) and "__weakref__" in dir(obj):
                try:
                    weak = child.__get__(obj.__weakref__.__objclass__())
                except:
                    weak = child
                pyobject = BuiltinFunction(builtin=weak, parent=parent)
            else:
                pyobject = BuiltinFunction(builtin=child, parent=parent)
        else:
            pyobject = BuiltinUnknown(builtin=child)
        attributes[name] = BuiltinName(pyobject)
    return attributes


def _create_builtin_type_getter(cls):
    def _get_builtin(*args):
        if not hasattr(cls, '_generated'):
            cls._generated = {}
        if args not in cls._generated:
            cls._generated[args] = cls(*args)
        return cls._generated[args]
    return _get_builtin

def _create_builtin_getter(cls):
    type_getter = _create_builtin_type_getter(cls)
    def _get_builtin(*args):
        return pyobjects.PyObject(type_getter(*args))
    return _get_builtin


class _CallContext(object):

    def __init__(self, argnames, args):
        self.argnames = argnames
        self.args = args

    def _get_scope_and_pyname(self, pyname):
        if pyname is not None and isinstance(pyname, pynames.AssignedName):
            pymodule, lineno = pyname.get_definition_location()
            if pymodule is None:
                return None, None
            if lineno is None:
                lineno = 1
            scope = pymodule.get_scope().get_inner_scope_for_line(lineno)
            name = None
            while name is None and scope is not None:
                for current in scope.get_names():
                    if scope[current] is pyname:
                        name = current
                        break
                else:
                    scope = scope.parent
            return scope, name
        return None, None

    def get_argument(self, name):
        if self.args:
            args = self.args.get_arguments(self.argnames)
            return args[self.argnames.index(name)]

    def get_pyname(self, name):
        if self.args:
            args = self.args.get_pynames(self.argnames)
            if name in self.argnames:
                return args[self.argnames.index(name)]

    def get_arguments(self, argnames):
        if self.args:
            return self.args.get_arguments(argnames)

    def get_pynames(self, argnames):
        if self.args:
            return self.args.get_pynames(argnames)

    def get_per_name(self):
        if self.args is None:
            return None
        pyname = self.args.get_instance_pyname()
        scope, name = self._get_scope_and_pyname(pyname)
        if name is not None:
            pymodule = pyname.get_definition_location()[0]
            return pymodule.pycore.object_info.get_per_name(scope, name)
        return None

    def save_per_name(self, value):
        if self.args is None:
            return None
        pyname = self.args.get_instance_pyname()
        scope, name = self._get_scope_and_pyname(pyname)
        if name is not None:
            pymodule = pyname.get_definition_location()[0]
            pymodule.pycore.object_info.save_per_name(scope, name, value)


class _AttributeCollector(object):

    def __init__(self, type):
        self.attributes = {}
        self.type = type

    def __call__(self, name, returned=None, function=None,
                 argnames=['self'], check_existence=True):
        try:
            builtin = getattr(self.type, name)
        except AttributeError:
            if check_existence:
                raise
            builtin=None
        self.attributes[name] = BuiltinName(
            BuiltinFunction(returned=returned, function=function,
                            argnames=argnames, builtin=builtin))

    def __setitem__(self, name, value):
        self.attributes[name] = value


class List(BuiltinClass):

    def __init__(self, holding=None):
        self.holding = holding
        collector = _AttributeCollector(list)

        collector('__iter__', function=self._iterator_get)
        collector('__new__', function=self._new_list)

        # Adding methods
        collector('append', function=self._list_add, argnames=['self', 'value'])
        collector('__setitem__', function=self._list_add,
                  argnames=['self', 'index', 'value'])
        collector('insert', function=self._list_add,
                  argnames=['self', 'index', 'value'])
        collector('extend', function=self._self_set,
                  argnames=['self', 'iterable'])

        # Getting methods
        collector('__getitem__', function=self._list_get)
        collector('pop', function=self._list_get)

        super(List, self).__init__(list, collector.attributes)

    def _new_list(self, args):
        return _create_builtin(args, get_list)

    def _list_add(self, context):
        if self.holding is not None:
            return
        holding = context.get_argument('value')
        if holding is not None and holding != pyobjects.get_unknown():
            context.save_per_name(holding)

    def _self_set(self, context):
        if self.holding is not None:
            return
        iterable = context.get_pyname('iterable')
        holding = _infer_sequence_for_pyname(iterable)
        if holding is not None and holding != pyobjects.get_unknown():
            context.save_per_name(holding)

    def _list_get(self, context):
        if self.holding is not None:
            args = context.get_arguments(['self', 'key'])
            if len(args) > 1 and args[1] is not None \
                and args[1].get_type() == builtins['slice'].get_object():
                return get_list(self.holding)
            return self.holding
        return context.get_per_name()

    def _iterator_get(self, context):
        return get_iterator(self._list_get(context))

    def _self_get(self, context):
        return get_list(self._list_get(context))


get_list = _create_builtin_getter(List)
get_list_type = _create_builtin_type_getter(List)


class Dict(BuiltinClass):

    def __init__(self, keys=None, values=None):
        self.keys = keys
        self.values = values
        item = get_tuple(self.keys, self.values)
        collector = _AttributeCollector(dict)
        collector('__new__', function=self._new_dict)
        collector('__setitem__', function=self._dict_add)
        collector('popitem', function=self._item_get)
        collector('pop', function=self._value_get)
        collector('get', function=self._key_get)
        collector('keys', function=self._key_list)
        collector('values', function=self._value_list)
        collector('items', function=self._item_list)
        collector('copy', function=self._self_get)
        collector('__getitem__', function=self._value_get)
        collector('__iter__', function=self._key_iter)
        collector('update', function=self._self_set)
        super(Dict, self).__init__(dict, collector.attributes)

    def _new_dict(self, args):
        def do_create(holding=None):
            if holding is None:
                return get_dict()
            type = holding.get_type()
            if isinstance(type, Tuple) and len(type.get_holding_objects()) == 2:
                return get_dict(*type.get_holding_objects())
        return _create_builtin(args, do_create)

    def _dict_add(self, context):
        if self.keys is not None:
            return
        key, value = context.get_arguments(['self', 'key', 'value'])[1:]
        if key is not None and key != pyobjects.get_unknown():
            context.save_per_name(get_tuple(key, value))

    def _item_get(self, context):
        if self.keys is not None:
            return get_tuple(self.keys, self.values)
        item = context.get_per_name()
        if item is None or not isinstance(item.get_type(), Tuple):
            return get_tuple(self.keys, self.values)
        return item

    def _value_get(self, context):
        item = self._item_get(context).get_type()
        return item.get_holding_objects()[1]

    def _key_get(self, context):
        item = self._item_get(context).get_type()
        return item.get_holding_objects()[0]

    def _value_list(self, context):
        return get_list(self._value_get(context))

    def _key_list(self, context):
        return get_list(self._key_get(context))

    def _item_list(self, context):
        return get_list(self._item_get(context))

    def _value_iter(self, context):
        return get_iterator(self._value_get(context))

    def _key_iter(self, context):
        return get_iterator(self._key_get(context))

    def _item_iter(self, context):
        return get_iterator(self._item_get(context))

    def _self_get(self, context):
        item = self._item_get(context).get_type()
        key, value = item.get_holding_objects()[:2]
        return get_dict(key, value)

    def _self_set(self, context):
        if self.keys is not None:
            return
        new_dict = context.get_pynames(['self', 'd'])[1]
        if new_dict and isinstance(new_dict.get_object().get_type(), Dict):
            args = arguments.ObjectArguments([new_dict])
            items = new_dict.get_object()['popitem'].\
                    get_object().get_returned_object(args)
            context.save_per_name(items)
        else:
            holding = _infer_sequence_for_pyname(new_dict)
            if holding is not None and isinstance(holding.get_type(), Tuple):
                context.save_per_name(holding)


get_dict = _create_builtin_getter(Dict)
get_dict_type = _create_builtin_type_getter(Dict)


class Tuple(BuiltinClass):

    def __init__(self, *objects):
        self.objects = objects
        first = None
        if objects:
            first = objects[0]
        attributes = {
            '__getitem__': BuiltinName(BuiltinFunction(first)),
            '__getslice__': BuiltinName(BuiltinFunction(pyobjects.PyObject(self))),
            '__new__': BuiltinName(BuiltinFunction(function=self._new_tuple)),
            '__iter__': BuiltinName(BuiltinFunction(get_iterator(first)))}
        super(Tuple, self).__init__(tuple, attributes)

    def get_holding_objects(self):
        return self.objects

    def _new_tuple(self, args):
        return _create_builtin(args, get_tuple)


get_tuple = _create_builtin_getter(Tuple)
get_tuple_type = _create_builtin_type_getter(Tuple)


class Set(BuiltinClass):

    def __init__(self, holding=None):
        self.holding = holding
        collector = _AttributeCollector(set)
        collector('__new__', function=self._new_set)

        self_methods = ['copy', 'difference', 'intersection',
                        'symmetric_difference', 'union']
        for method in self_methods:
            collector(method, function=self._self_get)
        collector('add', function=self._set_add)
        collector('update', function=self._self_set)
        collector('update', function=self._self_set)
        collector('symmetric_difference_update', function=self._self_set)
        collector('difference_update', function=self._self_set)

        collector('pop', function=self._set_get)
        collector('__iter__', function=self._iterator_get)
        super(Set, self).__init__(set, collector.attributes)

    def _new_set(self, args):
        return _create_builtin(args, get_set)

    def _set_add(self, context):
        if self.holding is not None:
            return
        holding = context.get_arguments(['self', 'value'])[1]
        if holding is not None and holding != pyobjects.get_unknown():
            context.save_per_name(holding)

    def _self_set(self, context):
        if self.holding is not None:
            return
        iterable = context.get_pyname('iterable')
        holding = _infer_sequence_for_pyname(iterable)
        if holding is not None and holding != pyobjects.get_unknown():
            context.save_per_name(holding)

    def _set_get(self, context):
        if self.holding is not None:
            return self.holding
        return context.get_per_name()

    def _iterator_get(self, context):
        return get_iterator(self._set_get(context))

    def _self_get(self, context):
        return get_list(self._set_get(context))


get_set = _create_builtin_getter(Set)
get_set_type = _create_builtin_type_getter(Set)


class Str(BuiltinClass):

    def __init__(self):
        self_object = pyobjects.PyObject(self)
        collector = _AttributeCollector(str)
        collector('__iter__', get_iterator(self_object), check_existence=False)

        self_methods = ['__getitem__', 'capitalize', 'center',
                        'encode', 'expandtabs', 'join', 'ljust',
                        'lower', 'lstrip', 'replace', 'rjust', 'rstrip', 'strip',
                        'swapcase', 'title', 'translate', 'upper', 'zfill']
        for method in self_methods:
            collector(method, self_object)

        for method in ['rsplit', 'split', 'splitlines']:
            collector(method, get_list(self_object))

        super(Str, self).__init__(str, collector.attributes)

    def get_doc(self):
        return str.__doc__


get_str = _create_builtin_getter(Str)
get_str_type = _create_builtin_type_getter(Str)


class BuiltinName(pynames.PyName):

    def __init__(self, pyobject):
        self.pyobject = pyobject

    def get_object(self):
        return self.pyobject

    def get_definition_location(self):
        return (None, None)

class Iterator(pyobjects.AbstractClass):

    def __init__(self, holding=None):
        super(Iterator, self).__init__()
        self.holding = holding
        self.attributes = {
            'next': BuiltinName(BuiltinFunction(self.holding)),
            '__iter__': BuiltinName(BuiltinFunction(self))}

    def get_attributes(self):
        return self.attributes

    def get_returned_object(self, args):
        return self.holding

get_iterator = _create_builtin_getter(Iterator)


class Generator(pyobjects.AbstractClass):

    def __init__(self, holding=None):
        super(Generator, self).__init__()
        self.holding = holding
        self.attributes = {
            'next': BuiltinName(BuiltinFunction(self.holding)),
            '__iter__': BuiltinName(BuiltinFunction(get_iterator(self.holding))),
            'close': BuiltinName(BuiltinFunction()),
            'send': BuiltinName(BuiltinFunction()),
            'throw': BuiltinName(BuiltinFunction())}

    def get_attributes(self):
        return self.attributes

    def get_returned_object(self, args):
        return self.holding

get_generator = _create_builtin_getter(Generator)


class File(BuiltinClass):

    def __init__(self):
        self_object = pyobjects.PyObject(self)
        str_object = get_str()
        str_list = get_list(get_str())
        attributes = {}
        def add(name, returned=None, function=None):
            builtin = getattr(open, name, None)
            attributes[name] = BuiltinName(
                BuiltinFunction(returned=returned, function=function,
                                builtin=builtin))
        add('__iter__', get_iterator(str_object))
        for method in ['next', 'read', 'readline', 'readlines']:
            add(method, str_list)
        for method in ['close', 'flush', 'lineno', 'isatty', 'seek', 'tell',
                       'truncate', 'write', 'writelines']:
            add(method)
        super(File, self).__init__(open, attributes)


get_file = _create_builtin_getter(File)
get_file_type = _create_builtin_type_getter(File)


class Property(BuiltinClass):

    def __init__(self, fget=None, fset=None, fdel=None, fdoc=None):
        self._fget = fget
        self._fdoc = fdoc
        attributes = {
            'fget': BuiltinName(BuiltinFunction()),
            'fset': BuiltinName(pynames.UnboundName()),
            'fdel': BuiltinName(pynames.UnboundName()),
            '__new__': BuiltinName(BuiltinFunction(function=_property_function))}
        super(Property, self).__init__(property, attributes)

    def get_property_object(self, args):
        if isinstance(self._fget, pyobjects.AbstractFunction):
            return self._fget.get_returned_object(args)


def _property_function(args):
    parameters = args.get_arguments(['fget', 'fset', 'fdel', 'fdoc'])
    return pyobjects.PyObject(Property(parameters[0]))


class Lambda(pyobjects.AbstractFunction):

    def __init__(self, node, scope):
        super(Lambda, self).__init__()
        self.node = node
        self.arguments = node.args
        self.scope = scope

    def get_returned_object(self, args):
        result = rope.base.evaluate.eval_node(self.scope, self.node.body)
        if result is not None:
            return result.get_object()
        else:
            return pyobjects.get_unknown()

    def get_module(self):
        return self.parent.get_module()

    def get_scope(self):
        return self.scope

    def get_kind(self):
        return 'lambda'

    def get_ast(self):
        return self.node

    def get_attributes(self):
        return {}

    def get_name(self):
        return  'lambda'

    def get_param_names(self, special_args=True):
        result = [node.arg for node in self.arguments.args
                  if isinstance(node, ast.arg)]
        if self.arguments.vararg:
            result.append('*' + self.arguments.vararg)
        if self.arguments.kwarg:
            result.append('**' + self.arguments.kwarg)
        return result

    @property
    def parent(self):
        return self.scope.pyobject


class BuiltinObject(BuiltinClass):

    def __init__(self):
        super(BuiltinObject, self).__init__(object, {})


class BuiltinType(BuiltinClass):

    def __init__(self):
        super(BuiltinType, self).__init__(type, {})


def _infer_sequence_for_pyname(pyname):
    if pyname is None:
        return None
    seq = pyname.get_object()
    args = arguments.ObjectArguments([pyname])
    if '__iter__' in seq:
        obj = seq['__iter__'].get_object()
        if not isinstance(obj, pyobjects.AbstractFunction):
            return None
        iter = obj.get_returned_object(args)
        if iter is not None and 'next' in iter:
            holding = iter['next'].get_object().\
                      get_returned_object(args)
            return holding


def _create_builtin(args, creator):
    passed = args.get_pynames(['sequence'])[0]
    if passed is None:
        holding = None
    else:
        holding = _infer_sequence_for_pyname(passed)
    if holding is not None:
        return creator(holding)
    else:
        return creator()


def _range_function(args):
    return get_list()

def _reversed_function(args):
    return _create_builtin(args, get_iterator)

def _sorted_function(args):
    return _create_builtin(args, get_list)

def _super_function(args):
    passed_class, passed_self = args.get_arguments(['type', 'self'])
    if passed_self is None:
        return passed_class
    else:
        #pyclass = passed_self.get_type()
        pyclass = passed_class
        if isinstance(pyclass, pyobjects.AbstractClass):
            supers = pyclass.get_superclasses()
            if supers:
                return pyobjects.PyObject(supers[0])
        return passed_self

def _zip_function(args):
    args = args.get_pynames(['sequence'])
    objects = []
    for seq in args:
        if seq is None:
            holding = None
        else:
            holding = _infer_sequence_for_pyname(seq)
        objects.append(holding)
    tuple = get_tuple(*objects)
    return get_list(tuple)

def _enumerate_function(args):
    passed = args.get_pynames(['sequence'])[0]
    if passed is None:
        holding = None
    else:
        holding = _infer_sequence_for_pyname(passed)
    tuple = get_tuple(None, holding)
    return get_iterator(tuple)

def _iter_function(args):
    passed = args.get_pynames(['sequence'])[0]
    if passed is None:
        holding = None
    else:
        holding = _infer_sequence_for_pyname(passed)
    return get_iterator(holding)

def _input_function(args):
    return get_str()


_initial_builtins = {
    'list': BuiltinName(get_list_type()),
    'dict': BuiltinName(get_dict_type()),
    'tuple': BuiltinName(get_tuple_type()),
    'set': BuiltinName(get_set_type()),
    'str': BuiltinName(get_str_type()),
    'file': BuiltinName(get_file_type()),
    'open': BuiltinName(get_file_type()),
    'unicode': BuiltinName(get_str_type()),
    'range': BuiltinName(BuiltinFunction(function=_range_function, builtin=range)),
    'reversed': BuiltinName(BuiltinFunction(function=_reversed_function, builtin=reversed)),
    'sorted': BuiltinName(BuiltinFunction(function=_sorted_function, builtin=sorted)),
    'super': BuiltinName(BuiltinFunction(function=_super_function, builtin=super)),
    'property': BuiltinName(BuiltinFunction(function=_property_function, builtin=property)),
    'zip': BuiltinName(BuiltinFunction(function=_zip_function, builtin=zip)),
    'enumerate': BuiltinName(BuiltinFunction(function=_enumerate_function, builtin=enumerate)),
    'object': BuiltinName(BuiltinObject()),
    'type': BuiltinName(BuiltinType()),
    'iter': BuiltinName(BuiltinFunction(function=_iter_function, builtin=iter)),
    'input': BuiltinName(BuiltinFunction(function=_input_function, builtin=input)),
    }

builtins = BuiltinModule('builtins', initial=_initial_builtins)

########NEW FILE########
__FILENAME__ = change
import datetime
import difflib
import os
import time
import warnings

import rope.base.fscommands
from rope.base import taskhandle, exceptions, utils


class Change(object):
    """The base class for changes

    Rope refactorings return `Change` objects.  They can be previewed,
    committed or undone.
    """

    def do(self, job_set=None):
        """Perform the change
        
        .. note:: Do use this directly.  Use `Project.do()` instead.
        """

    def undo(self, job_set=None):
        """Perform the change
        
        .. note:: Do use this directly.  Use `History.undo()` instead.
        """

    def get_description(self):
        """Return the description of this change

        This can be used for previewing the changes.
        """
        return str(self)

    def get_changed_resources(self):
        """Return the list of resources that will be changed"""
        return []

    @property
    @utils.saveit
    def _operations(self):
        return _ResourceOperations(self.resource.project)


class ChangeSet(Change):
    """A collection of `Change` objects

    This class holds a collection of changes.  This class provides
    these fields:

    * `changes`: the list of changes
    * `description`: the goal of these changes
    """

    def __init__(self, description, timestamp=None):
        self.changes = []
        self.description = description
        self.time = timestamp

    def do(self, job_set=taskhandle.NullJobSet()):
        try:
            done = []
            for change in self.changes:
                change.do(job_set)
                done.append(change)
            self.time = time.time()
        except Exception:
            for change in done:
                change.undo()
            raise

    def undo(self, job_set=taskhandle.NullJobSet()):
        try:
            done = []
            for change in reversed(self.changes):
                change.undo(job_set)
                done.append(change)
        except Exception:
            for change in done:
                change.do()
            raise

    def add_change(self, change):
        self.changes.append(change)

    def get_description(self):
        result = [str(self) + ':\n\n\n']
        for change in self.changes:
            result.append(change.get_description())
            result.append('\n')
        return ''.join(result)

    def __str__(self):
        if self.time is not None:
            date = datetime.datetime.fromtimestamp(self.time)
            if date.date() == datetime.date.today():
                string_date = 'today'
            elif date.date() == (datetime.date.today() - datetime.timedelta(1)):
                string_date = 'yesterday'
            elif date.year == datetime.date.today().year:
                string_date = date.strftime('%b %d')
            else:
                string_date = date.strftime('%d %b, %Y')
            string_time = date.strftime('%H:%M:%S')
            string_time = '%s %s ' % (string_date, string_time)
            return self.description + ' - ' + string_time
        return self.description

    def get_changed_resources(self):
        result = set()
        for change in self.changes:
            result.update(change.get_changed_resources())
        return result


def _handle_job_set(function):
    """A decorator for handling `taskhandle.JobSet`\s

    A decorator for handling `taskhandle.JobSet`\s for `do` and `undo`
    methods of `Change`\s.
    """
    def call(self, job_set=taskhandle.NullJobSet()):
        job_set.started_job(str(self))
        function(self)
        job_set.finished_job()
    return call


class ChangeContents(Change):
    """A class to change the contents of a file

    Fields:

    * `resource`: The `rope.base.resources.File` to change
    * `new_contents`: What to write in the file
    """

    def __init__(self, resource, new_contents, old_contents=None):
        self.resource = resource
        # IDEA: Only saving diffs; possible problems when undo/redoing
        self.new_contents = new_contents
        self.old_contents = old_contents

    @_handle_job_set
    def do(self):
        if self.old_contents is None:
            self.old_contents = self.resource.read()
        self._operations.write_file(self.resource, self.new_contents)

    @_handle_job_set
    def undo(self):
        if self.old_contents is None:
            raise exceptions.HistoryError(
                'Undoing a change that is not performed yet!')
        self._operations.write_file(self.resource, self.old_contents)

    def __str__(self):
        return 'Change <%s>' % self.resource.path

    def get_description(self):
        new = self.new_contents
        old = self.old_contents
        if old is None:
            if self.resource.exists():
                old = self.resource.read()
            else:
                old = ''
        result = difflib.unified_diff(
            old.splitlines(True), new.splitlines(True),
            'a/' + self.resource.path, 'b/' + self.resource.path)
        return ''.join(list(result))

    def get_changed_resources(self):
        return [self.resource]


class MoveResource(Change):
    """Move a resource to a new location

    Fields:

    * `resource`: The `rope.base.resources.Resource` to move
    * `new_resource`: The destination for move; It is the moved
      resource not the folder containing that resource.
    """

    def __init__(self, resource, new_location, exact=False):
        self.project = resource.project
        self.resource = resource
        if not exact:
            new_location = _get_destination_for_move(resource, new_location)
        if resource.is_folder():
            self.new_resource = self.project.get_folder(new_location)
        else:
            self.new_resource = self.project.get_file(new_location)

    @_handle_job_set
    def do(self):
        self._operations.move(self.resource, self.new_resource)

    @_handle_job_set
    def undo(self):
        self._operations.move(self.new_resource, self.resource)

    def __str__(self):
        return 'Move <%s>' % self.resource.path

    def get_description(self):
        return 'rename from %s\nrename to %s' % (self.resource.path,
                                                 self.new_resource.path)

    def get_changed_resources(self):
        return [self.resource, self.new_resource]


class CreateResource(Change):
    """A class to create a resource

    Fields:

    * `resource`: The resource to create
    """

    def __init__(self, resource):
        self.resource = resource

    @_handle_job_set
    def do(self):
        self._operations.create(self.resource)

    @_handle_job_set
    def undo(self):
        self._operations.remove(self.resource)

    def __str__(self):
        return 'Create Resource <%s>' % (self.resource.path)

    def get_description(self):
        return 'new file %s' % (self.resource.path)

    def get_changed_resources(self):
        return [self.resource]

    def _get_child_path(self, parent, name):
        if parent.path == '':
            return name
        else:
            return parent.path + '/' + name


class CreateFolder(CreateResource):
    """A class to create a folder

    See docs for `CreateResource`.
    """

    def __init__(self, parent, name):
        resource = parent.project.get_folder(self._get_child_path(parent, name))
        super(CreateFolder, self).__init__(resource)


class CreateFile(CreateResource):
    """A class to create a file

    See docs for `CreateResource`.
    """

    def __init__(self, parent, name):
        resource = parent.project.get_file(self._get_child_path(parent, name))
        super(CreateFile, self).__init__(resource)


class RemoveResource(Change):
    """A class to remove a resource

    Fields:

    * `resource`: The resource to be removed
    """

    def __init__(self, resource):
        self.resource = resource

    @_handle_job_set
    def do(self):
        self._operations.remove(self.resource)

    # TODO: Undoing remove operations
    @_handle_job_set
    def undo(self):
        raise NotImplementedError(
            'Undoing `RemoveResource` is not implemented yet.')

    def __str__(self):
        return 'Remove <%s>' % (self.resource.path)

    def get_changed_resources(self):
        return [self.resource]


def count_changes(change):
    """Counts the number of basic changes a `Change` will make"""
    if isinstance(change, ChangeSet):
        result = 0
        for child in change.changes:
            result += count_changes(child)
        return result
    return 1

def create_job_set(task_handle, change):
    return task_handle.create_jobset(str(change), count_changes(change))


class _ResourceOperations(object):

    def __init__(self, project):
        self.project = project
        self.fscommands = project.fscommands
        self.direct_commands = rope.base.fscommands.FileSystemCommands()

    def _get_fscommands(self, resource):
        if self.project.is_ignored(resource):
            return self.direct_commands
        return self.fscommands

    def write_file(self, resource, contents):
        data = rope.base.fscommands.unicode_to_file_data(contents)
        fscommands = self._get_fscommands(resource)
        fscommands.write(resource.real_path, data)
        for observer in list(self.project.observers):
            observer.resource_changed(resource)

    def move(self, resource, new_resource):
        fscommands = self._get_fscommands(resource)
        fscommands.move(resource.real_path, new_resource.real_path)
        for observer in list(self.project.observers):
            observer.resource_moved(resource, new_resource)

    def create(self, resource):
        if resource.is_folder():
            self._create_resource(resource.path, kind='folder')
        else:
            self._create_resource(resource.path)
        for observer in list(self.project.observers):
            observer.resource_created(resource)

    def remove(self, resource):
        fscommands = self._get_fscommands(resource)
        fscommands.remove(resource.real_path)
        for observer in list(self.project.observers):
            observer.resource_removed(resource)

    def _create_resource(self, file_name, kind='file'):
        resource_path = self.project._get_resource_path(file_name)
        if os.path.exists(resource_path):
            raise exceptions.RopeError('Resource <%s> already exists'
                                       % resource_path)
        resource = self.project.get_file(file_name)
        if not resource.parent.exists():
            raise exceptions.ResourceNotFoundError(
                'Parent folder of <%s> does not exist' % resource.path)
        fscommands = self._get_fscommands(resource)
        try:
            if kind == 'file':
                fscommands.create_file(resource_path)
            else:
                fscommands.create_folder(resource_path)
        except IOError as e:
            raise exceptions.RopeError(e)


def _get_destination_for_move(resource, destination):
    dest_path = resource.project._get_resource_path(destination)
    if os.path.isdir(dest_path):
        if destination != '':
            return destination + '/' + resource.name
        else:
            return resource.name
    return destination


class ChangeToData(object):

    def convertChangeSet(self, change):
        description = change.description
        changes = []
        for child in change.changes:
            changes.append(self(child))
        return (description, changes, change.time)

    def convertChangeContents(self, change):
        return (change.resource.path, change.new_contents, change.old_contents)

    def convertMoveResource(self, change):
        return (change.resource.path, change.new_resource.path)

    def convertCreateResource(self, change):
        return (change.resource.path, change.resource.is_folder())

    def convertRemoveResource(self, change):
        return (change.resource.path, change.resource.is_folder())

    def __call__(self, change):
        change_type = type(change)
        if change_type in (CreateFolder, CreateFile):
            change_type = CreateResource
        method = getattr(self, 'convert' + change_type.__name__)
        return (change_type.__name__, method(change))


class DataToChange(object):

    def __init__(self, project):
        self.project = project

    def makeChangeSet(self, description, changes, time=None):
        result = ChangeSet(description, time)
        for child in changes:
            result.add_change(self(child))
        return result

    def makeChangeContents(self, path, new_contents, old_contents):
        resource = self.project.get_file(path)
        return ChangeContents(resource, new_contents, old_contents)

    def makeMoveResource(self, old_path, new_path):
        resource = self.project.get_file(old_path)
        return MoveResource(resource, new_path, exact=True)

    def makeCreateResource(self, path, is_folder):
        if is_folder:
            resource = self.project.get_folder(path)
        else:
            resource = self.project.get_file(path)
        return CreateResource(resource)

    def makeRemoveResource(self, path, is_folder):
        if is_folder:
            resource = self.project.get_folder(path)
        else:
            resource = self.project.get_file(path)
        return RemoveResource(resource)

    def __call__(self, data):
        method = getattr(self, 'make' + data[0])
        return method(*data[1])

########NEW FILE########
__FILENAME__ = codeanalyze
import bisect
import re
import token
import tokenize


class ChangeCollector(object):

    def __init__(self, text):
        self.text = text
        self.changes = []

    def add_change(self, start, end, new_text=None):
        if new_text is None:
            new_text = self.text[start:end]
        self.changes.append((start, end, new_text))

    def get_changed(self):
        if not self.changes:
            return None
        def compare_changes(change1, change2):
            return cmp(change1[:2], change2[:2])
        self.changes.sort(key=lambda change: change[:2])
        pieces = []
        last_changed = 0
        for change in self.changes:
            start, end, text = change
            pieces.append(self.text[last_changed:start] + text)
            last_changed = end
        if last_changed < len(self.text):
            pieces.append(self.text[last_changed:])
        result = ''.join(pieces)
        if result != self.text:
            return result


class SourceLinesAdapter(object):
    """Adapts source to Lines interface

    Note: The creation of this class is expensive.
    """

    def __init__(self, source_code):
        self.code = source_code
        self.starts = None
        self._initialize_line_starts()

    def _initialize_line_starts(self):
        self.starts = []
        self.starts.append(0)
        try:
            i = 0
            while True:
                i = self.code.index('\n', i) + 1
                self.starts.append(i)
        except ValueError:
            pass
        self.starts.append(len(self.code) + 1)

    def get_line(self, lineno):
        return self.code[self.starts[lineno - 1]:
                         self.starts[lineno] - 1]

    def length(self):
        return len(self.starts) - 1

    def get_line_number(self, offset):
        return bisect.bisect(self.starts, offset)

    def get_line_start(self, lineno):
        return self.starts[lineno - 1]

    def get_line_end(self, lineno):
        return self.starts[lineno] - 1


class ArrayLinesAdapter(object):

    def __init__(self, lines):
        self.lines = lines

    def get_line(self, line_number):
        return self.lines[line_number - 1]

    def length(self):
        return len(self.lines)


class LinesToReadline(object):

    def __init__(self, lines, start):
        self.lines = lines
        self.current = start

    def readline(self):
        if self.current <= self.lines.length():
            self.current += 1
            return self.lines.get_line(self.current - 1) + '\n'
        return ''

    def __call__(self):
        return self.readline()


class _CustomGenerator(object):

    def __init__(self, lines):
        self.lines = lines
        self.in_string = ''
        self.open_count = 0
        self.continuation = False

    def __call__(self):
        size = self.lines.length()
        result = []
        i = 1
        while i <= size:
            while i <= size and not self.lines.get_line(i).strip():
                i += 1
            if i <= size:
                start = i
                while True:
                    line = self.lines.get_line(i)
                    self._analyze_line(line)
                    if not (self.continuation or self.open_count or
                            self.in_string) or i == size:
                        break
                    i += 1
                result.append((start, i))
                i += 1
        return result

    _main_chars = re.compile(r'[\'|"|#|\\|\[|\]|\{|\}|\(|\)]')
    def _analyze_line(self, line):
        char = None
        for match in self._main_chars.finditer(line):
            char = match.group()
            i = match.start()
            if char in '\'"':
                if not self.in_string:
                    self.in_string = char
                    if char * 3 == line[i:i + 3]:
                        self.in_string = char * 3
                elif self.in_string == line[i:i + len(self.in_string)] and \
                     not (i > 0 and line[i - 1] == '\\' and
                          not (i > 1 and line[i - 2] == '\\')):
                    self.in_string = ''
            if self.in_string:
                continue
            if char == '#':
                break
            if char in '([{':
                self.open_count += 1
            elif char in ')]}':
                self.open_count -= 1
        if line and char != '#' and line.endswith('\\'):
            self.continuation = True
        else:
            self.continuation = False

def custom_generator(lines):
    return _CustomGenerator(lines)()


class LogicalLineFinder(object):

    def __init__(self, lines):
        self.lines = lines

    def logical_line_in(self, line_number):
        indents = count_line_indents(self.lines.get_line(line_number))
        tries = 0
        while True:
            block_start = get_block_start(self.lines, line_number, indents)
            try:
                return self._block_logical_line(block_start, line_number)
            except IndentationError as e:
                tries += 1
                if tries == 5:
                    raise e
                lineno = e.lineno + block_start - 1
                indents = count_line_indents(self.lines.get_line(lineno))

    def generate_starts(self, start_line=1, end_line=None):
        for start, end in self.generate_regions(start_line, end_line):
            yield start

    def generate_regions(self, start_line=1, end_line=None):
        # XXX: `block_start` should be at a better position!
        block_start = 1
        readline = LinesToReadline(self.lines, block_start)
        shifted = start_line - block_start + 1
        try:
            for start, end in self._logical_lines(readline):
                real_start = start + block_start - 1
                real_start = self._first_non_blank(real_start)
                if end_line is not None and real_start >= end_line:
                    break
                real_end = end + block_start - 1
                if real_start >= start_line:
                    yield (real_start, real_end)
        except tokenize.TokenError as e:
            pass

    def _block_logical_line(self, block_start, line_number):
        readline = LinesToReadline(self.lines, block_start)
        shifted = line_number - block_start + 1
        region = self._calculate_logical(readline, shifted)
        start = self._first_non_blank(region[0] + block_start - 1)
        if region[1] is None:
            end = self.lines.length()
        else:
            end = region[1] + block_start - 1
        return start, end

    def _calculate_logical(self, readline, line_number):
        last_end = 1
        try:
            for start, end in self._logical_lines(readline):
                if line_number <= end:
                    return (start, end)
                last_end = end + 1
        except tokenize.TokenError as e:
            current = e.args[1][0]
            return (last_end, max(last_end, current - 1))
        return (last_end, None)

    def _logical_lines(self, readline):
        last_end = 1
        for current_token in tokenize.generate_tokens(readline):
            current = current_token[2][0]
            if current_token[0] == token.NEWLINE:
                yield (last_end, current)
                last_end = current + 1

    def _first_non_blank(self, line_number):
        current = line_number
        while current < self.lines.length():
            line = self.lines.get_line(current).strip()
            if line and not line.startswith('#'):
                return current
            current += 1
        return current


def tokenizer_generator(lines):
    return LogicalLineFinder(lines).generate_regions()


class CachingLogicalLineFinder(object):

    def __init__(self, lines, generate=custom_generator):
        self.lines = lines
        self._generate = generate

    _starts = None
    @property
    def starts(self):
        if self._starts is None:
            self._init_logicals()
        return self._starts

    _ends = None
    @property
    def ends(self):
        if self._ends is None:
            self._init_logicals()
        return self._ends

    def _init_logicals(self):
        """Should initialize _starts and _ends attributes"""
        size = self.lines.length() + 1
        self._starts = [None] * size
        self._ends = [None] * size
        for start, end in self._generate(self.lines):
            self._starts[start] = True
            self._ends[end] = True

    def logical_line_in(self, line_number):
        start = line_number
        while start > 0 and not self.starts[start]:
            start -= 1
        if start == 0:
            try:
                start = self.starts.index(True, line_number)
            except ValueError:
                return (line_number, line_number)
        return (start, self.ends.index(True, start))

    def generate_starts(self, start_line=1, end_line=None):
        if end_line is None:
            end_line = self.lines.length()
        for index in range(start_line, end_line):
            if self.starts[index]:
                yield index


def get_block_start(lines, lineno, maximum_indents=80):
    """Approximate block start"""
    pattern = get_block_start_patterns()
    for i in range(lineno, 0, -1):
        match = pattern.search(lines.get_line(i))
        if match is not None and \
           count_line_indents(lines.get_line(i)) <= maximum_indents:
            striped = match.string.lstrip()
            # Maybe we're in a list comprehension or generator expression
            if i > 1 and striped.startswith('if') or striped.startswith('for'):
                bracs = 0
                for j in range(i, min(i + 5, lines.length() + 1)):
                    for c in lines.get_line(j):
                        if c == '#':
                            break
                        if c in '[(':
                            bracs += 1
                        if c in ')]':
                            bracs -= 1
                            if bracs < 0:
                                break
                    if bracs < 0:
                        break
                if bracs < 0:
                    continue
            return i
    return 1


_block_start_pattern = None

def get_block_start_patterns():
    global _block_start_pattern
    if not _block_start_pattern:
        pattern = '^\\s*(((def|class|if|elif|except|for|while|with)\\s)|'\
                  '((try|else|finally|except)\\s*:))'
        _block_start_pattern = re.compile(pattern, re.M)
    return _block_start_pattern


def count_line_indents(line):
    indents = 0
    for char in line:
        if char == ' ':
            indents += 1
        elif char == '\t':
            indents += 8
        else:
            return indents
    return 0


def get_string_pattern():
    start = r'(\b[uU]?[rR]?)?'
    longstr = r'%s"""(\\.|"(?!"")|\\\n|[^"\\])*"""' % start
    shortstr = r'%s"(\\.|[^"\\\n])*"' % start
    return '|'.join([longstr, longstr.replace('"', "'"),
                     shortstr, shortstr.replace('"', "'")])

def get_comment_pattern():
    return r'#[^\n]*'

########NEW FILE########
__FILENAME__ = default_config
# The default ``config.py``


def set_prefs(prefs):
    """This function is called before opening the project"""

    # Specify which files and folders to ignore in the project.
    # Changes to ignored resources are not added to the history and
    # VCSs.  Also they are not returned in `Project.get_files()`.
    # Note that ``?`` and ``*`` match all characters but slashes.
    # '*.pyc': matches 'test.pyc' and 'pkg/test.pyc'
    # 'mod*.pyc': matches 'test/mod1.pyc' but not 'mod/1.pyc'
    # '.svn': matches 'pkg/.svn' and all of its children
    # 'build/*.o': matches 'build/lib.o' but not 'build/sub/lib.o'
    # 'build//*.o': matches 'build/lib.o' and 'build/sub/lib.o'
    prefs['ignored_resources'] = ['*.pyc', '*~', '.ropeproject',
                                  '.hg', '.svn', '_svn', '.git', 
                                  '__pycache__']

    # Specifies which files should be considered python files.  It is
    # useful when you have scripts inside your project.  Only files
    # ending with ``.py`` are considered to be python files by
    # default.
    #prefs['python_files'] = ['*.py']

    # Custom source folders:  By default rope searches the project
    # for finding source folders (folders that should be searched
    # for finding modules).  You can add paths to that list.  Note
    # that rope guesses project source folders correctly most of the
    # time; use this if you have any problems.
    # The folders should be relative to project root and use '/' for
    # separating folders regardless of the platform rope is running on.
    # 'src/my_source_folder' for instance.
    #prefs.add('source_folders', 'src')

    # You can extend python path for looking up modules
    #prefs.add('python_path', '~/python/')

    # Should rope save object information or not.
    prefs['save_objectdb'] = True
    prefs['compress_objectdb'] = False

    # If `True`, rope analyzes each module when it is being saved.
    prefs['automatic_soa'] = True
    # The depth of calls to follow in static object analysis
    prefs['soa_followed_calls'] = 0

    # If `False` when running modules or unit tests "dynamic object
    # analysis" is turned off.  This makes them much faster.
    prefs['perform_doa'] = True

    # Rope can check the validity of its object DB when running.
    prefs['validate_objectdb'] = True

    # How many undos to hold?
    prefs['max_history_items'] = 32

    # Shows whether to save history across sessions.
    prefs['save_history'] = True
    prefs['compress_history'] = False

    # Set the number spaces used for indenting.  According to
    # :PEP:`8`, it is best to use 4 spaces.  Since most of rope's
    # unit-tests use 4 spaces it is more reliable, too.
    prefs['indent_size'] = 4

    # Builtin and c-extension modules that are allowed to be imported
    # and inspected by rope.
    prefs['extension_modules'] = []

    # Add all standard c-extensions to extension_modules list.
    prefs['import_dynload_stdmods'] = True

    # If `True` modules with syntax errors are considered to be empty.
    # The default value is `False`; When `False` syntax errors raise
    # `rope.base.exceptions.ModuleSyntaxError` exception.
    prefs['ignore_syntax_errors'] = False

    # If `True`, rope ignores unresolvable imports.  Otherwise, they
    # appear in the importing namespace.
    prefs['ignore_bad_imports'] = False


def project_opened(project):
    """This function is called after opening the project"""
    # Do whatever you like here!

########NEW FILE########
__FILENAME__ = evaluate
import rope.base.builtins
import rope.base.pynames
import rope.base.pyobjects
from rope.base import ast, astutils, exceptions, pyobjects, arguments, worder


BadIdentifierError = exceptions.BadIdentifierError

def eval_location(pymodule, offset):
    """Find the pyname at the offset"""
    return eval_location2(pymodule, offset)[1]


def eval_location2(pymodule, offset):
    """Find the primary and pyname at offset"""
    pyname_finder = ScopeNameFinder(pymodule)
    return pyname_finder.get_primary_and_pyname_at(offset)


def eval_node(scope, node):
    """Evaluate a `ast.AST` node and return a PyName

    Return `None` if the expression cannot be evaluated.
    """
    return eval_node2(scope, node)[1]


def eval_node2(scope, node):
    evaluator = StatementEvaluator(scope)
    ast.walk(node, evaluator)
    return evaluator.old_result, evaluator.result


def eval_str(holding_scope, name):
    return eval_str2(holding_scope, name)[1]


def eval_str2(holding_scope, name):
    try:
        # parenthesizing for handling cases like 'a_var.\nattr'
        node = ast.parse('(%s)' % name)
    except SyntaxError:
        raise BadIdentifierError('Not a resolvable python identifier selected.')
    return eval_node2(holding_scope, node)


class ScopeNameFinder(object):

    def __init__(self, pymodule):
        self.module_scope = pymodule.get_scope()
        self.lines = pymodule.lines
        self.worder = worder.Worder(pymodule.source_code, True)

    def _is_defined_in_class_body(self, holding_scope, offset, lineno):
        if lineno == holding_scope.get_start() and \
           holding_scope.parent is not None and \
           holding_scope.parent.get_kind() == 'Class' and \
           self.worder.is_a_class_or_function_name_in_header(offset):
            return True
        if lineno != holding_scope.get_start() and \
           holding_scope.get_kind() == 'Class' and \
           self.worder.is_name_assigned_in_class_body(offset):
            return True
        return False

    def _is_function_name_in_function_header(self, scope, offset, lineno):
        if scope.get_start() <= lineno <= scope.get_body_start() and \
           scope.get_kind() == 'Function' and \
           self.worder.is_a_class_or_function_name_in_header(offset):
            return True
        return False

    def get_pyname_at(self, offset):
        return self.get_primary_and_pyname_at(offset)[1]

    def get_primary_and_pyname_at(self, offset):
        lineno = self.lines.get_line_number(offset)
        holding_scope = self.module_scope.get_inner_scope_for_line(lineno)
        # function keyword parameter
        if self.worder.is_function_keyword_parameter(offset):
            keyword_name = self.worder.get_word_at(offset)
            pyobject = self.get_enclosing_function(offset)
            if isinstance(pyobject, pyobjects.PyFunction):
                return (None, pyobject.get_parameters().get(keyword_name, None))
        # class body
        if self._is_defined_in_class_body(holding_scope, offset, lineno):
            class_scope = holding_scope
            if lineno == holding_scope.get_start():
                class_scope = holding_scope.parent
            name = self.worder.get_primary_at(offset).strip()
            try:
                return (None, class_scope.pyobject[name])
            except rope.base.exceptions.AttributeNotFoundError:
                return (None, None)
        # function header
        if self._is_function_name_in_function_header(holding_scope, offset, lineno):
            name = self.worder.get_primary_at(offset).strip()
            return (None, holding_scope.parent[name])
        # from statement module
        if self.worder.is_from_statement_module(offset):
            module = self.worder.get_primary_at(offset)
            module_pyname = self._find_module(module)
            return (None, module_pyname)
        if self.worder.is_from_aliased(offset):
            name = self.worder.get_from_aliased(offset)
        else:
            name = self.worder.get_primary_at(offset)
        return eval_str2(holding_scope, name)

    def get_enclosing_function(self, offset):
        function_parens = self.worder.find_parens_start_from_inside(offset)
        try:
            function_pyname = self.get_pyname_at(function_parens - 1)
        except BadIdentifierError:
            function_pyname = None
        if function_pyname is not None:
            pyobject = function_pyname.get_object()
            if isinstance(pyobject, pyobjects.AbstractFunction):
                return pyobject
            elif isinstance(pyobject, pyobjects.AbstractClass) and \
                 '__init__' in pyobject:
                return pyobject['__init__'].get_object()
            elif '__call__' in pyobject:
                return pyobject['__call__'].get_object()
        return None

    def _find_module(self, module_name):
        dots = 0
        while module_name[dots] == '.':
            dots += 1
        return rope.base.pynames.ImportedModule(
            self.module_scope.pyobject, module_name[dots:], dots)


class StatementEvaluator(object):

    def __init__(self, scope):
        self.scope = scope
        self.result = None
        self.old_result = None

    def _Name(self, node):
        self.result = self.scope.lookup(node.id)

    def _Attribute(self, node):
        pyname = eval_node(self.scope, node.value)
        if pyname is None:
            pyname = rope.base.pynames.UnboundName()
        self.old_result = pyname
        if pyname.get_object() != rope.base.pyobjects.get_unknown():
            try:
                self.result = pyname.get_object()[node.attr]
            except exceptions.AttributeNotFoundError:
                self.result = None

    def _Call(self, node):
        primary, pyobject = self._get_primary_and_object_for_node(node.func)
        if pyobject is None:
            return
        def _get_returned(pyobject):
            args = arguments.create_arguments(primary, pyobject,
                                              node, self.scope)
            return pyobject.get_returned_object(args)
        if isinstance(pyobject, rope.base.pyobjects.AbstractClass):
            result = None
            if '__new__' in pyobject:
                new_function = pyobject['__new__'].get_object()
                result = _get_returned(new_function)
            if result is None or \
               result == rope.base.pyobjects.get_unknown():
                result = rope.base.pyobjects.PyObject(pyobject)
            self.result = rope.base.pynames.UnboundName(pyobject=result)
            return

        pyfunction = None
        if isinstance(pyobject, rope.base.pyobjects.AbstractFunction):
            pyfunction = pyobject
        elif '__call__' in pyobject:
            pyfunction = pyobject['__call__'].get_object()
        if pyfunction is not None:
            self.result = rope.base.pynames.UnboundName(
                pyobject=_get_returned(pyfunction))

    def _Str(self, node):
        self.result = rope.base.pynames.UnboundName(
            pyobject=rope.base.builtins.get_str())

    def _Num(self, node):
        type_name = type(node.n).__name__
        self.result = self._get_builtin_name(type_name)

    def _get_builtin_name(self, type_name):
        pytype = rope.base.builtins.builtins[type_name].get_object()
        return rope.base.pynames.UnboundName(
            rope.base.pyobjects.PyObject(pytype))

    def _BinOp(self, node):
        self.result = rope.base.pynames.UnboundName(
            self._get_object_for_node(node.left))

    def _BoolOp(self, node):
        pyobject = self._get_object_for_node(node.values[0])
        if pyobject is None:
            pyobject = self._get_object_for_node(node.values[1])
        self.result = rope.base.pynames.UnboundName(pyobject)

    def _Repr(self, node):
        self.result = self._get_builtin_name('str')

    def _UnaryOp(self, node):
        self.result = rope.base.pynames.UnboundName(
            self._get_object_for_node(node.operand))

    def _Compare(self, node):
        self.result = self._get_builtin_name('bool')

    def _Dict(self, node):
        keys = None
        values = None
        if node.keys:
            keys = self._get_object_for_node(node.keys[0])
            values = self._get_object_for_node(node.values[0])
        self.result = rope.base.pynames.UnboundName(
            pyobject=rope.base.builtins.get_dict(keys, values))

    def _List(self, node):
        holding = None
        if node.elts:
            holding = self._get_object_for_node(node.elts[0])
        self.result = rope.base.pynames.UnboundName(
            pyobject=rope.base.builtins.get_list(holding))

    def _ListComp(self, node):
        pyobject = self._what_does_comprehension_hold(node)
        self.result = rope.base.pynames.UnboundName(
            pyobject=rope.base.builtins.get_list(pyobject))

    def _GeneratorExp(self, node):
        pyobject = self._what_does_comprehension_hold(node)
        self.result = rope.base.pynames.UnboundName(
            pyobject=rope.base.builtins.get_iterator(pyobject))

    def _what_does_comprehension_hold(self, node):
        scope = self._make_comprehension_scope(node)
        pyname = eval_node(scope, node.elt)
        return pyname.get_object() if pyname is not None else None

    def _make_comprehension_scope(self, node):
        scope = self.scope
        module = scope.pyobject.get_module()
        names = {}
        for comp in node.generators:
            new_names = _get_evaluated_names(comp.target, comp.iter, module,
                                             '.__iter__().next()', node.lineno)
            names.update(new_names)
        return rope.base.pyscopes.TemporaryScope(scope.pycore, scope, names)

    def _Tuple(self, node):
        objects = []
        if len(node.elts) < 4:
            for stmt in node.elts:
                pyobject = self._get_object_for_node(stmt)
                objects.append(pyobject)
        else:
            objects.append(self._get_object_for_node(node.elts[0]))
        self.result = rope.base.pynames.UnboundName(
            pyobject=rope.base.builtins.get_tuple(*objects))

    def _get_object_for_node(self, stmt):
        pyname = eval_node(self.scope, stmt)
        pyobject = None
        if pyname is not None:
            pyobject = pyname.get_object()
        return pyobject

    def _get_primary_and_object_for_node(self, stmt):
        primary, pyname = eval_node2(self.scope, stmt)
        pyobject = None
        if pyname is not None:
            pyobject = pyname.get_object()
        return primary, pyobject

    def _Subscript(self, node):
        if isinstance(node.slice, ast.Index):
            self._call_function(node.value, '__getitem__',
                                [node.slice.value])
        elif isinstance(node.slice, ast.Slice):
            self._call_function(node.value, '__getitem__', 
                                [node.slice])

    def _Slice(self, node):
        self.result = self._get_builtin_name('slice')

    def _call_function(self, node, function_name, other_args=None):
        pyname = eval_node(self.scope, node)
        if pyname is not None:
            pyobject = pyname.get_object()
        else:
            return
        if function_name in pyobject:
            called = pyobject[function_name].get_object()
            if not called or not isinstance(called, pyobjects.AbstractFunction):
                return
            args = [node]
            if other_args:
                args += other_args
            arguments_ = arguments.Arguments(args, self.scope)
            self.result = rope.base.pynames.UnboundName(
                pyobject=called.get_returned_object(arguments_))

    def _Lambda(self, node):
        self.result = rope.base.pynames.UnboundName(
            pyobject=rope.base.builtins.Lambda(node, self.scope))


def _get_evaluated_names(targets, assigned, module, evaluation, lineno):
    result = {}
    for name, levels in astutils.get_name_levels(targets):
        assignment = rope.base.pynames.AssignmentValue(assigned, levels,
                                                       evaluation)
        # XXX: this module should not access `rope.base.pynamesdef`!
        pyname = rope.base.pynamesdef.AssignedName(lineno, module)
        pyname.assignments.append(assignment)
        result[name] = pyname
    return result

########NEW FILE########
__FILENAME__ = exceptions
class RopeError(Exception):
    """Base exception for rope"""


class ResourceNotFoundError(RopeError):
    """Resource not found exception"""


class RefactoringError(RopeError):
    """Errors for performing a refactoring"""


class InterruptedTaskError(RopeError):
    """The task has been interrupted"""


class HistoryError(RopeError):
    """Errors for history undo/redo operations"""


class ModuleNotFoundError(RopeError):
    """Module not found exception"""


class AttributeNotFoundError(RopeError):
    """Attribute not found exception"""


class NameNotFoundError(RopeError):
    """Name not found exception"""


class BadIdentifierError(RopeError):
    """The name cannot be resolved"""


class ModuleSyntaxError(RopeError):
    """Module has syntax errors

    The `filename` and `lineno` fields indicate where the error has
    occurred.

    """

    def __init__(self, filename, lineno, message):
        self.filename = filename
        self.lineno = lineno
        self.message_ = message
        super(ModuleSyntaxError, self).__init__(
            'Syntax error in file <%s> line <%s>: %s' %
            (filename, lineno, message))


class ModuleDecodeError(RopeError):
    """Cannot decode module"""

    def __init__(self, filename, message):
        self.filename = filename
        self.message_ = message
        super(ModuleDecodeError, self).__init__(
            'Cannot decode file <%s>: %s' % (filename, message))

########NEW FILE########
__FILENAME__ = fscommands
"""Project file system commands.

This modules implements file system operations used by rope.  Different
version control systems can be supported by implementing the interface
provided by `FileSystemCommands` class.  See `SubversionCommands` and
`MercurialCommands` for example.

"""
import os, re
import shutil
import subprocess


def create_fscommands(root):
    dirlist = os.listdir(root)
    commands = {'.hg': MercurialCommands,
                '.svn': SubversionCommands,
                '.git': GITCommands,
                '_svn': SubversionCommands,
                '_darcs': DarcsCommands}
    for key in commands:
        if key in dirlist:
            try:
                return commands[key](root)
            except (ImportError, OSError):
                pass
    return FileSystemCommands()


class FileSystemCommands(object):

    def create_file(self, path):
        open(path, 'w').close()

    def create_folder(self, path):
        os.mkdir(path)

    def move(self, path, new_location):
        shutil.move(path, new_location)

    def remove(self, path):
        if os.path.isfile(path):
            os.remove(path)
        else:
            shutil.rmtree(path)

    def write(self, path, data):
        file_ = open(path, 'wb')
        try:
            file_.write(data)
        finally:
            file_.close()


class SubversionCommands(object):

    def __init__(self, *args):
        self.normal_actions = FileSystemCommands()
        import pysvn
        self.client = pysvn.Client()

    def create_file(self, path):
        self.normal_actions.create_file(path)
        self.client.add(path, force=True)

    def create_folder(self, path):
        self.normal_actions.create_folder(path)
        self.client.add(path, force=True)

    def move(self, path, new_location):
        self.client.move(path, new_location, force=True)

    def remove(self, path):
        self.client.remove(path, force=True)

    def write(self, path, data):
        self.normal_actions.write(path, data)


class MercurialCommands(object):

    def __init__(self, root):
        self.hg = self._import_mercurial()
        self.normal_actions = FileSystemCommands()
        try:
            self.ui = self.hg.ui.ui(
                verbose=False, debug=False, quiet=True,
                interactive=False, traceback=False, report_untrusted=False)
        except:
            self.ui = self.hg.ui.ui()
            self.ui.setconfig('ui', 'interactive', 'no')
            self.ui.setconfig('ui', 'debug', 'no')
            self.ui.setconfig('ui', 'traceback', 'no')
            self.ui.setconfig('ui', 'verbose', 'no')
            self.ui.setconfig('ui', 'report_untrusted', 'no')
            self.ui.setconfig('ui', 'quiet', 'yes')

        self.repo = self.hg.hg.repository(self.ui, root)

    def _import_mercurial(self):
        import mercurial.commands
        import mercurial.hg
        import mercurial.ui
        return mercurial

    def create_file(self, path):
        self.normal_actions.create_file(path)
        self.hg.commands.add(self.ui, self.repo, path)

    def create_folder(self, path):
        self.normal_actions.create_folder(path)

    def move(self, path, new_location):
        self.hg.commands.rename(self.ui, self.repo, path,
                                new_location, after=False)

    def remove(self, path):
        self.hg.commands.remove(self.ui, self.repo, path)

    def write(self, path, data):
        self.normal_actions.write(path, data)


class GITCommands(object):

    def __init__(self, root):
        self.root = root
        self._do(['version'])
        self.normal_actions = FileSystemCommands()

    def create_file(self, path):
        self.normal_actions.create_file(path)
        self._do(['add', self._in_dir(path)])

    def create_folder(self, path):
        self.normal_actions.create_folder(path)

    def move(self, path, new_location):
        self._do(['mv', self._in_dir(path), self._in_dir(new_location)])

    def remove(self, path):
        self._do(['rm', self._in_dir(path)])

    def write(self, path, data):
        # XXX: should we use ``git add``?
        self.normal_actions.write(path, data)

    def _do(self, args):
        _execute(['git'] + args, cwd=self.root)

    def _in_dir(self, path):
        if path.startswith(self.root):
            return path[len(self.root) + 1:]
        return self.root


class DarcsCommands(object):

    def __init__(self, root):
        self.root = root
        self.normal_actions = FileSystemCommands()

    def create_file(self, path):
        self.normal_actions.create_file(path)
        self._do(['add', path])

    def create_folder(self, path):
        self.normal_actions.create_folder(path)
        self._do(['add', path])

    def move(self, path, new_location):
        self._do(['mv', path, new_location])

    def remove(self, path):
        self.normal_actions.remove(path)

    def write(self, path, data):
        self.normal_actions.write(path, data)

    def _do(self, args):
        _execute(['darcs'] + args, cwd=self.root)


def _execute(args, cwd=None):
    process = subprocess.Popen(args, cwd=cwd, stdout=subprocess.PIPE)
    process.wait()
    return process.returncode


def unicode_to_file_data(contents, encoding=None):
    if not isinstance(contents, str):
        return contents
    if encoding is None:
        encoding = read_str_coding(contents)
    if encoding is not None:
        return contents.encode(encoding)
    try:
        return contents.encode()
    except UnicodeEncodeError:
        return contents.encode('utf-8')

def file_data_to_unicode(data, encoding=None):
    result = _decode_data(data, encoding)
    if '\r' in result:
        result = result.replace('\r\n', '\n').replace('\r', '\n')
    return result

def _decode_data(data, encoding):
    if isinstance(data, str):
        return data
    if encoding is None:
        encoding = read_str_coding(data)
    if encoding is None:
        # there is no encoding tip, we need to guess.
        # PEP263 says that "encoding not explicitly defined" means it is ascii,
        # but we will use utf8 instead since utf8 fully covers ascii and btw is
        # the only non-latin sane encoding.
        encoding = 'utf-8'
    try:
        return data.decode(encoding)
    except (UnicodeError, LookupError):
        # fallback to utf-8: it should never fail
        return data.decode('utf-8')


def read_file_coding(path):
    file = open(path, 'b')
    count = 0
    result = []
    buffsize = 10
    while True:
        current = file.read(10)
        if not current:
            break
        count += current.count('\n')
        result.append(current)
    file.close()
    return _find_coding(''.join(result))


def read_str_coding(source):
    if not isinstance(source, str):
        source = source.decode("utf-8", "ignore")
    #TODO: change it to precompiled version
    mex = re.search("\-\*\-\s+coding:\s+(.*?)\s+\-\*\-", source)
    if mex:
        return mex.group(1)
    return "utf-8"

def _find_coding(text):
    coding = 'coding'
    try:
        start = text.index(coding) + len(coding)
        if text[start] not in '=:':
            return
        start += 1
        while start < len(text) and text[start].isspace():
            start += 1
        end = start
        while end < len(text):
            c = text[end]
            if not c.isalnum() and c not in '-_':
                break
            end += 1
        return text[start:end]
    except ValueError:
        pass

########NEW FILE########
__FILENAME__ = history
from rope.base import exceptions, change, taskhandle


class History(object):
    """A class that holds project history"""

    def __init__(self, project, maxundos=None):
        self.project = project
        self._undo_list = []
        self._redo_list = []
        self._maxundos = maxundos
        self._load_history()
        self.project.data_files.add_write_hook(self.write)
        self.current_change = None

    def _load_history(self):
        if self.save:
            result = self.project.data_files.read_data(
                'history', compress=self.compress, import_=True)
            if result is not None:
                to_change = change.DataToChange(self.project)
                for data in result[0]:
                    self._undo_list.append(to_change(data))
                for data in result[1]:
                    self._redo_list.append(to_change(data))

    def do(self, changes, task_handle=taskhandle.NullTaskHandle()):
        """Perform the change and add it to the `self.undo_list`

        Note that uninteresting changes (changes to ignored files)
        will not be appended to `self.undo_list`.

        """
        try:
            self.current_change = changes
            changes.do(change.create_job_set(task_handle, changes))
        finally:
            self.current_change = None
        if self._is_change_interesting(changes):
            self.undo_list.append(changes)
            self._remove_extra_items()
        del self.redo_list[:]

    def _remove_extra_items(self):
        if len(self.undo_list) > self.max_undos:
            del self.undo_list[0:len(self.undo_list) - self.max_undos]

    def _is_change_interesting(self, changes):
        for resource in changes.get_changed_resources():
            if not self.project.is_ignored(resource):
                return True
        return False

    def undo(self, change=None, drop=False,
             task_handle=taskhandle.NullTaskHandle()):
        """Redo done changes from the history

        When `change` is `None`, the last done change will be undone.
        If change is not `None` it should be an item from
        `self.undo_list`; this change and all changes that depend on
        it will be undone.  In both cases the list of undone changes
        will be returned.

        If `drop` is `True`, the undone change will not be appended to
        the redo list.

        """
        if not self._undo_list:
            raise exceptions.HistoryError('Undo list is empty')
        if change is None:
            change = self.undo_list[-1]
        dependencies = self._find_dependencies(self.undo_list, change)
        self._move_front(self.undo_list, dependencies)
        self._perform_undos(len(dependencies), task_handle)
        result = self.redo_list[-len(dependencies):]
        if drop:
            del self.redo_list[-len(dependencies):]
        return result

    def redo(self, change=None, task_handle=taskhandle.NullTaskHandle()):
        """Redo undone changes from the history

        When `change` is `None`, the last undone change will be
        redone.  If change is not `None` it should be an item from
        `self.redo_list`; this change and all changes that depend on
        it will be redone.  In both cases the list of redone changes
        will be returned.

        """
        if not self.redo_list:
            raise exceptions.HistoryError('Redo list is empty')
        if change is None:
            change = self.redo_list[-1]
        dependencies = self._find_dependencies(self.redo_list, change)
        self._move_front(self.redo_list, dependencies)
        self._perform_redos(len(dependencies), task_handle)
        return self.undo_list[-len(dependencies):]

    def _move_front(self, change_list, changes):
        for change in changes:
            change_list.remove(change)
            change_list.append(change)

    def _find_dependencies(self, change_list, change):
        index = change_list.index(change)
        return _FindChangeDependencies(change_list[index:])()

    def _perform_undos(self, count, task_handle):
        for i in range(count):
            self.current_change = self.undo_list[-1]
            try:
                job_set = change.create_job_set(task_handle,
                                                self.current_change)
                self.current_change.undo(job_set)
            finally:
                self.current_change = None
            self.redo_list.append(self.undo_list.pop())

    def _perform_redos(self, count, task_handle):
        for i in range(count):
            self.current_change = self.redo_list[-1]
            try:
                job_set = change.create_job_set(task_handle,
                                                self.current_change)
                self.current_change.do(job_set)
            finally:
                self.current_change = None
            self.undo_list.append(self.redo_list.pop())

    def contents_before_current_change(self, file):
        if self.current_change is None:
            return None
        result = self._search_for_change_contents([self.current_change], file)
        if result is not None:
            return result
        if file.exists() and not file.is_folder():
            return file.read()
        else:
            return None

    def _search_for_change_contents(self, change_list, file):
        for change_ in reversed(change_list):
            if isinstance(change_, change.ChangeSet):
                result = self._search_for_change_contents(change_.changes,
                                                          file)
                if result is not None:
                    return result
            if isinstance(change_, change.ChangeContents) and \
               change_.resource == file:
                return change_.old_contents

    def write(self):
        if self.save:
            data = []
            to_data = change.ChangeToData()
            self._remove_extra_items()
            data.append([to_data(change_) for change_ in self.undo_list])
            data.append([to_data(change_) for change_ in self.redo_list])
            self.project.data_files.write_data('history', data,
                                               compress=self.compress)

    def get_file_undo_list(self, resource):
        result = []
        for change in self.undo_list:
            if resource in change.get_changed_resources():
                result.append(change)
        return result

    def __str__(self):
        return 'History holds %s changes in memory' % \
               (len(self.undo_list) + len(self.redo_list))

    undo_list = property(lambda self: self._undo_list)
    redo_list = property(lambda self: self._redo_list)

    @property
    def tobe_undone(self):
        """The last done change if available, `None` otherwise"""
        if self.undo_list:
            return self.undo_list[-1]

    @property
    def tobe_redone(self):
        """The last undone change if available, `None` otherwise"""
        if self.redo_list:
            return self.redo_list[-1]

    @property
    def max_undos(self):
        if self._maxundos is None:
            return self.project.prefs.get('max_history_items', 100)
        else:
            return self._maxundos

    @property
    def save(self):
        return self.project.prefs.get('save_history', False)

    @property
    def compress(self):
        return self.project.prefs.get('compress_history', False)

    def clear(self):
        """Forget all undo and redo information"""
        del self.undo_list[:]
        del self.redo_list[:]


class _FindChangeDependencies(object):

    def __init__(self, change_list):
        self.change = change_list[0]
        self.change_list = change_list
        self.changed_resources = set(self.change.get_changed_resources())

    def __call__(self):
        result = [self.change]
        for change in self.change_list[1:]:
            if self._depends_on(change, result):
                result.append(change)
                self.changed_resources.update(change.get_changed_resources())
        return result

    def _depends_on(self, changes, result):
        for resource in changes.get_changed_resources():
            if resource is None:
                continue
            if resource in self.changed_resources:
                return True
            for changed in self.changed_resources:
                if resource.is_folder() and resource.contains(changed):
                    return True
                if changed.is_folder() and changed.contains(resource):
                    return True
        return False

########NEW FILE########
__FILENAME__ = libutils
"""A few useful functions for using rope as a library"""
import os.path

import rope.base.project
import rope.base.pycore
from rope.base import taskhandle


def path_to_resource(project, path, type=None):
    """Get the resource at path

    You only need to specify `type` if `path` does not exist.  It can
    be either 'file' or 'folder'.  If the type is `None` it is assumed
    that the resource already exists.

    Note that this function uses `Project.get_resource()`,
    `Project.get_file()`, and `Project.get_folder()` methods.

    """
    project_path = relative(project.address, path)
    if project_path is None:
        project_path = rope.base.project._realpath(path)
        project = rope.base.project.get_no_project()
    if type is None:
        return project.get_resource(project_path)
    if type == 'file':
        return project.get_file(project_path)
    if type == 'folder':
        return project.get_folder(project_path)
    return None

def relative(root, path):
    root = rope.base.project._realpath(root).replace(os.path.sep, '/')
    path = rope.base.project._realpath(path).replace(os.path.sep, '/')
    if path == root:
    	return ''
    if path.startswith(root + '/'):
    	return path[len(root) + 1:]

def report_change(project, path, old_content):
    """Report that the contents of file at `path` was changed

    The new contents of file is retrieved by reading the file.

    """
    resource = path_to_resource(project, path)
    if resource is None:
        return
    for observer in list(project.observers):
        observer.resource_changed(resource)
    if project.pycore.automatic_soa:
        rope.base.pycore.perform_soa_on_changed_scopes(project, resource,
                                                       old_content)

def analyze_modules(project, task_handle=taskhandle.NullTaskHandle()):
    """Perform static object analysis on all python files in the project

    Note that this might be really time consuming.
    """
    resources = project.pycore.get_python_files()
    job_set = task_handle.create_jobset('Analyzing Modules', len(resources))
    for resource in resources:
        job_set.started_job(resource.path)
        project.pycore.analyze_module(resource)
        job_set.finished_job()

########NEW FILE########
__FILENAME__ = doa
import pickle
import marshal
import os
import socket
import subprocess
import sys
import tempfile
import threading


class PythonFileRunner(object):
    """A class for running python project files"""

    def __init__(self, pycore, file_, args=None, stdin=None,
                 stdout=None, analyze_data=None):
        self.pycore = pycore
        self.file = file_
        self.analyze_data = analyze_data
        self.observers = []
        self.args = args
        self.stdin = stdin
        self.stdout = stdout

    def run(self):
        """Execute the process"""
        env = dict(os.environ)
        file_path = self.file.real_path
        path_folders = self.pycore.get_source_folders() + \
                       self.pycore.get_python_path_folders()
        env['PYTHONPATH'] = os.pathsep.join(folder.real_path
                                            for folder in path_folders)
        runmod_path = self.pycore.find_module('rope.base.oi.runmod').real_path
        self.receiver = None
        self._init_data_receiving()
        send_info = '-'
        if self.receiver:
            send_info = self.receiver.get_send_info()
        args = [sys.executable, runmod_path, send_info,
                self.pycore.project.address, self.file.real_path]
        if self.analyze_data is None:
            del args[1:4]
        if self.args is not None:
            args.extend(self.args)
        self.process = subprocess.Popen(
            executable=sys.executable, args=args, env=env,
            cwd=os.path.split(file_path)[0], stdin=self.stdin,
            stdout=self.stdout, stderr=self.stdout, close_fds=os.name != 'nt')

    def _init_data_receiving(self):
        if self.analyze_data is None:
            return
        # Disabling FIFO data transfer due to blocking when running
        # unittests in the GUI.
        # XXX: Handle FIFO data transfer for `rope.ui.testview`
        if True or os.name == 'nt':
            self.receiver = _SocketReceiver()
        else:
            self.receiver = _FIFOReceiver()
        self.receiving_thread = threading.Thread(target=self._receive_information)
        self.receiving_thread.setDaemon(True)
        self.receiving_thread.start()

    def _receive_information(self):
        #temp = open('/dev/shm/info', 'w')
        for data in self.receiver.receive_data():
            self.analyze_data(data)
            #temp.write(str(data) + '\n')
        #temp.close()
        for observer in self.observers:
            observer()

    def wait_process(self):
        """Wait for the process to finish"""
        self.process.wait()
        if self.analyze_data:
            self.receiving_thread.join()

    def kill_process(self):
        """Stop the process"""
        if self.process.poll() is not None:
            return
        try:
            if hasattr(self.process, 'terminate'):
                self.process.terminate()
            elif os.name != 'nt':
                os.kill(self.process.pid, 9)
            else:
                import ctypes
                handle = int(self.process._handle)
                ctypes.windll.kernel32.TerminateProcess(handle, -1)
        except OSError:
            pass

    def add_finishing_observer(self, observer):
        """Notify this observer when execution finishes"""
        self.observers.append(observer)


class _MessageReceiver(object):

    def receive_data(self):
        pass

    def get_send_info(self):
        pass


class _SocketReceiver(_MessageReceiver):

    def __init__(self):
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.data_port = 3037
        while self.data_port < 4000:
            try:
                self.server_socket.bind(('', self.data_port))
                break
            except socket.error as e:
                self.data_port += 1
        self.server_socket.listen(1)

    def get_send_info(self):
        return str(self.data_port)

    def receive_data(self):
        conn, addr = self.server_socket.accept()
        self.server_socket.close()
        my_file = conn.makefile('rb')
        while True:
            try:
                yield pickle.load(my_file)
            except EOFError:
                break
        my_file.close()
        conn.close()


class _FIFOReceiver(_MessageReceiver):

    def __init__(self):
        # XXX: this is insecure and might cause race conditions
        self.file_name = self._get_file_name()
        os.mkfifo(self.file_name)

    def _get_file_name(self):
        prefix = tempfile.gettempdir() + '/__rope_'
        i = 0
        while os.path.exists(prefix + str(i).rjust(4, '0')):
            i += 1
        return prefix + str(i).rjust(4, '0')

    def get_send_info(self):
        return self.file_name

    def receive_data(self):
        my_file = open(self.file_name, 'rb')
        while True:
            try:
                yield marshal.load(my_file)
            except EOFError:
                break
        my_file.close()
        os.remove(self.file_name)

########NEW FILE########
__FILENAME__ = memorydb
from rope.base.oi import objectdb


class MemoryDB(objectdb.FileDict):

    def __init__(self, project, persist=None):
        self.project = project
        self._persist = persist
        self.files = self
        self._load_files()
        self.project.data_files.add_write_hook(self.write)

    def _load_files(self):
        self._files = {}
        if self.persist:
            result = self.project.data_files.read_data(
                'objectdb', compress=self.compress, import_=True)
            if result is not None:
                self._files = result

    def keys(self):
        return list(self._files.keys())

    def __contains__(self, key):
        return key in self._files

    def __getitem__(self, key):
        return FileInfo(self._files[key])

    def create(self, path):
        self._files[path] = {}

    def rename(self, file, newfile):
        if file not in self._files:
            return
        self._files[newfile] = self._files[file]
        del self[file]

    def __delitem__(self, file):
        del self._files[file]

    def write(self):
        if self.persist:
            self.project.data_files.write_data('objectdb', self._files,
                                               self.compress)

    @property
    def compress(self):
        return self.project.prefs.get('compress_objectdb', False)

    @property
    def persist(self):
        if self._persist is not None:
            return self._persist
        else:
            return self.project.prefs.get('save_objectdb', False)


class FileInfo(objectdb.FileInfo):

    def __init__(self, scopes):
        self.scopes = scopes

    def create_scope(self, key):
        self.scopes[key] = ScopeInfo()

    def keys(self):
        return list(self.scopes.keys())

    def __contains__(self, key):
        return key in self.scopes

    def __getitem__(self, key):
        return self.scopes[key]

    def __delitem__(self, key):
        del self.scopes[key]


class ScopeInfo(objectdb.ScopeInfo):

    def __init__(self):
        self.call_info = {}
        self.per_name = {}

    def get_per_name(self, name):
        return self.per_name.get(name, None)

    def save_per_name(self, name, value):
        self.per_name[name] = value

    def get_returned(self, parameters):
        return self.call_info.get(parameters, None)

    def get_call_infos(self):
        for args, returned in self.call_info.items():
            yield objectdb.CallInfo(args, returned)

    def add_call(self, parameters, returned):
        self.call_info[parameters] = returned

    def __getstate__(self):
        return (self.call_info, self.per_name)

    def __setstate__(self, data):
        self.call_info, self.per_name = data

########NEW FILE########
__FILENAME__ = objectdb
from collections import UserDict, MutableMapping

class ObjectDB(object):

    def __init__(self, db, validation):
        self.db = db
        self.validation = validation
        self.observers = []
        self.files = db.files

    def validate_files(self):
        for file in list(self.files):
            if not self.validation.is_file_valid(file):
                del self.files[file]
                self._file_removed(file)

    def validate_file(self, file):
        if file not in self.files:
            return
        for key in list(self.files[file]):
            if not self.validation.is_scope_valid(file, key):
                del self.files[file][key]

    def file_moved(self, file, newfile):
        if file not in self.files:
            return
        self.files.rename(file, newfile)
        self._file_removed(file)
        self._file_added(newfile)

    def get_files(self):
        return list(self.files.keys())

    def get_returned(self, path, key, args):
        scope_info = self._get_scope_info(path, key, readonly=True)
        result = scope_info.get_returned(args)
        if self.validation.is_value_valid(result):
            return result

    def get_pername(self, path, key, name):
        scope_info = self._get_scope_info(path, key, readonly=True)
        result = scope_info.get_per_name(name)
        if self.validation.is_value_valid(result):
            return result

    def get_callinfos(self, path, key):
        scope_info = self._get_scope_info(path, key, readonly=True)
        return scope_info.get_call_infos()

    def add_callinfo(self, path, key, args, returned):
        scope_info = self._get_scope_info(path, key, readonly=False)
        old_returned = scope_info.get_returned(args)
        if self.validation.is_more_valid(returned, old_returned):
            scope_info.add_call(args, returned)

    def add_pername(self, path, key, name, value):
        scope_info = self._get_scope_info(path, key, readonly=False)
        old_value = scope_info.get_per_name(name)
        if self.validation.is_more_valid(value, old_value):
            scope_info.save_per_name(name, value)

    def add_file_list_observer(self, observer):
        self.observers.append(observer)

    def write(self):
        self.db.write()

    def _get_scope_info(self, path, key, readonly=True):
        if path not in self.files:
            if readonly:
                return _NullScopeInfo()
            self.files.create(path)
            self._file_added(path)
        if key not in self.files[path]:
            if readonly:
                return _NullScopeInfo()
            self.files[path].create_scope(key)
        result = self.files[path][key]
        if isinstance(result, dict):
            print(self.files, self.files[path], self.files[path][key])
        return result

    def _file_removed(self, path):
        for observer in self.observers:
            observer.removed(path)

    def _file_added(self, path):
        for observer in self.observers:
            observer.added(path)

    def __str__(self):
        scope_count = 0
        for file_dict in self.files.values():
            scope_count += len(file_dict)
        return 'ObjectDB holds %s file and %s scope infos' % \
               (len(self.files), scope_count)


class _NullScopeInfo(object):

    def __init__(self, error_on_write=True):
        self.error_on_write = error_on_write

    def get_per_name(self, name):
        pass

    def save_per_name(self, name, value):
        if self.error_on_write:
            raise NotImplementedError()

    def get_returned(self, parameters):
        pass

    def get_call_infos(self):
        return []

    def add_call(self, parameters, returned):
        if self.error_on_write:
            raise NotImplementedError()


class FileInfo(MutableMapping):

    def create_scope(self, key):
        pass

    def __iter__(self):
        for key in self.keys():
            yield key

    def __len__(self):
        return len(self.keys())

    def __setitem__(self, key, value):
        self[key] = value

class FileDict(MutableMapping):

    def create(self, key):
        pass

    def rename(self, key, new_key):
        pass

    def __iter__(self):
        for key in self.keys():
            yield key

    def __len__(self):
        return len(self.keys())

    def __setitem__(self, key, value):
        self[key] = value

class ScopeInfo(object):

    def get_per_name(self, name):
        pass

    def save_per_name(self, name, value):
        pass

    def get_returned(self, parameters):
        pass

    def get_call_infos(self):
        pass

    def add_call(self, parameters, returned):
        pass


class CallInfo(object):

    def __init__(self, args, returned):
        self.args = args
        self.returned = returned

    def get_parameters(self):
        return self.args

    def get_returned(self):
        return self.returned


class FileListObserver(object):

    def added(self, path):
        pass

    def removed(self, path):
        pass

########NEW FILE########
__FILENAME__ = objectinfo
import warnings

from rope.base import exceptions, resourceobserver
from rope.base.oi import objectdb, memorydb, transform


class ObjectInfoManager(object):
    """Stores object information

    It uses an instance of `objectdb.ObjectDB` for storing
    information.

    """

    def __init__(self, project):
        self.project = project
        self.to_textual = transform.PyObjectToTextual(project)
        self.to_pyobject = transform.TextualToPyObject(project)
        self.doi_to_pyobject = transform.DOITextualToPyObject(project)
        self._init_objectdb()
        if project.prefs.get('validate_objectdb', False):
            self._init_validation()

    def _init_objectdb(self):
        dbtype = self.project.get_prefs().get('objectdb_type', None)
        persist = None
        if dbtype is not None:
            warnings.warn(
                '"objectdb_type" project config is deprecated;\n'
                'Use "save_objectdb" instead in your project '
                'config file.\n(".ropeproject/config.py" by default)\n',
                DeprecationWarning)
            if dbtype != 'memory' and self.project.ropefolder is not None:
                persist = True
        self.validation = TextualValidation(self.to_pyobject)
        db = memorydb.MemoryDB(self.project, persist=persist)
        self.objectdb = objectdb.ObjectDB(db, self.validation)

    def _init_validation(self):
        self.objectdb.validate_files()
        observer = resourceobserver.ResourceObserver(
            changed=self._resource_changed, moved=self._resource_moved,
            removed=self._resource_moved)
        files = []
        for path in self.objectdb.get_files():
            resource = self.to_pyobject.path_to_resource(path)
            if resource is not None and resource.project == self.project:
                files.append(resource)
        self.observer = resourceobserver.FilteredResourceObserver(observer,
                                                                  files)
        self.objectdb.add_file_list_observer(_FileListObserver(self))
        self.project.add_observer(self.observer)

    def _resource_changed(self, resource):
        try:
            self.objectdb.validate_file(
                self.to_textual.resource_to_path(resource))
        except exceptions.ModuleSyntaxError:
            pass

    def _resource_moved(self, resource, new_resource=None):
        self.observer.remove_resource(resource)
        if new_resource is not None:
            old = self.to_textual.resource_to_path(resource)
            new = self.to_textual.resource_to_path(new_resource)
            self.objectdb.file_moved(old, new)
            self.observer.add_resource(new_resource)

    def get_returned(self, pyobject, args):
        result = self.get_exact_returned(pyobject, args)
        if result is not None:
            return result
        path, key = self._get_scope(pyobject)
        if path is None:
            return None
        for call_info in self.objectdb.get_callinfos(path, key):
            returned = call_info.get_returned()
            if returned and returned[0] not in ('unknown', 'none'):
                result = returned
                break
            if result is None:
                result = returned
        if result is not None:
            return self.to_pyobject(result)

    def get_exact_returned(self, pyobject, args):
        path, key = self._get_scope(pyobject)
        if path is not None:
            returned = self.objectdb.get_returned(
                path, key, self._args_to_textual(pyobject, args))
            if returned is not None:
                return self.to_pyobject(returned)

    def _args_to_textual(self, pyfunction, args):
        parameters = list(pyfunction.get_param_names(special_args=False))
        arguments = args.get_arguments(parameters)[:len(parameters)]
        textual_args = tuple([self.to_textual(arg)
                              for arg in arguments])
        return textual_args

    def get_parameter_objects(self, pyobject):
        path, key = self._get_scope(pyobject)
        if path is None:
            return None
        arg_count = len(pyobject.get_param_names(special_args=False))
        unknowns = arg_count
        parameters = [None] * arg_count
        for call_info in self.objectdb.get_callinfos(path, key):
            args = call_info.get_parameters()
            for index, arg in enumerate(args[:arg_count]):
                old = parameters[index]
                if self.validation.is_more_valid(arg, old):
                    parameters[index] = arg
                    if self.validation.is_value_valid(arg):
                        unknowns -= 1
            if unknowns == 0:
                break
        if unknowns < arg_count:
            return [self.to_pyobject(parameter)
                    for parameter in parameters]

    def get_passed_objects(self, pyfunction, parameter_index):
        path, key = self._get_scope(pyfunction)
        if path is None:
            return []
        result = []
        for call_info in self.objectdb.get_callinfos(path, key):
            args = call_info.get_parameters()
            if len(args) > parameter_index:
                parameter = self.to_pyobject(args[parameter_index])
                if parameter is not None:
                    result.append(parameter)
        return result

    def doa_data_received(self, data):
        def doi_to_normal(textual):
            pyobject = self.doi_to_pyobject(textual)
            return self.to_textual(pyobject)
        function = doi_to_normal(data[0])
        args = tuple([doi_to_normal(textual) for textual in data[1]])
        returned = doi_to_normal(data[2])
        if function[0] == 'defined' and len(function) == 3:
            self._save_data(function, args, returned)

    def function_called(self, pyfunction, params, returned=None):
        function_text = self.to_textual(pyfunction)
        params_text = tuple([self.to_textual(param)
                             for param in params])
        returned_text = ('unknown',)
        if returned is not None:
            returned_text = self.to_textual(returned)
        self._save_data(function_text, params_text, returned_text)

    def save_per_name(self, scope, name, data):
        path, key = self._get_scope(scope.pyobject)
        if path is not None:
            self.objectdb.add_pername(path, key, name, self.to_textual(data))

    def get_per_name(self, scope, name):
        path, key = self._get_scope(scope.pyobject)
        if path is not None:
            result = self.objectdb.get_pername(path, key, name)
            if result is not None:
                return self.to_pyobject(result)

    def _save_data(self, function, args, returned=('unknown',)):
        self.objectdb.add_callinfo(function[1], function[2], args, returned)

    def _get_scope(self, pyobject):
        resource = pyobject.get_module().get_resource()
        if resource is None:
            return None, None
        textual = self.to_textual(pyobject)
        if textual[0] == 'defined':
            path = textual[1]
            if len(textual) == 3:
                key = textual[2]
            else:
                key = ''
            return path, key
        return None, None

    def sync(self):
        self.objectdb.sync()

    def __str__(self):
        return str(self.objectdb)


class TextualValidation(object):

    def __init__(self, to_pyobject):
        self.to_pyobject = to_pyobject

    def is_value_valid(self, value):
        # ???: Should none and unknown be considered valid?
        if value is None or value[0] in ('none', 'unknown'):
            return False
        return self.to_pyobject(value) is not None

    def is_more_valid(self, new, old):
        if old is None:
            return True
        return new[0] not in ('unknown', 'none')

    def is_file_valid(self, path):
        return self.to_pyobject.path_to_resource(path) is not None

    def is_scope_valid(self, path, key):
        if key == '':
            textual = ('defined', path)
        else:
            textual = ('defined', path, key)
        return self.to_pyobject(textual) is not None


class _FileListObserver(object):

    def __init__(self, object_info):
        self.object_info = object_info
        self.observer = self.object_info.observer
        self.to_pyobject = self.object_info.to_pyobject

    def removed(self, path):
        resource = self.to_pyobject.path_to_resource(path)
        if resource is not None:
            self.observer.remove_resource(resource)

    def added(self, path):
        resource = self.to_pyobject.path_to_resource(path)
        if resource is not None:
            self.observer.add_resource(resource)

########NEW FILE########
__FILENAME__ = runmod

def __rope_start_everything():
    import os
    import sys
    import socket
    import pickle
    import marshal
    import inspect
    import types
    import threading

    class _MessageSender(object):

        def send_data(self, data):
            pass

    class _SocketSender(_MessageSender):

        def __init__(self, port):
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(('127.0.0.1', port))
            self.my_file = s.makefile('wb')

        def send_data(self, data):
            if not self.my_file.closed:
                pickle.dump(data, self.my_file)

        def close(self):
            self.my_file.close()

    class _FileSender(_MessageSender):

        def __init__(self, file_name):
            self.my_file = open(file_name, 'wb')

        def send_data(self, data):
            if not self.my_file.closed:
                marshal.dump(data, self.my_file)

        def close(self):
            self.my_file.close()


    def _cached(func):
        cache = {}
        def newfunc(self, arg):
            if arg in cache:
                return cache[arg]
            result = func(self, arg)
            cache[arg] = result
            return result
        return newfunc

    class _FunctionCallDataSender(object):

        def __init__(self, send_info, project_root):
            self.project_root = project_root
            if send_info.isdigit():
                self.sender = _SocketSender(int(send_info))
            else:
                self.sender = _FileSender(send_info)

            def global_trace(frame, event, arg):
                # HACK: Ignoring out->in calls
                # This might lose some information
                if self._is_an_interesting_call(frame):
                    return self.on_function_call
            sys.settrace(global_trace)
            threading.settrace(global_trace)

        def on_function_call(self, frame, event, arg):
            if event != 'return':
                return
            args = []
            returned = ('unknown',)
            code = frame.f_code
            for argname in code.co_varnames[:code.co_argcount]:
                try:
                    args.append(self._object_to_persisted_form(frame.f_locals[argname]))
                except (TypeError, AttributeError):
                    args.append(('unknown',))
            try:
                returned = self._object_to_persisted_form(arg)
            except (TypeError, AttributeError):
                pass
            try:
                data = (self._object_to_persisted_form(frame.f_code),
                        tuple(args), returned)
                self.sender.send_data(data)
            except (TypeError):
                pass
            return self.on_function_call

        def _is_an_interesting_call(self, frame):
            #if frame.f_code.co_name in ['?', '<module>']:
            #    return False
            #return not frame.f_back or not self._is_code_inside_project(frame.f_back.f_code)

            if not self._is_code_inside_project(frame.f_code) and \
               (not frame.f_back or not self._is_code_inside_project(frame.f_back.f_code)):
                return False
            return True

        def _is_code_inside_project(self, code):
            source = self._path(code.co_filename)
            return source is not None and os.path.exists(source) and \
                   _realpath(source).startswith(self.project_root)

        @_cached
        def _get_persisted_code(self, object_):
            source = self._path(object_.co_filename)
            if not os.path.exists(source):
                raise TypeError('no source')
            return ('defined', _realpath(source), str(object_.co_firstlineno))

        @_cached
        def _get_persisted_class(self, object_):
            try:
                return ('defined', _realpath(inspect.getsourcefile(object_)),
                        object_.__name__)
            except (TypeError, AttributeError):
                return ('unknown',)

        def _get_persisted_builtin(self, object_):
            if isinstance(object_, str):
                return ('builtin', 'str')
            if isinstance(object_, list):
                holding = None
                if len(object_) > 0:
                    holding = object_[0]
                return ('builtin', 'list', self._object_to_persisted_form(holding))
            if isinstance(object_, dict):
                keys = None
                values = None
                if len(object_) > 0:
                    keys = list(object_.keys())[0]
                    values = object_[keys]
                return ('builtin', 'dict',
                        self._object_to_persisted_form(keys),
                        self._object_to_persisted_form(values))
            if isinstance(object_, tuple):
                objects = []
                if len(object_) < 3:
                    for holding in object_:
                        objects.append(self._object_to_persisted_form(holding))
                else:
                    objects.append(self._object_to_persisted_form(object_[0]))
                return tuple(['builtin', 'tuple'] + objects)
            if isinstance(object_, set):
                holding = None
                if len(object_) > 0:
                    for o in object_:
                        holding = o
                        break
                return ('builtin', 'set', self._object_to_persisted_form(holding))
            return ('unknown',)

        def _object_to_persisted_form(self, object_):
            if object_ is None:
                return ('none',)
            if isinstance(object_, types.CodeType):
                return self._get_persisted_code(object_)
            if isinstance(object_, types.FunctionType):
                return self._get_persisted_code(object_.__code__)
            if isinstance(object_, types.MethodType):
                return self._get_persisted_code(object_.__func__.__code__)
            if isinstance(object_, types.ModuleType):
                return self._get_persisted_module(object_)
            if isinstance(object_, (str, list, dict, tuple, set)):
                return self._get_persisted_builtin(object_)
            if isinstance(object_, type):
                return self._get_persisted_class(object_)
            return ('instance', self._get_persisted_class(type(object_)))

        @_cached
        def _get_persisted_module(self, object_):
            path = self._path(object_.__file__)
            if path and os.path.exists(path):
                return ('defined', _realpath(path))
            return ('unknown',)

        def _path(self, path):
            if path.endswith('.pyc'):
                path = path[:-1]
            if path.endswith('.py'):
                return path

        def close(self):
            self.sender.close()
            sys.settrace(None)

    def _realpath(path):
        return os.path.realpath(os.path.abspath(os.path.expanduser(path)))

    send_info = sys.argv[1]
    project_root = sys.argv[2]
    file_to_run = sys.argv[3]
    run_globals = globals()
    run_globals.update({'__name__': '__main__',
                        'builtins': __builtins__,
                        '__file__': file_to_run})
    if send_info != '-':
        data_sender = _FunctionCallDataSender(send_info, project_root)
    del sys.argv[1:4]
    with open(file_to_run) as file:
        exec(compile(file.read(), file_to_run, 'exec'), run_globals)
    if send_info != '-':
        data_sender.close()


if __name__ == '__main__':
    __rope_start_everything()

########NEW FILE########
__FILENAME__ = soa
import rope.base.ast
import rope.base.oi.soi
import rope.base.pynames
from rope.base import pyobjects, evaluate, astutils, arguments


def analyze_module(pycore, pymodule, should_analyze,
                   search_subscopes, followed_calls):
    """Analyze `pymodule` for static object inference

    Analyzes scopes for collecting object information.  The analysis
    starts from inner scopes.

    """
    _analyze_node(pycore, pymodule, should_analyze,
                  search_subscopes, followed_calls)


def _analyze_node(pycore, pydefined, should_analyze,
                  search_subscopes, followed_calls):
    if search_subscopes(pydefined):
        for scope in pydefined.get_scope().get_scopes():
            _analyze_node(pycore, scope.pyobject, should_analyze,
                          search_subscopes, followed_calls)
    if should_analyze(pydefined):
        new_followed_calls = max(0, followed_calls - 1)
        return_true = lambda pydefined: True
        return_false = lambda pydefined: False
        def _follow(pyfunction):
            _analyze_node(pycore, pyfunction, return_true,
                          return_false, new_followed_calls)
        if not followed_calls:
            _follow = None
        visitor = SOAVisitor(pycore, pydefined, _follow)
        for child in rope.base.ast.get_child_nodes(pydefined.get_ast()):
            rope.base.ast.walk(child, visitor)


class SOAVisitor(object):

    def __init__(self, pycore, pydefined, follow_callback=None):
        self.pycore = pycore
        self.pymodule = pydefined.get_module()
        self.scope = pydefined.get_scope()
        self.follow = follow_callback

    def _FunctionDef(self, node):
        pass

    def _ClassDef(self, node):
        pass

    def _Call(self, node):
        for child in rope.base.ast.get_child_nodes(node):
            rope.base.ast.walk(child, self)
        primary, pyname = evaluate.eval_node2(self.scope, node.func)
        if pyname is None:
            return
        pyfunction = pyname.get_object()
        if isinstance(pyfunction, pyobjects.AbstractFunction):
            args = arguments.create_arguments(primary, pyfunction,
                                              node, self.scope)
        elif isinstance(pyfunction, pyobjects.PyClass):
            pyclass = pyfunction
            if '__init__' in pyfunction:
                pyfunction = pyfunction['__init__'].get_object()
            pyname = rope.base.pynames.UnboundName(pyobjects.PyObject(pyclass))
            args = self._args_with_self(primary, pyname, pyfunction, node)
        elif '__call__' in pyfunction:
            pyfunction = pyfunction['__call__'].get_object()
            args = self._args_with_self(primary, pyname, pyfunction, node)
        else:
            return
        self._call(pyfunction, args)

    def _args_with_self(self, primary, self_pyname, pyfunction, node):
        base_args = arguments.create_arguments(primary, pyfunction,
                                               node, self.scope)
        return arguments.MixedArguments(self_pyname, base_args, self.scope)

    def _call(self, pyfunction, args):
        if isinstance(pyfunction, pyobjects.PyFunction):
            if self.follow is not None:
                before = self._parameter_objects(pyfunction)
            self.pycore.object_info.function_called(
                pyfunction, args.get_arguments(pyfunction.get_param_names()))
            pyfunction._set_parameter_pyobjects(None)
            if self.follow is not None:
                after = self._parameter_objects(pyfunction)
                if after != before:
                    self.follow(pyfunction)
        # XXX: Maybe we should not call every builtin function
        if isinstance(pyfunction, rope.base.builtins.BuiltinFunction):
            pyfunction.get_returned_object(args)

    def _parameter_objects(self, pyfunction):
        result = []
        for i in range(len(pyfunction.get_param_names(False))):
            result.append(pyfunction.get_parameter(i))
        return result

    def _Assign(self, node):
        for child in rope.base.ast.get_child_nodes(node):
            rope.base.ast.walk(child, self)
        visitor = _SOAAssignVisitor()
        nodes = []
        for child in node.targets:
            rope.base.ast.walk(child, visitor)
            nodes.extend(visitor.nodes)
        for subscript, levels in nodes:
            instance = evaluate.eval_node(self.scope, subscript.value)
            args_pynames = []
            args_pynames.append(evaluate.eval_node(self.scope,
                                                   subscript.slice.value))
            value = rope.base.oi.soi._infer_assignment(
                rope.base.pynames.AssignmentValue(node.value, levels), self.pymodule)
            args_pynames.append(rope.base.pynames.UnboundName(value))
            if instance is not None and value is not None:
                pyobject = instance.get_object()
                if '__setitem__' in pyobject:
                    pyfunction = pyobject['__setitem__'].get_object()
                    args = arguments.ObjectArguments([instance] + args_pynames)
                    self._call(pyfunction, args)
                # IDEA: handle `__setslice__`, too


class _SOAAssignVisitor(astutils._NodeNameCollector):

    def __init__(self):
        super(_SOAAssignVisitor, self).__init__()
        self.nodes = []

    def _added(self, node, levels):
        if isinstance(node, rope.base.ast.Subscript) and \
           isinstance(node.slice, rope.base.ast.Index):
            self.nodes.append((node, levels))

########NEW FILE########
__FILENAME__ = soi
"""A module for inferring objects

For more information see the documentation in `rope.base.oi`
package.

"""
import rope.base.builtins
import rope.base.pynames
import rope.base.pyobjects
from rope.base import evaluate, utils, arguments


_ignore_inferred = utils.ignore_exception(
    rope.base.pyobjects.IsBeingInferredError)


@_ignore_inferred
def infer_returned_object(pyfunction, args):
    """Infer the `PyObject` this `PyFunction` returns after calling"""
    object_info = pyfunction.pycore.object_info
    result = object_info.get_exact_returned(pyfunction, args)
    if result is not None:
        return result
    result = _infer_returned(pyfunction, args)
    if result is not None:
        if args and pyfunction.get_module().get_resource() is not None:
            params = args.get_arguments(
                pyfunction.get_param_names(special_args=False))
            object_info.function_called(pyfunction, params, result)
        return result
    return object_info.get_returned(pyfunction, args)

@_ignore_inferred
def infer_parameter_objects(pyfunction):
    """Infer the `PyObject`\s of parameters of this `PyFunction`"""
    object_info = pyfunction.pycore.object_info
    result = object_info.get_parameter_objects(pyfunction)
    if result is None:
        result = _parameter_objects(pyfunction)
    _handle_first_parameter(pyfunction, result)
    return result

def _handle_first_parameter(pyobject, parameters):
    kind = pyobject.get_kind()
    if parameters is None or kind not in ['method', 'classmethod']:
        pass
    if not parameters:
        if not pyobject.get_param_names(special_args=False):
            return
        parameters.append(rope.base.pyobjects.get_unknown())
    if kind == 'method':
        parameters[0] = rope.base.pyobjects.PyObject(pyobject.parent)
    if kind == 'classmethod':
        parameters[0] = pyobject.parent

@_ignore_inferred
def infer_assigned_object(pyname):
    if not pyname.assignments:
        return
    for assignment in reversed(pyname.assignments):
        result = _infer_assignment(assignment, pyname.module)
        if result is not None:
            return result

def get_passed_objects(pyfunction, parameter_index):
    object_info = pyfunction.pycore.object_info
    result = object_info.get_passed_objects(pyfunction,
                                            parameter_index)
    if not result:
        statically_inferred = _parameter_objects(pyfunction)
        if len(statically_inferred) > parameter_index:
            result.append(statically_inferred[parameter_index])
    return result

def _infer_returned(pyobject, args):
    if args:
        # HACK: Setting parameter objects manually
        # This is not thread safe and might cause problems if `args`
        # does not come from a good call site
        pyobject.get_scope().invalidate_data()
        pyobject._set_parameter_pyobjects(
            args.get_arguments(pyobject.get_param_names(special_args=False)))
    scope = pyobject.get_scope()
    if not scope._get_returned_asts():
        return
    maxtries = 3
    for returned_node in reversed(scope._get_returned_asts()[-maxtries:]):
        try:
            resulting_pyname = evaluate.eval_node(scope, returned_node)
            if resulting_pyname is None:
                continue
            pyobject = resulting_pyname.get_object()
            if pyobject == rope.base.pyobjects.get_unknown():
                continue
            if not scope._is_generator():
                return pyobject
            else:
                return rope.base.builtins.get_generator(pyobject)
        except rope.base.pyobjects.IsBeingInferredError:
            pass

def _parameter_objects(pyobject):
    params = pyobject.get_param_names(special_args=False)
    return [rope.base.pyobjects.get_unknown()] * len(params)

# handling `rope.base.pynames.AssignmentValue`

@_ignore_inferred
def _infer_assignment(assignment, pymodule):
    result = _follow_pyname(assignment, pymodule)
    if result is None:
        return None
    pyname, pyobject = result
    pyobject = _follow_evaluations(assignment, pyname, pyobject)
    if pyobject is None:
        return None
    return _follow_levels(assignment, pyobject)

def _follow_levels(assignment, pyobject):
    for index in assignment.levels:
        if isinstance(pyobject.get_type(), rope.base.builtins.Tuple):
            holdings = pyobject.get_type().get_holding_objects()
            if holdings:
                pyobject = holdings[min(len(holdings) - 1, index)]
            else:
                pyobject = None
        elif isinstance(pyobject.get_type(), rope.base.builtins.List):
            pyobject = pyobject.get_type().holding
        else:
            pyobject = None
        if pyobject is None:
            break
    return pyobject

@_ignore_inferred
def _follow_pyname(assignment, pymodule, lineno=None):
    assign_node = assignment.ast_node
    if lineno is None:
        lineno = _get_lineno_for_node(assign_node)
    holding_scope = pymodule.get_scope().get_inner_scope_for_line(lineno)
    pyname = evaluate.eval_node(holding_scope, assign_node)
    if pyname is not None:
        result = pyname.get_object()
        if isinstance(result.get_type(), rope.base.builtins.Property) and \
           holding_scope.get_kind() == 'Class':
            arg = rope.base.pynames.UnboundName(
                rope.base.pyobjects.PyObject(holding_scope.pyobject))
            return pyname, result.get_type().get_property_object(
                arguments.ObjectArguments([arg]))
        return pyname, result

@_ignore_inferred
def _follow_evaluations(assignment, pyname, pyobject):
    new_pyname = pyname
    tokens = assignment.evaluation.split('.')
    for token in tokens:
        call = token.endswith('()')
        if call:
            token = token[:-2]
        if token:
            pyname = new_pyname
            new_pyname = _get_attribute(pyobject, token)
            if new_pyname is not None:
                pyobject = new_pyname.get_object()
        if pyobject is not None and call:
            if isinstance(pyobject, rope.base.pyobjects.AbstractFunction):
                args = arguments.ObjectArguments([pyname])
                pyobject = pyobject.get_returned_object(args)
            else:
                pyobject = None
        if pyobject is None:
            break
    if pyobject is not None and assignment.assign_type:
        return rope.base.pyobjects.PyObject(pyobject)
    return pyobject


def _get_lineno_for_node(assign_node):
    if hasattr(assign_node, 'lineno') and \
       assign_node.lineno is not None:
        return assign_node.lineno
    return 1

def _get_attribute(pyobject, name):
    if pyobject is not None and name in pyobject:
        return pyobject[name]

########NEW FILE########
__FILENAME__ = transform
"""Provides classes for persisting `PyObject`\s"""
import os
import re

import rope.base.builtins
from rope.base import exceptions


class PyObjectToTextual(object):
    """For transforming `PyObject` to textual form

    This can be used for storing `PyObjects` in files.  Use
    `TextualToPyObject` for converting back.

    """

    def __init__(self, project):
        self.project = project

    def transform(self, pyobject):
        """Transform a `PyObject` to textual form"""
        if pyobject is None:
            return ('none',)
        object_type = type(pyobject)
        try:
            method = getattr(self, object_type.__name__ + '_to_textual')
            return method(pyobject)
        except AttributeError:
            return ('unknown',)

    def __call__(self, pyobject):
        return self.transform(pyobject)

    def PyObject_to_textual(self, pyobject):
        if isinstance(pyobject.get_type(), rope.base.pyobjects.AbstractClass):
            result = self.transform(pyobject.get_type())
            if result[0] == 'defined':
                return ('instance', result)
            return result
        return ('unknown',)

    def PyFunction_to_textual(self, pyobject):
        return self._defined_to_textual(pyobject)

    def PyClass_to_textual(self, pyobject):
        return self._defined_to_textual(pyobject)

    def _defined_to_textual(self, pyobject):
        address = []
        while pyobject.parent is not None:
            address.insert(0, pyobject.get_name())
            pyobject = pyobject.parent
        return ('defined', self._get_pymodule_path(pyobject.get_module()),
                '.'.join(address))

    def PyModule_to_textual(self, pyobject):
        return ('defined', self._get_pymodule_path(pyobject))

    def PyPackage_to_textual(self, pyobject):
        return ('defined', self._get_pymodule_path(pyobject))

    def List_to_textual(self, pyobject):
        return ('builtin', 'list', self.transform(pyobject.holding))

    def Dict_to_textual(self, pyobject):
        return ('builtin', 'dict', self.transform(pyobject.keys),
                self.transform(pyobject.values))

    def Tuple_to_textual(self, pyobject):
        objects = [self.transform(holding)
                   for holding in pyobject.get_holding_objects()]
        return tuple(['builtin', 'tuple'] + objects)

    def Set_to_textual(self, pyobject):
        return ('builtin', 'set', self.transform(pyobject.holding))

    def Iterator_to_textual(self, pyobject):
        return ('builtin', 'iter', self.transform(pyobject.holding))

    def Generator_to_textual(self, pyobject):
        return ('builtin', 'generator', self.transform(pyobject.holding))

    def Str_to_textual(self, pyobject):
        return ('builtin', 'str')

    def File_to_textual(self, pyobject):
        return ('builtin', 'file')

    def BuiltinFunction_to_textual(self, pyobject):
        return ('builtin', 'function', pyobject.get_name())

    def _get_pymodule_path(self, pymodule):
        return self.resource_to_path(pymodule.get_resource())

    def resource_to_path(self, resource):
        if resource.project == self.project:
            return resource.path
        else:
            return resource.real_path


class TextualToPyObject(object):
    """For transforming textual form to `PyObject`"""

    def __init__(self, project, allow_in_project_absolutes=False):
        self.project = project

    def __call__(self, textual):
        return self.transform(textual)

    def transform(self, textual):
        """Transform an object from textual form to `PyObject`"""
        if textual is None:
            return None
        type = textual[0]
        try:
            method = getattr(self, type + '_to_pyobject')
            return method(textual)
        except AttributeError:
            return None

    def builtin_to_pyobject(self, textual):
        name = textual[1]
        method = getattr(self, 'builtin_%s_to_pyobject' % textual[1], None)
        if method is not None:
            return method(textual)

    def builtin_str_to_pyobject(self, textual):
        return rope.base.builtins.get_str()

    def builtin_list_to_pyobject(self, textual):
        holding = self.transform(textual[2])
        return rope.base.builtins.get_list(holding)

    def builtin_dict_to_pyobject(self, textual):
        keys = self.transform(textual[2])
        values = self.transform(textual[3])
        return rope.base.builtins.get_dict(keys, values)

    def builtin_tuple_to_pyobject(self, textual):
        objects = []
        for holding in textual[2:]:
            objects.append(self.transform(holding))
        return rope.base.builtins.get_tuple(*objects)

    def builtin_set_to_pyobject(self, textual):
        holding = self.transform(textual[2])
        return rope.base.builtins.get_set(holding)

    def builtin_iter_to_pyobject(self, textual):
        holding = self.transform(textual[2])
        return rope.base.builtins.get_iterator(holding)

    def builtin_generator_to_pyobject(self, textual):
        holding = self.transform(textual[2])
        return rope.base.builtins.get_generator(holding)

    def builtin_file_to_pyobject(self, textual):
        return rope.base.builtins.get_file()

    def builtin_function_to_pyobject(self, textual):
        if textual[2] in rope.base.builtins.builtins:
            return rope.base.builtins.builtins[textual[2]].get_object()

    def unknown_to_pyobject(self, textual):
        return None

    def none_to_pyobject(self, textual):
        return None

    def _module_to_pyobject(self, textual):
        path = textual[1]
        return self._get_pymodule(path)

    def _hierarchical_defined_to_pyobject(self, textual):
        path = textual[1]
        names = textual[2].split('.')
        pymodule = self._get_pymodule(path)
        pyobject = pymodule
        for name in names:
            if pyobject is None:
                return None
            if isinstance(pyobject, rope.base.pyobjects.PyDefinedObject):
                try:
                    pyobject = pyobject.get_scope()[name].get_object()
                except exceptions.NameNotFoundError:
                    return None
            else:
                return None
        return pyobject

    def defined_to_pyobject(self, textual):
        if len(textual) == 2 or textual[2] == '':
            return self._module_to_pyobject(textual)
        else:
            return self._hierarchical_defined_to_pyobject(textual)

    def instance_to_pyobject(self, textual):
        type = self.transform(textual[1])
        if type is not None:
            return rope.base.pyobjects.PyObject(type)

    def _get_pymodule(self, path):
        resource = self.path_to_resource(path)
        if resource is not None:
            return self.project.pycore.resource_to_pyobject(resource)

    def path_to_resource(self, path):
        try:
            root = self.project.address
            if not os.path.isabs(path):
                return self.project.get_resource(path)
            if path == root or path.startswith(root + os.sep):
                # INFO: This is a project file; should not be absolute
                return None
            import rope.base.project
            return rope.base.project.get_no_project().get_resource(path)
        except exceptions.ResourceNotFoundError:
            return None


class DOITextualToPyObject(TextualToPyObject):
    """For transforming textual form to `PyObject`
    
    The textual form DOI uses is different from rope's standard
    textual form.  The reason is that we cannot find the needed
    information by analyzing live objects.  This class can be
    used to transform DOI textual form to `PyObject` and later
    we can convert it to standard textual form using
    `TextualToPyObject` class.

    """

    def _function_to_pyobject(self, textual):
        path = textual[1]
        lineno = int(textual[2])
        pymodule = self._get_pymodule(path)
        if pymodule is not None:
            scope = pymodule.get_scope()
            inner_scope = scope.get_inner_scope_for_line(lineno)
            return inner_scope.pyobject

    def _class_to_pyobject(self, textual):
        path, name = textual[1:]
        pymodule = self._get_pymodule(path)
        if pymodule is None:
            return None
        module_scope = pymodule.get_scope()
        suspected = None
        if name in module_scope.get_names():
            suspected = module_scope[name].get_object()
        if suspected is not None and \
           isinstance(suspected, rope.base.pyobjects.PyClass):
            return suspected
        else:
            lineno = self._find_occurrence(name, pymodule.get_resource().read())
            if lineno is not None:
                inner_scope = module_scope.get_inner_scope_for_line(lineno)
                return inner_scope.pyobject

    def defined_to_pyobject(self, textual):
        if len(textual) == 2:
            return self._module_to_pyobject(textual)
        else:
            if textual[2].isdigit():
                result = self._function_to_pyobject(textual)
            else:
                result = self._class_to_pyobject(textual)
            if not isinstance(result, rope.base.pyobjects.PyModule):
                return result

    def _find_occurrence(self, name, source):
        pattern = re.compile(r'^\s*class\s*' + name + r'\b')
        lines = source.split('\n')
        for i in range(len(lines)):
            if pattern.match(lines[i]):
                return i + 1

    def path_to_resource(self, path):
        import rope.base.libutils
        root = self.project.address
        relpath = rope.base.libutils.relative(root, path)
        if relpath is not None:
            path = relpath
        return super(DOITextualToPyObject, self).path_to_resource(path)

########NEW FILE########
__FILENAME__ = prefs
class Prefs(object):

    def __init__(self):
        self.prefs = {}
        self.callbacks = {}

    def set(self, key, value):
        """Set the value of `key` preference to `value`."""
        if key in self.callbacks:
            self.callbacks[key](value)
        else:
            self.prefs[key] = value

    def add(self, key, value):
        """Add an entry to a list preference

        Add `value` to the list of entries for the `key` preference.

        """
        if not key in self.prefs:
            self.prefs[key] = []
        self.prefs[key].append(value)

    def get(self, key, default=None):
        """Get the value of the key preference"""
        return self.prefs.get(key, default)

    def add_callback(self, key, callback):
        """Add `key` preference with `callback` function
        
        Whenever `key` is set the callback is called with the
        given `value` as parameter.

        """
        self.callbacks[key] = callback

    def __setitem__(self, key, value):
        self.set(key, value)

    def __getitem__(self, key):
        return self.get(key)

########NEW FILE########
__FILENAME__ = project
import pickle
import os
import shutil
import sys
import warnings

import rope.base.fscommands
from rope.base import exceptions, taskhandle, prefs, history, pycore, utils
from rope.base.resourceobserver import *
from rope.base.resources import File, Folder, _ResourceMatcher


class _Project(object):

    def __init__(self, fscommands):
        self.observers = []
        self.fscommands = fscommands
        self.prefs = prefs.Prefs()
        self.data_files = _DataFiles(self)

    def get_resource(self, resource_name):
        """Get a resource in a project.

        `resource_name` is the path of a resource in a project.  It is
        the path of a resource relative to project root.  Project root
        folder address is an empty string.  If the resource does not
        exist a `exceptions.ResourceNotFound` exception would be
        raised.  Use `get_file()` and `get_folder()` when you need to
        get nonexistent `Resource`\s.

        """
        path = self._get_resource_path(resource_name)
        if not os.path.exists(path):
            raise exceptions.ResourceNotFoundError(
                'Resource <%s> does not exist' % resource_name)
        elif os.path.isfile(path):
            return File(self, resource_name)
        elif os.path.isdir(path):
            return Folder(self, resource_name)
        else:
            raise exceptions.ResourceNotFoundError('Unknown resource '
                                                   + resource_name)

    def validate(self, folder):
        """Validate files and folders contained in this folder

        It validates all of the files and folders contained in this
        folder if some observers are interested in them.

        """
        for observer in list(self.observers):
            observer.validate(folder)

    def add_observer(self, observer):
        """Register a `ResourceObserver`

        See `FilteredResourceObserver`.
        """
        self.observers.append(observer)

    def remove_observer(self, observer):
        """Remove a registered `ResourceObserver`"""
        if observer in self.observers:
            self.observers.remove(observer)

    def do(self, changes, task_handle=taskhandle.NullTaskHandle()):
        """Apply the changes in a `ChangeSet`

        Most of the time you call this function for committing the
        changes for a refactoring.
        """
        self.history.do(changes, task_handle=task_handle)

    def get_pycore(self):
        return self.pycore

    def get_file(self, path):
        """Get the file with `path` (it may not exist)"""
        return File(self, path)

    def get_folder(self, path):
        """Get the folder with `path` (it may not exist)"""
        return Folder(self, path)

    def is_ignored(self, resource):
        return False

    def get_prefs(self):
        return self.prefs

    def _get_resource_path(self, name):
        pass

    @property
    @utils.saveit
    def history(self):
        return history.History(self)

    @property
    @utils.saveit
    def pycore(self):
        return pycore.PyCore(self)

    def close(self):
        warnings.warn('Cannot close a NoProject',
                      DeprecationWarning, stacklevel=2)

    ropefolder = None


class Project(_Project):
    """A Project containing files and folders"""

    def __init__(self, projectroot, fscommands=None,
                 ropefolder='.ropeproject', **prefs):
        """A rope project

        :parameters:
            - `projectroot`: The address of the root folder of the project
            - `fscommands`: Implements the file system operations used
              by rope; have a look at `rope.base.fscommands`
            - `ropefolder`: The name of the folder in which rope stores
              project configurations and data.  Pass `None` for not using
              such a folder at all.
            - `prefs`: Specify project preferences.  These values
              overwrite config file preferences.

        """
        if projectroot != '/':
            projectroot = _realpath(projectroot).rstrip('/\\')
        self._address = projectroot
        self._ropefolder_name = ropefolder
        if not os.path.exists(self._address):
            os.mkdir(self._address)
        elif not os.path.isdir(self._address):
            raise exceptions.RopeError('Project root exists and'
                                       ' is not a directory')
        if fscommands is None:
            fscommands = rope.base.fscommands.create_fscommands(self._address)
        super(Project, self).__init__(fscommands)
        self.ignored = _ResourceMatcher()
        self.file_list = _FileListCacher(self)
        self.prefs.add_callback('ignored_resources', self.ignored.set_patterns)
        if ropefolder is not None:
            self.prefs['ignored_resources'] = [ropefolder]
        self._init_prefs(prefs)
        #print(self.prefs.prefs)

    def get_files(self):
        return self.file_list.get_files()

    def _get_resource_path(self, name):
        return os.path.join(self._address, *name.split('/'))

    def _init_ropefolder(self):
        if self.ropefolder is not None:
            if not self.ropefolder.exists():
                self._create_recursively(self.ropefolder)
            if not self.ropefolder.has_child('config.py'):
                config = self.ropefolder.create_file('config.py')
                config.write(self._default_config())

    def _create_recursively(self, folder):
        if folder.parent != self.root and not folder.parent.exists():
            self._create_recursively(folder.parent)
        folder.create()

    def _init_prefs(self, prefs):
        run_globals = {}
        if self.ropefolder is not None:
            config = self.get_file(self.ropefolder.path + '/config.py')
            run_globals.update({'__name__': '__main__',
                                '__builtins__': __builtins__,
                                '__file__': config.real_path})
            if config.exists():
                config = self.ropefolder.get_child('config.py')
                exec(config.read(), run_globals)
            else:
                exec(self._default_config(), run_globals)
            if 'set_prefs' in run_globals:
                run_globals['set_prefs'](self.prefs)
        for key, value in prefs.items():
            self.prefs[key] = value
        self._init_other_parts()
        self._init_ropefolder()
        if 'project_opened' in run_globals:
            run_globals['project_opened'](self)

    def _default_config(self):
        import rope.base.default_config
        import inspect
        return inspect.getsource(rope.base.default_config)

    def _init_other_parts(self):
        # Forcing the creation of `self.pycore` to register observers
        self.pycore

    def is_ignored(self, resource):
        return self.ignored.does_match(resource)

    def sync(self):
        """Closes project open resources"""
        self.close()

    def close(self):
        """Closes project open resources"""
        self.data_files.write()

    def set(self, key, value):
        """Set the `key` preference to `value`"""
        self.prefs.set(key, value)

    @property
    def ropefolder(self):
        if self._ropefolder_name is not None:
            return self.get_folder(self._ropefolder_name)

    def validate(self, folder=None):
        if folder is None:
            folder = self.root
        super(Project, self).validate(folder)

    root = property(lambda self: self.get_resource(''))
    address = property(lambda self: self._address)


class NoProject(_Project):
    """A null object for holding out of project files.

    This class is singleton use `get_no_project` global function
    """

    def __init__(self):
        fscommands = rope.base.fscommands.FileSystemCommands()
        super(NoProject, self).__init__(fscommands)

    def _get_resource_path(self, name):
        real_name = name.replace('/', os.path.sep)
        return _realpath(real_name)

    def get_resource(self, name):
        universal_name = _realpath(name).replace(os.path.sep, '/')
        return super(NoProject, self).get_resource(universal_name)

    def get_files(self):
        return []

    _no_project = None


def get_no_project():
    if NoProject._no_project is None:
        NoProject._no_project = NoProject()
    return NoProject._no_project


class _FileListCacher(object):

    def __init__(self, project):
        self.project = project
        self.files = None
        rawobserver = ResourceObserver(
            self._changed, self._invalid, self._invalid,
            self._invalid, self._invalid)
        self.project.add_observer(rawobserver)

    def get_files(self):
        if self.files is None:
            self.files = set()
            self._add_files(self.project.root)
        return self.files

    def _add_files(self, folder):
        for child in folder.get_children():
            if child.is_folder():
                self._add_files(child)
            elif not self.project.is_ignored(child):
                self.files.add(child)

    def _changed(self, resource):
        if resource.is_folder():
            self.files = None

    def _invalid(self, resource, new_resource=None):
        self.files = None


class _DataFiles(object):

    def __init__(self, project):
        self.project = project
        self.hooks = []

    def read_data(self, name, compress=False, import_=False):
        if self.project.ropefolder is None:
            return None
        compress = compress and self._can_compress()
        opener = self._get_opener(compress)
        file = self._get_file(name, compress)
        if not compress and import_:
            self._import_old_files(name)
        if file.exists():
            input = opener(file.real_path, 'rb')
            try:
                result = []
                try:
                    while True:
                        result.append(pickle.load(input))
                except EOFError:
                    pass
                if len(result) == 1:
                    return result[0]
                if len(result) > 1:
                    return result
            finally:
                input.close()

    def write_data(self, name, data, compress=False):
        if self.project.ropefolder is not None:
            compress = compress and self._can_compress()
            file = self._get_file(name, compress)
            opener = self._get_opener(compress)
            output = opener(file.real_path, 'wb')
            try:
                pickle.dump(data, output, 2)
            finally:
                output.close()

    def add_write_hook(self, hook):
        self.hooks.append(hook)

    def write(self):
        for hook in self.hooks:
            hook()

    def _can_compress(self):
        try:
            import gzip
            return True
        except ImportError:
            return False

    def _import_old_files(self, name):
        old = self._get_file(name + '.pickle', False)
        new = self._get_file(name, False)
        if old.exists() and not new.exists():
            shutil.move(old.real_path, new.real_path)

    def _get_opener(self, compress):
        if compress:
            try:
                import gzip
                return gzip.open
            except ImportError:
                pass
        return open

    def _get_file(self, name, compress):
        path = self.project.ropefolder.path + '/' + name
        if compress:
            path += '.gz'
        return self.project.get_file(path)


def _realpath(path):
    """Return the real path of `path`

    Is equivalent to ``realpath(abspath(expanduser(path)))``.

    """
    # there is a bug in cygwin for os.path.abspath() for abs paths
    if sys.platform == 'cygwin':
        if path[1:3] == ':\\':
            return path
        return os.path.abspath(os.path.expanduser(path))
    return os.path.realpath(os.path.abspath(os.path.expanduser(path)))

########NEW FILE########
__FILENAME__ = pycore
import bisect
import difflib
import sys
import warnings

import rope.base.oi.doa
import rope.base.oi.objectinfo
import rope.base.oi.soa
from rope.base import ast, exceptions, taskhandle, utils, stdmods
from rope.base.exceptions import ModuleNotFoundError
from rope.base.pyobjectsdef import PyModule, PyPackage, PyClass
import rope.base.resources
import rope.base.resourceobserver
from rope.base import builtins


class PyCore(object):

    def __init__(self, project):
        self.project = project
        self._init_resource_observer()
        self.cache_observers = []
        self.module_cache = _ModuleCache(self)
        self.extension_cache = _ExtensionCache(self)
        self.object_info = rope.base.oi.objectinfo.ObjectInfoManager(project)
        self._init_python_files()
        self._init_automatic_soa()
        self._init_source_folders()

    def _init_python_files(self):
        self.python_matcher = None
        patterns = self.project.prefs.get('python_files', None)
        if patterns is not None:
            self.python_matcher = rope.base.resources._ResourceMatcher()
            self.python_matcher.set_patterns(patterns)

    def _init_resource_observer(self):
        callback = self._invalidate_resource_cache
        observer = rope.base.resourceobserver.ResourceObserver(
            changed=callback, moved=callback, removed=callback)
        self.observer = rope.base.resourceobserver.FilteredResourceObserver(observer)
        self.project.add_observer(self.observer)

    def _init_source_folders(self):
        self._custom_source_folders = []
        for path in self.project.prefs.get('source_folders', []):
            folder = self.project.get_resource(path)
            self._custom_source_folders.append(folder)

    def _init_automatic_soa(self):
        if not self.automatic_soa:
            return
        callback = self._file_changed_for_soa
        observer = rope.base.resourceobserver.ResourceObserver(
            changed=callback, moved=callback, removed=callback)
        self.project.add_observer(observer)

    @property
    def automatic_soa(self):
        auto_soa = self.project.prefs.get('automatic_soi', None)
        return self.project.prefs.get('automatic_soa', auto_soa)

    def _file_changed_for_soa(self, resource, new_resource=None):
        old_contents = self.project.history.\
                       contents_before_current_change(resource)
        if old_contents is not None:
            perform_soa_on_changed_scopes(self.project, resource, old_contents)

    def is_python_file(self, resource):
        if resource.is_folder():
            return False
        if self.python_matcher is None:
            return resource.name.endswith('.py')
        return self.python_matcher.does_match(resource)

    def get_module(self, name, folder=None):
        """Returns a `PyObject` if the module was found."""
        # check if this is a builtin module
        pymod = self._builtin_module(name)
        if pymod is not None:
            return pymod
        module = self.find_module(name, folder)
        if module is None:
            raise ModuleNotFoundError('Module %s not found' % name)
        return self.resource_to_pyobject(module)

    def _builtin_submodules(self, modname):
        result = {}
        for extension in self.extension_modules:
            if extension.startswith(modname + '.'):
                name = extension[len(modname) + 1:]
                if '.' not in name:
                    result[name] = self._builtin_module(extension)
        return result

    def _builtin_module(self, name):
        return self.extension_cache.get_pymodule(name)

    def get_relative_module(self, name, folder, level):
        module = self.find_relative_module(name, folder, level)
        if module is None:
            raise ModuleNotFoundError('Module %s not found' % name)
        return self.resource_to_pyobject(module)

    def get_string_module(self, code, resource=None, force_errors=False):
        """Returns a `PyObject` object for the given code

        If `force_errors` is `True`, `exceptions.ModuleSyntaxError` is
        raised if module has syntax errors.  This overrides
        ``ignore_syntax_errors`` project config.

        """
        return PyModule(self, code, resource, force_errors=force_errors)

    def get_string_scope(self, code, resource=None):
        """Returns a `Scope` object for the given code"""
        return self.get_string_module(code, resource).get_scope()

    def _invalidate_resource_cache(self, resource, new_resource=None):
        for observer in self.cache_observers:
            observer(resource)

    def _find_module_in_folder(self, folder, modname):
        module = folder
        packages = modname.split('.')
        for pkg in packages[:-1]:
            if  module.is_folder() and module.has_child(pkg):
                module = module.get_child(pkg)
            else:
                return None
        if module.is_folder():
            if module.has_child(packages[-1]) and \
               module.get_child(packages[-1]).is_folder():
                return module.get_child(packages[-1])
            elif module.has_child(packages[-1] + '.py') and \
                 not module.get_child(packages[-1] + '.py').is_folder():
                return module.get_child(packages[-1] + '.py')

    def get_python_path_folders(self):
        import rope.base.project
        result = []
        for src in self.project.prefs.get('python_path', []) + sys.path:
            try:
                src_folder = rope.base.project.get_no_project().get_resource(src)
                result.append(src_folder)
            except rope.base.exceptions.ResourceNotFoundError:
                pass
        return result

    def find_module(self, modname, folder=None):
        """Returns a resource corresponding to the given module

        returns None if it can not be found
        """
        return self._find_module(modname, folder)

    def find_relative_module(self, modname, folder, level):
        for i in range(level - 1):
            folder = folder.parent
        if modname == '':
            return folder
        else:
            return self._find_module_in_folder(folder, modname)

    def _find_module(self, modname, folder=None):
        """Return `modname` module resource"""
        for src in self.get_source_folders():
            module = self._find_module_in_folder(src, modname)
            if module is not None:
                return module
        for src in self.get_python_path_folders():
            module = self._find_module_in_folder(src, modname)
            if module is not None:
                return module
        if folder is not None:
            module = self._find_module_in_folder(folder, modname)
            if module is not None:
                return module
        return None

    # INFO: It was decided not to cache source folders, since:
    #  - Does not take much time when the root folder contains
    #    packages, that is most of the time
    #  - We need a separate resource observer; `self.observer`
    #    does not get notified about module and folder creations
    def get_source_folders(self):
        """Returns project source folders"""
        if self.project.root is None:
            return []
        result = list(self._custom_source_folders)
        result.extend(self._find_source_folders(self.project.root))
        return result

    def resource_to_pyobject(self, resource, force_errors=False):
        return self.module_cache.get_pymodule(resource, force_errors)

    def get_python_files(self):
        """Returns all python files available in the project"""
        return [resource for resource in self.project.get_files()
                if self.is_python_file(resource)]

    def _is_package(self, folder):
        if folder.has_child('__init__.py') and \
           not folder.get_child('__init__.py').is_folder():
            return True
        else:
            return False

    def _find_source_folders(self, folder):
        for resource in folder.get_folders():
            if self._is_package(resource):
                return [folder]
        result = []
        for resource in folder.get_files():
            if resource.name.endswith('.py'):
                result.append(folder)
                break
        for resource in folder.get_folders():
            result.extend(self._find_source_folders(resource))
        return result

    def run_module(self, resource, args=None, stdin=None, stdout=None):
        """Run `resource` module

        Returns a `rope.base.oi.doa.PythonFileRunner` object for
        controlling the process.

        """
        perform_doa = self.project.prefs.get('perform_doi', True)
        perform_doa = self.project.prefs.get('perform_doa', perform_doa)
        receiver = self.object_info.doa_data_received
        if not perform_doa:
            receiver = None
        runner = rope.base.oi.doa.PythonFileRunner(
            self, resource, args, stdin, stdout, receiver)
        runner.add_finishing_observer(self.module_cache.forget_all_data)
        runner.run()
        return runner

    def analyze_module(self, resource, should_analyze=lambda py: True,
                       search_subscopes=lambda py: True, followed_calls=None):
        """Analyze `resource` module for static object inference

        This function forces rope to analyze this module to collect
        information about function calls.  `should_analyze` is a
        function that is called with a `PyDefinedObject` argument.  If
        it returns `True` the element is analyzed.  If it is `None` or
        returns `False` the element is not analyzed.

        `search_subscopes` is like `should_analyze`; The difference is
        that if it returns `False` the sub-scopes are all ignored.
        That is it is assumed that `should_analyze` returns `False`
        for all of its subscopes.

        `followed_calls` override the value of ``soa_followed_calls``
        project config.
        """
        if followed_calls is None:
            followed_calls = self.project.prefs.get('soa_followed_calls', 0)
        pymodule = self.resource_to_pyobject(resource)
        self.module_cache.forget_all_data()
        rope.base.oi.soa.analyze_module(
            self, pymodule, should_analyze, search_subscopes, followed_calls)

    def get_classes(self, task_handle=taskhandle.NullTaskHandle()):
        warnings.warn('`PyCore.get_classes()` is deprecated',
                      DeprecationWarning, stacklevel=2)
        return []

    def __str__(self):
        return str(self.module_cache) + str(self.object_info)

    def modname(self, resource):
        if resource.is_folder():
            module_name = resource.name
            source_folder = resource.parent
        elif resource.name == '__init__.py':
            module_name = resource.parent.name
            source_folder = resource.parent.parent
        else:
            module_name = resource.name[:-3]
            source_folder = resource.parent

        while source_folder != source_folder.parent and \
              source_folder.has_child('__init__.py'):
            module_name = source_folder.name + '.' + module_name
            source_folder = source_folder.parent
        return module_name

    @property
    @utils.cacheit
    def extension_modules(self):
        result = set(self.project.prefs.get('extension_modules', []))
        if self.project.prefs.get('import_dynload_stdmods', False):
            result.update(stdmods.dynload_modules())
        return result


class _ModuleCache(object):

    def __init__(self, pycore):
        self.pycore = pycore
        self.module_map = {}
        self.pycore.cache_observers.append(self._invalidate_resource)
        self.observer = self.pycore.observer

    def _invalidate_resource(self, resource):
        if resource in self.module_map:
            self.forget_all_data()
            self.observer.remove_resource(resource)
            del self.module_map[resource]

    def get_pymodule(self, resource, force_errors=False):
        if resource in self.module_map:
            return self.module_map[resource]
        if resource.is_folder():
            result = PyPackage(self.pycore, resource,
                               force_errors=force_errors)
        else:
            result = PyModule(self.pycore, resource=resource,
                              force_errors=force_errors)
            if result.has_errors:
                return result
        self.module_map[resource] = result
        self.observer.add_resource(resource)
        return result

    def forget_all_data(self):
        for pymodule in self.module_map.values():
            pymodule._forget_concluded_data()

    def __str__(self):
        return 'PyCore caches %d PyModules\n' % len(self.module_map)


class _ExtensionCache(object):

    def __init__(self, pycore):
        self.pycore = pycore
        self.extensions = {}

    def get_pymodule(self, name):
        if name == '__builtin__':
            return builtins.builtins
        allowed = self.pycore.extension_modules
        if name not in self.extensions and name in allowed:
            self.extensions[name] = builtins.BuiltinModule(name, self.pycore)
        return self.extensions.get(name)


def perform_soa_on_changed_scopes(project, resource, old_contents):
    pycore = project.pycore
    if resource.exists() and pycore.is_python_file(resource):
        try:
            new_contents = resource.read()
            # detecting changes in new_contents relative to old_contents
            detector = _TextChangeDetector(new_contents, old_contents)
            def search_subscopes(pydefined):
                scope = pydefined.get_scope()
                return detector.is_changed(scope.get_start(), scope.get_end())
            def should_analyze(pydefined):
                scope = pydefined.get_scope()
                start = scope.get_start()
                end = scope.get_end()
                return detector.consume_changes(start, end)
            pycore.analyze_module(resource, should_analyze, search_subscopes)
        except exceptions.ModuleSyntaxError:
            pass


class _TextChangeDetector(object):

    def __init__(self, old, new):
        self.old = old
        self.new = new
        self._set_diffs()

    def _set_diffs(self):
        differ = difflib.Differ()
        self.lines = []
        lineno = 0
        for line in differ.compare(self.old.splitlines(True),
                                   self.new.splitlines(True)):
            if line.startswith(' '):
                lineno += 1
            elif line.startswith('-'):
                lineno += 1
                self.lines.append(lineno)

    def is_changed(self, start, end):
        """Tell whether any of start till end lines have changed

        The end points are inclusive and indices start from 1.
        """
        left, right = self._get_changed(start, end)
        if left < right:
            return True
        return False

    def consume_changes(self, start, end):
        """Clear the changed status of lines from start till end"""
        left, right = self._get_changed(start, end)
        if left < right:
            del self.lines[left:right]
        return left < right

    def _get_changed(self, start, end):
        left = bisect.bisect_left(self.lines, start)
        right = bisect.bisect_right(self.lines, end)
        return left, right

########NEW FILE########
__FILENAME__ = pynames
import rope.base.pyobjects
from rope.base import exceptions, utils


class PyName(object):
    """References to `PyObject`\s inside python programs"""

    def get_object(self):
        """Return the `PyObject` object referenced by this `PyName`"""

    def get_definition_location(self):
        """Return a (module, lineno) tuple"""


class DefinedName(PyName):

    def __init__(self, pyobject):
        self.pyobject = pyobject

    def get_object(self):
        return self.pyobject

    def get_definition_location(self):
        return (self.pyobject.get_module(), self.pyobject.get_ast().lineno)


class AssignedName(PyName):
    """Only a placeholder"""


class UnboundName(PyName):

    def __init__(self, pyobject=None):
        self.pyobject = pyobject
        if self.pyobject is None:
            self.pyobject = rope.base.pyobjects.get_unknown()

    def get_object(self):
        return self.pyobject

    def get_definition_location(self):
        return (None, None)


class AssignmentValue(object):
    """An assigned expression"""

    def __init__(self, ast_node, levels=None, evaluation='',
                 assign_type=False):
        """The `level` is `None` for simple assignments and is
        a list of numbers for tuple assignments for example in::

           a, (b, c) = x

        The levels for for `a` is ``[0]``, for `b` is ``[1, 0]`` and for
        `c` is ``[1, 1]``.

        """
        self.ast_node = ast_node
        if levels == None:
            self.levels = []
        else:
            self.levels = levels
        self.evaluation = evaluation
        self.assign_type = assign_type

    def get_lineno(self):
        return self.ast_node.lineno


class EvaluatedName(PyName):
    """A name whose object will be evaluated later"""

    def __init__(self, callback, module=None, lineno=None):
        self.module = module
        self.lineno = lineno
        self.callback = callback
        self.pyobject = _Inferred(callback, _get_concluded_data(module))

    def get_object(self):
        return self.pyobject.get()

    def get_definition_location(self):
        return (self.module, self.lineno)

    def invalidate(self):
        """Forget the `PyObject` this `PyName` holds"""
        self.pyobject.set(None)


class ParameterName(PyName):
    """Only a placeholder"""


class ImportedModule(PyName):

    def __init__(self, importing_module, module_name=None,
                 level=0, resource=None):
        self.importing_module = importing_module
        self.module_name = module_name
        self.level = level
        self.resource = resource
        self.pymodule = _get_concluded_data(self.importing_module)

    def _current_folder(self):
        resource = self.importing_module.get_module().get_resource()
        if resource is None:
            return None
        return resource.parent

    def _get_pymodule(self):
        if self.pymodule.get() is None:
            pycore = self.importing_module.pycore
            if self.resource is not None:
                self.pymodule.set(pycore.resource_to_pyobject(self.resource))
            elif self.module_name is not None:
                try:
                    if self.level == 0:
                        pymodule = pycore.get_module(self.module_name,
                                                     self._current_folder())
                    else:
                        pymodule = pycore.get_relative_module(
                            self.module_name, self._current_folder(), self.level)
                    self.pymodule.set(pymodule)
                except exceptions.ModuleNotFoundError:
                    pass
        return self.pymodule.get()

    def get_object(self):
        if self._get_pymodule() is None:
            return rope.base.pyobjects.get_unknown()
        return self._get_pymodule()

    def get_definition_location(self):
        pymodule = self._get_pymodule()
        if not isinstance(pymodule, rope.base.pyobjects.PyDefinedObject):
            return (None, None)
        return (pymodule.get_module(), 1)


class ImportedName(PyName):

    def __init__(self, imported_module, imported_name):
        self.imported_module = imported_module
        self.imported_name = imported_name

    def _get_imported_pyname(self):
        try:
            result = self.imported_module.get_object()[self.imported_name]
            if result != self:
                return result
        except exceptions.AttributeNotFoundError:
            pass
        return UnboundName()

    @utils.prevent_recursion(rope.base.pyobjects.get_unknown)
    def get_object(self):
        return self._get_imported_pyname().get_object()

    @utils.prevent_recursion(lambda: (None, None))
    def get_definition_location(self):
        return self._get_imported_pyname().get_definition_location()


def _get_concluded_data(module):
    if module is None:
        return rope.base.pyobjects._ConcludedData()
    return module._get_concluded_data()


def _circular_inference():
    raise rope.base.pyobjects.IsBeingInferredError(
        'Circular Object Inference')

class _Inferred(object):

    def __init__(self, get_inferred, concluded=None):
        self.get_inferred = get_inferred
        self.concluded = concluded
        if self.concluded is None:
            self.temp = None

    @utils.prevent_recursion(_circular_inference)
    def get(self, *args, **kwds):
        if self.concluded is None or self.concluded.get() is None:
            self.set(self.get_inferred(*args, **kwds))
        if self._get() is None:
            self.set(rope.base.pyobjects.get_unknown())
        return self._get()

    def set(self, pyobject):
        if self.concluded is not None:
            self.concluded.set(pyobject)
        self.temp = pyobject

    def _get(self):
        if self.concluded is not None:
            return self.concluded.get()
        return self.temp

########NEW FILE########
__FILENAME__ = pynamesdef
import rope.base.oi.soi
from rope.base import pynames
from rope.base.pynames import *


class AssignedName(pynames.AssignedName):

    def __init__(self, lineno=None, module=None, pyobject=None):
        self.lineno = lineno
        self.module = module
        self.assignments = []
        self.pyobject = _Inferred(self._get_inferred,
                                  pynames._get_concluded_data(module))
        self.pyobject.set(pyobject)

    @utils.prevent_recursion(lambda: None)
    def _get_inferred(self):
        if self.module is not None:
            return rope.base.oi.soi.infer_assigned_object(self)

    def get_object(self):
        return self.pyobject.get()

    def get_definition_location(self):
        """Returns a (module, lineno) tuple"""
        if self.lineno is None and self.assignments:
            self.lineno = self.assignments[0].get_lineno()
        return (self.module, self.lineno)

    def invalidate(self):
        """Forget the `PyObject` this `PyName` holds"""
        self.pyobject.set(None)


class ParameterName(pynames.ParameterName):

    def __init__(self, pyfunction, index):
        self.pyfunction = pyfunction
        self.index = index

    def get_object(self):
        result = self.pyfunction.get_parameter(self.index)
        if result is None:
            result = rope.base.pyobjects.get_unknown()
        return result

    def get_objects(self):
        """Returns the list of objects passed as this parameter"""
        return rope.base.oi.soi.get_passed_objects(
            self.pyfunction, self.index)

    def get_definition_location(self):
        return (self.pyfunction.get_module(), self.pyfunction.get_ast().lineno)

_Inferred = pynames._Inferred

########NEW FILE########
__FILENAME__ = pyobjects
from rope.base.fscommands import _decode_data
from rope.base import ast, exceptions, utils


class PyObject(object):

    def __init__(self, type_):
        if type_ is None:
            type_ = self
        self.type = type_

    def get_attributes(self):
        if self.type is self:
            return {}
        return self.type.get_attributes()

    def get_attribute(self, name):
        if name not in self.get_attributes():
            raise exceptions.AttributeNotFoundError(
                'Attribute %s not found' % name)
        return self.get_attributes()[name]

    def get_type(self):
        return self.type

    def __getitem__(self, key):
        """The same as ``get_attribute(key)``"""
        return self.get_attribute(key)

    def __contains__(self, key):
        """The same as ``key in self.get_attributes()``"""
        return key in self.get_attributes()

    def __eq__(self, obj):
        """Check the equality of two `PyObject`\s

        Currently it is assumed that instances (the direct instances
        of `PyObject`, not the instances of its subclasses) are equal
        if their types are equal.  For every other object like
        defineds or builtins rope assumes objects are reference
        objects and their identities should match.

        """
        if self.__class__ != obj.__class__:
            return False
        if type(self) == PyObject:
            if self is not self.type:
                return self.type == obj.type
            else:
                return self.type is obj.type
        return self is obj

    def __ne__(self, obj):
        return not self.__eq__(obj)

    def __hash__(self):
        """See docs for `__eq__()` method"""
        if type(self) == PyObject and self != self.type:
            return hash(self.type) + 1
        else:
            return super(PyObject, self).__hash__()

    def __iter__(self):
        """The same as ``iter(self.get_attributes())``"""
        return iter(self.get_attributes())

    _types = None
    _unknown = None

    @staticmethod
    def _get_base_type(name):
        if PyObject._types is None:
            PyObject._types = {}
            base_type = PyObject(None)
            PyObject._types['Type'] = base_type
            PyObject._types['Module'] = PyObject(base_type)
            PyObject._types['Function'] = PyObject(base_type)
            PyObject._types['Unknown'] = PyObject(base_type)
        return PyObject._types[name]


def get_base_type(name):
    """Return the base type with name `name`.

    The base types are 'Type', 'Function', 'Module' and 'Unknown'.  It
    was used to check the type of a `PyObject` but currently its use
    is discouraged.  Use classes defined in this module instead.
    For example instead of
    ``pyobject.get_type() == get_base_type('Function')`` use
    ``isinstance(pyobject, AbstractFunction)``.

    You can use `AbstractClass` for classes, `AbstractFunction` for
    functions, and `AbstractModule` for modules.  You can also use
    `PyFunction` and `PyClass` for testing if an object is
    defined somewhere and rope can access its source.  These classes
    provide more methods.

    """
    return PyObject._get_base_type(name)


def get_unknown():
    """Return a pyobject whose type is unknown

    Note that two unknown objects are equal.  So for example you can
    write::

      if pyname.get_object() == get_unknown():
          print 'cannot determine what this pyname holds'

    Rope could have used `None` for indicating unknown objects but
    we had to check that in many places.  So actually this method
    returns a null object.

    """
    if PyObject._unknown is None:
        PyObject._unknown = PyObject(get_base_type('Unknown'))
    return PyObject._unknown


class AbstractClass(PyObject):

    def __init__(self):
        super(AbstractClass, self).__init__(get_base_type('Type'))

    def get_name(self):
        pass

    def get_doc(self):
        pass

    def get_superclasses(self):
        return []


class AbstractFunction(PyObject):

    def __init__(self):
        super(AbstractFunction, self).__init__(get_base_type('Function'))

    def get_name(self):
        pass

    def get_doc(self):
        pass

    def get_param_names(self, special_args=True):
        return []

    def get_returned_object(self, args):
        return get_unknown()


class AbstractModule(PyObject):

    def __init__(self, doc=None):
        super(AbstractModule, self).__init__(get_base_type('Module'))

    def get_doc(self):
        pass

    def get_resource(self):
        pass


class PyDefinedObject(object):
    """Python defined names that rope can access their sources"""

    def __init__(self, pycore, ast_node, parent):
        self.pycore = pycore
        self.ast_node = ast_node
        self.scope = None
        self.parent = parent
        self.structural_attributes = None
        self.concluded_attributes = self.get_module()._get_concluded_data()
        self.attributes = self.get_module()._get_concluded_data()
        self.defineds = None

    visitor_class = None

    @utils.prevent_recursion(lambda: {})
    def _get_structural_attributes(self):
        if self.structural_attributes is None:
            self.structural_attributes = self._create_structural_attributes()
        return self.structural_attributes

    @utils.prevent_recursion(lambda: {})
    def _get_concluded_attributes(self):
        if self.concluded_attributes.get() is None:
            self._get_structural_attributes()
            self.concluded_attributes.set(self._create_concluded_attributes())
        return self.concluded_attributes.get()

    def get_attributes(self):
        if self.attributes.get() is None:
            result = dict(self._get_concluded_attributes())
            result.update(self._get_structural_attributes())
            self.attributes.set(result)
        return self.attributes.get()

    def get_attribute(self, name):
        if name in self._get_structural_attributes():
            return self._get_structural_attributes()[name]
        if name in self._get_concluded_attributes():
            return self._get_concluded_attributes()[name]
        raise exceptions.AttributeNotFoundError('Attribute %s not found' %
                                                name)

    def get_scope(self):
        if self.scope is None:
            self.scope = self._create_scope()
        return self.scope

    def get_module(self):
        current_object = self
        while current_object.parent is not None:
            current_object = current_object.parent
        return current_object

    def get_doc(self):
        if len(self.get_ast().body) > 0:
            expr = self.get_ast().body[0]
            if isinstance(expr, ast.Expr) and \
               isinstance(expr.value, ast.Str):
                docstring = expr.value.s
                coding = self.get_module().coding
                return _decode_data(docstring, coding)

    def _get_defined_objects(self):
        if self.defineds is None:
            self._get_structural_attributes()
        return self.defineds

    def _create_structural_attributes(self):
        if self.visitor_class is None:
            return {}
        new_visitor = self.visitor_class(self.pycore, self)
        for child in ast.get_child_nodes(self.ast_node):
            ast.walk(child, new_visitor)
        self.defineds = new_visitor.defineds
        return new_visitor.names

    def _create_concluded_attributes(self):
        return {}

    def get_ast(self):
        return self.ast_node

    def _create_scope(self):
        pass


class PyFunction(PyDefinedObject, AbstractFunction):
    """Only a placeholder"""


class PyClass(PyDefinedObject, AbstractClass):
    """Only a placeholder"""


class _ConcludedData(object):

    def __init__(self):
        self.data_ = None

    def set(self, data):
        self.data_ = data

    def get(self):
        return self.data_

    data = property(get, set)

    def _invalidate(self):
        self.data = None

    def __str__(self):
        return '<' + str(self.data) + '>'


class _PyModule(PyDefinedObject, AbstractModule):

    def __init__(self, pycore, ast_node, resource):
        self.resource = resource
        self.concluded_data = []
        AbstractModule.__init__(self)
        PyDefinedObject.__init__(self, pycore, ast_node, None)

    def _get_concluded_data(self):
        new_data = _ConcludedData()
        self.concluded_data.append(new_data)
        return new_data

    def _forget_concluded_data(self):
        for data in self.concluded_data:
            data._invalidate()

    def get_resource(self):
        return self.resource


class PyModule(_PyModule):
    """Only a placeholder"""


class PyPackage(_PyModule):
    """Only a placeholder"""


class IsBeingInferredError(exceptions.RopeError):
    pass

########NEW FILE########
__FILENAME__ = pyobjectsdef
import rope.base.codeanalyze
import rope.base.evaluate
import rope.base.builtins
import rope.base.oi.soi
import rope.base.pyscopes
from rope.base import (pynamesdef as pynames, exceptions, ast,
                       astutils, pyobjects, fscommands, arguments, utils)
from rope.base.pyobjects import *


class PyFunction(pyobjects.PyFunction):

    def __init__(self, pycore, ast_node, parent):
        AbstractFunction.__init__(self)
        PyDefinedObject.__init__(self, pycore, ast_node, parent)
        self.arguments = self.ast_node.args
        self.parameter_pyobjects = pynames._Inferred(
            self._infer_parameters, self.get_module()._get_concluded_data())
        self.returned = pynames._Inferred(self._infer_returned)
        self.parameter_pynames = None

    def _create_structural_attributes(self):
        return {}

    def _create_concluded_attributes(self):
        return {}

    def _create_scope(self):
        return rope.base.pyscopes.FunctionScope(self.pycore, self,
                                                _FunctionVisitor)

    def _infer_parameters(self):
        pyobjects = rope.base.oi.soi.infer_parameter_objects(self)
        self._handle_special_args(pyobjects)
        return pyobjects

    def _infer_returned(self, args=None):
        return rope.base.oi.soi.infer_returned_object(self, args)

    def _handle_special_args(self, pyobjects):
        if len(pyobjects) == len(self.arguments.args):
            if self.arguments.vararg:
                pyobjects.append(rope.base.builtins.get_list())
            if self.arguments.kwarg:
                pyobjects.append(rope.base.builtins.get_dict())

    def _set_parameter_pyobjects(self, pyobjects):
        if pyobjects is not None:
            self._handle_special_args(pyobjects)
        self.parameter_pyobjects.set(pyobjects)

    def get_parameters(self):
        if self.parameter_pynames is None:
            result = {}
            for index, name in enumerate(self.get_param_names()):
                # TODO: handle tuple parameters
                result[name] = pynames.ParameterName(self, index)
            self.parameter_pynames = result
        return self.parameter_pynames

    def get_parameter(self, index):
        if index < len(self.parameter_pyobjects.get()):
            return self.parameter_pyobjects.get()[index]

    def get_returned_object(self, args):
        return self.returned.get(args)

    def get_name(self):
        return self.get_ast().name

    def get_param_names(self, special_args=True):
        # TODO: handle tuple parameters
        result = [node.arg for node in self.arguments.args
                  if isinstance(node, ast.arg)]
        if special_args:
            if self.arguments.vararg:
                result.append(self.arguments.vararg)
            if self.arguments.kwarg:
                result.append(self.arguments.kwarg)
        return result

    def get_kind(self):
        """Get function type

        It returns one of 'function', 'method', 'staticmethod' or
        'classmethod' strs.

        """
        scope = self.parent.get_scope()
        if isinstance(self.parent, PyClass):
            for decorator in self.decorators:
                pyname = rope.base.evaluate.eval_node(scope, decorator)
                if pyname == rope.base.builtins.builtins['staticmethod']:
                    return 'staticmethod'
                if pyname == rope.base.builtins.builtins['classmethod']:
                    return 'classmethod'
            return 'method'
        return 'function'

    @property
    def decorators(self):
        try:
            return getattr(self.ast_node, 'decorator_list')
        except AttributeError:
            return getattr(self.ast_node, 'decorators', None)


class PyClass(pyobjects.PyClass):

    def __init__(self, pycore, ast_node, parent):
        self.visitor_class = _ClassVisitor
        AbstractClass.__init__(self)
        PyDefinedObject.__init__(self, pycore, ast_node, parent)
        self.parent = parent
        self._superclasses = self.get_module()._get_concluded_data()

    def get_superclasses(self):
        if self._superclasses.get() is None:
            self._superclasses.set(self._get_bases())
        return self._superclasses.get()

    def get_name(self):
        return self.get_ast().name

    def _create_concluded_attributes(self):
        result = {}
        for base in reversed(self.get_superclasses()):
            result.update(base.get_attributes())
        return result

    def _get_bases(self):
        result = []
        for base_name in self.ast_node.bases:
            base = rope.base.evaluate.eval_node(self.parent.get_scope(),
                                                base_name)
            if base is not None and \
               base.get_object().get_type() == get_base_type('Type'):
                result.append(base.get_object())
        return result

    def _create_scope(self):
        return rope.base.pyscopes.ClassScope(self.pycore, self)


class PyModule(pyobjects.PyModule):

    def __init__(self, pycore, source=None,
                 resource=None, force_errors=False):
        ignore = pycore.project.prefs.get('ignore_syntax_errors', False)
        syntax_errors = force_errors or not ignore
        self.has_errors = False
        try:
            source, node = self._init_source(pycore, source, resource)
        except exceptions.ModuleSyntaxError:
            self.has_errors = True
            if syntax_errors:
                raise
            else:
                source = '\n'
                node = ast.parse('\n')
        self.source_code = source
        self.star_imports = []
        self.visitor_class = _GlobalVisitor
        self.coding = fscommands.read_str_coding(self.source_code)
        super(PyModule, self).__init__(pycore, node, resource)

    def _init_source(self, pycore, source_code, resource):
        filename = 'string'
        if resource:
            filename = resource.path
        try:
            if source_code is None:
                source_bytes = resource.read_bytes()
                source_code = fscommands.file_data_to_unicode(source_bytes)
            else:
                if isinstance(source_code, str):
                    source_bytes = fscommands.unicode_to_file_data(source_code)
                else:
                    source_bytes = source_code
            ast_node = ast.parse(source_bytes, filename=filename)
        except SyntaxError as e:
            raise exceptions.ModuleSyntaxError(filename, e.lineno, e.msg)
        except UnicodeDecodeError as e:
            raise exceptions.ModuleSyntaxError(filename, 1, '%s' % (e.reason))
        return source_code, ast_node

    @utils.prevent_recursion(lambda: {})
    def _create_concluded_attributes(self):
        result = {}
        for star_import in self.star_imports:
            result.update(star_import.get_names())
        return result

    def _create_scope(self):
        return rope.base.pyscopes.GlobalScope(self.pycore, self)

    @property
    @utils.saveit
    def lines(self):
        """A `SourceLinesAdapter`"""
        return rope.base.codeanalyze.SourceLinesAdapter(self.source_code)

    @property
    @utils.saveit
    def logical_lines(self):
        """A `LogicalLinesFinder`"""
        return rope.base.codeanalyze.CachingLogicalLineFinder(self.lines)


class PyPackage(pyobjects.PyPackage):

    def __init__(self, pycore, resource=None, force_errors=False):
        self.resource = resource
        init_dot_py = self._get_init_dot_py()
        if init_dot_py is not None:
            ast_node = pycore.resource_to_pyobject(
                init_dot_py, force_errors=force_errors).get_ast()
        else:
            ast_node = ast.parse('\n')
        super(PyPackage, self).__init__(pycore, ast_node, resource)

    def _create_structural_attributes(self):
        result = {}
        modname = self.pycore.modname(self.resource)
        extension_submodules = self.pycore._builtin_submodules(modname)
        for name, module in extension_submodules.items():
            result[name] = rope.base.builtins.BuiltinName(module)
        if self.resource is None:
            return result
        for name, resource in self._get_child_resources().items():
            result[name] = pynames.ImportedModule(self, resource=resource)
        return result

    def _create_concluded_attributes(self):
        result = {}
        init_dot_py = self._get_init_dot_py()
        if init_dot_py:
            init_object = self.pycore.resource_to_pyobject(init_dot_py)
            result.update(init_object.get_attributes())
        return result

    def _get_child_resources(self):
        result = {}
        for child in self.resource.get_children():
            if child.is_folder():
                result[child.name] = child
            elif child.name.endswith('.py') and \
                 child.name != '__init__.py':
                name = child.name[:-3]
                result[name] = child
        return result

    def _get_init_dot_py(self):
        if self.resource is not None and self.resource.has_child('__init__.py'):
            return self.resource.get_child('__init__.py')
        else:
            return None

    def _create_scope(self):
        return self.get_module().get_scope()

    def get_module(self):
        init_dot_py = self._get_init_dot_py()
        if init_dot_py:
            return self.pycore.resource_to_pyobject(init_dot_py)
        return self


class _AssignVisitor(object):

    def __init__(self, scope_visitor):
        self.scope_visitor = scope_visitor
        self.assigned_ast = None

    def _Assign(self, node):
        self.assigned_ast = node.value
        for child_node in node.targets:
            ast.walk(child_node, self)

    def _assigned(self, name, assignment=None):
        self.scope_visitor._assigned(name, assignment)

    def _Name(self, node):
        assignment = None
        if self.assigned_ast is not None:
            assignment = pynames.AssignmentValue(self.assigned_ast)
        self._assigned(node.id, assignment)

    def _Tuple(self, node):
        names = astutils.get_name_levels(node)
        for name, levels in names:
            assignment = None
            if self.assigned_ast is not None:
                assignment = pynames.AssignmentValue(self.assigned_ast, levels)
            self._assigned(name, assignment)

    def _Attribute(self, node):
        pass

    def _Subscript(self, node):
        pass

    def _Slice(self, node):
        pass


class _ScopeVisitor(object):

    def __init__(self, pycore, owner_object):
        self.pycore = pycore
        self.owner_object = owner_object
        self.names = {}
        self.defineds = []

    def get_module(self):
        if self.owner_object is not None:
            return self.owner_object.get_module()
        else:
            return None

    def _ClassDef(self, node):
        pyclass = PyClass(self.pycore, node, self.owner_object)
        self.names[node.name] = pynames.DefinedName(pyclass)
        self.defineds.append(pyclass)

    def _FunctionDef(self, node):
        pyfunction = PyFunction(self.pycore, node, self.owner_object)
        for decorator in pyfunction.decorators:
            if isinstance(decorator, ast.Name) and decorator.id == 'property':
                if isinstance(self, _ClassVisitor):
                    type_ = rope.base.builtins.Property(pyfunction)
                    arg = pynames.UnboundName(PyObject(self.owner_object))
                    def _eval(type_=type_, arg=arg):
                        return type_.get_property_object(
                            arguments.ObjectArguments([arg]))
                    self.names[node.name] = pynames.EvaluatedName(
                        _eval, module=self.get_module(), lineno=node.lineno)
                    break
        else:
            self.names[node.name] = pynames.DefinedName(pyfunction)
        self.defineds.append(pyfunction)

    def _Assign(self, node):
        ast.walk(node, _AssignVisitor(self))

    def _AugAssign(self, node):
        pass

    def _For(self, node):
        names = self._update_evaluated(node.target, node.iter,
                                       '.__iter__().next()')
        for child in node.body + node.orelse:
            ast.walk(child, self)

    def _assigned(self, name, assignment):
        pyname = self.names.get(name, None)
        if pyname is None:
            pyname = pynames.AssignedName(module=self.get_module())
        if isinstance(pyname, pynames.AssignedName):
            if assignment is not None:
                pyname.assignments.append(assignment)
            self.names[name] = pyname

    def _update_evaluated(self, targets, assigned,
                          evaluation= '', eval_type=False):
        result = {}
        if not isinstance(targets, str):
            names = astutils.get_name_levels(targets)
            for name, levels in names:
                assignment = pynames.AssignmentValue(assigned, levels,
                                                     evaluation, eval_type)
                self._assigned(name, assignment)
        else:
            assignment = pynames.AssignmentValue(assigned, [],
                                                 evaluation, eval_type)
            self._assigned(targets, assignment)
        return result

    def _With(self, node):
        if node.optional_vars:
            self._update_evaluated(node.optional_vars,
                                   node.context_expr, '.__enter__()')
        for child in node.body:
            ast.walk(child, self)

    def _excepthandler(self, node):
        if node.name is not None and isinstance(node.name, str):
            type_node = node.type
            if isinstance(node.type, ast.Tuple) and type_node.elts:
                type_node = type_node.elts[0]
            self._update_evaluated(node.name, type_node, eval_type=True)
        for child in node.body:
            ast.walk(child, self)

    def _ExceptHandler(self, node):
        self._excepthandler(node)

    def _Import(self, node):
        for import_pair in node.names:
            module_name = import_pair.name
            alias = import_pair.asname
            first_package = module_name.split('.')[0]
            if alias is not None:
                imported = pynames.ImportedModule(self.get_module(),
                                                  module_name)
                if not self._is_ignored_import(imported):
                    self.names[alias] = imported
            else:
                imported = pynames.ImportedModule(self.get_module(),
                                                  first_package)
                if not self._is_ignored_import(imported):
                    self.names[first_package] = imported

    def _ImportFrom(self, node):
        level = 0
        if node.level:
            level = node.level
        if node.module is None and len(node.names) > 0: #Relative import "."
            self._Import(node)
            return
        imported_module = pynames.ImportedModule(self.get_module(),
                                                 node.module, level)
        if self._is_ignored_import(imported_module):
            return
        if len(node.names) == 1 and node.names[0].name == '*':
            if isinstance(self.owner_object, PyModule):
                self.owner_object.star_imports.append(
                    StarImport(imported_module))
        else:
            for imported_name in node.names:
                imported = imported_name.name
                alias = imported_name.asname
                if alias is not None:
                    imported = alias
                self.names[imported] = pynames.ImportedName(imported_module,
                                                            imported_name.name)

    def _is_ignored_import(self, imported_module):
        if not self.pycore.project.prefs.get('ignore_bad_imports', False):
            return False
        return not isinstance(imported_module.get_object(), AbstractModule)

    def _Global(self, node):
        module = self.get_module()
        for name in node.names:
            if module is not None:
                try:
                    pyname = module[name]
                except exceptions.AttributeNotFoundError:
                    pyname = pynames.AssignedName(node.lineno)
            self.names[name] = pyname


class _GlobalVisitor(_ScopeVisitor):

    def __init__(self, pycore, owner_object):
        super(_GlobalVisitor, self).__init__(pycore, owner_object)


class _ClassVisitor(_ScopeVisitor):

    def __init__(self, pycore, owner_object):
        super(_ClassVisitor, self).__init__(pycore, owner_object)

    def _FunctionDef(self, node):
        _ScopeVisitor._FunctionDef(self, node)
        if len(node.args.args) > 0:
            first = node.args.args[0]
            if isinstance(first, ast.arg):
                new_visitor = _ClassInitVisitor(self, first.arg)
                for child in ast.get_child_nodes(node):
                    ast.walk(child, new_visitor)


class _FunctionVisitor(_ScopeVisitor):

    def __init__(self, pycore, owner_object):
        super(_FunctionVisitor, self).__init__(pycore, owner_object)
        self.returned_asts = []
        self.generator = False

    def _Return(self, node):
        if node.value is not None:
            self.returned_asts.append(node.value)

    def _Yield(self, node):
        if node.value is not None:
            self.returned_asts.append(node.value)
        self.generator = True


class _ClassInitVisitor(_AssignVisitor):

    def __init__(self, scope_visitor, self_name):
        super(_ClassInitVisitor, self).__init__(scope_visitor)
        self.self_name = self_name

    def _Attribute(self, node):
        if not isinstance(node.ctx, ast.Store):
            return
        if isinstance(node.value, ast.Name) and \
           node.value.id == self.self_name:
            if node.attr not in self.scope_visitor.names:
                self.scope_visitor.names[node.attr] = pynames.AssignedName(
                    lineno=node.lineno, module=self.scope_visitor.get_module())
            if self.assigned_ast is not None:
                pyname = self.scope_visitor.names[node.attr]
                if isinstance(pyname, pynames.AssignedName):
                    pyname.assignments.append(
                        pynames.AssignmentValue(self.assigned_ast))

    def _Tuple(self, node):
        if not isinstance(node.ctx, ast.Store):
            return
        for child in ast.get_child_nodes(node):
            ast.walk(child, self)

    def _Name(self, node):
        pass

    def _FunctionDef(self, node):
        pass

    def _ClassDef(self, node):
        pass

    def _For(self, node):
        pass

    def _With(self, node):
        pass


class StarImport(object):

    def __init__(self, imported_module):
        self.imported_module = imported_module

    def get_names(self):
        result = {}
        imported = self.imported_module.get_object()
        for name in imported:
            if not name.startswith('_'):
                result[name] = pynames.ImportedName(self.imported_module, name)
        return result

########NEW FILE########
__FILENAME__ = pyscopes
import rope.base.builtins
import rope.base.codeanalyze
import rope.base.pynames
from rope.base import ast, exceptions, utils


class Scope(object):

    def __init__(self, pycore, pyobject, parent_scope):
        self.pycore = pycore
        self.pyobject = pyobject
        self.parent = parent_scope

    def get_names(self):
        """Return the names defined or imported in this scope"""
        return self.pyobject.get_attributes()

    def get_defined_names(self):
        """Return the names defined in this scope"""
        return self.pyobject._get_structural_attributes()

    def get_name(self, name):
        """Return name `PyName` defined in this scope"""
        if name not in self.get_names():
            raise exceptions.NameNotFoundError('name %s not found' % name)
        return self.get_names()[name]

    def __getitem__(self, key):
        """The same as ``get_name(key)``"""
        return self.get_name(key)

    def __contains__(self, key):
        """The same as ``key in self.get_names()``"""
        return key in self.get_names()

    @utils.saveit
    def get_scopes(self):
        """Return the subscopes of this scope

        The returned scopes should be sorted by the order they appear.
        """
        return self._create_scopes()

    def lookup(self, name):
        if name in self.get_names():
            return self.get_names()[name]
        if self.parent is not None:
            return self.parent._propagated_lookup(name)
        return None

    def get_propagated_names(self):
        """Return the visible names of this scope

        Return the names defined in this scope that are visible from
        scopes containing this scope.  This method returns the same
        dictionary returned by `get_names()` except for `ClassScope`
        which returns an empty dict.
        """
        return self.get_names()

    def _propagated_lookup(self, name):
        if name in self.get_propagated_names():
            return self.get_propagated_names()[name]
        if self.parent is not None:
            return self.parent._propagated_lookup(name)
        return None

    def _create_scopes(self):
        return [pydefined.get_scope()
                for pydefined in self.pyobject._get_defined_objects()]

    def _get_global_scope(self):
        current = self
        while current.parent is not None:
            current = current.parent
        return current

    def get_start(self):
        return self.pyobject.get_ast().lineno

    def get_body_start(self):
        body = self.pyobject.get_ast().body
        if body:
            return body[0].lineno
        return self.get_start()

    def get_end(self):
        pymodule = self._get_global_scope().pyobject
        return pymodule.logical_lines.logical_line_in(self.logical_end)[1]

    @utils.saveit
    def get_logical_end(self):
        global_scope = self._get_global_scope()
        return global_scope._scope_finder.find_scope_end(self)

    start = property(get_start)
    end = property(get_end)
    logical_end = property(get_logical_end)

    def get_kind(self):
        pass


class GlobalScope(Scope):

    def __init__(self, pycore, module):
        super(GlobalScope, self).__init__(pycore, module, None)
        self.names = module._get_concluded_data()

    def get_start(self):
        return 1

    def get_kind(self):
        return 'Module'

    def get_name(self, name):
        try:
            return self.pyobject[name]
        except exceptions.AttributeNotFoundError:
            if name in self.builtin_names:
                return self.builtin_names[name]
            raise exceptions.NameNotFoundError('name %s not found' % name)

    def get_names(self):
        if self.names.get() is None:
            result = dict(self.builtin_names)
            result.update(super(GlobalScope, self).get_names())
            self.names.set(result)
        return self.names.get()

    def get_inner_scope_for_line(self, lineno, indents=None):
        return self._scope_finder.get_holding_scope(self, lineno, indents)

    def get_inner_scope_for_offset(self, offset):
        return self._scope_finder.get_holding_scope_for_offset(self, offset)

    @property
    @utils.saveit
    def _scope_finder(self):
        return _HoldingScopeFinder(self.pyobject)

    @property
    def builtin_names(self):
        return rope.base.builtins.builtins.get_attributes()


class FunctionScope(Scope):

    def __init__(self, pycore, pyobject, visitor):
        super(FunctionScope, self).__init__(pycore, pyobject,
                                            pyobject.parent.get_scope())
        self.names = None
        self.returned_asts = None
        self.is_generator = None
        self.defineds = None
        self.visitor = visitor

    def _get_names(self):
        if self.names is None:
            self._visit_function()
        return self.names

    def _visit_function(self):
        if self.names is None:
            new_visitor = self.visitor(self.pycore, self.pyobject)
            for n in ast.get_child_nodes(self.pyobject.get_ast()):
                ast.walk(n, new_visitor)
            self.names = new_visitor.names
            self.names.update(self.pyobject.get_parameters())
            self.returned_asts = new_visitor.returned_asts
            self.is_generator = new_visitor.generator
            self.defineds = new_visitor.defineds

    def _get_returned_asts(self):
        if self.names is None:
            self._visit_function()
        return self.returned_asts

    def _is_generator(self):
        if self.is_generator is None:
            self._get_returned_asts()
        return self.is_generator

    def get_names(self):
        return self._get_names()

    def _create_scopes(self):
        if self.defineds is None:
            self._visit_function()
        return [pydefined.get_scope() for pydefined in self.defineds]

    def get_kind(self):
        return 'Function'

    def invalidate_data(self):
        for pyname in self.get_names().values():
            if isinstance(pyname, (rope.base.pynames.AssignedName,
                                   rope.base.pynames.EvaluatedName)):
                pyname.invalidate()


class ClassScope(Scope):

    def __init__(self, pycore, pyobject):
        super(ClassScope, self).__init__(pycore, pyobject,
                                         pyobject.parent.get_scope())

    def get_kind(self):
        return 'Class'

    def get_propagated_names(self):
        return {}


class _HoldingScopeFinder(object):

    def __init__(self, pymodule):
        self.pymodule = pymodule

    def get_indents(self, lineno):
        return rope.base.codeanalyze.count_line_indents(
            self.lines.get_line(lineno))

    def _get_scope_indents(self, scope):
        return self.get_indents(scope.get_start())

    def get_holding_scope(self, module_scope, lineno, line_indents=None):
        if line_indents is None:
            line_indents = self.get_indents(lineno)
        current_scope = module_scope
        new_scope = current_scope
        while new_scope is not None and \
              (new_scope.get_kind() == 'Module' or
               self._get_scope_indents(new_scope) <= line_indents):
            current_scope = new_scope
            if current_scope.get_start() == lineno and \
               current_scope.get_kind() != 'Module':
                return current_scope
            new_scope = None
            for scope in current_scope.get_scopes():
                if scope.get_start() <= lineno:
                    if lineno <= scope.get_end():
                        new_scope = scope
                        break
                else:
                    break
        return current_scope

    def _is_empty_line(self, lineno):
        line = self.lines.get_line(lineno)
        return line.strip() == '' or line.lstrip().startswith('#')

    def _get_body_indents(self, scope):
        return self.get_indents(scope.get_body_start())

    def get_holding_scope_for_offset(self, scope, offset):
        return self.get_holding_scope(
            scope, self.lines.get_line_number(offset))

    def find_scope_end(self, scope):
        if not scope.parent:
            return self.lines.length()
        end = scope.pyobject.get_ast().body[-1].lineno
        scope_start = self.pymodule.logical_lines.logical_line_in(scope.start)
        if scope_start[1] >= end:
            # handling one-liners
            body_indents = self._get_scope_indents(scope) + 4
        else:
            body_indents = self._get_body_indents(scope)
        for l in self.logical_lines.generate_starts(
            min(end + 1, self.lines.length()), self.lines.length() + 1):
            if not self._is_empty_line(l):
                if self.get_indents(l) < body_indents:
                    return end
                else:
                    end = l
        return end

    @property
    def lines(self):
        return self.pymodule.lines

    @property
    def code(self):
        return self.pymodule.source_code

    @property
    def logical_lines(self):
        return self.pymodule.logical_lines

class TemporaryScope(Scope):
    """Currently used for list comprehensions and generator expressions

    These scopes do not appear in the `get_scopes()` method of their
    parent scopes.
    """

    def __init__(self, pycore, parent_scope, names):
        super(TemporaryScope, self).__init__(
            pycore, parent_scope.pyobject, parent_scope)
        self.names = names

    def get_names(self):
        return self.names

    def get_defined_names(self):
        return self.names

    def _create_scopes(self):
        return []

    def get_kind(self):
        return 'Temporary'

########NEW FILE########
__FILENAME__ = resourceobserver
import os


class ResourceObserver(object):
    """Provides the interface for observing resources

    `ResourceObserver`\s can be registered using `Project.
    add_observer()`.  But most of the time `FilteredResourceObserver`
    should be used.  `ResourceObserver`\s report all changes passed
    to them and they don't report changes to all resources.  For
    example if a folder is removed, it only calls `removed()` for that
    folder and not its contents.  You can use
    `FilteredResourceObserver` if you are interested in changes only
    to a list of resources.  And you want changes to be reported on
    individual resources.

    """

    def __init__(self, changed=None, moved=None, created=None,
                 removed=None, validate=None):
        self.changed = changed
        self.moved = moved
        self.created = created
        self.removed = removed
        self._validate = validate

    def resource_changed(self, resource):
        """It is called when the resource changes"""
        if self.changed is not None:
            self.changed(resource)

    def resource_moved(self, resource, new_resource):
        """It is called when a resource is moved"""
        if self.moved is not None:
            self.moved(resource, new_resource)

    def resource_created(self, resource):
        """Is called when a new resource is created"""
        if self.created is not None:
            self.created(resource)

    def resource_removed(self, resource):
        """Is called when a new resource is removed"""
        if self.removed is not None:
            self.removed(resource)

    def validate(self, resource):
        """Validate the existence of this resource and its children.

        This function is called when rope need to update its resource
        cache about the files that might have been changed or removed
        by other processes.

        """
        if self._validate is not None:
            self._validate(resource)


class FilteredResourceObserver(object):
    """A useful decorator for `ResourceObserver`

    Most resource observers have a list of resources and are
    interested only in changes to those files.  This class satisfies
    this need.  It dispatches resource changed and removed messages.
    It performs these tasks:

    * Changes to files and folders are analyzed to check whether any
      of the interesting resources are changed or not.  If they are,
      it reports these changes to `resource_observer` passed to the
      constructor.
    * When a resource is removed it checks whether any of the
      interesting resources are contained in that folder and reports
      them to `resource_observer`.
    * When validating a folder it validates all of the interesting
      files in that folder.

    Since most resource observers are interested in a list of
    resources that change over time, `add_resource` and
    `remove_resource` might be useful.

    """

    def __init__(self, resource_observer, initial_resources=None,
                 timekeeper=None):
        self.observer = resource_observer
        self.resources = {}
        if timekeeper is not None:
            self.timekeeper = timekeeper
        else:
            self.timekeeper = ChangeIndicator()
        if initial_resources is not None:
            for resource in initial_resources:
                self.add_resource(resource)

    def add_resource(self, resource):
        """Add a resource to the list of interesting resources"""
        if resource.exists():
            self.resources[resource] = self.timekeeper.get_indicator(resource)
        else:
            self.resources[resource] = None

    def remove_resource(self, resource):
        """Add a resource to the list of interesting resources"""
        if resource in self.resources:
            del self.resources[resource]

    def clear_resources(self):
        """Removes all registered resources"""
        self.resources.clear()

    def resource_changed(self, resource):
        changes = _Changes()
        self._update_changes_caused_by_changed(changes, resource)
        self._perform_changes(changes)

    def _update_changes_caused_by_changed(self, changes, changed):
        if changed in self.resources:
            changes.add_changed(changed)
        if self._is_parent_changed(changed):
            changes.add_changed(changed.parent)

    def _update_changes_caused_by_moved(self, changes, resource,
                                        new_resource=None):
        if resource in self.resources:
            changes.add_removed(resource, new_resource)
        if new_resource in self.resources:
            changes.add_created(new_resource)
        if resource.is_folder():
            for file in list(self.resources):
                if resource.contains(file):
                    new_file = self._calculate_new_resource(
                        resource, new_resource, file)
                    changes.add_removed(file, new_file)
        if self._is_parent_changed(resource):
            changes.add_changed(resource.parent)
        if new_resource is not None:
            if self._is_parent_changed(new_resource):
                changes.add_changed(new_resource.parent)

    def _is_parent_changed(self, child):
        return child.parent in self.resources

    def resource_moved(self, resource, new_resource):
        changes = _Changes()
        self._update_changes_caused_by_moved(changes, resource, new_resource)
        self._perform_changes(changes)

    def resource_created(self, resource):
        changes = _Changes()
        self._update_changes_caused_by_created(changes, resource)
        self._perform_changes(changes)

    def _update_changes_caused_by_created(self, changes, resource):
        if resource in self.resources:
            changes.add_created(resource)
        if self._is_parent_changed(resource):
            changes.add_changed(resource.parent)

    def resource_removed(self, resource):
        changes = _Changes()
        self._update_changes_caused_by_moved(changes, resource)
        self._perform_changes(changes)

    def _perform_changes(self, changes):
        for resource in changes.changes:
            self.observer.resource_changed(resource)
            self.resources[resource] = self.timekeeper.get_indicator(resource)
        for resource, new_resource in changes.moves.items():
            self.resources[resource] = None
            if new_resource is not None:
                self.observer.resource_moved(resource, new_resource)
            else:
                self.observer.resource_removed(resource)
        for resource in changes.creations:
            self.observer.resource_created(resource)
            self.resources[resource] = self.timekeeper.get_indicator(resource)

    def validate(self, resource):
        changes = _Changes()
        for file in self._search_resource_moves(resource):
            if file in self.resources:
                self._update_changes_caused_by_moved(changes, file)
        for file in self._search_resource_changes(resource):
            if file in self.resources:
                self._update_changes_caused_by_changed(changes, file)
        for file in self._search_resource_creations(resource):
            if file in self.resources:
                changes.add_created(file)
        self._perform_changes(changes)

    def _search_resource_creations(self, resource):
        creations = set()
        if resource in self.resources and resource.exists() and \
           self.resources[resource] is None:
            creations.add(resource)
        if resource.is_folder():
            for file in self.resources:
                if file.exists() and resource.contains(file) and \
                   self.resources[file] is None:
                    creations.add(file)
        return creations

    def _search_resource_moves(self, resource):
        all_moved = set()
        if resource in self.resources and not resource.exists():
            all_moved.add(resource)
        if resource.is_folder():
            for file in self.resources:
                if resource.contains(file):
                    if not file.exists():
                        all_moved.add(file)
        moved = set(all_moved)
        for folder in [file for file in all_moved if file.is_folder()]:
            if folder in moved:
                for file in list(moved):
                    if folder.contains(file):
                        moved.remove(file)
        return moved

    def _search_resource_changes(self, resource):
        changed = set()
        if resource in self.resources and self._is_changed(resource):
            changed.add(resource)
        if resource.is_folder():
            for file in self.resources:
                if file.exists() and resource.contains(file):
                    if self._is_changed(file):
                        changed.add(file)
        return changed

    def _is_changed(self, resource):
        if self.resources[resource] is None:
            return False
        return self.resources[resource] != self.timekeeper.get_indicator(resource)

    def _calculate_new_resource(self, main, new_main, resource):
        if new_main is None:
            return None
        diff = resource.path[len(main.path):]
        return resource.project.get_resource(new_main.path + diff)


class ChangeIndicator(object):

    def get_indicator(self, resource):
        """Return the modification time and size of a `Resource`."""
        path = resource.real_path
        # on dos, mtime does not change for a folder when files are added
        if os.name != 'posix' and os.path.isdir(path):
            return (os.path.getmtime(path),
                    len(os.listdir(path)),
                    os.path.getsize(path))
        return (os.path.getmtime(path),
                os.path.getsize(path))


class _Changes(object):

    def __init__(self):
        self.changes = set()
        self.creations = set()
        self.moves = {}

    def add_changed(self, resource):
        self.changes.add(resource)

    def add_removed(self, resource, new_resource=None):
        self.moves[resource] = new_resource

    def add_created(self, resource):
        self.creations.add(resource)

########NEW FILE########
__FILENAME__ = resources
import os
import re

import rope.base.change
import rope.base.fscommands
from rope.base import exceptions


class Resource(object):
    """Represents files and folders in a project"""

    def __init__(self, project, path):
        self.project = project
        self._path = path

    def move(self, new_location):
        """Move resource to `new_location`"""
        self._perform_change(rope.base.change.MoveResource(self, new_location),
                             'Moving <%s> to <%s>' % (self.path, new_location))

    def remove(self):
        """Remove resource from the project"""
        self._perform_change(rope.base.change.RemoveResource(self),
                             'Removing <%s>' % self.path)

    def is_folder(self):
        """Return true if the resource is a folder"""

    def create(self):
        """Create this resource"""

    def exists(self):
        return os.path.exists(self.real_path)

    @property
    def parent(self):
        parent = '/'.join(self.path.split('/')[0:-1])
        return self.project.get_folder(parent)

    @property
    def path(self):
        """Return the path of this resource relative to the project root

        The path is the list of parent directories separated by '/' followed
        by the resource name.
        """
        return self._path

    @property
    def name(self):
        """Return the name of this resource"""
        return self.path.split('/')[-1]

    @property
    def real_path(self):
        """Return the file system path of this resource"""
        return self.project._get_resource_path(self.path)

    def __eq__(self, obj):
        return self.__class__ == obj.__class__ and self.path == obj.path

    def __ne__(self, obj):
        return not self.__eq__(obj)

    def __hash__(self):
        return hash(self.path)

    def _perform_change(self, change_, description):
        changes = rope.base.change.ChangeSet(description)
        changes.add_change(change_)
        self.project.do(changes)


class File(Resource):
    """Represents a file"""

    def __init__(self, project, name):
        super(File, self).__init__(project, name)

    def read(self):
        data = self.read_bytes()
        try:
            return rope.base.fscommands.file_data_to_unicode(data)
        except UnicodeDecodeError as e:
            raise exceptions.ModuleDecodeError(self.path, e.reason)

    def read_bytes(self):
        with open(self.real_path, 'rb') as fi:
            return fi.read()

    def write(self, contents):
        try:
            if contents == self.read():
                return
        except IOError:
            pass
        self._perform_change(rope.base.change.ChangeContents(self, contents),
                             'Writing file <%s>' % self.path)

    def is_folder(self):
        return False

    def create(self):
        self.parent.create_file(self.name)


class Folder(Resource):
    """Represents a folder"""

    def __init__(self, project, name):
        super(Folder, self).__init__(project, name)

    def is_folder(self):
        return True

    def get_children(self):
        """Return the children of this folder"""
        result = []
        for name in os.listdir(self.real_path):
            try:
                child = self.get_child(name)
            except exceptions.ResourceNotFoundError:
                continue
            if not self.project.is_ignored(child):
                result.append(self.get_child(name))
        return result

    def create_file(self, file_name):
        self._perform_change(
            rope.base.change.CreateFile(self, file_name),
            'Creating file <%s>' % self._get_child_path(file_name))
        return self.get_child(file_name)

    def create_folder(self, folder_name):
        self._perform_change(
            rope.base.change.CreateFolder(self, folder_name),
            'Creating folder <%s>' % self._get_child_path(folder_name))
        return self.get_child(folder_name)

    def _get_child_path(self, name):
        if self.path:
            return self.path + '/' + name
        else:
            return name

    def get_child(self, name):
        return self.project.get_resource(self._get_child_path(name))

    def has_child(self, name):
        try:
            self.get_child(name)
            return True
        except exceptions.ResourceNotFoundError:
            return False

    def get_files(self):
        return [resource for resource in self.get_children()
                if not resource.is_folder()]

    def get_folders(self):
        return [resource for resource in self.get_children()
                if resource.is_folder()]

    def contains(self, resource):
        if self == resource:
            return False
        return self.path == '' or resource.path.startswith(self.path + '/')

    def create(self):
        self.parent.create_folder(self.name)


class _ResourceMatcher(object):

    def __init__(self):
        self.patterns = []
        self._compiled_patterns = []

    def set_patterns(self, patterns):
        """Specify which resources to match

        `patterns` is a `list` of `str`\s that can contain ``*`` and
        ``?`` signs for matching resource names.

        """
        self._compiled_patterns = None
        self.patterns = patterns

    def _add_pattern(self, pattern):
        re_pattern = pattern.replace('.', '\\.').\
                     replace('*', '[^/]*').replace('?', '[^/]').\
                     replace('//', '/(.*/)?')
        re_pattern = '^(.*/)?' + re_pattern + '(/.*)?$'
        self.compiled_patterns.append(re.compile(re_pattern))

    def does_match(self, resource):
        for pattern in self.compiled_patterns:
            if pattern.match(resource.path):
                return True
        path = os.path.join(resource.project.address,
                            *resource.path.split('/'))
        if os.path.islink(path):
            return True
        return False

    @property
    def compiled_patterns(self):
        if self._compiled_patterns is None:
            self._compiled_patterns = []
            for pattern in self.patterns:
                self._add_pattern(pattern)
        return self._compiled_patterns

########NEW FILE########
__FILENAME__ = simplify
"""A module to ease code analysis

This module is here to help source code analysis.
"""
import re

from rope.base import codeanalyze, utils


@utils.cached(7)
def real_code(source):
    """Simplify `source` for analysis

    It replaces:

    * comments with spaces
    * strs with a new str filled with spaces
    * implicit and explicit continuations with spaces
    * tabs and semicolons with spaces

    The resulting code is a lot easier to analyze if we are interested
    only in offsets.
    """
    collector = codeanalyze.ChangeCollector(source)
    for start, end in ignored_regions(source):
        if source[start] == '#':
            replacement = ' ' * (end - start)
        else:
            replacement = '"%s"' % (' ' * (end - start - 2))
        collector.add_change(start, end, replacement)
    source = collector.get_changed() or source
    collector = codeanalyze.ChangeCollector(source)
    parens = 0
    for match in _parens.finditer(source):
        i = match.start()
        c = match.group()
        if c in '({[':
            parens += 1
        if c in ')}]':
            parens -= 1
        if c == '\n' and parens > 0:
            collector.add_change(i, i + 1, ' ')
    source = collector.get_changed() or source
    return source.replace('\\\n', '  ').replace('\t', ' ').replace(';', '\n')


@utils.cached(7)
def ignored_regions(source):
    """Return ignored regions like strings and comments in `source` """
    return [(match.start(), match.end()) for match in _str.finditer(source)]


_str = re.compile('%s|%s' % (codeanalyze.get_comment_pattern(),
                             codeanalyze.get_string_pattern()))
_parens = re.compile(r'[\({\[\]}\)\n]')

########NEW FILE########
__FILENAME__ = stdmods
import os
import sys

from rope.base import utils


def _stdlib_path():
    import inspect
    return os.path.dirname(inspect.getsourcefile(inspect))

@utils.cached(1)
def standard_modules():
    return python_modules() | dynload_modules()

@utils.cached(1)
def python_modules():
    result = set()
    lib_path = _stdlib_path()
    if os.path.exists(lib_path):
        for name in os.listdir(lib_path):
            path = os.path.join(lib_path, name)
            if os.path.isdir(path):
                if '-' not in name:
                    result.add(name)
            else:
                if name.endswith('.py'):
                    result.add(name[:-3])
    return result

@utils.cached(1)
def dynload_modules():
    result = set(sys.builtin_module_names)
    dynload_path = os.path.join(_stdlib_path(), 'lib-dynload')
    if os.path.exists(dynload_path):
        for name in os.listdir(dynload_path):
            path = os.path.join(dynload_path, name)
            if os.path.isfile(path):
                if name.endswith('.so') or name.endswith('.dll'):
                    if "cpython" in name:
                        result.add(os.path.splitext(os.path.splitext(name)[0])[0])
                    else:
                        result.add(os.path.splitext(name)[0])
    return result

########NEW FILE########
__FILENAME__ = taskhandle
import warnings

from rope.base import exceptions


class TaskHandle(object):

    def __init__(self, name='Task', interrupts=True):
        """Construct a TaskHandle

        If `interrupts` is `False` the task won't be interrupted by
        calling `TaskHandle.stop()`.

        """
        self.name = name
        self.interrupts = interrupts
        self.stopped = False
        self.job_sets = []
        self.observers = []

    def stop(self):
        """Interrupts the refactoring"""
        if self.interrupts:
            self.stopped = True
            self._inform_observers()

    def current_jobset(self):
        """Return the current `JobSet`"""
        if self.job_sets:
            return self.job_sets[-1]

    def add_observer(self, observer):
        """Register an observer for this task handle

        The observer is notified whenever the task is stopped or
        a job gets finished.

        """
        self.observers.append(observer)

    def is_stopped(self):
        return self.stopped

    def get_jobsets(self):
        return self.job_sets

    def create_jobset(self, name='JobSet', count=None):
        result = JobSet(self, name=name, count=count)
        self.job_sets.append(result)
        self._inform_observers()
        return result

    def _inform_observers(self):
        for observer in list(self.observers):
            observer()


class JobSet(object):

    def __init__(self, handle, name, count):
        self.handle = handle
        self.name = name
        self.count = count
        self.done = 0
        self.job_name = None

    def started_job(self, name):
        self.check_status()
        self.job_name = name
        self.handle._inform_observers()

    def finished_job(self):
        self.check_status()
        self.done += 1
        self.handle._inform_observers()
        self.job_name = None

    def check_status(self):
        if self.handle.is_stopped():
            raise exceptions.InterruptedTaskError()

    def get_active_job_name(self):
        return self.job_name

    def get_percent_done(self):
        if self.count is not None and self.count > 0:
            percent = self.done * 100 // self.count
            return min(percent, 100)

    def get_name(self):
        return self.name


class NullTaskHandle(object):

    def __init__(self):
        pass

    def is_stopped(self):
        return False

    def stop(self):
        pass

    def create_jobset(self, *args, **kwds):
        return NullJobSet()

    def get_jobsets(self):
        return []

    def add_observer(self, observer):
        pass


class NullJobSet(object):

    def started_job(self, name):
        pass

    def finished_job(self):
        pass

    def check_status(self):
        pass

    def get_active_job_name(self):
        pass

    def get_percent_done(self):
        pass

    def get_name(self):
        pass

########NEW FILE########
__FILENAME__ = utils
import warnings


def saveit(func):
    """A decorator that caches the return value of a function"""

    name = '_' + func.__name__
    def _wrapper(self, *args, **kwds):
        if not hasattr(self, name):
            setattr(self, name, func(self, *args, **kwds))
        return getattr(self, name)
    return _wrapper

cacheit = saveit

def prevent_recursion(default):
    """A decorator that returns the return value of `default` in recursions"""
    def decorator(func):
        name = '_calling_%s_' % func.__name__
        def newfunc(self, *args, **kwds):
            if getattr(self, name, False):
                return default()
            setattr(self, name, True)
            try:
                return func(self, *args, **kwds)
            finally:
                setattr(self, name, False)
        return newfunc
    return decorator


def ignore_exception(exception_class):
    """A decorator that ignores `exception_class` exceptions"""
    def _decorator(func):
        def newfunc(*args, **kwds):
            try:
                return func(*args, **kwds)
            except exception_class:
                pass
        return newfunc
    return _decorator


def deprecated(message=None):
    """A decorator for deprecated functions"""
    def _decorator(func, message=message):
        if message is None:
            message = '%s is deprecated' % func.__name__
        def newfunc(*args, **kwds):
            warnings.warn(message, DeprecationWarning, stacklevel=2)
            return func(*args, **kwds)
        return newfunc
    return _decorator


def cached(count):
    """A caching decorator based on parameter objects"""
    def decorator(func):
        return _Cached(func, count)
    return decorator

class _Cached(object):

    def __init__(self, func, count):
        self.func = func
        self.cache = []
        self.count = count

    def __call__(self, *args, **kwds):
        key = (args, kwds)
        for cached_key, cached_result in self.cache:
            if cached_key == key:
                return cached_result
        result = self.func(*args, **kwds)
        self.cache.append((key, result))
        if len(self.cache) > self.count:
            del self.cache[0]
        return result

########NEW FILE########
__FILENAME__ = worder
import bisect
import keyword

import rope.base.simplify


def get_name_at(resource, offset):
    source_code = resource.read()
    word_finder = Worder(source_code)
    return word_finder.get_word_at(offset)


class Worder(object):
    """A class for finding boundaries of words and expressions

    Note that in these methods, offset should be the index of the
    character not the index of the character after it.
    """

    def __init__(self, code, handle_ignores=False):
        simplified = rope.base.simplify.real_code(code)
        self.code_finder = _RealFinder(simplified, code)
        self.handle_ignores = handle_ignores
        self.code = code

    def _init_ignores(self):
        ignores = rope.base.simplify.ignored_regions(self.code)
        self.dumb_finder = _RealFinder(self.code, self.code)
        self.starts = [ignored[0] for ignored in ignores]
        self.ends = [ignored[1] for ignored in ignores]

    def _context_call(self, name, offset):
        if self.handle_ignores:
            if not hasattr(self, 'starts'):
                self._init_ignores()
            start = bisect.bisect(self.starts, offset)
            if start > 0 and offset < self.ends[start - 1]:
                return getattr(self.dumb_finder, name)(offset)
        return getattr(self.code_finder, name)(offset)

    def get_primary_at(self, offset):
        return self._context_call('get_primary_at', offset)

    def get_word_at(self, offset):
        return self._context_call('get_word_at', offset)

    def get_primary_range(self, offset):
        return self._context_call('get_primary_range', offset)

    def get_splitted_primary_before(self, offset):
        return self._context_call('get_splitted_primary_before', offset)

    def get_word_range(self, offset):
        return self._context_call('get_word_range', offset)

    def is_function_keyword_parameter(self, offset):
        return self.code_finder.is_function_keyword_parameter(offset)

    def is_a_class_or_function_name_in_header(self, offset):
        return self.code_finder.is_a_class_or_function_name_in_header(offset)

    def is_from_statement_module(self, offset):
        return self.code_finder.is_from_statement_module(offset)

    def is_from_aliased(self, offset):
        return self.code_finder.is_from_aliased(offset)

    def find_parens_start_from_inside(self, offset):
        return self.code_finder.find_parens_start_from_inside(offset)

    def is_a_name_after_from_import(self, offset):
        return self.code_finder.is_a_name_after_from_import(offset)

    def is_from_statement(self, offset):
        return self.code_finder.is_from_statement(offset)

    def get_from_aliased(self, offset):
        return self.code_finder.get_from_aliased(offset)

    def is_import_statement(self, offset):
        return self.code_finder.is_import_statement(offset)

    def is_assigned_here(self, offset):
        return self.code_finder.is_assigned_here(offset)

    def is_a_function_being_called(self, offset):
        return self.code_finder.is_a_function_being_called(offset)

    def get_word_parens_range(self, offset):
        return self.code_finder.get_word_parens_range(offset)

    def is_name_assigned_in_class_body(self, offset):
        return self.code_finder.is_name_assigned_in_class_body(offset)

    def is_on_function_call_keyword(self, offset):
        return self.code_finder.is_on_function_call_keyword(offset)

    def _find_parens_start(self, offset):
        return self.code_finder._find_parens_start(offset)

    def get_parameters(self, first, last):
        return self.code_finder.get_parameters(first, last)

    def get_from_module(self, offset):
        return self.code_finder.get_from_module(offset)

    def is_assigned_in_a_tuple_assignment(self, offset):
        return self.code_finder.is_assigned_in_a_tuple_assignment(offset)

    def get_assignment_type(self, offset):
        return self.code_finder.get_assignment_type(offset)

    def get_function_and_args_in_header(self, offset):
        return self.code_finder.get_function_and_args_in_header(offset)

    def get_lambda_and_args(self, offset):
        return self.code_finder.get_lambda_and_args(offset)

    def find_function_offset(self, offset):
        return self.code_finder.find_function_offset(offset)


class _RealFinder(object):

    def __init__(self, code, raw):
        self.code = code
        self.raw = raw

    def _find_word_start(self, offset):
        current_offset = offset
        while current_offset >= 0 and self._is_id_char(current_offset):
            current_offset -= 1
        return current_offset + 1

    def _find_word_end(self, offset):
        while offset + 1 < len(self.code) and self._is_id_char(offset + 1):
            offset += 1
        return offset

    def _find_last_non_space_char(self, offset):
        while offset >= 0 and self.code[offset].isspace():
            if self.code[offset] == '\n':
                return offset
            offset -= 1
        return max(-1, offset)

    def get_word_at(self, offset):
        offset = self._get_fixed_offset(offset)
        return self.raw[self._find_word_start(offset):
                        self._find_word_end(offset) + 1]

    def _get_fixed_offset(self, offset):
        if offset >= len(self.code):
            return offset - 1
        if not self._is_id_char(offset):
            if offset > 0 and self._is_id_char(offset - 1):
                return offset - 1
            if offset < len(self.code) - 1 and self._is_id_char(offset + 1):
                return offset + 1
        return offset

    def _is_id_char(self, offset):
        return self.code[offset].isalnum() or self.code[offset] == '_'

    def _find_string_start(self, offset):
        kind = self.code[offset]
        try:
            return self.code.rindex(kind, 0, offset)
        except ValueError:
            return 0

    def _find_parens_start(self, offset):
        offset = self._find_last_non_space_char(offset - 1)
        while offset >= 0 and self.code[offset] not in '[({':
            if self.code[offset] not in ':,':
                offset = self._find_primary_start(offset)
            offset = self._find_last_non_space_char(offset - 1)
        return offset

    def _find_atom_start(self, offset):
        old_offset = offset
        if self.code[offset] == '\n':
            return offset + 1
        if self.code[offset].isspace():
            offset = self._find_last_non_space_char(offset)
        if self.code[offset] in '\'"':
            return self._find_string_start(offset)
        if self.code[offset] in ')]}':
            return self._find_parens_start(offset)
        if self._is_id_char(offset):
            return self._find_word_start(offset)
        return old_offset

    def _find_primary_without_dot_start(self, offset):
        """It tries to find the undotted primary start

        It is different from `self._get_atom_start()` in that it
        follows function calls, too; such as in ``f(x)``.

        """
        last_atom = offset
        offset = self._find_last_non_space_char(last_atom)
        while offset > 0 and self.code[offset] in ')]':
            last_atom = self._find_parens_start(offset)
            offset = self._find_last_non_space_char(last_atom - 1)
        if offset >= 0 and (self.code[offset] in '"\'})]' or
                            self._is_id_char(offset)):
            atom_start = self._find_atom_start(offset)
            if not keyword.iskeyword(self.code[atom_start:offset + 1]):
                return atom_start
        return last_atom

    def _find_primary_start(self, offset):
        if offset >= len(self.code):
            offset = len(self.code) - 1
        if self.code[offset] != '.':
            offset = self._find_primary_without_dot_start(offset)
        else:
            offset = offset + 1
        while offset > 0:
            prev = self._find_last_non_space_char(offset - 1)
            if offset <= 0 or self.code[prev] != '.':
                break
            offset = self._find_primary_without_dot_start(prev - 1)
            if not self._is_id_char(offset):
                break

        return offset

    def get_primary_at(self, offset):
        offset = self._get_fixed_offset(offset)
        start, end = self.get_primary_range(offset)
        return self.raw[start:end].strip()

    def get_splitted_primary_before(self, offset):
        """returns expression, starting, starting_offset

        This function is used in `rope.codeassist.assist` function.
        """
        if offset == 0:
            return ('', '', 0)
        end = offset - 1
        word_start = self._find_atom_start(end)
        real_start = self._find_primary_start(end)
        if self.code[word_start:offset].strip() == '':
            word_start = end
        if self.code[end].isspace():
            word_start = end
        if self.code[real_start:word_start].strip() == '':
            real_start = word_start
        if real_start == word_start == end and not self._is_id_char(end):
            return ('', '', offset)
        if real_start == word_start:
            return ('', self.raw[word_start:offset], word_start)
        else:
            if self.code[end] == '.':
                return (self.raw[real_start:end], '', offset)
            last_dot_position = word_start
            if self.code[word_start] != '.':
                last_dot_position = self._find_last_non_space_char(word_start - 1)
            last_char_position = self._find_last_non_space_char(last_dot_position - 1)
            if self.code[word_start].isspace():
                word_start = offset
            return (self.raw[real_start:last_char_position + 1],
                    self.raw[word_start:offset], word_start)

    def _get_line_start(self, offset):
        try:
            return self.code.rindex('\n', 0, offset + 1)
        except ValueError:
            return 0

    def _get_line_end(self, offset):
        try:
            return self.code.index('\n', offset)
        except ValueError:
            return len(self.code)

    def is_name_assigned_in_class_body(self, offset):
        word_start = self._find_word_start(offset - 1)
        word_end = self._find_word_end(offset) + 1
        if '.' in self.code[word_start:word_end]:
            return False
        line_start = self._get_line_start(word_start)
        line = self.code[line_start:word_start].strip()
        return not line and self.get_assignment_type(offset) == '='

    def is_a_class_or_function_name_in_header(self, offset):
        word_start = self._find_word_start(offset - 1)
        line_start = self._get_line_start(word_start)
        prev_word = self.code[line_start:word_start].strip()
        return prev_word in ['def', 'class']

    def _find_first_non_space_char(self, offset):
        if offset >= len(self.code):
            return len(self.code)
        while offset < len(self.code) and self.code[offset].isspace():
            if self.code[offset] == '\n':
                return offset
            offset += 1
        return offset

    def is_a_function_being_called(self, offset):
        word_end = self._find_word_end(offset) + 1
        next_char = self._find_first_non_space_char(word_end)
        return next_char < len(self.code) and \
               self.code[next_char] == '(' and \
               not self.is_a_class_or_function_name_in_header(offset)

    def _find_import_end(self, start):
        return self._get_line_end(start)

    def is_import_statement(self, offset):
        try:
            last_import = self.code.rindex('import ', 0, offset)
        except ValueError:
            return False
        return self._find_import_end(last_import + 7) >= offset

    def is_from_statement(self, offset):
        try:
            last_from = self.code.rindex('from ', 0, offset)
            from_import = self.code.index(' import ', last_from)
            from_names = from_import + 8
        except ValueError:
            return False
        from_names = self._find_first_non_space_char(from_names)
        return self._find_import_end(from_names) >= offset

    def is_from_statement_module(self, offset):
        if offset >= len(self.code) - 1:
            return False
        stmt_start = self._find_primary_start(offset)
        line_start = self._get_line_start(stmt_start)
        prev_word = self.code[line_start:stmt_start].strip()
        return prev_word == 'from'

    def is_a_name_after_from_import(self, offset):
        try:
            if len(self.code) > offset and  self.code[offset] == '\n':
                line_start = self._get_line_start(offset - 1)
            else:
                line_start = self._get_line_start(offset)
            last_from = self.code.rindex('from ', line_start, offset)
            from_import = self.code.index(' import ', last_from)
            from_names = from_import + 8
        except ValueError:
            return False
        if from_names - 1 > offset:
            return False
        return self._find_import_end(from_names) >= offset

    def get_from_module(self, offset):
        try:
            last_from = self.code.rindex('from ', 0, offset)
            import_offset = self.code.index(' import ', last_from)
            end = self._find_last_non_space_char(import_offset)
            return self.get_primary_at(end)
        except ValueError:
            pass

    def is_from_aliased(self, offset):
        if not self.is_a_name_after_from_import(offset):
            return False
        try:
            end = self._find_word_end(offset)
            as_end = min(self._find_word_end(end + 1), len(self.code))
            as_start = self._find_word_start(as_end)
            if self.code[as_start:as_end + 1] == 'as':
                return True
        except ValueError:
            return False

    def get_from_aliased(self, offset):
        try:
            end = self._find_word_end(offset)
            as_ = self._find_word_end(end + 1)
            alias = self._find_word_end(as_ + 1)
            start = self._find_word_start(alias)
            return self.raw[start:alias + 1]
        except ValueError:
            pass

    def is_function_keyword_parameter(self, offset):
        word_end = self._find_word_end(offset)
        if word_end + 1 == len(self.code):
            return False
        next_char = self._find_first_non_space_char(word_end + 1)
        equals = self.code[next_char:next_char + 2]
        if equals == '==' or not equals.startswith('='):
            return False
        word_start = self._find_word_start(offset)
        prev_char = self._find_last_non_space_char(word_start - 1)
        return prev_char - 1 >= 0 and self.code[prev_char] in ',('

    def is_on_function_call_keyword(self, offset):
        stop = self._get_line_start(offset)
        if self._is_id_char(offset):
            offset = self._find_word_start(offset) - 1
        offset = self._find_last_non_space_char(offset)
        if offset <= stop or self.code[offset] not in '(,':
            return False
        parens_start = self.find_parens_start_from_inside(offset)
        return stop < parens_start

    def find_parens_start_from_inside(self, offset):
        stop = self._get_line_start(offset)
        opens = 1
        while offset > stop:
            if self.code[offset] == '(':
                break
            if self.code[offset] != ',':
                offset = self._find_primary_start(offset)
            offset -= 1
        return max(stop, offset)

    def is_assigned_here(self, offset):
        return self.get_assignment_type(offset) is not None

    def get_assignment_type(self, offset):
        # XXX: does not handle tuple assignments
        word_end = self._find_word_end(offset)
        next_char = self._find_first_non_space_char(word_end + 1)
        single = self.code[next_char:next_char + 1]
        double = self.code[next_char:next_char + 2]
        triple = self.code[next_char:next_char + 3]
        if double not in ('==', '<=', '>=', '!='):
            for op in [single, double, triple]:
                if op.endswith('='):
                    return op

    def get_primary_range(self, offset):
        start = self._find_primary_start(offset)
        end = self._find_word_end(offset) + 1
        return (start, end)

    def get_word_range(self, offset):
        offset = max(0, offset)
        start = self._find_word_start(offset)
        end = self._find_word_end(offset) + 1
        return (start, end)

    def get_word_parens_range(self, offset, opening='(', closing=')'):
        end = self._find_word_end(offset)
        start_parens = self.code.index(opening, end)
        index = start_parens
        open_count = 0
        while index < len(self.code):
            if self.code[index] == opening:
                open_count += 1
            if self.code[index] == closing:
                open_count -= 1
            if open_count == 0:
                return (start_parens, index + 1)
            index += 1
        return (start_parens, index)

    def get_parameters(self, first, last):
        keywords = []
        args = []
        current = self._find_last_non_space_char(last - 1)
        while current > first:
            primary_start = current
            current = self._find_primary_start(current)
            while current != first and self.code[current] not in '=,':
                current = self._find_last_non_space_char(current - 1)
            primary = self.raw[current + 1:primary_start + 1].strip()
            if self.code[current] == '=':
                primary_start = current - 1
                current -= 1
                while current != first and self.code[current] not in ',':
                    current = self._find_last_non_space_char(current - 1)
                param_name = self.raw[current + 1:primary_start + 1].strip()
                keywords.append((param_name, primary))
            else:
                args.append(primary)
            current = self._find_last_non_space_char(current - 1)
        args.reverse()
        keywords.reverse()
        return args, keywords

    def is_assigned_in_a_tuple_assignment(self, offset):
        start = self._get_line_start(offset)
        end = self._get_line_end(offset)
        primary_start = self._find_primary_start(offset)
        primary_end = self._find_word_end(offset)

        prev_char_offset = self._find_last_non_space_char(primary_start - 1)
        next_char_offset = self._find_first_non_space_char(primary_end + 1)
        next_char = prev_char = ''
        if prev_char_offset >= start:
            prev_char = self.code[prev_char_offset]
        if next_char_offset < end:
            next_char = self.code[next_char_offset]
        try:
            equals_offset = self.code.index('=', start, end)
        except ValueError:
            return False
        if prev_char not in '(,' and next_char not in ',)':
            return False
        parens_start = self.find_parens_start_from_inside(offset)
        # XXX: only handling (x, y) = value
        return offset < equals_offset and \
               self.code[start:parens_start].strip() == ''

    def get_function_and_args_in_header(self, offset):
        offset = self.find_function_offset(offset)
        lparens, rparens = self.get_word_parens_range(offset)
        return self.raw[offset:rparens + 1]

    def find_function_offset(self, offset, definition='def '):
        while True:
            offset = self.code.index(definition, offset)
            if offset == 0 or not self._is_id_char(offset - 1):
                break
            offset += 1
        def_ = offset + 4
        return self._find_first_non_space_char(def_)

    def get_lambda_and_args(self, offset):
        offset = self.find_function_offset(offset, definition = 'lambda ')
        lparens, rparens = self.get_word_parens_range(offset, opening=' ', closing=':')
        return self.raw[offset:rparens + 1]


########NEW FILE########
__FILENAME__ = autoimport
import re

from rope.base import (exceptions, pynames, resourceobserver,
                       taskhandle, pyobjects, builtins, resources)
from rope.refactor import importutils


class AutoImport(object):
    """A class for finding the module that provides a name

    This class maintains a cache of global names in python modules.
    Note that this cache is not accurate and might be out of date.

    """

    def __init__(self, project, observe=True, underlined=False):
        """Construct an AutoImport object

        If `observe` is `True`, listen for project changes and update
        the cache.

        If `underlined` is `True`, underlined names are cached, too.
        """
        self.project = project
        self.underlined = underlined
        self.names = project.data_files.read_data('globalnames')
        if self.names is None:
            self.names = {}
        project.data_files.add_write_hook(self._write)
        # XXX: using a filtered observer
        observer = resourceobserver.ResourceObserver(
            changed=self._changed, moved=self._moved, removed=self._removed)
        if observe:
            project.add_observer(observer)

    def import_assist(self, starting):
        """Return a list of ``(name, module)`` tuples

        This function tries to find modules that have a global name
        that starts with `starting`.
        """
        # XXX: breaking if gave up! use generators
        result = []
        for module in self.names:
            for global_name in self.names[module]:
                if global_name.startswith(starting):
                    result.append((global_name, module))
        return result

    def get_modules(self, name):
        """Return the list of modules that have global `name`"""
        result = []
        for module in self.names:
            if name in self.names[module]:
                result.append(module)
        return result

    def get_all_names(self):
        """Return the list of all cached global names"""
        result = set()
        for module in self.names:
            result.update(set(self.names[module]))
        return result

    def get_name_locations(self, name):
        """Return a list of ``(resource, lineno)`` tuples"""
        result = []
        pycore = self.project.pycore
        for module in self.names:
            if name in self.names[module]:
                try:
                    pymodule = pycore.get_module(module)
                    if name in pymodule:
                        pyname = pymodule[name]
                        module, lineno = pyname.get_definition_location()
                        if module is not None:
                            resource = module.get_module().get_resource()
                            if resource is not None and lineno is not None:
                                result.append((resource, lineno))
                except exceptions.ModuleNotFoundError:
                    pass
        return result

    def generate_cache(self, resources=None, underlined=None,
                       task_handle=taskhandle.NullTaskHandle()):
        """Generate global name cache for project files

        If `resources` is a list of `rope.base.resource.File`\s, only
        those files are searched; otherwise all python modules in the
        project are cached.

        """
        if resources is None:
            resources = self.project.pycore.get_python_files()
        job_set = task_handle.create_jobset(
            'Generatig autoimport cache', len(resources))
        for file in resources:
            job_set.started_job('Working on <%s>' % file.path)
            self.update_resource(file, underlined)
            job_set.finished_job()

    def generate_modules_cache(self, modules, underlined=None,
                               task_handle=taskhandle.NullTaskHandle()):
        """Generate global name cache for modules listed in `modules`"""
        job_set = task_handle.create_jobset(
            'Generatig autoimport cache for modules', len(modules))
        for modname in modules:
            job_set.started_job('Working on <%s>' % modname)
            if modname.endswith('.*'):
                mod = self.project.pycore.find_module(modname[:-2])
                if mod:
                    for sub in submodules(mod):
                        self.update_resource(sub, underlined)
            else:
                self.update_module(modname, underlined)
            job_set.finished_job()

    def clear_cache(self):
        """Clear all entries in global-name cache

        It might be a good idea to use this function before
        regenerating global names.

        """
        self.names.clear()

    def find_insertion_line(self, code):
        """Guess at what line the new import should be inserted"""
        match = re.search(r'^(def|class)\s+', code)
        if match is not None:
            code = code[:match.start()]
        try:
            pymodule = self.project.pycore.get_string_module(code)
        except exceptions.ModuleSyntaxError:
            return 1
        testmodname = '__rope_testmodule_rope'
        importinfo = importutils.NormalImport(((testmodname, None),))
        module_imports = importutils.get_module_imports(
            self.project.pycore, pymodule)
        module_imports.add_import(importinfo)
        code = module_imports.get_changed_source()
        offset = code.index(testmodname)
        lineno = code.count('\n', 0, offset) + 1
        return lineno

    def update_resource(self, resource, underlined=None):
        """Update the cache for global names in `resource`"""
        try:
            pymodule = self.project.pycore.resource_to_pyobject(resource)
            modname = self._module_name(resource)
            self._add_names(pymodule, modname, underlined)
        except exceptions.ModuleSyntaxError:
            pass

    def update_module(self, modname, underlined=None):
        """Update the cache for global names in `modname` module

        `modname` is the name of a module.
        """
        try:
            pymodule = self.project.pycore.get_module(modname)
            self._add_names(pymodule, modname, underlined)
        except exceptions.ModuleNotFoundError:
            pass

    def _module_name(self, resource):
        return self.project.pycore.modname(resource)

    def _add_names(self, pymodule, modname, underlined):
        if underlined is None:
            underlined = self.underlined
        globals = []
        if isinstance(pymodule, pyobjects.PyDefinedObject):
            attributes = pymodule._get_structural_attributes()
        else:
            attributes = pymodule.get_attributes()
        for name, pyname in attributes.items():
            if not underlined and name.startswith('_'):
                continue
            if isinstance(pyname, (pynames.AssignedName, pynames.DefinedName)):
                globals.append(name)
            if isinstance(pymodule, builtins.BuiltinModule):
                globals.append(name)
        self.names[modname] = globals

    def _write(self):
        self.project.data_files.write_data('globalnames', self.names)

    def _changed(self, resource):
        if not resource.is_folder():
            self.update_resource(resource)

    def _moved(self, resource, newresource):
        if not resource.is_folder():
            modname = self._module_name(resource)
            if modname in self.names:
                del self.names[modname]
            self.update_resource(newresource)

    def _removed(self, resource):
        if not resource.is_folder():
            modname = self._module_name(resource)
            if modname in self.names:
                del self.names[modname]


def submodules(mod):
    if isinstance(mod, resources.File):
        if mod.name.endswith('.py') and mod.name != '__init__.py':
            return set([mod])
        return set()
    if not mod.has_child('__init__.py'):
        return set()
    result = set([mod])
    for child in mod.get_children():
        result |= submodules(child)
    return result

########NEW FILE########
__FILENAME__ = changestack
"""For performing many refactorings as a single command

`changestack` module can be used to perform many refactorings on top
of each other as one bigger command.  It can be used like::

  stack = ChangeStack(project, 'my big command')

  #..
  stack.push(refactoring1.get_changes())
  #..
  stack.push(refactoring2.get_changes())
  #..
  stack.push(refactoringX.get_changes())

  stack.pop_all()
  changes = stack.merged()

Now `changes` can be previewed or performed as before.
"""

from rope.base import change


class ChangeStack(object):

    def __init__(self, project, description='merged changes'):
        self.project = project
        self.description = description
        self.stack = []

    def push(self, changes):
        self.stack.append(changes)
        self.project.do(changes)

    def pop_all(self):
        for i in range(len(self.stack)):
            self.project.history.undo(drop=True)

    def merged(self):
        result = change.ChangeSet(self.description)
        for changes in self.stack:
            for c in self._basic_changes(changes):
                result.add_change(c)
        return result

    def _basic_changes(self, changes):
        if isinstance(changes, change.ChangeSet):
            for child in changes.changes:
                for atom in self._basic_changes(child):
                    yield atom
        else:
            yield changes

########NEW FILE########
__FILENAME__ = codeassist
import keyword
import sys
import warnings

import rope.base.codeanalyze
import rope.base.evaluate
from rope.base import pyobjects, pyobjectsdef, pynames, builtins, exceptions, worder
from rope.base.codeanalyze import SourceLinesAdapter
from rope.contrib import fixsyntax
from rope.refactor import functionutils


def code_assist(project, source_code, offset, resource=None,
                templates=None, maxfixes=1, later_locals=True):
    """Return python code completions as a list of `CodeAssistProposal`\s

    `resource` is a `rope.base.resources.Resource` object.  If
    provided, relative imports are handled.

    `maxfixes` is the maximum number of errors to fix if the code has
    errors in it.

    If `later_locals` is `False` names defined in this scope and after
    this line is ignored.

    """
    if templates is not None:
        warnings.warn('Codeassist no longer supports templates',
                      DeprecationWarning, stacklevel=2)
    assist = _PythonCodeAssist(
        project, source_code, offset, resource=resource,
        maxfixes=maxfixes, later_locals=later_locals)
    return assist()


def starting_offset(source_code, offset):
    """Return the offset in which the completion should be inserted

    Usually code assist proposals should be inserted like::

        completion = proposal.name
        result = (source_code[:starting_offset] +
                  completion + source_code[offset:])

    Where starting_offset is the offset returned by this function.

    """
    word_finder = worder.Worder(source_code, True)
    expression, starting, starting_offset = \
        word_finder.get_splitted_primary_before(offset)
    return starting_offset


def get_doc(project, source_code, offset, resource=None, maxfixes=1):
    """Get the pydoc"""
    fixer = fixsyntax.FixSyntax(project.pycore, source_code,
                                resource, maxfixes)
    pymodule = fixer.get_pymodule()
    pyname = fixer.pyname_at(offset)
    if pyname is None:
        return None
    pyobject = pyname.get_object()
    return PyDocExtractor().get_doc(pyobject)


def get_calltip(project, source_code, offset, resource=None,
                maxfixes=1, ignore_unknown=False, remove_self=False):
    """Get the calltip of a function

    The format of the returned string is
    ``module_name.holding_scope_names.function_name(arguments)``.  For
    classes `__init__()` and for normal objects `__call__()` function
    is used.

    Note that the offset is on the function itself *not* after the its
    open parenthesis.  (Actually it used to be the other way but it
    was easily confused when string literals were involved.  So I
    decided it is better for it not to try to be too clever when it
    cannot be clever enough).  You can use a simple search like::

        offset = source_code.rindex('(', 0, offset) - 1

    to handle simple situations.

    If `ignore_unknown` is `True`, `None` is returned for functions
    without source-code like builtins and extensions.

    If `remove_self` is `True`, the first parameter whose name is self
    will be removed for methods.
    """
    fixer = fixsyntax.FixSyntax(project.pycore, source_code,
                                resource, maxfixes)
    pymodule = fixer.get_pymodule()
    pyname = fixer.pyname_at(offset)
    if pyname is None:
        return None
    pyobject = pyname.get_object()
    return PyDocExtractor().get_calltip(pyobject, ignore_unknown, remove_self)


def get_definition_location(project, source_code, offset,
                            resource=None, maxfixes=1):
    """Return the definition location of the python name at `offset`

    Return a (`rope.base.resources.Resource`, lineno) tuple.  If no
    `resource` is given and the definition is inside the same module,
    the first element of the returned tuple would be `None`.  If the
    location cannot be determined ``(None, None)`` is returned.

    """
    fixer = fixsyntax.FixSyntax(project.pycore, source_code,
                                resource, maxfixes)
    pymodule = fixer.get_pymodule()
    pyname = fixer.pyname_at(offset)
    if pyname is not None:
        module, lineno = pyname.get_definition_location()
        if module is not None:
            return module.get_module().get_resource(), lineno
    return (None, None)


def find_occurrences(*args, **kwds):
    import rope.contrib.findit
    warnings.warn('Use `rope.contrib.findit.find_occurrences()` instead',
                  DeprecationWarning, stacklevel=2)
    return rope.contrib.findit.find_occurrences(*args, **kwds)


class CompletionProposal(object):
    """A completion proposal

    The `scope` instance variable shows where proposed name came from
    and can be 'global', 'local', 'builtin', 'attribute', 'keyword',
    'imported', 'parameter_keyword'.

    The `type` instance variable shows the approximate type of the
    proposed object and can be 'instance', 'class', 'function', 'module',
    and `None`.

    All possible relations between proposal's `scope` and `type` are shown
    in the table below (different scopes in rows and types in columns):

                      | instance | class | function | module | None
                local |    +     |   +   |    +     |   +    |
               global |    +     |   +   |    +     |   +    |
              builtin |    +     |   +   |    +     |        |
            attribute |    +     |   +   |    +     |   +    |
             imported |    +     |   +   |    +     |   +    |
              keyword |          |       |          |        |  +
    parameter_keyword |          |       |          |        |  +

    """

    def __init__(self, name, scope, pyname=None):
        self.name = name
        self.pyname = pyname
        self.scope = self._get_scope(scope)

    def __str__(self):
        return '%s (%s, %s)' % (self.name, self.scope, self.type)

    def __repr__(self):
        return str(self)

    @property
    def parameters(self):
        """The names of the parameters the function takes.

        Returns None if this completion is not a function.
        """
        pyname = self.pyname
        if isinstance(pyname, pynames.ImportedName):
            pyname = pyname._get_imported_pyname()
        if isinstance(pyname, pynames.DefinedName):
            pyobject = pyname.get_object()
            if isinstance(pyobject, pyobjects.AbstractFunction):
                return pyobject.get_param_names()

    @property
    def type(self):
        pyname = self.pyname
        if isinstance(pyname, builtins.BuiltinName):
            pyobject = pyname.get_object()
            if isinstance(pyobject, builtins.BuiltinFunction):
                return 'function'
            elif isinstance(pyobject, builtins.BuiltinClass):
                clsobj = pyobject.builtin
                return 'class'
            elif isinstance(pyobject, builtins.BuiltinObject) or \
                 isinstance(pyobject, builtins.BuiltinName):
                return 'instance'
        elif isinstance(pyname, pynames.ImportedModule):
            return 'module'
        elif isinstance(pyname, pynames.ImportedName) or \
           isinstance(pyname, pynames.DefinedName):
            pyobject = pyname.get_object()
            if isinstance(pyobject, pyobjects.AbstractFunction):
                return 'function'
            if isinstance(pyobject, pyobjects.AbstractClass):
                return 'class'
        return 'instance'

    def _get_scope(self, scope):
        if isinstance(self.pyname, builtins.BuiltinName):
            return 'builtin'
        if isinstance(self.pyname, pynames.ImportedModule) or \
           isinstance(self.pyname, pynames.ImportedName):
            return 'imported'
        return scope

    def get_doc(self):
        """Get the proposed object's docstring.

        Returns None if it can not be get.
        """
        if not self.pyname:
            return None
        pyobject = self.pyname.get_object()
        if not hasattr(pyobject, 'get_doc'):
            return None
        return self.pyname.get_object().get_doc()

    @property
    def kind(self):
        warnings.warn("the proposal's `kind` property is deprecated, " \
                      "use `scope` instead")
        return self.scope


# leaved for backward compatibility
CodeAssistProposal = CompletionProposal


class NamedParamProposal(CompletionProposal):
    """A parameter keyword completion proposal

    Holds reference to ``_function`` -- the function which
    parameter ``name`` belongs to. This allows to determine
    default value for this parameter.
    """
    def __init__(self, name, function):
        self.argname = name
        name = '%s=' % name
        super(NamedParamProposal, self).__init__(name, 'parameter_keyword')
        self._function = function

    def get_default(self):
        """Get a string representation of a param's default value.

        Returns None if there is no default value for this param.
        """
        definfo = functionutils.DefinitionInfo.read(self._function)
        for arg, default in definfo.args_with_defaults:
            if self.argname == arg:
                return default
        return None


def sorted_proposals(proposals, scopepref=None, typepref=None):
    """Sort a list of proposals

    Return a sorted list of the given `CodeAssistProposal`\s.

    `scopepref` can be a list of proposal scopes.  Defaults to
    ``['parameter_keyword', 'local', 'global', 'imported',
    'attribute', 'builtin', 'keyword']``.

    `typepref` can be a list of proposal types.  Defaults to
    ``['class', 'function', 'instance', 'module', None]``.
    (`None` stands for completions with no type like keywords.)
    """
    sorter = _ProposalSorter(proposals, scopepref, typepref)
    return sorter.get_sorted_proposal_list()


def starting_expression(source_code, offset):
    """Return the expression to complete"""
    word_finder = worder.Worder(source_code, True)
    expression, starting, starting_offset = \
        word_finder.get_splitted_primary_before(offset)
    if expression:
        return expression + '.' + starting
    return starting


def default_templates():
    warnings.warn('default_templates() is deprecated.',
                  DeprecationWarning, stacklevel=2)
    return {}


class _PythonCodeAssist(object):

    def __init__(self, project, source_code, offset, resource=None,
                 maxfixes=1, later_locals=True):
        self.project = project
        self.pycore = self.project.pycore
        self.code = source_code
        self.resource = resource
        self.maxfixes = maxfixes
        self.later_locals = later_locals
        self.word_finder = worder.Worder(source_code, True)
        self.expression, self.starting, self.offset = \
            self.word_finder.get_splitted_primary_before(offset)

    keywords = keyword.kwlist

    def _find_starting_offset(self, source_code, offset):
        current_offset = offset - 1
        while current_offset >= 0 and (source_code[current_offset].isalnum() or
                                       source_code[current_offset] in '_'):
            current_offset -= 1;
        return current_offset + 1

    def _matching_keywords(self, starting):
        result = []
        for kw in self.keywords:
            if kw.startswith(starting):
                result.append(CompletionProposal(kw, 'keyword'))
        return result

    def __call__(self):
        if self.offset > len(self.code):
            return []
        completions = list(self._code_completions().values())
        if self.expression.strip() == '' and self.starting.strip() != '':
            completions.extend(self._matching_keywords(self.starting))
        return completions

    def _dotted_completions(self, module_scope, holding_scope):
        result = {}
        found_pyname = rope.base.evaluate.eval_str(holding_scope,
                                                   self.expression)
        if found_pyname is not None:
            element = found_pyname.get_object()
            compl_scope = 'attribute'
            if isinstance(element, (pyobjectsdef.PyModule,
                                    pyobjectsdef.PyPackage)):
                compl_scope = 'imported'
            for name, pyname in element.get_attributes().items():
                if name.startswith(self.starting):
                    result[name] = CompletionProposal(name, compl_scope, pyname)
        return result

    def _undotted_completions(self, scope, result, lineno=None):
        if scope.parent != None:
            self._undotted_completions(scope.parent, result)
        if lineno is None:
            names = scope.get_propagated_names()
        else:
            names = scope.get_names()
        for name, pyname in names.items():
            if name.startswith(self.starting):
                compl_scope = 'local'
                if scope.get_kind() == 'Module':
                    compl_scope = 'global'
                if lineno is None or self.later_locals or \
                   not self._is_defined_after(scope, pyname, lineno):
                    result[name] = CompletionProposal(name, compl_scope,
                                                      pyname)

    def _from_import_completions(self, pymodule):
        module_name = self.word_finder.get_from_module(self.offset)
        if module_name is None:
            return {}
        pymodule = self._find_module(pymodule, module_name)
        result = {}
        for name in pymodule:
            if name.startswith(self.starting):
                result[name] = CompletionProposal(name, scope='global',
                                                  pyname=pymodule[name])
        return result

    def _find_module(self, pymodule, module_name):
        dots = 0
        while module_name[dots] == '.':
            dots += 1
        pyname = pynames.ImportedModule(pymodule,
                                        module_name[dots:], dots)
        return pyname.get_object()

    def _is_defined_after(self, scope, pyname, lineno):
        location = pyname.get_definition_location()
        if location is not None and location[1] is not None:
            if location[0] == scope.pyobject.get_module() and \
               lineno <= location[1] <= scope.get_end():
                return True

    def _code_completions(self):
        lineno = self.code.count('\n', 0, self.offset) + 1
        fixer = fixsyntax.FixSyntax(self.pycore, self.code,
                                    self.resource, self.maxfixes)
        pymodule = fixer.get_pymodule()
        module_scope = pymodule.get_scope()
        code = pymodule.source_code
        lines = code.split('\n')
        result = {}
        start = fixsyntax._logical_start(lines, lineno)
        indents = fixsyntax._get_line_indents(lines[start - 1])
        inner_scope = module_scope.get_inner_scope_for_line(start, indents)
        if self.word_finder.is_a_name_after_from_import(self.offset):
            return self._from_import_completions(pymodule)
        if self.expression.strip() != '':
            result.update(self._dotted_completions(module_scope, inner_scope))
        else:
            result.update(self._keyword_parameters(module_scope.pyobject,
                                                   inner_scope))
            self._undotted_completions(inner_scope, result, lineno=lineno)
        return result

    def _keyword_parameters(self, pymodule, scope):
        offset = self.offset
        if offset == 0:
            return {}
        word_finder = worder.Worder(self.code, True)
        lines = SourceLinesAdapter(self.code)
        lineno = lines.get_line_number(offset)
        if word_finder.is_on_function_call_keyword(offset - 1):
            name_finder = rope.base.evaluate.ScopeNameFinder(pymodule)
            function_parens = word_finder.\
                find_parens_start_from_inside(offset - 1)
            primary = word_finder.get_primary_at(function_parens - 1)
            try:
                function_pyname = rope.base.evaluate.\
                    eval_str(scope, primary)
            except exceptions.BadIdentifierError as e:
                return {}
            if function_pyname is not None:
                pyobject = function_pyname.get_object()
                if isinstance(pyobject, pyobjects.AbstractFunction):
                    pass
                elif isinstance(pyobject, pyobjects.AbstractClass) and \
                     '__init__' in pyobject:
                    pyobject = pyobject['__init__'].get_object()
                elif '__call__' in pyobject:
                    pyobject = pyobject['__call__'].get_object()
                if isinstance(pyobject, pyobjects.AbstractFunction):
                    param_names = []
                    param_names.extend(
                        pyobject.get_param_names(special_args=False))
                    result = {}
                    for name in param_names:
                        if name.startswith(self.starting):
                            result[name + '='] = NamedParamProposal(
                                name, pyobject
                            )
                    return result
        return {}


class _ProposalSorter(object):
    """Sort a list of code assist proposals"""

    def __init__(self, code_assist_proposals, scopepref=None, typepref=None):
        self.proposals = code_assist_proposals
        if scopepref is None:
            scopepref = ['parameter_keyword', 'local', 'global', 'imported',
                        'attribute', 'builtin', 'keyword']
        self.scopepref = scopepref
        if typepref is None:
            typepref = ['class', 'function', 'instance', 'module', None]
        self.typerank = dict((type, index)
                              for index, type in enumerate(typepref))

    def get_sorted_proposal_list(self):
        """Return a list of `CodeAssistProposal`"""
        proposals = {}
        for proposal in self.proposals:
            proposals.setdefault(proposal.scope, []).append(proposal)
        result = []
        for scope in self.scopepref:
            scope_proposals = proposals.get(scope, [])
            scope_proposals = [proposal for proposal in scope_proposals
                              if proposal.type in self.typerank]
            scope_proposals.sort(key = self._proposal_cmp)
            result.extend(scope_proposals)
        return result

    def _proposal_cmp(self, proposal):
        def underline_count(name):
            result = 0
            while result < len(name) and name[result] == '_':
                result += 1
            return result
        return (self.typerank.get(proposal.type, 100), underline_count(proposal.name), proposal.name)

    def _compare_underlined_names(self, name1, name2):
        def underline_count(name):
            result = 0
            while result < len(name) and name[result] == '_':
                result += 1
            return result
        underline_count1 = underline_count(name1)
        underline_count2 = underline_count(name2)
        if underline_count1 != underline_count2:
            return cmp(underline_count1, underline_count2)
        return cmp(name1, name2)


class PyDocExtractor(object):

    def get_doc(self, pyobject):
        if isinstance(pyobject, pyobjects.AbstractFunction):
            return self._get_function_docstring(pyobject)
        elif isinstance(pyobject, pyobjects.AbstractClass):
            return self._get_class_docstring(pyobject)
        elif isinstance(pyobject, pyobjects.AbstractModule):
            return self._trim_docstring(pyobject.get_doc())
        return None

    def get_calltip(self, pyobject, ignore_unknown=False, remove_self=False):
        try:
            if isinstance(pyobject, pyobjects.AbstractClass):
                pyobject = pyobject['__init__'].get_object()
            if not isinstance(pyobject, pyobjects.AbstractFunction):
                pyobject = pyobject['__call__'].get_object()
        except exceptions.AttributeNotFoundError:
            return None
        if ignore_unknown and not isinstance(pyobject, pyobjects.PyFunction):
            return
        if isinstance(pyobject, pyobjects.AbstractFunction):
            result = self._get_function_signature(pyobject, add_module=True)
            if remove_self and self._is_method(pyobject):
                return result.replace('(self)', '()').replace('(self, ', '(')
            return result

    def _get_class_docstring(self, pyclass):
        contents = self._trim_docstring(pyclass.get_doc(), 2)
        supers = [super.get_name() for super in pyclass.get_superclasses()]
        doc = 'class %s(%s):\n\n' % (pyclass.get_name(), ', '.join(supers)) + contents

        if '__init__' in pyclass:
            init = pyclass['__init__'].get_object()
            if isinstance(init, pyobjects.AbstractFunction):
                doc += '\n\n' + self._get_single_function_docstring(init)
        return doc

    def _get_function_docstring(self, pyfunction):
        functions = [pyfunction]
        if self._is_method(pyfunction):
            functions.extend(self._get_super_methods(pyfunction.parent,
                                                     pyfunction.get_name()))
        return '\n\n'.join([self._get_single_function_docstring(function)
                            for function in functions])

    def _is_method(self, pyfunction):
        return isinstance(pyfunction, pyobjects.PyFunction) and \
               isinstance(pyfunction.parent, pyobjects.PyClass)

    def _get_single_function_docstring(self, pyfunction):
        signature = self._get_function_signature(pyfunction)
        docs = self._trim_docstring(pyfunction.get_doc(), indents=2)
        return signature + ':\n\n' + docs

    def _get_super_methods(self, pyclass, name):
        result = []
        for super_class in pyclass.get_superclasses():
            if name in super_class:
                function = super_class[name].get_object()
                if isinstance(function, pyobjects.AbstractFunction):
                    result.append(function)
            result.extend(self._get_super_methods(super_class, name))
        return result

    def _get_function_signature(self, pyfunction, add_module=False):
        location = self._location(pyfunction, add_module)
        if isinstance(pyfunction, pyobjects.PyFunction):
            info = functionutils.DefinitionInfo.read(pyfunction)
            return location + info.to_string()
        else:
            return '%s(%s)' % (location + pyfunction.get_name(),
                               ', '.join(pyfunction.get_param_names()))

    def _location(self, pyobject, add_module=False):
        location = []
        parent = pyobject.parent
        while parent and not isinstance(parent, pyobjects.AbstractModule):
            location.append(parent.get_name())
            location.append('.')
            parent = parent.parent
        if add_module:
            if isinstance(pyobject, pyobjects.PyFunction):
                module = pyobject.get_module()
                location.insert(0, self._get_module(pyobject))
            if isinstance(parent, builtins.BuiltinModule):
                location.insert(0, parent.get_name() + '.')
        return ''.join(location)

    def _get_module(self, pyfunction):
        module = pyfunction.get_module()
        if module is not None:
            resource = module.get_resource()
            if resource is not None:
                return pyfunction.pycore.modname(resource) + '.'
        return ''

    def _trim_docstring(self, docstring, indents=0):
        """The sample code from :PEP:`257`"""
        if not docstring:
            return ''
        # Convert tabs to spaces (following normal Python rules)
        # and split into a list of lines:
        lines = docstring.expandtabs().splitlines()
        # Determine minimum indentation (first line doesn't count):
        indent = sys.maxsize
        for line in lines[1:]:
            stripped = line.lstrip()
            if stripped:
                indent = min(indent, len(line) - len(stripped))
        # Remove indentation (first line is special):
        trimmed = [lines[0].strip()]
        if indent < sys.maxsize:
            for line in lines[1:]:
                trimmed.append(line[indent:].rstrip())
        # Strip off trailing and leading blank lines:
        while trimmed and not trimmed[-1]:
            trimmed.pop()
        while trimmed and not trimmed[0]:
            trimmed.pop(0)
        # Return a single string:
        return '\n'.join((' ' * indents + line for line in trimmed))


# Deprecated classes

class TemplateProposal(CodeAssistProposal):
    def __init__(self, name, template):
        warnings.warn('TemplateProposal is deprecated.',
                      DeprecationWarning, stacklevel=2)
        super(TemplateProposal, self).__init__(name, 'template')
        self.template = template


class Template(object):

    def __init__(self, template):
        self.template = template
        warnings.warn('Template is deprecated.',
                      DeprecationWarning, stacklevel=2)

    def variables(self):
        return []

    def substitute(self, mapping):
        return self.template

    def get_cursor_location(self, mapping):
        return len(self.template)

########NEW FILE########
__FILENAME__ = finderrors
"""Finding bad name and attribute accesses

`find_errors` function can be used to find possible bad name and
attribute accesses.  As an example::

  errors = find_errors(project, project.get_resource('mod.py'))
  for error in errors:
      print '%s: %s' % (error.lineno, error.error)

prints possible errors for ``mod.py`` file.

TODO:

* use task handles
* reporting names at most once
* attributes of extension modules that don't appear in
  extension_modules project config can be ignored
* not calling `PyScope.get_inner_scope_for_line()` if it is a
  bottleneck; needs profiling
* not reporting occurrences where rope cannot infer the object
* rope saves multiple objects for some of the names in its objectdb
  use all of them not to give false positives
* ... ;-)

"""
from rope.base import ast, evaluate, pyobjects


def find_errors(project, resource):
    """Find possible bad name and attribute accesses

    It returns a list of `Error`\s.
    """
    pymodule = project.pycore.resource_to_pyobject(resource)
    finder = _BadAccessFinder(pymodule)
    ast.walk(pymodule.get_ast(), finder)
    return finder.errors


class _BadAccessFinder(object):

    def __init__(self, pymodule):
        self.pymodule = pymodule
        self.scope = pymodule.get_scope()
        self.errors = []

    def _Name(self, node):
        if isinstance(node.ctx, (ast.Store, ast.Param)):
            return
        scope = self.scope.get_inner_scope_for_line(node.lineno)
        pyname = scope.lookup(node.id)
        if pyname is None:
            self._add_error(node, 'Unresolved variable')
        elif self._is_defined_after(scope, pyname, node.lineno):
            self._add_error(node, 'Defined later')

    def _Attribute(self, node):
        if not isinstance(node.ctx, ast.Store):
            scope = self.scope.get_inner_scope_for_line(node.lineno)
            pyname = evaluate.eval_node(scope, node.value)
            if pyname is not None and \
               pyname.get_object() != pyobjects.get_unknown():
                if node.attr not in pyname.get_object():
                    self._add_error(node, 'Unresolved attribute')
        ast.walk(node.value, self)

    def _add_error(self, node, msg):
        if isinstance(node, ast.Attribute):
            name = node.attr
        else:
            name = node.id
        if name != 'None':
            error = Error(node.lineno, msg + ' ' + name)
            self.errors.append(error)

    def _is_defined_after(self, scope, pyname, lineno):
        location = pyname.get_definition_location()
        if location is not None and location[1] is not None:
            if location[0] == self.pymodule and \
               lineno <= location[1] <= scope.get_end():
                return True


class Error(object):

    def __init__(self, lineno, error):
        self.lineno = lineno
        self.error = error

    def __str__(self):
        return '%s: %s' % (self.lineno, self.error)

########NEW FILE########
__FILENAME__ = findit
import rope.base.codeanalyze
import rope.base.evaluate
import rope.base.pyobjects
from rope.base import taskhandle, exceptions, worder
from rope.contrib import fixsyntax
from rope.refactor import occurrences


def find_occurrences(project, resource, offset, unsure=False, resources=None,
                     in_hierarchy=False, task_handle=taskhandle.NullTaskHandle()):
    """Return a list of `Location`\s

    If `unsure` is `True`, possible matches are returned, too.  You
    can use `Location.unsure` to see which are unsure occurrences.
    `resources` can be a list of `rope.base.resource.File`\s that
    should be searched for occurrences; if `None` all python files
    in the project are searched.

    """
    name = worder.get_name_at(resource, offset)
    this_pymodule = project.pycore.resource_to_pyobject(resource)
    primary, pyname = rope.base.evaluate.eval_location2(
        this_pymodule, offset)
    def is_match(occurrence):
        return unsure
    finder = occurrences.create_finder(
        project.pycore, name, pyname, unsure=is_match,
        in_hierarchy=in_hierarchy, instance=primary)
    if resources is None:
        resources = project.pycore.get_python_files()
    job_set = task_handle.create_jobset('Finding Occurrences',
                                        count=len(resources))
    return _find_locations(finder, resources, job_set)


def find_implementations(project, resource, offset, resources=None,
                         task_handle=taskhandle.NullTaskHandle()):
    """Find the places a given method is overridden.

    Finds the places a method is implemented.  Returns a list of
    `Location`\s.
    """
    name = worder.get_name_at(resource, offset)
    this_pymodule = project.pycore.resource_to_pyobject(resource)
    pyname = rope.base.evaluate.eval_location(this_pymodule, offset)
    if pyname is not None:
        pyobject = pyname.get_object()
        if not isinstance(pyobject, rope.base.pyobjects.PyFunction) or \
           pyobject.get_kind() != 'method':
            raise exceptions.BadIdentifierError('Not a method!')
    else:
        raise exceptions.BadIdentifierError('Cannot resolve the identifier!')
    def is_defined(occurrence):
        if not occurrence.is_defined():
            return False
    def not_self(occurrence):
        if occurrence.get_pyname().get_object() == pyname.get_object():
            return False
    filters = [is_defined, not_self,
               occurrences.InHierarchyFilter(pyname, True)]
    finder = occurrences.Finder(project.pycore, name, filters=filters)
    if resources is None:
        resources = project.pycore.get_python_files()
    job_set = task_handle.create_jobset('Finding Implementations',
                                        count=len(resources))
    return _find_locations(finder, resources, job_set)


def find_definition(project, code, offset, resource=None, maxfixes=1):
    """Return the definition location of the python name at `offset`

    A `Location` object is returned if the definition location can be
    determined, otherwise ``None`` is returned.
    """
    fixer = fixsyntax.FixSyntax(project.pycore, code, resource, maxfixes)
    main_module = fixer.get_pymodule()
    pyname = fixer.pyname_at(offset)
    if pyname is not None:
        module, lineno = pyname.get_definition_location()
        name = rope.base.worder.Worder(code).get_word_at(offset)
        if lineno is not None:
            start = module.lines.get_line_start(lineno)
            def check_offset(occurrence):
                if occurrence.offset < start:
                    return False
            pyname_filter = occurrences.PyNameFilter(pyname)
            finder = occurrences.Finder(project.pycore, name,
                                        [check_offset, pyname_filter])
            for occurrence in finder.find_occurrences(pymodule=module):
                return Location(occurrence)


class Location(object):

    def __init__(self, occurrence):
        self.resource = occurrence.resource
        self.region = occurrence.get_word_range()
        self.offset = self.region[0]
        self.unsure = occurrence.is_unsure()
        self.lineno = occurrence.lineno


def _find_locations(finder, resources, job_set):
    result = []
    for resource in resources:
        job_set.started_job(resource.path)
        for occurrence in finder.find_occurrences(resource):
            result.append(Location(occurrence))
        job_set.finished_job()
    return result

########NEW FILE########
__FILENAME__ = fixmodnames
"""Fix the name of modules

This module is useful when you want to rename many of the modules in
your project.  That can happen specially when you want to change their
naming style.

For instance::

  fixer = FixModuleNames(project)
  changes = fixer.get_changes(fixer=str.lower)
  project.do(changes)

Here it renames all modules and packages to use lower-cased chars.
You can tell it to use any other style by using the ``fixer``
argument.

"""
from rope.base import change, taskhandle
from rope.contrib import changestack
from rope.refactor import rename


class FixModuleNames(object):

    def __init__(self, project):
        self.project = project

    def get_changes(self, fixer=str.lower,
                    task_handle=taskhandle.NullTaskHandle()):
        """Fix module names

        `fixer` is a function that takes and returns a `str`.  Given
        the name of a module, it should return the fixed name.

        """
        stack = changestack.ChangeStack(self.project, 'Fixing module names')
        jobset = task_handle.create_jobset('Fixing module names',
                                           self._count_fixes(fixer) + 1)
        try:
            while True:
                for resource in self._tobe_fixed(fixer):
                    jobset.started_job(resource.path)
                    renamer = rename.Rename(self.project, resource)
                    changes = renamer.get_changes(fixer(self._name(resource)))
                    stack.push(changes)
                    jobset.finished_job()
                    break
                else:
                    break
        finally:
            jobset.started_job('Reverting to original state')
            stack.pop_all()
            jobset.finished_job()
        return stack.merged()

    def _count_fixes(self, fixer):
        return len(list(self._tobe_fixed(fixer)))

    def _tobe_fixed(self, fixer):
        for resource in self.project.pycore.get_python_files():
            modname = self._name(resource)
            if modname != fixer(modname):
                yield resource

    def _name(self, resource):
        modname = resource.name.rsplit('.', 1)[0]
        if modname == '__init__':
            modname = resource.parent.name
        return modname

########NEW FILE########
__FILENAME__ = fixsyntax
import rope.base.codeanalyze
import rope.base.evaluate
from rope.base import worder, exceptions, utils
from rope.base.codeanalyze import ArrayLinesAdapter, LogicalLineFinder


class FixSyntax(object):

    def __init__(self, pycore, code, resource, maxfixes=1):
        self.pycore = pycore
        self.code = code
        self.resource = resource
        self.maxfixes = maxfixes

    @utils.saveit
    def get_pymodule(self):
        """Get a `PyModule`"""
        errors = []
        code = self.code
        tries = 0
        while True:
            try:
                if tries == 0 and self.resource is not None and \
                   self.resource.read() == code:
                    return self.pycore.resource_to_pyobject(self.resource,
                                                            force_errors=True)
                return self.pycore.get_string_module(
                    code, resource=self.resource, force_errors=True)
            except exceptions.ModuleSyntaxError as e:
                if tries < self.maxfixes:
                    tries += 1
                    self.commenter.comment(e.lineno)
                    code = '\n'.join(self.commenter.lines)
                    errors.append('  * line %s: %s ... fixed' % (e.lineno,
                                                                 e.message_))
                else:
                    errors.append('  * line %s: %s ... raised!' % (e.lineno,
                                                                   e.message_))
                    new_message = ('\nSyntax errors in file %s:\n' % e.filename) \
                                   + '\n'.join(errors)
                    raise exceptions.ModuleSyntaxError(e.filename, e.lineno,
                                                       new_message)

    @property
    @utils.saveit
    def commenter(self):
        return _Commenter(self.code)

    def pyname_at(self, offset):
        pymodule = self.get_pymodule()
        def old_pyname():
            word_finder = worder.Worder(self.code, True)
            expression = word_finder.get_primary_at(offset)
            expression = expression.replace('\\\n', ' ').replace('\n', ' ')
            lineno = self.code.count('\n', 0, offset)
            scope = pymodule.get_scope().get_inner_scope_for_line(lineno)
            return rope.base.evaluate.eval_str(scope, expression)
        new_code = pymodule.source_code
        def new_pyname():
            newoffset = self.commenter.transfered_offset(offset)
            return rope.base.evaluate.eval_location(pymodule, newoffset)
        if new_code.startswith(self.code[:offset + 1]):
            return new_pyname()
        result = old_pyname()
        if result is None:
            return new_pyname()
        return result


class _Commenter(object):

    def __init__(self, code):
        self.code = code
        self.lines = self.code.split('\n')
        self.lines.append('\n')
        self.origs = list(range(len(self.lines) + 1))
        self.diffs = [0] * (len(self.lines) + 1)

    def comment(self, lineno):
        start = _logical_start(self.lines, lineno, check_prev=True) - 1
        # using self._get_stmt_end() instead of self._get_block_end()
        # to lower commented lines
        end = self._get_stmt_end(start)
        indents = _get_line_indents(self.lines[start])
        if 0 < start:
            last_lineno = self._last_non_blank(start - 1)
            last_line = self.lines[last_lineno]
            if last_line.rstrip().endswith(':'):
                indents = _get_line_indents(last_line) + 4
        self._set(start, ' ' * indents + 'pass')
        for line in range(start + 1, end + 1):
            self._set(line, self.lines[start])
        self._fix_incomplete_try_blocks(lineno, indents)

    def transfered_offset(self, offset):
        lineno = self.code.count('\n', 0, offset)
        diff = sum(self.diffs[:lineno])
        return offset + diff

    def _last_non_blank(self, start):
        while start > 0 and self.lines[start].strip() == '':
            start -= 1
        return start

    def _get_block_end(self, lineno):
        end_line = lineno
        base_indents = _get_line_indents(self.lines[lineno])
        for i in range(lineno + 1, len(self.lines)):
            if _get_line_indents(self.lines[i]) >= base_indents:
                end_line = i
            else:
                break
        return end_line

    def _get_stmt_end(self, lineno):
        end_line = lineno
        base_indents = _get_line_indents(self.lines[lineno])
        for i in range(lineno + 1, len(self.lines)):
            if _get_line_indents(self.lines[i]) <= base_indents:
                return i - 1
        return lineno

    def _fix_incomplete_try_blocks(self, lineno, indents):
        block_start = lineno
        last_indents = current_indents = indents
        while block_start > 0:
            block_start = rope.base.codeanalyze.get_block_start(
                ArrayLinesAdapter(self.lines), block_start) - 1
            if self.lines[block_start].strip().startswith('try:'):
                indents = _get_line_indents(self.lines[block_start])
                if indents > last_indents:
                    continue
                last_indents = indents
                block_end = self._find_matching_deindent(block_start)
                line = self.lines[block_end].strip()
                if not (line.startswith('finally:') or
                        line.startswith('except ') or
                        line.startswith('except:')):
                    self._insert(block_end, ' ' * indents + 'finally:')
                    self._insert(block_end + 1, ' ' * indents + '    pass')

    def _find_matching_deindent(self, line_number):
        indents = _get_line_indents(self.lines[line_number])
        current_line = line_number + 1
        while current_line < len(self.lines):
            line = self.lines[current_line]
            if not line.strip().startswith('#') and not line.strip() == '':
                # HACK: We should have used logical lines here
                if _get_line_indents(self.lines[current_line]) <= indents:
                    return current_line
            current_line += 1
        return len(self.lines) - 1

    def _set(self, lineno, line):
        self.diffs[self.origs[lineno]] += len(line) - len(self.lines[lineno])
        self.lines[lineno] = line

    def _insert(self, lineno, line):
        self.diffs[self.origs[lineno]] += len(line) + 1
        self.origs.insert(lineno, self.origs[lineno])
        self.lines.insert(lineno, line)

def _logical_start(lines, lineno, check_prev=False):
    logical_finder = LogicalLineFinder(ArrayLinesAdapter(lines))
    if check_prev:
        prev = lineno - 1
        while prev > 0:
            start, end = logical_finder.logical_line_in(prev)
            if end is None or start <= lineno < end:
                return start
            if start <= prev:
                break
            prev -= 1
    return logical_finder.logical_line_in(lineno)[0]


def _get_line_indents(line):
    return rope.base.codeanalyze.count_line_indents(line)

########NEW FILE########
__FILENAME__ = generate
import rope.base.evaluate
from rope.base import change, pyobjects, exceptions, pynames, worder, codeanalyze
from rope.refactor import sourceutils, importutils, functionutils, suites


def create_generate(kind, project, resource, offset):
    """A factory for creating `Generate` objects

    `kind` can be 'variable', 'function', 'class', 'module' or
    'package'.

    """
    generate = eval('Generate' + kind.title())
    return generate(project, resource, offset)


def create_module(project, name, sourcefolder=None):
    """Creates a module and returns a `rope.base.resources.File`"""
    if sourcefolder is None:
        sourcefolder = project.root
    packages = name.split('.')
    parent = sourcefolder
    for package in packages[:-1]:
        parent = parent.get_child(package)
    return parent.create_file(packages[-1] + '.py')

def create_package(project, name, sourcefolder=None):
    """Creates a package and returns a `rope.base.resources.Folder`"""
    if sourcefolder is None:
        sourcefolder = project.root
    packages = name.split('.')
    parent = sourcefolder
    for package in packages[:-1]:
        parent = parent.get_child(package)
    made_packages = parent.create_folder(packages[-1])
    made_packages.create_file('__init__.py')
    return made_packages


class _Generate(object):

    def __init__(self, project, resource, offset):
        self.project = project
        self.resource = resource
        self.info = self._generate_info(project, resource, offset)
        self.name = self.info.get_name()
        self._check_exceptional_conditions()

    def _generate_info(self, project, resource, offset):
        return _GenerationInfo(project.pycore, resource, offset)

    def _check_exceptional_conditions(self):
        if self.info.element_already_exists():
            raise exceptions.RefactoringError(
                'Element <%s> already exists.' % self.name)
        if not self.info.primary_is_found():
            raise exceptions.RefactoringError(
                'Cannot determine the scope <%s> should be defined in.' % self.name)

    def get_changes(self):
        changes = change.ChangeSet('Generate %s <%s>' %
                                   (self._get_element_kind(), self.name))
        indents = self.info.get_scope_indents()
        blanks = self.info.get_blank_lines()
        base_definition = sourceutils.fix_indentation(self._get_element(), indents)
        definition = '\n' * blanks[0] + base_definition + '\n' * blanks[1]

        resource = self.info.get_insertion_resource()
        start, end = self.info.get_insertion_offsets()

        collector = codeanalyze.ChangeCollector(resource.read())
        collector.add_change(start, end, definition)
        changes.add_change(change.ChangeContents(
                           resource, collector.get_changed()))
        return changes

    def get_location(self):
        return (self.info.get_insertion_resource(),
                self.info.get_insertion_lineno())

    def _get_element_kind(self):
        raise NotImplementedError()

    def _get_element(self):
        raise NotImplementedError()


class GenerateFunction(_Generate):

    def _generate_info(self, project, resource, offset):
        return _FunctionGenerationInfo(project.pycore, resource, offset)

    def _get_element(self):
        decorator = ''
        args = []
        if self.info.is_static_method():
            decorator = '@staticmethod\n'
        if self.info.is_method() or self.info.is_constructor() or \
           self.info.is_instance():
            args.append('self')
        args.extend(self.info.get_passed_args())
        definition = '%sdef %s(%s):\n    pass\n' % (decorator, self.name,
                                                    ', '.join(args))
        return definition

    def _get_element_kind(self):
        return 'Function'


class GenerateVariable(_Generate):

    def _get_element(self):
        return '%s = None\n' % self.name

    def _get_element_kind(self):
        return 'Variable'


class GenerateClass(_Generate):

    def _get_element(self):
        return 'class %s(object):\n    pass\n' % self.name

    def _get_element_kind(self):
        return 'Class'


class GenerateModule(_Generate):

    def get_changes(self):
        package = self.info.get_package()
        changes = change.ChangeSet('Generate Module <%s>' % self.name)
        new_resource = self.project.get_file('%s/%s.py' % (package.path, self.name))
        if new_resource.exists():
            raise exceptions.RefactoringError(
                'Module <%s> already exists' % new_resource.path)
        changes.add_change(change.CreateResource(new_resource))
        changes.add_change(_add_import_to_module(
                           self.project.pycore, self.resource, new_resource))
        return changes

    def get_location(self):
        package = self.info.get_package()
        return (package.get_child('%s.py' % self.name) , 1)


class GeneratePackage(_Generate):

    def get_changes(self):
        package = self.info.get_package()
        changes = change.ChangeSet('Generate Package <%s>' % self.name)
        new_resource = self.project.get_folder('%s/%s' % (package.path, self.name))
        if new_resource.exists():
            raise exceptions.RefactoringError(
                'Package <%s> already exists' % new_resource.path)
        changes.add_change(change.CreateResource(new_resource))
        changes.add_change(_add_import_to_module(
                           self.project.pycore, self.resource, new_resource))
        child = self.project.get_folder(package.path + '/' + self.name)
        changes.add_change(change.CreateFile(child, '__init__.py'))
        return changes

    def get_location(self):
        package = self.info.get_package()
        child = package.get_child(self.name)
        return (child.get_child('__init__.py') , 1)


def _add_import_to_module(pycore, resource, imported):
    pymodule = pycore.resource_to_pyobject(resource)
    import_tools = importutils.ImportTools(pycore)
    module_imports = import_tools.module_imports(pymodule)
    module_name = pycore.modname(imported)
    new_import = importutils.NormalImport(((module_name, None), ))
    module_imports.add_import(new_import)
    return change.ChangeContents(resource, module_imports.get_changed_source())


class _GenerationInfo(object):

    def __init__(self, pycore, resource, offset):
        self.pycore = pycore
        self.resource = resource
        self.offset = offset
        self.source_pymodule = self.pycore.resource_to_pyobject(resource)
        finder = rope.base.evaluate.ScopeNameFinder(self.source_pymodule)
        self.primary, self.pyname = finder.get_primary_and_pyname_at(offset)
        self._init_fields()

    def _init_fields(self):
        self.source_scope = self._get_source_scope()
        self.goal_scope = self._get_goal_scope()
        self.goal_pymodule = self._get_goal_module(self.goal_scope)

    def _get_goal_scope(self):
        if self.primary is None:
            return self._get_source_scope()
        pyobject = self.primary.get_object()
        if isinstance(pyobject, pyobjects.PyDefinedObject):
            return pyobject.get_scope()
        elif isinstance(pyobject.get_type(), pyobjects.PyClass):
            return pyobject.get_type().get_scope()

    def _get_goal_module(self, scope):
        if scope is None:
            return
        while scope.parent is not None:
            scope = scope.parent
        return scope.pyobject

    def _get_source_scope(self):
        module_scope = self.source_pymodule.get_scope()
        lineno = self.source_pymodule.lines.get_line_number(self.offset)
        return module_scope.get_inner_scope_for_line(lineno)

    def get_insertion_lineno(self):
        lines = self.goal_pymodule.lines
        if self.goal_scope == self.source_scope:
            line_finder = self.goal_pymodule.logical_lines
            lineno = lines.get_line_number(self.offset)
            lineno = line_finder.logical_line_in(lineno)[0]
            root = suites.ast_suite_tree(self.goal_scope.pyobject.get_ast())
            suite = root.find_suite(lineno)
            indents = sourceutils.get_indents(lines, lineno)
            while self.get_scope_indents() < indents:
                lineno = suite.get_start()
                indents = sourceutils.get_indents(lines, lineno)
                suite = suite.parent
            return lineno
        else:
            return min(self.goal_scope.get_end() + 1, lines.length())

    def get_insertion_resource(self):
        return self.goal_pymodule.get_resource()

    def get_insertion_offsets(self):
        if self.goal_scope.get_kind() == 'Class':
            start, end = sourceutils.get_body_region(self.goal_scope.pyobject)
            if self.goal_pymodule.source_code[start:end].strip() == 'pass':
                return start, end
        lines = self.goal_pymodule.lines
        start = lines.get_line_start(self.get_insertion_lineno())
        return (start, start)

    def get_scope_indents(self):
        if self.goal_scope.get_kind() == 'Module':
            return 0
        return sourceutils.get_indents(self.goal_pymodule.lines,
                                       self.goal_scope.get_start()) + 4

    def get_blank_lines(self):
        if self.goal_scope.get_kind() == 'Module':
            base_blanks = 2
            if self.goal_pymodule.source_code.strip() == '':
                base_blanks = 0
        if self.goal_scope.get_kind() == 'Class':
            base_blanks = 1
        if self.goal_scope.get_kind() == 'Function':
            base_blanks = 0
        if self.goal_scope == self.source_scope:
            return (0, base_blanks)
        return (base_blanks, 0)

    def get_package(self):
        primary = self.primary
        if self.primary is None:
            return self.pycore.get_source_folders()[0]
        if isinstance(primary.get_object(), pyobjects.PyPackage):
            return primary.get_object().get_resource()
        raise exceptions.RefactoringError(
            'A module/package can be only created in a package.')

    def primary_is_found(self):
        return self.goal_scope is not None

    def element_already_exists(self):
        if self.pyname is None or isinstance(self.pyname, pynames.UnboundName):
            return False
        return self.get_name() in self.goal_scope.get_defined_names()

    def get_name(self):
        return worder.get_name_at(self.resource, self.offset)


class _FunctionGenerationInfo(_GenerationInfo):

    def _get_goal_scope(self):
        if self.is_constructor():
            return self.pyname.get_object().get_scope()
        if self.is_instance():
            return self.pyname.get_object().get_type().get_scope()
        if self.primary is None:
            return self._get_source_scope()
        pyobject = self.primary.get_object()
        if isinstance(pyobject, pyobjects.PyDefinedObject):
            return pyobject.get_scope()
        elif isinstance(pyobject.get_type(), pyobjects.PyClass):
            return pyobject.get_type().get_scope()

    def element_already_exists(self):
        if self.pyname is None or isinstance(self.pyname, pynames.UnboundName):
            return False
        return self.get_name() in self.goal_scope.get_defined_names()

    def is_static_method(self):
        return self.primary is not None and \
               isinstance(self.primary.get_object(), pyobjects.PyClass)

    def is_method(self):
        return self.primary is not None and \
               isinstance(self.primary.get_object().get_type(), pyobjects.PyClass)

    def is_constructor(self):
        return self.pyname is not None and \
               isinstance(self.pyname.get_object(), pyobjects.PyClass)

    def is_instance(self):
        if self.pyname is None:
            return False
        pyobject = self.pyname.get_object()
        return isinstance(pyobject.get_type(), pyobjects.PyClass)

    def get_name(self):
        if self.is_constructor():
            return '__init__'
        if self.is_instance():
            return '__call__'
        return worder.get_name_at(self.resource, self.offset)

    def get_passed_args(self):
        result = []
        source = self.source_pymodule.source_code
        finder = worder.Worder(source)
        if finder.is_a_function_being_called(self.offset):
            start, end = finder.get_primary_range(self.offset)
            parens_start, parens_end = finder.get_word_parens_range(end - 1)
            call = source[start:parens_end]
            parser = functionutils._FunctionParser(call, False)
            args, keywords = parser.get_parameters()
            for arg in args:
                if self._is_id(arg):
                    result.append(arg)
                else:
                    result.append('arg%d' % len(result))
            for name, value in keywords:
                result.append(name)
        return result

    def _is_id(self, arg):
        def id_or_underline(c):
            return c.isalpha() or c == '_'
        for c in arg:
            if not id_or_underline(c) and not c.isdigit():
                return False
        return id_or_underline(arg[0])

########NEW FILE########
__FILENAME__ = change_signature
import copy

import rope.base.exceptions
from rope.base import pyobjects, taskhandle, evaluate, worder, codeanalyze, utils
from rope.base.change import ChangeContents, ChangeSet
from rope.refactor import occurrences, functionutils


class ChangeSignature(object):

    def __init__(self, project, resource, offset):
        self.pycore = project.pycore
        self.resource = resource
        self.offset = offset
        self._set_name_and_pyname()
        if self.pyname is None or self.pyname.get_object() is None or \
           not isinstance(self.pyname.get_object(), pyobjects.PyFunction):
            raise rope.base.exceptions.RefactoringError(
                'Change method signature should be performed on functions')

    def _set_name_and_pyname(self):
        self.name = worder.get_name_at(self.resource, self.offset)
        this_pymodule = self.pycore.resource_to_pyobject(self.resource)
        self.primary, self.pyname = evaluate.eval_location2(
            this_pymodule, self.offset)
        if self.pyname is None:
            return
        pyobject = self.pyname.get_object()
        if isinstance(pyobject, pyobjects.PyClass) and \
           '__init__' in pyobject:
            self.pyname = pyobject['__init__']
            self.name = '__init__'
        pyobject = self.pyname.get_object()
        self.others = None
        if self.name == '__init__' and \
           isinstance(pyobject, pyobjects.PyFunction) and \
           isinstance(pyobject.parent, pyobjects.PyClass):
            pyclass = pyobject.parent
            self.others = (pyclass.get_name(),
                           pyclass.parent[pyclass.get_name()])

    def _change_calls(self, call_changer, in_hierarchy=None, resources=None,
                      handle=taskhandle.NullTaskHandle()):
        if resources is None:
            resources = self.pycore.get_python_files()
        changes = ChangeSet('Changing signature of <%s>' % self.name)
        job_set = handle.create_jobset('Collecting Changes', len(resources))
        finder = occurrences.create_finder(
            self.pycore, self.name, self.pyname, instance=self.primary,
            in_hierarchy=in_hierarchy and self.is_method())
        if self.others:
            name, pyname = self.others
            constructor_finder = occurrences.create_finder(
                self.pycore, name, pyname, only_calls=True)
            finder = _MultipleFinders([finder, constructor_finder])
        for file in resources:
            job_set.started_job(file.path)
            change_calls = _ChangeCallsInModule(
                self.pycore, finder, file, call_changer)
            changed_file = change_calls.get_changed_module()
            if changed_file is not None:
                changes.add_change(ChangeContents(file, changed_file))
            job_set.finished_job()
        return changes

    def get_args(self):
        """Get function arguments.

        Return a list of ``(name, default)`` tuples for all but star
        and double star arguments.  For arguments that don't have a
        default, `None` will be used.
        """
        return self._definfo().args_with_defaults

    def is_method(self):
        pyfunction = self.pyname.get_object()
        return isinstance(pyfunction.parent, pyobjects.PyClass)

    @utils.deprecated('Use `ChangeSignature.get_args()` instead')
    def get_definition_info(self):
        return self._definfo()

    def _definfo(self):
        return functionutils.DefinitionInfo.read(self.pyname.get_object())

    @utils.deprecated()
    def normalize(self):
        changer = _FunctionChangers(
            self.pyname.get_object(), self.get_definition_info(),
            [ArgumentNormalizer()])
        return self._change_calls(changer)

    @utils.deprecated()
    def remove(self, index):
        changer = _FunctionChangers(
            self.pyname.get_object(), self.get_definition_info(),
            [ArgumentRemover(index)])
        return self._change_calls(changer)

    @utils.deprecated()
    def add(self, index, name, default=None, value=None):
        changer = _FunctionChangers(
            self.pyname.get_object(), self.get_definition_info(),
            [ArgumentAdder(index, name, default, value)])
        return self._change_calls(changer)

    @utils.deprecated()
    def inline_default(self, index):
        changer = _FunctionChangers(
            self.pyname.get_object(), self.get_definition_info(),
            [ArgumentDefaultInliner(index)])
        return self._change_calls(changer)

    @utils.deprecated()
    def reorder(self, new_ordering):
        changer = _FunctionChangers(
            self.pyname.get_object(), self.get_definition_info(),
            [ArgumentReorderer(new_ordering)])
        return self._change_calls(changer)

    def get_changes(self, changers, in_hierarchy=False, resources=None,
                    task_handle=taskhandle.NullTaskHandle()):
        """Get changes caused by this refactoring

        `changers` is a list of `_ArgumentChanger`\s.  If `in_hierarchy`
        is `True` the changers are applyed to all matching methods in
        the class hierarchy.
        `resources` can be a list of `rope.base.resource.File`\s that
        should be searched for occurrences; if `None` all python files
        in the project are searched.

        """
        function_changer = _FunctionChangers(self.pyname.get_object(),
                                             self._definfo(), changers)
        return self._change_calls(function_changer, in_hierarchy,
                                  resources, task_handle)


class _FunctionChangers(object):

    def __init__(self, pyfunction, definition_info, changers=None):
        self.pyfunction = pyfunction
        self.definition_info = definition_info
        self.changers = changers
        self.changed_definition_infos = self._get_changed_definition_infos()

    def _get_changed_definition_infos(self):
        result = []
        definition_info = self.definition_info
        result.append(definition_info)
        for changer in self.changers:
            definition_info = copy.deepcopy(definition_info)
            changer.change_definition_info(definition_info)
            result.append(definition_info)
        return result

    def change_definition(self, call):
        return self.changed_definition_infos[-1].to_string()

    def change_call(self, primary, pyname, call):
        call_info = functionutils.CallInfo.read(
            primary, pyname, self.definition_info, call)
        mapping = functionutils.ArgumentMapping(self.definition_info, call_info)

        for definition_info, changer in zip(self.changed_definition_infos, self.changers):
            changer.change_argument_mapping(definition_info, mapping)

        return mapping.to_call_info(self.changed_definition_infos[-1]).to_string()


class _ArgumentChanger(object):

    def change_definition_info(self, definition_info):
        pass

    def change_argument_mapping(self, definition_info, argument_mapping):
        pass


class ArgumentNormalizer(_ArgumentChanger):
    pass


class ArgumentRemover(_ArgumentChanger):

    def __init__(self, index):
        self.index = index

    def change_definition_info(self, call_info):
        if self.index < len(call_info.args_with_defaults):
            del call_info.args_with_defaults[self.index]
        elif self.index == len(call_info.args_with_defaults) and \
           call_info.args_arg is not None:
            call_info.args_arg = None
        elif (self.index == len(call_info.args_with_defaults) and
            call_info.args_arg is None and call_info.keywords_arg is not None) or \
           (self.index == len(call_info.args_with_defaults) + 1 and
            call_info.args_arg is not None and call_info.keywords_arg is not None):
            call_info.keywords_arg = None

    def change_argument_mapping(self, definition_info, mapping):
        if self.index < len(definition_info.args_with_defaults):
            name = definition_info.args_with_defaults[0]
            if name in mapping.param_dict:
                del mapping.param_dict[name]


class ArgumentAdder(_ArgumentChanger):

    def __init__(self, index, name, default=None, value=None):
        self.index = index
        self.name = name
        self.default = default
        self.value = value

    def change_definition_info(self, definition_info):
        for pair in definition_info.args_with_defaults:
            if pair[0] == self.name:
                raise rope.base.exceptions.RefactoringError(
                    'Adding duplicate parameter: <%s>.' % self.name)
        definition_info.args_with_defaults.insert(self.index,
                                                  (self.name, self.default))

    def change_argument_mapping(self, definition_info, mapping):
        if self.value is not None:
            mapping.param_dict[self.name] = self.value


class ArgumentDefaultInliner(_ArgumentChanger):

    def __init__(self, index):
        self.index = index
        self.remove = False

    def change_definition_info(self, definition_info):
        if self.remove:
            definition_info.args_with_defaults[self.index] = \
                (definition_info.args_with_defaults[self.index][0], None)

    def change_argument_mapping(self, definition_info, mapping):
        default = definition_info.args_with_defaults[self.index][1]
        name = definition_info.args_with_defaults[self.index][0]
        if default is not None and name not in mapping.param_dict:
            mapping.param_dict[name] = default


class ArgumentReorderer(_ArgumentChanger):

    def __init__(self, new_order, autodef=None):
        """Construct an `ArgumentReorderer`

        Note that the `new_order` is a list containing the new
        position of parameters; not the position each parameter
        is going to be moved to. (changed in ``0.5m4``)

        For example changing ``f(a, b, c)`` to ``f(c, a, b)``
        requires passing ``[2, 0, 1]`` and *not* ``[1, 2, 0]``.

        The `autodef` (automatic default) argument, forces rope to use
        it as a default if a default is needed after the change.  That
        happens when an argument without default is moved after
        another that has a default value.  Note that `autodef` should
        be a string or `None`; the latter disables adding automatic
        default.

        """
        self.new_order = new_order
        self.autodef = autodef

    def change_definition_info(self, definition_info):
        new_args = list(definition_info.args_with_defaults)
        for new_index, index in enumerate(self.new_order):
            new_args[new_index] = definition_info.args_with_defaults[index]
        seen_default = False
        for index, (arg, default) in enumerate(list(new_args)):
            if default is not None:
                seen_default = True
            if seen_default and default is None and self.autodef is not None:
                new_args[index] = (arg, self.autodef)
        definition_info.args_with_defaults = new_args


class _ChangeCallsInModule(object):

    def __init__(self, pycore, occurrence_finder, resource, call_changer):
        self.pycore = pycore
        self.occurrence_finder = occurrence_finder
        self.resource = resource
        self.call_changer = call_changer

    def get_changed_module(self):
        word_finder = worder.Worder(self.source)
        change_collector = codeanalyze.ChangeCollector(self.source)
        for occurrence in self.occurrence_finder.find_occurrences(self.resource):
            if not occurrence.is_called() and not occurrence.is_defined():
                continue
            start, end = occurrence.get_primary_range()
            begin_parens, end_parens = word_finder.get_word_parens_range(end - 1)
            if occurrence.is_called():
                primary, pyname = occurrence.get_primary_and_pyname()
                changed_call = self.call_changer.change_call(
                    primary, pyname, self.source[start:end_parens])
            else:
                changed_call = self.call_changer.change_definition(
                    self.source[start:end_parens])
            if changed_call is not None:
                change_collector.add_change(start, end_parens, changed_call)
        return change_collector.get_changed()

    @property
    @utils.saveit
    def pymodule(self):
        return self.pycore.resource_to_pyobject(self.resource)

    @property
    @utils.saveit
    def source(self):
        if self.resource is not None:
            return self.resource.read()
        else:
            return self.pymodule.source_code

    @property
    @utils.saveit
    def lines(self):
        return self.pymodule.lines


class _MultipleFinders(object):

    def __init__(self, finders):
        self.finders = finders

    def find_occurrences(self, resource=None, pymodule=None):
        all_occurrences = []
        for finder in self.finders:
            all_occurrences.extend(finder.find_occurrences(resource, pymodule))
        all_occurrences.sort(key = lambda o: o.get_primary_range())
        return all_occurrences


########NEW FILE########
__FILENAME__ = encapsulate_field
from rope.base import pynames, taskhandle, evaluate, exceptions, worder, utils
from rope.base.change import ChangeSet, ChangeContents
from rope.refactor import sourceutils, occurrences


class EncapsulateField(object):

    def __init__(self, project, resource, offset):
        self.pycore = project.pycore
        self.name = worder.get_name_at(resource, offset)
        this_pymodule = self.pycore.resource_to_pyobject(resource)
        self.pyname = evaluate.eval_location(this_pymodule, offset)
        if not self._is_an_attribute(self.pyname):
            raise exceptions.RefactoringError(
                'Encapsulate field should be performed on class attributes.')
        self.resource = self.pyname.get_definition_location()[0].get_resource()

    def get_changes(self, getter=None, setter=None, resources=None,
                    task_handle=taskhandle.NullTaskHandle()):
        """Get the changes this refactoring makes

        If `getter` is not `None`, that will be the name of the
        getter, otherwise ``get_${field_name}`` will be used.  The
        same is true for `setter` and if it is None set_${field_name} is
        used.

        `resources` can be a list of `rope.base.resource.File`\s that
        the refactoring should be applied on; if `None` all python
        files in the project are searched.

        """
        if resources is None:
            resources = self.pycore.get_python_files()
        changes = ChangeSet('Encapsulate field <%s>' % self.name)
        job_set = task_handle.create_jobset('Collecting Changes',
                                            len(resources))
        if getter is None:
            getter = 'get_' + self.name
        if setter is None:
            setter = 'set_' + self.name
        renamer = GetterSetterRenameInModule(
            self.pycore, self.name, self.pyname, getter, setter)
        for file in resources:
            job_set.started_job(file.path)
            if file == self.resource:
                result = self._change_holding_module(changes, renamer,
                                                     getter, setter)
                changes.add_change(ChangeContents(self.resource, result))
            else:
                result = renamer.get_changed_module(file)
                if result is not None:
                    changes.add_change(ChangeContents(file, result))
            job_set.finished_job()
        return changes

    def get_field_name(self):
        """Get the name of the field to be encapsulated"""
        return self.name

    def _is_an_attribute(self, pyname):
        if pyname is not None and isinstance(pyname, pynames.AssignedName):
            pymodule, lineno = self.pyname.get_definition_location()
            scope = pymodule.get_scope().\
                             get_inner_scope_for_line(lineno)
            if scope.get_kind() == 'Class':
                return pyname in list(scope.get_names().values())
            parent = scope.parent
            if parent is not None and parent.get_kind() == 'Class':
                return pyname in list(parent.get_names().values())
        return False

    def _get_defining_class_scope(self):
        defining_scope = self._get_defining_scope()
        if defining_scope.get_kind() == 'Function':
            defining_scope = defining_scope.parent
        return defining_scope

    def _get_defining_scope(self):
        pymodule, line = self.pyname.get_definition_location()
        return pymodule.get_scope().get_inner_scope_for_line(line)

    def _change_holding_module(self, changes, renamer, getter, setter):
        pymodule = self.pycore.resource_to_pyobject(self.resource)
        class_scope = self._get_defining_class_scope()
        defining_object = self._get_defining_scope().pyobject
        start, end = sourceutils.get_body_region(defining_object)

        new_source = renamer.get_changed_module(pymodule=pymodule,
                                                skip_start=start, skip_end=end)
        if new_source is not None:
            pymodule = self.pycore.get_string_module(new_source, self.resource)
            class_scope = pymodule.get_scope().\
                          get_inner_scope_for_line(class_scope.get_start())
        indents = sourceutils.get_indent(self.pycore) * ' '
        getter = 'def %s(self):\n%sreturn self.%s' % \
                 (getter, indents, self.name)
        setter = 'def %s(self, value):\n%sself.%s = value' % \
                 (setter, indents, self.name)
        new_source = sourceutils.add_methods(pymodule, class_scope,
                                             [getter, setter])
        return new_source


class GetterSetterRenameInModule(object):

    def __init__(self, pycore, name, pyname, getter, setter):
        self.pycore = pycore
        self.name = name
        self.finder = occurrences.create_finder(pycore, name, pyname)
        self.getter = getter
        self.setter = setter

    def get_changed_module(self, resource=None, pymodule=None,
                           skip_start=0, skip_end=0):
        change_finder = _FindChangesForModule(self, resource, pymodule,
                                              skip_start, skip_end)
        return change_finder.get_changed_module()


class _FindChangesForModule(object):

    def __init__(self, finder, resource, pymodule, skip_start, skip_end):
        self.pycore = finder.pycore
        self.finder = finder.finder
        self.getter = finder.getter
        self.setter = finder.setter
        self.resource = resource
        self.pymodule = pymodule
        self.last_modified = 0
        self.last_set = None
        self.set_index = None
        self.skip_start = skip_start
        self.skip_end = skip_end

    def get_changed_module(self):
        result = []
        for occurrence in self.finder.find_occurrences(self.resource,
                                                       self.pymodule):
            start, end = occurrence.get_word_range()
            if self.skip_start <= start < self.skip_end:
                continue
            self._manage_writes(start, result)
            result.append(self.source[self.last_modified:start])
            if self._is_assigned_in_a_tuple_assignment(occurrence):
                raise exceptions.RefactoringError(
                    'Cannot handle tuple assignments in encapsulate field.')
            if occurrence.is_written():
                assignment_type = self.worder.get_assignment_type(start)
                if assignment_type == '=':
                    result.append(self.setter + '(')
                else:
                    var_name = self.source[occurrence.get_primary_range()[0]:
                                           start] + self.getter + '()'
                    result.append(self.setter + '(' + var_name
                                  + ' %s ' % assignment_type[:-1])
                current_line = self.lines.get_line_number(start)
                start_line, end_line = self.pymodule.logical_lines.\
                                       logical_line_in(current_line)
                self.last_set = self.lines.get_line_end(end_line)
                end = self.source.index('=', end) + 1
                self.set_index = len(result)
            else:
                result.append(self.getter + '()')
            self.last_modified = end
        if self.last_modified != 0:
            self._manage_writes(len(self.source), result)
            result.append(self.source[self.last_modified:])
            return ''.join(result)
        return None

    def _manage_writes(self, offset, result):
        if self.last_set is not None and self.last_set <= offset:
            result.append(self.source[self.last_modified:self.last_set])
            set_value = ''.join(result[self.set_index:]).strip()
            del result[self.set_index:]
            result.append(set_value + ')')
            self.last_modified = self.last_set
            self.last_set = None

    def _is_assigned_in_a_tuple_assignment(self, occurance):
        offset = occurance.get_word_range()[0]
        return self.worder.is_assigned_in_a_tuple_assignment(offset)

    @property
    @utils.saveit
    def source(self):
        if self.resource is not None:
            return self.resource.read()
        else:
            return self.pymodule.source_code

    @property
    @utils.saveit
    def lines(self):
        if self.pymodule is None:
            self.pymodule = self.pycore.resource_to_pyobject(self.resource)
        return self.pymodule.lines

    @property
    @utils.saveit
    def worder(self):
        return worder.Worder(self.source)

########NEW FILE########
__FILENAME__ = extract
import re

from rope.base import ast, codeanalyze
from rope.base.change import ChangeSet, ChangeContents
from rope.base.exceptions import RefactoringError
from rope.refactor import (sourceutils, similarfinder,
                           patchedast, suites, usefunction)


# Extract refactoring has lots of special cases.  I tried to split it
# to smaller parts to make it more manageable:
#
# _ExtractInfo: holds information about the refactoring; it is passed
# to the parts that need to have information about the refactoring
# 
# _ExtractCollector: merely saves all of the information necessary for
# performing the refactoring.
#
# _DefinitionLocationFinder: finds where to insert the definition.
#
# _ExceptionalConditionChecker: checks for exceptional conditions in
# which the refactoring cannot be applied.
#
# _ExtractMethodParts: generates the pieces of code (like definition)
# needed for performing extract method.
#
# _ExtractVariableParts: like _ExtractMethodParts for variables.
#
# _ExtractPerformer: Uses above classes to collect refactoring
# changes.
#
# There are a few more helper functions and classes used by above
# classes.
class _ExtractRefactoring(object):

    def __init__(self, project, resource, start_offset, end_offset,
                 variable=False):
        self.project = project
        self.pycore = project.pycore
        self.resource = resource
        self.start_offset = self._fix_start(resource.read(), start_offset)
        self.end_offset = self._fix_end(resource.read(), end_offset)

    def _fix_start(self, source, offset):
        while offset < len(source) and source[offset].isspace():
            offset += 1
        return offset

    def _fix_end(self, source, offset):
        while offset > 0 and source[offset - 1].isspace():
            offset -= 1
        return offset

    def get_changes(self, extracted_name, similar=False, global_=False):
        """Get the changes this refactoring makes

        :parameters:
            - `similar`: if `True`, similar expressions/statements are also
              replaced.
            - `global_`: if `True`, the extracted method/variable will
              be global.

        """
        info = _ExtractInfo(
            self.project, self.resource, self.start_offset, self.end_offset,
            extracted_name, variable=self.kind == 'variable',
            similar=similar, make_global=global_)
        new_contents = _ExtractPerformer(info).extract()
        changes = ChangeSet('Extract %s <%s>' % (self.kind,
                                                 extracted_name))
        changes.add_change(ChangeContents(self.resource, new_contents))
        return changes


class ExtractMethod(_ExtractRefactoring):

    def __init__(self, *args, **kwds):
        super(ExtractMethod, self).__init__(*args, **kwds)

    kind = 'method'


class ExtractVariable(_ExtractRefactoring):

    def __init__(self, *args, **kwds):
        kwds = dict(kwds)
        kwds['variable'] = True
        super(ExtractVariable, self).__init__(*args, **kwds)

    kind = 'variable'


class _ExtractInfo(object):
    """Holds information about the extract to be performed"""

    def __init__(self, project, resource, start, end, new_name,
                 variable, similar, make_global):
        self.pycore = project.pycore
        self.resource = resource
        self.pymodule = self.pycore.resource_to_pyobject(resource)
        self.global_scope = self.pymodule.get_scope()
        self.source = self.pymodule.source_code
        self.lines = self.pymodule.lines
        self.new_name = new_name
        self.variable = variable
        self.similar = similar
        self._init_parts(start, end)
        self._init_scope()
        self.make_global = make_global

    def _init_parts(self, start, end):
        self.region = (self._choose_closest_line_end(start),
                       self._choose_closest_line_end(end, end=True))

        start = self.logical_lines.logical_line_in(
            self.lines.get_line_number(self.region[0]))[0]
        end = self.logical_lines.logical_line_in(
            self.lines.get_line_number(self.region[1]))[1]
        self.region_lines = (start, end)

        self.lines_region = (self.lines.get_line_start(self.region_lines[0]),
                             self.lines.get_line_end(self.region_lines[1]))

    @property
    def logical_lines(self):
        return self.pymodule.logical_lines

    def _init_scope(self):
        start_line = self.region_lines[0]
        scope = self.global_scope.get_inner_scope_for_line(start_line)
        if scope.get_kind() != 'Module' and scope.get_start() == start_line:
            scope = scope.parent
        self.scope = scope
        self.scope_region = self._get_scope_region(self.scope)

    def _get_scope_region(self, scope):
        return (self.lines.get_line_start(scope.get_start()),
                self.lines.get_line_end(scope.get_end()) + 1)

    def _choose_closest_line_end(self, offset, end=False):
        lineno = self.lines.get_line_number(offset)
        line_start = self.lines.get_line_start(lineno)
        line_end = self.lines.get_line_end(lineno)
        if self.source[line_start:offset].strip() == '':
            if end:
                return line_start - 1
            else:
                return line_start
        elif self.source[offset:line_end].strip() == '':
            return min(line_end, len(self.source))
        return offset

    @property
    def one_line(self):
        return self.region != self.lines_region and \
               (self.logical_lines.logical_line_in(self.region_lines[0]) ==
                self.logical_lines.logical_line_in(self.region_lines[1]))

    @property
    def global_(self):
        return self.scope.parent is None

    @property
    def method(self):
        return self.scope.parent is not None and \
               self.scope.parent.get_kind() == 'Class'

    @property
    def indents(self):
        return sourceutils.get_indents(self.pymodule.lines,
                                       self.region_lines[0])

    @property
    def scope_indents(self):
        if self.global_:
            return 0
        return sourceutils.get_indents(self.pymodule.lines,
                                       self.scope.get_start())

    @property
    def extracted(self):
        return self.source[self.region[0]:self.region[1]]

    _returned = None
    @property
    def returned(self):
        """Does the extracted piece contain return statement"""
        if self._returned is None:
            node = _parse_text(self.extracted)
            self._returned = usefunction._returns_last(node)
        return self._returned


class _ExtractCollector(object):
    """Collects information needed for performing the extract"""

    def __init__(self, info):
        self.definition = None
        self.body_pattern = None
        self.checks = {}
        self.replacement_pattern = None
        self.matches = None
        self.replacements = None
        self.definition_location = None


class _ExtractPerformer(object):

    def __init__(self, info):
        self.info = info
        _ExceptionalConditionChecker()(self.info)

    def extract(self):
        extract_info = self._collect_info()
        content = codeanalyze.ChangeCollector(self.info.source)
        definition = extract_info.definition
        lineno, indents = extract_info.definition_location
        offset = self.info.lines.get_line_start(lineno)
        indented = sourceutils.fix_indentation(definition, indents)
        content.add_change(offset, offset, indented)
        self._replace_occurrences(content, extract_info)
        return content.get_changed()

    def _replace_occurrences(self, content, extract_info):
        for match in extract_info.matches:
            replacement = similarfinder.CodeTemplate(
                extract_info.replacement_pattern)
            mapping = {}
            for name in replacement.get_names():
                node = match.get_ast(name)
                if node:
                    start, end = patchedast.node_region(match.get_ast(name))
                    mapping[name] = self.info.source[start:end]
                else:
                    mapping[name] = name
            region = match.get_region()
            content.add_change(region[0], region[1],
                               replacement.substitute(mapping))

    def _collect_info(self):
        extract_collector = _ExtractCollector(self.info)
        self._find_definition(extract_collector)
        self._find_matches(extract_collector)
        self._find_definition_location(extract_collector)
        return extract_collector

    def _find_matches(self, collector):
        regions = self._where_to_search()
        finder = similarfinder.SimilarFinder(self.info.pymodule)
        matches = []
        for start, end in regions:
            matches.extend((finder.get_matches(collector.body_pattern,
                                               collector.checks, start, end)))
        collector.matches = matches

    def _where_to_search(self):
        if self.info.similar:
            if self.info.make_global or self.info.global_:
                return [(0, len(self.info.pymodule.source_code))]
            if self.info.method and not self.info.variable:
                class_scope = self.info.scope.parent
                regions = []
                method_kind = _get_function_kind(self.info.scope)
                for scope in class_scope.get_scopes():
                    if method_kind == 'method' and \
                       _get_function_kind(scope) != 'method':
                        continue
                    start = self.info.lines.get_line_start(scope.get_start())
                    end = self.info.lines.get_line_end(scope.get_end())
                    regions.append((start, end))
                return regions
            else:
                if self.info.variable:
                    return [self.info.scope_region]
                else:
                    return [self.info._get_scope_region(self.info.scope.parent)]
        else:
            return [self.info.region]

    def _find_definition_location(self, collector):
        matched_lines = []
        for match in collector.matches:
            start = self.info.lines.get_line_number(match.get_region()[0])
            start_line = self.info.logical_lines.logical_line_in(start)[0]
            matched_lines.append(start_line)
        location_finder = _DefinitionLocationFinder(self.info, matched_lines)
        collector.definition_location = (location_finder.find_lineno(),
                                         location_finder.find_indents())

    def _find_definition(self, collector):
        if self.info.variable:
            parts = _ExtractVariableParts(self.info)
        else:
            parts = _ExtractMethodParts(self.info)
        collector.definition = parts.get_definition()
        collector.body_pattern = parts.get_body_pattern()
        collector.replacement_pattern = parts.get_replacement_pattern()
        collector.checks = parts.get_checks()


class _DefinitionLocationFinder(object):

    def __init__(self, info, matched_lines):
        self.info = info
        self.matched_lines = matched_lines
        # This only happens when subexpressions cannot be matched
        if not matched_lines:
            self.matched_lines.append(self.info.region_lines[0])

    def find_lineno(self):
        if self.info.variable and not self.info.make_global:
            return self._get_before_line()
        if self.info.make_global or self.info.global_:
            toplevel = self._find_toplevel(self.info.scope)
            ast = self.info.pymodule.get_ast()
            newlines = sorted(self.matched_lines + [toplevel.get_end() + 1])
            return suites.find_visible(ast, newlines)
        return self._get_after_scope()

    def _find_toplevel(self, scope):
        toplevel = scope
        if toplevel.parent is not None:
            while toplevel.parent.parent is not None:
                toplevel = toplevel.parent
        return toplevel

    def find_indents(self):
        if self.info.variable and not self.info.make_global:
            return sourceutils.get_indents(self.info.lines,
                                           self._get_before_line())
        else:
            if self.info.global_ or self.info.make_global:
                return 0
        return self.info.scope_indents

    def _get_before_line(self):
        ast = self.info.scope.pyobject.get_ast()
        return suites.find_visible(ast, self.matched_lines)

    def _get_after_scope(self):
        return self.info.scope.get_end() + 1


class _ExceptionalConditionChecker(object):

    def __call__(self, info):
        self.base_conditions(info)
        if info.one_line:
            self.one_line_conditions(info)
        else:
            self.multi_line_conditions(info)

    def base_conditions(self, info):
        if info.region[1] > info.scope_region[1]:
            raise RefactoringError('Bad region selected for extract method')
        end_line = info.region_lines[1]
        end_scope = info.global_scope.get_inner_scope_for_line(end_line)
        if end_scope != info.scope and end_scope.get_end() != end_line:
            raise RefactoringError('Bad region selected for extract method')
        try:
            extracted = info.source[info.region[0]:info.region[1]]
            if info.one_line:
                extracted = '(%s)' % extracted
            if _UnmatchedBreakOrContinueFinder.has_errors(extracted):
                raise RefactoringError('A break/continue without having a '
                                       'matching for/while loop.')
        except SyntaxError:
            raise RefactoringError('Extracted piece should '
                                   'contain complete statements.')

    def one_line_conditions(self, info):
        if self._is_region_on_a_word(info):
            raise RefactoringError('Should extract complete statements.')
        if info.variable and not info.one_line:
            raise RefactoringError('Extract variable should not '
                                   'span multiple lines.')

    def multi_line_conditions(self, info):
        node = _parse_text(info.source[info.region[0]:info.region[1]])
        count = usefunction._return_count(node)
        if count > 1:
            raise RefactoringError('Extracted piece can have only one '
                                   'return statement.')
        if usefunction._yield_count(node):
            raise RefactoringError('Extracted piece cannot '
                                   'have yield statements.')
        if count == 1 and not usefunction._returns_last(node):
            raise RefactoringError('Return should be the last statement.')
        if info.region != info.lines_region:
            raise RefactoringError('Extracted piece should '
                                   'contain complete statements.')

    def _is_region_on_a_word(self, info):
        if info.region[0] > 0 and self._is_on_a_word(info, info.region[0] - 1) or \
           self._is_on_a_word(info, info.region[1] - 1):
            return True

    def _is_on_a_word(self, info, offset):
        prev = info.source[offset]
        if not (prev.isalnum() or prev == '_') or \
           offset + 1 == len(info.source):
            return False
        next = info.source[offset + 1]
        return next.isalnum() or next == '_'


class _ExtractMethodParts(object):

    def __init__(self, info):
        self.info = info
        self.info_collector = self._create_info_collector()

    def get_definition(self):
        if self.info.global_:
            return '\n%s\n' % self._get_function_definition()
        else:
            return '\n%s' % self._get_function_definition()

    def get_replacement_pattern(self):
        variables = []
        variables.extend(self._find_function_arguments())
        variables.extend(self._find_function_returns())
        return similarfinder.make_pattern(self._get_call(), variables)

    def get_body_pattern(self):
        variables = []
        variables.extend(self._find_function_arguments())
        variables.extend(self._find_function_returns())
        variables.extend(self._find_temps())
        return similarfinder.make_pattern(self._get_body(), variables)

    def _get_body(self):
        result = sourceutils.fix_indentation(self.info.extracted, 0)
        if self.info.one_line:
            result = '(%s)' % result
        return result

    def _find_temps(self):
        return usefunction.find_temps(self.info.pycore.project,
                                      self._get_body())

    def get_checks(self):
        if self.info.method and not self.info.make_global:
            if _get_function_kind(self.info.scope) == 'method':
                class_name = similarfinder._pydefined_to_str(
                    self.info.scope.parent.pyobject)
                return {self._get_self_name(): 'type=' + class_name}
        return {}

    def _create_info_collector(self):
        zero = self.info.scope.get_start() - 1
        start_line = self.info.region_lines[0] - zero
        end_line = self.info.region_lines[1] - zero
        info_collector = _FunctionInformationCollector(start_line, end_line,
                                                       self.info.global_)
        body = self.info.source[self.info.scope_region[0]:
                                self.info.scope_region[1]]
        node = _parse_text(body)
        ast.walk(node, info_collector)
        return info_collector

    def _get_function_definition(self):
        args = self._find_function_arguments()
        returns = self._find_function_returns()
        result = []
        if self.info.method and not self.info.make_global and \
           _get_function_kind(self.info.scope) != 'method':
            result.append('@staticmethod\n')
        result.append('def %s:\n' % self._get_function_signature(args))
        unindented_body = self._get_unindented_function_body(returns)
        indents = sourceutils.get_indent(self.info.pycore)
        function_body = sourceutils.indent_lines(unindented_body, indents)
        result.append(function_body)
        definition = ''.join(result)

        return definition + '\n'

    def _get_function_signature(self, args):
        args = list(args)
        prefix = ''
        if self._extracting_method():
            self_name = self._get_self_name()
            if self_name is None:
                raise RefactoringError('Extracting a method from a function '
                                       'with no self argument.')
            if self_name in args:
                args.remove(self_name)
            args.insert(0, self_name)
        return prefix + self.info.new_name + \
               '(%s)' % self._get_comma_form(args)

    def _extracting_method(self):
        return self.info.method and not self.info.make_global and \
               _get_function_kind(self.info.scope) == 'method'

    def _get_self_name(self):
        param_names = self.info.scope.pyobject.get_param_names()
        if param_names:
            return param_names[0]

    def _get_function_call(self, args):
        prefix = ''
        if self.info.method and not self.info.make_global:
            if _get_function_kind(self.info.scope) == 'method':
                self_name = self._get_self_name()
                if  self_name in args:
                    args.remove(self_name)
                prefix = self_name + '.'
            else:
                prefix = self.info.scope.parent.pyobject.get_name() + '.'
        return prefix + '%s(%s)' % (self.info.new_name,
                                    self._get_comma_form(args))

    def _get_comma_form(self, names):
        result = ''
        if names:
            result += names[0]
            for name in names[1:]:
                result += ', ' + name
        return result

    def _get_call(self):
        if self.info.one_line:
            args = self._find_function_arguments()
            return self._get_function_call(args)
        args = self._find_function_arguments()
        returns = self._find_function_returns()
        call_prefix = ''
        if returns:
            call_prefix = self._get_comma_form(returns) + ' = '
        if self.info.returned:
            call_prefix = 'return '
        return call_prefix + self._get_function_call(args)

    def _find_function_arguments(self):
        # if not make_global, do not pass any global names; they are
        # all visible.
        if self.info.global_ and not self.info.make_global:
            return ()
        if not self.info.one_line:
            result = (self.info_collector.prewritten &
                      self.info_collector.read)
            result |= (self.info_collector.prewritten &
                       self.info_collector.postread &
                       (self.info_collector.maybe_written -
                        self.info_collector.written))
            return list(result)
        start = self.info.region[0]
        if start == self.info.lines_region[0]:
            start = start + re.search('\S', self.info.extracted).start()
        function_definition = self.info.source[start:self.info.region[1]]
        read = _VariableReadsAndWritesFinder.find_reads_for_one_liners(
            function_definition)
        return list(self.info_collector.prewritten.intersection(read))

    def _find_function_returns(self):
        if self.info.one_line or self.info.returned:
            return []
        written = self.info_collector.written | \
                  self.info_collector.maybe_written
        return list(written & self.info_collector.postread)

    def _get_unindented_function_body(self, returns):
        if self.info.one_line:
            return 'return ' + _join_lines(self.info.extracted)
        extracted_body = self.info.extracted
        unindented_body = sourceutils.fix_indentation(extracted_body, 0)
        if returns:
            unindented_body += '\nreturn %s' % self._get_comma_form(returns)
        return unindented_body


class _ExtractVariableParts(object):

    def __init__(self, info):
        self.info = info

    def get_definition(self):
        result = self.info.new_name + ' = ' + \
                 _join_lines(self.info.extracted) + '\n'
        return result

    def get_body_pattern(self):
        return '(%s)' % self.info.extracted.strip()

    def get_replacement_pattern(self):
        return self.info.new_name

    def get_checks(self):
        return {}


class _FunctionInformationCollector(object):

    def __init__(self, start, end, is_global):
        self.start = start
        self.end = end
        self.is_global = is_global
        self.prewritten = set()
        self.maybe_written = set()
        self.written = set()
        self.read = set()
        self.postread = set()
        self.postwritten = set()
        self.host_function = True
        self.conditional = False

    def _read_variable(self, name, lineno):
        if self.start <= lineno <= self.end:
            if name not in self.written:
                self.read.add(name)
        if self.end < lineno:
            if name not in self.postwritten:
                self.postread.add(name)

    def _written_variable(self, name, lineno):
        if self.start <= lineno <= self.end:
            if self.conditional:
                self.maybe_written.add(name)
            else:
                self.written.add(name)
        if self.start > lineno:
            self.prewritten.add(name)
        if self.end < lineno:
            self.postwritten.add(name)

    def _FunctionDef(self, node):
        if not self.is_global and self.host_function:
            self.host_function = False
            for name in _get_argnames(node.args):
                self._written_variable(name, node.lineno)
            for child in node.body:
                ast.walk(child, self)
        else:
            self._written_variable(node.name, node.lineno)
            visitor = _VariableReadsAndWritesFinder()
            for child in node.body:
                ast.walk(child, visitor)
            for name in visitor.read - visitor.written:
                self._read_variable(name, node.lineno)

    def _Name(self, node):
        if isinstance(node.ctx, (ast.Store, ast.AugStore)):
            self._written_variable(node.id, node.lineno)
        if not isinstance(node.ctx, ast.Store):
            self._read_variable(node.id, node.lineno)

    def _Assign(self, node):
        ast.walk(node.value, self)
        for child in node.targets:
            ast.walk(child, self)

    def _ClassDef(self, node):
        self._written_variable(node.name, node.lineno)

    def _handle_conditional_node(self, node):
        self.conditional = True
        try:
            for child in ast.get_child_nodes(node):
                ast.walk(child, self)
        finally:
            self.conditional = False

    def _If(self, node):
        self._handle_conditional_node(node)

    def _While(self, node):
        self._handle_conditional_node(node)

    def _For(self, node):
        self._handle_conditional_node(node)



def _get_argnames(arguments):
    result = [node.arg for node in arguments.args
              if isinstance(node, ast.arg)]
    if arguments.vararg:
        result.append(arguments.vararg)
    if arguments.kwarg:
        result.append(arguments.kwarg)
    return result


class _VariableReadsAndWritesFinder(object):

    def __init__(self):
        self.written = set()
        self.read = set()

    def _Name(self, node):
        if isinstance(node.ctx, (ast.Store, ast.AugStore)):
            self.written.add(node.id)
        if not isinstance(node, ast.Store):
            self.read.add(node.id)

    def _FunctionDef(self, node):
        self.written.add(node.name)
        visitor = _VariableReadsAndWritesFinder()
        for child in ast.get_child_nodes(node):
            ast.walk(child, visitor)
        self.read.update(visitor.read - visitor.written)

    def _Class(self, node):
        self.written.add(node.name)

    @staticmethod
    def find_reads_and_writes(code):
        if code.strip() == '':
            return set(), set()
        if isinstance(code, str):
            code = code.encode('utf-8')
        node = _parse_text(code)
        visitor = _VariableReadsAndWritesFinder()
        ast.walk(node, visitor)
        return visitor.read, visitor.written

    @staticmethod
    def find_reads_for_one_liners(code):
        if code.strip() == '':
            return set(), set()
        node = _parse_text(code)
        visitor = _VariableReadsAndWritesFinder()
        ast.walk(node, visitor)
        return visitor.read


class _UnmatchedBreakOrContinueFinder(object):

    def __init__(self):
        self.error = False
        self.loop_count = 0

    def _For(self, node):
        self.loop_encountered(node)

    def _While(self, node):
        self.loop_encountered(node)

    def loop_encountered(self, node):
        self.loop_count += 1
        for child in node.body:
            ast.walk(child, self)
        self.loop_count -= 1
        if node.orelse:
            ast.walk(node.orelse, self)

    def _Break(self, node):
        self.check_loop()

    def _Continue(self, node):
        self.check_loop()

    def check_loop(self):
        if self.loop_count < 1:
            self.error = True

    def _FunctionDef(self, node):
        pass

    def _ClassDef(self, node):
        pass

    @staticmethod
    def has_errors(code):
        if code.strip() == '':
            return False
        node = _parse_text(code)
        visitor = _UnmatchedBreakOrContinueFinder()
        ast.walk(node, visitor)
        return visitor.error

def _get_function_kind(scope):
    return scope.pyobject.get_kind()


def _parse_text(body):
    body = sourceutils.fix_indentation(body, 0)
    node = ast.parse(body)
    return node

def _join_lines(code):
    lines = []
    for line in code.splitlines():
        if line.endswith('\\'):
            lines.append(line[:-1].strip())
        else:
            lines.append(line.strip())
    return ' '.join(lines)

########NEW FILE########
__FILENAME__ = functionutils
import rope.base.exceptions
import rope.base.pyobjects
from rope.base.builtins import Lambda
from rope.base import worder


class DefinitionInfo(object):

    def __init__(self, function_name, is_method, args_with_defaults,
                 args_arg, keywords_arg):
        self.function_name = function_name
        self.is_method = is_method
        self.args_with_defaults = args_with_defaults
        self.args_arg = args_arg
        self.keywords_arg = keywords_arg

    def to_string(self):
        return '%s(%s)' % (self.function_name, self.arguments_to_string())

    def arguments_to_string(self, from_index=0):
        params = []
        for arg, default in self.args_with_defaults:
            if default is not None:
                params.append('%s=%s' % (arg, default))
            else:
                params.append(arg)
        if self.args_arg is not None:
            params.append('*' + self.args_arg)
        if self.keywords_arg:
            params.append('**' + self.keywords_arg)
        return ', '.join(params[from_index:])

    @staticmethod
    def _read(pyfunction, code):
        scope = pyfunction.get_scope()
        parent = scope.parent
        parameter_names = pyfunction.get_param_names()
        kind = pyfunction.get_kind()
        is_method = kind == 'method'
        is_lambda = kind == 'lambda'
        info = _FunctionParser(code, is_method, is_lambda)
        args, keywords = info.get_parameters()
        args_arg = None
        keywords_arg = None
        if args and args[-1].startswith('**'):
            keywords_arg = args[-1][2:]
            del args[-1]
        if args and args[-1].startswith('*'):
            args_arg = args[-1][1:]
            del args[-1]
        args_with_defaults = [(name, None) for name in args]
        args_with_defaults.extend(keywords)
        return DefinitionInfo(info.get_function_name(), is_method,
                              args_with_defaults, args_arg, keywords_arg)

    @staticmethod
    def read(pyfunction):
        pymodule = pyfunction.get_module()
        word_finder = worder.Worder(pymodule.source_code)
        lineno = pyfunction.get_ast().lineno
        start = pymodule.lines.get_line_start(lineno)
        if isinstance(pyfunction, Lambda):
            call = word_finder.get_lambda_and_args(start)
        else:
            call = word_finder.get_function_and_args_in_header(start)
        return DefinitionInfo._read(pyfunction, call)


class CallInfo(object):

    def __init__(self, function_name, args, keywords, args_arg,
                 keywords_arg, implicit_arg, constructor):
        self.function_name = function_name
        self.args = args
        self.keywords = keywords
        self.args_arg = args_arg
        self.keywords_arg = keywords_arg
        self.implicit_arg = implicit_arg
        self.constructor = constructor

    def to_string(self):
        function = self.function_name
        if self.implicit_arg:
            function = self.args[0] + '.' + self.function_name
        params = []
        start = 0
        if self.implicit_arg or self.constructor:
            start = 1
        if self.args[start:]:
            params.extend(self.args[start:])
        if self.keywords:
            params.extend(['%s=%s' % (name, value) for name, value in self.keywords])
        if self.args_arg is not None:
            params.append('*' + self.args_arg)
        if self.keywords_arg:
            params.append('**' + self.keywords_arg)
        return '%s(%s)' % (function, ', '.join(params))

    @staticmethod
    def read(primary, pyname, definition_info, code):
        is_method_call = CallInfo._is_method_call(primary, pyname)
        is_constructor = CallInfo._is_class(pyname)
        is_classmethod = CallInfo._is_classmethod(pyname)
        info = _FunctionParser(code, is_method_call or is_classmethod)
        args, keywords = info.get_parameters()
        args_arg = None
        keywords_arg = None
        if args and args[-1].startswith('**'):
            keywords_arg = args[-1][2:]
            del args[-1]
        if args and args[-1].startswith('*'):
            args_arg = args[-1][1:]
            del args[-1]
        if is_constructor:
            args.insert(0, definition_info.args_with_defaults[0][0])
        return CallInfo(info.get_function_name(), args, keywords, args_arg,
                        keywords_arg, is_method_call or is_classmethod,
                        is_constructor)

    @staticmethod
    def _is_method_call(primary, pyname):
        return primary is not None and \
               isinstance(primary.get_object().get_type(),
                          rope.base.pyobjects.PyClass) and \
                          CallInfo._is_method(pyname)

    @staticmethod
    def _is_class(pyname):
        return pyname is not None and \
               isinstance(pyname.get_object(),
                          rope.base.pyobjects.PyClass)

    @staticmethod
    def _is_method(pyname):
        if pyname is not None and \
           isinstance(pyname.get_object(), rope.base.pyobjects.PyFunction):
            return pyname.get_object().get_kind() == 'method'
        return False

    @staticmethod
    def _is_classmethod(pyname):
        if pyname is not None and \
           isinstance(pyname.get_object(), rope.base.pyobjects.PyFunction):
            return pyname.get_object().get_kind() == 'classmethod'
        return False


class ArgumentMapping(object):

    def __init__(self, definition_info, call_info):
        self.call_info = call_info
        self.param_dict = {}
        self.keyword_args = []
        self.args_arg = []
        for index, value in enumerate(call_info.args):
            if index < len(definition_info.args_with_defaults):
                name = definition_info.args_with_defaults[index][0]
                self.param_dict[name] = value
            else:
                self.args_arg.append(value)
        for name, value in call_info.keywords:
            index = -1
            for pair in definition_info.args_with_defaults:
                if pair[0] == name:
                    self.param_dict[name] = value
                    break
            else:
                self.keyword_args.append((name, value))

    def to_call_info(self, definition_info):
        args = []
        keywords = []
        for index in range(len(definition_info.args_with_defaults)):
            name = definition_info.args_with_defaults[index][0]
            if name in self.param_dict:
                args.append(self.param_dict[name])
            else:
                for i in range(index, len(definition_info.args_with_defaults)):
                    name = definition_info.args_with_defaults[i][0]
                    if name in self.param_dict:
                        keywords.append((name, self.param_dict[name]))
                break
        args.extend(self.args_arg)
        keywords.extend(self.keyword_args)
        return CallInfo(self.call_info.function_name, args, keywords,
                        self.call_info.args_arg, self.call_info.keywords_arg,
                        self.call_info.implicit_arg, self.call_info.constructor)


class _FunctionParser(object):

    def __init__(self, call, implicit_arg, is_lambda=False):
        self.call = call
        self.implicit_arg = implicit_arg
        self.word_finder = worder.Worder(self.call)
        if is_lambda:
            self.last_parens = self.call.rindex(':')
        else:
            self.last_parens = self.call.rindex(')')
        self.first_parens = self.word_finder._find_parens_start(self.last_parens)

    def get_parameters(self):
        args, keywords = self.word_finder.get_parameters(self.first_parens,
                                                         self.last_parens)
        if self.is_called_as_a_method():
            instance = self.call[:self.call.rindex('.', 0, self.first_parens)]
            args.insert(0, instance.strip())
        return args, keywords

    def get_instance(self):
        if self.is_called_as_a_method():
            return self.word_finder.get_primary_at(
                self.call.rindex('.', 0, self.first_parens) - 1)

    def get_function_name(self):
        if self.is_called_as_a_method():
            return self.word_finder.get_word_at(self.first_parens - 1)
        else:
            return self.word_finder.get_primary_at(self.first_parens - 1)

    def is_called_as_a_method(self):
        return self.implicit_arg and '.' in self.call[:self.first_parens]

########NEW FILE########
__FILENAME__ = actions
import os
import sys

from rope.base import pyobjects, exceptions, stdmods
from rope.refactor import occurrences
from rope.refactor.importutils import importinfo


class ImportInfoVisitor(object):

    def dispatch(self, import_):
        try:
            method_name = 'visit' + import_.import_info.__class__.__name__
            method = getattr(self, method_name)
            return method(import_, import_.import_info)
        except exceptions.ModuleNotFoundError:
            pass

    def visitEmptyImport(self, import_stmt, import_info):
        pass

    def visitNormalImport(self, import_stmt, import_info):
        pass

    def visitFromImport(self, import_stmt, import_info):
        pass


class RelativeToAbsoluteVisitor(ImportInfoVisitor):

    def __init__(self, pycore, current_folder):
        self.to_be_absolute = []
        self.pycore = pycore
        self.folder = current_folder
        self.context = importinfo.ImportContext(pycore, current_folder)

    def visitNormalImport(self, import_stmt, import_info):
        self.to_be_absolute.extend(self._get_relative_to_absolute_list(import_info))
        new_pairs = []
        for name, alias in import_info.names_and_aliases:
            resource = self.pycore.find_module(name, folder=self.folder)
            if resource is None:
                new_pairs.append((name, alias))
                continue
            absolute_name = self.pycore.modname(resource)
            new_pairs.append((absolute_name, alias))
        if not import_info._are_name_and_alias_lists_equal(
            new_pairs, import_info.names_and_aliases):
            import_stmt.import_info = importinfo.NormalImport(new_pairs)

    def _get_relative_to_absolute_list(self, import_info):
        result = []
        for name, alias in import_info.names_and_aliases:
            if alias is not None:
                continue
            resource = self.pycore.find_module(name, folder=self.folder)
            if resource is None:
                continue
            absolute_name = self.pycore.modname(resource)
            if absolute_name != name:
                result.append((name, absolute_name))
        return result

    def visitFromImport(self, import_stmt, import_info):
        resource = import_info.get_imported_resource(self.context)
        if resource is None:
            return None
        absolute_name = self.pycore.modname(resource)
        if import_info.module_name != absolute_name:
            import_stmt.import_info = importinfo.FromImport(
                absolute_name, 0, import_info.names_and_aliases)


class FilteringVisitor(ImportInfoVisitor):

    def __init__(self, pycore, folder, can_select):
        self.to_be_absolute = []
        self.pycore = pycore
        self.can_select = self._transform_can_select(can_select)
        self.context = importinfo.ImportContext(pycore, folder)

    def _transform_can_select(self, can_select):
        def can_select_name_and_alias(name, alias):
            imported = name
            if alias is not None:
                imported = alias
            return can_select(imported)
        return can_select_name_and_alias

    def visitNormalImport(self, import_stmt, import_info):
        new_pairs = []
        for name, alias in import_info.names_and_aliases:
            if self.can_select(name, alias):
                new_pairs.append((name, alias))
        return importinfo.NormalImport(new_pairs)

    def visitFromImport(self, import_stmt, import_info):
        if _is_future(import_info):
            return import_info
        new_pairs = []
        if import_info.is_star_import():
            for name in import_info.get_imported_names(self.context):
                if self.can_select(name, None):
                    new_pairs.append(import_info.names_and_aliases[0])
                    break
        else:
            for name, alias in import_info.names_and_aliases:
                if self.can_select(name, alias):
                    new_pairs.append((name, alias))
        return importinfo.FromImport(
            import_info.module_name, import_info.level, new_pairs)


class RemovingVisitor(ImportInfoVisitor):

    def __init__(self, pycore, folder, can_select):
        self.to_be_absolute = []
        self.pycore = pycore
        self.filtering = FilteringVisitor(pycore, folder, can_select)

    def dispatch(self, import_):
        result = self.filtering.dispatch(import_)
        if result is not None:
            import_.import_info = result


class AddingVisitor(ImportInfoVisitor):
    """A class for adding imports

    Given a list of `ImportInfo`\s, it tries to add each import to the
    module and returns `True` and gives up when an import can be added
    to older ones.

    """

    def __init__(self, pycore, import_list):
        self.pycore = pycore
        self.import_list = import_list
        self.import_info = None

    def dispatch(self, import_):
        for import_info in self.import_list:
            self.import_info = import_info
            if ImportInfoVisitor.dispatch(self, import_):
                return True

    # TODO: Handle adding relative and absolute imports
    def visitNormalImport(self, import_stmt, import_info):
        if not isinstance(self.import_info, import_info.__class__):
            return False
        # Adding ``import x`` and ``import x.y`` that results ``import x.y``
        if len(import_info.names_and_aliases) == \
           len(self.import_info.names_and_aliases) == 1:
            imported1 = import_info.names_and_aliases[0]
            imported2 = self.import_info.names_and_aliases[0]
            if imported1[1] == imported2[1] is None:
                if imported1[0].startswith(imported2[0] + '.'):
                    return True
                if imported2[0].startswith(imported1[0] + '.'):
                    import_stmt.import_info = self.import_info
                    return True
        # Multiple imports using a single import statement is discouraged
        # so we won't bother adding them.
        if self.import_info._are_name_and_alias_lists_equal(
            import_info.names_and_aliases, self.import_info.names_and_aliases):
            return True

    def visitFromImport(self, import_stmt, import_info):
        if isinstance(self.import_info, import_info.__class__) and \
           import_info.module_name == self.import_info.module_name and \
           import_info.level == self.import_info.level:
            if import_info.is_star_import():
                return True
            if self.import_info.is_star_import():
                import_stmt.import_info = self.import_info
                return True
            new_pairs = list(import_info.names_and_aliases)
            for pair in self.import_info.names_and_aliases:
                if pair not in new_pairs:
                    new_pairs.append(pair)
            import_stmt.import_info = importinfo.FromImport(
                import_info.module_name, import_info.level, new_pairs)
            return True


class ExpandStarsVisitor(ImportInfoVisitor):

    def __init__(self, pycore, folder, can_select):
        self.pycore = pycore
        self.filtering = FilteringVisitor(pycore, folder, can_select)
        self.context = importinfo.ImportContext(pycore, folder)

    def visitNormalImport(self, import_stmt, import_info):
        self.filtering.dispatch(import_stmt)

    def visitFromImport(self, import_stmt, import_info):
        if import_info.is_star_import():
            new_pairs = []
            for name in import_info.get_imported_names(self.context):
                new_pairs.append((name, None))
            new_import = importinfo.FromImport(
                import_info.module_name, import_info.level, new_pairs)
            import_stmt.import_info = \
                self.filtering.visitFromImport(None, new_import)
        else:
            self.filtering.dispatch(import_stmt)


class SelfImportVisitor(ImportInfoVisitor):

    def __init__(self, pycore, current_folder, resource):
        self.pycore = pycore
        self.folder = current_folder
        self.resource = resource
        self.to_be_fixed = set()
        self.to_be_renamed = set()
        self.context = importinfo.ImportContext(pycore, current_folder)

    def visitNormalImport(self, import_stmt, import_info):
        new_pairs = []
        for name, alias in import_info.names_and_aliases:
            resource = self.pycore.find_module(name, folder=self.folder)
            if resource is not None and resource == self.resource:
                imported = name
                if alias is not None:
                    imported = alias
                self.to_be_fixed.add(imported)
            else:
                new_pairs.append((name, alias))
        if not import_info._are_name_and_alias_lists_equal(
            new_pairs, import_info.names_and_aliases):
            import_stmt.import_info = importinfo.NormalImport(new_pairs)

    def visitFromImport(self, import_stmt, import_info):
        resource = import_info.get_imported_resource(self.context)
        if resource is None:
            return
        if resource == self.resource:
            self._importing_names_from_self(import_info, import_stmt)
            return
        pymodule = self.pycore.resource_to_pyobject(resource)
        new_pairs = []
        for name, alias in import_info.names_and_aliases:
            try:
                result = pymodule[name].get_object()
                if isinstance(result, pyobjects.PyModule) and \
                   result.get_resource() == self.resource:
                    imported = name
                    if alias is not None:
                        imported = alias
                    self.to_be_fixed.add(imported)
                else:
                    new_pairs.append((name, alias))
            except exceptions.AttributeNotFoundError:
                new_pairs.append((name, alias))
        if not import_info._are_name_and_alias_lists_equal(
            new_pairs, import_info.names_and_aliases):
            import_stmt.import_info = importinfo.FromImport(
                import_info.module_name, import_info.level, new_pairs)

    def _importing_names_from_self(self, import_info, import_stmt):
        if not import_info.is_star_import():
            for name, alias in import_info.names_and_aliases:
                if alias is not None:
                    self.to_be_renamed.add((alias, name))
        import_stmt.empty_import()


class SortingVisitor(ImportInfoVisitor):

    def __init__(self, pycore, current_folder):
        self.pycore = pycore
        self.folder = current_folder
        self.standard = set()
        self.third_party = set()
        self.in_project = set()
        self.future = set()
        self.context = importinfo.ImportContext(pycore, current_folder)

    def visitNormalImport(self, import_stmt, import_info):
        if import_info.names_and_aliases:
            name, alias = import_info.names_and_aliases[0]
            resource = self.pycore.find_module(
                name, folder=self.folder)
            self._check_imported_resource(import_stmt, resource, name)

    def visitFromImport(self, import_stmt, import_info):
        resource = import_info.get_imported_resource(self.context)
        self._check_imported_resource(import_stmt, resource,
                                      import_info.module_name)

    def _check_imported_resource(self, import_stmt, resource, imported_name):
        info = import_stmt.import_info
        if resource is not None and resource.project == self.pycore.project:
            self.in_project.add(import_stmt)
        elif _is_future(info):
            self.future.add(import_stmt)
        elif imported_name.split('.')[0] in stdmods.standard_modules():
            self.standard.add(import_stmt)
        else:
            self.third_party.add(import_stmt)


class LongImportVisitor(ImportInfoVisitor):

    def __init__(self, current_folder, pycore, maxdots, maxlength):
        self.maxdots = maxdots
        self.maxlength = maxlength
        self.to_be_renamed = set()
        self.current_folder = current_folder
        self.pycore = pycore
        self.new_imports = []

    def visitNormalImport(self, import_stmt, import_info):
        new_pairs = []
        for name, alias in import_info.names_and_aliases:
            if alias is None and self._is_long(name):
                self.to_be_renamed.add(name)
                last_dot = name.rindex('.')
                from_ = name[:last_dot]
                imported = name[last_dot + 1:]
                self.new_imports.append(
                    importinfo.FromImport(from_, 0, ((imported, None), )))

    def _is_long(self, name):
        return name.count('.') > self.maxdots or \
               ('.' in name and len(name) > self.maxlength)


class RemovePyNameVisitor(ImportInfoVisitor):

    def __init__(self, pycore, pymodule, pyname, folder):
        self.pymodule = pymodule
        self.pyname = pyname
        self.context = importinfo.ImportContext(pycore, folder)

    def visitFromImport(self, import_stmt, import_info):
        new_pairs = []
        if not import_info.is_star_import():
            for name, alias in import_info.names_and_aliases:
                try:
                    pyname = self.pymodule[alias or name]
                    if occurrences.same_pyname(self.pyname, pyname):
                        continue
                except exceptions.AttributeNotFoundError:
                    pass
                new_pairs.append((name, alias))
        return importinfo.FromImport(
            import_info.module_name, import_info.level, new_pairs)

    def dispatch(self, import_):
        result = ImportInfoVisitor.dispatch(self, import_)
        if result is not None:
            import_.import_info = result


def _is_future(info):
    return isinstance(info, importinfo.FromImport) and \
           info.module_name == '__future__'

########NEW FILE########
__FILENAME__ = importinfo
class ImportStatement(object):
    """Represent an import in a module

    `readonly` attribute controls whether this import can be changed
    by import actions or not.

    """

    def __init__(self, import_info, start_line, end_line,
                 main_statement=None, blank_lines=0):
        self.start_line = start_line
        self.end_line = end_line
        self.readonly = False
        self.main_statement = main_statement
        self._import_info = None
        self.import_info = import_info
        self._is_changed = False
        self.new_start = None
        self.blank_lines = blank_lines

    def _get_import_info(self):
        return self._import_info

    def _set_import_info(self, new_import):
        if not self.readonly and \
           new_import is not None and not new_import == self._import_info:
            self._is_changed = True
            self._import_info = new_import

    import_info = property(_get_import_info, _set_import_info)

    def get_import_statement(self):
        if self._is_changed or self.main_statement is None:
            return self.import_info.get_import_statement()
        else:
            return self.main_statement

    def empty_import(self):
        self.import_info = ImportInfo.get_empty_import()

    def move(self, lineno, blank_lines=0):
        self.new_start = lineno
        self.blank_lines = blank_lines

    def get_old_location(self):
        return self.start_line, self.end_line

    def get_new_start(self):
        return self.new_start

    def is_changed(self):
        return self._is_changed or (self.new_start is not None or
                                    self.new_start != self.start_line)

    def accept(self, visitor):
        return visitor.dispatch(self)


class ImportInfo(object):

    def get_imported_primaries(self, context):
        pass

    def get_imported_names(self, context):
        return [primary.split('.')[0]
                for primary in self.get_imported_primaries(context)]

    def get_import_statement(self):
        pass

    def is_empty(self):
        pass

    def __hash__(self):
        return hash(self.get_import_statement())

    def _are_name_and_alias_lists_equal(self, list1, list2):
        if len(list1) != len(list2):
            return False
        for pair1, pair2 in list(zip(list1, list2)):
            if pair1 != pair2:
                return False
        return True

    def __eq__(self, obj):
        return isinstance(obj, self.__class__) and \
               self.get_import_statement() == obj.get_import_statement()

    def __ne__(self, obj):
        return not self.__eq__(obj)

    @staticmethod
    def get_empty_import():
        return EmptyImport()


class NormalImport(ImportInfo):

    def __init__(self, names_and_aliases):
        self.names_and_aliases = names_and_aliases

    def get_imported_primaries(self, context):
        result = []
        for name, alias in self.names_and_aliases:
            if alias:
                result.append(alias)
            else:
                result.append(name)
        return result

    def get_import_statement(self):
        result = 'import '
        for name, alias in self.names_and_aliases:
            result += name
            if alias:
                result += ' as ' + alias
            result += ', '
        return result[:-2]

    def is_empty(self):
        return len(self.names_and_aliases) == 0


class FromImport(ImportInfo):

    def __init__(self, module_name, level, names_and_aliases):
        self.module_name = module_name
        self.level = level
        self.names_and_aliases = names_and_aliases

    def get_imported_primaries(self, context):
        if self.names_and_aliases[0][0] == '*':
            module = self.get_imported_module(context)
            return [name for name in module
                    if not name.startswith('_')]
        result = []
        for name, alias in self.names_and_aliases:
            if alias:
                result.append(alias)
            else:
                result.append(name)
        return result

    def get_imported_resource(self, context):
        """Get the imported resource

        Returns `None` if module was not found.
        """
        if self.level == 0:
            return context.pycore.find_module(
                self.module_name, folder=context.folder)
        else:
            return context.pycore.find_relative_module(
                self.module_name, context.folder, self.level)

    def get_imported_module(self, context):
        """Get the imported `PyModule`

        Raises `rope.base.exceptions.ModuleNotFoundError` if module
        could not be found.
        """
        if self.level == 0:
            return context.pycore.get_module(
                self.module_name, context.folder)
        else:
            return context.pycore.get_relative_module(
                self.module_name, context.folder, self.level)

    def get_import_statement(self):
        result = 'from ' + '.' * self.level + self.module_name + ' import '
        for name, alias in self.names_and_aliases:
            result += name
            if alias:
                result += ' as ' + alias
            result += ', '
        return result[:-2]

    def is_empty(self):
        return len(self.names_and_aliases) == 0

    def is_star_import(self):
        return len(self.names_and_aliases) > 0 and \
               self.names_and_aliases[0][0] == '*'


class EmptyImport(ImportInfo):

    names_and_aliases = []

    def is_empty(self):
        return True

    def get_imported_primaries(self, context):
        return []


class ImportContext(object):

    def __init__(self, pycore, folder):
        self.pycore = pycore
        self.folder = folder

########NEW FILE########
__FILENAME__ = module_imports
import functools
import rope.base.pynames
from rope.base import ast, utils
from rope.refactor.importutils import importinfo
from rope.refactor.importutils import actions


class ModuleImports(object):

    def __init__(self, pycore, pymodule, import_filter=None):
        self.pycore = pycore
        self.pymodule = pymodule
        self.separating_lines = 0
        self.filter = import_filter

    @property
    @utils.saveit
    def imports(self):
        finder = _GlobalImportFinder(self.pymodule, self.pycore)
        result = finder.find_import_statements()
        self.separating_lines = finder.get_separating_line_count()
        if self.filter is not None:
            for import_stmt in result:
                if not self.filter(import_stmt):
                    import_stmt.readonly = True
        return result

    def _get_unbound_names(self, defined_pyobject):
        visitor = _GlobalUnboundNameFinder(self.pymodule, defined_pyobject)
        ast.walk(self.pymodule.get_ast(), visitor)
        return visitor.unbound

    def remove_unused_imports(self):
        can_select = _OneTimeSelector(self._get_unbound_names(self.pymodule))
        visitor = actions.RemovingVisitor(
            self.pycore, self._current_folder(), can_select)
        for import_statement in self.imports:
            import_statement.accept(visitor)

    def get_used_imports(self, defined_pyobject):
        result = []
        can_select = _OneTimeSelector(self._get_unbound_names(defined_pyobject))
        visitor = actions.FilteringVisitor(
            self.pycore, self._current_folder(), can_select)
        for import_statement in self.imports:
            new_import = import_statement.accept(visitor)
            if new_import is not None and not new_import.is_empty():
                result.append(new_import)
        return result

    def get_changed_source(self):
        imports = self.imports
        after_removing = self._remove_imports(imports)
        imports = [stmt for stmt in imports
                   if not stmt.import_info.is_empty()]

        first_non_blank = self._first_non_blank_line(after_removing, 0)
        first_import = self._first_import_line() - 1
        result = []
        # Writing module docs
        result.extend(after_removing[first_non_blank:first_import])
        # Writing imports
        sorted_imports = sorted(imports, key = functools.cmp_to_key(self._compare_import_locations))
        for stmt in sorted_imports:
            start = self._get_import_location(stmt)
            if stmt != sorted_imports[0]:
                result.append('\n' * stmt.blank_lines)
            result.append(stmt.get_import_statement() + '\n')
        if sorted_imports and first_non_blank < len(after_removing):
            result.append('\n' * self.separating_lines)

        # Writing the body
        first_after_imports = self._first_non_blank_line(after_removing,
                                                         first_import)
        result.extend(after_removing[first_after_imports:])
        return ''.join(result)

    def _get_import_location(self, stmt):
        start = stmt.get_new_start()
        if start is None:
            start = stmt.get_old_location()[0]
        return start

    def _compare_import_locations(self, stmt1, stmt2):
        def get_location(stmt):
            if stmt.get_new_start() is not None:
                return stmt.get_new_start()
            else:
                return stmt.get_old_location()[0]
        return get_location(stmt1) - get_location(stmt2)

    def _remove_imports(self, imports):
        lines = self.pymodule.source_code.splitlines(True)
        after_removing = []
        last_index = 0
        for stmt in imports:
            start, end = stmt.get_old_location()
            after_removing.extend(lines[last_index:start - 1])
            last_index = end - 1
            for i in range(start, end):
                after_removing.append('')
        after_removing.extend(lines[last_index:])
        return after_removing

    def _first_non_blank_line(self, lines, lineno):
        result = lineno
        for line in lines[lineno:]:
            if line.strip() == '':
                result += 1
            else:
                break
        return result

    def add_import(self, import_info):
        visitor = actions.AddingVisitor(self.pycore, [import_info])
        for import_statement in self.imports:
            if import_statement.accept(visitor):
                break
        else:
            lineno = self._get_new_import_lineno()
            blanks = self._get_new_import_blanks()
            self.imports.append(importinfo.ImportStatement(
                                import_info, lineno, lineno,
                                blank_lines=blanks))

    def _get_new_import_blanks(self):
        return 0

    def _get_new_import_lineno(self):
        if self.imports:
            return self.imports[-1].end_line
        return 1

    def filter_names(self, can_select):
        visitor = actions.RemovingVisitor(
            self.pycore, self._current_folder(), can_select)
        for import_statement in self.imports:
            import_statement.accept(visitor)

    def expand_stars(self):
        can_select = _OneTimeSelector(self._get_unbound_names(self.pymodule))
        visitor = actions.ExpandStarsVisitor(
            self.pycore, self._current_folder(), can_select)
        for import_statement in self.imports:
            import_statement.accept(visitor)

    def remove_duplicates(self):
        added_imports = []
        for import_stmt in self.imports:
            visitor = actions.AddingVisitor(self.pycore,
                                            [import_stmt.import_info])
            for added_import in added_imports:
                if added_import.accept(visitor):
                    import_stmt.empty_import()
            else:
                added_imports.append(import_stmt)

    def get_relative_to_absolute_list(self):
        visitor = rope.refactor.importutils.actions.RelativeToAbsoluteVisitor(
            self.pycore, self._current_folder())
        for import_stmt in self.imports:
            if not import_stmt.readonly:
                import_stmt.accept(visitor)
        return visitor.to_be_absolute

    def get_self_import_fix_and_rename_list(self):
        visitor = rope.refactor.importutils.actions.SelfImportVisitor(
            self.pycore, self._current_folder(), self.pymodule.get_resource())
        for import_stmt in self.imports:
            if not import_stmt.readonly:
                import_stmt.accept(visitor)
        return visitor.to_be_fixed, visitor.to_be_renamed

    def _current_folder(self):
        return self.pymodule.get_resource().parent

    def sort_imports(self):
        # IDEA: Sort from import list
        visitor = actions.SortingVisitor(self.pycore, self._current_folder())
        for import_statement in self.imports:
            import_statement.accept(visitor)
        in_projects = sorted(visitor.in_project, key = self._compare_imports)
        third_party = sorted(visitor.third_party, key = self._compare_imports)
        standards = sorted(visitor.standard, key = self._compare_imports)
        future = sorted(visitor.future, key = self._compare_imports)
        blank_lines = 0
        last_index = self._first_import_line()
        last_index = self._move_imports(future, last_index, 0)
        last_index = self._move_imports(standards, last_index, 1)
        last_index = self._move_imports(third_party, last_index, 1)
        last_index = self._move_imports(in_projects, last_index, 1)
        self.separating_lines = 2

    def _first_import_line(self):
        nodes = self.pymodule.get_ast().body
        lineno = 0
        if self.pymodule.get_doc() is not None:
            lineno = 1
        if len(nodes) > lineno:
            lineno = self.pymodule.logical_lines.logical_line_in(
                nodes[lineno].lineno)[0]
        else:
            lineno = self.pymodule.lines.length()
        while lineno > 1:
            line = self.pymodule.lines.get_line(lineno - 1)
            if line.strip() == '':
                lineno -= 1
            else:
                break
        return lineno

    def _compare_imports(self, stmt):
        str = stmt.get_import_statement()
        return (str.startswith('from '), str)

    def _move_imports(self, imports, index, blank_lines):
        if imports:
            imports[0].move(index, blank_lines)
            index += 1
            if len(imports) > 1:
                for stmt in imports[1:]:
                    stmt.move(index)
                    index += 1
        return index

    def handle_long_imports(self, maxdots, maxlength):
        visitor = actions.LongImportVisitor(
            self._current_folder(), self.pycore, maxdots, maxlength)
        for import_statement in self.imports:
            if not import_statement.readonly:
                import_statement.accept(visitor)
        for import_info in visitor.new_imports:
            self.add_import(import_info)
        return visitor.to_be_renamed

    def remove_pyname(self, pyname):
        """Removes pyname when imported in ``from mod import x``"""
        visitor = actions.RemovePyNameVisitor(self.pycore, self.pymodule,
                                              pyname, self._current_folder())
        for import_stmt in self.imports:
            import_stmt.accept(visitor)


class _OneTimeSelector(object):

    def __init__(self, names):
        self.names = names
        self.selected_names = set()

    def __call__(self, imported_primary):
        if self._can_name_be_added(imported_primary):
            for name in self._get_dotted_tokens(imported_primary):
                self.selected_names.add(name)
            return True
        return False

    def _get_dotted_tokens(self, imported_primary):
        tokens = imported_primary.split('.')
        for i in range(len(tokens)):
            yield '.'.join(tokens[:i + 1])

    def _can_name_be_added(self, imported_primary):
        for name in self._get_dotted_tokens(imported_primary):
            if name in self.names and name not in self.selected_names:
                return True
        return False


class _UnboundNameFinder(object):

    def __init__(self, pyobject):
        self.pyobject = pyobject

    def _visit_child_scope(self, node):
        pyobject = self.pyobject.get_module().get_scope().\
                   get_inner_scope_for_line(node.lineno).pyobject
        visitor = _LocalUnboundNameFinder(pyobject, self)
        for child in ast.get_child_nodes(node):
            ast.walk(child, visitor)

    def _FunctionDef(self, node):
        self._visit_child_scope(node)

    def _ClassDef(self, node):
        self._visit_child_scope(node)

    def _Name(self, node):
        if self._get_root()._is_node_interesting(node) and \
           not self.is_bound(node.id):
            self.add_unbound(node.id)

    def _Attribute(self, node):
        result = []
        while isinstance(node, ast.Attribute):
            result.append(node.attr)
            node = node.value
        if isinstance(node, ast.Name):
            result.append(node.id)
            primary = '.'.join(reversed(result))
            if self._get_root()._is_node_interesting(node) and \
               not self.is_bound(primary):
                self.add_unbound(primary)
        else:
            ast.walk(node, self)

    def _get_root(self):
        pass

    def is_bound(self, name, propagated=False):
        pass

    def add_unbound(self, name):
        pass


class _GlobalUnboundNameFinder(_UnboundNameFinder):

    def __init__(self, pymodule, wanted_pyobject):
        super(_GlobalUnboundNameFinder, self).__init__(pymodule)
        self.unbound = set()
        self.names = set()
        for name, pyname in pymodule._get_structural_attributes().items():
            if not isinstance(pyname, (rope.base.pynames.ImportedName,
                                       rope.base.pynames.ImportedModule)):
                self.names.add(name)
        wanted_scope = wanted_pyobject.get_scope()
        self.start = wanted_scope.get_start()
        self.end = wanted_scope.get_end() + 1

    def _get_root(self):
        return self

    def is_bound(self, primary, propagated=False):
        name = primary.split('.')[0]
        if name in self.names:
            return True
        return False

    def add_unbound(self, name):
        names = name.split('.')
        for i in range(len(names)):
            self.unbound.add('.'.join(names[:i + 1]))

    def _is_node_interesting(self, node):
        return self.start <= node.lineno < self.end


class _LocalUnboundNameFinder(_UnboundNameFinder):

    def __init__(self, pyobject, parent):
        super(_LocalUnboundNameFinder, self).__init__(pyobject)
        self.parent = parent

    def _get_root(self):
        return self.parent._get_root()

    def is_bound(self, primary, propagated=False):
        name = primary.split('.')[0]
        if propagated:
            names = self.pyobject.get_scope().get_propagated_names()
        else:
            names = self.pyobject.get_scope().get_names()
        if name in names or self.parent.is_bound(name, propagated=True):
            return True
        return False

    def add_unbound(self, name):
        self.parent.add_unbound(name)


class _GlobalImportFinder(object):

    def __init__(self, pymodule, pycore):
        self.current_folder = None
        if pymodule.get_resource():
            self.current_folder = pymodule.get_resource().parent
            self.pymodule = pymodule
        self.pycore = pycore
        self.imports = []
        self.pymodule = pymodule
        self.lines = self.pymodule.lines

    def visit_import(self, node, end_line):
        start_line = node.lineno
        import_statement = importinfo.ImportStatement(
            importinfo.NormalImport(self._get_names(node.names)),
            start_line, end_line, self._get_text(start_line, end_line),
            blank_lines=self._count_empty_lines_before(start_line))
        self.imports.append(import_statement)

    def _count_empty_lines_before(self, lineno):
        result = 0
        for current in range(lineno - 1, 0, -1):
            line = self.lines.get_line(current)
            if line.strip() == '':
                result += 1
            else:
                break
        return result

    def _count_empty_lines_after(self, lineno):
        result = 0
        for current in range(lineno + 1, self.lines.length()):
            line = self.lines.get_line(current)
            if line.strip() == '':
                result += 1
            else:
                break
        return result

    def get_separating_line_count(self):
        if not self.imports:
            return 0
        return self._count_empty_lines_after(self.imports[-1].end_line - 1)

    def _get_text(self, start_line, end_line):
        result = []
        for index in range(start_line, end_line):
            result.append(self.lines.get_line(index))
        return '\n'.join(result)

    def visit_from(self, node, end_line):
        level = 0
        if node.level:
            level = node.level
        import_info = importinfo.FromImport(
            node.module or '', # see comment at rope.base.ast.walk
            level, self._get_names(node.names))
        start_line = node.lineno
        self.imports.append(importinfo.ImportStatement(
                            import_info, node.lineno, end_line,
                            self._get_text(start_line, end_line),
                            blank_lines=self._count_empty_lines_before(start_line)))

    def _get_names(self, alias_names):
        result = []
        for alias in alias_names:
            result.append((alias.name, alias.asname))
        return result

    def find_import_statements(self):
        nodes = self.pymodule.get_ast().body
        for index, node in enumerate(nodes):
            if isinstance(node, (ast.Import, ast.ImportFrom)):
                lines = self.pymodule.logical_lines
                end_line = lines.logical_line_in(node.lineno)[1] + 1
            if isinstance(node, ast.Import):
                self.visit_import(node, end_line)
            if isinstance(node, ast.ImportFrom):
                self.visit_from(node, end_line)
        return self.imports

########NEW FILE########
__FILENAME__ = inline
# Known Bugs when inlining a function/method
# The values passed to function are inlined using _inlined_variable.
# This may cause two problems, illustrated in the examples below
#
# def foo(var1):
#    var1 = var1*10
#    return var1
#
#  If a call to foo(20) is inlined, the result of inlined function is 20,
#  but it should be 200.
#
# def foo(var1):
#    var2 = var1*10
#    return var2
#
# 2- If a call to foo(10+10) is inlined the result of inlined function is 110
#  but it should be 200.

import re

import rope.base.exceptions
import rope.refactor.functionutils
from rope.base import (pynames, pyobjects, codeanalyze,
                       taskhandle, evaluate, worder, utils)
from rope.base.change import ChangeSet, ChangeContents
from rope.refactor import (occurrences, rename, sourceutils,
                           importutils, move, change_signature)

def unique_prefix():
    n = 0
    while True:
        yield "__" + str(n) + "__"
        n += 1

def create_inline(project, resource, offset):
    """Create a refactoring object for inlining

    Based on `resource` and `offset` it returns an instance of
    `InlineMethod`, `InlineVariable` or `InlineParameter`.

    """
    pycore = project.pycore
    pyname = _get_pyname(pycore, resource, offset)
    message = 'Inline refactoring should be performed on ' \
              'a method, local variable or parameter.'
    if pyname is None:
        raise rope.base.exceptions.RefactoringError(message)
    if isinstance(pyname, pynames.ImportedName):
        pyname = pyname._get_imported_pyname()
    if isinstance(pyname, pynames.AssignedName):
        return InlineVariable(project, resource, offset)
    if isinstance(pyname, pynames.ParameterName):
        return InlineParameter(project, resource, offset)
    if isinstance(pyname.get_object(), pyobjects.PyFunction):
        return InlineMethod(project, resource, offset)
    else:
        raise rope.base.exceptions.RefactoringError(message)


class _Inliner(object):

    def __init__(self, project, resource, offset):
        self.project = project
        self.pycore = project.pycore
        self.pyname = _get_pyname(self.pycore, resource, offset)
        range_finder = worder.Worder(resource.read())
        self.region = range_finder.get_primary_range(offset)
        self.name = range_finder.get_word_at(offset)
        self.offset = offset
        self.original = resource

    def get_changes(self, *args, **kwds):
        pass

    def get_kind(self):
        """Return either 'variable', 'method' or 'parameter'"""


class InlineMethod(_Inliner):

    def __init__(self, *args, **kwds):
        super(InlineMethod, self).__init__(*args, **kwds)
        self.pyfunction = self.pyname.get_object()
        self.pymodule = self.pyfunction.get_module()
        self.resource = self.pyfunction.get_module().get_resource()
        self.occurrence_finder = occurrences.create_finder(
            self.pycore, self.name, self.pyname)
        self.normal_generator = _DefinitionGenerator(self.project,
                                                     self.pyfunction)
        self._init_imports()

    def _init_imports(self):
        body = sourceutils.get_body(self.pyfunction)
        body, imports = move.moving_code_with_imports(
            self.pycore, self.resource, body)
        self.imports = imports
        self.others_generator = _DefinitionGenerator(
            self.project, self.pyfunction, body=body)

    def _get_scope_range(self):
        scope = self.pyfunction.get_scope()
        lines = self.pymodule.lines
        logicals = self.pymodule.logical_lines
        start_line = scope.get_start()
        if self.pyfunction.decorators:
            decorators = self.pyfunction.decorators
            if hasattr(decorators[0], 'lineno'):
                start_line = decorators[0].lineno
        start_offset = lines.get_line_start(start_line)
        end_offset = min(lines.get_line_end(scope.end) + 1,
                         len(self.pymodule.source_code))
        return (start_offset, end_offset)

    def get_changes(self, remove=True, only_current=False, resources=None,
                    task_handle=taskhandle.NullTaskHandle()):
        """Get the changes this refactoring makes

        If `remove` is `False` the definition will not be removed.  If
        `only_current` is `True`, the the current occurrence will be
        inlined, only.
        """
        changes = ChangeSet('Inline method <%s>' % self.name)
        if resources is None:
            resources = self.pycore.get_python_files()
        if only_current:
            resources = [self.original]
            if remove:
                resources.append(self.resource)
        job_set = task_handle.create_jobset('Collecting Changes',
                                            len(resources))
        for file in resources:
            job_set.started_job(file.path)
            if file == self.resource:
                changes.add_change(self._defining_file_changes(
                        changes, remove=remove, only_current=only_current))
            else:
                aim = None
                if only_current and self.original == file:
                    aim = self.offset
                handle = _InlineFunctionCallsForModuleHandle(
                    self.pycore, file, self.others_generator, aim)
                result = move.ModuleSkipRenamer(
                    self.occurrence_finder, file, handle).get_changed_module()
                if result is not None:
                    result = _add_imports(self.pycore, result,
                                          file, self.imports)
                    if remove:
                        result = _remove_from(self.pycore, self.pyname,
                                              result, file)
                    changes.add_change(ChangeContents(file, result))
            job_set.finished_job()
        return changes

    def _get_removed_range(self):
        scope = self.pyfunction.get_scope()
        lines = self.pymodule.lines
        logical = self.pymodule.logical_lines
        start_line = scope.get_start()
        start, end = self._get_scope_range()
        end_line = scope.get_end()
        for i in range(end_line + 1, lines.length()):
            if lines.get_line(i).strip() == '':
                end_line = i
            else:
                break
        end = min(lines.get_line_end(end_line) + 1,
                  len(self.pymodule.source_code))
        return (start, end)

    def _defining_file_changes(self, changes, remove, only_current):
        start_offset, end_offset = self._get_removed_range()
        aim = None
        if only_current:
            if self.resource == self.original:
                aim = self.offset
            else:
                # we don't want to change any of them
                aim = len(self.resource.read()) + 100
        handle = _InlineFunctionCallsForModuleHandle(
            self.pycore, self.resource,
            self.normal_generator, aim_offset=aim)
        replacement = None
        if remove:
            replacement = self._get_method_replacement()
        result = move.ModuleSkipRenamer(
            self.occurrence_finder, self.resource, handle, start_offset,
            end_offset, replacement).get_changed_module()
        return ChangeContents(self.resource, result)

    def _get_method_replacement(self):
        if self._is_the_last_method_of_a_class():
            indents = sourceutils.get_indents(
                self.pymodule.lines, self.pyfunction.get_scope().get_start())
            return ' ' * indents + 'pass\n'
        return ''

    def _is_the_last_method_of_a_class(self):
        pyclass = self.pyfunction.parent
        if not isinstance(pyclass, pyobjects.PyClass):
            return False
        class_start, class_end = sourceutils.get_body_region(pyclass)
        source = self.pymodule.source_code
        lines = self.pymodule.lines
        func_start, func_end = self._get_scope_range()
        if source[class_start:func_start].strip() == '' and \
           source[func_end:class_end].strip() == '':
            return True
        return False

    def get_kind(self):
        return 'method'


class InlineVariable(_Inliner):

    def __init__(self, *args, **kwds):
        super(InlineVariable, self).__init__(*args, **kwds)
        self.pymodule = self.pyname.get_definition_location()[0]
        self.resource = self.pymodule.get_resource()
        self._check_exceptional_conditions()
        self._init_imports()

    def _check_exceptional_conditions(self):
        if len(self.pyname.assignments) != 1:
            raise rope.base.exceptions.RefactoringError(
                'Local variable should be assigned once for inlining.')

    def get_changes(self, remove=True, only_current=False, resources=None,
                    task_handle=taskhandle.NullTaskHandle()):
        if resources is None:
            if rename._is_local(self.pyname):
                resources = [self.resource]
            else:
                resources = self.pycore.get_python_files()
        if only_current:
            resources = [self.original]
            if remove and self.original != self.resource:
                resources.append(self.resource)
        changes = ChangeSet('Inline variable <%s>' % self.name)
        jobset = task_handle.create_jobset('Calculating changes',
                                           len(resources))

        for resource in resources:
            jobset.started_job(resource.path)
            if resource == self.resource:
                source = self._change_main_module(remove, only_current)
                changes.add_change(ChangeContents(self.resource, source))
            else:
                result = self._change_module(resource, remove, only_current)
                if result is not None:
                    result = _add_imports(self.pycore, result,
                                          resource, self.imports)
                    changes.add_change(ChangeContents(resource, result))
            jobset.finished_job()
        return changes

    def _change_main_module(self, remove, only_current):
        region = None
        if only_current and self.original == self.resource:
            region = self.region
        return _inline_variable(self.pycore, self.pymodule, self.pyname,
                                self.name, remove=remove, region=region)

    def _init_imports(self):
        vardef = _getvardef(self.pymodule, self.pyname)
        self.imported, self.imports = move.moving_code_with_imports(
            self.pycore, self.resource, vardef)

    def _change_module(self, resource, remove, only_current):
        filters = [occurrences.NoImportsFilter(),
                   occurrences.PyNameFilter(self.pyname)]
        if only_current and resource == self.original:
            def check_aim(occurrence):
                start, end = occurrence.get_primary_range()
                if self.offset < start or end < self.offset:
                    return False
            filters.insert(0, check_aim)
        finder = occurrences.Finder(self.pycore, self.name, filters=filters)
        changed = rename.rename_in_module(
            finder, self.imported, resource=resource, replace_primary=True)
        if changed and remove:
            changed = _remove_from(self.pycore, self.pyname, changed, resource)
        return changed

    def get_kind(self):
        return 'variable'


class InlineParameter(_Inliner):

    def __init__(self, *args, **kwds):
        super(InlineParameter, self).__init__(*args, **kwds)
        resource, offset = self._function_location()
        index = self.pyname.index
        self.changers = [change_signature.ArgumentDefaultInliner(index)]
        self.signature = change_signature.ChangeSignature(self.project,
                                                          resource, offset)

    def _function_location(self):
        pymodule, lineno = self.pyname.get_definition_location()
        resource = pymodule.get_resource()
        start = pymodule.lines.get_line_start(lineno)
        word_finder = worder.Worder(pymodule.source_code)
        offset = word_finder.find_function_offset(start)
        return resource, offset

    def get_changes(self, **kwds):
        """Get the changes needed by this refactoring

        See `rope.refactor.change_signature.ChangeSignature.get_changes()`
        for arguments.
        """
        return self.signature.get_changes(self.changers, **kwds)

    def get_kind(self):
        return 'parameter'


def _join_lines(lines):
    definition_lines = []
    for unchanged_line in lines:
        line = unchanged_line.strip()
        if line.endswith('\\'):
            line = line[:-1].strip()
        definition_lines.append(line)
    joined = ' '.join(definition_lines)
    return joined


class _DefinitionGenerator(object):
    unique_prefix = unique_prefix()
    def __init__(self, project, pyfunction, body=None):
        self.pycore = project.pycore
        self.pyfunction = pyfunction
        self.pymodule = pyfunction.get_module()
        self.resource = self.pymodule.get_resource()
        self.definition_info = self._get_definition_info()
        self.definition_params = self._get_definition_params()
        self._calculated_definitions = {}
        if body is not None:
            self.body = body
        else:
            self.body = sourceutils.get_body(self.pyfunction)

    def _get_definition_info(self):
        return rope.refactor.functionutils.DefinitionInfo.read(self.pyfunction)

    def _get_definition_params(self):
        definition_info = self.definition_info
        paramdict = dict([pair for pair in definition_info.args_with_defaults])
        if definition_info.args_arg is not None or \
           definition_info.keywords_arg is not None:
            raise rope.base.exceptions.RefactoringError(
                'Cannot inline functions with list and keyword arguements.')
        if self.pyfunction.get_kind() == 'classmethod':
            paramdict[definition_info.args_with_defaults[0][0]] = \
                self.pyfunction.parent.get_name()
        return paramdict

    def get_function_name(self):
        return self.pyfunction.get_name()

    def get_definition(self, primary, pyname, call, host_vars=[],returns=False):
        # caching already calculated definitions
        return self._calculate_definition(primary, pyname, call,
                           host_vars, returns)

    def _calculate_header(self, primary, pyname, call):
        # A header is created which initializes parameters
        # to the values passed to the function.
        call_info = rope.refactor.functionutils.CallInfo.read(
            primary, pyname, self.definition_info, call)
        paramdict = self.definition_params
        mapping = rope.refactor.functionutils.ArgumentMapping(
            self.definition_info, call_info)
        for param_name, value in mapping.param_dict.items():
            paramdict[param_name] = value
        header = ''
        to_be_inlined = []
        mod = self.pycore.get_string_module(self.body)
        all_names = mod.get_scope().get_names()
        assigned_names = [name for name in all_names if
            isinstance(all_names[name], rope.base.pynamesdef.AssignedName)]
        for name, value in paramdict.items():
            if name != value and value is not None:
                header += name + ' = ' + value.replace('\n', ' ') + '\n'
                to_be_inlined.append(name)
        return header, to_be_inlined

    def _calculate_definition(self, primary, pyname, call, host_vars, returns):

        header, to_be_inlined = self._calculate_header(primary, pyname, call)

        source = header + self.body
        mod = self.pycore.get_string_module(source)
        name_dict = mod.get_scope().get_names()
        all_names =   [x for x in  name_dict if
            not isinstance(name_dict[x], rope.base.builtins.BuiltinName)]

        # If there is a name conflict, all variable names
        # inside the inlined function are renamed
        if len(set(all_names).intersection(set(host_vars))) > 0:

            prefix = _DefinitionGenerator.unique_prefix.next()
            guest = self.pycore.get_string_module(source, self.resource)

            to_be_inlined = [prefix+item for item in to_be_inlined]
            for item in all_names:
                pyname = guest[item]
                occurrence_finder = occurrences.create_finder(
                                        self.pycore, item, pyname)
                source = rename.rename_in_module(occurrence_finder,
                                         prefix+item, pymodule=guest)
                guest = self.pycore.get_string_module(source, self.resource)

        #parameters not reassigned inside the functions are now inlined.
        for name in to_be_inlined:
            pymodule = self.pycore.get_string_module(source, self.resource)
            pyname = pymodule[name]
            source = _inline_variable(self.pycore, pymodule, pyname, name)

        return self._replace_returns_with(source, returns)

    def _replace_returns_with(self, source, returns):
        result = []
        returned = None
        last_changed = 0
        for match in _DefinitionGenerator._get_return_pattern().finditer(source):
            for key, value in match.groupdict().items():
                if value and key == 'return':
                    result.append(source[last_changed:match.start('return')])
                    if returns:
                        self._check_nothing_after_return(source,
                                                         match.end('return'))
                        returned = _join_lines(
                            source[match.end('return'): len(source)].splitlines())
                        last_changed = len(source)
                    else:
                        current = match.end('return')
                        while current < len(source) and source[current] in ' \t':
                            current += 1
                        last_changed = current
                        if current == len(source) or source[current] == '\n':
                            result.append('pass')
        result.append(source[last_changed:])
        return ''.join(result), returned

    def _check_nothing_after_return(self, source, offset):
        lines = codeanalyze.SourceLinesAdapter(source)
        lineno = lines.get_line_number(offset)
        logical_lines = codeanalyze.LogicalLineFinder(lines)
        lineno = logical_lines.logical_line_in(lineno)[1]
        if source[lines.get_line_end(lineno):len(source)].strip() != '':
            raise rope.base.exceptions.RefactoringError(
                'Cannot inline functions with statements after return statement.')

    @classmethod
    def _get_return_pattern(cls):
        if not hasattr(cls, '_return_pattern'):
            def named_pattern(name, list_):
                return "(?P<%s>" % name + "|".join(list_) + ")"
            comment_pattern = named_pattern('comment', [r'#[^\n]*'])
            string_pattern = named_pattern('string',
                                           [codeanalyze.get_string_pattern()])
            return_pattern = r'\b(?P<return>return)\b'
            cls._return_pattern = re.compile(comment_pattern + "|" +
                                             string_pattern + "|" +
                                             return_pattern)
        return cls._return_pattern


class _InlineFunctionCallsForModuleHandle(object):

    def __init__(self, pycore, resource,
                 definition_generator, aim_offset=None):
        """Inlines occurrences

        If `aim` is not `None` only the occurrences that intersect
        `aim` offset will be inlined.

        """
        self.pycore = pycore
        self.generator = definition_generator
        self.resource = resource
        self.aim = aim_offset

    def occurred_inside_skip(self, change_collector, occurrence):
        if not occurrence.is_defined():
            raise rope.base.exceptions.RefactoringError(
                'Cannot inline functions that reference themselves')

    def occurred_outside_skip(self, change_collector, occurrence):
        start, end = occurrence.get_primary_range()
        # we remove out of date imports later
        if occurrence.is_in_import_statement():
            return
        # the function is referenced outside an import statement
        if not occurrence.is_called():
            raise rope.base.exceptions.RefactoringError(
                'Reference to inlining function other than function call'
                ' in <file: %s, offset: %d>' % (self.resource.path, start))
        if self.aim is not None and (self.aim < start or self.aim > end):
            return
        end_parens = self._find_end_parens(self.source, end - 1)
        lineno = self.lines.get_line_number(start)
        start_line, end_line = self.pymodule.logical_lines.\
                               logical_line_in(lineno)
        line_start = self.lines.get_line_start(start_line)
        line_end = self.lines.get_line_end(end_line)


        returns = self.source[line_start:start].strip() != '' or \
                  self.source[end_parens:line_end].strip() != ''
        indents = sourceutils.get_indents(self.lines, start_line)
        primary, pyname = occurrence.get_primary_and_pyname()

        host = self.pycore.resource_to_pyobject(self.resource)
        scope = host.scope.get_inner_scope_for_line(lineno)
        definition, returned = self.generator.get_definition(
            primary, pyname, self.source[start:end_parens], scope.get_names(), returns=returns)

        end = min(line_end + 1, len(self.source))
        change_collector.add_change(line_start, end,
               sourceutils.fix_indentation(definition, indents))
        if returns:
            name = returned
            if name is None:
                name = 'None'
            change_collector.add_change(
                line_end, end, self.source[line_start:start] + name +
                self.source[end_parens:end])

    def _find_end_parens(self, source, offset):
        finder = worder.Worder(source)
        return finder.get_word_parens_range(offset)[1]

    @property
    @utils.saveit
    def pymodule(self):
        return self.pycore.resource_to_pyobject(self.resource)

    @property
    @utils.saveit
    def source(self):
        if self.resource is not None:
            return self.resource.read()
        else:
            return self.pymodule.source_code

    @property
    @utils.saveit
    def lines(self):
        return self.pymodule.lines


def _inline_variable(pycore, pymodule, pyname, name,
                     remove=True, region=None):
    definition = _getvardef(pymodule, pyname)
    start, end = _assigned_lineno(pymodule, pyname)

    occurrence_finder = occurrences.create_finder(pycore, name, pyname)
    changed_source = rename.rename_in_module(
        occurrence_finder, definition, pymodule=pymodule,
        replace_primary=True, writes=False, region=region)
    if changed_source is None:
        changed_source = pymodule.source_code
    if remove:
        lines = codeanalyze.SourceLinesAdapter(changed_source)
        source = changed_source[:lines.get_line_start(start)] + \
                 changed_source[lines.get_line_end(end) + 1:]
    else:
        source = changed_source
    return source

def _getvardef(pymodule, pyname):
    assignment = pyname.assignments[0]
    lines = pymodule.lines
    start, end = _assigned_lineno(pymodule, pyname)
    definition_with_assignment = _join_lines(
        [lines.get_line(n) for n in range(start, end + 1)])
    if assignment.levels:
        raise rope.base.exceptions.RefactoringError(
            'Cannot inline tuple assignments.')
    definition = definition_with_assignment[definition_with_assignment.\
                                            index('=') + 1:].strip()
    return definition

def _assigned_lineno(pymodule, pyname):
    definition_line = pyname.assignments[0].ast_node.lineno
    return pymodule.logical_lines.logical_line_in(definition_line)

def _add_imports(pycore, source, resource, imports):
    if not imports:
        return source
    pymodule = pycore.get_string_module(source, resource)
    module_import = importutils.get_module_imports(pycore, pymodule)
    for import_info in imports:
        module_import.add_import(import_info)
    source = module_import.get_changed_source()
    pymodule = pycore.get_string_module(source, resource)
    import_tools = importutils.ImportTools(pycore)
    return import_tools.organize_imports(pymodule, unused=False, sort=False)

def _get_pyname(pycore, resource, offset):
    pymodule = pycore.resource_to_pyobject(resource)
    pyname = evaluate.eval_location(pymodule, offset)
    if isinstance(pyname, pynames.ImportedName):
        pyname = pyname._get_imported_pyname()
    return pyname

def _remove_from(pycore, pyname, source, resource):
    pymodule = pycore.get_string_module(source, resource)
    module_import = importutils.get_module_imports(pycore, pymodule)
    module_import.remove_pyname(pyname)
    return module_import.get_changed_source()

########NEW FILE########
__FILENAME__ = introduce_factory
import rope.base.exceptions
import rope.base.pyobjects
from rope.base import taskhandle, evaluate
from rope.base.change import (ChangeSet, ChangeContents)
from rope.refactor import rename, occurrences, sourceutils, importutils


class IntroduceFactory(object):

    def __init__(self, project, resource, offset):
        self.pycore = project.pycore
        self.offset = offset

        this_pymodule = self.pycore.resource_to_pyobject(resource)
        self.old_pyname = evaluate.eval_location(this_pymodule, offset)
        if self.old_pyname is None or not isinstance(self.old_pyname.get_object(),
                                                     rope.base.pyobjects.PyClass):
            raise rope.base.exceptions.RefactoringError(
                'Introduce factory should be performed on a class.')
        self.old_name = self.old_pyname.get_object().get_name()
        self.pymodule = self.old_pyname.get_object().get_module()
        self.resource = self.pymodule.get_resource()

    def get_changes(self, factory_name, global_factory=False, resources=None,
                    task_handle=taskhandle.NullTaskHandle()):
        """Get the changes this refactoring makes

        `factory_name` indicates the name of the factory function to
        be added.  If `global_factory` is `True` the factory will be
        global otherwise a static method is added to the class.

        `resources` can be a list of `rope.base.resource.File`\s that
        this refactoring should be applied on; if `None` all python
        files in the project are searched.

        """
        if resources is None:
            resources = self.pycore.get_python_files()
        changes = ChangeSet('Introduce factory method <%s>' % factory_name)
        job_set = task_handle.create_jobset('Collecting Changes',
                                            len(resources))
        self._change_module(resources, changes, factory_name,
                            global_factory, job_set)
        return changes

    def get_name(self):
        """Return the name of the class"""
        return self.old_name

    def _change_module(self, resources, changes,
                       factory_name, global_, job_set):
        if global_:
            replacement = '__rope_factory_%s_' % factory_name
        else:
            replacement = self._new_function_name(factory_name, global_)

        for file_ in resources:
            job_set.started_job(file_.path)
            if file_ == self.resource:
                self._change_resource(changes, factory_name, global_)
                job_set.finished_job()
                continue
            changed_code = self._rename_occurrences(file_, replacement,
                                                    global_)
            if changed_code is not None:
                if global_:
                    new_pymodule = self.pycore.get_string_module(changed_code,
                                                                 self.resource)
                    modname = self.pycore.modname(self.resource)
                    changed_code, imported = importutils.add_import(
                        self.pycore, new_pymodule, modname, factory_name)
                    changed_code = changed_code.replace(replacement, imported)
                changes.add_change(ChangeContents(file_, changed_code))
            job_set.finished_job()

    def _change_resource(self, changes, factory_name, global_):
        class_scope = self.old_pyname.get_object().get_scope()
        source_code = self._rename_occurrences(
            self.resource, self._new_function_name(factory_name,
                                                   global_), global_)
        if source_code is None:
            source_code = self.pymodule.source_code
        else:
            self.pymodule = self.pycore.get_string_module(
                source_code, resource=self.resource)
        lines = self.pymodule.lines
        start = self._get_insertion_offset(class_scope, lines)
        result = source_code[:start]
        result += self._get_factory_method(lines, class_scope,
                                           factory_name, global_)
        result += source_code[start:]
        changes.add_change(ChangeContents(self.resource, result))

    def _get_insertion_offset(self, class_scope, lines):
        start_line = class_scope.get_end()
        if class_scope.get_scopes():
            start_line = class_scope.get_scopes()[-1].get_end()
        start = lines.get_line_end(start_line) + 1
        return start

    def _get_factory_method(self, lines, class_scope,
                            factory_name, global_):
        unit_indents = ' ' * sourceutils.get_indent(self.pycore)
        if global_:
            if self._get_scope_indents(lines, class_scope) > 0:
                raise rope.base.exceptions.RefactoringError(
                    'Cannot make global factory method for nested classes.')
            return ('\ndef %s(*args, **kwds):\n%sreturn %s(*args, **kwds)\n' %
                    (factory_name, unit_indents, self.old_name))
        unindented_factory = \
            ('@staticmethod\ndef %s(*args, **kwds):\n' % factory_name +
             '%sreturn %s(*args, **kwds)\n' % (unit_indents, self.old_name))
        indents = self._get_scope_indents(lines, class_scope) + \
                  sourceutils.get_indent(self.pycore)
        return '\n' + sourceutils.indent_lines(unindented_factory, indents)

    def _get_scope_indents(self, lines, scope):
        return sourceutils.get_indents(lines, scope.get_start())

    def _new_function_name(self, factory_name, global_):
        if global_:
            return factory_name
        else:
            return self.old_name + '.' + factory_name

    def _rename_occurrences(self, file_, changed_name, global_factory):
        finder = occurrences.create_finder(self.pycore, self.old_name,
                                           self.old_pyname, only_calls=True)
        result = rename.rename_in_module(finder, changed_name, resource=file_,
                                         replace_primary=global_factory)
        return result

IntroduceFactoryRefactoring = IntroduceFactory

########NEW FILE########
__FILENAME__ = introduce_parameter
import rope.base.change
from rope.base import exceptions, evaluate, worder, codeanalyze
from rope.refactor import functionutils, sourceutils, occurrences


class IntroduceParameter(object):
    """Introduce parameter refactoring

    This refactoring adds a new parameter to a function and replaces
    references to an expression in it with the new parameter.

    The parameter finding part is different from finding similar
    pieces in extract refactorings.  In this refactoring parameters
    are found based on the object they reference to.  For instance
    in::

      class A(object):
          var = None

      class B(object):
          a = A()

      b = B()
      a = b.a

      def f(a):
          x = b.a.var + a.var

    using this refactoring on ``a.var`` with ``p`` as the new
    parameter name, will result in::

      def f(p=a.var):
          x = p + p

    """

    def __init__(self, project, resource, offset):
        self.pycore = project.pycore
        self.resource = resource
        self.offset = offset
        self.pymodule = self.pycore.resource_to_pyobject(self.resource)
        scope = self.pymodule.get_scope().get_inner_scope_for_offset(offset)
        if scope.get_kind() != 'Function':
            raise exceptions.RefactoringError(
                'Introduce parameter should be performed inside functions')
        self.pyfunction = scope.pyobject
        self.name, self.pyname = self._get_name_and_pyname()
        if self.pyname is None:
            raise exceptions.RefactoringError(
                'Cannot find the definition of <%s>' % self.name)

    def _get_primary(self):
        word_finder = worder.Worder(self.resource.read())
        return word_finder.get_primary_at(self.offset)

    def _get_name_and_pyname(self):
        return (worder.get_name_at(self.resource, self.offset),
                evaluate.eval_location(self.pymodule, self.offset))

    def get_changes(self, new_parameter):
        definition_info = functionutils.DefinitionInfo.read(self.pyfunction)
        definition_info.args_with_defaults.append((new_parameter,
                                                   self._get_primary()))
        collector = codeanalyze.ChangeCollector(self.resource.read())
        header_start, header_end = self._get_header_offsets()
        body_start, body_end = sourceutils.get_body_region(self.pyfunction)
        collector.add_change(header_start, header_end,
                             definition_info.to_string())
        self._change_function_occurances(collector, body_start,
                                         body_end, new_parameter)
        changes = rope.base.change.ChangeSet('Introduce parameter <%s>' %
                                             new_parameter)
        change = rope.base.change.ChangeContents(self.resource,
                                                 collector.get_changed())
        changes.add_change(change)
        return changes

    def _get_header_offsets(self):
        lines = self.pymodule.lines
        start_line = self.pyfunction.get_scope().get_start()
        end_line = self.pymodule.logical_lines.\
                   logical_line_in(start_line)[1]
        start = lines.get_line_start(start_line)
        end = lines.get_line_end(end_line)
        start = self.pymodule.source_code.find('def', start) + 4
        end = self.pymodule.source_code.rfind(':', start, end)
        return start, end

    def _change_function_occurances(self, collector, function_start,
                                    function_end, new_name):
        finder = occurrences.create_finder(self.pycore, self.name, self.pyname)
        for occurrence in finder.find_occurrences(resource=self.resource):
            start, end = occurrence.get_primary_range()
            if function_start <= start < function_end:
                collector.add_change(start, end, new_name)

########NEW FILE########
__FILENAME__ = localtofield
from rope.base import pynames, evaluate, exceptions, worder
from rope.refactor.rename import Rename


class LocalToField(object):

    def __init__(self, project, resource, offset):
        self.project = project
        self.pycore = project.pycore
        self.resource = resource
        self.offset = offset

    def get_changes(self):
        name = worder.get_name_at(self.resource, self.offset)
        this_pymodule = self.pycore.resource_to_pyobject(self.resource)
        pyname = evaluate.eval_location(this_pymodule, self.offset)
        if not self._is_a_method_local(pyname):
            raise exceptions.RefactoringError(
                'Convert local variable to field should be performed on \n'
                'a local variable of a method.')

        pymodule, lineno = pyname.get_definition_location()
        function_scope = pymodule.get_scope().get_inner_scope_for_line(lineno)
        # Not checking redefinition
        #self._check_redefinition(name, function_scope)

        new_name = self._get_field_name(function_scope.pyobject, name)
        changes = Rename(self.project, self.resource, self.offset).\
                  get_changes(new_name, resources=[self.resource])
        return changes

    def _check_redefinition(self, name, function_scope):
        class_scope = function_scope.parent
        if name in class_scope.pyobject:
            raise exceptions.RefactoringError(
                'The field %s already exists' % name)

    def _get_field_name(self, pyfunction, name):
        self_name = pyfunction.get_param_names()[0]
        new_name = self_name + '.' + name
        return new_name

    def _is_a_method_local(self, pyname):
        pymodule, lineno = pyname.get_definition_location()
        holding_scope = pymodule.get_scope().get_inner_scope_for_line(lineno)
        parent = holding_scope.parent
        return isinstance(pyname, pynames.AssignedName) and \
               pyname in list(holding_scope.get_names().values()) and \
               holding_scope.get_kind() == 'Function' and \
               parent is not None and parent.get_kind() == 'Class'

########NEW FILE########
__FILENAME__ = method_object
import warnings

from rope.base import pyobjects, exceptions, change, evaluate, codeanalyze
from rope.refactor import sourceutils, occurrences, rename


class MethodObject(object):

    def __init__(self, project, resource, offset):
        self.pycore = project.pycore
        this_pymodule = self.pycore.resource_to_pyobject(resource)
        pyname = evaluate.eval_location(this_pymodule, offset)
        if pyname is None or not isinstance(pyname.get_object(),
                                            pyobjects.PyFunction):
            raise exceptions.RefactoringError(
                'Replace method with method object refactoring should be '
                'performed on a function.')
        self.pyfunction = pyname.get_object()
        self.pymodule = self.pyfunction.get_module()
        self.resource = self.pymodule.get_resource()

    def get_new_class(self, name):
        body = sourceutils.fix_indentation(
            self._get_body(), sourceutils.get_indent(self.pycore) * 2)
        return 'class %s(object):\n\n%s%sdef __call__(self):\n%s' % \
               (name, self._get_init(),
                ' ' * sourceutils.get_indent(self.pycore), body)

    def get_changes(self, classname=None, new_class_name=None):
        if new_class_name is not None:
            warnings.warn(
                'new_class_name parameter is deprecated; use classname',
                DeprecationWarning, stacklevel=2)
            classname = new_class_name
        collector = codeanalyze.ChangeCollector(self.pymodule.source_code)
        start, end = sourceutils.get_body_region(self.pyfunction)
        indents = sourceutils.get_indents(
            self.pymodule.lines, self.pyfunction.get_scope().get_start()) + \
            sourceutils.get_indent(self.pycore)
        new_contents = ' ' * indents + 'return %s(%s)()\n' % \
                       (classname, ', '.join(self._get_parameter_names()))
        collector.add_change(start, end, new_contents)
        insertion = self._get_class_insertion_point()
        collector.add_change(insertion, insertion,
                             '\n\n' + self.get_new_class(classname))
        changes = change.ChangeSet('Replace method with method object refactoring')
        changes.add_change(change.ChangeContents(self.resource,
                                                 collector.get_changed()))
        return changes

    def _get_class_insertion_point(self):
        current = self.pyfunction
        while current.parent != self.pymodule:
            current = current.parent
        end = self.pymodule.lines.get_line_end(current.get_scope().get_end())
        return min(end + 1, len(self.pymodule.source_code))

    def _get_body(self):
        body = sourceutils.get_body(self.pyfunction)
        for param in self._get_parameter_names():
            body = param + ' = None\n' + body
            pymod = self.pycore.get_string_module(body, self.resource)
            pyname = pymod[param]
            finder = occurrences.create_finder(self.pycore, param, pyname)
            result = rename.rename_in_module(finder, 'self.' + param,
                                             pymodule=pymod)
            body = result[result.index('\n') + 1:]
        return body

    def _get_init(self):
        params = self._get_parameter_names()
        indents = ' ' * sourceutils.get_indent(self.pycore)
        if not params:
            return ''
        header = indents + 'def __init__(self'
        body = ''
        for arg in params:
            new_name = arg
            if arg == 'self':
                new_name = 'host'
            header += ', %s' % new_name
            body += indents * 2 + 'self.%s = %s\n' % (arg, new_name)
        header += '):'
        return '%s\n%s\n' % (header, body)

    def _get_parameter_names(self):
        return self.pyfunction.get_param_names()

########NEW FILE########
__FILENAME__ = move
"""A module containing classes for move refactoring

`create_move()` is a factory for creating move refactoring objects
based on inputs.

"""
from rope.base import pyobjects, codeanalyze, exceptions, pynames, taskhandle, evaluate, worder
from rope.base.change import ChangeSet, ChangeContents, MoveResource
from rope.refactor import importutils, rename, occurrences, sourceutils, functionutils


def create_move(project, resource, offset=None):
    """A factory for creating Move objects

    Based on `resource` and `offset`, return one of `MoveModule`,
    `MoveGlobal` or `MoveMethod` for performing move refactoring.

    """
    if offset is None:
        return MoveModule(project, resource)
    this_pymodule = project.pycore.resource_to_pyobject(resource)
    pyname = evaluate.eval_location(this_pymodule, offset)
    if pyname is None:
        raise exceptions.RefactoringError(
            'Move only works on classes, functions, modules and methods.')
    pyobject = pyname.get_object()
    if isinstance(pyobject, pyobjects.PyModule) or \
       isinstance(pyobject, pyobjects.PyPackage):
        return MoveModule(project, pyobject.get_resource())
    if isinstance(pyobject, pyobjects.PyFunction) and \
       isinstance(pyobject.parent, pyobjects.PyClass):
        return MoveMethod(project, resource, offset)
    if isinstance(pyobject, pyobjects.PyDefinedObject) and \
       isinstance(pyobject.parent, pyobjects.PyModule):
        return MoveGlobal(project, resource, offset)
    raise exceptions.RefactoringError(
        'Move only works on global classes/functions, modules and methods.')


class MoveMethod(object):
    """For moving methods

    It makes a new method in the destination class and changes
    the body of the old method to call the new method.  You can
    inline the old method to change all of its occurrences.

    """

    def __init__(self, project, resource, offset):
        self.project = project
        self.pycore = project.pycore
        this_pymodule = self.pycore.resource_to_pyobject(resource)
        pyname = evaluate.eval_location(this_pymodule, offset)
        self.method_name = worder.get_name_at(resource, offset)
        self.pyfunction = pyname.get_object()
        if self.pyfunction.get_kind() != 'method':
            raise exceptions.RefactoringError('Only normal methods'
                                              ' can be moved.')

    def get_changes(self, dest_attr, new_name=None, resources=None,
                    task_handle=taskhandle.NullTaskHandle()):
        """Return the changes needed for this refactoring

        Parameters:

        - `dest_attr`: the name of the destination attribute
        - `new_name`: the name of the new method; if `None` uses
          the old name
        - `resources` can be a list of `rope.base.resources.File`\s to
          apply this refactoring on.  If `None`, the restructuring
          will be applied to all python files.

        """
        changes = ChangeSet('Moving method <%s>' % self.method_name)
        if resources is None:
            resources = self.pycore.get_python_files()
        if new_name is None:
            new_name = self.get_method_name()
        resource1, start1, end1, new_content1 = \
            self._get_changes_made_by_old_class(dest_attr, new_name)
        collector1 = codeanalyze.ChangeCollector(resource1.read())
        collector1.add_change(start1, end1, new_content1)

        resource2, start2, end2, new_content2 = \
            self._get_changes_made_by_new_class(dest_attr, new_name)
        if resource1 == resource2:
            collector1.add_change(start2, end2, new_content2)
        else:
            collector2 = codeanalyze.ChangeCollector(resource2.read())
            collector2.add_change(start2, end2, new_content2)
            result = collector2.get_changed()
            import_tools = importutils.ImportTools(self.pycore)
            new_imports = self._get_used_imports(import_tools)
            if new_imports:
                goal_pymodule = self.pycore.get_string_module(result,
                                                              resource2)
                result = _add_imports_to_module(
                    import_tools, goal_pymodule, new_imports)
            if resource2 in resources:
                changes.add_change(ChangeContents(resource2, result))

        if resource1 in resources:
            changes.add_change(ChangeContents(resource1,
                                              collector1.get_changed()))
        return changes

    def get_method_name(self):
        return self.method_name

    def _get_used_imports(self, import_tools):
        return importutils.get_imports(self.pycore, self.pyfunction)

    def _get_changes_made_by_old_class(self, dest_attr, new_name):
        pymodule = self.pyfunction.get_module()
        indents = self._get_scope_indents(self.pyfunction)
        body = 'return self.%s.%s(%s)\n' % (dest_attr, new_name,
                                            self._get_passed_arguments_string())
        region = sourceutils.get_body_region(self.pyfunction)
        return (pymodule.get_resource(), region[0], region[1],
                sourceutils.fix_indentation(body, indents))

    def _get_scope_indents(self, pyobject):
        pymodule = pyobject.get_module()
        return sourceutils.get_indents(
            pymodule.lines, pyobject.get_scope().get_start()) + \
            sourceutils.get_indent(self.pycore)

    def _get_changes_made_by_new_class(self, dest_attr, new_name):
        old_pyclass = self.pyfunction.parent
        if dest_attr not in old_pyclass:
            raise exceptions.RefactoringError(
                'Destination attribute <%s> not found' % dest_attr)
        pyclass = old_pyclass[dest_attr].get_object().get_type()
        if not isinstance(pyclass, pyobjects.PyClass):
            raise exceptions.RefactoringError(
                'Unknown class type for attribute <%s>' % dest_attr)
        pymodule = pyclass.get_module()
        resource = pyclass.get_module().get_resource()
        start, end = sourceutils.get_body_region(pyclass)
        pre_blanks = '\n'
        if pymodule.source_code[start:end].strip() != 'pass':
            pre_blanks = '\n\n'
            start = end
        indents = self._get_scope_indents(pyclass)
        body = pre_blanks + sourceutils.fix_indentation(
            self.get_new_method(new_name), indents)
        return resource, start, end, body

    def get_new_method(self, name):
        return '%s\n%s' % (
            self._get_new_header(name),
            sourceutils.fix_indentation(self._get_body(),
                                        sourceutils.get_indent(self.pycore)))

    def _get_unchanged_body(self):
        return sourceutils.get_body(self.pyfunction)

    def _get_body(self, host='host'):
        self_name = self._get_self_name()
        body = self_name + ' = None\n' + self._get_unchanged_body()
        pymodule = self.pycore.get_string_module(body)
        finder = occurrences.create_finder(
            self.pycore, self_name, pymodule[self_name])
        result = rename.rename_in_module(finder, host, pymodule=pymodule)
        if result is None:
            result = body
        return result[result.index('\n') + 1:]

    def _get_self_name(self):
        return self.pyfunction.get_param_names()[0]

    def _get_new_header(self, name):
        header = 'def %s(self' % name
        if self._is_host_used():
            header += ', host'
        definition_info = functionutils.DefinitionInfo.read(self.pyfunction)
        others = definition_info.arguments_to_string(1)
        if others:
            header += ', ' + others
        return header + '):'

    def _get_passed_arguments_string(self):
        result = ''
        if self._is_host_used():
            result = 'self'
        definition_info = functionutils.DefinitionInfo.read(self.pyfunction)
        others = definition_info.arguments_to_string(1)
        if others:
            if result:
                result += ', '
            result += others
        return result

    def _is_host_used(self):
        return self._get_body('__old_self') != self._get_unchanged_body()


class MoveGlobal(object):
    """For moving global function and classes"""

    def __init__(self, project, resource, offset):
        self.pycore = project.pycore
        this_pymodule = self.pycore.resource_to_pyobject(resource)
        self.old_pyname = evaluate.eval_location(this_pymodule, offset)
        self.old_name = self.old_pyname.get_object().get_name()
        pymodule = self.old_pyname.get_object().get_module()
        self.source = pymodule.get_resource()
        self.tools = _MoveTools(self.pycore, self.source,
                                self.old_pyname, self.old_name)
        self.import_tools = self.tools.import_tools
        self._check_exceptional_conditions()

    def _check_exceptional_conditions(self):
        if self.old_pyname is None or \
           not isinstance(self.old_pyname.get_object(), pyobjects.PyDefinedObject):
            raise exceptions.RefactoringError(
                'Move refactoring should be performed on a class/function.')
        moving_pyobject = self.old_pyname.get_object()
        if not self._is_global(moving_pyobject):
            raise exceptions.RefactoringError(
                'Move refactoring should be performed on a global class/function.')

    def _is_global(self, pyobject):
        return pyobject.get_scope().parent == pyobject.get_module().get_scope()

    def get_changes(self, dest, resources=None,
                    task_handle=taskhandle.NullTaskHandle()):
        if resources is None:
            resources = self.pycore.get_python_files()
        if dest is None or not dest.exists():
            raise exceptions.RefactoringError(
                'Move destination does not exist.')
        if dest.is_folder() and dest.has_child('__init__.py'):
            dest = dest.get_child('__init__.py')
        if dest.is_folder():
            raise exceptions.RefactoringError(
                'Move destination for non-modules should not be folders.')
        if self.source == dest:
            raise exceptions.RefactoringError(
                'Moving global elements to the same module.')
        return self._calculate_changes(dest, resources, task_handle)

    def _calculate_changes(self, dest, resources, task_handle):
        changes = ChangeSet('Moving global <%s>' % self.old_name)
        job_set = task_handle.create_jobset('Collecting Changes',
                                            len(resources))
        for file_ in resources:
            job_set.started_job(file_.path)
            if file_ == self.source:
                changes.add_change(self._source_module_changes(dest))
            elif file_ == dest:
                changes.add_change(self._dest_module_changes(dest))
            elif self.tools.occurs_in_module(resource=file_):
                pymodule = self.pycore.resource_to_pyobject(file_)
                # Changing occurrences
                placeholder = '__rope_renaming_%s_' % self.old_name
                source = self.tools.rename_in_module(placeholder,
                                                     resource=file_)
                should_import = source is not None
                # Removing out of date imports
                pymodule = self.tools.new_pymodule(pymodule, source)
                source = self.tools.remove_old_imports(pymodule)
                # Adding new import
                if should_import:
                    pymodule = self.tools.new_pymodule(pymodule, source)
                    source, imported = importutils.add_import(
                        self.pycore, pymodule, self._new_modname(dest), self.old_name)
                    source = source.replace(placeholder, imported)
                source = self.tools.new_source(pymodule, source)
                if source != file_.read():
                    changes.add_change(ChangeContents(file_, source))
            job_set.finished_job()
        return changes

    def _source_module_changes(self, dest):
        placeholder = '__rope_moving_%s_' % self.old_name
        handle = _ChangeMoveOccurrencesHandle(placeholder)
        occurrence_finder = occurrences.create_finder(
            self.pycore, self.old_name, self.old_pyname)
        start, end = self._get_moving_region()
        renamer = ModuleSkipRenamer(occurrence_finder, self.source,
                                    handle, start, end)
        source = renamer.get_changed_module()
        if handle.occurred:
            pymodule = self.pycore.get_string_module(source, self.source)
            # Adding new import
            source, imported = importutils.add_import(
                self.pycore, pymodule, self._new_modname(dest), self.old_name)
            source = source.replace(placeholder, imported)
        return ChangeContents(self.source, source)

    def _new_modname(self, dest):
        return self.pycore.modname(dest)

    def _dest_module_changes(self, dest):
        # Changing occurrences
        pymodule = self.pycore.resource_to_pyobject(dest)
        source = self.tools.rename_in_module(self.old_name, pymodule)
        pymodule = self.tools.new_pymodule(pymodule, source)

        moving, imports = self._get_moving_element_with_imports()
        source = self.tools.remove_old_imports(pymodule)
        pymodule = self.tools.new_pymodule(pymodule, source)
        pymodule, has_changed = self._add_imports2(pymodule, imports)

        module_with_imports = self.import_tools.module_imports(pymodule)
        source = pymodule.source_code
        lineno = 0
        if module_with_imports.imports:
            lineno = module_with_imports.imports[-1].end_line - 1
        else:
            while lineno < pymodule.lines.length() and \
                  pymodule.lines.get_line(lineno + 1).lstrip().startswith('#'):
                lineno += 1
        if lineno > 0:
            cut = pymodule.lines.get_line_end(lineno) + 1
            result = source[:cut] + '\n\n' + moving + source[cut:]
        else:
            result = moving + source
        # Organizing imports
        source = result
        pymodule = self.pycore.get_string_module(source, dest)
        source = self.import_tools.organize_imports(pymodule, sort=False,
                                                    unused=False)
        return ChangeContents(dest, source)

    def _get_moving_element_with_imports(self):
        return moving_code_with_imports(
            self.pycore, self.source, self._get_moving_element())

    def _get_module_with_imports(self, source_code, resource):
        pymodule = self.pycore.get_string_module(source_code, resource)
        return self.import_tools.module_imports(pymodule)

    def _get_moving_element(self):
        start, end = self._get_moving_region()
        moving = self.source.read()[start:end]
        return moving.rstrip() + '\n'

    def _get_moving_region(self):
        pymodule = self.pycore.resource_to_pyobject(self.source)
        lines = pymodule.lines
        scope = self.old_pyname.get_object().get_scope()
        start = lines.get_line_start(scope.get_start())
        end_line = scope.get_end()
        while end_line < lines.length() and \
              lines.get_line(end_line + 1).strip() == '':
            end_line += 1
        end = min(lines.get_line_end(end_line) + 1, len(pymodule.source_code))
        return start, end

    def _add_imports2(self, pymodule, new_imports):
        source = self.tools.add_imports(pymodule, new_imports)
        if source is None:
            return pymodule, False
        else:
            resource = pymodule.get_resource()
            pymodule = self.pycore.get_string_module(source, resource)
            return pymodule, True


class MoveModule(object):
    """For moving modules and packages"""

    def __init__(self, project, resource):
        self.project = project
        self.pycore = project.pycore
        if not resource.is_folder() and resource.name == '__init__.py':
            resource = resource.parent
        if resource.is_folder() and not resource.has_child('__init__.py'):
            raise exceptions.RefactoringError(
                'Cannot move non-package folder.')
        dummy_pymodule = self.pycore.get_string_module('')
        self.old_pyname = pynames.ImportedModule(dummy_pymodule,
                                                 resource=resource)
        self.source = self.old_pyname.get_object().get_resource()
        if self.source.is_folder():
            self.old_name = self.source.name
        else:
            self.old_name = self.source.name[:-3]
        self.tools = _MoveTools(self.pycore, self.source,
                                self.old_pyname, self.old_name)
        self.import_tools = self.tools.import_tools

    def get_changes(self, dest, resources=None,
                    task_handle=taskhandle.NullTaskHandle()):
        moving_pyobject = self.old_pyname.get_object()
        if resources is None:
            resources = self.pycore.get_python_files()
        if dest is None or not dest.is_folder():
            raise exceptions.RefactoringError(
                'Move destination for modules should be packages.')
        return self._calculate_changes(dest, resources, task_handle)

    def _calculate_changes(self, dest, resources, task_handle):
        changes = ChangeSet('Moving module <%s>' % self.old_name)
        job_set = task_handle.create_jobset('Collecting changes',
                                            len(resources))
        for module in resources:
            job_set.started_job(module.path)
            if module == self.source:
                self._change_moving_module(changes, dest)
            else:
                source = self._change_occurrences_in_module(dest,
                                                            resource=module)
                if source is not None:
                    changes.add_change(ChangeContents(module, source))
            job_set.finished_job()
        if self.project == self.source.project:
            changes.add_change(MoveResource(self.source, dest.path))
        return changes

    def _new_modname(self, dest):
        destname = self.pycore.modname(dest)
        if destname:
            return destname + '.' + self.old_name
        return self.old_name

    def _new_import(self, dest):
        return importutils.NormalImport([(self._new_modname(dest), None)])

    def _change_moving_module(self, changes, dest):
        if not self.source.is_folder():
            pymodule = self.pycore.resource_to_pyobject(self.source)
            source = self.import_tools.relatives_to_absolutes(pymodule)
            pymodule = self.tools.new_pymodule(pymodule, source)
            source = self._change_occurrences_in_module(dest, pymodule)
            source = self.tools.new_source(pymodule, source)
            if source != self.source.read():
                changes.add_change(ChangeContents(self.source, source))

    def _change_occurrences_in_module(self, dest, pymodule=None,
                                      resource=None):
        if not self.tools.occurs_in_module(pymodule=pymodule,
                                           resource=resource):
            return
        if pymodule is None:
            pymodule = self.pycore.resource_to_pyobject(resource)
        new_name = self._new_modname(dest)
        new_import = self._new_import(dest)
        source = self.tools.rename_in_module(
            new_name, imports=True, pymodule=pymodule, resource=resource)
        should_import = self.tools.occurs_in_module(
            pymodule=pymodule, resource=resource, imports=False)
        pymodule = self.tools.new_pymodule(pymodule, source)
        source = self.tools.remove_old_imports(pymodule)
        if should_import:
            pymodule = self.tools.new_pymodule(pymodule, source)
            source = self.tools.add_imports(pymodule, [new_import])
        source = self.tools.new_source(pymodule, source)
        if source != pymodule.resource.read():
            return source


class _ChangeMoveOccurrencesHandle(object):

    def __init__(self, new_name):
        self.new_name = new_name
        self.occurred = False

    def occurred_inside_skip(self, change_collector, occurrence):
        pass

    def occurred_outside_skip(self, change_collector, occurrence):
        start, end = occurrence.get_primary_range()
        change_collector.add_change(start, end, self.new_name)
        self.occurred = True


class _MoveTools(object):

    def __init__(self, pycore, source, pyname, old_name):
        self.pycore = pycore
        self.source = source
        self.old_pyname = pyname
        self.old_name = old_name
        self.import_tools = importutils.ImportTools(self.pycore)

    def remove_old_imports(self, pymodule):
        old_source = pymodule.source_code
        module_with_imports = self.import_tools.module_imports(pymodule)
        class CanSelect(object):
            changed = False
            old_name = self.old_name
            old_pyname = self.old_pyname
            def __call__(self, name):
                try:
                    if name == self.old_name and \
                       pymodule[name].get_object() == \
                       self.old_pyname.get_object():
                        self.changed = True
                        return False
                except exceptions.AttributeNotFoundError:
                    pass
                return True
        can_select = CanSelect()
        module_with_imports.filter_names(can_select)
        new_source = module_with_imports.get_changed_source()
        if old_source != new_source:
            return new_source

    def rename_in_module(self, new_name, pymodule=None,
                          imports=False, resource=None):
        occurrence_finder = self._create_finder(imports)
        source = rename.rename_in_module(
            occurrence_finder, new_name, replace_primary=True,
            pymodule=pymodule, resource=resource)
        return source

    def occurs_in_module(self, pymodule=None, resource=None, imports=True):
        finder = self._create_finder(imports)
        for occurrence in finder.find_occurrences(pymodule=pymodule,
                                                  resource=resource):
            return True
        return False

    def _create_finder(self, imports):
        return occurrences.create_finder(self.pycore, self.old_name,
                                         self.old_pyname, imports=imports)

    def new_pymodule(self, pymodule, source):
        if source is not None:
            return self.pycore.get_string_module(
                source, pymodule.get_resource())
        return pymodule

    def new_source(self, pymodule, source):
        if source is None:
            return pymodule.source_code
        return source

    def add_imports(self, pymodule, new_imports):
        return _add_imports_to_module(self.import_tools, pymodule, new_imports)


def _add_imports_to_module(import_tools, pymodule, new_imports):
    module_with_imports = import_tools.module_imports(pymodule)
    for new_import in new_imports:
        module_with_imports.add_import(new_import)
    return module_with_imports.get_changed_source()


def moving_code_with_imports(pycore, resource, source):
    import_tools = importutils.ImportTools(pycore)
    pymodule = pycore.get_string_module(source, resource)
    origin = pycore.resource_to_pyobject(resource)

    imports = []
    for stmt in import_tools.module_imports(origin).imports:
        imports.append(stmt.import_info)

    back_names = []
    for name in origin:
        if name not in pymodule:
            back_names.append(name)
    imports.append(import_tools.get_from_import(resource, back_names))

    source = _add_imports_to_module(import_tools, pymodule, imports)
    pymodule = pycore.get_string_module(source, resource)

    source = import_tools.relatives_to_absolutes(pymodule)
    pymodule = pycore.get_string_module(source, resource)
    source = import_tools.organize_imports(pymodule, selfs=False)
    pymodule = pycore.get_string_module(source, resource)

    # extracting imports after changes
    module_imports = import_tools.module_imports(pymodule)
    imports = [import_stmt.import_info
               for import_stmt in module_imports.imports]
    start = 1
    if module_imports.imports:
        start = module_imports.imports[-1].end_line
    lines = codeanalyze.SourceLinesAdapter(source)
    while start < lines.length() and not lines.get_line(start).strip():
        start += 1
    moving = source[lines.get_line_start(start):]
    return moving, imports


class ModuleSkipRenamerHandle(object):

    def occurred_outside_skip(self, change_collector, occurrence):
        pass

    def occurred_inside_skip(self, change_collector, occurrence):
        pass


class ModuleSkipRenamer(object):
    """Rename occurrences in a module

    This class can be used when you want to treat a region in a file
    separately from other parts when renaming.

    """

    def __init__(self, occurrence_finder, resource, handle=None,
                 skip_start=0, skip_end=0, replacement=''):
        """Constructor

        if replacement is `None` the region is not changed.  Otherwise
        it is replaced with `replacement`.

        """
        self.occurrence_finder = occurrence_finder
        self.resource = resource
        self.skip_start = skip_start
        self.skip_end = skip_end
        self.replacement = replacement
        self.handle = handle
        if self.handle is None:
            self.handle = ModuleSkipHandle()

    def get_changed_module(self):
        source = self.resource.read()
        change_collector = codeanalyze.ChangeCollector(source)
        if self.replacement is not None:
            change_collector.add_change(self.skip_start, self.skip_end,
                                        self.replacement)
        for occurrence in self.occurrence_finder.find_occurrences(self.resource):
            start, end = occurrence.get_primary_range()
            if self.skip_start <= start < self.skip_end:
                self.handle.occurred_inside_skip(change_collector, occurrence)
            else:
                self.handle.occurred_outside_skip(change_collector, occurrence)
        result = change_collector.get_changed()
        if result is not None and result != source:
            return result

########NEW FILE########
__FILENAME__ = multiproject
"""This module can be used for performing cross-project refactorings

See the "cross-project refactorings" section of ``docs/library.txt``
file.

"""

from rope.base import resources, project, libutils


class MultiProjectRefactoring(object):

    def __init__(self, refactoring, projects, addpath=True):
        """Create a multiproject proxy for the main refactoring

        `projects` are other project.

        """
        self.refactoring = refactoring
        self.projects = projects
        self.addpath = addpath

    def __call__(self, project, *args, **kwds):
        """Create the refactoring"""
        return _MultiRefactoring(self.refactoring, self.projects,
                                 self.addpath, project, *args, **kwds)


class _MultiRefactoring(object):

    def __init__(self, refactoring, other_projects, addpath,
                 project, *args, **kwds):
        self.refactoring = refactoring
        self.projects = [project] + other_projects
        for other_project in other_projects:
            for folder in self.project.pycore.get_source_folders():
                other_project.get_prefs().add('python_path', folder.real_path)
        self.refactorings = []
        for other in self.projects:
            args, kwds = self._resources_for_args(other, args, kwds)
            self.refactorings.append(
                self.refactoring(other, *args, **kwds))

    def get_all_changes(self, *args, **kwds):
        """Get a project to changes dict"""
        result = []
        for project, refactoring in zip(self.projects, self.refactorings):
            args, kwds = self._resources_for_args(project, args, kwds)
            result.append((project, refactoring.get_changes(*args, **kwds)))
        return result

    def __getattr__(self, name):
        return getattr(self.main_refactoring, name)

    def _resources_for_args(self, project, args, kwds):
        newargs = [self._change_project_resource(project, arg) for arg in args]
        newkwds = dict((name, self._change_project_resource(project, value))
                       for name, value in kwds.items())
        return newargs, newkwds
        
    def _change_project_resource(self, project, obj):
        if isinstance(obj, resources.Resource) and \
           obj.project != project:
            return libutils.path_to_resource(project, obj.real_path)
        return obj

    @property
    def project(self):
        return self.projects[0]

    @property
    def main_refactoring(self):
        return self.refactorings[0]


def perform(project_changes):
    for project, changes in project_changes:
        project.do(changes)

########NEW FILE########
__FILENAME__ = occurrences
import re

import rope.base.pynames
from rope.base import pynames, pyobjects, codeanalyze, evaluate, exceptions, utils, worder


class Finder(object):
    """For finding occurrences of a name

    The constructor takes a `filters` argument.  It should be a list
    of functions that take a single argument.  For each possible
    occurrence, these functions are called in order with the an
    instance of `Occurrence`:

      * If it returns `None` other filters are tried.
      * If it returns `True`, the occurrence will be a match.
      * If it returns `False`, the occurrence will be skipped.
      * If all of the filters return `None`, it is skipped also.

    """

    def __init__(self, pycore, name, filters=[lambda o: True], docs=False):
        self.pycore = pycore
        self.name = name
        self.docs = docs
        self.filters = filters
        self._textual_finder = _TextualFinder(name, docs=docs)

    def find_occurrences(self, resource=None, pymodule=None):
        """Generate `Occurrence` instances"""
        tools = _OccurrenceToolsCreator(self.pycore, resource=resource,
                                        pymodule=pymodule, docs=self.docs)
        for offset in self._textual_finder.find_offsets(tools.source_code):
            occurrence = Occurrence(tools, offset)
            for filter in self.filters:
                result = filter(occurrence)
                if result is None:
                    continue
                if result:
                    yield occurrence
                break


def create_finder(pycore, name, pyname, only_calls=False, imports=True,
                  unsure=None, docs=False, instance=None, in_hierarchy=False):
    """A factory for `Finder`

    Based on the arguments it creates a list of filters.  `instance`
    argument is needed only when you want implicit interfaces to be
    considered.

    """
    pynames = set([pyname])
    filters = []
    if only_calls:
        filters.append(CallsFilter())
    if not imports:
        filters.append(NoImportsFilter())
    if isinstance(instance, rope.base.pynames.ParameterName):
        for pyobject in instance.get_objects():
            try:
                pynames.add(pyobject[name])
            except exceptions.AttributeNotFoundError:
                pass
    for pyname in pynames:
        filters.append(PyNameFilter(pyname))
        if in_hierarchy:
            filters.append(InHierarchyFilter(pyname))
    if unsure:
        filters.append(UnsureFilter(unsure))
    return Finder(pycore, name, filters=filters, docs=docs)


class Occurrence(object):

    def __init__(self, tools, offset):
        self.tools = tools
        self.offset = offset
        self.resource = tools.resource

    @utils.saveit
    def get_word_range(self):
        return self.tools.word_finder.get_word_range(self.offset)

    @utils.saveit
    def get_primary_range(self):
        return self.tools.word_finder.get_primary_range(self.offset)

    @utils.saveit
    def get_pyname(self):
        try:
            return self.tools.name_finder.get_pyname_at(self.offset)
        except exceptions.BadIdentifierError:
            pass

    @utils.saveit
    def get_primary_and_pyname(self):
        try:
            return self.tools.name_finder.get_primary_and_pyname_at(self.offset)
        except exceptions.BadIdentifierError:
            pass

    @utils.saveit
    def is_in_import_statement(self):
        return (self.tools.word_finder.is_from_statement(self.offset) or
                self.tools.word_finder.is_import_statement(self.offset))

    def is_called(self):
        return self.tools.word_finder.is_a_function_being_called(self.offset)

    def is_defined(self):
        return self.tools.word_finder.is_a_class_or_function_name_in_header(self.offset)

    def is_a_fixed_primary(self):
        return self.tools.word_finder.is_a_class_or_function_name_in_header(self.offset) or \
               self.tools.word_finder.is_a_name_after_from_import(self.offset)

    def is_written(self):
        return self.tools.word_finder.is_assigned_here(self.offset)

    def is_unsure(self):
        return unsure_pyname(self.get_pyname())

    @property
    @utils.saveit
    def lineno(self):
        offset = self.get_word_range()[0]
        return self.tools.pymodule.lines.get_line_number(offset)


def same_pyname(expected, pyname):
    """Check whether `expected` and `pyname` are the same"""
    if expected is None or pyname is None:
        return False
    if expected == pyname:
        return True
    if type(expected) not in (pynames.ImportedModule, pynames.ImportedName) and \
       type(pyname) not in (pynames.ImportedModule, pynames.ImportedName):
        return False
    return expected.get_definition_location() == pyname.get_definition_location() and \
           expected.get_object() == pyname.get_object()

def unsure_pyname(pyname, unbound=True):
    """Return `True` if we don't know what this name references"""
    if pyname is None:
        return True
    if unbound and not isinstance(pyname, pynames.UnboundName):
        return False
    if pyname.get_object() == pyobjects.get_unknown():
        return True


class PyNameFilter(object):
    """For finding occurrences of a name"""

    def __init__(self, pyname):
        self.pyname = pyname

    def __call__(self, occurrence):
        if same_pyname(self.pyname, occurrence.get_pyname()):
            return True


class InHierarchyFilter(object):
    """For finding occurrences of a name"""

    def __init__(self, pyname, implementations_only=False):
        self.pyname = pyname
        self.impl_only = implementations_only
        self.pyclass = self._get_containing_class(pyname)
        if self.pyclass is not None:
            self.name = pyname.get_object().get_name()
            self.roots = self._get_root_classes(self.pyclass, self.name)
        else:
            self.roots = None

    def __call__(self, occurrence):
        if self.roots is None:
            return
        pyclass = self._get_containing_class(occurrence.get_pyname())
        if pyclass is not None:
            roots = self._get_root_classes(pyclass, self.name)
            if self.roots.intersection(roots):
                return True

    def _get_containing_class(self, pyname):
        if isinstance(pyname, pynames.DefinedName):
            scope = pyname.get_object().get_scope()
            parent = scope.parent
            if parent is not None and parent.get_kind() == 'Class':
                return parent.pyobject

    def _get_root_classes(self, pyclass, name):
        if self.impl_only and pyclass == self.pyclass:
            return set([pyclass])
        result = set()
        for superclass in pyclass.get_superclasses():
            if name in superclass:
                result.update(self._get_root_classes(superclass, name))
        if not result:
            return set([pyclass])
        return result


class UnsureFilter(object):

    def __init__(self, unsure):
        self.unsure = unsure

    def __call__(self, occurrence):
        if occurrence.is_unsure() and self.unsure(occurrence):
            return True


class NoImportsFilter(object):

    def __call__(self, occurrence):
        if occurrence.is_in_import_statement():
            return False


class CallsFilter(object):

    def __call__(self, occurrence):
        if not occurrence.is_called():
            return False


class _TextualFinder(object):

    def __init__(self, name, docs=False):
        self.name = name
        self.docs = docs
        self.comment_pattern = _TextualFinder.any('comment', [r'#[^\n]*'])
        self.string_pattern = _TextualFinder.any(
            'string', [codeanalyze.get_string_pattern()])
        self.pattern = self._get_occurrence_pattern(self.name)

    def find_offsets(self, source):
        if not self._fast_file_query(source):
            return
        if self.docs:
            searcher = self._normal_search
        else:
            searcher = self._re_search
        for matched in searcher(source):
            yield matched

    def _re_search(self, source):
        for match in self.pattern.finditer(source):
            for key, value in match.groupdict().items():
                if value and key == 'occurrence':
                    yield match.start(key)

    def _normal_search(self, source):
        current = 0
        while True:
            try:
                found = source.index(self.name, current)
                current = found + len(self.name)
                if (found == 0 or not self._is_id_char(source[found - 1])) and \
                   (current == len(source) or not self._is_id_char(source[current])):
                    yield found
            except ValueError:
                break

    def _is_id_char(self, c):
        return c.isalnum() or c == '_'

    def _fast_file_query(self, source):
        try:
            source.index(self.name)
            return True
        except ValueError:
            return False

    def _get_source(self, resource, pymodule):
        if resource is not None:
            return resource.read()
        else:
            return pymodule.source_code

    def _get_occurrence_pattern(self, name):
        occurrence_pattern = _TextualFinder.any('occurrence',
                                                 ['\\b' + name + '\\b'])
        pattern = re.compile(occurrence_pattern + '|' + self.comment_pattern +
                             '|' + self.string_pattern)
        return pattern

    @staticmethod
    def any(name, list_):
        return '(?P<%s>' % name + '|'.join(list_) + ')'


class _OccurrenceToolsCreator(object):

    def __init__(self, pycore, resource=None, pymodule=None, docs=False):
        self.pycore = pycore
        self.__resource = resource
        self.__pymodule = pymodule
        self.docs = docs

    @property
    @utils.saveit
    def name_finder(self):
        return evaluate.ScopeNameFinder(self.pymodule)

    @property
    @utils.saveit
    def source_code(self):
        if self.__resource is not None:
            return self.resource.read()
        else:
            return self.pymodule.source_code

    @property
    @utils.saveit
    def word_finder(self):
        return worder.Worder(self.source_code, self.docs)

    @property
    @utils.saveit
    def resource(self):
        if self.__resource is not None:
            return self.__resource
        if self.__pymodule is not None:
            return self.__pymodule.resource

    @property
    @utils.saveit
    def pymodule(self):
        if self.__pymodule is not None:
            return self.__pymodule
        return self.pycore.resource_to_pyobject(self.resource)

########NEW FILE########
__FILENAME__ = patchedast
import collections
import re
import warnings

from rope.base import ast, codeanalyze, exceptions


def get_patched_ast(source, sorted_children=False):
    """Adds ``region`` and ``sorted_children`` fields to nodes

    Adds ``sorted_children`` field only if `sorted_children` is True.

    """
    return patch_ast(ast.parse(source), source, sorted_children)


def patch_ast(node, source, sorted_children=False):
    """Patches the given node

    After calling, each node in `node` will have a new field named
    `region` that is a tuple containing the start and end offsets
    of the code that generated it.

    If `sorted_children` is true, a `sorted_children` field will
    be created for each node, too.  It is a list containing child
    nodes as well as whitespaces and comments that occur between
    them.

    """
    if hasattr(node, 'region'):
        return node
    walker = _PatchingASTWalker(source, children=sorted_children)
    ast.call_for_nodes(node, walker)
    return node


def node_region(patched_ast_node):
    """Get the region of a patched ast node"""
    return patched_ast_node.region


def write_ast(patched_ast_node):
    """Extract source form a patched AST node with `sorted_children` field

    If the node is patched with sorted_children turned off you can use
    `node_region` function for obtaining code using module source code.
    """
    result = []
    for child in patched_ast_node.sorted_children:
        if isinstance(child, ast.AST):
            result.append(write_ast(child))
        else:
            result.append(child)
    return ''.join(result)


class MismatchedTokenError(exceptions.RopeError):
    pass


class _PatchingASTWalker(object):

    def __init__(self, source, children=False):
        self.source = _Source(source)
        self.children = children
        self.lines = codeanalyze.SourceLinesAdapter(source)
        self.children_stack = []

    Number = object()
    String = object()

    def __call__(self, node):
        method = getattr(self, '_' + node.__class__.__name__, None)
        if method is not None:
            return method(node)
        # ???: Unknown node; what should we do here?
        warnings.warn('Unknown node type <%s>; please report!'
                      % node.__class__.__name__, RuntimeWarning)
        node.region = (self.source.offset, self.source.offset)
        if self.children:
            node.sorted_children = ast.get_children(node)

    def _handle(self, node, base_children, eat_parens=False, eat_spaces=False):
        if hasattr(node, 'region'):
            # ???: The same node was seen twice; what should we do?
            warnings.warn(
                'Node <%s> has been already patched; please report!' %
                node.__class__.__name__, RuntimeWarning)
            return
        base_children = collections.deque(base_children)
        self.children_stack.append(base_children)
        children = collections.deque()
        formats = []
        suspected_start = self.source.offset
        start = suspected_start
        first_token = True
        while base_children:
            child = base_children.popleft()
            if child is None:
                continue
            offset = self.source.offset
            if isinstance(child, ast.arg):
                region = self.source.consume(child.arg)
                child = self.source[region[0]:region[1]]
                token_start = offset
            elif isinstance(child, ast.AST):
                ast.call_for_nodes(child, self)
                token_start = child.region[0]
            else:
                if child is self.String:
                    region = self.source.consume_string(
                        end=self._find_next_statement_start())
                elif child is self.Number:
                    region = self.source.consume_number()
                elif child == '!=':
                    # INFO: This has been added to handle deprecated ``<>``
                    region = self.source.consume_not_equal()
                else:
                    region = self.source.consume(child)
                child = self.source[region[0]:region[1]]
                token_start = region[0]
            if not first_token:
                formats.append(self.source[offset:token_start])
                if self.children:
                    children.append(self.source[offset:token_start])
            else:
                first_token = False
                start = token_start
            if self.children:
                children.append(child)
        start = self._handle_parens(children, start, formats)
        if eat_parens:
            start = self._eat_surrounding_parens(
                children, suspected_start, start)
        if eat_spaces:
            if self.children:
                children.appendleft(self.source[0:start])
            end_spaces = self.source[self.source.offset:]
            self.source.consume(end_spaces)
            if self.children:
                children.append(end_spaces)
            start = 0
        if self.children:
            node.sorted_children = children
        node.region = (start, self.source.offset)
        self.children_stack.pop()

    def _handle_parens(self, children, start, formats):
        """Changes `children` and returns new start"""
        opens, closes = self._count_needed_parens(formats)
        old_end = self.source.offset
        new_end = None
        for i in range(closes):
            new_end = self.source.consume(')')[1]
        if new_end is not None:
            if self.children:
                children.append(self.source[old_end:new_end])
        new_start = start
        for i in range(opens):
            new_start = self.source.rfind_token('(', 0, new_start)
        if new_start != start:
            if self.children:
                children.appendleft(self.source[new_start:start])
            start = new_start
        return start

    def _eat_surrounding_parens(self, children, suspected_start, start):
        index = self.source.rfind_token('(', suspected_start, start)
        if index is not None:
            old_start = start
            old_offset = self.source.offset
            start = index
            if self.children:
                children.appendleft(self.source[start + 1:old_start])
                children.appendleft('(')
            token_start, token_end = self.source.consume(')')
            if self.children:
                children.append(self.source[old_offset:token_start])
                children.append(')')
        return start

    def _count_needed_parens(self, children):
        start = 0
        opens = 0
        for child in children:
            if not isinstance(child, str):
                continue
            if child == '' or child[0] in '\'"':
                continue
            index = 0
            while index < len(child):
                if child[index] == ')':
                    if opens > 0:
                        opens -= 1
                    else:
                        start += 1
                if child[index] == '(':
                    opens += 1
                if child[index] == '#':
                    try:
                        index = child.index('\n', index)
                    except ValueError:
                        break
                index += 1
        return start, opens

    def _find_next_statement_start(self):
        for children in reversed(self.children_stack):
            for child in children:
                if isinstance(child, ast.stmt):
                    return child.col_offset \
                           + self.lines.get_line_start(child.lineno)
        return len(self.source.source)

    _operators = {'And': 'and', 'Or': 'or', 'Add': '+', 'Sub': '-', 'Mult': '*',
                  'Div': '/', 'Mod': '%', 'Pow': '**', 'LShift': '<<',
                  'RShift': '>>', 'BitOr': '|', 'BitAnd': '&', 'BitXor': '^',
                  'FloorDiv': '//', 'Invert': '~', 'Not': 'not', 'UAdd': '+',
                  'USub': '-', 'Eq': '==', 'NotEq': '!=', 'Lt': '<',
                  'LtE': '<=', 'Gt': '>', 'GtE': '>=', 'Is': 'is',
                  'IsNot': 'is not', 'In': 'in', 'NotIn': 'not in'}

    def _get_op(self, node):
        return self._operators[node.__class__.__name__].split(' ')

    def _Attribute(self, node):
        self._handle(node, [node.value, '.', node.attr])

    def _Assert(self, node):
        children = ['assert', node.test]
        if node.msg:
            children.append(',')
            children.append(node.msg)
        self._handle(node, children)

    def _Assign(self, node):
        children = self._child_nodes(node.targets, '=')
        children.append('=')
        children.append(node.value)
        self._handle(node, children)

    def _AugAssign(self, node):
        children = [node.target]
        children.extend(self._get_op(node.op))
        children.extend(['=', node.value])
        self._handle(node, children)

    def _Repr(self, node):
        self._handle(node, ['`', node.value, '`'])

    def _BinOp(self, node):
        children = [node.left] + self._get_op(node.op) + [node.right]
        self._handle(node, children)

    def _BoolOp(self, node):
        self._handle(node, self._child_nodes(node.values,
                                             self._get_op(node.op)[0]))

    def _Break(self, node):
        self._handle(node, ['break'])

    def _Call(self, node):
        children = [node.func, '(']
        args = list(node.args) + node.keywords
        children.extend(self._child_nodes(args, ','))
        if node.starargs is not None:
            if args:
                children.append(',')
            children.extend(['*', node.starargs])
        if node.kwargs is not None:
            if args or node.starargs is not None:
                children.append(',')
            children.extend(['**', node.kwargs])
        children.append(')')
        self._handle(node, children)

    def _ClassDef(self, node):
        children = []
        if getattr(node, 'decorator_list', None):
            for decorator in node.decorator_list:
                children.append('@')
                children.append(decorator)
        children.extend(['class', node.name])
        if node.bases:
            children.append('(')
            children.extend(self._child_nodes(node.bases, ','))
            children.append(')')
        children.append(':')
        children.extend(node.body)
        self._handle(node, children)

    def _Compare(self, node):
        children = []
        children.append(node.left)
        for op, expr in zip(node.ops, node.comparators):
            children.extend(self._get_op(op))
            children.append(expr)
        self._handle(node, children)

    def _Delete(self, node):
        self._handle(node, ['del'] + self._child_nodes(node.targets, ','))

    def _Num(self, node):
        self._handle(node, [self.Number])

    def _Str(self, node):
        self._handle(node, [self.String])

    def _Continue(self, node):
        self._handle(node, ['continue'])

    def _Dict(self, node):
        children = []
        children.append('{')
        if node.keys:
            for index, (key, value) in enumerate(list(zip(node.keys, node.values))):
                children.extend([key, ':', value])
                if index < len(node.keys) - 1:
                    children.append(',')
        children.append('}')
        self._handle(node, children)

    def _Ellipsis(self, node):
        self._handle(node, ['...'])

    def _Expr(self, node):
        self._handle(node, [node.value])

    def _Exec(self, node):
        children = []
        children.extend(['exec', node.body])
        if node.globals:
            children.extend(['in', node.globals])
        if node.locals:
            children.extend([',', node.locals])
        self._handle(node, children)

    def _ExtSlice(self, node):
        children = []
        for index, dim in enumerate(node.dims):
            if index > 0:
                children.append(',')
            children.append(dim)
        self._handle(node, children)

    def _For(self, node):
        children = ['for', node.target, 'in', node.iter, ':']
        children.extend(node.body)
        if node.orelse:
            children.extend(['else', ':'])
            children.extend(node.orelse)
        self._handle(node, children)

    def _ImportFrom(self, node):
        children = ['from']
        if node.level:
            children.append('.' * node.level)
        children.extend([node.module or '', # see comment at rope.base.ast.walk
                         'import'])
        children.extend(self._child_nodes(node.names, ','))
        self._handle(node, children)

    def _alias(self, node):
        children = [node.name]
        if node.asname:
            children.extend(['as', node.asname])
        self._handle(node, children)

    def _FunctionDef(self, node):
        children = []
        try:
            decorators = getattr(node, 'decorator_list')
        except AttributeError:
            decorators = getattr(node, 'decorators', None)
        if decorators:
            for decorator in decorators:
                children.append('@')
                children.append(decorator)
        children.extend(['def', node.name, '(', node.args])
        children.extend([')', ':'])
        children.extend(node.body)
        self._handle(node, children)

    def _arguments(self, node):
        children = []
        args = list(node.args)
        defaults = [None] * (len(args) - len(node.defaults)) + list(node.defaults)
        for index, (arg, default) in enumerate(list(zip(args, defaults))):
            if index > 0:
                children.append(',')
            self._add_args_to_children(children, arg, default)
        if node.vararg is not None:
            if args:
                children.append(',')
            children.extend(['*', node.vararg])
        if node.kwarg is not None:
            if args or node.vararg is not None:
                children.append(',')
            children.extend(['**', node.kwarg])
        self._handle(node, children)

    def _add_args_to_children(self, children, arg, default):
        if isinstance(arg, (list, tuple)):
            self._add_tuple_parameter(children, arg)
        else:
            children.append(arg)
        if default is not None:
            children.append('=')
            children.append(default)

    def _add_tuple_parameter(self, children, arg):
        children.append('(')
        for index, token in enumerate(arg):
            if index > 0:
                children.append(',')
            if isinstance(token, (list, tuple)):
                self._add_tuple_parameter(children, token)
            else:
                children.append(token)
        children.append(')')

    def _GeneratorExp(self, node):
        children = [node.elt]
        children.extend(node.generators)
        self._handle(node, children, eat_parens=True)

    def _comprehension(self, node):
        children = ['for', node.target, 'in', node.iter]
        if node.ifs:
            for if_ in node.ifs:
                children.append('if')
                children.append(if_)
        self._handle(node, children)

    def _Global(self, node):
        children = self._child_nodes(node.names, ',')
        children.insert(0, 'global')
        self._handle(node, children)

    def _If(self, node):
        if self._is_elif(node):
            children = ['elif']
        else:
            children = ['if']
        children.extend([node.test, ':'])
        children.extend(node.body)
        if node.orelse:
            if len(node.orelse) == 1 and self._is_elif(node.orelse[0]):
                pass
            else:
                children.extend(['else', ':'])
            children.extend(node.orelse)
        self._handle(node, children)

    def _is_elif(self, node):
        if not isinstance(node, ast.If):
            return False
        offset = self.lines.get_line_start(node.lineno) + node.col_offset
        word = self.source[offset:offset + 4]
        # XXX: This is a bug; the offset does not point to the first
        alt_word = self.source[offset - 5:offset - 1]
        return 'elif' in (word, alt_word)

    def _IfExp(self, node):
        return self._handle(node, [node.body, 'if', node.test,
                                   'else', node.orelse])

    def _Import(self, node):
        children = ['import']
        children.extend(self._child_nodes(node.names, ','))
        self._handle(node, children)

    def _keyword(self, node):
        self._handle(node, [node.arg, '=', node.value])

    def _Lambda(self, node):
        self._handle(node, ['lambda', node.args, ':', node.body])

    def _List(self, node):
        self._handle(node, ['['] + self._child_nodes(node.elts, ',') + [']'])

    def _ListComp(self, node):
        children = ['[', node.elt]
        children.extend(node.generators)
        children.append(']')
        self._handle(node, children)

    def _Module(self, node):
        self._handle(node, list(node.body), eat_spaces=True)

    def _Name(self, node):
        self._handle(node, [node.id])

    def _Pass(self, node):
        self._handle(node, ['pass'])

    def _Print(self, node):
        children = ['print']
        if node.dest:
            children.extend(['>>', node.dest])
            if node.values:
                children.append(',')
        children.extend(self._child_nodes(node.values, ','))
        if not node.nl:
            children.append(',')
        self._handle(node, children)

    def _Raise(self, node):
        children = ['raise']
        if node.cause:
            children.append(node.cause)
        if node.exc:
            children.append(node.exc)
        self._handle(node, children)

    def _Return(self, node):
        children = ['return']
        if node.value:
            children.append(node.value)
        self._handle(node, children)

    def _Sliceobj(self, node):
        children = []
        for index, slice in enumerate(node.nodes):
            if index > 0:
                children.append(':')
            if slice:
                children.append(slice)
        self._handle(node, children)

    def _Index(self, node):
        self._handle(node, [node.value])

    def _Subscript(self, node):
        self._handle(node, [node.value, '[', node.slice, ']'])

    def _Slice(self, node):
        children = []
        if node.lower:
            children.append(node.lower)
        children.append(':')
        if node.upper:
            children.append(node.upper)
        if node.step:
            children.append(':')
            children.append(node.step)
        self._handle(node, children)

    def _TryFinally(self, node):
        children = []
        if len(node.body) != 1 or not isinstance(node.body[0], ast.TryExcept):
            children.extend(['try', ':'])
        children.extend(node.body)
        children.extend(['finally', ':'])
        children.extend(node.finalbody)
        self._handle(node, children)

    def _TryExcept(self, node):
        children = ['try', ':']
        children.extend(node.body)
        children.extend(node.handlers)
        if node.orelse:
            children.extend(['else', ':'])
            children.extend(node.orelse)
        self._handle(node, children)

    def _ExceptHandler(self, node):
        self._excepthandler(node)

    def _excepthandler(self, node):
        children = ['except']
        if node.type:
            children.append(node.type)
        if node.name:
            children.extend(['as', node.name])
        children.append(':')
        children.extend(node.body)
        self._handle(node, children)

    def _Tuple(self, node):
        if node.elts:
            self._handle(node, self._child_nodes(node.elts, ','),
                         eat_parens=True)
        else:
            self._handle(node, ['(', ')'])

    def _UnaryOp(self, node):
        children = self._get_op(node.op)
        children.append(node.operand)
        self._handle(node, children)

    def _Yield(self, node):
        children = ['yield']
        if node.value:
            children.append(node.value)
        self._handle(node, children)

    def _While(self, node):
        children = ['while', node.test, ':']
        children.extend(node.body)
        if node.orelse:
            children.extend(['else', ':'])
            children.extend(node.orelse)
        self._handle(node, children)

    def _With(self, node):
        children = ['with', node.context_expr]
        if node.optional_vars:
            children.extend(['as', node.optional_vars])
        children.append(':')
        children.extend(node.body)
        self._handle(node, children)

    def _child_nodes(self, nodes, separator):
        children = []
        for index, child in enumerate(nodes):
            children.append(child)
            if index < len(nodes) - 1:
                children.append(separator)
        return children


class _Source(object):

    def __init__(self, source):
        self.source = source
        self.offset = 0

    def consume(self, token):
        try:
            while True:
                new_offset = self.source.index(token, self.offset)
                if self._good_token(token, new_offset):
                    break
                else:
                    self._skip_comment()
        except (ValueError, TypeError):
            raise MismatchedTokenError(
                'Token <%s> at %s cannot be matched' %
                (token, self._get_location()))
        self.offset = new_offset + len(token)
        return (new_offset, self.offset)

    def consume_string(self, end=None):
        if _Source._string_pattern is None:
            original = codeanalyze.get_string_pattern()
            pattern = r'(%s)((\s|\\\n|#[^\n]*\n)*(%s))*' % \
                      (original, original)
            _Source._string_pattern = re.compile(pattern)
        repattern = _Source._string_pattern
        return self._consume_pattern(repattern, end)

    def consume_number(self):
        if _Source._number_pattern is None:
            _Source._number_pattern = re.compile(
                self._get_number_pattern())
        repattern = _Source._number_pattern
        return self._consume_pattern(repattern)

    def consume_not_equal(self):
        if _Source._not_equals_pattern is None:
            _Source._not_equals_pattern = re.compile(r'<>|!=')
        repattern = _Source._not_equals_pattern
        return self._consume_pattern(repattern)

    def _good_token(self, token, offset, start=None):
        """Checks whether consumed token is in comments"""
        if start is None:
            start = self.offset
        try:
            comment_index = self.source.rindex('#', start, offset)
        except ValueError:
            return True
        try:
            new_line_index = self.source.rindex('\n', start, offset)
        except ValueError:
            return False
        return comment_index < new_line_index

    def _skip_comment(self):
        self.offset = self.source.index('\n', self.offset + 1)

    def _get_location(self):
        lines = self.source[:self.offset].split('\n')
        return (len(lines), len(lines[-1]))

    def _consume_pattern(self, repattern, end=None):
        while True:
            if end is None:
                end = len(self.source)
            match = repattern.search(self.source, self.offset, end)
            if self._good_token(match.group(), match.start()):
                break
            else:
                self._skip_comment()
        self.offset = match.end()
        return match.start(), match.end()

    def till_token(self, token):
        new_offset = self.source.index(token, self.offset)
        return self[self.offset:new_offset]

    def rfind_token(self, token, start, end):
        index = start
        while True:
            try:
                index = self.source.rindex(token, start, end)
                if self._good_token(token, index, start=start):
                    return index
                else:
                    end = index
            except ValueError:
                return None

    def from_offset(self, offset):
        return self[offset:self.offset]

    def find_backwards(self, pattern, offset):
        return self.source.rindex(pattern, 0, offset)

    def __getitem__(self, index):
        return self.source[index]

    def __getslice__(self, i, j):
        return self.source[i:j]

    def _get_number_pattern(self):
        # HACK: It is merely an approaximation and does the job
        integer = r'(0|0x)?[\da-fA-F]+[lL]?'
        return r'(%s(\.\d*)?|(\.\d+))([eE][-+]?\d*)?[jJ]?' % integer

    _string_pattern = None
    _number_pattern = None
    _not_equals_pattern = None

########NEW FILE########
__FILENAME__ = rename
import warnings

from rope.base import exceptions, pyobjects, pynames, taskhandle, evaluate, worder, codeanalyze
from rope.base.change import ChangeSet, ChangeContents, MoveResource
from rope.refactor import occurrences, sourceutils


class Rename(object):
    """A class for performing rename refactoring

    It can rename everything: classes, functions, modules, packages,
    methods, variables and keyword arguments.

    """

    def __init__(self, project, resource, offset=None):
        """If `offset` is None, the `resource` itself will be renamed"""
        self.project = project
        self.pycore = project.pycore
        self.resource = resource
        if offset is not None:
            self.old_name = worder.get_name_at(self.resource, offset)
            this_pymodule = self.pycore.resource_to_pyobject(self.resource)
            self.old_instance, self.old_pyname = \
                evaluate.eval_location2(this_pymodule, offset)
            if self.old_pyname is None:
                raise exceptions.RefactoringError(
                    'Rename refactoring should be performed'
                    ' on resolvable python identifiers.')
        else:
            if not resource.is_folder() and resource.name == '__init__.py':
                resource = resource.parent
            dummy_pymodule = self.pycore.get_string_module('')
            self.old_instance = None
            self.old_pyname = pynames.ImportedModule(dummy_pymodule,
                                                     resource=resource)
            if resource.is_folder():
                self.old_name = resource.name
            else:
                self.old_name = resource.name[:-3]

    def get_old_name(self):
        return self.old_name

    def get_changes(self, new_name, in_file=None, in_hierarchy=False,
                    unsure=None, docs=False, resources=None,
                    task_handle=taskhandle.NullTaskHandle()):
        """Get the changes needed for this refactoring

        Parameters:

        - `in_hierarchy`: when renaming a method this keyword forces
          to rename all matching methods in the hierarchy
        - `docs`: when `True` rename refactoring will rename
          occurrences in comments and strings where the name is
          visible.  Setting it will make renames faster, too.
        - `unsure`: decides what to do about unsure occurrences.
          If `None`, they are ignored.  Otherwise `unsure` is
          called with an instance of `occurrence.Occurrence` as
          parameter.  If it returns `True`, the occurrence is
          considered to be a match.
        - `resources` can be a list of `rope.base.resources.File`\s to
          apply this refactoring on.  If `None`, the restructuring
          will be applied to all python files.
        - `in_file`: this argument has been deprecated; use
          `resources` instead.

        """
        if unsure in (True, False):
            warnings.warn(
                'unsure parameter should be a function that returns '
                'True or False', DeprecationWarning, stacklevel=2)
            def unsure_func(value=unsure):
                return value
            unsure = unsure_func
        if in_file is not None:
            warnings.warn(
                '`in_file` argument has been deprecated; use `resources` '
                'instead. ', DeprecationWarning, stacklevel=2)
            if in_file:
                resources = [self.resource]
        if _is_local(self.old_pyname):
            resources = [self.resource]
        if resources is None:
            resources = self.pycore.get_python_files()
        changes = ChangeSet('Renaming <%s> to <%s>' %
                            (self.old_name, new_name))
        finder = occurrences.create_finder(
            self.pycore, self.old_name, self.old_pyname, unsure=unsure,
            docs=docs, instance=self.old_instance,
            in_hierarchy=in_hierarchy and self.is_method())
        job_set = task_handle.create_jobset('Collecting Changes', len(resources))
        for file_ in resources:
            job_set.started_job(file_.path)
            new_content = rename_in_module(finder, new_name, resource=file_)
            if new_content is not None:
                changes.add_change(ChangeContents(file_, new_content))
            job_set.finished_job()
        if self._is_renaming_a_module():
            resource = self.old_pyname.get_object().get_resource()
            if self._is_allowed_to_move(resources, resource):
                self._rename_module(resource, new_name, changes)
        return changes

    def _is_allowed_to_move(self, resources, resource):
        if resource.is_folder():
            try:
                return resource.get_child('__init__.py') in resources
            except exceptions.ResourceNotFoundError:
                return False
        else:
            return resource in resources

    def _is_renaming_a_module(self):
        if isinstance(self.old_pyname.get_object(), pyobjects.AbstractModule):
            return True
        return False

    def is_method(self):
        pyname = self.old_pyname
        return isinstance(pyname, pynames.DefinedName) and \
               isinstance(pyname.get_object(), pyobjects.PyFunction) and \
               isinstance(pyname.get_object().parent, pyobjects.PyClass)

    def _rename_module(self, resource, new_name, changes):
        if not resource.is_folder():
            new_name = new_name + '.py'
        parent_path = resource.parent.path
        if parent_path == '':
            new_location = new_name
        else:
            new_location = parent_path + '/' + new_name
        changes.add_change(MoveResource(resource, new_location))


class ChangeOccurrences(object):
    """A class for changing the occurrences of a name in a scope

    This class replaces the occurrences of a name.  Note that it only
    changes the scope containing the offset passed to the constructor.
    What's more it does not have any side-effects.  That is for
    example changing occurrences of a module does not rename the
    module; it merely replaces the occurrences of that module in a
    scope with the given expression.  This class is useful for
    performing many custom refactorings.

    """

    def __init__(self, project, resource, offset):
        self.pycore = project.pycore
        self.resource = resource
        self.offset = offset
        self.old_name = worder.get_name_at(resource, offset)
        self.pymodule = self.pycore.resource_to_pyobject(self.resource)
        self.old_pyname = evaluate.eval_location(self.pymodule, offset)

    def get_old_name(self):
        word_finder = worder.Worder(self.resource.read())
        return word_finder.get_primary_at(self.offset)

    def _get_scope_offset(self):
        lines = self.pymodule.lines
        scope = self.pymodule.get_scope().\
                get_inner_scope_for_line(lines.get_line_number(self.offset))
        start = lines.get_line_start(scope.get_start())
        end = lines.get_line_end(scope.get_end())
        return start, end

    def get_changes(self, new_name, only_calls=False, reads=True, writes=True):
        changes = ChangeSet('Changing <%s> occurrences to <%s>' %
                            (self.old_name, new_name))
        scope_start, scope_end = self._get_scope_offset()
        finder = occurrences.create_finder(
            self.pycore, self.old_name, self.old_pyname,
            imports=False, only_calls=only_calls)
        new_contents = rename_in_module(
            finder, new_name, pymodule=self.pymodule, replace_primary=True,
            region=(scope_start, scope_end), reads=reads, writes=writes)
        if new_contents is not None:
            changes.add_change(ChangeContents(self.resource, new_contents))
        return changes


def rename_in_module(occurrences_finder, new_name, resource=None, pymodule=None,
                     replace_primary=False, region=None, reads=True, writes=True):
    """Returns the changed source or `None` if there is no changes"""
    if resource is not None:
        source_code = resource.read()
    else:
        source_code = pymodule.source_code
    change_collector = codeanalyze.ChangeCollector(source_code)
    for occurrence in occurrences_finder.find_occurrences(resource, pymodule):
        if replace_primary and occurrence.is_a_fixed_primary():
            continue
        if replace_primary:
            start, end = occurrence.get_primary_range()
        else:
            start, end = occurrence.get_word_range()
        if (not reads and not occurrence.is_written()) or \
           (not writes and occurrence.is_written()):
            continue
        if region is None or region[0] <= start < region[1]:
            change_collector.add_change(start, end, new_name)
    return change_collector.get_changed()

def _is_local(pyname):
    module, lineno = pyname.get_definition_location()
    if lineno is None:
        return False
    scope = module.get_scope().get_inner_scope_for_line(lineno)
    if isinstance(pyname, pynames.DefinedName) and \
       scope.get_kind() in ('Function', 'Class'):
        scope = scope.parent
    return scope.get_kind() == 'Function' and \
           pyname in list(scope.get_names().values()) and \
           isinstance(pyname, pynames.AssignedName)

########NEW FILE########
__FILENAME__ = restructure
import warnings

from rope.base import change, taskhandle, builtins, ast, codeanalyze
from rope.refactor import patchedast, similarfinder, sourceutils
from rope.refactor.importutils import module_imports


class Restructure(object):
    """A class to perform python restructurings

    A restructuring transforms pieces of code matching `pattern` to
    `goal`.  In the `pattern` wildcards can appear.  Wildcards match
    some piece of code based on their kind and arguments that are
    passed to them through `args`.

    `args` is a dictionary of wildcard names to wildcard arguments.
    If the argument is a tuple, the first item of the tuple is
    considered to be the name of the wildcard to use; otherwise the
    "default" wildcard is used.  For getting the list arguments a
    wildcard supports, see the pydoc of the wildcard.  (see
    `rope.refactor.wildcard.DefaultWildcard` for the default
    wildcard.)

    `wildcards` is the list of wildcard types that can appear in
    `pattern`.  See `rope.refactor.wildcards`.  If a wildcard does not
    specify its kind (by using a tuple in args), the wildcard named
    "default" is used.  So there should be a wildcard with "default"
    name in `wildcards`.

    `imports` is the list of imports that changed modules should
    import.  Note that rope handles duplicate imports and does not add
    the import if it already appears.

    Example #1::

      pattern ${pyobject}.get_attribute(${name})
      goal ${pyobject}[${name}]
      args pyobject: instance=rope.base.pyobjects.PyObject

    Example #2::

      pattern ${name} in ${pyobject}.get_attributes()
      goal ${name} in {pyobject}
      args pyobject: instance=rope.base.pyobjects.PyObject

    Example #3::

      pattern ${pycore}.create_module(${project}.root, ${name})
      goal generate.create_module(${project}, ${name})

      imports
       from rope.contrib import generate

      args
       pycore: type=rope.base.pycore.PyCore
       project: type=rope.base.project.Project

    Example #4::

      pattern ${pow}(${param1}, ${param2})
      goal ${param1} ** ${param2}
      args pow: name=mod.pow, exact

    Example #5::

      pattern ${inst}.longtask(${p1}, ${p2})
      goal
       ${inst}.subtask1(${p1})
       ${inst}.subtask2(${p2})
      args
       inst: type=mod.A,unsure

    """

    def __init__(self, project, pattern, goal, args=None,
                 imports=None, wildcards=None):
        """Construct a restructuring

        See class pydoc for more info about the arguments.

        """
        self.pycore = project.pycore
        self.pattern = pattern
        self.goal = goal
        self.args = args
        if self.args is None:
            self.args = {}
        self.imports = imports
        if self.imports is None:
            self.imports = []
        self.wildcards = wildcards
        self.template = similarfinder.CodeTemplate(self.goal)

    def get_changes(self, checks=None, imports=None, resources=None,
                    task_handle=taskhandle.NullTaskHandle()):
        """Get the changes needed by this restructuring

        `resources` can be a list of `rope.base.resources.File`\s to
        apply the restructuring on.  If `None`, the restructuring will
        be applied to all python files.

        `checks` argument has been deprecated.  Use the `args` argument
        of the constructor.  The usage of::

          strchecks = {'obj1.type': 'mod.A', 'obj2': 'mod.B',
                       'obj3.object': 'mod.C'}
          checks = restructuring.make_checks(strchecks)

        can be replaced with::

          args = {'obj1': 'type=mod.A', 'obj2': 'name=mod.B',
                  'obj3': 'object=mod.C'}

        where obj1, obj2 and obj3 are wildcard names that appear
        in restructuring pattern.

        """
        if checks is not None:
            warnings.warn(
                'The use of checks parameter is deprecated; '
                'use the args parameter of the constructor instead.',
                DeprecationWarning, stacklevel=2)
            for name, value in checks.items():
                self.args[name] = similarfinder._pydefined_to_str(value)
        if imports is not None:
            warnings.warn(
                'The use of imports parameter is deprecated; '
                'use imports parameter of the constructor, instead.',
                DeprecationWarning, stacklevel=2)
            self.imports = imports
        changes = change.ChangeSet('Restructuring <%s> to <%s>' %
                                   (self.pattern, self.goal))
        if resources is not None:
            files = [resource for resource in resources
                     if self.pycore.is_python_file(resource)]
        else:
            files = self.pycore.get_python_files()
        job_set = task_handle.create_jobset('Collecting Changes', len(files))
        for resource in files:
            job_set.started_job(resource.path)
            pymodule = self.pycore.resource_to_pyobject(resource)
            finder = similarfinder.SimilarFinder(pymodule,
                                                 wildcards=self.wildcards)
            matches = list(finder.get_matches(self.pattern, self.args))
            computer = self._compute_changes(matches, pymodule)
            result = computer.get_changed()
            if result is not None:
                imported_source = self._add_imports(resource, result,
                                                    self.imports)
                changes.add_change(change.ChangeContents(resource,
                                                         imported_source))
            job_set.finished_job()
        return changes

    def _compute_changes(self, matches, pymodule):
        return _ChangeComputer(
            pymodule.source_code, pymodule.get_ast(),
            pymodule.lines, self.template, matches)

    def _add_imports(self, resource, source, imports):
        if not imports:
            return source
        import_infos = self._get_import_infos(resource, imports)
        pymodule = self.pycore.get_string_module(source, resource)
        imports = module_imports.ModuleImports(self.pycore, pymodule)
        for import_info in import_infos:
            imports.add_import(import_info)
        return imports.get_changed_source()

    def _get_import_infos(self, resource, imports):
        pymodule = self.pycore.get_string_module('\n'.join(imports),
                                                 resource)
        imports = module_imports.ModuleImports(self.pycore, pymodule)
        return [imports.import_info
                for imports in imports.imports]

    def make_checks(self, string_checks):
        """Convert str to str dicts to str to PyObject dicts

        This function is here to ease writing a UI.

        """
        checks = {}
        for key, value in string_checks.items():
            is_pyname = not key.endswith('.object') and \
                        not key.endswith('.type')
            evaluated = self._evaluate(value, is_pyname=is_pyname)
            if evaluated is not None:
                checks[key] = evaluated
        return checks

    def _evaluate(self, code, is_pyname=True):
        attributes = code.split('.')
        pyname = None
        if attributes[0] in ('__builtin__', '__builtins__'):
            class _BuiltinsStub(object):
                def get_attribute(self, name):
                    return builtins.builtins[name]
            pyobject = _BuiltinsStub()
        else:
            pyobject = self.pycore.get_module(attributes[0])
        for attribute in attributes[1:]:
            pyname = pyobject[attribute]
            if pyname is None:
                return None
            pyobject = pyname.get_object()
        return pyname if is_pyname else pyobject


def replace(code, pattern, goal):
    """used by other refactorings"""
    finder = similarfinder.RawSimilarFinder(code)
    matches = list(finder.get_matches(pattern))
    ast = patchedast.get_patched_ast(code)
    lines = codeanalyze.SourceLinesAdapter(code)
    template = similarfinder.CodeTemplate(goal)
    computer = _ChangeComputer(code, ast, lines, template, matches)
    result = computer.get_changed()
    if result is None:
        return code
    return result


class _ChangeComputer(object):

    def __init__(self, code, ast, lines, goal, matches):
        self.source = code
        self.goal = goal
        self.matches = matches
        self.ast = ast
        self.lines = lines
        self.matched_asts = {}
        self._nearest_roots = {}
        if self._is_expression():
            for match in self.matches:
                self.matched_asts[match.ast] = match

    def get_changed(self):
        if self._is_expression():
            result = self._get_node_text(self.ast)
            if result == self.source:
                return None
            return result
        else:
            collector = codeanalyze.ChangeCollector(self.source)
            last_end = -1
            for match in self.matches:
                start, end = match.get_region()
                if start < last_end:
                    if not self._is_expression():
                        continue
                last_end = end
                replacement = self._get_matched_text(match)
                collector.add_change(start, end, replacement)
            return collector.get_changed()

    def _is_expression(self):
        return self.matches and isinstance(self.matches[0],
                                           similarfinder.ExpressionMatch)

    def _get_matched_text(self, match):
        mapping = {}
        for name in self.goal.get_names():
            node = match.get_ast(name)
            if node is None:
                raise similarfinder.BadNameInCheckError(
                    'Unknown name <%s>' % name)
            force = self._is_expression() and match.ast == node
            mapping[name] = self._get_node_text(node, force)
        unindented = self.goal.substitute(mapping)
        return self._auto_indent(match.get_region()[0], unindented)

    def _get_node_text(self, node, force=False):
        if not force and node in self.matched_asts:
            return self._get_matched_text(self.matched_asts[node])
        start, end = patchedast.node_region(node)
        main_text = self.source[start:end]
        collector = codeanalyze.ChangeCollector(main_text)
        for node in self._get_nearest_roots(node):
            sub_start, sub_end = patchedast.node_region(node)
            collector.add_change(sub_start - start, sub_end - start,
                                 self._get_node_text(node))
        result = collector.get_changed()
        if result is None:
            return main_text
        return result

    def _auto_indent(self, offset, text):
        lineno = self.lines.get_line_number(offset)
        indents = sourceutils.get_indents(self.lines, lineno)
        result = []
        for index, line in enumerate(text.splitlines(True)):
            if index != 0 and line.strip():
                result.append(' ' * indents)
            result.append(line)
        return ''.join(result)

    def _get_nearest_roots(self, node):
        if node not in self._nearest_roots:
            result = []
            for child in ast.get_child_nodes(node):
                if child in self.matched_asts:
                    result.append(child)
                else:
                    result.extend(self._get_nearest_roots(child))
            self._nearest_roots[node] = result
        return self._nearest_roots[node]

########NEW FILE########
__FILENAME__ = similarfinder
"""This module can be used for finding similar code"""
import re

import rope.refactor.wildcards
from rope.base import codeanalyze, evaluate, exceptions, ast, builtins
from rope.refactor import (patchedast, sourceutils, occurrences,
                           wildcards, importutils)


class BadNameInCheckError(exceptions.RefactoringError):
    pass


class SimilarFinder(object):
    """`SimilarFinder` can be used to find similar pieces of code

    See the notes in the `rope.refactor.restructure` module for more
    info.

    """

    def __init__(self, pymodule, wildcards=None):
        """Construct a SimilarFinder"""
        self.source = pymodule.source_code
        self.raw_finder = RawSimilarFinder(
            pymodule.source_code, pymodule.get_ast(), self._does_match)
        self.pymodule = pymodule
        if wildcards is None:
            self.wildcards = {}
            for wildcard in [rope.refactor.wildcards.
                             DefaultWildcard(pymodule.pycore.project)]:
                self.wildcards[wildcard.get_name()] = wildcard
        else:
            self.wildcards = wildcards

    def get_matches(self, code, args={}, start=0, end=None):
        self.args = args
        if end is None:
            end = len(self.source)
        skip_region = None
        if 'skip' in args.get('', {}):
            resource, region = args['']['skip']
            if resource == self.pymodule.get_resource():
                skip_region = region            
        return self.raw_finder.get_matches(code, start=start, end=end,
                                           skip=skip_region)

    def get_match_regions(self, *args, **kwds):
        for match in self.get_matches(*args, **kwds):
            yield match.get_region()

    def _does_match(self, node, name):
        arg = self.args.get(name, '')
        kind = 'default'
        if isinstance(arg, (tuple, list)):
            kind = arg[0]
            arg = arg[1]
        suspect = wildcards.Suspect(self.pymodule, node, name)
        return self.wildcards[kind].matches(suspect, arg)


class RawSimilarFinder(object):
    """A class for finding similar expressions and statements"""

    def __init__(self, source, node=None, does_match=None):
        if node is None:
            node = ast.parse(source)
        if does_match is None:
            self.does_match = self._simple_does_match
        else:
            self.does_match = does_match
        self._init_using_ast(node, source)

    def _simple_does_match(self, node, name):
        return isinstance(node, (ast.expr, ast.Name))

    def _init_using_ast(self, node, source):
        self.source = source
        self._matched_asts = {}
        if not hasattr(node, 'region'):
            patchedast.patch_ast(node, source)
        self.ast = node

    def get_matches(self, code, start=0, end=None, skip=None):
        """Search for `code` in source and return a list of `Match`\es

        `code` can contain wildcards.  ``${name}`` matches normal
        names and ``${?name} can match any expression.  You can use
        `Match.get_ast()` for getting the node that has matched a
        given pattern.

        """
        if end is None:
            end = len(self.source)
        for match in self._get_matched_asts(code):
            match_start, match_end = match.get_region()
            if start <= match_start and match_end <= end:
                if skip is not None and (skip[0] < match_end and
                                         skip[1] > match_start):
                    continue                    
                yield match

    def _get_matched_asts(self, code):
        if code not in self._matched_asts:
            wanted = self._create_pattern(code)
            matches = _ASTMatcher(self.ast, wanted,
                                  self.does_match).find_matches()
            self._matched_asts[code] = matches
        return self._matched_asts[code]

    def _create_pattern(self, expression):
        expression = self._replace_wildcards(expression)
        node = ast.parse(expression)
        # Getting Module.Stmt.nodes
        nodes = node.body
        if len(nodes) == 1 and isinstance(nodes[0], ast.Expr):
            # Getting Discard.expr
            wanted = nodes[0].value
        else:
            wanted = nodes
        return wanted

    def _replace_wildcards(self, expression):
        ropevar = _RopeVariable()
        template = CodeTemplate(expression)
        mapping = {}
        for name in template.get_names():
            mapping[name] = ropevar.get_var(name)
        return template.substitute(mapping)


class _ASTMatcher(object):

    def __init__(self, body, pattern, does_match):
        """Searches the given pattern in the body AST.

        body is an AST node and pattern can be either an AST node or
        a list of ASTs nodes
        """
        self.body = body
        self.pattern = pattern
        self.matches = None
        self.ropevar = _RopeVariable()
        self.matches_callback = does_match

    def find_matches(self):
        if self.matches is None:
            self.matches = []
            ast.call_for_nodes(self.body, self._check_node, recursive=True)
        return self.matches

    def _check_node(self, node):
        if isinstance(self.pattern, list):
            self._check_statements(node)
        else:
            self._check_expression(node)

    def _check_expression(self, node):
        mapping = {}
        if self._match_nodes(self.pattern, node, mapping):
            self.matches.append(ExpressionMatch(node, mapping))

    def _check_statements(self, node):
        for child in ast.get_children(node):
            if isinstance(child, (list, tuple)):
                self.__check_stmt_list(child)

    def __check_stmt_list(self, nodes):
        for index in range(len(nodes)):
            if len(nodes) - index >= len(self.pattern):
                current_stmts = nodes[index:index + len(self.pattern)]
                mapping = {}
                if self._match_stmts(current_stmts, mapping):
                    self.matches.append(StatementMatch(current_stmts, mapping))

    def _match_nodes(self, expected, node, mapping):
        if isinstance(expected, ast.Name):
           if self.ropevar.is_var(expected.id):
               return self._match_wildcard(expected, node, mapping)
        if not isinstance(expected, ast.AST):
            return expected == node
        if expected.__class__ != node.__class__:
            return False

        children1 = self._get_children(expected)
        children2 = self._get_children(node)
        if len(children1) != len(children2):
            return False
        for child1, child2 in zip(children1, children2):
            if isinstance(child1, ast.AST):
                if not self._match_nodes(child1, child2, mapping):
                    return False
            elif isinstance(child1, (list, tuple)):
                if not isinstance(child2, (list, tuple)) or \
                   len(child1) != len(child2):
                    return False
                for c1, c2 in zip(child1, child2):
                    if not self._match_nodes(c1, c2, mapping):
                        return False
            else:
                if child1 != child2:
                    return False
        return True

    def _get_children(self, node):
        """Return not `ast.expr_context` children of `node`"""
        children = ast.get_children(node)
        return [child for child in children
                if not isinstance(child, ast.expr_context)]

    def _match_stmts(self, current_stmts, mapping):
        if len(current_stmts) != len(self.pattern):
            return False
        for stmt, expected in zip(current_stmts, self.pattern):
            if not self._match_nodes(expected, stmt, mapping):
                return False
        return True

    def _match_wildcard(self, node1, node2, mapping):
        name = self.ropevar.get_base(node1.id)
        if name not in mapping:
            if self.matches_callback(node2, name):
                mapping[name] = node2
                return True
            return False
        else:
            return self._match_nodes(mapping[name], node2, {})


class Match(object):

    def __init__(self, mapping):
        self.mapping = mapping

    def get_region(self):
        """Returns match region"""

    def get_ast(self, name):
        """Return the ast node that has matched rope variables"""
        return self.mapping.get(name, None)


class ExpressionMatch(Match):

    def __init__(self, ast, mapping):
        super(ExpressionMatch, self).__init__(mapping)
        self.ast = ast

    def get_region(self):
        return self.ast.region


class StatementMatch(Match):

    def __init__(self, ast_list, mapping):
        super(StatementMatch, self).__init__(mapping)
        self.ast_list = ast_list

    def get_region(self):
        return self.ast_list[0].region[0], self.ast_list[-1].region[1]


class CodeTemplate(object):

    def __init__(self, template):
        self.template = template
        self._find_names()

    def _find_names(self):
        self.names = {}
        for match in CodeTemplate._get_pattern().finditer(self.template):
            if 'name' in match.groupdict() and \
               match.group('name') is not None:
                start, end = match.span('name')
                name = self.template[start + 2:end - 1]
                if name not in self.names:
                    self.names[name] = []
                self.names[name].append((start, end))

    def get_names(self):
        return list(self.names.keys())

    def substitute(self, mapping):
        collector = codeanalyze.ChangeCollector(self.template)
        for name, occurrences in self.names.items():
            for region in occurrences:
                collector.add_change(region[0], region[1], mapping[name])
        result = collector.get_changed()
        if result is None:
            return self.template
        return result

    _match_pattern = None

    @classmethod
    def _get_pattern(cls):
        if cls._match_pattern is None:
            pattern = codeanalyze.get_comment_pattern() + '|' + \
                      codeanalyze.get_string_pattern() + '|' + \
                      r'(?P<name>\$\{[^\s\$\}]*\})'
            cls._match_pattern = re.compile(pattern)
        return cls._match_pattern


class _RopeVariable(object):
    """Transform and identify rope inserted wildcards"""

    _normal_prefix = '__rope__variable_normal_'
    _any_prefix = '__rope__variable_any_'

    def get_var(self, name):
        if name.startswith('?'):
            return self._get_any(name)
        else:
            return self._get_normal(name)

    def is_var(self, name):
        return self._is_normal(name) or self._is_var(name)

    def get_base(self, name):
        if self._is_normal(name):
            return name[len(self._normal_prefix):]
        if self._is_var(name):
            return '?' + name[len(self._any_prefix):]

    def _get_normal(self, name):
        return self._normal_prefix + name

    def _get_any(self, name):
        return self._any_prefix + name[1:]

    def _is_normal(self, name):
        return name.startswith(self._normal_prefix)

    def _is_var(self, name):
        return name.startswith(self._any_prefix)


def make_pattern(code, variables):
    variables = set(variables)
    collector = codeanalyze.ChangeCollector(code)
    def does_match(node, name):
        return isinstance(node, ast.Name) and node.id == name
    finder = RawSimilarFinder(code, does_match=does_match)
    for variable in variables:
        for match in finder.get_matches('${%s}' % variable):
            start, end = match.get_region()
            collector.add_change(start, end, '${%s}' % variable)
    result = collector.get_changed()
    return result if result is not None else code


def _pydefined_to_str(pydefined):
    address = []
    if isinstance(pydefined, (builtins.BuiltinClass, builtins.BuiltinFunction)):
        return '__builtins__.' + pydefined.get_name()
    else:
        while pydefined.parent is not None:
            address.insert(0, pydefined.get_name())
            pydefined = pydefined.parent
        module_name = pydefined.pycore.modname(pydefined.resource)
    return '.'.join(module_name.split('.') + address)

########NEW FILE########
__FILENAME__ = sourceutils
from rope.base import ast, codeanalyze


def get_indents(lines, lineno):
    return codeanalyze.count_line_indents(lines.get_line(lineno))


def find_minimum_indents(source_code):
    result = 80
    lines = source_code.split('\n')
    for line in lines:
        if line.strip() == '':
            continue
        result = min(result, codeanalyze.count_line_indents(line))
    return result


def indent_lines(source_code, amount):
    if amount == 0:
        return source_code
    lines = source_code.splitlines(True)
    result = []
    for l in lines:
        if l.strip() == '':
            result.append('\n')
            continue
        if amount < 0:
            indents = codeanalyze.count_line_indents(l)
            result.append(max(0, indents + amount) * ' ' + l.lstrip())
        else:
            result.append(' ' * amount + l)
    return ''.join(result)


def fix_indentation(code, new_indents):
    """Change the indentation of `code` to `new_indents`"""
    min_indents = find_minimum_indents(code)
    return indent_lines(code, new_indents - min_indents)


def add_methods(pymodule, class_scope, methods_sources):
    source_code = pymodule.source_code
    lines = pymodule.lines
    insertion_line = class_scope.get_end()
    if class_scope.get_scopes():
        insertion_line = class_scope.get_scopes()[-1].get_end()
    insertion_offset = lines.get_line_end(insertion_line)
    methods = '\n\n' + '\n\n'.join(methods_sources)
    indented_methods = fix_indentation(
        methods, get_indents(lines, class_scope.get_start()) +
        get_indent(pymodule.pycore))
    result = []
    result.append(source_code[:insertion_offset])
    result.append(indented_methods)
    result.append(source_code[insertion_offset:])
    return ''.join(result)


def get_body(pyfunction):
    """Return unindented function body"""
    scope = pyfunction.get_scope()
    pymodule = pyfunction.get_module()
    start, end = get_body_region(pyfunction)
    return fix_indentation(pymodule.source_code[start:end], 0)


def get_body_region(defined):
    """Return the start and end offsets of function body"""
    scope = defined.get_scope()
    pymodule = defined.get_module()
    lines = pymodule.lines
    node = defined.get_ast()
    start_line = node.lineno
    if defined.get_doc() is None:
        start_line = node.body[0].lineno
    elif len(node.body) > 1:
        start_line = node.body[1].lineno
    start = lines.get_line_start(start_line)
    scope_start = pymodule.logical_lines.logical_line_in(scope.start)
    if scope_start[1] >= start_line:
        # a one-liner!
        # XXX: what if colon appears in a string
        start = pymodule.source_code.index(':', start) + 1
        while pymodule.source_code[start].isspace():
            start += 1
    end = min(lines.get_line_end(scope.end) + 1, len(pymodule.source_code))
    return start, end


def get_indent(pycore):
    project = pycore.project
    return project.prefs.get('indent_size', 4)

########NEW FILE########
__FILENAME__ = suites
from rope.base import ast


def find_visible(node, lines):
    """Return the line which is visible from all `lines`"""
    root = ast_suite_tree(node)
    return find_visible_for_suite(root, lines)


def find_visible_for_suite(root, lines):
    if len(lines) == 1:
        return lines[0]
    line1 = lines[0]
    line2 = find_visible_for_suite(root, lines[1:])
    suite1 = root.find_suite(line1)
    suite2 = root.find_suite(line2)
    def valid(suite):
        return suite is not None and not suite.ignored
    if valid(suite1) and not valid(suite2):
        return line1
    if not valid(suite1) and valid(suite2):
        return line2
    if not valid(suite1) and not valid(suite2):
        return None
    while suite1 != suite2 and suite1.parent != suite2.parent:
        if suite1._get_level() < suite2._get_level():
            line2 = suite2.get_start()
            suite2 = suite2.parent
        elif suite1._get_level() > suite2._get_level():
            line1 = suite1.get_start()
            suite1 = suite1.parent
        else:
            line1 = suite1.get_start()
            line2 = suite2.get_start()
            suite1 = suite1.parent
            suite2 = suite2.parent
    if suite1 == suite2:
        return min(line1, line2)
    return min(suite1.get_start(), suite2.get_start())


def ast_suite_tree(node):
    if hasattr(node, 'lineno'):
        lineno = node.lineno
    else:
        lineno = 1
    return Suite(node.body, lineno)


class Suite(object):

    def __init__(self, child_nodes, lineno, parent=None, ignored=False):
        self.parent = parent
        self.lineno = lineno
        self.child_nodes = child_nodes
        self._children = None
        self.ignored = ignored

    def get_start(self):
        if self.parent is None:
            if self.child_nodes:
                return self.local_start()
            else:
                return 1
        return self.lineno

    def get_children(self):
        if self._children is None:
            walker = _SuiteWalker(self)
            for child in self.child_nodes:
                ast.walk(child, walker)
            self._children = walker.suites
        return self._children

    def local_start(self):
        return self.child_nodes[0].lineno

    def local_end(self):
        end = self.child_nodes[-1].lineno
        if self.get_children():
            end = max(end, self.get_children()[-1].local_end())
        return end

    def find_suite(self, line):
        if line is None:
            return None
        for child in self.get_children():
            if child.local_start() <= line <= child.local_end():
                return child.find_suite(line)
        return self

    def _get_level(self):
        if self.parent is None:
            return 0
        return self.parent._get_level() + 1


class _SuiteWalker(object):

    def __init__(self, suite):
        self.suite = suite
        self.suites = []

    def _If(self, node):
        self._add_if_like_node(node)

    def _For(self, node):
        self._add_if_like_node(node)

    def _While(self, node):
        self._add_if_like_node(node)

    def _With(self, node):
        self.suites.append(Suite(node.body, node.lineno, self.suite))

    def _TryFinally(self, node):
        if len(node.finalbody) == 1 and \
           isinstance(node.body[0], ast.TryExcept):
            self._TryExcept(node.body[0])
        else:
            self.suites.append(Suite(node.body, node.lineno, self.suite))
        self.suites.append(Suite(node.finalbody, node.lineno, self.suite))

    def _TryExcept(self, node):
        self.suites.append(Suite(node.body, node.lineno, self.suite))
        for handler in node.handlers:
            self.suites.append(Suite(handler.body, node.lineno, self.suite))
        if node.orelse:
            self.suites.append(Suite(node.orelse, node.lineno, self.suite))

    def _add_if_like_node(self, node):
        self.suites.append(Suite(node.body, node.lineno, self.suite))
        if node.orelse:
            self.suites.append(Suite(node.orelse, node.lineno, self.suite))

    def _FunctionDef(self, node):
        self.suites.append(Suite(node.body, node.lineno,
                                 self.suite, ignored=True))

    def _ClassDef(self, node):
        self.suites.append(Suite(node.body, node.lineno,
                                 self.suite, ignored=True))

########NEW FILE########
__FILENAME__ = topackage
import rope.refactor.importutils
from rope.base.change import ChangeSet, ChangeContents, MoveResource, CreateFolder


class ModuleToPackage(object):

    def __init__(self, project, resource):
        self.project = project
        self.pycore = project.pycore
        self.resource = resource

    def get_changes(self):
        changes = ChangeSet('Transform <%s> module to package' %
                            self.resource.path)
        new_content = self._transform_relatives_to_absolute(self.resource)
        if new_content is not None:
            changes.add_change(ChangeContents(self.resource, new_content))
        parent = self.resource.parent
        name = self.resource.name[:-3]
        changes.add_change(CreateFolder(parent, name))
        parent_path = parent.path + '/'
        if not parent.path:
            parent_path = ''
        new_path = parent_path + '%s/__init__.py' % name
        if self.resource.project == self.project:
            changes.add_change(MoveResource(self.resource, new_path))
        return changes

    def _transform_relatives_to_absolute(self, resource):
        pymodule = self.pycore.resource_to_pyobject(resource)
        import_tools = rope.refactor.importutils.ImportTools(self.pycore)
        return import_tools.relatives_to_absolutes(pymodule)

########NEW FILE########
__FILENAME__ = usefunction
from rope.base import (change, taskhandle, evaluate,
                       exceptions, pyobjects, pynames, ast)
from rope.refactor import restructure, sourceutils, similarfinder, importutils


class UseFunction(object):
    """Try to use a function wherever possible"""

    def __init__(self, project, resource, offset):
        self.project = project
        self.offset = offset
        this_pymodule = project.pycore.resource_to_pyobject(resource)
        pyname = evaluate.eval_location(this_pymodule, offset)
        if pyname is None:
            raise exceptions.RefactoringError('Unresolvable name selected')
        self.pyfunction = pyname.get_object()
        if not isinstance(self.pyfunction, pyobjects.PyFunction) or \
           not isinstance(self.pyfunction.parent, pyobjects.PyModule):
            raise exceptions.RefactoringError(
                'Use function works for global functions, only.')
        self.resource = self.pyfunction.get_module().get_resource()
        self._check_returns()

    def _check_returns(self):
        node = self.pyfunction.get_ast()
        if _yield_count(node):
            raise exceptions.RefactoringError('Use function should not '
                                              'be used on generators.')
        returns = _return_count(node)
        if returns > 1:
            raise exceptions.RefactoringError('usefunction: Function has more '
                                              'than one return statement.')
        if returns == 1 and not _returns_last(node):
            raise exceptions.RefactoringError('usefunction: return should '
                                              'be the last statement.')

    def get_changes(self, resources=None,
                    task_handle=taskhandle.NullTaskHandle()):
        if resources is None:
            resources = self.project.pycore.get_python_files()
        changes = change.ChangeSet('Using function <%s>' %
                                   self.pyfunction.get_name())
        if self.resource in resources:
            newresources = list(resources)
            newresources.remove(self.resource)
        for c in self._restructure(newresources, task_handle).changes:
            changes.add_change(c)
        if self.resource in resources:
            for c in self._restructure([self.resource], task_handle,
                                       others=False).changes:
                changes.add_change(c)
        return changes

    def get_function_name(self):
        return self.pyfunction.get_name()

    def _restructure(self, resources, task_handle, others=True):
        body = self._get_body()
        pattern = self._make_pattern()
        goal = self._make_goal(import_=others)
        imports = None
        if others:
            imports = ['import %s' % self._module_name()]

        body_region = sourceutils.get_body_region(self.pyfunction)
        args_value = {'skip': (self.resource, body_region)}
        args = {'': args_value}

        restructuring = restructure.Restructure(
            self.project, pattern, goal, args=args, imports=imports)
        return restructuring.get_changes(resources=resources,
                                         task_handle=task_handle)

    def _find_temps(self):
        return find_temps(self.project, self._get_body())

    def _module_name(self):
        return self.project.pycore.modname(self.resource)

    def _make_pattern(self):
        params = self.pyfunction.get_param_names()
        body = self._get_body()
        body = restructure.replace(body, 'return', 'pass')
        wildcards = list(params)
        wildcards.extend(self._find_temps())
        if self._does_return():
            if self._is_expression():
                replacement = '${%s}' % self._rope_returned
            else:
                replacement = '%s = ${%s}' % (self._rope_result,
                                              self._rope_returned)
            body = restructure.replace(
                body, 'return ${%s}' % self._rope_returned,
                replacement)
            wildcards.append(self._rope_result)
        return similarfinder.make_pattern(body, wildcards)

    def _get_body(self):
        return sourceutils.get_body(self.pyfunction)

    def _make_goal(self, import_=False):
        params = self.pyfunction.get_param_names()
        function_name = self.pyfunction.get_name()
        if import_:
            function_name = self._module_name() + '.' + function_name
        goal = '%s(%s)' % (function_name,
                           ', ' .join(('${%s}' % p) for p in params))
        if self._does_return() and not self._is_expression():
            goal = '${%s} = %s' % (self._rope_result, goal)
        return goal

    def _does_return(self):
        body = self._get_body()
        removed_return = restructure.replace(body, 'return ${result}', '')
        return removed_return != body

    def _is_expression(self):
        return len(self.pyfunction.get_ast().body) == 1

    _rope_result = '_rope__result'
    _rope_returned = '_rope__returned'


def find_temps(project, code):
    code = 'def f():\n' + sourceutils.indent_lines(code, 4)
    pymodule = project.pycore.get_string_module(code)
    result = []
    function_scope = pymodule.get_scope().get_scopes()[0]
    for name, pyname in function_scope.get_names().items():
        if isinstance(pyname, pynames.AssignedName):
            result.append(name)
    return result


def _returns_last(node):
    return node.body and isinstance(node.body[-1], ast.Return)

def _yield_count(node):
    visitor = _ReturnOrYieldFinder()
    visitor.start_walking(node)
    return visitor.yields

def _return_count(node):
    visitor = _ReturnOrYieldFinder()
    visitor.start_walking(node)
    return visitor.returns

class _ReturnOrYieldFinder(object):

    def __init__(self):
        self.returns = 0
        self.yields = 0

    def _Return(self, node):
        self.returns += 1

    def _Yield(self, node):
        self.yields += 1

    def _FunctionDef(self, node):
        pass

    def _ClassDef(self, node):
        pass

    def start_walking(self, node):
        nodes = [node]
        if isinstance(node, ast.FunctionDef):
            nodes = ast.get_child_nodes(node)
        for child in nodes:
            ast.walk(child, self)

########NEW FILE########
__FILENAME__ = wildcards
from rope.base import ast, evaluate, builtins, pyobjects
from rope.refactor import patchedast, occurrences


class Wildcard(object):

    def get_name(self):
        """Return the name of this wildcard"""

    def matches(self, suspect, arg):
        """Return `True` if `suspect` matches this wildcard"""


class Suspect(object):

    def __init__(self, pymodule, node, name):
        self.name = name
        self.pymodule = pymodule
        self.node = node


class DefaultWildcard(object):
    """The default restructuring wildcard

    The argument passed to this wildcard is in the
    ``key1=value1,key2=value2,...`` format.  Possible keys are:

    * name - for checking the reference
    * type - for checking the type
    * object - for checking the object
    * instance - for checking types but similar to builtin isinstance
    * exact - matching only occurrences with the same name as the wildcard
    * unsure - matching unsure occurrences

    """

    def __init__(self, project):
        self.project = project

    def get_name(self):
        return 'default'

    def matches(self, suspect, arg=''):
        args = parse_arg(arg)

        if not self._check_exact(args, suspect):
            return False
        if not self._check_object(args, suspect):
            return False
        return True

    def _check_object(self, args, suspect):
        kind = None
        expected = None
        unsure = args.get('unsure', False)
        for check in ['name', 'object', 'type', 'instance']:
            if check in args:
                kind = check
                expected = args[check]
            if expected is not None:
                checker = _CheckObject(self.project, expected,
                                       kind, unsure=unsure)
                return checker(suspect.pymodule, suspect.node)
        return True

    def _check_exact(self, args, suspect):
        node = suspect.node
        if args.get('exact'):
            if not isinstance(node, ast.Name) or not node.id == suspect.name:
                return False
        else:
            if not isinstance(node, ast.expr):
                return False
        return True


def parse_arg(arg):
    if isinstance(arg, dict):
        return arg
    result = {}
    tokens = arg.split(',')
    for token in tokens:
        if '=' in token:
            parts = token.split('=', 1)
            result[parts[0].strip()] = parts[1].strip()
        else:
            result[token.strip()] = True
    return result


class _CheckObject(object):

    def __init__(self, project, expected, kind='object', unsure=False):
        self.project = project
        self.kind = kind
        self.unsure = unsure
        self.expected = self._evaluate(expected)

    def __call__(self, pymodule, node):
        pyname = self._evaluate_node(pymodule, node)
        if pyname is None or self.expected is None:
            return self.unsure
        if self._unsure_pyname(pyname, unbound=self.kind=='name'):
            return True
        if self.kind == 'name':
            return self._same_pyname(self.expected, pyname)
        else:
            pyobject = pyname.get_object()
            if self.kind == 'object':
                objects = [pyobject]
            if self.kind == 'type':
                objects = [pyobject.get_type()]
            if self.kind == 'instance':
                objects = [pyobject]
                objects.extend(self._get_super_classes(pyobject))
                objects.extend(self._get_super_classes(pyobject.get_type()))
            for pyobject in objects:
                if self._same_pyobject(self.expected.get_object(), pyobject):
                    return True
            return False

    def _get_super_classes(self, pyobject):
        result = []
        if isinstance(pyobject, pyobjects.AbstractClass):
            for superclass in pyobject.get_superclasses():
                result.append(superclass)
                result.extend(self._get_super_classes(superclass))
        return result

    def _same_pyobject(self, expected, pyobject):
        return expected == pyobject

    def _same_pyname(self, expected, pyname):
        return occurrences.same_pyname(expected, pyname)

    def _unsure_pyname(self, pyname, unbound=True):
        return self.unsure and occurrences.unsure_pyname(pyname, unbound)

    def _split_name(self, name):
        parts = name.split('.')
        expression, kind = parts[0], parts[-1]
        if len(parts) == 1:
            kind = 'name'
        return expression, kind

    def _evaluate_node(self, pymodule, node):
        scope = pymodule.get_scope().get_inner_scope_for_line(node.lineno)
        expression = node
        if isinstance(expression, ast.Name) and \
           isinstance(expression.ctx, ast.Store):
            start, end = patchedast.node_region(expression)
            text = pymodule.source_code[start:end]
            return evaluate.eval_str(scope, text)
        else:
            return evaluate.eval_node(scope, expression)

    def _evaluate(self, code):
        attributes = code.split('.')
        pyname = None
        if attributes[0] in ('__builtin__', '__builtins__'):
            class _BuiltinsStub(object):
                def get_attribute(self, name):
                    return builtins.builtins[name]
                def __getitem__(self, name):
                    return builtins.builtins[name]
                def __contains__(self, name):
                    return name in builtins.builtins
            pyobject = _BuiltinsStub()
        else:
            pyobject = self.project.pycore.get_module(attributes[0])
        for attribute in attributes[1:]:
            pyname = pyobject[attribute]
            if pyname is None:
                return None
            pyobject = pyname.get_object()
        return pyname

########NEW FILE########
__FILENAME__ = temp8
#
# Python implemetation of a scoreboard for the Volta River Authority
# Author: Amoatey Harrison
# Email: fortharris@gmail.com, fortharris@yahoo.co.uk
#

import sys
import re
import os
from PyQt4 import QtCore, QtGui, QtNetwork

from FrameLabel import FrameLabel
import StyleSheet


class SettingsDialog(QtGui.QDialog):

    settingsUpdated = QtCore.pyqtSignal(list)

    def __init__(self, parent=None):
        QtGui.QDialog.__init__(self, parent,
                               QtCore.Qt.Window | QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle("Dispay Settings")
        self.resize(100, 150)

        mainLayout = QtGui.QVBoxLayout()
        self.setLayout(mainLayout)

        formLayout = QtGui.QFormLayout()
        mainLayout.addLayout(formLayout)

        self.scoreFontSizeBox = QtGui.QSpinBox()
        self.scoreFontSizeBox.setMinimum(20)
        self.scoreFontSizeBox.setMaximum(200)
        self.scoreFontSizeBox.setSingleStep(10)
        self.scoreFontSizeBox.setValue(100)
        self.scoreFontSizeBox.valueChanged.connect(self.updateSettings)
        formLayout.addRow("Score font size", self.scoreFontSizeBox)

        self.teamFontSizeBox = QtGui.QSpinBox()
        self.teamFontSizeBox.setMinimum(20)
        self.teamFontSizeBox.setMaximum(150)
        self.teamFontSizeBox.setSingleStep(10)
        self.teamFontSizeBox.setValue(50)
        self.teamFontSizeBox.valueChanged.connect(self.updateSettings)
        formLayout.addRow("Team Name font size", self.teamFontSizeBox)

        self.elapsedTimeFontSizeBox = QtGui.QSpinBox()
        self.elapsedTimeFontSizeBox.setMinimum(20)
        self.elapsedTimeFontSizeBox.setMaximum(200)
        self.elapsedTimeFontSizeBox.setSingleStep(10)
        self.elapsedTimeFontSizeBox.setValue(70)
        self.elapsedTimeFontSizeBox.valueChanged.connect(self.updateSettings)
        formLayout.addRow(
            "Elapsed Time font size", self.elapsedTimeFontSizeBox)

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)
        hbox.addStretch(1)

        closelButton = QtGui.QPushButton("Close")
        closelButton.clicked.connect(self.close)
        hbox.addWidget(closelButton)

        hbox.addStretch(1)

        self.updateSettings()

    def updateSettings(self):
        self.settingsList = [self.scoreFontSizeBox.text(),
                             self.teamFontSizeBox.text(),
                             self.elapsedTimeFontSizeBox.text()]
        self.settingsUpdated.emit(self.settingsList)


class NewMatch(QtGui.QDialog):

    def __init__(self, parent=None):
        QtGui.QDialog.__init__(self, parent,
                               QtCore.Qt.Window | QtCore.Qt.WindowCloseButtonHint)

        self.setWindowTitle("New Match")
        self.resize(350, 100)

        mainLayout = QtGui.QVBoxLayout()
        self.setLayout(mainLayout)

        hbox = QtGui.QHBoxLayout()
        hbox.setMargin(0)
        mainLayout.addLayout(hbox)

        vbox = QtGui.QVBoxLayout()
        hbox.addLayout(vbox)

        label = QtGui.QLabel("Team A")
        label.setAlignment(QtCore.Qt.AlignHCenter)
        vbox.addWidget(label)
        
        self.teamALine = QtGui.QLineEdit()
        vbox.addWidget(self.teamALine)

        vbox = QtGui.QVBoxLayout()
        hbox.addLayout(vbox)

        label = QtGui.QLabel("Team B")
        label.setAlignment(QtCore.Qt.AlignHCenter)
        vbox.addWidget(label)

        self.teamBLine = QtGui.QLineEdit()
        vbox.addWidget(self.teamBLine)

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        hbox.addStretch(1)

        doneButton = QtGui.QPushButton("Done")
        doneButton.clicked.connect(self.accept)
        hbox.addWidget(doneButton)

        cancelButton = QtGui.QPushButton("Cancel")
        cancelButton.clicked.connect(self.close)
        hbox.addWidget(cancelButton)

        hbox.addStretch(1)

        self.accepted = False

        self.exec_()

    def accept(self):
        teamA = self.teamALine.text().strip()
        if teamA == '':
            return QtGui.QMessageBox.warning(self, "Add Match", "Team A cannot be empty!")
        teamB = self.teamBLine.text().strip()
        if teamB == '':
            return QtGui.QMessageBox.warning(self, "Add Match", "Team B cannot be empty!")

        self.accepted = True
        self.matchList = [teamA, teamB]

        self.close()


class Rematch(QtGui.QMainWindow):

    def __init__(self, parent=None):
        QtGui.QMainWindow.__init__(self, parent, QtCore.Qt.Window |
                              QtCore.Qt.FramelessWindowHint | QtCore.Qt.WindowSystemMenuHint |
                              QtCore.Qt.WindowMinimizeButtonHint | QtCore.Qt.WindowCloseButtonHint)
        self.setAttribute(QtCore.Qt.WA_TranslucentBackground, True)

        self.setWindowIcon(
            QtGui.QIcon(os.path.join("Resources", "images", "Icon")))
        self.setWindowTitle("Rematch")

        screen = QtGui.QDesktopWidget().screenGeometry()
        self.setFixedSize(450, 300)
        size = self.geometry()
        self.move((screen.width() - size.width()) / 2, (
            screen.height() - size.height()) / 2)
        self.lastWindowGeometry = self.geometry()

        self.settingsDialog = SettingsDialog(self)
        self.settingsDialog.settingsUpdated.connect(self.updateSettings)

        mainWidget = QtGui.QWidget(self)
        mainWidget.setGeometry(0, 0, 450, 300)
        mainWidget.setObjectName("main")
        mainWidget.setStyleSheet("""
                            QWidget#main {
                            background: #ffffff; border: 1px solid #00B6F3; border-radius: 0px;
                            }
                            """)

        mainLayout = QtGui.QVBoxLayout()
        mainLayout.setSpacing(0)
        mainLayout.setMargin(0)
        mainWidget.setLayout(mainLayout)

        frame = FrameLabel(self)
        frame.settingsButton.clicked.connect(self.settingsDialog.exec_)
        mainLayout.addWidget(frame)

        self.timer = QtCore.QTimer()
        self.timer.setSingleShot(False)
        self.timer.setInterval(1000)
        self.timer.timeout.connect(self.increaseElapsedTime)

        hbox = QtGui.QHBoxLayout()
        hbox.setMargin(5)
        hbox.setSpacing(5)
        mainLayout.addLayout(hbox)

        hbox.addStretch(1)

        self.pauseButton = QtGui.QToolButton()
        self.pauseButton.setToolTip("Pause Time")
        self.pauseButton.setStyleSheet(StyleSheet.playPauseButtonStyle)
        self.pauseButton.setAutoRaise(True)
        self.pauseButton.setIconSize(QtCore.QSize(30, 30))
        self.pauseButton.setMinimumWidth(45)
        self.pauseButton.setMinimumHeight(45)
        self.pauseButton.setIcon(QtGui.QIcon("Resources\\images\\pause"))
        hbox.addWidget(self.pauseButton)
        self.pauseButton.clicked.connect(self.stop)
        self.pauseButton.hide()

        self.playButton = QtGui.QToolButton()
        self.playButton.setToolTip("Start\Continue Time")
        self.playButton.setStyleSheet(StyleSheet.playPauseButtonStyle)
        self.playButton.setAutoRaise(True)
        self.playButton.setIconSize(QtCore.QSize(30, 30))
        self.playButton.setMinimumWidth(45)
        self.playButton.setMinimumHeight(45)
        self.playButton.setIcon(QtGui.QIcon("Resources\\images\\player_play"))
        self.playButton.clicked.connect(self.play)
        hbox.addWidget(self.playButton)

        hbox.addStretch(1)

        hbox = QtGui.QHBoxLayout()
        hbox.setMargin(10)
        mainLayout.addLayout(hbox)

        self.teamAScoreLabel = QtGui.QLabel()
        self.teamAScoreLabel.setStyleSheet(StyleSheet.scoreLabelStyle)
        hbox.addWidget(self.teamAScoreLabel)

        hbox.addStretch(1)

        self.scoreABox = QtGui.QLineEdit('0')
        self.scoreABox.setReadOnly(True)
        self.scoreABox.setStyleSheet(StyleSheet.scoreBoxStyle)
        self.scoreABox.setMinimumHeight(45)
        self.scoreABox.setMinimumWidth(95)
        self.scoreABox.textChanged.connect(self.updateInstruction)
        hbox.addWidget(self.scoreABox)

        self.increaseAbutton = QtGui.QToolButton()
        self.increaseAbutton.setToolTip("Score")
        self.increaseAbutton.setIcon(
            QtGui.QIcon("Resources\\images\\go-up-black"))
        self.increaseAbutton.setStyleSheet(StyleSheet.increaseButtonStyle)
        self.increaseAbutton.clicked.connect(self.increaseA)
        hbox.addWidget(self.increaseAbutton)

        hbox = QtGui.QHBoxLayout()
        hbox.setMargin(10)
        mainLayout.addLayout(hbox)

        self.teamBScoreLabel = QtGui.QLabel()
        self.teamBScoreLabel.setStyleSheet(StyleSheet.scoreLabelStyle)
        hbox.addWidget(self.teamBScoreLabel)

        hbox.addStretch(1)

        self.scoreBBox = QtGui.QLineEdit('0')
        self.scoreBBox.setReadOnly(True)
        self.scoreBBox.setStyleSheet(StyleSheet.scoreBoxStyle)
        self.scoreBBox.setMinimumHeight(45)
        self.scoreBBox.setMinimumWidth(95)
        self.scoreBBox.textChanged.connect(self.updateInstruction)
        hbox.addWidget(self.scoreBBox)

        self.increaseBbutton = QtGui.QToolButton()
        self.increaseBbutton.setToolTip("Score")
        self.increaseBbutton.setStyleSheet(StyleSheet.increaseButtonStyle)
        self.increaseBbutton.setIcon(
            QtGui.QIcon("Resources\\images\\go-up-black"))
        self.increaseBbutton.clicked.connect(self.increaseB)
        hbox.addWidget(self.increaseBbutton)

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        hbox.addStretch(1)

        self.timeElapsedLabel = QtGui.QLabel('00:00')
        self.timeElapsedLabel.setStyleSheet(StyleSheet.timeElapsedStyle)
        hbox.addWidget(self.timeElapsedLabel)

        hbox.addStretch(1)

        mainLayout.addStretch(1)

        hbox = QtGui.QHBoxLayout()
        mainLayout.addLayout(hbox)

        self.resetButton = QtGui.QPushButton("Reset")
        self.resetButton.setStyleSheet(StyleSheet.resetButtonStyle)
        self.resetButton.clicked.connect(self.reset)
        hbox.addWidget(self.resetButton)

        self.movieButton = QtGui.QPushButton("Movie")
        self.movieButton.setStyleSheet(StyleSheet.breakButtonStyle)
        self.movieButton.clicked.connect(self.showMovie)
        hbox.addWidget(self.movieButton)

        self.newButton = QtGui.QPushButton("New")
        self.newButton.setStyleSheet(StyleSheet.newButtonStyle)
        self.newButton.clicked.connect(self.newMatch)
        hbox.addWidget(self.newButton)

        hbox = QtGui.QHBoxLayout()
        hbox.setMargin(5)
        hbox.setSpacing(5)
        mainLayout.addLayout(hbox)

        label = QtGui.QLabel()
        label.setScaledContents(True)
        label.setMaximumWidth(25)
        label.setMinimumWidth(25)
        label.setMaximumHeight(25)
        label.setMinimumHeight(25)
        label.setPixmap(QtGui.QPixmap("Resources\\images\\network-wireless"))
        hbox.addWidget(label)

        self.addressLabel = QtGui.QLabel("Boadcasting on port:")
        hbox.addWidget(self.addressLabel)

        self.addressLabel = QtGui.QLabel()
        hbox.addWidget(self.addressLabel)

        self.timeElapsed = 0
        self.animation = 0

        self.tcpServer = QtNetwork.QTcpServer(self)
        if not self.tcpServer.listen():
            QtGui.QMessageBox.critical(self, "Rematch",
                                      "Unable to start the server: {0}.".format(self.tcpServer.errorString()))
            self.close()
        self.tcpServer.newConnection.connect(self.sendInstruction)

        self.addressLabel.setText(str(self.tcpServer.serverPort()))
        hbox.addStretch(1)

        self.settingsList = self.settingsDialog.settingsList

        self.updateInstruction()

    def closeEvent(self, event):
        reply = QtGui.QMessageBox.warning(self, "Close",
                                         "Do you really want to quit?",
                                         QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()

    def increaseA(self):
        if self.timer.isActive():
            self.scoreABox.setText(str(int(self.scoreABox.text()) + 1))
        else:
            message = QtGui.QMessageBox.information(
                self, "Rematch", "No match in progress.")

    def increaseB(self):
        if self.timer.isActive():
            self.scoreBBox.setText(str(int(self.scoreBBox.text()) + 1))
        else:
            message = QtGui.QMessageBox.information(
                self, "Rematch", "No match in progress.")

    def updateInstruction(self):
        teamA = self.teamAScoreLabel.text()
        scoreA = self.scoreABox.text()
        teamB = self.teamBScoreLabel.text()
        scoreB = self.scoreBBox.text()
        elapsedTime = str(self.timeElapsedLabel.text())
        animation = str(self.animation)

        self.instruction = \
            teamA + '#' + \
            scoreA +  '#' + \
            teamB +  '#' + \
            scoreB +  '#' + \
            elapsedTime +  '#' + \
            animation +  '#' + \
            str(self.settingsList[0])  +  '#' + \
            str(self.settingsList[1])  +  '#' + \
            str(self.settingsList[2])

    def sendInstruction(self):
        block = QtCore.QByteArray()
        out = QtCore.QDataStream(block, QtCore.QIODevice.WriteOnly)
        out.setVersion(QtCore.QDataStream.Qt_4_0)
        out.writeUInt16(0)

        try:
            # Python v3.
            instruction = bytes(self.instruction, encoding='ascii')
        except:
            # Python v2.
            print("Error")

        out.writeString(instruction)
        out.device().seek(0)
        out.writeUInt16(block.size() - 2)

        clientConnection = self.tcpServer.nextPendingConnection()
        clientConnection.disconnected.connect(clientConnection.deleteLater)

        clientConnection.write(block)
        clientConnection.disconnectFromHost()

        if self.animation == 1:
            self.animation = 0
            self.updateInstruction()

    def clear(self):
        self.timer.stop()
        self.scoreABox.setText('0')
        self.scoreBBox.setText('0')
        self.pauseButton.hide()
        self.playButton.show()
        self.teamAScoreLabel.clear()
        self.teamBScoreLabel.clear()
        self.timeElapsed = 0
        self.animation = 0
        self.timeElapsedLabel.setText("00:00")

        self.updateInstruction()

    def reset(self):
        reply = QtGui.QMessageBox.warning(self, "Restart",
                                         "This will clear the current match for a new one!\n\n Proceed?",
                                         QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            self.clear()
        else:
            return

    def showMovie(self):
        self.animation = 1
        self.updateInstruction()

    def play(self):
        if self.teamBScoreLabel.text().strip() == '':
            message = QtGui.QMessageBox.information(
                self, "Play", "You may have to set up the teams first.")
            return
        self.playButton.hide()
        self.pauseButton.show()
        self.timer.start()
        
    def formatNumber(self, numString):
        if len(numString) == 1:
            return '0' + numString
        else:
            return numString

    def increaseElapsedTime(self):
        self.timeElapsed += 1
    
        if self.timeElapsed >= 60:
            min = int(self.timeElapsed / 60)
            sec = int(self.timeElapsed - (60 * min))
            
            min = self.formatNumber(str(min))
            sec = self.formatNumber(str(sec))
            elapsed = "{0}:{1}".format(min, sec)
        else:
            sec = self.formatNumber(str(self.timeElapsed))
            elapsed = '00:{0}'.format(sec)
        
        self.timeElapsedLabel.setText(elapsed)
        self.updateInstruction()

    def stop(self):
        self.timer.stop()
        self.pauseButton.hide()
        self.playButton.show()

    def newMatch(self):
        if self.teamAScoreLabel.text() != '':
            reply = QtGui.QMessageBox.warning(self, "New Match",
                                             "This will end the current match.\n\nProceed?",
                                             QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
            if reply == QtGui.QMessageBox.Yes:
                pass
            else:
                return
        newMatch = NewMatch(self)
        if newMatch.accepted:
            self.clear()
            self.teamAScoreLabel.setText(newMatch.matchList[0])
            self.teamBScoreLabel.setText(newMatch.matchList[1])
            self.updateInstruction()

    def updateSettings(self, settingsList):
        self.settingsList = settingsList
        self.updateInstruction()

app = QtGui.QApplication(sys.argv)
app.setStyleSheet(StyleSheet.globalStyle)

main = Rematch()
main.show()

sys.exit(app.exec_())

########NEW FILE########
__FILENAME__ = autopep8
#!/usr/bin/env python
#
# Copyright (C) 2010-2011 Hideo Hattori
# Copyright (C) 2011-2013 Hideo Hattori, Steven Myint
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

"""Automatically formats Python code to conform to the PEP 8 style guide.

Fixes that only need be done once can be added by adding a function of the form
"fix_<code>(source)" to this module. They should return the fixed source code.
These fixes are picked up by apply_global_fixes().

Fixes that depend on pep8 should be added as methods to FixPEP8. See the class
documentation for more information.

"""

from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import codecs
import copy
import fnmatch
import inspect
import os
import re
import signal
import sys
try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO
import token
import tokenize
from optparse import OptionParser
import difflib

from Xtra import pep8


try:
    unicode
except NameError:
    unicode = str


__version__ = '0.9.1'


CR = '\r'
LF = '\n'
CRLF = '\r\n'


PYTHON_SHEBANG_REGEX = re.compile(r'^#!.*\bpython[23]?\b')


# For generating line shortening candidates.
SHORTEN_OPERATOR_GROUPS = frozenset([
    frozenset([',']),
    frozenset(['%']),
    frozenset([',', '(', '[', '{']),
    frozenset([',', '(', '[', '{', '%', '+', '-', '*', '/', '//']),
])


DEFAULT_IGNORE = 'E24,W6'


def open_with_encoding(filename, encoding=None, mode='r'):
    """Return opened file with a specific encoding."""
    if not encoding:
        encoding = detect_encoding(filename)

    import io
    return io.open(filename, mode=mode, encoding=encoding,
                   newline='')  # Preserve line endings


def detect_encoding(filename):
    """Return file encoding."""
    try:
        with open(filename, 'rb') as input_file:
            from lib2to3.pgen2 import tokenize as lib2to3_tokenize
            encoding = lib2to3_tokenize.detect_encoding(input_file.readline)[0]

        # Check for correctness of encoding
        with open_with_encoding(filename, encoding) as test_file:
            test_file.read()

        return encoding
    except (LookupError, SyntaxError, UnicodeDecodeError):
        return 'latin-1'


def read_from_filename(filename, readlines=False):
    """Return contents of file."""
    with open_with_encoding(filename) as input_file:
        return input_file.readlines() if readlines else input_file.read()


def extended_blank_lines(logical_line,
                         blank_lines,
                         indent_level,
                         previous_logical):
    """Check for missing blank lines after class declaration."""
    if (previous_logical.startswith('class ')):
        if (logical_line.startswith(('def ', 'class ', '@')) or
                pep8.DOCSTRING_REGEX.match(logical_line)):
            if indent_level and not blank_lines:
                yield (0, 'E301 expected 1 blank line, found 0')
    elif previous_logical.startswith('def '):
        if blank_lines and pep8.DOCSTRING_REGEX.match(logical_line):
            yield (0, 'E303 too many blank lines ({0})'.format(blank_lines))
    elif pep8.DOCSTRING_REGEX.match(previous_logical):
        if (
            indent_level and
            not blank_lines and
            logical_line.startswith(('def ')) and
            '(self' in logical_line
        ):
            yield (0, 'E301 expected 1 blank line, found 0')
pep8.register_check(extended_blank_lines)


class FixPEP8(object):

    """Fix invalid code.

    Fixer methods are prefixed "fix_". The _fix_source() method looks for these
    automatically.

    The fixer method can take either one or two arguments (in addition to
    self). The first argument is "result", which is the error information from
    pep8. The second argument, "logical", is required only for logical-line
    fixes.

    The fixer method can return the list of modified lines or None. An empty
    list would mean that no changes were made. None would mean that only the
    line reported in the pep8 error was modified. Note that the modified line
    numbers that are returned are indexed at 1. This typically would correspond
    with the line number reported in the pep8 error information.

    [fixed method list]
        - e111
        - e121,e122,e123,e124,e125,e126,e127,e128,e129
        - e201,e202,e203
        - e211
        - e221,e222,e223,e224,e225
        - e231
        - e251
        - e261,e262
        - e271,e272,e273,e274
        - e301,e302,e303
        - e401
        - e502
        - e701,e702
        - e711
        - w291,w293
        - w391

    """

    def __init__(self, filename, options, contents=None):
        self.filename = filename
        if contents is None:
            self.source = read_from_filename(filename, readlines=True)
        else:
            sio = StringIO(contents)
            self.source = sio.readlines()
        self.newline = find_newline(self.source)
        self.options = options
        self.indent_word = _get_indentword(''.join(self.source))

        # method definition
        self.fix_e111 = self.fix_e101
        self.fix_e128 = self.fix_e127
        self.fix_e129 = self.fix_e125
        self.fix_e202 = self.fix_e201
        self.fix_e203 = self.fix_e201
        self.fix_e211 = self.fix_e201
        self.fix_e221 = self.fix_e271
        self.fix_e222 = self.fix_e271
        self.fix_e223 = self.fix_e271
        self.fix_e226 = self.fix_e225
        self.fix_e227 = self.fix_e225
        self.fix_e228 = self.fix_e225
        self.fix_e241 = self.fix_e271
        self.fix_e242 = self.fix_e224
        self.fix_e261 = self.fix_e262
        self.fix_e272 = self.fix_e271
        self.fix_e273 = self.fix_e271
        self.fix_e274 = self.fix_e271
        self.fix_e703 = self.fix_e702
        self.fix_w191 = self.fix_e101

    def _fix_source(self, results):
        completed_lines = set()
        for result in sorted(results, key=_priority_key):
            if result['line'] in completed_lines:
                continue

            fixed_methodname = 'fix_%s' % result['id'].lower()
            if hasattr(self, fixed_methodname):
                fix = getattr(self, fixed_methodname)

                is_logical_fix = len(inspect.getargspec(fix).args) > 2
                if is_logical_fix:
                    # Do not run logical fix if any lines have been modified.
                    if completed_lines:
                        continue

                    logical = self._get_logical(result)
                    if not logical:
                        continue

                    modified_lines = fix(result, logical)
                else:
                    modified_lines = fix(result)

                if modified_lines:
                    completed_lines.update(modified_lines)
                elif modified_lines == []:  # Empty list means no fix
                    if self.options.verbose >= 2:
                        print(
                            '--->  Not fixing {f} on line {l}'.format(
                                f=result['id'], l=result['line']),
                            file=sys.stderr)
                else:  # We assume one-line fix when None
                    completed_lines.add(result['line'])
            else:
                if self.options.verbose >= 3:
                    print("--->  '%s' is not defined." % fixed_methodname,
                          file=sys.stderr)
                    info = result['info'].strip()
                    print('--->  %s:%s:%s:%s' % (self.filename,
                                                 result['line'],
                                                 result['column'],
                                                 info),
                          file=sys.stderr)

    def fix(self):
        """Return a version of the source code with PEP 8 violations fixed."""
        pep8_options = {
            'ignore': self.options.ignore,
            'select': self.options.select,
            'max_line_length': self.options.max_line_length,
        }
        results = _execute_pep8(pep8_options, self.source)

        if self.options.verbose:
            progress = {}
            for r in results:
                if r['id'] not in progress:
                    progress[r['id']] = set()
                progress[r['id']].add(r['line'])
            print('--->  {n} issue(s) to fix {progress}'.format(
                n=len(results), progress=progress), file=sys.stderr)

        self._fix_source(filter_results(source=''.join(self.source),
                                        results=results,
                                        aggressive=self.options.aggressive))
        return ''.join(self.source)

    def fix_e101(self, _):
        """Reindent all lines."""
        reindenter = Reindenter(self.source, self.newline)
        modified_line_numbers = reindenter.run()
        if modified_line_numbers:
            self.source = reindenter.fixed_lines()
            return modified_line_numbers
        else:
            return []

    def _find_logical(self):
        # make a variable which is the index of all the starts of lines
        logical_start = []
        logical_end = []
        last_newline = True
        sio = StringIO(''.join(self.source))
        parens = 0
        for t in tokenize.generate_tokens(sio.readline):
            if t[0] in [tokenize.COMMENT, tokenize.DEDENT,
                        tokenize.INDENT, tokenize.NL,
                        tokenize.ENDMARKER]:
                continue
            if not parens and t[0] in [
                tokenize.NEWLINE, tokenize.SEMI
            ]:
                last_newline = True
                logical_end.append((t[3][0] - 1, t[2][1]))
                continue
            if last_newline and not parens:
                logical_start.append((t[2][0] - 1, t[2][1]))
                last_newline = False
            if t[0] == tokenize.OP:
                if t[1] in '([{':
                    parens += 1
                elif t[1] in '}])':
                    parens -= 1
        return (logical_start, logical_end)

    def _get_logical(self, result):
        """Return the logical line corresponding to the result.

        Assumes input is already E702-clean.

        """
        try:
            (logical_start, logical_end) = self._find_logical()
        except (SyntaxError, tokenize.TokenError):
            return None

        row = result['line'] - 1
        col = result['column'] - 1
        ls = None
        le = None
        for i in range(0, len(logical_start), 1):
            x = logical_end[i]
            if x[0] > row or (x[0] == row and x[1] > col):
                le = x
                ls = logical_start[i]
                break
        if ls is None:
            return None
        original = self.source[ls[0]:le[0] + 1]
        return ls, le, original

    def _fix_reindent(self, result, logical):
        """Fix a badly indented line.

        This is done by adding or removing from its initial indent only.

        """
        assert logical
        ls, _, original = logical

        rewrapper = Wrapper(original)
        valid_indents = rewrapper.pep8_expected()
        if not rewrapper.rel_indent:
            return []  # pragma: no cover
        if result['line'] > ls[0]:
            # got a valid continuation line number from pep8
            row = result['line'] - ls[0] - 1
            # always pick the first option for this
            valid = valid_indents[row]
            got = rewrapper.rel_indent[row]
        else:
            return []  # pragma: no cover
        line = ls[0] + row
        # always pick the expected indent, for now.
        indent_to = valid[0]

        if got != indent_to:
            orig_line = self.source[line]
            new_line = ' ' * (indent_to) + orig_line.lstrip()
            if new_line == orig_line:
                return []
            else:
                self.source[line] = new_line
                return [line + 1]  # Line indexed at 1
        else:
            return []  # pragma: no cover

    def fix_e121(self, result, logical):
        """Fix indentation to be a multiple of four."""
        # Fix by adjusting initial indent level.
        return self._fix_reindent(result, logical)

    def fix_e122(self, result, logical):
        """Add absent indentation for hanging indentation."""
        # Fix by adding an initial indent.
        return self._fix_reindent(result, logical)

    def fix_e123(self, result, logical):
        """Align closing bracket to match opening bracket."""
        # Fix by deleting whitespace to the correct level.
        assert logical
        logical_lines = logical[2]
        line_index = result['line'] - 1
        original_line = self.source[line_index]

        fixed_line = (_get_indentation(logical_lines[0]) +
                      original_line.lstrip())
        if fixed_line == original_line:
            # Fall back to slower method.
            return self._fix_reindent(result, logical)
        else:
            self.source[line_index] = fixed_line

    def fix_e124(self, result, logical):
        """Align closing bracket to match visual indentation."""
        # Fix by inserting whitespace before the closing bracket.
        return self._fix_reindent(result, logical)

    def fix_e125(self, result, logical):
        """Indent to distinguish line from next logical line."""
        # Fix by indenting the line in error to the next stop.
        modified_lines = self._fix_reindent(result, logical)
        if modified_lines:
            return modified_lines
        else:
            # Fallback
            line_index = result['line'] - 1
            original_line = self.source[line_index]
            self.source[line_index] = self.indent_word + original_line

    def fix_e126(self, result, logical):
        """Fix over-indented hanging indentation."""
        # fix by deleting whitespace to the left
        assert logical
        logical_lines = logical[2]
        line_index = result['line'] - 1
        original = self.source[line_index]

        fixed = (_get_indentation(logical_lines[0]) +
                 self.indent_word + original.lstrip())
        if fixed == original:
            # Fall back to slower method.
            return self._fix_reindent(result, logical)  # pragma: no cover
        else:
            self.source[line_index] = fixed

    def fix_e127(self, result, logical):
        """Fix visual indentation."""
        # Fix by inserting/deleting whitespace to the correct level.
        modified_lines = self._align_visual_indent(result, logical)
        if modified_lines != []:
            return modified_lines
        else:
            # Fall back to slower method.
            return self._fix_reindent(result, logical)

    def _align_visual_indent(self, result, logical):
        """Correct visual indent.

        This includes over (E127) and under (E128) indented lines.

        """
        assert logical
        logical_lines = logical[2]
        line_index = result['line'] - 1
        original = self.source[line_index]
        fixed = original

        if logical_lines[0].rstrip().endswith('\\'):
            fixed = (_get_indentation(logical_lines[0]) +
                     self.indent_word + original.lstrip())
        else:
            start_index = None
            for symbol in '([{':
                if symbol in logical_lines[0]:
                    found_index = logical_lines[0].find(symbol)
                    if start_index is None:
                        start_index = found_index
                    else:
                        start_index = min(start_index, found_index)

            if start_index is not None:
                fixed = start_index * ' ' + original.lstrip()

        if fixed == original:
            return []
        else:
            self.source[line_index] = fixed

    def fix_e201(self, result):
        """Remove extraneous whitespace."""
        line_index = result['line'] - 1
        target = self.source[line_index]
        offset = result['column'] - 1

        # When multiline strings are involved, pep8 reports the error as
        # being at the start of the multiline string, which doesn't work
        # for us.
        if ('"""' in target or
            "'''" in target or
                target.rstrip().endswith('\\')):
            return []

        fixed = fix_whitespace(target,
                               offset=offset,
                               replacement='')

        if fixed == target:
            return []
        else:
            self.source[line_index] = fixed

    def fix_e224(self, result):
        """Remove extraneous whitespace around operator."""
        target = self.source[result['line'] - 1]
        offset = result['column'] - 1
        fixed = target[:offset] + target[offset:].replace('\t', ' ')
        self.source[result['line'] - 1] = fixed

    def fix_e225(self, result):
        """Fix missing whitespace around operator."""
        target = self.source[result['line'] - 1]
        offset = result['column'] - 1
        fixed = target[:offset] + ' ' + target[offset:]

        # Only proceed if non-whitespace characters match.
        # And make sure we don't break the indentation.
        if (fixed.replace(' ', '') == target.replace(' ', '') and
                _get_indentation(fixed) == _get_indentation(target)):
            self.source[result['line'] - 1] = fixed
        else:
            return []

    def fix_e231(self, result):
        """Add missing whitespace."""
        # Optimize for comma case. This will fix all commas in the full source
        # code in one pass.
        if ',' in result['info']:
            original = ''.join(self.source)
            new = refactor(original, ['ws_comma'])
            if original.strip() != new.strip():
                self.source = [new]
                return range(1, 1 + len(original))

        line_index = result['line'] - 1
        target = self.source[line_index]
        offset = result['column']
        fixed = target[:offset] + ' ' + target[offset:]
        self.source[line_index] = fixed

    def fix_e251(self, result):
        """Remove whitespace around parameter '=' sign."""
        line_index = result['line'] - 1
        target = self.source[line_index]

        # This is necessary since pep8 sometimes reports columns that goes
        # past the end of the physical line. This happens in cases like,
        # foo(bar\n=None)
        c = min(result['column'] - 1,
                len(target) - 1)

        if target[c].strip():
            fixed = target
        else:
            fixed = target[:c].rstrip() + target[c:].lstrip()

        # There could be an escaped newline
        #
        #     def foo(a=\
        #             1)
        if (fixed.endswith('=\\\n') or
                fixed.endswith('=\\\r\n') or
                fixed.endswith('=\\\r')):
            self.source[line_index] = fixed.rstrip('\n\r \t\\')
            self.source[line_index + 1] = self.source[line_index + 1].lstrip()
            return [line_index + 1, line_index + 2]  # Line indexed at 1

        self.source[result['line'] - 1] = fixed

    def fix_e262(self, result):
        """Fix spacing after comment hash."""
        target = self.source[result['line'] - 1]
        offset = result['column']

        code = target[:offset].rstrip(' \t#')
        comment = target[offset:].lstrip(' \t#')

        fixed = code + ('  # ' + comment if comment.strip()
                        else self.newline)

        self.source[result['line'] - 1] = fixed

    def fix_e271(self, result):
        """Fix extraneous whitespace around keywords."""
        line_index = result['line'] - 1
        target = self.source[line_index]
        offset = result['column'] - 1

        # When multiline strings are involved, pep8 reports the error as
        # being at the start of the multiline string, which doesn't work
        # for us.
        if ('"""' in target or
            "'''" in target or
                target.rstrip().endswith('\\')):
            return []

        fixed = fix_whitespace(target,
                               offset=offset,
                               replacement=' ')

        if fixed == target:
            return []
        else:
            self.source[line_index] = fixed

    def fix_e301(self, result):
        """Add missing blank line."""
        cr = self.newline
        self.source[result['line'] - 1] = cr + self.source[result['line'] - 1]

    def fix_e302(self, result):
        """Add missing 2 blank lines."""
        add_linenum = 2 - int(result['info'].split()[-1])
        cr = self.newline * add_linenum
        self.source[result['line'] - 1] = cr + self.source[result['line'] - 1]

    def fix_e303(self, result):
        """Remove extra blank lines."""
        delete_linenum = int(result['info'].split('(')[1].split(')')[0]) - 2
        delete_linenum = max(1, delete_linenum)

        # We need to count because pep8 reports an offset line number if there
        # are comments.
        cnt = 0
        line = result['line'] - 2
        modified_lines = []
        while cnt < delete_linenum and line >= 0:
            if not self.source[line].strip():
                self.source[line] = ''
                modified_lines.append(1 + line)  # Line indexed at 1
                cnt += 1
            line -= 1

        return modified_lines

    def fix_e304(self, result):
        """Remove blank line following function decorator."""
        line = result['line'] - 2
        if not self.source[line].strip():
            self.source[line] = ''

    def fix_e401(self, result):
        """Put imports on separate lines."""
        line_index = result['line'] - 1
        target = self.source[line_index]
        offset = result['column'] - 1

        if not target.lstrip().startswith('import'):
            return []

        # pep8 (1.3.1) reports false positive if there is an import statement
        # followed by a semicolon and some unrelated statement with commas in
        # it.
        if ';' in target:
            return []

        indentation = re.split(pattern=r'\bimport\b',
                               string=target, maxsplit=1)[0]
        fixed = (target[:offset].rstrip('\t ,') + self.newline +
                 indentation + 'import ' + target[offset:].lstrip('\t ,'))
        self.source[line_index] = fixed

    def fix_e501(self, result):
        """Try to make lines fit within --max-line-length characters."""
        line_index = result['line'] - 1
        target = self.source[line_index]

        if target.lstrip().startswith('#'):
            # Shorten comment if it is the last comment line.
            try:
                if self.source[line_index + 1].lstrip().startswith('#'):
                    return []
            except IndexError:
                pass

            # Wrap commented lines.
            fixed = shorten_comment(
                line=target,
                newline=self.newline,
                max_line_length=self.options.max_line_length)
            if fixed == self.source[line_index]:
                return []
            else:
                self.source[line_index] = fixed
                return

        indent = _get_indentation(target)
        source = target[len(indent):]
        assert source.lstrip() == source
        sio = StringIO(source)

        # Check for multiline string.
        try:
            tokens = list(tokenize.generate_tokens(sio.readline))
        except (SyntaxError, tokenize.TokenError):
            multiline_candidate = break_multiline(
                target, newline=self.newline,
                indent_word=self.indent_word)

            if multiline_candidate:
                self.source[line_index] = multiline_candidate
                return
            else:
                return []

        candidates = shorten_line(
            tokens, source, indent,
            self.indent_word, newline=self.newline,
            aggressive=self.options.aggressive)

        candidates = list(sorted(
            set(candidates),
            key=lambda x: line_shortening_rank(x,
                                               self.newline,
                                               self.indent_word)))

        if self.options.verbose >= 4:
            print(('-' * 79 + '\n').join([''] + candidates + ['']),
                  file=codecs.getwriter('utf-8')(sys.stderr.buffer
                                                 if hasattr(sys.stderr,
                                                            'buffer')
                                                 else sys.stderr))

        for _candidate in candidates:
            assert _candidate is not None

            if (get_longest_length(_candidate, self.newline) >=
                    get_longest_length(target, self.newline)):
                continue

            self.source[line_index] = _candidate
            return

        return []

    def fix_e502(self, result):
        """Remove extraneous escape of newline."""
        line_index = result['line'] - 1
        target = self.source[line_index]
        self.source[line_index] = target.rstrip('\n\r \t\\') + self.newline

    def fix_e701(self, result):
        """Put colon-separated compound statement on separate lines."""
        line_index = result['line'] - 1
        target = self.source[line_index]
        c = result['column']

        fixed_source = (target[:c] + self.newline +
                        _get_indentation(target) + self.indent_word +
                        target[c:].lstrip('\n\r \t\\'))
        self.source[result['line'] - 1] = fixed_source

    def fix_e702(self, result, logical):
        """Put semicolon-separated compound statement on separate lines."""
        logical_lines = logical[2]

        line_index = result['line'] - 1
        target = self.source[line_index]

        if target.rstrip().endswith('\\'):
            # Normalize '1; \\\n2' into '1; 2'.
            self.source[line_index] = target.rstrip('\n \r\t\\')
            self.source[line_index + 1] = self.source[line_index + 1].lstrip()
            return [line_index + 1, line_index + 2]

        if target.rstrip().endswith(';'):
            self.source[line_index] = target.rstrip('\n \r\t;') + self.newline
            return

        offset = result['column'] - 1
        first = target[:offset].rstrip(';').rstrip()
        second = (_get_indentation(logical_lines[0]) +
                  target[offset:].lstrip(';').lstrip())

        self.source[line_index] = first + self.newline + second

    def fix_e711(self, result):
        """Fix comparison with None."""
        line_index = result['line'] - 1
        target = self.source[line_index]
        offset = result['column'] - 1

        right_offset = offset + 2
        if right_offset >= len(target):
            return []

        left = target[:offset].rstrip()
        center = target[offset:right_offset]
        right = target[right_offset:].lstrip()

        if not right.startswith('None'):
            return []

        if center.strip() == '==':
            new_center = 'is'
        elif center.strip() == '!=':
            new_center = 'is not'
        else:
            return []

        self.source[line_index] = ' '.join([left, new_center, right])

    def fix_e712(self, result):
        """Fix comparison with boolean."""
        line_index = result['line'] - 1
        target = self.source[line_index]
        offset = result['column'] - 1

        right_offset = offset + 2
        if right_offset >= len(target):
            return []

        left = target[:offset].rstrip()
        center = target[offset:right_offset]
        right = target[right_offset:].lstrip()

        # Handle simple cases only.
        new_right = None
        if center.strip() == '==':
            if re.match(r'\bTrue\b', right):
                new_right = re.sub(r'\bTrue\b *', '', right, count=1)
        elif center.strip() == '!=':
            if re.match(r'\bFalse\b', right):
                new_right = re.sub(r'\bFalse\b *', '', right, count=1)

        if new_right is None:
            return []

        if new_right[0].isalnum():
            new_right = ' ' + new_right

        self.source[line_index] = left + new_right

    def fix_w291(self, result):
        """Remove trailing whitespace."""
        fixed_line = self.source[result['line'] - 1].rstrip()
        self.source[result['line'] - 1] = '%s%s' % (fixed_line, self.newline)

    def fix_w293(self, result):
        """Remove trailing whitespace on blank line."""
        assert not self.source[result['line'] - 1].strip()
        self.source[result['line'] - 1] = self.newline

    def fix_w391(self, _):
        """Remove trailing blank lines."""
        blank_count = 0
        for line in reversed(self.source):
            line = line.rstrip()
            if line:
                break
            else:
                blank_count += 1

        original_length = len(self.source)
        self.source = self.source[:original_length - blank_count]
        return range(1, 1 + original_length)


def fix_e26(source):
    """Format block comments."""
    if '#' not in source:
        # Optimization.
        return source

    string_line_numbers = multiline_string_lines(source,
                                                 include_docstrings=True)
    fixed_lines = []
    sio = StringIO(source)
    for (line_number, line) in enumerate(sio.readlines(), start=1):
        if (line.lstrip().startswith('#') and
                line_number not in string_line_numbers):

            indentation = _get_indentation(line)
            line = line.lstrip()

            # Normalize beginning if not a shebang.
            if len(line) > 1:
                # Leave multiple spaces like '#    ' alone.
                if line.count('#') > 1 or line[1].isalnum():
                    line = '# ' + line.lstrip('# \t')

            fixed_lines.append(indentation + line)
        else:
            fixed_lines.append(line)

    return ''.join(fixed_lines)


def refactor(source, fixer_names, ignore=None):
    """Return refactored code using lib2to3.

    Skip if ignore string is produced in the refactored code.

    """
    from lib2to3 import pgen2
    try:
        new_text = refactor_with_2to3(source,
                                      fixer_names=fixer_names)
    except (pgen2.parse.ParseError,
            SyntaxError,
            UnicodeDecodeError,
            UnicodeEncodeError):
        return source

    if ignore:
        if ignore in new_text and ignore not in source:
            return source

    return new_text


def fix_w602(source):
    """Fix deprecated form of raising exception."""
    return refactor(source, ['raise'],
                    ignore='with_traceback')


def fix_w6(source):
    """Fix various deprecated code (via lib2to3)."""
    return refactor(source,
                    ['apply',
                     'except',
                     'exec',
                     'execfile',
                     'exitfunc',
                     'has_key',
                     'idioms',
                     'import',
                     'methodattrs',  # Python >= 2.6
                     'ne',
                     'numliterals',
                     'operator',
                     'paren',
                     'reduce',
                     'renames',
                     'repr',
                     'standarderror',
                     'sys_exc',
                     'throw',
                     'tuple_params',
                     'types',
                     'xreadlines'])


def find_newline(source):
    """Return type of newline used in source."""
    cr, lf, crlf = 0, 0, 0
    for s in source:
        if s.endswith(CRLF):
            crlf += 1
        elif s.endswith(CR):
            cr += 1
        elif s.endswith(LF):
            lf += 1
    _max = max(lf, cr, crlf)
    if _max == lf:
        return LF
    elif _max == crlf:
        return CRLF
    else:
        return CR


def _get_indentword(source):
    """Return indentation type."""
    sio = StringIO(source)
    indent_word = '    '  # Default in case source has no indentation
    try:
        for t in tokenize.generate_tokens(sio.readline):
            if t[0] == token.INDENT:
                indent_word = t[1]
                break
    except (SyntaxError, tokenize.TokenError):
        pass
    return indent_word


def _get_indentation(line):
    """Return leading whitespace."""
    if line.strip():
        non_whitespace_index = len(line) - len(line.lstrip())
        return line[:non_whitespace_index]
    else:
        return ''


def get_diff_text(old, new, filename):
    """Return text of unified diff between old and new."""
    newline = '\n'
    diff = difflib.unified_diff(
        old, new,
        'original/' + filename,
        'fixed/' + filename,
        lineterm=newline)

    text = ''
    for line in diff:
        text += line

        # Work around missing newline (http://bugs.python.org/issue2142).
        if not line.endswith(newline):
            text += newline + r'\ No newline at end of file' + newline

    return text


def _priority_key(pep8_result):
    """Key for sorting PEP8 results.

    Global fixes should be done first. This is important for things
    like indentation.

    """
    priority = [
        # Global fixes.
        'e101', 'e111', 'w191',
        # Fix multiline colon-based before semicolon based.
        'e701',
        # Break multiline statements early.
        'e702',
        # Things that make lines longer.
        'e225', 'e231',
        # Remove extraneous whitespace before breaking lines.
        'e201',
        # Before breaking lines.
        'e121', 'e122', 'e123', 'e124', 'e125', 'e126', 'e127', 'e128', 'e129',
    ]
    key = pep8_result['id'].lower()
    if key in priority:
        return priority.index(key)
    else:
        # Lowest priority
        return len(priority)


def shorten_line(tokens, source, indentation, indent_word, newline,
                 aggressive=False):
    """Separate line at OPERATOR.

    Multiple candidates will be yielded.

    """
    for candidate in _shorten_line(tokens=tokens,
                                   source=source,
                                   indentation=indentation,
                                   indent_word=indent_word,
                                   newline=newline,
                                   aggressive=aggressive):
        yield candidate

    if aggressive:
        for key_token_strings in SHORTEN_OPERATOR_GROUPS:
            shortened = _shorten_line_at_tokens(
                tokens=tokens,
                source=source,
                indentation=indentation,
                indent_word=indent_word,
                newline=newline,
                key_token_strings=key_token_strings,
                aggressive=aggressive)

            if shortened is not None and shortened != source:
                yield shortened


def _shorten_line(tokens, source, indentation, indent_word, newline,
                  aggressive=False):
    """Separate line at OPERATOR.

    Multiple candidates will be yielded.

    """
    for tkn in tokens:
        # Don't break on '=' after keyword as this violates PEP 8.
        if token.OP == tkn[0] and tkn[1] != '=':
            assert tkn[0] != token.INDENT

            offset = tkn[2][1] + 1
            first = source[:offset]

            second_indent = indentation
            if first.rstrip().endswith('('):
                second_indent += indent_word
            elif '(' in first:
                second_indent += ' ' * (1 + first.find('('))
            else:
                second_indent += indent_word

            second = (second_indent + source[offset:].lstrip())
            if not second.strip():
                continue

            # Do not begin a line with a comma
            if second.lstrip().startswith(','):
                continue
            # Do end a line with a dot
            if first.rstrip().endswith('.'):
                continue
            if tkn[1] in '+-*/':
                fixed = first + ' \\' + newline + second
            else:
                fixed = first + newline + second

            # Only fix if syntax is okay.
            if check_syntax(normalize_multiline(fixed, newline=newline)
                            if aggressive else fixed):
                yield indentation + fixed


def _shorten_line_at_tokens(tokens, source, indentation, indent_word, newline,
                            key_token_strings, aggressive):
    """Separate line by breaking at tokens in key_token_strings.

    This will always break the line at the first parenthesis.

    """
    offsets = []
    first_paren = True
    for tkn in tokens:
        token_type = tkn[0]
        token_string = tkn[1]
        next_offset = tkn[2][1] + 1

        assert token_type != token.INDENT

        if token_string in key_token_strings or (first_paren and
                                                 token_string == '('):
            # Don't split right before newline.
            if next_offset < len(source) - 1:
                offsets.append(next_offset)

            if token_string == '(':
                first_paren = False

    current_indent = None
    fixed = None
    for line in split_at_offsets(source, offsets):
        if fixed:
            fixed += newline + current_indent + line

            for symbol in '([{':
                if line.endswith(symbol):
                    current_indent += indent_word
        else:
            # First line.
            fixed = line
            assert not current_indent
            current_indent = indent_word

    assert fixed is not None

    if check_syntax(normalize_multiline(fixed, newline=newline)
                    if aggressive > 1 else fixed):
        return indentation + fixed
    else:
        return None


def normalize_multiline(line, newline):
    """Remove multiline-related code that will cause syntax error.

    This is for purposes of checking syntax.

    """
    for quote in '\'"':
        dict_pattern = r'^{q}[^{q}]*{q} *: *'.format(q=quote)
        if re.match(dict_pattern, line):
            if not line.strip().endswith('}'):
                line += '}'
            return '{' + line

    if line.startswith('def ') and line.rstrip().endswith(':'):
        # Do not allow ':' to be alone. That is invalid.
        split_line = [item.strip() for item in line.split(newline)]
        if ':' not in split_line and 'def' not in split_line:
            return line[len('def'):].strip().rstrip(':')

    return line


def fix_whitespace(line, offset, replacement):
    """Replace whitespace at offset and return fixed line."""
    # Replace escaped newlines too
    left = line[:offset].rstrip('\n\r \t\\')
    right = line[offset:].lstrip('\n\r \t\\')
    if right.startswith('#'):
        return line
    else:
        return left + replacement + right


def _execute_pep8(pep8_options, source):
    """Execute pep8 via python method calls."""
    class QuietReport(pep8.BaseReport):

        """Version of checker that does not print."""

        def __init__(self, options):
            super(QuietReport, self).__init__(options)
            self.__full_error_results = []

        def error(self, line_number, offset, text, _):
            """Collect errors."""
            code = super(QuietReport, self).error(line_number, offset, text, _)
            if code:
                self.__full_error_results.append(
                    {'id': code,
                     'line': line_number,
                     'column': offset + 1,
                     'info': text})

        def full_error_results(self):
            """Return error results in detail.

            Results are in the form of a list of dictionaries. Each dictionary
            contains 'id', 'line', 'column', and 'info'.

            """
            return self.__full_error_results

    checker = pep8.Checker('', lines=source,
                           reporter=QuietReport, **pep8_options)
    checker.check_all()
    return checker.report.full_error_results()


class Reindenter(object):

    """Reindents badly-indented code to uniformly use four-space indentation.

    Released to the public domain, by Tim Peters, 03 October 2000.

    """

    def __init__(self, input_text, newline):
        self.newline = newline

        # Raw file lines.
        self.raw = input_text
        self.after = None

        self.string_content_line_numbers = multiline_string_lines(
            ''.join(self.raw))

        # File lines, rstripped & tab-expanded. Dummy at start is so
        # that we can use tokenize's 1-based line numbering easily.
        # Note that a line is all-blank iff it is a newline.
        self.lines = []
        for line_number, line in enumerate(self.raw, start=1):
            # Do not modify if inside a multiline string.
            if line_number in self.string_content_line_numbers:
                self.lines.append(line)
            else:
                # Only expand leading tabs.
                self.lines.append(_get_indentation(line).expandtabs() +
                                  line.strip() + newline)

        self.lines.insert(0, None)
        self.index = 1  # index into self.lines of next line

    def run(self):
        """Fix indentation and return modified line numbers.

        Line numbers are indexed at 1.

        """
        try:
            stats = reindent_stats(tokenize.generate_tokens(self.getline))
        except (SyntaxError, tokenize.TokenError):
            return set()
        # Remove trailing empty lines.
        lines = self.lines
        while lines and lines[-1] == self.newline:
            lines.pop()
        # Sentinel.
        stats.append((len(lines), 0))
        # Map count of leading spaces to # we want.
        have2want = {}
        # Program after transformation.
        after = self.after = []
        # Copy over initial empty lines -- there's nothing to do until
        # we see a line with *something* on it.
        i = stats[0][0]
        after.extend(lines[1:i])
        for i in range(len(stats) - 1):
            thisstmt, thislevel = stats[i]
            nextstmt = stats[i + 1][0]
            have = _leading_space_count(lines[thisstmt])
            want = thislevel * 4
            if want < 0:
                # A comment line.
                if have:
                    # An indented comment line. If we saw the same
                    # indentation before, reuse what it most recently
                    # mapped to.
                    want = have2want.get(have, -1)
                    if want < 0:
                        # Then it probably belongs to the next real stmt.
                        for j in range(i + 1, len(stats) - 1):
                            jline, jlevel = stats[j]
                            if jlevel >= 0:
                                if have == _leading_space_count(lines[jline]):
                                    want = jlevel * 4
                                break
                    if want < 0:           # Maybe it's a hanging
                                           # comment like this one,
                        # in which case we should shift it like its base
                        # line got shifted.
                        for j in range(i - 1, -1, -1):
                            jline, jlevel = stats[j]
                            if jlevel >= 0:
                                want = (have + _leading_space_count(
                                        after[jline - 1]) -
                                        _leading_space_count(lines[jline]))
                                break
                    if want < 0:
                        # Still no luck -- leave it alone.
                        want = have
                else:
                    want = 0
            assert want >= 0
            have2want[have] = want
            diff = want - have
            if diff == 0 or have == 0:
                after.extend(lines[thisstmt:nextstmt])
            else:
                for line_number, line in enumerate(lines[thisstmt:nextstmt],
                                                   start=thisstmt):
                    if line_number in self.string_content_line_numbers:
                        after.append(line)
                    elif diff > 0:
                        if line == self.newline:
                            after.append(line)
                        else:
                            after.append(' ' * diff + line)
                    else:
                        remove = min(_leading_space_count(line), -diff)
                        after.append(line[remove:])

        if self.raw == self.after:
            return set()
        else:
            return (set(range(1, 1 + len(self.raw))) -
                    self.string_content_line_numbers)

    def fixed_lines(self):
        return self.after

    def getline(self):
        """Line-getter for tokenize."""
        if self.index >= len(self.lines):
            line = ''
        else:
            line = self.lines[self.index]
            self.index += 1
        return line


def reindent_stats(tokens):
    """Return list  of (lineno, indentlevel) pairs.

    One for each stmt and comment line. indentlevel is -1 for comment lines, as
    a signal that tokenize doesn't know what to do about them; indeed, they're
    our headache!

    """
    find_stmt = 1  # next token begins a fresh stmt?
    level = 0  # current indent level
    stats = []

    for t in tokens:
        token_type = t[0]
        sline = t[2][0]
        line = t[4]

        if token_type == tokenize.NEWLINE:
            # A program statement, or ENDMARKER, will eventually follow,
            # after some (possibly empty) run of tokens of the form
            #     (NL | COMMENT)* (INDENT | DEDENT+)?
            find_stmt = 1

        elif token_type == tokenize.INDENT:
            find_stmt = 1
            level += 1

        elif token_type == tokenize.DEDENT:
            find_stmt = 1
            level -= 1

        elif token_type == tokenize.COMMENT:
            if find_stmt:
                stats.append((sline, -1))
                # but we're still looking for a new stmt, so leave
                # find_stmt alone

        elif token_type == tokenize.NL:
            pass

        elif find_stmt:
            # This is the first "real token" following a NEWLINE, so it
            # must be the first token of the next program statement, or an
            # ENDMARKER.
            find_stmt = 0
            if line:   # not endmarker
                stats.append((sline, level))

    return stats


class Wrapper(object):

    """Class for functions relating to continuation lines and line folding.

    Each instance operates on a single logical line.

    """

    SKIP_TOKENS = frozenset([
        tokenize.COMMENT, tokenize.NL, tokenize.INDENT,
        tokenize.DEDENT, tokenize.NEWLINE, tokenize.ENDMARKER
    ])

    def __init__(self, physical_lines):
        self.lines = physical_lines
        self.tokens = []
        self.rel_indent = None
        sio = StringIO(''.join(physical_lines))
        for t in tokenize.generate_tokens(sio.readline):
            if not len(self.tokens) and t[0] in self.SKIP_TOKENS:
                continue
            if t[0] != tokenize.ENDMARKER:
                self.tokens.append(t)

        self.logical_line = self.build_tokens_logical(self.tokens)

    def build_tokens_logical(self, tokens):
        """Build a logical line from a list of tokens.

        Return the logical line and a list of (offset, token) tuples. Does
        not mute strings like the version in pep8.py.

        """
        # from pep8.py with minor modifications
        logical = []
        previous = None
        for t in tokens:
            token_type, text = t[0:2]
            if token_type in self.SKIP_TOKENS:
                continue
            if previous:
                end_line, end = previous[3]
                start_line, start = t[2]
                if end_line != start_line:  # different row
                    prev_text = self.lines[end_line - 1][end - 1]
                    if prev_text == ',' or (prev_text not in '{[('
                                            and text not in '}])'):
                        logical.append(' ')
                elif end != start:  # different column
                    fill = self.lines[end_line - 1][end:start]
                    logical.append(fill)
            logical.append(text)
            previous = t
        logical_line = ''.join(logical)
        assert logical_line.lstrip() == logical_line
        assert logical_line.rstrip() == logical_line
        return logical_line

    def pep8_expected(self):
        """Replicate logic in pep8.py, to know what level to indent things to.

        Return a list of lists; each list represents valid indent levels for
        the line in question, relative from the initial indent. However, the
        first entry is the indent level which was expected.

        """
        # What follows is an adjusted version of
        # pep8.py:continuation_line_indentation. All of the comments have been
        # stripped and the 'yield' statements replaced with 'pass'.
        if not self.tokens:
            return  # pragma: no cover

        first_row = self.tokens[0][2][0]
        nrows = 1 + self.tokens[-1][2][0] - first_row

        # here are the return values
        valid_indents = [list()] * nrows
        indent_level = self.tokens[0][2][1]
        valid_indents[0].append(indent_level)

        if nrows == 1:
            # bug, really.
            return valid_indents  # pragma: no cover

        indent_next = self.logical_line.endswith(':')

        row = depth = 0
        parens = [0] * nrows
        self.rel_indent = rel_indent = [0] * nrows
        indent = [indent_level]
        indent_chances = {}
        last_indent = (0, 0)
        last_token_multiline = None

        for token_type, text, start, end, _ in self.tokens:
            newline = row < start[0] - first_row
            if newline:
                row = start[0] - first_row
                newline = (not last_token_multiline and
                           token_type not in (tokenize.NL, tokenize.NEWLINE))

            if newline:
                # This is where the differences start. Instead of looking at
                # the line and determining whether the observed indent matches
                # our expectations, we decide which type of indentation is in
                # use at the given indent level, and return the offset. This
                # algorithm is susceptible to "carried errors", but should
                # through repeated runs eventually solve indentation for
                # multiline expressions less than PEP8_PASSES_MAX lines long.

                if depth:
                    for open_row in range(row - 1, -1, -1):
                        if parens[open_row]:
                            break
                else:
                    open_row = 0

                # That's all we get to work with. This code attempts to
                # "reverse" the below logic, and place into the valid indents
                # list
                vi = []
                add_second_chances = False
                if token_type == tokenize.OP and text in ']})':
                    # this line starts with a closing bracket, so it needs to
                    # be closed at the same indent as the opening one.
                    if indent[depth]:
                        # hanging indent
                        vi.append(indent[depth])
                    else:
                        # visual indent
                        vi.append(indent_level + rel_indent[open_row])
                elif depth and indent[depth]:
                    # visual indent was previously confirmed.
                    vi.append(indent[depth])
                    add_second_chances = True
                elif depth and True in indent_chances.values():
                    # visual indent happened before, so stick to
                    # visual indent this time.
                    if depth > 1 and indent[depth - 1]:
                        vi.append(indent[depth - 1])
                    else:
                        # stupid fallback
                        vi.append(indent_level + 4)
                    add_second_chances = True
                elif not depth:
                    vi.append(indent_level + 4)
                else:
                    # must be in hanging indent
                    hang = rel_indent[open_row] + 4
                    vi.append(indent_level + hang)

                # about the best we can do without look-ahead
                if (indent_next and vi[0] == indent_level + 4 and
                        nrows == row + 1):
                    vi[0] += 4

                if add_second_chances:
                    # visual indenters like to line things up.
                    min_indent = vi[0]
                    for col, what in indent_chances.items():
                        if col > min_indent and (
                            what is True or
                            (what == str and token_type == tokenize.STRING) or
                            (what == text and token_type == tokenize.OP)
                        ):
                            vi.append(col)
                    vi = sorted(vi)

                valid_indents[row] = vi

                # Returning to original continuation_line_indentation() from
                # pep8.
                visual_indent = indent_chances.get(start[1])
                last_indent = start
                rel_indent[row] = start[1] - indent_level
                hang = rel_indent[row] - rel_indent[open_row]

                if token_type == tokenize.OP and text in ']})':
                    pass
                elif visual_indent:
                    if not indent[depth]:
                        indent[depth] = start[1]

            # line altered: comments shouldn't define a visual indent
            if parens[row] and not indent[depth] and token_type not in (
                tokenize.NL, tokenize.COMMENT
            ):
                indent[depth] = start[1]
                indent_chances[start[1]] = True
            elif token_type == tokenize.STRING or text in (
                'u', 'ur', 'b', 'br'
            ):
                indent_chances[start[1]] = str

            if token_type == tokenize.OP:
                if text in '([{':
                    depth += 1
                    indent.append(0)
                    parens[row] += 1
                elif text in ')]}' and depth > 0:
                    prev_indent = indent.pop() or last_indent[1]
                    for d in range(depth):
                        if indent[d] > prev_indent:
                            indent[d] = 0
                    for ind in list(indent_chances):
                        if ind >= prev_indent:
                            del indent_chances[ind]
                    depth -= 1
                    if depth and indent[depth]:  # modified
                        indent_chances[indent[depth]] = True
                    for idx in range(row, -1, -1):
                        if parens[idx]:
                            parens[idx] -= 1
                            break
                assert len(indent) == depth + 1
                if start[1] not in indent_chances:
                    indent_chances[start[1]] = text

            last_token_multiline = (start[0] != end[0])

        return valid_indents


def _leading_space_count(line):
    """Return number of leading spaces in line."""
    i = 0
    while i < len(line) and line[i] == ' ':
        i += 1
    return i


def refactor_with_2to3(source_text, fixer_names):
    """Use lib2to3 to refactor the source.

    Return the refactored source code.

    """
    from lib2to3.refactor import RefactoringTool
    fixers = ['lib2to3.fixes.fix_' + name for name in fixer_names]
    tool = RefactoringTool(fixer_names=fixers, explicit=fixers)
    return unicode(tool.refactor_string(source_text, name=''))


def break_multiline(source_text, newline, indent_word):
    """Break first line of multiline code.

    Return None if a break is not possible.

    """
    indentation = _get_indentation(source_text)

    # Handle special case only.
    for symbol in '([{':
        # Only valid if symbol is not on a line by itself.
        if (symbol in source_text and not source_text.strip() == symbol):

            if not source_text.rstrip()[-1] == ',':
                continue

            index = 1 + source_text.find(symbol)

            if index <= len(indent_word) + len(indentation):
                continue

            if is_probably_inside_string_or_comment(source_text, index - 1):
                continue

            return (
                source_text[:index].rstrip() + newline +
                indentation + indent_word +
                source_text[index:].lstrip())

    return None


def is_probably_inside_string_or_comment(line, index):
    """Return True if index may be inside a string or comment."""
    # Make sure we are not in a string.
    for quote in ['"', "'"]:
        if quote in line:
            if line.find(quote) <= index:
                return True

    # Make sure we are not in a comment.
    if '#' in line:
        if line.find('#') <= index:
            return True

    return False


def check_syntax(code):
    """Return True if syntax is okay."""
    try:
        return compile(code, '<string>', 'exec')
    except (SyntaxError, TypeError, UnicodeDecodeError):
        return False


def filter_results(source, results, aggressive=False):
    """Filter out spurious reports from pep8.

    If aggressive is True, we allow possibly unsafe fixes (E711, E712).

    """
    non_docstring_string_line_numbers = multiline_string_lines(
        source, include_docstrings=False)
    all_string_line_numbers = multiline_string_lines(
        source, include_docstrings=True)

    split_source = [None] + source.splitlines()

    for r in results:
        issue_id = r['id'].lower()

        if r['line'] in non_docstring_string_line_numbers:
            if issue_id.startswith('e1'):
                continue
            elif issue_id in ['e501', 'w191']:
                continue

        if r['line'] in all_string_line_numbers:
            if issue_id in ['e501']:
                continue

        # Filter out incorrect E101 reports when there are no tabs.
        # pep8 will complain about this even if the tab indentation found
        # elsewhere is in a multiline string.
        if issue_id == 'e101' and '\t' not in split_source[r['line']]:
            continue

        if issue_id in ['e711', 'e712'] and not aggressive:
            continue

        yield r


def multiline_string_lines(source, include_docstrings=False):
    """Return line numbers that are within multiline strings.

    The line numbers are indexed at 1.

    Docstrings are ignored.

    """
    sio = StringIO(source)
    line_numbers = set()
    previous_token_type = ''
    try:
        for t in tokenize.generate_tokens(sio.readline):
            token_type = t[0]
            start_row = t[2][0]
            end_row = t[3][0]
            start_row = t[2][0]
            end_row = t[3][0]

            if (token_type == tokenize.STRING and start_row != end_row):
                if (include_docstrings or
                        previous_token_type != tokenize.INDENT):
                    # We increment by one since we want the contents of the
                    # string.
                    line_numbers |= set(range(1 + start_row, 1 + end_row))

            previous_token_type = token_type
    except (SyntaxError, tokenize.TokenError):
        pass

    return line_numbers


def shorten_comment(line, newline, max_line_length):
    """Return trimmed or split long comment line."""
    assert len(line) > max_line_length
    line = line.rstrip()

    # PEP 8 recommends 72 characters for comment text.
    indentation = _get_indentation(line) + '# '
    max_line_length = min(max_line_length,
                          len(indentation) + 72)

    MIN_CHARACTER_REPEAT = 5
    if (len(line) - len(line.rstrip(line[-1])) >= MIN_CHARACTER_REPEAT and
            not line[-1].isalnum()):
        # Trim comments that end with things like ---------
        return line[:max_line_length] + newline
    elif re.match(r'\s*#+\s*\w+', line):
        import textwrap
        split_lines = textwrap.wrap(line.lstrip(' \t#'),
                                    initial_indent=indentation,
                                    subsequent_indent=indentation,
                                    width=max_line_length,
                                    break_long_words=False,
                                    break_on_hyphens=False)
        return newline.join(split_lines) + newline
    else:
        return line + newline


def normalize_line_endings(lines):
    """Return fixed line endings.

    All lines will be modified to use the most common line ending.

    """
    newline = find_newline(lines)
    return [line.rstrip('\n\r') + newline for line in lines]


def mutual_startswith(a, b):
    return b.startswith(a) or a.startswith(b)


def code_match(code, select, ignore):
    if ignore:
        for ignored_code in [c.strip() for c in ignore]:
            if mutual_startswith(code.lower(), ignored_code.lower()):
                return False

    if select:
        for selected_code in [c.strip() for c in select]:
            if mutual_startswith(code.lower(), selected_code.lower()):
                return True
        return False

    return True


def fix_string(source, options=None):
    """Return fixed source code."""
    if not options:
        options = parse_args([''])[0]

    sio = StringIO(source)
    return fix_lines(sio.readlines(), options=options)


def fix_lines(source_lines, options, filename=''):
    """Return fixed source code."""
    tmp_source = ''.join(normalize_line_endings(source_lines))

    # Keep a history to break out of cycles.
    previous_hashes = set([hash(tmp_source)])

    # Apply global fixes only once (for efficiency).
    fixed_source = apply_global_fixes(tmp_source, options)

    passes = 0
    while True:
        if options.pep8_passes >= 0 and passes > options.pep8_passes:
            break
        passes += 1

        tmp_source = copy.copy(fixed_source)

        fix = FixPEP8(filename, options, contents=tmp_source)
        fixed_source = fix.fix()

        if hash(fixed_source) in previous_hashes:
            break
        else:
            previous_hashes.add(hash(fixed_source))

    return fixed_source


def fix_file(filename, options=None, output=None):
    if not options:
        options = parse_args([filename])[0]

    original_source = read_from_filename(filename, readlines=True)

    fixed_source = original_source

    if options.in_place or output:
        encoding = detect_encoding(filename)

    if output:
        output = codecs.getwriter(encoding)(output.buffer
                                            if hasattr(output, 'buffer')
                                            else output)

        output = LineEndingWrapper(output)

    fixed_source = fix_lines(fixed_source, options, filename=filename)

    if options.diff:
        new = StringIO(fixed_source)
        new = new.readlines()
        diff = get_diff_text(original_source, new, filename)
        if output:
            output.write(diff)
            output.flush()
        else:
            return diff
    elif options.in_place:
        fp = open_with_encoding(filename, encoding=encoding,
                                mode='w')
        fp.write(fixed_source)
        fp.close()
    else:
        if output:
            output.write(fixed_source)
            output.flush()
        else:
            return fixed_source


def global_fixes():
    """Yield multiple (code, function) tuples."""
    for function in globals().values():
        if inspect.isfunction(function):
            arguments = inspect.getargspec(function)[0]
            if arguments != ['source']:
                continue

            code = extract_code_from_function(function)
            if code:
                yield (code, function)


def apply_global_fixes(source, options):
    """Run global fixes on source code.

    Thsese are fixes that only need be done once (unlike those in FixPEP8,
    which are dependent on pep8).

    """
    for (code, function) in global_fixes():
        if code_match(code, select=options.select, ignore=options.ignore):
            if options.verbose:
                print('--->  Applying global fix for {0}'.format(code.upper()),
                      file=sys.stderr)
            source = function(source)

    return source


def extract_code_from_function(function):
    """Return code handled by function."""
    if not function.__name__.startswith('fix_'):
        return None

    code = re.sub('^fix_', '', function.__name__)
    if not code:
        return None

    try:
        int(code[1:])
    except ValueError:
        return None

    return code


def parse_args(args):
    """Parse command-line options."""
    parser = OptionParser(usage='Usage: autopep8 [options] '
                                '[filename [filename ...]]'
                                '\nUse filename \'-\'  for stdin.',
                          version='%prog {0}'.format(__version__),
                          description=__doc__.split('\n')[0],
                          prog='autopep8')
    parser.add_option('-v', '--verbose', action='count', dest='verbose',
                      default=0,
                      help='print verbose messages; '
                           'multiple -v result in more verbose messages')
    parser.add_option('-d', '--diff', action='store_true', dest='diff',
                      help='print the diff for the fixed source')
    parser.add_option('-i', '--in-place', action='store_true',
                      help='make changes to files in place')
    parser.add_option('-r', '--recursive', action='store_true',
                      help='run recursively; must be used with --in-place or '
                           '--diff')
    parser.add_option('-j', '--jobs', type=int, metavar='n', default=1,
                      help='number of parallel jobs; '
                           'match CPU count if value is less than 1')
    parser.add_option('-p', '--pep8-passes', metavar='n',
                      default=-1, type=int,
                      help='maximum number of additional pep8 passes '
                           '(default: infinite)')
    parser.add_option('-a', '--aggressive', action='count', default=0,
                      help='enable non-whitespace changes; '
                           'multiple -a result in more aggressive changes')
    parser.add_option('--exclude', metavar='globs',
                      help='exclude files/directories that match these '
                           'comma-separated globs')
    parser.add_option('--list-fixes', action='store_true',
                      help='list codes for fixes; '
                           'used by --ignore and --select')
    parser.add_option('--ignore', metavar='errors', default='',
                      help='do not fix these errors/warnings '
                           '(default: {0})'.format(DEFAULT_IGNORE))
    parser.add_option('--select', metavar='errors', default='',
                      help='fix only these errors/warnings (e.g. E4,W)')
    parser.add_option('--max-line-length', metavar='n', default=79, type=int,
                      help='set maximum allowed line length '
                           '(default: %default)')
    options, args = parser.parse_args(args)

    if not len(args) and not options.list_fixes:
        parser.error('incorrect number of arguments')

    if '-' in args:
        if len(args) > 1:
            parser.error('cannot mix stdin and regular files')

        if options.diff:
            parser.error('--diff cannot be used with standard input')

        if options.in_place:
            parser.error('--in-place cannot be used with standard input')

        if options.recursive:
            parser.error('--recursive cannot be used with standard input')

    if len(args) > 1 and not (options.in_place or options.diff):
        parser.error('autopep8 only takes one filename as argument '
                     'unless the "--in-place" or "--diff" options are '
                     'used')

    if options.recursive and not (options.in_place or options.diff):
        parser.error('--recursive must be used with --in-place or --diff')

    if options.exclude and not options.recursive:
        parser.error('--exclude is only relevant when used with --recursive')

    if options.in_place and options.diff:
        parser.error('--in-place and --diff are mutually exclusive')

    if options.max_line_length <= 0:
        parser.error('--max-line-length must be greater than 0')

    if options.select:
        options.select = options.select.split(',')

    if options.ignore:
        options.ignore = options.ignore.split(',')
    elif not options.select:
        if options.aggressive:
            # Enable everything by default if aggressive.
            options.select = ['E', 'W']
        else:
            options.ignore = DEFAULT_IGNORE.split(',')

    if options.exclude:
        options.exclude = options.exclude.split(',')
    else:
        options.exclude = []

    if options.jobs < 1:
        # Do not import multiprocessing globally in case it is not supported
        # on the platform.
        import multiprocessing
        options.jobs = multiprocessing.cpu_count()

    if options.jobs > 1 and not options.in_place:
        parser.error('parallel jobs requires --in-place')

    return options, args


def supported_fixes():
    """Yield pep8 error codes that autopep8 fixes.

    Each item we yield is a tuple of the code followed by its description.

    """
    instance = FixPEP8(filename=None, options=None, contents='')
    for attribute in dir(instance):
        code = re.match('fix_([ew][0-9][0-9][0-9])', attribute)
        if code:
            yield (code.group(1).upper(),
                   re.sub(r'\s+', ' ',
                          getattr(instance, attribute).__doc__))

    for (code, function) in sorted(global_fixes()):
        yield (code.upper() + (4 - len(code)) * ' ',
               re.sub(r'\s+', ' ', function.__doc__))


def line_shortening_rank(candidate, newline, indent_word):
    """Return rank of candidate.

    This is for sorting candidates.

    """
    rank = 0
    if candidate.strip():
        lines = candidate.split(newline)

        offset = 0
        if lines[0].rstrip()[-1] not in '([{':
            for symbol in '([{':
                offset = max(offset, 1 + lines[0].find(symbol))

        max_length = max([offset + len(x.strip()) for x in lines])
        rank += max_length
        rank += len(lines)

        bad_staring_symbol = {
            '(': ')',
            '[': ']',
            '{': '}'}.get(lines[0][-1], None)

        if len(lines) > 1:
            if (bad_staring_symbol and
                    lines[1].lstrip().startswith(bad_staring_symbol)):
                rank += 20
            else:
                rank -= 10

        if lines[0].endswith('(['):
            rank += 10

        for current_line in lines:
            for bad_start in ['.', '%', '+', '-', '/']:
                if current_line.startswith(bad_start):
                    rank += 100

            for ending in '([{':
                # Avoid lonely opening. They result in longer lines.
                if (current_line.endswith(ending) and
                        len(current_line.strip()) <= len(indent_word)):
                    rank += 100

            if current_line.endswith('%'):
                rank -= 20

            # Try to break list comprehensions at the "for".
            if current_line.lstrip().startswith('for'):
                rank -= 50

            rank += 10 * count_unbalanced_brackets(current_line)
    else:
        rank = 100000

    return max(0, rank)


def count_unbalanced_brackets(line):
    """Return number of unmatched open/close brackets."""
    count = 0
    for opening, closing in ['()', '[]', '{}']:
        count += abs(line.count(opening) - line.count(closing))

    return count


def split_at_offsets(line, offsets):
    """Split line at offsets.

    Return list of strings.

    """
    result = []

    previous_offset = 0
    current_offset = 0
    for current_offset in sorted(offsets):
        if current_offset < len(line) and previous_offset != current_offset:
            result.append(line[previous_offset:current_offset])
        previous_offset = current_offset

    result.append(line[current_offset:])

    return result


def get_longest_length(text, newline):
    """Return length of longest line."""
    return max([len(line) for line in text.split(newline)])


class LineEndingWrapper(object):

    r"""Replace line endings to work with sys.stdout.

    It seems that sys.stdout expects only '\n' as the line ending, no matter
    the platform. Otherwise, we get repeated line endings.

    """

    def __init__(self, output):
        self.__output = output

    def write(self, s):
        self.__output.write(s.replace('\r\n', '\n').replace('\r', '\n'))

    def flush(self):
        self.__output.flush()


def match_file(filename, exclude):
    """Return True if file is okay for modifying/recursing."""
    if os.path.basename(filename).startswith('.'):
        return False

    for pattern in exclude:
        if fnmatch.fnmatch(filename, pattern):
            return False

    if not is_python_file(filename):
        return False

    return True


def find_files(filenames, recursive, exclude):
    """Yield filenames."""
    while filenames:
        name = filenames.pop(0)
        if recursive and os.path.isdir(name):
            for root, directories, children in os.walk(name):
                filenames += [os.path.join(root, f) for f in children
                              if match_file(f, exclude)]
                directories[:] = [d for d in directories
                                  if not d.startswith('.')]
        else:
            yield name


def _fix_file(parameters):
    """Helper function for optionally running fix_file() in parallel."""
    if parameters[1].verbose:
        print('[file:{0}]'.format(parameters[0]), file=sys.stderr)
    try:
        fix_file(*parameters)
    except IOError as error:
        print(str(error), file=sys.stderr)


def fix_multiple_files(filenames, options, output=None):
    """Fix list of files.

    Optionally fix files recursively.

    """
    filenames = find_files(filenames, options.recursive, options.exclude)
    if options.jobs > 1:
        import multiprocessing
        pool = multiprocessing.Pool(options.jobs)
        pool.map(_fix_file,
                 [(name, options) for name in filenames])
    else:
        for name in filenames:
            _fix_file((name, options, output))


def is_python_file(filename):
    """Return True if filename is Python file."""
    if filename.endswith('.py'):
        return True

    try:
        with open_with_encoding(filename) as f:
            first_line = f.readlines(1)[0]
    except (IOError, IndexError):
        return False

    if len(first_line) > 200:
        # This is probably not even a text file.
        return False

    if not PYTHON_SHEBANG_REGEX.match(first_line):
        return False

    return True


def main():
    """Tool main."""
    try:
        # Exit on broken pipe.
        signal.signal(signal.SIGPIPE, signal.SIG_DFL)
    except AttributeError:  # pragma: no cover
        # SIGPIPE is not available on Windows.
        pass

    try:
        options, args = parse_args(sys.argv[1:])

        if options.list_fixes:
            for code, description in supported_fixes():
                print('{code} - {description}'.format(
                    code=code, description=description))
            return 0

        if args == ['-']:
            assert not options.in_place

            # LineEndingWrapper is unnecessary here due to the symmetry between
            # standard in and standard out.
            sys.stdout.write(fix_string(sys.stdin.read(),
                                        options))
        else:
            if options.in_place or options.diff:
                filenames = list(set(args))
            else:
                assert len(args) == 1
                assert not options.recursive

                filenames = args[:1]

            fix_multiple_files(filenames, options, sys.stdout)
    except KeyboardInterrupt:
        return 1  # pragma: no cover


if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = pep8
#!/usr/bin/env python
# pep8.py - Check Python source code formatting, according to PEP 8
# Copyright (C) 2006-2009 Johann C. Rocholl <johann@rocholl.net>
# Copyright (C) 2009-2013 Florent Xicluna <florent.xicluna@gmail.com>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

r"""
Check Python source code formatting, according to PEP 8:
http://www.python.org/dev/peps/pep-0008/

For usage and a list of options, try this:
$ python pep8.py -h

This program and its regression test suite live here:
http://github.com/jcrocholl/pep8

Groups of errors and warnings:
E errors
W warnings
100 indentation
200 whitespace
300 blank lines
400 imports
500 line length
600 deprecation
700 statements
900 syntax error
"""
__version__ = '1.4.6'

import os
import sys
import re
import time
import inspect
import keyword
import tokenize
from optparse import OptionParser
from fnmatch import fnmatch
try:
    from configparser import RawConfigParser
    from io import TextIOWrapper
except ImportError:
    from ConfigParser import RawConfigParser

DEFAULT_EXCLUDE = '.svn,CVS,.bzr,.hg,.git,__pycache__'
DEFAULT_IGNORE = 'E123,E226,E24'
if sys.platform == 'win32':
    DEFAULT_CONFIG = os.path.expanduser(r'~\.pep8')
else:
    DEFAULT_CONFIG = os.path.join(os.getenv('XDG_CONFIG_HOME') or
                                  os.path.expanduser('~/.config'), 'pep8')
PROJECT_CONFIG = ('setup.cfg', 'tox.ini', '.pep8')
TESTSUITE_PATH = os.path.join(os.path.dirname(__file__), 'testsuite')
MAX_LINE_LENGTH = 79
REPORT_FORMAT = {
    'default': '%(path)s:%(row)d:%(col)d: %(code)s %(text)s',
    'pylint': '%(path)s:%(row)d: [%(code)s] %(text)s',
}

PyCF_ONLY_AST = 1024
SINGLETONS = frozenset(['False', 'None', 'True'])
KEYWORDS = frozenset(keyword.kwlist + ['print']) - SINGLETONS
UNARY_OPERATORS = frozenset(['>>', '**', '*', '+', '-'])
ARITHMETIC_OP = frozenset(['**', '*', '/', '//', '+', '-'])
WS_OPTIONAL_OPERATORS = ARITHMETIC_OP.union(['^', '&', '|', '<<', '>>', '%'])
WS_NEEDED_OPERATORS = frozenset([
    '**=', '*=', '/=', '//=', '+=', '-=', '!=', '<>', '<', '>',
    '%=', '^=', '&=', '|=', '==', '<=', '>=', '<<=', '>>=', '='])
WHITESPACE = frozenset(' \t')
SKIP_TOKENS = frozenset([tokenize.COMMENT, tokenize.NL, tokenize.NEWLINE,
                         tokenize.INDENT, tokenize.DEDENT])
BENCHMARK_KEYS = ['directories', 'files', 'logical lines', 'physical lines']

INDENT_REGEX = re.compile(r'([ \t]*)')
RAISE_COMMA_REGEX = re.compile(r'raise\s+\w+\s*,')
RERAISE_COMMA_REGEX = re.compile(r'raise\s+\w+\s*,\s*\w+\s*,\s*\w+')
ERRORCODE_REGEX = re.compile(r'\b[A-Z]\d{3}\b')
DOCSTRING_REGEX = re.compile(r'u?r?["\']')
EXTRANEOUS_WHITESPACE_REGEX = re.compile(r'[[({] | []}),;:]')
WHITESPACE_AFTER_COMMA_REGEX = re.compile(r'[,;:]\s*(?:  |\t)')
COMPARE_SINGLETON_REGEX = re.compile(r'([=!]=)\s*(None|False|True)')
COMPARE_TYPE_REGEX = re.compile(r'(?:[=!]=|is(?:\s+not)?)\s*type(?:s.\w+Type'
                                r'|\s*\(\s*([^)]*[^ )])\s*\))')
KEYWORD_REGEX = re.compile(r'(\s*)\b(?:%s)\b(\s*)' % r'|'.join(KEYWORDS))
OPERATOR_REGEX = re.compile(r'(?:[^,\s])(\s*)(?:[-+*/|!<=>%&^]+)(\s*)')
LAMBDA_REGEX = re.compile(r'\blambda\b')
HUNK_REGEX = re.compile(r'^@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@.*$')

# Work around Python < 2.6 behaviour, which does not generate NL after
# a comment which is on a line by itself.
COMMENT_WITH_NL = tokenize.generate_tokens(['#\n'].pop).send(None)[1] == '#\n'


##############################################################################
# Plugins (check functions) for physical lines
##############################################################################


def tabs_or_spaces(physical_line, indent_char):
    r"""
    Never mix tabs and spaces.

    The most popular way of indenting Python is with spaces only.  The
    second-most popular way is with tabs only.  Code indented with a mixture
    of tabs and spaces should be converted to using spaces exclusively.  When
    invoking the Python command line interpreter with the -t option, it issues
    warnings about code that illegally mixes tabs and spaces.  When using -tt
    these warnings become errors.  These options are highly recommended!

    Okay: if a == 0:\n        a = 1\n        b = 1
    E101: if a == 0:\n        a = 1\n\tb = 1
    """
    indent = INDENT_REGEX.match(physical_line).group(1)
    for offset, char in enumerate(indent):
        if char != indent_char:
            return offset, "E101 indentation contains mixed spaces and tabs"


def tabs_obsolete(physical_line):
    r"""
    For new projects, spaces-only are strongly recommended over tabs.  Most
    editors have features that make this easy to do.

    Okay: if True:\n    return
    W191: if True:\n\treturn
    """
    indent = INDENT_REGEX.match(physical_line).group(1)
    if '\t' in indent:
        return indent.index('\t'), "W191 indentation contains tabs"


def trailing_whitespace(physical_line):
    r"""
    JCR: Trailing whitespace is superfluous.
    FBM: Except when it occurs as part of a blank line (i.e. the line is
         nothing but whitespace). According to Python docs[1] a line with only
         whitespace is considered a blank line, and is to be ignored. However,
         matching a blank line to its indentation level avoids mistakenly
         terminating a multi-line statement (e.g. class declaration) when
         pasting code into the standard Python interpreter.

         [1] http://docs.python.org/reference/lexical_analysis.html#blank-lines

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
    """
    physical_line = physical_line.rstrip('\n')    # chr(10), newline
    physical_line = physical_line.rstrip('\r')    # chr(13), carriage return
    physical_line = physical_line.rstrip('\x0c')  # chr(12), form feed, ^L
    stripped = physical_line.rstrip(' \t\v')
    if physical_line != stripped:
        if stripped:
            return len(stripped), "W291 trailing whitespace"
        else:
            return 0, "W293 blank line contains whitespace"


def trailing_blank_lines(physical_line, lines, line_number):
    r"""
    JCR: Trailing blank lines are superfluous.

    Okay: spam(1)
    W391: spam(1)\n
    """
    if not physical_line.rstrip() and line_number == len(lines):
        return 0, "W391 blank line at end of file"


def missing_newline(physical_line):
    """
    JCR: The last line should have a newline.

    Reports warning W292.
    """
    if physical_line.rstrip() == physical_line:
        return len(physical_line), "W292 no newline at end of file"


def maximum_line_length(physical_line, max_line_length):
    """
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
    """
    line = physical_line.rstrip()
    length = len(line)
    if length > max_line_length and not noqa(line):
        if hasattr(line, 'decode'):   # Python 2
            # The line could contain multi-byte characters
            try:
                length = len(line.decode('utf-8'))
            except UnicodeError:
                pass
        if length > max_line_length:
            return (max_line_length, "E501 line too long "
                    "(%d > %d characters)" % (length, max_line_length))


##############################################################################
# Plugins (check functions) for logical lines
##############################################################################


def blank_lines(logical_line, blank_lines, indent_level, line_number,
                previous_logical, previous_indent_level):
    r"""
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
    """
    if line_number < 3 and not previous_logical:
        return  # Don't expect blank lines before the first line
    if previous_logical.startswith('@'):
        if blank_lines:
            yield 0, "E304 blank lines found after function decorator"
    elif blank_lines > 2 or (indent_level and blank_lines == 2):
        yield 0, "E303 too many blank lines (%d)" % blank_lines
    elif logical_line.startswith(('def ', 'class ', '@')):
        if indent_level:
            if not (blank_lines or previous_indent_level < indent_level or
                    DOCSTRING_REGEX.match(previous_logical)):
                yield 0, "E301 expected 1 blank line, found 0"
        elif blank_lines != 2:
            yield 0, "E302 expected 2 blank lines, found %d" % blank_lines


def extraneous_whitespace(logical_line):
    """
    Avoid extraneous whitespace in the following situations:

    - Immediately inside parentheses, brackets or braces.

    - Immediately before a comma, semicolon, or colon.

    Okay: spam(ham[1], {eggs: 2})
    E201: spam( ham[1], {eggs: 2})
    E201: spam(ham[ 1], {eggs: 2})
    E201: spam(ham[1], { eggs: 2})
    E202: spam(ham[1], {eggs: 2} )
    E202: spam(ham[1 ], {eggs: 2})
    E202: spam(ham[1], {eggs: 2 })

    E203: if x == 4: print x, y; x, y = y , x
    E203: if x == 4: print x, y ; x, y = y, x
    E203: if x == 4 : print x, y; x, y = y, x
    """
    line = logical_line
    for match in EXTRANEOUS_WHITESPACE_REGEX.finditer(line):
        text = match.group()
        char = text.strip()
        found = match.start()
        if text == char + ' ':
            # assert char in '([{'
            yield found + 1, "E201 whitespace after '%s'" % char
        elif line[found - 1] != ',':
            code = ('E202' if char in '}])' else 'E203')  # if char in ',;:'
            yield found, "%s whitespace before '%s'" % (code, char)


def whitespace_around_keywords(logical_line):
    r"""
    Avoid extraneous whitespace around keywords.

    Okay: True and False
    E271: True and  False
    E272: True  and False
    E273: True and\tFalse
    E274: True\tand False
    """
    for match in KEYWORD_REGEX.finditer(logical_line):
        before, after = match.groups()

        if '\t' in before:
            yield match.start(1), "E274 tab before keyword"
        elif len(before) > 1:
            yield match.start(1), "E272 multiple spaces before keyword"

        if '\t' in after:
            yield match.start(2), "E273 tab after keyword"
        elif len(after) > 1:
            yield match.start(2), "E271 multiple spaces after keyword"


def missing_whitespace(logical_line):
    """
    JCR: Each comma, semicolon or colon should be followed by whitespace.

    Okay: [a, b]
    Okay: (3,)
    Okay: a[1:4]
    Okay: a[:4]
    Okay: a[1:]
    Okay: a[1:4:2]
    E231: ['a','b']
    E231: foo(bar,baz)
    E231: [{'a':'b'}]
    """
    line = logical_line
    for index in range(len(line) - 1):
        char = line[index]
        if char in ',;:' and line[index + 1] not in WHITESPACE:
            before = line[:index]
            if char == ':' and before.count('[') > before.count(']') and \
                    before.rfind('{') < before.rfind('['):
                continue  # Slice syntax, no space required
            if char == ',' and line[index + 1] == ')':
                continue  # Allow tuple with only one element: (3,)
            yield index, "E231 missing whitespace after '%s'" % char


def indentation(logical_line, previous_logical, indent_char,
                indent_level, previous_indent_level):
    r"""
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.

    Okay: a = 1
    Okay: if a == 0:\n    a = 1
    E111:   a = 1

    Okay: for item in items:\n    pass
    E112: for item in items:\npass

    Okay: a = 1\nb = 2
    E113: a = 1\n    b = 2
    """
    if indent_char == ' ' and indent_level % 4:
        yield 0, "E111 indentation is not a multiple of four"
    indent_expect = previous_logical.endswith(':')
    if indent_expect and indent_level <= previous_indent_level:
        yield 0, "E112 expected an indented block"
    if indent_level > previous_indent_level and not indent_expect:
        yield 0, "E113 unexpected indentation"


def continued_indentation(logical_line, tokens, indent_level, hang_closing,
                          noqa, verbose):
    r"""
    Continuation lines should align wrapped elements either vertically using
    Python's implicit line joining inside parentheses, brackets and braces, or
    using a hanging indent.

    When using a hanging indent the following considerations should be applied:

    - there should be no arguments on the first line, and

    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (a or\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    """
    first_row = tokens[0][2][0]
    nrows = 1 + tokens[-1][2][0] - first_row
    if noqa or nrows == 1:
        return

    # indent_next tells us whether the next block is indented; assuming
    # that it is indented by 4 spaces, then we should not allow 4-space
    # indents on the final continuation line; in turn, some other
    # indents are allowed to have an extra 4 spaces.
    indent_next = logical_line.endswith(':')

    row = depth = 0
    # remember how many brackets were opened on each line
    parens = [0] * nrows
    # relative indents of physical lines
    rel_indent = [0] * nrows
    # visual indents
    indent_chances = {}
    last_indent = tokens[0][2]
    indent = [last_indent[1]]
    if verbose >= 3:
        print(">>> " + tokens[0][4].rstrip())

    for token_type, text, start, end, line in tokens:

        newline = row < start[0] - first_row
        if newline:
            row = start[0] - first_row
            newline = (not last_token_multiline and
                       token_type not in (tokenize.NL, tokenize.NEWLINE))

        if newline:
            # this is the beginning of a continuation line.
            last_indent = start
            if verbose >= 3:
                print("... " + line.rstrip())

            # record the initial indent.
            rel_indent[row] = expand_indent(line) - indent_level

            if depth:
                # a bracket expression in a continuation line.
                # find the line that it was opened on
                for open_row in range(row - 1, -1, -1):
                    if parens[open_row]:
                        break
            else:
                # an unbracketed continuation line (ie, backslash)
                open_row = 0
            hang = rel_indent[row] - rel_indent[open_row]
            close_bracket = (token_type == tokenize.OP and text in ']})')
            visual_indent = (not close_bracket and hang > 0 and
                             indent_chances.get(start[1]))

            if close_bracket and indent[depth]:
                # closing bracket for visual indent
                if start[1] != indent[depth]:
                    yield (start, "E124 closing bracket does not match "
                           "visual indentation")
            elif close_bracket and not hang:
                # closing bracket matches indentation of opening bracket's line
                if hang_closing:
                    yield start, "E133 closing bracket is missing indentation"
            elif visual_indent:
                # visual indent is verified
                if not indent[depth]:
                    indent[depth] = start[1]
            elif visual_indent in (text, str):
                # ignore token lined up with matching one from a previous line
                pass
            elif indent[depth] and start[1] < indent[depth]:
                # visual indent is broken
                yield (start, "E128 continuation line "
                       "under-indented for visual indent")
            elif hang == 4 or (indent_next and rel_indent[row] == 8):
                # hanging indent is verified
                if close_bracket and not hang_closing:
                    yield (start, "E123 closing bracket does not match "
                           "indentation of opening bracket's line")
            else:
                # indent is broken
                if hang <= 0:
                    error = "E122", "missing indentation or outdented"
                elif indent[depth]:
                    error = "E127", "over-indented for visual indent"
                elif hang % 4:
                    error = "E121", "indentation is not a multiple of four"
                else:
                    error = "E126", "over-indented for hanging indent"
                yield start, "%s continuation line %s" % error

        # look for visual indenting
        if (parens[row] and token_type not in (tokenize.NL, tokenize.COMMENT)
                and not indent[depth]):
            indent[depth] = start[1]
            indent_chances[start[1]] = True
            if verbose >= 4:
                print("bracket depth %s indent to %s" % (depth, start[1]))
        # deal with implicit string concatenation
        elif (token_type in (tokenize.STRING, tokenize.COMMENT) or
              text in ('u', 'ur', 'b', 'br')):
            indent_chances[start[1]] = str
        # special case for the "if" statement because len("if (") == 4
        elif not indent_chances and not row and not depth and text == 'if':
            indent_chances[end[1] + 1] = True

        # keep track of bracket depth
        if token_type == tokenize.OP:
            if text in '([{':
                depth += 1
                indent.append(0)
                parens[row] += 1
                if verbose >= 4:
                    print("bracket depth %s seen, col %s, visual min = %s" %
                          (depth, start[1], indent[depth]))
            elif text in ')]}' and depth > 0:
                # parent indents should not be more than this one
                prev_indent = indent.pop() or last_indent[1]
                for d in range(depth):
                    if indent[d] > prev_indent:
                        indent[d] = 0
                for ind in list(indent_chances):
                    if ind >= prev_indent:
                        del indent_chances[ind]
                depth -= 1
                if depth:
                    indent_chances[indent[depth]] = True
                for idx in range(row, -1, -1):
                    if parens[idx]:
                        parens[idx] -= 1
                        rel_indent[row] = rel_indent[idx]
                        break
            assert len(indent) == depth + 1
            if start[1] not in indent_chances:
                # allow to line up tokens
                indent_chances[start[1]] = text

        last_token_multiline = (start[0] != end[0])

    if indent_next and expand_indent(line) == indent_level + 4:
        yield (last_indent, "E125 continuation line does not distinguish "
               "itself from next logical line")


def whitespace_before_parameters(logical_line, tokens):
    """
    Avoid extraneous whitespace in the following situations:

    - Immediately before the open parenthesis that starts the argument
      list of a function call.

    - Immediately before the open parenthesis that starts an indexing or
      slicing.

    Okay: spam(1)
    E211: spam (1)

    Okay: dict['key'] = list[index]
    E211: dict ['key'] = list[index]
    E211: dict['key'] = list [index]
    """
    prev_type, prev_text, __, prev_end, __ = tokens[0]
    for index in range(1, len(tokens)):
        token_type, text, start, end, __ = tokens[index]
        if (token_type == tokenize.OP and
            text in '([' and
            start != prev_end and
            (prev_type == tokenize.NAME or prev_text in '}])') and
            # Syntax "class A (B):" is allowed, but avoid it
            (index < 2 or tokens[index - 2][1] != 'class') and
                # Allow "return (a.foo for a in range(5))"
                not keyword.iskeyword(prev_text)):
            yield prev_end, "E211 whitespace before '%s'" % text
        prev_type = token_type
        prev_text = text
        prev_end = end


def whitespace_around_operator(logical_line):
    r"""
    Avoid extraneous whitespace in the following situations:

    - More than one space around an assignment (or other) operator to
      align it with another.

    Okay: a = 12 + 3
    E221: a = 4  + 5
    E222: a = 4 +  5
    E223: a = 4\t+ 5
    E224: a = 4 +\t5
    """
    for match in OPERATOR_REGEX.finditer(logical_line):
        before, after = match.groups()

        if '\t' in before:
            yield match.start(1), "E223 tab before operator"
        elif len(before) > 1:
            yield match.start(1), "E221 multiple spaces before operator"

        if '\t' in after:
            yield match.start(2), "E224 tab after operator"
        elif len(after) > 1:
            yield match.start(2), "E222 multiple spaces after operator"


def missing_whitespace_around_operator(logical_line, tokens):
    r"""
    - Always surround these binary operators with a single space on
      either side: assignment (=), augmented assignment (+=, -= etc.),
      comparisons (==, <, >, !=, <>, <=, >=, in, not in, is, is not),
      Booleans (and, or, not).

    - Use spaces around arithmetic operators.

    Okay: i = i + 1
    Okay: submitted += 1
    Okay: x = x * 2 - 1
    Okay: hypot2 = x * x + y * y
    Okay: c = (a + b) * (a - b)
    Okay: foo(bar, key='word', *args, **kwargs)
    Okay: alpha[:-i]

    E225: i=i+1
    E225: submitted +=1
    E225: x = x /2 - 1
    E225: z = x **y
    E226: c = (a+b) * (a-b)
    E226: hypot2 = x*x + y*y
    E227: c = a|b
    E228: msg = fmt%(errno, errmsg)
    """
    parens = 0
    need_space = False
    prev_type = tokenize.OP
    prev_text = prev_end = None
    for token_type, text, start, end, line in tokens:
        if token_type in (tokenize.NL, tokenize.NEWLINE, tokenize.ERRORTOKEN):
            # ERRORTOKEN is triggered by backticks in Python 3
            continue
        if text in ('(', 'lambda'):
            parens += 1
        elif text == ')':
            parens -= 1
        if need_space:
            if start != prev_end:
                # Found a (probably) needed space
                if need_space is not True and not need_space[1]:
                    yield (need_space[0],
                           "E225 missing whitespace around operator")
                need_space = False
            elif text == '>' and prev_text in ('<', '-'):
                # Tolerate the "<>" operator, even if running Python 3
                # Deal with Python 3's annotated return value "->"
                pass
            else:
                if need_space is True or need_space[1]:
                    # A needed trailing space was not found
                    yield prev_end, "E225 missing whitespace around operator"
                else:
                    code, optype = 'E226', 'arithmetic'
                    if prev_text == '%':
                        code, optype = 'E228', 'modulo'
                    elif prev_text not in ARITHMETIC_OP:
                        code, optype = 'E227', 'bitwise or shift'
                    yield (need_space[0], "%s missing whitespace "
                           "around %s operator" % (code, optype))
                need_space = False
        elif token_type == tokenize.OP and prev_end is not None:
            if text == '=' and parens:
                # Allow keyword args or defaults: foo(bar=None).
                pass
            elif text in WS_NEEDED_OPERATORS:
                need_space = True
            elif text in UNARY_OPERATORS:
                # Check if the operator is being used as a binary operator
                # Allow unary operators: -123, -x, +1.
                # Allow argument unpacking: foo(*args, **kwargs).
                if prev_type == tokenize.OP:
                    binary_usage = (prev_text in '}])')
                elif prev_type == tokenize.NAME:
                    binary_usage = (prev_text not in KEYWORDS)
                else:
                    binary_usage = (prev_type not in SKIP_TOKENS)

                if binary_usage:
                    need_space = None
            elif text in WS_OPTIONAL_OPERATORS:
                need_space = None

            if need_space is None:
                # Surrounding space is optional, but ensure that
                # trailing space matches opening space
                need_space = (prev_end, start != prev_end)
            elif need_space and start == prev_end:
                # A needed opening space was not found
                yield prev_end, "E225 missing whitespace around operator"
                need_space = False
        prev_type = token_type
        prev_text = text
        prev_end = end


def whitespace_around_comma(logical_line):
    r"""
    Avoid extraneous whitespace in the following situations:

    - More than one space around an assignment (or other) operator to
      align it with another.

    Note: these checks are disabled by default

    Okay: a = (1, 2)
    E241: a = (1,  2)
    E242: a = (1,\t2)
    """
    line = logical_line
    for m in WHITESPACE_AFTER_COMMA_REGEX.finditer(line):
        found = m.start() + 1
        if '\t' in m.group():
            yield found, "E242 tab after '%s'" % m.group()[0]
        else:
            yield found, "E241 multiple spaces after '%s'" % m.group()[0]


def whitespace_around_named_parameter_equals(logical_line, tokens):
    """
    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
    """
    parens = 0
    no_space = False
    prev_end = None
    message = "E251 unexpected spaces around keyword / parameter equals"
    for token_type, text, start, end, line in tokens:
        if no_space:
            no_space = False
            if start != prev_end:
                yield (prev_end, message)
        elif token_type == tokenize.OP:
            if text == '(':
                parens += 1
            elif text == ')':
                parens -= 1
            elif parens and text == '=':
                no_space = True
                if start != prev_end:
                    yield (prev_end, message)
        prev_end = end


def whitespace_before_inline_comment(logical_line, tokens):
    """
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    """
    prev_end = (0, 0)
    for token_type, text, start, end, line in tokens:
        if token_type == tokenize.COMMENT:
            if not line[:start[1]].strip():
                continue
            if prev_end[0] == start[0] and start[1] < prev_end[1] + 2:
                yield (prev_end,
                       "E261 at least two spaces before inline comment")
            symbol, sp, comment = text.partition(' ')
            if symbol not in ('#', '#:') or comment[:1].isspace():
                yield start, "E262 inline comment should start with '# '"
        elif token_type != tokenize.NL:
            prev_end = end


def imports_on_separate_lines(logical_line):
    r"""
    Imports should usually be on separate lines.

    Okay: import os\nimport sys
    E401: import sys, os

    Okay: from subprocess import Popen, PIPE
    Okay: from myclas import MyClass
    Okay: from foo.bar.yourclass import YourClass
    Okay: import myclass
    Okay: import foo.bar.yourclass
    """
    line = logical_line
    if line.startswith('import '):
        found = line.find(',')
        if -1 < found and ';' not in line[:found]:
            yield found, "E401 multiple imports on one line"


def compound_statements(logical_line):
    r"""
    Compound statements (multiple statements on the same line) are
    generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements. Also
    avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
    """
    line = logical_line
    last_char = len(line) - 1
    found = line.find(':')
    while -1 < found < last_char:
        before = line[:found]
        if (before.count('{') <= before.count('}') and  # {'a': 1} (dict)
            before.count('[') <= before.count(']') and  # [1:2] (slice)
            before.count('(') <= before.count(')') and  # (Python 3 annotation)
                not LAMBDA_REGEX.search(before)):       # lambda x: x
            yield found, "E701 multiple statements on one line (colon)"
        found = line.find(':', found + 1)
    found = line.find(';')
    while -1 < found:
        if found < last_char:
            yield found, "E702 multiple statements on one line (semicolon)"
        else:
            yield found, "E703 statement ends with a semicolon"
        found = line.find(';', found + 1)


def explicit_line_join(logical_line, tokens):
    r"""
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
    """
    prev_start = prev_end = parens = 0
    for token_type, text, start, end, line in tokens:
        if start[0] != prev_start and parens and backslash:
            yield backslash, "E502 the backslash is redundant between brackets"
        if end[0] != prev_end:
            if line.rstrip('\r\n').endswith('\\'):
                backslash = (end[0], len(line.splitlines()[-1]) - 1)
            else:
                backslash = None
            prev_start = prev_end = end[0]
        else:
            prev_start = start[0]
        if token_type == tokenize.OP:
            if text in '([{':
                parens += 1
            elif text in ')]}':
                parens -= 1


def comparison_to_singleton(logical_line, noqa):
    """
    Comparisons to singletons like None should always be done
    with "is" or "is not", never the equality operators.

    Okay: if arg is not None:
    E711: if arg != None:
    E712: if arg == True:

    Also, beware of writing if x when you really mean if x is not None --
    e.g. when testing whether a variable or argument that defaults to None was
    set to some other value.  The other value might have a type (such as a
    container) that could be false in a boolean context!
    """
    match = not noqa and COMPARE_SINGLETON_REGEX.search(logical_line)
    if match:
        same = (match.group(1) == '==')
        singleton = match.group(2)
        msg = "'if cond is %s:'" % (('' if same else 'not ') + singleton)
        if singleton in ('None',):
            code = 'E711'
        else:
            code = 'E712'
            nonzero = ((singleton == 'True' and same) or
                       (singleton == 'False' and not same))
            msg += " or 'if %scond:'" % ('' if nonzero else 'not ')
        yield match.start(1), ("%s comparison to %s should be %s" %
                               (code, singleton, msg))


def comparison_type(logical_line):
    """
    Object type comparisons should always use isinstance() instead of
    comparing types directly.

    Okay: if isinstance(obj, int):
    E721: if type(obj) is type(1):

    When checking if an object is a string, keep in mind that it might be a
    unicode string too! In Python 2.3, str and unicode have a common base
    class, basestring, so you can do:

    Okay: if isinstance(obj, basestring):
    Okay: if type(a1) is type(b1):
    """
    match = COMPARE_TYPE_REGEX.search(logical_line)
    if match:
        inst = match.group(1)
        if inst and isidentifier(inst) and inst not in SINGLETONS:
            return  # Allow comparison for types which are not obvious
        yield match.start(), "E721 do not compare types, use 'isinstance()'"


def python_3000_has_key(logical_line):
    r"""
    The {}.has_key() method is removed in the Python 3.
    Use the 'in' operation instead.

    Okay: if "alph" in d:\n    print d["alph"]
    W601: assert d.has_key('alph')
    """
    pos = logical_line.find('.has_key(')
    if pos > -1:
        yield pos, "W601 .has_key() is deprecated, use 'in'"


def python_3000_raise_comma(logical_line):
    """
    When raising an exception, use "raise ValueError('message')"
    instead of the older form "raise ValueError, 'message'".

    The paren-using form is preferred because when the exception arguments
    are long or include string formatting, you don't need to use line
    continuation characters thanks to the containing parentheses.  The older
    form is removed in Python 3.

    Okay: raise DummyError("Message")
    W602: raise DummyError, "Message"
    """
    match = RAISE_COMMA_REGEX.match(logical_line)
    if match and not RERAISE_COMMA_REGEX.match(logical_line):
        yield match.end() - 1, "W602 deprecated form of raising exception"


def python_3000_not_equal(logical_line):
    """
    != can also be written <>, but this is an obsolete usage kept for
    backwards compatibility only. New code should always use !=.
    The older syntax is removed in Python 3.

    Okay: if a != 'no':
    W603: if a <> 'no':
    """
    pos = logical_line.find('<>')
    if pos > -1:
        yield pos, "W603 '<>' is deprecated, use '!='"


def python_3000_backticks(logical_line):
    """
    Backticks are removed in Python 3.
    Use repr() instead.

    Okay: val = repr(1 + 2)
    W604: val = `1 + 2`
    """
    pos = logical_line.find('`')
    if pos > -1:
        yield pos, "W604 backticks are deprecated, use 'repr()'"


##############################################################################
# Helper functions
##############################################################################


if '' == ''.encode():
    # Python 2: implicit encoding.
    def readlines(filename):
        f = open(filename)
        try:
            return f.readlines()
        finally:
            f.close()
    isidentifier = re.compile(r'[a-zA-Z_]\w*').match
    stdin_get_value = sys.stdin.read
else:
    # Python 3
    def readlines(filename):
        f = open(filename, 'rb')
        try:
            coding, lines = tokenize.detect_encoding(f.readline)
            f = TextIOWrapper(f, coding, line_buffering=True)
            return [l.decode(coding) for l in lines] + f.readlines()
        except (LookupError, SyntaxError, UnicodeError):
            f.close()
            # Fall back if files are improperly declared
            f = open(filename, encoding='latin-1')
            return f.readlines()
        finally:
            f.close()
    isidentifier = str.isidentifier

    def stdin_get_value():
        return TextIOWrapper(sys.stdin.buffer, errors='ignore').read()
readlines.__doc__ = "    Read the source code."
noqa = re.compile(r'# no(?:qa|pep8)\b', re.I).search


def expand_indent(line):
    r"""
    Return the amount of indentation.
    Tabs are expanded to the next multiple of 8.

    >>> expand_indent('    ')
    4
    >>> expand_indent('\t')
    8
    >>> expand_indent('    \t')
    8
    >>> expand_indent('       \t')
    8
    >>> expand_indent('        \t')
    16
    """
    if '\t' not in line:
        return len(line) - len(line.lstrip())
    result = 0
    for char in line:
        if char == '\t':
            result = result // 8 * 8 + 8
        elif char == ' ':
            result += 1
        else:
            break
    return result


def mute_string(text):
    """
    Replace contents with 'xxx' to prevent syntax matching.

    >>> mute_string('"abc"')
    '"xxx"'
    >>> mute_string("'''abc'''")
    "'''xxx'''"
    >>> mute_string("r'abc'")
    "r'xxx'"
    """
    # String modifiers (e.g. u or r)
    start = text.index(text[-1]) + 1
    end = len(text) - 1
    # Triple quotes
    if text[-3:] in ('"""', "'''"):
        start += 2
        end -= 2
    return text[:start] + 'x' * (end - start) + text[end:]


def parse_udiff(diff, patterns=None, parent='.'):
    """Return a dictionary of matching lines."""
    # For each file of the diff, the entry key is the filename,
    # and the value is a set of row numbers to consider.
    rv = {}
    path = nrows = None
    for line in diff.splitlines():
        if nrows:
            if line[:1] != '-':
                nrows -= 1
            continue
        if line[:3] == '@@ ':
            hunk_match = HUNK_REGEX.match(line)
            row, nrows = [int(g or '1') for g in hunk_match.groups()]
            rv[path].update(range(row, row + nrows))
        elif line[:3] == '+++':
            path = line[4:].split('\t', 1)[0]
            if path[:2] == 'b/':
                path = path[2:]
            rv[path] = set()
    return dict([(os.path.join(parent, path), rows)
                 for (path, rows) in rv.items()
                 if rows and filename_match(path, patterns)])


def filename_match(filename, patterns, default=True):
    """
    Check if patterns contains a pattern that matches filename.
    If patterns is unspecified, this always returns True.
    """
    if not patterns:
        return default
    return any(fnmatch(filename, pattern) for pattern in patterns)


##############################################################################
# Framework to run all checks
##############################################################################


_checks = {'physical_line': {}, 'logical_line': {}, 'tree': {}}


def register_check(check, codes=None):
    """
    Register a new check object.
    """
    def _add_check(check, kind, codes, args):
        if check in _checks[kind]:
            _checks[kind][check][0].extend(codes or [])
        else:
            _checks[kind][check] = (codes or [''], args)
    if inspect.isfunction(check):
        args = inspect.getargspec(check)[0]
        if args and args[0] in ('physical_line', 'logical_line'):
            if codes is None:
                codes = ERRORCODE_REGEX.findall(check.__doc__ or '')
            _add_check(check, args[0], codes, args)
    elif inspect.isclass(check):
        if inspect.getargspec(check.__init__)[0][:2] == ['self', 'tree']:
            _add_check(check, 'tree', codes, None)


def init_checks_registry():
    """
    Register all globally visible functions where the first argument name
    is 'physical_line' or 'logical_line'.
    """
    mod = inspect.getmodule(register_check)
    for (name, function) in inspect.getmembers(mod, inspect.isfunction):
        register_check(function)
init_checks_registry()


class Checker(object):
    """
    Load a Python source file, tokenize it, check coding style.
    """

    def __init__(self, filename=None, lines=None,
                 options=None, report=None, **kwargs):
        if options is None:
            options = StyleGuide(kwargs).options
        else:
            assert not kwargs
        self._io_error = None
        self._physical_checks = options.physical_checks
        self._logical_checks = options.logical_checks
        self._ast_checks = options.ast_checks
        self.max_line_length = options.max_line_length
        self.hang_closing = options.hang_closing
        self.verbose = options.verbose
        self.filename = filename
        if filename is None:
            self.filename = 'stdin'
            self.lines = lines or []
        elif filename == '-':
            self.filename = 'stdin'
            self.lines = stdin_get_value().splitlines(True)
        elif lines is None:
            try:
                self.lines = readlines(filename)
            except IOError:
                exc_type, exc = sys.exc_info()[:2]
                self._io_error = '%s: %s' % (exc_type.__name__, exc)
                self.lines = []
        else:
            self.lines = lines
        if self.lines:
            ord0 = ord(self.lines[0][0])
            if ord0 in (0xef, 0xfeff):  # Strip the UTF-8 BOM
                if ord0 == 0xfeff:
                    self.lines[0] = self.lines[0][1:]
                elif self.lines[0][:3] == '\xef\xbb\xbf':
                    self.lines[0] = self.lines[0][3:]
        self.report = report or options.report
        self.report_error = self.report.error

    def report_invalid_syntax(self):
        exc_type, exc = sys.exc_info()[:2]
        if len(exc.args) > 1:
            offset = exc.args[1]
            if len(offset) > 2:
                offset = offset[1:3]
        else:
            offset = (1, 0)
        self.report_error(offset[0], offset[1] or 0,
                          'E901 %s: %s' % (exc_type.__name__, exc.args[0]),
                          self.report_invalid_syntax)
    report_invalid_syntax.__doc__ = "    Check if the syntax is valid."

    def readline(self):
        """
        Get the next line from the input buffer.
        """
        self.line_number += 1
        if self.line_number > len(self.lines):
            return ''
        return self.lines[self.line_number - 1]

    def readline_check_physical(self):
        """
        Check and return the next physical line. This method can be
        used to feed tokenize.generate_tokens.
        """
        line = self.readline()
        if line:
            self.check_physical(line)
        return line

    def run_check(self, check, argument_names):
        """
        Run a check plugin.
        """
        arguments = []
        for name in argument_names:
            arguments.append(getattr(self, name))
        return check(*arguments)

    def check_physical(self, line):
        """
        Run all physical checks on a raw input line.
        """
        self.physical_line = line
        if self.indent_char is None and line[:1] in WHITESPACE:
            self.indent_char = line[0]
        for name, check, argument_names in self._physical_checks:
            result = self.run_check(check, argument_names)
            if result is not None:
                offset, text = result
                self.report_error(self.line_number, offset, text, check)

    def build_tokens_line(self):
        """
        Build a logical line from tokens.
        """
        self.mapping = []
        logical = []
        comments = []
        length = 0
        previous = None
        for token in self.tokens:
            token_type, text = token[0:2]
            if token_type == tokenize.COMMENT:
                comments.append(text)
                continue
            if token_type in SKIP_TOKENS:
                continue
            if token_type == tokenize.STRING:
                text = mute_string(text)
            if previous:
                end_row, end = previous[3]
                start_row, start = token[2]
                if end_row != start_row:    # different row
                    prev_text = self.lines[end_row - 1][end - 1]
                    if prev_text == ',' or (prev_text not in '{[('
                                            and text not in '}])'):
                        logical.append(' ')
                        length += 1
                elif end != start:  # different column
                    fill = self.lines[end_row - 1][end:start]
                    logical.append(fill)
                    length += len(fill)
            self.mapping.append((length, token))
            logical.append(text)
            length += len(text)
            previous = token
        self.logical_line = ''.join(logical)
        self.noqa = comments and noqa(''.join(comments))
        # With Python 2, if the line ends with '\r\r\n' the assertion fails
        # assert self.logical_line.strip() == self.logical_line

    def check_logical(self):
        """
        Build a line from tokens and run all logical checks on it.
        """
        self.build_tokens_line()
        self.report.increment_logical_line()
        first_line = self.lines[self.mapping[0][1][2][0] - 1]
        indent = first_line[:self.mapping[0][1][2][1]]
        self.previous_indent_level = self.indent_level
        self.indent_level = expand_indent(indent)
        if self.verbose >= 2:
            print(self.logical_line[:80].rstrip())
        for name, check, argument_names in self._logical_checks:
            if self.verbose >= 4:
                print('   ' + name)
            for result in self.run_check(check, argument_names):
                offset, text = result
                if isinstance(offset, tuple):
                    orig_number, orig_offset = offset
                else:
                    for token_offset, token in self.mapping:
                        if offset >= token_offset:
                            orig_number = token[2][0]
                            orig_offset = (token[2][1] + offset - token_offset)
                self.report_error(orig_number, orig_offset, text, check)
        self.previous_logical = self.logical_line

    def check_ast(self):
        try:
            tree = compile(''.join(self.lines), '', 'exec', PyCF_ONLY_AST)
        except (SyntaxError, TypeError):
            return self.report_invalid_syntax()
        for name, cls, _ in self._ast_checks:
            checker = cls(tree, self.filename)
            for lineno, offset, text, check in checker.run():
                if not noqa(self.lines[lineno - 1]):
                    self.report_error(lineno, offset, text, check)

    def generate_tokens(self):
        if self._io_error:
            self.report_error(1, 0, 'E902 %s' % self._io_error, readlines)
        tokengen = tokenize.generate_tokens(self.readline_check_physical)
        try:
            for token in tokengen:
                yield token
        except (SyntaxError, tokenize.TokenError):
            self.report_invalid_syntax()

    def check_all(self, expected=None, line_offset=0):
        """
        Run all checks on the input file.
        """
        self.report.init_file(self.filename, self.lines, expected, line_offset)
        if self._ast_checks:
            self.check_ast()
        self.line_number = 0
        self.indent_char = None
        self.indent_level = 0
        self.previous_logical = ''
        self.tokens = []
        self.blank_lines = blank_lines_before_comment = 0
        parens = 0
        for token in self.generate_tokens():
            self.tokens.append(token)
            token_type, text = token[0:2]
            if self.verbose >= 3:
                if token[2][0] == token[3][0]:
                    pos = '[%s:%s]' % (token[2][1] or '', token[3][1])
                else:
                    pos = 'l.%s' % token[3][0]
                print('l.%s\t%s\t%s\t%r' %
                      (token[2][0], pos, tokenize.tok_name[token[0]], text))
            if token_type == tokenize.OP:
                if text in '([{':
                    parens += 1
                elif text in '}])':
                    parens -= 1
            elif not parens:
                if token_type == tokenize.NEWLINE:
                    if self.blank_lines < blank_lines_before_comment:
                        self.blank_lines = blank_lines_before_comment
                    self.check_logical()
                    self.tokens = []
                    self.blank_lines = blank_lines_before_comment = 0
                elif token_type == tokenize.NL:
                    if len(self.tokens) == 1:
                        # The physical line contains only this token.
                        self.blank_lines += 1
                    self.tokens = []
                elif token_type == tokenize.COMMENT and len(self.tokens) == 1:
                    if blank_lines_before_comment < self.blank_lines:
                        blank_lines_before_comment = self.blank_lines
                    self.blank_lines = 0
                    if COMMENT_WITH_NL:
                        # The comment also ends a physical line
                        self.tokens = []
        return self.report.get_file_results()


class BaseReport(object):
    """Collect the results of the checks."""
    print_filename = False

    def __init__(self, options):
        self._benchmark_keys = options.benchmark_keys
        self._ignore_code = options.ignore_code
        # Results
        self.elapsed = 0
        self.total_errors = 0
        self.counters = dict.fromkeys(self._benchmark_keys, 0)
        self.messages = {}

    def start(self):
        """Start the timer."""
        self._start_time = time.time()

    def stop(self):
        """Stop the timer."""
        self.elapsed = time.time() - self._start_time

    def init_file(self, filename, lines, expected, line_offset):
        """Signal a new file."""
        self.filename = filename
        self.lines = lines
        self.expected = expected or ()
        self.line_offset = line_offset
        self.file_errors = 0
        self.counters['files'] += 1
        self.counters['physical lines'] += len(lines)

    def increment_logical_line(self):
        """Signal a new logical line."""
        self.counters['logical lines'] += 1

    def error(self, line_number, offset, text, check):
        """Report an error, according to options."""
        code = text[:4]
        if self._ignore_code(code):
            return
        if code in self.counters:
            self.counters[code] += 1
        else:
            self.counters[code] = 1
            self.messages[code] = text[5:]
        # Don't care about expected errors or warnings
        if code in self.expected:
            return
        if self.print_filename and not self.file_errors:
            print(self.filename)
        self.file_errors += 1
        self.total_errors += 1
        return code

    def get_file_results(self):
        """Return the count of errors and warnings for this file."""
        return self.file_errors

    def get_count(self, prefix=''):
        """Return the total count of errors and warnings."""
        return sum([self.counters[key]
                    for key in self.messages if key.startswith(prefix)])

    def get_statistics(self, prefix=''):
        """
        Get statistics for message codes that start with the prefix.

        prefix='' matches all errors and warnings
        prefix='E' matches all errors
        prefix='W' matches all warnings
        prefix='E4' matches all errors that have to do with imports
        """
        return ['%-7s %s %s' % (self.counters[key], key, self.messages[key])
                for key in sorted(self.messages) if key.startswith(prefix)]

    def print_statistics(self, prefix=''):
        """Print overall statistics (number of errors and warnings)."""
        for line in self.get_statistics(prefix):
            print(line)

    def print_benchmark(self):
        """Print benchmark numbers."""
        print('%-7.2f %s' % (self.elapsed, 'seconds elapsed'))
        if self.elapsed:
            for key in self._benchmark_keys:
                print('%-7d %s per second (%d total)' %
                      (self.counters[key] / self.elapsed, key,
                       self.counters[key]))


class FileReport(BaseReport):
    """Collect the results of the checks and print only the filenames."""
    print_filename = True


class StandardReport(BaseReport):
    """Collect and print the results of the checks."""

    def __init__(self, options):
        super(StandardReport, self).__init__(options)
        self._fmt = REPORT_FORMAT.get(options.format.lower(),
                                      options.format)
        self._repeat = options.repeat
        self._show_source = options.show_source
        self._show_pep8 = options.show_pep8

    def init_file(self, filename, lines, expected, line_offset):
        """Signal a new file."""
        self._deferred_print = []
        return super(StandardReport, self).init_file(
            filename, lines, expected, line_offset)

    def error(self, line_number, offset, text, check):
        """Report an error, according to options."""
        code = super(StandardReport, self).error(line_number, offset,
                                                 text, check)
        if code and (self.counters[code] == 1 or self._repeat):
            self._deferred_print.append(
                (line_number, offset, code, text[5:], check.__doc__))
        return code

    def get_file_results(self):
        """Print the result and return the overall count for this file."""
        self._deferred_print.sort()
        for line_number, offset, code, text, doc in self._deferred_print:
            print(self._fmt % {
                'path': self.filename,
                'row': self.line_offset + line_number, 'col': offset + 1,
                'code': code, 'text': text,
            })
            if self._show_source:
                if line_number > len(self.lines):
                    line = ''
                else:
                    line = self.lines[line_number - 1]
                print(line.rstrip())
                print(' ' * offset + '^')
            if self._show_pep8 and doc:
                print(doc.lstrip('\n').rstrip())
        return self.file_errors


class DiffReport(StandardReport):
    """Collect and print the results for the changed lines only."""

    def __init__(self, options):
        super(DiffReport, self).__init__(options)
        self._selected = options.selected_lines

    def error(self, line_number, offset, text, check):
        if line_number not in self._selected[self.filename]:
            return
        return super(DiffReport, self).error(line_number, offset, text, check)


class StyleGuide(object):
    """Initialize a PEP-8 instance with few options."""

    def __init__(self, *args, **kwargs):
        # build options from the command line
        self.checker_class = kwargs.pop('checker_class', Checker)
        parse_argv = kwargs.pop('parse_argv', False)
        config_file = kwargs.pop('config_file', None)
        parser = kwargs.pop('parser', None)
        options, self.paths = process_options(
            parse_argv=parse_argv, config_file=config_file, parser=parser)
        if args or kwargs:
            # build options from dict
            options_dict = dict(*args, **kwargs)
            options.__dict__.update(options_dict)
            if 'paths' in options_dict:
                self.paths = options_dict['paths']

        self.runner = self.input_file
        self.options = options

        if not options.reporter:
            options.reporter = BaseReport if options.quiet else StandardReport

        for index, value in enumerate(options.exclude):
            options.exclude[index] = value.rstrip('/')
        options.select = tuple(options.select or ())
        if not (options.select or options.ignore or
                options.testsuite or options.doctest) and DEFAULT_IGNORE:
            # The default choice: ignore controversial checks
            options.ignore = tuple(DEFAULT_IGNORE.split(','))
        else:
            # Ignore all checks which are not explicitly selected
            options.ignore = ('',) if options.select else tuple(options.ignore)
        options.benchmark_keys = BENCHMARK_KEYS[:]
        options.ignore_code = self.ignore_code
        options.physical_checks = self.get_checks('physical_line')
        options.logical_checks = self.get_checks('logical_line')
        options.ast_checks = self.get_checks('tree')
        self.init_report()

    def init_report(self, reporter=None):
        """Initialize the report instance."""
        self.options.report = (reporter or self.options.reporter)(self.options)
        return self.options.report

    def check_files(self, paths=None):
        """Run all checks on the paths."""
        if paths is None:
            paths = self.paths
        report = self.options.report
        runner = self.runner
        report.start()
        try:
            for path in paths:
                if os.path.isdir(path):
                    self.input_dir(path)
                elif not self.excluded(path):
                    runner(path)
        except KeyboardInterrupt:
            print('... stopped')
        report.stop()
        return report

    def input_file(self, filename, lines=None, expected=None, line_offset=0):
        """Run all checks on a Python source file."""
        if self.options.verbose:
            print('checking %s' % filename)
        fchecker = self.checker_class(
            filename, lines=lines, options=self.options)
        return fchecker.check_all(expected=expected, line_offset=line_offset)

    def input_dir(self, dirname):
        """Check all files in this directory and all subdirectories."""
        dirname = dirname.rstrip('/')
        if self.excluded(dirname):
            return 0
        counters = self.options.report.counters
        verbose = self.options.verbose
        filepatterns = self.options.filename
        runner = self.runner
        for root, dirs, files in os.walk(dirname):
            if verbose:
                print('directory ' + root)
            counters['directories'] += 1
            for subdir in sorted(dirs):
                if self.excluded(subdir, root):
                    dirs.remove(subdir)
            for filename in sorted(files):
                # contain a pattern that matches?
                if ((filename_match(filename, filepatterns) and
                     not self.excluded(filename, root))):
                    runner(os.path.join(root, filename))

    def excluded(self, filename, parent=None):
        """
        Check if options.exclude contains a pattern that matches filename.
        """
        if not self.options.exclude:
            return False
        basename = os.path.basename(filename)
        if filename_match(basename, self.options.exclude):
            return True
        if parent:
            filename = os.path.join(parent, filename)
        return filename_match(filename, self.options.exclude)

    def ignore_code(self, code):
        """
        Check if the error code should be ignored.

        If 'options.select' contains a prefix of the error code,
        return False.  Else, if 'options.ignore' contains a prefix of
        the error code, return True.
        """
        return (code.startswith(self.options.ignore) and
                not code.startswith(self.options.select))

    def get_checks(self, argument_name):
        """
        Find all globally visible functions where the first argument name
        starts with argument_name and which contain selected tests.
        """
        checks = []
        for check, attrs in _checks[argument_name].items():
            (codes, args) = attrs
            if any(not (code and self.ignore_code(code)) for code in codes):
                checks.append((check.__name__, check, args))
        return sorted(checks)


def get_parser(prog='pep8', version=__version__):
    parser = OptionParser(prog=prog, version=version,
                          usage="%prog [options] input ...")
    parser.config_options = [
        'exclude', 'filename', 'select', 'ignore', 'max-line-length',
        'hang-closing', 'count', 'format', 'quiet', 'show-pep8',
        'show-source', 'statistics', 'verbose']
    parser.add_option('-v', '--verbose', default=0, action='count',
                      help="print status messages, or debug with -vv")
    parser.add_option('-q', '--quiet', default=0, action='count',
                      help="report only file names, or nothing with -qq")
    parser.add_option('-r', '--repeat', default=True, action='store_true',
                      help="(obsolete) show all occurrences of the same error")
    parser.add_option('--first', action='store_false', dest='repeat',
                      help="show first occurrence of each error")
    parser.add_option('--exclude', metavar='patterns', default=DEFAULT_EXCLUDE,
                      help="exclude files or directories which match these "
                           "comma separated patterns (default: %default)")
    parser.add_option('--filename', metavar='patterns', default='*.py',
                      help="when parsing directories, only check filenames "
                           "matching these comma separated patterns "
                           "(default: %default)")
    parser.add_option('--select', metavar='errors', default='',
                      help="select errors and warnings (e.g. E,W6)")
    parser.add_option('--ignore', metavar='errors', default='',
                      help="skip errors and warnings (e.g. E4,W)")
    parser.add_option('--show-source', action='store_true',
                      help="show source code for each error")
    parser.add_option('--show-pep8', action='store_true',
                      help="show text of PEP 8 for each error "
                           "(implies --first)")
    parser.add_option('--statistics', action='store_true',
                      help="count errors and warnings")
    parser.add_option('--count', action='store_true',
                      help="print total number of errors and warnings "
                           "to standard error and set exit code to 1 if "
                           "total is not null")
    parser.add_option('--max-line-length', type='int', metavar='n',
                      default=MAX_LINE_LENGTH,
                      help="set maximum allowed line length "
                           "(default: %default)")
    parser.add_option('--hang-closing', action='store_true',
                      help="hang closing bracket instead of matching "
                           "indentation of opening bracket's line")
    parser.add_option('--format', metavar='format', default='default',
                      help="set the error format [default|pylint|<custom>]")
    parser.add_option('--diff', action='store_true',
                      help="report only lines changed according to the "
                           "unified diff received on STDIN")
    group = parser.add_option_group("Testing Options")
    if os.path.exists(TESTSUITE_PATH):
        group.add_option('--testsuite', metavar='dir',
                         help="run regression tests from dir")
        group.add_option('--doctest', action='store_true',
                         help="run doctest on myself")
    group.add_option('--benchmark', action='store_true',
                     help="measure processing speed")
    return parser


def read_config(options, args, arglist, parser):
    """Read both user configuration and local configuration."""
    config = RawConfigParser()

    user_conf = options.config
    if user_conf and os.path.isfile(user_conf):
        if options.verbose:
            print('user configuration: %s' % user_conf)
        config.read(user_conf)

    parent = tail = args and os.path.abspath(os.path.commonprefix(args))
    while tail:
        if config.read([os.path.join(parent, fn) for fn in PROJECT_CONFIG]):
            if options.verbose:
                print('local configuration: in %s' % parent)
            break
        parent, tail = os.path.split(parent)

    pep8_section = parser.prog
    if config.has_section(pep8_section):
        option_list = dict([(o.dest, o.type or o.action)
                            for o in parser.option_list])

        # First, read the default values
        new_options, _ = parser.parse_args([])

        # Second, parse the configuration
        for opt in config.options(pep8_section):
            if options.verbose > 1:
                print("  %s = %s" % (opt, config.get(pep8_section, opt)))
            if opt.replace('_', '-') not in parser.config_options:
                print("Unknown option: '%s'\n  not in [%s]" %
                      (opt, ' '.join(parser.config_options)))
                sys.exit(1)
            normalized_opt = opt.replace('-', '_')
            opt_type = option_list[normalized_opt]
            if opt_type in ('int', 'count'):
                value = config.getint(pep8_section, opt)
            elif opt_type == 'string':
                value = config.get(pep8_section, opt)
            else:
                assert opt_type in ('store_true', 'store_false')
                value = config.getboolean(pep8_section, opt)
            setattr(new_options, normalized_opt, value)

        # Third, overwrite with the command-line options
        options, _ = parser.parse_args(arglist, values=new_options)
    options.doctest = options.testsuite = False
    return options


def process_options(arglist=None, parse_argv=False, config_file=None,
                    parser=None):
    """Process options passed either via arglist or via command line args."""
    if not arglist and not parse_argv:
        # Don't read the command line if the module is used as a library.
        arglist = []
    if not parser:
        parser = get_parser()
    if not parser.has_option('--config'):
        if config_file:
            config_file = DEFAULT_CONFIG
        group = parser.add_option_group("Configuration", description=(
            "The project options are read from the [%s] section of the "
            "tox.ini file or the setup.cfg file located in any parent folder "
            "of the path(s) being processed.  Allowed options are: %s." %
            (parser.prog, ', '.join(parser.config_options))))
        group.add_option('--config', metavar='path', default=config_file,
                         help="user config file location (default: %default)")
    options, args = parser.parse_args(arglist)
    options.reporter = None

    if options.ensure_value('testsuite', False):
        args.append(options.testsuite)
    elif not options.ensure_value('doctest', False):
        if parse_argv and not args:
            if options.diff or any(os.path.exists(name)
                                   for name in PROJECT_CONFIG):
                args = ['.']
            else:
                parser.error('input not specified')
        options = read_config(options, args, arglist, parser)
        options.reporter = parse_argv and options.quiet == 1 and FileReport

    options.filename = options.filename and options.filename.split(',')
    options.exclude = options.exclude.split(',')
    options.select = options.select and options.select.split(',')
    options.ignore = options.ignore and options.ignore.split(',')

    if options.diff:
        options.reporter = DiffReport
        stdin = stdin_get_value()
        options.selected_lines = parse_udiff(stdin, options.filename, args[0])
        args = sorted(options.selected_lines)

    return options, args


def _main():
    """Parse options and run checks on Python source."""
    pep8style = StyleGuide(parse_argv=True, config_file=True)
    options = pep8style.options
    if options.doctest or options.testsuite:
        from testsuite.support import run_tests
        report = run_tests(pep8style)
    else:
        report = pep8style.check_files()
    if options.statistics:
        report.print_statistics()
    if options.benchmark:
        report.print_benchmark()
    if options.testsuite and not options.quiet:
        report.print_results()
    if report.total_errors:
        if options.count:
            sys.stderr.write(str(report.total_errors) + '\n')
        sys.exit(1)

if __name__ == '__main__':
    _main()

########NEW FILE########
