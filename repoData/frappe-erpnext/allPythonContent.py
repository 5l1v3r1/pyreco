__FILENAME__ = account
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt, cstr, cint, getdate, add_days, formatdate
from frappe import msgprint, throw, _
from frappe.model.document import Document

class Account(Document):
	nsm_parent_field = 'parent_account'

	def onload(self):
		frozen_accounts_modifier = frappe.db.get_value("Accounts Settings", "Accounts Settings", "frozen_accounts_modifier")
		if frozen_accounts_modifier in frappe.user.get_roles():
			self.get("__onload").can_freeze_account = True


	def autoname(self):
		self.name = self.account_name.strip() + ' - ' + \
			frappe.db.get_value("Company", self.company, "abbr")

	def get_address(self):
		return {'address': frappe.db.get_value(self.master_type, self.master_name, "address")}

	def validate(self):
		self.validate_master_name()
		self.validate_parent()
		self.validate_root_details()
		self.validate_mandatory()
		self.validate_warehouse_account()
		self.validate_frozen_accounts_modifier()

	def validate_master_name(self):
		if self.master_type in ('Customer', 'Supplier') or self.account_type == "Warehouse":
			if not self.master_name:
				msgprint(_("Please enter Master Name once the account is created."))
			elif not frappe.db.exists(self.master_type or self.account_type, self.master_name):
				throw(_("Invalid Master Name"))

	def validate_parent(self):
		"""Fetch Parent Details and validation for account not to be created under ledger"""
		if self.parent_account:
			par = frappe.db.get_value("Account", self.parent_account,
				["name", "group_or_ledger", "report_type", "root_type"], as_dict=1)
			if not par:
				throw(_("Parent account does not exist"))
			elif par["name"] == self.name:
				throw(_("You can not assign itself as parent account"))
			elif par["group_or_ledger"] != 'Group':
				throw(_("Parent account can not be a ledger"))

			if par["report_type"]:
				self.report_type = par["report_type"]
			if par["root_type"]:
				self.root_type = par["root_type"]

	def validate_root_details(self):
		#does not exists parent
		if frappe.db.exists("Account", self.name):
			if not frappe.db.get_value("Account", self.name, "parent_account"):
				throw(_("Root cannot be edited."))

	def validate_frozen_accounts_modifier(self):
		old_value = frappe.db.get_value("Account", self.name, "freeze_account")
		if old_value and old_value != self.freeze_account:
			frozen_accounts_modifier = frappe.db.get_value('Accounts Settings', None, 'frozen_accounts_modifier')
			if not frozen_accounts_modifier or \
				frozen_accounts_modifier not in frappe.user.get_roles():
					throw(_("You are not authorized to set Frozen value"))

	def convert_group_to_ledger(self):
		if self.check_if_child_exists():
			throw(_("Account with child nodes cannot be converted to ledger"))
		elif self.check_gle_exists():
			throw(_("Account with existing transaction cannot be converted to ledger"))
		else:
			self.group_or_ledger = 'Ledger'
			self.save()
			return 1

	def convert_ledger_to_group(self):
		if self.check_gle_exists():
			throw(_("Account with existing transaction can not be converted to group."))
		elif self.master_type or self.account_type:
			throw(_("Cannot covert to Group because Master Type or Account Type is selected."))
		else:
			self.group_or_ledger = 'Group'
			self.save()
			return 1

	# Check if any previous balance exists
	def check_gle_exists(self):
		return frappe.db.get_value("GL Entry", {"account": self.name})

	def check_if_child_exists(self):
		return frappe.db.sql("""select name from `tabAccount` where parent_account = %s
			and docstatus != 2""", self.name)

	def validate_mandatory(self):
		if not self.report_type:
			throw(_("Report Type is mandatory"))

		if not self.root_type:
			throw(_("Root Type is mandatory"))

	def validate_warehouse_account(self):
		if not cint(frappe.defaults.get_global_default("auto_accounting_for_stock")):
			return

		if self.account_type == "Warehouse":
			old_warehouse = cstr(frappe.db.get_value("Account", self.name, "master_name"))
			if old_warehouse != cstr(self.master_name):
				if old_warehouse:
					self.validate_warehouse(old_warehouse)
				if self.master_name:
					self.validate_warehouse(self.master_name)
				else:
					throw(_("Master Name is mandatory if account type is Warehouse"))

	def validate_warehouse(self, warehouse):
		if frappe.db.get_value("Stock Ledger Entry", {"warehouse": warehouse}):
			throw(_("Stock entries exist against warehouse {0} cannot re-assign or modify 'Master Name'").format(warehouse))

	def update_nsm_model(self):
		"""update lft, rgt indices for nested set model"""
		import frappe
		import frappe.utils.nestedset
		frappe.utils.nestedset.update_nsm(self)

	def on_update(self):
		self.update_nsm_model()

	def get_authorized_user(self):
		# Check logged-in user is authorized
		if frappe.db.get_value('Accounts Settings', None, 'credit_controller') \
				in frappe.user.get_roles():
			return 1

	def check_credit_limit(self, total_outstanding):
		# Get credit limit
		credit_limit_from = 'Customer'

		cr_limit = frappe.db.sql("""select t1.credit_limit from tabCustomer t1, `tabAccount` t2
			where t2.name=%s and t1.name = t2.master_name""", self.name)
		credit_limit = cr_limit and flt(cr_limit[0][0]) or 0
		if not credit_limit:
			credit_limit = frappe.db.get_value('Company', self.company, 'credit_limit')
			credit_limit_from = 'Company'

		# If outstanding greater than credit limit and not authorized person raise exception
		if credit_limit > 0 and flt(total_outstanding) > credit_limit \
				and not self.get_authorized_user():
			throw(_("{0} Credit limit {0} crossed").format(_(credit_limit_from), credit_limit))

	def validate_due_date(self, posting_date, due_date):
		credit_days = (self.credit_days or frappe.db.get_value("Company", self.company, "credit_days"))
		if credit_days is None:
			return

		posting_date, due_date = getdate(posting_date), getdate(due_date)
		diff = (due_date - posting_date).days

		if diff < 0:
			frappe.throw(_("Due Date cannot be before Posting Date"))
		elif diff > credit_days:
			is_credit_controller = frappe.db.get_value("Accounts Settings", None,
				"credit_controller") in frappe.user.get_roles()

			if is_credit_controller:
				msgprint(_("Note: Due Date exceeds the allowed credit days by {0} day(s)").format(
					diff - credit_days))
			else:
				max_due_date = formatdate(add_days(posting_date, credit_days))
				frappe.throw(_("Due Date cannot be after {0}").format(max_due_date))

	def validate_trash(self):
		"""checks gl entries and if child exists"""
		if not self.parent_account:
			throw(_("Root account can not be deleted"))

		if self.check_gle_exists():
			throw(_("Account with existing transaction can not be deleted"))
		if self.check_if_child_exists():
			throw(_("Child account exists for this account. You can not delete this account."))

	def on_trash(self):
		self.validate_trash()
		self.update_nsm_model()

	def before_rename(self, old, new, merge=False):
		# Add company abbr if not provided
		from erpnext.setup.doctype.company.company import get_name_with_abbr
		new_account = get_name_with_abbr(new, self.company)

		# Validate properties before merging
		if merge:
			if not frappe.db.exists("Account", new):
				throw(_("Account {0} does not exist").format(new))

			val = list(frappe.db.get_value("Account", new_account,
				["group_or_ledger", "root_type", "company"]))

			if val != [self.group_or_ledger, self.root_type, self.company]:
				throw(_("""Merging is only possible if following properties are same in both records. Group or Ledger, Root Type, Company"""))

		return new_account

	def after_rename(self, old, new, merge=False):
		if not merge:
			frappe.db.set_value("Account", new, "account_name",
				" - ".join(new.split(" - ")[:-1]))
		else:
			from frappe.utils.nestedset import rebuild_tree
			rebuild_tree("Account", "parent_account")

def get_master_name(doctype, txt, searchfield, start, page_len, filters):
	conditions = (" and company='%s'"% filters["company"].replace("'", "\'")) if doctype == "Warehouse" else ""

	return frappe.db.sql("""select name from `tab%s` where %s like %s %s
		order by name limit %s, %s""" %
		(filters["master_type"], searchfield, "%s", conditions, "%s", "%s"),
		("%%%s%%" % txt, start, page_len), as_list=1)

def get_parent_account(doctype, txt, searchfield, start, page_len, filters):
	return frappe.db.sql("""select name from tabAccount
		where group_or_ledger = 'Group' and docstatus != 2 and company = %s
		and %s like %s order by name limit %s, %s""" %
		("%s", searchfield, "%s", "%s", "%s"),
		(filters["company"], "%%%s%%" % txt, start, page_len), as_list=1)

########NEW FILE########
__FILENAME__ = test_account
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def _make_test_records(verbose):
	from frappe.test_runner import make_test_objects
		
	accounts = [
		# [account_name, parent_account, group_or_ledger]
		["_Test Account Bank Account", "Bank Accounts", "Ledger", "Bank"],
		
		["_Test Account Stock Expenses", "Direct Expenses", "Group", None],
		["_Test Account Shipping Charges", "_Test Account Stock Expenses", "Ledger", "Chargeable"],
		["_Test Account Customs Duty", "_Test Account Stock Expenses", "Ledger", "Tax"],
		
		
		["_Test Account Tax Assets", "Current Assets", "Group", None],
		["_Test Account VAT", "_Test Account Tax Assets", "Ledger", "Tax"],
		["_Test Account Service Tax", "_Test Account Tax Assets", "Ledger", "Tax"],
		
		["_Test Account Reserves and Surplus", "Current Liabilities", "Ledger", None],

		["_Test Account Cost for Goods Sold", "Expenses", "Ledger", None],
		["_Test Account Excise Duty", "_Test Account Tax Assets", "Ledger", "Tax"],
		["_Test Account Education Cess", "_Test Account Tax Assets", "Ledger", "Tax"],
		["_Test Account S&H Education Cess", "_Test Account Tax Assets", "Ledger", "Tax"],
		["_Test Account CST", "Direct Expenses", "Ledger", "Tax"],
		["_Test Account Discount", "Direct Expenses", "Ledger", None],
		
		# related to Account Inventory Integration
		["_Test Account Stock In Hand", "Current Assets", "Ledger", None],
		["_Test Account Fixed Assets", "Current Assets", "Ledger", None],
	]

	for company, abbr in [["_Test Company", "_TC"], ["_Test Company 1", "_TC1"]]:
		test_objects = make_test_objects("Account", [{
				"doctype": "Account",
				"account_name": account_name,
				"parent_account": parent_account + " - " + abbr,
				"company": company,
				"group_or_ledger": group_or_ledger,
				"account_type": account_type
			} for account_name, parent_account, group_or_ledger, account_type in accounts])
	
	return test_objects
########NEW FILE########
__FILENAME__ = accounts_settings
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.utils import cint, comma_and
from frappe.model.document import Document

class AccountsSettings(Document):
	def on_update(self):
		frappe.db.set_default("auto_accounting_for_stock", self.auto_accounting_for_stock)

		if cint(self.auto_accounting_for_stock):
			# set default perpetual account in company
			for company in frappe.db.sql("select name from tabCompany"):
				frappe.get_doc("Company", company[0]).save()

			# Create account head for warehouses
			warehouse_list = frappe.db.sql("select name, company from tabWarehouse", as_dict=1)
			warehouse_with_no_company = [d.name for d in warehouse_list if not d.company]
			if warehouse_with_no_company:
				frappe.throw(_("Company is missing in warehouses {0}").format(comma_and(warehouse_with_no_company)))
			for wh in warehouse_list:
				wh_doc = frappe.get_doc("Warehouse", wh.name)
				wh_doc.save()

########NEW FILE########
__FILENAME__ = bank_reconciliation
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt, getdate, nowdate
from frappe import msgprint, _
from frappe.model.document import Document

class BankReconciliation(Document):
	def get_details(self):
		if not (self.bank_account and self.from_date and self.to_date):
			msgprint("Bank Account, From Date and To Date are Mandatory")
			return

		condition = ""
		if not self.include_reconciled_entries:
			condition = "and ifnull(clearance_date, '') in ('', '0000-00-00')"


		dl = frappe.db.sql("""select t1.name, t1.cheque_no, t1.cheque_date, t2.debit,
				t2.credit, t1.posting_date, t2.against_account, t1.clearance_date
			from
				`tabJournal Voucher` t1, `tabJournal Voucher Detail` t2
			where
				t2.parent = t1.name and t2.account = %s
				and t1.posting_date >= %s and t1.posting_date <= %s and t1.docstatus=1 %s""" %
				('%s', '%s', '%s', condition), (self.bank_account, self.from_date, self.to_date), as_dict=1)

		self.set('entries', [])
		self.total_amount = 0.0

		for d in dl:
			nl = self.append('entries', {})
			nl.posting_date = d.posting_date
			nl.voucher_id = d.name
			nl.cheque_number = d.cheque_no
			nl.cheque_date = d.cheque_date
			nl.debit = d.debit
			nl.credit = d.credit
			nl.against_account = d.against_account
			nl.clearance_date = d.clearance_date
			self.total_amount += flt(d.debit) - flt(d.credit)

	def update_details(self):
		vouchers = []
		for d in self.get('entries'):
			if d.clearance_date:
				if d.cheque_date and getdate(d.clearance_date) < getdate(d.cheque_date):
					frappe.throw(_("Clearance date cannot be before check date in row {0}").format(d.idx))

				frappe.db.set_value("Journal Voucher", d.voucher_id, "clearance_date", d.clearance_date)
				frappe.db.sql("""update `tabJournal Voucher` set clearance_date = %s, modified = %s
					where name=%s""", (d.clearance_date, nowdate(), d.voucher_id))
				vouchers.append(d.voucher_id)

		if vouchers:
			msgprint("Clearance Date updated in: {0}".format(", ".join(vouchers)))
		else:
			msgprint(_("Clearance Date not mentioned"))

########NEW FILE########
__FILENAME__ = bank_reconciliation_detail
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.model.document import Document

class BankReconciliationDetail(Document):
	pass
########NEW FILE########
__FILENAME__ = budget_detail
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.model.document import Document

class BudgetDetail(Document):
	pass
########NEW FILE########
__FILENAME__ = budget_distribution
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt
from frappe import _
from frappe.model.document import Document

class BudgetDistribution(Document):
	def get_months(self):
		month_list = ['January','February','March','April','May','June','July','August','September',
		'October','November','December']
		idx =1
		for m in month_list:
			mnth = self.append('budget_distribution_details')
			mnth.month = m
			mnth.idx = idx
			idx += 1

	def validate(self):
		total = sum([flt(d.percentage_allocation) for d in self.get("budget_distribution_details")])

		if total != 100.0:
			frappe.throw(_("Percentage Allocation should be equal to 100%"))

########NEW FILE########
__FILENAME__ = test_budget_distribution
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Budget Distribution')
########NEW FILE########
__FILENAME__ = budget_distribution_detail
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.model.document import Document

class BudgetDistributionDetail(Document):
	pass
########NEW FILE########
__FILENAME__ = account_properties
account_properties = {
	"Deutscher Kontenplan SKR03": {
		"Bilanzkonten": {
			"report_type": "Balance Sheet",
		},
		"Gewinn u. Verlust": {
			"report_type": "Profit and Loss",
		},
		"Vortrags- Kapital- und Statistische Konten": {
			"report_type": "Balance Sheet"
		}
	}
}
########NEW FILE########
__FILENAME__ = import_from_openerp
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

"""
Import chart of accounts from OpenERP sources
"""
from __future__ import unicode_literals

import os, json
import ast
from xml.etree import ElementTree as ET
from frappe.utils.datautils import read_csv_content
from frappe.utils import cstr
import frappe


path = "/Users/nabinhait/Documents/openerp/openerp/addons"

accounts = {}
charts = {}
all_account_types = []

def go():
	global accounts, charts
	default_account_types = get_default_account_types()
	
	country_dirs = []
	for basepath, folders, files in os.walk(path):
		basename = os.path.basename(basepath)
		if basename.startswith("l10n_"):
			country_dirs.append(basename)
	
	for country_dir in country_dirs:
		accounts, charts = {}, {}
		country_path = os.path.join(path, country_dir)
		manifest = ast.literal_eval(open(os.path.join(country_path, "__openerp__.py")).read())
		data_files = manifest.get("data", []) + manifest.get("init_xml", []) + \
			manifest.get("update_xml", [])
		files_path = [os.path.join(country_path, d) for d in data_files]
		xml_roots = get_xml_roots(files_path)
		csv_content = get_csv_contents(files_path)
		prefix = country_dir if csv_content else None
		account_types = get_account_types(xml_roots.get("account.account.type", []), 
			csv_content.get("account.account.type", []), prefix)
		account_types.update(default_account_types)
		
		if xml_roots:
			make_maps_for_xml(xml_roots, account_types, country_dir)

		if csv_content:
			make_maps_for_csv(csv_content, account_types, country_dir)
		make_account_trees()
		make_charts()
		
def get_default_account_types():
	default_types_root = []
	for file in ["data_account_type.xml"]:
		default_types_root.append(ET.parse(os.path.join(path, "account", "data", 
			"data_account_type.xml")).getroot())
	return get_account_types(default_types_root, None, prefix="account")
					
def get_xml_roots(files_path):
	xml_roots = frappe._dict()
	for filepath in files_path:
		fname = os.path.basename(filepath)
		if fname.endswith(".xml"):
			tree = ET.parse(filepath)
			root = tree.getroot()
			for node in root[0].findall("record"):
				if node.get("model") in ["account.account.template", 
					"account.chart.template", "account.account.type"]:
					xml_roots.setdefault(node.get("model"), []).append(root)
					break
	return xml_roots
	
def get_csv_contents(files_path):
	csv_content = {}
	for filepath in files_path:
		fname = os.path.basename(filepath)
		for file_type in ["account.account.template", "account.account.type", 
				"account.chart.template"]:
			if fname.startswith(file_type) and fname.endswith(".csv"):
				with open(filepath, "r") as csvfile:
					try:
						csv_content.setdefault(file_type, [])\
							.append(read_csv_content(csvfile.read()))
					except Exception, e:
						continue
	return csv_content
	
def get_account_types(root_list, csv_content, prefix=None):
	types = {}
	account_type_map = {
		'cash': 'Cash', 
		'bank': 'Bank', 
		'tr_cash': 'Cash', 
		'tr_bank': 'Bank',
		'receivable': 'Receivable', 
		'tr_receivable': 'Receivable',
		'account rec': 'Receivable',
		'payable': 'Payable', 
		'tr_payable': 'Payable', 
		'equity': 'Equity', 
		'stocks': 'Stock', 
		'stock': 'Stock', 
		'tax': 'Tax', 
		'tr_tax': 'Tax', 
		'tax-out': 'Tax', 
		'tax-in': 'Tax',
		'charges_personnel': 'Chargeable', 
		'fixed asset': 'Fixed Asset',
		'cogs': 'Cost of Goods Sold',

	}
	for root in root_list:
		for node in root[0].findall("record"):
			if node.get("model")=="account.account.type":
				data = {}
				for field in node.findall("field"):
					if field.get("name")=="report_type" and field.text.lower() != "none":
						data["report_type"] = get_report_type(field.text.title())
					if field.get("name")=="code" and field.text.lower() != "none" \
						and account_type_map.get(field.text):
							data["account_type"] = account_type_map[field.text]
						
				node_id = prefix + "." + node.get("id") if prefix else node.get("id")
				types[node_id] = data
				
	if csv_content and csv_content[0][0]=="id":
		for row in csv_content[1:]:
			row_dict = dict(zip(csv_content[0], row))
			data = {}
			if row_dict.get("report_type"):
				data["report_type"] = get_report_type(row_dict.get("report_type"))
			if row_dict.get("code") and account_type_map.get(row_dict["code"]):
				data["account_type"] = account_type_map[row_dict["code"]]
			if data and data.get("id"):
				node_id = prefix + "." + data.get("id") if prefix else data.get("id")
				types[node_id] = data
	return types
	
def get_report_type(report_type):
	report_type_map = {
		"asset": "Balance Sheet",
		"liability": "Balance Sheet",
		"equity": "Balance Sheet",
		"expense": "Profit and Loss",
		"income": "Profit and Loss"
	}
	
	for d in report_type_map:
		if d in report_type.lower():
			return report_type_map[d]
	
def make_maps_for_xml(xml_roots, account_types, country_dir):
	"""make maps for `charts` and `accounts`"""	
	for model, root_list in xml_roots.iteritems():
		for root in root_list:
			for node in root[0].findall("record"):
				if node.get("model")=="account.account.template":
					data = {}
					for field in node.findall("field"):
						if field.get("name")=="name":
							data["name"] = field.text
						if field.get("name")=="parent_id":
							parent_id = field.get("ref") or field.get("eval")
							data["parent_id"] = parent_id
							
						if field.get("name")=="user_type":
							value = field.get("ref")
							if account_types.get(value, {}).get("report_type"):
								data["report_type"] = account_types[value]["report_type"]
								
							if account_types.get(value, {}).get("account_type"):
								data["account_type"] = account_types[value]["account_type"]
								if data["account_type"] not in all_account_types:
									all_account_types.append(data["account_type"])

					data["children"] = []
					accounts[node.get("id")] = data
				
				if node.get("model")=="account.chart.template":
					data = {}
					for field in node.findall("field"):
						if field.get("name")=="name":
							data["name"] = field.text
						if field.get("name")=="account_root_id":
							data["account_root_id"] = field.get("ref")
						data["id"] = country_dir
					charts.setdefault(node.get("id"), {}).update(data)

def make_account_trees():
	"""build tree hierarchy"""
	for id in accounts.keys():
		account = accounts[id]
		if account.get("parent_id"):
			if accounts.get(account["parent_id"]):
				accounts[account["parent_id"]]["children"].append(account)
			del account["parent_id"]

	# remove empty children
	for id in accounts.keys():
		if "children" in accounts[id] and not accounts[id].get("children"):
			del accounts[id]["children"]
	
def make_maps_for_csv(csv_content, account_types, country_dir):
	for content in csv_content.get("account.account.template", []):
		for row in content[1:]:
			data = dict(zip(content[0], row))
			account = {
				"name": data.get("name"),
				"parent_id": data.get("parent_id:id") or data.get("parent_id/id"),
				"children": []
			}
			user_type = data.get("user_type/id") or data.get("user_type:id")
			if account_types.get(user_type, {}).get("report_type"):
				account["report_type"] = account_types[user_type]["report_type"]
				
			if account_types.get(user_type, {}).get("account_type"):
				account["account_type"] = account_types[user_type]["account_type"]
				if account["account_type"] not in all_account_types:
					all_account_types.append(account["account_type"])
				
			accounts[data.get("id")] = account
			if not account.get("parent_id") and data.get("chart_template_id:id"):
				chart_id = data.get("chart_template_id:id")
				charts.setdefault(chart_id, {}).update({"account_root_id": data.get("id")})
					
	for content in csv_content.get("account.chart.template", []):
		for row in content[1:]:
			if row:
				data = dict(zip(content[0], row))
				charts.setdefault(data.get("id"), {}).update({
					"account_root_id": data.get("account_root_id:id") or \
						data.get("account_root_id/id"),
					"name": data.get("name"),
					"id": country_dir
				})
		
					
def make_charts():
	"""write chart files in app/setup/doctype/company/charts"""
	for chart_id in charts:
		src = charts[chart_id]
		if not src.get("name") or not src.get("account_root_id"):
			continue
			
		if not src["account_root_id"] in accounts:
			continue

		filename = src["id"][5:] + "_" + chart_id
		
		print "building " + filename
		chart = {}
		chart["name"] = src["name"]
		chart["root"] = accounts[src["account_root_id"]]
		
		with open(os.path.join("erpnext", "accounts", "doctype", "chart_of_accounts", 
			"charts", filename + ".json"), "w") as chartfile:
			chartfile.write(json.dumps(chart, indent=1, sort_keys=True))

if __name__=="__main__":
	go()
########NEW FILE########
__FILENAME__ = chart_of_accounts
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe, os, json
from frappe.utils import cstr
from unidecode import unidecode
from frappe.model.document import Document

class ChartofAccounts(Document):
	no_report_type = False
		
	def create_accounts(self, company):
		chart = {}
		with open(os.path.join(os.path.dirname(__file__), "charts", self.source_file), "r") as f:
			chart = json.loads(f.read())
			
		from erpnext.accounts.doctype.chart_of_accounts.charts.account_properties import account_properties
			
		if chart:
			accounts = []
			
			def _import_accounts(children, parent):
				for child in children:
					account_name = child.get("name")
					account_name_in_db = unidecode(account_name.strip().lower())
					
					if account_name_in_db in accounts:
						count = accounts.count(account_name_in_db)
						account_name = account_name + " " + cstr(count)

					child.update(account_properties.get(chart.get("name"), {}).get(account_name, {}))
					
					account = frappe.get_doc({
						"doctype": "Account",
						"account_name": account_name,
						"company": company,
						"parent_account": parent,
						"group_or_ledger": "Group" if child.get("children") else "Ledger",
						"report_type": child.get("report_type"),
						"account_type": child.get("account_type")
					}).insert()
					
					accounts.append(account_name_in_db)
					
					# set report_type for all parents where blank
					if not account.report_type or account.report_type == 'None':
						self.no_report_type = True
					elif self.no_report_type:
						frappe.db.sql("""update tabAccount set report_type=%s 
							where lft<=%s and rgt>=%s and ifnull(report_type, '')=''""", 
							(account.report_type, account.lft, account.rgt))
					
					if child.get("children"):
						_import_accounts(child.get("children"), account.name)
			
			_import_accounts(chart.get("root").get("children"), None)
			
@frappe.whitelist()
def get_charts_for_country(country):
	return frappe.db.sql_list("""select chart_name from `tabChart of Accounts` 
		where country=%s""", country)

########NEW FILE########
__FILENAME__ = import_charts
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe, os, json

def import_charts():
	frappe.db.sql("""delete from `tabChart of Accounts`""")
	charts_dir = os.path.join(os.path.dirname(__file__), "charts")
	for fname in os.listdir(charts_dir):
		if fname.endswith(".json"):
			with open(os.path.join(charts_dir, fname), "r") as f:
				chart = json.loads(f.read())
				country = frappe.db.get_value("Country", {"code": fname.split("_", 1)[0]})
				if country:
					doc = frappe.get_doc({
						"doctype":"Chart of Accounts",
						"chart_name": chart.get("name"),
						"source_file": fname,
						"country": country
					}).insert()
					print doc.name.encode("utf-8")
				else:
					print "No chart for: " + chart.get("name").encode("utf-8")
				
	frappe.db.commit()
########NEW FILE########
__FILENAME__ = cost_center
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe import msgprint, _

from frappe.utils.nestedset import NestedSet

class CostCenter(NestedSet):
	nsm_parent_field = 'parent_cost_center'

	def autoname(self):
		self.name = self.cost_center_name.strip() + ' - ' + \
			frappe.db.get_value("Company", self.company, "abbr")

	def validate_mandatory(self):
		if not self.group_or_ledger:
			msgprint(_("Please select Group or Ledger value"), raise_exception=1)

		if self.cost_center_name != self.company and not self.parent_cost_center:
			msgprint(_("Please enter parent cost center"), raise_exception=1)
		elif self.cost_center_name == self.company and self.parent_cost_center:
			msgprint(_("Root cannot have a parent cost center"), raise_exception=1)

	def convert_group_to_ledger(self):
		if self.check_if_child_exists():
			msgprint(_("Cannot convert Cost Center to ledger as it has child nodes"), raise_exception=1)
		elif self.check_gle_exists():
			msgprint(_("Cost Center with existing transactions can not be converted to ledger"), raise_exception=1)
		else:
			self.group_or_ledger = 'Ledger'
			self.save()
			return 1

	def convert_ledger_to_group(self):
		if self.check_gle_exists():
			msgprint(_("Cost Center with existing transactions can not be converted to group"), raise_exception=1)
		else:
			self.group_or_ledger = 'Group'
			self.save()
			return 1

	def check_gle_exists(self):
		return frappe.db.get_value("GL Entry", {"cost_center": self.name})

	def check_if_child_exists(self):
		return frappe.db.sql("select name from `tabCost Center` where \
			parent_cost_center = %s and docstatus != 2", self.name)

	def validate_budget_details(self):
		check_acc_list = []
		for d in self.get('budget_details'):
			if self.group_or_ledger=="Group":
				msgprint(_("Budget cannot be set for Group Cost Centers"), raise_exception=1)

			if [d.account, d.fiscal_year] in check_acc_list:
				msgprint(_("Account {0} has been entered more than once for fiscal year {1}").format(d.account, d.fiscal_year), raise_exception=1)
			else:
				check_acc_list.append([d.account, d.fiscal_year])

	def validate(self):
		self.validate_mandatory()
		self.validate_budget_details()

	def before_rename(self, olddn, newdn, merge=False):
		# Add company abbr if not provided
		from erpnext.setup.doctype.company.company import get_name_with_abbr
		new_cost_center = get_name_with_abbr(newdn, self.company)

		# Validate properties before merging
		super(CostCenter, self).before_rename(olddn, new_cost_center, merge, "group_or_ledger")

		return new_cost_center

	def after_rename(self, olddn, newdn, merge=False):
		if not merge:
			frappe.db.set_value("Cost Center", newdn, "cost_center_name",
				" - ".join(newdn.split(" - ")[:-1]))
		else:
			super(CostCenter, self).after_rename(olddn, newdn, merge)


########NEW FILE########
__FILENAME__ = test_cost_center
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Cost Center')
########NEW FILE########
__FILENAME__ = c_form
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt
from frappe import _
from frappe.model.document import Document

class CForm(Document):
	def validate(self):
		"""Validate invoice that c-form is applicable
			and no other c-form is received for that"""

		for d in self.get('invoice_details'):
			if d.invoice_no:
				inv = frappe.db.sql("""select c_form_applicable, c_form_no from
					`tabSales Invoice` where name = %s and docstatus = 1""", d.invoice_no)

				if inv[0][0] != 'Yes':
					frappe.throw("C-form is not applicable for Invoice: %s" % d.invoice_no)

				elif inv[0][1] and inv[0][1] != self.name:
					frappe.throw("""Invoice %s is tagged in another C-form: %s.
						If you want to change C-form no for this invoice,
						please remove invoice no from the previous c-form and then try again""" %
						(d.invoice_no, inv[0][1]))

	def on_update(self):
		"""	Update C-Form No on invoices"""
		self.set_total_invoiced_amount()

	def on_submit(self):
		self.set_cform_in_sales_invoices()

	def before_cancel(self):
		# remove cform reference
		frappe.db.sql("""update `tabSales Invoice` set c_form_no=null where c_form_no=%s""", self.name)

	def set_cform_in_sales_invoices(self):
		inv = [d.invoice_no for d in self.get('invoice_details')]
		if inv:
			frappe.db.sql("""update `tabSales Invoice` set c_form_no=%s, modified=%s where name in (%s)""" %
				('%s', '%s', ', '.join(['%s'] * len(inv))), tuple([self.name, self.modified] + inv))

			frappe.db.sql("""update `tabSales Invoice` set c_form_no = null, modified = %s
				where name not in (%s) and ifnull(c_form_no, '') = %s""" %
				('%s', ', '.join(['%s']*len(inv)), '%s'), tuple([self.modified] + inv + [self.name]))
		else:
			frappe.throw(_("Please enter atleast 1 invoice in the table"))

	def set_total_invoiced_amount(self):
		total = sum([flt(d.grand_total) for d in self.get('invoice_details')])
		frappe.db.set(self, 'total_invoiced_amount', total)

	def get_invoice_details(self, invoice_no):
		"""	Pull details from invoices for referrence """

		inv = frappe.db.get_value("Sales Invoice", invoice_no,
			["posting_date", "territory", "net_total", "grand_total"], as_dict=True)
		return {
			'invoice_date' : inv.posting_date,
			'territory'    : inv.territory,
			'net_total'    : inv.net_total,
			'grand_total'  : inv.grand_total
		}

def get_invoice_nos(doctype, txt, searchfield, start, page_len, filters):
	from erpnext.utilities import build_filter_conditions
	conditions, filter_values = build_filter_conditions(filters)

	return frappe.db.sql("""select name from `tabSales Invoice` where docstatus = 1
		and c_form_applicable = 'Yes' and ifnull(c_form_no, '') = '' %s
		and %s like %s order by name limit %s, %s""" %
		(conditions, searchfield, "%s", "%s", "%s"),
		tuple(filter_values + ["%%%s%%" % txt, start, page_len]))

########NEW FILE########
__FILENAME__ = c_form_invoice_detail
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.model.document import Document

class CFormInvoiceDetail(Document):
	pass
########NEW FILE########
__FILENAME__ = fiscal_year
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import msgprint, _
from frappe.utils import getdate

from frappe.model.document import Document

class FiscalYear(Document):

	def set_as_default(self):
		frappe.db.set_value("Global Defaults", None, "current_fiscal_year", self.name)
		frappe.get_doc("Global Defaults").on_update()

		# clear cache
		frappe.clear_cache()

		msgprint(_("{0} is now the default Fiscal Year. Please refresh your browser for the change to take effect.").format(self.name))

	def validate(self):
		year_start_end_dates = frappe.db.sql("""select year_start_date, year_end_date
			from `tabFiscal Year` where name=%s""", (self.name))

		if year_start_end_dates:
			if getdate(self.year_start_date) != year_start_end_dates[0][0] or getdate(self.year_end_date) != year_start_end_dates[0][1]:
				frappe.throw(_("Cannot change Year Start Date and Year End Date once the Fiscal Year is saved."))

	def on_update(self):
		# validate year start date and year end date
		if getdate(self.year_start_date) > getdate(self.year_end_date):
			frappe.throw(_("Year Start Date should not be greater than Year End Date"))

		if (getdate(self.year_end_date) - getdate(self.year_start_date)).days > 366:
			frappe.throw(_("Year Start Date and Year End Date are not within Fiscal Year."))

		year_start_end_dates = frappe.db.sql("""select name, year_start_date, year_end_date
			from `tabFiscal Year` where name!=%s""", (self.name))

		for fiscal_year, ysd, yed in year_start_end_dates:
			if (getdate(self.year_start_date) == ysd and getdate(self.year_end_date) == yed) \
				and (not frappe.flags.in_test):
					frappe.throw(_("Year Start Date and Year End Date are already set in Fiscal Year {0}").format(fiscal_year))

########NEW FILE########
__FILENAME__ = test_fiscal_year
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals

import frappe

test_records = frappe.get_test_records('Fiscal Year')
########NEW FILE########
__FILENAME__ = gl_entry
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import flt, fmt_money, getdate, formatdate
from frappe import _

from frappe.model.document import Document

class GLEntry(Document):

	def validate(self):
		self.check_mandatory()
		self.pl_must_have_cost_center()
		self.validate_posting_date()
		self.check_pl_account()
		self.validate_cost_center()

	def on_update_with_args(self, adv_adj, update_outstanding = 'Yes'):
		self.validate_account_details(adv_adj)
		validate_frozen_account(self.account, adv_adj)
		check_freezing_date(self.posting_date, adv_adj)
		validate_balance_type(self.account, adv_adj)

		# Update outstanding amt on against voucher
		if self.against_voucher and update_outstanding == 'Yes':
				update_outstanding_amt(self.account, self.against_voucher_type,
					self.against_voucher)

	def check_mandatory(self):
		mandatory = ['account','remarks','voucher_type','voucher_no','fiscal_year','company']
		for k in mandatory:
			if not self.get(k):
				frappe.throw(_("{0} is required").format(self.meta.get_label(k)))

		# Zero value transaction is not allowed
		if not (flt(self.debit) or flt(self.credit)):
			frappe.throw(_("Either debit or credit amount is required for {0}").format(self.account))

	def pl_must_have_cost_center(self):
		if frappe.db.get_value("Account", self.account, "report_type") == "Profit and Loss":
			if not self.cost_center and self.voucher_type != 'Period Closing Voucher':
				frappe.throw(_("Cost Center is required for 'Profit and Loss' account {0}").format(self.account))
		elif self.cost_center:
			self.cost_center = None

	def validate_posting_date(self):
		from erpnext.accounts.utils import validate_fiscal_year
		validate_fiscal_year(self.posting_date, self.fiscal_year, "Posting Date")

	def check_pl_account(self):
		if self.is_opening=='Yes' and \
				frappe.db.get_value("Account", self.account, "report_type")=="Profit and Loss":
			frappe.throw(_("'Profit and Loss' type account {0} not allowed in Opening Entry").format(self.account))

	def validate_account_details(self, adv_adj):
		"""Account must be ledger, active and not freezed"""

		ret = frappe.db.sql("""select group_or_ledger, docstatus, company
			from tabAccount where name=%s""", self.account, as_dict=1)[0]

		if ret.group_or_ledger=='Group':
			frappe.throw(_("Account {0} cannot be a Group").format(self.account))

		if ret.docstatus==2:
			frappe.throw(_("Account {0} is inactive").format(self.account))

		if ret.company != self.company:
			frappe.throw(_("Account {0} does not belong to Company {1}").format(self.account, self.company))

	def validate_cost_center(self):
		if not hasattr(self, "cost_center_company"):
			self.cost_center_company = {}

		def _get_cost_center_company():
			if not self.cost_center_company.get(self.cost_center):
				self.cost_center_company[self.cost_center] = frappe.db.get_value(
					"Cost Center", self.cost_center, "company")

			return self.cost_center_company[self.cost_center]

		if self.cost_center and _get_cost_center_company() != self.company:
			frappe.throw(_("Cost Center {0} does not belong to Company {1}").format(self.cost_center, self.company))

def validate_balance_type(account, adv_adj=False):
	if not adv_adj and account:
		balance_must_be = frappe.db.get_value("Account", account, "balance_must_be")
		if balance_must_be:
			balance = frappe.db.sql("""select sum(ifnull(debit, 0)) - sum(ifnull(credit, 0))
				from `tabGL Entry` where account = %s""", account)[0][0]

			if (balance_must_be=="Debit" and flt(balance) < 0) or \
				(balance_must_be=="Credit" and flt(balance) > 0):
				frappe.throw(_("Balance for Account {0} must always be {1}").format(account, _(balance_must_be)))

def check_freezing_date(posting_date, adv_adj=False):
	"""
		Nobody can do GL Entries where posting date is before freezing date
		except authorized person
	"""
	if not adv_adj:
		acc_frozen_upto = frappe.db.get_value('Accounts Settings', None, 'acc_frozen_upto')
		if acc_frozen_upto:
			bde_auth_role = frappe.db.get_value( 'Accounts Settings', None,'bde_auth_role')
			if getdate(posting_date) <= getdate(acc_frozen_upto) \
					and not bde_auth_role in frappe.user.get_roles():
				frappe.throw(_("You are not authorized to add or update entries before {0}").format(formatdate(acc_frozen_upto)))

def update_outstanding_amt(account, against_voucher_type, against_voucher, on_cancel=False):
	# get final outstanding amt
	bal = flt(frappe.db.sql("""select sum(ifnull(debit, 0)) - sum(ifnull(credit, 0))
		from `tabGL Entry`
		where against_voucher_type=%s and against_voucher=%s and account = %s""",
		(against_voucher_type, against_voucher, account))[0][0] or 0.0)

	if against_voucher_type == 'Purchase Invoice':
		bal = -bal
	elif against_voucher_type == "Journal Voucher":
		against_voucher_amount = flt(frappe.db.sql("""
			select sum(ifnull(debit, 0)) - sum(ifnull(credit, 0))
			from `tabGL Entry` where voucher_type = 'Journal Voucher' and voucher_no = %s
			and account = %s and ifnull(against_voucher, '') = ''""",
			(against_voucher, account))[0][0])
		bal = against_voucher_amount + bal
		if against_voucher_amount < 0:
			bal = -bal

	# Validation : Outstanding can not be negative
	if bal < 0 and not on_cancel:
		frappe.throw(_("Outstanding for {0} cannot be less than zero ({1})").format(against_voucher, fmt_money(bal)))

	# Update outstanding amt on against voucher
	if against_voucher_type in ["Sales Invoice", "Purchase Invoice"]:
		frappe.db.sql("update `tab%s` set outstanding_amount=%s where name=%s" %
			(against_voucher_type, '%s', '%s'),	(bal, against_voucher))

def validate_frozen_account(account, adv_adj=None):
	frozen_account = frappe.db.get_value("Account", account, "freeze_account")
	if frozen_account == 'Yes' and not adv_adj:
		frozen_accounts_modifier = frappe.db.get_value( 'Accounts Settings', None,
			'frozen_accounts_modifier')

		if not frozen_accounts_modifier:
			frappe.throw(_("Account {0} is frozen").format(account))
		elif frozen_accounts_modifier not in frappe.user.get_roles():
			frappe.throw(_("Not authorized to edit frozen Account {0}").format(account))

########NEW FILE########
__FILENAME__ = journal_voucher
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import cint, cstr, flt, fmt_money, formatdate, getdate
from frappe import msgprint, _
from erpnext.setup.utils import get_company_currency

from erpnext.controllers.accounts_controller import AccountsController

class JournalVoucher(AccountsController):
	def __init__(self, arg1, arg2=None):
		super(JournalVoucher, self).__init__(arg1, arg2)
		self.master_type = {}
		self.credit_days_for = {}
		self.credit_days_global = -1
		self.is_approving_authority = -1

	def validate(self):
		if not self.is_opening:
			self.is_opening='No'
		self.clearance_date = None

		super(JournalVoucher, self).validate_date_with_fiscal_year()

		self.validate_cheque_info()
		self.validate_entries_for_advance()
		self.validate_debit_and_credit()
		self.validate_against_jv()
		self.validate_against_sales_invoice()
		self.validate_against_purchase_invoice()
		self.set_against_account()
		self.create_remarks()
		self.set_aging_date()
		self.set_print_format_fields()

	def on_submit(self):
		if self.voucher_type in ['Bank Voucher', 'Contra Voucher', 'Journal Entry']:
			self.check_credit_days()
		self.make_gl_entries()
		self.check_credit_limit()

	def on_cancel(self):
		from erpnext.accounts.utils import remove_against_link_from_jv
		remove_against_link_from_jv(self.doctype, self.name, "against_jv")

		self.make_gl_entries(1)

	def validate_cheque_info(self):
		if self.voucher_type in ['Bank Voucher']:
			if not self.cheque_no or not self.cheque_date:
				msgprint(_("Reference No & Reference Date is required for {0}").format(self.voucher_type),
					raise_exception=1)

		if self.cheque_date and not self.cheque_no:
			msgprint(_("Reference No is mandatory if you entered Reference Date"), raise_exception=1)

	def validate_entries_for_advance(self):
		for d in self.get('entries'):
			if not d.is_advance and not d.against_voucher and \
					not d.against_invoice and not d.against_jv:
				master_type = frappe.db.get_value("Account", d.account, "master_type")
				if (master_type == 'Customer' and flt(d.credit) > 0) or \
						(master_type == 'Supplier' and flt(d.debit) > 0):
					msgprint(_("Please check 'Is Advance' against Account {0} if this is an advance entry.").format(d.account))

	def validate_against_jv(self):
		for d in self.get('entries'):
			if d.against_jv:
				if d.against_jv == self.name:
					frappe.throw(_("You can not enter current voucher in 'Against Journal Voucher' column"))

				against_entries = frappe.db.sql("""select * from `tabJournal Voucher Detail`
					where account = %s and docstatus = 1 and parent = %s
					and ifnull(against_jv, '') = ''""", (d.account, d.against_jv), as_dict=True)

				if not against_entries:
					frappe.throw(_("Journal Voucher {0} does not have account {1} or already matched")
						.format(d.against_jv, d.account))
				else:
					dr_or_cr = "debit" if d.credit > 0 else "credit"
					valid = False
					for jvd in against_entries:
						if flt(jvd[dr_or_cr]) > 0:
							valid = True
					if not valid:
						frappe.throw(_("Against Journal Voucher {0} does not have any unmatched {1} entry")
							.format(d.against_jv, dr_or_cr))

	def validate_against_sales_invoice(self):
		for d in self.get("entries"):
			if d.against_invoice:
				if d.debit > 0:
					frappe.throw(_("Row {0}: Debit entry can not be linked with a Sales Invoice")
						.format(d.idx))
				if frappe.db.get_value("Sales Invoice", d.against_invoice, "debit_to") != d.account:
					frappe.throw(_("Row {0}: Account does not match with \
						Sales Invoice Debit To account").format(d.idx, d.account))

	def validate_against_purchase_invoice(self):
		for d in self.get("entries"):
			if d.against_voucher:
				if flt(d.credit) > 0:
					frappe.throw(_("Row {0}: Credit entry can not be linked with a Purchase Invoice")
						.format(d.idx))
				if frappe.db.get_value("Purchase Invoice", d.against_voucher, "credit_to") != d.account:
					frappe.throw(_("Row {0}: Account does not match with \
						Purchase Invoice Credit To account").format(d.idx, d.account))

	def set_against_account(self):
		accounts_debited, accounts_credited = [], []
		for d in self.get("entries"):
			if flt(d.debit > 0): accounts_debited.append(d.account)
			if flt(d.credit) > 0: accounts_credited.append(d.account)

		for d in self.get("entries"):
			if flt(d.debit > 0): d.against_account = ", ".join(list(set(accounts_credited)))
			if flt(d.credit > 0): d.against_account = ", ".join(list(set(accounts_debited)))

	def validate_debit_and_credit(self):
		self.total_debit, self.total_credit, self.difference = 0, 0, 0

		for d in self.get("entries"):
			if d.debit and d.credit:
				frappe.throw(_("You cannot credit and debit same account at the same time"))

			self.total_debit = flt(self.total_debit) + flt(d.debit, self.precision("debit", "entries"))
			self.total_credit = flt(self.total_credit) + flt(d.credit, self.precision("credit", "entries"))

		self.difference = flt(self.total_debit, self.precision("total_debit")) - \
			flt(self.total_credit, self.precision("total_credit"))

		if self.difference:
			frappe.throw(_("Total Debit must be equal to Total Credit. The difference is {0}")
				.format(self.difference))

	def create_remarks(self):
		r = []
		if self.cheque_no:
			if self.cheque_date:
				r.append(_('Reference #{0} dated {1}').format(self.cheque_no, formatdate(self.cheque_date)))
			else:
				msgprint(_("Please enter Reference date"), raise_exception=1)

		for d in self.get('entries'):
			if d.against_invoice and d.credit:
				currency = frappe.db.get_value("Sales Invoice", d.against_invoice, "currency")
				r.append(_("{0} {1} against Invoice {1}").format(currency, fmt_money(flt(d.credit)), d.against_invoice))

			if d.against_voucher and d.debit:
				bill_no = frappe.db.sql("""select bill_no, bill_date, currency
					from `tabPurchase Invoice` where name=%s""", d.against_voucher)
				if bill_no and bill_no[0][0] and bill_no[0][0].lower().strip() \
						not in ['na', 'not applicable', 'none']:
					r.append(_('{0} {1} against Bill {2} dated {3}').format(bill_no[0][2],
						fmt_money(flt(d.debit)), bill_no[0][0],
						bill_no[0][1] and formatdate(bill_no[0][1].strftime('%Y-%m-%d'))))

		if self.user_remark:
			r.append(_("Note: {0}").format(self.user_remark))

		if r:
			self.remark = ("\n").join(r)
		else:
			frappe.msgprint(_("User Remarks is mandatory"), raise_exception=1)

	def set_aging_date(self):
		if self.is_opening != 'Yes':
			self.aging_date = self.posting_date
		else:
			# check account type whether supplier or customer
			exists = False
			for d in self.get('entries'):
				account_type = frappe.db.get_value("Account", d.account, "account_type")
				if account_type in ["Supplier", "Customer"]:
					exists = True
					break

			# If customer/supplier account, aging date is mandatory
			if exists and not self.aging_date:
				msgprint(_("Aging Date is mandatory for opening entry"), raise_exception=1)
			else:
				self.aging_date = self.posting_date

	def set_print_format_fields(self):
		for d in self.get('entries'):
			account_type, master_type = frappe.db.get_value("Account", d.account,
				["account_type", "master_type"])

			if master_type in ['Supplier', 'Customer']:
				if not self.pay_to_recd_from:
					self.pay_to_recd_from = frappe.db.get_value(master_type,
						' - '.join(d.account.split(' - ')[:-1]),
						master_type == 'Customer' and 'customer_name' or 'supplier_name')

			if account_type in ['Bank', 'Cash']:
				company_currency = get_company_currency(self.company)
				amt = flt(d.debit) and d.debit or d.credit
				self.total_amount = company_currency + ' ' + cstr(amt)
				from frappe.utils import money_in_words
				self.total_amount_in_words = money_in_words(amt, company_currency)

	def check_credit_days(self):
		date_diff = 0
		if self.cheque_date:
			date_diff = (getdate(self.cheque_date)-getdate(self.posting_date)).days

		if date_diff <= 0: return

		# Get List of Customer Account
		acc_list = filter(lambda d: frappe.db.get_value("Account", d.account,
		 	"master_type")=='Customer', self.get('entries'))

		for d in acc_list:
			credit_days = self.get_credit_days_for(d.account)
			# Check credit days
			if credit_days > 0 and not self.get_authorized_user() and cint(date_diff) > credit_days:
				msgprint(_("Maximum allowed credit is {0} days after posting date").format(credit_days),
					raise_exception=1)

	def get_credit_days_for(self, ac):
		if not self.credit_days_for.has_key(ac):
			self.credit_days_for[ac] = cint(frappe.db.get_value("Account", ac, "credit_days"))

		if not self.credit_days_for[ac]:
			if self.credit_days_global==-1:
				self.credit_days_global = cint(frappe.db.get_value("Company",
					self.company, "credit_days"))

			return self.credit_days_global
		else:
			return self.credit_days_for[ac]

	def get_authorized_user(self):
		if self.is_approving_authority==-1:
			self.is_approving_authority = 0

			# Fetch credit controller role
			approving_authority = frappe.db.get_value("Accounts Settings", None,
				"credit_controller")

			# Check logged-in user is authorized
			if approving_authority in frappe.user.get_roles():
				self.is_approving_authority = 1

		return self.is_approving_authority

	def make_gl_entries(self, cancel=0, adv_adj=0):
		from erpnext.accounts.general_ledger import make_gl_entries

		gl_map = []
		for d in self.get("entries"):
			if d.debit or d.credit:
				gl_map.append(
					self.get_gl_dict({
						"account": d.account,
						"against": d.against_account,
						"debit": flt(d.debit, self.precision("debit", "entries")),
						"credit": flt(d.credit, self.precision("credit", "entries")),
						"against_voucher_type": ((d.against_voucher and "Purchase Invoice")
							or (d.against_invoice and "Sales Invoice")
							or (d.against_jv and "Journal Voucher")),
						"against_voucher": d.against_voucher or d.against_invoice or d.against_jv,
						"remarks": self.remark,
						"cost_center": d.cost_center
					})
				)
		if gl_map:
			make_gl_entries(gl_map, cancel=cancel, adv_adj=adv_adj)

	def check_credit_limit(self):
		for d in self.get("entries"):
			master_type, master_name = frappe.db.get_value("Account", d.account,
				["master_type", "master_name"])
			if master_type == "Customer" and master_name:
				super(JournalVoucher, self).check_credit_limit(d.account)

	def get_balance(self):
		if not self.get('entries'):
			msgprint(_("'Entries' cannot be empty"), raise_exception=True)
		else:
			flag, self.total_debit, self.total_credit = 0, 0, 0
			diff = flt(self.difference, self.precision("difference"))

			# If any row without amount, set the diff on that row
			for d in self.get('entries'):
				if not d.credit and not d.debit and diff != 0:
					if diff>0:
						d.credit = diff
					elif diff<0:
						d.debit = diff
					flag = 1

			# Set the diff in a new row
			if flag == 0 and diff != 0:
				jd = self.append('entries', {})
				if diff>0:
					jd.credit = abs(diff)
				elif diff<0:
					jd.debit = abs(diff)

			self.validate_debit_and_credit()

	def get_outstanding_invoices(self):
		self.set('entries', [])
		total = 0
		for d in self.get_values():
			total += flt(d.outstanding_amount, self.precision("credit", "entries"))
			jd1 = self.append('entries', {})
			jd1.account = d.account

			if self.write_off_based_on == 'Accounts Receivable':
				jd1.credit = flt(d.outstanding_amount, self.precision("credit", "entries"))
				jd1.against_invoice = cstr(d.name)
			elif self.write_off_based_on == 'Accounts Payable':
				jd1.debit = flt(d.outstanding_amount, self.precision("debit", "entries"))
				jd1.against_voucher = cstr(d.name)

		jd2 = self.append('entries', {})
		if self.write_off_based_on == 'Accounts Receivable':
			jd2.debit = total
		elif self.write_off_based_on == 'Accounts Payable':
			jd2.credit = total

		self.validate_debit_and_credit()


	def get_values(self):
		cond = " and outstanding_amount <= {0}".format(self.write_off_amount) \
			if flt(self.write_off_amount) > 0 else ""

		if self.write_off_based_on == 'Accounts Receivable':
			return frappe.db.sql("""select name, debit_to as account, outstanding_amount
				from `tabSales Invoice` where docstatus = 1 and company = %s
				and outstanding_amount > 0 %s""" % ('%s', cond), self.company, as_dict=True)
		elif self.write_off_based_on == 'Accounts Payable':
			return frappe.db.sql("""select name, credit_to as account, outstanding_amount
				from `tabPurchase Invoice` where docstatus = 1 and company = %s
				and outstanding_amount > 0 %s""" % ('%s', cond), self.company, as_dict=True)

@frappe.whitelist()
def get_default_bank_cash_account(company, voucher_type):
	from erpnext.accounts.utils import get_balance_on
	account = frappe.db.get_value("Company", company,
		voucher_type=="Bank Voucher" and "default_bank_account" or "default_cash_account")
	if account:
		return {
			"account": account,
			"balance": get_balance_on(account)
		}

@frappe.whitelist()
def get_payment_entry_from_sales_invoice(sales_invoice):
	from erpnext.accounts.utils import get_balance_on
	si = frappe.get_doc("Sales Invoice", sales_invoice)
	jv = get_payment_entry(si)
	jv.remark = 'Payment received against Sales Invoice {0}. {1}'.format(si.name, si.remarks)

	# credit customer
	jv.get("entries")[0].account = si.debit_to
	jv.get("entries")[0].balance = get_balance_on(si.debit_to)
	jv.get("entries")[0].credit = si.outstanding_amount
	jv.get("entries")[0].against_invoice = si.name

	# debit bank
	jv.get("entries")[1].debit = si.outstanding_amount

	return jv.as_dict()

@frappe.whitelist()
def get_payment_entry_from_purchase_invoice(purchase_invoice):
	from erpnext.accounts.utils import get_balance_on
	pi = frappe.get_doc("Purchase Invoice", purchase_invoice)
	jv = get_payment_entry(pi)
	jv.remark = 'Payment against Purchase Invoice {0}. {1}'.format(pi.name, pi.remarks)

	# credit supplier
	jv.get("entries")[0].account = pi.credit_to
	jv.get("entries")[0].balance = get_balance_on(pi.credit_to)
	jv.get("entries")[0].debit = pi.outstanding_amount
	jv.get("entries")[0].against_voucher = pi.name

	# credit bank
	jv.get("entries")[1].credit = pi.outstanding_amount

	return jv.as_dict()

def get_payment_entry(doc):
	bank_account = get_default_bank_cash_account(doc.company, "Bank Voucher")

	jv = frappe.new_doc('Journal Voucher')
	jv.voucher_type = 'Bank Voucher'

	jv.company = doc.company
	jv.fiscal_year = doc.fiscal_year

	jv.append("entries")
	d2 = jv.append("entries")

	if bank_account:
		d2.account = bank_account["account"]
		d2.balance = bank_account["balance"]

	return jv

@frappe.whitelist()
def get_opening_accounts(company):
	"""get all balance sheet accounts for opening entry"""
	from erpnext.accounts.utils import get_balance_on
	accounts = frappe.db.sql_list("""select name from tabAccount
		where group_or_ledger='Ledger' and report_type='Profit and Loss' and company=%s""", company)

	return [{"account": a, "balance": get_balance_on(a)} for a in accounts]

def get_against_purchase_invoice(doctype, txt, searchfield, start, page_len, filters):
	return frappe.db.sql("""select name, credit_to, outstanding_amount, bill_no, bill_date
		from `tabPurchase Invoice` where credit_to = %s and docstatus = 1
		and outstanding_amount > 0 and %s like %s order by name desc limit %s, %s""" %
		("%s", searchfield, "%s", "%s", "%s"),
		(filters["account"], "%%%s%%" % txt, start, page_len))

def get_against_sales_invoice(doctype, txt, searchfield, start, page_len, filters):
	return frappe.db.sql("""select name, debit_to, outstanding_amount
		from `tabSales Invoice` where debit_to = %s and docstatus = 1
		and outstanding_amount > 0 and `%s` like %s order by name desc limit %s, %s""" %
		("%s", searchfield, "%s", "%s", "%s"),
		(filters["account"], "%%%s%%" % txt, start, page_len))

def get_against_jv(doctype, txt, searchfield, start, page_len, filters):
	return frappe.db.sql("""select jv.name, jv.posting_date, jv.user_remark
		from `tabJournal Voucher` jv, `tabJournal Voucher Detail` jv_detail
		where jv_detail.parent = jv.name and jv_detail.account = %s and jv.docstatus = 1
		and jv.%s like %s order by jv.name desc limit %s, %s""" %
		("%s", searchfield, "%s", "%s", "%s"),
		(filters["account"], "%%%s%%" % txt, start, page_len))

@frappe.whitelist()
def get_outstanding(args):
	args = eval(args)
	if args.get("doctype") == "Journal Voucher" and args.get("account"):
		against_jv_amount = frappe.db.sql("""
			select sum(ifnull(debit, 0)) - sum(ifnull(credit, 0))
			from `tabJournal Voucher Detail` where parent=%s and account=%s
			and ifnull(against_invoice, '')='' and ifnull(against_voucher, '')=''
			and ifnull(against_jv, '')=''""", (args['docname'], args['account']))

		against_jv_amount = flt(against_jv_amount[0][0]) if against_jv_amount else 0
		if against_jv_amount > 0:
			return {"credit": against_jv_amount}
		else:
			return {"debit": -1* against_jv_amount}

	elif args.get("doctype") == "Sales Invoice":
		return {
			"credit": flt(frappe.db.get_value("Sales Invoice", args["docname"],
				"outstanding_amount"))
		}
	elif args.get("doctype") == "Purchase Invoice":
		return {
			"debit": flt(frappe.db.get_value("Purchase Invoice", args["docname"],
				"outstanding_amount"))
		}

########NEW FILE########
__FILENAME__ = test_journal_voucher
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


from __future__ import unicode_literals
import unittest
import frappe

class TestJournalVoucher(unittest.TestCase):
	def test_journal_voucher_with_against_jv(self):
		self.clear_account_balance()
		jv_invoice = frappe.copy_doc(test_records[2])
		jv_invoice.insert()
		jv_invoice.submit()

		self.assertTrue(frappe.db.sql("""select name from `tabJournal Voucher Detail`
			where account = %s and docstatus = 1 and parent = %s""",
			("_Test Customer - _TC", jv_invoice.name)))

		self.assertTrue(not frappe.db.sql("""select name from `tabJournal Voucher Detail`
			where against_jv=%s""", jv_invoice.name))

		jv_payment = frappe.copy_doc(test_records[0])
		jv_payment.get("entries")[0].against_jv = jv_invoice.name
		jv_payment.insert()
		jv_payment.submit()

		self.assertTrue(frappe.db.sql("""select name from `tabJournal Voucher Detail`
			where against_jv=%s""", jv_invoice.name))

		self.assertTrue(frappe.db.sql("""select name from `tabJournal Voucher Detail`
			where against_jv=%s and credit=400""", jv_invoice.name))

		# cancel jv_invoice
		jv_invoice.cancel()

		self.assertTrue(not frappe.db.sql("""select name from `tabJournal Voucher Detail`
			where against_jv=%s""", jv_invoice.name))

	def test_jv_against_stock_account(self):
		from erpnext.stock.doctype.purchase_receipt.test_purchase_receipt import set_perpetual_inventory
		set_perpetual_inventory()

		jv = frappe.copy_doc(test_records[0])
		jv.get("entries")[0].account = "_Test Warehouse - _TC"
		jv.insert()

		from erpnext.accounts.general_ledger import StockAccountInvalidTransaction
		self.assertRaises(StockAccountInvalidTransaction, jv.submit)

		set_perpetual_inventory(0)

	def test_monthly_budget_crossed_ignore(self):
		frappe.db.set_value("Company", "_Test Company", "monthly_bgt_flag", "Ignore")
		self.clear_account_balance()

		jv = frappe.copy_doc(test_records[0])
		jv.get("entries")[1].account = "_Test Account Cost for Goods Sold - _TC"
		jv.get("entries")[1].cost_center = "_Test Cost Center - _TC"
		jv.get("entries")[1].debit = 20000.0
		jv.get("entries")[0].credit = 20000.0
		jv.insert()
		jv.submit()
		self.assertTrue(frappe.db.get_value("GL Entry",
			{"voucher_type": "Journal Voucher", "voucher_no": jv.name}))

	def test_monthly_budget_crossed_stop(self):
		from erpnext.accounts.utils import BudgetError
		frappe.db.set_value("Company", "_Test Company", "monthly_bgt_flag", "Stop")
		self.clear_account_balance()

		jv = frappe.copy_doc(test_records[0])
		jv.get("entries")[1].account = "_Test Account Cost for Goods Sold - _TC"
		jv.get("entries")[1].cost_center = "_Test Cost Center - _TC"
		jv.get("entries")[1].debit = 20000.0
		jv.get("entries")[0].credit = 20000.0
		jv.insert()

		self.assertRaises(BudgetError, jv.submit)

		frappe.db.set_value("Company", "_Test Company", "monthly_bgt_flag", "Ignore")

	def test_yearly_budget_crossed_stop(self):
		from erpnext.accounts.utils import BudgetError
		self.clear_account_balance()
		self.test_monthly_budget_crossed_ignore()

		frappe.db.set_value("Company", "_Test Company", "yearly_bgt_flag", "Stop")

		jv = frappe.copy_doc(test_records[0])
		jv.posting_date = "2013-08-12"
		jv.get("entries")[1].account = "_Test Account Cost for Goods Sold - _TC"
		jv.get("entries")[1].cost_center = "_Test Cost Center - _TC"
		jv.get("entries")[1].debit = 150000.0
		jv.get("entries")[0].credit = 150000.0
		jv.insert()

		self.assertRaises(BudgetError, jv.submit)

		frappe.db.set_value("Company", "_Test Company", "yearly_bgt_flag", "Ignore")

	def test_monthly_budget_on_cancellation(self):
		from erpnext.accounts.utils import BudgetError
		frappe.db.set_value("Company", "_Test Company", "monthly_bgt_flag", "Stop")
		self.clear_account_balance()

		jv = frappe.copy_doc(test_records[0])
		jv.get("entries")[0].account = "_Test Account Cost for Goods Sold - _TC"
		jv.get("entries")[0].cost_center = "_Test Cost Center - _TC"
		jv.get("entries")[0].credit = 30000.0
		jv.get("entries")[1].debit = 30000.0
		jv.submit()

		self.assertTrue(frappe.db.get_value("GL Entry",
			{"voucher_type": "Journal Voucher", "voucher_no": jv.name}))

		jv1 = frappe.copy_doc(test_records[0])
		jv1.get("entries")[1].account = "_Test Account Cost for Goods Sold - _TC"
		jv1.get("entries")[1].cost_center = "_Test Cost Center - _TC"
		jv1.get("entries")[1].debit = 40000.0
		jv1.get("entries")[0].credit = 40000.0
		jv1.submit()

		self.assertTrue(frappe.db.get_value("GL Entry",
			{"voucher_type": "Journal Voucher", "voucher_no": jv1.name}))

		self.assertRaises(BudgetError, jv.cancel)

		frappe.db.set_value("Company", "_Test Company", "monthly_bgt_flag", "Ignore")

	def clear_account_balance(self):
		frappe.db.sql("""delete from `tabGL Entry`""")


test_records = frappe.get_test_records('Journal Voucher')

########NEW FILE########
__FILENAME__ = journal_voucher_detail
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class JournalVoucherDetail(Document):
	pass
########NEW FILE########
__FILENAME__ = mode_of_payment
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ModeofPayment(Document):
	pass

########NEW FILE########
__FILENAME__ = payment_to_invoice_matching_tool
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import flt

from frappe import msgprint, _

from frappe.model.document import Document

class PaymenttoInvoiceMatchingTool(Document):
	def get_voucher_details(self):
		total_amount = frappe.db.sql("""select sum(ifnull(debit, 0)) - sum(ifnull(credit, 0))
			from `tabGL Entry`
			where voucher_type = %s and voucher_no = %s
				and account = %s and ifnull(against_voucher, '') != voucher_no""",
			(self.voucher_type, self.voucher_no, self.account))

		self.total_amount = total_amount and flt(total_amount[0][0]) or 0

		reconciled_payment = frappe.db.sql("""
			select abs(sum(ifnull(debit, 0)) - sum(ifnull(credit, 0)))
			from `tabGL Entry`
			where against_voucher_type = %s and against_voucher = %s and account = %s
		""", (self.voucher_type, self.voucher_no, self.account))

		reconciled_payment = reconciled_payment and flt(reconciled_payment[0][0]) or 0
		self.unmatched_amount = self.total_amount - reconciled_payment

	def get_against_entries(self):
		self.set('against_entries', [])
		gle = self.get_gl_entries()
		self.create_against_entries_table(gle)

	def get_gl_entries(self):
		self.validate_mandatory()

		dr_or_cr = "credit" if self.total_amount > 0 else "debit"

		cond = self.from_date and " and t1.posting_date >= '" + self.from_date + "'" or ""
		cond += self.to_date and " and t1.posting_date <= '" + self.to_date + "'" or ""

		if self.amt_greater_than:
			cond += ' and abs(ifnull(t2.debit, 0) - ifnull(t2.credit, 0)) >= ' + self.amt_greater_than
		if self.amt_less_than:
			cond += ' and abs(ifnull(t2.debit, 0) - ifnull(t2.credit, 0)) >= ' + self.amt_less_than

		gle = frappe.db.sql("""
			select
				t1.name as voucher_no, t1.posting_date, t1.total_debit as total_amt,
			 	abs(ifnull(t2.debit, 0) - ifnull(t2.credit, 0)) as unmatched_amount, t1.remark,
			 	t2.against_account, t2.name as voucher_detail_no, t2.is_advance
			from
				`tabJournal Voucher` t1, `tabJournal Voucher Detail` t2
			where
				t1.name = t2.parent and t1.docstatus = 1 and t2.account = %s
				and ifnull(t2.against_voucher, '')='' and ifnull(t2.against_invoice, '')=''
				and ifnull(t2.against_jv, '')='' and t2.%s > 0 and t1.name != %s
				and not exists (select * from `tabJournal Voucher Detail`
					where parent=%s and against_jv = t1.name) %s
			group by t1.name, t2.name """ %	('%s', dr_or_cr, '%s', '%s', cond),
			(self.account, self.voucher_no, self.voucher_no), as_dict=1)

		return gle

	def create_against_entries_table(self, gle):
		adjusted_jv = {}
		for d in gle:
			if not adjusted_jv.has_key(d.get("voucher_no")):
				matched_amount = frappe.db.sql("""
					select
						ifnull(abs(sum(ifnull(debit, 0)) - sum(ifnull(credit, 0))), 0)
					from
						`tabGL Entry`
					where
						account = %s and against_voucher_type = "Journal Voucher"
						and ifnull(against_voucher, '') = %s
				""", (self.account, d.get('voucher_no')))
				matched_amount = matched_amount[0][0] if matched_amount else 0
			else:
				matched_amount = adjusted_jv.get(d.get("voucher_no"))

			if matched_amount < flt(d.get('unmatched_amount')):
				unmatched_amount = flt(d.get('unmatched_amount')) - matched_amount
				adjusted_jv.setdefault(d.get("voucher_no"), 0)
			else:
				unmatched_amount = 0
				adjusted_jv.setdefault(d.get("voucher_no"), matched_amount - flt(d.get('unmatched_amount')))

			if unmatched_amount:
				ch = self.append('against_entries', {})
				ch.voucher_no = d.get('voucher_no')
				ch.posting_date = d.get('posting_date')
				ch.unmatched_amount = unmatched_amount
				ch.total_amt = flt(d.get('total_amt'))
				ch.against_account = d.get('against_account')
				ch.remarks = d.get('remark')
				ch.voucher_detail_no = d.get('voucher_detail_no')
				ch.is_advance = d.get("is_advance")
				ch.original_amount = flt(d.get('unmatched_amount'))

	def validate_mandatory(self):
		for fieldname in ["account", "voucher_type", "voucher_no"]:
			if not self.get(fieldname):
				frappe.throw(_("Please select {0} first").format(self.meta.get_label("fieldname")))

		if not frappe.db.exists(self.voucher_type, self.voucher_no):
			frappe.throw(_("Voucher No is not valid"))

	def reconcile(self):
		self.validate_mandatory()
		self.validate_allocated_amount()

		dr_or_cr = "credit" if self.total_amount > 0 else "debit"

		lst = []
		for d in self.get('against_entries'):
			if flt(d.allocated_amount) > 0:
				lst.append({
					'voucher_no' : d.voucher_no,
					'voucher_detail_no' : d.voucher_detail_no,
					'against_voucher_type' : self.voucher_type,
					'against_voucher'  : self.voucher_no,
					'account' : self.account,
					'is_advance' : d.is_advance,
					'dr_or_cr' : dr_or_cr,
					'unadjusted_amt' : flt(d.original_amount),
					'allocated_amt' : flt(d.allocated_amount)
				})

		if lst:
			from erpnext.accounts.utils import reconcile_against_document
			reconcile_against_document(lst)
			self.get_voucher_details()
			self.get_against_entries()
			msgprint(_("Successfully allocated"))

	def validate_allocated_amount(self):
		if not self.total_allocated_amount:
			frappe.throw(_("You must allocate amount before reconcile"))
		elif self.total_allocated_amount > self.unmatched_amount:
			frappe.throw(_("Total Allocated Amount can not be greater than unmatched amount"))

def get_voucher_nos(doctype, txt, searchfield, start, page_len, filters):
	non_reconclied_entries = []
	entries = frappe.db.sql("""
		select
			voucher_no, posting_date, ifnull(abs(sum(ifnull(debit, 0)) - sum(ifnull(credit, 0))), 0) as amount
		from
			`tabGL Entry`
		where
			account = %s and voucher_type = %s and voucher_no like %s
			and ifnull(against_voucher, '') = ''
		group by voucher_no
	""", (filters["account"], filters["voucher_type"], "%%%s%%" % txt), as_dict=True)

	for d in entries:
		adjusted_amount = frappe.db.sql("""
			select
				ifnull(abs(sum(ifnull(debit, 0)) - sum(ifnull(credit, 0))), 0)
			from
				`tabGL Entry`
			where
				account = %s and against_voucher_type = %s and ifnull(against_voucher, '') = %s
		""", (filters["account"], filters["voucher_type"], d.voucher_no))
		adjusted_amount = adjusted_amount[0][0] if adjusted_amount else 0

		if d.amount > adjusted_amount:
			non_reconclied_entries.append([d.voucher_no, d.posting_date, d.amount])

	return non_reconclied_entries

########NEW FILE########
__FILENAME__ = test_payment_to_invoice_matching_tool
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import unittest
import frappe

test_records = frappe.get_test_records('Payment To Invoice Matching Tool')
########NEW FILE########
__FILENAME__ = payment_to_invoice_matching_tool_detail
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class PaymentToInvoiceMatchingToolDetail(Document):
	pass
########NEW FILE########
__FILENAME__ = period_closing_voucher
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt
from frappe import _
from erpnext.controllers.accounts_controller import AccountsController

class PeriodClosingVoucher(AccountsController):
	def validate(self):
		self.validate_account_head()
		self.validate_posting_date()

	def on_submit(self):
		self.make_gl_entries()

	def on_cancel(self):
		frappe.db.sql("""delete from `tabGL Entry`
			where voucher_type = 'Period Closing Voucher' and voucher_no=%s""", self.name)

	def validate_account_head(self):
		if frappe.db.get_value("Account", self.closing_account_head, "report_type") \
				!= "Balance Sheet":
			frappe.throw(_("Closing Account {0} must be of type 'Liability'").format(self.closing_account_head))

	def validate_posting_date(self):
		from erpnext.accounts.utils import get_fiscal_year
		self.year_start_date = get_fiscal_year(self.posting_date, self.fiscal_year)[1]

		pce = frappe.db.sql("""select name from `tabPeriod Closing Voucher`
			where posting_date > %s and fiscal_year = %s and docstatus = 1""",
			(self.posting_date, self.fiscal_year))
		if pce and pce[0][0]:
			frappe.throw(_("Another Period Closing Entry {0} has been made after {1}").format(pce[0][0], self.posting_date))

	def get_pl_balances(self):
		"""Get balance for pl accounts"""
		return frappe.db.sql("""
			select t1.account, sum(ifnull(t1.debit,0))-sum(ifnull(t1.credit,0)) as balance
			from `tabGL Entry` t1, `tabAccount` t2
			where t1.account = t2.name and ifnull(t2.report_type, '') = 'Profit and Loss'
			and t2.docstatus < 2 and t2.company = %s
			and t1.posting_date between %s and %s
			group by t1.account
		""", (self.company, self.get("year_start_date"), self.posting_date), as_dict=1)

	def make_gl_entries(self):
		gl_entries = []
		net_pl_balance = 0
		pl_accounts = self.get_pl_balances()
		for acc in pl_accounts:
			if flt(acc.balance):
				gl_entries.append(self.get_gl_dict({
					"account": acc.account,
					"debit": abs(flt(acc.balance)) if flt(acc.balance) < 0 else 0,
					"credit": abs(flt(acc.balance)) if flt(acc.balance) > 0 else 0,
				}))

				net_pl_balance += flt(acc.balance)

		if net_pl_balance:
			gl_entries.append(self.get_gl_dict({
				"account": self.closing_account_head,
				"debit": abs(net_pl_balance) if net_pl_balance > 0 else 0,
				"credit": abs(net_pl_balance) if net_pl_balance < 0 else 0
			}))

		from erpnext.accounts.general_ledger import make_gl_entries
		make_gl_entries(gl_entries)

########NEW FILE########
__FILENAME__ = test_period_closing_voucher
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


from __future__ import unicode_literals
import unittest
import frappe
from erpnext.accounts.doctype.journal_voucher.test_journal_voucher import test_records as jv_records

class TestPeriodClosingVoucher(unittest.TestCase):
	def test_closing_entry(self):
		# clear GL Entries
		frappe.db.sql("""delete from `tabGL Entry`""")
		jv = frappe.copy_doc(jv_records[2])
		jv.insert()
		jv.submit()

		jv1 = frappe.copy_doc(jv_records[0])
		jv1.get("entries")[1].account = "_Test Account Cost for Goods Sold - _TC"
		jv1.get("entries")[1].cost_center = "_Test Cost Center - _TC"
		jv1.get("entries")[1].debit = 600.0
		jv1.get("entries")[0].credit = 600.0
		jv1.insert()
		jv1.submit()

		pcv = frappe.copy_doc(test_records[0])
		pcv.insert()
		pcv.submit()

		gl_entries = frappe.db.sql("""select account, debit, credit
			from `tabGL Entry` where voucher_type='Period Closing Voucher' and voucher_no=%s
			order by account asc, debit asc""", pcv.name, as_dict=1)

		self.assertTrue(gl_entries)

		expected_gl_entries = sorted([
			["_Test Account Reserves and Surplus - _TC", 200.0, 0.0],
			["_Test Account Cost for Goods Sold - _TC", 0.0, 600.0],
			["Sales - _TC", 400.0, 0.0]
		])
		for i, gle in enumerate(gl_entries):
			self.assertEquals(expected_gl_entries[i][0], gle.account)
			self.assertEquals(expected_gl_entries[i][1], gle.debit)
			self.assertEquals(expected_gl_entries[i][2], gle.credit)


test_dependencies = ["Customer", "Cost Center"]
test_records = frappe.get_test_records("Period Closing Voucher")

########NEW FILE########
__FILENAME__ = pos_setting
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import msgprint, _
from frappe.utils import cint

from frappe.model.document import Document

class POSSetting(Document):
	def validate(self):
		self.check_for_duplicate()
		self.validate_expense_account()
		self.validate_all_link_fields()

	def check_for_duplicate(self):
		res = frappe.db.sql("""select name, user from `tabPOS Setting`
			where ifnull(user, '') = %s and name != %s and company = %s""",
			(self.user, self.name, self.company))
		if res:
			if res[0][1]:
				msgprint(_("POS Setting {0} already created for user: {1} and company {2}").format(res[0][0],
					res[0][1], self.company), raise_exception=1)
			else:
				msgprint(_("Global POS Setting {0} already created for company {1}").format(res[0][0],
					self.company), raise_exception=1)

	def validate_expense_account(self):
		if cint(frappe.defaults.get_global_default("auto_accounting_for_stock")) \
				and not self.expense_account:
			msgprint(_("Expense Account is mandatory"), raise_exception=1)

	def validate_all_link_fields(self):
		accounts = {"Account": [self.cash_bank_account, self.income_account,
			self.expense_account], "Cost Center": [self.cost_center],
			"Warehouse": [self.warehouse]}

		for link_dt, dn_list in accounts.items():
			for link_dn in dn_list:
				if link_dn and not frappe.db.exists({"doctype": link_dt,
						"company": self.company, "name": link_dn}):
					frappe.throw(_("{0} does not belong to Company {1}").format(link_dn, self.company))

	def on_update(self):
		self.set_defaults()

	def on_trash(self):
		self.set_defaults(include_current_pos=False)

	def set_defaults(self, include_current_pos=True):
		frappe.defaults.clear_default("is_pos")

		if not include_current_pos:
			condition = " where name != '%s'" % self.name.replace("'", "\'")
		else:
			condition = ""

		pos_view_users = frappe.db.sql_list("""select user
			from `tabPOS Setting` {0}""".format(condition))

		for user in pos_view_users:
			if user:
				frappe.defaults.set_user_default("is_pos", 1, user)
			else:
				frappe.defaults.set_global_default("is_pos", 1)

@frappe.whitelist()
def get_series():
	return frappe.get_meta("Sales Invoice").get_field("naming_series").options or ""

########NEW FILE########
__FILENAME__ = pricing_rule
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# MIT License. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe import throw, _
from frappe.utils import flt
from frappe.model.document import Document

class PricingRule(Document):
	def validate(self):
		self.validate_mandatory()
		self.validate_min_max_qty()
		self.cleanup_fields_value()


	def validate_mandatory(self):
		for field in ["apply_on", "applicable_for", "price_or_discount"]:
			tocheck = frappe.scrub(self.get(field) or "")
			if tocheck and not self.get(tocheck):
				throw(_("{0} is required").format(self.meta.get_label(tocheck)), frappe.MandatoryError)

	def validate_min_max_qty(self):
		if self.min_qty and self.max_qty and flt(self.min_qty) > flt(self.max_qty):
			throw(_("Min Qty can not be greater than Max Qty"))


	def cleanup_fields_value(self):
		for logic_field in ["apply_on", "applicable_for", "price_or_discount"]:
			fieldname = frappe.scrub(self.get(logic_field) or "")

			# reset all values except for the logic field
			options = (self.meta.get_options(logic_field) or "").split("\n")
			for f in options:
				if not f: continue

				f = frappe.scrub(f)
				if f!=fieldname:
					self.set(f, None)

########NEW FILE########
__FILENAME__ = test_pricing_rule
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


from __future__ import unicode_literals
import unittest
import frappe

class TestPricingRule(unittest.TestCase):
	def test_pricing_rule_for_discount(self):
		from erpnext.stock.get_item_details import get_item_details
		from frappe import MandatoryError

		frappe.db.sql("delete from `tabPricing Rule`")

		test_record = {
			"doctype": "Pricing Rule",
			"apply_on": "Item Code",
			"item_code": "_Test Item",
			"price_or_discount": "Discount Percentage",
			"price": 0,
			"discount_percentage": 10,
		}
		frappe.get_doc(test_record.copy()).insert()

		args = frappe._dict({
			"item_code": "_Test Item",
			"company": "_Test Company",
			"price_list": "_Test Price List",
			"currency": "_Test Currency",
			"doctype": "Sales Order",
			"conversion_rate": 1,
			"price_list_currency": "_Test Currency",
			"plc_conversion_rate": 1,
			"order_type": "Sales",
			"transaction_type": "selling",
			"customer": "_Test Customer",
		})

		details = get_item_details(args)
		self.assertEquals(details.get("discount_percentage"), 10)

		prule = frappe.get_doc(test_record.copy())
		prule.applicable_for = "Customer"
		self.assertRaises(MandatoryError, prule.insert)
		prule.customer = "_Test Customer"
		prule.discount_percentage = 20
		prule.insert()
		details = get_item_details(args)
		self.assertEquals(details.get("discount_percentage"), 20)

		prule = frappe.get_doc(test_record.copy())
		prule.apply_on = "Item Group"
		prule.item_group = "All Item Groups"
		prule.discount_percentage = 15
		prule.insert()

		args.customer = None
		details = get_item_details(args)
		self.assertEquals(details.get("discount_percentage"), 10)

		prule = frappe.get_doc(test_record.copy())
		prule.applicable_for = "Campaign"
		prule.campaign = "_Test Campaign"
		prule.discount_percentage = 5
		prule.priority = 8
		prule.insert()

		args.campaign = "_Test Campaign"
		details = get_item_details(args)
		self.assertEquals(details.get("discount_percentage"), 5)

		frappe.db.sql("update `tabPricing Rule` set priority=NULL where campaign='_Test Campaign'")
		from erpnext.stock.get_item_details import MultiplePricingRuleConflict
		self.assertRaises (MultiplePricingRuleConflict, get_item_details, args)

		args.item_code = "_Test Item 2"
		details = get_item_details(args)
		self.assertEquals(details.get("discount_percentage"), 15)

		frappe.db.sql("delete from `tabPricing Rule`")

########NEW FILE########
__FILENAME__ = purchase_invoice
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import cint, cstr, flt, formatdate

from frappe import msgprint, _, throw
from erpnext.setup.utils import get_company_currency

import frappe.defaults

from erpnext.controllers.buying_controller import BuyingController
from erpnext.accounts.party import get_party_account, get_due_date

class PurchaseInvoice(BuyingController):
	tname = 'Purchase Invoice Item'
	fname = 'entries'

	def __init__(self, arg1, arg2=None):
		super(PurchaseInvoice, self).__init__(arg1, arg2)
		self.status_updater = [{
			'source_dt': 'Purchase Invoice Item',
			'target_dt': 'Purchase Order Item',
			'join_field': 'po_detail',
			'target_field': 'billed_amt',
			'target_parent_dt': 'Purchase Order',
			'target_parent_field': 'per_billed',
			'target_ref_field': 'amount',
			'source_field': 'amount',
			'percent_join_field': 'purchase_order',
		}]

	def validate(self):
		if not self.is_opening:
			self.is_opening = 'No'

		super(PurchaseInvoice, self).validate()

		self.po_required()
		self.pr_required()
		self.check_active_purchase_items()
		self.check_conversion_rate()
		self.validate_bill_no()
		self.validate_credit_acc()
		self.clear_unallocated_advances("Purchase Invoice Advance", "advance_allocation_details")
		self.check_for_acc_head_of_supplier()
		self.check_for_stopped_status()
		self.validate_with_previous_doc()
		self.validate_uom_is_integer("uom", "qty")
		self.set_aging_date()
		frappe.get_doc("Account", self.credit_to).validate_due_date(self.posting_date, self.due_date)
		self.set_against_expense_account()
		self.validate_write_off_account()
		self.update_valuation_rate("entries")
		self.validate_multiple_billing("Purchase Receipt", "pr_detail", "amount",
			"purchase_receipt_details")

	def set_missing_values(self, for_validate=False):
		if not self.credit_to:
			self.credit_to = get_party_account(self.company, self.supplier, "Supplier")
		if not self.due_date:
			self.due_date = get_due_date(self.posting_date, self.supplier, "Supplier",
				self.credit_to, self.company)

		super(PurchaseInvoice, self).set_missing_values(for_validate)

	def get_advances(self):
		super(PurchaseInvoice, self).get_advances(self.credit_to,
			"Purchase Invoice Advance", "advance_allocation_details", "debit")

	def check_active_purchase_items(self):
		for d in self.get('entries'):
			if d.item_code:		# extra condn coz item_code is not mandatory in PV
				if frappe.db.get_value("Item", d.item_code, "is_purchase_item") != 'Yes':
					msgprint(_("Item {0} is not Purchase Item").format(d.item_code), raise_exception=True)

	def check_conversion_rate(self):
		default_currency = get_company_currency(self.company)
		if not default_currency:
			throw(_('Please enter default currency in Company Master'))
		if (self.currency == default_currency and flt(self.conversion_rate) != 1.00) or not self.conversion_rate or (self.currency != default_currency and flt(self.conversion_rate) == 1.00):
			throw(_("Conversion rate cannot be 0 or 1"))

	def validate_bill_no(self):
		if self.bill_no and self.bill_no.lower().strip() \
				not in ['na', 'not applicable', 'none']:
			b_no = frappe.db.sql("""select bill_no, name, ifnull(is_opening,'') from `tabPurchase Invoice`
				where bill_no = %s and credit_to = %s and docstatus = 1 and name != %s""",
				(self.bill_no, self.credit_to, self.name))
			if b_no and cstr(b_no[0][2]) == cstr(self.is_opening):
				throw(_("Bill No {0} already booked in Purchase Invoice {1}").format(cstr(b_no[0][0]),
					cstr(b_no[0][1])))

			if not self.remarks and self.bill_date:
				self.remarks = (self.remarks or '') + "\n" \
					+ _("Against Bill {0} dated {1}").format(self.bill_no, formatdate(self.bill_date))

		if not self.remarks:
			self.remarks = "No Remarks"

	def validate_credit_acc(self):
		if frappe.db.get_value("Account", self.credit_to, "report_type") != "Balance Sheet":
			frappe.throw(_("Account must be a balance sheet account"))

	# Validate Acc Head of Supplier and Credit To Account entered
	# ------------------------------------------------------------
	def check_for_acc_head_of_supplier(self):
		if self.supplier and self.credit_to:
			acc_head = frappe.db.sql("select master_name from `tabAccount` where name = %s", self.credit_to)

			if (acc_head and cstr(acc_head[0][0]) != cstr(self.supplier)) or (not acc_head and (self.credit_to != cstr(self.supplier) + " - " + self.company_abbr)):
				msgprint("Credit To: %s do not match with Supplier: %s for Company: %s.\n If both correctly entered, please select Master Type and Master Name in account master." %(self.credit_to,self.supplier,self.company), raise_exception=1)

	# Check for Stopped PO
	# ---------------------
	def check_for_stopped_status(self):
		check_list = []
		for d in self.get('entries'):
			if d.purchase_order and not d.purchase_order in check_list and not d.purchase_receipt:
				check_list.append(d.purchase_order)
				stopped = frappe.db.sql("select name from `tabPurchase Order` where status = 'Stopped' and name = %s", d.purchase_order)
				if stopped:
					throw(_("Purchase Order {0} is 'Stopped'").format(d.purchase_order))

	def validate_with_previous_doc(self):
		super(PurchaseInvoice, self).validate_with_previous_doc(self.tname, {
			"Purchase Order": {
				"ref_dn_field": "purchase_order",
				"compare_fields": [["supplier", "="], ["company", "="], ["currency", "="]],
			},
			"Purchase Order Item": {
				"ref_dn_field": "po_detail",
				"compare_fields": [["project_name", "="], ["item_code", "="], ["uom", "="]],
				"is_child_table": True,
				"allow_duplicate_prev_row_id": True
			},
			"Purchase Receipt": {
				"ref_dn_field": "purchase_receipt",
				"compare_fields": [["supplier", "="], ["company", "="], ["currency", "="]],
			},
			"Purchase Receipt Item": {
				"ref_dn_field": "pr_detail",
				"compare_fields": [["project_name", "="], ["item_code", "="], ["uom", "="]],
				"is_child_table": True
			}
		})

		if cint(frappe.defaults.get_global_default('maintain_same_rate')):
			super(PurchaseInvoice, self).validate_with_previous_doc(self.tname, {
				"Purchase Order Item": {
					"ref_dn_field": "po_detail",
					"compare_fields": [["rate", "="]],
					"is_child_table": True,
					"allow_duplicate_prev_row_id": True
				},
				"Purchase Receipt Item": {
					"ref_dn_field": "pr_detail",
					"compare_fields": [["rate", "="]],
					"is_child_table": True
				}
			})


	def set_aging_date(self):
		if self.is_opening != 'Yes':
			self.aging_date = self.posting_date
		elif not self.aging_date:
			throw(_("Ageing date is mandatory for opening entry"))

	def set_against_expense_account(self):
		auto_accounting_for_stock = cint(frappe.defaults.get_global_default("auto_accounting_for_stock"))

		if auto_accounting_for_stock:
			stock_not_billed_account = self.get_company_default("stock_received_but_not_billed")

		against_accounts = []
		stock_items = self.get_stock_items()
		for item in self.get("entries"):
			if auto_accounting_for_stock and item.item_code in stock_items \
					and self.is_opening == 'No':
				# in case of auto inventory accounting, against expense account is always
				# Stock Received But Not Billed for a stock item
				item.expense_account = stock_not_billed_account
				item.cost_center = None

				if stock_not_billed_account not in against_accounts:
					against_accounts.append(stock_not_billed_account)

			elif not item.expense_account:
				throw(_("Expense account is mandatory for item {0}").format(item.item_code or item.item_name))

			elif item.expense_account not in against_accounts:
				# if no auto_accounting_for_stock or not a stock item
				against_accounts.append(item.expense_account)

		self.against_expense_account = ",".join(against_accounts)

	def po_required(self):
		if frappe.db.get_value("Buying Settings", None, "po_required") == 'Yes':
			 for d in self.get('entries'):
				 if not d.purchase_order:
					 throw(_("Purchse Order number required for Item {0}").format(d.item_code))

	def pr_required(self):
		if frappe.db.get_value("Buying Settings", None, "pr_required") == 'Yes':
			 for d in self.get('entries'):
				 if not d.purchase_receipt:
					 throw(_("Purchase Receipt number required for Item {0}").format(d.item_code))

	def validate_write_off_account(self):
		if self.write_off_amount and not self.write_off_account:
			throw(_("Please enter Write Off Account"))

	def check_prev_docstatus(self):
		for d in self.get('entries'):
			if d.purchase_order:
				submitted = frappe.db.sql("select name from `tabPurchase Order` where docstatus = 1 and name = %s", d.purchase_order)
				if not submitted:
					frappe.throw(_("Purchase Order {0} is not submitted").format(d.purchase_order))
			if d.purchase_receipt:
				submitted = frappe.db.sql("select name from `tabPurchase Receipt` where docstatus = 1 and name = %s", d.purchase_receipt)
				if not submitted:
					frappe.throw(_("Purchase Receipt {0} is not submitted").format(d.purchase_receipt))


	def update_against_document_in_jv(self):
		"""
			Links invoice and advance voucher:
				1. cancel advance voucher
				2. split into multiple rows if partially adjusted, assign against voucher
				3. submit advance voucher
		"""

		lst = []
		for d in self.get('advance_allocation_details'):
			if flt(d.allocated_amount) > 0:
				args = {
					'voucher_no' : d.journal_voucher,
					'voucher_detail_no' : d.jv_detail_no,
					'against_voucher_type' : 'Purchase Invoice',
					'against_voucher'  : self.name,
					'account' : self.credit_to,
					'is_advance' : 'Yes',
					'dr_or_cr' : 'debit',
					'unadjusted_amt' : flt(d.advance_amount),
					'allocated_amt' : flt(d.allocated_amount)
				}
				lst.append(args)

		if lst:
			from erpnext.accounts.utils import reconcile_against_document
			reconcile_against_document(lst)

	def on_submit(self):
		self.check_prev_docstatus()

		frappe.get_doc('Authorization Control').validate_approving_authority(self.doctype,
			self.company, self.grand_total)

		# this sequence because outstanding may get -negative
		self.make_gl_entries()
		self.update_against_document_in_jv()
		self.update_prevdoc_status()
		self.update_billing_status_for_zero_amount_refdoc("Purchase Order")

	def make_gl_entries(self):
		auto_accounting_for_stock = \
			cint(frappe.defaults.get_global_default("auto_accounting_for_stock"))

		gl_entries = []

		# parent's gl entry
		if self.grand_total:
			gl_entries.append(
				self.get_gl_dict({
					"account": self.credit_to,
					"against": self.against_expense_account,
					"credit": self.total_amount_to_pay,
					"remarks": self.remarks,
					"against_voucher": self.name,
					"against_voucher_type": self.doctype,
				})
			)

		# tax table gl entries
		valuation_tax = {}
		for tax in self.get("other_charges"):
			if tax.category in ("Total", "Valuation and Total") and flt(tax.tax_amount):
				gl_entries.append(
					self.get_gl_dict({
						"account": tax.account_head,
						"against": self.credit_to,
						"debit": tax.add_deduct_tax == "Add" and tax.tax_amount or 0,
						"credit": tax.add_deduct_tax == "Deduct" and tax.tax_amount or 0,
						"remarks": self.remarks,
						"cost_center": tax.cost_center
					})
				)

			# accumulate valuation tax
			if tax.category in ("Valuation", "Valuation and Total") and flt(tax.tax_amount):
				if auto_accounting_for_stock and not tax.cost_center:
					frappe.throw(_("Cost Center is required in row {0} in Taxes table for type {1}").format(tax.idx, _(tax.category)))
				valuation_tax.setdefault(tax.cost_center, 0)
				valuation_tax[tax.cost_center] += \
					(tax.add_deduct_tax == "Add" and 1 or -1) * flt(tax.tax_amount)

		# item gl entries
		stock_item_and_auto_accounting_for_stock = False
		stock_items = self.get_stock_items()
		for item in self.get("entries"):
			if auto_accounting_for_stock and item.item_code in stock_items:
				if flt(item.valuation_rate):
					# if auto inventory accounting enabled and stock item,
					# then do stock related gl entries
					# expense will be booked in sales invoice
					stock_item_and_auto_accounting_for_stock = True

					valuation_amt = flt(item.base_amount + item.item_tax_amount,
						self.precision("base_amount", item))

					gl_entries.append(
						self.get_gl_dict({
							"account": item.expense_account,
							"against": self.credit_to,
							"debit": valuation_amt,
							"remarks": self.remarks or "Accounting Entry for Stock"
						})
					)

			elif flt(item.base_amount):
				# if not a stock item or auto inventory accounting disabled, book the expense
				gl_entries.append(
					self.get_gl_dict({
						"account": item.expense_account,
						"against": self.credit_to,
						"debit": item.base_amount,
						"remarks": self.remarks,
						"cost_center": item.cost_center
					})
				)

		if stock_item_and_auto_accounting_for_stock and valuation_tax:
			# credit valuation tax amount in "Expenses Included In Valuation"
			# this will balance out valuation amount included in cost of goods sold
			expenses_included_in_valuation = \
				self.get_company_default("expenses_included_in_valuation")

			for cost_center, amount in valuation_tax.items():
				gl_entries.append(
					self.get_gl_dict({
						"account": expenses_included_in_valuation,
						"cost_center": cost_center,
						"against": self.credit_to,
						"credit": amount,
						"remarks": self.remarks or "Accounting Entry for Stock"
					})
				)

		# writeoff account includes petty difference in the invoice amount
		# and the amount that is paid
		if self.write_off_account and flt(self.write_off_amount):
			gl_entries.append(
				self.get_gl_dict({
					"account": self.write_off_account,
					"against": self.credit_to,
					"credit": flt(self.write_off_amount),
					"remarks": self.remarks,
					"cost_center": self.write_off_cost_center
				})
			)

		if gl_entries:
			from erpnext.accounts.general_ledger import make_gl_entries
			make_gl_entries(gl_entries, cancel=(self.docstatus == 2))

	def on_cancel(self):
		from erpnext.accounts.utils import remove_against_link_from_jv
		remove_against_link_from_jv(self.doctype, self.name, "against_voucher")

		self.update_prevdoc_status()
		self.update_billing_status_for_zero_amount_refdoc("Purchase Order")
		self.make_cancel_gl_entries()

	def on_update(self):
		pass

@frappe.whitelist()
def get_expense_account(doctype, txt, searchfield, start, page_len, filters):
	from erpnext.controllers.queries import get_match_cond

	# expense account can be any Debit account,
	# but can also be a Liability account with account_type='Expense Account' in special circumstances.
	# Hence the first condition is an "OR"
	return frappe.db.sql("""select tabAccount.name from `tabAccount`
			where (tabAccount.report_type = "Profit and Loss"
					or tabAccount.account_type = "Expense Account")
				and tabAccount.group_or_ledger="Ledger"
				and tabAccount.docstatus!=2
				and ifnull(tabAccount.master_type, "")=""
				and ifnull(tabAccount.master_name, "")=""
				and tabAccount.company = '%(company)s'
				and tabAccount.%(key)s LIKE '%(txt)s'
				%(mcond)s""" % {'company': filters['company'], 'key': searchfield,
			'txt': "%%%s%%" % txt, 'mcond':get_match_cond(doctype)})

########NEW FILE########
__FILENAME__ = test_purchase_invoice
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


from __future__ import unicode_literals
import unittest
import frappe
import frappe.model
import json
from frappe.utils import cint
import frappe.defaults
from erpnext.stock.doctype.purchase_receipt.test_purchase_receipt import set_perpetual_inventory

test_dependencies = ["Item", "Cost Center"]
test_ignore = ["Serial No"]

class TestPurchaseInvoice(unittest.TestCase):
	def test_gl_entries_without_auto_accounting_for_stock(self):
		set_perpetual_inventory(0)
		self.assertTrue(not cint(frappe.defaults.get_global_default("auto_accounting_for_stock")))

		wrapper = frappe.copy_doc(test_records[0])
		wrapper.insert()
		wrapper.submit()
		wrapper.load_from_db()
		dl = wrapper

		expected_gl_entries = {
			"_Test Supplier - _TC": [0, 1512.30],
			"_Test Account Cost for Goods Sold - _TC": [1250, 0],
			"_Test Account Shipping Charges - _TC": [100, 0],
			"_Test Account Excise Duty - _TC": [140, 0],
			"_Test Account Education Cess - _TC": [2.8, 0],
			"_Test Account S&H Education Cess - _TC": [1.4, 0],
			"_Test Account CST - _TC": [29.88, 0],
			"_Test Account VAT - _TC": [156.25, 0],
			"_Test Account Discount - _TC": [0, 168.03],
		}
		gl_entries = frappe.db.sql("""select account, debit, credit from `tabGL Entry`
			where voucher_type = 'Purchase Invoice' and voucher_no = %s""", dl.name, as_dict=1)
		for d in gl_entries:
			self.assertEqual([d.debit, d.credit], expected_gl_entries.get(d.account))

	def test_gl_entries_with_auto_accounting_for_stock(self):
		set_perpetual_inventory(1)
		self.assertEqual(cint(frappe.defaults.get_global_default("auto_accounting_for_stock")), 1)

		pi = frappe.copy_doc(test_records[1])
		pi.insert()
		pi.submit()

		gl_entries = frappe.db.sql("""select account, debit, credit
			from `tabGL Entry` where voucher_type='Purchase Invoice' and voucher_no=%s
			order by account asc""", pi.name, as_dict=1)
		self.assertTrue(gl_entries)

		expected_values = sorted([
			["_Test Supplier - _TC", 0, 720],
			["Stock Received But Not Billed - _TC", 750.0, 0],
			["_Test Account Shipping Charges - _TC", 100.0, 0],
			["_Test Account VAT - _TC", 120.0, 0],
			["Expenses Included In Valuation - _TC", 0, 250.0],
		])

		for i, gle in enumerate(gl_entries):
			self.assertEquals(expected_values[i][0], gle.account)
			self.assertEquals(expected_values[i][1], gle.debit)
			self.assertEquals(expected_values[i][2], gle.credit)

		set_perpetual_inventory(0)

	def test_gl_entries_with_aia_for_non_stock_items(self):
		set_perpetual_inventory()
		self.assertEqual(cint(frappe.defaults.get_global_default("auto_accounting_for_stock")), 1)

		pi = frappe.copy_doc(test_records[1])
		pi.get("entries")[0].item_code = "_Test Non Stock Item"
		pi.get("entries")[0].expense_account = "_Test Account Cost for Goods Sold - _TC"
		pi.get("other_charges").pop(0)
		pi.get("other_charges").pop(1)
		pi.insert()
		pi.submit()

		gl_entries = frappe.db.sql("""select account, debit, credit
			from `tabGL Entry` where voucher_type='Purchase Invoice' and voucher_no=%s
			order by account asc""", pi.name, as_dict=1)
		self.assertTrue(gl_entries)

		expected_values = sorted([
			["_Test Supplier - _TC", 0, 620],
			["_Test Account Cost for Goods Sold - _TC", 500.0, 0],
			["_Test Account VAT - _TC", 120.0, 0],
		])

		for i, gle in enumerate(gl_entries):
			self.assertEquals(expected_values[i][0], gle.account)
			self.assertEquals(expected_values[i][1], gle.debit)
			self.assertEquals(expected_values[i][2], gle.credit)
		set_perpetual_inventory(0)

	def test_purchase_invoice_calculation(self):
		wrapper = frappe.copy_doc(test_records[0])
		wrapper.insert()
		wrapper.load_from_db()

		expected_values = [
			["_Test Item Home Desktop 100", 90, 59],
			["_Test Item Home Desktop 200", 135, 177]
		]
		for i, item in enumerate(wrapper.get("entries")):
			self.assertEqual(item.item_code, expected_values[i][0])
			self.assertEqual(item.item_tax_amount, expected_values[i][1])
			self.assertEqual(item.valuation_rate, expected_values[i][2])

		self.assertEqual(wrapper.net_total, 1250)

		# tax amounts
		expected_values = [
			["_Test Account Shipping Charges - _TC", 100, 1350],
			["_Test Account Customs Duty - _TC", 125, 1350],
			["_Test Account Excise Duty - _TC", 140, 1490],
			["_Test Account Education Cess - _TC", 2.8, 1492.8],
			["_Test Account S&H Education Cess - _TC", 1.4, 1494.2],
			["_Test Account CST - _TC", 29.88, 1524.08],
			["_Test Account VAT - _TC", 156.25, 1680.33],
			["_Test Account Discount - _TC", 168.03, 1512.30],
		]

		for i, tax in enumerate(wrapper.get("other_charges")):
			self.assertEqual(tax.account_head, expected_values[i][0])
			self.assertEqual(tax.tax_amount, expected_values[i][1])
			self.assertEqual(tax.total, expected_values[i][2])

	def test_purchase_invoice_with_subcontracted_item(self):
		wrapper = frappe.copy_doc(test_records[0])
		wrapper.get("entries")[0].item_code = "_Test FG Item"
		wrapper.insert()
		wrapper.load_from_db()

		expected_values = [
			["_Test FG Item", 90, 59],
			["_Test Item Home Desktop 200", 135, 177]
		]
		for i, item in enumerate(wrapper.get("entries")):
			self.assertEqual(item.item_code, expected_values[i][0])
			self.assertEqual(item.item_tax_amount, expected_values[i][1])
			self.assertEqual(item.valuation_rate, expected_values[i][2])

		self.assertEqual(wrapper.net_total, 1250)

		# tax amounts
		expected_values = [
			["_Test Account Shipping Charges - _TC", 100, 1350],
			["_Test Account Customs Duty - _TC", 125, 1350],
			["_Test Account Excise Duty - _TC", 140, 1490],
			["_Test Account Education Cess - _TC", 2.8, 1492.8],
			["_Test Account S&H Education Cess - _TC", 1.4, 1494.2],
			["_Test Account CST - _TC", 29.88, 1524.08],
			["_Test Account VAT - _TC", 156.25, 1680.33],
			["_Test Account Discount - _TC", 168.03, 1512.30],
		]

		for i, tax in enumerate(wrapper.get("other_charges")):
			self.assertEqual(tax.account_head, expected_values[i][0])
			self.assertEqual(tax.tax_amount, expected_values[i][1])
			self.assertEqual(tax.total, expected_values[i][2])

	def test_purchase_invoice_with_advance(self):
		from erpnext.accounts.doctype.journal_voucher.test_journal_voucher \
			import test_records as jv_test_records

		jv = frappe.copy_doc(jv_test_records[1])
		jv.insert()
		jv.submit()

		pi = frappe.copy_doc(test_records[0])
		pi.append("advance_allocation_details", {
			"journal_voucher": jv.name,
			"jv_detail_no": jv.get("entries")[0].name,
			"advance_amount": 400,
			"allocated_amount": 300,
			"remarks": jv.remark
		})
		pi.insert()
		pi.submit()
		pi.load_from_db()

		self.assertTrue(frappe.db.sql("""select name from `tabJournal Voucher Detail`
			where against_voucher=%s""", pi.name))

		self.assertTrue(frappe.db.sql("""select name from `tabJournal Voucher Detail`
			where against_voucher=%s and debit=300""", pi.name))

		self.assertEqual(pi.outstanding_amount, 1212.30)

		pi.cancel()

		self.assertTrue(not frappe.db.sql("""select name from `tabJournal Voucher Detail`
			where against_voucher=%s""", pi.name))

test_records = frappe.get_test_records('Purchase Invoice')

########NEW FILE########
__FILENAME__ = purchase_invoice_advance
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class PurchaseInvoiceAdvance(Document):
	pass
########NEW FILE########
__FILENAME__ = purchase_invoice_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class PurchaseInvoiceItem(Document):
	pass
########NEW FILE########
__FILENAME__ = purchase_taxes_and_charges
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class PurchaseTaxesandCharges(Document):
	pass
########NEW FILE########
__FILENAME__ = purchase_taxes_and_charges_master
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.model.document import Document

class PurchaseTaxesandChargesMaster(Document):
	pass

########NEW FILE########
__FILENAME__ = pos
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

@frappe.whitelist()
def get_items(price_list, sales_or_purchase, item=None, item_group=None):
	condition = ""
	args = {"price_list": price_list}

	if sales_or_purchase == "Sales":
		condition = "i.is_sales_item='Yes'"
	else:
		condition = "i.is_purchase_item='Yes'"

	if item_group and item_group != "All Item Groups":
		condition += " and i.item_group='%s'" % item_group.replace("'", "\'")

	if item:
		condition += " and CONCAT(i.name, i.item_name) like %(name)s"
		args["name"] = "%%%s%%" % item

	return frappe.db.sql("""select i.name, i.item_name, i.image,
		item_det.price_list_rate, item_det.currency
		from `tabItem` i LEFT JOIN
			(select item_code, price_list_rate, currency from
				`tabItem Price`	where price_list=%s) item_det
		ON
			item_det.item_code=i.name
		where
			%s""" % ('%(price_list)s', condition), args, as_dict=1)

@frappe.whitelist()
def get_item_code(barcode_serial_no):
	input_via = "serial_no"
	item_code = frappe.db.sql("""select name, item_code from `tabSerial No` where
		name=%s""", (barcode_serial_no), as_dict=1)

	if not item_code:
		input_via = "barcode"
		item_code = frappe.db.sql("""select name from `tabItem` where barcode=%s""",
			(barcode_serial_no), as_dict=1)

	if item_code:
		return item_code, input_via
	else:
		frappe.throw(frappe._("Invalid Barcode or Serial No"))

@frappe.whitelist()
def get_mode_of_payment():
	return frappe.get_list("Mode of Payment")

########NEW FILE########
__FILENAME__ = sales_invoice
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
import frappe.defaults

from frappe.utils import add_days, cint, cstr, date_diff, flt, getdate, nowdate, \
	get_first_day, get_last_day
from frappe.model.naming import make_autoname
from frappe import _, msgprint, throw

from erpnext.accounts.party import get_party_account, get_due_date
from erpnext.controllers.stock_controller import update_gl_entries_after
from frappe.model.mapper import get_mapped_doc

month_map = {'Monthly': 1, 'Quarterly': 3, 'Half-yearly': 6, 'Yearly': 12}

from erpnext.controllers.selling_controller import SellingController

class SalesInvoice(SellingController):
	tname = 'Sales Invoice Item'
	fname = 'entries'

	def __init__(self, arg1, arg2=None):
		super(SalesInvoice, self).__init__(arg1, arg2)
		self.status_updater = [{
			'source_dt': 'Sales Invoice Item',
			'target_field': 'billed_amt',
			'target_ref_field': 'amount',
			'target_dt': 'Sales Order Item',
			'join_field': 'so_detail',
			'target_parent_dt': 'Sales Order',
			'target_parent_field': 'per_billed',
			'source_field': 'amount',
			'join_field': 'so_detail',
			'percent_join_field': 'sales_order',
			'status_field': 'billing_status',
			'keyword': 'Billed'
		}]

	def validate(self):
		super(SalesInvoice, self).validate()
		self.validate_posting_time()
		self.so_dn_required()
		self.validate_proj_cust()
		self.validate_with_previous_doc()
		self.validate_uom_is_integer("stock_uom", "qty")
		self.check_stop_sales_order("sales_order")
		self.validate_customer_account()
		self.validate_debit_acc()
		self.validate_fixed_asset_account()
		self.clear_unallocated_advances("Sales Invoice Advance", "advance_adjustment_details")
		self.add_remarks()

		if cint(self.is_pos):
			self.validate_pos()
			self.validate_write_off_account()

		if cint(self.update_stock):
			self.validate_item_code()
			self.update_current_stock()
			self.validate_delivery_note()

		if not self.is_opening:
			self.is_opening = 'No'

		self.set_aging_date()
		frappe.get_doc("Account", self.debit_to).validate_due_date(self.posting_date, self.due_date)
		self.set_against_income_account()
		self.validate_c_form()
		self.validate_time_logs_are_submitted()
		self.validate_recurring_invoice()
		self.validate_multiple_billing("Delivery Note", "dn_detail", "amount",
			"delivery_note_details")

	def on_submit(self):
		if cint(self.update_stock) == 1:
			self.update_stock_ledger()
		else:
			# Check for Approving Authority
			if not self.recurring_id:
				frappe.get_doc('Authorization Control').validate_approving_authority(self.doctype,
				 	self.company, self.grand_total, self)

		self.check_prev_docstatus()

		self.update_status_updater_args()
		self.update_prevdoc_status()
		self.update_billing_status_for_zero_amount_refdoc("Sales Order")

		# this sequence because outstanding may get -ve
		self.make_gl_entries()
		self.check_credit_limit(self.debit_to)

		if not cint(self.is_pos) == 1:
			self.update_against_document_in_jv()

		self.update_c_form()
		self.update_time_log_batch(self.name)
		self.convert_to_recurring()

	def before_cancel(self):
		self.update_time_log_batch(None)

	def on_cancel(self):
		if cint(self.update_stock) == 1:
			self.update_stock_ledger()

		self.check_stop_sales_order("sales_order")

		from erpnext.accounts.utils import remove_against_link_from_jv
		remove_against_link_from_jv(self.doctype, self.name, "against_invoice")

		self.update_status_updater_args()
		self.update_prevdoc_status()
		self.update_billing_status_for_zero_amount_refdoc("Sales Order")

		self.make_cancel_gl_entries()

	def update_status_updater_args(self):
		if cint(self.update_stock):
			self.status_updater.append({
				'source_dt':'Sales Invoice Item',
				'target_dt':'Sales Order Item',
				'target_parent_dt':'Sales Order',
				'target_parent_field':'per_delivered',
				'target_field':'delivered_qty',
				'target_ref_field':'qty',
				'source_field':'qty',
				'join_field':'so_detail',
				'percent_join_field':'sales_order',
				'status_field':'delivery_status',
				'keyword':'Delivered',
				'second_source_dt': 'Delivery Note Item',
				'second_source_field': 'qty',
				'second_join_field': 'prevdoc_detail_docname'
			})

	def on_update_after_submit(self):
		self.validate_recurring_invoice()
		self.convert_to_recurring()

	def get_portal_page(self):
		return "invoice" if self.docstatus==1 else None

	def set_missing_values(self, for_validate=False):
		self.set_pos_fields(for_validate)

		if not self.debit_to:
			self.debit_to = get_party_account(self.company, self.customer, "Customer")
		if not self.due_date:
			self.due_date = get_due_date(self.posting_date, self.customer, "Customer",
				self.debit_to, self.company)

		super(SalesInvoice, self).set_missing_values(for_validate)

	def update_time_log_batch(self, sales_invoice):
		for d in self.get(self.fname):
			if d.time_log_batch:
				tlb = frappe.get_doc("Time Log Batch", d.time_log_batch)
				tlb.sales_invoice = sales_invoice
				tlb.ignore_validate_update_after_submit = True
				tlb.save()

	def validate_time_logs_are_submitted(self):
		for d in self.get(self.fname):
			if d.time_log_batch:
				status = frappe.db.get_value("Time Log Batch", d.time_log_batch, "status")
				if status!="Submitted":
					frappe.throw(_("Time Log Batch {0} must be 'Submitted'").format(d.time_log_batch))

	def set_pos_fields(self, for_validate=False):
		"""Set retail related fields from pos settings"""
		if cint(self.is_pos) != 1:
			return

		from erpnext.stock.get_item_details import get_pos_settings_item_details, get_pos_settings
		pos = get_pos_settings(self.company)

		if pos:
			if not for_validate and not self.customer:
				self.customer = pos.customer
				# self.set_customer_defaults()

			for fieldname in ('territory', 'naming_series', 'currency', 'taxes_and_charges', 'letter_head', 'tc_name',
				'selling_price_list', 'company', 'select_print_heading', 'cash_bank_account'):
					if (not for_validate) or (for_validate and not self.get(fieldname)):
						self.set(fieldname, pos.get(fieldname))

			if not for_validate:
				self.update_stock = cint(pos.get("update_stock"))

			# set pos values in items
			for item in self.get("entries"):
				if item.get('item_code'):
					for fname, val in get_pos_settings_item_details(pos,
						frappe._dict(item.as_dict()), pos).items():

						if (not for_validate) or (for_validate and not item.get(fname)):
							item.set(fname, val)

			# fetch terms
			if self.tc_name and not self.terms:
				self.terms = frappe.db.get_value("Terms and Conditions", self.tc_name, "terms")

			# fetch charges
			if self.taxes_and_charges and not len(self.get("other_charges")):
				self.set_taxes("other_charges", "taxes_and_charges")

	def get_advances(self):
		super(SalesInvoice, self).get_advances(self.debit_to,
			"Sales Invoice Advance", "advance_adjustment_details", "credit")

	def get_company_abbr(self):
		return frappe.db.sql("select abbr from tabCompany where name=%s", self.company)[0][0]

	def update_against_document_in_jv(self):
		"""
			Links invoice and advance voucher:
				1. cancel advance voucher
				2. split into multiple rows if partially adjusted, assign against voucher
				3. submit advance voucher
		"""

		lst = []
		for d in self.get('advance_adjustment_details'):
			if flt(d.allocated_amount) > 0:
				args = {
					'voucher_no' : d.journal_voucher,
					'voucher_detail_no' : d.jv_detail_no,
					'against_voucher_type' : 'Sales Invoice',
					'against_voucher'  : self.name,
					'account' : self.debit_to,
					'is_advance' : 'Yes',
					'dr_or_cr' : 'credit',
					'unadjusted_amt' : flt(d.advance_amount),
					'allocated_amt' : flt(d.allocated_amount)
				}
				lst.append(args)

		if lst:
			from erpnext.accounts.utils import reconcile_against_document
			reconcile_against_document(lst)

	def validate_customer_account(self):
		"""Validates Debit To Account and Customer Matches"""
		if self.customer and self.debit_to and not cint(self.is_pos):
			acc_head = frappe.db.sql("select master_name from `tabAccount` where name = %s and docstatus != 2", self.debit_to)

			if (acc_head and cstr(acc_head[0][0]) != cstr(self.customer)) or \
				(not acc_head and (self.debit_to != cstr(self.customer) + " - " + self.get_company_abbr())):
				msgprint("Debit To: %s do not match with Customer: %s for Company: %s.\n If both correctly entered, please select Master Type \
					and Master Name in account master." %(self.debit_to, self.customer,self.company), raise_exception=1)


	def validate_debit_acc(self):
		if frappe.db.get_value("Account", self.debit_to, "report_type") != "Balance Sheet":
			frappe.throw(_("Account must be a balance sheet account"))

	def validate_fixed_asset_account(self):
		"""Validate Fixed Asset and whether Income Account Entered Exists"""
		for d in self.get('entries'):
			item = frappe.db.sql("""select name,is_asset_item,is_sales_item from `tabItem`
				where name = %s and (ifnull(end_of_life,'')='' or end_of_life > now())""", d.item_code)
			acc =	frappe.db.sql("""select account_type from `tabAccount`
				where name = %s and docstatus != 2""", d.income_account)
			if item and item[0][1] == 'Yes' and not acc[0][0] == 'Fixed Asset':
				msgprint(_("Account {0} must be of type 'Fixed Asset' as Item {1} is an Asset Item").format(d.item_code), raise_exception=True)

	def validate_with_previous_doc(self):
		super(SalesInvoice, self).validate_with_previous_doc(self.tname, {
			"Sales Order": {
				"ref_dn_field": "sales_order",
				"compare_fields": [["customer", "="], ["company", "="], ["project_name", "="],
					["currency", "="]],
			},
			"Delivery Note": {
				"ref_dn_field": "delivery_note",
				"compare_fields": [["customer", "="], ["company", "="], ["project_name", "="],
					["currency", "="]],
			},
		})

		if cint(frappe.defaults.get_global_default('maintain_same_sales_rate')):
			super(SalesInvoice, self).validate_with_previous_doc(self.tname, {
				"Sales Order Item": {
					"ref_dn_field": "so_detail",
					"compare_fields": [["rate", "="]],
					"is_child_table": True,
					"allow_duplicate_prev_row_id": True
				},
				"Delivery Note Item": {
					"ref_dn_field": "dn_detail",
					"compare_fields": [["rate", "="]],
					"is_child_table": True
				}
			})


	def set_aging_date(self):
		if self.is_opening != 'Yes':
			self.aging_date = self.posting_date
		elif not self.aging_date:
			throw(_("Ageing Date is mandatory for opening entry"))

	def set_against_income_account(self):
		"""Set against account for debit to account"""
		against_acc = []
		for d in self.get('entries'):
			if d.income_account not in against_acc:
				against_acc.append(d.income_account)
		self.against_income_account = ','.join(against_acc)


	def add_remarks(self):
		if not self.remarks: self.remarks = 'No Remarks'


	def so_dn_required(self):
		"""check in manage account if sales order / delivery note required or not."""
		dic = {'Sales Order':'so_required','Delivery Note':'dn_required'}
		for i in dic:
			if frappe.db.get_value('Selling Settings', None, dic[i]) == 'Yes':
				for d in self.get('entries'):
					if frappe.db.get_value('Item', d.item_code, 'is_stock_item') == 'Yes' \
						and not d.get(i.lower().replace(' ','_')):
						msgprint(_("{0} is mandatory for Item {1}").format(i,d.item_code), raise_exception=1)


	def validate_proj_cust(self):
		"""check for does customer belong to same project as entered.."""
		if self.project_name and self.customer:
			res = frappe.db.sql("""select name from `tabProject`
				where name = %s and (customer = %s or
					ifnull(customer,'')='')""", (self.project_name, self.customer))
			if not res:
				throw(_("Customer {0} does not belong to project {1}").format(self.customer,self.project_name))

	def validate_pos(self):
		if not self.cash_bank_account and flt(self.paid_amount):
			msgprint(_("Cash or Bank Account is mandatory for making payment entry"))
			raise Exception
		if flt(self.paid_amount) + flt(self.write_off_amount) \
				- flt(self.grand_total) > 1/(10**(self.precision("grand_total") + 1)):
			frappe.throw(_("""Paid amount + Write Off Amount can not be greater than Grand Total"""))


	def validate_item_code(self):
		for d in self.get('entries'):
			if not d.item_code:
				msgprint(_("Item Code required at Row No {0}").format(d.idx), raise_exception=True)

	def validate_delivery_note(self):
		for d in self.get("entries"):
			if d.delivery_note:
				msgprint(_("Stock cannot be updated against Delivery Note {0}").format(d.delivery_note), raise_exception=1)


	def validate_write_off_account(self):
		if flt(self.write_off_amount) and not self.write_off_account:
			msgprint(_("Please enter Write Off Account"), raise_exception=1)


	def validate_c_form(self):
		""" Blank C-form no if C-form applicable marked as 'No'"""
		if self.amended_from and self.c_form_applicable == 'No' and self.c_form_no:
			frappe.db.sql("""delete from `tabC-Form Invoice Detail` where invoice_no = %s
					and parent = %s""", (self.amended_from,	self.c_form_no))

			frappe.db.set(self, 'c_form_no', '')

	def update_current_stock(self):
		for d in self.get('entries'):
			if d.item_code and d.warehouse:
				bin = frappe.db.sql("select actual_qty from `tabBin` where item_code = %s and warehouse = %s", (d.item_code, d.warehouse), as_dict = 1)
				d.actual_qty = bin and flt(bin[0]['actual_qty']) or 0

		for d in self.get('packing_details'):
			bin = frappe.db.sql("select actual_qty, projected_qty from `tabBin` where item_code =	%s and warehouse = %s", (d.item_code, d.warehouse), as_dict = 1)
			d.actual_qty = bin and flt(bin[0]['actual_qty']) or 0
			d.projected_qty = bin and flt(bin[0]['projected_qty']) or 0


	def get_warehouse(self):
		w = frappe.db.sql("""select warehouse from `tabPOS Setting`
			where ifnull(user,'') = %s and company = %s""",
			(frappe.session['user'], self.company))
		w = w and w[0][0] or ''
		if not w:
			ps = frappe.db.sql("""select name, warehouse from `tabPOS Setting`
				where ifnull(user,'') = '' and company = %s""", self.company)
			if not ps:
				msgprint(_("POS Setting required to make POS Entry"), raise_exception=True)
			elif not ps[0][1]:
				msgprint(_("Warehouse required in POS Setting"))
			else:
				w = ps[0][1]
		return w

	def on_update(self):
		if cint(self.update_stock) == 1:
			# Set default warehouse from pos setting
			if cint(self.is_pos) == 1:
				w = self.get_warehouse()
				if w:
					for d in self.get('entries'):
						if not d.warehouse:
							d.warehouse = cstr(w)

			from erpnext.stock.doctype.packed_item.packed_item import make_packing_list
			make_packing_list(self, 'entries')
		else:
			self.set('packing_details', [])

		if cint(self.is_pos) == 1:
			if flt(self.paid_amount) == 0:
				if self.cash_bank_account:
					frappe.db.set(self, 'paid_amount',
						(flt(self.grand_total) - flt(self.write_off_amount)))
				else:
					# show message that the amount is not paid
					frappe.db.set(self,'paid_amount',0)
					frappe.msgprint(_("Note: Payment Entry will not be created since 'Cash or Bank Account' was not specified"))
		else:
			frappe.db.set(self,'paid_amount',0)

	def check_prev_docstatus(self):
		for d in self.get('entries'):
			if d.sales_order:
				submitted = frappe.db.sql("""select name from `tabSales Order`
					where docstatus = 1 and name = %s""", d.sales_order)
				if not submitted:
					msgprint(_("Sales Order {0} is not submitted").format(d.sales_order))
					raise Exception

			if d.delivery_note:
				submitted = frappe.db.sql("""select name from `tabDelivery Note`
					where docstatus = 1 and name = %s""", d.delivery_note)
				if not submitted:
					throw(_("Delivery Note {0} is not submitted").format(d.delivery_note))

	def update_stock_ledger(self):
		sl_entries = []
		for d in self.get_item_list():
			if frappe.db.get_value("Item", d.item_code, "is_stock_item") == "Yes" \
					and d.warehouse:
				sl_entries.append(self.get_sl_entries(d, {
					"actual_qty": -1*flt(d.qty),
					"stock_uom": frappe.db.get_value("Item", d.item_code, "stock_uom")
				}))

		self.make_sl_entries(sl_entries)

	def make_gl_entries(self, repost_future_gle=True):
		gl_entries = self.get_gl_entries()

		if gl_entries:
			from erpnext.accounts.general_ledger import make_gl_entries

			update_outstanding = cint(self.is_pos) and self.write_off_account \
				and 'No' or 'Yes'
			make_gl_entries(gl_entries, cancel=(self.docstatus == 2),
				update_outstanding=update_outstanding, merge_entries=False)

			if update_outstanding == "No":
				from erpnext.accounts.doctype.gl_entry.gl_entry import update_outstanding_amt
				update_outstanding_amt(self.debit_to, self.doctype, self.name)

			if repost_future_gle and cint(self.update_stock) \
				and cint(frappe.defaults.get_global_default("auto_accounting_for_stock")):
					items, warehouse_account = self.get_items_and_warehouse_accounts()
					update_gl_entries_after(self.posting_date, self.posting_time,
						warehouse_account, items)

	def get_gl_entries(self, warehouse_account=None):
		from erpnext.accounts.general_ledger import merge_similar_entries

		gl_entries = []

		self.make_customer_gl_entry(gl_entries)

		self.make_tax_gl_entries(gl_entries)

		self.make_item_gl_entries(gl_entries)

		# merge gl entries before adding pos entries
		gl_entries = merge_similar_entries(gl_entries)

		self.make_pos_gl_entries(gl_entries)

		return gl_entries

	def make_customer_gl_entry(self, gl_entries):
		if self.grand_total:
			gl_entries.append(
				self.get_gl_dict({
					"account": self.debit_to,
					"against": self.against_income_account,
					"debit": self.grand_total,
					"remarks": self.remarks,
					"against_voucher": self.name,
					"against_voucher_type": self.doctype,
				})
			)

	def make_tax_gl_entries(self, gl_entries):
		for tax in self.get("other_charges"):
			if flt(tax.tax_amount_after_discount_amount):
				gl_entries.append(
					self.get_gl_dict({
						"account": tax.account_head,
						"against": self.debit_to,
						"credit": flt(tax.tax_amount_after_discount_amount),
						"remarks": self.remarks,
						"cost_center": tax.cost_center
					})
				)

	def make_item_gl_entries(self, gl_entries):
		# income account gl entries
		for item in self.get("entries"):
			if flt(item.base_amount):
				gl_entries.append(
					self.get_gl_dict({
						"account": item.income_account,
						"against": self.debit_to,
						"credit": item.base_amount,
						"remarks": self.remarks,
						"cost_center": item.cost_center
					})
				)

		# expense account gl entries
		if cint(frappe.defaults.get_global_default("auto_accounting_for_stock")) \
				and cint(self.update_stock):
			gl_entries += super(SalesInvoice, self).get_gl_entries()

	def make_pos_gl_entries(self, gl_entries):
		if cint(self.is_pos) and self.cash_bank_account and self.paid_amount:
			# POS, make payment entries
			gl_entries.append(
				self.get_gl_dict({
					"account": self.debit_to,
					"against": self.cash_bank_account,
					"credit": self.paid_amount,
					"remarks": self.remarks,
					"against_voucher": self.name,
					"against_voucher_type": self.doctype,
				})
			)
			gl_entries.append(
				self.get_gl_dict({
					"account": self.cash_bank_account,
					"against": self.debit_to,
					"debit": self.paid_amount,
					"remarks": self.remarks,
				})
			)
			# write off entries, applicable if only pos
			if self.write_off_account and self.write_off_amount:
				gl_entries.append(
					self.get_gl_dict({
						"account": self.debit_to,
						"against": self.write_off_account,
						"credit": self.write_off_amount,
						"remarks": self.remarks,
						"against_voucher": self.name,
						"against_voucher_type": self.doctype,
					})
				)
				gl_entries.append(
					self.get_gl_dict({
						"account": self.write_off_account,
						"against": self.debit_to,
						"debit": self.write_off_amount,
						"remarks": self.remarks,
						"cost_center": self.write_off_cost_center
					})
				)

	def update_c_form(self):
		"""Update amended id in C-form"""
		if self.c_form_no and self.amended_from:
			frappe.db.sql("""update `tabC-Form Invoice Detail` set invoice_no = %s,
				invoice_date = %s, territory = %s, net_total = %s,
				grand_total = %s where invoice_no = %s and parent = %s""",
				(self.name, self.amended_from, self.c_form_no))

	def validate_recurring_invoice(self):
		if self.convert_into_recurring_invoice:
			self.validate_notification_email_id()

			if not self.recurring_type:
				msgprint(_("Please select {0}").format(self.meta.get_label("recurring_type")),
				raise_exception=1)

			elif not (self.invoice_period_from_date and \
					self.invoice_period_to_date):
				throw(_("Invoice Period From and Invoice Period To dates mandatory for recurring invoice"))

	def convert_to_recurring(self):
		if self.convert_into_recurring_invoice:
			if not self.recurring_id:
				frappe.db.set(self, "recurring_id",
					make_autoname("RECINV/.#####"))

			self.set_next_date()

		elif self.recurring_id:
			frappe.db.sql("""update `tabSales Invoice`
				set convert_into_recurring_invoice = 0
				where recurring_id = %s""", (self.recurring_id,))

	def validate_notification_email_id(self):
		if self.notification_email_address:
			email_list = filter(None, [cstr(email).strip() for email in
				self.notification_email_address.replace("\n", "").split(",")])

			from frappe.utils import validate_email_add
			for email in email_list:
				if not validate_email_add(email):
					throw(_("{0} is an invalid email address in 'Notification Email Address'").format(email))

		else:
			throw(_("'Notification Email Addresses' not specified for recurring invoice"))

	def set_next_date(self):
		""" Set next date on which auto invoice will be created"""
		if not self.repeat_on_day_of_month:
			msgprint(_("Please enter 'Repeat on Day of Month' field value"), raise_exception=1)

		next_date = get_next_date(self.posting_date,
			month_map[self.recurring_type], cint(self.repeat_on_day_of_month))

		frappe.db.set(self, 'next_date', next_date)

def get_next_date(dt, mcount, day=None):
	dt = getdate(dt)

	from dateutil.relativedelta import relativedelta
	dt += relativedelta(months=mcount, day=day)

	return dt

def manage_recurring_invoices(next_date=None, commit=True):
	"""
		Create recurring invoices on specific date by copying the original one
		and notify the concerned people
	"""
	next_date = next_date or nowdate()
	recurring_invoices = frappe.db.sql("""select name, recurring_id
		from `tabSales Invoice` where ifnull(convert_into_recurring_invoice, 0)=1
		and docstatus=1 and next_date=%s
		and next_date <= ifnull(end_date, '2199-12-31')""", next_date)

	exception_list = []
	for ref_invoice, recurring_id in recurring_invoices:
		if not frappe.db.sql("""select name from `tabSales Invoice`
				where posting_date=%s and recurring_id=%s and docstatus=1""",
				(next_date, recurring_id)):
			try:
				ref_wrapper = frappe.get_doc('Sales Invoice', ref_invoice)
				new_invoice_wrapper = make_new_invoice(ref_wrapper, next_date)
				send_notification(new_invoice_wrapper)
				if commit:
					frappe.db.commit()
			except:
				if commit:
					frappe.db.rollback()

					frappe.db.begin()
					frappe.db.sql("update `tabSales Invoice` set \
						convert_into_recurring_invoice = 0 where name = %s", ref_invoice)
					notify_errors(ref_invoice, ref_wrapper.customer, ref_wrapper.owner)
					frappe.db.commit()

				exception_list.append(frappe.get_traceback())
			finally:
				if commit:
					frappe.db.begin()

	if exception_list:
		exception_message = "\n\n".join([cstr(d) for d in exception_list])
		raise Exception, exception_message

def make_new_invoice(ref_wrapper, posting_date):
	from erpnext.accounts.utils import get_fiscal_year
	new_invoice = frappe.copy_doc(ref_wrapper)

	mcount = month_map[ref_wrapper.recurring_type]

	invoice_period_from_date = get_next_date(ref_wrapper.invoice_period_from_date, mcount)

	# get last day of the month to maintain period if the from date is first day of its own month
	# and to date is the last day of its own month
	if (cstr(get_first_day(ref_wrapper.invoice_period_from_date)) == \
			cstr(ref_wrapper.invoice_period_from_date)) and \
		(cstr(get_last_day(ref_wrapper.invoice_period_to_date)) == \
			cstr(ref_wrapper.invoice_period_to_date)):
		invoice_period_to_date = get_last_day(get_next_date(ref_wrapper.invoice_period_to_date,
			mcount))
	else:
		invoice_period_to_date = get_next_date(ref_wrapper.invoice_period_to_date, mcount)

	new_invoice.update({
		"posting_date": posting_date,
		"aging_date": posting_date,
		"due_date": add_days(posting_date, cint(date_diff(ref_wrapper.due_date,
			ref_wrapper.posting_date))),
		"invoice_period_from_date": invoice_period_from_date,
		"invoice_period_to_date": invoice_period_to_date,
		"fiscal_year": get_fiscal_year(posting_date)[0],
		"owner": ref_wrapper.owner,
	})

	new_invoice.submit()

	return new_invoice

def send_notification(new_rv):
	"""Notify concerned persons about recurring invoice generation"""

	from frappe.core.doctype.print_format.print_format import get_html
	frappe.sendmail(new_rv.notification_email_address,
		subject="New Invoice : " + new_rv.name,
		message = get_html(new_rv, new_rv, "SalesInvoice"))

def notify_errors(inv, customer, owner):
	from frappe.utils.user import get_system_managers
	recipients=get_system_managers()

	frappe.sendmail(recipients + [frappe.db.get_value("User", owner, "email")],
		subject="[Urgent] Error while creating recurring invoice for %s" % inv,
		message = frappe.get_template("template/emails/recurring_invoice_failed.html").render({
			"name": inv,
			"customer": customer
		}))

	assign_task_to_owner(inv, "Recurring Invoice Failed", recipients)

def assign_task_to_owner(inv, msg, users):
	for d in users:
		from frappe.widgets.form import assign_to
		args = {
			'assign_to' 	:	d,
			'doctype'		:	'Sales Invoice',
			'name'			:	inv,
			'description'	:	msg,
			'priority'		:	'Urgent'
		}
		assign_to.add(args)

@frappe.whitelist()
def get_bank_cash_account(mode_of_payment):
	val = frappe.db.get_value("Mode of Payment", mode_of_payment, "default_account")
	if not val:
		frappe.msgprint(_("Please set default Cash or Bank account in Mode of Payment {0}").format(mode_of_payment))
	return {
		"cash_bank_account": val
	}

@frappe.whitelist()
def get_income_account(doctype, txt, searchfield, start, page_len, filters):
	from erpnext.controllers.queries import get_match_cond

	# income account can be any Credit account,
	# but can also be a Asset account with account_type='Income Account' in special circumstances.
	# Hence the first condition is an "OR"
	return frappe.db.sql("""select tabAccount.name from `tabAccount`
			where (tabAccount.report_type = "Profit and Loss"
					or tabAccount.account_type = "Income Account")
				and tabAccount.group_or_ledger="Ledger"
				and tabAccount.docstatus!=2
				and ifnull(tabAccount.master_type, "")=""
				and ifnull(tabAccount.master_name, "")=""
				and tabAccount.company = '%(company)s'
				and tabAccount.%(key)s LIKE '%(txt)s'
				%(mcond)s""" % {'company': filters['company'], 'key': searchfield,
			'txt': "%%%s%%" % txt, 'mcond':get_match_cond(doctype)})


@frappe.whitelist()
def make_delivery_note(source_name, target_doc=None):
	def set_missing_values(source, target):
		target.run_method("set_missing_values")
		target.run_method("calculate_taxes_and_totals")

	def update_item(source_doc, target_doc, source_parent):
		target_doc.base_amount = (flt(source_doc.qty) - flt(source_doc.delivered_qty)) * \
			flt(source_doc.base_rate)
		target_doc.amount = (flt(source_doc.qty) - flt(source_doc.delivered_qty)) * \
			flt(source_doc.rate)
		target_doc.qty = flt(source_doc.qty) - flt(source_doc.delivered_qty)

	doclist = get_mapped_doc("Sales Invoice", source_name, 	{
		"Sales Invoice": {
			"doctype": "Delivery Note",
			"validation": {
				"docstatus": ["=", 1]
			}
		},
		"Sales Invoice Item": {
			"doctype": "Delivery Note Item",
			"field_map": {
				"name": "prevdoc_detail_docname",
				"parent": "against_sales_invoice",
				"serial_no": "serial_no"
			},
			"postprocess": update_item
		},
		"Sales Taxes and Charges": {
			"doctype": "Sales Taxes and Charges",
			"add_if_empty": True
		},
		"Sales Team": {
			"doctype": "Sales Team",
			"field_map": {
				"incentives": "incentives"
			},
			"add_if_empty": True
		}
	}, target_doc, set_missing_values)

	return doclist

########NEW FILE########
__FILENAME__ = test_sales_invoice
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

import frappe
import unittest, json, copy
from frappe.utils import flt
from erpnext.accounts.utils import get_stock_and_account_difference
from erpnext.stock.doctype.purchase_receipt.test_purchase_receipt import set_perpetual_inventory
from erpnext.projects.doctype.time_log_batch.test_time_log_batch import *


class TestSalesInvoice(unittest.TestCase):
	def make(self):
		w = frappe.copy_doc(test_records[0])
		w.is_pos = 0
		w.insert()
		w.submit()
		return w

	def test_timestamp_change(self):
		w = frappe.copy_doc(test_records[0])
		w.docstatus = 0
		w.insert()

		w2 = frappe.get_doc(w.doctype, w.name)

		import time
		time.sleep(1)
		w.save()

		import time
		time.sleep(1)
		self.assertRaises(frappe.TimestampMismatchError, w2.save)

	def test_sales_invoice_calculation_base_currency(self):
		si = frappe.copy_doc(test_records[2])
		si.insert()

		expected_values = {
			"keys": ["price_list_rate", "discount_percentage", "rate", "amount",
				"base_price_list_rate", "base_rate", "base_amount"],
			"_Test Item Home Desktop 100": [50, 0, 50, 500, 50, 50, 500],
			"_Test Item Home Desktop 200": [150, 0, 150, 750, 150, 150, 750],
		}

		# check if children are saved
		self.assertEquals(len(si.get("entries")),
			len(expected_values)-1)

		# check if item values are calculated
		for d in si.get("entries"):
			for i, k in enumerate(expected_values["keys"]):
				self.assertEquals(d.get(k), expected_values[d.item_code][i])

		# check net total
		self.assertEquals(si.net_total, 1250)
		self.assertEquals(si.net_total_export, 1250)

		# check tax calculation
		expected_values = {
			"keys": ["tax_amount", "total"],
			"_Test Account Shipping Charges - _TC": [100, 1350],
			"_Test Account Customs Duty - _TC": [125, 1475],
			"_Test Account Excise Duty - _TC": [140, 1615],
			"_Test Account Education Cess - _TC": [2.8, 1617.8],
			"_Test Account S&H Education Cess - _TC": [1.4, 1619.2],
			"_Test Account CST - _TC": [32.38, 1651.58],
			"_Test Account VAT - _TC": [156.25, 1807.83],
			"_Test Account Discount - _TC": [-180.78, 1627.05]
		}

		for d in si.get("other_charges"):
			for i, k in enumerate(expected_values["keys"]):
				self.assertEquals(d.get(k), expected_values[d.account_head][i])

		self.assertEquals(si.grand_total, 1627.05)
		self.assertEquals(si.grand_total_export, 1627.05)

	def test_sales_invoice_calculation_export_currency(self):
		si = frappe.copy_doc(test_records[2])
		si.currency = "USD"
		si.conversion_rate = 50
		si.get("entries")[0].rate = 1
		si.get("entries")[0].price_list_rate = 1
		si.get("entries")[1].rate = 3
		si.get("entries")[1].price_list_rate = 3
		si.insert()

		expected_values = {
			"keys": ["price_list_rate", "discount_percentage", "rate", "amount",
				"base_price_list_rate", "base_rate", "base_amount"],
			"_Test Item Home Desktop 100": [1, 0, 1, 10, 50, 50, 500],
			"_Test Item Home Desktop 200": [3, 0, 3, 15, 150, 150, 750],
		}

		# check if children are saved
		self.assertEquals(len(si.get("entries")),
			len(expected_values)-1)

		# check if item values are calculated
		for d in si.get("entries"):
			for i, k in enumerate(expected_values["keys"]):
				self.assertEquals(d.get(k), expected_values[d.item_code][i])

		# check net total
		self.assertEquals(si.net_total, 1250)
		self.assertEquals(si.net_total_export, 25)

		# check tax calculation
		expected_values = {
			"keys": ["tax_amount", "total"],
			"_Test Account Shipping Charges - _TC": [100, 1350],
			"_Test Account Customs Duty - _TC": [125, 1475],
			"_Test Account Excise Duty - _TC": [140, 1615],
			"_Test Account Education Cess - _TC": [2.8, 1617.8],
			"_Test Account S&H Education Cess - _TC": [1.4, 1619.2],
			"_Test Account CST - _TC": [32.38, 1651.58],
			"_Test Account VAT - _TC": [156.25, 1807.83],
			"_Test Account Discount - _TC": [-180.78, 1627.05]
		}

		for d in si.get("other_charges"):
			for i, k in enumerate(expected_values["keys"]):
				self.assertEquals(d.get(k), expected_values[d.account_head][i])

		self.assertEquals(si.grand_total, 1627.05)
		self.assertEquals(si.grand_total_export, 32.54)

	def test_sales_invoice_discount_amount(self):
		si = frappe.copy_doc(test_records[3])
		si.discount_amount = 104.95
		si.append("other_charges", {
			"doctype": "Sales Taxes and Charges",
			"charge_type": "On Previous Row Amount",
			"account_head": "_Test Account Service Tax - _TC",
			"cost_center": "_Test Cost Center - _TC",
			"description": "Service Tax",
			"rate": 10,
			"row_id": 8,
		})
		si.insert()

		expected_values = {
			"keys": ["price_list_rate", "discount_percentage", "rate", "amount",
				"base_price_list_rate", "base_rate", "base_amount"],
			"_Test Item Home Desktop 100": [62.5, 0, 62.5, 625.0, 50, 50, 465.37],
			"_Test Item Home Desktop 200": [190.66, 0, 190.66, 953.3, 150, 150, 698.08],
		}

		# check if children are saved
		self.assertEquals(len(si.get("entries")),
			len(expected_values)-1)

		# check if item values are calculated
		for d in si.get("entries"):
			for i, k in enumerate(expected_values["keys"]):
				self.assertEquals(d.get(k), expected_values[d.item_code][i])

		# check net total
		self.assertEquals(si.net_total, 1163.45)
		self.assertEquals(si.net_total_export, 1578.3)

		# check tax calculation
		expected_values = {
			"keys": ["tax_amount", "tax_amount_after_discount_amount", "total"],
			"_Test Account Excise Duty - _TC": [140, 130.31, 1293.76],
			"_Test Account Education Cess - _TC": [2.8, 2.61, 1296.37],
			"_Test Account S&H Education Cess - _TC": [1.4, 1.31, 1297.68],
			"_Test Account CST - _TC": [27.88, 25.96, 1323.64],
			"_Test Account VAT - _TC": [156.25, 145.43, 1469.07],
			"_Test Account Customs Duty - _TC": [125, 116.35, 1585.42],
			"_Test Account Shipping Charges - _TC": [100, 100, 1685.42],
			"_Test Account Discount - _TC": [-180.33, -168.54, 1516.88],
			"_Test Account Service Tax - _TC": [-18.03, -16.88, 1500]
		}

		for d in si.get("other_charges"):
			for i, k in enumerate(expected_values["keys"]):
				self.assertEquals(d.get(k), expected_values[d.account_head][i])

		self.assertEquals(si.grand_total, 1500)
		self.assertEquals(si.grand_total_export, 1500)

	def test_discount_amount_gl_entry(self):
		si = frappe.copy_doc(test_records[3])
		si.discount_amount = 104.95
		si.append("other_charges", {
			"doctype": "Sales Taxes and Charges",
			"charge_type": "On Previous Row Amount",
			"account_head": "_Test Account Service Tax - _TC",
			"cost_center": "_Test Cost Center - _TC",
			"description": "Service Tax",
			"rate": 10,
			"row_id": 8
		})
		si.insert()
		si.submit()

		gl_entries = frappe.db.sql("""select account, debit, credit
			from `tabGL Entry` where voucher_type='Sales Invoice' and voucher_no=%s
			order by account asc""", si.name, as_dict=1)

		self.assertTrue(gl_entries)

		expected_values = sorted([
			[si.debit_to, 1500, 0.0],
			[test_records[3]["entries"][0]["income_account"], 0.0, 1163.45],
			[test_records[3]["other_charges"][0]["account_head"], 0.0, 130.31],
			[test_records[3]["other_charges"][1]["account_head"], 0.0, 2.61],
			[test_records[3]["other_charges"][2]["account_head"], 0.0, 1.31],
			[test_records[3]["other_charges"][3]["account_head"], 0.0, 25.96],
			[test_records[3]["other_charges"][4]["account_head"], 0.0, 145.43],
			[test_records[3]["other_charges"][5]["account_head"], 0.0, 116.35],
			[test_records[3]["other_charges"][6]["account_head"], 0.0, 100],
			[test_records[3]["other_charges"][7]["account_head"], 168.54, 0.0],
			["_Test Account Service Tax - _TC", 16.88, 0.0],
		])

		for i, gle in enumerate(gl_entries):
			self.assertEquals(expected_values[i][0], gle.account)
			self.assertEquals(expected_values[i][1], gle.debit)
			self.assertEquals(expected_values[i][2], gle.credit)

		# cancel
		si.cancel()

		gle = frappe.db.sql("""select * from `tabGL Entry`
			where voucher_type='Sales Invoice' and voucher_no=%s""", si.name)

		self.assertFalse(gle)

	def test_inclusive_rate_validations(self):
		si = frappe.copy_doc(test_records[2])
		for i, tax in enumerate(si.get("other_charges")):
			tax.idx = i+1

		si.get("entries")[0].price_list_rate = 62.5
		si.get("entries")[0].price_list_rate = 191
		for i in xrange(6):
			si.get("other_charges")[i].included_in_print_rate = 1

		# tax type "Actual" cannot be inclusive
		self.assertRaises(frappe.ValidationError, si.insert)

		# taxes above included type 'On Previous Row Total' should also be included
		si.get("other_charges")[0].included_in_print_rate = 0
		self.assertRaises(frappe.ValidationError, si.insert)

	def test_sales_invoice_calculation_base_currency_with_tax_inclusive_price(self):
		# prepare
		si = frappe.copy_doc(test_records[3])
		si.insert()

		expected_values = {
			"keys": ["price_list_rate", "discount_percentage", "rate", "amount",
				"base_price_list_rate", "base_rate", "base_amount"],
			"_Test Item Home Desktop 100": [62.5, 0, 62.5, 625.0, 50, 50, 499.98],
			"_Test Item Home Desktop 200": [190.66, 0, 190.66, 953.3, 150, 150, 750],
		}

		# check if children are saved
		self.assertEquals(len(si.get("entries")),
			len(expected_values)-1)

		# check if item values are calculated
		for d in si.get("entries"):
			for i, k in enumerate(expected_values["keys"]):
				self.assertEquals(d.get(k), expected_values[d.item_code][i])

		# check net total
		self.assertEquals(si.net_total, 1249.98)
		self.assertEquals(si.net_total_export, 1578.3)

		# check tax calculation
		expected_values = {
			"keys": ["tax_amount", "total"],
			"_Test Account Excise Duty - _TC": [140, 1389.98],
			"_Test Account Education Cess - _TC": [2.8, 1392.78],
			"_Test Account S&H Education Cess - _TC": [1.4, 1394.18],
			"_Test Account CST - _TC": [27.88, 1422.06],
			"_Test Account VAT - _TC": [156.25, 1578.31],
			"_Test Account Customs Duty - _TC": [125, 1703.31],
			"_Test Account Shipping Charges - _TC": [100, 1803.31],
			"_Test Account Discount - _TC": [-180.33, 1622.98]
		}

		for d in si.get("other_charges"):
			for i, k in enumerate(expected_values["keys"]):
				self.assertEquals(d.get(k), expected_values[d.account_head][i])

		self.assertEquals(si.grand_total, 1622.98)
		self.assertEquals(si.grand_total_export, 1622.98)

	def test_sales_invoice_calculation_export_currency_with_tax_inclusive_price(self):
		# prepare
		si = frappe.copy_doc(test_records[3])
		si.currency = "USD"
		si.conversion_rate = 50
		si.get("entries")[0].price_list_rate = 55.56
		si.get("entries")[0].discount_percentage = 10
		si.get("entries")[1].price_list_rate = 187.5
		si.get("entries")[1].discount_percentage = 20
		si.get("other_charges")[6].rate = 5000

		si.insert()

		expected_values = {
			"keys": ["price_list_rate", "discount_percentage", "rate", "amount",
				"base_price_list_rate", "base_rate", "base_amount"],
			"_Test Item Home Desktop 100": [55.56, 10, 50, 500, 2222.11, 1999.9, 19999.04],
			"_Test Item Home Desktop 200": [187.5, 20, 150, 750, 7375.66, 5900.53, 29502.66],
		}

		# check if children are saved
		self.assertEquals(len(si.get("entries")), len(expected_values)-1)

		# check if item values are calculated
		for d in si.get("entries"):
			for i, k in enumerate(expected_values["keys"]):
				self.assertEquals(d.get(k), expected_values[d.item_code][i])

		# check net total
		self.assertEquals(si.net_total, 49501.7)
		self.assertEquals(si.net_total_export, 1250)

		# check tax calculation
		expected_values = {
			"keys": ["tax_amount", "total"],
			"_Test Account Excise Duty - _TC": [5540.22, 55041.92],
			"_Test Account Education Cess - _TC": [110.81, 55152.73],
			"_Test Account S&H Education Cess - _TC": [55.4, 55208.13],
			"_Test Account CST - _TC": [1104.16, 56312.29],
			"_Test Account VAT - _TC": [6187.71, 62500],
			"_Test Account Customs Duty - _TC": [4950.17, 67450.17],
			"_Test Account Shipping Charges - _TC": [5000, 72450.17],
			"_Test Account Discount - _TC": [-7245.01, 65205.16]
		}

		for d in si.get("other_charges"):
			for i, k in enumerate(expected_values["keys"]):
				self.assertEquals(d.get(k), expected_values[d.account_head][i])

		self.assertEquals(si.grand_total, 65205.16)
		self.assertEquals(si.grand_total_export, 1304.1)

	def test_outstanding(self):
		w = self.make()
		self.assertEquals(w.outstanding_amount, w.grand_total)

	def test_payment(self):
		frappe.db.sql("""delete from `tabGL Entry`""")
		w = self.make()

		from erpnext.accounts.doctype.journal_voucher.test_journal_voucher \
			import test_records as jv_test_records

		jv = frappe.get_doc(frappe.copy_doc(jv_test_records[0]))
		jv.get("entries")[0].against_invoice = w.name
		jv.insert()
		jv.submit()

		self.assertEquals(frappe.db.get_value("Sales Invoice", w.name, "outstanding_amount"),
			161.8)

		jv.cancel()
		self.assertEquals(frappe.db.get_value("Sales Invoice", w.name, "outstanding_amount"),
			561.8)

	def test_time_log_batch(self):
		delete_time_log_and_batch()
		time_log = create_time_log()
		tlb = create_time_log_batch(time_log)

		tlb = frappe.get_doc("Time Log Batch", tlb.name)
		tlb.submit()

		si = frappe.get_doc(frappe.copy_doc(test_records[0]))
		si.get("entries")[0].time_log_batch = tlb.name
		si.insert()
		si.submit()

		self.assertEquals(frappe.db.get_value("Time Log Batch", tlb.name, "status"), "Billed")

		self.assertEquals(frappe.db.get_value("Time Log", time_log, "status"), "Billed")

		si.cancel()

		self.assertEquals(frappe.db.get_value("Time Log Batch", tlb.name, "status"), "Submitted")

		self.assertEquals(frappe.db.get_value("Time Log", time_log, "status"), "Batched for Billing")

		frappe.delete_doc("Sales Invoice", si.name)
		delete_time_log_and_batch()

	def test_sales_invoice_gl_entry_without_aii(self):
		self.clear_stock_account_balance()
		set_perpetual_inventory(0)
		si = frappe.copy_doc(test_records[1])
		si.insert()
		si.submit()

		gl_entries = frappe.db.sql("""select account, debit, credit
			from `tabGL Entry` where voucher_type='Sales Invoice' and voucher_no=%s
			order by account asc""", si.name, as_dict=1)

		self.assertTrue(gl_entries)

		expected_values = sorted([
			[si.debit_to, 630.0, 0.0],
			[test_records[1]["entries"][0]["income_account"], 0.0, 500.0],
			[test_records[1]["other_charges"][0]["account_head"], 0.0, 80.0],
			[test_records[1]["other_charges"][1]["account_head"], 0.0, 50.0],
		])

		for i, gle in enumerate(gl_entries):
			self.assertEquals(expected_values[i][0], gle.account)
			self.assertEquals(expected_values[i][1], gle.debit)
			self.assertEquals(expected_values[i][2], gle.credit)

		# cancel
		si.cancel()

		gle = frappe.db.sql("""select * from `tabGL Entry`
			where voucher_type='Sales Invoice' and voucher_no=%s""", si.name)

		self.assertFalse(gle)

	def test_pos_gl_entry_with_aii(self):
		self.clear_stock_account_balance()
		set_perpetual_inventory()
		self.make_pos_setting()

		self._insert_purchase_receipt()

		pos = copy.deepcopy(test_records[1])
		pos["is_pos"] = 1
		pos["update_stock"] = 1
		pos["posting_time"] = "12:05"
		pos["cash_bank_account"] = "_Test Account Bank Account - _TC"
		pos["paid_amount"] = 600.0

		si = frappe.copy_doc(pos)
		si.insert()
		si.submit()

		# check stock ledger entries
		sle = frappe.db.sql("""select * from `tabStock Ledger Entry`
			where voucher_type = 'Sales Invoice' and voucher_no = %s""",
			si.name, as_dict=1)[0]
		self.assertTrue(sle)
		self.assertEquals([sle.item_code, sle.warehouse, sle.actual_qty],
			["_Test Item", "_Test Warehouse - _TC", -1.0])

		# check gl entries
		gl_entries = frappe.db.sql("""select account, debit, credit
			from `tabGL Entry` where voucher_type='Sales Invoice' and voucher_no=%s
			order by account asc, debit asc""", si.name, as_dict=1)
		self.assertTrue(gl_entries)

		stock_in_hand = frappe.db.get_value("Account", {"master_name": "_Test Warehouse - _TC"})

		expected_gl_entries = sorted([
			[si.debit_to, 630.0, 0.0],
			[pos["entries"][0]["income_account"], 0.0, 500.0],
			[pos["other_charges"][0]["account_head"], 0.0, 80.0],
			[pos["other_charges"][1]["account_head"], 0.0, 50.0],
			[stock_in_hand, 0.0, 75.0],
			[pos["entries"][0]["expense_account"], 75.0, 0.0],
			[si.debit_to, 0.0, 600.0],
			["_Test Account Bank Account - _TC", 600.0, 0.0]
		])
		for i, gle in enumerate(gl_entries):
			self.assertEquals(expected_gl_entries[i][0], gle.account)
			self.assertEquals(expected_gl_entries[i][1], gle.debit)
			self.assertEquals(expected_gl_entries[i][2], gle.credit)

		si.cancel()
		gle = frappe.db.sql("""select * from `tabGL Entry`
			where voucher_type='Sales Invoice' and voucher_no=%s""", si.name)

		self.assertFalse(gle)

		self.assertFalse(get_stock_and_account_difference([stock_in_hand]))

		set_perpetual_inventory(0)

		frappe.db.sql("delete from `tabPOS Setting`")

	def make_pos_setting(self):
		pos_setting = frappe.get_doc({
			"cash_bank_account": "_Test Account Bank Account - _TC",
			"company": "_Test Company",
			"cost_center": "_Test Cost Center - _TC",
			"currency": "INR",
			"doctype": "POS Setting",
			"expense_account": "_Test Account Cost for Goods Sold - _TC",
			"income_account": "Sales - _TC",
			"name": "_Test POS Setting",
			"naming_series": "_T-POS Setting-",
			"selling_price_list": "_Test Price List",
			"territory": "_Test Territory",
			"warehouse": "_Test Warehouse - _TC"
		})

		pos_setting.insert()

	def test_si_gl_entry_with_aii_and_update_stock_with_warehouse_but_no_account(self):
		self.clear_stock_account_balance()
		set_perpetual_inventory()
		frappe.delete_doc("Account", "_Test Warehouse No Account - _TC")

		# insert purchase receipt
		from erpnext.stock.doctype.purchase_receipt.test_purchase_receipt import test_records \
			as pr_test_records
		pr = frappe.copy_doc(pr_test_records[0])
		pr.naming_series = "_T-Purchase Receipt-"
		pr.get("purchase_receipt_details")[0].warehouse = "_Test Warehouse No Account - _TC"
		pr.insert()
		pr.submit()

		si_doc = copy.deepcopy(test_records[1])
		si_doc["update_stock"] = 1
		si_doc["posting_time"] = "12:05"
		si_doc.get("entries")[0]["warehouse"] = "_Test Warehouse No Account - _TC"

		si = frappe.copy_doc(si_doc)
		si.insert()
		si.submit()

		# check stock ledger entries
		sle = frappe.db.sql("""select * from `tabStock Ledger Entry`
			where voucher_type = 'Sales Invoice' and voucher_no = %s""",
			si.name, as_dict=1)[0]
		self.assertTrue(sle)
		self.assertEquals([sle.item_code, sle.warehouse, sle.actual_qty],
			["_Test Item", "_Test Warehouse No Account - _TC", -1.0])

		# check gl entries
		gl_entries = frappe.db.sql("""select account, debit, credit
			from `tabGL Entry` where voucher_type='Sales Invoice' and voucher_no=%s
			order by account asc, debit asc""", si.name, as_dict=1)
		self.assertTrue(gl_entries)

		expected_gl_entries = sorted([
			[si.debit_to, 630.0, 0.0],
			[si_doc.get("entries")[0]["income_account"], 0.0, 500.0],
			[si_doc.get("other_charges")[0]["account_head"], 0.0, 80.0],
			[si_doc.get("other_charges")[1]["account_head"], 0.0, 50.0],
		])
		for i, gle in enumerate(gl_entries):
			self.assertEquals(expected_gl_entries[i][0], gle.account)
			self.assertEquals(expected_gl_entries[i][1], gle.debit)
			self.assertEquals(expected_gl_entries[i][2], gle.credit)

		si.cancel()
		gle = frappe.db.sql("""select * from `tabGL Entry`
			where voucher_type='Sales Invoice' and voucher_no=%s""", si.name)

		self.assertFalse(gle)
		set_perpetual_inventory(0)

	def test_sales_invoice_gl_entry_with_aii_no_item_code(self):
		self.clear_stock_account_balance()
		set_perpetual_inventory()

		si = frappe.get_doc(test_records[1])
		si.get("entries")[0].item_code = None
		si.insert()
		si.submit()

		gl_entries = frappe.db.sql("""select account, debit, credit
			from `tabGL Entry` where voucher_type='Sales Invoice' and voucher_no=%s
			order by account asc""", si.name, as_dict=1)
		self.assertTrue(gl_entries)

		expected_values = sorted([
			[si.debit_to, 630.0, 0.0],
			[test_records[1]["entries"][0]["income_account"], 0.0, 500.0],
			[test_records[1]["other_charges"][0]["account_head"], 0.0, 80.0],
			[test_records[1]["other_charges"][1]["account_head"], 0.0, 50.0],
		])
		for i, gle in enumerate(gl_entries):
			self.assertEquals(expected_values[i][0], gle.account)
			self.assertEquals(expected_values[i][1], gle.debit)
			self.assertEquals(expected_values[i][2], gle.credit)

		set_perpetual_inventory(0)

	def test_sales_invoice_gl_entry_with_aii_non_stock_item(self):
		self.clear_stock_account_balance()
		set_perpetual_inventory()
		si = frappe.get_doc(test_records[1])
		si.get("entries")[0].item_code = "_Test Non Stock Item"
		si.insert()
		si.submit()

		gl_entries = frappe.db.sql("""select account, debit, credit
			from `tabGL Entry` where voucher_type='Sales Invoice' and voucher_no=%s
			order by account asc""", si.name, as_dict=1)
		self.assertTrue(gl_entries)

		expected_values = sorted([
			[si.debit_to, 630.0, 0.0],
			[test_records[1]["entries"][0]["income_account"], 0.0, 500.0],
			[test_records[1]["other_charges"][0]["account_head"], 0.0, 80.0],
			[test_records[1]["other_charges"][1]["account_head"], 0.0, 50.0],
		])
		for i, gle in enumerate(gl_entries):
			self.assertEquals(expected_values[i][0], gle.account)
			self.assertEquals(expected_values[i][1], gle.debit)
			self.assertEquals(expected_values[i][2], gle.credit)

		set_perpetual_inventory(0)

	def _insert_purchase_receipt(self):
		from erpnext.stock.doctype.purchase_receipt.test_purchase_receipt import test_records \
			as pr_test_records
		pr = frappe.copy_doc(pr_test_records[0])
		pr.naming_series = "_T-Purchase Receipt-"
		pr.insert()
		pr.submit()

	def _insert_delivery_note(self):
		from erpnext.stock.doctype.delivery_note.test_delivery_note import test_records \
			as dn_test_records
		dn = frappe.copy_doc(dn_test_records[0])
		dn.naming_series = "_T-Delivery Note-"
		dn.insert()
		dn.submit()
		return dn

	def test_sales_invoice_with_advance(self):
		from erpnext.accounts.doctype.journal_voucher.test_journal_voucher \
			import test_records as jv_test_records

		jv = frappe.copy_doc(jv_test_records[0])
		jv.insert()
		jv.submit()

		si = frappe.copy_doc(test_records[0])
		si.append("advance_adjustment_details", {
			"doctype": "Sales Invoice Advance",
			"journal_voucher": jv.name,
			"jv_detail_no": jv.get("entries")[0].name,
			"advance_amount": 400,
			"allocated_amount": 300,
			"remarks": jv.remark
		})
		si.insert()
		si.submit()
		si.load_from_db()

		self.assertTrue(frappe.db.sql("""select name from `tabJournal Voucher Detail`
			where against_invoice=%s""", si.name))

		self.assertTrue(frappe.db.sql("""select name from `tabJournal Voucher Detail`
			where against_invoice=%s and credit=300""", si.name))

		self.assertEqual(si.outstanding_amount, 261.8)

		si.cancel()

		self.assertTrue(not frappe.db.sql("""select name from `tabJournal Voucher Detail`
			where against_invoice=%s""", si.name))

	def test_recurring_invoice(self):
		from frappe.utils import get_first_day, get_last_day, add_to_date, nowdate, getdate
		from erpnext.accounts.utils import get_fiscal_year
		today = nowdate()
		base_si = frappe.copy_doc(test_records[0])
		base_si.update({
			"convert_into_recurring_invoice": 1,
			"recurring_type": "Monthly",
			"notification_email_address": "test@example.com, test1@example.com, test2@example.com",
			"repeat_on_day_of_month": getdate(today).day,
			"posting_date": today,
			"fiscal_year": get_fiscal_year(today)[0],
			"invoice_period_from_date": get_first_day(today),
			"invoice_period_to_date": get_last_day(today)
		})

		# monthly
		si1 = frappe.copy_doc(base_si)
		si1.insert()
		si1.submit()
		self._test_recurring_invoice(si1, True)

		# monthly without a first and last day period
		si2 = frappe.copy_doc(base_si)
		si2.update({
			"invoice_period_from_date": today,
			"invoice_period_to_date": add_to_date(today, days=30)
		})
		si2.insert()
		si2.submit()
		self._test_recurring_invoice(si2, False)

		# quarterly
		si3 = frappe.copy_doc(base_si)
		si3.update({
			"recurring_type": "Quarterly",
			"invoice_period_from_date": get_first_day(today),
			"invoice_period_to_date": get_last_day(add_to_date(today, months=3))
		})
		si3.insert()
		si3.submit()
		self._test_recurring_invoice(si3, True)

		# quarterly without a first and last day period
		si4 = frappe.copy_doc(base_si)
		si4.update({
			"recurring_type": "Quarterly",
			"invoice_period_from_date": today,
			"invoice_period_to_date": add_to_date(today, months=3)
		})
		si4.insert()
		si4.submit()
		self._test_recurring_invoice(si4, False)

		# yearly
		si5 = frappe.copy_doc(base_si)
		si5.update({
			"recurring_type": "Yearly",
			"invoice_period_from_date": get_first_day(today),
			"invoice_period_to_date": get_last_day(add_to_date(today, years=1))
		})
		si5.insert()
		si5.submit()
		self._test_recurring_invoice(si5, True)

		# yearly without a first and last day period
		si6 = frappe.copy_doc(base_si)
		si6.update({
			"recurring_type": "Yearly",
			"invoice_period_from_date": today,
			"invoice_period_to_date": add_to_date(today, years=1)
		})
		si6.insert()
		si6.submit()
		self._test_recurring_invoice(si6, False)

		# change posting date but keep recuring day to be today
		si7 = frappe.copy_doc(base_si)
		si7.update({
			"posting_date": add_to_date(today, days=-1)
		})
		si7.insert()
		si7.submit()

		# setting so that _test function works
		si7.posting_date = today
		self._test_recurring_invoice(si7, True)

	def _test_recurring_invoice(self, base_si, first_and_last_day):
		from frappe.utils import add_months, get_last_day
		from erpnext.accounts.doctype.sales_invoice.sales_invoice \
			import manage_recurring_invoices, get_next_date

		no_of_months = ({"Monthly": 1, "Quarterly": 3, "Yearly": 12})[base_si.recurring_type]

		def _test(i):
			self.assertEquals(i+1, frappe.db.sql("""select count(*) from `tabSales Invoice`
				where recurring_id=%s and docstatus=1""", base_si.recurring_id)[0][0])

			next_date = get_next_date(base_si.posting_date, no_of_months,
				base_si.repeat_on_day_of_month)

			manage_recurring_invoices(next_date=next_date, commit=False)

			recurred_invoices = frappe.db.sql("""select name from `tabSales Invoice`
				where recurring_id=%s and docstatus=1 order by name desc""",
				base_si.recurring_id)

			self.assertEquals(i+2, len(recurred_invoices))

			new_si = frappe.get_doc("Sales Invoice", recurred_invoices[0][0])

			for fieldname in ["convert_into_recurring_invoice", "recurring_type",
				"repeat_on_day_of_month", "notification_email_address"]:
					self.assertEquals(base_si.get(fieldname),
						new_si.get(fieldname))

			self.assertEquals(new_si.posting_date, unicode(next_date))

			self.assertEquals(new_si.invoice_period_from_date,
				unicode(add_months(base_si.invoice_period_from_date, no_of_months)))

			if first_and_last_day:
				self.assertEquals(new_si.invoice_period_to_date,
					unicode(get_last_day(add_months(base_si.invoice_period_to_date,
						no_of_months))))
			else:
				self.assertEquals(new_si.invoice_period_to_date,
					unicode(add_months(base_si.invoice_period_to_date, no_of_months)))


			return new_si

		# if yearly, test 1 repetition, else test 5 repetitions
		count = 1 if (no_of_months == 12) else 5
		for i in xrange(count):
			base_si = _test(i)

	def clear_stock_account_balance(self):
		frappe.db.sql("delete from `tabStock Ledger Entry`")
		frappe.db.sql("delete from tabBin")
		frappe.db.sql("delete from `tabGL Entry`")

	def test_serialized(self):
		from erpnext.stock.doctype.stock_entry.test_stock_entry import make_serialized_item
		from erpnext.stock.doctype.serial_no.serial_no import get_serial_nos

		se = make_serialized_item()
		serial_nos = get_serial_nos(se.get("mtn_details")[0].serial_no)

		si = frappe.copy_doc(test_records[0])
		si.update_stock = 1
		si.get("entries")[0].item_code = "_Test Serialized Item With Series"
		si.get("entries")[0].qty = 1
		si.get("entries")[0].serial_no = serial_nos[0]
		si.insert()
		si.submit()

		self.assertEquals(frappe.db.get_value("Serial No", serial_nos[0], "status"), "Delivered")
		self.assertFalse(frappe.db.get_value("Serial No", serial_nos[0], "warehouse"))
		self.assertEquals(frappe.db.get_value("Serial No", serial_nos[0],
			"delivery_document_no"), si.name)

		return si

	def test_serialized_cancel(self):
		from erpnext.stock.doctype.serial_no.serial_no import get_serial_nos
		si = self.test_serialized()
		si.cancel()

		serial_nos = get_serial_nos(si.get("entries")[0].serial_no)

		self.assertEquals(frappe.db.get_value("Serial No", serial_nos[0], "status"), "Available")
		self.assertEquals(frappe.db.get_value("Serial No", serial_nos[0], "warehouse"), "_Test Warehouse - _TC")
		self.assertFalse(frappe.db.get_value("Serial No", serial_nos[0],
			"delivery_document_no"))

	def test_serialize_status(self):
		from erpnext.stock.doctype.serial_no.serial_no import SerialNoStatusError, get_serial_nos
		from erpnext.stock.doctype.stock_entry.test_stock_entry import make_serialized_item

		se = make_serialized_item()
		serial_nos = get_serial_nos(se.get("mtn_details")[0].serial_no)

		sr = frappe.get_doc("Serial No", serial_nos[0])
		sr.status = "Not Available"
		sr.save()

		si = frappe.copy_doc(test_records[0])
		si.update_stock = 1
		si.get("entries")[0].item_code = "_Test Serialized Item With Series"
		si.get("entries")[0].qty = 1
		si.get("entries")[0].serial_no = serial_nos[0]
		si.insert()

		self.assertRaises(SerialNoStatusError, si.submit)

test_dependencies = ["Journal Voucher", "Contact", "Address"]
test_records = frappe.get_test_records('Sales Invoice')

########NEW FILE########
__FILENAME__ = sales_invoice_advance
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SalesInvoiceAdvance(Document):
	pass
########NEW FILE########
__FILENAME__ = sales_invoice_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SalesInvoiceItem(Document):
	pass
########NEW FILE########
__FILENAME__ = sales_taxes_and_charges
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SalesTaxesandCharges(Document):
	pass
########NEW FILE########
__FILENAME__ = sales_taxes_and_charges_master
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cint
from frappe.model.document import Document

class SalesTaxesandChargesMaster(Document):
	def validate(self):
		if self.is_default == 1:
			frappe.db.sql("""update `tabSales Taxes and Charges Master` set is_default = 0
				where ifnull(is_default,0) = 1 and name != %s and company = %s""",
				(self.name, self.company))

		# at least one territory
		self.validate_table_has_rows("valid_for_territories")

########NEW FILE########
__FILENAME__ = test_sales_taxes_and_charges_master
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Sales Taxes And Charges Master')
########NEW FILE########
__FILENAME__ = shipping_rule
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe import _, msgprint, throw
from frappe.utils import flt, fmt_money
from frappe.model.document import Document
from erpnext.setup.utils import get_company_currency

class OverlappingConditionError(frappe.ValidationError): pass
class FromGreaterThanToError(frappe.ValidationError): pass
class ManyBlankToValuesError(frappe.ValidationError): pass

class ShippingRule(Document):
	def validate(self):
		self.validate_value("calculate_based_on", "in", ["Net Total", "Net Weight"])
		self.shipping_rule_conditions = self.get("shipping_rule_conditions")
		self.validate_from_to_values()
		self.sort_shipping_rule_conditions()
		self.validate_overlapping_shipping_rule_conditions()

	def validate_from_to_values(self):
		zero_to_values = []

		for d in self.get("shipping_rule_conditions"):
			self.round_floats_in(d)

			# values cannot be negative
			self.validate_value("from_value", ">=", 0.0, d)
			self.validate_value("to_value", ">=", 0.0, d)

			if not d.to_value:
				zero_to_values.append(d)
			elif d.from_value >= d.to_value:
				throw(_("From value must be less than to value in row {0}").format(d.idx), FromGreaterThanToError)

		# check if more than two or more rows has To Value = 0
		if len(zero_to_values) >= 2:
			throw(_('There can only be one Shipping Rule Condition with 0 or blank value for "To Value"'),
				ManyBlankToValuesError)

	def sort_shipping_rule_conditions(self):
		"""Sort Shipping Rule Conditions based on increasing From Value"""
		self.shipping_rules_conditions = sorted(self.shipping_rule_conditions, key=lambda d: flt(d.from_value))
		for i, d in enumerate(self.shipping_rule_conditions):
			d.idx = i + 1

	def validate_overlapping_shipping_rule_conditions(self):
		def overlap_exists_between((x1, x2), (y1, y2)):
			"""
				(x1, x2) and (y1, y2) are two ranges
				if condition x = 100 to 300
				then condition y can only be like 50 to 99 or 301 to 400
				hence, non-overlapping condition = (x1 <= x2 < y1 <= y2) or (y1 <= y2 < x1 <= x2)
			"""
			separate = (x1 <= x2 <= y1 <= y2) or (y1 <= y2 <= x1 <= x2)
			return (not separate)

		overlaps = []
		for i in xrange(0, len(self.shipping_rule_conditions)):
			for j in xrange(i+1, len(self.shipping_rule_conditions)):
				d1, d2 = self.shipping_rule_conditions[i], self.shipping_rule_conditions[j]
				if d1.as_dict() != d2.as_dict():
					# in our case, to_value can be zero, hence pass the from_value if so
					range_a = (d1.from_value, d1.to_value or d1.from_value)
					range_b = (d2.from_value, d2.to_value or d2.from_value)
					if overlap_exists_between(range_a, range_b):
						overlaps.append([d1, d2])

		if overlaps:
			company_currency = get_company_currency(self.company)
			msgprint(_("Overlapping conditions found between:"))
			messages = []
			for d1, d2 in overlaps:
				messages.append("%s-%s = %s " % (d1.from_value, d1.to_value, fmt_money(d1.shipping_amount, currency=company_currency)) +
					_("and") + " %s-%s = %s" % (d2.from_value, d2.to_value, fmt_money(d2.shipping_amount, currency=company_currency)))

			msgprint("\n".join(messages), raise_exception=OverlappingConditionError)

########NEW FILE########
__FILENAME__ = test_shipping_rule
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

import frappe
import unittest
from erpnext.accounts.doctype.shipping_rule.shipping_rule import FromGreaterThanToError, ManyBlankToValuesError, OverlappingConditionError

test_records = frappe.get_test_records('Shipping Rule')

class TestShippingRule(unittest.TestCase):
	def test_from_greater_than_to(self):
		shipping_rule = frappe.copy_doc(test_records[0])
		shipping_rule.name = test_records[0].get('name')
		shipping_rule.get("shipping_rule_conditions")[0].from_value = 101
		self.assertRaises(FromGreaterThanToError, shipping_rule.insert)
		
	def test_many_zero_to_values(self):
		shipping_rule = frappe.copy_doc(test_records[0])
		shipping_rule.name = test_records[0].get('name')
		shipping_rule.get("shipping_rule_conditions")[0].to_value = 0
		self.assertRaises(ManyBlankToValuesError, shipping_rule.insert)
		
	def test_overlapping_conditions(self):
		for range_a, range_b in [
			((50, 150), (0, 100)),
			((50, 150), (100, 200)),
			((50, 150), (75, 125)),
			((50, 150), (25, 175)),
			((50, 150), (50, 150)),
		]:
			shipping_rule = frappe.copy_doc(test_records[0])
			shipping_rule.name = test_records[0].get('name')
			shipping_rule.get("shipping_rule_conditions")[0].from_value = range_a[0]
			shipping_rule.get("shipping_rule_conditions")[0].to_value = range_a[1]
			shipping_rule.get("shipping_rule_conditions")[1].from_value = range_b[0]
			shipping_rule.get("shipping_rule_conditions")[1].to_value = range_b[1]
			self.assertRaises(OverlappingConditionError, shipping_rule.insert)

########NEW FILE########
__FILENAME__ = shipping_rule_condition
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ShippingRuleCondition(Document):
	pass
########NEW FILE########
__FILENAME__ = general_ledger
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt, cstr
from frappe import _
from erpnext.accounts.utils import validate_expense_against_budget


class StockAccountInvalidTransaction(frappe.ValidationError): pass

def make_gl_entries(gl_map, cancel=False, adv_adj=False, merge_entries=True,
		update_outstanding='Yes'):
	if gl_map:
		if not cancel:
			gl_map = process_gl_map(gl_map, merge_entries)
			save_entries(gl_map, adv_adj, update_outstanding)
		else:
			delete_gl_entries(gl_map, adv_adj=adv_adj, update_outstanding=update_outstanding)

def process_gl_map(gl_map, merge_entries=True):
	if merge_entries:
		gl_map = merge_similar_entries(gl_map)

	for entry in gl_map:
		# toggle debit, credit if negative entry
		if flt(entry.debit) < 0:
			entry.credit = flt(entry.credit) - flt(entry.debit)
			entry.debit = 0.0
		if flt(entry.credit) < 0:
			entry.debit = flt(entry.debit) - flt(entry.credit)
			entry.credit = 0.0

	return gl_map

def merge_similar_entries(gl_map):
	merged_gl_map = []
	for entry in gl_map:
		# if there is already an entry in this account then just add it
		# to that entry
		same_head = check_if_in_list(entry, merged_gl_map)
		if same_head:
			same_head.debit	= flt(same_head.debit) + flt(entry.debit)
			same_head.credit = flt(same_head.credit) + flt(entry.credit)
		else:
			merged_gl_map.append(entry)

	# filter zero debit and credit entries
	merged_gl_map = filter(lambda x: flt(x.debit)!=0 or flt(x.credit)!=0, merged_gl_map)
	return merged_gl_map

def check_if_in_list(gle, gl_map):
	for e in gl_map:
		if e.account == gle.account and \
				cstr(e.get('against_voucher'))==cstr(gle.get('against_voucher')) \
				and cstr(e.get('against_voucher_type')) == \
					cstr(gle.get('against_voucher_type')) \
				and cstr(e.get('cost_center')) == cstr(gle.get('cost_center')):
			return e

def save_entries(gl_map, adv_adj, update_outstanding):
	validate_account_for_auto_accounting_for_stock(gl_map)

	total_debit = total_credit = 0.0
	for entry in gl_map:
		make_entry(entry, adv_adj, update_outstanding)
		# check against budget
		validate_expense_against_budget(entry)


		# update total debit / credit
		total_debit += flt(entry.debit)
		total_credit += flt(entry.credit)

	validate_total_debit_credit(total_debit, total_credit)

def make_entry(args, adv_adj, update_outstanding):
	args.update({"doctype": "GL Entry"})
	gle = frappe.get_doc(args)
	gle.ignore_permissions = 1
	gle.insert()
	gle.run_method("on_update_with_args", adv_adj, update_outstanding)
	gle.submit()

def validate_total_debit_credit(total_debit, total_credit):
	if abs(total_debit - total_credit) > 0.005:
		frappe.throw(_("Debit and Credit not equal for this voucher. Difference is {0}.").format(total_debit - total_credit))

def validate_account_for_auto_accounting_for_stock(gl_map):
	if gl_map[0].voucher_type=="Journal Voucher":
		aii_accounts = [d[0] for d in frappe.db.sql("""select name from tabAccount
			where account_type = 'Warehouse' and ifnull(master_name, '')!=''""")]

		for entry in gl_map:
			if entry.account in aii_accounts:
				frappe.throw(_("Account: {0} can only be updated via \
					Stock Transactions").format(entry.account), StockAccountInvalidTransaction)


def delete_gl_entries(gl_entries=None, voucher_type=None, voucher_no=None,
		adv_adj=False, update_outstanding="Yes"):

	from erpnext.accounts.doctype.gl_entry.gl_entry import validate_balance_type, \
		check_freezing_date, update_outstanding_amt, validate_frozen_account

	if not gl_entries:
		gl_entries = frappe.db.sql("""select * from `tabGL Entry`
			where voucher_type=%s and voucher_no=%s""", (voucher_type, voucher_no), as_dict=True)
	if gl_entries:
		check_freezing_date(gl_entries[0]["posting_date"], adv_adj)

	frappe.db.sql("""delete from `tabGL Entry` where voucher_type=%s and voucher_no=%s""",
		(voucher_type or gl_entries[0]["voucher_type"], voucher_no or gl_entries[0]["voucher_no"]))

	for entry in gl_entries:
		validate_frozen_account(entry["account"], adv_adj)
		validate_balance_type(entry["account"], adv_adj)
		validate_expense_against_budget(entry)

		if entry.get("against_voucher") and update_outstanding == 'Yes':
			update_outstanding_amt(entry["account"], entry.get("against_voucher_type"),
				entry.get("against_voucher"), on_cancel=True)

########NEW FILE########
__FILENAME__ = accounts_browser
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
import frappe.defaults
from frappe.utils import flt
from erpnext.accounts.utils import get_balance_on

@frappe.whitelist()
def get_companies():
	"""get a list of companies based on permission"""
	return [d.name for d in frappe.get_list("Company", fields=["name"], 
		order_by="name")]

@frappe.whitelist()
def get_children():
	args = frappe.local.form_dict
	ctype, company = args['ctype'], args['comp']
	
	# root
	if args['parent'] in ("Accounts", "Cost Centers"):
		acc = frappe.db.sql(""" select 
			name as value, if(group_or_ledger='Group', 1, 0) as expandable
			from `tab%s`
			where ifnull(parent_%s,'') = ''
			and `company` = %s	and docstatus<2 
			order by name""" % (ctype, ctype.lower().replace(' ','_'), '%s'),
				company, as_dict=1)
	else:	
		# other
		acc = frappe.db.sql("""select 
			name as value, if(group_or_ledger='Group', 1, 0) as expandable
	 		from `tab%s` 
			where ifnull(parent_%s,'') = %s
			and docstatus<2 
			order by name""" % (ctype, ctype.lower().replace(' ','_'), '%s'),
				args['parent'], as_dict=1)
				
	if ctype == 'Account':
		currency = frappe.db.sql("select default_currency from `tabCompany` where name = %s", company)[0][0]
		for each in acc:
			bal = get_balance_on(each.get("value"))
			each["currency"] = currency
			each["balance"] = flt(bal)
		
	return acc

########NEW FILE########
__FILENAME__ = party
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals

import frappe
from frappe import _
from frappe.defaults import get_restrictions
from frappe.utils import add_days
from erpnext.utilities.doctype.address.address import get_address_display
from erpnext.utilities.doctype.contact.contact import get_contact_details

@frappe.whitelist()
def get_party_details(party=None, account=None, party_type="Customer", company=None,
	posting_date=None, price_list=None, currency=None):

	return _get_party_details(party, account, party_type, company, posting_date, price_list, currency)

def _get_party_details(party=None, account=None, party_type="Customer", company=None,
	posting_date=None, price_list=None, currency=None, ignore_permissions=False):
	out = frappe._dict(set_account_and_due_date(party, account, party_type, company, posting_date))

	party = out[party_type.lower()]

	if not ignore_permissions and not frappe.has_permission(party_type, "read", party):
		frappe.throw(_("Not permitted"), frappe.PermissionError)

	party = frappe.get_doc(party_type, party)

	set_address_details(out, party, party_type)
	set_contact_details(out, party, party_type)
	set_other_values(out, party, party_type)
	set_price_list(out, party, party_type, price_list)

	if not out.get("currency"):
		out["currency"] = currency

	# sales team
	if party_type=="Customer":
		out["sales_team"] = [{
			"sales_person": d.sales_person,
			"sales_designation": d.sales_designation,
			"allocated_percentage": d.allocated_percentage
		} for d in party.get("sales_team")]

	return out

def set_address_details(out, party, party_type):
	billing_address_field = "customer_address" if party_type == "Lead" \
		else party_type.lower() + "_address"
	out[billing_address_field] = frappe.db.get_value("Address",
		{party_type.lower(): party.name, "is_primary_address":1}, "name")

	# address display
	out.address_display = get_address_display(out[billing_address_field])

	# shipping address
	if party_type in ["Customer", "Lead"]:
		out.shipping_address_name = frappe.db.get_value("Address",
			{party_type.lower(): party.name, "is_shipping_address":1}, "name")
		out.shipping_address = get_address_display(out["shipping_address_name"])

def set_contact_details(out, party, party_type):
	out.contact_person = frappe.db.get_value("Contact",
		{party_type.lower(): party.name, "is_primary_contact":1}, "name")

	if not out.contact_person:
		return

	out.update(get_contact_details(out.contact_person))

def set_other_values(out, party, party_type):
	# copy
	if party_type=="Customer":
		to_copy = ["customer_name", "customer_group", "territory"]
	else:
		to_copy = ["supplier_name", "supplier_type"]
	for f in to_copy:
		out[f] = party.get(f)

	# fields prepended with default in Customer doctype
	for f in ['currency', 'taxes_and_charges'] \
		+ (['sales_partner', 'commission_rate'] if party_type=="Customer" else []):
		if party.get("default_" + f):
			out[f] = party.get("default_" + f)

def set_price_list(out, party, party_type, given_price_list):
	# price list
	price_list = get_restrictions().get("Price List")
	if isinstance(price_list, list):
		price_list = None

	if not price_list:
		price_list = party.default_price_list

	if not price_list and party_type=="Customer":
		price_list =  frappe.db.get_value("Customer Group",
			party.customer_group, "default_price_list")

	if not price_list:
		price_list = given_price_list

	if price_list:
		out.price_list_currency = frappe.db.get_value("Price List", price_list, "currency")

	out["selling_price_list" if party.doctype=="Customer" else "buying_price_list"] = price_list


def set_account_and_due_date(party, account, party_type, company, posting_date):
	if not posting_date:
		# not an invoice
		return {
			party_type.lower(): party
		}

	if party:
		account = get_party_account(company, party, party_type)
	elif account:
		party = frappe.db.get_value('Account', account, 'master_name')

	account_fieldname = "debit_to" if party_type=="Customer" else "credit_to"

	out = {
		party_type.lower(): party,
		account_fieldname : account,
		"due_date": get_due_date(posting_date, party, party_type, account, company)
	}
	return out

def get_party_account(company, party, party_type):
	if not company:
		frappe.throw(_("Please select company first."))

	if party:
		acc_head = frappe.db.get_value("Account", {"master_name":party,
			"master_type": party_type, "company": company})

		if not acc_head:
			create_party_account(party, party_type, company)

		return acc_head

def get_due_date(posting_date, party, party_type, account, company):
	"""Set Due Date = Posting Date + Credit Days"""
	due_date = None
	if posting_date:
		credit_days = 0
		if account:
			credit_days = frappe.db.get_value("Account", account, "credit_days")
		if party and not credit_days:
			credit_days = frappe.db.get_value(party_type, party, "credit_days")
		if company and not credit_days:
			credit_days = frappe.db.get_value("Company", company, "credit_days")

		due_date = add_days(posting_date, credit_days) if credit_days else posting_date

	return due_date

def create_party_account(party, party_type, company):
	if not company:
		frappe.throw(_("Company is required"))

	company_details = frappe.db.get_value("Company", company,
		["abbr", "receivables_group", "payables_group"], as_dict=True)
	if not frappe.db.exists("Account", (party + " - " + company_details.abbr)):
		parent_account = company_details.receivables_group \
			if party_type=="Customer" else company_details.payables_group
		if not parent_account:
			frappe.throw(_("Please enter Account Receivable/Payable group in company master"))

		# create
		account = frappe.get_doc({
			"doctype": "Account",
			'account_name': party,
			'parent_account': parent_account,
			'group_or_ledger':'Ledger',
			'company': company,
			'master_type': party_type,
			'master_name': party,
			"freeze_account": "No",
			"report_type": "Balance Sheet"
		}).insert(ignore_permissions=True)

		frappe.msgprint(_("Account Created: {0}").format(account.name))

########NEW FILE########
__FILENAME__ = accounts_payable
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import getdate, nowdate, flt, cstr
from frappe import msgprint, _
from erpnext.accounts.report.accounts_receivable.accounts_receivable import get_ageing_data

def execute(filters=None):
	if not filters: filters = {}
	supplier_naming_by = frappe.db.get_value("Buying Settings", None, "supp_master_name")
	columns = get_columns(supplier_naming_by)
	entries = get_gl_entries(filters)
	account_map = dict(((r.name, r) for r in frappe.db.sql("""select acc.name, 
		supp.supplier_name, supp.name as supplier 
		from `tabAccount` acc, `tabSupplier` supp 
		where acc.master_type="Supplier" and supp.name=acc.master_name""", as_dict=1)))

	entries_after_report_date = [[gle.voucher_type, gle.voucher_no] 
		for gle in get_gl_entries(filters, before_report_date=False)]

	account_supplier_type_map = get_account_supplier_type_map()
	voucher_detail_map = get_voucher_details()

	# Age of the invoice on this date
	age_on = getdate(filters.get("report_date")) > getdate(nowdate()) \
		and nowdate() or filters.get("report_date")

	data = []
	for gle in entries:
		if cstr(gle.against_voucher) == gle.voucher_no or not gle.against_voucher \
				or [gle.against_voucher_type, gle.against_voucher] in entries_after_report_date:
			voucher_details = voucher_detail_map.get(gle.voucher_type, {}).get(gle.voucher_no, {})
			
			invoiced_amount = gle.credit > 0 and gle.credit or 0
			outstanding_amount = get_outstanding_amount(gle, 
				filters.get("report_date") or nowdate())

			if abs(flt(outstanding_amount)) > 0.01:
				paid_amount = invoiced_amount - outstanding_amount
				row = [gle.posting_date, gle.account, gle.voucher_type, gle.voucher_no, 
					voucher_details.get("due_date", ""), voucher_details.get("bill_no", ""), 
					voucher_details.get("bill_date", ""), invoiced_amount, 
					paid_amount, outstanding_amount]
				
				# Ageing
				if filters.get("ageing_based_on") == "Due Date":
					ageing_based_on_date = voucher_details.get("due_date", "")
				else:
					ageing_based_on_date = gle.posting_date
					
				row += get_ageing_data(age_on, ageing_based_on_date, outstanding_amount) + \
					[account_map.get(gle.account, {}).get("supplier") or ""]

				if supplier_naming_by == "Naming Series":
					row += [account_map.get(gle.account, {}).get("supplier_name") or ""]

				row += [account_supplier_type_map.get(gle.account), gle.remarks]
				data.append(row)

	for i in range(0, len(data)):
		data[i].insert(4, """<a href="%s"><i class="icon icon-share" style="cursor: pointer;"></i></a>""" \
			% ("/".join(["#Form", data[i][2], data[i][3]]),))

	return columns, data
	
def get_columns(supplier_naming_by):
	columns = [
		"Posting Date:Date:80", "Account:Link/Account:150", "Voucher Type::110", 
		"Voucher No::120", "::30", "Due Date:Date:80", "Bill No::80", "Bill Date:Date:80", 
		"Invoiced Amount:Currency:100", "Paid Amount:Currency:100", 
		"Outstanding Amount:Currency:100", "Age:Int:50", "0-30:Currency:100", 
		"30-60:Currency:100", "60-90:Currency:100", "90-Above:Currency:100",
		"Supplier:Link/Supplier:150"
	]

	if supplier_naming_by == "Naming Series":
		columns += ["Supplier Name::110"]

	columns += ["Supplier Type:Link/Supplier Type:120", "Remarks::150"]

	return columns

def get_gl_entries(filters, before_report_date=True):
	conditions, supplier_accounts = get_conditions(filters, before_report_date)
	gl_entries = []
	gl_entries = frappe.db.sql("""select * from `tabGL Entry` 
		where docstatus < 2 %s order by posting_date, account""" % 
		(conditions), tuple(supplier_accounts), as_dict=1)
	return gl_entries
	
def get_conditions(filters, before_report_date=True):
	conditions = ""
	if filters.get("company"):
		conditions += " and company='%s'" % filters["company"].replace("'", "\'")
	
	supplier_accounts = []
	if filters.get("account"):
		supplier_accounts = [filters["account"]]
	else:
		supplier_accounts = frappe.db.sql_list("""select name from `tabAccount` 
			where ifnull(master_type, '') = 'Supplier' and docstatus < 2 %s""" % 
			conditions, filters)
	
	if supplier_accounts:
		conditions += " and account in (%s)" % (", ".join(['%s']*len(supplier_accounts)))
	else:
		msgprint(_("No Supplier Accounts found. Supplier Accounts are identified based on 'Master Type' value in account record."), raise_exception=1)
		
	if filters.get("report_date"):
		if before_report_date:
			conditions += " and posting_date<='%s'" % filters["report_date"]
		else:
			conditions += " and posting_date>'%s'" % filters["report_date"]
		
	return conditions, supplier_accounts
	
def get_account_supplier_type_map():
	account_supplier_type_map = {}
	for each in frappe.db.sql("""select acc.name, supp.supplier_type from `tabSupplier` supp, 
			`tabAccount` acc where supp.name = acc.master_name group by acc.name"""):
		account_supplier_type_map[each[0]] = each[1]

	return account_supplier_type_map
	
def get_voucher_details():
	voucher_details = {}
	for dt in ["Purchase Invoice", "Journal Voucher"]:
		voucher_details.setdefault(dt, frappe._dict())
		for t in frappe.db.sql("""select name, due_date, bill_no, bill_date 
				from `tab%s`""" % dt, as_dict=1):
			voucher_details[dt].setdefault(t.name, t)
		
	return voucher_details

def get_outstanding_amount(gle, report_date):
	payment_amount = frappe.db.sql("""
		select sum(ifnull(debit, 0)) - sum(ifnull(credit, 0)) 
		from `tabGL Entry` 
		where account = %s and posting_date <= %s and against_voucher_type = %s 
		and against_voucher = %s and name != %s""", 
		(gle.account, report_date, gle.voucher_type, gle.voucher_no, gle.name))[0][0]
		
	outstanding_amount = flt(gle.credit) - flt(gle.debit) - flt(payment_amount)
	return outstanding_amount

########NEW FILE########
__FILENAME__ = accounts_receivable
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd.
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.utils import getdate, nowdate, flt

class AccountsReceivableReport(object):
	def __init__(self, filters=None):
		self.filters = frappe._dict(filters or {})
		self.filters.report_date = getdate(self.filters.report_date or nowdate())
		self.age_as_on = getdate(nowdate()) \
			if self.filters.report_date > getdate(nowdate()) \
			else self.filters.report_date
			
	def run(self):
		customer_naming_by = frappe.db.get_value("Selling Settings", None, "cust_master_name")
		return self.get_columns(customer_naming_by), self.get_data(customer_naming_by)
		
	def get_columns(self, customer_naming_by):
		columns = [
			"Posting Date:Date:80", "Account:Link/Account:150",
			"Voucher Type::110", "Voucher No::120", "::30",
			"Due Date:Date:80",  
			"Invoiced Amount:Currency:100", "Payment Received:Currency:100", 
			"Outstanding Amount:Currency:100", "Age:Int:50", "0-30:Currency:100",
			"30-60:Currency:100", "60-90:Currency:100", "90-Above:Currency:100",
			"Customer:Link/Customer:200"
		]

		if customer_naming_by == "Naming Series":
			columns += ["Customer Name::110"]

		columns += ["Territory:Link/Territory:80", "Remarks::200"]

		return columns

	def get_data(self, customer_naming_by):
		from erpnext.accounts.utils import get_currency_precision
		currency_precision = get_currency_precision() or 2

		data = []
		future_vouchers = self.get_entries_after(self.filters.report_date)
		for gle in self.get_entries_till(self.filters.report_date):
			if self.is_receivable(gle, future_vouchers):
				outstanding_amount = self.get_outstanding_amount(gle, self.filters.report_date)
				if abs(outstanding_amount) > 0.1/10**currency_precision:
					due_date = self.get_due_date(gle)
					invoiced_amount = gle.debit if (gle.debit > 0) else 0
					payment_received = invoiced_amount - outstanding_amount
					row = [gle.posting_date, gle.account,
						gle.voucher_type, gle.voucher_no, due_date,
						invoiced_amount, payment_received,
						outstanding_amount]
					entry_date = due_date if self.filters.ageing_based_on == "Due Date" \
						else gle.posting_date
					row += get_ageing_data(self.age_as_on, entry_date, outstanding_amount) + \
						[self.get_customer(gle.account)]

					if customer_naming_by == "Naming Series":
						row += [self.get_customer_name(gle.account)]

					row += [self.get_territory(gle.account), gle.remarks]
					data.append(row)
		
		for i in range(0, len(data)):
			data[i].insert(4, """<a href="%s"><i class="icon icon-share" style="cursor: pointer;"></i></a>""" \
				% ("/".join(["#Form", data[i][2], data[i][3]]),))
		
		return data

	def get_entries_after(self, report_date):
		# returns a distinct list
		return list(set([(e.voucher_type, e.voucher_no) for e in self.get_gl_entries()
			if getdate(e.posting_date) > report_date]))
			
	def get_entries_till(self, report_date):
		# returns a generator
		return (e for e in self.get_gl_entries() 
			if getdate(e.posting_date) <= report_date)
			
	def is_receivable(self, gle, future_vouchers):
		return (
			# advance
			(not gle.against_voucher) or 
			
			# sales invoice
			(gle.against_voucher==gle.voucher_no and gle.debit > 0) or 
			
			# entries adjusted with future vouchers
			((gle.against_voucher_type, gle.against_voucher) in future_vouchers)
		)
			
	def get_outstanding_amount(self, gle, report_date):
		payment_received = 0.0
		for e in self.get_gl_entries_for(gle.account, gle.voucher_type, gle.voucher_no):
			if getdate(e.posting_date) <= report_date and e.name!=gle.name:
				payment_received += (flt(e.credit) - flt(e.debit))

		return flt(gle.debit) - flt(gle.credit) - payment_received
		
	def get_customer(self, account):
		return self.get_account_map().get(account, {}).get("customer") or ""

	def get_customer_name(self, account):
		return self.get_account_map().get(account, {}).get("customer_name") or ""

	def get_territory(self, account):
		return self.get_account_map().get(account, {}).get("territory") or ""
		
	def get_account_map(self):
		if not hasattr(self, "account_map"):
			self.account_map = dict(((r.name, r) for r in frappe.db.sql("""select 
				acc.name, cust.name as customer, cust.customer_name, cust.territory
				from `tabAccount` acc left join `tabCustomer` cust 
				on cust.name=acc.master_name where acc.master_type="Customer" """, as_dict=True)))
				
		return self.account_map
		
	def get_due_date(self, gle):
		if not hasattr(self, "invoice_due_date_map"):
			# TODO can be restricted to posting date
			self.invoice_due_date_map = dict(frappe.db.sql("""select name, due_date
				from `tabSales Invoice` where docstatus=1"""))
				
		return gle.voucher_type == "Sales Invoice" \
			and self.invoice_due_date_map.get(gle.voucher_no) or ""
		
	def get_gl_entries(self):
		if not hasattr(self, "gl_entries"):
			conditions, values = self.prepare_conditions()
			self.gl_entries = frappe.db.sql("""select * from `tabGL Entry`
				where docstatus < 2 {0} order by posting_date, account""".format(conditions),
				values, as_dict=True)
		return self.gl_entries
		
	def prepare_conditions(self):
		conditions = [""]
		values = {}
		
		if self.filters.company:
			conditions.append("company=%(company)s")
			values["company"] = self.filters.company
		
		if self.filters.account:
			conditions.append("account=%(account)s")
			values["account"] = self.filters.account
		else:
			account_map = self.get_account_map()
			if not account_map:
				frappe.throw(_("No Customer Accounts found."))
			else:
				accounts_list = ['"{0}"'.format(ac) for ac in account_map]
				conditions.append("account in ({0})".format(", ".join(accounts_list)))
		
		return " and ".join(conditions), values
		
	def get_gl_entries_for(self, account, against_voucher_type, against_voucher):
		if not hasattr(self, "gl_entries_map"):
			self.gl_entries_map = {}
			for gle in self.get_gl_entries():
				if gle.against_voucher_type and gle.against_voucher:
					self.gl_entries_map.setdefault(gle.account, {})\
						.setdefault(gle.against_voucher_type, {})\
						.setdefault(gle.against_voucher, [])\
						.append(gle)
		
		return self.gl_entries_map.get(account, {})\
			.get(against_voucher_type, {})\
			.get(against_voucher, [])

def execute(filters=None):
	return AccountsReceivableReport(filters).run()

def get_ageing_data(age_as_on, entry_date, outstanding_amount):
	# [0-30, 30-60, 60-90, 90-above]
	outstanding_range = [0.0, 0.0, 0.0, 0.0]
	if not (age_as_on and entry_date):
		return [0] + outstanding_range
		
	age = (getdate(age_as_on) - getdate(entry_date)).days or 0
	index = None
	for i, days in enumerate([30, 60, 90]):
		if age <= days:
			index = i
			break
	
	if index is None: index = 3
	outstanding_range[index] = outstanding_amount
	
	return [age] + outstanding_range

########NEW FILE########
__FILENAME__ = bank_clearance_summary
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _, msgprint

def execute(filters=None):
	if not filters: filters = {}
	
	columns = get_columns()
	data = get_entries(filters)
	
	return columns, data
	
def get_columns():
	return ["Journal Voucher:Link/Journal Voucher:140", "Account:Link/Account:140", 
		"Posting Date:Date:100", "Clearance Date:Date:110", "Against Account:Link/Account:200", 
		"Debit:Currency:120", "Credit:Currency:120"
	]

def get_conditions(filters):
	conditions = ""
	if not filters.get("account"):
		msgprint(_("Please select Bank Account"), raise_exception=1)
	else:
		conditions += " and jvd.account = %(account)s"
		
	if filters.get("from_date"): conditions += " and jv.posting_date>=%(from_date)s"
	if filters.get("to_date"): conditions += " and jv.posting_date<=%(to_date)s"
	
	return conditions
	
def get_entries(filters):
	conditions = get_conditions(filters)
	entries =  frappe.db.sql("""select jv.name, jvd.account, jv.posting_date, 
		jv.clearance_date, jvd.against_account, jvd.debit, jvd.credit
		from `tabJournal Voucher Detail` jvd, `tabJournal Voucher` jv 
		where jvd.parent = jv.name and jv.docstatus=1 %s
		order by jv.name DESC""" % conditions, filters, as_list=1)
	return entries
########NEW FILE########
__FILENAME__ = bank_reconciliation_statement
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt

def execute(filters=None):
	if not filters: filters = {}
		
	columns = get_columns()
	data = get_entries(filters)
	
	from erpnext.accounts.utils import get_balance_on
	balance_as_per_company = get_balance_on(filters["account"], filters["report_date"])

	total_debit, total_credit = 0,0
	for d in data:
		total_debit += flt(d[4])
		total_credit += flt(d[5])

	bank_bal = flt(balance_as_per_company) + flt(total_debit) - flt(total_credit)
		
	data += [
		get_balance_row("Balance as per company books", balance_as_per_company),
		["", "", "", "Amounts not reflected in bank", total_debit, total_credit], 
		get_balance_row("Balance as per bank", bank_bal)
	]
	
	return columns, data
	
def get_columns():
	return ["Journal Voucher:Link/Journal Voucher:140", "Posting Date:Date:100", 
		"Clearance Date:Date:110", "Against Account:Link/Account:200", 
		"Debit:Currency:120", "Credit:Currency:120"
	]
	
def get_entries(filters):
	entries = frappe.db.sql("""select 
			jv.name, jv.posting_date, jv.clearance_date, jvd.against_account, jvd.debit, jvd.credit
		from 
			`tabJournal Voucher Detail` jvd, `tabJournal Voucher` jv 
		where jvd.parent = jv.name and jv.docstatus=1 
			and jvd.account = %(account)s and jv.posting_date <= %(report_date)s 
			and ifnull(jv.clearance_date, '4000-01-01') > %(report_date)s
		order by jv.name DESC""", filters, as_list=1)
		
	return entries
	
def get_balance_row(label, amount):
	if amount > 0:
		return ["", "", "", label, amount, 0]
	else:
		return ["", "", "", label, 0, amount]

########NEW FILE########
__FILENAME__ = budget_variance_report
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _, msgprint
from frappe.utils import flt
import time
from erpnext.accounts.utils import get_fiscal_year
from erpnext.controllers.trends import get_period_date_ranges, get_period_month_ranges

def execute(filters=None):
	if not filters: filters = {}
	
	columns = get_columns(filters)
	period_month_ranges = get_period_month_ranges(filters["period"], filters["fiscal_year"])
	cam_map = get_costcenter_account_month_map(filters)

	data = []
	for cost_center, cost_center_items in cam_map.items():
		for account, monthwise_data in cost_center_items.items():
			row = [cost_center, account]
			totals = [0, 0, 0]
			for relevant_months in period_month_ranges:
				period_data = [0, 0, 0]
				for month in relevant_months:
					month_data = monthwise_data.get(month, {})
					for i, fieldname in enumerate(["target", "actual", "variance"]):
						value = flt(month_data.get(fieldname))
						period_data[i] += value
						totals[i] += value
				period_data[2] = period_data[0] - period_data[1]
				row += period_data
			totals[2] = totals[0] - totals[1]
			row += totals
			data.append(row)

	return columns, sorted(data, key=lambda x: (x[0], x[1]))
	
def get_columns(filters):
	for fieldname in ["fiscal_year", "period", "company"]:
		if not filters.get(fieldname):
			label = (" ".join(fieldname.split("_"))).title()
			msgprint(_("Please specify") + ": " + label,
				raise_exception=True)

	columns = ["Cost Center:Link/Cost Center:120", "Account:Link/Account:120"]

	group_months = False if filters["period"] == "Monthly" else True

	for from_date, to_date in get_period_date_ranges(filters["period"], filters["fiscal_year"]):
		for label in ["Target (%s)", "Actual (%s)", "Variance (%s)"]:
			if group_months:
				label = label % (from_date.strftime("%b") + " - " + to_date.strftime("%b"))
			else:
				label = label % from_date.strftime("%b")
				
			columns.append(label+":Float:120")

	return columns + ["Total Target:Float:120", "Total Actual:Float:120", 
		"Total Variance:Float:120"]

#Get cost center & target details
def get_costcenter_target_details(filters):
	return frappe.db.sql("""select cc.name, cc.distribution_id, 
		cc.parent_cost_center, bd.account, bd.budget_allocated 
		from `tabCost Center` cc, `tabBudget Detail` bd 
		where bd.parent=cc.name and bd.fiscal_year=%s and 
		cc.company=%s order by cc.name""" % ('%s', '%s'), 
		(filters.get("fiscal_year"), filters.get("company")), as_dict=1)

#Get target distribution details of accounts of cost center
def get_target_distribution_details(filters):
	target_details = {}

	for d in frappe.db.sql("""select bd.name, bdd.month, bdd.percentage_allocation  
		from `tabBudget Distribution Detail` bdd, `tabBudget Distribution` bd
		where bdd.parent=bd.name and bd.fiscal_year=%s""", (filters["fiscal_year"]), as_dict=1):
			target_details.setdefault(d.name, {}).setdefault(d.month, flt(d.percentage_allocation))

	return target_details

#Get actual details from gl entry
def get_actual_details(filters):
	ac_details = frappe.db.sql("""select gl.account, gl.debit, gl.credit, 
		gl.cost_center, MONTHNAME(gl.posting_date) as month_name 
		from `tabGL Entry` gl, `tabBudget Detail` bd 
		where gl.fiscal_year=%s and company=%s
		and bd.account=gl.account and bd.parent=gl.cost_center""" % ('%s', '%s'), 
		(filters.get("fiscal_year"), filters.get("company")), as_dict=1)
		
	cc_actual_details = {}
	for d in ac_details:
		cc_actual_details.setdefault(d.cost_center, {}).setdefault(d.account, []).append(d)
		
	return cc_actual_details

def get_costcenter_account_month_map(filters):
	import datetime
	costcenter_target_details = get_costcenter_target_details(filters)
	tdd = get_target_distribution_details(filters)
	actual_details = get_actual_details(filters)

	cam_map = {}

	for ccd in costcenter_target_details:
		for month_id in range(1, 13):
			month = datetime.date(2013, month_id, 1).strftime('%B')
			
			cam_map.setdefault(ccd.name, {}).setdefault(ccd.account, {})\
				.setdefault(month, frappe._dict({
					"target": 0.0, "actual": 0.0
				}))

			tav_dict = cam_map[ccd.name][ccd.account][month]

			month_percentage = tdd.get(ccd.distribution_id, {}).get(month, 0) \
				if ccd.distribution_id else 100.0/12
				
			tav_dict.target = flt(ccd.budget_allocated) * month_percentage / 100
			
			for ad in actual_details.get(ccd.name, {}).get(ccd.account, []):
				if ad.month_name == month:
						tav_dict.actual += flt(ad.debit) - flt(ad.credit)
						
	return cam_map

########NEW FILE########
__FILENAME__ = customer_account_head
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute(filters=None):
	account_map = get_account_map()
	columns = get_columns(account_map)
	data = []
	customers = frappe.db.sql("select name from tabCustomer where docstatus < 2")
	for cust in customers:
		row = [cust[0]]
		for company in sorted(account_map):
			row.append(account_map[company].get(cust[0], ''))
		data.append(row)

	return columns, data

def get_account_map():
	accounts = frappe.db.sql("""select name, company, master_name 
		from `tabAccount` where master_type = 'Customer' 
		and ifnull(master_name, '') != '' and docstatus < 2""", as_dict=1)

	account_map = {}
	for acc in accounts:
		account_map.setdefault(acc.company, {}).setdefault(acc.master_name, {})
		account_map[acc.company][acc.master_name] = acc.name

	return account_map

def get_columns(account_map):
	columns = ["Customer:Link/Customer:120"] + \
		[(company + ":Link/Account:120") for company in sorted(account_map)]

	return columns
########NEW FILE########
__FILENAME__ = general_ledger
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cstr, flt
from frappe import _

def execute(filters=None):
	account_details = {}
	for acc in frappe.db.sql("""select name, group_or_ledger from tabAccount""", as_dict=1):
			account_details.setdefault(acc.name, acc)

	validate_filters(filters, account_details)

	columns = get_columns()

	res = get_result(filters, account_details)

	return columns, res

def validate_filters(filters, account_details):
	if filters.get("account") and filters.get("group_by_account") \
			and account_details[filters.account].group_or_ledger == "Ledger":
		frappe.throw(_("Can not filter based on Account, if grouped by Account"))

	if filters.get("voucher_no") and filters.get("group_by_voucher"):
		frappe.throw(_("Can not filter based on Voucher No, if grouped by Voucher"))

	if filters.from_date > filters.to_date:
		frappe.throw(_("From Date must be before To Date"))

def get_columns():
	return ["Posting Date:Date:100", "Account:Link/Account:200", "Debit:Float:100",
		"Credit:Float:100", "Voucher Type::120", "Voucher No::160", "Link::20",
		"Against Account::120", "Cost Center:Link/Cost Center:100", "Remarks::400"]

def get_result(filters, account_details):
	gl_entries = get_gl_entries(filters)

	data = get_data_with_opening_closing(filters, account_details, gl_entries)

	result = get_result_as_list(data)

	return result

def get_gl_entries(filters):
	group_by_condition = "group by voucher_type, voucher_no, account" \
		if filters.get("group_by_voucher") else "group by name"

	gl_entries = frappe.db.sql("""select posting_date, account,
			sum(ifnull(debit, 0)) as debit, sum(ifnull(credit, 0)) as credit,
			voucher_type, voucher_no, cost_center, remarks, is_opening, against
		from `tabGL Entry`
		where company=%(company)s {conditions}
		{group_by_condition}
		order by posting_date, account"""\
		.format(conditions=get_conditions(filters), group_by_condition=group_by_condition),
		filters, as_dict=1)

	return gl_entries

def get_conditions(filters):
	conditions = []
	if filters.get("account"):
		lft, rgt = frappe.db.get_value("Account", filters["account"], ["lft", "rgt"])
		conditions.append("""account in (select name from tabAccount
			where lft>=%s and rgt<=%s and docstatus<2)""" % (lft, rgt))
	else:
		conditions.append("posting_date between %(from_date)s and %(to_date)s")

	if filters.get("voucher_no"):
		conditions.append("voucher_no=%(voucher_no)s")


	from frappe.widgets.reportview import build_match_conditions
	match_conditions = build_match_conditions("GL Entry")
	if match_conditions: conditions.append(match_conditions)

	return "and {}".format(" and ".join(conditions)) if conditions else ""

def get_data_with_opening_closing(filters, account_details, gl_entries):
	data = []
	gle_map = initialize_gle_map(gl_entries)

	opening, total_debit, total_credit, gle_map = get_accountwise_gle(filters, gl_entries, gle_map)

	# Opening for filtered account
	if filters.get("account"):
		data += [get_balance_row("Opening", opening), {}]

	for acc, acc_dict in gle_map.items():
		if acc_dict.entries:
			# Opening for individual ledger, if grouped by account
			if filters.get("group_by_account"):
				data.append(get_balance_row("Opening", acc_dict.opening))

			data += acc_dict.entries

			# Totals and closing for individual ledger, if grouped by account
			if filters.get("group_by_account"):
				data += [{"account": "Totals", "debit": acc_dict.total_debit,
					"credit": acc_dict.total_credit},
					get_balance_row("Closing (Opening + Totals)",
						(acc_dict.opening + acc_dict.total_debit - acc_dict.total_credit)), {}]

	# Total debit and credit between from and to date
	if total_debit or total_credit:
		data.append({"account": "Totals", "debit": total_debit, "credit": total_credit})

	# Closing for filtered account
	if filters.get("account"):
		data.append(get_balance_row("Closing (Opening + Totals)",
			(opening + total_debit - total_credit)))

	return data

def initialize_gle_map(gl_entries):
	gle_map = frappe._dict()
	for gle in gl_entries:
		gle_map.setdefault(gle.account, frappe._dict({
			"opening": 0,
			"entries": [],
			"total_debit": 0,
			"total_credit": 0,
			"closing": 0
		}))
	return gle_map

def get_accountwise_gle(filters, gl_entries, gle_map):
	opening, total_debit, total_credit = 0, 0, 0

	for gle in gl_entries:
		amount = flt(gle.debit) - flt(gle.credit)
		if filters.get("account") and (gle.posting_date<filters.from_date or cstr(gle.is_opening)=="Yes"):
			gle_map[gle.account].opening += amount
			opening += amount
		elif gle.posting_date <= filters.to_date:
			gle_map[gle.account].entries.append(gle)
			gle_map[gle.account].total_debit += flt(gle.debit)
			gle_map[gle.account].total_credit += flt(gle.credit)

			total_debit += flt(gle.debit)
			total_credit += flt(gle.credit)

	return opening, total_debit, total_credit, gle_map

def get_balance_row(label, balance):
	return {
		"account": label,
		"debit": balance if balance > 0 else 0,
		"credit": -1*balance if balance < 0 else 0,
	}

def get_result_as_list(data):
	result = []
	for d in data:
		result.append([d.get("posting_date"), d.get("account"), d.get("debit"),
			d.get("credit"), d.get("voucher_type"), d.get("voucher_no"),
			get_voucher_link(d.get("voucher_type"), d.get("voucher_no")),
			d.get("against"), d.get("cost_center"), d.get("remarks")])

	return result

def get_voucher_link(voucher_type, voucher_no):
	icon = ""
	if voucher_type and voucher_no:
		icon = """<a href="%s"><i class="icon icon-share" style="cursor: pointer;">
			</i></a>""" % ("/".join(["#Form", voucher_type, voucher_no]))

	return icon

########NEW FILE########
__FILENAME__ = gross_profit
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt
from erpnext.stock.utils import get_buying_amount, get_sales_bom_buying_amount

def execute(filters=None):
	if not filters: filters = {}
	
	stock_ledger_entries = get_stock_ledger_entries(filters)
	source = get_source_data(filters)
	item_sales_bom = get_item_sales_bom()
	
	columns = ["Delivery Note/Sales Invoice::120", "Link::30", "Posting Date:Date", "Posting Time", 
		"Item Code:Link/Item", "Item Name", "Description", "Warehouse:Link/Warehouse",
		"Qty:Float", "Selling Rate:Currency", "Avg. Buying Rate:Currency", 
		"Selling Amount:Currency", "Buying Amount:Currency",
		"Gross Profit:Currency", "Gross Profit %:Percent", "Project:Link/Project"]
	data = []
	for row in source:
		selling_amount = flt(row.base_amount)
		
		item_sales_bom_map = item_sales_bom.get(row.parenttype, {}).get(row.name, frappe._dict())
		
		if item_sales_bom_map.get(row.item_code):
			buying_amount = get_sales_bom_buying_amount(row.item_code, row.warehouse, 
				row.parenttype, row.name, row.item_row, stock_ledger_entries, item_sales_bom_map)
		else:
			buying_amount = get_buying_amount(row.parenttype, row.name, row.item_row,
				stock_ledger_entries.get((row.item_code, row.warehouse), []))
		
		buying_amount = buying_amount > 0 and buying_amount or 0

		gross_profit = selling_amount - buying_amount
		if selling_amount:
			gross_profit_percent = (gross_profit / selling_amount) * 100.0
		else:
			gross_profit_percent = 0.0
		
		icon = """<a href="%s"><i class="icon icon-share" style="cursor: pointer;"></i></a>""" \
			% ("/".join(["#Form", row.parenttype, row.name]),)
		data.append([row.name, icon, row.posting_date, row.posting_time, row.item_code, row.item_name,
			row.description, row.warehouse, row.qty, row.base_rate, 
			row.qty and (buying_amount / row.qty) or 0, row.base_amount, buying_amount,
			gross_profit, gross_profit_percent, row.project])
			
	return columns, data
	
def get_stock_ledger_entries(filters):	
	query = """select item_code, voucher_type, voucher_no,
		voucher_detail_no, posting_date, posting_time, stock_value,
		warehouse, actual_qty as qty
		from `tabStock Ledger Entry`"""
	
	if filters.get("company"):
		query += """ where company=%(company)s"""
	
	query += " order by item_code desc, warehouse desc, posting_date desc, posting_time desc, name desc"
	
	res = frappe.db.sql(query, filters, as_dict=True)
	
	out = {}
	for r in res:
		if (r.item_code, r.warehouse) not in out:
			out[(r.item_code, r.warehouse)] = []
		
		out[(r.item_code, r.warehouse)].append(r)

	return out
	
def get_item_sales_bom():
	item_sales_bom = {}
	
	for d in frappe.db.sql("""select parenttype, parent, parent_item,
		item_code, warehouse, -1*qty as total_qty, parent_detail_docname
		from `tabPacked Item` where docstatus=1""", as_dict=True):
		item_sales_bom.setdefault(d.parenttype, frappe._dict()).setdefault(d.parent,
			frappe._dict()).setdefault(d.parent_item, []).append(d)

	return item_sales_bom
	
def get_source_data(filters):
	conditions = ""
	if filters.get("company"):
		conditions += " and company=%(company)s"
	if filters.get("from_date"):
		conditions += " and posting_date>=%(from_date)s"
	if filters.get("to_date"):
		conditions += " and posting_date<=%(to_date)s"
	
	delivery_note_items = frappe.db.sql("""select item.parenttype, dn.name, 
		dn.posting_date, dn.posting_time, dn.project_name, 
		item.item_code, item.item_name, item.description, item.warehouse,
		item.qty, item.base_rate, item.base_amount, item.name as "item_row",
		timestamp(dn.posting_date, dn.posting_time) as posting_datetime
		from `tabDelivery Note` dn, `tabDelivery Note Item` item
		where item.parent = dn.name and dn.docstatus = 1 %s
		order by dn.posting_date desc, dn.posting_time desc""" % (conditions,), filters, as_dict=1)

	sales_invoice_items = frappe.db.sql("""select item.parenttype, si.name, 
		si.posting_date, si.posting_time, si.project_name,
		item.item_code, item.item_name, item.description, item.warehouse,
		item.qty, item.base_rate, item.base_amount, item.name as "item_row",
		timestamp(si.posting_date, si.posting_time) as posting_datetime
		from `tabSales Invoice` si, `tabSales Invoice Item` item
		where item.parent = si.name and si.docstatus = 1 %s
		and si.update_stock = 1
		order by si.posting_date desc, si.posting_time desc""" % (conditions,), filters, as_dict=1)
	
	source = delivery_note_items + sales_invoice_items
	if len(source) > len(delivery_note_items):
		source.sort(key=lambda d: d.posting_datetime, reverse=True)
	
	return source
########NEW FILE########
__FILENAME__ = item_wise_purchase_register
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt

def execute(filters=None):
	if not filters: filters = {}
	columns = get_columns()
	last_col = len(columns)
	
	item_list = get_items(filters)
	aii_account_map = get_aii_accounts()
	if item_list:
		item_tax, tax_accounts = get_tax_accounts(item_list, columns)
	
	data = []
	for d in item_list:
		expense_account = d.expense_account or aii_account_map.get(d.company)
		row = [d.item_code, d.item_name, d.item_group, d.parent, d.posting_date, 
			d.supplier_name, d.credit_to, d.project_name, d.company, d.purchase_order, 
			d.purchase_receipt, expense_account, d.qty, d.base_rate, d.base_amount]
		for tax in tax_accounts:
			row.append(item_tax.get(d.parent, {}).get(d.item_code, {}).get(tax, 0))

		total_tax = sum(row[last_col:])
		row += [total_tax, d.base_amount + total_tax]
		
		data.append(row)
	
	return columns, data
	
	
def get_columns():
	return ["Item Code:Link/Item:120", "Item Name::120", "Item Group:Link/Item Group:100", 
		"Invoice:Link/Purchase Invoice:120", "Posting Date:Date:80", "Supplier:Link/Customer:120", 
		"Supplier Account:Link/Account:120", "Project:Link/Project:80", "Company:Link/Company:100", 
		"Purchase Order:Link/Purchase Order:100", "Purchase Receipt:Link/Purchase Receipt:100", 
		"Expense Account:Link/Account:140", "Qty:Float:120", "Rate:Currency:120", 
		"Amount:Currency:120"]
	
def get_conditions(filters):
	conditions = ""
	
	for opts in (("company", " and company=%(company)s"),
		("account", " and pi.credit_to = %(account)s"),
		("item_code", " and pi_item.item_code = %(item_code)s"),
		("from_date", " and pi.posting_date>=%(from_date)s"),
		("to_date", " and pi.posting_date<=%(to_date)s")):
			if filters.get(opts[0]):
				conditions += opts[1]

	return conditions
	
def get_items(filters):
	conditions = get_conditions(filters)
	match_conditions = frappe.build_match_conditions("Purchase Invoice")
	
	return frappe.db.sql("""select pi_item.parent, pi.posting_date, pi.credit_to, pi.company, 
		pi.supplier, pi.remarks, pi_item.item_code, pi_item.item_name, pi_item.item_group, 
		pi_item.project_name, pi_item.purchase_order, pi_item.purchase_receipt, 
		pi_item.expense_account, pi_item.qty, pi_item.base_rate, pi_item.base_amount, pi.supplier_name
		from `tabPurchase Invoice` pi, `tabPurchase Invoice Item` pi_item 
		where pi.name = pi_item.parent and pi.docstatus = 1 %s %s
		order by pi.posting_date desc, pi_item.item_code desc""" % (conditions, match_conditions), filters, as_dict=1)
		
def get_aii_accounts():
	return dict(frappe.db.sql("select name, stock_received_but_not_billed from tabCompany"))
	
def get_tax_accounts(item_list, columns):
	import json
	item_tax = {}
	tax_accounts = []
	
	tax_details = frappe.db.sql("""select parent, account_head, item_wise_tax_detail
		from `tabPurchase Taxes and Charges` where parenttype = 'Purchase Invoice' 
		and docstatus = 1 and ifnull(account_head, '') != '' and category in ('Total', 'Valuation and Total') 
		and parent in (%s)""" % ', '.join(['%s']*len(item_list)), tuple([item.parent for item in item_list]))
		
	for parent, account_head, item_wise_tax_detail in tax_details:
		if account_head not in tax_accounts:
			tax_accounts.append(account_head)
		
		if item_wise_tax_detail:
			try:
				item_wise_tax_detail = json.loads(item_wise_tax_detail)
				for item, tax_amount in item_wise_tax_detail.items():
					item_tax.setdefault(parent, {}).setdefault(item, {})[account_head] = \
						flt(tax_amount[1]) if isinstance(tax_amount, list) else flt(tax_amount)
				
			except ValueError:
				continue
	
	tax_accounts.sort()
	columns += [account_head + ":Currency:80" for account_head in tax_accounts]
	columns += ["Total Tax:Currency:80", "Total:Currency:80"]

	return item_tax, tax_accounts
########NEW FILE########
__FILENAME__ = item_wise_sales_register
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt

def execute(filters=None):
	if not filters: filters = {}
	columns = get_columns()
	last_col = len(columns)

	item_list = get_items(filters)
	if item_list:
		item_tax, tax_accounts = get_tax_accounts(item_list, columns)
	
	data = []
	for d in item_list:
		row = [d.item_code, d.item_name, d.item_group, d.parent, d.posting_date, 
			d.customer_name, d.debit_to, d.territory, d.project_name, d.company, d.sales_order, 
			d.delivery_note, d.income_account, d.qty, d.base_rate, d.base_amount]
			
		for tax in tax_accounts:
			row.append(item_tax.get(d.parent, {}).get(d.item_code, {}).get(tax, 0))

		total_tax = sum(row[last_col:])
		row += [total_tax, d.base_amount + total_tax]
		
		data.append(row)
	
	return columns, data
	
def get_columns():
	return [
		"Item Code:Link/Item:120", "Item Name::120", "Item Group:Link/Item Group:100", 
		"Invoice:Link/Sales Invoice:120", "Posting Date:Date:80", "Customer:Link/Customer:120", 
		"Customer Account:Link/Account:120", "Territory:Link/Territory:80",
		"Project:Link/Project:80", "Company:Link/Company:100", "Sales Order:Link/Sales Order:100", 
		"Delivery Note:Link/Delivery Note:100", "Income Account:Link/Account:140", 
		"Qty:Float:120", "Rate:Currency:120", "Amount:Currency:120"
	]
	
def get_conditions(filters):
	conditions = ""
	
	for opts in (("company", " and company=%(company)s"),
		("account", " and si.debit_to = %(account)s"),
		("item_code", " and si_item.item_code = %(item_code)s"),
		("from_date", " and si.posting_date>=%(from_date)s"),
		("to_date", " and si.posting_date<=%(to_date)s")):
			if filters.get(opts[0]):
				conditions += opts[1]

	return conditions
		
def get_items(filters):
	conditions = get_conditions(filters)
	return frappe.db.sql("""select si_item.parent, si.posting_date, si.debit_to, si.project_name, 
		si.customer, si.remarks, si.territory, si.company, si_item.item_code, si_item.item_name, 
		si_item.item_group, si_item.sales_order, si_item.delivery_note, si_item.income_account, 
		si_item.qty, si_item.base_rate, si_item.base_amount, si.customer_name
		from `tabSales Invoice` si, `tabSales Invoice Item` si_item 
		where si.name = si_item.parent and si.docstatus = 1 %s 
		order by si.posting_date desc, si_item.item_code desc""" % conditions, filters, as_dict=1)
		
def get_tax_accounts(item_list, columns):
	import json
	item_tax = {}
	tax_accounts = []
	
	tax_details = frappe.db.sql("""select parent, account_head, item_wise_tax_detail
		from `tabSales Taxes and Charges` where parenttype = 'Sales Invoice' 
		and docstatus = 1 and ifnull(account_head, '') != ''
		and parent in (%s)""" % ', '.join(['%s']*len(item_list)), 
		tuple([item.parent for item in item_list]))
		
	for parent, account_head, item_wise_tax_detail in tax_details:
		if account_head not in tax_accounts:
			tax_accounts.append(account_head)
				
		if item_wise_tax_detail:
			try:
				item_wise_tax_detail = json.loads(item_wise_tax_detail)
				for item, tax_amount in item_wise_tax_detail.items():
					item_tax.setdefault(parent, {}).setdefault(item, {})[account_head] = \
						 flt(tax_amount[1]) if isinstance(tax_amount, list) else flt(tax_amount)
			except ValueError:
				continue
	
	tax_accounts.sort()
	columns += [account_head + ":Currency:80" for account_head in tax_accounts]
	columns += ["Total Tax:Currency:80", "Total:Currency:80"]

	return item_tax, tax_accounts
########NEW FILE########
__FILENAME__ = payment_period_based_on_invoice_date
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import msgprint, _
from erpnext.accounts.report.accounts_receivable.accounts_receivable import get_ageing_data

def execute(filters=None):
	if not filters: filters = {}

	columns = get_columns()
	entries = get_entries(filters)
	invoice_posting_date_map = get_invoice_posting_date_map(filters)
	against_date = ""
	outstanding_amount = 0.0

	data = []
	for d in entries:
		if d.against_voucher:
			against_date = d.against_voucher and invoice_posting_date_map[d.against_voucher] or ""
			outstanding_amount = d.debit or -1*d.credit
		else:
			against_date = d.against_invoice and invoice_posting_date_map[d.against_invoice] or ""
			outstanding_amount = d.credit or -1*d.debit

		row = [d.name, d.account, d.posting_date, d.against_voucher or d.against_invoice,
			against_date, d.debit, d.credit, d.cheque_no, d.cheque_date, d.remark]

		if d.against_voucher or d.against_invoice:
			row += get_ageing_data(d.posting_date, against_date, outstanding_amount)
		else:
			row += ["", "", "", "", ""]

		data.append(row)

	return columns, data

def get_columns():
	return ["Journal Voucher:Link/Journal Voucher:140", "Account:Link/Account:140",
		"Posting Date:Date:100", "Against Invoice:Link/Purchase Invoice:130",
		"Against Invoice Posting Date:Date:130", "Debit:Currency:120", "Credit:Currency:120",
		"Reference No::100", "Reference Date:Date:100", "Remarks::150", "Age:Int:40",
		"0-30:Currency:100", "30-60:Currency:100", "60-90:Currency:100", "90-Above:Currency:100"
	]

def get_conditions(filters):
	conditions = ""
	party_accounts = []

	if filters.get("account"):
		party_accounts = [filters["account"]]
	else:
		cond = filters.get("company") and (" and company = '%s'" %
			filters["company"].replace("'", "\'")) or ""

		if filters.get("payment_type") == "Incoming":
			cond += " and master_type = 'Customer'"
		else:
			cond += " and master_type = 'Supplier'"

		party_accounts = frappe.db.sql_list("""select name from `tabAccount`
			where ifnull(master_name, '')!='' and docstatus < 2 %s""" % cond)

	if party_accounts:
		conditions += " and jvd.account in (%s)" % (", ".join(['%s']*len(party_accounts)))
	else:
		msgprint(_("No Customer or Supplier Accounts found"), raise_exception=1)

	if filters.get("from_date"): conditions += " and jv.posting_date >= '%s'" % filters["from_date"]
	if filters.get("to_date"): conditions += " and jv.posting_date <= '%s'" % filters["to_date"]

	return conditions, party_accounts

def get_entries(filters):
	conditions, party_accounts = get_conditions(filters)
	entries =  frappe.db.sql("""select jv.name, jvd.account, jv.posting_date,
		jvd.against_voucher, jvd.against_invoice, jvd.debit, jvd.credit,
		jv.cheque_no, jv.cheque_date, jv.remark
		from `tabJournal Voucher Detail` jvd, `tabJournal Voucher` jv
		where jvd.parent = jv.name and jv.docstatus=1 %s order by jv.name DESC""" %
		(conditions), tuple(party_accounts), as_dict=1)

	return entries

def get_invoice_posting_date_map(filters):
	invoice_posting_date_map = {}
	if filters.get("payment_type") == "Incoming":
		for t in frappe.db.sql("""select name, posting_date from `tabSales Invoice`"""):
			invoice_posting_date_map[t[0]] = t[1]
	else:
		for t in frappe.db.sql("""select name, posting_date from `tabPurchase Invoice`"""):
			invoice_posting_date_map[t[0]] = t[1]

	return invoice_posting_date_map

########NEW FILE########
__FILENAME__ = purchase_invoice_trends
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from erpnext.controllers.trends	import get_columns,get_data

def execute(filters=None):
	if not filters: filters ={}
	data = []
	conditions = get_columns(filters, "Purchase Invoice")
	data = get_data(filters, conditions)

	return conditions["columns"], data 
########NEW FILE########
__FILENAME__ = purchase_register
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt
from frappe import msgprint, _

def execute(filters=None):
	if not filters: filters = {}

	invoice_list = get_invoices(filters)
	columns, expense_accounts, tax_accounts = get_columns(invoice_list)
	
	
	if not invoice_list:
		msgprint(_("No record found"))		
		return columns, invoice_list
	
	invoice_expense_map = get_invoice_expense_map(invoice_list)
	invoice_expense_map, invoice_tax_map = get_invoice_tax_map(invoice_list, 
		invoice_expense_map, expense_accounts)
	invoice_po_pr_map = get_invoice_po_pr_map(invoice_list)
	account_map = get_account_details(invoice_list)

	data = []
	for inv in invoice_list:
		# invoice details
		purchase_order = list(set(invoice_po_pr_map.get(inv.name, {}).get("purchase_order", [])))
		purchase_receipt = list(set(invoice_po_pr_map.get(inv.name, {}).get("purchase_receipt", [])))
		project_name = list(set(invoice_po_pr_map.get(inv.name, {}).get("project_name", [])))

		row = [inv.name, inv.posting_date, inv.supplier, inv.supplier_name, inv.credit_to, 
			account_map.get(inv.credit_to), ", ".join(project_name), inv.bill_no, inv.bill_date, 
			inv.remarks, ", ".join(purchase_order), ", ".join(purchase_receipt)]
		
		# map expense values
		net_total = 0
		for expense_acc in expense_accounts:
			expense_amount = flt(invoice_expense_map.get(inv.name, {}).get(expense_acc))
			net_total += expense_amount
			row.append(expense_amount)
		
		# net total
		row.append(net_total or inv.net_total)
			
		# tax account
		total_tax = 0
		for tax_acc in tax_accounts:
			if tax_acc not in expense_accounts:
				tax_amount = flt(invoice_tax_map.get(inv.name, {}).get(tax_acc))
				total_tax += tax_amount
				row.append(tax_amount)

		# total tax, grand total, outstanding amount & rounded total
		row += [total_tax, inv.grand_total, flt(inv.grand_total, 2), inv.outstanding_amount]
		data.append(row)
		# raise Exception
	
	return columns, data
	
	
def get_columns(invoice_list):
	"""return columns based on filters"""
	columns = [
		"Invoice:Link/Purchase Invoice:120", "Posting Date:Date:80", "Supplier Id::120", 
		"Supplier Name::120", "Supplier Account:Link/Account:120", 
		"Account Group:LInk/Account:120", "Project:Link/Project:80", "Bill No::120", 
		"Bill Date:Date:80", "Remarks::150", 
		"Purchase Order:Link/Purchase Order:100", "Purchase Receipt:Link/Purchase Receipt:100"
	]
	expense_accounts = tax_accounts = expense_columns = tax_columns = []
	
	if invoice_list:	
		expense_accounts = frappe.db.sql_list("""select distinct expense_account 
			from `tabPurchase Invoice Item` where docstatus = 1 and ifnull(expense_account, '') != '' 
			and parent in (%s) order by expense_account""" % 
			', '.join(['%s']*len(invoice_list)), tuple([inv.name for inv in invoice_list]))
		
		tax_accounts = 	frappe.db.sql_list("""select distinct account_head 
			from `tabPurchase Taxes and Charges` where parenttype = 'Purchase Invoice' 
			and docstatus = 1 and ifnull(account_head, '') != '' and category in ('Total', 'Valuation and Total') 
			and parent in (%s) order by account_head""" % 
			', '.join(['%s']*len(invoice_list)), tuple([inv.name for inv in invoice_list]))
			
				
	expense_columns = [(account + ":Currency:120") for account in expense_accounts]
	for account in tax_accounts:
		if account not in expense_accounts:
			tax_columns.append(account + ":Currency:120")
	
	columns = columns + expense_columns + \
		["Net Total:Currency:120"] + tax_columns + \
		["Total Tax:Currency:120"] + ["Grand Total:Currency:120"] + \
		["Rounded Total:Currency:120"] + ["Outstanding Amount:Currency:120"]

	return columns, expense_accounts, tax_accounts

def get_conditions(filters):
	conditions = ""
	
	if filters.get("company"): conditions += " and company=%(company)s"
	if filters.get("account"): conditions += " and credit_to = %(account)s"

	if filters.get("from_date"): conditions += " and posting_date>=%(from_date)s"
	if filters.get("to_date"): conditions += " and posting_date<=%(to_date)s"

	return conditions
	
def get_invoices(filters):
	conditions = get_conditions(filters)
	return frappe.db.sql("""select name, posting_date, credit_to, supplier, supplier_name, 
		bill_no, bill_date, remarks, net_total, grand_total, outstanding_amount 
		from `tabPurchase Invoice` where docstatus = 1 %s 
		order by posting_date desc, name desc""" % conditions, filters, as_dict=1)
	
	
def get_invoice_expense_map(invoice_list):
	expense_details = frappe.db.sql("""select parent, expense_account, sum(base_amount) as amount
		from `tabPurchase Invoice Item` where parent in (%s) group by parent, expense_account""" % 
		', '.join(['%s']*len(invoice_list)), tuple([inv.name for inv in invoice_list]), as_dict=1)
	
	invoice_expense_map = {}
	for d in expense_details:
		invoice_expense_map.setdefault(d.parent, frappe._dict()).setdefault(d.expense_account, [])
		invoice_expense_map[d.parent][d.expense_account] = flt(d.amount)
	
	return invoice_expense_map
	
def get_invoice_tax_map(invoice_list, invoice_expense_map, expense_accounts):
	tax_details = frappe.db.sql("""select parent, account_head, sum(tax_amount) as tax_amount
		from `tabPurchase Taxes and Charges` where parent in (%s) group by parent, account_head""" % 
		', '.join(['%s']*len(invoice_list)), tuple([inv.name for inv in invoice_list]), as_dict=1)
	
	invoice_tax_map = {}
	for d in tax_details:
		if d.account_head in expense_accounts:
			if invoice_expense_map[d.parent].has_key(d.account_head):
				invoice_expense_map[d.parent][d.account_head] += flt(d.tax_amount)
			else:
				invoice_expense_map[d.parent][d.account_head] = flt(d.tax_amount)
		else:
			invoice_tax_map.setdefault(d.parent, frappe._dict()).setdefault(d.account_head, [])
			invoice_tax_map[d.parent][d.account_head] = flt(d.tax_amount)
	
	return invoice_expense_map, invoice_tax_map
	
def get_invoice_po_pr_map(invoice_list):
	pi_items = frappe.db.sql("""select parent, purchase_order, purchase_receipt, 
		project_name from `tabPurchase Invoice Item` where parent in (%s) 
		and (ifnull(purchase_order, '') != '' or ifnull(purchase_receipt, '') != '')""" % 
		', '.join(['%s']*len(invoice_list)), tuple([inv.name for inv in invoice_list]), as_dict=1)
	
	invoice_po_pr_map = {}
	for d in pi_items:
		if d.purchase_order:
			invoice_po_pr_map.setdefault(d.parent, frappe._dict()).setdefault(
				"purchase_order", []).append(d.purchase_order)
		if d.purchase_receipt:
			invoice_po_pr_map.setdefault(d.parent, frappe._dict()).setdefault(
				"purchase_receipt", []).append(d.purchase_receipt)
		if d.project_name:
			invoice_po_pr_map.setdefault(d.parent, frappe._dict()).setdefault(
				"project_name", []).append(d.project_name)
				
	return invoice_po_pr_map
	
def get_account_details(invoice_list):
	account_map = {}
	accounts = list(set([inv.credit_to for inv in invoice_list]))
	for acc in frappe.db.sql("""select name, parent_account from tabAccount 
		where name in (%s)""" % ", ".join(["%s"]*len(accounts)), tuple(accounts), as_dict=1):
			account_map[acc.name] = acc.parent_account
						
	return account_map
########NEW FILE########
__FILENAME__ = sales_invoice_trends
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from erpnext.controllers.trends	import get_columns,get_data

def execute(filters=None):
	if not filters: filters ={}
	data = []
	conditions = get_columns(filters, "Sales Invoice")
	data = get_data(filters, conditions)

	return conditions["columns"], data 
########NEW FILE########
__FILENAME__ = sales_register
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt
from frappe import msgprint, _

def execute(filters=None):
	if not filters: filters = {}
	
	invoice_list = get_invoices(filters)
	columns, income_accounts, tax_accounts = get_columns(invoice_list)
	
	if not invoice_list:
		msgprint(_("No record found"))
		return columns, invoice_list
	
	invoice_income_map = get_invoice_income_map(invoice_list)
	invoice_income_map, invoice_tax_map = get_invoice_tax_map(invoice_list, 
		invoice_income_map, income_accounts)
	
	invoice_so_dn_map = get_invoice_so_dn_map(invoice_list)
	customer_map = get_customer_deatils(invoice_list)
	account_map = get_account_details(invoice_list)

	data = []
	for inv in invoice_list:
		# invoice details
		sales_order = list(set(invoice_so_dn_map.get(inv.name, {}).get("sales_order", [])))
		delivery_note = list(set(invoice_so_dn_map.get(inv.name, {}).get("delivery_note", [])))

		row = [inv.name, inv.posting_date, inv.customer, inv.customer_name, inv.debit_to, 
			account_map.get(inv.debit_to), customer_map.get(inv.customer), inv.project_name, 
			inv.remarks, ", ".join(sales_order), ", ".join(delivery_note)]
		
		# map income values
		net_total = 0
		for income_acc in income_accounts:
			income_amount = flt(invoice_income_map.get(inv.name, {}).get(income_acc))
			net_total += income_amount
			row.append(income_amount)
		
		# net total
		row.append(net_total or inv.net_total)
			
		# tax account
		total_tax = 0
		for tax_acc in tax_accounts:
			if tax_acc not in income_accounts:
				tax_amount = flt(invoice_tax_map.get(inv.name, {}).get(tax_acc))
				total_tax += tax_amount
				row.append(tax_amount)

		# total tax, grand total, outstanding amount & rounded total
		row += [total_tax, inv.grand_total, inv.rounded_total, inv.outstanding_amount]

		data.append(row)
	
	return columns, data
	
	
def get_columns(invoice_list):
	"""return columns based on filters"""
	columns = [
		"Invoice:Link/Sales Invoice:120", "Posting Date:Date:80", "Customer Id::120", 
		"Customer Name::120", "Customer Account:Link/Account:120", "Account Group:LInk/Account:120",
		"Territory:Link/Territory:80", "Project:Link/Project:80", "Remarks::150", 
		"Sales Order:Link/Sales Order:100", "Delivery Note:Link/Delivery Note:100"
	]
	
	income_accounts = tax_accounts = income_columns = tax_columns = []
	
	if invoice_list:
		income_accounts = frappe.db.sql_list("""select distinct income_account 
			from `tabSales Invoice Item` where docstatus = 1 and parent in (%s) 
			order by income_account""" % 
			', '.join(['%s']*len(invoice_list)), tuple([inv.name for inv in invoice_list]))
	
		tax_accounts = 	frappe.db.sql_list("""select distinct account_head 
			from `tabSales Taxes and Charges` where parenttype = 'Sales Invoice' 
			and docstatus = 1 and ifnull(tax_amount_after_discount_amount, 0) != 0 
			and parent in (%s) order by account_head""" % 
			', '.join(['%s']*len(invoice_list)), tuple([inv.name for inv in invoice_list]))

	income_columns = [(account + ":Currency:120") for account in income_accounts]
	for account in tax_accounts:
		if account not in income_accounts:
			tax_columns.append(account + ":Currency:120")
	
	columns = columns + income_columns + ["Net Total:Currency:120"] + tax_columns + \
		["Total Tax:Currency:120"] + ["Grand Total:Currency:120"] + \
		["Rounded Total:Currency:120"] + ["Outstanding Amount:Currency:120"]

	return columns, income_accounts, tax_accounts

def get_conditions(filters):
	conditions = ""
	
	if filters.get("company"): conditions += " and company=%(company)s"
	if filters.get("account"): conditions += " and debit_to = %(account)s"

	if filters.get("from_date"): conditions += " and posting_date >= %(from_date)s"
	if filters.get("to_date"): conditions += " and posting_date <= %(to_date)s"

	return conditions
	
def get_invoices(filters):
	conditions = get_conditions(filters)
	return frappe.db.sql("""select name, posting_date, debit_to, project_name, customer, 
		customer_name, remarks, net_total, grand_total, rounded_total, outstanding_amount 
		from `tabSales Invoice` 
		where docstatus = 1 %s order by posting_date desc, name desc""" % 
		conditions, filters, as_dict=1)
	
def get_invoice_income_map(invoice_list):
	income_details = frappe.db.sql("""select parent, income_account, sum(base_amount) as amount
		from `tabSales Invoice Item` where parent in (%s) group by parent, income_account""" % 
		', '.join(['%s']*len(invoice_list)), tuple([inv.name for inv in invoice_list]), as_dict=1)
	
	invoice_income_map = {}
	for d in income_details:
		invoice_income_map.setdefault(d.parent, frappe._dict()).setdefault(d.income_account, [])
		invoice_income_map[d.parent][d.income_account] = flt(d.amount)
	
	return invoice_income_map
	
def get_invoice_tax_map(invoice_list, invoice_income_map, income_accounts):
	tax_details = frappe.db.sql("""select parent, account_head, 
		sum(tax_amount_after_discount_amount) as tax_amount 
		from `tabSales Taxes and Charges` where parent in (%s) group by parent, account_head""" % 
		', '.join(['%s']*len(invoice_list)), tuple([inv.name for inv in invoice_list]), as_dict=1)
	
	invoice_tax_map = {}
	for d in tax_details:
		if d.account_head in income_accounts:
			if invoice_income_map[d.parent].has_key(d.account_head):
				invoice_income_map[d.parent][d.account_head] += flt(d.tax_amount)
			else:
				invoice_income_map[d.parent][d.account_head] = flt(d.tax_amount)
		else:
			invoice_tax_map.setdefault(d.parent, frappe._dict()).setdefault(d.account_head, [])
			invoice_tax_map[d.parent][d.account_head] = flt(d.tax_amount)
	
	return invoice_income_map, invoice_tax_map
	
def get_invoice_so_dn_map(invoice_list):
	si_items = frappe.db.sql("""select parent, sales_order, delivery_note
		from `tabSales Invoice Item` where parent in (%s) 
		and (ifnull(sales_order, '') != '' or ifnull(delivery_note, '') != '')""" % 
		', '.join(['%s']*len(invoice_list)), tuple([inv.name for inv in invoice_list]), as_dict=1)
	
	invoice_so_dn_map = {}
	for d in si_items:
		if d.sales_order:
			invoice_so_dn_map.setdefault(d.parent, frappe._dict()).setdefault(
				"sales_order", []).append(d.sales_order)
		if d.delivery_note:
			invoice_so_dn_map.setdefault(d.parent, frappe._dict()).setdefault(
				"delivery_note", []).append(d.delivery_note)
				
	return invoice_so_dn_map
	
def get_customer_deatils(invoice_list):
	customer_map = {}
	customers = list(set([inv.customer for inv in invoice_list]))
	for cust in frappe.db.sql("""select name, territory from `tabCustomer` 
		where name in (%s)""" % ", ".join(["%s"]*len(customers)), tuple(customers), as_dict=1):
			customer_map[cust.name] = cust.territory
	
	return customer_map
	
def get_account_details(invoice_list):
	account_map = {}
	accounts = list(set([inv.debit_to for inv in invoice_list]))
	for acc in frappe.db.sql("""select name, parent_account from tabAccount 
		where name in (%s)""" % ", ".join(["%s"]*len(accounts)), tuple(accounts), as_dict=1):
			account_map[acc.name] = acc.parent_account
						
	return account_map
########NEW FILE########
__FILENAME__ = supplier_account_head
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute(filters=None):
	account_map = get_account_map()
	columns = get_columns(account_map)
	data = []
	suppliers = frappe.db.sql("select name from tabSupplier where docstatus < 2")
	for supplier in suppliers:
		row = [supplier[0]]
		for company in sorted(account_map):
			row.append(account_map[company].get(supplier[0], ''))
		data.append(row)

	return columns, data

def get_account_map():
	accounts = frappe.db.sql("""select name, company, master_name 
		from `tabAccount` where master_type = 'Supplier' 
		and ifnull(master_name, '') != '' and docstatus < 2""", as_dict=1)

	account_map = {}
	for acc in accounts:
		account_map.setdefault(acc.company, {}).setdefault(acc.master_name, {})
		account_map[acc.company][acc.master_name] = acc.name

	return account_map

def get_columns(account_map):
	columns = ["Supplier:Link/Supplier:120"] + \
		[(company + ":Link/Account:120") for company in sorted(account_map)]

	return columns
########NEW FILE########
__FILENAME__ = utils
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals

import frappe
from frappe.utils import nowdate, cstr, flt, now, getdate, add_months
from frappe import throw, _
from frappe.utils import formatdate
from erpnext.utilities import build_filter_conditions


class FiscalYearError(frappe.ValidationError): pass
class BudgetError(frappe.ValidationError): pass


def get_fiscal_year(date=None, fiscal_year=None, label="Date", verbose=1):
	return get_fiscal_years(date, fiscal_year, label, verbose)[0]

def get_fiscal_years(date=None, fiscal_year=None, label="Date", verbose=1):
	# if year start date is 2012-04-01, year end date should be 2013-03-31 (hence subdate)
	cond = ""
	if fiscal_year:
		cond = "name = '%s'" % fiscal_year.replace("'", "\'")
	else:
		cond = "'%s' >= year_start_date and '%s' <= year_end_date" % \
			(date, date)
	fy = frappe.db.sql("""select name, year_start_date, year_end_date
		from `tabFiscal Year` where %s order by year_start_date desc""" % cond)

	if not fy:
		error_msg = _("""{0} {1} not in any Fiscal Year""").format(label, formatdate(date))
		if verbose: frappe.msgprint(error_msg)
		raise FiscalYearError, error_msg

	return fy

def validate_fiscal_year(date, fiscal_year, label="Date"):
	years = [f[0] for f in get_fiscal_years(date, label=label)]
	if fiscal_year not in years:
		throw(_("{0} '{1}' not in Fiscal Year {2}").format(label, formatdate(date), fiscal_year))

@frappe.whitelist()
def get_balance_on(account=None, date=None):
	if not account and frappe.form_dict.get("account"):
		account = frappe.form_dict.get("account")
		date = frappe.form_dict.get("date")

	acc = frappe.db.get_value('Account', account, \
		['lft', 'rgt', 'report_type', 'group_or_ledger'], as_dict=1)

	if not acc:
		frappe.throw(_("Account {0} does not exist").format(account), frappe.DoesNotExistError)

	cond = []
	if date:
		cond.append("posting_date <= '%s'" % date)
	else:
		# get balance of all entries that exist
		date = nowdate()

	try:
		year_start_date = get_fiscal_year(date, verbose=0)[1]
	except FiscalYearError:
		if getdate(date) > getdate(nowdate()):
			# if fiscal year not found and the date is greater than today
			# get fiscal year for today's date and its corresponding year start date
			year_start_date = get_fiscal_year(nowdate(), verbose=1)[1]
		else:
			# this indicates that it is a date older than any existing fiscal year.
			# hence, assuming balance as 0.0
			return 0.0

	# for pl accounts, get balance within a fiscal year
	if acc.report_type == 'Profit and Loss':
		cond.append("posting_date >= '%s' and voucher_type != 'Period Closing Voucher'" \
			% year_start_date)

	# different filter for group and ledger - improved performance
	if acc.group_or_ledger=="Group":
		cond.append("""exists (
			select * from `tabAccount` ac where ac.name = gle.account
			and ac.lft >= %s and ac.rgt <= %s
		)""" % (acc.lft, acc.rgt))
	else:
		cond.append("""gle.account = "%s" """ % (account.replace('"', '\"'), ))

	bal = frappe.db.sql("""
		SELECT sum(ifnull(debit, 0)) - sum(ifnull(credit, 0))
		FROM `tabGL Entry` gle
		WHERE %s""" % " and ".join(cond))[0][0]

	# if bal is None, return 0
	return flt(bal)

@frappe.whitelist()
def add_ac(args=None):
	if not args:
		args = frappe.local.form_dict
		args.pop("cmd")

	ac = frappe.new_doc("Account")
	ac.update(args)
	ac.old_parent = ""
	ac.freeze_account = "No"
	ac.insert()

	return ac.name

@frappe.whitelist()
def add_cc(args=None):
	if not args:
		args = frappe.local.form_dict
		args.pop("cmd")

	cc = frappe.new_doc("Cost Center")
	cc.update(args)
	cc.old_parent = ""
	cc.insert()
	return cc.name

def reconcile_against_document(args):
	"""
		Cancel JV, Update aginst document, split if required and resubmit jv
	"""
	for d in args:
		check_if_jv_modified(d)
		validate_allocated_amount(d)
		against_fld = {
			'Journal Voucher' : 'against_jv',
			'Sales Invoice' : 'against_invoice',
			'Purchase Invoice' : 'against_voucher'
		}

		d['against_fld'] = against_fld[d['against_voucher_type']]

		# cancel JV
		jv_obj = frappe.get_doc('Journal Voucher', d['voucher_no'])

		jv_obj.make_gl_entries(cancel=1, adv_adj=1)

		# update ref in JV Detail
		update_against_doc(d, jv_obj)

		# re-submit JV
		jv_obj = frappe.get_doc('Journal Voucher', d['voucher_no'])
		jv_obj.make_gl_entries(cancel = 0, adv_adj =1)


def check_if_jv_modified(args):
	"""
		check if there is already a voucher reference
		check if amount is same
		check if jv is submitted
	"""
	ret = frappe.db.sql("""
		select t2.%(dr_or_cr)s from `tabJournal Voucher` t1, `tabJournal Voucher Detail` t2
		where t1.name = t2.parent and t2.account = '%(account)s'
		and ifnull(t2.against_voucher, '')=''
		and ifnull(t2.against_invoice, '')='' and ifnull(t2.against_jv, '')=''
		and t1.name = '%(voucher_no)s' and t2.name = '%(voucher_detail_no)s'
		and t1.docstatus=1 """ % args)

	if not ret:
		throw(_("""Payment Entry has been modified after you pulled it. Please pull it again."""))

def validate_allocated_amount(args):
	if args.get("allocated_amt") < 0:
		throw(_("Allocated amount can not be negative"))
	elif args.get("allocated_amt") > args.get("unadjusted_amt"):
		throw(_("Allocated amount can not greater than unadusted amount"))

def update_against_doc(d, jv_obj):
	"""
		Updates against document, if partial amount splits into rows
	"""
	jv_detail = jv_obj.get("entries", {"name": d["voucher_detail_no"]})[0]
	jv_detail.set(d["dr_or_cr"], d["allocated_amt"])
	jv_detail.set(d["against_fld"], d["against_voucher"])

	if d['allocated_amt'] < d['unadjusted_amt']:
		jvd = frappe.db.sql("""select cost_center, balance, against_account, is_advance
			from `tabJournal Voucher Detail` where name = %s""", d['voucher_detail_no'])
		# new entry with balance amount
		ch = jv_obj.append("entries")
		ch.account = d['account']
		ch.cost_center = cstr(jvd[0][0])
		ch.balance = cstr(jvd[0][1])
		ch.set(d['dr_or_cr'], flt(d['unadjusted_amt']) - flt(d['allocated_amt']))
		ch.set(d['dr_or_cr']== 'debit' and 'credit' or 'debit', 0)
		ch.against_account = cstr(jvd[0][2])
		ch.is_advance = cstr(jvd[0][3])
		ch.docstatus = 1

	# will work as update after submit
	jv_obj.ignore_validate_update_after_submit = True
	jv_obj.save()

def get_account_list(doctype, txt, searchfield, start, page_len, filters):
	if not filters.get("group_or_ledger"):
		filters["group_or_ledger"] = "Ledger"

	conditions, filter_values = build_filter_conditions(filters)

	return frappe.db.sql("""select name, parent_account from `tabAccount`
		where docstatus < 2 %s and %s like %s order by name limit %s, %s""" %
		(conditions, searchfield, "%s", "%s", "%s"),
		tuple(filter_values + ["%%%s%%" % txt, start, page_len]))

def get_cost_center_list(doctype, txt, searchfield, start, page_len, filters):
	if not filters.get("group_or_ledger"):
		filters["group_or_ledger"] = "Ledger"

	conditions, filter_values = build_filter_conditions(filters)

	return frappe.db.sql("""select name, parent_cost_center from `tabCost Center`
		where docstatus < 2 %s and %s like %s order by name limit %s, %s""" %
		(conditions, searchfield, "%s", "%s", "%s"),
		tuple(filter_values + ["%%%s%%" % txt, start, page_len]))

def remove_against_link_from_jv(ref_type, ref_no, against_field):
	linked_jv = frappe.db.sql_list("""select parent from `tabJournal Voucher Detail`
		where `%s`=%s and docstatus < 2""" % (against_field, "%s"), (ref_no))

	if linked_jv:
		frappe.db.sql("""update `tabJournal Voucher Detail` set `%s`=null,
			modified=%s, modified_by=%s
			where `%s`=%s and docstatus < 2""" % (against_field, "%s", "%s", against_field, "%s"),
			(now(), frappe.session.user, ref_no))

		frappe.db.sql("""update `tabGL Entry`
			set against_voucher_type=null, against_voucher=null,
			modified=%s, modified_by=%s
			where against_voucher_type=%s and against_voucher=%s
			and voucher_no != ifnull(against_voucher, '')""",
			(now(), frappe.session.user, ref_type, ref_no))

		frappe.msgprint(_("Journal Vouchers {0} are un-linked".format("\n".join(linked_jv))))


@frappe.whitelist()
def get_company_default(company, fieldname):
	value = frappe.db.get_value("Company", company, fieldname)

	if not value:
		throw(_("Please set default value {0} in Company {0}").format(frappe.get_meta("Company").get_label(fieldname), company))

	return value

def fix_total_debit_credit():
	vouchers = frappe.db.sql("""select voucher_type, voucher_no,
		sum(debit) - sum(credit) as diff
		from `tabGL Entry`
		group by voucher_type, voucher_no
		having sum(ifnull(debit, 0)) != sum(ifnull(credit, 0))""", as_dict=1)

	for d in vouchers:
		if abs(d.diff) > 0:
			dr_or_cr = d.voucher_type == "Sales Invoice" and "credit" or "debit"

			frappe.db.sql("""update `tabGL Entry` set %s = %s + %s
				where voucher_type = %s and voucher_no = %s and %s > 0 limit 1""" %
				(dr_or_cr, dr_or_cr, '%s', '%s', '%s', dr_or_cr),
				(d.diff, d.voucher_type, d.voucher_no))

def get_stock_and_account_difference(account_list=None, posting_date=None):
	from erpnext.stock.utils import get_stock_balance_on

	if not posting_date: posting_date = nowdate()

	difference = {}

	account_warehouse = dict(frappe.db.sql("""select name, master_name from tabAccount
		where account_type = 'Warehouse' and ifnull(master_name, '') != ''
		and name in (%s)""" % ', '.join(['%s']*len(account_list)), account_list))

	for account, warehouse in account_warehouse.items():
		account_balance = get_balance_on(account, posting_date)
		stock_value = get_stock_balance_on(warehouse, posting_date)
		if abs(flt(stock_value) - flt(account_balance)) > 0.005:
			difference.setdefault(account, flt(stock_value) - flt(account_balance))

	return difference

def validate_expense_against_budget(args):
	args = frappe._dict(args)
	if frappe.db.get_value("Account", {"name": args.account, "report_type": "Profit and Loss"}):
			budget = frappe.db.sql("""
				select bd.budget_allocated, cc.distribution_id
				from `tabCost Center` cc, `tabBudget Detail` bd
				where cc.name=bd.parent and cc.name=%s and account=%s and bd.fiscal_year=%s
			""", (args.cost_center, args.account, args.fiscal_year), as_dict=True)

			if budget and budget[0].budget_allocated:
				yearly_action, monthly_action = frappe.db.get_value("Company", args.company,
					["yearly_bgt_flag", "monthly_bgt_flag"])
				action_for = action = ""

				if monthly_action in ["Stop", "Warn"]:
					budget_amount = get_allocated_budget(budget[0].distribution_id,
						args.posting_date, args.fiscal_year, budget[0].budget_allocated)

					args["month_end_date"] = frappe.db.sql("select LAST_DAY(%s)",
						args.posting_date)[0][0]
					action_for, action = _("Monthly"), monthly_action

				elif yearly_action in ["Stop", "Warn"]:
					budget_amount = budget[0].budget_allocated
					action_for, action = _("Annual"), yearly_action

				if action_for:
					actual_expense = get_actual_expense(args)
					if actual_expense > budget_amount:
						frappe.msgprint(_("{0} budget for Account {1} against Cost Center {2} will exceed by {3}").format(
							_(action_for), args.account, args.cost_center, cstr(actual_expense - budget_amount)))
						if action=="Stop":
							raise BudgetError

def get_allocated_budget(distribution_id, posting_date, fiscal_year, yearly_budget):
	if distribution_id:
		distribution = {}
		for d in frappe.db.sql("""select bdd.month, bdd.percentage_allocation
			from `tabBudget Distribution Detail` bdd, `tabBudget Distribution` bd
			where bdd.parent=bd.name and bd.fiscal_year=%s""", fiscal_year, as_dict=1):
				distribution.setdefault(d.month, d.percentage_allocation)

	dt = frappe.db.get_value("Fiscal Year", fiscal_year, "year_start_date")
	budget_percentage = 0.0

	while(dt <= getdate(posting_date)):
		if distribution_id:
			budget_percentage += distribution.get(getdate(dt).strftime("%B"), 0)
		else:
			budget_percentage += 100.0/12

		dt = add_months(dt, 1)

	return yearly_budget * budget_percentage / 100

def get_actual_expense(args):
	args["condition"] = " and posting_date<='%s'" % args.month_end_date \
		if args.get("month_end_date") else ""

	return frappe.db.sql("""
		select sum(ifnull(debit, 0)) - sum(ifnull(credit, 0))
		from `tabGL Entry`
		where account='%(account)s' and cost_center='%(cost_center)s'
		and fiscal_year='%(fiscal_year)s' and company='%(company)s' %(condition)s
	""" % (args))[0][0]

def rename_account_for(dt, olddn, newdn, merge, company):
	old_account = get_account_for(dt, olddn)
	if old_account:
		new_account = None
		if not merge:
			if old_account == add_abbr_if_missing(olddn, company):
				new_account = frappe.rename_doc("Account", old_account, newdn)
		else:
			existing_new_account = get_account_for(dt, newdn)
			new_account = frappe.rename_doc("Account", old_account,
				existing_new_account or newdn, merge=True if existing_new_account else False)

		frappe.db.set_value("Account", new_account or old_account, "master_name", newdn)

def add_abbr_if_missing(dn, company):
	from erpnext.setup.doctype.company.company import get_name_with_abbr
	return get_name_with_abbr(dn, company)

def get_account_for(account_for_doctype, account_for):
	if account_for_doctype in ["Customer", "Supplier"]:
		account_for_field = "master_type"
	elif account_for_doctype == "Warehouse":
		account_for_field = "account_type"

	return frappe.db.get_value("Account", {account_for_field: account_for_doctype,
		"master_name": account_for})

def get_currency_precision(currency=None):
	if not currency:
		currency = frappe.db.get_value("Company",
			frappe.db.get_default("company"), "default_currency")
	currency_format = frappe.db.get_value("Currency", currency, "number_format")

	from frappe.utils import get_number_format_info
	return get_number_format_info(currency_format)[2]

########NEW FILE########
__FILENAME__ = buying_settings
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class BuyingSettings(Document):
		
	def validate(self):
		for key in ["supplier_type", "supp_master_name", "maintain_same_rate", "buying_price_list"]:
			frappe.db.set_default(key, self.get(key, ""))

		from erpnext.setup.doctype.naming_series.naming_series import set_by_naming_series
		set_by_naming_series("Supplier", "supplier_name", 
			self.get("supp_master_name")=="Naming Series", hide_name_field=False)

########NEW FILE########
__FILENAME__ = purchase_common
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import cstr, flt
from frappe import _

from erpnext.stock.doctype.item.item import get_last_purchase_details
from erpnext.controllers.buying_controller import BuyingController

class PurchaseCommon(BuyingController):

	def update_last_purchase_rate(self, obj, is_submit):
		"""updates last_purchase_rate in item table for each item"""

		import frappe.utils
		this_purchase_date = frappe.utils.getdate(obj.get('posting_date') or obj.get('transaction_date'))

		for d in obj.get(obj.fname):
			# get last purchase details
			last_purchase_details = get_last_purchase_details(d.item_code, obj.name)

			# compare last purchase date and this transaction's date
			last_purchase_rate = None
			if last_purchase_details and \
					(last_purchase_details.purchase_date > this_purchase_date):
				last_purchase_rate = last_purchase_details['base_rate']
			elif is_submit == 1:
				# even if this transaction is the latest one, it should be submitted
				# for it to be considered for latest purchase rate
				if flt(d.conversion_factor):
					last_purchase_rate = flt(d.base_rate) / flt(d.conversion_factor)
				else:
					frappe.throw(_("UOM Conversion factor is required in row {0}").format(d.idx))

			# update last purchsae rate
			if last_purchase_rate:
				frappe.db.sql("""update `tabItem` set last_purchase_rate = %s where name = %s""",
					(flt(last_purchase_rate), d.item_code))

	def get_last_purchase_rate(self, obj):
		"""get last purchase rates for all items"""
		doc_name = obj.name
		conversion_rate = flt(obj.get('conversion_rate')) or 1.0

		for d in obj.get(obj.fname):
			if d.item_code:
				last_purchase_details = get_last_purchase_details(d.item_code, doc_name)

				if last_purchase_details:
					d.base_price_list_rate = last_purchase_details['base_price_list_rate'] * (flt(d.conversion_factor) or 1.0)
					d.discount_percentage = last_purchase_details['discount_percentage']
					d.base_rate = last_purchase_details['base_rate'] * (flt(d.conversion_factor) or 1.0)
					d.price_list_rate = d.base_price_list_rate / conversion_rate
					d.rate = d.base_rate / conversion_rate
				else:
					# if no last purchase found, reset all values to 0
					d.base_price_list_rate = d.base_rate = d.price_list_rate = d.rate = d.discount_percentage = 0

					item_last_purchase_rate = frappe.db.get_value("Item",
						d.item_code, "last_purchase_rate")
					if item_last_purchase_rate:
						d.base_price_list_rate = d.base_rate = d.price_list_rate \
							= d.rate = item_last_purchase_rate

	def validate_for_items(self, obj):
		check_list, chk_dupl_itm=[],[]
		for d in obj.get(obj.fname):
			# validation for valid qty
			if flt(d.qty) < 0 or (d.parenttype != 'Purchase Receipt' and not flt(d.qty)):
				frappe.throw(_("Please enter quantity for Item {0}").format(d.item_code))

			# udpate with latest quantities
			bin = frappe.db.sql("""select projected_qty from `tabBin` where
				item_code = %s and warehouse = %s""", (d.item_code, d.warehouse), as_dict=1)

			f_lst ={'projected_qty': bin and flt(bin[0]['projected_qty']) or 0, 'ordered_qty': 0, 'received_qty' : 0}
			if d.doctype == 'Purchase Receipt Item':
				f_lst.pop('received_qty')
			for x in f_lst :
				if d.meta.get_field(x):
					d.set(x, f_lst[x])

			item = frappe.db.sql("""select is_stock_item, is_purchase_item,
				is_sub_contracted_item, end_of_life from `tabItem` where name=%s""", d.item_code)

			from erpnext.stock.doctype.item.item import validate_end_of_life
			validate_end_of_life(d.item_code, item[0][3])

			# validate stock item
			if item[0][0]=='Yes' and d.qty and not d.warehouse:
				frappe.throw(_("Warehouse is mandatory for stock Item {0} in row {1}").format(d.item_code, d.idx))

			# validate purchase item
			if item[0][1] != 'Yes' and item[0][2] != 'Yes':
				frappe.throw(_("{0} must be a Purchased or Sub-Contracted Item in row {1}").format(d.item_code, d.idx))

			# list criteria that should not repeat if item is stock item
			e = [getattr(d, "schedule_date", None), d.item_code, d.description, d.warehouse, d.uom,
				d.meta.get_field('prevdoc_docname') and d.prevdoc_docname or d.meta.get_field('sales_order_no') and d.sales_order_no or '',
				d.meta.get_field('prevdoc_detail_docname') and d.prevdoc_detail_docname or '',
				d.meta.get_field('batch_no') and d.batch_no or '']

			# if is not stock item
			f = [getattr(d, "schedule_date", None), d.item_code, d.description]

			ch = frappe.db.sql("""select is_stock_item from `tabItem` where name = %s""", d.item_code)

			if ch and ch[0][0] == 'Yes':
				# check for same items
				if e in check_list:
					frappe.throw(_("Item {0} has been entered multiple times with same description or date or warehouse").format(d.item_code))
				else:
					check_list.append(e)

			elif ch and ch[0][0] == 'No':
				# check for same items
				if f in chk_dupl_itm:
					frappe.throw(_("Item {0} has been entered multiple times with same description or date").format(d.item_code))
				else:
					chk_dupl_itm.append(f)

	def get_qty(self, curr_doctype, ref_tab_fname, ref_tab_dn, ref_doc_tname, transaction, curr_parent_name):
		# Get total Quantities of current doctype (eg. PR) except for qty of this transaction
		#------------------------------
		# please check as UOM changes from Material Request - Purchase Order ,so doing following else uom should be same .
		# i.e. in PO uom is NOS then in PR uom should be NOS
		# but if in Material Request uom KG it can change in PO

		get_qty = (transaction == 'Material Request - Purchase Order') and 'qty * conversion_factor' or 'qty'
		qty = frappe.db.sql("""select sum(%s) from `tab%s` where %s = %s and
			docstatus = 1 and parent != %s""" % (get_qty, curr_doctype, ref_tab_fname, '%s', '%s'),
			(ref_tab_dn, curr_parent_name))
		qty = qty and flt(qty[0][0]) or 0

		# get total qty of ref doctype
		#--------------------
		max_qty = frappe.db.sql("""select qty from `tab%s` where name = %s
			and docstatus = 1""" % (ref_doc_tname, '%s'), ref_tab_dn)
		max_qty = max_qty and flt(max_qty[0][0]) or 0

		return cstr(qty)+'~~~'+cstr(max_qty)

	def check_for_stopped_status(self, doctype, docname):
		stopped = frappe.db.sql("""select name from `tab%s` where name = %s and
			status = 'Stopped'""" % (doctype, '%s'), docname)
		if stopped:
			frappe.throw(_("{0} {1} status is 'Stopped'").format(doctype, docname), frappe.InvalidStatusError)

	def check_docstatus(self, check, doctype, docname, detail_doctype = ''):
		if check == 'Next':
			submitted = frappe.db.sql("""select t1.name from `tab%s` t1,`tab%s` t2
				where t1.name = t2.parent and t2.prevdoc_docname = %s and t1.docstatus = 1"""
				% (doctype, detail_doctype, '%s'), docname)
			if submitted:
				frappe.throw(_("{0} {1} has already been submitted").format(doctype, submitted[0][0]))

		if check == 'Previous':
			submitted = frappe.db.sql("""select name from `tab%s`
				where docstatus = 1 and name = %s""" % (doctype, '%s'), docname)
			if not submitted:
				frappe.throw(_("{0} {1} is not submitted").format(doctype, submitted[0][0]))

########NEW FILE########
__FILENAME__ = purchase_order
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cstr, flt
from frappe import msgprint, _, throw
from frappe.model.mapper import get_mapped_doc
from erpnext.controllers.buying_controller import BuyingController

class PurchaseOrder(BuyingController):
	tname = 'Purchase Order Item'
	fname = 'po_details'

	def __init__(self, arg1, arg2=None):
		super(PurchaseOrder, self).__init__(arg1, arg2)
		self.status_updater = [{
			'source_dt': 'Purchase Order Item',
			'target_dt': 'Material Request Item',
			'join_field': 'prevdoc_detail_docname',
			'target_field': 'ordered_qty',
			'target_parent_dt': 'Material Request',
			'target_parent_field': 'per_ordered',
			'target_ref_field': 'qty',
			'source_field': 'qty',
			'percent_join_field': 'prevdoc_docname',
		}]

	def validate(self):
		super(PurchaseOrder, self).validate()

		if not self.status:
			self.status = "Draft"

		from erpnext.utilities import validate_status
		validate_status(self.status, ["Draft", "Submitted", "Stopped",
			"Cancelled"])

		pc_obj = frappe.get_doc('Purchase Common')
		pc_obj.validate_for_items(self)
		self.check_for_stopped_status(pc_obj)

		self.validate_uom_is_integer("uom", "qty")
		self.validate_uom_is_integer("stock_uom", ["qty", "required_qty"])

		self.validate_with_previous_doc()
		self.validate_for_subcontracting()
		self.create_raw_materials_supplied("po_raw_material_details")

	def validate_with_previous_doc(self):
		super(PurchaseOrder, self).validate_with_previous_doc(self.tname, {
			"Supplier Quotation": {
				"ref_dn_field": "supplier_quotation",
				"compare_fields": [["supplier", "="], ["company", "="], ["currency", "="]],
			},
			"Supplier Quotation Item": {
				"ref_dn_field": "supplier_quotation_item",
				"compare_fields": [["rate", "="], ["project_name", "="], ["item_code", "="],
					["uom", "="]],
				"is_child_table": True
			}
		})

	def get_schedule_dates(self):
		for d in self.get('po_details'):
			if d.prevdoc_detail_docname and not d.schedule_date:
				d.schedule_date = frappe.db.get_value("Material Request Item",
						d.prevdoc_detail_docname, "schedule_date")

	def get_last_purchase_rate(self):
		frappe.get_doc('Purchase Common').get_last_purchase_rate(self)

	# Check for Stopped status
	def check_for_stopped_status(self, pc_obj):
		check_list =[]
		for d in self.get('po_details'):
			if d.meta.get_field('prevdoc_docname') and d.prevdoc_docname and d.prevdoc_docname not in check_list:
				check_list.append(d.prevdoc_docname)
				pc_obj.check_for_stopped_status( d.prevdoc_doctype, d.prevdoc_docname)


	def update_bin(self, is_submit, is_stopped = 0):
		from erpnext.stock.utils import update_bin
		pc_obj = frappe.get_doc('Purchase Common')
		for d in self.get('po_details'):
			#1. Check if is_stock_item == 'Yes'
			if frappe.db.get_value("Item", d.item_code, "is_stock_item") == "Yes":
				# this happens when item is changed from non-stock to stock item
				if not d.warehouse:
					continue

				ind_qty, po_qty = 0, flt(d.qty) * flt(d.conversion_factor)
				if is_stopped:
					po_qty = flt(d.qty) > flt(d.received_qty) and \
						flt( flt(flt(d.qty) - flt(d.received_qty))*flt(d.conversion_factor)) or 0

				# No updates in Material Request on Stop / Unstop
				if cstr(d.prevdoc_doctype) == 'Material Request' and not is_stopped:
					# get qty and pending_qty of prevdoc
					curr_ref_qty = pc_obj.get_qty(d.doctype, 'prevdoc_detail_docname',
					 	d.prevdoc_detail_docname, 'Material Request Item',
						'Material Request - Purchase Order', self.name)
					max_qty, qty, curr_qty = flt(curr_ref_qty.split('~~~')[1]), \
					 	flt(curr_ref_qty.split('~~~')[0]), 0

					if flt(qty) + flt(po_qty) > flt(max_qty):
						curr_qty = flt(max_qty) - flt(qty)
						# special case as there is no restriction
						# for Material Request - Purchase Order
						curr_qty = curr_qty > 0 and curr_qty or 0
					else:
						curr_qty = flt(po_qty)

					ind_qty = -flt(curr_qty)

				# Update ordered_qty and indented_qty in bin
				args = {
					"item_code": d.item_code,
					"warehouse": d.warehouse,
					"ordered_qty": (is_submit and 1 or -1) * flt(po_qty),
					"indented_qty": (is_submit and 1 or -1) * flt(ind_qty),
					"posting_date": self.transaction_date
				}
				update_bin(args)

	def check_modified_date(self):
		mod_db = frappe.db.sql("select modified from `tabPurchase Order` where name = %s",
			self.name)
		date_diff = frappe.db.sql("select TIMEDIFF('%s', '%s')" % ( mod_db[0][0],cstr(self.modified)))

		if date_diff and date_diff[0][0]:
			msgprint(_("{0} {1} has been modified. Please refresh").format(self.doctype, self.name),
				raise_exception=True)

	def update_status(self, status):
		self.check_modified_date()
		# step 1:=> Set Status
		frappe.db.set(self,'status',cstr(status))

		# step 2:=> Update Bin
		self.update_bin(is_submit = (status == 'Submitted') and 1 or 0, is_stopped = 1)

		# step 3:=> Acknowledge user
		msgprint(_("Status of {0} {1} is now {2}").format(self.doctype, self.name, status))

	def on_submit(self):
		purchase_controller = frappe.get_doc("Purchase Common")

		self.update_prevdoc_status()
		self.update_bin(is_submit = 1, is_stopped = 0)

		frappe.get_doc('Authorization Control').validate_approving_authority(self.doctype,
			self.company, self.grand_total)

		purchase_controller.update_last_purchase_rate(self, is_submit = 1)

		frappe.db.set(self,'status','Submitted')

	def on_cancel(self):
		pc_obj = frappe.get_doc('Purchase Common')
		self.check_for_stopped_status(pc_obj)

		# Check if Purchase Receipt has been submitted against current Purchase Order
		pc_obj.check_docstatus(check = 'Next', doctype = 'Purchase Receipt', docname = self.name, detail_doctype = 'Purchase Receipt Item')

		# Check if Purchase Invoice has been submitted against current Purchase Order
		submitted = frappe.db.sql_list("""select t1.name
			from `tabPurchase Invoice` t1,`tabPurchase Invoice Item` t2
			where t1.name = t2.parent and t2.purchase_order = %s and t1.docstatus = 1""",
			self.name)
		if submitted:
			throw(_("Purchase Invoice {0} is already submitted").format(", ".join(submitted)))

		frappe.db.set(self,'status','Cancelled')
		self.update_prevdoc_status()
		self.update_bin( is_submit = 0, is_stopped = 0)
		pc_obj.update_last_purchase_rate(self, is_submit = 0)

	def on_update(self):
		pass

@frappe.whitelist()
def make_purchase_receipt(source_name, target_doc=None):
	def set_missing_values(source, target):
		target.run_method("set_missing_values")
		target.run_method("calculate_taxes_and_totals")

	def update_item(obj, target, source_parent):
		target.qty = flt(obj.qty) - flt(obj.received_qty)
		target.stock_qty = (flt(obj.qty) - flt(obj.received_qty)) * flt(obj.conversion_factor)
		target.amount = (flt(obj.qty) - flt(obj.received_qty)) * flt(obj.rate)
		target.base_amount = (flt(obj.qty) - flt(obj.received_qty)) * flt(obj.base_rate)

	doc = get_mapped_doc("Purchase Order", source_name,	{
		"Purchase Order": {
			"doctype": "Purchase Receipt",
			"validation": {
				"docstatus": ["=", 1],
			}
		},
		"Purchase Order Item": {
			"doctype": "Purchase Receipt Item",
			"field_map": {
				"name": "prevdoc_detail_docname",
				"parent": "prevdoc_docname",
				"parenttype": "prevdoc_doctype",
			},
			"postprocess": update_item,
			"condition": lambda doc: doc.received_qty < doc.qty
		},
		"Purchase Taxes and Charges": {
			"doctype": "Purchase Taxes and Charges",
			"add_if_empty": True
		}
	}, target_doc, set_missing_values)

	return doc

@frappe.whitelist()
def make_purchase_invoice(source_name, target_doc=None):
	def set_missing_values(source, target):
		target.run_method("set_missing_values")
		target.run_method("calculate_taxes_and_totals")

	def update_item(obj, target, source_parent):
		target.amount = flt(obj.amount) - flt(obj.billed_amt)
		target.base_amount = target.amount * flt(source_parent.conversion_rate)
		if flt(obj.base_rate):
			target.qty = target.base_amount / flt(obj.base_rate)

	doc = get_mapped_doc("Purchase Order", source_name,	{
		"Purchase Order": {
			"doctype": "Purchase Invoice",
			"validation": {
				"docstatus": ["=", 1],
			}
		},
		"Purchase Order Item": {
			"doctype": "Purchase Invoice Item",
			"field_map": {
				"name": "po_detail",
				"parent": "purchase_order",
			},
			"postprocess": update_item,
			"condition": lambda doc: doc.base_amount==0 or doc.billed_amt < doc.amount
		},
		"Purchase Taxes and Charges": {
			"doctype": "Purchase Taxes and Charges",
			"add_if_empty": True
		}
	}, target_doc, set_missing_values)

	return doc

########NEW FILE########
__FILENAME__ = test_purchase_order
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import unittest
import frappe
import frappe.defaults
from frappe.utils import flt

class TestPurchaseOrder(unittest.TestCase):
	def test_make_purchase_receipt(self):
		from erpnext.buying.doctype.purchase_order.purchase_order import make_purchase_receipt

		po = frappe.copy_doc(test_records[0]).insert()

		self.assertRaises(frappe.ValidationError, make_purchase_receipt,
			po.name)

		po = frappe.get_doc("Purchase Order", po.name)
		po.submit()

		pr = make_purchase_receipt(po.name)
		pr.supplier_warehouse = "_Test Warehouse 1 - _TC"
		pr.posting_date = "2013-05-12"
		self.assertEquals(pr.doctype, "Purchase Receipt")
		self.assertEquals(len(pr.get("purchase_receipt_details")), len(test_records[0]["po_details"]))

		pr.naming_series = "_T-Purchase Receipt-"
		frappe.get_doc(pr).insert()

	def test_ordered_qty(self):
		frappe.db.sql("delete from tabBin")

		from erpnext.buying.doctype.purchase_order.purchase_order import make_purchase_receipt

		po = frappe.copy_doc(test_records[0]).insert()

		self.assertRaises(frappe.ValidationError, make_purchase_receipt,
			po.name)

		po = frappe.get_doc("Purchase Order", po.name)
		po.is_subcontracted = "No"
		po.get("po_details")[0].item_code = "_Test Item"
		po.submit()

		self.assertEquals(frappe.db.get_value("Bin", {"item_code": "_Test Item",
			"warehouse": "_Test Warehouse - _TC"}, "ordered_qty"), 10)

		pr = make_purchase_receipt(po.name)

		self.assertEquals(pr.doctype, "Purchase Receipt")
		self.assertEquals(len(pr.get("purchase_receipt_details", [])), len(test_records[0]["po_details"]))
		pr.posting_date = "2013-05-12"
		pr.naming_series = "_T-Purchase Receipt-"
		pr.purchase_receipt_details[0].qty = 4.0
		pr.insert()
		pr.submit()

		self.assertEquals(flt(frappe.db.get_value("Bin", {"item_code": "_Test Item",
			"warehouse": "_Test Warehouse - _TC"}, "ordered_qty")), 6.0)

		frappe.db.set_value('Item', '_Test Item', 'tolerance', 50)

		pr1 = make_purchase_receipt(po.name)
		pr1.naming_series = "_T-Purchase Receipt-"
		pr1.posting_date = "2013-05-12"
		pr1.get("purchase_receipt_details")[0].qty = 8
		pr1.insert()
		pr1.submit()

		self.assertEquals(flt(frappe.db.get_value("Bin", {"item_code": "_Test Item",
			"warehouse": "_Test Warehouse - _TC"}, "ordered_qty")), 0.0)

	def test_make_purchase_invoice(self):
		from erpnext.buying.doctype.purchase_order.purchase_order import make_purchase_invoice

		po = frappe.copy_doc(test_records[0]).insert()

		self.assertRaises(frappe.ValidationError, make_purchase_invoice,
			po.name)

		po = frappe.get_doc("Purchase Order", po.name)
		po.submit()
		pi = make_purchase_invoice(po.name)

		self.assertEquals(pi.doctype, "Purchase Invoice")
		self.assertEquals(len(pi.get("entries", [])), len(test_records[0]["po_details"]))
		pi.posting_date = "2013-05-12"
		pi.bill_no = "NA"
		frappe.get_doc(pi).insert()

	def test_subcontracting(self):
		po = frappe.copy_doc(test_records[0])
		po.insert()
		self.assertEquals(len(po.get("po_raw_material_details")), 2)

	def test_warehouse_company_validation(self):
		from erpnext.stock.utils import InvalidWarehouseCompany
		po = frappe.copy_doc(test_records[0])
		po.company = "_Test Company 1"
		po.conversion_rate = 0.0167
		self.assertRaises(InvalidWarehouseCompany, po.insert)

	def test_uom_integer_validation(self):
		from erpnext.utilities.transaction_base import UOMMustBeIntegerError
		po = frappe.copy_doc(test_records[0])
		po.get("po_details")[0].qty = 3.4
		self.assertRaises(UOMMustBeIntegerError, po.insert)


test_dependencies = ["BOM"]

test_records = frappe.get_test_records('Purchase Order')

########NEW FILE########
__FILENAME__ = purchase_order_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class PurchaseOrderItem(Document):
	pass
########NEW FILE########
__FILENAME__ = purchase_order_item_supplied
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class PurchaseOrderItemSupplied(Document):
	pass
########NEW FILE########
__FILENAME__ = purchase_receipt_item_supplied
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class PurchaseReceiptItemSupplied(Document):
	pass
########NEW FILE########
__FILENAME__ = quality_inspection
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe


from frappe.model.document import Document

class QualityInspection(Document):

	def get_item_specification_details(self):
		self.set('qa_specification_details', [])
		specification = frappe.db.sql("select specification, value from `tabItem Quality Inspection Parameter` \
			where parent = '%s' order by idx" % (self.item_code))
		for d in specification:
			child = self.append('qa_specification_details', {})
			child.specification = d[0]
			child.value = d[1]
			child.status = 'Accepted'

	def on_submit(self):
		if self.purchase_receipt_no:
			frappe.db.sql("""update `tabPurchase Receipt Item` t1, `tabPurchase Receipt` t2 
				set t1.qa_no = %s, t2.modified = %s 
				where t1.parent = %s and t1.item_code = %s and t1.parent = t2.name""",  
				(self.name, self.modified, self.purchase_receipt_no, 
					self.item_code))
		

	def on_cancel(self):
		if self.purchase_receipt_no:
			frappe.db.sql("""update `tabPurchase Receipt Item` t1, `tabPurchase Receipt` t2 
				set t1.qa_no = '', t2.modified = %s
				where t1.parent = %s and t1.item_code = %s and t1.parent = t2.name""", 
				(self.modified, self.purchase_receipt_no, self.item_code))


def item_query(doctype, txt, searchfield, start, page_len, filters):
	if filters.get("from"):
		from frappe.widgets.reportview import get_match_cond
		filters.update({
			"txt": txt,
			"mcond": get_match_cond(filters["from"]),
			"start": start,
			"page_len": page_len
		})
		return frappe.db.sql("""select item_code from `tab%(from)s` 
			where parent='%(parent)s' and docstatus < 2 and item_code like '%%%(txt)s%%' %(mcond)s
			order by item_code limit %(start)s, %(page_len)s""" % filters)
########NEW FILE########
__FILENAME__ = quality_inspection_reading
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class QualityInspectionReading(Document):
	pass
########NEW FILE########
__FILENAME__ = supplier
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
import frappe.defaults

from frappe.utils import cint
from frappe import msgprint, _
from frappe.model.naming import make_autoname
from erpnext.accounts.party import create_party_account

from erpnext.utilities.transaction_base import TransactionBase

class Supplier(TransactionBase):

	def autoname(self):
		supp_master_name = frappe.defaults.get_global_default('supp_master_name')
		if supp_master_name == 'Supplier Name':
			if frappe.db.exists("Customer", self.supplier_name):
				frappe.msgprint(_("A Customer exists with same name"), raise_exception=1)
			self.name = self.supplier_name
		else:
			self.name = make_autoname(self.naming_series + '.#####')

	def update_address(self):
		frappe.db.sql("""update `tabAddress` set supplier_name=%s, modified=NOW()
			where supplier=%s""", (self.supplier_name, self.name))

	def update_contact(self):
		frappe.db.sql("""update `tabContact` set supplier_name=%s, modified=NOW()
			where supplier=%s""", (self.supplier_name, self.name))

	def update_credit_days_limit(self):
		frappe.db.sql("""update tabAccount set credit_days = %s where name = %s""",
			(cint(self.credit_days), self.name + " - " + self.get_company_abbr()))

	def on_update(self):
		if not self.naming_series:
			self.naming_series = ''

		self.update_address()
		self.update_contact()

		# create account head
		create_party_account(self.name, "Supplier", self.company)

		# update credit days and limit in account
		self.update_credit_days_limit()

	def get_company_abbr(self):
		return frappe.db.sql("select abbr from tabCompany where name=%s", self.company)[0][0]

	def validate(self):
		#validation for Naming Series mandatory field...
		if frappe.defaults.get_global_default('supp_master_name') == 'Naming Series':
			if not self.naming_series:
				msgprint(_("Series is mandatory"), raise_exception=1)

	def get_contacts(self,nm):
		if nm:
			contact_details =frappe.db.convert_to_lists(frappe.db.sql("select name, CONCAT(IFNULL(first_name,''),' ',IFNULL(last_name,'')),contact_no,email_id from `tabContact` where supplier = %s", nm))

			return contact_details
		else:
			return ''

	def delete_supplier_address(self):
		for rec in frappe.db.sql("select * from `tabAddress` where supplier=%s", (self.name,), as_dict=1):
			frappe.db.sql("delete from `tabAddress` where name=%s",(rec['name']))

	def delete_supplier_contact(self):
		for contact in frappe.db.sql_list("""select name from `tabContact`
			where supplier=%s""", self.name):
				frappe.delete_doc("Contact", contact)

	def delete_supplier_account(self):
		"""delete supplier's ledger if exist and check balance before deletion"""
		acc = frappe.db.sql("select name from `tabAccount` where master_type = 'Supplier' \
			and master_name = %s and docstatus < 2", self.name)
		if acc:
			frappe.delete_doc('Account', acc[0][0])

	def on_trash(self):
		self.delete_supplier_address()
		self.delete_supplier_contact()
		self.delete_supplier_account()

	def before_rename(self, olddn, newdn, merge=False):
		from erpnext.accounts.utils import rename_account_for
		rename_account_for("Supplier", olddn, newdn, merge, self.company)

	def after_rename(self, olddn, newdn, merge=False):
		set_field = ''
		if frappe.defaults.get_global_default('supp_master_name') == 'Supplier Name':
			frappe.db.set(self, "supplier_name", newdn)
			self.update_contact()
			set_field = ", supplier_name=%(newdn)s"
		self.update_supplier_address(newdn, set_field)

	def update_supplier_address(self, newdn, set_field):
		frappe.db.sql("""update `tabAddress` set address_title=%(newdn)s
			{set_field} where supplier=%(newdn)s"""\
			.format(set_field=set_field), ({"newdn": newdn}))

@frappe.whitelist()
def get_dashboard_info(supplier):
	if not frappe.has_permission("Supplier", "read", supplier):
		frappe.throw(_("No permission"))

	out = {}
	for doctype in ["Supplier Quotation", "Purchase Order", "Purchase Receipt", "Purchase Invoice"]:
		out[doctype] = frappe.db.get_value(doctype,
			{"supplier": supplier, "docstatus": ["!=", 2] }, "count(*)")

	billing = frappe.db.sql("""select sum(grand_total), sum(outstanding_amount)
		from `tabPurchase Invoice`
		where supplier=%s
			and docstatus = 1
			and fiscal_year = %s""", (supplier, frappe.db.get_default("fiscal_year")))

	out["total_billing"] = billing[0][0]
	out["total_unpaid"] = billing[0][1]

	return out

########NEW FILE########
__FILENAME__ = test_supplier
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Supplier')
########NEW FILE########
__FILENAME__ = supplier_quotation
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.model.mapper import get_mapped_doc

from erpnext.controllers.buying_controller import BuyingController
class SupplierQuotation(BuyingController):
	tname = "Supplier Quotation Item"
	fname = "quotation_items"

	def validate(self):
		super(SupplierQuotation, self).validate()

		if not self.status:
			self.status = "Draft"

		from erpnext.utilities import validate_status
		validate_status(self.status, ["Draft", "Submitted", "Stopped",
			"Cancelled"])

		self.validate_common()
		self.validate_with_previous_doc()
		self.validate_uom_is_integer("uom", "qty")

	def on_submit(self):
		frappe.db.set(self, "status", "Submitted")

	def on_cancel(self):
		frappe.db.set(self, "status", "Cancelled")

	def on_trash(self):
		pass

	def validate_with_previous_doc(self):
		super(SupplierQuotation, self).validate_with_previous_doc(self.tname, {
			"Material Request": {
				"ref_dn_field": "prevdoc_docname",
				"compare_fields": [["company", "="]],
			},
			"Material Request Item": {
				"ref_dn_field": "prevdoc_detail_docname",
				"compare_fields": [["item_code", "="], ["uom", "="]],
				"is_child_table": True
			}
		})


	def validate_common(self):
		pc = frappe.get_doc('Purchase Common')
		pc.validate_for_items(self)

@frappe.whitelist()
def make_purchase_order(source_name, target_doc=None):
	def set_missing_values(source, target):
		target.run_method("set_missing_values")
		target.run_method("get_schedule_dates")
		target.run_method("calculate_taxes_and_totals")

	def update_item(obj, target, source_parent):
		target.conversion_factor = 1

	doclist = get_mapped_doc("Supplier Quotation", source_name,		{
		"Supplier Quotation": {
			"doctype": "Purchase Order",
			"validation": {
				"docstatus": ["=", 1],
			}
		},
		"Supplier Quotation Item": {
			"doctype": "Purchase Order Item",
			"field_map": [
				["name", "supplier_quotation_item"],
				["parent", "supplier_quotation"],
				["uom", "stock_uom"],
				["uom", "uom"],
				["prevdoc_detail_docname", "prevdoc_detail_docname"],
				["prevdoc_doctype", "prevdoc_doctype"],
				["prevdoc_docname", "prevdoc_docname"]
			],
			"postprocess": update_item
		},
		"Purchase Taxes and Charges": {
			"doctype": "Purchase Taxes and Charges",
			"add_if_empty": True
		},
	}, target_doc, set_missing_values)

	return doclist

########NEW FILE########
__FILENAME__ = test_supplier_quotation
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


from __future__ import unicode_literals
import unittest
import frappe
import frappe.defaults

class TestPurchaseOrder(unittest.TestCase):
	def test_make_purchase_order(self):
		from erpnext.buying.doctype.supplier_quotation.supplier_quotation import make_purchase_order

		sq = frappe.copy_doc(test_records[0]).insert()

		self.assertRaises(frappe.ValidationError, make_purchase_order,
			sq.name)

		sq = frappe.get_doc("Supplier Quotation", sq.name)
		sq.submit()
		po = make_purchase_order(sq.name)

		self.assertEquals(po.doctype, "Purchase Order")
		self.assertEquals(len(po.get("po_details")), len(sq.get("quotation_items")))

		po.naming_series = "_T-Purchase Order-"

		for doc in po.get("po_details"):
			if doc.get("item_code"):
				doc.set("schedule_date", "2013-04-12")

		po.insert()

test_records = frappe.get_test_records('Supplier Quotation')

########NEW FILE########
__FILENAME__ = supplier_quotation_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SupplierQuotationItem(Document):
	pass
########NEW FILE########
__FILENAME__ = purchase_order_trends
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from erpnext.controllers.trends	import get_columns,get_data

def execute(filters=None):
	if not filters: filters ={}
	data = []
	conditions = get_columns(filters, "Purchase Order")
	data = get_data(filters, conditions)

	return conditions["columns"], data 
########NEW FILE########
__FILENAME__ = accounts
from frappe import _

def get_data():
	return [
		{
			"label": _("Documents"),
			"icon": "icon-star",
			"items": [
				{
					"type": "doctype",
					"name": "Journal Voucher",
					"description": _("Accounting journal entries.")
				},
				{
					"type": "doctype",
					"name": "Sales Invoice",
					"description": _("Bills raised to Customers.")
				},
				{
					"type": "doctype",
					"name": "Purchase Invoice",
					"description": _("Bills raised by Suppliers.")
				},
				{
					"type": "doctype",
					"name": "Customer",
					"description": _("Customer database.")
				},
				{
					"type": "doctype",
					"name": "Supplier",
					"description": _("Supplier database.")
				},
				{
					"type": "page",
					"name": "Accounts Browser",
					"icon": "icon-sitemap",
					"label": _("Chart of Accounts"),
					"route": "Accounts Browser/Account",
					"description": _("Tree of finanial accounts."),
					"doctype": "Account",
				},
			]
		},
		{
			"label": _("Tools"),
			"icon": "icon-wrench",
			"items": [
				{
					"type": "doctype",
					"name": "Bank Reconciliation",
					"description": _("Update bank payment dates with journals.")
				},
				# {
				# 	"type": "doctype",
				# 	"name": "Payment to Invoice Matching Tool",
				# 	"description": _("Match non-linked Invoices and Payments.")
				# },
				{
					"type": "doctype",
					"name": "Period Closing Voucher",
					"description": _("Close Balance Sheet and book Profit or Loss.")
				},
			]
		},
		{
			"label": _("Setup"),
			"icon": "icon-cog",
			"items": [
				{
					"type": "doctype",
					"name": "Fiscal Year",
					"description": _("Financial / accounting year.")
				},
				{
					"type": "page",
					"name": "Accounts Browser",
					"icon": "icon-sitemap",
					"label": _("Chart of Accounts"),
					"route": "Accounts Browser/Account",
					"description": _("Tree of finanial accounts."),
					"doctype": "Account",
				},
				{
					"type": "page",
					"name": "Accounts Browser",
					"icon": "icon-sitemap",
					"label": _("Chart of Cost Centers"),
					"route": "Accounts Browser/Cost Center",
					"description": _("Tree of finanial Cost Centers."),
					"doctype": "Cost Center",
				},
				{
					"type": "doctype",
					"name": "Accounts Settings",
					"description": _("Default settings for accounting transactions.")
				},
				{
					"type": "doctype",
					"name": "Sales Taxes and Charges Master",
					"description": _("Tax template for selling transactions.")
				},
				{
					"type": "doctype",
					"name": "Purchase Taxes and Charges Master",
					"description": _("Tax template for buying transactions.")
				},
				{
					"type": "doctype",
					"name": "POS Setting",
					"label": _("Point-of-Sale Setting"),
					"description": _("Rules to calculate shipping amount for a sale")
				},
				{
					"type": "doctype",
					"name": "Shipping Rule",
					"description": _("Rules for adding shipping costs.")
				},
				{
					"type": "doctype",
					"name": "Pricing Rule",
					"description": _("Rules for applying pricing and discount.")
				},
				{
					"type": "doctype",
					"name": "Currency",
					"description": _("Enable / disable currencies.")
				},
				{
					"type": "doctype",
					"name": "Currency Exchange",
					"description": _("Currency exchange rate master.")
				},
				{
					"type":"doctype",
					"name": "Budget Distribution",
					"description": _("Seasonality for setting budgets.")
				},
				{
					"type": "doctype",
					"name":"Terms and Conditions",
					"label": _("Terms and Conditions Template"),
					"description": _("Template of terms or contract.")
				},
				{
					"type": "doctype",
					"name":"Mode of Payment",
					"description": _("e.g. Bank, Cash, Credit Card")
				},
				{
					"type": "doctype",
					"name":"C-Form",
					"description": _("C-Form records"),
					"country": "India"
				}
			]
		},
		{
			"label": _("Main Reports"),
			"icon": "icon-table",
			"items": [
				{
					"type": "report",
					"name":"General Ledger",
					"doctype": "GL Entry",
					"is_query_report": True,
				},
				{
					"type": "page",
					"name": "trial-balance",
					"label": _("Trial Balance"),
					"icon": "icon-table"
				},
				{
					"type": "report",
					"name": "Accounts Receivable",
					"doctype": "Sales Invoice",
					"is_query_report": True
				},
				{
					"type": "report",
					"name": "Accounts Payable",
					"doctype": "Purchase Invoice",
					"is_query_report": True
				},
				{
					"type": "report",
					"name": "Sales Register",
					"doctype": "Sales Invoice",
					"is_query_report": True
				},
				{
					"type": "report",
					"name": "Purchase Register",
					"doctype": "Purchase Invoice",
					"is_query_report": True
				},
				{
					"type": "page",
					"name": "financial-analytics",
					"label": _("Financial Analytics"),
					"icon": "icon-bar-chart",
				},
				{
					"type": "report",
					"name": "Gross Profit",
					"doctype": "Sales Invoice",
					"is_query_report": True
				},
			]
		},
		{
			"label": _("Standard Reports"),
			"icon": "icon-list",
			"items": [
				{
					"type": "report",
					"name": "Bank Reconciliation Statement",
					"is_query_report": True,
					"doctype": "Journal Voucher"
				},
				{
					"type": "report",
					"name": "Ordered Items To Be Billed",
					"is_query_report": True,
					"doctype": "Sales Invoice"
				},
				{
					"type": "report",
					"name": "Delivered Items To Be Billed",
					"is_query_report": True,
					"doctype": "Sales Invoice"
				},
				{
					"type": "report",
					"name": "Purchase Order Items To Be Billed",
					"is_query_report": True,
					"doctype": "Purchase Invoice"
				},
				{
					"type": "report",
					"name": "Received Items To Be Billed",
					"is_query_report": True,
					"doctype": "Purchase Invoice"
				},
				{
					"type": "report",
					"name": "Bank Clearance Summary",
					"is_query_report": True,
					"doctype": "Journal Voucher"
				},
				{
					"type": "report",
					"name": "Payment Period Based On Invoice Date",
					"is_query_report": True,
					"doctype": "Journal Voucher"
				},
				{
					"type": "report",
					"name": "Sales Partners Commission",
					"is_query_report": True,
					"doctype": "Sales Invoice"
				},
				{
					"type": "report",
					"name": "Customer Account Head",
					"is_query_report": True,
					"doctype": "Account"
				},
				{
					"type": "report",
					"name": "Supplier Account Head",
					"is_query_report": True,
					"doctype": "Account"
				},
				{
					"type": "report",
					"name": "Item-wise Sales Register",
					"is_query_report": True,
					"doctype": "Sales Invoice"
				},
				{
					"type": "report",
					"name": "Item-wise Purchase Register",
					"is_query_report": True,
					"doctype": "Purchase Invoice"
				},
				{
					"type": "report",
					"name": "Budget Variance Report",
					"is_query_report": True,
					"doctype": "Cost Center"
				},
				{
					"type": "report",
					"name": "Purchase Invoice Trends",
					"is_query_report": True,
					"doctype": "Purchase Invoice"
				},
				{
					"type": "report",
					"name": "Sales Invoice Trends",
					"is_query_report": True,
					"doctype": "Sales Invoice"
				},
			]
		},
	]

########NEW FILE########
__FILENAME__ = buying
from frappe import _

def get_data():
	return [
		{
			"label": _("Documents"),
			"icon": "icon-star",
			"items": [
				{
					"type": "doctype",
					"name": "Supplier",
					"description": _("Supplier database."),
				},
				{
					"type": "doctype",
					"name": "Material Request",
					"description": _("Request for purchase."),
				},
				{
					"type": "doctype",
					"name": "Supplier Quotation",
					"description": _("Quotations received from Suppliers."),
				},
				{
					"type": "doctype",
					"name": "Purchase Order",
					"description": _("Purchase Orders given to Suppliers."),
				},
				{
					"type": "doctype",
					"name": "Contact",
					"description": _("All Contacts."),
				},
				{
					"type": "doctype",
					"name": "Address",
					"description": _("All Addresses."),
				},
				{
					"type": "doctype",
					"name": "Item",
					"description": _("All Products or Services."),
				},
			]
		},
		{
			"label": _("Setup"),
			"icon": "icon-cog",
			"items": [
				{
					"type": "doctype",
					"name": "Buying Settings",
					"description": _("Default settings for buying transactions.")
				},
				{
					"type": "doctype",
					"name": "Supplier Type",
					"description": _("Supplier Type master.")
				},
				{
					"type": "page",
					"name": "Sales Browser",
					"icon": "icon-sitemap",
					"label": _("Item Group Tree"),
					"link": "Sales Browser/Item Group",
					"description": _("Tree of Item Groups."),
					"doctype": "Item Group",
				},
				{
					"type": "doctype",
					"name":"Terms and Conditions",
					"label": _("Terms and Conditions Template"),
					"description": _("Template of terms or contract.")
				},
				{
					"type": "doctype",
					"name": "Purchase Taxes and Charges Master",
					"description": _("Tax template for buying transactions.")
				},
				{
					"type": "doctype",
					"name": "Price List",
					"description": _("Price List master.")
				},
				{
					"type": "doctype",
					"name": "Item Price",
					"description": _("Multiple Item prices."),
					"route": "Report/Item Price"
				},
				{
					"type": "doctype",
					"name": "Pricing Rule",
					"description": _("Rules for applying pricing and discount.")
				},
			]
		},
		{
			"label": _("Main Reports"),
			"icon": "icon-table",
			"items": [
				{
					"type": "page",
					"name": "purchase-analytics",
					"label": _("Purchase Analytics"),
					"icon": "icon-bar-chart",
				},
			]
		},
		{
			"label": _("Standard Reports"),
			"icon": "icon-list",
			"items": [
				{
					"type": "report",
					"is_query_report": True,
					"name": "Items To Be Requested",
					"doctype": "Item"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Requested Items To Be Ordered",
					"doctype": "Material Request"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Material Requests for which Supplier Quotations are not created",
					"doctype": "Material Request"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Purchase In Transit",
					"doctype": "Purchase Order"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Item-wise Purchase History",
					"doctype": "Item"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Item-wise Last Purchase Rate",
					"doctype": "Item"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Purchase Order Trends",
					"doctype": "Purchase Order"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Supplier Addresses And Contacts",
					"doctype": "Supplier"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Supplier-Wise Sales Analytics",
					"doctype": "Stock Ledger Entry"
				}
			]
		},
	]

########NEW FILE########
__FILENAME__ = desktop
from frappe import _

def get_data():
	return {
		"Accounts": {
			"color": "#3498db",
			"icon": "icon-money",
			"type": "module"
		},
		"Activity": {
			"color": "#e67e22",
			"icon": "icon-play",
			"label": _("Activity"),
			"link": "activity",
			"type": "page"
		},
		"Buying": {
			"color": "#c0392b",
			"icon": "icon-shopping-cart",
			"type": "module"
		},
		"HR": {
			"color": "#2ecc71",
			"icon": "icon-group",
			"label": _("Human Resources"),
			"type": "module"
		},
		"Manufacturing": {
			"color": "#7f8c8d",
			"icon": "icon-cogs",
			"type": "module"
		},
		"Notes": {
			"color": "#95a5a6",
			"doctype": "Note",
			"icon": "icon-file-alt",
			"label": _("Notes"),
			"link": "List/Note",
			"type": "list"
		},
		"Projects": {
			"color": "#8e44ad",
			"icon": "icon-puzzle-piece",
			"type": "module"
		},
		"Selling": {
			"color": "#1abc9c",
			"icon": "icon-tag",
			"type": "module"
		},
		"Stock": {
			"color": "#f39c12",
			"icon": "icon-truck",
			"type": "module"
		},
		"Support": {
			"color": "#2c3e50",
			"icon": "icon-phone",
			"type": "module"
		}
	}

########NEW FILE########
__FILENAME__ = hr
from frappe import _

def get_data():
	return [
		{
			"label": _("Documents"),
			"icon": "icon-star",
			"items": [
				{
					"type": "doctype",
					"name": "Employee",
					"description": _("Employee records."),
				},
				{
					"type": "doctype",
					"name": "Salary Slip",
					"description": _("Monthly salary statement."),
				},
				{
					"type": "doctype",
					"name": "Leave Application",
					"description": _("Applications for leave."),
				},
				{
					"type": "doctype",
					"name": "Attendance",
					"description": _("Attendance record."),
				},
				{
					"type": "doctype",
					"name": "Expense Claim",
					"description": _("Claims for company expense."),
				},
				{
					"type": "doctype",
					"name": "Appraisal",
					"description": _("Performance appraisal."),
				},
				{
					"type": "doctype",
					"name": "Job Applicant",
					"description": _("Applicant for a Job."),
				},
				{
					"type": "doctype",
					"name": "Job Opening",
					"description": _("Opening for a Job."),
				},
			]
		},
		{
			"label": _("Tools"),
			"icon": "icon-wrench",
			"items": [
				{
					"type": "doctype",
					"name": "Salary Manager",
					"label": _("Process Payroll"),
					"description":_("Generate Salary Slips"),
					"hide_count": True
				},
				{
					"type": "doctype",
					"name": "Upload Attendance",
					"description":_("Upload attendance from a .csv file"),
					"hide_count": True
				},
				{
					"type": "doctype",
					"name": "Leave Control Panel",
					"label": _("Leave Allocation Tool"),
					"description":_("Allocate leaves for the year."),
					"hide_count": True
				},
			]
		},
		{
			"label": _("Setup"),
			"icon": "icon-cog",
			"items": [
				{
					"type": "doctype",
					"name": "HR Settings",
					"description": _("Settings for HR Module")
				},
				{
					"type": "doctype",
					"name": "Employee",
					"description": _("Employee master.")
				},
				{
					"type": "doctype",
					"name": "Employment Type",
					"description": _("Types of employment (permanent, contract, intern etc.).")
				},
				{
					"type": "doctype",
					"name": "Branch",
					"description": _("Organization branch master.")
				},
				{
					"type": "doctype",
					"name": "Department",
					"description": _("Organization unit (department) master.")
				},
				{
					"type": "doctype",
					"name": "Designation",
					"description": _("Employee designation (e.g. CEO, Director etc.).")
				},
				{
					"type": "doctype",
					"name": "Salary Structure",
					"description": _("Salary template master.")
				},
				{
					"type": "doctype",
					"name": "Earning Type",
					"description": _("Salary components.")
				},
				{
					"type": "doctype",
					"name": "Deduction Type",
					"description": _("Tax and other salary deductions.")
				},
				{
					"type": "doctype",
					"name": "Leave Allocation",
					"description": _("Allocate leaves for a period.")
				},
				{
					"type": "doctype",
					"name":"Leave Type",
					"description": _("Type of leaves like casual, sick etc."),
				},
				{
					"type": "doctype",
					"name": "Holiday List",
					"description": _("Holiday master.")
				},
				{
					"type": "doctype",
					"name": "Leave Block List",
					"description": _("Block leave applications by department.")
				},
				{
					"type": "doctype",
					"name": "Appraisal Template",
					"description": _("Template for performance appraisals.")
				},
				{
					"type": "doctype",
					"name": "Expense Claim Type",
					"description": _("Types of Expense Claim.")
				},
				{
					"type": "doctype",
					"name": "Jobs Email Settings",
					"description": _("Setup incoming server for jobs email id. (e.g. jobs@example.com)")
				},
			]
		},
		{
			"label": _("Standard Reports"),
			"icon": "icon-list",
			"items": [
				{
					"type": "report",
					"is_query_report": True,
					"name": "Employee Leave Balance",
					"doctype": "Leave Application"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Employee Birthday",
					"doctype": "Employee"
				},
				{
					"type": "report",
					"name": "Employee Information",
					"doctype": "Employee"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Monthly Salary Register",
					"doctype": "Salary Slip"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Monthly Attendance Sheet",
					"doctype": "Attendance"
				},
			]
		},
	]

########NEW FILE########
__FILENAME__ = manufacturing
from frappe import _

def get_data():
	return [
		{
			"label": _("Documents"),
			"icon": "icon-star",
			"items": [
				{
					"type": "doctype",
					"name": "BOM",
					"description": _("Bill of Materials (BOM)"),
					"label": _("Bill of Material")
				},
				{
					"type": "doctype",
					"name": "Production Order",
					"description": _("Orders released for production."),
				},
				{
					"type": "doctype",
					"name": "Item",
					"description": _("All Products or Services."),
				},
				{
					"type": "doctype",
					"name": "Workstation",
					"description": _("Where manufacturing operations are carried out."),
				},

			]
		},
		{
			"label": _("Tools"),
			"icon": "icon-wrench",
			"items": [
				{
					"type": "doctype",
					"name": "Production Planning Tool",
					"description": _("Generate Material Requests (MRP) and Production Orders."),
				},
				{
					"type": "doctype",
					"name": "BOM Replace Tool",
					"description": _("Replace Item / BOM in all BOMs"),
				},
			]
		},
		{
			"label": _("Standard Reports"),
			"icon": "icon-list",
			"items": [
				{
					"type": "report",
					"is_query_report": True,
					"name": "Open Production Orders",
					"doctype": "Production Order"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Production Orders in Progress",
					"doctype": "Production Order"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Issued Items Against Production Order",
					"doctype": "Production Order"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Completed Production Orders",
					"doctype": "Production Order"
				},
			]
		},
	]

########NEW FILE########
__FILENAME__ = projects
from frappe import _

def get_data():
	return [
		{
			"label": _("Documents"),
			"icon": "icon-star",
			"items": [
				{
					"type": "doctype",
					"name": "Task",
					"description": _("Project activity / task."),
				},
				{
					"type": "doctype",
					"name": "Project",
					"description": _("Project master."),
				},
				{
					"type": "doctype",
					"name": "Time Log",
					"description": _("Time Log for tasks."),
				},
				{
					"type": "doctype",
					"name": "Time Log Batch",
					"description": _("Batch Time Logs for billing."),
				},
				{
					"type": "doctype",
					"name": "Activity Type",
					"description": _("Types of activities for Time Sheets"),
				},
			]
		},
		{
			"label": _("Tools"),
			"icon": "icon-wrench",
			"items": [
				{
					"type": "report",
					"route": "Gantt/Task",
					"doctype": "Task",
					"name": "Gantt Chart",
					"description": _("Gantt chart of all tasks.")
				},
			]
		},
		{
			"label": _("Standard Reports"),
			"icon": "icon-list",
			"items": [
				{
					"type": "report",
					"is_query_report": True,
					"name": "Daily Time Log Summary",
					"doctype": "Time Log"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Project wise Stock Tracking",
					"doctype": "Project"
				},
			]
		},
	]

########NEW FILE########
__FILENAME__ = selling
from frappe import _

def get_data():
	return [
		{
			"label": _("Documents"),
			"icon": "icon-star",
			"items": [
				{
					"type": "doctype",
					"name": "Lead",
					"description": _("Database of potential customers."),
				},
				{
					"type": "doctype",
					"name": "Customer",
					"description": _("Customer database."),
				},
				{
					"type": "doctype",
					"name": "Opportunity",
					"description": _("Potential opportunities for selling."),
				},
				{
					"type": "doctype",
					"name": "Quotation",
					"description": _("Quotes to Leads or Customers."),
				},
				{
					"type": "doctype",
					"name": "Sales Order",
					"description": _("Confirmed orders from Customers."),
				},
				{
					"type": "doctype",
					"name": "Contact",
					"description": _("All Contacts."),
				},
				{
					"type": "doctype",
					"name": "Address",
					"description": _("All Addresses."),
				},
				{
					"type": "doctype",
					"name": "Item",
					"description": _("All Products or Services."),
				},
			]
		},
		{
			"label": _("Tools"),
			"icon": "icon-wrench",
			"items": [
				{
					"type": "doctype",
					"name": "SMS Center",
					"description":_("Send mass SMS to your contacts"),
				},
			]
		},
		{
			"label": _("Setup"),
			"icon": "icon-cog",
			"items": [
				{
					"type": "doctype",
					"name": "Selling Settings",
					"description": _("Default settings for selling transactions.")
				},
				{
					"type": "doctype",
					"name": "Campaign",
					"description": _("Sales campaigns."),
				},
				{
					"type": "page",
					"label": _("Customer Group"),
					"name": "Sales Browser",
					"icon": "icon-sitemap",
					"link": "Sales Browser/Customer Group",
					"description": _("Manage Customer Group Tree."),
					"doctype": "Customer Group",
				},
				{
					"type": "page",
					"label": _("Territory"),
					"name": "Sales Browser",
					"icon": "icon-sitemap",
					"link": "Sales Browser/Territory",
					"description": _("Manage Territory Tree."),
					"doctype": "Territory",
				},
				{
					"type": "page",
					"label": _("Sales Person"),
					"name": "Sales Browser",
					"icon": "icon-sitemap",
					"link": "Sales Browser/Sales Person",
					"description": _("Manage Sales Person Tree."),
					"doctype": "Sales Person",
				},
				{
					"type": "page",
					"name": "Sales Browser",
					"icon": "icon-sitemap",
					"label": _("Item Group Tree"),
					"link": "Sales Browser/Item Group",
					"description": _("Tree of Item Groups."),
					"doctype": "Item Group",
				},
				{
					"type": "doctype",
					"name":"Terms and Conditions",
					"label": _("Terms and Conditions Template"),
					"description": _("Template of terms or contract.")
				},
				{
					"type": "doctype",
					"name": "Sales Taxes and Charges Master",
					"description": _("Tax template for selling transactions.")
				},
				{
					"type": "doctype",
					"name": "Shipping Rule",
					"description": _("Rules for adding shipping costs.")
				},
				{
					"type": "doctype",
					"name": "Price List",
					"description": _("Price List master.")
				},
				{
					"type": "doctype",
					"name": "Item Price",
					"description": _("Multiple Item prices."),
					"route": "Report/Item Price"
				},
				{
					"type": "doctype",
					"name": "Pricing Rule",
					"description": _("Rules for applying pricing and discount.")
				},
				{
					"type": "doctype",
					"name": "Sales BOM",
					"description": _("Bundle items at time of sale."),
				},
				{
					"type": "doctype",
					"name": "Sales Email Settings",
					"description": _("Setup incoming server for sales email id. (e.g. sales@example.com)")
				},
				{
					"type": "doctype",
					"name": "Industry Type",
					"description": _("Track Leads by Industry Type.")
				},
			]
		},
		{
			"label": _("Main Reports"),
			"icon": "icon-table",
			"items": [
				{
					"type": "page",
					"name": "sales-analytics",
					"label": _("Sales Analytics"),
					"icon": "icon-bar-chart",
				},
				{
					"type": "page",
					"name": "sales-funnel",
					"label": _("Sales Funnel"),
					"icon": "icon-bar-chart",
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Customer Acquisition and Loyalty",
					"doctype": "Customer",
					"icon": "icon-bar-chart",
				},
			]
		},
		{
			"label": _("Standard Reports"),
			"icon": "icon-list",
			"items": [
				{
					"type": "report",
					"is_query_report": True,
					"name": "Lead Details",
					"doctype": "Lead"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Customer Addresses And Contacts",
					"doctype": "Contact"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Ordered Items To Be Delivered",
					"doctype": "Sales Order"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Sales Person-wise Transaction Summary",
					"doctype": "Sales Order"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Item-wise Sales History",
					"doctype": "Item"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Territory Target Variance (Item Group-Wise)",
					"route": "query-report/Territory Target Variance Item Group-Wise",
					"doctype": "Territory"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Sales Person Target Variance (Item Group-Wise)",
					"route": "query-report/Sales Person Target Variance Item Group-Wise",
					"doctype": "Sales Person",
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Customers Not Buying Since Long Time",
					"doctype": "Sales Order"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Quotation Trend",
					"doctype": "Quotation"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Sales Order Trends",
					"doctype": "Sales Order"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Available Stock for Packing Items",
					"doctype": "Item",
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Pending SO Items For Purchase Request",
					"doctype": "Sales Order"
				},
			]
		},
	]

########NEW FILE########
__FILENAME__ = stock
from frappe import _

def get_data():
	return [
		{
			"label": _("Documents"),
			"icon": "icon-star",
			"items": [
				{
					"type": "doctype",
					"name": "Material Request",
					"description": _("Requests for items."),
				},
				{
					"type": "doctype",
					"name": "Stock Entry",
					"description": _("Record item movement."),
				},
				{
					"type": "doctype",
					"name": "Delivery Note",
					"description": _("Shipments to customers."),
				},
				{
					"type": "doctype",
					"name": "Purchase Receipt",
					"description": _("Goods received from Suppliers."),
				},
				{
					"type": "doctype",
					"name": "Item",
					"description": _("All Products or Services."),
				},
				{
					"type": "doctype",
					"name": "Warehouse",
					"description": _("Where items are stored."),
				},
				{
					"type": "doctype",
					"name": "Serial No",
					"description": _("Single unit of an Item."),
				},
				{
					"type": "doctype",
					"name": "Batch",
					"description": _("Batch (lot) of an Item."),
				},
			]
		},
		{
			"label": _("Tools"),
			"icon": "icon-wrench",
			"items": [
				{
					"type": "doctype",
					"name": "Stock Reconciliation",
					"description": _("Upload stock balance via csv.")
				},
				{
					"type": "doctype",
					"name": "Installation Note",
					"description": _("Installation record for a Serial No.")
				},
				{
					"type": "doctype",
					"name": "Packing Slip",
					"description": _("Split Delivery Note into packages.")
				},
				{
					"type": "doctype",
					"name": "Quality Inspection",
					"description": _("Incoming quality inspection.")
				},
				{
					"type": "doctype",
					"name": "Landed Cost Wizard",
					"description": _("Distribute transport overhead across items."),
				},
				{
					"type": "doctype",
					"name": "Stock UOM Replace Utility",
					"description": _("Change UOM for an Item."),
				},
			]
		},
		{
			"label": _("Setup"),
			"icon": "icon-cog",
			"items": [
				{
					"type": "doctype",
					"name": "Stock Settings",
					"description": _("Default settings for stock transactions.")
				},
				{
					"type": "page",
					"name": "Sales Browser",
					"icon": "icon-sitemap",
					"label": _("Item Group Tree"),
					"link": "Sales Browser/Item Group",
					"description": _("Tree of Item Groups."),
					"doctype": "Item Group",
				},
				{
					"type": "doctype",
					"name": "UOM",
					"label": _("Unit of Measure") + " (UOM)",
					"description": _("e.g. Kg, Unit, Nos, m")
				},
				{
					"type": "doctype",
					"name": "Warehouse",
					"description": _("Warehouses.")
				},
				{
					"type": "doctype",
					"name": "Brand",
					"description": _("Brand master.")
				},
				{
					"type": "doctype",
					"name": "Price List",
					"description": _("Price List master.")
				},
				{
					"type": "doctype",
					"name": "Item Price",
					"description": _("Multiple Item prices."),
					"route": "Report/Item Price"
				},
			]
		},
		{
			"label": _("Main Reports"),
			"icon": "icon-table",
			"items": [
				{
					"type": "report",
					"is_query_report": True,
					"name": "Stock Ledger",
					"doctype": "Item",
				},
				{
					"type": "page",
					"name": "stock-balance",
					"label": _("Stock Balance"),
					"icon": "icon-table",
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Stock Projected Qty",
					"doctype": "Item",
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Stock Ageing",
					"doctype": "Item",
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Item-wise Price List Rate",
					"doctype": "Item Price",
				},
				{
					"type": "page",
					"name": "stock-analytics",
					"label": _("Stock Analytics"),
					"icon": "icon-bar-chart"
				},
			]
		},
		{
			"label": _("Standard Reports"),
			"icon": "icon-list",
			"items": [
				{
					"type": "report",
					"is_query_report": True,
					"name": "Ordered Items To Be Delivered",
					"doctype": "Delivery Note"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Purchase Order Items To Be Received",
					"doctype": "Purchase Receipt"
				},
				{
					"type": "report",
					"name": "Item Shortage Report",
					"route": "Report/Bin/Item Shortage Report",
					"doctype": "Purchase Receipt"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Serial No Service Contract Expiry",
					"doctype": "Serial No"
				},
				{
					"type": "report",
					"name": "Serial No Status",
					"doctype": "Serial No"
				},
				{
					"type": "report",
					"name": "Serial No Warranty Expiry",
					"doctype": "Serial No"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Purchase In Transit",
					"doctype": "Purchase Order"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Requested Items To Be Transferred",
					"doctype": "Material Request"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Batch-Wise Balance History",
					"doctype": "Batch"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Warehouse-Wise Stock Balance",
					"doctype": "Warehouse"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Item Prices",
					"doctype": "Price List"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Itemwise Recommended Reorder Level",
					"doctype": "Item"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Delivery Note Trends",
					"doctype": "Delivery Note"
				},
				{
					"type": "report",
					"is_query_report": True,
					"name": "Purchase Receipt Trends",
					"doctype": "Purchase Receipt"
				},
			]
		},
	]

########NEW FILE########
__FILENAME__ = support
from frappe import _

def get_data():
	return [
		{
			"label": _("Documents"),
			"icon": "icon-star",
			"items": [
				{
					"type": "doctype",
					"name": "Support Ticket",
					"description": _("Support queries from customers."),
				},
				{
					"type": "doctype",
					"name": "Customer Issue",
					"description": _("Customer Issue against Serial No."),
				},
				{
					"type": "doctype",
					"name": "Maintenance Schedule",
					"description": _("Plan for maintenance visits."),
				},
				{
					"type": "doctype",
					"name": "Maintenance Visit",
					"description": _("Visit report for maintenance call."),
				},
				{
					"type": "doctype",
					"name": "Newsletter",
					"description": _("Newsletters to contacts, leads."),
				},
				{
					"type": "doctype",
					"name": "Communication",
					"description": _("Communication log."),
				},
				{
					"type": "doctype",
					"name": "Serial No",
					"description": _("Single unit of an Item."),
				},
			]
		},
		{
			"label": _("Setup"),
			"icon": "icon-cog",
			"items": [
				{
					"type": "doctype",
					"name": "Support Email Settings",
					"description": _("Setup incoming server for support email id. (e.g. support@example.com)")
				},
			]
		},
		{
			"label": _("Standard Reports"),
			"icon": "icon-list",
			"items": [
				{
					"type": "page",
					"name": "support-analytics",
					"label": _("Support Analytics"),
					"icon": "icon-bar-chart"
				},
				{
					"type": "report",
					"name": "Maintenance Schedules",
					"is_query_report": True,
					"doctype": "Maintenance Schedule"
				},
			]
		},
	]

########NEW FILE########
__FILENAME__ = party_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils.nestedset import NestedSet

class PartyType(NestedSet):
	nsm_parent_field = 'parent_party_type';

########NEW FILE########
__FILENAME__ = accounts_controller
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _, throw
from frappe.utils import flt, cint, today
from erpnext.setup.utils import get_company_currency
from erpnext.accounts.utils import get_fiscal_year, validate_fiscal_year
from erpnext.utilities.transaction_base import TransactionBase
import json

class AccountsController(TransactionBase):
	def validate(self):
		self.set_missing_values(for_validate=True)
		self.validate_date_with_fiscal_year()
		if self.meta.get_field("currency"):
			self.calculate_taxes_and_totals()
			self.validate_value("grand_total", ">=", 0)
			self.set_total_in_words()

		self.validate_for_freezed_account()

	def set_missing_values(self, for_validate=False):
		for fieldname in ["posting_date", "transaction_date"]:
			if not self.get(fieldname) and self.meta.get_field(fieldname):
				self.set(fieldname, today())
				if not self.fiscal_year:
					self.fiscal_year = get_fiscal_year(self.get(fieldname))[0]
				break

	def validate_date_with_fiscal_year(self):
		if self.meta.get_field("fiscal_year") :
			date_field = ""
			if self.meta.get_field("posting_date"):
				date_field = "posting_date"
			elif self.meta.get_field("transaction_date"):
				date_field = "transaction_date"

			if date_field and self.get(date_field):
				validate_fiscal_year(self.get(date_field), self.fiscal_year,
					label=self.meta.get_label(date_field))

	def validate_for_freezed_account(self):
		for fieldname in ["customer", "supplier"]:
			if self.meta.get_field(fieldname) and self.get(fieldname):
				accounts = frappe.db.get_values("Account",
					{"master_type": fieldname.title(), "master_name": self.get(fieldname),
					"company": self.company}, "name")
				if accounts:
					from erpnext.accounts.doctype.gl_entry.gl_entry import validate_frozen_account
					for account in accounts:
						validate_frozen_account(account[0])

	def set_price_list_currency(self, buying_or_selling):
		if self.meta.get_field("currency"):
			company_currency = get_company_currency(self.company)

			# price list part
			fieldname = "selling_price_list" if buying_or_selling.lower() == "selling" \
				else "buying_price_list"
			if self.meta.get_field(fieldname) and self.get(fieldname):
				self.price_list_currency = frappe.db.get_value("Price List",
					self.get(fieldname), "currency")

				if self.price_list_currency == company_currency:
					self.plc_conversion_rate = 1.0

				elif not self.plc_conversion_rate:
					self.plc_conversion_rate = self.get_exchange_rate(
						self.price_list_currency, company_currency)

			# currency
			if not self.currency:
				self.currency = self.price_list_currency
				self.conversion_rate = self.plc_conversion_rate
			elif self.currency == company_currency:
				self.conversion_rate = 1.0
			elif not self.conversion_rate:
				self.conversion_rate = self.get_exchange_rate(self.currency,
					company_currency)

	def get_exchange_rate(self, from_currency, to_currency):
		exchange = "%s-%s" % (from_currency, to_currency)
		return flt(frappe.db.get_value("Currency Exchange", exchange, "exchange_rate"))

	def set_missing_item_details(self):
		"""set missing item values"""
		from erpnext.stock.get_item_details import get_item_details
		if hasattr(self, "fname"):
			parent_dict = {"doctype": self.doctype}
			for fieldname in self.meta.get_valid_columns():
				parent_dict[fieldname] = self.get(fieldname)

			for item in self.get(self.fname):
				if item.get("item_code"):
					args = item.as_dict()
					args.update(parent_dict)
					ret = get_item_details(args)
					for fieldname, value in ret.items():
						if item.meta.get_field(fieldname) and \
							item.get(fieldname) is None and value is not None:
								item.set(fieldname, value)

	def set_taxes(self, tax_parentfield, tax_master_field):
		if not self.meta.get_field(tax_parentfield):
			return

		tax_master_doctype = self.meta.get_field(tax_master_field).options

		if not self.get(tax_parentfield):
			if not self.get(tax_master_field):
				# get the default tax master
				self.set(tax_master_field, frappe.db.get_value(tax_master_doctype, {"is_default": 1}))

			self.append_taxes_from_master(tax_parentfield, tax_master_field, tax_master_doctype)

	def append_taxes_from_master(self, tax_parentfield, tax_master_field, tax_master_doctype=None):
		if self.get(tax_master_field):
			if not tax_master_doctype:
				tax_master_doctype = self.meta.get_field(tax_master_field).options

			self.extend(tax_parentfield,
				get_taxes_and_charges(tax_master_doctype, self.get(tax_master_field), tax_parentfield))

	def set_other_charges(self):
		self.set("other_charges", [])
		self.set_taxes("other_charges", "taxes_and_charges")

	def calculate_taxes_and_totals(self):
		self.discount_amount_applied = False
		self._calculate_taxes_and_totals()

		if self.meta.get_field("discount_amount"):
			self.apply_discount_amount()

	def _calculate_taxes_and_totals(self):
		# validate conversion rate
		company_currency = get_company_currency(self.company)
		if not self.currency or self.currency == company_currency:
			self.currency = company_currency
			self.conversion_rate = 1.0
		else:
			from erpnext.setup.doctype.currency.currency import validate_conversion_rate
			validate_conversion_rate(self.currency, self.conversion_rate,
				self.meta.get_label("conversion_rate"), self.company)

		self.conversion_rate = flt(self.conversion_rate)
		self.item_doclist = self.get(self.fname)
		self.tax_doclist = self.get(self.other_fname)

		self.calculate_item_values()
		self.initialize_taxes()

		if hasattr(self, "determine_exclusive_rate"):
			self.determine_exclusive_rate()

		self.calculate_net_total()
		self.calculate_taxes()
		self.calculate_totals()
		self._cleanup()

	def initialize_taxes(self):
		for tax in self.tax_doclist:
			tax.item_wise_tax_detail = {}
			tax_fields = ["total", "tax_amount_after_discount_amount",
				"tax_amount_for_current_item", "grand_total_for_current_item",
				"tax_fraction_for_current_item", "grand_total_fraction_for_current_item"]

			if not self.discount_amount_applied:
				tax_fields.append("tax_amount")

			for fieldname in tax_fields:
				tax.set(fieldname, 0.0)

			self.validate_on_previous_row(tax)
			self.validate_inclusive_tax(tax)
			self.round_floats_in(tax)

	def validate_on_previous_row(self, tax):
		"""
			validate if a valid row id is mentioned in case of
			On Previous Row Amount and On Previous Row Total
		"""
		if tax.charge_type in ["On Previous Row Amount", "On Previous Row Total"] and \
				(not tax.row_id or cint(tax.row_id) >= tax.idx):
			throw(_("Please specify a valid Row ID for {0} in row {1}").format(_(tax.doctype), tax.idx))

	def validate_inclusive_tax(self, tax):
		def _on_previous_row_error(row_range):
			throw(_("To include tax in row {0} in Item rate, taxes in rows {1} must also be included").format(tax.idx,
				row_range))

		if cint(getattr(tax, "included_in_print_rate", None)):
			if tax.charge_type == "Actual":
				# inclusive tax cannot be of type Actual
				throw(_("Charge of type 'Actual' in row {0} cannot be included in Item Rate").format(tax.idx))
			elif tax.charge_type == "On Previous Row Amount" and \
					not cint(self.tax_doclist[cint(tax.row_id) - 1].included_in_print_rate):
				# referred row should also be inclusive
				_on_previous_row_error(tax.row_id)
			elif tax.charge_type == "On Previous Row Total" and \
					not all([cint(t.included_in_print_rate) for t in self.tax_doclist[:cint(tax.row_id) - 1]]):
				# all rows about the reffered tax should be inclusive
				_on_previous_row_error("1 - %d" % (tax.row_id,))

	def calculate_taxes(self):
		# maintain actual tax rate based on idx
		actual_tax_dict = dict([[tax.idx, tax.rate] for tax in self.tax_doclist
			if tax.charge_type == "Actual"])

		for n, item in enumerate(self.item_doclist):
			item_tax_map = self._load_item_tax_rate(item.item_tax_rate)

			for i, tax in enumerate(self.tax_doclist):
				# tax_amount represents the amount of tax for the current step
				current_tax_amount = self.get_current_tax_amount(item, tax, item_tax_map)

				# Adjust divisional loss to the last item
				if tax.charge_type == "Actual":
					actual_tax_dict[tax.idx] -= current_tax_amount
					if n == len(self.item_doclist) - 1:
						current_tax_amount += actual_tax_dict[tax.idx]

				# store tax_amount for current item as it will be used for
				# charge type = 'On Previous Row Amount'
				tax.tax_amount_for_current_item = current_tax_amount

				# accumulate tax amount into tax.tax_amount
				if not self.discount_amount_applied:
					tax.tax_amount += current_tax_amount

				tax.tax_amount_after_discount_amount += current_tax_amount

				if getattr(tax, "category", None):
					# if just for valuation, do not add the tax amount in total
					# hence, setting it as 0 for further steps
					current_tax_amount = 0.0 if (tax.category == "Valuation") \
						else current_tax_amount

					current_tax_amount *= -1.0 if (tax.add_deduct_tax == "Deduct") else 1.0

				# Calculate tax.total viz. grand total till that step
				# note: grand_total_for_current_item contains the contribution of
				# item's amount, previously applied tax and the current tax on that item
				if i==0:
					tax.grand_total_for_current_item = flt(item.base_amount + current_tax_amount,
						self.precision("total", tax))
				else:
					tax.grand_total_for_current_item = \
						flt(self.tax_doclist[i-1].grand_total_for_current_item +
							current_tax_amount, self.precision("total", tax))

				# in tax.total, accumulate grand total of each item
				tax.total += tax.grand_total_for_current_item

				# set precision in the last item iteration
				if n == len(self.item_doclist) - 1:
					self.round_off_totals(tax)

					# adjust Discount Amount loss in last tax iteration
					if i == (len(self.tax_doclist) - 1) and self.discount_amount_applied:
						self.adjust_discount_amount_loss(tax)

	def round_off_totals(self, tax):
		tax.total = flt(tax.total, self.precision("total", tax))
		tax.tax_amount = flt(tax.tax_amount, self.precision("tax_amount", tax))
		tax.tax_amount_after_discount_amount = flt(tax.tax_amount_after_discount_amount,
			self.precision("tax_amount", tax))

	def adjust_discount_amount_loss(self, tax):
		discount_amount_loss = self.grand_total - flt(self.discount_amount) - tax.total
		tax.tax_amount_after_discount_amount = flt(tax.tax_amount_after_discount_amount +
			discount_amount_loss, self.precision("tax_amount", tax))
		tax.total = flt(tax.total + discount_amount_loss, self.precision("total", tax))

	def get_current_tax_amount(self, item, tax, item_tax_map):
		tax_rate = self._get_tax_rate(tax, item_tax_map)
		current_tax_amount = 0.0

		if tax.charge_type == "Actual":
			# distribute the tax amount proportionally to each item row
			actual = flt(tax.rate, self.precision("tax_amount", tax))
			current_tax_amount = (self.net_total
				and ((item.base_amount / self.net_total) * actual)
				or 0)
		elif tax.charge_type == "On Net Total":
			current_tax_amount = (tax_rate / 100.0) * item.base_amount
		elif tax.charge_type == "On Previous Row Amount":
			current_tax_amount = (tax_rate / 100.0) * \
				self.tax_doclist[cint(tax.row_id) - 1].tax_amount_for_current_item
		elif tax.charge_type == "On Previous Row Total":
			current_tax_amount = (tax_rate / 100.0) * \
				self.tax_doclist[cint(tax.row_id) - 1].grand_total_for_current_item

		current_tax_amount = flt(current_tax_amount, self.precision("tax_amount", tax))

		# store tax breakup for each item
		key = item.item_code or item.item_name
		if tax.item_wise_tax_detail.get(key):
			item_wise_tax_amount = tax.item_wise_tax_detail[key][1] + current_tax_amount
			tax.item_wise_tax_detail[key] = [tax_rate,item_wise_tax_amount]
		else:
			tax.item_wise_tax_detail[key] = [tax_rate,current_tax_amount]

		return current_tax_amount

	def _load_item_tax_rate(self, item_tax_rate):
		return json.loads(item_tax_rate) if item_tax_rate else {}

	def _get_tax_rate(self, tax, item_tax_map):
		if item_tax_map.has_key(tax.account_head):
			return flt(item_tax_map.get(tax.account_head), self.precision("rate", tax))
		else:
			return tax.rate

	def _cleanup(self):
		for tax in self.tax_doclist:
			tax.item_wise_tax_detail = json.dumps(tax.item_wise_tax_detail, separators=(',', ':'))

	def _set_in_company_currency(self, item, print_field, base_field):
		"""set values in base currency"""
		value_in_company_currency = flt(self.conversion_rate *
			flt(item.get(print_field), self.precision(print_field, item)),
			self.precision(base_field, item))
		item.set(base_field, value_in_company_currency)

	def calculate_total_advance(self, parenttype, advance_parentfield):
		if self.doctype == parenttype and self.docstatus < 2:
			sum_of_allocated_amount = sum([flt(adv.allocated_amount, self.precision("allocated_amount", adv))
				for adv in self.get(advance_parentfield)])

			self.total_advance = flt(sum_of_allocated_amount, self.precision("total_advance"))

			self.calculate_outstanding_amount()

	def get_gl_dict(self, args):
		"""this method populates the common properties of a gl entry record"""
		gl_dict = frappe._dict({
			'company': self.company,
			'posting_date': self.posting_date,
			'voucher_type': self.doctype,
			'voucher_no': self.name,
			'aging_date': self.get("aging_date") or self.posting_date,
			'remarks': self.get("remarks"),
			'fiscal_year': self.fiscal_year,
			'debit': 0,
			'credit': 0,
			'is_opening': self.get("is_opening") or "No",
		})
		gl_dict.update(args)
		return gl_dict

	def clear_unallocated_advances(self, childtype, parentfield):
		self.set(parentfield, self.get(parentfield, {"allocated_amount": ["not in", [0, None, ""]]}))

		frappe.db.sql("""delete from `tab%s` where parentfield=%s and parent = %s
			and ifnull(allocated_amount, 0) = 0""" % (childtype, '%s', '%s'), (parentfield, self.name))

	def get_advances(self, account_head, child_doctype, parentfield, dr_or_cr):
		res = frappe.db.sql("""
			select
				t1.name as jv_no, t1.remark, t2.%s as amount, t2.name as jv_detail_no
			from
				`tabJournal Voucher` t1, `tabJournal Voucher Detail` t2
			where
				t1.name = t2.parent and t2.account = %s and t2.is_advance = 'Yes' and t1.docstatus = 1
				and ifnull(t2.against_voucher, '')  = ''
				and ifnull(t2.against_invoice, '')  = ''
				and ifnull(t2.against_jv, '')  = ''
			order by t1.posting_date""" %
			(dr_or_cr, '%s'), account_head, as_dict=1)

		self.set(parentfield, [])
		for d in res:
			self.append(parentfield, {
				"doctype": child_doctype,
				"journal_voucher": d.jv_no,
				"jv_detail_no": d.jv_detail_no,
				"remarks": d.remark,
				"advance_amount": flt(d.amount),
				"allocate_amount": 0
			})

	def validate_multiple_billing(self, ref_dt, item_ref_dn, based_on, parentfield):
		from erpnext.controllers.status_updater import get_tolerance_for
		item_tolerance = {}
		global_tolerance = None

		for item in self.get("entries"):
			if item.get(item_ref_dn):
				ref_amt = flt(frappe.db.get_value(ref_dt + " Item",
					item.get(item_ref_dn), based_on), self.precision(based_on, item))
				if not ref_amt:
					frappe.msgprint(_("Warning: System will not check overbilling since amount for Item {0} in {1} is zero").format(item.item_code, ref_dt))
				else:
					already_billed = frappe.db.sql("""select sum(%s) from `tab%s`
						where %s=%s and docstatus=1 and parent != %s""" %
						(based_on, self.tname, item_ref_dn, '%s', '%s'),
						(item.get(item_ref_dn), self.name))[0][0]

					total_billed_amt = flt(flt(already_billed) + flt(item.get(based_on)),
						self.precision(based_on, item))

					tolerance, item_tolerance, global_tolerance = get_tolerance_for(item.item_code,
						item_tolerance, global_tolerance)

					max_allowed_amt = flt(ref_amt * (100 + tolerance) / 100)

					if total_billed_amt - max_allowed_amt > 0.01:
						reduce_by = total_billed_amt - max_allowed_amt
						frappe.throw(_("Cannot overbill for Item {0} in row {0} more than {1}. To allow overbilling, please set in 'Setup' > 'Global Defaults'").format(item.item_code, item.row, max_allowed_amt))

	def get_company_default(self, fieldname):
		from erpnext.accounts.utils import get_company_default
		return get_company_default(self.company, fieldname)

	def get_stock_items(self):
		stock_items = []
		item_codes = list(set(item.item_code for item in
			self.get(self.fname)))
		if item_codes:
			stock_items = [r[0] for r in frappe.db.sql("""select name
				from `tabItem` where name in (%s) and is_stock_item='Yes'""" % \
				(", ".join((["%s"]*len(item_codes))),), item_codes)]

		return stock_items

	@property
	def company_abbr(self):
		if not hasattr(self, "_abbr"):
			self._abbr = frappe.db.get_value("Company", self.company, "abbr")

		return self._abbr

	def check_credit_limit(self, account):
		total_outstanding = frappe.db.sql("""
			select sum(ifnull(debit, 0)) - sum(ifnull(credit, 0))
			from `tabGL Entry` where account = %s""", account)

		total_outstanding = total_outstanding[0][0] if total_outstanding else 0
		if total_outstanding:
			frappe.get_doc('Account', account).check_credit_limit(total_outstanding)


@frappe.whitelist()
def get_tax_rate(account_head):
	return frappe.db.get_value("Account", account_head, "tax_rate")

@frappe.whitelist()
def get_taxes_and_charges(master_doctype, master_name, tax_parentfield):
	from frappe.model import default_fields
	tax_master = frappe.get_doc(master_doctype, master_name)

	taxes_and_charges = []
	for i, tax in enumerate(tax_master.get(tax_parentfield)):
		tax = tax.as_dict()

		for fieldname in default_fields:
			if fieldname in tax:
				del tax[fieldname]

		taxes_and_charges.append(tax)

	return taxes_and_charges

########NEW FILE########
__FILENAME__ = buying_controller
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _, msgprint
from frappe.utils import flt, _round
from erpnext.setup.utils import get_company_currency
from erpnext.accounts.party import get_party_details

from erpnext.controllers.stock_controller import StockController

class BuyingController(StockController):
	def validate(self):
		super(BuyingController, self).validate()
		if getattr(self, "supplier", None) and not self.supplier_name:
			self.supplier_name = frappe.db.get_value("Supplier",
				self.supplier, "supplier_name")
		self.is_item_table_empty()
		self.validate_stock_or_nonstock_items()
		self.validate_warehouse()

	def set_missing_values(self, for_validate=False):
		super(BuyingController, self).set_missing_values(for_validate)

		self.set_supplier_from_item_default()
		self.set_price_list_currency("Buying")

		# set contact and address details for supplier, if they are not mentioned
		if getattr(self, "supplier", None):
			self.update_if_missing(get_party_details(self.supplier, party_type="Supplier"))

		self.set_missing_item_details()
		if self.get("__islocal"):
			self.set_taxes("other_charges", "taxes_and_charges")

	def set_supplier_from_item_default(self):
		if self.meta.get_field("supplier") and not self.supplier:
			for d in self.get(self.fname):
				supplier = frappe.db.get_value("Item", d.item_code, "default_supplier")
				if supplier:
					self.supplier = supplier
					break

	def validate_warehouse(self):
		from erpnext.stock.utils import validate_warehouse_company

		warehouses = list(set([d.warehouse for d in
			self.get(self.fname) if getattr(d, "warehouse", None)]))

		for w in warehouses:
			validate_warehouse_company(w, self.company)

	def validate_stock_or_nonstock_items(self):
		if not self.get_stock_items():
			tax_for_valuation = [d.account_head for d in
				self.get("other_charges")
				if d.category in ["Valuation", "Valuation and Total"]]
			if tax_for_valuation:
				frappe.throw(_("Tax Category can not be 'Valuation' or 'Valuation and Total' as all items are non-stock items"))

	def set_total_in_words(self):
		from frappe.utils import money_in_words
		company_currency = get_company_currency(self.company)
		if self.meta.get_field("in_words"):
			self.in_words = money_in_words(self.grand_total, company_currency)
		if self.meta.get_field("in_words_import"):
			self.in_words_import = money_in_words(self.grand_total_import,
		 		self.currency)

	def calculate_taxes_and_totals(self):
		self.other_fname = "other_charges"
		super(BuyingController, self).calculate_taxes_and_totals()
		self.calculate_total_advance("Purchase Invoice", "advance_allocation_details")

	def calculate_item_values(self):
		for item in self.item_doclist:
			self.round_floats_in(item)

			if item.discount_percentage == 100.0:
				item.rate = 0.0
			elif not item.rate:
				item.rate = flt(item.price_list_rate * (1.0 - (item.discount_percentage / 100.0)),
					self.precision("rate", item))

			item.amount = flt(item.rate * item.qty,
				self.precision("amount", item))
			item.item_tax_amount = 0.0;

			self._set_in_company_currency(item, "amount", "base_amount")
			self._set_in_company_currency(item, "price_list_rate", "base_price_list_rate")
			self._set_in_company_currency(item, "rate", "base_rate")


	def calculate_net_total(self):
		self.net_total = self.net_total_import = 0.0

		for item in self.item_doclist:
			self.net_total += item.base_amount
			self.net_total_import += item.amount

		self.round_floats_in(self, ["net_total", "net_total_import"])

	def calculate_totals(self):
		self.grand_total = flt(self.tax_doclist[-1].total if self.tax_doclist
			else self.net_total, self.precision("grand_total"))
		self.grand_total_import = flt(self.grand_total / self.conversion_rate,
			self.precision("grand_total_import"))

		self.total_tax = flt(self.grand_total - self.net_total,
			self.precision("total_tax"))

		if self.meta.get_field("rounded_total"):
			self.rounded_total = _round(self.grand_total)

		if self.meta.get_field("rounded_total_import"):
			self.rounded_total_import = _round(self.grand_total_import)

		if self.meta.get_field("other_charges_added"):
			self.other_charges_added = flt(sum([flt(d.tax_amount) for d in self.tax_doclist
				if d.add_deduct_tax=="Add" and d.category in ["Valuation and Total", "Total"]]),
				self.precision("other_charges_added"))

		if self.meta.get_field("other_charges_deducted"):
			self.other_charges_deducted = flt(sum([flt(d.tax_amount) for d in self.tax_doclist
				if d.add_deduct_tax=="Deduct" and d.category in ["Valuation and Total", "Total"]]),
				self.precision("other_charges_deducted"))

		if self.meta.get_field("other_charges_added_import"):
			self.other_charges_added_import = flt(self.other_charges_added /
				self.conversion_rate, self.precision("other_charges_added_import"))

		if self.meta.get_field("other_charges_deducted_import"):
			self.other_charges_deducted_import = flt(self.other_charges_deducted /
				self.conversion_rate, self.precision("other_charges_deducted_import"))

	def calculate_outstanding_amount(self):
		if self.doctype == "Purchase Invoice" and self.docstatus == 0:
			self.total_advance = flt(self.total_advance,
				self.precision("total_advance"))
			self.total_amount_to_pay = flt(self.grand_total - flt(self.write_off_amount,
				self.precision("write_off_amount")), self.precision("total_amount_to_pay"))
			self.outstanding_amount = flt(self.total_amount_to_pay - self.total_advance,
				self.precision("outstanding_amount"))

	# update valuation rate
	def update_valuation_rate(self, parentfield):
		"""
			item_tax_amount is the total tax amount applied on that item
			stored for valuation

			TODO: rename item_tax_amount to valuation_tax_amount
		"""
		stock_items = self.get_stock_items()

		stock_items_qty, stock_items_amount = 0, 0
		last_stock_item_idx = 1
		for d in self.get(parentfield):
			if d.item_code and d.item_code in stock_items:
				stock_items_qty += flt(d.qty)
				stock_items_amount += flt(d.base_amount)
				last_stock_item_idx = d.idx

		total_valuation_amount = sum([flt(d.tax_amount) for d in
			self.get("other_charges")
			if d.category in ["Valuation", "Valuation and Total"]])


		valuation_amount_adjustment = total_valuation_amount
		for i, item in enumerate(self.get(parentfield)):
			if item.item_code and item.qty and item.item_code in stock_items:
				item_proportion = flt(item.base_amount) / stock_items_amount if stock_items_amount \
					else flt(item.qty) / stock_items_qty

				if i == (last_stock_item_idx - 1):
					item.item_tax_amount = flt(valuation_amount_adjustment,
						self.precision("item_tax_amount", item))
				else:
					item.item_tax_amount = flt(item_proportion * total_valuation_amount,
						self.precision("item_tax_amount", item))
					valuation_amount_adjustment -= item.item_tax_amount

				self.round_floats_in(item)

				item.conversion_factor = item.conversion_factor or flt(frappe.db.get_value(
					"UOM Conversion Detail", {"parent": item.item_code, "uom": item.uom},
					"conversion_factor")) or 1
				qty_in_stock_uom = flt(item.qty * item.conversion_factor)
				rm_supp_cost = item.rm_supp_cost if self.doctype=="Purchase Receipt" else 0.0
				item.valuation_rate = ((item.base_amount + item.item_tax_amount + rm_supp_cost)
					/ qty_in_stock_uom)
			else:
				item.valuation_rate = 0.0

	def validate_for_subcontracting(self):
		if not self.is_subcontracted and self.sub_contracted_items:
			frappe.throw(_("Please enter 'Is Subcontracted' as Yes or No"))

		if self.doctype == "Purchase Receipt" and self.is_subcontracted=="Yes" \
			and not self.supplier_warehouse:
				frappe.throw(_("Supplier Warehouse mandatory for sub-contracted Purchase Receipt"))

	def create_raw_materials_supplied(self, raw_material_table):
		if self.is_subcontracted=="Yes":
			parent_items = []
			rm_supplied_idx = 0
			for item in self.get(self.fname):
				if self.doctype == "Purchase Receipt":
					item.rm_supp_cost = 0.0
				if item.item_code in self.sub_contracted_items:
					self.update_raw_materials_supplied(item, raw_material_table, rm_supplied_idx)

					if [item.item_code, item.name] not in parent_items:
						parent_items.append([item.item_code, item.name])

			self.cleanup_raw_materials_supplied(parent_items, raw_material_table)

		elif self.doctype == "Purchase Receipt":
			for item in self.get(self.fname):
				item.rm_supp_cost = 0.0

	def update_raw_materials_supplied(self, item, raw_material_table, rm_supplied_idx):
		bom_items = self.get_items_from_default_bom(item.item_code)
		raw_materials_cost = 0

		for bom_item in bom_items:
			# check if exists
			exists = 0
			for d in self.get(raw_material_table):
				if d.main_item_code == item.item_code and d.rm_item_code == bom_item.item_code \
					and d.reference_name == item.name:
						rm, exists = d, 1
						break

			if not exists:
				rm = self.append(raw_material_table, {})

			required_qty = flt(bom_item.qty_consumed_per_unit) * flt(item.qty) * flt(item.conversion_factor)
			rm.reference_name = item.name
			rm.bom_detail_no = bom_item.name
			rm.main_item_code = item.item_code
			rm.rm_item_code = bom_item.item_code
			rm.stock_uom = bom_item.stock_uom
			rm.required_qty = required_qty

			rm.conversion_factor = item.conversion_factor
			rm.rate = bom_item.rate
			rm.amount = required_qty * flt(bom_item.rate)
			rm.idx = rm_supplied_idx

			if self.doctype == "Purchase Receipt":
				rm.consumed_qty = required_qty
				rm.description = bom_item.description
				if item.batch_no and not rm.batch_no:
					rm.batch_no = item.batch_no

			rm_supplied_idx += 1

			raw_materials_cost += required_qty * flt(bom_item.rate)

		if self.doctype == "Purchase Receipt":
			item.rm_supp_cost = raw_materials_cost

	def cleanup_raw_materials_supplied(self, parent_items, raw_material_table):
		"""Remove all those child items which are no longer present in main item table"""
		delete_list = []
		for d in self.get(raw_material_table):
			if [d.main_item_code, d.reference_name] not in parent_items:
				# mark for deletion from doclist
				delete_list.append([d.main_item_code, d.reference_name])

		# delete from doclist
		if delete_list:
			rm_supplied_details = self.get(raw_material_table)
			self.set(raw_material_table, [])
			for d in rm_supplied_details:
				if d not in delete_list:
					self.append(raw_material_table, d)

	def get_items_from_default_bom(self, item_code):
		bom_items = frappe.db.sql("""select t2.item_code, t2.qty_consumed_per_unit,
			t2.rate, t2.stock_uom, t2.name, t2.description
			from `tabBOM` t1, `tabBOM Item` t2
			where t2.parent = t1.name and t1.item = %s and t1.is_default = 1
			and t1.docstatus = 1 and t1.is_active = 1""", item_code, as_dict=1)
		if not bom_items:
			msgprint(_("No default BOM exists for Item {0}").format(item_code), raise_exception=1)

		return bom_items

	@property
	def sub_contracted_items(self):
		if not hasattr(self, "_sub_contracted_items"):
			self._sub_contracted_items = []
			item_codes = list(set(item.item_code for item in
				self.get(self.fname)))
			if item_codes:
				self._sub_contracted_items = [r[0] for r in frappe.db.sql("""select name
					from `tabItem` where name in (%s) and is_sub_contracted_item='Yes'""" % \
					(", ".join((["%s"]*len(item_codes))),), item_codes)]

		return self._sub_contracted_items

	@property
	def purchase_items(self):
		if not hasattr(self, "_purchase_items"):
			self._purchase_items = []
			item_codes = list(set(item.item_code for item in
				self.get(self.fname)))
			if item_codes:
				self._purchase_items = [r[0] for r in frappe.db.sql("""select name
					from `tabItem` where name in (%s) and is_purchase_item='Yes'""" % \
					(", ".join((["%s"]*len(item_codes))),), item_codes)]

		return self._purchase_items


	def is_item_table_empty(self):
		if not len(self.get(self.fname)):
			frappe.throw(_("Item table can not be blank"))

########NEW FILE########
__FILENAME__ = queries
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.widgets.reportview import get_match_cond
from frappe.model.db_query import DatabaseQuery

def get_filters_cond(doctype, filters, conditions):
	if filters:
		if isinstance(filters, dict):
			filters = filters.items()
			flt = []
			for f in filters:
				if isinstance(f[1], basestring) and f[1][0] == '!':
					flt.append([doctype, f[0], '!=', f[1][1:]])
				else:
					flt.append([doctype, f[0], '=', f[1]])

		query = DatabaseQuery(doctype)
		query.filters = flt
		query.conditions = conditions
		query.build_filter_conditions(flt, conditions)

		cond = ' and ' + ' and '.join(query.conditions)
	else:
		cond = ''
	return cond

 # searches for active employees
def employee_query(doctype, txt, searchfield, start, page_len, filters):
	return frappe.db.sql("""select name, employee_name from `tabEmployee`
		where status = 'Active'
			and docstatus < 2
			and (%(key)s like "%(txt)s"
				or employee_name like "%(txt)s")
			%(mcond)s
		order by
			if(locate("%(_txt)s", name), locate("%(_txt)s", name), 99999),
			if(locate("%(_txt)s", employee_name), locate("%(_txt)s", employee_name), 99999),
			name, employee_name
		limit %(start)s, %(page_len)s""" % {'key': searchfield, 'txt': "%%%s%%" % txt,
		'_txt': txt.replace("%", ""),
		'mcond':get_match_cond(doctype), 'start': start, 'page_len': page_len})

 # searches for leads which are not converted
def lead_query(doctype, txt, searchfield, start, page_len, filters):
	return frappe.db.sql("""select name, lead_name, company_name from `tabLead`
		where docstatus < 2
			and ifnull(status, '') != 'Converted'
			and (%(key)s like "%(txt)s"
				or lead_name like "%(txt)s"
				or company_name like "%(txt)s")
			%(mcond)s
		order by
			if(locate("%(_txt)s", name), locate("%(_txt)s", name), 99999),
			if(locate("%(_txt)s", lead_name), locate("%(_txt)s", lead_name), 99999),
			if(locate("%(_txt)s", company_name), locate("%(_txt)s", company_name), 99999),
			name, lead_name
		limit %(start)s, %(page_len)s""" % {'key': searchfield, 'txt': "%%%s%%" % txt,
		'_txt': txt.replace("%", ""),
		'mcond':get_match_cond(doctype), 'start': start, 'page_len': page_len})

 # searches for customer
def customer_query(doctype, txt, searchfield, start, page_len, filters):
	cust_master_name = frappe.defaults.get_user_default("cust_master_name")

	if cust_master_name == "Customer Name":
		fields = ["name", "customer_group", "territory"]
	else:
		fields = ["name", "customer_name", "customer_group", "territory"]

	fields = ", ".join(fields)

	return frappe.db.sql("""select %(field)s from `tabCustomer`
		where docstatus < 2
			and (%(key)s like "%(txt)s"
				or customer_name like "%(txt)s")
			%(mcond)s
		order by
			if(locate("%(_txt)s", name), locate("%(_txt)s", name), 99999),
			if(locate("%(_txt)s", customer_name), locate("%(_txt)s", customer_name), 99999),
			name, customer_name
		limit %(start)s, %(page_len)s""" % {'field': fields,'key': searchfield,
		'txt': "%%%s%%" % txt, '_txt': txt.replace("%", ""),
		'mcond':get_match_cond(doctype),
		'start': start, 'page_len': page_len})

# searches for supplier
def supplier_query(doctype, txt, searchfield, start, page_len, filters):
	supp_master_name = frappe.defaults.get_user_default("supp_master_name")
	if supp_master_name == "Supplier Name":
		fields = ["name", "supplier_type"]
	else:
		fields = ["name", "supplier_name", "supplier_type"]
	fields = ", ".join(fields)

	return frappe.db.sql("""select %(field)s from `tabSupplier`
		where docstatus < 2
			and (%(key)s like "%(txt)s"
				or supplier_name like "%(txt)s")
			%(mcond)s
		order by
			if(locate("%(_txt)s", name), locate("%(_txt)s", name), 99999),
			if(locate("%(_txt)s", supplier_name), locate("%(_txt)s", supplier_name), 99999),
			name, supplier_name
		limit %(start)s, %(page_len)s """ % {'field': fields,'key': searchfield,
		'txt': "%%%s%%" % txt, '_txt': txt.replace("%", ""),
		'mcond':get_match_cond(doctype), 'start': start,
		'page_len': page_len})

def tax_account_query(doctype, txt, searchfield, start, page_len, filters):
	tax_accounts = frappe.db.sql("""select name, parent_account	from tabAccount
		where tabAccount.docstatus!=2
			and account_type in (%s)
			and group_or_ledger = 'Ledger'
			and company = %s
			and `%s` LIKE %s
		limit %s, %s""" %
		(", ".join(['%s']*len(filters.get("account_type"))), "%s", searchfield, "%s", "%s", "%s"),
		tuple(filters.get("account_type") + [filters.get("company"), "%%%s%%" % txt,
			start, page_len]))
	if not tax_accounts:
		tax_accounts = frappe.db.sql("""select name, parent_account	from tabAccount
			where tabAccount.docstatus!=2 and group_or_ledger = 'Ledger'
				and company = %s and `%s` LIKE %s limit %s, %s"""
			% ("%s", searchfield, "%s", "%s", "%s"),
			(filters.get("company"), "%%%s%%" % txt, start, page_len))

	return tax_accounts

def item_query(doctype, txt, searchfield, start, page_len, filters):
	from frappe.utils import nowdate

	conditions = []

	return frappe.db.sql("""select tabItem.name,
		if(length(tabItem.item_name) > 40,
			concat(substr(tabItem.item_name, 1, 40), "..."), item_name) as item_name,
		if(length(tabItem.description) > 40, \
			concat(substr(tabItem.description, 1, 40), "..."), description) as decription
		from tabItem
		where tabItem.docstatus < 2
			and (ifnull(tabItem.end_of_life, '') = '' or tabItem.end_of_life > %(today)s)
			and (tabItem.`{key}` LIKE %(txt)s
				or tabItem.item_name LIKE %(txt)s)
			{fcond} {mcond}
		order by
			if(locate(%(_txt)s, name), locate(%(_txt)s, name), 99999),
			if(locate(%(_txt)s, item_name), locate(%(_txt)s, item_name), 99999),
			name, item_name
		limit %(start)s, %(page_len)s """.format(key=searchfield,
			fcond=get_filters_cond(doctype, filters, conditions),
			mcond=get_match_cond(doctype)),
			{
				"today": nowdate(),
				"txt": "%%%s%%" % txt,
				"_txt": txt.replace("%", ""),
				"start": start,
				"page_len": page_len
			})

def bom(doctype, txt, searchfield, start, page_len, filters):
	conditions = []

	return frappe.db.sql("""select tabBOM.name, tabBOM.item
		from tabBOM
		where tabBOM.docstatus=1
			and tabBOM.is_active=1
			and tabBOM.%(key)s like "%(txt)s"
			%(fcond)s  %(mcond)s
		limit %(start)s, %(page_len)s """ %  {'key': searchfield, 'txt': "%%%s%%" % txt,
		'fcond': get_filters_cond(doctype, filters, conditions),
		'mcond':get_match_cond(doctype), 'start': start, 'page_len': page_len})

def get_project_name(doctype, txt, searchfield, start, page_len, filters):
	cond = ''
	if filters['customer']:
		cond = '(`tabProject`.customer = "' + filters['customer'] + '" or ifnull(`tabProject`.customer,"")="") and'

	return frappe.db.sql("""select `tabProject`.name from `tabProject`
		where `tabProject`.status not in ("Completed", "Cancelled")
			and %(cond)s `tabProject`.name like "%(txt)s" %(mcond)s
		order by `tabProject`.name asc
		limit %(start)s, %(page_len)s """ % {'cond': cond,'txt': "%%%s%%" % txt,
		'mcond':get_match_cond(doctype),'start': start, 'page_len': page_len})

def get_delivery_notes_to_be_billed(doctype, txt, searchfield, start, page_len, filters):
	return frappe.db.sql("""select `tabDelivery Note`.name, `tabDelivery Note`.customer_name
		from `tabDelivery Note`
		where `tabDelivery Note`.`%(key)s` like %(txt)s and
			`tabDelivery Note`.docstatus = 1 %(fcond)s and
			(ifnull((select sum(qty) from `tabDelivery Note Item` where
					`tabDelivery Note Item`.parent=`tabDelivery Note`.name), 0) >
				ifnull((select sum(qty) from `tabSales Invoice Item` where
					`tabSales Invoice Item`.docstatus = 1 and
					`tabSales Invoice Item`.delivery_note=`tabDelivery Note`.name), 0))
			%(mcond)s order by `tabDelivery Note`.`%(key)s` asc
			limit %(start)s, %(page_len)s""" % {
				"key": searchfield,
				"fcond": get_filters_cond(doctype, filters, []),
				"mcond": get_match_cond(doctype),
				"start": "%(start)s", "page_len": "%(page_len)s", "txt": "%(txt)s"
			}, { "start": start, "page_len": page_len, "txt": ("%%%s%%" % txt) })

def get_batch_no(doctype, txt, searchfield, start, page_len, filters):
	from erpnext.controllers.queries import get_match_cond

	if filters.has_key('warehouse'):
		return frappe.db.sql("""select batch_no from `tabStock Ledger Entry` sle
				where item_code = '%(item_code)s'
					and warehouse = '%(warehouse)s'
					and batch_no like '%(txt)s'
					and exists(select * from `tabBatch`
							where name = sle.batch_no
								and (ifnull(expiry_date, '')='' or expiry_date >= '%(posting_date)s')
								and docstatus != 2)
					%(mcond)s
				group by batch_no having sum(actual_qty) > 0
				order by batch_no desc
				limit %(start)s, %(page_len)s """ % {'item_code': filters['item_code'],
					'warehouse': filters['warehouse'], 'posting_date': filters['posting_date'],
					'txt': "%%%s%%" % txt, 'mcond':get_match_cond(doctype),
					'start': start, 'page_len': page_len})
	else:
		return frappe.db.sql("""select name from tabBatch
				where docstatus != 2
					and item = '%(item_code)s'
					and (ifnull(expiry_date, '')='' or expiry_date >= '%(posting_date)s')
					and name like '%(txt)s'
					%(mcond)s
				order by name desc
				limit %(start)s, %(page_len)s""" % {'item_code': filters['item_code'],
				'posting_date': filters['posting_date'], 'txt': "%%%s%%" % txt,
				'mcond':get_match_cond(doctype),'start': start,
				'page_len': page_len})

########NEW FILE########
__FILENAME__ = selling_controller
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cint, flt, _round, cstr
from erpnext.setup.utils import get_company_currency
from frappe import _, throw

from erpnext.controllers.stock_controller import StockController

class SellingController(StockController):
	def validate(self):
		super(SellingController, self).validate()
		self.validate_max_discount()
		check_active_sales_items(self)

	def get_sender(self, comm):
		if frappe.db.get_value('Sales Email Settings', None, 'extract_emails'):
			return frappe.db.get_value('Sales Email Settings', None, 'email_id')
		else:
			return frappe.session.user

	def set_missing_values(self, for_validate=False):
		super(SellingController, self).set_missing_values(for_validate)

		# set contact and address details for customer, if they are not mentioned
		self.set_missing_lead_customer_details()
		self.set_price_list_and_item_details()
		if self.get("__islocal"):
			self.set_taxes("other_charges", "taxes_and_charges")

	def set_missing_lead_customer_details(self):
		if getattr(self, "customer", None):
			from erpnext.accounts.party import _get_party_details
			party_details = _get_party_details(self.customer,
				ignore_permissions=getattr(self, "ignore_permissions", None))
			if not self.meta.get_field("sales_team"):
				party_details.pop("sales_team")

			self.update_if_missing(party_details)

		elif getattr(self, "lead", None):
			from erpnext.selling.doctype.lead.lead import get_lead_details
			self.update_if_missing(get_lead_details(self.lead))

	def set_price_list_and_item_details(self):
		self.set_price_list_currency("Selling")
		self.set_missing_item_details()

	def apply_shipping_rule(self):
		if self.shipping_rule:
			shipping_rule = frappe.get_doc("Shipping Rule", self.shipping_rule)
			value = self.net_total

			# TODO
			# shipping rule calculation based on item's net weight

			shipping_amount = 0.0
			for condition in shipping_rule.get("shipping_rule_conditions"):
				if not condition.to_value or (flt(condition.from_value) <= value <= flt(condition.to_value)):
					shipping_amount = condition.shipping_amount
					break

			shipping_charge = {
				"doctype": "Sales Taxes and Charges",
				"charge_type": "Actual",
				"account_head": shipping_rule.account,
				"cost_center": shipping_rule.cost_center
			}

			existing_shipping_charge = self.get("other_charges", filters=shipping_charge)
			if existing_shipping_charge:
				# take the last record found
				existing_shipping_charge[-1].rate = shipping_amount
			else:
				shipping_charge["rate"] = shipping_amount
				shipping_charge["description"] = shipping_rule.label
				self.append("other_charges", shipping_charge)

			self.calculate_taxes_and_totals()

	def remove_shipping_charge(self):
		if self.shipping_rule:
			shipping_rule = frappe.get_doc("Shipping Rule", self.shipping_rule)
			existing_shipping_charge = self.get("other_charges", {
				"doctype": "Sales Taxes and Charges",
				"charge_type": "Actual",
				"account_head": shipping_rule.account,
				"cost_center": shipping_rule.cost_center
			})
			if existing_shipping_charge:
				self.get("other_charges").remove(existing_shipping_charge[-1])
				self.calculate_taxes_and_totals()

	def set_total_in_words(self):
		from frappe.utils import money_in_words
		company_currency = get_company_currency(self.company)

		disable_rounded_total = cint(frappe.db.get_value("Global Defaults", None,
			"disable_rounded_total"))

		if self.meta.get_field("in_words"):
			self.in_words = money_in_words(disable_rounded_total and
				self.grand_total or self.rounded_total, company_currency)
		if self.meta.get_field("in_words_export"):
			self.in_words_export = money_in_words(disable_rounded_total and
				self.grand_total_export or self.rounded_total_export, self.currency)

	def calculate_taxes_and_totals(self):
		self.other_fname = "other_charges"

		super(SellingController, self).calculate_taxes_and_totals()

		self.calculate_total_advance("Sales Invoice", "advance_adjustment_details")
		self.calculate_commission()
		self.calculate_contribution()

	def determine_exclusive_rate(self):
		if not any((cint(tax.included_in_print_rate) for tax in self.tax_doclist)):
			# no inclusive tax
			return

		for item in self.item_doclist:
			item_tax_map = self._load_item_tax_rate(item.item_tax_rate)
			cumulated_tax_fraction = 0
			for i, tax in enumerate(self.tax_doclist):
				tax.tax_fraction_for_current_item = self.get_current_tax_fraction(tax, item_tax_map)

				if i==0:
					tax.grand_total_fraction_for_current_item = 1 + tax.tax_fraction_for_current_item
				else:
					tax.grand_total_fraction_for_current_item = \
						self.tax_doclist[i-1].grand_total_fraction_for_current_item \
						+ tax.tax_fraction_for_current_item

				cumulated_tax_fraction += tax.tax_fraction_for_current_item

			if cumulated_tax_fraction and not self.discount_amount_applied:
				item.base_amount = flt((item.amount * self.conversion_rate) /
					(1 + cumulated_tax_fraction), self.precision("base_amount", item))

				item.base_rate = flt(item.base_amount / item.qty, self.precision("base_rate", item))

				if item.discount_percentage == 100:
					item.base_price_list_rate = item.base_rate
					item.base_rate = 0.0
				else:
					item.base_price_list_rate = flt(item.base_rate / (1 - (item.discount_percentage / 100.0)),
						self.precision("base_price_list_rate", item))

	def get_current_tax_fraction(self, tax, item_tax_map):
		"""
			Get tax fraction for calculating tax exclusive amount
			from tax inclusive amount
		"""
		current_tax_fraction = 0

		if cint(tax.included_in_print_rate):
			tax_rate = self._get_tax_rate(tax, item_tax_map)

			if tax.charge_type == "On Net Total":
				current_tax_fraction = tax_rate / 100.0

			elif tax.charge_type == "On Previous Row Amount":
				current_tax_fraction = (tax_rate / 100.0) * \
					self.tax_doclist[cint(tax.row_id) - 1].tax_fraction_for_current_item

			elif tax.charge_type == "On Previous Row Total":
				current_tax_fraction = (tax_rate / 100.0) * \
					self.tax_doclist[cint(tax.row_id) - 1].grand_total_fraction_for_current_item

		return current_tax_fraction

	def calculate_item_values(self):
		if not self.discount_amount_applied:
			for item in self.item_doclist:
				self.round_floats_in(item)

				if item.discount_percentage == 100:
					item.rate = 0
				elif not item.rate:
					item.rate = flt(item.price_list_rate * (1.0 - (item.discount_percentage / 100.0)),
						self.precision("rate", item))

				item.amount = flt(item.rate * item.qty,
					self.precision("amount", item))

				self._set_in_company_currency(item, "price_list_rate", "base_price_list_rate")
				self._set_in_company_currency(item, "rate", "base_rate")
				self._set_in_company_currency(item, "amount", "base_amount")

	def calculate_net_total(self):
		self.net_total = self.net_total_export = 0.0

		for item in self.item_doclist:
			self.net_total += item.base_amount
			self.net_total_export += item.amount

		self.round_floats_in(self, ["net_total", "net_total_export"])

	def calculate_totals(self):
		self.grand_total = flt(self.tax_doclist and \
			self.tax_doclist[-1].total or self.net_total, self.precision("grand_total"))
		self.grand_total_export = flt(self.grand_total / self.conversion_rate,
			self.precision("grand_total_export"))

		self.other_charges_total = flt(self.grand_total - self.net_total,
			self.precision("other_charges_total"))

		self.other_charges_total_export = flt(self.grand_total_export -
			self.net_total_export + flt(self.discount_amount),
			self.precision("other_charges_total_export"))

		self.rounded_total = _round(self.grand_total)
		self.rounded_total_export = _round(self.grand_total_export)

	def apply_discount_amount(self):
		if self.discount_amount:
			grand_total_for_discount_amount = self.get_grand_total_for_discount_amount()

			if grand_total_for_discount_amount:
				# calculate item amount after Discount Amount
				for item in self.item_doclist:
					distributed_amount = flt(self.discount_amount) * item.base_amount / grand_total_for_discount_amount
					item.base_amount = flt(item.base_amount - distributed_amount, self.precision("base_amount", item))

				self.discount_amount_applied = True
				self._calculate_taxes_and_totals()

	def get_grand_total_for_discount_amount(self):
		actual_taxes_dict = {}

		for tax in self.tax_doclist:
			if tax.charge_type == "Actual":
				actual_taxes_dict.setdefault(tax.idx, tax.tax_amount)
			elif tax.row_id in actual_taxes_dict:
				actual_tax_amount = flt(actual_taxes_dict.get(tax.row_id, 0)) * \
					flt(tax.rate) / 100
				actual_taxes_dict.setdefault(tax.idx, actual_tax_amount)

		grand_total_for_discount_amount = flt(self.grand_total - sum(actual_taxes_dict.values()),
			self.precision("grand_total"))
		return grand_total_for_discount_amount

	def calculate_outstanding_amount(self):
		# NOTE:
		# write_off_amount is only for POS Invoice
		# total_advance is only for non POS Invoice
		if self.doctype == "Sales Invoice" and self.docstatus == 0:
			self.round_floats_in(self, ["grand_total", "total_advance", "write_off_amount",
				"paid_amount"])
			total_amount_to_pay = self.grand_total - self.write_off_amount
			self.outstanding_amount = flt(total_amount_to_pay - self.total_advance \
				- self.paid_amount,	self.precision("outstanding_amount"))

	def calculate_commission(self):
		if self.meta.get_field("commission_rate"):
			self.round_floats_in(self, ["net_total", "commission_rate"])
			if self.commission_rate > 100.0:
				throw(_("Commission rate cannot be greater than 100"))

			self.total_commission = flt(self.net_total * self.commission_rate / 100.0,
				self.precision("total_commission"))

	def calculate_contribution(self):
		if not self.meta.get_field("sales_team"):
			return

		total = 0.0
		sales_team = self.get("sales_team")
		for sales_person in sales_team:
			self.round_floats_in(sales_person)

			sales_person.allocated_amount = flt(
				self.net_total * sales_person.allocated_percentage / 100.0,
				self.precision("allocated_amount", sales_person))

			total += sales_person.allocated_percentage

		if sales_team and total != 100.0:
			throw(_("Total allocated percentage for sales team should be 100"))

	def validate_order_type(self):
		valid_types = ["Sales", "Maintenance", "Shopping Cart"]
		if not self.order_type:
			self.order_type = "Sales"
		elif self.order_type not in valid_types:
			throw(_("Order Type must be one of {1}").comma_or(valid_types))

	def check_credit(self, grand_total):
		customer_account = frappe.db.get_value("Account", {"company": self.company,
			"master_name": self.customer}, "name")
		if customer_account:
			total_outstanding = frappe.db.sql("""select
				sum(ifnull(debit, 0)) - sum(ifnull(credit, 0))
				from `tabGL Entry` where account = %s""", customer_account)
			total_outstanding = total_outstanding[0][0] if total_outstanding else 0

			outstanding_including_current = flt(total_outstanding) + flt(grand_total)
			frappe.get_doc('Account', customer_account).run_method("check_credit_limit",
				outstanding_including_current)

	def validate_max_discount(self):
		for d in self.get(self.fname):
			discount = flt(frappe.db.get_value("Item", d.item_code, "max_discount"))

			if discount and flt(d.discount_percentage) > discount:
				frappe.throw(_("Maxiumm discount for Item {0} is {1}%").format(d.item_code, discount))

	def get_item_list(self):
		il = []
		for d in self.get(self.fname):
			reserved_warehouse = ""
			reserved_qty_for_main_item = 0

			if self.doctype == "Sales Order":
				if (frappe.db.get_value("Item", d.item_code, "is_stock_item") == 'Yes' or
					self.has_sales_bom(d.item_code)) and not d.warehouse:
						frappe.throw(_("Reserved Warehouse required for stock Item {0} in row {1}").format(d.item_code, d.idx))
				reserved_warehouse = d.warehouse
				if flt(d.qty) > flt(d.delivered_qty):
					reserved_qty_for_main_item = flt(d.qty) - flt(d.delivered_qty)

			elif self.doctype == "Delivery Note" and d.against_sales_order:
				# if SO qty is 10 and there is tolerance of 20%, then it will allow DN of 12.
				# But in this case reserved qty should only be reduced by 10 and not 12

				already_delivered_qty = self.get_already_delivered_qty(self.name,
					d.against_sales_order, d.prevdoc_detail_docname)
				so_qty, reserved_warehouse = self.get_so_qty_and_warehouse(d.prevdoc_detail_docname)

				if already_delivered_qty + d.qty > so_qty:
					reserved_qty_for_main_item = -(so_qty - already_delivered_qty)
				else:
					reserved_qty_for_main_item = -flt(d.qty)

			if self.has_sales_bom(d.item_code):
				for p in self.get("packing_details"):
					if p.parent_detail_docname == d.name and p.parent_item == d.item_code:
						# the packing details table's qty is already multiplied with parent's qty
						il.append(frappe._dict({
							'warehouse': p.warehouse,
							'reserved_warehouse': reserved_warehouse,
							'item_code': p.item_code,
							'qty': flt(p.qty),
							'reserved_qty': (flt(p.qty)/flt(d.qty)) * reserved_qty_for_main_item,
							'uom': p.uom,
							'batch_no': cstr(p.batch_no).strip(),
							'serial_no': cstr(p.serial_no).strip(),
							'name': d.name
						}))
			else:
				il.append(frappe._dict({
					'warehouse': d.warehouse,
					'reserved_warehouse': reserved_warehouse,
					'item_code': d.item_code,
					'qty': d.qty,
					'reserved_qty': reserved_qty_for_main_item,
					'uom': d.stock_uom,
					'batch_no': cstr(d.get("batch_no")).strip(),
					'serial_no': cstr(d.get("serial_no")).strip(),
					'name': d.name
				}))
		return il

	def has_sales_bom(self, item_code):
		return frappe.db.sql("""select name from `tabSales BOM`
			where new_item_code=%s and docstatus != 2""", item_code)

	def get_already_delivered_qty(self, dn, so, so_detail):
		qty = frappe.db.sql("""select sum(qty) from `tabDelivery Note Item`
			where prevdoc_detail_docname = %s and docstatus = 1
			and against_sales_order = %s
			and parent != %s""", (so_detail, so, dn))
		return qty and flt(qty[0][0]) or 0.0

	def get_so_qty_and_warehouse(self, so_detail):
		so_item = frappe.db.sql("""select qty, warehouse from `tabSales Order Item`
			where name = %s and docstatus = 1""", so_detail, as_dict=1)
		so_qty = so_item and flt(so_item[0]["qty"]) or 0.0
		so_warehouse = so_item and so_item[0]["warehouse"] or ""
		return so_qty, so_warehouse

	def check_stop_sales_order(self, ref_fieldname):
		for d in self.get(self.fname):
			if d.get(ref_fieldname):
				status = frappe.db.get_value("Sales Order", d.get(ref_fieldname), "status")
				if status == "Stopped":
					frappe.throw(_("Sales Order {0} is stopped").format(d.get(ref_fieldname)))

def check_active_sales_items(obj):
	for d in obj.get(obj.fname):
		if d.item_code:
			item = frappe.db.sql("""select docstatus, is_sales_item,
				is_service_item, income_account from tabItem where name = %s""",
				d.item_code, as_dict=True)[0]
			if item.is_sales_item == 'No' and item.is_service_item == 'No':
				frappe.throw(_("Item {0} must be Sales or Service Item in {1}").format(d.item_code, d.idx))
			if getattr(d, "income_account", None) and not item.income_account:
				frappe.db.set_value("Item", d.item_code, "income_account",
					d.income_account)

########NEW FILE########
__FILENAME__ = status_updater
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt
from frappe import msgprint, _, throw
from frappe.model.document import Document

status_map = {
	"Contact": [
		["Replied", "communication_sent"],
		["Open", "communication_received"]
	],
	"Job Applicant": [
		["Replied", "communication_sent"],
		["Open", "communication_received"]
	],
	"Lead": [
		["Replied", "communication_sent"],
		["Converted", "has_customer"],
		["Opportunity", "has_opportunity"],
		["Open", "communication_received"],
	],
	"Opportunity": [
		["Draft", None],
		["Submitted", "eval:self.docstatus==1"],
		["Lost", "eval:self.status=='Lost'"],
		["Quotation", "has_quotation"],
		["Replied", "communication_sent"],
		["Cancelled", "eval:self.docstatus==2"],
		["Open", "communication_received"],
	],
	"Quotation": [
		["Draft", None],
		["Submitted", "eval:self.docstatus==1"],
		["Lost", "eval:self.status=='Lost'"],
		["Ordered", "has_sales_order"],
		["Replied", "communication_sent"],
		["Cancelled", "eval:self.docstatus==2"],
		["Open", "communication_received"],
	],
	"Sales Order": [
		["Draft", None],
		["Submitted", "eval:self.docstatus==1"],
		["Stopped", "eval:self.status=='Stopped'"],
		["Cancelled", "eval:self.docstatus==2"],
	],
	"Support Ticket": [
		["Replied", "communication_sent"],
		["Open", "communication_received"]
	],
}

class StatusUpdater(Document):
	"""
		Updates the status of the calling records
		Delivery Note: Update Delivered Qty, Update Percent and Validate over delivery
		Sales Invoice: Update Billed Amt, Update Percent and Validate over billing
		Installation Note: Update Installed Qty, Update Percent Qty and Validate over installation
	"""

	def update_prevdoc_status(self):
		self.update_qty()
		self.validate_qty()

	def set_status(self, update=False):
		if self.get("__islocal"):
			return

		if self.doctype in status_map:
			sl = status_map[self.doctype][:]
			sl.reverse()
			for s in sl:
				if not s[1]:
					self.status = s[0]
					break
				elif s[1].startswith("eval:"):
					if eval(s[1][5:]):
						self.status = s[0]
						break
				elif getattr(self, s[1])():
					self.status = s[0]
					break

			if update:
				frappe.db.set_value(self.doctype, self.name, "status", self.status)

	def on_communication(self):
		if not self.get("communications"): return
		self.communication_set = True
		self.get("communications").sort(key=lambda d: d.creation)
		self.set_status(update=True)
		del self.communication_set

	def communication_received(self):
		if getattr(self, "communication_set", False):
			last_comm = self.get("communications")
			if last_comm:
				return last_comm[-1].sent_or_received == "Received"

	def communication_sent(self):
		if getattr(self, "communication_set", False):
			last_comm = self.get("communications")
			if last_comm:
				return last_comm[-1].sent_or_received == "Sent"

	def validate_qty(self):
		"""
			Validates qty at row level
		"""
		self.tolerance = {}
		self.global_tolerance = None

		for args in self.status_updater:
			# get unique transactions to update
			for d in self.get_all_children():
				if d.doctype == args['source_dt'] and d.get(args["join_field"]):
					args['name'] = d.get(args['join_field'])

					# get all qty where qty > target_field
					item = frappe.db.sql("""select item_code, `{target_ref_field}`,
						`{target_field}`, parenttype, parent from `tab{target_dt}`
						where `{target_ref_field}` < `{target_field}`
						and name=%s and docstatus=1""".format(**args),
						args['name'], as_dict=1)
					if item:
						item = item[0]
						item['idx'] = d.idx
						item['target_ref_field'] = args['target_ref_field'].replace('_', ' ')

						if not item[args['target_ref_field']]:
							msgprint(_("Note: System will not check over-delivery and over-booking for Item {0} as quantity or amount is 0").format(item.item_code))
						elif args.get('no_tolerance'):
							item['reduce_by'] = item[args['target_field']] - \
								item[args['target_ref_field']]
							if item['reduce_by'] > .01:
								msgprint(_("Allowance for over-delivery / over-billing crossed for Item {0}").format(item.item_code))
								throw(_("{0} must be less than or equal to {1}").format(_(item.target_ref_field), item[args["target_ref_field"]]))

						else:
							self.check_overflow_with_tolerance(item, args)

	def check_overflow_with_tolerance(self, item, args):
		"""
			Checks if there is overflow condering a relaxation tolerance
		"""
		# check if overflow is within tolerance
		tolerance, self.tolerance, self.global_tolerance = get_tolerance_for(item['item_code'],
			self.tolerance, self.global_tolerance)

		overflow_percent = ((item[args['target_field']] - item[args['target_ref_field']]) /
		 	item[args['target_ref_field']]) * 100

		if overflow_percent - tolerance > 0.01:
			item['max_allowed'] = flt(item[args['target_ref_field']] * (100+tolerance)/100)
			item['reduce_by'] = item[args['target_field']] - item['max_allowed']

			msgprint(_("Allowance for over-delivery / over-billing crossed for Item {0}").format(item["item_code"]))
			throw(_("{0} must be less than or equal to {1}").format(_(item["target_ref_field"]), item[args["max_allowed"]]))

	def update_qty(self, change_modified=True):
		"""
			Updates qty at row level
		"""
		for args in self.status_updater:
			# condition to include current record (if submit or no if cancel)
			if self.docstatus == 1:
				args['cond'] = ' or parent="%s"' % self.name.replace('"', '\"')
			else:
				args['cond'] = ' and parent!="%s"' % self.name.replace('"', '\"')

			args['modified_cond'] = ''
			if change_modified:
				args['modified_cond'] = ', modified = now()'

			# update quantities in child table
			for d in self.get_all_children():
				if d.doctype == args['source_dt']:
					# updates qty in the child table
					args['detail_id'] = d.get(args['join_field'])

					args['second_source_condition'] = ""
					if args.get('second_source_dt') and args.get('second_source_field') \
							and args.get('second_join_field'):
						args['second_source_condition'] = """ + (select sum(%(second_source_field)s)
							from `tab%(second_source_dt)s`
							where `%(second_join_field)s`="%(detail_id)s"
							and (docstatus=1))""" % args

					if args['detail_id']:
						frappe.db.sql("""update `tab%(target_dt)s`
							set %(target_field)s = (select sum(%(source_field)s)
								from `tab%(source_dt)s` where `%(join_field)s`="%(detail_id)s"
								and (docstatus=1 %(cond)s)) %(second_source_condition)s
							where name='%(detail_id)s'""" % args)

			# get unique transactions to update
			for name in set([d.get(args['percent_join_field']) for d in self.get_all_children(args['source_dt'])]):
				if name:
					args['name'] = name

					# update percent complete in the parent table
					frappe.db.sql("""update `tab%(target_parent_dt)s`
						set %(target_parent_field)s = (select sum(if(%(target_ref_field)s >
							ifnull(%(target_field)s, 0), %(target_field)s,
							%(target_ref_field)s))/sum(%(target_ref_field)s)*100
							from `tab%(target_dt)s` where parent="%(name)s") %(modified_cond)s
						where name='%(name)s'""" % args)

					# update field
					if args.get('status_field'):
						frappe.db.sql("""update `tab%(target_parent_dt)s`
							set %(status_field)s = if(ifnull(%(target_parent_field)s,0)<0.001,
								'Not %(keyword)s', if(%(target_parent_field)s>=99.99,
								'Fully %(keyword)s', 'Partly %(keyword)s'))
							where name='%(name)s'""" % args)


	def update_billing_status_for_zero_amount_refdoc(self, ref_dt):
		ref_fieldname = ref_dt.lower().replace(" ", "_")
		zero_amount_refdoc = []
		all_zero_amount_refdoc = frappe.db.sql_list("""select name from `tab%s`
			where docstatus=1 and net_total = 0""" % ref_dt)

		for item in self.get("entries"):
			if item.get(ref_fieldname) \
				and item.get(ref_fieldname) in all_zero_amount_refdoc \
				and item.get(ref_fieldname) not in zero_amount_refdoc:
					zero_amount_refdoc.append(item.get(ref_fieldname))

		if zero_amount_refdoc:
			self.update_biling_status(zero_amount_refdoc, ref_dt, ref_fieldname)

	def update_biling_status(self, zero_amount_refdoc, ref_dt, ref_fieldname):
		for ref_dn in zero_amount_refdoc:
			ref_doc_qty = flt(frappe.db.sql("""select sum(ifnull(qty, 0)) from `tab%s Item`
				where parent=%s""" % (ref_dt, '%s'), (ref_dn))[0][0])

			billed_qty = flt(frappe.db.sql("""select sum(ifnull(qty, 0))
				from `tab%s Item` where %s=%s and docstatus=1""" %
				(self.doctype, ref_fieldname, '%s'), (ref_dn))[0][0])

			per_billed = ((ref_doc_qty if billed_qty > ref_doc_qty else billed_qty)\
				/ ref_doc_qty)*100
			frappe.db.set_value(ref_dt, ref_dn, "per_billed", per_billed)

			if frappe.get_meta(ref_dt).get_field("billing_status"):
				if per_billed < 0.001: billing_status = "Not Billed"
				elif per_billed >= 99.99: billing_status = "Fully Billed"
				else: billing_status = "Partly Billed"

				frappe.db.set_value(ref_dt, ref_dn, "billing_status", billing_status)

def get_tolerance_for(item_code, item_tolerance={}, global_tolerance=None):
	"""
		Returns the tolerance for the item, if not set, returns global tolerance
	"""
	if item_tolerance.get(item_code):
		return item_tolerance[item_code], item_tolerance, global_tolerance

	tolerance = flt(frappe.db.get_value('Item',item_code,'tolerance') or 0)

	if not tolerance:
		if global_tolerance == None:
			global_tolerance = flt(frappe.db.get_value('Global Defaults', None,
				'tolerance'))
		tolerance = global_tolerance

	item_tolerance[item_code] = tolerance
	return tolerance, item_tolerance, global_tolerance

########NEW FILE########
__FILENAME__ = stock_controller
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cint, flt, cstr
from frappe import msgprint, _
import frappe.defaults

from erpnext.controllers.accounts_controller import AccountsController
from erpnext.accounts.general_ledger import make_gl_entries, delete_gl_entries

class StockController(AccountsController):
	def make_gl_entries(self, repost_future_gle=True):
		if self.docstatus == 2:
			delete_gl_entries(voucher_type=self.doctype, voucher_no=self.name)

		if cint(frappe.defaults.get_global_default("auto_accounting_for_stock")):
			warehouse_account = self.get_warehouse_account()

			if self.docstatus==1:
				gl_entries = self.get_gl_entries(warehouse_account)
				make_gl_entries(gl_entries)

			if repost_future_gle:
				items, warehouse_account = self.get_items_and_warehouse_accounts(warehouse_account)
				update_gl_entries_after(self.posting_date, self.posting_time,
					warehouse_account, items)

	def get_gl_entries(self, warehouse_account=None, default_expense_account=None,
			default_cost_center=None):
		from erpnext.accounts.general_ledger import process_gl_map
		if not warehouse_account:
			warehouse_account = get_warehouse_account()

		sle_map = self.get_stock_ledger_details()
		voucher_details = self.get_voucher_details(default_expense_account, default_cost_center, sle_map)

		gl_list = []
		warehouse_with_no_account = []
		for detail in voucher_details:
			sle_list = sle_map.get(detail.name)
			if sle_list:
				for sle in sle_list:
					if warehouse_account.get(sle.warehouse):
						# from warehouse account

						self.check_expense_account(detail)

						gl_list.append(self.get_gl_dict({
							"account": warehouse_account[sle.warehouse],
							"against": detail.expense_account,
							"cost_center": detail.cost_center,
							"remarks": self.get("remarks") or "Accounting Entry for Stock",
							"debit": flt(sle.stock_value_difference, 2)
						}))

						# to target warehouse / expense account
						gl_list.append(self.get_gl_dict({
							"account": detail.expense_account,
							"against": warehouse_account[sle.warehouse],
							"cost_center": detail.cost_center,
							"remarks": self.get("remarks") or "Accounting Entry for Stock",
							"credit": flt(sle.stock_value_difference, 2)
						}))
					elif sle.warehouse not in warehouse_with_no_account:
						warehouse_with_no_account.append(sle.warehouse)

		if warehouse_with_no_account:
			msgprint(_("No accounting entries for the following warehouses") + ": \n" +
				"\n".join(warehouse_with_no_account))

		return process_gl_map(gl_list)

	def get_voucher_details(self, default_expense_account, default_cost_center, sle_map):
		if self.doctype == "Stock Reconciliation":
			return [frappe._dict({ "name": voucher_detail_no, "expense_account": default_expense_account,
				"cost_center": default_cost_center }) for voucher_detail_no, sle in sle_map.items()]
		else:
			details = self.get(self.fname)

			if default_expense_account or default_cost_center:
				for d in details:
					if default_expense_account and not d.get("expense_account"):
						d.expense_account = default_expense_account
					if default_cost_center and not d.get("cost_center"):
						d.cost_center = default_cost_center

			return details

	def get_items_and_warehouse_accounts(self, warehouse_account=None):
		items, warehouses = [], []
		if not warehouse_account:
			warehouse_account = get_warehouse_account()

		if hasattr(self, "fname"):
			item_doclist = self.get(self.fname)
		elif self.doctype == "Stock Reconciliation":
			import json
			item_doclist = []
			data = json.loads(self.reconciliation_json)
			for row in data[data.index(self.head_row)+1:]:
				d = frappe._dict(zip(["item_code", "warehouse", "qty", "valuation_rate"], row))
				item_doclist.append(d)

		if item_doclist:
			for d in item_doclist:
				if d.item_code and d.item_code not in items:
					items.append(d.item_code)

				if d.get("warehouse") and d.warehouse not in warehouses:
					warehouses.append(d.warehouse)

				if self.doctype == "Stock Entry":
					if d.get("s_warehouse") and d.s_warehouse not in warehouses:
						warehouses.append(d.s_warehouse)
					if d.get("t_warehouse") and d.t_warehouse not in warehouses:
						warehouses.append(d.t_warehouse)

			warehouse_account = {wh: warehouse_account[wh] for wh in warehouses
				if warehouse_account.get(wh)}

		return items, warehouse_account

	def get_stock_ledger_details(self):
		stock_ledger = {}
		for sle in frappe.db.sql("""select warehouse, stock_value_difference, voucher_detail_no
			from `tabStock Ledger Entry` where voucher_type=%s and voucher_no=%s""",
			(self.doctype, self.name), as_dict=True):
				stock_ledger.setdefault(sle.voucher_detail_no, []).append(sle)
		return stock_ledger

	def get_warehouse_account(self):
		warehouse_account = dict(frappe.db.sql("""select master_name, name from tabAccount
			where account_type = 'Warehouse' and ifnull(master_name, '') != ''"""))
		return warehouse_account

	def update_gl_entries_after(self, warehouse_account=None):
		future_stock_vouchers = self.get_future_stock_vouchers()
		gle = self.get_voucherwise_gl_entries(future_stock_vouchers)
		if not warehouse_account:
			warehouse_account = self.get_warehouse_account()
		for voucher_type, voucher_no in future_stock_vouchers:
			existing_gle = gle.get((voucher_type, voucher_no), [])
			voucher_obj = frappe.get_doc(voucher_type, voucher_no)
			expected_gle = voucher_obj.get_gl_entries(warehouse_account)
			if expected_gle:
				matched = True
				if existing_gle:
					for entry in expected_gle:
						for e in existing_gle:
							if entry.account==e.account \
								and entry.against_account==e.against_account\
								and entry.cost_center==e.cost_center:
									if entry.debit != e.debit or entry.credit != e.credit:
										matched = False
										break
				else:
					matched = False

				if not matched:
					self.delete_gl_entries(voucher_type, voucher_no)
					voucher_obj.make_gl_entries(repost_future_gle=False)
			else:
				self.delete_gl_entries(voucher_type, voucher_no)


	def get_future_stock_vouchers(self):
		future_stock_vouchers = []

		if hasattr(self, "fname"):
			item_list = [d.item_code for d in self.get(self.fname)]
			condition = ''.join(['and item_code in (\'', '\', \''.join(item_list) ,'\')'])
		else:
			condition = ""

		for d in frappe.db.sql("""select distinct sle.voucher_type, sle.voucher_no
			from `tabStock Ledger Entry` sle
			where timestamp(sle.posting_date, sle.posting_time) >= timestamp(%s, %s) %s
			order by timestamp(sle.posting_date, sle.posting_time) asc, name asc""" %
			('%s', '%s', condition), (self.posting_date, self.posting_time),
			as_dict=True):
				future_stock_vouchers.append([d.voucher_type, d.voucher_no])

		return future_stock_vouchers

	def get_voucherwise_gl_entries(self, future_stock_vouchers):
		gl_entries = {}
		if future_stock_vouchers:
			for d in frappe.db.sql("""select * from `tabGL Entry`
				where posting_date >= %s and voucher_no in (%s)""" %
				('%s', ', '.join(['%s']*len(future_stock_vouchers))),
				tuple([self.posting_date] + [d[1] for d in future_stock_vouchers]), as_dict=1):
					gl_entries.setdefault((d.voucher_type, d.voucher_no), []).append(d)

		return gl_entries

	def delete_gl_entries(self, voucher_type, voucher_no):
		frappe.db.sql("""delete from `tabGL Entry`
			where voucher_type=%s and voucher_no=%s""", (voucher_type, voucher_no))

	def make_adjustment_entry(self, expected_gle, voucher_obj):
		from erpnext.accounts.utils import get_stock_and_account_difference
		account_list = [d.account for d in expected_gle]
		acc_diff = get_stock_and_account_difference(account_list, expected_gle[0].posting_date)

		cost_center = self.get_company_default("cost_center")
		stock_adjustment_account = self.get_company_default("stock_adjustment_account")

		gl_entries = []
		for account, diff in acc_diff.items():
			if diff:
				gl_entries.append([
					# stock in hand account
					voucher_obj.get_gl_dict({
						"account": account,
						"against": stock_adjustment_account,
						"debit": diff,
						"remarks": "Adjustment Accounting Entry for Stock",
					}),

					# account against stock in hand
					voucher_obj.get_gl_dict({
						"account": stock_adjustment_account,
						"against": account,
						"credit": diff,
						"cost_center": cost_center or None,
						"remarks": "Adjustment Accounting Entry for Stock",
					}),
				])

		if gl_entries:
			from erpnext.accounts.general_ledger import make_gl_entries
			make_gl_entries(gl_entries)

	def check_expense_account(self, item):
		if not item.get("expense_account"):
			frappe.throw(_("Expense or Difference account is mandatory for Item {0} as it impacts overall stock value").format(item.item_code))

		if item.get("expense_account") and not item.get("cost_center"):
			frappe.throw(_("""Cost Center is mandatory for Item {0}""").format(item.get("item_code")))

	def get_sl_entries(self, d, args):
		sl_dict = {
			"item_code": d.get("item_code", None),
			"warehouse": d.get("warehouse", None),
			"posting_date": self.posting_date,
			"posting_time": self.posting_time,
			"voucher_type": self.doctype,
			"voucher_no": self.name,
			"voucher_detail_no": d.name,
			"actual_qty": (self.docstatus==1 and 1 or -1)*flt(d.get("stock_qty")),
			"stock_uom": d.get("stock_uom"),
			"incoming_rate": 0,
			"company": self.company,
			"fiscal_year": self.fiscal_year,
			"batch_no": cstr(d.get("batch_no")).strip(),
			"serial_no": d.get("serial_no"),
			"project": d.get("project_name"),
			"is_cancelled": self.docstatus==2 and "Yes" or "No"
		}

		sl_dict.update(args)
		return sl_dict

	def make_sl_entries(self, sl_entries, is_amended=None):
		from erpnext.stock.stock_ledger import make_sl_entries
		make_sl_entries(sl_entries, is_amended)

	def make_cancel_gl_entries(self):
		if frappe.db.sql("""select name from `tabGL Entry` where voucher_type=%s
			and voucher_no=%s""", (self.doctype, self.name)):
				self.make_gl_entries()

def update_gl_entries_after(posting_date, posting_time, warehouse_account=None, for_items=None):
	def _delete_gl_entries(voucher_type, voucher_no):
		frappe.db.sql("""delete from `tabGL Entry`
			where voucher_type=%s and voucher_no=%s""", (voucher_type, voucher_no))

	if not warehouse_account:
		warehouse_account = get_warehouse_account()
	future_stock_vouchers = get_future_stock_vouchers(posting_date, posting_time,
		warehouse_account, for_items)
	gle = get_voucherwise_gl_entries(future_stock_vouchers, posting_date)

	for voucher_type, voucher_no in future_stock_vouchers:
		existing_gle = gle.get((voucher_type, voucher_no), [])
		voucher_obj = frappe.get_doc(voucher_type, voucher_no)
		expected_gle = voucher_obj.get_gl_entries(warehouse_account)
		if expected_gle:
			if not existing_gle or not compare_existing_and_expected_gle(existing_gle,
				expected_gle):
					_delete_gl_entries(voucher_type, voucher_no)
					voucher_obj.make_gl_entries(repost_future_gle=False)
		else:
			_delete_gl_entries(voucher_type, voucher_no)

def compare_existing_and_expected_gle(existing_gle, expected_gle):
	matched = True
	for entry in expected_gle:
		for e in existing_gle:
			if entry.account==e.account and entry.against_account==e.against_account \
				and entry.cost_center==e.cost_center \
				and (entry.debit != e.debit or entry.credit != e.credit):
					matched = False
					break
	return matched

def get_future_stock_vouchers(posting_date, posting_time, warehouse_account=None, for_items=None):
	future_stock_vouchers = []

	condition = ""
	if for_items:
		condition = ''.join([' and item_code in (\'', '\', \''.join(for_items) ,'\')'])

	if warehouse_account:
		condition += ''.join([' and warehouse in (\'', '\', \''.join(warehouse_account.keys()) ,'\')'])

	for d in frappe.db.sql("""select distinct sle.voucher_type, sle.voucher_no
		from `tabStock Ledger Entry` sle
		where timestamp(sle.posting_date, sle.posting_time) >= timestamp(%s, %s) %s
		order by timestamp(sle.posting_date, sle.posting_time) asc, name asc""" %
		('%s', '%s', condition), (posting_date, posting_time),
		as_dict=True):
			future_stock_vouchers.append([d.voucher_type, d.voucher_no])

	return future_stock_vouchers

def get_voucherwise_gl_entries(future_stock_vouchers, posting_date):
	gl_entries = {}
	if future_stock_vouchers:
		for d in frappe.db.sql("""select * from `tabGL Entry`
			where posting_date >= %s and voucher_no in (%s)""" %
			('%s', ', '.join(['%s']*len(future_stock_vouchers))),
			tuple([posting_date] + [d[1] for d in future_stock_vouchers]), as_dict=1):
				gl_entries.setdefault((d.voucher_type, d.voucher_no), []).append(d)

	return gl_entries

def get_warehouse_account():
	warehouse_account = dict(frappe.db.sql("""select master_name, name from tabAccount
		where account_type = 'Warehouse' and ifnull(master_name, '') != ''"""))
	return warehouse_account

########NEW FILE########
__FILENAME__ = trends
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import getdate
from frappe import _

def get_columns(filters, trans):
	validate_filters(filters)

	# get conditions for based_on filter cond
	based_on_details = based_wise_colums_query(filters.get("based_on"), trans)
	# get conditions for periodic filter cond
	period_cols, period_select = period_wise_colums_query(filters, trans)
	# get conditions for grouping filter cond
	group_by_cols = group_wise_column(filters.get("group_by"))

	columns = based_on_details["based_on_cols"] + period_cols + ["Total(Qty):Float:120", "Total(Amt):Currency:120"]
	if group_by_cols:
		columns = based_on_details["based_on_cols"] + group_by_cols + period_cols + \
			["Total(Qty):Float:120", "Total(Amt):Currency:120"]

	conditions = {"based_on_select": based_on_details["based_on_select"], "period_wise_select": period_select,
		"columns": columns, "group_by": based_on_details["based_on_group_by"], "grbc": group_by_cols, "trans": trans,
		"addl_tables": based_on_details["addl_tables"]}

	return conditions

def validate_filters(filters):
	for f in ["Fiscal Year", "Based On", "Period", "Company"]:
		if not filters.get(f.lower().replace(" ", "_")):
			frappe.throw(_("{0} is mandatory").format(f))

	if filters.get("based_on") == filters.get("group_by"):
		frappe.throw(_("'Based On' and 'Group By' can not be same"))

def get_data(filters, conditions):
	data = []
	inc, cond= '',''
	query_details =  conditions["based_on_select"] + conditions["period_wise_select"]

	if conditions["based_on_select"] in ["t1.project_name,", "t2.project_name,"]:
		cond = 'and '+ conditions["based_on_select"][:-1] +' IS Not NULL'

	if filters.get("group_by"):
		sel_col = ''
		ind = conditions["columns"].index(conditions["grbc"][0])

		if filters.get("group_by") == 'Item':
			sel_col = 't2.item_code'
		elif filters.get("group_by") == 'Customer':
			sel_col = 't1.customer'
		elif filters.get("group_by") == 'Supplier':
			sel_col = 't1.supplier'

		if filters.get('based_on') in ['Item','Customer','Supplier']:
			inc = 2
		else :
			inc = 1
		data1 = frappe.db.sql(""" select %s from `tab%s` t1, `tab%s Item` t2 %s
					where t2.parent = t1.name and t1.company = %s and t1.fiscal_year = %s and
					t1.docstatus = 1 %s
					group by %s
				""" % (query_details,  conditions["trans"],  conditions["trans"], conditions["addl_tables"], "%s",
					"%s", cond, conditions["group_by"]), (filters.get("company"),
					filters["fiscal_year"]),as_list=1)

		for d in range(len(data1)):
			#to add blanck column
			dt = data1[d]
			dt.insert(ind,'')
			data.append(dt)

			#to get distinct value of col specified by group_by in filter
			row = frappe.db.sql("""select DISTINCT(%s) from `tab%s` t1, `tab%s Item` t2 %s
						where t2.parent = t1.name and t1.company = %s and t1.fiscal_year = %s
						and t1.docstatus = 1 and %s = %s
					""" %
					(sel_col,  conditions["trans"],  conditions["trans"], conditions["addl_tables"],
						"%s", "%s", conditions["group_by"], "%s"),
					(filters.get("company"), filters.get("fiscal_year"), data1[d][0]), as_list=1)

			for i in range(len(row)):
				des = ['' for q in range(len(conditions["columns"]))]

				#get data for group_by filter
				row1 = frappe.db.sql(""" select %s , %s from `tab%s` t1, `tab%s Item` t2 %s
							where t2.parent = t1.name and t1.company = %s and t1.fiscal_year = %s
							and t1.docstatus = 1 and %s = %s and %s = %s
						""" %
						(sel_col, conditions["period_wise_select"], conditions["trans"],
						 	conditions["trans"], conditions["addl_tables"], "%s", "%s", sel_col,
							"%s", conditions["group_by"], "%s"),
						(filters.get("company"), filters.get("fiscal_year"), row[i][0],
							data1[d][0]), as_list=1)

				des[ind] = row[i]
				for j in range(1,len(conditions["columns"])-inc):
					des[j+inc] = row1[0][j]

				data.append(des)
	else:
		data = frappe.db.sql(""" select %s from `tab%s` t1, `tab%s Item` t2 %s
					where t2.parent = t1.name and t1.company = %s and t1.fiscal_year = %s and
					t1.docstatus = 1 %s
					group by %s
				""" %
				(query_details, conditions["trans"], conditions["trans"], conditions["addl_tables"],
					"%s", "%s", cond,conditions["group_by"]),
				(filters.get("company"), filters.get("fiscal_year")), as_list=1)

	return data

def get_mon(dt):
	return getdate(dt).strftime("%b")

def period_wise_colums_query(filters, trans):
	query_details = ''
	pwc = []
	bet_dates = get_period_date_ranges(filters.get("period"), filters.get("fiscal_year"))

	if trans in ['Purchase Receipt', 'Delivery Note', 'Purchase Invoice', 'Sales Invoice']:
		trans_date = 'posting_date'
	else:
		trans_date = 'transaction_date'

	if filters.get("period") != 'Yearly':
		for dt in bet_dates:
			get_period_wise_columns(dt, filters.get("period"), pwc)
			query_details = get_period_wise_query(dt, trans_date, query_details)
	else:
		pwc = [filters.get("fiscal_year") + " (Qty):Float:120",
			filters.get("fiscal_year") + " (Amt):Currency:120"]
		query_details = " SUM(t2.qty), SUM(t1.grand_total),"

	query_details += 'SUM(t2.qty), SUM(t1.grand_total)'
	return pwc, query_details

def get_period_wise_columns(bet_dates, period, pwc):
	if period == 'Monthly':
		pwc += [get_mon(bet_dates[0]) + " (Qty):Float:120",
			get_mon(bet_dates[0]) + " (Amt):Currency:120"]
	else:
		pwc += [get_mon(bet_dates[0]) + "-" + get_mon(bet_dates[1]) + " (Qty):Float:120",
			get_mon(bet_dates[0]) + "-" + get_mon(bet_dates[1]) + " (Amt):Currency:120"]

def get_period_wise_query(bet_dates, trans_date, query_details):
	query_details += """SUM(IF(t1.%(trans_date)s BETWEEN '%(sd)s' AND '%(ed)s', t2.qty, NULL)),
					SUM(IF(t1.%(trans_date)s BETWEEN '%(sd)s' AND '%(ed)s', t1.grand_total, NULL)),
				""" % {"trans_date": trans_date, "sd": bet_dates[0],"ed": bet_dates[1]}
	return query_details

@frappe.whitelist(allow_guest=True)
def get_period_date_ranges(period, fiscal_year=None, year_start_date=None):
	from dateutil.relativedelta import relativedelta

	if not year_start_date:
		year_start_date, year_end_date = frappe.db.get_value("Fiscal Year",
			fiscal_year, ["year_start_date", "year_end_date"])

	increment = {
		"Monthly": 1,
		"Quarterly": 3,
		"Half-Yearly": 6,
		"Yearly": 12
	}.get(period)

	period_date_ranges = []
	for i in xrange(1, 13, increment):
		period_end_date = getdate(year_start_date) + relativedelta(months=increment, days=-1)
		if period_end_date > getdate(year_end_date):
			period_end_date = year_end_date
		period_date_ranges.append([year_start_date, period_end_date])
		year_start_date = period_end_date + relativedelta(days=1)
		if period_end_date == year_end_date:
			break

	return period_date_ranges

def get_period_month_ranges(period, fiscal_year):
	from dateutil.relativedelta import relativedelta
	period_month_ranges = []

	for start_date, end_date in get_period_date_ranges(period, fiscal_year):
		months_in_this_period = []
		while start_date <= end_date:
			months_in_this_period.append(start_date.strftime("%B"))
			start_date += relativedelta(months=1)
		period_month_ranges.append(months_in_this_period)

	return period_month_ranges

def based_wise_colums_query(based_on, trans):
	based_on_details = {}

	# based_on_cols, based_on_select, based_on_group_by, addl_tables
	if based_on == "Item":
		based_on_details["based_on_cols"] = ["Item:Link/Item:120", "Item Name:Data:120"]
		based_on_details["based_on_select"] = "t2.item_code, t2.item_name,"
		based_on_details["based_on_group_by"] = 't2.item_code'
		based_on_details["addl_tables"] = ''

	elif based_on == "Item Group":
		based_on_details["based_on_cols"] = ["Item Group:Link/Item Group:120"]
		based_on_details["based_on_select"] = "t2.item_group,"
		based_on_details["based_on_group_by"] = 't2.item_group'
		based_on_details["addl_tables"] = ''

	elif based_on == "Customer":
		based_on_details["based_on_cols"] = ["Customer:Link/Customer:120", "Territory:Link/Territory:120"]
		based_on_details["based_on_select"] = "t1.customer_name, t1.territory, "
		based_on_details["based_on_group_by"] = 't1.customer_name'
		based_on_details["addl_tables"] = ''

	elif based_on == "Customer Group":
		based_on_details["based_on_cols"] = ["Customer Group:Link/Customer Group"]
		based_on_details["based_on_select"] = "t1.customer_group,"
		based_on_details["based_on_group_by"] = 't1.customer_group'
		based_on_details["addl_tables"] = ''

	elif based_on == 'Supplier':
		based_on_details["based_on_cols"] = ["Supplier:Link/Supplier:120", "Supplier Type:Link/Supplier Type:140"]
		based_on_details["based_on_select"] = "t1.supplier, t3.supplier_type,"
		based_on_details["based_on_group_by"] = 't1.supplier'
		based_on_details["addl_tables"] = ',`tabSupplier` t3'

	elif based_on == 'Supplier Type':
		based_on_details["based_on_cols"] = ["Supplier Type:Link/Supplier Type:140"]
		based_on_details["based_on_select"] = "t3.supplier_type,"
		based_on_details["based_on_group_by"] = 't3.supplier_type'
		based_on_details["addl_tables"] =',`tabSupplier` t3'

	elif based_on == "Territory":
		based_on_details["based_on_cols"] = ["Territory:Link/Territory:120"]
		based_on_details["based_on_select"] = "t1.territory,"
		based_on_details["based_on_group_by"] = 't1.territory'
		based_on_details["addl_tables"] = ''

	elif based_on == "Project":
		if trans in ['Sales Invoice', 'Delivery Note', 'Sales Order']:
			based_on_details["based_on_cols"] = ["Project:Link/Project:120"]
			based_on_details["based_on_select"] = "t1.project_name,"
			based_on_details["based_on_group_by"] = 't1.project_name'
			based_on_details["addl_tables"] = ''
		elif trans in ['Purchase Order', 'Purchase Invoice', 'Purchase Receipt']:
			based_on_details["based_on_cols"] = ["Project:Link/Project:120"]
			based_on_details["based_on_select"] = "t2.project_name,"
			based_on_details["based_on_group_by"] = 't2.project_name'
			based_on_details["addl_tables"] = ''
		else:
			frappe.throw(_("Project-wise data is not available for Quotation"))

	return based_on_details

def group_wise_column(group_by):
	if group_by:
		return [group_by+":Link/"+group_by+":120"]
	else:
		return []

########NEW FILE########
__FILENAME__ = feed
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
import frappe.defaults
from frappe.model.document import Document

class Feed(Document):
	pass

def on_doctype_update():
	if not frappe.db.sql("""show index from `tabFeed`
		where Key_name="feed_doctype_docname_index" """):
		frappe.db.commit()
		frappe.db.sql("""alter table `tabFeed`
			add index feed_doctype_docname_index(doc_type, doc_name)""")

def get_permission_query_conditions():
	restrictions = frappe.defaults.get_restrictions()
	can_read = frappe.user.get_can_read()

	can_read_doctypes = ['"{}"'.format(doctype) for doctype in
		list(set(can_read) - set(restrictions.keys()))]

	if not can_read_doctypes:
		return ""

	conditions = ["tabFeed.doc_type in ({})".format(", ".join(can_read_doctypes))]

	if restrictions:
		can_read_docs = []
		for doctype, names in restrictions.items():
			for n in names:
				can_read_docs.append('"{}|{}"'.format(doctype, n))

		if can_read_docs:
			conditions.append("concat_ws('|', tabFeed.doc_type, tabFeed.doc_name) in ({})".format(
				", ".join(can_read_docs)))

	return "(" + " or ".join(conditions) + ")"

def has_permission(doc):
	return frappe.has_permission(doc.doc_type, "read", doc.doc_name)

########NEW FILE########
__FILENAME__ = activity
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cint

@frappe.whitelist()
def get_feed(limit_start, limit_page_length):
	"""get feed"""
	return frappe.get_list("Feed", fields=["name", "feed_type", "doc_type", "subject", "owner", "modified"],
		limit_start = limit_start, limit_page_length = limit_page_length)

########NEW FILE########
__FILENAME__ = hooks
app_name = "erpnext"
app_title = "ERPNext"
app_publisher = "Web Notes Technologies Pvt. Ltd. and Contributors"
app_description = "Open Source Enterprise Resource Planning for Small and Midsized Organizations"
app_icon = "icon-th"
app_color = "#e74c3c"
app_version = "4.0.0-wip"

app_include_js = "assets/js/erpnext.min.js"
app_include_css = "assets/css/erpnext.css"
web_include_js = "assets/js/erpnext-web.min.js"

after_install = "erpnext.setup.install.after_install"

boot_session = "erpnext.startup.boot.boot_session"
notification_config = "erpnext.startup.notifications.get_notification_config"

dump_report_map = "erpnext.startup.report_data_map.data_map"
update_website_context = "erpnext.startup.webutils.update_website_context"

mail_footer = "erpnext.startup.mail_footer"

on_session_creation = "erpnext.startup.event_handlers.on_session_creation"
before_tests = "erpnext.setup.utils.before_tests"

standard_queries = "Customer:erpnext.selling.doctype.customer.customer.get_customer_list"

permission_query_conditions = {
		"Feed": "erpnext.home.doctype.feed.feed.get_permission_query_conditions",
	}

has_permission = {
		"Feed": "erpnext.home.doctype.feed.feed.has_permission",
	}


doc_events = {
	"*": {
		"on_update": "erpnext.home.update_feed",
		"on_submit": "erpnext.home.update_feed"
	},
	"Comment": {
		"on_update": "erpnext.home.make_comment_feed"
	},
	"Stock Entry": {
		"on_submit": "erpnext.stock.doctype.material_request.material_request.update_completed_qty",
		"on_cancel": "erpnext.stock.doctype.material_request.material_request.update_completed_qty"
	},
	"User": {
		"on_update": "erpnext.hr.doctype.employee.employee.update_user_default"
	}
}

scheduler_events = {
	"all": [
		"erpnext.support.doctype.support_ticket.get_support_mails.get_support_mails",
		"erpnext.hr.doctype.job_applicant.get_job_applications.get_job_applications",
		"erpnext.selling.doctype.lead.get_leads.get_leads"
	],
	"daily": [
		"erpnext.accounts.doctype.sales_invoice.sales_invoice.manage_recurring_invoices",
		"erpnext.stock.utils.reorder_item",
		"erpnext.setup.doctype.email_digest.email_digest.send",
		"erpnext.support.doctype.support_ticket.support_ticket.auto_close_tickets"
	],
	"daily_long": [
		"erpnext.setup.doctype.backup_manager.backup_manager.take_backups_daily"
	],
	"weekly_long": [
		"erpnext.setup.doctype.backup_manager.backup_manager.take_backups_weekly"
	]
}

########NEW FILE########
__FILENAME__ = appraisal
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import flt, getdate

from frappe import _
from frappe.model.mapper import get_mapped_doc
from frappe.model.document import Document

class Appraisal(Document):
	def validate(self):
		if not self.status:
			self.status = "Draft"

		self.validate_dates()
		self.validate_existing_appraisal()
		self.calculate_total()

	def get_employee_name(self):
		self.employee_name = frappe.db.get_value("Employee", self.employee, "employee_name")
		return self.employee_name

	def validate_dates(self):
		if getdate(self.start_date) > getdate(self.end_date):
			frappe.throw(_("End Date can not be less than Start Date"))

	def validate_existing_appraisal(self):
		chk = frappe.db.sql("""select name from `tabAppraisal` where employee=%s
			and (status='Submitted' or status='Completed')
			and ((start_date>=%s and start_date<=%s)
			or (end_date>=%s and end_date<=%s))""",
			(self.employee,self.start_date,self.end_date,self.start_date,self.end_date))
		if chk:
			frappe.throw(_("Appraisal {0} created for Employee {1} in the given date range").format(chk[0][0], self.employee_name))

	def calculate_total(self):
		total, total_w  = 0, 0
		for d in self.get('appraisal_details'):
			if d.score:
				d.score_earned = flt(d.score) * flt(d.per_weightage) / 100
				total = total + d.score_earned
			total_w += flt(d.per_weightage)

		if int(total_w) != 100:
			frappe.throw(_("Total weightage assigned should be 100%. It is {0}").format(str(total_w) + "%"))

		if frappe.db.get_value("Employee", self.employee, "user_id") != \
				frappe.session.user and total == 0:
			frappe.throw(_("Total cannot be zero"))

		self.total_score = total

	def on_submit(self):
		frappe.db.set(self, 'status', 'Submitted')

	def on_cancel(self):
		frappe.db.set(self, 'status', 'Cancelled')

@frappe.whitelist()
def fetch_appraisal_template(source_name, target_doc=None):
	target_doc = get_mapped_doc("Appraisal Template", source_name, {
		"Appraisal Template": {
			"doctype": "Appraisal",
		},
		"Appraisal Template Goal": {
			"doctype": "Appraisal Goal",
		}
	}, target_doc)

	return target_doc

########NEW FILE########
__FILENAME__ = appraisal_goal
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class AppraisalGoal(Document):
	pass
########NEW FILE########
__FILENAME__ = appraisal_template
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _

from frappe.model.document import Document

class AppraisalTemplate(Document):
	def validate(self):
		self.total_points = 0
		for d in self.get("kra_sheet"):
			self.total_points += int(d.per_weightage or 0)

		if int(self.total_points) != 100:
			frappe.throw(_("Total points for all goals should be 100. It is {0}").format(self.total_points))

########NEW FILE########
__FILENAME__ = appraisal_template_goal
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class AppraisalTemplateGoal(Document):
	pass
########NEW FILE########
__FILENAME__ = attendance
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import getdate, nowdate
from frappe import _
from frappe.model.document import Document

class Attendance(Document):
	def validate_duplicate_record(self):
		res = frappe.db.sql("""select name from `tabAttendance` where employee = %s and att_date = %s
			and name != %s and docstatus = 1""",
			(self.employee, self.att_date, self.name))
		if res:
			frappe.throw(_("Attendance for employee {0} is already marked").format(self.employee))

	def check_leave_record(self):
		if self.status == 'Present':
			leave = frappe.db.sql("""select name from `tabLeave Application`
				where employee = %s and %s between from_date and to_date and status = 'Approved'
				and docstatus = 1""", (self.employee, self.att_date))

			if leave:
				frappe.throw(_("Employee {0} was on leave on {1}. Cannot mark attendance.").format(self.employee,
					self.att_date))

	def validate_fiscal_year(self):
		from erpnext.accounts.utils import validate_fiscal_year
		validate_fiscal_year(self.att_date, self.fiscal_year)

	def validate_att_date(self):
		if getdate(self.att_date) > getdate(nowdate()):
			frappe.throw(_("Attendance can not be marked for future dates"))

	def validate_employee(self):
		emp = frappe.db.sql("select name from `tabEmployee` where name = %s and status = 'Active'",
		 	self.employee)
		if not emp:
			frappe.throw(_("Employee {0} is not active or does not exist").format(self.employee))

	def validate(self):
		from erpnext.utilities import validate_status
		validate_status(self.status, ["Present", "Absent", "Half Day"])
		self.validate_fiscal_year()
		self.validate_att_date()
		self.validate_duplicate_record()
		self.check_leave_record()

	def on_update(self):
		# this is done because sometimes user entered wrong employee name
		# while uploading employee attendance
		employee_name = frappe.db.get_value("Employee", self.employee, "employee_name")
		frappe.db.set(self, 'employee_name', employee_name)

########NEW FILE########
__FILENAME__ = branch
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class Branch(Document):
	pass
########NEW FILE########
__FILENAME__ = test_branch
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Branch')
########NEW FILE########
__FILENAME__ = deduction_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class DeductionType(Document):
	pass
########NEW FILE########
__FILENAME__ = test_deduction_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Deduction Type')
########NEW FILE########
__FILENAME__ = department
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class Department(Document):
	pass
########NEW FILE########
__FILENAME__ = test_department
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

test_ignore = ["Leave Block List"]


import frappe
test_records = frappe.get_test_records('Department')
########NEW FILE########
__FILENAME__ = designation
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class Designation(Document):
	pass
########NEW FILE########
__FILENAME__ = test_designation
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Designation')
########NEW FILE########
__FILENAME__ = earning_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class EarningType(Document):
	pass
########NEW FILE########
__FILENAME__ = test_earning_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Earning Type')
########NEW FILE########
__FILENAME__ = employee
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import getdate, validate_email_add, cint
from frappe.model.naming import make_autoname
from frappe import throw, _
import frappe.permissions
from frappe.defaults import get_restrictions
from frappe.model.document import Document
from frappe.model.mapper import get_mapped_doc

class Employee(Document):
	def onload(self):
		self.get("__onload").salary_structure_exists = frappe.db.get_value("Salary Structure",
			{"employee": self.name, "is_active": "Yes", "docstatus": ["!=", 2]})

	def autoname(self):
		naming_method = frappe.db.get_value("HR Settings", None, "emp_created_by")
		if not naming_method:
			throw(_("Please setup Employee Naming System in Human Resource > HR Settings"))
		else:
			if naming_method=='Naming Series':
				self.name = make_autoname(self.naming_series + '.####')
			elif naming_method=='Employee Number':
				self.name = self.employee_number

		self.employee = self.name

	def validate(self):
		from erpnext.utilities import validate_status
		validate_status(self.status, ["Active", "Left"])

		self.employee = self.name
		self.validate_date()
		self.validate_email()
		self.validate_status()
		self.validate_employee_leave_approver()

		if self.user_id:
			self.validate_for_enabled_user_id()
			self.validate_duplicate_user_id()

	def on_update(self):
		if self.user_id:
			self.update_user_default()
			self.update_user()

		self.update_dob_event()
		self.restrict_leave_approver()

	def restrict_user(self):
		"""restrict to this employee for user"""
		self.add_restriction_if_required("Employee", self.user_id)

	def update_user_default(self):
		self.restrict_user()
		frappe.db.set_default("employee_name", self.employee_name, self.user_id)
		frappe.db.set_default("company", self.company, self.user_id)

	def restrict_leave_approver(self):
		"""restrict to this employee for leave approver"""
		employee_leave_approvers = [d.leave_approver for d in self.get("employee_leave_approvers")]
		if self.reports_to and self.reports_to not in employee_leave_approvers:
			employee_leave_approvers.append(frappe.db.get_value("Employee", self.reports_to, "user_id"))

		for user in employee_leave_approvers:
			self.add_restriction_if_required("Employee", user)
			self.add_restriction_if_required("Leave Application", user)

	def add_restriction_if_required(self, doctype, user):
		if frappe.permissions.has_only_non_restrict_role(doctype, user) \
			and self.name not in get_restrictions(user).get("Employee", []):

			frappe.defaults.add_default("Employee", self.name, user, "Restriction")

	def update_user(self):
		# add employee role if missing
		user = frappe.get_doc("User", self.user_id)
		user.ignore_permissions = True

		if "Employee" not in user.get("user_roles"):
			user.add_roles("Employee")

		# copy details like Fullname, DOB and Image to User
		if self.employee_name:
			employee_name = self.employee_name.split(" ")
			if len(employee_name) >= 3:
				user.last_name = " ".join(employee_name[2:])
				user.middle_name = employee_name[1]
			elif len(employee_name) == 2:
				user.last_name = employee_name[1]

			user.first_name = employee_name[0]

		if self.date_of_birth:
			user.birth_date = self.date_of_birth

		if self.gender:
			user.gender = self.gender

		if self.image:
			if not user.user_image:
				user.user_image = self.image
				try:
					frappe.get_doc({
						"doctype": "File Data",
						"file_name": self.image,
						"attached_to_doctype": "User",
						"attached_to_name": self.user_id
					}).insert()
				except frappe.DuplicateEntryError, e:
					# already exists
					pass

		user.save()

	def validate_date(self):
		if self.date_of_birth and self.date_of_joining and getdate(self.date_of_birth) >= getdate(self.date_of_joining):
			throw(_("Date of Joining must be greater than Date of Birth"))

		elif self.date_of_retirement and self.date_of_joining and (getdate(self.date_of_retirement) <= getdate(self.date_of_joining)):
			throw(_("Date Of Retirement must be greater than Date of Joining"))

		elif self.relieving_date and self.date_of_joining and (getdate(self.relieving_date) <= getdate(self.date_of_joining)):
			throw(_("Relieving Date must be greater than Date of Joining"))

		elif self.contract_end_date and self.date_of_joining and (getdate(self.contract_end_date)<=getdate(self.date_of_joining)):
			throw(_("Contract End Date must be greater than Date of Joining"))

	def validate_email(self):
		if self.company_email and not validate_email_add(self.company_email):
			throw(_("Please enter valid Company Email"))
		if self.personal_email and not validate_email_add(self.personal_email):
			throw(_("Please enter valid Personal Email"))

	def validate_status(self):
		if self.status == 'Left' and not self.relieving_date:
			throw(_("Please enter relieving date."))

	def validate_for_enabled_user_id(self):
		if not self.status == 'Active':
			return
		enabled = frappe.db.sql("""select name from `tabUser` where
			name=%s and enabled=1""", self.user_id)
		if not enabled:
			throw(_("User {0} is disabled").format(self.user_id))

	def validate_duplicate_user_id(self):
		employee = frappe.db.sql_list("""select name from `tabEmployee` where
			user_id=%s and status='Active' and name!=%s""", (self.user_id, self.name))
		if employee:
			throw(_("User {0} is already assigned to Employee {1}").format(self.user_id, employee[0]))

	def validate_employee_leave_approver(self):
		from frappe.utils.user import User
		from erpnext.hr.doctype.leave_application.leave_application import InvalidLeaveApproverError

		for l in self.get("employee_leave_approvers"):
			if "Leave Approver" not in User(l.leave_approver).get_roles():
				throw(_("{0} is not a valid Leave Approver").format(l.leave_approver), InvalidLeaveApproverError)

	def update_dob_event(self):
		if self.status == "Active" and self.date_of_birth \
			and not cint(frappe.db.get_value("HR Settings", None, "stop_birthday_reminders")):
			birthday_event = frappe.db.sql("""select name from `tabEvent` where repeat_on='Every Year'
				and ref_type='Employee' and ref_name=%s""", self.name)

			starts_on = self.date_of_birth + " 00:00:00"
			ends_on = self.date_of_birth + " 00:15:00"

			if birthday_event:
				event = frappe.get_doc("Event", birthday_event[0][0])
				event.starts_on = starts_on
				event.ends_on = ends_on
				event.save()
			else:
				frappe.get_doc({
					"doctype": "Event",
					"subject": _("Birthday") + ": " + self.employee_name,
					"description": _("Happy Birthday!") + " " + self.employee_name,
					"starts_on": starts_on,
					"ends_on": ends_on,
					"event_type": "Public",
					"all_day": 1,
					"send_reminder": 1,
					"repeat_this_event": 1,
					"repeat_on": "Every Year",
					"ref_type": "Employee",
					"ref_name": self.name
				}).insert()
		else:
			frappe.db.sql("""delete from `tabEvent` where repeat_on='Every Year' and
				ref_type='Employee' and ref_name=%s""", self.name)

@frappe.whitelist()
def get_retirement_date(date_of_birth=None):
	import datetime
	ret = {}
	if date_of_birth:
		dt = getdate(date_of_birth) + datetime.timedelta(21915)
		ret = {'date_of_retirement': dt.strftime('%Y-%m-%d')}
	return ret

@frappe.whitelist()
def make_salary_structure(source_name, target=None):
	target = get_mapped_doc("Employee", source_name, {
		"Employee": {
			"doctype": "Salary Structure",
			"field_map": {
				"name": "employee"
			}
		}
	})
	target.make_earn_ded_table()
	return target

def update_user_default(doc, method):
	# called via User hook
	try:
		employee = frappe.get_doc("Employee", {"user_id": doc.name})
		employee.update_user_default()
	except frappe.DoesNotExistError:
		pass

########NEW FILE########
__FILENAME__ = test_employee
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Employee')
########NEW FILE########
__FILENAME__ = employee_education
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class EmployeeEducation(Document):
	pass
########NEW FILE########
__FILENAME__ = employee_external_work_history
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class EmployeeExternalWorkHistory(Document):
	pass
########NEW FILE########
__FILENAME__ = employee_internal_work_history
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class EmployeeInternalWorkHistory(Document):
	pass
########NEW FILE########
__FILENAME__ = employee_leave_approver
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class EmployeeLeaveApprover(Document):
	pass
########NEW FILE########
__FILENAME__ = employment_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class EmploymentType(Document):
	pass
########NEW FILE########
__FILENAME__ = test_employment_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Employment Type')
########NEW FILE########
__FILENAME__ = expense_claim
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.model.document import Document

class ExpenseClaim(Document):
	def validate(self):
		self.validate_fiscal_year()
		self.validate_exp_details()

	def on_submit(self):
		if self.approval_status=="Draft":
			frappe.throw(_("""Approval Status must be 'Approved' or 'Rejected'"""))

	def validate_fiscal_year(self):
		from erpnext.accounts.utils import validate_fiscal_year
		validate_fiscal_year(self.posting_date, self.fiscal_year, "Posting Date")

	def validate_exp_details(self):
		if not self.get('expense_voucher_details'):
			frappe.throw(_("Please add expense voucher details"))

########NEW FILE########
__FILENAME__ = expense_claim_detail
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ExpenseClaimDetail(Document):
	pass
########NEW FILE########
__FILENAME__ = expense_claim_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ExpenseClaimType(Document):
	pass
########NEW FILE########
__FILENAME__ = holiday
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class Holiday(Document):
	pass
########NEW FILE########
__FILENAME__ = holiday_list
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import cint
from frappe.model.naming import make_autoname
from frappe import throw, _

from frappe.model.document import Document

class HolidayList(Document):
	def autoname(self):
		self.name = make_autoname(self.fiscal_year + "/" + self.holiday_list_name + "/.###")

	def validate(self):
		self.update_default_holiday_list()

	def get_weekly_off_dates(self):
		self.validate_values()
		yr_start_date, yr_end_date = self.get_fy_start_end_dates()
		date_list = self.get_weekly_off_date_list(yr_start_date, yr_end_date)
		last_idx = max([cint(d.idx) for d in self.get("holiday_list_details")] or [0,])
		for i, d in enumerate(date_list):
			ch = self.append('holiday_list_details', {})
			ch.description = self.weekly_off
			ch.holiday_date = d
			ch.idx = last_idx + i + 1

	def validate_values(self):
		if not self.fiscal_year:
			throw(_("Please select Fiscal Year"))
		if not self.weekly_off:
			throw(_("Please select weekly off day"))

	def get_fy_start_end_dates(self):
		return frappe.db.sql("""select year_start_date, year_end_date
			from `tabFiscal Year` where name=%s""", (self.fiscal_year,))[0]

	def get_weekly_off_date_list(self, year_start_date, year_end_date):
		from frappe.utils import getdate
		year_start_date, year_end_date = getdate(year_start_date), getdate(year_end_date)

		from dateutil import relativedelta
		from datetime import timedelta
		import calendar

		date_list = []
		weekday = getattr(calendar, (self.weekly_off).upper())
		reference_date = year_start_date + relativedelta.relativedelta(weekday=weekday)

		while reference_date <= year_end_date:
			date_list.append(reference_date)
			reference_date += timedelta(days=7)

		return date_list

	def clear_table(self):
		self.set('holiday_list_details', [])

	def update_default_holiday_list(self):
		frappe.db.sql("""update `tabHoliday List` set is_default = 0
			where ifnull(is_default, 0) = 1 and fiscal_year = %s""", (self.fiscal_year,))

########NEW FILE########
__FILENAME__ = test_holiday_list
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Holiday List')
########NEW FILE########
__FILENAME__ = hr_settings
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import cint

from frappe.model.document import Document

class HRSettings(Document):
		
	def validate(self):
		self.update_birthday_reminders()

		from erpnext.setup.doctype.naming_series.naming_series import set_by_naming_series
		set_by_naming_series("Employee", "employee_number", 
			self.get("emp_created_by")=="Naming Series", hide_name_field=True)
			
	def update_birthday_reminders(self):
		original_stop_birthday_reminders = cint(frappe.db.get_value("HR Settings", 
			None, "stop_birthday_reminders"))

		# reset birthday reminders
		if cint(self.stop_birthday_reminders) != original_stop_birthday_reminders:
			frappe.db.sql("""delete from `tabEvent` where repeat_on='Every Year' and ref_type='Employee'""")
		
			if not self.stop_birthday_reminders:
				for employee in frappe.db.sql_list("""select name from `tabEmployee` where status='Active' and 
					ifnull(date_of_birth, '')!=''"""):
					frappe.get_doc("Employee", employee).update_dob_event()
					
			frappe.msgprint(frappe._("Updated Birthday Reminders"))
########NEW FILE########
__FILENAME__ = get_job_applications
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cstr, cint
from frappe.utils.email_lib.receive import POP3Mailbox
from frappe.core.doctype.communication.communication import _make

class JobsMailbox(POP3Mailbox):	
	def setup(self, args=None):
		self.settings = args or frappe.get_doc("Jobs Email Settings", "Jobs Email Settings")
		
	def process_message(self, mail):
		if mail.from_email == self.settings.email_id:
			return
			
		name = frappe.db.get_value("Job Applicant", {"email_id": mail.from_email}, 
			"name")
		if name:
			applicant = frappe.get_doc("Job Applicant", name)
			if applicant.status!="Rejected":
				applicant.status = "Open"
			applicant.ignore_permissions = True
			applicant.save()
		else:
			name = (mail.from_real_name and (mail.from_real_name + " - ") or "") \
				+ mail.from_email
			applicant = frappe.get_doc({
				"creation": mail.date,
				"doctype":"Job Applicant",
				"applicant_name": name,
				"email_id": mail.from_email,
				"status": "Open"
			})
			applicant.ignore_permissions = True
			applicant.ignore_mandatory = True
			applicant.insert()
		
		mail.save_attachments_in_doc(applicant)
				
		_make(content=mail.content, sender=mail.from_email, subject=mail.subject or "No Subject",
			doctype="Job Applicant", name=applicant.name, sent_or_received="Received")

def get_job_applications():
	if cint(frappe.db.get_value('Jobs Email Settings', None, 'extract_emails')):
		JobsMailbox()
########NEW FILE########
__FILENAME__ = job_applicant
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from erpnext.utilities.transaction_base import TransactionBase
from frappe.utils import extract_email_id

class JobApplicant(TransactionBase):
	
	def get_sender(self, comm):
		return frappe.db.get_value('Jobs Email Settings',None,'email_id')	
	
	def validate(self):
		self.set_status()	
########NEW FILE########
__FILENAME__ = job_opening
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class JobOpening(Document):
	pass
########NEW FILE########
__FILENAME__ = leave_allocation
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cint, flt
from frappe import _

from frappe.model.document import Document

class LeaveAllocation(Document):
	def validate(self):
		self.validate_new_leaves_allocated_value()
		self.check_existing_leave_allocation()
		if not self.total_leaves_allocated:
			self.total_leaves_allocated = self.new_leaves_allocated

	def on_update_after_submit(self):
		self.validate_new_leaves_allocated_value()

	def on_update(self):
		self.get_total_allocated_leaves()

	def on_cancel(self):
		self.check_for_leave_application()

	def validate_new_leaves_allocated_value(self):
		"""validate that leave allocation is in multiples of 0.5"""
		if flt(self.new_leaves_allocated) % 0.5:
			frappe.throw(_("Leaves must be allocated in multiples of 0.5"))

	def check_existing_leave_allocation(self):
		"""check whether leave for same type is already allocated or not"""
		leave_allocation = frappe.db.sql("""select name from `tabLeave Allocation`
			where employee=%s and leave_type=%s and fiscal_year=%s and docstatus=1""",
			(self.employee, self.leave_type, self.fiscal_year))
		if leave_allocation:
			frappe.msgprint(_("Leaves for type {0} already allocated for Employee {1} for Fiscal Year {0}").format(self.leave_type,
				self.employee, self.fiscal_year))
			frappe.throw('<a href="#Form/Leave Allocation/{0}">{0}</a>'.format(leave_allocation[0][0]))

	def get_leave_bal(self, prev_fyear):
		return self.get_leaves_allocated(prev_fyear) - self.get_leaves_applied(prev_fyear)

	def get_leaves_applied(self, fiscal_year):
		leaves_applied = frappe.db.sql("""select SUM(ifnull(total_leave_days, 0))
			from `tabLeave Application` where employee=%s and leave_type=%s
			and fiscal_year=%s and docstatus=1""",
			(self.employee, self.leave_type, fiscal_year))
		return leaves_applied and flt(leaves_applied[0][0]) or 0

	def get_leaves_allocated(self, fiscal_year):
		leaves_allocated = frappe.db.sql("""select SUM(ifnull(total_leaves_allocated, 0))
			from `tabLeave Allocation` where employee=%s and leave_type=%s
			and fiscal_year=%s and docstatus=1 and name!=%s""",
			(self.employee, self.leave_type, fiscal_year, self.name))
		return leaves_allocated and flt(leaves_allocated[0][0]) or 0

	def allow_carry_forward(self):
		"""check whether carry forward is allowed or not for this leave type"""
		cf = frappe.db.sql("""select is_carry_forward from `tabLeave Type` where name = %s""",
			self.leave_type)
		cf = cf and cint(cf[0][0]) or 0
		if not cf:
			frappe.db.set(self,'carry_forward',0)
			frappe.throw(_("Cannot carry forward {0}").format(self.leave_type))

	def get_carry_forwarded_leaves(self):
		if self.carry_forward:
			self.allow_carry_forward()
		prev_fiscal_year = frappe.db.sql("""select name from `tabFiscal Year`
			where year_start_date = (select date_add(year_start_date, interval -1 year)
				from `tabFiscal Year` where name=%s)
			order by name desc limit 1""", self.fiscal_year)
		prev_fiscal_year = prev_fiscal_year and prev_fiscal_year[0][0] or ''
		prev_bal = 0
		if prev_fiscal_year and cint(self.carry_forward) == 1:
			prev_bal = self.get_leave_bal(prev_fiscal_year)
		ret = {
			'carry_forwarded_leaves': prev_bal,
			'total_leaves_allocated': flt(prev_bal) + flt(self.new_leaves_allocated)
		}
		return ret

	def get_total_allocated_leaves(self):
		leave_det = self.get_carry_forwarded_leaves()
		frappe.db.set(self,'carry_forwarded_leaves',flt(leave_det['carry_forwarded_leaves']))
		frappe.db.set(self,'total_leaves_allocated',flt(leave_det['total_leaves_allocated']))

	def check_for_leave_application(self):
		exists = frappe.db.sql("""select name from `tabLeave Application`
			where employee=%s and leave_type=%s and fiscal_year=%s and docstatus=1""",
			(self.employee, self.leave_type, self.fiscal_year))
		if exists:
			frappe.msgprint(_("Cannot cancel because Employee {0} is already approved for {1}").format(self.employee,
				self.leave_type))
			frappe.throw('<a href="#Form/Leave Application/{0}">{0}</a>'.format(exists[0][0]))


########NEW FILE########
__FILENAME__ = test_leave_allocation
import frappe

test_records = frappe.get_test_records('Leave Allocation')

########NEW FILE########
__FILENAME__ = leave_application
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _

from frappe.utils import cint, cstr, date_diff, flt, formatdate, getdate, get_url_to_form, \
	comma_or, get_fullname
from frappe import msgprint

class LeaveDayBlockedError(frappe.ValidationError): pass
class OverlapError(frappe.ValidationError): pass
class InvalidLeaveApproverError(frappe.ValidationError): pass
class LeaveApproverIdentityError(frappe.ValidationError): pass

from frappe.model.document import Document
class LeaveApplication(Document):
	def validate(self):
		if not getattr(self, "__islocal", None) and frappe.db.exists(self.doctype, self.name):
			self.previous_doc = frappe.db.get_value(self.doctype, self.name, "*", as_dict=True)
		else:
			self.previous_doc = None

		self.validate_to_date()
		self.validate_balance_leaves()
		self.validate_leave_overlap()
		self.validate_max_days()
		self.show_block_day_warning()
		self.validate_block_days()
		self.validate_leave_approver()

	def on_update(self):
		if (not self.previous_doc and self.leave_approver) or (self.previous_doc and \
				self.status == "Open" and self.previous_doc.leave_approver != self.leave_approver):
			# notify leave approver about creation
			self.notify_leave_approver()
		elif self.previous_doc and \
				self.previous_doc.status == "Open" and self.status == "Rejected":
			# notify employee about rejection
			self.notify_employee(self.status)

	def on_submit(self):
		if self.status != "Approved":
			frappe.throw(_("Only Leave Applications with status 'Approved' can be submitted"))

		# notify leave applier about approval
		self.notify_employee(self.status)

	def on_cancel(self):
		# notify leave applier about cancellation
		self.notify_employee("cancelled")

	def show_block_day_warning(self):
		from erpnext.hr.doctype.leave_block_list.leave_block_list import get_applicable_block_dates

		block_dates = get_applicable_block_dates(self.from_date, self.to_date,
			self.employee, self.company, all_lists=True)

		if block_dates:
			frappe.msgprint(_("Warning: Leave application contains following block dates") + ":")
			for d in block_dates:
				frappe.msgprint(formatdate(d.block_date) + ": " + d.reason)

	def validate_block_days(self):
		from erpnext.hr.doctype.leave_block_list.leave_block_list import get_applicable_block_dates

		block_dates = get_applicable_block_dates(self.from_date, self.to_date,
			self.employee, self.company)

		if block_dates:
			if self.status == "Approved":
				frappe.throw(_("Cannot approve leave as you are not authorized to approve leaves on Block Dates"),
					LeaveDayBlockedError)

	def get_holidays(self):
		tot_hol = frappe.db.sql("""select count(*) from `tabHoliday` h1, `tabHoliday List` h2, `tabEmployee` e1
			where e1.name = %s and h1.parent = h2.name and e1.holiday_list = h2.name
			and h1.holiday_date between %s and %s""", (self.employee, self.from_date, self.to_date))
		if not tot_hol:
			tot_hol = frappe.db.sql("""select count(*) from `tabHoliday` h1, `tabHoliday List` h2
				where h1.parent = h2.name and h1.holiday_date between %s and %s
				and ifnull(h2.is_default,0) = 1 and h2.fiscal_year = %s""",
				(self.from_date, self.to_date, self.fiscal_year))
		return tot_hol and flt(tot_hol[0][0]) or 0

	def get_total_leave_days(self):
		"""Calculates total leave days based on input and holidays"""
		ret = {'total_leave_days' : 0.5}
		if not self.half_day:
			tot_days = date_diff(self.to_date, self.from_date) + 1
			holidays = self.get_holidays()
			ret = {
				'total_leave_days' : flt(tot_days)-flt(holidays)
			}
		return ret

	def validate_to_date(self):
		if self.from_date and self.to_date and \
				(getdate(self.to_date) < getdate(self.from_date)):
			frappe.throw(_("To date cannot be before from date"))

	def validate_balance_leaves(self):
		if self.from_date and self.to_date:
			self.total_leave_days = self.get_total_leave_days()["total_leave_days"]

			if self.total_leave_days == 0:
				frappe.throw(_("The day(s) on which you are applying for leave are holiday. You need not apply for leave."))

			if not is_lwp(self.leave_type):
				self.leave_balance = get_leave_balance(self.employee,
					self.leave_type, self.fiscal_year)["leave_balance"]

				if self.status != "Rejected" \
						and self.leave_balance - self.total_leave_days < 0:
					#check if this leave type allow the remaining balance to be in negative. If yes then warn the user and continue to save else warn the user and don't save.
					if frappe.db.get_value("Leave Type", self.leave_type, "allow_negative"):
						frappe.msgprint(_("Note: There is not enough leave balance for Leave Type {0}").format(self.leave_type))
					else:
						frappe.throw(_("There is not enough leave balance for Leave Type {0}").format(self.leave_type))


	def validate_leave_overlap(self):
		if not self.name:
			self.name = "New Leave Application"

		for d in frappe.db.sql("""select name, leave_type, posting_date,
			from_date, to_date
			from `tabLeave Application`
			where
			employee = %(employee)s
			and docstatus < 2
			and status in ("Open", "Approved")
			and (from_date between %(from_date)s and %(to_date)s
				or to_date between %(from_date)s and %(to_date)s
				or %(from_date)s between from_date and to_date)
			and name != %(name)s""", self.as_dict(), as_dict = 1):

			frappe.msgprint(_("Employee {0} has already applied for {1} between {2} and {3}").format(self.employee,
				cstr(d['leave_type']), formatdate(d['from_date']), formatdate(d['to_date'])))
			frappe.throw('<a href="#Form/Leave Application/{0}">{0}</a>'.format(d["name"]), OverlapError)

	def validate_max_days(self):
		max_days = frappe.db.get_value("Leave Type", self.leave_type, "max_days_allowed")
		if max_days and self.total_leave_days > max_days:
			frappe.throw(_("Leave of type {0} cannot be longer than {1}").format(self.leave_type, max_days))

	def validate_leave_approver(self):
		employee = frappe.get_doc("Employee", self.employee)
		leave_approvers = [l.leave_approver for l in
			employee.get("employee_leave_approvers")]

		if len(leave_approvers) and self.leave_approver not in leave_approvers:
			frappe.throw(_("Leave approver must be one of {0}").format(comma_or(leave_approvers)), InvalidLeaveApproverError)

		elif self.leave_approver and not frappe.db.sql("""select name from `tabUserRole`
			where parent=%s and role='Leave Approver'""", self.leave_approver):
			frappe.throw(_("{0} must have role 'Leave Approver'").format(get_fullname(self.leave_approver)),
				InvalidLeaveApproverError)

		elif self.docstatus==1 and len(leave_approvers) and self.leave_approver != frappe.session.user:
			msgprint(_("Only the selected Leave Approver can submit this Leave Application"),
				raise_exception=LeaveApproverIdentityError)

	def notify_employee(self, status):
		employee = frappe.get_doc("Employee", self.employee)
		if not employee.user_id:
			return

		def _get_message(url=False):
			if url:
				name = get_url_to_form(self.doctype, self.name)
			else:
				name = self.name

			return (_("Leave Application") + ": %s - %s") % (name, _(status))

		self.notify({
			# for post in messages
			"message": _get_message(url=True),
			"message_to": employee.user_id,
			"subject": _get_message(),
		})

	def notify_leave_approver(self):
		employee = frappe.get_doc("Employee", self.employee)

		def _get_message(url=False):
			name = self.name
			employee_name = cstr(employee.employee_name)
			if url:
				name = get_url_to_form(self.doctype, self.name)
				employee_name = get_url_to_form("Employee", self.employee, label=employee_name)

			return (_("New Leave Application") + ": %s - " + _("Employee") + ": %s") % (name, employee_name)

		self.notify({
			# for post in messages
			"message": _get_message(url=True),
			"message_to": self.leave_approver,

			# for email
			"subject": _get_message()
		})

	def notify(self, args):
		args = frappe._dict(args)
		from frappe.core.page.messages.messages import post
		post({"txt": args.message, "contact": args.message_to, "subject": args.subject,
			"notify": cint(self.follow_via_email)})

@frappe.whitelist()
def get_leave_balance(employee, leave_type, fiscal_year):
	leave_all = frappe.db.sql("""select total_leaves_allocated
		from `tabLeave Allocation` where employee = %s and leave_type = %s
		and fiscal_year = %s and docstatus = 1""", (employee,
			leave_type, fiscal_year))

	leave_all = leave_all and flt(leave_all[0][0]) or 0

	leave_app = frappe.db.sql("""select SUM(total_leave_days)
		from `tabLeave Application`
		where employee = %s and leave_type = %s and fiscal_year = %s
		and status="Approved" and docstatus = 1""", (employee, leave_type, fiscal_year))
	leave_app = leave_app and flt(leave_app[0][0]) or 0

	ret = {'leave_balance': leave_all - leave_app}
	return ret

def is_lwp(leave_type):
	lwp = frappe.db.sql("select is_lwp from `tabLeave Type` where name = %s", leave_type)
	return lwp and cint(lwp[0][0]) or 0

@frappe.whitelist()
def get_events(start, end):
	events = []
	employee = frappe.db.get_default("employee", frappe.session.user)
	company = frappe.db.get_default("company", frappe.session.user)

	from frappe.widgets.reportview import build_match_conditions
	match_conditions = build_match_conditions("Leave Application")

	# show department leaves for employee
	if "Employee" in frappe.get_roles():
		add_department_leaves(events, start, end, employee, company)

	add_leaves(events, start, end, employee, company, match_conditions)

	add_block_dates(events, start, end, employee, company)
	add_holidays(events, start, end, employee, company)

	return events

def add_department_leaves(events, start, end, employee, company):
	department = frappe.db.get_value("Employee", employee, "department")

	if not department:
		return

	# department leaves
	department_employees = frappe.db.sql_list("""select name from tabEmployee where department=%s
		and company=%s""", (department, company))

	match_conditions = "employee in (\"%s\")" % '", "'.join(department_employees)
	add_leaves(events, start, end, employee, company, match_conditions=match_conditions)

def add_leaves(events, start, end, employee, company, match_conditions=None):
	query = """select name, from_date, to_date, employee_name, half_day,
		status, employee, docstatus
		from `tabLeave Application` where
		(from_date between %s and %s or to_date between %s and %s)
		and docstatus < 2
		and status!="Rejected" """
	if match_conditions:
		query += " and " + match_conditions

	for d in frappe.db.sql(query, (start, end, start, end), as_dict=True):
		e = {
			"name": d.name,
			"doctype": "Leave Application",
			"from_date": d.from_date,
			"to_date": d.to_date,
			"status": d.status,
			"title": cstr(d.employee_name) + \
				(d.half_day and _(" (Half Day)") or ""),
			"docstatus": d.docstatus
		}
		if e not in events:
			events.append(e)

def add_block_dates(events, start, end, employee, company):
	# block days
	from erpnext.hr.doctype.leave_block_list.leave_block_list import get_applicable_block_dates

	cnt = 0
	block_dates = get_applicable_block_dates(start, end, employee, company, all_lists=True)

	for block_date in block_dates:
		events.append({
			"doctype": "Leave Block List Date",
			"from_date": block_date.block_date,
			"title": _("Leave Blocked") + ": " + block_date.reason,
			"name": "_" + str(cnt),
		})
		cnt+=1

def add_holidays(events, start, end, employee, company):
	applicable_holiday_list = frappe.db.get_value("Employee", employee, "holiday_list")
	if not applicable_holiday_list:
		return

	for holiday in frappe.db.sql("""select name, holiday_date, description
		from `tabHoliday` where parent=%s and holiday_date between %s and %s""",
		(applicable_holiday_list, start, end), as_dict=True):
			events.append({
				"doctype": "Holiday",
				"from_date": holiday.holiday_date,
				"title": _("Holiday") + ": " + cstr(holiday.description),
				"name": holiday.name
			})

########NEW FILE########
__FILENAME__ = test_leave_application
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

import frappe
import unittest

from erpnext.hr.doctype.leave_application.leave_application import LeaveDayBlockedError, OverlapError
from frappe.core.page.user_properties.user_properties import clear_restrictions

test_dependencies = ["Leave Allocation", "Leave Block List"]

_test_records = [
 {
  "company": "_Test Company",
  "doctype": "Leave Application",
  "employee": "_T-Employee-0001",
  "fiscal_year": "_Test Fiscal Year 2013",
  "from_date": "2013-05-01",
  "leave_type": "_Test Leave Type",
  "posting_date": "2013-01-02",
  "to_date": "2013-05-05"
 },
 {
  "company": "_Test Company",
  "doctype": "Leave Application",
  "employee": "_T-Employee-0002",
  "fiscal_year": "_Test Fiscal Year 2013",
  "from_date": "2013-05-01",
  "leave_type": "_Test Leave Type",
  "posting_date": "2013-01-02",
  "to_date": "2013-05-05"
 },
 {
  "company": "_Test Company",
  "doctype": "Leave Application",
  "employee": "_T-Employee-0001",
  "fiscal_year": "_Test Fiscal Year 2013",
  "from_date": "2013-01-15",
  "leave_type": "_Test Leave Type LWP",
  "posting_date": "2013-01-02",
  "to_date": "2013-01-15"
 }
]


class TestLeaveApplication(unittest.TestCase):
	def tearDown(self):
		frappe.set_user("Administrator")

		# so that this test doesn't affect other tests
		frappe.db.sql("""delete from `tabEmployee Leave Approver`""")

	def _clear_roles(self):
		frappe.db.sql("""delete from `tabUserRole` where parent in
			("test@example.com", "test1@example.com", "test2@example.com")""")

	def _clear_applications(self):
		frappe.db.sql("""delete from `tabLeave Application`""")

	def _add_employee_leave_approver(self, employee, leave_approver):
		temp_session_user = frappe.session.user
		frappe.set_user("Administrator")
		employee = frappe.get_doc("Employee", employee)
		employee.append("employee_leave_approvers", {
			"doctype": "Employee Leave Approver",
			"leave_approver": leave_approver
		})
		employee.save()
		frappe.set_user(temp_session_user)

	def _remove_employee_leave_approver(self, employee, leave_approver):
		temp_session_user = frappe.session.user
		frappe.set_user("Administrator")
		employee = frappe.get_doc("Employee", employee)
		d = employee.get("employee_leave_approvers", {
			"leave_approver": leave_approver
		})
		if d:
			employee.get("employee_leave_approvers").remove(d[0])
			employee.save()
		frappe.set_user(temp_session_user)

	def get_application(self, doc):
		application = frappe.copy_doc(doc)
		application.from_date = "2013-01-01"
		application.to_date = "2013-01-05"
		return application

	def test_block_list(self):
		self._clear_roles()

		from frappe.utils.user import add_role
		add_role("test1@example.com", "HR User")
		clear_restrictions("Employee")

		frappe.db.set_value("Department", "_Test Department",
			"leave_block_list", "_Test Leave Block List")

		application = self.get_application(_test_records[0])
		application.insert()
		application.status = "Approved"
		self.assertRaises(LeaveDayBlockedError, application.submit)

		frappe.set_user("test1@example.com")

		# clear other applications
		frappe.db.sql("delete from `tabLeave Application`")

		application = self.get_application(_test_records[0])
		self.assertTrue(application.insert())

	def test_overlap(self):
		self._clear_roles()
		self._clear_applications()

		from frappe.utils.user import add_role
		add_role("test@example.com", "Employee")
		add_role("test2@example.com", "Leave Approver")

		frappe.set_user("test@example.com")
		application = self.get_application(_test_records[0])
		application.leave_approver = "test2@example.com"
		application.insert()

		application = self.get_application(_test_records[0])
		application.leave_approver = "test2@example.com"
		self.assertRaises(OverlapError, application.insert)

	def test_global_block_list(self):
		self._clear_roles()

		from frappe.utils.user import add_role
		add_role("test1@example.com", "Employee")
		add_role("test@example.com", "Leave Approver")
		self._add_employee_leave_approver("_T-Employee-0002", "test@example.com")

		application = self.get_application(_test_records[1])
		application.leave_approver = "test@example.com"

		frappe.db.set_value("Leave Block List", "_Test Leave Block List",
			"applies_to_all_departments", 1)
		frappe.db.set_value("Employee", "_T-Employee-0002", "department",
			"_Test Department")

		frappe.set_user("test1@example.com")
		application.insert()

		frappe.set_user("test@example.com")
		application.status = "Approved"
		self.assertRaises(LeaveDayBlockedError, application.submit)

		frappe.db.set_value("Leave Block List", "_Test Leave Block List",
			"applies_to_all_departments", 0)

	def test_leave_approval(self):
		self._clear_roles()

		from frappe.utils.user import add_role
		add_role("test@example.com", "Employee")
		add_role("test1@example.com", "Leave Approver")
		add_role("test2@example.com", "Leave Approver")

		self._test_leave_approval_basic_case()
		self._test_leave_approval_invalid_leave_approver_insert()
		self._test_leave_approval_invalid_leave_approver_submit()
		self._test_leave_approval_valid_leave_approver_insert()

	def _test_leave_approval_basic_case(self):
		self._clear_applications()

		self._add_employee_leave_approver("_T-Employee-0001", "test1@example.com")

		# create leave application as Employee
		frappe.set_user("test@example.com")
		application = self.get_application(_test_records[0])
		application.leave_approver = "test1@example.com"
		application.insert()

		# submit leave application by Leave Approver
		frappe.set_user("test1@example.com")
		application.status = "Approved"
		application.submit()
		self.assertEqual(frappe.db.get_value("Leave Application", application.name,
			"docstatus"), 1)

	def _test_leave_approval_invalid_leave_approver_insert(self):
		from erpnext.hr.doctype.leave_application.leave_application import InvalidLeaveApproverError

		self._clear_applications()

		# add a different leave approver in the employee's list
		# should raise exception if not a valid leave approver
		self._add_employee_leave_approver("_T-Employee-0001", "test2@example.com")
		self._remove_employee_leave_approver("_T-Employee-0001", "test1@example.com")

		application = self.get_application(_test_records[0])
		frappe.set_user("test@example.com")

		application.leave_approver = "test1@example.com"
		self.assertRaises(InvalidLeaveApproverError, application.insert)

		frappe.db.sql("""delete from `tabEmployee Leave Approver` where parent=%s""",
			"_T-Employee-0001")

	def _test_leave_approval_invalid_leave_approver_submit(self):
		self._clear_applications()
		self._add_employee_leave_approver("_T-Employee-0001", "test2@example.com")

		# create leave application as employee
		# but submit as invalid leave approver - should raise exception
		frappe.set_user("test@example.com")
		application = self.get_application(_test_records[0])
		application.leave_approver = "test2@example.com"
		application.insert()
		frappe.set_user("test1@example.com")
		application.status = "Approved"

		from erpnext.hr.doctype.leave_application.leave_application import LeaveApproverIdentityError
		self.assertRaises(LeaveApproverIdentityError, application.submit)

		frappe.db.sql("""delete from `tabEmployee Leave Approver` where parent=%s""",
			"_T-Employee-0001")

	def _test_leave_approval_valid_leave_approver_insert(self):
		self._clear_applications()
		self._add_employee_leave_approver("_T-Employee-0001", "test2@example.com")

		original_department = frappe.db.get_value("Employee", "_T-Employee-0001", "department")
		frappe.db.set_value("Employee", "_T-Employee-0001", "department", None)

		frappe.set_user("test@example.com")
		application = self.get_application(_test_records[0])
		application.leave_approver = "test2@example.com"
		application.insert()

		# change to valid leave approver and try to submit leave application
		frappe.set_user("test2@example.com")
		application.status = "Approved"
		application.submit()
		self.assertEqual(frappe.db.get_value("Leave Application", application.name,
			"docstatus"), 1)

		frappe.db.sql("""delete from `tabEmployee Leave Approver` where parent=%s""",
			"_T-Employee-0001")

		frappe.db.set_value("Employee", "_T-Employee-0001", "department", original_department)

########NEW FILE########
__FILENAME__ = leave_block_list
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from erpnext.accounts.utils import validate_fiscal_year
from frappe import _

from frappe.model.document import Document

class LeaveBlockList(Document):
		
	def validate(self):
		dates = []
		for d in self.get("leave_block_list_dates"):
			# validate fiscal year
			validate_fiscal_year(d.block_date, self.year, _("Block Date"))
			
			# date is not repeated
			if d.block_date in dates:
				frappe.msgprint(_("Date is repeated") + ":" + d.block_date, raise_exception=1)
			dates.append(d.block_date)

@frappe.whitelist()
def get_applicable_block_dates(from_date, to_date, employee=None, 
	company=None, all_lists=False):
	block_dates = []
	for block_list in get_applicable_block_lists(employee, company, all_lists):
		block_dates.extend(frappe.db.sql("""select block_date, reason 
			from `tabLeave Block List Date` where parent=%s 
			and block_date between %s and %s""", (block_list, from_date, to_date), 
			as_dict=1))
			
	return block_dates
		
def get_applicable_block_lists(employee=None, company=None, all_lists=False):
	block_lists = []
	
	if not employee:
		employee = frappe.db.get_value("Employee", {"user_id":frappe.session.user})
		if not employee:
			return []
	
	if not company:
		company = frappe.db.get_value("Employee", employee, "company")
		
	def add_block_list(block_list):
		if block_list:
			if all_lists or not is_user_in_allow_list(block_list):
				block_lists.append(block_list)

	# per department
	department = frappe.db.get_value("Employee",employee, "department")
	if department:
		block_list = frappe.db.get_value("Department", department, "leave_block_list")
		add_block_list(block_list)

	# global
	for block_list in frappe.db.sql_list("""select name from `tabLeave Block List`
		where ifnull(applies_to_all_departments,0)=1 and company=%s""", company):
		add_block_list(block_list)
		
	return list(set(block_lists))
	
def is_user_in_allow_list(block_list):
	return frappe.session.user in frappe.db.sql_list("""select allow_user
		from `tabLeave Block List Allow` where parent=%s""", block_list)
########NEW FILE########
__FILENAME__ = test_leave_block_list
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

import frappe
import unittest

from erpnext.hr.doctype.leave_block_list.leave_block_list import get_applicable_block_dates

class TestLeaveBlockList(unittest.TestCase):
	def tearDown(self):
		 frappe.set_user("Administrator")
		
	def test_get_applicable_block_dates(self):
		frappe.set_user("test@example.com")
		frappe.db.set_value("Department", "_Test Department", "leave_block_list", 
			"_Test Leave Block List")
		self.assertTrue("2013-01-02" in 
			[d.block_date for d in get_applicable_block_dates("2013-01-01", "2013-01-03")])
			
	def test_get_applicable_block_dates_for_allowed_user(self):
		frappe.set_user("test1@example.com")
		frappe.db.set_value("Department", "_Test Department 1", "leave_block_list", 
			"_Test Leave Block List")
		self.assertEquals([], [d.block_date for d in get_applicable_block_dates("2013-01-01", "2013-01-03")])
	
	def test_get_applicable_block_dates_all_lists(self):
		frappe.set_user("test1@example.com")
		frappe.db.set_value("Department", "_Test Department 1", "leave_block_list", 
			"_Test Leave Block List")
		self.assertTrue("2013-01-02" in 
			[d.block_date for d in get_applicable_block_dates("2013-01-01", "2013-01-03", all_lists=True)])
		
test_dependencies = ["Employee"]

test_records = frappe.get_test_records('Leave Block List')
########NEW FILE########
__FILENAME__ = leave_block_list_allow
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class LeaveBlockListAllow(Document):
	pass
########NEW FILE########
__FILENAME__ = leave_block_list_date
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class LeaveBlockListDate(Document):
	pass
########NEW FILE########
__FILENAME__ = leave_control_panel
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import cint, cstr, flt, nowdate, comma_and
from frappe import msgprint, _
from frappe.model.document import Document

class LeaveControlPanel(Document):
	def get_employees(self):
		lst1 = [[self.employee_type,"employment_type"],[self.branch,"branch"],[self.designation,"designation"],[self.department, "department"]]
		condition = "where "
		flag = 0
		for l in lst1:
			if(l[0]):
				if flag == 0:
					condition += l[1] + "= '" + l[0] +"'"
				else:
					condition += " and " + l[1]+ "= '" +l[0] +"'"
				flag = 1
		emp_query = "select name from `tabEmployee` "
		if flag == 1:
			emp_query += condition
		e = frappe.db.sql(emp_query)
		return e

	def validate_values(self):
		for f in ["fiscal_year", "leave_type", "no_of_days"]:
			if not self.get(f):
				frappe.throw(_("{0} is required").format(self.meta.get_label(f)))

	def allocate_leave(self):
		self.validate_values()
		leave_allocated_for = []
		employees = self.get_employees()
		if not employees:
			frappe.throw(_("No employee found"))

		for d in self.get_employees():
			try:
				la = frappe.new_doc('Leave Allocation')
				la.set("__islocal", 1)
				la.employee = cstr(d[0])
				la.employee_name = frappe.db.get_value('Employee',cstr(d[0]),'employee_name')
				la.leave_type = self.leave_type
				la.fiscal_year = self.fiscal_year
				la.posting_date = nowdate()
				la.carry_forward = cint(self.carry_forward)
				la.new_leaves_allocated = flt(self.no_of_days)
				la.docstatus = 1
				la.save()
				leave_allocated_for.append(d[0])
			except:
				pass
		if leave_allocated_for:
			msgprint(_("Leaves Allocated Successfully for {0}").format(comma_and(leave_allocated_for)))

########NEW FILE########
__FILENAME__ = leave_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class LeaveType(Document):
	pass
########NEW FILE########
__FILENAME__ = test_leave_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Leave Type')
########NEW FILE########
__FILENAME__ = salary_manager
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cint, flt
from frappe import _

from frappe.model.document import Document

class SalaryManager(Document):

	def get_emp_list(self):
		"""
			Returns list of active employees based on selected criteria
			and for which salary structure exists
		"""

		cond = self.get_filter_condition()
		cond += self.get_joining_releiving_condition()

		emp_list = frappe.db.sql("""
			select t1.name
			from `tabEmployee` t1, `tabSalary Structure` t2
			where t1.docstatus!=2 and t2.docstatus != 2
			and t1.name = t2.employee
		%s """% cond)

		return emp_list


	def get_filter_condition(self):
		self.check_mandatory()

		cond = ''
		for f in ['company', 'branch', 'department', 'designation']:
			if self.get(f):
				cond += " and t1." + f + " = '" + self.get(f).replace("'", "\'") + "'"

		return cond


	def get_joining_releiving_condition(self):
		m = self.get_month_details(self.fiscal_year, self.month)
		cond = """
			and ifnull(t1.date_of_joining, '0000-00-00') <= '%(month_end_date)s'
			and ifnull(t1.relieving_date, '2199-12-31') >= '%(month_start_date)s'
		""" % m
		return cond


	def check_mandatory(self):
		for f in ['company', 'month', 'fiscal_year']:
			if not self.get(f):
				frappe.throw(_("Please set {0}").format(f))

	def get_month_details(self, year, month):
		ysd = frappe.db.get_value("Fiscal Year", year, "year_start_date")
		if ysd:
			from dateutil.relativedelta import relativedelta
			import calendar, datetime
			diff_mnt = cint(month)-cint(ysd.month)
			if diff_mnt<0:
				diff_mnt = 12-int(ysd.month)+cint(month)
			msd = ysd + relativedelta(months=diff_mnt) # month start date
			month_days = cint(calendar.monthrange(cint(msd.year) ,cint(month))[1]) # days in month
			med = datetime.date(msd.year, cint(month), month_days) # month end date
			return {
				'year': msd.year,
				'month_start_date': msd,
				'month_end_date': med,
				'month_days': month_days
			}

	def create_sal_slip(self):
		"""
			Creates salary slip for selected employees if already not created

		"""

		emp_list = self.get_emp_list()
		ss_list = []
		for emp in emp_list:
			if not frappe.db.sql("""select name from `tabSalary Slip`
					where docstatus!= 2 and employee = %s and month = %s and fiscal_year = %s and company = %s
					""", (emp[0], self.month, self.fiscal_year, self.company)):
				ss = frappe.get_doc({
					"doctype": "Salary Slip",
					"fiscal_year": self.fiscal_year,
					"employee": emp[0],
					"month": self.month,
					"email_check": self.send_email,
					"company": self.company,
				})
				ss.insert()
				ss_list.append(ss.name)

		return self.create_log(ss_list)


	def create_log(self, ss_list):
		log = "<b>No employee for the above selected criteria OR salary slip already created</b>"
		if ss_list:
			log = "<b>Created Salary Slip has been created: </b>\
			<br><br>%s" % '<br>'.join(ss_list)
		return log


	def get_sal_slip_list(self):
		"""
			Returns list of salary slips based on selected criteria
			which are not submitted
		"""
		cond = self.get_filter_condition()
		ss_list = frappe.db.sql("""
			select t1.name from `tabSalary Slip` t1
			where t1.docstatus = 0 and month = %s and fiscal_year = %s %s
		""" % ('%s', '%s', cond), (self.month, self.fiscal_year))
		return ss_list


	def submit_salary_slip(self):
		"""
			Submit all salary slips based on selected criteria
		"""
		ss_list = self.get_sal_slip_list()
		not_submitted_ss = []
		for ss in ss_list:
			ss_obj = frappe.get_doc("Salary Slip",ss[0])
			try:
				frappe.db.set(ss_obj, 'email_check', cint(self.send_mail))
				if cint(self.send_email) == 1:
					ss_obj.send_mail_funct()

				frappe.db.set(ss_obj, 'docstatus', 1)
			except Exception,e:
				not_submitted_ss.append(ss[0])
				frappe.msgprint(e)
				continue

		return self.create_submit_log(ss_list, not_submitted_ss)


	def create_submit_log(self, all_ss, not_submitted_ss):
		log = ''
		if not all_ss:
			log = "No salary slip found to submit for the above selected criteria"
		else:
			all_ss = [d[0] for d in all_ss]

		submitted_ss = list(set(all_ss) - set(not_submitted_ss))
		if submitted_ss:
			mail_sent_msg = self.send_email and " (Mail has been sent to the employee)" or ""
			log = """
			<b>Submitted Salary Slips%s:</b>\
			<br><br> %s <br><br>
			""" % (mail_sent_msg, '<br>'.join(submitted_ss))

		if not_submitted_ss:
			log += """
				<b>Not Submitted Salary Slips: </b>\
				<br><br> %s <br><br> \
				Reason: <br>\
				May be company email id specified in employee master is not valid. <br> \
				Please mention correct email id in employee master or if you don't want to \
				send mail, uncheck 'Send Email' checkbox. <br>\
				Then try to submit Salary Slip again.
			"""% ('<br>'.join(not_submitted_ss))
		return log


	def get_total_salary(self):
		"""
			Get total salary amount from submitted salary slip based on selected criteria
		"""
		cond = self.get_filter_condition()
		tot = frappe.db.sql("""
			select sum(rounded_total) from `tabSalary Slip` t1
			where t1.docstatus = 1 and month = %s and fiscal_year = %s %s
		""" % ('%s', '%s', cond), (self.month, self.fiscal_year))

		return flt(tot[0][0])


	def get_acc_details(self):
		"""
			get default bank account,default salary acount from company
		"""
		amt = self.get_total_salary()
		default_bank_account = frappe.db.get_value("Company", self.company,
			"default_bank_account")
		if not default_bank_account:
			frappe.msgprint(_("You can set Default Bank Account in Company master"))

		return {
			'default_bank_account' : default_bank_account,
			'amount' : amt
		}

########NEW FILE########
__FILENAME__ = salary_slip
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import add_days, cint, cstr, flt, getdate, nowdate, _round
from frappe.model.naming import make_autoname

from frappe import msgprint, _
from erpnext.setup.utils import get_company_currency


from erpnext.utilities.transaction_base import TransactionBase

class SalarySlip(TransactionBase):
	def autoname(self):
		self.name = make_autoname('Sal Slip/' +self.employee + '/.#####')

	def get_emp_and_leave_details(self):
		if self.employee:
			self.get_leave_details()
			struct = self.check_sal_struct()
			if struct:
				self.pull_sal_struct(struct)

	def check_sal_struct(self):
		struct = frappe.db.sql("""select name from `tabSalary Structure`
			where employee=%s and is_active = 'Yes'""", self.employee)
		if not struct:
			msgprint(_("Please create Salary Structure for employee {0}").format(self.employee))
			self.employee = None
		return struct and struct[0][0] or ''

	def pull_sal_struct(self, struct):
		from erpnext.hr.doctype.salary_structure.salary_structure import get_mapped_doc
		self.update(get_mapped_doc(struct, self))

	def pull_emp_details(self):
		emp = frappe.db.get_value("Employee", self.employee,
			["bank_name", "bank_ac_no"], as_dict=1)
		if emp:
			self.bank_name = emp.bank_name
			self.bank_account_no = emp.bank_ac_no

	def get_leave_details(self, lwp=None):
		if not self.fiscal_year:
			self.fiscal_year = frappe.get_default("fiscal_year")
		if not self.month:
			self.month = "%02d" % getdate(nowdate()).month

		m = frappe.get_doc('Salary Manager').get_month_details(self.fiscal_year, self.month)
		holidays = self.get_holidays_for_employee(m)

		if not cint(frappe.db.get_value("HR Settings", "HR Settings",
			"include_holidays_in_total_working_days")):
				m["month_days"] -= len(holidays)
				if m["month_days"] < 0:
					frappe.throw(_("There are more holidays than working days this month."))

		if not lwp:
			lwp = self.calculate_lwp(holidays, m)
		self.total_days_in_month = m['month_days']
		self.leave_without_pay = lwp
		payment_days = flt(self.get_payment_days(m)) - flt(lwp)
		self.payment_days = payment_days > 0 and payment_days or 0


	def get_payment_days(self, m):
		payment_days = m['month_days']
		emp = frappe.db.sql("select date_of_joining, relieving_date from `tabEmployee` \
			where name = %s", self.employee, as_dict=1)[0]

		if emp['relieving_date']:
			if getdate(emp['relieving_date']) > m['month_start_date'] and \
				getdate(emp['relieving_date']) < m['month_end_date']:
					payment_days = getdate(emp['relieving_date']).day
			elif getdate(emp['relieving_date']) < m['month_start_date']:
				frappe.throw(_("Employee relieved on {0} must be set as 'Left'").format(emp["relieving_date"]))

		if emp['date_of_joining']:
			if getdate(emp['date_of_joining']) > m['month_start_date'] and \
				getdate(emp['date_of_joining']) < m['month_end_date']:
					payment_days = payment_days - getdate(emp['date_of_joining']).day + 1
			elif getdate(emp['date_of_joining']) > m['month_end_date']:
				payment_days = 0

		return payment_days

	def get_holidays_for_employee(self, m):
		holidays = frappe.db.sql("""select t1.holiday_date
			from `tabHoliday` t1, tabEmployee t2
			where t1.parent = t2.holiday_list and t2.name = %s
			and t1.holiday_date between %s and %s""",
			(self.employee, m['month_start_date'], m['month_end_date']))
		if not holidays:
			holidays = frappe.db.sql("""select t1.holiday_date
				from `tabHoliday` t1, `tabHoliday List` t2
				where t1.parent = t2.name and ifnull(t2.is_default, 0) = 1
				and t2.fiscal_year = %s
				and t1.holiday_date between %s and %s""", (self.fiscal_year,
					m['month_start_date'], m['month_end_date']))
		holidays = [cstr(i[0]) for i in holidays]
		return holidays

	def calculate_lwp(self, holidays, m):
		lwp = 0
		for d in range(m['month_days']):
			dt = add_days(cstr(m['month_start_date']), d)
			if dt not in holidays:
				leave = frappe.db.sql("""
					select t1.name, t1.half_day
					from `tabLeave Application` t1, `tabLeave Type` t2
					where t2.name = t1.leave_type
					and ifnull(t2.is_lwp, 0) = 1
					and t1.docstatus = 1
					and t1.employee = %s
					and %s between from_date and to_date
				""", (self.employee, dt))
				if leave:
					lwp = cint(leave[0][1]) and (lwp + 0.5) or (lwp + 1)
		return lwp

	def check_existing(self):
		ret_exist = frappe.db.sql("""select name from `tabSalary Slip`
			where month = %s and fiscal_year = %s and docstatus != 2
			and employee = %s and name != %s""",
			(self.month, self.fiscal_year, self.employee, self.name))
		if ret_exist:
			self.employee = ''
			frappe.throw(_("Salary Slip of employee {0} already created for this month").format(self.employee))

	def validate(self):
		from frappe.utils import money_in_words
		self.check_existing()

		if not (len(self.get("earning_details")) or
			len(self.get("deduction_details"))):
				self.get_emp_and_leave_details()
		else:
			self.get_leave_details(self.leave_without_pay)

		if not self.net_pay:
			self.calculate_net_pay()

		company_currency = get_company_currency(self.company)
		self.total_in_words = money_in_words(self.rounded_total, company_currency)

	def calculate_earning_total(self):
		self.gross_pay = flt(self.arrear_amount) + flt(self.leave_encashment_amount)
		for d in self.get("earning_details"):
			if cint(d.e_depends_on_lwp) == 1:
				d.e_modified_amount = _round(flt(d.e_amount) * flt(self.payment_days)
					/ cint(self.total_days_in_month), 2)
			elif not self.payment_days:
				d.e_modified_amount = 0
			else:
				d.e_modified_amount = d.e_amount
			self.gross_pay += flt(d.e_modified_amount)

	def calculate_ded_total(self):
		self.total_deduction = 0
		for d in self.get('deduction_details'):
			if cint(d.d_depends_on_lwp) == 1:
				d.d_modified_amount = _round(flt(d.d_amount) * flt(self.payment_days)
					/ cint(self.total_days_in_month), 2)
			elif not self.payment_days:
				d.d_modified_amount = 0
			else:
				d.d_modified_amount = d.d_amount

			self.total_deduction += flt(d.d_modified_amount)

	def calculate_net_pay(self):
		self.calculate_earning_total()
		self.calculate_ded_total()
		self.net_pay = flt(self.gross_pay) - flt(self.total_deduction)
		self.rounded_total = _round(self.net_pay)

	def on_submit(self):
		if(self.email_check == 1):
			self.send_mail_funct()


	def send_mail_funct(self):
		from frappe.utils.email_lib import sendmail
		receiver = frappe.db.get_value("Employee", self.employee, "company_email")
		if receiver:
			subj = 'Salary Slip - ' + cstr(self.month) +'/'+cstr(self.fiscal_year)
			earn_ret=frappe.db.sql("""select e_type, e_modified_amount from `tabSalary Slip Earning`
				where parent = %s""", self.name)
			ded_ret=frappe.db.sql("""select d_type, d_modified_amount from `tabSalary Slip Deduction`
				where parent = %s""", self.name)

			earn_table = ''
			ded_table = ''
			if earn_ret:
				earn_table += "<table cellspacing=5px cellpadding=5px width='100%%'>"

				for e in earn_ret:
					if not e[1]:
						earn_table += '<tr><td>%s</td><td align="right">0.00</td></tr>' % cstr(e[0])
					else:
						earn_table += '<tr><td>%s</td><td align="right">%s</td></tr>' \
							% (cstr(e[0]), cstr(e[1]))
				earn_table += '</table>'

			if ded_ret:

				ded_table += "<table cellspacing=5px cellpadding=5px width='100%%'>"

				for d in ded_ret:
					if not d[1]:
						ded_table +='<tr><td">%s</td><td align="right">0.00</td></tr>' % cstr(d[0])
					else:
						ded_table +='<tr><td>%s</td><td align="right">%s</td></tr>' \
							% (cstr(d[0]), cstr(d[1]))
				ded_table += '</table>'

			letter_head = frappe.db.get_value("Letter Head", {"is_default": 1, "disabled": 0},
				"content")

			msg = '''<div> %s <br>
			<table cellspacing= "5" cellpadding="5"  width = "100%%">
				<tr>
					<td width = "100%%" colspan = "2"><h4>Salary Slip</h4></td>
				</tr>
				<tr>
					<td width = "50%%"><b>Employee Code : %s</b></td>
					<td width = "50%%"><b>Employee Name : %s</b></td>
				</tr>
				<tr>
					<td width = "50%%">Month : %s</td>
					<td width = "50%%">Fiscal Year : %s</td>
				</tr>
				<tr>
					<td width = "50%%">Department : %s</td>
					<td width = "50%%">Branch : %s</td>
				</tr>
				<tr>
					<td width = "50%%">Designation : %s</td>
				</tr>
				<tr>
					<td width = "50%%">Bank Account No. : %s</td>
					<td  width = "50%%">Bank Name : %s</td>

				</tr>
				<tr>
					<td  width = "50%%">Arrear Amount : <b>%s</b></td>
					<td  width = "50%%">Payment days : %s</td>

				</tr>
			</table>
			<table border="1px solid #CCC" width="100%%" cellpadding="0px" cellspacing="0px">
				<tr>
					<td colspan = 2 width = "50%%" bgcolor="#CCC" align="center">
						<b>Earnings</b></td>
					<td colspan = 2 width = "50%%" bgcolor="#CCC" align="center">
						<b>Deductions</b></td>
				</tr>
				<tr>
					<td colspan = 2 width = "50%%" valign= "top">%s</td>
					<td colspan = 2 width = "50%%" valign= "top">%s</td>
				</tr>
			</table>
			<table cellspacing= "5" cellpadding="5" width = '100%%'>
				<tr>
					<td width = '25%%'><b>Gross Pay :</b> </td>
					<td width = '25%%' align='right'>%s</td>
					<td width = '25%%'><b>Total Deduction :</b></td>
					<td width = '25%%' align='right'> %s</td>
				</tr>
				<tr>
					<tdwidth='25%%'><b>Net Pay : </b></td>
					<td width = '25%%' align='right'><b>%s</b></td>
					<td colspan = '2' width = '50%%'></td>
				</tr>
				<tr>
					<td width='25%%'><b>Net Pay(in words) : </td>
					<td colspan = '3' width = '50%%'>%s</b></td>
				</tr>
			</table></div>''' % (cstr(letter_head), cstr(self.employee),
				cstr(self.employee_name), cstr(self.month), cstr(self.fiscal_year),
				cstr(self.department), cstr(self.branch), cstr(self.designation),
				cstr(self.bank_account_no), cstr(self.bank_name),
				cstr(self.arrear_amount), cstr(self.payment_days), earn_table, ded_table,
				cstr(flt(self.gross_pay)), cstr(flt(self.total_deduction)),
				cstr(flt(self.net_pay)), cstr(self.total_in_words))

			sendmail([receiver], subject=subj, msg = msg)
		else:
			msgprint(_("Company Email ID not found, hence mail not sent"))

########NEW FILE########
__FILENAME__ = test_salary_slip
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

import unittest
import frappe
from frappe.utils import today
from erpnext.hr.doctype.employee.employee import make_salary_structure
from erpnext.hr.doctype.salary_structure.salary_structure import make_salary_slip

class TestSalarySlip(unittest.TestCase):
	def setUp(self):
		frappe.db.sql("""delete from `tabLeave Application`""")
		frappe.db.sql("""delete from `tabSalary Slip`""")
		from erpnext.hr.doctype.leave_application.test_leave_application import _test_records as leave_applications
		la = frappe.copy_doc(leave_applications[2])
		la.insert()
		la.status = "Approved"
		la.submit()

	def tearDown(self):
		frappe.db.set_value("HR Settings", "HR Settings", "include_holidays_in_total_working_days", 0)
		frappe.set_user("Administrator")

	def test_salary_slip_with_holidays_included(self):
		frappe.db.set_value("HR Settings", "HR Settings", "include_holidays_in_total_working_days", 1)
		ss = frappe.copy_doc(test_records[0])
		ss.insert()
		self.assertEquals(ss.total_days_in_month, 31)
		self.assertEquals(ss.payment_days, 30)
		self.assertEquals(ss.earning_details[0].e_modified_amount, 14516.13)
		self.assertEquals(ss.earning_details[1].e_modified_amount, 500)
		self.assertEquals(ss.deduction_details[0].d_modified_amount, 100)
		self.assertEquals(ss.deduction_details[1].d_modified_amount, 48.39)
		self.assertEquals(ss.gross_pay, 15016.13)
		self.assertEquals(ss.net_pay, 14867.74)

	def test_salary_slip_with_holidays_excluded(self):
		ss = frappe.copy_doc(test_records[0])
		ss.insert()
		self.assertEquals(ss.total_days_in_month, 30)
		self.assertEquals(ss.payment_days, 29)
		self.assertEquals(ss.earning_details[0].e_modified_amount, 14500)
		self.assertEquals(ss.earning_details[1].e_modified_amount, 500)
		self.assertEquals(ss.deduction_details[0].d_modified_amount, 100)
		self.assertEquals(ss.deduction_details[1].d_modified_amount, 48.33)
		self.assertEquals(ss.gross_pay, 15000)
		self.assertEquals(ss.net_pay, 14851.67)

	def test_employee_salary_slip_read_permission(self):
		self.make_employee("test_employee@example.com")
		self.make_employee("test_employee_2@example.com")

		salary_slip_test_employee = frappe.get_doc("Salary Slip",
			self.make_employee_salary_slip("test_employee@example.com"))

		salary_slip_test_employee_2 = frappe.get_doc("Salary Slip",
			self.make_employee_salary_slip("test_employee_2@example.com"))

		frappe.set_user("test_employee@example.com")
		self.assertTrue(salary_slip_test_employee.has_permission("read"))
		self.assertFalse(salary_slip_test_employee_2.has_permission("read"))

	def make_employee(self, user):
		if not frappe.db.get_value("User", user):
			frappe.get_doc({
				"doctype": "User",
				"email": user,
				"first_name": user,
				"new_password": "password",
				"user_roles": [{"doctype": "UserRole", "role": "Employee"}]
			}).insert()

		if not frappe.db.get_value("Employee", {"user_id": user}):
			frappe.get_doc({
				"doctype": "Employee",
				"naming_series": "_T-Employee-",
				"employee_name": user,
				"user_id": user,
				"company": "_Test Company",
				"date_of_birth": "1990-05-08",
				"date_of_joining": "2013-01-01",
				"department": "_Test Department 1",
				"gender": "Female",
				"status": "Active"
			}).insert()

	def make_employee_salary_slip(self, user):
		employee = frappe.db.get_value("Employee", {"user_id": user})
		salary_structure = frappe.db.get_value("Salary Structure", {"employee": employee})
		if not salary_structure:
			salary_structure = make_salary_structure(employee)
			salary_structure.from_date = today()
			salary_structure.insert()
			salary_structure = salary_structure.name

		salary_slip = frappe.db.get_value("Salary Slip", {"employee": employee})
		if not salary_slip:
			salary_slip = make_salary_slip(salary_structure)
			salary_slip.insert()
			salary_slip.submit()
			salary_slip = salary_slip.name

		return salary_slip

test_dependencies = ["Leave Application"]

test_records = frappe.get_test_records('Salary Slip')

########NEW FILE########
__FILENAME__ = salary_slip_deduction
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SalarySlipDeduction(Document):
	pass
########NEW FILE########
__FILENAME__ = salary_slip_earning
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SalarySlipEarning(Document):
	pass
########NEW FILE########
__FILENAME__ = salary_structure
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import cstr, flt
from frappe.model.naming import make_autoname
from frappe import _
from frappe.model.mapper import get_mapped_doc
from frappe.model.document import Document

class SalaryStructure(Document):
	def autoname(self):
		self.name = make_autoname(self.employee + '/.SST' + '/.#####')

	def get_employee_details(self):
		ret = {}
		det = frappe.db.sql("""select employee_name, branch, designation, department
			from `tabEmployee` where name = %s""", self.employee)
		if det:
			ret = {
				'employee_name': cstr(det[0][0]),
				'branch': cstr(det[0][1]),
				'designation': cstr(det[0][2]),
				'department': cstr(det[0][3]),
				'backup_employee': cstr(self.employee)
			}
		return ret

	def get_ss_values(self,employee):
		basic_info = frappe.db.sql("""select bank_name, bank_ac_no
			from `tabEmployee` where name =%s""", employee)
		ret = {'bank_name': basic_info and basic_info[0][0] or '',
			'bank_ac_no': basic_info and basic_info[0][1] or ''}
		return ret

	def make_table(self, doct_name, tab_fname, tab_name):
		list1 = frappe.db.sql("select name from `tab%s` where docstatus != 2" % doct_name)
		for li in list1:
			child = self.append(tab_fname, {})
			if(tab_fname == 'earning_details'):
				child.e_type = cstr(li[0])
				child.modified_value = 0
			elif(tab_fname == 'deduction_details'):
				child.d_type = cstr(li[0])
				child.d_modified_amt = 0

	def make_earn_ded_table(self):
		self.make_table('Earning Type','earning_details','Salary Structure Earning')
		self.make_table('Deduction Type','deduction_details', 'Salary Structure Deduction')

	def check_existing(self):
		ret = frappe.db.sql("""select name from `tabSalary Structure` where is_active = 'Yes'
			and employee = %s and name!=%s""", (self.employee,self.name))
		if ret and self.is_active=='Yes':
			frappe.throw(_("Another Salary Structure {0} is active for employee {0}. Please make its status 'Inactive' to proceed.").format(cstr(ret), self.employee))

	def validate_amount(self):
		if flt(self.net_pay) < 0:
			frappe.throw(_("Net pay cannot be negative"))

	def validate(self):
		self.check_existing()
		self.validate_amount()

@frappe.whitelist()
def make_salary_slip(source_name, target_doc=None):
	def postprocess(source, target):
		target.run_method("pull_emp_details")
		target.run_method("get_leave_details")
		target.run_method("calculate_net_pay")

	doc = get_mapped_doc("Salary Structure", source_name, {
		"Salary Structure": {
			"doctype": "Salary Slip",
			"field_map": {
				"total_earning": "gross_pay"
			}
		},
		"Salary Structure Deduction": {
			"doctype": "Salary Slip Deduction",
			"field_map": [
				["depend_on_lwp", "d_depends_on_lwp"],
				["d_modified_amt", "d_amount"],
				["d_modified_amt", "d_modified_amount"]
			],
			"add_if_empty": True
		},
		"Salary Structure Earning": {
			"doctype": "Salary Slip Earning",
			"field_map": [
				["depend_on_lwp", "e_depends_on_lwp"],
				["modified_value", "e_modified_amount"],
				["modified_value", "e_amount"]
			],
			"add_if_empty": True
		}
	}, target_doc, postprocess)

	return doc

########NEW FILE########
__FILENAME__ = salary_structure_deduction
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SalaryStructureDeduction(Document):
	pass
########NEW FILE########
__FILENAME__ = salary_structure_earning
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SalaryStructureEarning(Document):
	pass
########NEW FILE########
__FILENAME__ = upload_attendance
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cstr, add_days, date_diff
from frappe import _
from frappe.utils.datautils import UnicodeWriter
from frappe.model.document import Document

class UploadAttendance(Document):
	pass

@frappe.whitelist()
def get_template():
	if not frappe.has_permission("Attendance", "create"):
		raise frappe.PermissionError

	args = frappe.local.form_dict

	w = UnicodeWriter()
	w = add_header(w)

	w = add_data(w, args)

	# write out response as a type csv
	frappe.response['result'] = cstr(w.getvalue())
	frappe.response['type'] = 'csv'
	frappe.response['doctype'] = "Attendance"

def add_header(w):
	status = ", ".join((frappe.get_meta("Attendance").get_field("status").options or "").strip().split("\n"))
	w.writerow(["Notes:"])
	w.writerow(["Please do not change the template headings"])
	w.writerow(["Status should be one of these values: " + status])
	w.writerow(["If you are overwriting existing attendance records, 'ID' column mandatory"])
	w.writerow(["ID", "Employee", "Employee Name", "Date", "Status",
		"Fiscal Year", "Company", "Naming Series"])
	return w

def add_data(w, args):
	from erpnext.accounts.utils import get_fiscal_year

	dates = get_dates(args)
	employees = get_active_employees()
	existing_attendance_records = get_existing_attendance_records(args)
	for date in dates:
		for employee in employees:
			existing_attendance = {}
			if existing_attendance_records \
				and tuple([date, employee.name]) in existing_attendance_records:
					existing_attendance = existing_attendance_records[tuple([date, employee.name])]
			row = [
				existing_attendance and existing_attendance.name or "",
				employee.name, employee.employee_name, date,
				existing_attendance and existing_attendance.status or "",
				get_fiscal_year(date)[0], employee.company,
				existing_attendance and existing_attendance.naming_series or get_naming_series(),
			]
			w.writerow(row)
	return w

def get_dates(args):
	"""get list of dates in between from date and to date"""
	no_of_days = date_diff(add_days(args["to_date"], 1), args["from_date"])
	dates = [add_days(args["from_date"], i) for i in range(0, no_of_days)]
	return dates

def get_active_employees():
	employees = frappe.db.sql("""select name, employee_name, company
		from tabEmployee where docstatus < 2 and status = 'Active'""", as_dict=1)
	return employees

def get_existing_attendance_records(args):
	attendance = frappe.db.sql("""select name, att_date, employee, status, naming_series
		from `tabAttendance` where att_date between %s and %s and docstatus < 2""",
		(args["from_date"], args["to_date"]), as_dict=1)

	existing_attendance = {}
	for att in attendance:
		existing_attendance[tuple([att.att_date, att.employee])] = att

	return existing_attendance

def get_naming_series():
	series = frappe.get_meta("Attendance").get_field("naming_series").options.strip().split("\n")
	if not series:
		frappe.throw(_("Please setup numbering series for Attendance via Setup > Numbering Series"))
	return series[0]


@frappe.whitelist()
def upload():
	if not frappe.has_permission("Attendance", "create"):
		raise frappe.PermissionError

	from frappe.utils.datautils import read_csv_content_from_uploaded_file
	from frappe.modules import scrub

	rows = read_csv_content_from_uploaded_file()
	if not rows:
		msg = [_("Please select a csv file")]
		return {"messages": msg, "error": msg}
	columns = [scrub(f) for f in rows[4]]
	columns[0] = "name"
	columns[3] = "att_date"
	ret = []
	error = False

	from frappe.utils.datautils import check_record, import_doc

	for i, row in enumerate(rows[5:]):
		if not row: continue
		row_idx = i + 5
		d = frappe._dict(zip(columns, row))
		d["doctype"] = "Attendance"
		if d.name:
			d["docstatus"] = frappe.db.get_value("Attendance", d.name, "docstatus")

		try:
			check_record(d)
			ret.append(import_doc(d, "Attendance", 1, row_idx, submit=True))
		except Exception, e:
			error = True
			ret.append('Error for row (#%d) %s : %s' % (row_idx,
				len(row)>1 and row[1] or "", cstr(e)))
			frappe.errprint(frappe.get_traceback())

	if error:
		frappe.db.rollback()
	else:
		frappe.db.commit()
	return {"messages": ret, "error": error}

########NEW FILE########
__FILENAME__ = employee_birthday
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt

def execute(filters=None):
	if not filters: filters = {}
	
	columns = get_columns()
	data = get_employees(filters)
	
	return columns, data
	
def get_columns():
	return [
		"Employee:Link/Employee:120", "Date of Birth:Date:100", "Branch:Link/Branch:120", 
		"Department:Link/Department:120", "Designation:Link/Designation:120", "Gender::60", 
		"Company:Link/Company:120"
	]
	
def get_employees(filters):
	conditions = get_conditions(filters)
	return frappe.db.sql("""select name, date_of_birth, branch, department, designation, 
	gender, company from tabEmployee where status = 'Active' %s""" % conditions, as_list=1)
	
def get_conditions(filters):
	conditions = ""
	if filters.get("month"):
		month = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", 
			"Dec"].index(filters["month"]) + 1
		conditions += " and month(date_of_birth) = '%s'" % month
	
	if filters.get("company"): conditions += " and company = '%s'" % \
		filters["company"].repalce("'", "\'")
	
	return conditions
########NEW FILE########
__FILENAME__ = employee_leave_balance
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.widgets.reportview import execute as runreport

def execute(filters=None):
	if not filters: filters = {}

	employee_filters = filters.get("company") and \
		[["Employee", "company", "=", filters.get("company")]] or None
	employees = runreport(doctype="Employee", fields=["name", "employee_name", "department"],
		filters=employee_filters)

	if not employees:
		frappe.throw(_("No employee found!"))

	leave_types = frappe.db.sql_list("select name from `tabLeave Type`")

	if filters.get("fiscal_year"):
		fiscal_years = [filters["fiscal_year"]]
	else:
		fiscal_years = frappe.db.sql_list("select name from `tabFiscal Year` order by name desc")

	allocations = frappe.db.sql("""select employee, fiscal_year, leave_type, total_leaves_allocated
	 	from `tabLeave Allocation`
		where docstatus=1 and employee in (%s)""" %
		','.join(['%s']*len(employees)), employees, as_dict=True)

	applications = frappe.db.sql("""select employee, fiscal_year, leave_type,
			SUM(total_leave_days) as leaves
		from `tabLeave Application`
		where status="Approved" and docstatus = 1 and employee in (%s)
		group by employee, fiscal_year, leave_type""" %
			','.join(['%s']*len(employees)), employees, as_dict=True)

	columns = [
		"Fiscal Year", "Employee:Link/Employee:150", "Employee Name::200", "Department::150"
	]

	for leave_type in leave_types:
		columns.append(leave_type + " Allocated:Float")
		columns.append(leave_type + " Taken:Float")
		columns.append(leave_type + " Balance:Float")

	data = {}
	for d in allocations:
		data.setdefault((d.fiscal_year, d.employee,
			d.leave_type), frappe._dict()).allocation = d.total_leaves_allocated

	for d in applications:
		data.setdefault((d.fiscal_year, d.employee,
			d.leave_type), frappe._dict()).leaves = d.leaves

	result = []
	for fiscal_year in fiscal_years:
		for employee in employees:
			row = [fiscal_year, employee.name, employee.employee_name, employee.department]
			result.append(row)
			for leave_type in leave_types:
				tmp = data.get((fiscal_year, employee.name, leave_type), frappe._dict())
				row.append(tmp.allocation or 0)
				row.append(tmp.leaves or 0)
				row.append((tmp.allocation or 0) - (tmp.leaves or 0))

	return columns, result

########NEW FILE########
__FILENAME__ = monthly_attendance_sheet
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cstr, cint
from frappe import msgprint, _

def execute(filters=None):
	if not filters: filters = {}

	conditions, filters = get_conditions(filters)
	columns = get_columns(filters)
	att_map = get_attendance_list(conditions, filters)
	emp_map = get_employee_details()

	data = []
	for emp in sorted(att_map):
		emp_det = emp_map.get(emp)
		if not emp_det:
			continue

		row = [emp, emp_det.employee_name, emp_det.branch, emp_det.department, emp_det.designation,
			emp_det.company]

		total_p = total_a = 0.0
		for day in range(filters["total_days_in_month"]):
			status = att_map.get(emp).get(day + 1, "Absent")
			status_map = {"Present": "P", "Absent": "A", "Half Day": "HD"}
			row.append(status_map[status])

			if status == "Present":
				total_p += 1
			elif status == "Absent":
				total_a += 1
			elif status == "Half Day":
				total_p += 0.5
				total_a += 0.5

		row += [total_p, total_a]

		data.append(row)

	return columns, data

def get_columns(filters):
	columns = [
		"Employee:Link/Employee:120", "Employee Name::140", "Branch:Link/Branch:120",
		"Department:Link/Department:120", "Designation:Link/Designation:120",
		 "Company:Link/Company:120"
	]

	for day in range(filters["total_days_in_month"]):
		columns.append(cstr(day+1) +"::20")

	columns += ["Total Present:Float:80", "Total Absent:Float:80"]
	return columns

def get_attendance_list(conditions, filters):
	attendance_list = frappe.db.sql("""select employee, day(att_date) as day_of_month,
		status from tabAttendance where docstatus = 1 %s order by employee, att_date""" %
		conditions, filters, as_dict=1)

	att_map = {}
	for d in attendance_list:
		att_map.setdefault(d.employee, frappe._dict()).setdefault(d.day_of_month, "")
		att_map[d.employee][d.day_of_month] = d.status

	return att_map

def get_conditions(filters):
	if not (filters.get("month") and filters.get("fiscal_year")):
		msgprint(_("Please select month and year"), raise_exception=1)

	filters["month"] = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov",
		"Dec"].index(filters["month"]) + 1

	from calendar import monthrange
	filters["total_days_in_month"] = monthrange(cint(filters["fiscal_year"].split("-")[-1]),
		filters["month"])[1]

	conditions = " and month(att_date) = %(month)s and fiscal_year = %(fiscal_year)s"

	if filters.get("company"): conditions += " and company = %(company)s"
	if filters.get("employee"): conditions += " and employee = %(employee)s"

	return conditions, filters

def get_employee_details():
	emp_map = frappe._dict()
	for d in frappe.db.sql("""select name, employee_name, designation,
		department, branch, company
		from tabEmployee where docstatus < 2
		and status = 'Active'""", as_dict=1):
		emp_map.setdefault(d.name, d)

	return emp_map

########NEW FILE########
__FILENAME__ = monthly_salary_register
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt, cstr
from frappe import msgprint, _

def execute(filters=None):
	if not filters: filters = {}
	
	salary_slips = get_salary_slips(filters)
	columns, earning_types, ded_types = get_columns(salary_slips)
	ss_earning_map = get_ss_earning_map(salary_slips)
	ss_ded_map = get_ss_ded_map(salary_slips)
	
	
	data = []
	for ss in salary_slips:
		row = [ss.employee, ss.employee_name, ss.branch, ss.department, ss.designation, 
			ss.company, ss.month, ss.leave_withut_pay, ss.payment_days]
			
		for e in earning_types:
			row.append(ss_earning_map.get(ss.name, {}).get(e))
			
		row += [ss.arrear_amount, ss.leave_encashment_amount, ss.gross_pay]
		
		for d in ded_types:
			row.append(ss_ded_map.get(ss.name, {}).get(d))
		
		row += [ss.total_deduction, ss.net_pay]
		
		data.append(row)
	
	return columns, data
	
def get_columns(salary_slips):
	columns = [
		"Employee:Link/Employee:120", "Employee Name::140", "Branch:Link/Branch:120", 
		"Department:Link/Department:120", "Designation:Link/Designation:120",
		 "Company:Link/Company:120", "Month::80", "Leave Without pay:Float:130", 
		"Payment Days:Float:120"
	]
	
	earning_types = frappe.db.sql_list("""select distinct e_type from `tabSalary Slip Earning`
		where ifnull(e_modified_amount, 0) != 0 and parent in (%s)""" % 
		(', '.join(['%s']*len(salary_slips))), tuple([d.name for d in salary_slips]))
		
	ded_types = frappe.db.sql_list("""select distinct d_type from `tabSalary Slip Deduction`
		where ifnull(d_modified_amount, 0) != 0 and parent in (%s)""" % 
		(', '.join(['%s']*len(salary_slips))), tuple([d.name for d in salary_slips]))
		
	columns = columns + [(e + ":Currency:120") for e in earning_types] + \
		["Arrear Amount:Currency:120", "Leave Encashment Amount:Currency:150", 
		"Gross Pay:Currency:120"] + [(d + ":Currency:120") for d in ded_types] + \
		["Total Deduction:Currency:120", "Net Pay:Currency:120"]

	return columns, earning_types, ded_types
	
def get_salary_slips(filters):
	conditions, filters = get_conditions(filters)
	salary_slips = frappe.db.sql("""select * from `tabSalary Slip` where docstatus = 1 %s
		order by employee, month""" % conditions, filters, as_dict=1)
	
	if not salary_slips:
		msgprint(_("No salary slip found for month: ") + cstr(filters.get("month")) + 
			_(" and year: ") + cstr(filters.get("fiscal_year")), raise_exception=1)
	
	return salary_slips
	
def get_conditions(filters):
	conditions = ""
	if filters.get("month"):
		month = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", 
			"Dec"].index(filters["month"]) + 1
		filters["month"] = month
		conditions += " and month = %(month)s"
	
	if filters.get("fiscal_year"): conditions += " and fiscal_year = %(fiscal_year)s"
	if filters.get("company"): conditions += " and company = %(company)s"
	if filters.get("employee"): conditions += " and employee = %(employee)s"
	
	return conditions, filters
	
def get_ss_earning_map(salary_slips):
	ss_earnings = frappe.db.sql("""select parent, e_type, e_modified_amount 
		from `tabSalary Slip Earning` where parent in (%s)""" %
		(', '.join(['%s']*len(salary_slips))), tuple([d.name for d in salary_slips]), as_dict=1)
	
	ss_earning_map = {}
	for d in ss_earnings:
		ss_earning_map.setdefault(d.parent, frappe._dict()).setdefault(d.e_type, [])
		ss_earning_map[d.parent][d.e_type] = flt(d.e_modified_amount)
	
	return ss_earning_map

def get_ss_ded_map(salary_slips):
	ss_deductions = frappe.db.sql("""select parent, d_type, d_modified_amount 
		from `tabSalary Slip Deduction` where parent in (%s)""" %
		(', '.join(['%s']*len(salary_slips))), tuple([d.name for d in salary_slips]), as_dict=1)
	
	ss_ded_map = {}
	for d in ss_deductions:
		ss_ded_map.setdefault(d.parent, frappe._dict()).setdefault(d.d_type, [])
		ss_ded_map[d.parent][d.d_type] = flt(d.d_modified_amount)
	
	return ss_ded_map
########NEW FILE########
__FILENAME__ = utils
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _

@frappe.whitelist()
def get_leave_approver_list():
	roles = [r[0] for r in frappe.db.sql("""select distinct parent from `tabUserRole`
		where role='Leave Approver'""")]
	if not roles:
		frappe.msgprint(_("No Leave Approvers. Please assign 'Leave Approver' Role to atleast one user"))

	return roles


@frappe.whitelist()
def get_expense_approver_list():
	roles = [r[0] for r in frappe.db.sql("""select distinct parent from `tabUserRole`
		where role='Expense Approver'""")]
	if not roles:
		frappe.msgprint(_("No Expense Approvers. Please assign 'Expense Approver' Role to atleast one user"))
	return roles

########NEW FILE########
__FILENAME__ = bom
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cint, cstr, flt, now, nowdate

from frappe import _
from frappe.model.document import Document

class BOM(Document):

	def autoname(self):
		last_name = frappe.db.sql("""select max(name) from `tabBOM`
			where name like "BOM/%s/%%" """ % cstr(self.item).replace('"', '\\"'))
		if last_name:
			idx = cint(cstr(last_name[0][0]).split('/')[-1].split('-')[0]) + 1

		else:
			idx = 1
		self.name = 'BOM/' + self.item + ('/%.3i' % idx)

	def validate(self):
		self.clear_operations()
		self.validate_main_item()

		from erpnext.utilities.transaction_base import validate_uom_is_integer
		validate_uom_is_integer(self, "stock_uom", "qty")

		self.validate_operations()
		self.validate_materials()
		self.set_bom_material_details()
		self.calculate_cost()

	def on_update(self):
		self.check_recursion()
		self.update_exploded_items()

	def on_submit(self):
		self.manage_default_bom()

	def on_cancel(self):
		frappe.db.set(self, "is_active", 0)
		frappe.db.set(self, "is_default", 0)

		# check if used in any other bom
		self.validate_bom_links()
		self.manage_default_bom()

	def on_update_after_submit(self):
		self.validate_bom_links()
		self.manage_default_bom()

	def get_item_det(self, item_code):
		item = frappe.db.sql("""select name, is_asset_item, is_purchase_item,
			docstatus, description, is_sub_contracted_item, stock_uom, default_bom,
			last_purchase_rate, standard_rate, is_manufactured_item
			from `tabItem` where name=%s""", item_code, as_dict = 1)

		return item

	def validate_rm_item(self, item):
		if item[0]['name'] == self.item:
			frappe.throw(_("Raw material cannot be same as main Item"))

	def set_bom_material_details(self):
		for item in self.get("bom_materials"):
			ret = self.get_bom_material_detail({"item_code": item.item_code, "bom_no": item.bom_no,
				"qty": item.qty})

			for r in ret:
				if not item.get(r):
					item.set(r, ret[r])

	def get_bom_material_detail(self, args=None):
		""" Get raw material details like uom, desc and rate"""
		if not args:
			args = frappe.form_dict.get('args')

		if isinstance(args, basestring):
			import json
			args = json.loads(args)

		item = self.get_item_det(args['item_code'])
		self.validate_rm_item(item)

		args['bom_no'] = args['bom_no'] or item and cstr(item[0]['default_bom']) or ''
		args.update(item[0])

		rate = self.get_rm_rate(args)
		ret_item = {
			 'description'  : item and args['description'] or '',
			 'stock_uom'	: item and args['stock_uom'] or '',
			 'bom_no'		: args['bom_no'],
			 'rate'			: rate
		}
		return ret_item

	def get_rm_rate(self, arg):
		"""	Get raw material rate as per selected method, if bom exists takes bom cost """
		rate = 0
		if arg['bom_no']:
			rate = self.get_bom_unitcost(arg['bom_no'])
		elif arg and (arg['is_purchase_item'] == 'Yes' or arg['is_sub_contracted_item'] == 'Yes'):
			if self.rm_cost_as_per == 'Valuation Rate':
				rate = self.get_valuation_rate(arg)
			elif self.rm_cost_as_per == 'Last Purchase Rate':
				rate = arg['last_purchase_rate']
			elif self.rm_cost_as_per == "Price List":
				if not self.buying_price_list:
					frappe.throw(_("Please select Price List"))
				rate = frappe.db.get_value("Item Price", {"price_list": self.buying_price_list,
					"item_code": arg["item_code"]}, "price_list_rate") or 0
			elif self.rm_cost_as_per == 'Standard Rate':
				rate = arg['standard_rate']

		return rate

	def update_cost(self):
		for d in self.get("bom_materials"):
			d.rate = self.get_bom_material_detail({
				'item_code': d.item_code,
				'bom_no': d.bom_no,
				'qty': d.qty
			})["rate"]

		if self.docstatus in (0, 1):
			self.ignore_validate_update_after_submit = True
			self.save()

	def get_bom_unitcost(self, bom_no):
		bom = frappe.db.sql("""select name, total_cost/quantity as unit_cost from `tabBOM`
			where is_active = 1 and name = %s""", bom_no, as_dict=1)
		return bom and bom[0]['unit_cost'] or 0

	def get_valuation_rate(self, args):
		""" Get average valuation rate of relevant warehouses
			as per valuation method (MAR/FIFO)
			as on costing date
		"""
		from erpnext.stock.utils import get_incoming_rate
		posting_date, posting_time = nowdate(), now().split()[1]
		warehouse = frappe.db.sql("select warehouse from `tabBin` where item_code = %s", args['item_code'])
		rate = []
		for wh in warehouse:
			r = get_incoming_rate({
				"item_code": args.get("item_code"),
				"warehouse": wh[0],
				"posting_date": posting_date,
				"posting_time": posting_time,
				"qty": args.get("qty") or 0
			})
			if r:
				rate.append(r)

		return rate and flt(sum(rate))/len(rate) or 0

	def manage_default_bom(self):
		""" Uncheck others if current one is selected as default,
			update default bom in item master
		"""
		if self.is_default and self.is_active:
			from frappe.model.utils import set_default
			set_default(self, "item")
			frappe.db.set_value("Item", self.item, "default_bom", self.name)

		else:
			if not self.is_active:
				frappe.db.set(self, "is_default", 0)

			frappe.db.sql("update `tabItem` set default_bom = null where name = %s and default_bom = %s",
				 (self.item, self.name))

	def clear_operations(self):
		if not self.with_operations:
			self.set('bom_operations', [])
			for d in self.get("bom_materials"):
				d.operation_no = None

	def validate_main_item(self):
		""" Validate main FG item"""
		item = self.get_item_det(self.item)
		if not item:
			frappe.throw(_("Item {0} does not exist in the system or has expired").format(self.item))
		elif item[0]['is_manufactured_item'] != 'Yes' \
				and item[0]['is_sub_contracted_item'] != 'Yes':
			frappe.throw(_("Item {0} must be manufactured or sub-contracted").format(self.item))
		else:
			ret = frappe.db.get_value("Item", self.item, ["description", "stock_uom"])
			self.description = ret[0]
			self.uom = ret[1]

	def validate_operations(self):
		""" Check duplicate operation no"""
		self.op = []
		for d in self.get('bom_operations'):
			if cstr(d.operation_no) in self.op:
				frappe.throw(_("Operation {0} is repeated in Operations Table").format(d.operation_no))
			else:
				# add operation in op list
				self.op.append(cstr(d.operation_no))

	def validate_materials(self):
		""" Validate raw material entries """
		check_list = []
		for m in self.get('bom_materials'):
			# check if operation no not in op table
			if self.with_operations and cstr(m.operation_no) not in self.op:
				frappe.throw(_("Operation {0} not present in Operations Table").format(m.operation_no))

			item = self.get_item_det(m.item_code)
			if item[0]['is_manufactured_item'] == 'Yes':
				if not m.bom_no:
					frappe.throw(_("BOM number is required for manufactured Item {0} in row {1}").format(m.item_code, m.idx))
				else:
					self.validate_bom_no(m.item_code, m.bom_no, m.idx)

			elif m.bom_no:
				frappe.throw(_("BOM number not allowed for non-manufactured Item {0} in row {1}").format(m.item_code, m.idx))

			if flt(m.qty) <= 0:
				frappe.throw(_("Quantity required for Item {0} in row {1}").format(m.item_code, m.idx))

			self.check_if_item_repeated(m.item_code, m.operation_no, check_list)

	def validate_bom_no(self, item, bom_no, idx):
		"""Validate BOM No of sub-contracted items"""
		bom = frappe.db.sql("""select name from `tabBOM` where name = %s and item = %s
			and is_active=1 and docstatus=1""",
			(bom_no, item), as_dict =1)
		if not bom:
			frappe.throw(_("BOM {0} for Item {1} in row {2} is inactive or not submitted").format(bom_no, item, idx))

	def check_if_item_repeated(self, item, op, check_list):
		if [cstr(item), cstr(op)] in check_list:
			frappe.throw(_("Item {0} has been entered multiple times against same operation").format(item))
		else:
			check_list.append([cstr(item), cstr(op)])

	def check_recursion(self):
		""" Check whether recursion occurs in any bom"""

		check_list = [['parent', 'bom_no', 'parent'], ['bom_no', 'parent', 'child']]
		for d in check_list:
			bom_list, count = [self.name], 0
			while (len(bom_list) > count ):
				boms = frappe.db.sql(" select %s from `tabBOM Item` where %s = %s " %
					(d[0], d[1], '%s'), cstr(bom_list[count]))
				count = count + 1
				for b in boms:
					if b[0] == self.name:
						frappe.throw(_("BOM recursion: {0} cannot be parent or child of {2}").format(b[0], self.name))
					if b[0]:
						bom_list.append(b[0])

	def update_cost_and_exploded_items(self, bom_list=[]):
		bom_list = self.traverse_tree(bom_list)
		for bom in bom_list:
			bom_obj = frappe.get_doc("BOM", bom)
			bom_obj.on_update()

		return bom_list

	def traverse_tree(self, bom_list=[]):
		def _get_children(bom_no):
			return [cstr(d[0]) for d in frappe.db.sql("""select bom_no from `tabBOM Item`
				where parent = %s and ifnull(bom_no, '') != ''""", bom_no)]

		count = 0
		if self.name not in bom_list:
			bom_list.append(self.name)

		while(count < len(bom_list)):
			for child_bom in _get_children(bom_list[count]):
				if child_bom not in bom_list:
					bom_list.append(child_bom)
			count += 1
		bom_list.reverse()
		return bom_list

	def calculate_cost(self):
		"""Calculate bom totals"""
		self.calculate_op_cost()
		self.calculate_rm_cost()
		self.total_cost = self.raw_material_cost + self.operating_cost

	def calculate_op_cost(self):
		"""Update workstation rate and calculates totals"""
		total_op_cost = 0
		for d in self.get('bom_operations'):
			if d.workstation and not d.hour_rate:
				d.hour_rate = frappe.db.get_value("Workstation", d.workstation, "hour_rate")
			if d.hour_rate and d.time_in_mins:
				d.operating_cost = flt(d.hour_rate) * flt(d.time_in_mins) / 60.0
			total_op_cost += flt(d.operating_cost)
		self.operating_cost = total_op_cost

	def calculate_rm_cost(self):
		"""Fetch RM rate as per today's valuation rate and calculate totals"""
		total_rm_cost = 0
		for d in self.get('bom_materials'):
			if d.bom_no:
				d.rate = self.get_bom_unitcost(d.bom_no)
			d.amount = flt(d.rate) * flt(d.qty)
			d.qty_consumed_per_unit = flt(d.qty) / flt(self.quantity)
			total_rm_cost += d.amount

		self.raw_material_cost = total_rm_cost

	def update_exploded_items(self):
		""" Update Flat BOM, following will be correct data"""
		self.get_exploded_items()
		self.add_exploded_items()

	def get_exploded_items(self):
		""" Get all raw materials including items from child bom"""
		self.cur_exploded_items = {}
		for d in self.get('bom_materials'):
			if d.bom_no:
				self.get_child_exploded_items(d.bom_no, d.qty)
			else:
				self.add_to_cur_exploded_items(frappe._dict({
					'item_code'				: d.item_code,
					'description'			: d.description,
					'stock_uom'				: d.stock_uom,
					'qty'					: flt(d.qty),
					'rate'					: flt(d.rate),
				}))

	def add_to_cur_exploded_items(self, args):
		if self.cur_exploded_items.get(args.item_code):
			self.cur_exploded_items[args.item_code]["qty"] += args.qty
		else:
			self.cur_exploded_items[args.item_code] = args

	def get_child_exploded_items(self, bom_no, qty):
		""" Add all items from Flat BOM of child BOM"""

		child_fb_items = frappe.db.sql("""select item_code, description, stock_uom, qty, rate,
			qty_consumed_per_unit from `tabBOM Explosion Item`
			where parent = %s and docstatus = 1""", bom_no, as_dict = 1)

		for d in child_fb_items:
			self.add_to_cur_exploded_items(frappe._dict({
				'item_code'				: d['item_code'],
				'description'			: d['description'],
				'stock_uom'				: d['stock_uom'],
				'qty'					: flt(d['qty_consumed_per_unit'])*qty,
				'rate'					: flt(d['rate']),
			}))

	def add_exploded_items(self):
		"Add items to Flat BOM table"
		frappe.db.sql("""delete from `tabBOM Explosion Item` where parent=%s""", self.name)
		self.set('flat_bom_details', [])
		for d in self.cur_exploded_items:
			ch = self.append('flat_bom_details', {})
			for i in self.cur_exploded_items[d].keys():
				ch.set(i, self.cur_exploded_items[d][i])
			ch.amount = flt(ch.qty) * flt(ch.rate)
			ch.qty_consumed_per_unit = flt(ch.qty) / flt(self.quantity)
			ch.docstatus = self.docstatus
			ch.db_insert()

	def validate_bom_links(self):
		if not self.is_active:
			act_pbom = frappe.db.sql("""select distinct bom_item.parent from `tabBOM Item` bom_item
				where bom_item.bom_no = %s and bom_item.docstatus = 1
				and exists (select * from `tabBOM` where name = bom_item.parent
					and docstatus = 1 and is_active = 1)""", self.name)

			if act_pbom and act_pbom[0][0]:
				frappe.throw(_("Cannot deactive or cancle BOM as it is linked with other BOMs"))

def get_bom_items_as_dict(bom, qty=1, fetch_exploded=1):
	item_dict = {}

	query = """select
				bom_item.item_code,
				item.item_name,
				ifnull(sum(bom_item.qty_consumed_per_unit),0) * %(qty)s as qty,
				item.description,
				item.stock_uom,
				item.default_warehouse,
				item.expense_account as expense_account,
				item.buying_cost_center as cost_center
			from
				`tab%(table)s` bom_item, `tabItem` item
			where
				bom_item.docstatus < 2
				and bom_item.parent = "%(bom)s"
				and item.name = bom_item.item_code
				%(conditions)s
				group by item_code, stock_uom"""

	if fetch_exploded:
		items = frappe.db.sql(query % {
			"qty": qty,
			"table": "BOM Explosion Item",
			"bom": bom,
			"conditions": """and ifnull(item.is_pro_applicable, 'No') = 'No'
					and ifnull(item.is_sub_contracted_item, 'No') = 'No' """
		}, as_dict=True)
	else:
		items = frappe.db.sql(query % {
			"qty": qty,
			"table": "BOM Item",
			"bom": bom,
			"conditions": ""
		}, as_dict=True)

	# make unique
	for item in items:
		if item_dict.has_key(item.item_code):
			item_dict[item.item_code]["qty"] += flt(item.qty)
		else:
			item_dict[item.item_code] = item

	return item_dict

@frappe.whitelist()
def get_bom_items(bom, qty=1, fetch_exploded=1):
	items = get_bom_items_as_dict(bom, qty, fetch_exploded).values()
	items.sort(lambda a, b: a.item_code > b.item_code and 1 or -1)
	return items

########NEW FILE########
__FILENAME__ = test_bom
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


from __future__ import unicode_literals
import unittest
import frappe

test_records = frappe.get_test_records('Bom')

class TestBOM(unittest.TestCase):
	def test_get_items(self):
		from erpnext.manufacturing.doctype.bom.bom import get_bom_items_as_dict
		items_dict = get_bom_items_as_dict(bom="BOM/_Test FG Item 2/001", qty=1, fetch_exploded=0)
		self.assertTrue(test_records[2]["bom_materials"][0]["item_code"] in items_dict)
		self.assertTrue(test_records[2]["bom_materials"][1]["item_code"] in items_dict)
		self.assertEquals(len(items_dict.values()), 2)

	def test_get_items_exploded(self):
		from erpnext.manufacturing.doctype.bom.bom import get_bom_items_as_dict
		items_dict = get_bom_items_as_dict(bom="BOM/_Test FG Item 2/001", qty=1, fetch_exploded=1)
		self.assertTrue(test_records[2]["bom_materials"][0]["item_code"] in items_dict)
		self.assertFalse(test_records[2]["bom_materials"][1]["item_code"] in items_dict)
		self.assertTrue(test_records[0]["bom_materials"][0]["item_code"] in items_dict)
		self.assertTrue(test_records[0]["bom_materials"][1]["item_code"] in items_dict)
		self.assertEquals(len(items_dict.values()), 3)

	def test_get_items_list(self):
		from erpnext.manufacturing.doctype.bom.bom import get_bom_items
		self.assertEquals(len(get_bom_items(bom="BOM/_Test FG Item 2/001", qty=1, fetch_exploded=1)), 3)

########NEW FILE########
__FILENAME__ = bom_explosion_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class BOMExplosionItem(Document):
	pass
########NEW FILE########
__FILENAME__ = bom_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class BOMItem(Document):
	pass
########NEW FILE########
__FILENAME__ = bom_operation
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class BOMOperation(Document):
	pass
########NEW FILE########
__FILENAME__ = bom_replace_tool
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cstr, flt
from frappe import _

from frappe.model.document import Document

class BOMReplaceTool(Document):
	def replace_bom(self):
		self.validate_bom()
		self.update_new_bom()
		bom_list = self.get_parent_boms()
		updated_bom = []
		for bom in bom_list:
			bom_obj = frappe.get_doc("BOM", bom)
			updated_bom = bom_obj.update_cost_and_exploded_items(updated_bom)

		frappe.msgprint(_("BOM replaced"))

	def validate_bom(self):
		if cstr(self.current_bom) == cstr(self.new_bom):
			frappe.throw(_("Current BOM and New BOM can not be same"))

	def update_new_bom(self):
		current_bom_unitcost = frappe.db.sql("""select total_cost/quantity
			from `tabBOM` where name = %s""", self.current_bom)
		current_bom_unitcost = current_bom_unitcost and flt(current_bom_unitcost[0][0]) or 0
		frappe.db.sql("""update `tabBOM Item` set bom_no=%s,
			rate=%s, amount=qty*%s where bom_no = %s and docstatus < 2""",
			(self.new_bom, current_bom_unitcost, current_bom_unitcost, self.current_bom))

	def get_parent_boms(self):
		return [d[0] for d in frappe.db.sql("""select distinct parent
			from `tabBOM Item` where ifnull(bom_no, '') = %s and docstatus < 2""",
			self.new_bom)]

########NEW FILE########
__FILENAME__ = production_order
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import flt, nowdate
from frappe import _
from frappe.model.document import Document

class OverProductionError(frappe.ValidationError): pass
class StockOverProductionError(frappe.ValidationError): pass

class ProductionOrder(Document):

	def validate(self):
		if self.docstatus == 0:
			self.status = "Draft"

		from erpnext.utilities import validate_status
		validate_status(self.status, ["Draft", "Submitted", "Stopped",
			"In Process", "Completed", "Cancelled"])

		self.validate_bom_no()
		self.validate_sales_order()
		self.validate_warehouse()

		from erpnext.utilities.transaction_base import validate_uom_is_integer
		validate_uom_is_integer(self, "stock_uom", ["qty", "produced_qty"])

	def validate_bom_no(self):
		if self.bom_no:
			bom = frappe.db.sql("""select name from `tabBOM` where name=%s and docstatus=1
				and is_active=1 and item=%s"""
				, (self.bom_no, self.production_item), as_dict =1)
			if not bom:
				frappe.throw(_("BOM {0} is not active or not submitted").format(self.bom_no))

	def validate_sales_order(self):
		if self.sales_order:
			so = frappe.db.sql("""select name, delivery_date from `tabSales Order`
				where name=%s and docstatus = 1""", self.sales_order, as_dict=1)[0]

			if not so.name:
				frappe.throw(_("Sales Order {0} is not valid") % self.sales_order)

			if not self.expected_delivery_date:
				self.expected_delivery_date = so.delivery_date

			self.validate_production_order_against_so()

	def validate_warehouse(self):
		from erpnext.stock.utils import validate_warehouse_company

		for w in [self.fg_warehouse, self.wip_warehouse]:
			validate_warehouse_company(w, self.company)

	def validate_production_order_against_so(self):
		# already ordered qty
		ordered_qty_against_so = frappe.db.sql("""select sum(qty) from `tabProduction Order`
			where production_item = %s and sales_order = %s and docstatus < 2 and name != %s""",
			(self.production_item, self.sales_order, self.name))[0][0]

		total_qty = flt(ordered_qty_against_so) + flt(self.qty)

		# get qty from Sales Order Item table
		so_item_qty = frappe.db.sql("""select sum(qty) from `tabSales Order Item`
			where parent = %s and item_code = %s""",
			(self.sales_order, self.production_item))[0][0]
		# get qty from Packing Item table
		dnpi_qty = frappe.db.sql("""select sum(qty) from `tabPacked Item`
			where parent = %s and parenttype = 'Sales Order' and item_code = %s""",
			(self.sales_order, self.production_item))[0][0]
		# total qty in SO
		so_qty = flt(so_item_qty) + flt(dnpi_qty)

		if total_qty > so_qty:
			frappe.throw(_("Cannot produce more Item {0} than Sales Order quantity {1}").format(self.production_item,
				so_qty), OverProductionError)

	def stop_unstop(self, status):
		""" Called from client side on Stop/Unstop event"""
		self.update_status(status)
		qty = (flt(self.qty)-flt(self.produced_qty)) * ((status == 'Stopped') and -1 or 1)
		self.update_planned_qty(qty)
		frappe.msgprint(_("Production Order status is {0}").format(status))


	def update_status(self, status=None):
		if not status:
			status = self.status

		if status != 'Stopped':
			stock_entries = frappe._dict(frappe.db.sql("""select purpose, sum(fg_completed_qty)
				from `tabStock Entry` where production_order=%s and docstatus=1
				group by purpose""", self.name))

			status = "Submitted"
			if stock_entries:
				status = "In Process"
				produced_qty = stock_entries.get("Manufacture/Repack")
				if flt(produced_qty) == flt(self.qty):
					status = "Completed"

		if status != self.status:
			self.db_set("status", status)

	def update_produced_qty(self):
		produced_qty = frappe.db.sql("""select sum(fg_completed_qty)
			from `tabStock Entry` where production_order=%s and docstatus=1
			and purpose='Manufacture/Repack'""", self.name)
		produced_qty = flt(produced_qty[0][0]) if produced_qty else 0

		if produced_qty > self.qty:
			frappe.throw(_("Manufactured quantity {0} cannot be greater than planned quanitity {1} in Production Order {2}").format(produced_qty, self.qty, self.name), StockOverProductionError)

		self.db_set("produced_qty", produced_qty)

	def on_submit(self):
		if not self.wip_warehouse:
			frappe.throw(_("Work-in-Progress Warehouse is required before Submit"))
		if not self.fg_warehouse:
			frappe.throw(_("For Warehouse is required before Submit"))
		frappe.db.set(self,'status', 'Submitted')
		self.update_planned_qty(self.qty)


	def on_cancel(self):
		# Check whether any stock entry exists against this Production Order
		stock_entry = frappe.db.sql("""select name from `tabStock Entry`
			where production_order = %s and docstatus = 1""", self.name)
		if stock_entry:
			frappe.throw(_("Cannot cancel because submitted Stock Entry {0} exists").format(stock_entry[0][0]))

		frappe.db.set(self,'status', 'Cancelled')
		self.update_planned_qty(-self.qty)

	def update_planned_qty(self, qty):
		"""update planned qty in bin"""
		args = {
			"item_code": self.production_item,
			"warehouse": self.fg_warehouse,
			"posting_date": nowdate(),
			"planned_qty": flt(qty)
		}
		from erpnext.stock.utils import update_bin
		update_bin(args)

@frappe.whitelist()
def get_item_details(item):
	res = frappe.db.sql("""select stock_uom, description
		from `tabItem` where (ifnull(end_of_life, "")="" or end_of_life > now())
		and name=%s""", item, as_dict=1)

	if not res:
		return {}

	res = res[0]
	bom = frappe.db.sql("""select name from `tabBOM` where item=%s
		and ifnull(is_default, 0)=1""", item)
	if bom:
		res.bom_no = bom[0][0]

	return res

@frappe.whitelist()
def make_stock_entry(production_order_id, purpose, qty=None):
	production_order = frappe.get_doc("Production Order", production_order_id)

	stock_entry = frappe.new_doc("Stock Entry")
	stock_entry.purpose = purpose
	stock_entry.production_order = production_order_id
	stock_entry.company = production_order.company
	stock_entry.bom_no = production_order.bom_no
	stock_entry.use_multi_level_bom = production_order.use_multi_level_bom
	stock_entry.fg_completed_qty = qty or (flt(production_order.qty) - flt(production_order.produced_qty))

	if purpose=="Material Transfer":
		stock_entry.to_warehouse = production_order.wip_warehouse
	else:
		stock_entry.from_warehouse = production_order.wip_warehouse
		stock_entry.to_warehouse = production_order.fg_warehouse

	stock_entry.run_method("get_items")
	return stock_entry.as_dict()

########NEW FILE########
__FILENAME__ = test_production_order
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


from __future__ import unicode_literals
import unittest
import frappe
from erpnext.stock.doctype.purchase_receipt.test_purchase_receipt import set_perpetual_inventory
from erpnext.manufacturing.doctype.production_order.production_order import make_stock_entry
from erpnext.stock.doctype.stock_entry import test_stock_entry

class TestProductionOrder(unittest.TestCase):
	def test_planned_qty(self):
		set_perpetual_inventory(0)

		planned0 = frappe.db.get_value("Bin", {"item_code": "_Test FG Item", "warehouse": "_Test Warehouse 1 - _TC"}, "planned_qty") or 0

		pro_doc = frappe.copy_doc(test_records[0])
		pro_doc.insert()
		pro_doc.submit()

		# add raw materials to stores
		test_stock_entry.make_stock_entry("_Test Item", None, "Stores - _TC", 100, 100)
		test_stock_entry.make_stock_entry("_Test Item Home Desktop 100", None, "Stores - _TC", 100, 100)

		# from stores to wip
		s = frappe.get_doc(make_stock_entry(pro_doc.name, "Material Transfer", 4))
		for d in s.get("mtn_details"):
			d.s_warehouse = "Stores - _TC"
		s.insert()
		s.submit()

		# from wip to fg
		s = frappe.get_doc(make_stock_entry(pro_doc.name, "Manufacture/Repack", 4))
		s.insert()
		s.submit()

		self.assertEqual(frappe.db.get_value("Production Order", pro_doc.name,
			"produced_qty"), 4)
		planned1 = frappe.db.get_value("Bin", {"item_code": "_Test FG Item", "warehouse": "_Test Warehouse 1 - _TC"}, "planned_qty")
		self.assertEqual(planned1 - planned0, 6)

		return pro_doc

	def test_over_production(self):
		from erpnext.manufacturing.doctype.production_order.production_order import StockOverProductionError
		pro_doc = self.test_planned_qty()

		test_stock_entry.make_stock_entry("_Test Item", None, "_Test Warehouse - _TC", 100, 100)
		test_stock_entry.make_stock_entry("_Test Item Home Desktop 100", None, "_Test Warehouse - _TC", 100, 100)

		s = frappe.get_doc(make_stock_entry(pro_doc.name, "Manufacture/Repack", 7))
		s.insert()

		self.assertRaises(StockOverProductionError, s.submit)


test_records = frappe.get_test_records('Production Order')

########NEW FILE########
__FILENAME__ = production_planning_tool
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cstr, flt, cint, nowdate, add_days, comma_and

from frappe import msgprint, _

from frappe.model.document import Document

class ProductionPlanningTool(Document):
	def __init__(self, arg1, arg2=None):
		super(ProductionPlanningTool, self).__init__(arg1, arg2)
		self.item_dict = {}

	def get_so_details(self, so):
		"""Pull other details from so"""
		so = frappe.db.sql("""select transaction_date, customer, grand_total
			from `tabSales Order` where name = %s""", so, as_dict = 1)
		ret = {
			'sales_order_date': so and so[0]['transaction_date'] or '',
			'customer' : so[0]['customer'] or '',
			'grand_total': so[0]['grand_total']
		}
		return ret

	def get_item_details(self, item_code):
		""" Pull other item details from item master"""

		item = frappe.db.sql("""select description, stock_uom, default_bom
			from `tabItem` where name = %s""", item_code, as_dict =1)
		ret = {
			'description'	: item and item[0]['description'],
			'stock_uom'		: item and item[0]['stock_uom'],
			'bom_no'		: item and item[0]['default_bom']
		}
		return ret

	def clear_so_table(self):
		self.set('pp_so_details', [])

	def clear_item_table(self):
		self.set('pp_details', [])

	def validate_company(self):
		if not self.company:
			frappe.throw(_("Please enter Company"))

	def get_open_sales_orders(self):
		""" Pull sales orders  which are pending to deliver based on criteria selected"""
		so_filter = item_filter = ""
		if self.from_date:
			so_filter += ' and so.transaction_date >= "' + self.from_date + '"'
		if self.to_date:
			so_filter += ' and so.transaction_date <= "' + self.to_date + '"'
		if self.customer:
			so_filter += ' and so.customer = "' + self.customer + '"'

		if self.fg_item:
			item_filter += ' and item.name = "' + self.fg_item + '"'

		open_so = frappe.db.sql("""
			select distinct so.name, so.transaction_date, so.customer, so.grand_total
			from `tabSales Order` so, `tabSales Order Item` so_item
			where so_item.parent = so.name
				and so.docstatus = 1 and so.status != "Stopped"
				and so.company = %s
				and ifnull(so_item.qty, 0) > ifnull(so_item.delivered_qty, 0) %s
				and (exists (select name from `tabItem` item where item.name=so_item.item_code
					and (ifnull(item.is_pro_applicable, 'No') = 'Yes'
						or ifnull(item.is_sub_contracted_item, 'No') = 'Yes') %s)
					or exists (select name from `tabPacked Item` pi
						where pi.parent = so.name and pi.parent_item = so_item.item_code
							and exists (select name from `tabItem` item where item.name=pi.item_code
								and (ifnull(item.is_pro_applicable, 'No') = 'Yes'
									or ifnull(item.is_sub_contracted_item, 'No') = 'Yes') %s)))
			""" % ('%s', so_filter, item_filter, item_filter), self.company, as_dict=1)

		self.add_so_in_table(open_so)

	def add_so_in_table(self, open_so):
		""" Add sales orders in the table"""
		self.clear_so_table()

		so_list = [d.sales_order for d in self.get('pp_so_details')]
		for r in open_so:
			if cstr(r['name']) not in so_list:
				pp_so = self.append('pp_so_details', {})
				pp_so.sales_order = r['name']
				pp_so.sales_order_date = cstr(r['transaction_date'])
				pp_so.customer = cstr(r['customer'])
				pp_so.grand_total = flt(r['grand_total'])

	def get_items_from_so(self):
		""" Pull items from Sales Order, only proction item
			and subcontracted item will be pulled from Packing item
			and add items in the table
		"""
		items = self.get_items()
		self.add_items(items)

	def get_items(self):
		so_list = filter(None, [d.sales_order for d in self.get('pp_so_details')])
		if not so_list:
			msgprint(_("Please enter sales order in the above table"))
			return []

		item_condition = ""
		if self.fg_item:
			item_condition = ' and so_item.item_code = "' + self.fg_item + '"'

		items = frappe.db.sql("""select distinct parent, item_code, warehouse,
			(qty - ifnull(delivered_qty, 0)) as pending_qty
			from `tabSales Order Item` so_item
			where parent in (%s) and docstatus = 1 and ifnull(qty, 0) > ifnull(delivered_qty, 0)
			and exists (select * from `tabItem` item where item.name=so_item.item_code
				and (ifnull(item.is_pro_applicable, 'No') = 'Yes'
					or ifnull(item.is_sub_contracted_item, 'No') = 'Yes')) %s""" % \
			(", ".join(["%s"] * len(so_list)), item_condition), tuple(so_list), as_dict=1)

		if self.fg_item:
			item_condition = ' and pi.item_code = "' + self.fg_item + '"'

		packed_items = frappe.db.sql("""select distinct pi.parent, pi.item_code, pi.warehouse as reserved_warhouse,
			(((so_item.qty - ifnull(so_item.delivered_qty, 0)) * pi.qty) / so_item.qty)
				as pending_qty
			from `tabSales Order Item` so_item, `tabPacked Item` pi
			where so_item.parent = pi.parent and so_item.docstatus = 1
			and pi.parent_item = so_item.item_code
			and so_item.parent in (%s) and ifnull(so_item.qty, 0) > ifnull(so_item.delivered_qty, 0)
			and exists (select * from `tabItem` item where item.name=pi.item_code
				and (ifnull(item.is_pro_applicable, 'No') = 'Yes'
					or ifnull(item.is_sub_contracted_item, 'No') = 'Yes')) %s""" % \
			(", ".join(["%s"] * len(so_list)), item_condition), tuple(so_list), as_dict=1)

		return items + packed_items


	def add_items(self, items):
		self.clear_item_table()

		for p in items:
			item_details = frappe.db.sql("""select description, stock_uom, default_bom
				from tabItem where name=%s""", p['item_code'])
			pi = self.append('pp_details', {})
			pi.sales_order				= p['parent']
			pi.warehouse				= p['warehouse']
			pi.item_code				= p['item_code']
			pi.description				= item_details and item_details[0][0] or ''
			pi.stock_uom				= item_details and item_details[0][1] or ''
			pi.bom_no					= item_details and item_details[0][2] or ''
			pi.so_pending_qty			= flt(p['pending_qty'])
			pi.planned_qty				= flt(p['pending_qty'])


	def validate_data(self):
		self.validate_company()
		for d in self.get('pp_details'):
			self.validate_bom_no(d)
			if not flt(d.planned_qty):
				frappe.throw(_("Please enter Planned Qty for Item {0} at row {1}").format(d.item_code, d.idx))

	def validate_bom_no(self, d):
		if not d.bom_no:
			frappe.throw(_("Please enter BOM for Item {0} at row {1}").format(d.item_code, d.idx))
		else:
			bom = frappe.db.sql("""select name from `tabBOM` where name = %s and item = %s
				and docstatus = 1 and is_active = 1""",
				(d.bom_no, d.item_code), as_dict = 1)
			if not bom:
				frappe.throw(_("Incorrect or Inactive BOM {0} for Item {1} at row {2}").format(d.bom_no, d.item_code, d.idx))

	def raise_production_order(self):
		"""It will raise production order (Draft) for all distinct FG items"""
		self.validate_data()

		from erpnext.utilities.transaction_base import validate_uom_is_integer
		validate_uom_is_integer(self, "stock_uom", "planned_qty")

		items = self.get_distinct_items_and_boms()[1]
		pro = self.create_production_order(items)
		if pro:
			pro = ["""<a href="#Form/Production Order/%s" target="_blank">%s</a>""" % \
				(p, p) for p in pro]
			msgprint(_("{0} created").format(comma_and(pro)))
		else :
			msgprint(_("No Production Orders created"))

	def get_distinct_items_and_boms(self):
		""" Club similar BOM and item for processing
			bom_dict {
				bom_no: ['sales_order', 'qty']
			}
		"""
		item_dict, bom_dict = {}, {}
		for d in self.get("pp_details"):
			bom_dict.setdefault(d.bom_no, []).append([d.sales_order, flt(d.planned_qty)])
			item_dict[(d.item_code, d.sales_order, d.warehouse)] = {
				"production_item"	: d.item_code,
				"sales_order"		: d.sales_order,
				"qty" 				: flt(item_dict.get((d.item_code, d.sales_order, d.warehouse),
										{}).get("qty")) + flt(d.planned_qty),
				"bom_no"			: d.bom_no,
				"description"		: d.description,
				"stock_uom"			: d.stock_uom,
				"company"			: self.company,
				"wip_warehouse"		: "",
				"fg_warehouse"		: d.warehouse,
				"status"			: "Draft",
			}
		return bom_dict, item_dict

	def create_production_order(self, items):
		"""Create production order. Called from Production Planning Tool"""
		from erpnext.manufacturing.doctype.production_order.production_order import OverProductionError

		pro_list = []
		for key in items:
			pro = frappe.new_doc("Production Order")
			pro.update(items[key])

			frappe.flags.mute_messages = True
			try:
				pro.insert()
				pro_list.append(pro.name)
			except OverProductionError:
				pass

			frappe.flags.mute_messages = False

		return pro_list

	def download_raw_materials(self):
		""" Create csv data for required raw material to produce finished goods"""
		self.validate_data()
		bom_dict = self.get_distinct_items_and_boms()[0]
		self.get_raw_materials(bom_dict)
		return self.get_csv()

	def get_raw_materials(self, bom_dict):
		""" Get raw materials considering sub-assembly items
			{
				"item_code": [qty_required, description, stock_uom, min_order_qty]
			}
		"""
		item_list = []

		for bom, so_wise_qty in bom_dict.items():
			bom_wise_item_details = {}
			if self.use_multi_level_bom:
				# get all raw materials with sub assembly childs
				for d in frappe.db.sql("""select fb.item_code,
					ifnull(sum(fb.qty_consumed_per_unit), 0) as qty,
					fb.description, fb.stock_uom, it.min_order_qty
					from `tabBOM Explosion Item` fb,`tabItem` it
					where it.name = fb.item_code and ifnull(it.is_pro_applicable, 'No') = 'No'
					and ifnull(it.is_sub_contracted_item, 'No') = 'No'
					and fb.docstatus<2 and fb.parent=%s
					group by item_code, stock_uom""", bom, as_dict=1):
						bom_wise_item_details.setdefault(d.item_code, d)
			else:
				# Get all raw materials considering SA items as raw materials,
				# so no childs of SA items
				for d in frappe.db.sql("""select bom_item.item_code,
					ifnull(sum(bom_item.qty_consumed_per_unit), 0) as qty,
					bom_item.description, bom_item.stock_uom, item.min_order_qty
					from `tabBOM Item` bom_item, tabItem item
					where bom_item.parent = %s and bom_item.docstatus < 2
					and bom_item.item_code = item.name
					group by item_code""", bom, as_dict=1):
						bom_wise_item_details.setdefault(d.item_code, d)

			for item, item_details in bom_wise_item_details.items():
				for so_qty in so_wise_qty:
					item_list.append([item, flt(item_details.qty) * so_qty[1], item_details.description,
						item_details.stock_uom, item_details.min_order_qty, so_qty[0]])

			self.make_items_dict(item_list)

	def make_items_dict(self, item_list):
		for i in item_list:
			self.item_dict.setdefault(i[0], []).append([flt(i[1]), i[2], i[3], i[4], i[5]])

	def get_csv(self):
		item_list = [['Item Code', 'Description', 'Stock UOM', 'Required Qty', 'Warehouse',
		 	'Quantity Requested for Purchase', 'Ordered Qty', 'Actual Qty']]
		for item in self.item_dict:
			total_qty = sum([flt(d[0]) for d in self.item_dict[item]])
			for item_details in self.item_dict[item]:
				item_list.append([item, item_details[1], item_details[2], item_details[0]])
				item_qty = frappe.db.sql("""select warehouse, indented_qty, ordered_qty, actual_qty
					from `tabBin` where item_code = %s""", item, as_dict=1)
				i_qty, o_qty, a_qty = 0, 0, 0
				for w in item_qty:
					i_qty, o_qty, a_qty = i_qty + flt(w.indented_qty), o_qty + flt(w.ordered_qty), a_qty + flt(w.actual_qty)
					item_list.append(['', '', '', '', w.warehouse, flt(w.indented_qty),
						flt(w.ordered_qty), flt(w.actual_qty)])
				if item_qty:
					item_list.append(['', '', '', '', 'Total', i_qty, o_qty, a_qty])

		return item_list

	def raise_purchase_request(self):
		"""
			Raise Material Request if projected qty is less than qty required
			Requested qty should be shortage qty considering minimum order qty
		"""
		self.validate_data()
		if not self.purchase_request_for_warehouse:
			frappe.throw(_("Please enter Warehouse for which Material Request will be raised"))

		bom_dict = self.get_distinct_items_and_boms()[0]
		self.get_raw_materials(bom_dict)

		if self.item_dict:
			self.insert_purchase_request()

	def get_requested_items(self):
		item_projected_qty = self.get_projected_qty()
		items_to_be_requested = frappe._dict()

		for item, so_item_qty in self.item_dict.items():
			requested_qty = 0
			total_qty = sum([flt(d[0]) for d in so_item_qty])
			if total_qty > item_projected_qty.get(item, 0):
				# shortage
				requested_qty = total_qty - item_projected_qty.get(item, 0)
				# consider minimum order qty
				requested_qty = requested_qty > flt(so_item_qty[0][3]) and \
					requested_qty or flt(so_item_qty[0][3])

			# distribute requested qty SO wise
			for item_details in so_item_qty:
				if requested_qty:
					sales_order = item_details[4] or "No Sales Order"
					if requested_qty <= item_details[0]:
						adjusted_qty = requested_qty
					else:
						adjusted_qty = item_details[0]

					items_to_be_requested.setdefault(item, {}).setdefault(sales_order, 0)
					items_to_be_requested[item][sales_order] += adjusted_qty
					requested_qty -= adjusted_qty
				else:
					break

			# requested qty >= total so qty, due to minimum order qty
			if requested_qty:
				items_to_be_requested.setdefault(item, {}).setdefault("No Sales Order", 0)
				items_to_be_requested[item]["No Sales Order"] += requested_qty

		return items_to_be_requested

	def get_projected_qty(self):
		items = self.item_dict.keys()
		item_projected_qty = frappe.db.sql("""select item_code, sum(projected_qty)
			from `tabBin` where item_code in (%s) group by item_code""" %
			(", ".join(["%s"]*len(items)),), tuple(items))

		return dict(item_projected_qty)

	def insert_purchase_request(self):
		items_to_be_requested = self.get_requested_items()

		from erpnext.accounts.utils import get_fiscal_year
		fiscal_year = get_fiscal_year(nowdate())[0]

		purchase_request_list = []
		if items_to_be_requested:
			for item in items_to_be_requested:
				item_wrapper = frappe.get_doc("Item", item)
				pr_doc = frappe.get_doc({
					"doctype": "Material Request",
					"__islocal": 1,
					"naming_series": "IDT",
					"transaction_date": nowdate(),
					"status": "Draft",
					"company": self.company,
					"fiscal_year": fiscal_year,
					"requested_by": frappe.session.user,
					"material_request_type": "Purchase"
				})
				for sales_order, requested_qty in items_to_be_requested[item].items():
					pr_doc.append("indent_details", {
						"doctype": "Material Request Item",
						"__islocal": 1,
						"item_code": item,
						"item_name": item_wrapper.item_name,
						"description": item_wrapper.description,
						"uom": item_wrapper.stock_uom,
						"item_group": item_wrapper.item_group,
						"brand": item_wrapper.brand,
						"qty": requested_qty,
						"schedule_date": add_days(nowdate(), cint(item_wrapper.lead_time_days)),
						"warehouse": self.purchase_request_for_warehouse,
						"sales_order_no": sales_order if sales_order!="No Sales Order" else None
					})

				pr_doc.ignore_permissions = 1
				pr_doc.submit()
				purchase_request_list.append(pr_doc.name)

			if purchase_request_list:
				pur_req = ["""<a href="#Form/Material Request/%s" target="_blank">%s</a>""" % \
					(p, p) for p in purchase_request_list]
				msgprint(_("Material Requests {0} created").format(comma_and(pur_req)))
		else:
			msgprint(_("Nothing to request"))

########NEW FILE########
__FILENAME__ = production_plan_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ProductionPlanItem(Document):
	pass
########NEW FILE########
__FILENAME__ = production_plan_sales_order
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ProductionPlanSalesOrder(Document):
	pass
########NEW FILE########
__FILENAME__ = workstation
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt

from frappe.model.document import Document

class Workstation(Document):
	def update_bom_operation(self):
		bom_list = frappe.db.sql("""select DISTINCT parent from `tabBOM Operation` 
			where workstation = %s""", self.name)
		for bom_no in bom_list:
			frappe.db.sql("""update `tabBOM Operation` set hour_rate = %s 
				where parent = %s and workstation = %s""", 
				(self.hour_rate, bom_no[0], self.name))
	
	def on_update(self):
		frappe.db.set(self, 'overhead', flt(self.hour_rate_electricity) + 
		flt(self.hour_rate_consumable) + flt(self.hour_rate_rent))
		frappe.db.set(self, 'hour_rate', flt(self.hour_rate_labour) + flt(self.overhead))
		self.update_bom_operation()
########NEW FILE########
__FILENAME__ = set_stock_balance_as_per_serial_no
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute():
	from erpnext.utilities.repost_stock import set_stock_balance_as_per_serial_no
	frappe.db.auto_commit_on_many_writes = 1

	set_stock_balance_as_per_serial_no()

	frappe.db.auto_commit_on_many_writes = 0

########NEW FILE########
__FILENAME__ = countrywise_coa
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute():
	frappe.reload_doc("setup", 'doctype', "company")
	frappe.reload_doc("accounts", 'doctype', "account")

	frappe.db.sql("""update tabAccount set account_type='Cash'
		where account_type='Bank or Cash' and account_name in ('Cash', 'Cash In Hand')""")

	frappe.db.sql("""update tabAccount set account_type='Stock'
		where account_name = 'Stock Assets'""")

	ac_types = {"Fixed Asset Account": "Fixed Asset", "Bank or Cash": "Bank"}
	for old, new in ac_types.items():
		frappe.db.sql("""update tabAccount set account_type=%s
			where account_type=%s""", (new, old))

	try:
		frappe.db.sql("""update `tabAccount` set report_type =
			if(is_pl_account='Yes', 'Profit and Loss', 'Balance Sheet')""")

		frappe.db.sql("""update `tabAccount` set balance_must_be=debit_or_credit
			where ifnull(allow_negative_balance, 0) = 0""")
	except:
		pass

########NEW FILE########
__FILENAME__ = customer_discount_to_pricing_rule
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute():
	frappe.reload_doc("accounts", "doctype", "pricing_rule")
	
	frappe.db.auto_commit_on_many_writes = True
	
	for d in frappe.db.sql("""select * from `tabCustomer Discount` 
		where ifnull(parent, '') != '' and docstatus < 2""", as_dict=1):
			if not d.item_group:
				item_group = frappe.db.sql("""select name from `tabItem Group` 
					where ifnull(parent_item_group, '') = ''""")[0][0]
			else:
				item_group = d.item_group
				
			frappe.get_doc({
				"doctype": "Pricing Rule",
				"apply_on": "Item Group",
				"item_group": item_group,
				"applicable_for": "Customer",
				"customer": d.parent,
				"price_or_discount": "Discount Percentage",
				"discount_percentage": d.discount
			}).insert()
	
	frappe.db.auto_commit_on_many_writes = False		
	
	frappe.delete_doc("DocType", "Customer Discount")

########NEW FILE########
__FILENAME__ = fields_to_be_renamed
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.model import rename_field
from frappe.modules import scrub, get_doctype_module

rename_map = {
	"Quotation Item": [
		["ref_rate", "price_list_rate"],
		["base_ref_rate", "base_price_list_rate"],
		["adj_rate", "discount_percentage"],
		["export_rate", "rate"],
		["basic_rate", "base_rate"],
		["amount", "base_amount"],
		["export_amount", "amount"]
	],

	"Sales Order Item": [
		["ref_rate", "price_list_rate"],
		["base_ref_rate", "base_price_list_rate"],
		["adj_rate", "discount_percentage"],
		["export_rate", "rate"],
		["basic_rate", "base_rate"],
		["amount", "base_amount"],
		["export_amount", "amount"],
		["reserved_warehouse", "warehouse"]
	],

	"Delivery Note Item": [
		["ref_rate", "price_list_rate"],
		["base_ref_rate", "base_price_list_rate"],
		["adj_rate", "discount_percentage"],
		["export_rate", "rate"],
		["basic_rate", "base_rate"],
		["amount", "base_amount"],
		["export_amount", "amount"]
	],

	"Sales Invoice Item": [
		["ref_rate", "price_list_rate"],
		["base_ref_rate", "base_price_list_rate"],
		["adj_rate", "discount_percentage"],
		["export_rate", "rate"],
		["basic_rate", "base_rate"],
		["amount", "base_amount"],
		["export_amount", "amount"]
	],

	"Supplier Quotation Item": [
		["import_ref_rate", "price_list_rate"],
		["purchase_ref_rate", "base_price_list_rate"],
		["discount_rate", "discount_percentage"],
		["import_rate", "rate"],
		["purchase_rate", "base_rate"],
		["amount", "base_amount"],
		["import_amount", "amount"]
	],

	"Purchase Order Item": [
		["import_ref_rate", "price_list_rate"],
		["purchase_ref_rate", "base_price_list_rate"],
		["discount_rate", "discount_percentage"],
		["import_rate", "rate"],
		["purchase_rate", "base_rate"],
		["amount", "base_amount"],
		["import_amount", "amount"]
	],

	"Purchase Receipt Item": [
		["import_ref_rate", "price_list_rate"],
		["purchase_ref_rate", "base_price_list_rate"],
		["discount_rate", "discount_percentage"],
		["import_rate", "rate"],
		["purchase_rate", "base_rate"],
		["amount", "base_amount"],
		["import_amount", "amount"]
	],

	"Purchase Invoice Item": [
		["import_ref_rate", "price_list_rate"],
		["purchase_ref_rate", "base_price_list_rate"],
		["discount_rate", "discount_percentage"],
		["import_rate", "rate"],
		["rate", "base_rate"],
		["amount", "base_amount"],
		["import_amount", "amount"],
		["expense_head", "expense_account"]
	],

	"Item": [
		["purchase_account", "expense_account"],
		["default_sales_cost_center", "selling_cost_center"],
		["cost_center", "buying_cost_center"],
		["default_income_account", "income_account"],
	],
	"Item Price": [
		["ref_rate", "price_list_rate"]
	]
}

def execute():
	for dn in rename_map:
		frappe.reload_doc(get_doctype_module(dn), "doctype", scrub(dn))

	for dt, field_list in rename_map.items():
		for field in field_list:
			rename_field(dt, field[0], field[1])

########NEW FILE########
__FILENAME__ = fix_contact_address
import frappe

def execute():
	frappe.reload_doc("website", "doctype", "contact_us_settings")
	address = frappe.db.get_value("Contact Us Settings", None, "address")
	if address:
		address = frappe.get_doc("Address", address)
		contact = frappe.get_doc("Contact Us Settings", "Contact Us Settings")
		for f in ("address_title", "address_line1", "address_line2", "city", "state", "country", "pincode"):
			contact.set(f, address.get(f))
		
		contact.save()
########NEW FILE########
__FILENAME__ = fix_employee_user_id
import frappe
from frappe.utils import get_fullname

def execute():
	for user_id in frappe.db.sql_list("""select distinct user_id from `tabEmployee`
		where ifnull(user_id, '')!=''
		group by user_id having count(name) > 1"""):
		
		fullname = get_fullname(user_id)
		employee = frappe.db.get_value("Employee", {"employee_name": fullname, "user_id": user_id})
		if employee:
			frappe.db.sql("""update `tabEmployee` set user_id=null
				where user_id=%s and name!=%s""", (user_id, employee))
########NEW FILE########
__FILENAME__ = global_defaults_to_system_settings
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# MIT License. See license.txt

from __future__ import unicode_literals

import frappe
from collections import Counter
from frappe.core.doctype.user.user import STANDARD_USERS

def execute():
	frappe.reload_doc("core", "doctype", "system_settings")
	system_settings = frappe.get_doc("System Settings")

	# set values from global_defauls
	global_defaults = frappe.db.get_value("Global Defaults", None,
		["time_zone", "date_format", "number_format", "float_precision", "session_expiry"], as_dict=True)

	if global_defaults:
		for key, val in global_defaults.items():
			if not system_settings.get(key):
				system_settings.set(key, val)

	# language
	if not system_settings.get("language"):
		# find most common language
		lang = frappe.db.sql_list("""select language from `tabUser`
			where ifnull(language, '')!='' and language not like "Loading%%" and name not in ({standard_users})""".format(
			standard_users=", ".join(["%s"]*len(STANDARD_USERS))), tuple(STANDARD_USERS))
		lang = Counter(lang).most_common(1)
		lang = (len(lang) > 0) and lang[0][0] or "english"

		system_settings.language = lang

	system_settings.ignore_mandatory = True
	system_settings.save()

########NEW FILE########
__FILENAME__ = import_country_codes
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# MIT License. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.country_info import get_all
from erpnext.setup.install import import_country_and_currency

def execute():
	frappe.reload_doc("setup", "doctype", "country")
	import_country_and_currency()
	for name, country in get_all().iteritems():
		frappe.set_value("Country", name, "code", country.get("code"))
########NEW FILE########
__FILENAME__ = map_charge_to_taxes_and_charges
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute():
	# udpate sales cycle
	for d in ['Sales Invoice', 'Sales Order', 'Quotation', 'Delivery Note']:
		frappe.db.sql("""update `tab%s` set taxes_and_charges=charge""" % d)

	# udpate purchase cycle
	for d in ['Purchase Invoice', 'Purchase Order', 'Supplier Quotation', 'Purchase Receipt']:
		frappe.db.sql("""update `tab%s` set taxes_and_charges=purchase_other_charges""" % d)
	
	frappe.db.sql("""update `tabPurchase Taxes and Charges` set parentfield='other_charges'""")

########NEW FILE########
__FILENAME__ = move_warehouse_user_to_restrictions
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute():
	from frappe.core.page.user_properties import user_properties
	for warehouse, user in frappe.db.sql("""select parent, user from `tabWarehouse User`"""):
		user_properties.add(user, "Warehouse", warehouse)
	
	frappe.delete_doc("DocType", "Warehouse User")
	frappe.reload_doc("stock", "doctype", "warehouse")
########NEW FILE########
__FILENAME__ = new_permissions
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute():
	# reset Page perms
	from frappe.core.page.permission_manager.permission_manager import reset
	reset("Page")
	reset("Report")
	
	# patch to move print, email into DocPerm
	for doctype, hide_print, hide_email in frappe.db.sql("""select name, ifnull(allow_print, 0), ifnull(allow_email, 0)
		from `tabDocType` where ifnull(issingle, 0)=0 and ifnull(istable, 0)=0 and
		(ifnull(allow_print, 0)=0 or ifnull(allow_email, 0)=0)"""):
		
		if not hide_print:
			frappe.db.sql("""update `tabDocPerm` set `print`=1
				where permlevel=0 and `read`=1 and parent=%s""", doctype)
		
		if not hide_email:
			frappe.db.sql("""update `tabDocPerm` set `email`=1
				where permlevel=0 and `read`=1 and parent=%s""", doctype)

########NEW FILE########
__FILENAME__ = reload_purchase_print_format
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute():
	frappe.reload_doc('buying', 'Print Format', 'Purchase Order Classic')
	frappe.reload_doc('buying', 'Print Format', 'Purchase Order Modern')
	frappe.reload_doc('buying', 'Print Format', 'Purchase Order Spartan')
########NEW FILE########
__FILENAME__ = reload_sales_print_format
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute():
	frappe.reload_doc('accounts', 'Print Format', 'POS Invoice')
	frappe.reload_doc('accounts', 'Print Format', 'Sales Invoice Classic')
	frappe.reload_doc('accounts', 'Print Format', 'Sales Invoice Modern')
	frappe.reload_doc('accounts', 'Print Format', 'Sales Invoice Spartan')
	frappe.reload_doc('selling', 'Print Format', 'Quotation Classic')
	frappe.reload_doc('selling', 'Print Format', 'Quotation Modern')
	frappe.reload_doc('selling', 'Print Format', 'Quotation Spartan')
	frappe.reload_doc('selling', 'Print Format', 'Sales Order Classic')
	frappe.reload_doc('selling', 'Print Format', 'Sales Order Modern')
	frappe.reload_doc('selling', 'Print Format', 'Sales Order Spartan')
	frappe.reload_doc('stock', 'Print Format', 'Delivery Note Classic')
	frappe.reload_doc('stock', 'Print Format', 'Delivery Note Modern')
	frappe.reload_doc('stock', 'Print Format', 'Delivery Note Spartan')
########NEW FILE########
__FILENAME__ = remove_india_specific_fields
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.core.doctype.custom_field.custom_field import create_custom_field_if_values_exist

def execute():
	frappe.db.sql("delete from tabDocField where parent='Salary Slip' and options='Grade'")
	docfields = {
		("Purchase Receipt", "challan_no"): frappe.get_meta("Purchase Receipt").get_field("challan_no"),
		("Purchase Receipt", "challan_date"): frappe.get_meta("Purchase Receipt").get_field("challan_date"),
		("Employee", "pf_number"): frappe.get_meta("Employee").get_field("pf_number"),
		("Employee", "pan_number"): frappe.get_meta("Employee").get_field("pan_number"),
		("Employee", "gratuity_lic_id"): frappe.get_meta("Employee").get_field("gratuity_lic_id"),
		("Employee", "esic_card_no"): frappe.get_meta("Employee").get_field("esic_card_no"),
		("Salary Slip", "esic_no"): frappe.get_meta("Salary Slip").get_field("esic_no"),
		("Salary Slip", "pf_no"): frappe.get_meta("Salary Slip").get_field("pf_no")
	}

	for (doctype, fieldname), df in docfields.items():
		if not df:
			continue
		opts = df.as_dict()
		if df.idx >= 2:
			opts["insert_after"] = frappe.get_meta(doctype).get("fields")[df.idx - 2].fieldname

		frappe.delete_doc("DocField", df.name)
		frappe.clear_cache(doctype=doctype)
		create_custom_field_if_values_exist(doctype, opts)

########NEW FILE########
__FILENAME__ = remove_module_home_pages
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute():
	for page in ("accounts-home", "website-home", "support-home", "stock-home", "selling-home", "projects-home",
		"manufacturing-home", "hr-home", "buying-home"):
		frappe.delete_doc("Page", page)
########NEW FILE########
__FILENAME__ = rename_sitemap_to_route
import frappe
import frappe.model

def execute():
	frappe.reload_doc("setup", "doctype", "item_group")
	frappe.reload_doc("stock", "doctype", "item")
	frappe.reload_doc("setup", "doctype", "sales_partner")
	
	try:
		frappe.model.rename_field("Item Group", "parent_website_sitemap", "parent_website_route")
		frappe.model.rename_field("Item", "parent_website_sitemap", "parent_website_route")
		frappe.model.rename_field("Sales Partner", "parent_website_sitemap",
			 "parent_website_route")
	except Exception, e:
		if e.args[0]!=1054:
			raise
########NEW FILE########
__FILENAME__ = split_email_settings
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute():
	frappe.reload_doc("core", "doctype", "outgoing_email_settings")
	frappe.reload_doc("support", "doctype", "support_email_settings")
	
	email_settings = get_email_settings()
	map_outgoing_email_settings(email_settings)
	map_support_email_settings(email_settings)
	frappe.delete_doc("Doctype", "Email Settings")
	
def map_outgoing_email_settings(email_settings):
	outgoing_email_settings = frappe.get_doc("Outgoing Email Settings")
	for fieldname in (("outgoing_mail_server", "mail_server"), 
		"use_ssl", "mail_port", "mail_login", "mail_password",
		"always_use_login_id_as_sender",
		"auto_email_id", "send_print_in_body_and_attachment"):

		if isinstance(fieldname, tuple):
			from_fieldname, to_fieldname = fieldname
		else:
			from_fieldname = to_fieldname = fieldname

		outgoing_email_settings.set(to_fieldname, email_settings.get(from_fieldname))

	outgoing_email_settings.save()
	
def map_support_email_settings(email_settings):
	support_email_settings = frappe.get_doc("Support Email Settings")
	
	for fieldname in ("sync_support_mails", "support_email", 
		("support_host", "mail_server"), 
		("support_use_ssl", "use_ssl"), 
		("support_username", "mail_login"), 
		("support_password", "mail_password"), 
		"support_signature", "send_autoreply", "support_autoreply"):
		
		if isinstance(fieldname, tuple):
			from_fieldname, to_fieldname = fieldname
		else:
			from_fieldname = to_fieldname = fieldname
	
		support_email_settings.set(to_fieldname, email_settings.get(from_fieldname))
	
	support_email_settings.save()
	
def get_email_settings():
	ret = {}
	for field, value in frappe.db.sql("select field, value from tabSingles where doctype='Email Settings'"):
		ret[field] = value
	return ret


########NEW FILE########
__FILENAME__ = update_account_root_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute():
	frappe.reload_doc("accounts", "doctype", "account")

	account_table_columns = frappe.db.get_table_columns("Account")
	if "debit_or_credit" in account_table_columns and "is_pl_account" in account_table_columns:
		frappe.db.sql("""UPDATE tabAccount
			SET root_type = CASE
				WHEN (debit_or_credit='Debit' and is_pl_account = 'No') THEN 'Asset'
				WHEN (debit_or_credit='Credit' and is_pl_account = 'No') THEN 'Liability'
				WHEN (debit_or_credit='Debit' and is_pl_account = 'Yes') THEN 'Expense'
				WHEN (debit_or_credit='Credit' and is_pl_account = 'Yes') THEN 'Income'
				END
			WHERE ifnull(parent_account, '') = ''
		""")

	else:
		for key, root_type in (("asset", "Asset"), ("liabilities", "Liability"), ("expense", "Expense"),
			("income", "Income")):
			frappe.db.sql("""update tabAccount set root_type=%s where name like %s
				and ifnull(parent_account, '')=''""", (root_type, "%" + key + "%"))

	for root in frappe.db.sql("""SELECT name, lft, rgt, root_type FROM `tabAccount`
		WHERE ifnull(parent_account, '')=''""",	as_dict=True):
			if root.root_type:
				frappe.db.sql("""UPDATE tabAccount SET root_type=%s WHERE lft>%s and rgt<%s""",
					(root.root_type, root.lft, root.rgt))
			else:
				print b"Root type not found for {0}".format(root.name.encode("utf-8"))

########NEW FILE########
__FILENAME__ = update_incharge_name_to_sales_person_in_maintenance_schedule
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute():
	frappe.reload_doc("support", "doctype", "maintenance_schedule_detail")
	frappe.reload_doc("support", "doctype", "maintenance_schedule_item")
	
	frappe.db.sql("""update `tabMaintenance Schedule Detail` set sales_person=incharge_name""")
	frappe.db.sql("""update `tabMaintenance Schedule Item` set sales_person=incharge_name""")
########NEW FILE########
__FILENAME__ = update_user_properties
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
import frappe.permissions
import frappe.defaults

def execute():
	frappe.reload_doc("core", "doctype", "docperm")
	frappe.reload_doc("hr", "doctype", "employee")
	update_user_properties()
	update_user_match()
	add_employee_restrictions_to_leave_approver()
	update_permissions()
	remove_duplicate_restrictions()
	frappe.defaults.clear_cache()
	frappe.clear_cache()

def update_user_properties():
	frappe.reload_doc("core", "doctype", "docfield")
	
	for d in frappe.db.sql("""select parent, defkey, defvalue from tabDefaultValue
		where parent not in ('__global', '__default')""", as_dict=True):
		df = frappe.db.sql("""select options from tabDocField
			where fieldname=%s and fieldtype='Link'""", d.defkey, as_dict=True)
		
		if df:
			frappe.db.sql("""update tabDefaultValue
				set defkey=%s, parenttype='Restriction'
				where defkey=%s and
				parent not in ('__global', '__default')""", (df[0].options, d.defkey))

def update_user_match():
	import frappe.defaults
	doctype_matches = {}
	for doctype, match in frappe.db.sql("""select parent, `match` from `tabDocPerm`
		where `match` like %s and ifnull(`match`, '')!="leave_approver:user" """, "%:user"):
		doctype_matches.setdefault(doctype, []).append(match)
	
	for doctype, user_matches in doctype_matches.items():
		meta = frappe.get_meta(doctype)
		
		# for each user with roles of this doctype, check if match condition applies
		for user in frappe.db.sql_list("""select name from `tabUser`
			where enabled=1 and user_type='System User'"""):
			
			user_roles = frappe.get_roles(user)
			
			perms = meta.get({"doctype": "DocPerm", "permlevel": 0, 
				"role": ["in", [["All"] + user_roles]], "read": 1})

			# user does not have required roles
			if not perms:
				continue
			
			# assume match
			user_match = True
			for perm in perms:
				if not perm.match:
					# aha! non match found
					user_match = False
					break
			
			if not user_match:
				continue
			
			# if match condition applies, restrict that user
			# add that doc's restriction to that user
			for match in user_matches:
				for name in frappe.db.sql_list("""select name from `tab{doctype}`
					where `{field}`=%s""".format(doctype=doctype, field=match.split(":")[0]), user):
					
					frappe.defaults.add_default(doctype, name, user, "Restriction")
					
def add_employee_restrictions_to_leave_approver():
	from frappe.core.page.user_properties import user_properties
	
	# add restrict rights to HR User and HR Manager
	frappe.db.sql("""update `tabDocPerm` set `restrict`=1 where parent in ('Employee', 'Leave Application')
		and role in ('HR User', 'HR Manager') and permlevel=0 and `read`=1""")
	frappe.clear_cache()
	
	# add Employee restrictions (in on_update method)
	for employee in frappe.db.sql_list("""select name from `tabEmployee`
		where (exists(select leave_approver from `tabEmployee Leave Approver`
			where `tabEmployee Leave Approver`.parent=`tabEmployee`.name)
		or ifnull(`reports_to`, '')!='') and docstatus<2 and status='Active'"""):
		
		frappe.get_doc("Employee", employee).save()

def update_permissions():
	# clear match conditions other than owner
	frappe.db.sql("""update tabDocPerm set `match`=''
		where ifnull(`match`,'') not in ('', 'owner')""")

def remove_duplicate_restrictions():
	# remove duplicate restrictions (if they exist)
	for d in frappe.db.sql("""select parent, defkey, defvalue,
		count(*) as cnt from tabDefaultValue
		where parent not in ('__global', '__default')
		group by parent, defkey, defvalue""", as_dict=1):
		if d.cnt > 1:
			# order by parenttype so that restriction does not get removed!
			frappe.db.sql("""delete from tabDefaultValue where `parent`=%s and `defkey`=%s and
				`defvalue`=%s order by parenttype limit %s""", (d.parent, d.defkey, d.defvalue, d.cnt-1))

########NEW FILE########
__FILENAME__ = validate_v3_patch
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute():
	from frappe.modules.patch_handler import executed
	last_v3_patch = 'patches.1401.fix_pos_outstanding'
	if not executed(last_v3_patch):
		raise Exception, "site not ready to migrate to version 4"

########NEW FILE########
__FILENAME__ = activity_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ActivityType(Document):
	pass
########NEW FILE########
__FILENAME__ = test_activity_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Activity Type')
########NEW FILE########
__FILENAME__ = project
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import flt, getdate
from frappe import _
from erpnext.utilities.transaction_base import delete_events

from frappe.model.document import Document

class Project(Document):

	def get_gross_profit(self):
		pft, per_pft =0, 0
		pft = flt(self.project_value) - flt(self.est_material_cost)
		#if pft > 0:
		per_pft = (flt(pft) / flt(self.project_value)) * 100
		ret = {'gross_margin_value': pft, 'per_gross_margin': per_pft}
		return ret

	def validate(self):
		"""validate start date before end date"""
		if self.project_start_date and self.completion_date:
			if getdate(self.completion_date) < getdate(self.project_start_date):
				frappe.throw(_("Expected Completion Date can not be less than Project Start Date"))

	def on_update(self):
		self.add_calendar_event()

	def update_percent_complete(self):
		total = frappe.db.sql("""select count(*) from tabTask where project=%s""",
			self.name)[0][0]
		if total:
			completed = frappe.db.sql("""select count(*) from tabTask where
				project=%s and status in ('Closed', 'Cancelled')""", self.name)[0][0]
			frappe.db.set_value("Project", self.name, "percent_complete",
			 	int(float(completed) / total * 100))

	def add_calendar_event(self):
		# delete any earlier event for this project
		delete_events(self.doctype, self.name)

		# add events
		for milestone in self.get("project_milestones"):
			if milestone.milestone_date:
				description = (milestone.milestone or "Milestone") + " for " + self.name
				frappe.get_doc({
					"doctype": "Event",
					"owner": self.owner,
					"subject": description,
					"description": description,
					"starts_on": milestone.milestone_date + " 10:00:00",
					"event_type": "Private",
					"ref_type": self.doctype,
					"ref_name": self.name
				}).insert()

	def on_trash(self):
		delete_events(self.doctype, self.name)

########NEW FILE########
__FILENAME__ = test_project
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Project')
########NEW FILE########
__FILENAME__ = project_milestone
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ProjectMilestone(Document):
	pass
########NEW FILE########
__FILENAME__ = task
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe, json

from frappe.utils import getdate, today
from frappe import _


from frappe.model.document import Document

class Task(Document):
	def get_project_details(self):
		return {
			"project": self.project
		}

	def get_customer_details(self):
		cust = frappe.db.sql("select customer_name from `tabCustomer` where name=%s", self.customer)
		if cust:
			ret = {'customer_name': cust and cust[0][0] or ''}
			return ret

	def validate(self):
		if self.exp_start_date and self.exp_end_date and getdate(self.exp_start_date) > getdate(self.exp_end_date):
			frappe.throw(_("'Expected Start Date' can not be greater than 'Expected End Date'"))

		if self.act_start_date and self.act_end_date and getdate(self.act_start_date) > getdate(self.act_end_date):
			frappe.throw(_("'Actual Start Date' can not be greater than 'Actual End Date'"))

		self.update_status()

	def update_status(self):
		status = frappe.db.get_value("Task", self.name, "status")
		if self.status=="Working" and status !="Working" and not self.act_start_date:
			self.act_start_date = today()

		if self.status=="Closed" and status != "Closed" and not self.act_end_date:
			self.act_end_date = today()

	def on_update(self):
		"""update percent complete in project"""
		if self.project:
			project = frappe.get_doc("Project", self.project)
			project.run_method("update_percent_complete")

@frappe.whitelist()
def get_events(start, end, filters=None):
	from frappe.widgets.reportview import build_match_conditions
	if not frappe.has_permission("Task"):
		frappe.msgprint(_("No Permission"), raise_exception=1)

	conditions = build_match_conditions("Task")
	conditions and (" and " + conditions) or ""

	if filters:
		filters = json.loads(filters)
		for key in filters:
			if filters[key]:
				conditions += " and " + key + ' = "' + filters[key].replace('"', '\"') + '"'

	data = frappe.db.sql("""select name, exp_start_date, exp_end_date,
		subject, status, project from `tabTask`
		where ((exp_start_date between '%(start)s' and '%(end)s') \
			or (exp_end_date between '%(start)s' and '%(end)s'))
		%(conditions)s""" % {
			"start": start,
			"end": end,
			"conditions": conditions
		}, as_dict=True, update={"allDay": 0})

	return data

def get_project(doctype, txt, searchfield, start, page_len, filters):
	from erpnext.controllers.queries import get_match_cond
	return frappe.db.sql(""" select name from `tabProject`
			where %(key)s like "%(txt)s"
				%(mcond)s
			order by name
			limit %(start)s, %(page_len)s """ % {'key': searchfield,
			'txt': "%%%s%%" % txt, 'mcond':get_match_cond(doctype),
			'start': start, 'page_len': page_len})

########NEW FILE########
__FILENAME__ = test_task
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Task')

test_ignore = ["Customer"]
########NEW FILE########
__FILENAME__ = test_time_log
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

import frappe
import unittest

from erpnext.projects.doctype.time_log.time_log import OverlapError
from erpnext.projects.doctype.time_log_batch.test_time_log_batch import *

class TestTimeLog(unittest.TestCase):
	def test_duplication(self):
		frappe.db.sql("delete from `tabTime Log`")
		frappe.get_doc(frappe.copy_doc(test_records[0])).insert()

		ts = frappe.get_doc(frappe.copy_doc(test_records[0]))
		self.assertRaises(OverlapError, ts.insert)

		frappe.db.sql("delete from `tabTime Log`")

test_records = frappe.get_test_records('Time Log')
test_ignore = ["Time Log Batch", "Sales Invoice"]

########NEW FILE########
__FILENAME__ = time_log
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.utils import cstr, comma_and


class OverlapError(frappe.ValidationError): pass

from frappe.model.document import Document

class TimeLog(Document):

	def validate(self):
		self.set_status()
		self.validate_overlap()
		self.calculate_total_hours()

	def calculate_total_hours(self):
		from frappe.utils import time_diff_in_hours
		self.hours = time_diff_in_hours(self.to_time, self.from_time)

	def set_status(self):
		self.status = {
			0: "Draft",
			1: "Submitted",
			2: "Cancelled"
		}[self.docstatus or 0]

		if self.time_log_batch:
			self.status="Batched for Billing"

		if self.sales_invoice:
			self.status="Billed"

	def validate_overlap(self):
		existing = frappe.db.sql_list("""select name from `tabTime Log` where owner=%s and
			(
				(from_time between %s and %s) or
				(to_time between %s and %s) or
				(%s between from_time and to_time))
			and name!=%s
			and ifnull(task, "")=%s
			and docstatus < 2""",
			(self.owner, self.from_time, self.to_time, self.from_time,
				self.to_time, self.from_time, self.name or "No Name",
				cstr(self.task)))

		if existing:
			frappe.throw(_("This Time Log conflicts with {0}").format(comma_and(existing)), OverlapError)

	def before_cancel(self):
		self.set_status()

	def before_update_after_submit(self):
		self.set_status()

@frappe.whitelist()
def get_events(start, end):
	from frappe.widgets.reportview import build_match_conditions
	if not frappe.has_permission("Time Log"):
		frappe.msgprint(_("No Permission"), raise_exception=1)

	match = build_match_conditions("Time Log")
	data = frappe.db.sql("""select name, from_time, to_time,
		activity_type, task, project from `tabTime Log`
		where from_time between '%(start)s' and '%(end)s' or to_time between '%(start)s' and '%(end)s'
		%(match)s""" % {
			"start": start,
			"end": end,
			"match": match and (" and " + match) or ""
		}, as_dict=True, update={"allDay": 0})

	for d in data:
		d.title = d.name + ": " + (d.activity_type or "[Activity Type not set]")
		if d.task:
			d.title += " for Task: " + d.task
		if d.project:
			d.title += " for Project: " + d.project

	return data

########NEW FILE########
__FILENAME__ = test_time_log_batch
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

import frappe, unittest

class TimeLogBatchTest(unittest.TestCase):
	def test_time_log_status(self):
		delete_time_log_and_batch()
		time_log = create_time_log()

		self.assertEquals(frappe.db.get_value("Time Log", time_log, "status"), "Submitted")

		tlb = create_time_log_batch(time_log)

		self.assertEquals(frappe.db.get_value("Time Log", time_log, "status"), "Batched for Billing")
		tlb.cancel()
		self.assertEquals(frappe.db.get_value("Time Log", time_log, "status"), "Submitted")

		delete_time_log_and_batch()

def delete_time_log_and_batch():
	for name in frappe.db.sql_list("select name from `tabTime Log Batch` where docstatus=1"):
		frappe.get_doc("Time Log Batch", name).cancel()
		frappe.delete_doc("Time Log Batch", name)

	for name in frappe.db.sql_list("select name from `tabTime Log` where docstatus=1"):
		frappe.get_doc("Time Log", name).cancel()
		frappe.delete_doc("Time Log", name)

def create_time_log():
	from erpnext.projects.doctype.time_log.test_time_log import test_records as time_log_records
	time_log = frappe.copy_doc(time_log_records[0])
	time_log.update({
		"from_time": "2013-01-02 10:00:00.000000",
		"to_time": "2013-01-02 11:00:00.000000",
		"docstatus": 0
	})
	time_log.insert()
	time_log.submit()
	return time_log.name

def create_time_log_batch(time_log):
	tlb = frappe.get_doc({
		"doctype": "Time Log Batch",
		"rate": "500",
		"time_log_batch_details": [
			{
			"doctype": "Time Log Batch Detail",
			"parentfield": "time_log_batch_details",
			"parenttype": "Time Log Batch",
			"time_log": time_log
			}
		]
	})

	tlb.insert()
	tlb.submit()
	return tlb

test_ignore = ["Sales Invoice"]

########NEW FILE########
__FILENAME__ = time_log_batch
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe import _

from frappe.model.document import Document
from frappe.model.mapper import get_mapped_doc

class TimeLogBatch(Document):

	def validate(self):
		self.set_status()
		self.total_hours = 0.0
		for d in self.get("time_log_batch_details"):
			tl = frappe.get_doc("Time Log", d.time_log)
			self.update_time_log_values(d, tl)
			self.validate_time_log_is_submitted(tl)
			self.total_hours += float(tl.hours or 0.0)

	def update_time_log_values(self, d, tl):
		d.update({
			"hours": tl.hours,
			"activity_type": tl.activity_type,
			"created_by": tl.owner
		})

	def validate_time_log_is_submitted(self, tl):
		if tl.status != "Submitted" and self.docstatus == 0:
			frappe.throw(_("Time Log {0} must be 'Submitted'").format(tl.name))

	def set_status(self):
		self.status = {
			"0": "Draft",
			"1": "Submitted",
			"2": "Cancelled"
		}[str(self.docstatus or 0)]

		if self.sales_invoice:
			self.status = "Billed"

	def on_submit(self):
		self.update_status(self.name)

	def before_cancel(self):
		self.update_status(None)

	def before_update_after_submit(self):
		self.update_status(self.name)

	def update_status(self, time_log_batch):
		self.set_status()
		for d in self.get("time_log_batch_details"):
			tl = frappe.get_doc("Time Log", d.time_log)
			tl.time_log_batch = time_log_batch
			tl.sales_invoice = self.sales_invoice
			tl.ignore_validate_update_after_submit = True
			tl.save()

@frappe.whitelist()
def make_sales_invoice(source_name, target=None):
	def update_item(source_doc, target_doc, source_parent):
		target_doc.stock_uom = "Hour"
		target_doc.description = "via Time Logs"

	target = frappe.new_doc("Sales Invoice")
	target.append("entries", get_mapped_doc("Time Log Batch", source_name, {
		"Time Log Batch": {
			"doctype": "Sales Invoice Item",
			"field_map": {
				"rate": "base_rate",
				"name": "time_log_batch",
				"total_hours": "qty",
			},
			"postprocess": update_item
		}
	}))

	return target

########NEW FILE########
__FILENAME__ = time_log_batch_detail
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class TimeLogBatchDetail(Document):
	pass
########NEW FILE########
__FILENAME__ = daily_time_log_summary
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt

def execute(filters=None):
	if not filters:
		filters = {}
	elif filters.get("from_date") or filters.get("to_date"):
		filters["from_time"] = "00:00:00"
		filters["to_time"] = "24:00:00"

	columns = ["Time Log:Link/Time Log:120", "Employee::150", "From Datetime::140",
		"To Datetime::140", "Hours::70", "Activity Type::120", "Task:Link/Task:150",
		"Task Subject::180", "Project:Link/Project:120", "Status::70"]

	user_map = get_user_map()
	task_map = get_task_map()

	conditions = build_conditions(filters)
	time_logs = frappe.db.sql("""select * from `tabTime Log`
		where docstatus < 2 %s order by owner asc""" % (conditions, ), filters, as_dict=1)

	if time_logs:
		users = [time_logs[0].owner]

	data = []
	total_hours = total_employee_hours = count = 0
	for tl in time_logs:
		if tl.owner not in users:
			users.append(tl.owner)
			data.append(["", "", "", "Total", total_employee_hours, "", "", "", "", ""])
			total_employee_hours = 0

		data.append([tl.name, user_map[tl.owner], tl.from_time, tl.to_time, tl.hours,
				tl.activity_type, tl.task, task_map.get(tl.task), tl.project, tl.status])

		count += 1
		total_hours += flt(tl.hours)
		total_employee_hours += flt(tl.hours)

		if count == len(time_logs):
			data.append(["", "", "", "Total Hours", total_employee_hours, "", "", "", "", ""])

	if total_hours:
		data.append(["", "", "", "Grand Total", total_hours, "", "", "", "", ""])

	return columns, data

def get_user_map():
	users = frappe.db.sql("""select name,
		concat(first_name, if(last_name, (' ' + last_name), '')) as fullname
		from tabUser""", as_dict=1)
	user_map = {}
	for p in users:
		user_map.setdefault(p.name, []).append(p.fullname)

	return user_map

def get_task_map():
	tasks = frappe.db.sql("""select name, subject from tabTask""", as_dict=1)
	task_map = {}
	for t in tasks:
		task_map.setdefault(t.name, []).append(t.subject)

	return task_map

def build_conditions(filters):
	conditions = ""
	if filters.get("from_date"):
		conditions += " and from_time >= timestamp(%(from_date)s, %(from_time)s)"
	if filters.get("to_date"):
		conditions += " and to_time <= timestamp(%(to_date)s, %(to_time)s)"

	from frappe.widgets.reportview import build_match_conditions
	match_conditions = build_match_conditions("Time Log")
	if match_conditions:
		conditions += " and %s" % match_conditions

	return conditions

########NEW FILE########
__FILENAME__ = project_wise_stock_tracking
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

import frappe 

def execute(filters=None):
	columns = get_columns()
	proj_details = get_project_details()
	pr_item_map = get_purchased_items_cost()
	se_item_map = get_issued_items_cost()
	dn_item_map = get_delivered_items_cost()

	data = []
	for project in proj_details:
		data.append([project.name, pr_item_map.get(project.name, 0), 
			se_item_map.get(project.name, 0), dn_item_map.get(project.name, 0), 
			project.project_name, project.status, project.company, 
			project.customer, project.project_value, project.project_start_date, 
			project.completion_date])

	return columns, data 

def get_columns():
	return ["Project Id:Link/Project:140", "Cost of Purchased Items:Currency:160",
		"Cost of Issued Items:Currency:160", "Cost of Delivered Items:Currency:160", 
		"Project Name::120", "Project Status::120", "Company:Link/Company:100", 
		"Customer:Link/Customer:140", "Project Value:Currency:120", 
		"Project Start Date:Date:120", "Completion Date:Date:120"]

def get_project_details():
	return frappe.db.sql(""" select name, project_name, status, company, customer, project_value,
		project_start_date, completion_date from tabProject where docstatus < 2""", as_dict=1)

def get_purchased_items_cost():
	pr_items = frappe.db.sql("""select project_name, sum(base_amount) as amount
		from `tabPurchase Receipt Item` where ifnull(project_name, '') != '' 
		and docstatus = 1 group by project_name""", as_dict=1)

	pr_item_map = {}
	for item in pr_items:
		pr_item_map.setdefault(item.project_name, item.amount)

	return pr_item_map

def get_issued_items_cost():
	se_items = frappe.db.sql("""select se.project_name, sum(se_item.amount) as amount
		from `tabStock Entry` se, `tabStock Entry Detail` se_item
		where se.name = se_item.parent and se.docstatus = 1 and ifnull(se_item.t_warehouse, '') = '' 
		and ifnull(se.project_name, '') != '' group by se.project_name""", as_dict=1)

	se_item_map = {}
	for item in se_items:
		se_item_map.setdefault(item.project_name, item.amount)

	return se_item_map

def get_delivered_items_cost():
	dn_items = frappe.db.sql("""select dn.project_name, sum(dn_item.base_amount) as amount
		from `tabDelivery Note` dn, `tabDelivery Note Item` dn_item
		where dn.name = dn_item.parent and dn.docstatus = 1 and ifnull(dn.project_name, '') != ''
		group by dn.project_name""", as_dict=1)

	si_items = frappe.db.sql("""select si.project_name, sum(si_item.base_amount) as amount
		from `tabSales Invoice` si, `tabSales Invoice Item` si_item
		where si.name = si_item.parent and si.docstatus = 1 and ifnull(si.update_stock, 0) = 1 
		and ifnull(si.is_pos, 0) = 1 and ifnull(si.project_name, '') != ''
		group by si.project_name""", as_dict=1)


	dn_item_map = {}
	for item in dn_items:
		dn_item_map.setdefault(item.project_name, item.amount)

	for item in si_items:
		dn_item_map.setdefault(item.project_name, item.amount)

	return dn_item_map
########NEW FILE########
__FILENAME__ = utils
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

@frappe.whitelist()
def get_time_log_list(doctype, txt, searchfield, start, page_len, filters):
	return frappe.db.get_values("Time Log", filters, ["name", "activity_type", "owner"])

@frappe.whitelist()
def query_task(doctype, txt, searchfield, start, page_len, filters):
	from frappe.widgets.reportview import build_match_conditions
	
	search_string = "%%%s%%" % txt
	order_by_string = "%s%%" % txt
	match_conditions = build_match_conditions("Task")
	match_conditions = ("and" + match_conditions) if match_conditions else ""
	
	return frappe.db.sql("""select name, subject from `tabTask`
		where (`%s` like %s or `subject` like %s) %s
		order by
			case when `subject` like %s then 0 else 1 end,
			case when `%s` like %s then 0 else 1 end,
			`%s`,
			subject
		limit %s, %s""" % 
		(searchfield, "%s", "%s", match_conditions, "%s", 
			searchfield, "%s", searchfield, "%s", "%s"),
		(search_string, search_string, order_by_string, order_by_string, start, page_len))
########NEW FILE########
__FILENAME__ = campaign
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document
from frappe.model.naming import make_autoname

class Campaign(Document):
	def autoname(self):
		if frappe.defaults.get_global_default('campaign_naming_by') != 'Naming Series':
			self.name = self.campaign_name
		else:
			self.name = make_autoname(self.naming_series+'.#####')

########NEW FILE########
__FILENAME__ = test_campaign
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Campaign')
########NEW FILE########
__FILENAME__ = customer
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.model.naming import make_autoname
from frappe import msgprint, _
import frappe.defaults


from erpnext.utilities.transaction_base import TransactionBase
from erpnext.accounts.party import create_party_account

class Customer(TransactionBase):

	def autoname(self):
		cust_master_name = frappe.defaults.get_global_default('cust_master_name')
		if cust_master_name == 'Customer Name':
			if frappe.db.exists("Supplier", self.customer_name):
				msgprint(_("A Supplier exists with same name"), raise_exception=1)
			self.name = self.customer_name
		else:
			self.name = make_autoname(self.naming_series+'.#####')

	def get_company_abbr(self):
		return frappe.db.get_value('Company', self.company, 'abbr')

	def validate_values(self):
		if frappe.defaults.get_global_default('cust_master_name') == 'Naming Series' and not self.naming_series:
			frappe.throw(_("Series is mandatory"), frappe.MandatoryError)

	def validate(self):
		self.validate_values()

	def update_lead_status(self):
		if self.lead_name:
			frappe.db.sql("update `tabLead` set status='Converted' where name = %s", self.lead_name)

	def update_address(self):
		frappe.db.sql("""update `tabAddress` set customer_name=%s, modified=NOW()
			where customer=%s""", (self.customer_name, self.name))

	def update_contact(self):
		frappe.db.sql("""update `tabContact` set customer_name=%s, modified=NOW()
			where customer=%s""", (self.customer_name, self.name))

	def update_credit_days_limit(self):
		frappe.db.sql("""update tabAccount set credit_days = %s, credit_limit = %s
			where master_type='Customer' and master_name = %s""",
			(self.credit_days or 0, self.credit_limit or 0, self.name))

	def create_lead_address_contact(self):
		if self.lead_name:
			if not frappe.db.get_value("Address", {"lead": self.lead_name, "customer": self.name}):
				frappe.db.sql("""update `tabAddress` set customer=%s, customer_name=%s where lead=%s""",
					(self.name, self.customer_name, self.lead_name))

			lead = frappe.db.get_value("Lead", self.lead_name, ["lead_name", "email_id", "phone", "mobile_no"], as_dict=True)
			c = frappe.new_doc('Contact')
			c.first_name = lead.lead_name
			c.email_id = lead.email_id
			c.phone = lead.phone
			c.mobile_no = lead.mobile_no
			c.customer = self.name
			c.customer_name = self.customer_name
			c.is_primary_contact = 1
			try:
				c.save()
			except frappe.NameError:
				pass

	def on_update(self):
		self.validate_name_with_customer_group()

		self.update_lead_status()
		self.update_address()
		self.update_contact()

		# create account head
		create_party_account(self.name, "Customer", self.company)

		# update credit days and limit in account
		self.update_credit_days_limit()
		#create address and contact from lead
		self.create_lead_address_contact()

	def validate_name_with_customer_group(self):
		if frappe.db.exists("Customer Group", self.name):
			frappe.throw(_("A Customer Group exists with same name please change the Customer name or rename the Customer Group"))

	def delete_customer_address(self):
		addresses = frappe.db.sql("""select name, lead from `tabAddress`
			where customer=%s""", (self.name,))

		for name, lead in addresses:
			if lead:
				frappe.db.sql("""update `tabAddress` set customer=null, customer_name=null
					where name=%s""", name)
			else:
				frappe.db.sql("""delete from `tabAddress` where name=%s""", name)

	def delete_customer_contact(self):
		for contact in frappe.db.sql_list("""select name from `tabContact`
			where customer=%s""", self.name):
				frappe.delete_doc("Contact", contact)

	def delete_customer_account(self):
		"""delete customer's ledger if exist and check balance before deletion"""
		acc = frappe.db.sql("select name from `tabAccount` where master_type = 'Customer' \
			and master_name = %s and docstatus < 2", self.name)
		if acc:
			frappe.delete_doc('Account', acc[0][0])

	def on_trash(self):
		self.delete_customer_address()
		self.delete_customer_contact()
		self.delete_customer_account()
		if self.lead_name:
			frappe.db.sql("update `tabLead` set status='Interested' where name=%s",self.lead_name)

	def before_rename(self, olddn, newdn, merge=False):
		from erpnext.accounts.utils import rename_account_for
		rename_account_for("Customer", olddn, newdn, merge, self.company)

	def after_rename(self, olddn, newdn, merge=False):
		set_field = ''
		if frappe.defaults.get_global_default('cust_master_name') == 'Customer Name':
			frappe.db.set(self, "customer_name", newdn)
			self.update_contact()
			set_field = ", customer_name=%(newdn)s"
		self.update_customer_address(newdn, set_field)

	def update_customer_address(self, newdn, set_field):
		frappe.db.sql("""update `tabAddress` set address_title=%(newdn)s
			{set_field} where customer=%(newdn)s"""\
			.format(set_field=set_field), ({"newdn": newdn}))

@frappe.whitelist()
def get_dashboard_info(customer):
	if not frappe.has_permission("Customer", "read", customer):
		frappe.msgprint(_("Not permitted"), raise_exception=True)

	out = {}
	for doctype in ["Opportunity", "Quotation", "Sales Order", "Delivery Note", "Sales Invoice"]:
		out[doctype] = frappe.db.get_value(doctype,
			{"customer": customer, "docstatus": ["!=", 2] }, "count(*)")

	billing = frappe.db.sql("""select sum(grand_total), sum(outstanding_amount)
		from `tabSales Invoice`
		where customer=%s
			and docstatus = 1
			and fiscal_year = %s""", (customer, frappe.db.get_default("fiscal_year")))

	out["total_billing"] = billing[0][0]
	out["total_unpaid"] = billing[0][1]

	return out


def get_customer_list(doctype, txt, searchfield, start, page_len, filters):
	if frappe.db.get_default("cust_master_name") == "Customer Name":
		fields = ["name", "customer_group", "territory"]
	else:
		fields = ["name", "customer_name", "customer_group", "territory"]

	return frappe.db.sql("""select %s from `tabCustomer` where docstatus < 2
		and (%s like %s or customer_name like %s) order by
		case when name like %s then 0 else 1 end,
		case when customer_name like %s then 0 else 1 end,
		name, customer_name limit %s, %s""" %
		(", ".join(fields), searchfield, "%s", "%s", "%s", "%s", "%s", "%s"),
		("%%%s%%" % txt, "%%%s%%" % txt, "%%%s%%" % txt, "%%%s%%" % txt, start, page_len))

########NEW FILE########
__FILENAME__ = test_customer
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals

import frappe
import unittest

from frappe.test_runner import make_test_records

test_ignore = ["Price List"]
			
test_records = frappe.get_test_records('Customer')

class TestCustomer(unittest.TestCase):
	def test_party_details(self):
		from erpnext.accounts.party import get_party_details
		
		to_check = {
			'address_display': '_Test Address Line 1\n_Test City\nIndia\nPhone: +91 0000000000', 
			'selling_price_list': None, 
			'customer_group': '_Test Customer Group', 
			'contact_designation': None, 
			'customer_address': '_Test Address-Office', 
			'contact_department': None, 
			'contact_email': 'test_contact_customer@example.com', 
			'contact_mobile': None, 
			'sales_team': [], 
			'contact_display': '_Test Contact For _Test Customer', 
			'contact_person': '_Test Contact For _Test Customer-_Test Customer', 
			'territory': u'_Test Territory', 
			'contact_phone': '+91 0000000000', 
			'customer_name': '_Test Customer'
		}
		
		make_test_records("Address")
		make_test_records("Contact")
						
		details = get_party_details("_Test Customer")
		
		for key, value in to_check.iteritems():
			self.assertEquals(value, details.get(key))
		
	def test_rename(self):
		frappe.rename_doc("Customer", "_Test Customer 1", "_Test Customer 1 Renamed")

		self.assertTrue(frappe.db.exists("Customer", "_Test Customer 1 Renamed"))
		self.assertFalse(frappe.db.exists("Customer", "_Test Customer 1"))
		
		frappe.rename_doc("Customer", "_Test Customer 1 Renamed", "_Test Customer 1")
		


########NEW FILE########
__FILENAME__ = industry_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class IndustryType(Document):
	pass
########NEW FILE########
__FILENAME__ = test_industry_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Industry Type')
########NEW FILE########
__FILENAME__ = installation_note
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import cstr, getdate

from frappe import _
from erpnext.stock.utils import get_valid_serial_nos

from erpnext.utilities.transaction_base import TransactionBase

class InstallationNote(TransactionBase):
	tname = 'Installation Note Item'
	fname = 'installed_item_details'

	def __init__(self, arg1, arg2=None):
		super(InstallationNote, self).__init__(arg1, arg2)
		self.status_updater = [{
			'source_dt': 'Installation Note Item',
			'target_dt': 'Delivery Note Item',
			'target_field': 'installed_qty',
			'target_ref_field': 'qty',
			'join_field': 'prevdoc_detail_docname',
			'target_parent_dt': 'Delivery Note',
			'target_parent_field': 'per_installed',
			'source_field': 'qty',
			'percent_join_field': 'prevdoc_docname',
			'status_field': 'installation_status',
			'keyword': 'Installed'
		}]

	def validate(self):
		self.validate_fiscal_year()
		self.validate_installation_date()
		self.check_item_table()

		from erpnext.controllers.selling_controller import check_active_sales_items
		check_active_sales_items(self)

	def validate_fiscal_year(self):
		from erpnext.accounts.utils import validate_fiscal_year
		validate_fiscal_year(self.inst_date, self.fiscal_year, "Installation Date")

	def is_serial_no_added(self, item_code, serial_no):
		ar_required = frappe.db.get_value("Item", item_code, "has_serial_no")
		if ar_required == 'Yes' and not serial_no:
			frappe.throw(_("Serial No is mandatory for Item {0}").format(item_code))
		elif ar_required != 'Yes' and cstr(serial_no).strip():
			frappe.throw(_("Item {0} is not a serialized Item").format(item_code))

	def is_serial_no_exist(self, item_code, serial_no):
		for x in serial_no:
			if not frappe.db.exists("Serial No", x):
				frappe.throw(_("Serial No {0} does not exist").format(x))

	def is_serial_no_installed(self,cur_s_no,item_code):
		for x in cur_s_no:
			status = frappe.db.sql("select status from `tabSerial No` where name = %s", x)
			status = status and status[0][0] or ''

			if status == 'Installed':
				frappe.throw(_("Item {0} with Serial No {1} is already installed").format(item_code, x))

	def get_prevdoc_serial_no(self, prevdoc_detail_docname):
		serial_nos = frappe.db.get_value("Delivery Note Item",
			prevdoc_detail_docname, "serial_no")
		return get_valid_serial_nos(serial_nos)

	def is_serial_no_match(self, cur_s_no, prevdoc_s_no, prevdoc_docname):
		for sr in cur_s_no:
			if sr not in prevdoc_s_no:
				frappe.throw(_("Serial No {0} does not belong to Delivery Note {1}").format(sr, prevdoc_docname))

	def validate_serial_no(self):
		cur_s_no, prevdoc_s_no, sr_list = [], [], []
		for d in self.get('installed_item_details'):
			self.is_serial_no_added(d.item_code, d.serial_no)
			if d.serial_no:
				sr_list = get_valid_serial_nos(d.serial_no, d.qty, d.item_code)
				self.is_serial_no_exist(d.item_code, sr_list)

				prevdoc_s_no = self.get_prevdoc_serial_no(d.prevdoc_detail_docname)
				if prevdoc_s_no:
					self.is_serial_no_match(sr_list, prevdoc_s_no, d.prevdoc_docname)

				self.is_serial_no_installed(sr_list, d.item_code)

	def validate_installation_date(self):
		for d in self.get('installed_item_details'):
			if d.prevdoc_docname:
				d_date = frappe.db.get_value("Delivery Note", d.prevdoc_docname, "posting_date")
				if d_date > getdate(self.inst_date):
					frappe.throw(_("Installation date cannot be before delivery date for Item {0}").format(d.item_code))

	def check_item_table(self):
		if not(self.get('installed_item_details')):
			frappe.throw(_("Please pull items from Delivery Note"))

	def on_update(self):
		frappe.db.set(self, 'status', 'Draft')

	def on_submit(self):
		self.validate_serial_no()
		self.update_prevdoc_status()
		frappe.db.set(self, 'status', 'Submitted')

	def on_cancel(self):
		for d in self.get('installed_item_details'):
			if d.serial_no:
				d.serial_no = d.serial_no.replace(",", "\n")
				for sr_no in d.serial_no.split("\n"):
					frappe.db.set_value("Serial No", sr_no, "status", "Delivered")

		self.update_prevdoc_status()
		frappe.db.set(self, 'status', 'Cancelled')

########NEW FILE########
__FILENAME__ = installation_note_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class InstallationNoteItem(Document):
	pass
########NEW FILE########
__FILENAME__ = get_leads
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cstr, cint
from frappe.utils.email_lib.receive import POP3Mailbox
from frappe.core.doctype.communication.communication import _make

def add_sales_communication(subject, content, sender, real_name, mail=None, 
	status="Open", date=None):
	lead_name = frappe.db.get_value("Lead", {"email_id": sender})
	contact_name = frappe.db.get_value("Contact", {"email_id": sender})

	if not (lead_name or contact_name):
		# none, create a new Lead
		lead = frappe.get_doc({
			"doctype":"Lead",
			"lead_name": real_name or sender,
			"email_id": sender,
			"status": status,
			"source": "Email"
		})
		lead.ignore_permissions = True
		lead.ignore_mandatory = True
		lead.insert()
		lead_name = lead.name

	parent_doctype = "Contact" if contact_name else "Lead"
	parent_name = contact_name or lead_name

	message = _make(content=content, sender=sender, subject=subject,
		doctype = parent_doctype, name = parent_name, date=date, sent_or_received="Received")
	
	if mail:
		# save attachments to parent if from mail
		doc = frappe.get_doc(parent_doctype, parent_name)
		mail.save_attachments_in_doc(doc)

class SalesMailbox(POP3Mailbox):	
	def setup(self, args=None):
		self.settings = args or frappe.get_doc("Sales Email Settings", "Sales Email Settings")
		
	def process_message(self, mail):
		if mail.from_email == self.settings.email_id:
			return
		
		add_sales_communication(mail.subject, mail.content, mail.from_email, 
			mail.from_real_name, mail=mail, date=mail.date)

def get_leads():
	if cint(frappe.db.get_value('Sales Email Settings', None, 'extract_emails')):
		SalesMailbox()
########NEW FILE########
__FILENAME__ = lead
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.utils import cstr, validate_email_add, cint, comma_and
from frappe import session
from frappe.model.mapper import get_mapped_doc

from erpnext.controllers.selling_controller import SellingController

class Lead(SellingController):
	def onload(self):
		customer = frappe.db.get_value("Customer", {"lead_name": self.name})
		self.get("__onload").is_customer = customer

	def validate(self):
		self._prev = frappe._dict({
			"contact_date": frappe.db.get_value("Lead", self.name, "contact_date") if \
				(not cint(self.get("__islocal"))) else None,
			"contact_by": frappe.db.get_value("Lead", self.name, "contact_by") if \
				(not cint(self.get("__islocal"))) else None,
		})

		self.set_status()

		if self.source == 'Campaign' and not self.campaign_name and session['user'] != 'Guest':
			frappe.throw(_("Campaign Name is required"))

		if self.email_id:
			if not validate_email_add(self.email_id):
				frappe.throw(_('{0} is not a valid email id').format(self.email_id))

			if self.email_id == self.lead_owner:
				# Lead Owner cannot be same as the Lead
				self.lead_owner = None

	def on_update(self):
		self.check_email_id_is_unique()
		self.add_calendar_event()

	def add_calendar_event(self, opts=None, force=False):
		super(Lead, self).add_calendar_event({
			"owner": self.lead_owner,
			"subject": ('Contact ' + cstr(self.lead_name)),
			"description": ('Contact ' + cstr(self.lead_name)) + \
				(self.contact_by and ('. By : ' + cstr(self.contact_by)) or '')
		}, force)

	def check_email_id_is_unique(self):
		if self.email_id:
			# validate email is unique
			email_list = frappe.db.sql("""select name from tabLead where email_id=%s""",
				self.email_id)
			if len(email_list) > 1:
				items = [e[0] for e in email_list if e[0]!=self.name]
				frappe.throw(_("Email id must be unique, already exists for {0}").format(comma_and(items)))

	def on_trash(self):
		frappe.db.sql("""update `tabSupport Ticket` set lead='' where lead=%s""",
			self.name)

		self.delete_events()

	def has_customer(self):
		return frappe.db.get_value("Customer", {"lead_name": self.name})

	def has_opportunity(self):
		return frappe.db.get_value("Opportunity", {"lead": self.name, "docstatus": 1,
			"status": ["!=", "Lost"]})

@frappe.whitelist()
def make_customer(source_name, target_doc=None):
	return _make_customer(source_name, target_doc)

def _make_customer(source_name, target_doc=None, ignore_permissions=False):
	def set_missing_values(source, target):
		if source.company_name:
			target.customer_type = "Company"
			target.customer_name = source.company_name
		else:
			target.customer_type = "Individual"
			target.customer_name = source.lead_name

		target.customer_group = frappe.db.get_default("customer_group")

	doclist = get_mapped_doc("Lead", source_name,
		{"Lead": {
			"doctype": "Customer",
			"field_map": {
				"name": "lead_name",
				"company_name": "customer_name",
				"contact_no": "phone_1",
				"fax": "fax_1"
			}
		}}, target_doc, set_missing_values, ignore_permissions=ignore_permissions)

	return doclist

@frappe.whitelist()
def make_opportunity(source_name, target_doc=None):
	target_doc = get_mapped_doc("Lead", source_name,
		{"Lead": {
			"doctype": "Opportunity",
			"field_map": {
				"campaign_name": "campaign",
				"doctype": "enquiry_from",
				"name": "lead",
				"lead_name": "contact_display",
				"company_name": "customer_name",
				"email_id": "contact_email",
				"mobile_no": "contact_mobile"
			}
		}}, target_doc)

	return target_doc

@frappe.whitelist()
def get_lead_details(lead):
	if not lead: return {}

	from erpnext.accounts.party import set_address_details
	out = frappe._dict()

	lead_doc = frappe.get_doc("Lead", lead)
	lead = lead_doc

	out.update({
		"territory": lead.territory,
		"customer_name": lead.company_name or lead.lead_name,
		"contact_display": lead.lead_name,
		"contact_email": lead.email_id,
		"contact_mobile": lead.mobile_no,
		"contact_phone": lead.phone,
	})

	set_address_details(out, lead, "Lead")

	return out

########NEW FILE########
__FILENAME__ = test_lead
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals

import frappe
import unittest

test_records = frappe.get_test_records('Lead')

class TestLead(unittest.TestCase):
	def test_make_customer(self):
		from erpnext.selling.doctype.lead.lead import make_customer

		frappe.delete_doc_if_exists("Customer", "_Test Lead")

		customer = make_customer("_T-Lead-00001")
		self.assertEquals(customer.doctype, "Customer")
		self.assertEquals(customer.lead_name, "_T-Lead-00001")

		customer.company = "_Test Company"
		customer.customer_group = "_Test Customer Group"
		customer.insert()

########NEW FILE########
__FILENAME__ = opportunity
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cstr, cint
from frappe import msgprint, _
from frappe.model.mapper import get_mapped_doc

from erpnext.utilities.transaction_base import TransactionBase

class Opportunity(TransactionBase):
	fname = 'enq_details'
	tname = 'Opportunity Item'

	def get_item_details(self, item_code):
		item = frappe.db.sql("""select item_name, stock_uom, description_html, description, item_group, brand
			from `tabItem` where name = %s""", item_code, as_dict=1)
		ret = {
			'item_name': item and item[0]['item_name'] or '',
			'uom': item and item[0]['stock_uom'] or '',
			'description': item and item[0]['description_html'] or item[0]['description'] or '',
			'item_group': item and item[0]['item_group'] or '',
			'brand': item and item[0]['brand'] or ''
		}
		return ret

	def get_cust_address(self,name):
		details = frappe.db.sql("""select customer_name, address, territory, customer_group
			from `tabCustomer` where name = %s and docstatus != 2""", (name), as_dict = 1)
		if details:
			ret = {
				'customer_name':	details and details[0]['customer_name'] or '',
				'address'	:	details and details[0]['address'] or '',
				'territory'			 :	details and details[0]['territory'] or '',
				'customer_group'		:	details and details[0]['customer_group'] or ''
			}
			# ********** get primary contact details (this is done separately coz. , in case there is no primary contact thn it would not be able to fetch customer details in case of join query)

			contact_det = frappe.db.sql("""select contact_name, contact_no, email_id
				from `tabContact` where customer = %s and is_customer = 1
					and is_primary_contact = 'Yes' and docstatus != 2""", name, as_dict = 1)

			ret['contact_person'] = contact_det and contact_det[0]['contact_name'] or ''
			ret['contact_no']		 = contact_det and contact_det[0]['contact_no'] or ''
			ret['email_id']			 = contact_det and contact_det[0]['email_id'] or ''

			return ret
		else:
			frappe.throw(_("Customer {0} does not exist").format(name), frappe.DoesNotExistError)

	def on_update(self):
		self.add_calendar_event()

	def add_calendar_event(self, opts=None, force=False):
		if not opts:
			opts = frappe._dict()

		opts.description = ""

		if self.customer:
			if self.contact_person:
				opts.description = 'Contact '+cstr(self.contact_person)
			else:
				opts.description = 'Contact customer '+cstr(self.customer)
		elif self.lead:
			if self.contact_display:
				opts.description = 'Contact '+cstr(self.contact_display)
			else:
				opts.description = 'Contact lead '+cstr(self.lead)

		opts.subject = opts.description
		opts.description += '. By : ' + cstr(self.contact_by)

		if self.to_discuss:
			opts.description += ' To Discuss : ' + cstr(self.to_discuss)

		super(Opportunity, self).add_calendar_event(opts, force)

	def validate_item_details(self):
		if not self.get('enquiry_details'):
			frappe.throw(_("Items required"))

	def validate_lead_cust(self):
		if self.enquiry_from == 'Lead' and not self.lead:
			frappe.throw(_("Lead must be set if Opportunity is made from Lead"))
		elif self.enquiry_from == 'Customer' and not self.customer:
			msgprint("Customer is mandatory if 'Opportunity From' is selected as Customer", raise_exception=1)

	def validate(self):
		self._prev = frappe._dict({
			"contact_date": frappe.db.get_value("Opportunity", self.name, "contact_date") if \
				(not cint(self.get("__islocal"))) else None,
			"contact_by": frappe.db.get_value("Opportunity", self.name, "contact_by") if \
				(not cint(self.get("__islocal"))) else None,
		})

		self.set_status()
		self.validate_item_details()
		self.validate_uom_is_integer("uom", "qty")
		self.validate_lead_cust()

		from erpnext.accounts.utils import validate_fiscal_year
		validate_fiscal_year(self.transaction_date, self.fiscal_year, "Opportunity Date")

	def on_submit(self):
		if self.lead:
			frappe.get_doc("Lead", self.lead).set_status(update=True)

	def on_cancel(self):
		if self.has_quotation():
			frappe.throw(_("Cannot Cancel Opportunity as Quotation Exists"))
		self.set_status(update=True)

	def declare_enquiry_lost(self,arg):
		if not self.has_quotation():
			frappe.db.set(self, 'status', 'Lost')
			frappe.db.set(self, 'order_lost_reason', arg)
		else:
			frappe.throw(_("Cannot declare as lost, because Quotation has been made."))

	def on_trash(self):
		self.delete_events()

	def has_quotation(self):
		return frappe.db.get_value("Quotation Item", {"prevdoc_docname": self.name, "docstatus": 1})

@frappe.whitelist()
def make_quotation(source_name, target_doc=None):
	def set_missing_values(source, target):
		quotation = frappe.get_doc(target)
		quotation.run_method("set_missing_values")
		quotation.run_method("calculate_taxes_and_totals")

	doclist = get_mapped_doc("Opportunity", source_name, {
		"Opportunity": {
			"doctype": "Quotation",
			"field_map": {
				"enquiry_from": "quotation_to",
				"enquiry_type": "order_type",
				"name": "enq_no",
			},
			"validation": {
				"docstatus": ["=", 1]
			}
		},
		"Opportunity Item": {
			"doctype": "Quotation Item",
			"field_map": {
				"parent": "prevdoc_docname",
				"parenttype": "prevdoc_doctype",
				"uom": "stock_uom"
			},
			"add_if_empty": True
		}
	}, target_doc, set_missing_values)

	return doclist

########NEW FILE########
__FILENAME__ = opportunity_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class OpportunityItem(Document):
	pass
########NEW FILE########
__FILENAME__ = quotation
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cstr
from frappe.model.mapper import get_mapped_doc
from frappe import _

from erpnext.controllers.selling_controller import SellingController

class Quotation(SellingController):
	tname = 'Quotation Item'
	fname = 'quotation_details'

	def validate(self):
		super(Quotation, self).validate()
		self.set_status()
		self.validate_order_type()
		self.validate_for_items()
		self.validate_uom_is_integer("stock_uom", "qty")
		self.quotation_to = "Customer" if self.customer else "Lead"

	def has_sales_order(self):
		return frappe.db.get_value("Sales Order Item", {"prevdoc_docname": self.name, "docstatus": 1})

	def validate_for_items(self):
		chk_dupl_itm = []
		for d in self.get('quotation_details'):
			if [cstr(d.item_code),cstr(d.description)] in chk_dupl_itm:
				frappe.throw(_("Item {0} with same description entered twice").format(d.item_code))
			else:
				chk_dupl_itm.append([cstr(d.item_code),cstr(d.description)])

	def validate_order_type(self):
		super(Quotation, self).validate_order_type()

		if self.order_type in ['Maintenance', 'Service']:
			for d in self.get('quotation_details'):
				is_service_item = frappe.db.sql("select is_service_item from `tabItem` where name=%s", d.item_code)
				is_service_item = is_service_item and is_service_item[0][0] or 'No'

				if is_service_item == 'No':
					frappe.throw(_("Item {0} must be Service Item").format(d.item_code))
		else:
			for d in self.get('quotation_details'):
				is_sales_item = frappe.db.sql("select is_sales_item from `tabItem` where name=%s", d.item_code)
				is_sales_item = is_sales_item and is_sales_item[0][0] or 'No'

				if is_sales_item == 'No':
					frappe.throw(_("Item {0} must be Sales Item").format(d.item_code))

	def update_opportunity(self):
		for opportunity in list(set([d.prevdoc_docname for d in self.get("quotation_details")])):
			if opportunity:
				frappe.get_doc("Opportunity", opportunity).set_status(update=True)

	def declare_order_lost(self, arg):
		if not self.has_sales_order():
			frappe.db.set(self, 'status', 'Lost')
			frappe.db.set(self, 'order_lost_reason', arg)
			self.update_opportunity()
		else:
			frappe.throw(_("Cannot set as Lost as Sales Order is made."))

	def check_item_table(self):
		if not self.get('quotation_details'):
			frappe.throw(_("Please enter item details"))

	def on_submit(self):
		self.check_item_table()

		# Check for Approving Authority
		frappe.get_doc('Authorization Control').validate_approving_authority(self.doctype, self.company, self.grand_total, self)

		#update enquiry status
		self.update_opportunity()

	def on_cancel(self):
		#update enquiry status
		self.set_status()
		self.update_opportunity()

	def print_other_charges(self,docname):
		print_lst = []
		for d in self.get('other_charges'):
			lst1 = []
			lst1.append(d.description)
			lst1.append(d.total)
			print_lst.append(lst1)
		return print_lst


@frappe.whitelist()
def make_sales_order(source_name, target_doc=None):
	return _make_sales_order(source_name, target_doc)

def _make_sales_order(source_name, target_doc=None, ignore_permissions=False):
	customer = _make_customer(source_name, ignore_permissions)

	def set_missing_values(source, target):
		if customer:
			target.customer = customer.name
			target.customer_name = customer.customer_name

		target.ignore_permissions = ignore_permissions
		target.run_method("set_missing_values")
		target.run_method("calculate_taxes_and_totals")

	doclist = get_mapped_doc("Quotation", source_name, {
			"Quotation": {
				"doctype": "Sales Order",
				"validation": {
					"docstatus": ["=", 1]
				}
			},
			"Quotation Item": {
				"doctype": "Sales Order Item",
				"field_map": {
					"parent": "prevdoc_docname"
				}
			},
			"Sales Taxes and Charges": {
				"doctype": "Sales Taxes and Charges",
				"add_if_empty": True
			},
			"Sales Team": {
				"doctype": "Sales Team",
				"add_if_empty": True
			}
		}, target_doc, set_missing_values, ignore_permissions=ignore_permissions)

	# postprocess: fetch shipping address, set missing values

	return doclist

def _make_customer(source_name, ignore_permissions=False):
	quotation = frappe.db.get_value("Quotation", source_name, ["lead", "order_type"])
	if quotation and quotation[0]:
		lead_name = quotation[0]
		customer_name = frappe.db.get_value("Customer", {"lead_name": lead_name},
			["name", "customer_name"], as_dict=True)
		if not customer_name:
			from erpnext.selling.doctype.lead.lead import _make_customer
			customer_doclist = _make_customer(lead_name, ignore_permissions=ignore_permissions)
			customer = frappe.get_doc(customer_doclist)
			customer.ignore_permissions = ignore_permissions
			if quotation[1] == "Shopping Cart":
				customer.customer_group = frappe.db.get_value("Shopping Cart Settings", None,
					"default_customer_group")

			try:
				customer.insert()
				return customer
			except frappe.NameError:
				if frappe.defaults.get_global_default('cust_master_name') == "Customer Name":
					customer.run_method("autoname")
					customer.name += "-" + lead_name
					customer.insert()
					return customer
				else:
					raise
			except frappe.MandatoryError:
				from frappe.utils import get_url_to_form
				frappe.throw(_("Please create Customer from Lead {0}").format(lead_name))
		else:
			return customer_name

########NEW FILE########
__FILENAME__ = test_quotation
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

import frappe, json
from frappe.utils import flt
import unittest

test_dependencies = ["Sales BOM"]

class TestQuotation(unittest.TestCase):
	def test_make_sales_order(self):
		from erpnext.selling.doctype.quotation.quotation import make_sales_order

		quotation = frappe.copy_doc(test_records[0])
		quotation.insert()

		self.assertRaises(frappe.ValidationError, make_sales_order, quotation.name)

		quotation.submit()

		sales_order = make_sales_order(quotation.name)

		self.assertEquals(sales_order.doctype, "Sales Order")
		self.assertEquals(len(sales_order.get("sales_order_details")), 1)
		self.assertEquals(sales_order.get("sales_order_details")[0].doctype, "Sales Order Item")
		self.assertEquals(sales_order.get("sales_order_details")[0].prevdoc_docname, quotation.name)
		self.assertEquals(sales_order.customer, "_Test Customer")

		sales_order.delivery_date = "2014-01-01"
		sales_order.naming_series = "_T-Quotation-"
		sales_order.transaction_date = "2013-05-12"
		sales_order.insert()


test_records = frappe.get_test_records('Quotation')

########NEW FILE########
__FILENAME__ = quotation_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class QuotationItem(Document):
	pass
########NEW FILE########
__FILENAME__ = sales_bom
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe import _

from frappe.model.document import Document

class SalesBOM(Document):


	def autoname(self):
		self.name = self.new_item_code

	def validate(self):
		self.validate_main_item()

		from erpnext.utilities.transaction_base import validate_uom_is_integer
		validate_uom_is_integer(self, "uom", "qty")

	def validate_main_item(self):
		"""main item must have Is Stock Item as No and Is Sales Item as Yes"""
		if not frappe.db.sql("""select name from tabItem where name=%s and
			ifnull(is_stock_item,'')='No' and ifnull(is_sales_item,'')='Yes'""", self.new_item_code):
			frappe.throw(_("Parent Item {0} must be not Stock Item and must be a Sales Item").format(self.new_item_code))

	def get_item_details(self, name):
		det = frappe.db.sql("""select description, stock_uom from `tabItem`
			where name = %s""", name)
		return {
			'description' : det and det[0][0] or '',
			'uom': det and det[0][1] or ''
		}

def get_new_item_code(doctype, txt, searchfield, start, page_len, filters):
	from erpnext.controllers.queries import get_match_cond

	return frappe.db.sql("""select name, item_name, description from tabItem
		where is_stock_item="No" and is_sales_item="Yes"
		and name not in (select name from `tabSales BOM`) and %s like %s
		%s limit %s, %s""" % (searchfield, "%s",
		get_match_cond(doctype),"%s", "%s"),
		("%%%s%%" % txt, start, page_len))

########NEW FILE########
__FILENAME__ = test_sales_bom
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Sales Bom')
########NEW FILE########
__FILENAME__ = sales_bom_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SalesBOMItem(Document):
	pass
########NEW FILE########
__FILENAME__ = sales_order
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
import frappe.utils

from frappe.utils import cstr, flt, getdate, comma_and

from frappe import _
from frappe.model.mapper import get_mapped_doc

from erpnext.controllers.selling_controller import SellingController

class SalesOrder(SellingController):
	tname = 'Sales Order Item'
	fname = 'sales_order_details'
	person_tname = 'Target Detail'
	partner_tname = 'Partner Target Detail'
	territory_tname = 'Territory Target Detail'

	def validate_mandatory(self):
		# validate transaction date v/s delivery date
		if self.delivery_date:
			if getdate(self.transaction_date) > getdate(self.delivery_date):
				frappe.throw(_("Expected Delivery Date cannot be before Sales Order Date"))

	def validate_po(self):
		# validate p.o date v/s delivery date
		if self.po_date and self.delivery_date and getdate(self.po_date) > getdate(self.delivery_date):
			frappe.throw(_("Expected Delivery Date cannot be before Purchase Order Date"))

		if self.po_no and self.customer:
			so = frappe.db.sql("select name from `tabSales Order` \
				where ifnull(po_no, '') = %s and name != %s and docstatus < 2\
				and customer = %s", (self.po_no, self.name, self.customer))
			if so and so[0][0]:
				frappe.msgprint(_("Warning: Sales Order {0} already exists against same Purchase Order number").format(so[0][0]))

	def validate_for_items(self):
		check_list, flag = [], 0
		chk_dupl_itm = []
		for d in self.get('sales_order_details'):
			e = [d.item_code, d.description, d.warehouse, d.prevdoc_docname or '']
			f = [d.item_code, d.description]

			if frappe.db.get_value("Item", d.item_code, "is_stock_item") == 'Yes':
				if not d.warehouse:
					frappe.throw(_("Reserved warehouse required for stock item {0}").format(d.item_code))

				if e in check_list:
					frappe.throw(_("Item {0} has been entered twice").format(d.item_code))
				else:
					check_list.append(e)
			else:
				if f in chk_dupl_itm:
					frappe.throw(_("Item {0} has been entered twice").format(d.item_code))
				else:
					chk_dupl_itm.append(f)

			# used for production plan
			d.transaction_date = self.transaction_date

			tot_avail_qty = frappe.db.sql("select projected_qty from `tabBin` \
				where item_code = %s and warehouse = %s", (d.item_code,d.warehouse))
			d.projected_qty = tot_avail_qty and flt(tot_avail_qty[0][0]) or 0

	def validate_sales_mntc_quotation(self):
		for d in self.get('sales_order_details'):
			if d.prevdoc_docname:
				res = frappe.db.sql("select name from `tabQuotation` where name=%s and order_type = %s", (d.prevdoc_docname, self.order_type))
				if not res:
					frappe.msgprint(_("Quotation {0} not of type {1}").format(d.prevdoc_docname, self.order_type))

	def validate_order_type(self):
		super(SalesOrder, self).validate_order_type()

	def validate_delivery_date(self):
		if self.order_type == 'Sales' and not self.delivery_date:
			frappe.throw(_("Please enter 'Expected Delivery Date'"))

		self.validate_sales_mntc_quotation()

	def validate_proj_cust(self):
		if self.project_name and self.customer_name:
			res = frappe.db.sql("""select name from `tabProject` where name = %s
				and (customer = %s or ifnull(customer,'')='')""",
					(self.project_name, self.customer))
			if not res:
				frappe.throw(_("Customer {0} does not belong to project {1}").format(self.customer, self.project_name))

	def validate(self):
		super(SalesOrder, self).validate()

		self.validate_order_type()
		self.validate_delivery_date()
		self.validate_mandatory()
		self.validate_proj_cust()
		self.validate_po()
		self.validate_uom_is_integer("stock_uom", "qty")
		self.validate_for_items()
		self.validate_warehouse()

		from erpnext.stock.doctype.packed_item.packed_item import make_packing_list

		make_packing_list(self,'sales_order_details')

		self.validate_with_previous_doc()

		if not self.status:
			self.status = "Draft"

		from erpnext.utilities import validate_status
		validate_status(self.status, ["Draft", "Submitted", "Stopped",
			"Cancelled"])

		if not self.billing_status: self.billing_status = 'Not Billed'
		if not self.delivery_status: self.delivery_status = 'Not Delivered'

	def validate_warehouse(self):
		from erpnext.stock.utils import validate_warehouse_company

		warehouses = list(set([d.warehouse for d in
			self.get(self.fname) if d.warehouse]))

		for w in warehouses:
			validate_warehouse_company(w, self.company)

	def validate_with_previous_doc(self):
		super(SalesOrder, self).validate_with_previous_doc(self.tname, {
			"Quotation": {
				"ref_dn_field": "prevdoc_docname",
				"compare_fields": [["company", "="], ["currency", "="]]
			}
		})


	def update_enquiry_status(self, prevdoc, flag):
		enq = frappe.db.sql("select t2.prevdoc_docname from `tabQuotation` t1, `tabQuotation Item` t2 where t2.parent = t1.name and t1.name=%s", prevdoc)
		if enq:
			frappe.db.sql("update `tabOpportunity` set status = %s where name=%s",(flag,enq[0][0]))

	def update_prevdoc_status(self, flag):
		for quotation in list(set([d.prevdoc_docname for d in self.get(self.fname)])):
			if quotation:
				doc = frappe.get_doc("Quotation", quotation)
				if doc.docstatus==2:
					frappe.throw(_("Quotation {0} is cancelled").format(quotation))

				doc.set_status(update=True)

	def on_submit(self):
		self.update_stock_ledger(update_stock = 1)

		self.check_credit(self.grand_total)

		frappe.get_doc('Authorization Control').validate_approving_authority(self.doctype, self.grand_total, self)

		self.update_prevdoc_status('submit')
		frappe.db.set(self, 'status', 'Submitted')

	def on_cancel(self):
		# Cannot cancel stopped SO
		if self.status == 'Stopped':
			frappe.throw(_("Stopped order cannot be cancelled. Unstop to cancel."))

		self.check_nextdoc_docstatus()
		self.update_stock_ledger(update_stock = -1)

		self.update_prevdoc_status('cancel')

		frappe.db.set(self, 'status', 'Cancelled')

	def check_nextdoc_docstatus(self):
		# Checks Delivery Note
		submit_dn = frappe.db.sql_list("""select t1.name from `tabDelivery Note` t1,`tabDelivery Note Item` t2
			where t1.name = t2.parent and t2.against_sales_order = %s and t1.docstatus = 1""", self.name)
		if submit_dn:
			frappe.throw(_("Delivery Notes {0} must be cancelled before cancelling this Sales Order").format(comma_and(submit_dn)))

		# Checks Sales Invoice
		submit_rv = frappe.db.sql_list("""select t1.name
			from `tabSales Invoice` t1,`tabSales Invoice Item` t2
			where t1.name = t2.parent and t2.sales_order = %s and t1.docstatus = 1""",
			self.name)
		if submit_rv:
			frappe.throw(_("Sales Invoice {0} must be cancelled before cancelling this Sales Order").format(comma_and(submit_rv)))

		#check maintenance schedule
		submit_ms = frappe.db.sql_list("""select t1.name from `tabMaintenance Schedule` t1,
			`tabMaintenance Schedule Item` t2
			where t2.parent=t1.name and t2.prevdoc_docname = %s and t1.docstatus = 1""", self.name)
		if submit_ms:
			frappe.throw(_("Maintenance Schedule {0} must be cancelled before cancelling this Sales Order").format(comma_and(submit_ms)))

		# check maintenance visit
		submit_mv = frappe.db.sql_list("""select t1.name from `tabMaintenance Visit` t1, `tabMaintenance Visit Purpose` t2
			where t2.parent=t1.name and t2.prevdoc_docname = %s and t1.docstatus = 1""",self.name)
		if submit_mv:
			frappe.throw(_("Maintenance Visit {0} must be cancelled before cancelling this Sales Order").format(comma_and(submit_mv)))

		# check production order
		pro_order = frappe.db.sql_list("""select name from `tabProduction Order`
			where sales_order = %s and docstatus = 1""", self.name)
		if pro_order:
			frappe.throw(_("Production Order {0} must be cancelled before cancelling this Sales Order").format(comma_and(pro_order)))

	def check_modified_date(self):
		mod_db = frappe.db.get_value("Sales Order", self.name, "modified")
		date_diff = frappe.db.sql("select TIMEDIFF('%s', '%s')" %
			( mod_db, cstr(self.modified)))
		if date_diff and date_diff[0][0]:
			frappe.throw(_("{0} {1} has been modified. Please Refresh").format(self.doctype, self.name))

	def stop_sales_order(self):
		self.check_modified_date()
		self.update_stock_ledger(-1)
		frappe.db.set(self, 'status', 'Stopped')
		frappe.msgprint(_("{0} {1} status is Stopped").format(self.doctype, self.name))

	def unstop_sales_order(self):
		self.check_modified_date()
		self.update_stock_ledger(1)
		frappe.db.set(self, 'status', 'Submitted')
		frappe.msgprint(_("{0} {1} status is Unstopped").format(self.doctype, self.name))


	def update_stock_ledger(self, update_stock):
		from erpnext.stock.utils import update_bin
		for d in self.get_item_list():
			if frappe.db.get_value("Item", d['item_code'], "is_stock_item") == "Yes":
				args = {
					"item_code": d['item_code'],
					"warehouse": d['reserved_warehouse'],
					"reserved_qty": flt(update_stock) * flt(d['reserved_qty']),
					"posting_date": self.transaction_date,
					"voucher_type": self.doctype,
					"voucher_no": self.name,
					"is_amended": self.amended_from and 'Yes' or 'No'
				}
				update_bin(args)

	def on_update(self):
		pass

	def get_portal_page(self):
		return "order" if self.docstatus==1 else None

def set_missing_values(source, target):
	target.run_method("set_missing_values")
	target.run_method("calculate_taxes_and_totals")

@frappe.whitelist()
def make_material_request(source_name, target_doc=None):
	def postprocess(source, doc):
		doc.material_request_type = "Purchase"

	doc = get_mapped_doc("Sales Order", source_name, {
		"Sales Order": {
			"doctype": "Material Request",
			"validation": {
				"docstatus": ["=", 1]
			}
		},
		"Sales Order Item": {
			"doctype": "Material Request Item",
			"field_map": {
				"parent": "sales_order_no",
				"stock_uom": "uom"
			}
		}
	}, target_doc, postprocess)

	return doc

@frappe.whitelist()
def make_delivery_note(source_name, target_doc=None):
	def update_item(source, target, source_parent):
		target.base_amount = (flt(source.qty) - flt(source.delivered_qty)) * flt(source.base_rate)
		target.amount = (flt(source.qty) - flt(source.delivered_qty)) * flt(source.rate)
		target.qty = flt(source.qty) - flt(source.delivered_qty)

	doclist = get_mapped_doc("Sales Order", source_name, {
		"Sales Order": {
			"doctype": "Delivery Note",
			"field_map": {
				"shipping_address": "address_display",
				"shipping_address_name": "customer_address",
			},
			"validation": {
				"docstatus": ["=", 1]
			}
		},
		"Sales Order Item": {
			"doctype": "Delivery Note Item",
			"field_map": {
				"rate": "rate",
				"name": "prevdoc_detail_docname",
				"parent": "against_sales_order",
			},
			"postprocess": update_item,
			"condition": lambda doc: doc.delivered_qty < doc.qty
		},
		"Sales Taxes and Charges": {
			"doctype": "Sales Taxes and Charges",
			"add_if_empty": True
		},
		"Sales Team": {
			"doctype": "Sales Team",
			"add_if_empty": True
		}
	}, target_doc, set_missing_values)

	return doclist

@frappe.whitelist()
def make_sales_invoice(source_name, target_doc=None):
	def set_missing_values(source, target):
		target.is_pos = 0
		target.run_method("set_missing_values")
		target.run_method("calculate_taxes_and_totals")

	def update_item(source, target, source_parent):
		target.amount = flt(source.amount) - flt(source.billed_amt)
		target.base_amount = target.amount * flt(source_parent.conversion_rate)
		target.qty = source.rate and target.amount / flt(source.rate) or source.qty

	doclist = get_mapped_doc("Sales Order", source_name, {
		"Sales Order": {
			"doctype": "Sales Invoice",
			"validation": {
				"docstatus": ["=", 1]
			}
		},
		"Sales Order Item": {
			"doctype": "Sales Invoice Item",
			"field_map": {
				"name": "so_detail",
				"parent": "sales_order",
			},
			"postprocess": update_item,
			"condition": lambda doc: doc.base_amount==0 or doc.billed_amt < doc.amount
		},
		"Sales Taxes and Charges": {
			"doctype": "Sales Taxes and Charges",
			"add_if_empty": True
		},
		"Sales Team": {
			"doctype": "Sales Team",
			"add_if_empty": True
		}
	}, target_doc, set_missing_values)

	return doclist

@frappe.whitelist()
def make_maintenance_schedule(source_name, target_doc=None):
	maint_schedule = frappe.db.sql("""select t1.name
		from `tabMaintenance Schedule` t1, `tabMaintenance Schedule Item` t2
		where t2.parent=t1.name and t2.prevdoc_docname=%s and t1.docstatus=1""", source_name)

	if not maint_schedule:
		doclist = get_mapped_doc("Sales Order", source_name, {
			"Sales Order": {
				"doctype": "Maintenance Schedule",
				"field_map": {
					"name": "sales_order_no"
				},
				"validation": {
					"docstatus": ["=", 1]
				}
			},
			"Sales Order Item": {
				"doctype": "Maintenance Schedule Item",
				"field_map": {
					"parent": "prevdoc_docname"
				},
				"add_if_empty": True
			}
		}, target_doc)

		return doclist

@frappe.whitelist()
def make_maintenance_visit(source_name, target_doc=None):
	visit = frappe.db.sql("""select t1.name
		from `tabMaintenance Visit` t1, `tabMaintenance Visit Purpose` t2
		where t2.parent=t1.name and t2.prevdoc_docname=%s
		and t1.docstatus=1 and t1.completion_status='Fully Completed'""", source_name)

	if not visit:
		doclist = get_mapped_doc("Sales Order", source_name, {
			"Sales Order": {
				"doctype": "Maintenance Visit",
				"field_map": {
					"name": "sales_order_no"
				},
				"validation": {
					"docstatus": ["=", 1]
				}
			},
			"Sales Order Item": {
				"doctype": "Maintenance Visit Purpose",
				"field_map": {
					"parent": "prevdoc_docname",
					"parenttype": "prevdoc_doctype"
				},
				"add_if_empty": True
			}
		}, target_doc)

		return doclist

########NEW FILE########
__FILENAME__ = test_sales_order
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

import frappe
from frappe.utils import flt
import unittest
import copy

class TestSalesOrder(unittest.TestCase):
	def tearDown(self):
		frappe.set_user("Administrator")

	def test_make_material_request(self):
		from erpnext.selling.doctype.sales_order.sales_order import make_material_request

		so = frappe.copy_doc(test_records[0]).insert()

		self.assertRaises(frappe.ValidationError, make_material_request,
			so.name)

		sales_order = frappe.get_doc("Sales Order", so.name)
		sales_order.submit()
		mr = make_material_request(so.name)

		self.assertEquals(mr.material_request_type, "Purchase")
		self.assertEquals(len(mr.get("indent_details")), len(sales_order.get("sales_order_details")))

	def test_make_delivery_note(self):
		from erpnext.selling.doctype.sales_order.sales_order import make_delivery_note

		so = frappe.copy_doc(test_records[0]).insert()

		self.assertRaises(frappe.ValidationError, make_delivery_note,
			so.name)

		sales_order = frappe.get_doc("Sales Order", so.name)
		sales_order.submit()
		dn = make_delivery_note(so.name)

		self.assertEquals(dn.doctype, "Delivery Note")
		self.assertEquals(len(dn.get("delivery_note_details")), len(sales_order.get("sales_order_details")))

	def test_make_sales_invoice(self):
		from erpnext.selling.doctype.sales_order.sales_order import make_sales_invoice

		so = frappe.copy_doc(test_records[0]).insert()

		self.assertRaises(frappe.ValidationError, make_sales_invoice,
			so.name)

		sales_order = frappe.get_doc("Sales Order", so.name)
		sales_order.submit()
		si = make_sales_invoice(so.name)

		self.assertEquals(si.doctype, "Sales Invoice")
		self.assertEquals(len(si.get("entries")), len(sales_order.get("sales_order_details")))
		self.assertEquals(len(si.get("entries")), 1)

		si.posting_date = "2013-10-10"
		si.insert()
		si.submit()

		si1 = make_sales_invoice(so.name)
		self.assertEquals(len(si1.get("entries")), 0)


	def create_so(self, so_doc = None):
		if not so_doc:
			so_doc = test_records[0]

		w = frappe.copy_doc(so_doc)
		w.insert()
		w.submit()

		return w

	def create_dn_against_so(self, so, delivered_qty=0):
		from erpnext.stock.doctype.delivery_note.test_delivery_note import test_records as dn_test_records
		from erpnext.stock.doctype.delivery_note.test_delivery_note import _insert_purchase_receipt

		_insert_purchase_receipt(so.get("sales_order_details")[0].item_code)

		dn = frappe.get_doc(frappe.copy_doc(dn_test_records[0]))
		dn.get("delivery_note_details")[0].item_code = so.get("sales_order_details")[0].item_code
		dn.get("delivery_note_details")[0].against_sales_order = so.name
		dn.get("delivery_note_details")[0].prevdoc_detail_docname = so.get("sales_order_details")[0].name
		if delivered_qty:
			dn.get("delivery_note_details")[0].qty = delivered_qty
		dn.insert()
		dn.submit()
		return dn

	def get_bin_reserved_qty(self, item_code, warehouse):
		return flt(frappe.db.get_value("Bin", {"item_code": item_code, "warehouse": warehouse},
			"reserved_qty"))

	def delete_bin(self, item_code, warehouse):
		bin = frappe.db.exists({"doctype": "Bin", "item_code": item_code,
			"warehouse": warehouse})
		if bin:
			frappe.delete_doc("Bin", bin[0][0])

	def check_reserved_qty(self, item_code, warehouse, qty):
		bin_reserved_qty = self.get_bin_reserved_qty(item_code, warehouse)
		self.assertEqual(bin_reserved_qty, qty)

	def test_reserved_qty_for_so(self):
		# reset bin
		so_item = test_records[0]["sales_order_details"][0].copy()
		self.delete_bin(so_item["item_code"], so_item["warehouse"])

		# submit
		so = self.create_so()
		self.check_reserved_qty(so.get("sales_order_details")[0].item_code, so.get("sales_order_details")[0].warehouse, 10.0)

		# cancel
		so.cancel()
		self.check_reserved_qty(so.get("sales_order_details")[0].item_code, so.get("sales_order_details")[0].warehouse, 0.0)


	def test_reserved_qty_for_partial_delivery(self):
		# reset bin
		so_item = test_records[0]["sales_order_details"][0].copy()
		self.delete_bin(so_item["item_code"], so_item["warehouse"])

		# submit so
		so = self.create_so()

		# allow negative stock
		frappe.db.set_default("allow_negative_stock", 1)

		# submit dn
		dn = self.create_dn_against_so(so)

		self.check_reserved_qty(so.get("sales_order_details")[0].item_code, so.get("sales_order_details")[0].warehouse, 5.0)

		# stop so
		so.load_from_db()
		so.stop_sales_order()
		self.check_reserved_qty(so.get("sales_order_details")[0].item_code, so.get("sales_order_details")[0].warehouse, 0.0)

		# unstop so
		so.load_from_db()
		so.unstop_sales_order()
		self.check_reserved_qty(so.get("sales_order_details")[0].item_code, so.get("sales_order_details")[0].warehouse, 5.0)

		# cancel dn
		dn.cancel()
		self.check_reserved_qty(so.get("sales_order_details")[0].item_code, so.get("sales_order_details")[0].warehouse, 10.0)

	def test_reserved_qty_for_over_delivery(self):
		# reset bin
		so_item = test_records[0]["sales_order_details"][0].copy()
		self.delete_bin(so_item["item_code"], so_item["warehouse"])

		# submit so
		so = self.create_so()

		# allow negative stock
		frappe.db.set_default("allow_negative_stock", 1)

		# set over-delivery tolerance
		frappe.db.set_value('Item', so.get("sales_order_details")[0].item_code, 'tolerance', 50)

		# submit dn
		dn = self.create_dn_against_so(so, 15)
		self.check_reserved_qty(so.get("sales_order_details")[0].item_code, so.get("sales_order_details")[0].warehouse, 0.0)

		# cancel dn
		dn.cancel()
		self.check_reserved_qty(so.get("sales_order_details")[0].item_code, so.get("sales_order_details")[0].warehouse, 10.0)

	def test_reserved_qty_for_so_with_packing_list(self):
		from erpnext.selling.doctype.sales_bom.test_sales_bom import test_records as sbom_test_records

		# change item in test so record
		test_record = copy.deepcopy(test_records[0])
		test_record["sales_order_details"][0]["item_code"] = "_Test Sales BOM Item"

		# reset bin
		self.delete_bin(sbom_test_records[0]["sales_bom_items"][0]["item_code"], test_record.get("sales_order_details")[0]["warehouse"])
		self.delete_bin(sbom_test_records[0]["sales_bom_items"][1]["item_code"], test_record.get("sales_order_details")[0]["warehouse"])

		# submit
		so = self.create_so(test_record)


		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][0]["item_code"],
			so.get("sales_order_details")[0].warehouse, 50.0)
		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][1]["item_code"],
			so.get("sales_order_details")[0].warehouse, 20.0)

		# cancel
		so.cancel()
		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][0]["item_code"],
			so.get("sales_order_details")[0].warehouse, 0.0)
		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][1]["item_code"],
			so.get("sales_order_details")[0].warehouse, 0.0)

	def test_reserved_qty_for_partial_delivery_with_packing_list(self):
		from erpnext.selling.doctype.sales_bom.test_sales_bom import test_records as sbom_test_records

		# change item in test so record

		test_record = frappe.copy_doc(test_records[0])
		test_record.get("sales_order_details")[0].item_code = "_Test Sales BOM Item"

		# reset bin
		self.delete_bin(sbom_test_records[0]["sales_bom_items"][0]["item_code"], test_record.get("sales_order_details")[0].warehouse)
		self.delete_bin(sbom_test_records[0]["sales_bom_items"][1]["item_code"], test_record.get("sales_order_details")[0].warehouse)

		# submit
		so = self.create_so(test_record)

		# allow negative stock
		frappe.db.set_default("allow_negative_stock", 1)

		# submit dn
		dn = self.create_dn_against_so(so)

		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][0]["item_code"],
			so.get("sales_order_details")[0].warehouse, 25.0)
		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][1]["item_code"],
			so.get("sales_order_details")[0].warehouse, 10.0)

		# stop so
		so.load_from_db()
		so.stop_sales_order()

		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][0]["item_code"],
			so.get("sales_order_details")[0].warehouse, 0.0)
		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][1]["item_code"],
			so.get("sales_order_details")[0].warehouse, 0.0)

		# unstop so
		so.load_from_db()
		so.unstop_sales_order()
		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][0]["item_code"],
			so.get("sales_order_details")[0].warehouse, 25.0)
		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][1]["item_code"],
			so.get("sales_order_details")[0].warehouse, 10.0)

		# cancel dn
		dn.cancel()
		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][0]["item_code"],
			so.get("sales_order_details")[0].warehouse, 50.0)
		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][1]["item_code"],
			so.get("sales_order_details")[0].warehouse, 20.0)

	def test_reserved_qty_for_over_delivery_with_packing_list(self):
		from erpnext.selling.doctype.sales_bom.test_sales_bom import test_records as sbom_test_records

		# change item in test so record
		test_record = frappe.copy_doc(test_records[0])
		test_record.get("sales_order_details")[0].item_code = "_Test Sales BOM Item"

		# reset bin
		self.delete_bin(sbom_test_records[0]["sales_bom_items"][0]["item_code"], test_record.get("sales_order_details")[0].warehouse)
		self.delete_bin(sbom_test_records[0]["sales_bom_items"][1]["item_code"], test_record.get("sales_order_details")[0].warehouse)

		# submit
		so = self.create_so(test_record)

		# allow negative stock
		frappe.db.set_default("allow_negative_stock", 1)

		# set over-delivery tolerance
		frappe.db.set_value('Item', so.get("sales_order_details")[0].item_code, 'tolerance', 50)

		# submit dn
		dn = self.create_dn_against_so(so, 15)

		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][0]["item_code"],
			so.get("sales_order_details")[0].warehouse, 0.0)
		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][1]["item_code"],
			so.get("sales_order_details")[0].warehouse, 0.0)

		# cancel dn
		dn.cancel()
		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][0]["item_code"],
			so.get("sales_order_details")[0].warehouse, 50.0)
		self.check_reserved_qty(sbom_test_records[0]["sales_bom_items"][1]["item_code"],
			so.get("sales_order_details")[0].warehouse, 20.0)

	def test_warehouse_user(self):
		frappe.defaults.add_default("Warehouse", "_Test Warehouse 1 - _TC1", "test@example.com", "Restriction")
		frappe.get_doc("User", "test@example.com")\
			.add_roles("Sales User", "Sales Manager", "Material User", "Material Manager")

		frappe.get_doc("User", "test2@example.com")\
			.add_roles("Sales User", "Sales Manager", "Material User", "Material Manager")

		frappe.set_user("test@example.com")

		so = frappe.copy_doc(test_records[0])
		so.company = "_Test Company 1"
		so.conversion_rate = 0.02
		so.plc_conversion_rate = 0.02
		so.get("sales_order_details")[0].warehouse = "_Test Warehouse 2 - _TC1"
		self.assertRaises(frappe.PermissionError, so.insert)

		frappe.set_user("test2@example.com")
		so.insert()

		frappe.defaults.clear_default("Warehouse", "_Test Warehouse 1 - _TC1", "test@example.com", parenttype="Restriction")

test_dependencies = ["Sales BOM", "Currency Exchange"]

test_records = frappe.get_test_records('Sales Order')

########NEW FILE########
__FILENAME__ = sales_order_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SalesOrderItem(Document):
	pass
########NEW FILE########
__FILENAME__ = sales_team
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SalesTeam(Document):
	pass
########NEW FILE########
__FILENAME__ = selling_settings
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SellingSettings(Document):

	def validate(self):
		for key in ["cust_master_name", "campaign_naming_by", "customer_group", "territory",
			"maintain_same_sales_rate", "editable_price_list_rate", "selling_price_list"]:
				frappe.db.set_default(key, self.get(key, ""))

		from erpnext.setup.doctype.naming_series.naming_series import set_by_naming_series
		set_by_naming_series("Customer", "customer_name",
			self.get("cust_master_name")=="Naming Series", hide_name_field=False)

########NEW FILE########
__FILENAME__ = sms_center
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import cstr
from frappe import msgprint, _

from frappe.model.document import Document

class SMSCenter(Document):

	def create_receiver_list(self):
		rec, where_clause = '', ''
		if self.send_to == 'All Customer Contact':
			where_clause = self.customer and " and customer = '%s'" % \
				self.customer.replace("'", "\'") or " and ifnull(customer, '') != ''"
		if self.send_to == 'All Supplier Contact':
			where_clause = self.supplier and \
				" and ifnull(is_supplier, 0) = 1 and supplier = '%s'" % \
				self.supplier.replace("'", "\'") or " and ifnull(supplier, '') != ''"
		if self.send_to == 'All Sales Partner Contact':
			where_clause = self.sales_partner and \
				" and ifnull(is_sales_partner, 0) = 1 and sales_partner = '%s'" % \
				self.sales_partner.replace("'", "\'") or " and ifnull(sales_partner, '') != ''"

		if self.send_to in ['All Contact', 'All Customer Contact', 'All Supplier Contact', 'All Sales Partner Contact']:
			rec = frappe.db.sql("""select CONCAT(ifnull(first_name,''), '', ifnull(last_name,'')), 
				mobile_no from `tabContact` where ifnull(mobile_no,'')!='' and 
				docstatus != 2 %s""", where_clause)
		
		elif self.send_to == 'All Lead (Open)':
			rec = frappe.db.sql("""select lead_name, mobile_no from `tabLead` where 
				ifnull(mobile_no,'')!='' and docstatus != 2 and status='Open'""")
		
		elif self.send_to == 'All Employee (Active)':
			where_clause = self.department and " and department = '%s'" % \
				self.department.replace("'", "\'") or ""
			where_clause += self.branch and " and branch = '%s'" % \
				self.branch.replace("'", "\'") or ""
				
			rec = frappe.db.sql("""select employee_name, cell_number from 
				`tabEmployee` where status = 'Active' and docstatus < 2 and 
				ifnull(cell_number,'')!='' %s""", where_clause)
		
		elif self.send_to == 'All Sales Person':
			rec = frappe.db.sql("""select sales_person_name, mobile_no from 
				`tabSales Person` where docstatus!=2 and ifnull(mobile_no,'')!=''""")
			rec_list = ''
		
		for d in rec:
			rec_list += d[0] + ' - ' + d[1] + '\n'
			self.receiver_list = rec_list

	def get_receiver_nos(self):
		receiver_nos = []
		if self.receiver_list:
			for d in self.receiver_list.split('\n'):
				receiver_no = d
				if '-' in d:
					receiver_no = receiver_no.split('-')[1]
				if receiver_no.strip():
					receiver_nos.append(cstr(receiver_no).strip())
		else:
			msgprint(_("Receiver List is empty. Please create Receiver List"))
		
		return receiver_nos

	def send_sms(self):
		if not self.message:
			msgprint(_("Please enter message before sending"))
		else:
			receiver_list = self.get_receiver_nos()
		if receiver_list:
			msgprint(frappe.get_doc('SMS Control', 'SMS Control').send_sms(receiver_list, cstr(self.message)))
########NEW FILE########
__FILENAME__ = sales_browser
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe


@frappe.whitelist()
def get_children():
	ctype = frappe.local.form_dict.get('ctype')
	frappe.local.form_dict['parent_field'] = 'parent_' + ctype.lower().replace(' ', '_')
	if not frappe.form_dict.get('parent'):
		frappe.local.form_dict['parent'] = ''

	return frappe.db.sql("""select name as value,
		if(is_group='Yes', 1, 0) as expandable
		from `tab%(ctype)s`
		where docstatus < 2
		and ifnull(%(parent_field)s,'') = "%(parent)s"
		order by name""" % frappe.local.form_dict, as_dict=1)

@frappe.whitelist()
def add_node():
	ctype = frappe.form_dict.get('ctype')
	parent_field = 'parent_' + ctype.lower().replace(' ', '_')
	name_field = ctype.lower().replace(' ', '_') + '_name'

	doc = frappe.new_doc(ctype)
	doc.update({
		name_field: frappe.form_dict['name_field'],
		parent_field: frappe.form_dict['parent'],
		"is_group": frappe.form_dict['is_group']
	})
	if ctype == "Sales Person":
		doc.employee = frappe.form_dict.get('employee')

	doc.save()

########NEW FILE########
__FILENAME__ = sales_funnel
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

@frappe.whitelist()
def get_funnel_data(from_date, to_date):
	active_leads = frappe.db.sql("""select count(*) from `tabLead`
		where (date(`modified`) between %s and %s)
		and status != "Do Not Contact" """, (from_date, to_date))[0][0]

	active_leads += frappe.db.sql("""select count(distinct customer) from `tabContact`
		where (date(`modified`) between %s and %s)
		and status != "Passive" """, (from_date, to_date))[0][0]

	opportunities = frappe.db.sql("""select count(*) from `tabOpportunity`
		where docstatus = 1 and (date(`creation`) between %s and %s)
		and status != "Lost" """, (from_date, to_date))[0][0]

	quotations = frappe.db.sql("""select count(*) from `tabQuotation`
		where docstatus = 1 and (date(`creation`) between %s and %s)
		and status != "Lost" """, (from_date, to_date))[0][0]

	sales_orders = frappe.db.sql("""select count(*) from `tabSales Order`
		where docstatus = 1 and (date(`creation`) between %s and %s)""", (from_date, to_date))[0][0]

	return [
		{ "title": "Active Leads / Customers", "value": active_leads, "color": "#B03B46" },
		{ "title": "Opportunities", "value": opportunities, "color": "#F09C00" },
		{ "title": "Quotations", "value": quotations, "color": "#006685" },
		{ "title": "Sales Orders", "value": sales_orders, "color": "#00AD65" }
	]

########NEW FILE########
__FILENAME__ = available_stock_for_packing_items
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt

def execute(filters=None):
	if not filters: filters = {}
	
	columns = get_columns()
	iwq_map = get_item_warehouse_quantity_map()
	item_map = get_item_details()

	data = []	
	for sbom, warehouse in iwq_map.items():
		total = 0
		total_qty = 0
		
		for wh, item_qty in warehouse.items():
			total += 1
			row = [sbom, item_map.get(sbom).item_name, item_map.get(sbom).description, 
				item_map.get(sbom).stock_uom, wh]
			available_qty = min(item_qty.values())
			total_qty += flt(available_qty)
			row += [available_qty]
			
			if available_qty:
				data.append(row)
				if (total == len(warehouse)):
					row = ["", "", "Total", "", "", total_qty]
					data.append(row)

	return columns, data
	
def get_columns():
	columns = ["Item Code:Link/Item:100", "Item Name::100", "Description::120", \
			"UOM:Link/UOM:80", "Warehouse:Link/Warehouse:100", "Quantity::100"]

	return columns

def get_sales_bom_items():
	sbom_item_map = {}
	for sbom in frappe.db.sql("""select parent, item_code, qty from `tabSales BOM Item` 
		where docstatus < 2""", as_dict=1):
			sbom_item_map.setdefault(sbom.parent, {}).setdefault(sbom.item_code, sbom.qty)
			
	return sbom_item_map

def get_item_details():
	item_map = {}
	for item in frappe.db.sql("""select name, item_name, description, stock_uom 
		from `tabItem`""", as_dict=1):
			item_map.setdefault(item.name, item)
			
	return item_map

def get_item_warehouse_quantity():
	iwq_map = {}
	bin = frappe.db.sql("""select item_code, warehouse, actual_qty from `tabBin` 
		where actual_qty > 0""")
	for item, wh, qty in bin:
		iwq_map.setdefault(item, {}).setdefault(wh, qty)
		
	return iwq_map

def get_item_warehouse_quantity_map():
	sbom_map = {}
	iwq_map = get_item_warehouse_quantity()
	sbom_item_map = get_sales_bom_items()
	
	for sbom, sbom_items in sbom_item_map.items():
		for item, child_qty in sbom_items.items():
			for wh, qty in iwq_map.get(item, {}).items():
				avail_qty = flt(qty) / flt(child_qty)
				sbom_map.setdefault(sbom, {}).setdefault(wh, {}) \
					.setdefault(item, avail_qty)

	return sbom_map
########NEW FILE########
__FILENAME__ = customers_not_buying_since_long_time
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cint
from frappe import _

def execute(filters=None):
	if not filters: filters ={}

	days_since_last_order = filters.get("days_since_last_order")
	if cint(days_since_last_order) <= 0:
		frappe.throw(_("'Days Since Last Order' must be greater than or equal to zero"))

	columns = get_columns()
	customers = get_so_details()

	data = []
	for cust in customers:
		if cint(cust[8]) >= cint(days_since_last_order):
			cust.insert(7,get_last_so_amt(cust[0]))
			data.append(cust)
	return columns, data

def get_so_details():
	return frappe.db.sql("""select
			cust.name,
			cust.customer_name,
			cust.territory,
			cust.customer_group,
			count(distinct(so.name)) as 'num_of_order',
			sum(net_total) as 'total_order_value',
			sum(if(so.status = "Stopped",
				so.net_total * so.per_delivered/100,
				so.net_total)) as 'total_order_considered',
			max(so.transaction_date) as 'last_sales_order_date',
			DATEDIFF(CURDATE(), max(so.transaction_date)) as 'days_since_last_order'
		from `tabCustomer` cust, `tabSales Order` so
		where cust.name = so.customer and so.docstatus = 1
		group by cust.name
		order by 'days_since_last_order' desc """,as_list=1)

def get_last_so_amt(customer):
	res =  frappe.db.sql("""select net_total from `tabSales Order`
		where customer ='%(customer)s' and docstatus = 1 order by transaction_date desc
		limit 1""" % {'customer':customer})

	return res and res[0][0] or 0

def get_columns():
	return [
		"Customer:Link/Customer:120",
		"Customer Name:Data:120",
		"Territory::120",
		"Customer Group::120",
		"Number of Order::120",
		"Total Order Value:Currency:120",
		"Total Order Considered:Currency:160",
		"Last Order Amount:Currency:160",
		"Last Sales Order Date:Date:160",
		"Days Since Last Order::160"
	]

########NEW FILE########
__FILENAME__ = customer_acquisition_and_loyalty
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import getdate, cint
import calendar

def execute(filters=None):
	# key yyyy-mm
	new_customers_in = {}
	repeat_customers_in = {}
	customers = []
	company_condition = ""

	if filters.get("company"):
		company_condition = ' and company=%(company)s'

	for si in frappe.db.sql("""select posting_date, customer, grand_total from `tabSales Invoice`
		where docstatus=1 and posting_date <= %(to_date)s 
		{company_condition} order by posting_date""".format(company_condition=company_condition), 
		filters, as_dict=1):
				
		key = si.posting_date[:7]
		if not si.customer in customers:
			new_customers_in.setdefault(key, [0, 0.0])
			new_customers_in[key][0] += 1
			new_customers_in[key][1] += si.grand_total
			customers.append(si.customer)
		else:
			repeat_customers_in.setdefault(key, [0, 0.0])
			repeat_customers_in[key][0] += 1
			repeat_customers_in[key][1] += si.grand_total
			
	# time series
	from_year, from_month, temp = filters.get("from_date").split("-")
	to_year, to_month, temp = filters.get("to_date").split("-")
	
	from_year, from_month, to_year, to_month = \
		cint(from_year), cint(from_month), cint(to_year), cint(to_month)
	
	out = []
	for year in xrange(from_year, to_year+1):
		for month in xrange(from_month if year==from_year else 1, (to_month+1) if year==to_year else 13):
			key = "{year}-{month:02d}".format(year=year, month=month)

			new = new_customers_in.get(key, [0,0.0])
			repeat = repeat_customers_in.get(key, [0,0.0])

			out.append([year, calendar.month_name[month], 
				new[0], repeat[0], new[0] + repeat[0],
				new[1], repeat[1], new[1] + repeat[1]])
					
	return [
		"Year", "Month", 
		"New Customers:Int", 
		"Repeat Customers:Int", 
		"Total:Int",
		"New Customer Revenue:Currency:150", 
		"Repeat Customer Revenue:Currency:150", 
		"Total Revenue:Currency:150"
	], out
		
		
		
########NEW FILE########
__FILENAME__ = quotation_trends
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from erpnext.controllers.trends	import get_columns, get_data

def execute(filters=None):
	if not filters: filters ={}
	data = []
	conditions = get_columns(filters, "Quotation")
	data = get_data(filters, conditions)

	return conditions["columns"], data 
########NEW FILE########
__FILENAME__ = sales_order_trends
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from erpnext.controllers.trends	import get_columns,get_data

def execute(filters=None):
	if not filters: filters ={}
	data = []
	conditions = get_columns(filters, "Sales Order")
	data = get_data(filters, conditions)
	
	return conditions["columns"], data 
########NEW FILE########
__FILENAME__ = sales_person_target_variance_item_group_wise
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _, msgprint
from frappe.utils import flt
from erpnext.accounts.utils import get_fiscal_year
from erpnext.controllers.trends import get_period_date_ranges, get_period_month_ranges

def execute(filters=None):
	if not filters: filters = {}

	columns = get_columns(filters)
	period_month_ranges = get_period_month_ranges(filters["period"], filters["fiscal_year"])
	sim_map = get_salesperson_item_month_map(filters)

	data = []
	for salesperson, salesperson_items in sim_map.items():
		for item_group, monthwise_data in salesperson_items.items():
			row = [salesperson, item_group]
			totals = [0, 0, 0]
			for relevant_months in period_month_ranges:
				period_data = [0, 0, 0]
				for month in relevant_months:
					month_data = monthwise_data.get(month, {})
					for i, fieldname in enumerate(["target", "achieved", "variance"]):
						value = flt(month_data.get(fieldname))
						period_data[i] += value
						totals[i] += value
				period_data[2] = period_data[0] - period_data[1]
				row += period_data
			totals[2] = totals[0] - totals[1]
			row += totals
			data.append(row)

	return columns, sorted(data, key=lambda x: (x[0], x[1]))

def get_columns(filters):
	for fieldname in ["fiscal_year", "period", "target_on"]:
		if not filters.get(fieldname):
			label = (" ".join(fieldname.split("_"))).title()
			msgprint(_("Please specify") + ": " + label,
				raise_exception=True)

	columns = ["Sales Person:Link/Sales Person:120", "Item Group:Link/Item Group:120"]

	group_months = False if filters["period"] == "Monthly" else True

	for from_date, to_date in get_period_date_ranges(filters["period"], filters["fiscal_year"]):
		for label in ["Target (%s)", "Achieved (%s)", "Variance (%s)"]:
			if group_months:
				label = label % (from_date.strftime("%b") + " - " + to_date.strftime("%b"))
			else:
				label = label % from_date.strftime("%b")

			columns.append(label+":Float:120")

	return columns + ["Total Target:Float:120", "Total Achieved:Float:120",
		"Total Variance:Float:120"]

#Get sales person & item group details
def get_salesperson_details(filters):
	return frappe.db.sql("""select sp.name, td.item_group, td.target_qty,
		td.target_amount, sp.distribution_id
		from `tabSales Person` sp, `tabTarget Detail` td
		where td.parent=sp.name and td.fiscal_year=%s order by sp.name""",
		(filters["fiscal_year"]), as_dict=1)

#Get target distribution details of item group
def get_target_distribution_details(filters):
	target_details = {}

	for d in frappe.db.sql("""select bd.name, bdd.month, bdd.percentage_allocation
		from `tabBudget Distribution Detail` bdd, `tabBudget Distribution` bd
		where bdd.parent=bd.name and bd.fiscal_year=%s""", (filters["fiscal_year"]), as_dict=1):
			target_details.setdefault(d.name, {}).setdefault(d.month, flt(d.percentage_allocation))

	return target_details

#Get achieved details from sales order
def get_achieved_details(filters):
	start_date, end_date = get_fiscal_year(fiscal_year = filters["fiscal_year"])[1:]

	item_details = frappe.db.sql("""select soi.item_code, soi.qty, soi.base_amount, so.transaction_date,
		st.sales_person, MONTHNAME(so.transaction_date) as month_name
		from `tabSales Order Item` soi, `tabSales Order` so, `tabSales Team` st
		where soi.parent=so.name and so.docstatus=1 and
		st.parent=so.name and so.transaction_date>=%s and
		so.transaction_date<=%s""" % ('%s', '%s'),
		(start_date, end_date), as_dict=1)

	item_actual_details = {}
	for d in item_details:
		item_actual_details.setdefault(d.sales_person, {}).setdefault(\
			get_item_group(d.item_code), []).append(d)

	return item_actual_details

def get_salesperson_item_month_map(filters):
	import datetime
	salesperson_details = get_salesperson_details(filters)
	tdd = get_target_distribution_details(filters)
	achieved_details = get_achieved_details(filters)

	sim_map = {}
	for sd in salesperson_details:
		for month_id in range(1, 13):
			month = datetime.date(2013, month_id, 1).strftime('%B')
			sim_map.setdefault(sd.name, {}).setdefault(sd.item_group, {})\
				.setdefault(month, frappe._dict({
					"target": 0.0, "achieved": 0.0
				}))

			tav_dict = sim_map[sd.name][sd.item_group][month]
			month_percentage = tdd.get(sd.distribution_id, {}).get(month, 0) \
				if sd.distribution_id else 100.0/12

			for ad in achieved_details.get(sd.name, {}).get(sd.item_group, []):
				if (filters["target_on"] == "Quantity"):
					tav_dict.target = flt(sd.target_qty) * month_percentage / 100
					if ad.month_name == month:
							tav_dict.achieved += ad.qty

				if (filters["target_on"] == "Amount"):
					tav_dict.target = flt(sd.target_amount) * month_percentage / 100
					if ad.month_name == month:
							tav_dict.achieved += ad.base_amount

	return sim_map

def get_item_group(item_name):
	return frappe.db.get_value("Item", item_name, "item_group")

########NEW FILE########
__FILENAME__ = sales_person_wise_transaction_summary
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import msgprint, _

def execute(filters=None):
	if not filters: filters = {}
	
	columns = get_columns(filters)
	data = get_entries(filters)
	
	return columns, data
	
def get_columns(filters):
	if not filters.get("doc_type"):
		msgprint(_("Please select the document type first"), raise_exception=1)
		
	return [filters["doc_type"] + ":Link/" + filters["doc_type"] + ":140", 
		"Customer:Link/Customer:140", "Territory:Link/Territory:100", "Posting Date:Date:100", 
		"Item Code:Link/Item:120", "Qty:Float:100", "Amount:Currency:120", 
		"Sales Person:Link/Sales Person:140", "Contribution %:Float:110", 
		"Contribution Amount:Currency:140"]
	
def get_entries(filters):
	date_field = filters["doc_type"] == "Sales Order" and "transaction_date" or "posting_date"
	conditions, items = get_conditions(filters, date_field)
	entries = frappe.db.sql("""select dt.name, dt.customer, dt.territory, dt.%s, 
		dt_item.item_code, dt_item.qty, dt_item.base_amount, st.sales_person, 
		st.allocated_percentage, dt_item.base_amount*st.allocated_percentage/100
		from `tab%s` dt, `tab%s Item` dt_item, `tabSales Team` st 
		where st.parent = dt.name and dt.name = dt_item.parent and st.parenttype = %s 
		and dt.docstatus = 1 %s order by st.sales_person, dt.name desc""" % 
		(date_field, filters["doc_type"], filters["doc_type"], '%s', conditions), 
		tuple([filters["doc_type"]] + items), as_list=1)
		
	return entries

def get_conditions(filters, date_field):
	conditions = ""
	if filters.get("company"): conditions += " and dt.company = '%s'" % \
		filters["company"].replace("'", "\'")
	if filters.get("customer"): conditions += " and dt.customer = '%s'" % \
		filters["customer"].replace("'", "\'")
	if filters.get("territory"): conditions += " and dt.territory = '%s'" % \
		filters["territory"].replace("'", "\'")
	
	if filters.get("from_date"): conditions += " and dt.%s >= '%s'" % \
		(date_field, filters["from_date"])
	if filters.get("to_date"): conditions += " and dt.%s <= '%s'" % (date_field, filters["to_date"])
	
	if filters.get("sales_person"): conditions += " and st.sales_person = '%s'" % \
	 	filters["sales_person"].replace("'", "\'")
	
	items = get_items(filters)
	if items:
		conditions += " and dt_item.item_code in (%s)" % ', '.join(['%s']*len(items))
	
	return conditions, items

def get_items(filters):
	if filters.get("item_group"): key = "item_group"
	elif filters.get("brand"): key = "brand"
	else: key = ""

	items = []
	if key:
		items = frappe.db.sql_list("""select name from tabItem where %s = %s""" % 
			(key, '%s'), (filters[key]))
			
	return items
########NEW FILE########
__FILENAME__ = territory_target_variance_item_group_wise
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _, msgprint
from frappe.utils import flt
import time
from erpnext.accounts.utils import get_fiscal_year
from erpnext.controllers.trends import get_period_date_ranges, get_period_month_ranges

def execute(filters=None):
	if not filters: filters = {}
	
	columns = get_columns(filters)
	period_month_ranges = get_period_month_ranges(filters["period"], filters["fiscal_year"])
	tim_map = get_territory_item_month_map(filters)
	
	data = []
	for territory, territory_items in tim_map.items():
		for item_group, monthwise_data in territory_items.items():
			row = [territory, item_group]
			totals = [0, 0, 0]
			for relevant_months in period_month_ranges:
				period_data = [0, 0, 0]
				for month in relevant_months:
					month_data = monthwise_data.get(month, {})
					for i, fieldname in enumerate(["target", "achieved", "variance"]):
						value = flt(month_data.get(fieldname))
						period_data[i] += value
						totals[i] += value
				period_data[2] = period_data[0] - period_data[1]
				row += period_data
			totals[2] = totals[0] - totals[1]
			row += totals
			data.append(row)

	return columns, sorted(data, key=lambda x: (x[0], x[1]))
	
def get_columns(filters):
	for fieldname in ["fiscal_year", "period", "target_on"]:
		if not filters.get(fieldname):
			label = (" ".join(fieldname.split("_"))).title()
			msgprint(_("Please specify") + ": " + label, raise_exception=True)

	columns = ["Territory:Link/Territory:120", "Item Group:Link/Item Group:120"]

	group_months = False if filters["period"] == "Monthly" else True

	for from_date, to_date in get_period_date_ranges(filters["period"], filters["fiscal_year"]):
		for label in ["Target (%s)", "Achieved (%s)", "Variance (%s)"]:
			if group_months:
				label = label % (from_date.strftime("%b") + " - " + to_date.strftime("%b"))
			else:
				label = label % from_date.strftime("%b")
			columns.append(label+":Float:120")

	return columns + ["Total Target:Float:120", "Total Achieved:Float:120", 
		"Total Variance:Float:120"]

#Get territory & item group details
def get_territory_details(filters):
	return frappe.db.sql("""select t.name, td.item_group, td.target_qty, 
		td.target_amount, t.distribution_id 
		from `tabTerritory` t, `tabTarget Detail` td 
		where td.parent=t.name and td.fiscal_year=%s order by t.name""", 
		(filters["fiscal_year"]), as_dict=1)

#Get target distribution details of item group
def get_target_distribution_details(filters):
	target_details = {}

	for d in frappe.db.sql("""select bd.name, bdd.month, bdd.percentage_allocation 
		from `tabBudget Distribution Detail` bdd, `tabBudget Distribution` bd
		where bdd.parent=bd.name and bd.fiscal_year=%s""", (filters["fiscal_year"]), as_dict=1):
			target_details.setdefault(d.name, {}).setdefault(d.month, flt(d.percentage_allocation))

	return target_details

#Get achieved details from sales order
def get_achieved_details(filters):
	start_date, end_date = get_fiscal_year(fiscal_year = filters["fiscal_year"])[1:]

	item_details = frappe.db.sql("""select soi.item_code, soi.qty, soi.base_amount, so.transaction_date, 
		so.territory, MONTHNAME(so.transaction_date) as month_name 
		from `tabSales Order Item` soi, `tabSales Order` so 
		where soi.parent=so.name and so.docstatus=1 and so.transaction_date>=%s and 
		so.transaction_date<=%s""" % ('%s', '%s'), 
		(start_date, end_date), as_dict=1)

	item_actual_details = {}
	for d in item_details:
		item_actual_details.setdefault(d.territory, {}).setdefault(\
			get_item_group(d.item_code), []).append(d)

	return item_actual_details

def get_territory_item_month_map(filters):
	import datetime
	territory_details = get_territory_details(filters)
	tdd = get_target_distribution_details(filters)
	achieved_details = get_achieved_details(filters)

	tim_map = {}

	for td in territory_details:
		for month_id in range(1, 13):
			month = datetime.date(2013, month_id, 1).strftime('%B')
			
			tim_map.setdefault(td.name, {}).setdefault(td.item_group, {})\
				.setdefault(month, frappe._dict({
					"target": 0.0, "achieved": 0.0
				}))

			tav_dict = tim_map[td.name][td.item_group][month]
			month_percentage = tdd.get(td.distribution_id, {}).get(month, 0) \
				if td.distribution_id else 100.0/12

			for ad in achieved_details.get(td.name, {}).get(td.item_group, []):
				if (filters["target_on"] == "Quantity"):
					tav_dict.target = flt(td.target_qty) * month_percentage / 100
					if ad.month_name == month:
							tav_dict.achieved += ad.qty

				if (filters["target_on"] == "Amount"):
					tav_dict.target = flt(td.target_amount) * month_percentage / 100
					if ad.month_name == month:
							tav_dict.achieved += ad.base_amount

	return tim_map

def get_item_group(item_name):
	return frappe.db.get_value("Item", item_name, "item_group")
########NEW FILE########
__FILENAME__ = applicable_territory
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# MIT License. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ApplicableTerritory(Document):
	pass
########NEW FILE########
__FILENAME__ = authorization_control
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import cstr, flt, has_common, make_esc, comma_or

from frappe import session, _


from erpnext.utilities.transaction_base import TransactionBase

class AuthorizationControl(TransactionBase):


	# Get Names of all Approving Users and Roles
	# -------------------------------------------
	def get_appr_user_role(self, det, doctype_name, total, based_on, condition, item, company):
		amt_list, appr_users, appr_roles = [], [], []
		users, roles = '',''
		if det:
			for x in det:
				amt_list.append(flt(x[0]))
			max_amount = max(amt_list)

			app_dtl = frappe.db.sql("select approving_user, approving_role from `tabAuthorization Rule` where transaction = %s and (value = %s or value > %s) and docstatus != 2 and based_on = %s and company = %s %s" % ('%s', '%s', '%s', '%s', '%s', condition), (doctype_name, flt(max_amount), total, based_on, company))

			if not app_dtl:
				app_dtl = frappe.db.sql("select approving_user, approving_role from `tabAuthorization Rule` where transaction = %s and (value = %s or value > %s) and docstatus != 2 and based_on = %s and ifnull(company,'') = '' %s" % ('%s', '%s', '%s', '%s', condition), (doctype_name, flt(max_amount), total, based_on))
			for d in app_dtl:
				if(d[0]): appr_users.append(d[0])
				if(d[1]): appr_roles.append(d[1])

			if not has_common(appr_roles, frappe.user.get_roles()) and not has_common(appr_users, [session['user']]):
				frappe.msgprint(_("Not authroized since {0} exceeds limits").format(_(based_on)))
				frappe.throw(_("Can be approved by {0}").format(comma_or(appr_roles + appr_users)))


	# Check if authorization rule is set specific to user
	# ----------------------------------------------------
	def validate_auth_rule(self, doctype_name, total, based_on, cond, company, item = ''):
		chk = 1
		add_cond1,add_cond2	= '',''
		if based_on == 'Itemwise Discount':
			add_cond1 += " and master_name = '"+cstr(item)+"'"
			itemwise_exists = frappe.db.sql("select value from `tabAuthorization Rule` where transaction = %s and value <= %s and based_on = %s and company = %s and docstatus != 2 %s %s" % ('%s', '%s', '%s', '%s', cond, add_cond1), (doctype_name, total, based_on, company))
			if not itemwise_exists:
				itemwise_exists = frappe.db.sql("select value from `tabAuthorization Rule` where transaction = %s and value <= %s and based_on = %s and ifnull(company,'') = '' and docstatus != 2 %s %s" % ('%s', '%s', '%s', cond, add_cond1), (doctype_name, total, based_on))
			if itemwise_exists:
				self.get_appr_user_role(itemwise_exists, doctype_name, total, based_on, cond+add_cond1, item,company)
				chk = 0
		if chk == 1:
			if based_on == 'Itemwise Discount': add_cond2 += " and ifnull(master_name,'') = ''"
			appr = frappe.db.sql("select value from `tabAuthorization Rule` where transaction = %s and value <= %s and based_on = %s and company = %s and docstatus != 2 %s %s" % ('%s', '%s', '%s', '%s', cond, add_cond2), (doctype_name, total, based_on, company))

			if not appr:
				appr = frappe.db.sql("select value from `tabAuthorization Rule` where transaction = %s and value <= %s and based_on = %s and ifnull(company,'') = '' and docstatus != 2 %s %s"% ('%s', '%s', '%s', cond, add_cond2), (doctype_name, total, based_on))
			self.get_appr_user_role(appr, doctype_name, total, based_on, cond+add_cond2, item, company)


	# Bifurcate Authorization based on type
	# --------------------------------------
	def bifurcate_based_on_type(self, doctype_name, total, av_dis, based_on, doc_obj, val, company):
		add_cond = ''
		auth_value = av_dis
		if val == 1: add_cond += " and system_user = '"+session['user']+"'"
		elif val == 2: add_cond += " and system_role IN %s" % ("('"+"','".join(frappe.user.get_roles())+"')")
		else: add_cond += " and ifnull(system_user,'') = '' and ifnull(system_role,'') = ''"
		if based_on == 'Grand Total': auth_value = total
		elif based_on == 'Customerwise Discount':
			if doc_obj:
				if doc_obj.doctype == 'Sales Invoice': customer = doc_obj.customer
				else: customer = doc_obj.customer_name
				add_cond = " and master_name = '"+make_esc("'")(cstr(customer))+"'"
		if based_on == 'Itemwise Discount':
			if doc_obj:
				for t in doc_obj.get(doc_obj.fname):
					self.validate_auth_rule(doctype_name, t.discount_percentage, based_on, add_cond, company,t.item_code )
		else:
			self.validate_auth_rule(doctype_name, auth_value, based_on, add_cond, company)


	# Check Approving Authority for transactions other than expense voucher and Appraisal
	# -------------------------
	def validate_approving_authority(self, doctype_name,company, total, doc_obj = ''):
		av_dis = 0
		if doc_obj:
			price_list_rate, base_rate = 0, 0
			for d in doc_obj.get(doc_obj.fname):
				if d.base_price_list_rate and d.base_rate:
					price_list_rate += flt(d.base_price_list_rate)
					base_rate += flt(d.base_rate)
			if price_list_rate: av_dis = 100 - flt(base_rate * 100 / price_list_rate)

		final_based_on = ['Grand Total','Average Discount','Customerwise Discount','Itemwise Discount']
		# Individual User
		# ================
		# Check for authorization set for individual user

		based_on = [x[0] for x in frappe.db.sql("select distinct based_on from `tabAuthorization Rule` where transaction = %s and system_user = %s and (company = %s or ifnull(company,'')='') and docstatus != 2", (doctype_name, session['user'], company))]

		for d in based_on:
			self.bifurcate_based_on_type(doctype_name, total, av_dis, d, doc_obj, 1, company)

		# Remove user specific rules from global authorization rules
		for r in based_on:
			if r in final_based_on and r != 'Itemwise Discount': final_based_on.remove(r)

		# Specific Role
		# ===============
		# Check for authorization set on particular roles
		based_on = [x[0] for x in frappe.db.sql("""select based_on
			from `tabAuthorization Rule`
			where transaction = %s and system_role IN (%s) and based_on IN (%s)
			and (company = %s or ifnull(company,'')='')
			and docstatus != 2
		""" % ('%s', "'"+"','".join(frappe.user.get_roles())+"'", "'"+"','".join(final_based_on)+"'", '%s'), (doctype_name, company))]

		for d in based_on:
			self.bifurcate_based_on_type(doctype_name, total, av_dis, d, doc_obj, 2, company)

		# Remove role specific rules from global authorization rules
		for r in based_on:
			if r in final_based_on and r != 'Itemwise Discount': final_based_on.remove(r)

		# Global Rule
		# =============
		# Check for global authorization
		for g in final_based_on:
			self.bifurcate_based_on_type(doctype_name, total, av_dis, g, doc_obj, 0, company)

	#========================================================================================================================
	# payroll related check
	def get_value_based_rule(self,doctype_name,employee,total_claimed_amount,company):
		val_lst =[]
		val = frappe.db.sql("select value from `tabAuthorization Rule` where transaction=%s and (to_emp=%s or to_designation IN (select designation from `tabEmployee` where name=%s)) and ifnull(value,0)< %s and company = %s and docstatus!=2",(doctype_name,employee,employee,total_claimed_amount,company))
		if not val:
			val = frappe.db.sql("select value from `tabAuthorization Rule` where transaction=%s and (to_emp=%s or to_designation IN (select designation from `tabEmployee` where name=%s)) and ifnull(value,0)< %s and ifnull(company,'') = '' and docstatus!=2",(doctype_name, employee, employee, total_claimed_amount))

		if val:
			val_lst = [y[0] for y in val]
		else:
			val_lst.append(0)

		max_val = max(val_lst)
		rule = frappe.db.sql("select name, to_emp, to_designation, approving_role, approving_user from `tabAuthorization Rule` where transaction=%s and company = %s and (to_emp=%s or to_designation IN (select designation from `tabEmployee` where name=%s)) and ifnull(value,0)= %s and docstatus!=2",(doctype_name,company,employee,employee,flt(max_val)), as_dict=1)
		if not rule:
			rule = frappe.db.sql("select name, to_emp, to_designation, approving_role, approving_user from `tabAuthorization Rule` where transaction=%s and ifnull(company,'') = '' and (to_emp=%s or to_designation IN (select designation from `tabEmployee` where name=%s)) and ifnull(value,0)= %s and docstatus!=2",(doctype_name,employee,employee,flt(max_val)), as_dict=1)

		return rule

	#---------------------------------------------------------------------------------------------------------------------
	# related to payroll module only
	def get_approver_name(self, doctype_name, total, doc_obj=''):
		app_user=[]
		app_specific_user =[]
		rule ={}

		if doc_obj:
			if doctype_name == 'Expense Claim':
				rule = self.get_value_based_rule(doctype_name,doc_obj.employee,doc_obj.total_claimed_amount, doc_obj.company)
			elif doctype_name == 'Appraisal':
				rule = frappe.db.sql("select name, to_emp, to_designation, approving_role, approving_user from `tabAuthorization Rule` where transaction=%s and (to_emp=%s or to_designation IN (select designation from `tabEmployee` where name=%s)) and company = %s and docstatus!=2",(doctype_name,doc_obj.employee, doc_obj.employee, doc_obj.company),as_dict=1)
				if not rule:
					rule = frappe.db.sql("select name, to_emp, to_designation, approving_role, approving_user from `tabAuthorization Rule` where transaction=%s and (to_emp=%s or to_designation IN (select designation from `tabEmployee` where name=%s)) and ifnull(company,'') = '' and docstatus!=2",(doctype_name,doc_obj.employee, doc_obj.employee),as_dict=1)

			if rule:
				for m in rule:
					if m['to_emp'] or m['to_designation']:
						if m['approving_user']:
							app_specific_user.append(m['approving_user'])
						elif m['approving_role']:
							user_lst = [z[0] for z in frappe.db.sql("select distinct t1.name from `tabUser` t1, `tabUserRole` t2 where t2.role=%s and t2.parent=t1.name and t1.name !='Administrator' and t1.name != 'Guest' and t1.docstatus !=2",m['approving_role'])]
							for x in user_lst:
								if not x in app_user:
									app_user.append(x)

			if len(app_specific_user) >0:
				return app_specific_user
			else:
				return app_user

########NEW FILE########
__FILENAME__ = authorization_rule
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import cstr, flt
from frappe import _, msgprint

from frappe.model.document import Document

class AuthorizationRule(Document):


	def check_duplicate_entry(self):
		exists = frappe.db.sql("""select name, docstatus from `tabAuthorization Rule`
			where transaction = %s and based_on = %s and system_user = %s
			and system_role = %s and approving_user = %s and approving_role = %s
			and to_emp =%s and to_designation=%s and name != %s""",
			(self.transaction, self.based_on, cstr(self.system_user),
				cstr(self.system_role), cstr(self.approving_user),
				cstr(self.approving_role), cstr(self.to_emp),
				cstr(self.to_designation), self.name))
		auth_exists = exists and exists[0][0] or ''
		if auth_exists:
			frappe.throw(_("Duplicate Entry. Please check Authorization Rule {0}").format(auth_exists))


	def validate_rule(self):
		if self.transaction != 'Appraisal':
			if not self.approving_role and not self.approving_user:
				frappe.throw(_("Please enter Approving Role or Approving User"))
			elif self.system_user and self.system_user == self.approving_user:
				frappe.throw(_("Approving User cannot be same as user the rule is Applicable To"))
			elif self.system_role and self.system_role == self.approving_role:
				frappe.throw(_("Approving Role cannot be same as role the rule is Applicable To"))
			elif self.transaction in ['Purchase Order', 'Purchase Receipt', \
					'Purchase Invoice', 'Stock Entry'] and self.based_on \
					in ['Average Discount', 'Customerwise Discount', 'Itemwise Discount']:
				frappe.throw(_("Cannot set authorization on basis of Discount for {0}").format(self.transaction))
			elif self.based_on == 'Average Discount' and flt(self.value) > 100.00:
				frappe.throw(_("Discount must be less than 100"))
			elif self.based_on == 'Customerwise Discount' and not self.master_name:
				frappe.throw(_("Customer required for 'Customerwise Discount'"))
		else:
			if self.transaction == 'Appraisal':
				self.based_on = "Not Applicable"

	def validate(self):
		self.check_duplicate_entry()
		self.validate_rule()
		self.validate_master_name()
		if not self.value: self.value = 0.0

########NEW FILE########
__FILENAME__ = backup_dropbox
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# SETUP:
# install pip install --upgrade dropbox
#
# Create new Dropbox App
#
# in conf.py, set oauth2 settings
# dropbox_access_key
# dropbox_access_secret

from __future__ import unicode_literals
import os
import frappe
from frappe.utils import get_request_site_address, cstr
from frappe import _

@frappe.whitelist()
def get_dropbox_authorize_url():
	sess = get_dropbox_session()
	request_token = sess.obtain_request_token()
	return_address = get_request_site_address(True) \
		+ "?cmd=erpnext.setup.doctype.backup_manager.backup_dropbox.dropbox_callback"

	url = sess.build_authorize_url(request_token, return_address)

	return {
		"url": url,
		"key": request_token.key,
		"secret": request_token.secret,
	}

@frappe.whitelist(allow_guest=True)
def dropbox_callback(oauth_token=None, not_approved=False):
	from dropbox import client
	if not not_approved:
		if frappe.db.get_value("Backup Manager", None, "dropbox_access_key")==oauth_token:		
			allowed = 1
			message = "Dropbox access allowed."

			sess = get_dropbox_session()
			sess.set_request_token(frappe.db.get_value("Backup Manager", None, "dropbox_access_key"), 
				frappe.db.get_value("Backup Manager", None, "dropbox_access_secret"))
			access_token = sess.obtain_access_token()
			frappe.db.set_value("Backup Manager", "Backup Manager", "dropbox_access_key", access_token.key)
			frappe.db.set_value("Backup Manager", "Backup Manager", "dropbox_access_secret", access_token.secret)
			frappe.db.set_value("Backup Manager", "Backup Manager", "dropbox_access_allowed", allowed)
			dropbox_client = client.DropboxClient(sess)
			try:
				dropbox_client.file_create_folder("files")
			except:
				pass

		else:
			allowed = 0
			message = "Illegal Access Token Please try again."
	else:
		allowed = 0
		message = "Dropbox Access not approved."

	frappe.local.message_title = "Dropbox Approval"
	frappe.local.message = "<h3>%s</h3><p>Please close this window.</p>" % message
	
	if allowed:
		frappe.local.message_success = True
	
	frappe.db.commit()
	frappe.response['type'] = 'page'
	frappe.response['page_name'] = 'message.html'

def backup_to_dropbox():
	from dropbox import client, session
	from frappe.utils.backups import new_backup
	from frappe.utils import get_files_path, get_backups_path
	if not frappe.db:
		frappe.connect()

	sess = session.DropboxSession(frappe.conf.dropbox_access_key, frappe.conf.dropbox_secret_key, "app_folder")

	sess.set_token(frappe.db.get_value("Backup Manager", None, "dropbox_access_key"),
		frappe.db.get_value("Backup Manager", None, "dropbox_access_secret"))
	
	dropbox_client = client.DropboxClient(sess)

	# upload database
	backup = new_backup()
	filename = os.path.join(get_backups_path(), os.path.basename(backup.backup_path_db))
	upload_file_to_dropbox(filename, "/database", dropbox_client)

	frappe.db.close()
	response = dropbox_client.metadata("/files")
	
	# upload files to files folder
	did_not_upload = []
	error_log = []
	path = get_files_path()
	for filename in os.listdir(path):
		filename = cstr(filename)

		found = False
		filepath = os.path.join(path, filename)
		for file_metadata in response["contents"]:
 			if os.path.basename(filepath) == os.path.basename(file_metadata["path"]) and os.stat(filepath).st_size == int(file_metadata["bytes"]):
				found = True
				break
		if not found:
			try:
				upload_file_to_dropbox(filepath, "/files", dropbox_client)
			except Exception:
				did_not_upload.append(filename)
				error_log.append(frappe.get_traceback())
	
	frappe.connect()
	return did_not_upload, list(set(error_log))

def get_dropbox_session():
	try:
		from dropbox import session
	except:
		frappe.msgprint(_("Please install dropbox python module"), raise_exception=1)
	
	if not (frappe.conf.dropbox_access_key or frappe.conf.dropbox_secret_key):
		frappe.throw(_("Please set Dropbox access keys in your site config"))

	sess = session.DropboxSession(frappe.conf.dropbox_access_key, frappe.conf.dropbox_secret_key, "app_folder")
	return sess

def upload_file_to_dropbox(filename, folder, dropbox_client):
	from dropbox import rest
	size = os.stat(filename).st_size
	
	with open(filename, 'r') as f:
		# if max packet size reached, use chunked uploader
		max_packet_size = 4194304
	
		if size > max_packet_size:
			uploader = dropbox_client.get_chunked_uploader(f, size)
			while uploader.offset < size:
				try:
					uploader.upload_chunked()
					uploader.finish(folder + "/" + os.path.basename(filename), overwrite=True)
				except rest.ErrorResponse:
					pass
		else:
			dropbox_client.put_file(folder + "/" + os.path.basename(filename), f, overwrite=True)

if __name__=="__main__":
	backup_to_dropbox()
########NEW FILE########
__FILENAME__ = backup_googledrive
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# SETUP:
# install pip install --upgrade google-api-python-client
#
# In Google API
# - create new API project
# - create new oauth2 client (create installed app type as google \
# 	does not support subdomains)
#
# in conf.py, set oauth2 settings
# gdrive_client_id
# gdrive_client_secret

from __future__ import unicode_literals
import httplib2
import os
import mimetypes
import frappe
import oauth2client.client
from frappe.utils import cstr
from frappe import _
from apiclient.discovery import build
from apiclient.http import MediaFileUpload

# define log config for google drive api's log messages
# basicConfig redirects log to stderr
import logging
logging.basicConfig()

@frappe.whitelist()
def get_gdrive_authorize_url():
	flow = get_gdrive_flow()
	authorize_url = flow.step1_get_authorize_url()
	return {
		"authorize_url": authorize_url,
	}

def upload_files(name, mimetype, service, folder_id):
	if not frappe.db:
		frappe.connect()
	file_name = os.path.basename(name)
	media_body = MediaFileUpload(name, mimetype=mimetype, resumable=True)
	body = {
		'title': file_name,
		'description': 'Backup File',
		'mimetype': mimetype,
		'parents': [{
			'kind': 'drive#filelink',
			'id': folder_id
		}]
	}
	request = service.files().insert(body=body, media_body=media_body)
	response = None
	while response is None:
		status, response = request.next_chunk()

def backup_to_gdrive():
	from frappe.utils.backups import new_backup
	if not frappe.db:
		frappe.connect()
	get_gdrive_flow()
	credentials_json = frappe.db.get_value("Backup Manager", None, "gdrive_credentials")
	credentials = oauth2client.client.Credentials.new_from_json(credentials_json)
	http = httplib2.Http()
	http = credentials.authorize(http)
	drive_service = build('drive', 'v2', http=http)

	# upload database
	backup = new_backup()
	path = os.path.join(frappe.local.site_path, "public", "backups")
	filename = os.path.join(path, os.path.basename(backup.backup_path_db))

	# upload files to database folder
	upload_files(filename, 'application/x-gzip', drive_service,
		frappe.db.get_value("Backup Manager", None, "database_folder_id"))

	# upload files to files folder
	did_not_upload = []
	error_log = []

	files_folder_id = frappe.db.get_value("Backup Manager", None, "files_folder_id")

	frappe.db.close()
	path = os.path.join(frappe.local.site_path, "public", "files")
	for filename in os.listdir(path):
		filename = cstr(filename)
		found = False
		filepath = os.path.join(path, filename)
		ext = filename.split('.')[-1]
		size = os.path.getsize(filepath)
		if ext == 'gz' or ext == 'gzip':
			mimetype = 'application/x-gzip'
		else:
			mimetype = mimetypes.types_map.get("." + ext) or "application/octet-stream"

		#Compare Local File with Server File
	  	children = drive_service.children().list(folderId=files_folder_id).execute()
	  	for child in children.get('items', []):
			file = drive_service.files().get(fileId=child['id']).execute()
			if filename == file['title'] and size == int(file['fileSize']):
				found = True
				break
		if not found:
			try:
				upload_files(filepath, mimetype, drive_service, files_folder_id)
			except Exception, e:
				did_not_upload.append(filename)
				error_log.append(cstr(e))

	frappe.connect()
	return did_not_upload, list(set(error_log))

def get_gdrive_flow():
	from oauth2client.client import OAuth2WebServerFlow
	from frappe import conf

	if not "gdrive_client_id" in conf:
		frappe.throw(_("Please set Google Drive access keys in {0}"),format("site_config.json"))

	flow = OAuth2WebServerFlow(conf.gdrive_client_id, conf.gdrive_client_secret,
		"https://www.googleapis.com/auth/drive", 'urn:ietf:wg:oauth:2.0:oob')
	return flow

@frappe.whitelist()
def gdrive_callback(verification_code = None):
	flow = get_gdrive_flow()
	if verification_code:
		credentials = flow.step2_exchange(verification_code)
		allowed = 1

	# make folders to save id
	http = httplib2.Http()
	http = credentials.authorize(http)
	drive_service = build('drive', 'v2', http=http)
	erpnext_folder_id = create_erpnext_folder(drive_service)
	database_folder_id = create_folder('database', drive_service, erpnext_folder_id)
	files_folder_id = create_folder('files', drive_service, erpnext_folder_id)

	frappe.db.set_value("Backup Manager", "Backup Manager", "gdrive_access_allowed", allowed)
	frappe.db.set_value("Backup Manager", "Backup Manager", "database_folder_id", database_folder_id)
	frappe.db.set_value("Backup Manager", "Backup Manager", "files_folder_id", files_folder_id)
	final_credentials = credentials.to_json()
	frappe.db.set_value("Backup Manager", "Backup Manager", "gdrive_credentials", final_credentials)

	frappe.msgprint(_("Updated"))

def create_erpnext_folder(service):
	if not frappe.db:
		frappe.connect()
	erpnext = {
		'title': 'erpnext',
		'mimeType': 'application/vnd.google-apps.folder'
	}
	erpnext = service.files().insert(body=erpnext).execute()
	return erpnext['id']

def create_folder(name, service, folder_id):
	database = {
		'title': name,
		'mimeType': 'application/vnd.google-apps.folder',
		'parents': [{
	       	'kind': 'drive#fileLink',
	       	'id': folder_id
	    }]
	}
	database = service.files().insert(body=database).execute()
	return database['id']

if __name__=="__main__":
	backup_to_gdrive()

########NEW FILE########
__FILENAME__ = backup_manager
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe import _

from frappe.model.document import Document

class BackupManager(Document):
	pass

def take_backups_daily():
	take_backups_if("Daily")

def take_backups_weekly():
	take_backups_if("Weekly")

def take_backups_if(freq):
	if frappe.db.get_value("Backup Manager", None, "upload_backups_to_dropbox")==freq:
		take_backups_dropbox()
		
	# if frappe.db.get_value("Backup Manager", None, "upload_backups_to_gdrive")==freq:
	# 	take_backups_gdrive()
	
@frappe.whitelist()
def take_backups_dropbox():
	did_not_upload, error_log = [], []
	try:
		from erpnext.setup.doctype.backup_manager.backup_dropbox import backup_to_dropbox
		did_not_upload, error_log = backup_to_dropbox()
		if did_not_upload: raise Exception
		
		send_email(True, "Dropbox")
	except Exception:
		file_and_error = [" - ".join(f) for f in zip(did_not_upload, error_log)]
		error_message = ("\n".join(file_and_error) + "\n" + frappe.get_traceback())
		frappe.errprint(error_message)
		send_email(False, "Dropbox", error_message)

#backup to gdrive 
@frappe.whitelist()
def take_backups_gdrive():
	did_not_upload, error_log = [], []
	try:
		from erpnext.setup.doctype.backup_manager.backup_googledrive import backup_to_gdrive
		did_not_upload, error_log = backup_to_gdrive()
		if did_not_upload: raise Exception
		
		send_email(True, "Google Drive")
	except Exception:
		file_and_error = [" - ".join(f) for f in zip(did_not_upload, error_log)]
		error_message = ("\n".join(file_and_error) + "\n" + frappe.get_traceback())
		frappe.errprint(error_message)
		send_email(False, "Google Drive", error_message)

def send_email(success, service_name, error_status=None):
	from frappe.utils.email_lib import sendmail
	if success:
		subject = "Backup Upload Successful"
		message ="""<h3>Backup Uploaded Successfully</h3><p>Hi there, this is just to inform you 
		that your backup was successfully uploaded to your %s account. So relax!</p>
		""" % service_name

	else:
		subject = "[Warning] Backup Upload Failed"
		message ="""<h3>Backup Upload Failed</h3><p>Oops, your automated backup to %s
		failed.</p>
		<p>Error message: %s</p>
		<p>Please contact your system manager for more information.</p>
		""" % (service_name, error_status)
	
	if not frappe.db:
		frappe.connect()
	
	recipients = frappe.db.get_value("Backup Manager", None, "send_notifications_to").split(",")
	sendmail(recipients, subject=subject, msg=message)

########NEW FILE########
__FILENAME__ = brand
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class Brand(Document):
	pass
########NEW FILE########
__FILENAME__ = test_brand
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Brand')
########NEW FILE########
__FILENAME__ = company
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe, os
from frappe import _

from frappe.utils import cint
import frappe.defaults


from frappe.model.document import Document

class Company(Document):
	def onload(self):
		self.get("__onload").transactions_exist = self.check_if_transactions_exist()

	def check_if_transactions_exist(self):
		exists = False
		for doctype in ["Sales Invoice", "Delivery Note", "Sales Order", "Quotation",
			"Purchase Invoice", "Purchase Receipt", "Purchase Order", "Supplier Quotation"]:
				if frappe.db.sql("""select name from `tab%s` where company=%s and docstatus=1
					limit 1""" % (doctype, "%s"), self.name):
						exists = True
						break

		return exists

	def validate(self):
		if self.get('__islocal') and len(self.abbr) > 5:
			frappe.throw(_("Abbreviation cannot have more than 5 characters"))

		self.previous_default_currency = frappe.db.get_value("Company", self.name, "default_currency")
		if self.default_currency and self.previous_default_currency and \
			self.default_currency != self.previous_default_currency and \
			self.check_if_transactions_exist():
				frappe.throw(_("Cannot change company's default currency, because there are existing transactions. Transactions must be cancelled to change the default currency."))

	def on_update(self):
		if not frappe.db.sql("""select name from tabAccount
			where company=%s and docstatus<2 limit 1""", self.name):
			self.create_default_accounts()
			self.create_default_warehouses()
			self.install_country_fixtures()

		if not frappe.db.get_value("Cost Center", {"group_or_ledger": "Ledger",
				"company": self.name}):
			self.create_default_cost_center()

		self.set_default_accounts()

		if self.default_currency:
			frappe.db.set_value("Currency", self.default_currency, "enabled", 1)

	def install_country_fixtures(self):
		if os.path.exists(os.path.join(os.path.dirname(__file__), "fixtures", self.country.lower())):
			frappe.get_attr("erpnext.setup.doctype.company.fixtures.{0}.install".format(self.country.lower()))(self)

	def create_default_warehouses(self):
		for whname in (_("Stores"), _("Work In Progress"), _("Finished Goods")):
			if not frappe.db.exists("Warehouse", whname + " - " + self.abbr):
				stock_group = frappe.db.get_value("Account", {"account_type": "Stock",
					"group_or_ledger": "Group"})
				if stock_group:
					frappe.get_doc({
						"doctype":"Warehouse",
						"warehouse_name": whname,
						"company": self.name,
						"create_account_under": stock_group
					}).insert()

	def create_default_accounts(self):
		if self.chart_of_accounts:
			self.import_chart_of_account()
		else:
			self.create_standard_accounts()
			frappe.db.set(self, "receivables_group", _("Accounts Receivable") + " - " + self.abbr)
			frappe.db.set(self, "payables_group", _("Accounts Payable") + " - " + self.abbr)

	def import_chart_of_account(self):
		chart = frappe.get_doc("Chart of Accounts", self.chart_of_accounts)
		chart.create_accounts(self.name)

	def add_acc(self, lst):
		account = frappe.get_doc({
			"doctype": "Account",
			"freeze_account": "No",
			"master_type": "",
			"company": self.name
		})

		for d in self.fld_dict.keys():
			account.set(d, (d == 'parent_account' and lst[self.fld_dict[d]]) and lst[self.fld_dict[d]] +' - '+ self.abbr or lst[self.fld_dict[d]])
		account.insert()

	def set_default_accounts(self):
		def _set_default_account(fieldname, account_type):
			if self.get(fieldname):
				return

			account = frappe.db.get_value("Account", {"account_type": account_type,
				"group_or_ledger": "Ledger", "company": self.name})

			if account:
				self.db_set(fieldname, account)

		_set_default_account("default_cash_account", "Cash")
		_set_default_account("default_bank_account", "Bank")

		if cint(frappe.db.get_value("Accounts Settings", None, "auto_accounting_for_stock")):
			_set_default_account("stock_received_but_not_billed", "Stock Received But Not Billed")
			_set_default_account("stock_adjustment_account", "Stock Adjustment")
			_set_default_account("expenses_included_in_valuation", "Expenses Included In Valuation")

		if not self.default_income_account:
			self.db_set("default_income_account", frappe.db.get_value("Account", {"account_name": _("Sales")}))

	def create_default_cost_center(self):
		cc_list = [
			{
				'cost_center_name': self.name,
				'company':self.name,
				'group_or_ledger':'Group',
				'parent_cost_center':''
			},
			{
				'cost_center_name':_('Main'),
				'company':self.name,
				'group_or_ledger':'Ledger',
				'parent_cost_center':self.name + ' - ' + self.abbr
			},
		]
		for cc in cc_list:
			cc.update({"doctype": "Cost Center"})
			cc_doc = frappe.get_doc(cc)
			cc_doc.ignore_permissions = True

			if cc.get("cost_center_name") == self.name:
				cc_doc.ignore_mandatory = True
			cc_doc.insert()

		frappe.db.set(self, "cost_center", _("Main") + " - " + self.abbr)

	def on_trash(self):
		"""
			Trash accounts and cost centers for this company if no gl entry exists
		"""
		rec = frappe.db.sql("SELECT name from `tabGL Entry` where company = %s", self.name)
		if not rec:
			#delete tabAccount
			frappe.db.sql("delete from `tabAccount` where company = %s order by lft desc, rgt desc", self.name)

			#delete cost center child table - budget detail
			frappe.db.sql("delete bd.* from `tabBudget Detail` bd, `tabCost Center` cc where bd.parent = cc.name and cc.company = %s", self.name)
			#delete cost center
			frappe.db.sql("delete from `tabCost Center` WHERE company = %s order by lft desc, rgt desc", self.name)

		if not frappe.db.get_value("Stock Ledger Entry", {"company": self.name}):
			frappe.db.sql("""delete from `tabWarehouse` where company=%s""", self.name)

		frappe.defaults.clear_default("company", value=self.name)

		frappe.db.sql("""update `tabSingles` set value=""
			where doctype='Global Defaults' and field='default_company'
			and value=%s""", self.name)

	def before_rename(self, olddn, newdn, merge=False):
		if merge:
			frappe.throw(_("Sorry, companies cannot be merged"))

	def after_rename(self, olddn, newdn, merge=False):
		frappe.db.set(self, "company_name", newdn)

		frappe.db.sql("""update `tabDefaultValue` set defvalue=%s
			where defkey='Company' and defvalue=%s""", (newdn, olddn))

		frappe.defaults.clear_cache()

	def create_standard_accounts(self):
		self.fld_dict = {
			'account_name': 0,
			'parent_account': 1,
			'group_or_ledger': 2,
			'account_type': 3,
			'report_type': 4,
			'tax_rate': 5,
			'root_type': 6
		}

		acc_list_common = [
			[_('Application of Funds (Assets)'),'','Group','','Balance Sheet','', 'Asset'],
				[_('Current Assets'),_('Application of Funds (Assets)'),'Group','','Balance Sheet','', 'Asset'],
					[_('Accounts Receivable'),_('Current Assets'),'Group','','Balance Sheet','', 'Asset'],
					[_('Bank Accounts'),_('Current Assets'),'Group','Bank','Balance Sheet','', 'Asset'],
					[_('Cash In Hand'),_('Current Assets'),'Group','Cash','Balance Sheet','', 'Asset'],
						[_('Cash'),_('Cash In Hand'),'Ledger','Cash','Balance Sheet','', 'Asset'],
					[_('Loans and Advances (Assets)'),_('Current Assets'),'Group','','Balance Sheet','', 'Asset'],
					[_('Securities and Deposits'),_('Current Assets'),'Group','','Balance Sheet','', 'Asset'],
						[_('Earnest Money'),_('Securities and Deposits'),'Ledger','','Balance Sheet','', 'Asset'],
					[_('Stock Assets'),_('Current Assets'),'Group','Stock','Balance Sheet','', 'Asset'],
					[_('Tax Assets'),_('Current Assets'),'Group','','Balance Sheet','', 'Asset'],
				[_('Fixed Assets'),_('Application of Funds (Assets)'),'Group','','Balance Sheet','', 'Asset'],
					[_('Capital Equipments'),_('Fixed Assets'),'Ledger','Fixed Asset','Balance Sheet','', 'Asset'],
					[_('Computers'),_('Fixed Assets'),'Ledger','Fixed Asset','Balance Sheet','', 'Asset'],
					[_('Furniture and Fixture'),_('Fixed Assets'),'Ledger','Fixed Asset','Balance Sheet','', 'Asset'],
					[_('Office Equipments'),_('Fixed Assets'),'Ledger','Fixed Asset','Balance Sheet','', 'Asset'],
					[_('Plant and Machinery'),_('Fixed Assets'),'Ledger','Fixed Asset','Balance Sheet','', 'Asset'],
				[_('Investments'),_('Application of Funds (Assets)'),'Group','','Balance Sheet','', 'Asset'],
				[_('Temporary Accounts (Assets)'),_('Application of Funds (Assets)'),'Group','','Balance Sheet','', 'Asset'],
					[_('Temporary Assets'),_('Temporary Accounts (Assets)'),'Ledger','','Balance Sheet','', 'Asset'],
			[_('Expenses'),'','Group','Expense Account','Profit and Loss','', 'Expense'],
				[_('Direct Expenses'),_('Expenses'),'Group','Expense Account','Profit and Loss','', 'Expense'],
					[_('Stock Expenses'),_('Direct Expenses'),'Group','Expense Account','Profit and Loss','', 'Expense'],
						[_('Cost of Goods Sold'),_('Stock Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
						[_('Stock Adjustment'),_('Stock Expenses'),'Ledger','Stock Adjustment','Profit and Loss','', 'Expense'],
						[_('Expenses Included In Valuation'), _("Stock Expenses"), 'Ledger', 'Expenses Included In Valuation', 'Profit and Loss',  '', 'Expense'],
				[_('Indirect Expenses'), _('Expenses'),'Group','Expense Account','Profit and Loss','', 'Expense'],
					[_('Marketing Expenses'), _('Indirect Expenses'),'Ledger','Chargeable','Profit and Loss','', 'Expense'],
					[_('Sales Expenses'), _('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
					[_('Administrative Expenses'), _('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
					[_('Charity and Donations'), _('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
					[_('Commission on Sales'), _('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
					[_('Travel Expenses'), _('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
					[_('Entertainment Expenses'), _('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
					[_('Depreciation'), _('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
					[_('Freight and Forwarding Charges'), _('Indirect Expenses'),'Ledger','Chargeable','Profit and Loss','', 'Expense'],
					[_('Legal Expenses'), _('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
					[_('Miscellaneous Expenses'), _('Indirect Expenses'),'Ledger','Chargeable','Profit and Loss','', 'Expense'],
					[_('Office Maintenance Expenses'), _('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
					[_('Office Rent'), _('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
					[_('Postal Expenses'), _('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
					[_('Print and Stationary'), _('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
					[_('Rounded Off'), _('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
					[_('Salary') ,_('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
					[_('Telephone Expenses') ,_('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
					[_('Utility Expenses') ,_('Indirect Expenses'),'Ledger','Expense Account','Profit and Loss','', 'Expense'],
			[_('Income'),'','Group','','Profit and Loss','', 'Income'],
				[_('Direct Income'),_('Income'),'Group','Income Account','Profit and Loss','', 'Income'],
					[_('Sales'),_('Direct Income'),'Ledger','Income Account','Profit and Loss','', 'Income'],
					[_('Service'),_('Direct Income'),'Ledger','Income Account','Profit and Loss','', 'Income'],
				[_('Indirect Income'),_('Income'),'Group','Income Account','Profit and Loss','', 'Income'],
			[_('Source of Funds (Liabilities)'),'','Group','','Balance Sheet','', 'Income'],
				[_('Capital Account'),_('Source of Funds (Liabilities)'),'Group','','Balance Sheet','', 'Liability'],
					[_('Reserves and Surplus'),_('Capital Account'),'Ledger','','Balance Sheet','', 'Liability'],
					[_('Shareholders Funds'),_('Capital Account'),'Ledger','','Balance Sheet','', 'Liability'],
				[_('Current Liabilities'),_('Source of Funds (Liabilities)'),'Group','','Balance Sheet','', 'Liability'],
					[_('Accounts Payable'),_('Current Liabilities'),'Group','','Balance Sheet','', 'Liability'],
					[_('Stock Liabilities'),_('Current Liabilities'),'Group','','Balance Sheet','', 'Liability'],
						[_('Stock Received But Not Billed'), _('Stock Liabilities'), 'Ledger', 'Stock Received But Not Billed', 'Balance Sheet',  '', 'Liability'],
					[_('Duties and Taxes'),_('Current Liabilities'),'Group','','Balance Sheet','', 'Liability'],
					[_('Loans (Liabilities)'),_('Current Liabilities'),'Group','','Balance Sheet','', 'Liability'],
						[_('Secured Loans'),_('Loans (Liabilities)'),'Group','','Balance Sheet','', 'Liability'],
						[_('Unsecured Loans'),_('Loans (Liabilities)'),'Group','','Balance Sheet','', 'Liability'],
						[_('Bank Overdraft Account'),_('Loans (Liabilities)'),'Group','','Balance Sheet','', 'Liability'],
				[_('Temporary Accounts (Liabilities)'),_('Source of Funds (Liabilities)'),'Group','','Balance Sheet','', 'Liability'],
					[_('Temporary Liabilities'),_('Temporary Accounts (Liabilities)'),'Ledger','','Balance Sheet','', 'Liability']
		]

		# load common account heads
		for d in acc_list_common:
			self.add_acc(d)

@frappe.whitelist()
def replace_abbr(company, old, new):
	frappe.db.set_value("Company", company, "abbr", new)

	def _rename_record(dt):
		for d in frappe.db.sql("select name from `tab%s` where company=%s" % (dt, '%s'), company):
			parts = d[0].split(" - ")
			if parts[-1].lower() == old.lower():
				name_without_abbr = " - ".join(parts[:-1])
				frappe.rename_doc(dt, d[0], name_without_abbr + " - " + new)

	for dt in ["Account", "Cost Center", "Warehouse"]:
		_rename_record(dt)
		frappe.db.commit()

def get_name_with_abbr(name, company):
	company_abbr = frappe.db.get_value("Company", company, "abbr")
	parts = name.split(" - ")

	if parts[-1].lower() != company_abbr.lower():
		parts.append(company_abbr)

	return " - ".join(parts)

########NEW FILE########
__FILENAME__ = test_company
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

test_ignore = ["Account", "Cost Center"]

import frappe
import unittest

class TestCompany(unittest.TestCase):
	def atest_coa(self):
		for country, chart_name in frappe.db.sql("""select country, chart_name 
			from `tabChart of Accounts` where name = 'Deutscher Kontenplan SKR03'""", as_list=1):
				print "Country: ", country
				print "Chart Name: ", chart_name
				
				company_doc = frappe.get_doc({
					"doctype": "Company",
					"company_name": "_Test Company 2",
					"abbr": "_TC2",
					"default_currency": "INR",
					"country": country,
					"chart_of_accounts": chart_name
				})

				company_doc.insert()
				self.assertTrue(frappe.db.sql("""select count(*) from tabAccount 
					where company='_Test Company 2'""")[0][0] > 10)
				
				frappe.delete_doc("Company", "_Test Company 2")
		

test_records = frappe.get_test_records('Company')
########NEW FILE########
__FILENAME__ = contact_control
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ContactControl(Document):
	pass
########NEW FILE########
__FILENAME__ = country
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class Country(Document):
	pass
########NEW FILE########
__FILENAME__ = test_country
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Country')
########NEW FILE########
__FILENAME__ = currency
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import throw, _

from frappe.model.document import Document

class Currency(Document):
	pass

def validate_conversion_rate(currency, conversion_rate, conversion_rate_label, company):
	"""common validation for currency and price list currency"""

	company_currency = frappe.db.get_value("Company", company, "default_currency")

	if not conversion_rate:
		throw(_('%(conversion_rate_label)s is mandatory. Maybe Currency Exchange record is not created for %(from_currency)s to %(to_currency)s') % {
			"conversion_rate_label": conversion_rate_label,
			"from_currency": currency,
			"to_currency": company_currency
		})
########NEW FILE########
__FILENAME__ = test_currency
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# pre loaded

import frappe
test_records = frappe.get_test_records('Currency')
########NEW FILE########
__FILENAME__ = currency_exchange
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.model.document import Document

class CurrencyExchange(Document):

	def autoname(self):
		self.name = self.from_currency + "-" + self.to_currency

	def validate(self):
		self.validate_value("exchange_rate", ">", 0)

		if self.from_currency == self.to_currency:
			frappe.throw(_("From Currency and To Currency cannot be same"))

########NEW FILE########
__FILENAME__ = test_currency_exchange
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Currency Exchange')
########NEW FILE########
__FILENAME__ = customer_group
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _


from frappe.utils.nestedset import NestedSet
class CustomerGroup(NestedSet):
	nsm_parent_field = 'parent_customer_group';

	def on_update(self):
		self.validate_name_with_customer()
		super(CustomerGroup, self).on_update()
		self.validate_one_root()

	def validate_name_with_customer(self):
		if frappe.db.exists("Customer", self.name):
			frappe.msgprint(_("An Customer exists with same name"), raise_exception=1)

########NEW FILE########
__FILENAME__ = test_customer_group
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

test_ignore = ["Price List"]



import frappe
test_records = frappe.get_test_records('Customer Group')
########NEW FILE########
__FILENAME__ = email_digest
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.utils import fmt_money, formatdate, now_datetime, cstr, esc, \
	get_url_to_form, get_fullname
from frappe.utils.dateutils import datetime_in_user_format
from datetime import timedelta
from dateutil.relativedelta import relativedelta
from frappe.utils.email_lib import sendmail
from frappe.core.doctype.user.user import STANDARD_USERS

content_sequence = [
	["Income / Expenses", ["income_year_to_date", "income", "expenses_booked"]],
	["Receivables / Payables", ["collections", "payments",
		"invoiced_amount", "payables"]],
	["Bank Balance", ["bank_balance"]],
	["Buying", ["new_purchase_requests", "new_supplier_quotations", "new_purchase_orders"]],
	["Selling", ["new_leads", "new_enquiries", "new_quotations", "new_sales_orders"]],
	["Stock", ["new_delivery_notes",  "new_purchase_receipts", "new_stock_entries"]],
	["Support", ["new_communications", "new_support_tickets", "open_tickets"]],
	["Projects", ["new_projects"]],
	["System", ["scheduler_errors"]],
]

user_specific_content = ["calendar_events", "todo_list"]

digest_template = """<style>p.ed-indent { margin-right: 17px; }</style>
<h2>%(name)s</h2>
<h4>%(company)s</h4>
<p style='color: grey'>%(date)s</p>
<hr>
%(with_value)s
%(no_value)s
<hr>
<p style="color: #888; font-size: 90%%">To change what you see here,
create more digests, go to Setup > Email Digest</p>"""

row_template = """<p style="%(style)s">
<span>%(label)s</span>:
<span style="font-weight: bold; font-size: 110%%">
	<span style="color: grey">%(currency)s</span>%(value)s
</span></p>"""

from frappe.model.document import Document
class EmailDigest(Document):
	def __init__(self, arg1, arg2=None):
		super(EmailDigest, self).__init__(arg1, arg2)
		self.from_date, self.to_date = self.get_from_to_date()
		self.future_from_date, self.future_to_date = self.get_future_from_to_date()
		self.currency = frappe.db.get_value("Company", self.company,
			"default_currency")

	def get_users(self):
		"""get list of users"""
		user_list = frappe.db.sql("""
			select name, enabled from tabUser
			where name not in ({})
			and user_type != "Website User"
			order by enabled desc, name asc""".format(", ".join(["%s"]*len(STANDARD_USERS))), STANDARD_USERS, as_dict=1)

		if self.recipient_list:
			recipient_list = self.recipient_list.split("\n")
		else:
			recipient_list = []
		for p in user_list:
			p["checked"] = p["name"] in recipient_list and 1 or 0

		frappe.response['user_list'] = user_list

	def send(self):
		# send email only to enabled users
		valid_users = [p[0] for p in frappe.db.sql("""select name from `tabUser`
			where enabled=1""")]
		recipients = filter(lambda r: r in valid_users,
			self.recipient_list.split("\n"))

		common_msg = self.get_common_content()
		if recipients:
			for user_id in recipients:
				msg_for_this_receipient = self.get_msg_html(self.get_user_specific_content(user_id) + \
					common_msg)
				if msg_for_this_receipient:
					sendmail(recipients=user_id,
						subject="[ERPNext] [{frequency} Digest] {name}".format(
							frequency=self.frequency, name=self.name),
						msg=msg_for_this_receipient)

	def get_digest_msg(self):
		return self.get_msg_html(self.get_user_specific_content(frappe.session.user) + \
			self.get_common_content(), send_only_if_updates=False)

	def get_common_content(self):
		out = []
		for module, content in content_sequence:
			module_out = []
			for ctype in content:
				if self.get(ctype) and hasattr(self, "get_"+ctype):
					module_out.append(getattr(self, "get_"+ctype)())
			if any([m[0] for m in module_out]):
				out += [[1, "<h4>" + _(module) + "</h4>"]] + module_out + [[1, "<hr>"]]
			else:
				out += module_out

		return out

	def get_user_specific_content(self, user_id):
		original_session_user = frappe.session.user

		# setting session user for role base event fetching
		frappe.session.user = user_id

		out = []
		for ctype in user_specific_content:
			if self.get(ctype) and hasattr(self, "get_"+ctype):
				out.append(getattr(self, "get_"+ctype)(user_id))

		frappe.session.user = original_session_user

		return out

	def get_msg_html(self, out, send_only_if_updates=True):
		with_value = [o[1] for o in out if o[0]]

		if with_value:
			has_updates = True
			with_value = "\n".join(with_value)
		else:
			has_updates = False
			with_value = "<p>There were no updates in the items selected for this digest.</p><hr>"

		if not has_updates and send_only_if_updates:
			return

		# seperate out no value items
		no_value = [o[1] for o in out if not o[0]]
		if no_value:
			no_value = """<h4>No Updates For:</h4>""" + "\n".join(no_value)

		date = self.frequency == "Daily" and formatdate(self.from_date) or \
			"%s to %s" % (formatdate(self.from_date), formatdate(self.to_date))

		msg = digest_template % {
				"digest": self.frequency + " Digest",
				"date": date,
				"company": self.company,
				"with_value": with_value,
				"no_value": no_value or "",
				"name": self.name
			}

		return msg

	def get_income_year_to_date(self):
		return self.get_income(frappe.db.get_defaults("year_start_date"),
			self.meta.get_label("income_year_to_date"))

	def get_bank_balance(self):
		# account is of type "Bank" or "Cash"
		accounts = dict([[a["name"], [a["account_name"], 0]] for a in self.get_accounts()
			if a["account_type"] in ["Bank", "Cash"]])
		ackeys = accounts.keys()

		for gle in self.get_gl_entries(None, self.to_date):
			if gle["account"] in ackeys:
				accounts[gle["account"]][1] += gle["debit"] - gle["credit"]

		# build html
		out = self.get_html("Bank/Cash Balance as on " + formatdate(self.to_date), "", "")
		for ac in ackeys:
			if accounts[ac][1]:
				out += "\n" + self.get_html(accounts[ac][0], self.currency,
					fmt_money(accounts[ac][1]), style="margin-left: 17px")
		return sum((accounts[ac][1] for ac in ackeys)), out

	def get_income(self, from_date=None, label=None):
		accounts = [a["name"] for a in self.get_accounts() if a["root_type"]=="Income"]

		income = 0
		for gle in self.get_gl_entries(from_date or self.from_date, self.to_date):
			if gle["account"] in accounts:
				income += gle["credit"] - gle["debit"]

		return income, self.get_html(label or self.meta.get_label("income"), self.currency,
			fmt_money(income))

	def get_expenses_booked(self):
		accounts = [a["name"] for a in self.get_accounts() if a["root_type"]=="Expense"]

		expense = 0
		for gle in self.get_gl_entries(self.from_date, self.to_date):
			if gle["account"] in accounts:
				expense += gle["debit"] - gle["credit"]

		return expense, self.get_html(self.meta.get_label("expenses_booked"), self.currency,
			fmt_money(expense))

	def get_collections(self):
		return self.get_party_total("Customer", "credit", self.meta.get_label("collections"))

	def get_payments(self):
		return self.get_party_total("Supplier", "debit", self.meta.get_label("payments"))

	def get_party_total(self, party_type, gle_field, label):
		import re
		# account is of master_type Customer or Supplier
		accounts = [a["name"] for a in self.get_accounts()
			if a["master_type"]==party_type]

		# account is "Bank" or "Cash"
		bc_accounts = [esc(a["name"], "()|") for a in self.get_accounts()
			if a["account_type"] in ["Bank", "Cash"]]
		bc_regex = re.compile("""(%s)""" % "|".join(bc_accounts))

		total = 0
		for gle in self.get_gl_entries(self.from_date, self.to_date):
			# check that its made against a bank or cash account
			if gle["account"] in accounts and gle["against"] and \
					bc_regex.findall(gle["against"]):
				val = gle["debit"] - gle["credit"]
				total += (gle_field=="debit" and 1 or -1) * val

		return total, self.get_html(label, self.currency, fmt_money(total))

	def get_invoiced_amount(self):
		# aka receivables
		return self.get_booked_total("Customer", "debit", self.meta.get_label("invoiced_amount"))

	def get_payables(self):
		return self.get_booked_total("Supplier", "credit", self.meta.get_label("payables"))

	def get_booked_total(self, party_type, gle_field, label):
		# account is of master_type Customer or Supplier
		accounts = [a["name"] for a in self.get_accounts()
			if a["master_type"]==party_type]

		total = 0
		for gle in self.get_gl_entries(self.from_date, self.to_date):
			if gle["account"] in accounts:
				total += gle[gle_field]

		return total, self.get_html(label, self.currency, fmt_money(total))

	def get_new_leads(self):
		return self.get_new_count("Lead", self.meta.get_label("new_leads"))

	def get_new_enquiries(self):
		return self.get_new_count("Opportunity", self.meta.get_label("new_enquiries"), docstatus=1)

	def get_new_quotations(self):
		return self.get_new_sum("Quotation", self.meta.get_label("new_quotations"), "grand_total")

	def get_new_sales_orders(self):
		return self.get_new_sum("Sales Order", self.meta.get_label("new_sales_orders"), "grand_total")

	def get_new_delivery_notes(self):
		return self.get_new_sum("Delivery Note", self.meta.get_label("new_delivery_notes"), "grand_total")

	def get_new_purchase_requests(self):
		return self.get_new_count("Material Request",
			 self.meta.get_label("new_purchase_requests"), docstatus=1)

	def get_new_supplier_quotations(self):
		return self.get_new_sum("Supplier Quotation", self.meta.get_label("new_supplier_quotations"),
			"grand_total")

	def get_new_purchase_orders(self):
		return self.get_new_sum("Purchase Order", self.meta.get_label("new_purchase_orders"),
			"grand_total")

	def get_new_purchase_receipts(self):
		return self.get_new_sum("Purchase Receipt", self.meta.get_label("new_purchase_receipts"),
			"grand_total")

	def get_new_stock_entries(self):
		return self.get_new_sum("Stock Entry", self.meta.get_label("new_stock_entries"), "total_amount")

	def get_new_support_tickets(self):
		return self.get_new_count("Support Ticket", self.meta.get_label("new_support_tickets"),
			filter_by_company=False)

	def get_new_communications(self):
		return self.get_new_count("Communication", self.meta.get_label("new_communications"),
			filter_by_company=False)

	def get_new_projects(self):
		return self.get_new_count("Project", self.meta.get_label("new_projects"),
			filter_by_company=False)

	def get_calendar_events(self, user_id):
		from frappe.core.doctype.event.event import get_events
		events = get_events(self.future_from_date.strftime("%Y-%m-%d"), self.future_to_date.strftime("%Y-%m-%d"))

		html = ""
		if events:
			for i, e in enumerate(events):
				if i>=10:
					break
				if e.all_day:
					html += """<li style='line-height: 200%%'>%s [%s (%s)]</li>""" % \
						(e.subject, datetime_in_user_format(e.starts_on), _("All Day"))
				else:
					html += "<li style='line-height: 200%%'>%s [%s - %s]</li>" % \
						(e.subject, datetime_in_user_format(e.starts_on), datetime_in_user_format(e.ends_on))

		if html:
			return 1, "<h4>Upcoming Calendar Events (max 10):</h4><ul>" + html + "</ul><hr>"
		else:
			return 0, "<p>Calendar Events</p>"

	def get_todo_list(self, user_id):
		todo_list = frappe.db.sql("""select *
			from `tabToDo` where (owner=%s or assigned_by=%s)
			order by field(priority, 'High', 'Medium', 'Low') asc, date asc""",
			(user_id, user_id), as_dict=True)

		html = ""
		if todo_list:
			for i, todo in enumerate([todo for todo in todo_list if not todo.checked]):
				if i>= 10:
					break
				if not todo.description and todo.reference_type:
					todo.description = "%s: %s - %s %s" % \
					(todo.reference_type, get_url_to_form(todo.reference_type, todo.reference_name),
					_("assigned by"), get_fullname(todo.assigned_by))

				html += "<li style='line-height: 200%%'>%s [%s]</li>" % (todo.description, todo.priority)

		if html:
			return 1, "<h4>To Do (max 10):</h4><ul>" + html + "</ul><hr>"
		else:
			return 0, "<p>To Do</p>"

	def get_new_count(self, doctype, label, docstatus=0, filter_by_company=True):
		if filter_by_company:
			company = """and company="%s" """ % self.company.replace('"', '\"')
		else:
			company = ""
		count = frappe.db.sql("""select count(*) from `tab%s`
			where docstatus=%s %s and
			date(creation)>=%s and date(creation)<=%s""" %
			(doctype, docstatus, company, "%s", "%s"), (self.from_date, self.to_date))
		count = count and count[0][0] or 0

		return count, self.get_html(label, None, count)

	def get_new_sum(self, doctype, label, sum_field):
		count_sum = frappe.db.sql("""select count(*), sum(ifnull(`%s`, 0))
			from `tab%s` where docstatus=1 and company = %s and
			date(creation)>=%s and date(creation)<=%s""" % (sum_field, doctype, "%s",
			"%s", "%s"), (self.company, self.from_date, self.to_date))
		count, total = count_sum and count_sum[0] or (0, 0)

		return count, self.get_html(label, self.currency,
			"%s - (%s)" % (fmt_money(total), cstr(count)))

	def get_html(self, label, currency, value, style=None):
		"""get html output"""
		return row_template % {
				"style": style or "",
				"label": label,
				"currency": currency and (currency+" ") or "",
				"value": value
			}

	def get_gl_entries(self, from_date=None, to_date=None):
		"""get valid GL Entries filtered by company and posting date"""
		if from_date==self.from_date and to_date==self.to_date and \
				hasattr(self, "gl_entries"):
			return self.gl_entries

		gl_entries = frappe.db.sql("""select `account`,
			ifnull(credit, 0) as credit, ifnull(debit, 0) as debit, `against`
			from `tabGL Entry`
			where company=%s
			and posting_date <= %s %s""" % ("%s", "%s",
			from_date and "and posting_date>='%s'" % from_date or ""),
			(self.company, to_date or self.to_date), as_dict=1)

		# cache if it is the normal cases
		if from_date==self.from_date and to_date==self.to_date:
			self.gl_entries = gl_entries

		return gl_entries

	def get_accounts(self):
		if not hasattr(self, "accounts"):
			self.accounts = frappe.db.sql("""select name, account_type, account_name, master_type, root_type
				from `tabAccount` where company=%s and docstatus < 2
				and group_or_ledger = "Ledger" order by lft""",
				(self.company,), as_dict=1)
		return self.accounts

	def get_from_to_date(self):
		today = now_datetime().date()

		# decide from date based on email digest frequency
		if self.frequency == "Daily":
			# from date, to_date is yesterday
			from_date = to_date = today - timedelta(days=1)
		elif self.frequency == "Weekly":
			# from date is the previous week's monday
			from_date = today - timedelta(days=today.weekday(), weeks=1)
			# to date is sunday i.e. the previous day
			to_date = from_date + timedelta(days=6)
		else:
			# from date is the 1st day of the previous month
			from_date = today - relativedelta(days=today.day-1, months=1)
			# to date is the last day of the previous month
			to_date = today - relativedelta(days=today.day)

		return from_date, to_date

	def get_future_from_to_date(self):
		today = now_datetime().date()

		# decide from date based on email digest frequency
		if self.frequency == "Daily":
			# from date, to_date is today
			from_date = to_date = today
		elif self.frequency == "Weekly":
			# from date is the current week's monday
			from_date = today - timedelta(days=today.weekday())
			# to date is the current week's sunday
			to_date = from_date + timedelta(days=6)
		else:
			# from date is the 1st day of the current month
			from_date = today - relativedelta(days=today.day-1)
			# to date is the last day of the current month
			to_date = from_date + relativedelta(days=-1, months=1)

		return from_date, to_date

	def get_next_sending(self):
		from_date, to_date = self.get_from_to_date()

		send_date = to_date + timedelta(days=1)

		if self.frequency == "Daily":
			next_send_date = send_date + timedelta(days=1)
		elif self.frequency == "Weekly":
			next_send_date = send_date + timedelta(weeks=1)
		else:
			next_send_date = send_date + relativedelta(months=1)
		self.next_send = formatdate(next_send_date) + " at midnight"

		return send_date

	def get_open_tickets(self):
		open_tickets = frappe.db.sql("""select name, subject, modified, raised_by
			from `tabSupport Ticket` where status='Open'
			order by modified desc limit 10""", as_dict=True)

		if open_tickets:
			return 1, """<hr><h4>Latest Open Tickets (max 10):</h4>%s""" % \
			 "".join(["<p>%(name)s: %(subject)s <br>by %(raised_by)s on %(modified)s</p>" % \
				t for t in open_tickets])
		else:
			return 0, "No Open Tickets!"

	def get_scheduler_errors(self):
		import frappe.utils.scheduler
		return frappe.utils.scheduler.get_error_report(self.from_date, self.to_date)

	def onload(self):
		self.get_next_sending()

def send():
	now_date = now_datetime().date()

	for ed in frappe.db.sql("""select name from `tabEmail Digest`
			where enabled=1 and docstatus<2""", as_list=1):
		ed_obj = frappe.get_doc('Email Digest', ed[0])
		if (now_date == ed_obj.get_next_sending()):
			ed_obj.send()

########NEW FILE########
__FILENAME__ = global_defaults
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
"""Global Defaults"""
import frappe
import frappe.defaults

keydict = {
	# "key in defaults": "key in Global Defaults"
	"print_style": "print_style",
	"fiscal_year": "current_fiscal_year",
	'company': 'default_company',
	'currency': 'default_currency',
	"country": "country",
	'hide_currency_symbol':'hide_currency_symbol',
	'account_url':'account_url',
	'disable_rounded_total': 'disable_rounded_total',
}

from frappe.model.document import Document

class GlobalDefaults(Document):

	def on_update(self):
		"""update defaults"""
		for key in keydict:
			frappe.db.set_default(key, self.get(keydict[key], ''))

		# update year start date and year end date from fiscal_year
		year_start_end_date = frappe.db.sql("""select year_start_date, year_end_date
			from `tabFiscal Year` where name=%s""", self.current_fiscal_year)

		ysd = year_start_end_date[0][0] or ''
		yed = year_start_end_date[0][1] or ''

		if ysd and yed:
			frappe.db.set_default('year_start_date', ysd.strftime('%Y-%m-%d'))
			frappe.db.set_default('year_end_date', yed.strftime('%Y-%m-%d'))

		# enable default currency
		if self.default_currency:
			frappe.db.set_value("Currency", self.default_currency, "enabled", 1)

		# clear cache
		frappe.clear_cache()

	def get_defaults(self):
		return frappe.defaults.get_defaults()

########NEW FILE########
__FILENAME__ = item_group
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils.nestedset import NestedSet
from frappe.website.website_generator import WebsiteGenerator
from frappe.website.render import clear_cache

class ItemGroup(NestedSet, WebsiteGenerator):
	nsm_parent_field = 'parent_item_group'

	def autoname(self):
		self.name = self.item_group_name

	def validate(self):
		if not self.parent_website_route:
			if frappe.db.get_value("Item Group", self.parent_item_group, "show_in_website"):
				self.parent_website_route = frappe.get_website_route("Item Group",
					self.parent_item_group)

	def on_update(self):
		NestedSet.on_update(self)
		WebsiteGenerator.on_update(self)
		invalidate_cache_for(self)
		self.validate_name_with_item()
		self.validate_one_root()

	def after_rename(self, olddn, newdn, merge=False):
		NestedSet.after_rename(self, olddn, newdn, merge)
		WebsiteGenerator.after_rename(self, olddn, newdn, merge)

	def on_trash(self):
		NestedSet.on_trash(self)
		WebsiteGenerator.on_trash(self)

	def validate_name_with_item(self):
		if frappe.db.exists("Item", self.name):
			frappe.throw(frappe._("An item exists with same name ({0}), please change the item group name or rename the item").format(self.name))

def get_parent_item_groups(item_group_name):
	item_group = frappe.get_doc("Item Group", item_group_name)
	return frappe.db.sql("""select name, page_name from `tabItem Group`
		where lft <= %s and rgt >= %s
		and ifnull(show_in_website,0)=1
		order by lft asc""", (item_group.lft, item_group.rgt), as_dict=True)

def invalidate_cache_for(doc, item_group=None):
	if not item_group:
		item_group = doc.name

	for i in get_parent_item_groups(item_group):
		if i.page_name:
			clear_cache(i.page_name)

########NEW FILE########
__FILENAME__ = test_item_group
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import unittest
import frappe
from frappe.utils.nestedset import NestedSetRecursionError, NestedSetMultipleRootsError, \
	NestedSetChildExistsError, NestedSetInvalidMergeError, rebuild_tree, get_ancestors_of

test_records = frappe.get_test_records('Item Group')

class TestItem(unittest.TestCase):
	def test_basic_tree(self, records=None):
		min_lft = 1
		max_rgt = frappe.db.sql("select max(rgt) from `tabItem Group`")[0][0]

		if not records:
			records = test_records[2:]

		for item_group in records:
			lft, rgt, parent_item_group = frappe.db.get_value("Item Group", item_group["item_group_name"],
				["lft", "rgt", "parent_item_group"])

			if parent_item_group:
				parent_lft, parent_rgt = frappe.db.get_value("Item Group", parent_item_group,
					["lft", "rgt"])
			else:
				# root
				parent_lft = min_lft - 1
				parent_rgt = max_rgt + 1

			self.assertTrue(lft)
			self.assertTrue(rgt)
			self.assertTrue(lft < rgt)
			self.assertTrue(parent_lft < parent_rgt)
			self.assertTrue(lft > parent_lft)
			self.assertTrue(rgt < parent_rgt)
			self.assertTrue(lft >= min_lft)
			self.assertTrue(rgt <= max_rgt)

			no_of_children = self.get_no_of_children(item_group["item_group_name"])
			self.assertTrue(rgt == (lft + 1 + (2 * no_of_children)))

			no_of_children = self.get_no_of_children(parent_item_group)
			self.assertTrue(parent_rgt == (parent_lft + 1 + (2 * no_of_children)))

	def get_no_of_children(self, item_group):
		def get_no_of_children(item_groups, no_of_children):
			children = []
			for ig in item_groups:
				children += frappe.db.sql_list("""select name from `tabItem Group`
				where ifnull(parent_item_group, '')=%s""", ig or '')

			if len(children):
				return get_no_of_children(children, no_of_children + len(children))
			else:
				return no_of_children

		return get_no_of_children([item_group], 0)

	def test_recursion(self):
		group_b = frappe.get_doc("Item Group", "_Test Item Group B")
		group_b.parent_item_group = "_Test Item Group B - 3"
		self.assertRaises(NestedSetRecursionError, group_b.save)

		# cleanup
		group_b.parent_item_group = "All Item Groups"
		group_b.save()

	def test_rebuild_tree(self):
		rebuild_tree("Item Group", "parent_item_group")
		self.test_basic_tree()

	def move_it_back(self):
		group_b = frappe.get_doc("Item Group", "_Test Item Group B")
		group_b.parent_item_group = "All Item Groups"
		group_b.save()
		self.test_basic_tree()

	def test_move_group_into_another(self):
		# before move
		old_lft, old_rgt = frappe.db.get_value("Item Group", "_Test Item Group C", ["lft", "rgt"])

		# put B under C
		group_b = frappe.get_doc("Item Group", "_Test Item Group B")
		lft, rgt = group_b.lft, group_b.rgt

		group_b.parent_item_group = "_Test Item Group C"
		group_b.save()
		self.test_basic_tree()

		# after move
		new_lft, new_rgt = frappe.db.get_value("Item Group", "_Test Item Group C", ["lft", "rgt"])

		# lft should reduce
		self.assertEquals(old_lft - new_lft, rgt - lft + 1)

		# adjacent siblings, hence rgt diff will be 0
		self.assertEquals(new_rgt - old_rgt, 0)

		self.move_it_back()

	def test_move_group_into_root(self):
		group_b = frappe.get_doc("Item Group", "_Test Item Group B")
		group_b.parent_item_group = ""
		self.assertRaises(NestedSetMultipleRootsError, group_b.save)

		# trick! works because it hasn't been rolled back :D
		self.test_basic_tree()

		self.move_it_back()

	def print_tree(self):
		import json
		print json.dumps(frappe.db.sql("select name, lft, rgt from `tabItem Group` order by lft"), indent=1)

	def test_move_leaf_into_another_group(self):
		# before move
		old_lft, old_rgt = frappe.db.get_value("Item Group", "_Test Item Group C", ["lft", "rgt"])

		group_b_3 = frappe.get_doc("Item Group", "_Test Item Group B - 3")
		lft, rgt = group_b_3.lft, group_b_3.rgt

		# child of right sibling is moved into it
		group_b_3.parent_item_group = "_Test Item Group C"
		group_b_3.save()
		self.test_basic_tree()

		new_lft, new_rgt = frappe.db.get_value("Item Group", "_Test Item Group C", ["lft", "rgt"])

		# lft should remain the same
		self.assertEquals(old_lft - new_lft, 0)

		# rgt should increase
		self.assertEquals(new_rgt - old_rgt, rgt - lft + 1)

		# move it back
		group_b_3 = frappe.get_doc("Item Group", "_Test Item Group B - 3")
		group_b_3.parent_item_group = "_Test Item Group B"
		group_b_3.save()
		self.test_basic_tree()

	def test_delete_leaf(self):
		# for checking later
		parent_item_group = frappe.db.get_value("Item Group", "_Test Item Group B - 3", "parent_item_group")
		rgt = frappe.db.get_value("Item Group", parent_item_group, "rgt")

		ancestors = get_ancestors_of("Item Group", "_Test Item Group B - 3")
		ancestors = frappe.db.sql("""select name, rgt from `tabItem Group`
			where name in ({})""".format(", ".join(["%s"]*len(ancestors))), tuple(ancestors), as_dict=True)

		frappe.delete_doc("Item Group", "_Test Item Group B - 3")
		records_to_test = test_records[2:]
		del records_to_test[4]
		self.test_basic_tree(records=records_to_test)

		# rgt of each ancestor would reduce by 2
		for item_group in ancestors:
			new_lft, new_rgt = frappe.db.get_value("Item Group", item_group.name, ["lft", "rgt"])
			self.assertEquals(new_rgt, item_group.rgt - 2)

		# insert it back
		frappe.copy_doc(test_records[6]).insert()

		self.test_basic_tree()

	def test_delete_group(self):
		# cannot delete group with child, but can delete leaf
		self.assertRaises(NestedSetChildExistsError, frappe.delete_doc, "Item Group", "_Test Item Group B")

	def test_merge_groups(self):
		frappe.rename_doc("Item Group", "_Test Item Group B", "_Test Item Group C", merge=True)
		records_to_test = test_records[2:]
		del records_to_test[1]
		self.test_basic_tree(records=records_to_test)

		# insert Group B back
		frappe.copy_doc(test_records[3]).insert()
		self.test_basic_tree()

		# move its children back
		for name in frappe.db.sql_list("""select name from `tabItem Group`
			where parent_item_group='_Test Item Group C'"""):

			doc = frappe.get_doc("Item Group", name)
			doc.parent_item_group = "_Test Item Group B"
			doc.save()

		self.test_basic_tree()

	def test_merge_leaves(self):
		frappe.rename_doc("Item Group", "_Test Item Group B - 2", "_Test Item Group B - 1", merge=True)
		records_to_test = test_records[2:]
		del records_to_test[3]
		self.test_basic_tree(records=records_to_test)

		# insert Group B - 2back
		frappe.copy_doc(test_records[5]).insert()
		self.test_basic_tree()

	def test_merge_leaf_into_group(self):
		self.assertRaises(NestedSetInvalidMergeError, frappe.rename_doc, "Item Group", "_Test Item Group B - 3",
			"_Test Item Group B", merge=True)

	def test_merge_group_into_leaf(self):
		self.assertRaises(NestedSetInvalidMergeError, frappe.rename_doc, "Item Group", "_Test Item Group B",
			"_Test Item Group B - 3", merge=True)

########NEW FILE########
__FILENAME__ = jobs_email_settings
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.utils import cint

from frappe.model.document import Document

class JobsEmailSettings(Document):

	def validate(self):
		if cint(self.extract_emails) and not (self.email_id and self.host and \
			self.username and self.password):

			frappe.throw(_("""Host, Email and Password required if emails are to be pulled"""))

########NEW FILE########
__FILENAME__ = naming_series
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import cstr
from frappe import msgprint, throw, _

from frappe.model.document import Document

class NamingSeries(Document):

	def get_transactions(self, arg=None):
		return {
			"transactions": "\n".join([''] + sorted(list(set(
				frappe.db.sql_list("""select parent
					from `tabDocField` where fieldname='naming_series'""")
				+ frappe.db.sql_list("""select dt from `tabCustom Field`
					where fieldname='naming_series'""")
				)))),
			"prefixes": "\n".join([''] + [i[0] for i in
				frappe.db.sql("""select name from tabSeries order by name""")])
		}

	def scrub_options_list(self, ol):
		options = filter(lambda x: x, [cstr(n).strip() for n in ol])
		return options

	def update_series(self, arg=None):
		"""update series list"""
		self.check_duplicate()
		series_list = self.set_options.split("\n")

		# set in doctype
		self.set_series_for(self.select_doc_for_series, series_list)

		# create series
		map(self.insert_series, [d.split('.')[0] for d in series_list])

		msgprint(_("Series Updated"))

		return self.get_transactions()

	def set_series_for(self, doctype, ol):
		options = self.scrub_options_list(ol)

		# validate names
		for i in options: self.validate_series_name(i)

		if self.user_must_always_select:
			options = [''] + options
			default = ''
		else:
			default = options[0]

		# update in property setter
		prop_dict = {'options': "\n".join(options), 'default': default}
		for prop in prop_dict:
			ps_exists = frappe.db.sql("""SELECT name FROM `tabProperty Setter`
					WHERE doc_type = %s AND field_name = 'naming_series'
					AND property = %s""", (doctype, prop))
			if ps_exists:
				ps = frappe.get_doc('Property Setter', ps_exists[0][0])
				ps.value = prop_dict[prop]
				ps.save()
			else:
				ps = frappe.get_doc({
					'doctype': 'Property Setter',
					'doctype_or_field': 'DocField',
					'doc_type': doctype,
					'field_name': 'naming_series',
					'property': prop,
					'value': prop_dict[prop],
					'property_type': 'Select',
					'__islocal': 1
				})
				ps.save()

		self.set_options = "\n".join(options)

		frappe.clear_cache(doctype=doctype)

	def check_duplicate(self):
		parent = list(set(
			frappe.db.sql_list("""select dt.name
				from `tabDocField` df, `tabDocType` dt
				where dt.name = df.parent and df.fieldname='naming_series' and dt.name != %s""",
				self.select_doc_for_series)
			+ frappe.db.sql_list("""select dt.name
				from `tabCustom Field` df, `tabDocType` dt
				where dt.name = df.dt and df.fieldname='naming_series' and dt.name != %s""",
				self.select_doc_for_series)
			))
		sr = [[frappe.get_meta(p).get_field("naming_series").options, p]
			for p in parent]

		dt = frappe.get_doc("DocType", self.select_doc_for_series)
		options = self.scrub_options_list(self.set_options.split("\n"))
		for series in options:
			dt.validate_series(series)
			for i in sr:
				if i[0]:
					existing_series = [d.split('.')[0] for d in i[0].split("\n")]
					if series.split(".")[0] in existing_series:
						frappe.throw(_("Series {0} already used in {1}").format(series,i[1]))

	def validate_series_name(self, n):
		import re
		if not re.match("^[a-zA-Z0-9- /.#]*$", n):
			throw(_('Special Characters except "-" and "/" not allowed in naming series'))

	def get_options(self, arg=''):
		return frappe.get_meta(self.select_doc_for_series).get_field("naming_series").options

	def get_current(self, arg=None):
		"""get series current"""
		if self.prefix:
			self.current_value = frappe.db.get_value("Series",
				self.prefix.split('.')[0], "current")

	def insert_series(self, series):
		"""insert series if missing"""
		if not frappe.db.exists('Series', series):
			frappe.db.sql("insert into tabSeries (name, current) values (%s, 0)", (series))

	def update_series_start(self):
		if self.prefix:
			prefix = self.prefix.split('.')[0]
			self.insert_series(prefix)
			frappe.db.sql("update `tabSeries` set current = %s where name = %s",
				(self.current_value, prefix))
			msgprint(_("Series Updated Successfully"))
		else:
			msgprint(_("Please select prefix first"))

def set_by_naming_series(doctype, fieldname, naming_series, hide_name_field=True):
	from frappe.core.doctype.property_setter.property_setter import make_property_setter
	if naming_series:
		make_property_setter(doctype, "naming_series", "hidden", 0, "Check")
		make_property_setter(doctype, "naming_series", "reqd", 1, "Check")

		# set values for mandatory
		frappe.db.sql("""update `tab{doctype}` set naming_series={s} where
			ifnull(naming_series, '')=''""".format(doctype=doctype, s="%s"),
			get_default_naming_series(doctype))

		if hide_name_field:
			make_property_setter(doctype, fieldname, "reqd", 0, "Check")
			make_property_setter(doctype, fieldname, "hidden", 1, "Check")
	else:
		make_property_setter(doctype, "naming_series", "reqd", 0, "Check")
		make_property_setter(doctype, "naming_series", "hidden", 1, "Check")

		if hide_name_field:
			make_property_setter(doctype, fieldname, "hidden", 0, "Check")
			make_property_setter(doctype, fieldname, "reqd", 1, "Check")

			# set values for mandatory
			frappe.db.sql("""update `tab{doctype}` set `{fieldname}`=`name` where
				ifnull({fieldname}, '')=''""".format(doctype=doctype, fieldname=fieldname))

def get_default_naming_series(doctype):
	naming_series = frappe.get_meta(doctype).get_field("naming_series").options or ""
	naming_series = naming_series.split("\n")
	return naming_series[0] or naming_series[1]

########NEW FILE########
__FILENAME__ = notification_control
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe import _

from frappe.model.document import Document

class NotificationControl(Document):
	def get_message(self, arg):
		fn = arg.lower().replace(' ', '_') + '_message'
		v = frappe.db.sql("select value from tabSingles where field=%s and doctype=%s", (fn, 'Notification Control'))
		return v and v[0][0] or ''

	def set_message(self, arg = ''):
		fn = self.select_transaction.lower().replace(' ', '_') + '_message'
		frappe.db.set(self, fn, self.custom_message)
		frappe.msgprint(_("Message updated"))


########NEW FILE########
__FILENAME__ = print_heading
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class PrintHeading(Document):
	pass
########NEW FILE########
__FILENAME__ = test_print_heading
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Print Heading')
########NEW FILE########
__FILENAME__ = quotation_lost_reason
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class QuotationLostReason(Document):
	pass
########NEW FILE########
__FILENAME__ = test_quotation_lost_reason
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Quotation Lost Reason')
########NEW FILE########
__FILENAME__ = sales_email_settings
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.utils import cint

from frappe.model.document import Document

class SalesEmailSettings(Document):
		
	def validate(self):
		if cint(self.extract_emails) and not (self.email_id and self.host and \
			self.username and self.password):
			
			frappe.msgprint(_("""Host, Email and Password required if emails are to be pulled"""),
				raise_exception=True)
########NEW FILE########
__FILENAME__ = sales_partner
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cint, cstr, filter_strip_join
from frappe.website.website_generator import WebsiteGenerator

class SalesPartner(WebsiteGenerator):
	def autoname(self):
		self.name = self.partner_name

	def validate(self):
		if self.partner_website and not self.partner_website.startswith("http"):
			self.partner_website = "http://" + self.partner_website

	def get_contacts(self, nm):
		if nm:
			return frappe.db.convert_to_lists(frappe.db.sql("""
				select name, CONCAT(IFNULL(first_name,''),
					' ',IFNULL(last_name,'')),contact_no,email_id
				from `tabContact` where sales_partner = %s""", nm))
		else:
			return ''

	def get_page_title(self):
		return self.partner_name

########NEW FILE########
__FILENAME__ = test_sales_partner
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Sales Partner')
########NEW FILE########
__FILENAME__ = sales_person
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import flt
from frappe.utils.nestedset import NestedSet

class SalesPerson(NestedSet):
	nsm_parent_field = 'parent_sales_person';

	def validate(self):
		for d in self.get('target_details'):
			if not flt(d.target_qty) and not flt(d.target_amount):
				frappe.throw(_("Either target qty or target amount is mandatory."))

	def on_update(self):
		super(SalesPerson, self).on_update()
		self.validate_one_root()

	def get_email_id(self):
		if self.employee:
			user = frappe.db.get_value("Employee", self.employee, "user_id")
			if not user:
				frappe.throw(_("User ID not set for Employee {0}").format(self.employee))
			else:
				return frappe.db.get_value("User", user, "email") or user

########NEW FILE########
__FILENAME__ = test_sales_person
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

test_dependencies = ["Employee"]

import frappe
test_records = frappe.get_test_records('Sales Person')
########NEW FILE########
__FILENAME__ = sms_parameter
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SMSParameter(Document):
	pass
########NEW FILE########
__FILENAME__ = sms_settings
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SMSSettings(Document):
	pass
########NEW FILE########
__FILENAME__ = supplier_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SupplierType(Document):
	pass
########NEW FILE########
__FILENAME__ = test_supplier_type
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Supplier Type')
########NEW FILE########
__FILENAME__ = target_detail
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class TargetDetail(Document):
	pass
########NEW FILE########
__FILENAME__ = terms_and_conditions
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class TermsandConditions(Document):
	pass
########NEW FILE########
__FILENAME__ = test_terms_and_conditions
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Terms And Conditions')
########NEW FILE########
__FILENAME__ = territory
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe


from frappe.utils import flt
from frappe import _

from frappe.utils.nestedset import NestedSet

class Territory(NestedSet):
	nsm_parent_field = 'parent_territory'

	def validate(self):
		for d in self.get('target_details'):
			if not flt(d.target_qty) and not flt(d.target_amount):
				frappe.throw(_("Either target qty or target amount is mandatory"))

	def on_update(self):
		super(Territory, self).on_update()
		self.validate_one_root()


########NEW FILE########
__FILENAME__ = test_territory
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Territory')
########NEW FILE########
__FILENAME__ = test_uom
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Uom')
########NEW FILE########
__FILENAME__ = uom
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class UOM(Document):
	pass
########NEW FILE########
__FILENAME__ = website_item_group
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# MIT License. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class WebsiteItemGroup(Document):
	pass
########NEW FILE########
__FILENAME__ = install
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals

import frappe

from frappe import _

def after_install():
	frappe.get_doc({'doctype': "Role", "role_name": "Analytics"}).insert()
	set_single_defaults()
	import_country_and_currency()
	from erpnext.accounts.doctype.chart_of_accounts.import_charts import import_charts
	import_charts()
	frappe.db.set_default('desktop:home_page', 'setup-wizard')
	feature_setup()
	from erpnext.setup.page.setup_wizard.setup_wizard import add_all_roles_to
	add_all_roles_to("Administrator")
	frappe.db.commit()

def import_country_and_currency():
	from frappe.country_info import get_all
	data = get_all()

	for name in data:
		country = frappe._dict(data[name])
		if not frappe.db.exists("Country", name):
			frappe.get_doc({
				"doctype": "Country",
				"country_name": name,
				"code": country.code,
				"date_format": country.date_format or "dd-mm-yyyy",
				"time_zones": "\n".join(country.timezones or [])
			}).insert()

		if country.currency and not frappe.db.exists("Currency", country.currency):
			frappe.get_doc({
				"doctype": "Currency",
				"currency_name": country.currency,
				"fraction": country.currency_fraction,
				"symbol": country.currency_symbol,
				"fraction_units": country.currency_fraction_units,
				"number_format": country.number_format
			}).insert()

	# enable frequently used currencies
	for currency in ("INR", "USD", "GBP", "EUR", "AED", "AUD", "JPY", "CNY", "CHF"):
		frappe.db.set_value("Currency", currency, "enabled", 1)

def feature_setup():
	"""save global defaults and features setup"""
	doc = frappe.get_doc("Features Setup", "Features Setup")
	doc.ignore_permissions = True

	# store value as 1 for all these fields
	flds = ['fs_item_serial_nos', 'fs_item_batch_nos', 'fs_brands', 'fs_item_barcode',
		'fs_item_advanced', 'fs_packing_details', 'fs_item_group_in_details',
		'fs_exports', 'fs_imports', 'fs_discounts', 'fs_purchase_discounts',
		'fs_after_sales_installations', 'fs_projects', 'fs_sales_extras',
		'fs_recurring_invoice', 'fs_pos', 'fs_manufacturing', 'fs_quality',
		'fs_page_break', 'fs_more_info', 'fs_pos_view'
	]
	for f in flds:
		doc.set(f, 1)
	doc.save()

def set_single_defaults():
	for dt in frappe.db.sql_list("""select name from `tabDocType` where issingle=1"""):
		default_values = frappe.db.sql("""select fieldname, `default` from `tabDocField`
			where parent=%s""", dt)
		if default_values:
			try:
				b = frappe.get_doc(dt, dt)
				for fieldname, value in default_values:
					b.set(fieldname, value)
				b.save()
			except frappe.MandatoryError:
				pass

	frappe.db.set_default("date_format", "dd-mm-yyyy")

########NEW FILE########
__FILENAME__ = default_website
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe import _
from frappe.utils import nowdate

class website_maker(object):
	def __init__(self, company, tagline, user):
		self.company = company
		self.tagline = tagline
		self.user = user
		self.make_web_page()
		self.make_style_settings()
		self.make_website_settings()
		self.make_blog()

	def make_web_page(self):
		# home page
		self.webpage = frappe.get_doc({
			"doctype": "Web Page",
			"title": self.company,
			"published": 1,
			"header": "<h1>{0}</h1>".format(self.tagline or "Headline")+\
				'<p>'+_("This is an example website auto-generated from ERPNext")+"</p>"+\
				'<p><a class="btn btn-primary" href="/login">Login</a></p>',
			"description": self.company + ":" + (self.tagline or ""),
			"css": frappe.get_template("setup/page/setup_wizard/sample_home_page.css").render(),
			"main_section": frappe.get_template("setup/page/setup_wizard/sample_home_page.html").render({
				"company": self.company, "tagline": (self.tagline or "")
			})
		}).insert()

	def make_style_settings(self):
		style_settings = frappe.get_doc("Style Settings", "Style Settings")
		style_settings.top_bar_background = "F2F2F2"
		style_settings.font_size = "15px"
		style_settings.save()

	def make_website_settings(self):
		# update in home page in settings
		website_settings = frappe.get_doc("Website Settings", "Website Settings")
		website_settings.home_page = self.webpage.name
		website_settings.brand_html = self.company
		website_settings.copyright = self.company
		website_settings.top_bar_items = []
		website_settings.append("top_bar_items", {
			"doctype": "Top Bar Item",
			"label":"Contact",
			"url": "contact"
		})
		website_settings.append("top_bar_items", {
			"doctype": "Top Bar Item",
			"label":"Blog",
			"url": "blog"
		})
		website_settings.append("top_bar_items", {
			"doctype": "Top Bar Item",
			"label": _("Products"),
			"url": frappe.db.get_value("Website Route", {"ref_doctype":"Item Group"})
		})
		website_settings.save()

	def make_blog(self):
		blogger = frappe.new_doc("Blogger")
		user = frappe.get_doc("User", self.user)
		blogger.user = self.user
		blogger.full_name = user.first_name + (" " + user.last_name if user.last_name else "")
		blogger.short_name = user.first_name.lower()
		blogger.avatar = user.user_image
		blogger.insert()

		blog_category = frappe.get_doc({
			"doctype": "Blog Category",
			"category_name": "general",
			"published": 1,
			"title": _("General")
		}).insert()

		frappe.get_doc({
			"doctype": "Blog Post",
			"title": "Welcome",
			"published": 1,
			"published_on": nowdate(),
			"blogger": blogger.name,
			"blog_category": blog_category.name,
			"blog_intro": "My First Blog",
			"content": frappe.get_template("setup/page/setup_wizard/sample_blog_post.html").render(),
		}).insert()

def test():
	frappe.delete_doc("Web Page", "test-company")
	frappe.delete_doc("Blog Post", "welcome")
	frappe.delete_doc("Blogger", "administrator")
	frappe.delete_doc("Blog Category", "general")
	website_maker("Test Company", "Better Tools for Everyone", "Administrator")
	frappe.db.commit()

########NEW FILE########
__FILENAME__ = install_fixtures
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals

import frappe

from frappe import _

def install(country=None):
	records = [

		# item group
		{'doctype': 'Item Group', 'item_group_name': _('All Item Groups'),
			'is_group': 'Yes', 'parent_item_group': ''},
		{'doctype': 'Item Group', 'item_group_name': _('Products'),
			'is_group': 'No', 'parent_item_group': _('All Item Groups'), "show_in_website": 1 },
		{'doctype': 'Item Group', 'item_group_name': _('Raw Material'),
			'is_group': 'No', 'parent_item_group': _('All Item Groups') },
		{'doctype': 'Item Group', 'item_group_name': _('Services'),
			'is_group': 'No', 'parent_item_group': _('All Item Groups') },
		{'doctype': 'Item Group', 'item_group_name': _('Sub Assemblies'),
			'is_group': 'No', 'parent_item_group': _('All Item Groups') },
		{'doctype': 'Item Group', 'item_group_name': _('Consumable'),
			'is_group': 'No', 'parent_item_group': _('All Item Groups') },

		# deduction type
		{'doctype': 'Deduction Type', 'name': _('Income Tax'), 'description': _('Income Tax'), 'deduction_name': _('Income Tax')},

		# earning type
		{'doctype': 'Earning Type', 'name': _('Basic'), 'description': _('Basic'), 'earning_name': _('Basic'), 'taxable': 'Yes'},

		# expense claim type
		{'doctype': 'Expense Claim Type', 'name': _('Calls'), 'expense_type': _('Calls')},
		{'doctype': 'Expense Claim Type', 'name': _('Food'), 'expense_type': _('Food')},
		{'doctype': 'Expense Claim Type', 'name': _('Medical'), 'expense_type': _('Medical')},
		{'doctype': 'Expense Claim Type', 'name': _('Others'), 'expense_type': _('Others')},
		{'doctype': 'Expense Claim Type', 'name': _('Travel'), 'expense_type': _('Travel')},

		# leave type
		{'doctype': 'Leave Type', 'leave_type_name': _('Casual Leave'), 'name': _('Casual Leave'), 'is_encash': 1, 'is_carry_forward': 1, 'max_days_allowed': '3', },
		{'doctype': 'Leave Type', 'leave_type_name': _('Compensatory Off'), 'name': _('Compensatory Off'), 'is_encash': 0, 'is_carry_forward': 0, },
		{'doctype': 'Leave Type', 'leave_type_name': _('Sick Leave'), 'name': _('Sick Leave'), 'is_encash': 0, 'is_carry_forward': 0, },
		{'doctype': 'Leave Type', 'leave_type_name': _('Privilege Leave'), 'name': _('Privilege Leave'), 'is_encash': 0, 'is_carry_forward': 0, },
		{'doctype': 'Leave Type', 'leave_type_name': _('Leave Without Pay'), 'name': _('Leave Without Pay'), 'is_encash': 0, 'is_carry_forward': 0, 'is_lwp':1},

		# Employment Type
		{'doctype': 'Employment Type', 'employee_type_name': _('Full-time')},
		{'doctype': 'Employment Type', 'employee_type_name': _('Part-time')},
		{'doctype': 'Employment Type', 'employee_type_name': _('Probation')},
		{'doctype': 'Employment Type', 'employee_type_name': _('Contract')},
		{'doctype': 'Employment Type', 'employee_type_name': _('Commission')},
		{'doctype': 'Employment Type', 'employee_type_name': _('Piecework')},
		{'doctype': 'Employment Type', 'employee_type_name': _('Intern')},
		{'doctype': 'Employment Type', 'employee_type_name': _('Apprentice')},

		# Department
		{'doctype': 'Department', 'department_name': _('Accounts')},
		{'doctype': 'Department', 'department_name': _('Marketing')},
		{'doctype': 'Department', 'department_name': _('Sales')},
		{'doctype': 'Department', 'department_name': _('Purchase')},
		{'doctype': 'Department', 'department_name': _('Operations')},
		{'doctype': 'Department', 'department_name': _('Production')},
		{'doctype': 'Department', 'department_name': _('Dispatch')},
		{'doctype': 'Department', 'department_name': _('Customer Service')},
		{'doctype': 'Department', 'department_name': _('Human Resources')},
		{'doctype': 'Department', 'department_name': _('Management')},
		{'doctype': 'Department', 'department_name': _('Quality Management')},
		{'doctype': 'Department', 'department_name': _('Research & Development')},
		{'doctype': 'Department', 'department_name': _('Legal')},

		# Designation
		{'doctype': 'Designation', 'designation_name': _('CEO')},
		{'doctype': 'Designation', 'designation_name': _('Manager')},
		{'doctype': 'Designation', 'designation_name': _('Analyst')},
		{'doctype': 'Designation', 'designation_name': _('Engineer')},
		{'doctype': 'Designation', 'designation_name': _('Accountant')},
		{'doctype': 'Designation', 'designation_name': _('Secretary')},
		{'doctype': 'Designation', 'designation_name': _('Associate')},
		{'doctype': 'Designation', 'designation_name': _('Administrative Officer')},
		{'doctype': 'Designation', 'designation_name': _('Business Development Manager')},
		{'doctype': 'Designation', 'designation_name': _('HR Manager')},
		{'doctype': 'Designation', 'designation_name': _('Project Manager')},
		{'doctype': 'Designation', 'designation_name': _('Head of Marketing and Sales')},
		{'doctype': 'Designation', 'designation_name': _('Software Developer')},
		{'doctype': 'Designation', 'designation_name': _('Designer')},
		{'doctype': 'Designation', 'designation_name': _('Assistant')},
		{'doctype': 'Designation', 'designation_name': _('Researcher')},

		# territory
		{'doctype': 'Territory', 'territory_name': _('All Territories'), 'is_group': 'Yes', 'name': _('All Territories'), 'parent_territory': ''},

		# customer group
		{'doctype': 'Customer Group', 'customer_group_name': _('All Customer Groups'), 'is_group': 'Yes', 	'name': _('All Customer Groups'), 'parent_customer_group': ''},
		{'doctype': 'Customer Group', 'customer_group_name': _('Individual'), 'is_group': 'No', 'parent_customer_group': _('All Customer Groups')},
		{'doctype': 'Customer Group', 'customer_group_name': _('Commercial'), 'is_group': 'No', 'parent_customer_group': _('All Customer Groups')},
		{'doctype': 'Customer Group', 'customer_group_name': _('Non Profit'), 'is_group': 'No', 'parent_customer_group': _('All Customer Groups')},
		{'doctype': 'Customer Group', 'customer_group_name': _('Government'), 'is_group': 'No', 'parent_customer_group': _('All Customer Groups')},

		# supplier type
		{'doctype': 'Supplier Type', 'supplier_type': _('Services')},
		{'doctype': 'Supplier Type', 'supplier_type': _('Local')},
		{'doctype': 'Supplier Type', 'supplier_type': _('Raw Material')},
		{'doctype': 'Supplier Type', 'supplier_type': _('Electrical')},
		{'doctype': 'Supplier Type', 'supplier_type': _('Hardware')},
		{'doctype': 'Supplier Type', 'supplier_type': _('Pharmaceutical')},
		{'doctype': 'Supplier Type', 'supplier_type': _('Distributor')},

		# Sales Person
		{'doctype': 'Sales Person', 'sales_person_name': _('Sales Team'), 'is_group': "Yes", "parent_sales_person": ""},

		# UOM
		{'uom_name': _('Unit'), 'doctype': 'UOM', 'name': _('Unit'), "must_be_whole_number": 1},
		{'uom_name': _('Box'), 'doctype': 'UOM', 'name': _('Box'), "must_be_whole_number": 1},
		{'uom_name': _('Kg'), 'doctype': 'UOM', 'name': _('Kg')},
		{'uom_name': _('Nos'), 'doctype': 'UOM', 'name': _('Nos'), "must_be_whole_number": 1},
		{'uom_name': _('Pair'), 'doctype': 'UOM', 'name': _('Pair'), "must_be_whole_number": 1},
		{'uom_name': _('Set'), 'doctype': 'UOM', 'name': _('Set'), "must_be_whole_number": 1},
		{'uom_name': _('Hour'), 'doctype': 'UOM', 'name': _('Hour')},
		{'uom_name': _('Minute'), 'doctype': 'UOM', 'name': _('Minute')},

		# Mode of Payment
		{'doctype': 'Mode of Payment', 'mode_of_payment': 'Check' if country=="United States" else _('Cheque')},
		{'doctype': 'Mode of Payment', 'mode_of_payment': _('Cash')},
		{'doctype': 'Mode of Payment', 'mode_of_payment': _('Credit Card')},
		{'doctype': 'Mode of Payment', 'mode_of_payment': _('Wire Transfer')},
		{'doctype': 'Mode of Payment', 'mode_of_payment': _('Bank Draft')},

		# Activity Type
		{'doctype': 'Activity Type', 'activity_type': _('Planning')},
		{'doctype': 'Activity Type', 'activity_type': _('Research')},
		{'doctype': 'Activity Type', 'activity_type': _('Proposal Writing')},
		{'doctype': 'Activity Type', 'activity_type': _('Execution')},
		{'doctype': 'Activity Type', 'activity_type': _('Communication')},

		# Industry Type
		{'doctype': 'Industry Type', 'industry': _('Accounting')},
		{'doctype': 'Industry Type', 'industry': _('Advertising')},
		{'doctype': 'Industry Type', 'industry': _('Aerospace')},
		{'doctype': 'Industry Type', 'industry': _('Agriculture')},
		{'doctype': 'Industry Type', 'industry': _('Airline')},
		{'doctype': 'Industry Type', 'industry': _('Apparel & Accessories')},
		{'doctype': 'Industry Type', 'industry': _('Automotive')},
		{'doctype': 'Industry Type', 'industry': _('Banking')},
		{'doctype': 'Industry Type', 'industry': _('Biotechnology')},
		{'doctype': 'Industry Type', 'industry': _('Broadcasting')},
		{'doctype': 'Industry Type', 'industry': _('Brokerage')},
		{'doctype': 'Industry Type', 'industry': _('Chemical')},
		{'doctype': 'Industry Type', 'industry': _('Computer')},
		{'doctype': 'Industry Type', 'industry': _('Consulting')},
		{'doctype': 'Industry Type', 'industry': _('Consumer Products')},
		{'doctype': 'Industry Type', 'industry': _('Cosmetics')},
		{'doctype': 'Industry Type', 'industry': _('Defense')},
		{'doctype': 'Industry Type', 'industry': _('Department Stores')},
		{'doctype': 'Industry Type', 'industry': _('Education')},
		{'doctype': 'Industry Type', 'industry': _('Electronics')},
		{'doctype': 'Industry Type', 'industry': _('Energy')},
		{'doctype': 'Industry Type', 'industry': _('Entertainment & Leisure')},
		{'doctype': 'Industry Type', 'industry': _('Executive Search')},
		{'doctype': 'Industry Type', 'industry': _('Financial Services')},
		{'doctype': 'Industry Type', 'industry': _('Food, Beverage & Tobacco')},
		{'doctype': 'Industry Type', 'industry': _('Grocery')},
		{'doctype': 'Industry Type', 'industry': _('Health Care')},
		{'doctype': 'Industry Type', 'industry': _('Internet Publishing')},
		{'doctype': 'Industry Type', 'industry': _('Investment Banking')},
		{'doctype': 'Industry Type', 'industry': _('Legal')},
		{'doctype': 'Industry Type', 'industry': _('Manufacturing')},
		{'doctype': 'Industry Type', 'industry': _('Motion Picture & Video')},
		{'doctype': 'Industry Type', 'industry': _('Music')},
		{'doctype': 'Industry Type', 'industry': _('Newspaper Publishers')},
		{'doctype': 'Industry Type', 'industry': _('Online Auctions')},
		{'doctype': 'Industry Type', 'industry': _('Pension Funds')},
		{'doctype': 'Industry Type', 'industry': _('Pharmaceuticals')},
		{'doctype': 'Industry Type', 'industry': _('Private Equity')},
		{'doctype': 'Industry Type', 'industry': _('Publishing')},
		{'doctype': 'Industry Type', 'industry': _('Real Estate')},
		{'doctype': 'Industry Type', 'industry': _('Retail & Wholesale')},
		{'doctype': 'Industry Type', 'industry': _('Securities & Commodity Exchanges')},
		{'doctype': 'Industry Type', 'industry': _('Service')},
		{'doctype': 'Industry Type', 'industry': _('Soap & Detergent')},
		{'doctype': 'Industry Type', 'industry': _('Software')},
		{'doctype': 'Industry Type', 'industry': _('Sports')},
		{'doctype': 'Industry Type', 'industry': _('Technology')},
		{'doctype': 'Industry Type', 'industry': _('Telecommunications')},
		{'doctype': 'Industry Type', 'industry': _('Television')},
		{'doctype': 'Industry Type', 'industry': _('Transportation')},
		{'doctype': 'Industry Type', 'industry': _('Venture Capital')}
	]

	from frappe.modules import scrub
	for r in records:
		doc = frappe.get_doc(r)

		# ignore mandatory for root
		parent_link_field = ("parent_" + scrub(doc.doctype))
		if doc.meta.get_field(parent_link_field) and not doc.get(parent_link_field):
			doc.ignore_mandatory = True

		doc.insert()

########NEW FILE########
__FILENAME__ = utils
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _, throw

def get_company_currency(company):
	currency = frappe.db.get_value("Company", company, "default_currency")
	if not currency:
		currency = frappe.db.get_default("currency")
	if not currency:
		throw(_('Please specify Default Currency in Company Master and Global Defaults'))

	return currency

def get_root_of(doctype):
	"""Get root element of a DocType with a tree structure"""
	result = frappe.db.sql_list("""select name from `tab%s`
		where lft=1 and rgt=(select max(rgt) from `tab%s` where docstatus < 2)""" %
		(doctype, doctype))
	return result[0] if result else None

def get_ancestors_of(doctype, name):
	"""Get ancestor elements of a DocType with a tree structure"""
	lft, rgt = frappe.db.get_value(doctype, name, ["lft", "rgt"])
	result = frappe.db.sql_list("""select name from `tab%s`
		where lft<%s and rgt>%s order by lft desc""" % (doctype, "%s", "%s"), (lft, rgt))
	return result or []

@frappe.whitelist()
def get_price_list_currency(price_list):
	price_list_currency = frappe.db.get_value("Price List", {"name": price_list,
		"enabled": 1}, "currency")

	if not price_list_currency:
		throw(_("Price List {0} is disabled").format(price_list))
	else:
		return {"price_list_currency": price_list_currency}

def before_tests():
	# complete setup if missing
	from erpnext.setup.page.setup_wizard.setup_wizard import setup_account
	if not frappe.get_list("Item Group"):
		setup_account({
			"currency"			:"USD",
			"first_name"		:"Test",
			"last_name"			:"User",
			"company_name"		:"Wind Power LLC",
			"timezone"			:"America/New_York",
			"company_abbr"		:"WP",
			"industry"			:"Manufacturing",
			"country"			:"United States",
			"fy_start_date"		:"2014-01-01",
			"fy_end_date"		:"2014-12-31",
			"language"			:"english",
			"company_tagline"	:"Testing",
			"email"				:"test@erpnext.com",
			"password"			:"test"
		})

	frappe.db.sql("delete from `tabLeave Allocation`")
	frappe.db.sql("delete from `tabLeave Application`")
	frappe.db.sql("delete from `tabSalary Slip`")
	frappe.db.sql("delete from `tabItem Price`")
	frappe.db.commit()

########NEW FILE########
__FILENAME__ = boot
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt"


from __future__ import unicode_literals
import frappe

def boot_session(bootinfo):
	"""boot session - send website info if guest"""
	import frappe
	
	bootinfo['custom_css'] = frappe.db.get_value('Style Settings', None, 'custom_css') or ''
	bootinfo['website_settings'] = frappe.get_doc('Website Settings')

	if frappe.session['user']!='Guest':
		bootinfo['letter_heads'] = get_letter_heads()
		
		load_country_and_currency(bootinfo)
		
		bootinfo['notification_settings'] = frappe.get_doc("Notification Control", 
			"Notification Control")
				
		# if no company, show a dialog box to create a new company
		bootinfo["customer_count"] = frappe.db.sql("""select count(*) from tabCustomer""")[0][0]

		if not bootinfo["customer_count"]:
			bootinfo['setup_complete'] = frappe.db.sql("""select name from 
				tabCompany limit 1""") and 'Yes' or 'No'
		
		bootinfo['docs'] += frappe.db.sql("""select name, default_currency, cost_center
            from `tabCompany`""", as_dict=1, update={"doctype":":Company"})

def load_country_and_currency(bootinfo):
	country = frappe.db.get_default("country")
	if country and frappe.db.exists("Country", country):
		bootinfo["docs"] += [frappe.get_doc("Country", country)]
		
	bootinfo["docs"] += frappe.db.sql("""select * from tabCurrency
		where ifnull(enabled,0)=1""", as_dict=1, update={"doctype":":Currency"})

def get_letter_heads():
	import frappe
	ret = frappe.db.sql("""select name, content from `tabLetter Head` 
		where ifnull(disabled,0)=0""")
	return dict(ret)
	

########NEW FILE########
__FILENAME__ = event_handlers
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt"


from __future__ import unicode_literals
import frappe
from frappe.utils import nowtime
from frappe.utils.user import get_user_fullname
from erpnext.home import make_feed

def on_session_creation(login_manager):
	"""make feed"""
	if frappe.session['user'] != 'Guest':
		# create feed
		make_feed('Login', 'User', login_manager.user, login_manager.user,
			'%s logged in at %s' % (get_user_fullname(login_manager.user), nowtime()),
			login_manager.user=='Administrator' and '#8CA2B3' or '#1B750D')

########NEW FILE########
__FILENAME__ = notifications
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def get_notification_config():
	return { "for_doctype": 
		{
			"Support Ticket": {"status":"Open"},
			"Customer Issue": {"status":"Open"},
			"Task": {"status":"Open"},
			"Lead": {"status":"Open"},
			"Contact": {"status":"Open"},
			"Opportunity": {"docstatus":0},
			"Quotation": {"docstatus":0},
			"Sales Order": {"docstatus":0},
			"Journal Voucher": {"docstatus":0},
			"Sales Invoice": {"docstatus":0},
			"Purchase Invoice": {"docstatus":0},
			"Leave Application": {"status":"Open"},
			"Expense Claim": {"approval_status":"Draft"},
			"Job Applicant": {"status":"Open"},
			"Purchase Receipt": {"docstatus":0},
			"Delivery Note": {"docstatus":0},
			"Stock Entry": {"docstatus":0},
			"Material Request": {"docstatus":0},
			"Purchase Order": {"docstatus":0},
			"Production Order": {"docstatus":0},
			"BOM": {"docstatus":0},
			"Timesheet": {"docstatus":0},
			"Time Log": {"status":"Draft"},
			"Time Log Batch": {"status":"Draft"},
		}
	}
########NEW FILE########
__FILENAME__ = report_data_map
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals

# mappings for table dumps
# "remember to add indexes!"

data_map = {
	"Company": {
		"columns": ["name"],
		"conditions": ["docstatus < 2"]
	},
	"Fiscal Year": {
		"columns": ["name", "year_start_date", "year_end_date"],
		"conditions": ["docstatus < 2"],
	},

	# Accounts
	"Account": {
		"columns": ["name", "parent_account", "lft", "rgt", "report_type", 
			"company", "group_or_ledger"],
		"conditions": ["docstatus < 2"],
		"order_by": "lft",
		"links": {
			"company": ["Company", "name"],
		}
		
	},
	"Cost Center": {
		"columns": ["name", "lft", "rgt"],
		"conditions": ["docstatus < 2"],
		"order_by": "lft"
	},
	"GL Entry": {
		"columns": ["name", "account", "posting_date", "cost_center", "debit", "credit", 
			"is_opening", "company", "voucher_type", "voucher_no", "remarks"],
		"order_by": "posting_date, account",
		"links": {
			"account": ["Account", "name"],
			"company": ["Company", "name"],
			"cost_center": ["Cost Center", "name"]
		}
	},

	# Stock
	"Item": {
		"columns": ["name", "if(item_name=name, '', item_name) as item_name", "description", 
			"item_group as parent_item_group", "stock_uom", "brand", "valuation_method", 
			"re_order_level", "re_order_qty"],
		# "conditions": ["docstatus < 2"],
		"order_by": "name",
		"links": {
			"parent_item_group": ["Item Group", "name"],
			"brand": ["Brand", "name"]
		}
	},
	"Item Group": {
		"columns": ["name", "parent_item_group"],
		# "conditions": ["docstatus < 2"],
		"order_by": "lft"
	},
	"Brand": {
		"columns": ["name"],
		"conditions": ["docstatus < 2"],
		"order_by": "name"
	},
	"Project": {
		"columns": ["name"],
		"conditions": ["docstatus < 2"],
		"order_by": "name"
	},
	"Warehouse": {
		"columns": ["name"],
		"conditions": ["docstatus < 2"],
		"order_by": "name"
	},
	"Stock Ledger Entry": {
		"columns": ["name", "posting_date", "posting_time", "item_code", "warehouse", 
			"actual_qty as qty", "voucher_type", "voucher_no", "project",
			"ifnull(incoming_rate,0) as incoming_rate", "stock_uom", "serial_no"],
		"order_by": "posting_date, posting_time, name",
		"links": {
			"item_code": ["Item", "name"],
			"warehouse": ["Warehouse", "name"],
			"project": ["Project", "name"]
		},
		"force_index": "posting_sort_index"
	},
	"Serial No": {
		"columns": ["name", "purchase_rate as incoming_rate"],
		"conditions": ["docstatus < 2"],
		"order_by": "name"
	},
	"Stock Entry": {
		"columns": ["name", "purpose"],
		"conditions": ["docstatus=1"],
		"order_by": "posting_date, posting_time, name",
	},
	"Production Order": {
		"columns": ["name", "production_item as item_code", 
			"(ifnull(qty, 0) - ifnull(produced_qty, 0)) as qty", 
			"fg_warehouse as warehouse"],
		"conditions": ["docstatus=1", "status != 'Stopped'", "ifnull(fg_warehouse, '')!=''",
			"ifnull(qty, 0) > ifnull(produced_qty, 0)"],
		"links": {
			"item_code": ["Item", "name"],
			"warehouse": ["Warehouse", "name"]
		},
	},
	"Material Request Item": {
		"columns": ["item.name as name", "item_code", "warehouse", 
			"(ifnull(qty, 0) - ifnull(ordered_qty, 0)) as qty"],
		"from": "`tabMaterial Request Item` item, `tabMaterial Request` main",
		"conditions": ["item.parent = main.name", "main.docstatus=1", "main.status != 'Stopped'",
			"ifnull(warehouse, '')!=''", "ifnull(qty, 0) > ifnull(ordered_qty, 0)"],
		"links": {
			"item_code": ["Item", "name"],
			"warehouse": ["Warehouse", "name"]
		},
	},
	"Purchase Order Item": {
		"columns": ["item.name as name", "item_code", "warehouse", 
			"(ifnull(qty, 0) - ifnull(received_qty, 0)) as qty"],
		"from": "`tabPurchase Order Item` item, `tabPurchase Order` main",
		"conditions": ["item.parent = main.name", "main.docstatus=1", "main.status != 'Stopped'", 
			"ifnull(warehouse, '')!=''", "ifnull(qty, 0) > ifnull(received_qty, 0)"],
		"links": {
			"item_code": ["Item", "name"],
			"warehouse": ["Warehouse", "name"]
		},
	},
	
	"Sales Order Item": {
		"columns": ["item.name as name", "item_code", "(ifnull(qty, 0) - ifnull(delivered_qty, 0)) as qty", "warehouse"],
		"from": "`tabSales Order Item` item, `tabSales Order` main",
		"conditions": ["item.parent = main.name", "main.docstatus=1", "main.status != 'Stopped'", 
			"ifnull(warehouse, '')!=''", "ifnull(qty, 0) > ifnull(delivered_qty, 0)"],
		"links": {
			"item_code": ["Item", "name"],
			"warehouse": ["Warehouse", "name"]
		},
	},

	# Sales
	"Customer": {
		"columns": ["name", "if(customer_name=name, '', customer_name) as customer_name", 
			"customer_group as parent_customer_group", "territory as parent_territory"],
		"conditions": ["docstatus < 2"],
		"order_by": "name",
		"links": {
			"parent_customer_group": ["Customer Group", "name"],
			"parent_territory": ["Territory", "name"],
		}
	},
	"Customer Group": {
		"columns": ["name", "parent_customer_group"],
		"conditions": ["docstatus < 2"],
		"order_by": "lft"
	},
	"Territory": {
		"columns": ["name", "parent_territory"],
		"conditions": ["docstatus < 2"],
		"order_by": "lft"
	},
	"Sales Invoice": {
		"columns": ["name", "customer", "posting_date", "company"],
		"conditions": ["docstatus=1"],
		"order_by": "posting_date",
		"links": {
			"customer": ["Customer", "name"],
			"company":["Company", "name"]
		}
	},
	"Sales Invoice Item": {
		"columns": ["name", "parent", "item_code", "qty", "base_amount"],
		"conditions": ["docstatus=1", "ifnull(parent, '')!=''"],
		"order_by": "parent",
		"links": {
			"parent": ["Sales Invoice", "name"],
			"item_code": ["Item", "name"]
		}
	},
	"Sales Order": {
		"columns": ["name", "customer", "transaction_date as posting_date", "company"],
		"conditions": ["docstatus=1"],
		"order_by": "transaction_date",
		"links": {
			"customer": ["Customer", "name"],
			"company":["Company", "name"]
		}
	},
	"Sales Order Item[Sales Analytics]": {
		"columns": ["name", "parent", "item_code", "qty", "base_amount"],
		"conditions": ["docstatus=1", "ifnull(parent, '')!=''"],
		"order_by": "parent",
		"links": {
			"parent": ["Sales Order", "name"],
			"item_code": ["Item", "name"]
		}
	},
	"Delivery Note": {
		"columns": ["name", "customer", "posting_date", "company"],
		"conditions": ["docstatus=1"],
		"order_by": "posting_date",
		"links": {
			"customer": ["Customer", "name"],
			"company":["Company", "name"]
		}
	},
	"Delivery Note Item[Sales Analytics]": {
		"columns": ["name", "parent", "item_code", "qty", "base_amount"],
		"conditions": ["docstatus=1", "ifnull(parent, '')!=''"],
		"order_by": "parent",
		"links": {
			"parent": ["Delivery Note", "name"],
			"item_code": ["Item", "name"]
		}
	},
	"Supplier": {
		"columns": ["name", "if(supplier_name=name, '', supplier_name) as supplier_name", 
			"supplier_type as parent_supplier_type"],
		"conditions": ["docstatus < 2"],
		"order_by": "name",
		"links": {
			"parent_supplier_type": ["Supplier Type", "name"],
		}
	},
	"Supplier Type": {
		"columns": ["name"],
		"conditions": ["docstatus < 2"],
		"order_by": "name"
	},
	"Purchase Invoice": {
		"columns": ["name", "supplier", "posting_date", "company"],
		"conditions": ["docstatus=1"],
		"order_by": "posting_date",
		"links": {
			"supplier": ["Supplier", "name"],
			"company":["Company", "name"]
		}
	},
	"Purchase Invoice Item": {
		"columns": ["name", "parent", "item_code", "qty", "base_amount"],
		"conditions": ["docstatus=1", "ifnull(parent, '')!=''"],
		"order_by": "parent",
		"links": {
			"parent": ["Purchase Invoice", "name"],
			"item_code": ["Item", "name"]
		}
	},
	"Purchase Order": {
		"columns": ["name", "supplier", "transaction_date as posting_date", "company"],
		"conditions": ["docstatus=1"],
		"order_by": "posting_date",
		"links": {
			"supplier": ["Supplier", "name"],
			"company":["Company", "name"]
		}
	},
	"Purchase Order Item[Purchase Analytics]": {
		"columns": ["name", "parent", "item_code", "qty", "base_amount"],
		"conditions": ["docstatus=1", "ifnull(parent, '')!=''"],
		"order_by": "parent",
		"links": {
			"parent": ["Purchase Order", "name"],
			"item_code": ["Item", "name"]
		}
	},
	"Purchase Receipt": {
		"columns": ["name", "supplier", "posting_date", "company"],
		"conditions": ["docstatus=1"],
		"order_by": "posting_date",
		"links": {
			"supplier": ["Supplier", "name"],
			"company":["Company", "name"]
		}
	},
	"Purchase Receipt Item[Purchase Analytics]": {
		"columns": ["name", "parent", "item_code", "qty", "base_amount"],
		"conditions": ["docstatus=1", "ifnull(parent, '')!=''"],
		"order_by": "parent",
		"links": {
			"parent": ["Purchase Receipt", "name"],
			"item_code": ["Item", "name"]
		}
	},
	# Support
	"Support Ticket": {
		"columns": ["name","status","creation","resolution_date","first_responded_on"],
		"conditions": ["docstatus < 2"],
		"order_by": "creation"
	}
	
}

########NEW FILE########
__FILENAME__ = webutils
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals

import frappe

def update_website_context(context):
	if not context.get("favicon"):
		context["favicon"] = "app/images/favicon.ico"
########NEW FILE########
__FILENAME__ = batch
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class Batch(Document):
	pass
########NEW FILE########
__FILENAME__ = bin
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt, nowdate
import frappe.defaults
from frappe.model.document import Document

class Bin(Document):
	def validate(self):
		if self.get("__islocal") or not self.stock_uom:
			self.stock_uom = frappe.db.get_value('Item', self.item_code, 'stock_uom')
				
		self.validate_mandatory()
		
		self.projected_qty = flt(self.actual_qty) + flt(self.ordered_qty) + \
		 	flt(self.indented_qty) + flt(self.planned_qty) - flt(self.reserved_qty)
		
	def validate_mandatory(self):
		qf = ['actual_qty', 'reserved_qty', 'ordered_qty', 'indented_qty']
		for f in qf:
			if (not getattr(self, f, None)) or (not self.get(f)): 
				self.set(f, 0.0)
		
	def update_stock(self, args):
		self.update_qty(args)
		
		if args.get("actual_qty"):
			from erpnext.stock.stock_ledger import update_entries_after
			
			if not args.get("posting_date"):
				args["posting_date"] = nowdate()
			
			# update valuation and qty after transaction for post dated entry
			update_entries_after({
				"item_code": self.item_code,
				"warehouse": self.warehouse,
				"posting_date": args.get("posting_date"),
				"posting_time": args.get("posting_time")
			})
			
	def update_qty(self, args):
		# update the stock values (for current quantities)
		
		self.actual_qty = flt(self.actual_qty) + flt(args.get("actual_qty"))
		self.ordered_qty = flt(self.ordered_qty) + flt(args.get("ordered_qty"))
		self.reserved_qty = flt(self.reserved_qty) + flt(args.get("reserved_qty"))
		self.indented_qty = flt(self.indented_qty) + flt(args.get("indented_qty"))
		self.planned_qty = flt(self.planned_qty) + flt(args.get("planned_qty"))
		
		self.projected_qty = flt(self.actual_qty) + flt(self.ordered_qty) + \
		 	flt(self.indented_qty) + flt(self.planned_qty) - flt(self.reserved_qty)
		
		self.save()
		
	def get_first_sle(self):
		sle = frappe.db.sql("""
			select * from `tabStock Ledger Entry`
			where item_code = %s
			and warehouse = %s
			order by timestamp(posting_date, posting_time) asc, name asc
			limit 1
		""", (self.item_code, self.warehouse), as_dict=1)
		return sle and sle[0] or None
########NEW FILE########
__FILENAME__ = delivery_note
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import flt, cint

from frappe import msgprint, _
import frappe.defaults
from frappe.model.mapper import get_mapped_doc
from erpnext.stock.utils import update_bin
from erpnext.controllers.selling_controller import SellingController

class DeliveryNote(SellingController):
	tname = 'Delivery Note Item'
	fname = 'delivery_note_details'

	def __init__(self, arg1, arg2=None):
		super(DeliveryNote, self).__init__(arg1, arg2)
		self.status_updater = [{
			'source_dt': 'Delivery Note Item',
			'target_dt': 'Sales Order Item',
			'join_field': 'prevdoc_detail_docname',
			'target_field': 'delivered_qty',
			'target_parent_dt': 'Sales Order',
			'target_parent_field': 'per_delivered',
			'target_ref_field': 'qty',
			'source_field': 'qty',
			'percent_join_field': 'against_sales_order',
			'status_field': 'delivery_status',
			'keyword': 'Delivered'
		}]

	def onload(self):
		billed_qty = frappe.db.sql("""select sum(ifnull(qty, 0)) from `tabSales Invoice Item`
			where docstatus=1 and delivery_note=%s""", self.name)
		if billed_qty:
			total_qty = sum((item.qty for item in self.get("delivery_note_details")))
			self.get("__onload").billing_complete = (billed_qty[0][0] == total_qty)

	def get_portal_page(self):
		return "shipment" if self.docstatus==1 else None

	def set_actual_qty(self):
		for d in self.get('delivery_note_details'):
			if d.item_code and d.warehouse:
				actual_qty = frappe.db.sql("""select actual_qty from `tabBin`
					where item_code = %s and warehouse = %s""", (d.item_code, d.warehouse))
				d.actual_qty = actual_qty and flt(actual_qty[0][0]) or 0

	def so_required(self):
		"""check in manage account if sales order required or not"""
		if frappe.db.get_value("Selling Settings", None, 'so_required') == 'Yes':
			 for d in self.get('delivery_note_details'):
				 if not d.against_sales_order:
					 frappe.throw(_("Sales Order required for Item {0}").format(d.item_code))

	def validate(self):
		super(DeliveryNote, self).validate()

		from erpnext.utilities import validate_status
		validate_status(self.status, ["Draft", "Submitted", "Cancelled"])

		self.so_required()
		self.validate_proj_cust()
		self.check_stop_sales_order("against_sales_order")
		self.validate_for_items()
		self.validate_warehouse()
		self.validate_uom_is_integer("stock_uom", "qty")
		self.update_current_stock()
		self.validate_with_previous_doc()

		from erpnext.stock.doctype.packed_item.packed_item import make_packing_list
		make_packing_list(self, 'delivery_note_details')

		self.status = 'Draft'
		if not self.installation_status: self.installation_status = 'Not Installed'

	def validate_with_previous_doc(self):
		items = self.get("delivery_note_details")

		for fn in (("Sales Order", "against_sales_order"), ("Sales Invoice", "against_sales_invoice")):
			if filter(None, [getattr(d, fn[1], None) for d in items]):
				super(DeliveryNote, self).validate_with_previous_doc(self.tname, {
					fn[0]: {
						"ref_dn_field": fn[1],
						"compare_fields": [["customer", "="], ["company", "="], ["project_name", "="],
							["currency", "="]],
					},
				})

				if cint(frappe.defaults.get_global_default('maintain_same_sales_rate')):
					super(DeliveryNote, self).validate_with_previous_doc(self.tname, {
						fn[0] + " Item": {
							"ref_dn_field": "prevdoc_detail_docname",
							"compare_fields": [["rate", "="]],
							"is_child_table": True
						}
					})

	def validate_proj_cust(self):
		"""check for does customer belong to same project as entered.."""
		if self.project_name and self.customer:
			res = frappe.db.sql("""select name from `tabProject`
				where name = %s and (customer = %s or
					ifnull(customer,'')='')""", (self.project_name, self.customer))
			if not res:
				frappe.throw(_("Customer {0} does not belong to project {1}").format(self.customer, self.project_name))

	def validate_for_items(self):
		check_list, chk_dupl_itm = [], []
		for d in self.get('delivery_note_details'):
			e = [d.item_code, d.description, d.warehouse, d.against_sales_order or d.against_sales_invoice, d.batch_no or '']
			f = [d.item_code, d.description, d.against_sales_order or d.against_sales_invoice]

			if frappe.db.get_value("Item", d.item_code, "is_stock_item") == 'Yes':
				if e in check_list:
					msgprint(_("Note: Item {0} entered multiple times").format(d.item_code))
				else:
					check_list.append(e)
			else:
				if f in chk_dupl_itm:
					msgprint(_("Note: Item {0} entered multiple times").format(d.item_code))
				else:
					chk_dupl_itm.append(f)

	def validate_warehouse(self):
		for d in self.get_item_list():
			if frappe.db.get_value("Item", d['item_code'], "is_stock_item") == "Yes":
				if not d['warehouse']:
					frappe.throw(_("Warehouse required for stock Item {0}").format(d["item_code"]))


	def update_current_stock(self):
		for d in self.get('delivery_note_details'):
			bin = frappe.db.sql("select actual_qty from `tabBin` where item_code = %s and warehouse = %s", (d.item_code, d.warehouse), as_dict = 1)
			d.actual_qty = bin and flt(bin[0]['actual_qty']) or 0

		for d in self.get('packing_details'):
			bin = frappe.db.sql("select actual_qty, projected_qty from `tabBin` where item_code =	%s and warehouse = %s", (d.item_code, d.warehouse), as_dict = 1)
			d.actual_qty = bin and flt(bin[0]['actual_qty']) or 0
			d.projected_qty = bin and flt(bin[0]['projected_qty']) or 0

	def on_submit(self):
		self.validate_packed_qty()

		# Check for Approving Authority
		frappe.get_doc('Authorization Control').validate_approving_authority(self.doctype, self.company, self.grand_total, self)

		# update delivered qty in sales order
		self.update_prevdoc_status()

		# create stock ledger entry
		self.update_stock_ledger()

		self.credit_limit()

		self.make_gl_entries()

		# set DN status
		frappe.db.set(self, 'status', 'Submitted')


	def on_cancel(self):
		self.check_stop_sales_order("against_sales_order")
		self.check_next_docstatus()

		self.update_prevdoc_status()

		self.update_stock_ledger()

		frappe.db.set(self, 'status', 'Cancelled')
		self.cancel_packing_slips()

		self.make_cancel_gl_entries()

	def validate_packed_qty(self):
		"""
			Validate that if packed qty exists, it should be equal to qty
		"""
		if not any([flt(d.get('packed_qty')) for d in self.get(self.fname)]):
			return
		has_error = False
		for d in self.get(self.fname):
			if flt(d.get('qty')) != flt(d.get('packed_qty')):
				frappe.msgprint(_("Packed quantity must equal quantity for Item {0} in row {1}").format(d.item_code, d.idx))
				has_error = True
		if has_error:
			raise frappe.ValidationError

	def check_next_docstatus(self):
		submit_rv = frappe.db.sql("""select t1.name
			from `tabSales Invoice` t1,`tabSales Invoice Item` t2
			where t1.name = t2.parent and t2.delivery_note = %s and t1.docstatus = 1""",
			(self.name))
		if submit_rv:
			frappe.throw(_("Sales Invoice {0} has already been submitted").format(submit_rv[0][0]))

		submit_in = frappe.db.sql("""select t1.name
			from `tabInstallation Note` t1, `tabInstallation Note Item` t2
			where t1.name = t2.parent and t2.prevdoc_docname = %s and t1.docstatus = 1""",
			(self.name))
		if submit_in:
			frappe.throw(_("Installation Note {0} has already been submitted").format(submit_in[0][0]))

	def cancel_packing_slips(self):
		"""
			Cancel submitted packing slips related to this delivery note
		"""
		res = frappe.db.sql("""SELECT name FROM `tabPacking Slip` WHERE delivery_note = %s
			AND docstatus = 1""", self.name)

		if res:
			for r in res:
				ps = frappe.get_doc('Packing Slip', r[0])
				ps.cancel()
			frappe.msgprint(_("Packing Slip(s) cancelled"))


	def update_stock_ledger(self):
		sl_entries = []
		for d in self.get_item_list():
			if frappe.db.get_value("Item", d.item_code, "is_stock_item") == "Yes" \
					and d.warehouse:
				self.update_reserved_qty(d)

				sl_entries.append(self.get_sl_entries(d, {
					"actual_qty": -1*flt(d['qty']),
				}))

		self.make_sl_entries(sl_entries)

	def update_reserved_qty(self, d):
		if d['reserved_qty'] < 0 :
			# Reduce reserved qty from reserved warehouse mentioned in so
			if not d["reserved_warehouse"]:
				frappe.throw(_("Reserved Warehouse is missing in Sales Order"))

			args = {
				"item_code": d['item_code'],
				"warehouse": d["reserved_warehouse"],
				"voucher_type": self.doctype,
				"voucher_no": self.name,
				"reserved_qty": (self.docstatus==1 and 1 or -1)*flt(d['reserved_qty']),
				"posting_date": self.posting_date,
				"is_amended": self.amended_from and 'Yes' or 'No'
			}
			update_bin(args)

	def credit_limit(self):
		"""check credit limit of items in DN Detail which are not fetched from sales order"""
		amount, total = 0, 0
		for d in self.get('delivery_note_details'):
			if not (d.against_sales_order or d.against_sales_invoice):
				amount += d.base_amount
		if amount != 0:
			total = (amount/self.net_total)*self.grand_total
			self.check_credit(total)

def get_invoiced_qty_map(delivery_note):
	"""returns a map: {dn_detail: invoiced_qty}"""
	invoiced_qty_map = {}

	for dn_detail, qty in frappe.db.sql("""select dn_detail, qty from `tabSales Invoice Item`
		where delivery_note=%s and docstatus=1""", delivery_note):
			if not invoiced_qty_map.get(dn_detail):
				invoiced_qty_map[dn_detail] = 0
			invoiced_qty_map[dn_detail] += qty

	return invoiced_qty_map

@frappe.whitelist()
def make_sales_invoice(source_name, target_doc=None):
	invoiced_qty_map = get_invoiced_qty_map(source_name)

	def update_accounts(source, target):
		target.is_pos = 0
		target.run_method("set_missing_values")

		if len(target.get("entries")) == 0:
			frappe.throw(_("All these items have already been invoiced"))

		target.run_method("calculate_taxes_and_totals")

	def update_item(source_doc, target_doc, source_parent):
		target_doc.qty = source_doc.qty - invoiced_qty_map.get(source_doc.name, 0)

	doc = get_mapped_doc("Delivery Note", source_name, 	{
		"Delivery Note": {
			"doctype": "Sales Invoice",
			"validation": {
				"docstatus": ["=", 1]
			}
		},
		"Delivery Note Item": {
			"doctype": "Sales Invoice Item",
			"field_map": {
				"name": "dn_detail",
				"parent": "delivery_note",
				"prevdoc_detail_docname": "so_detail",
				"against_sales_order": "sales_order",
				"serial_no": "serial_no"
			},
			"postprocess": update_item,
			"filter": lambda d: d.qty - invoiced_qty_map.get(d.name, 0)<=0
		},
		"Sales Taxes and Charges": {
			"doctype": "Sales Taxes and Charges",
			"add_if_empty": True
		},
		"Sales Team": {
			"doctype": "Sales Team",
			"field_map": {
				"incentives": "incentives"
			},
			"add_if_empty": True
		}
	}, target_doc, update_accounts)

	return doc

@frappe.whitelist()
def make_installation_note(source_name, target_doc=None):
	def update_item(obj, target, source_parent):
		target.qty = flt(obj.qty) - flt(obj.installed_qty)
		target.serial_no = obj.serial_no

	doclist = get_mapped_doc("Delivery Note", source_name, 	{
		"Delivery Note": {
			"doctype": "Installation Note",
			"validation": {
				"docstatus": ["=", 1]
			}
		},
		"Delivery Note Item": {
			"doctype": "Installation Note Item",
			"field_map": {
				"name": "prevdoc_detail_docname",
				"parent": "prevdoc_docname",
				"parenttype": "prevdoc_doctype",
			},
			"postprocess": update_item,
			"condition": lambda doc: doc.installed_qty < doc.qty
		}
	}, target_doc)

	return doclist

########NEW FILE########
__FILENAME__ = test_delivery_note
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


from __future__ import unicode_literals
import unittest
import frappe
import frappe.defaults
from frappe.utils import cint
from erpnext.stock.doctype.purchase_receipt.test_purchase_receipt import get_gl_entries, set_perpetual_inventory, test_records as pr_test_records

def _insert_purchase_receipt(item_code=None):
	if not item_code:
		item_code = pr_test_records[0]["purchase_receipt_details"][0]["item_code"]

	pr = frappe.copy_doc(pr_test_records[0])
	pr.get("purchase_receipt_details")[0].item_code = item_code
	pr.insert()
	pr.submit()

class TestDeliveryNote(unittest.TestCase):
	def test_over_billing_against_dn(self):
		self.clear_stock_account_balance()
		_insert_purchase_receipt()

		from erpnext.stock.doctype.delivery_note.delivery_note import make_sales_invoice
		_insert_purchase_receipt()
		dn = frappe.copy_doc(test_records[0]).insert()

		self.assertRaises(frappe.ValidationError, make_sales_invoice,
			dn.name)

		dn = frappe.get_doc("Delivery Note", dn.name)
		dn.submit()
		si = make_sales_invoice(dn.name)

		self.assertEquals(len(si.get("entries")), len(dn.get("delivery_note_details")))

		# modify amount
		si.get("entries")[0].rate = 200
		self.assertRaises(frappe.ValidationError, frappe.get_doc(si).insert)


	def test_delivery_note_no_gl_entry(self):
		self.clear_stock_account_balance()
		set_perpetual_inventory(0)
		self.assertEqual(cint(frappe.defaults.get_global_default("auto_accounting_for_stock")), 0)

		_insert_purchase_receipt()

		dn = frappe.copy_doc(test_records[0])
		dn.insert()
		dn.submit()

		stock_value, stock_value_difference = frappe.db.get_value("Stock Ledger Entry",
			{"voucher_type": "Delivery Note", "voucher_no": dn.name,
				"item_code": "_Test Item"}, ["stock_value", "stock_value_difference"])
		self.assertEqual(stock_value, 0)
		self.assertEqual(stock_value_difference, -375)

		self.assertFalse(get_gl_entries("Delivery Note", dn.name))

	def test_delivery_note_gl_entry(self):
		self.clear_stock_account_balance()
		set_perpetual_inventory()
		self.assertEqual(cint(frappe.defaults.get_global_default("auto_accounting_for_stock")), 1)
		frappe.db.set_value("Item", "_Test Item", "valuation_method", "FIFO")

		_insert_purchase_receipt()

		dn = frappe.copy_doc(test_records[0])
		dn.get("delivery_note_details")[0].expense_account = "Cost of Goods Sold - _TC"
		dn.get("delivery_note_details")[0].cost_center = "Main - _TC"

		stock_in_hand_account = frappe.db.get_value("Account",
			{"master_name": dn.get("delivery_note_details")[0].warehouse})

		from erpnext.accounts.utils import get_balance_on
		prev_bal = get_balance_on(stock_in_hand_account, dn.posting_date)

		dn.insert()
		dn.submit()

		gl_entries = get_gl_entries("Delivery Note", dn.name)
		self.assertTrue(gl_entries)
		expected_values = {
			stock_in_hand_account: [0.0, 375.0],
			"Cost of Goods Sold - _TC": [375.0, 0.0]
		}
		for i, gle in enumerate(gl_entries):
			self.assertEquals([gle.debit, gle.credit], expected_values.get(gle.account))

		# check stock in hand balance
		bal = get_balance_on(stock_in_hand_account, dn.posting_date)
		self.assertEquals(bal, prev_bal - 375.0)

		# back dated purchase receipt
		pr = frappe.copy_doc(pr_test_records[0])
		pr.posting_date = "2013-01-01"
		pr.get("purchase_receipt_details")[0].rate = 100
		pr.get("purchase_receipt_details")[0].base_amount = 100

		pr.insert()
		pr.submit()

		gl_entries = get_gl_entries("Delivery Note", dn.name)
		self.assertTrue(gl_entries)
		expected_values = {
			stock_in_hand_account: [0.0, 666.67],
			"Cost of Goods Sold - _TC": [666.67, 0.0]
		}
		for i, gle in enumerate(gl_entries):
			self.assertEquals([gle.debit, gle.credit], expected_values.get(gle.account))

		dn.cancel()
		self.assertFalse(get_gl_entries("Delivery Note", dn.name))
		set_perpetual_inventory(0)

	def test_delivery_note_gl_entry_packing_item(self):
		self.clear_stock_account_balance()
		set_perpetual_inventory()

		_insert_purchase_receipt()
		_insert_purchase_receipt("_Test Item Home Desktop 100")

		dn = frappe.copy_doc(test_records[0])
		dn.get("delivery_note_details")[0].item_code = "_Test Sales BOM Item"
		dn.get("delivery_note_details")[0].qty = 1

		stock_in_hand_account = frappe.db.get_value("Account",
			{"master_name": dn.get("delivery_note_details")[0].warehouse})

		from erpnext.accounts.utils import get_balance_on
		prev_bal = get_balance_on(stock_in_hand_account, dn.posting_date)

		dn.insert()
		dn.submit()

		gl_entries = get_gl_entries("Delivery Note", dn.name)
		self.assertTrue(gl_entries)

		expected_values = {
			stock_in_hand_account: [0.0, 525],
			"Cost of Goods Sold - _TC": [525.0, 0.0]
		}
		for i, gle in enumerate(gl_entries):
			self.assertEquals([gle.debit, gle.credit], expected_values.get(gle.account))

		# check stock in hand balance
		bal = get_balance_on(stock_in_hand_account, dn.posting_date)
		self.assertEquals(bal, prev_bal - 525.0)

		dn.cancel()
		self.assertFalse(get_gl_entries("Delivery Note", dn.name))

		set_perpetual_inventory(0)

	def test_serialized(self):
		from erpnext.stock.doctype.stock_entry.test_stock_entry import make_serialized_item
		from erpnext.stock.doctype.serial_no.serial_no import get_serial_nos

		se = make_serialized_item()
		serial_nos = get_serial_nos(se.get("mtn_details")[0].serial_no)

		dn = frappe.copy_doc(test_records[0])
		dn.get("delivery_note_details")[0].item_code = "_Test Serialized Item With Series"
		dn.get("delivery_note_details")[0].qty = 1
		dn.get("delivery_note_details")[0].serial_no = serial_nos[0]
		dn.insert()
		dn.submit()

		self.assertEquals(frappe.db.get_value("Serial No", serial_nos[0], "status"), "Delivered")
		self.assertFalse(frappe.db.get_value("Serial No", serial_nos[0], "warehouse"))
		self.assertEquals(frappe.db.get_value("Serial No", serial_nos[0],
			"delivery_document_no"), dn.name)

		return dn

	def test_serialized_cancel(self):
		from erpnext.stock.doctype.serial_no.serial_no import get_serial_nos
		dn = self.test_serialized()
		dn.cancel()

		serial_nos = get_serial_nos(dn.get("delivery_note_details")[0].serial_no)

		self.assertEquals(frappe.db.get_value("Serial No", serial_nos[0], "status"), "Available")
		self.assertEquals(frappe.db.get_value("Serial No", serial_nos[0], "warehouse"), "_Test Warehouse - _TC")
		self.assertFalse(frappe.db.get_value("Serial No", serial_nos[0],
			"delivery_document_no"))

	def test_serialize_status(self):
		from erpnext.stock.doctype.serial_no.serial_no import SerialNoStatusError, get_serial_nos
		from erpnext.stock.doctype.stock_entry.test_stock_entry import make_serialized_item

		se = make_serialized_item()
		serial_nos = get_serial_nos(se.get("mtn_details")[0].serial_no)

		sr = frappe.get_doc("Serial No", serial_nos[0])
		sr.status = "Not Available"
		sr.save()

		dn = frappe.copy_doc(test_records[0])
		dn.get("delivery_note_details")[0].item_code = "_Test Serialized Item With Series"
		dn.get("delivery_note_details")[0].qty = 1
		dn.get("delivery_note_details")[0].serial_no = serial_nos[0]
		dn.insert()

		self.assertRaises(SerialNoStatusError, dn.submit)

	def clear_stock_account_balance(self):
		frappe.db.sql("""delete from `tabBin`""")
		frappe.db.sql("delete from `tabStock Ledger Entry`")
		frappe.db.sql("delete from `tabGL Entry`")

test_dependencies = ["Sales BOM"]

test_records = frappe.get_test_records('Delivery Note')

########NEW FILE########
__FILENAME__ = delivery_note_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class DeliveryNoteItem(Document):
	pass
########NEW FILE########
__FILENAME__ = item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import msgprint, _
from frappe.utils import cstr, flt, getdate, now_datetime, formatdate
from frappe.website.website_generator import WebsiteGenerator
from erpnext.setup.doctype.item_group.item_group import invalidate_cache_for
from frappe.website.render import clear_cache

class WarehouseNotSet(frappe.ValidationError): pass

class Item(WebsiteGenerator):
	def onload(self):
		self.get("__onload").sle_exists = self.check_if_sle_exists()

	def autoname(self):
		if frappe.db.get_default("item_naming_by")=="Naming Series":
			from frappe.model.naming import make_autoname
			self.item_code = make_autoname(self.naming_series+'.#####')
		elif not self.item_code:
			msgprint(_("Item Code is mandatory because Item is not automatically numbered"), raise_exception=1)

		self.name = self.item_code

	def validate(self):
		if not self.stock_uom:
			msgprint(_("Please enter default Unit of Measure"), raise_exception=1)
		if self.image and not self.website_image:
			self.website_image = self.image

		self.check_warehouse_is_set_for_stock_item()
		self.check_stock_uom_with_bin()
		self.add_default_uom_in_conversion_factor_table()
		self.validate_conversion_factor()
		self.validate_item_type()
		self.check_for_active_boms()
		self.fill_customer_code()
		self.check_item_tax()
		self.validate_barcode()
		self.cant_change()
		self.validate_item_type_for_reorder()

		if not self.parent_website_route:
			self.parent_website_route = frappe.get_website_route("Item Group", self.item_group)

		if self.name:
			self.old_page_name = frappe.db.get_value('Item', self.name, 'page_name')

	def on_update(self):
		super(Item, self).on_update()
		invalidate_cache_for_item(self)
		self.validate_name_with_item_group()
		self.update_item_price()

	def check_warehouse_is_set_for_stock_item(self):
		if self.is_stock_item=="Yes" and not self.default_warehouse:
			frappe.msgprint(_("Default Warehouse is mandatory for stock Item."),
				raise_exception=WarehouseNotSet)

	def add_default_uom_in_conversion_factor_table(self):
		uom_conv_list = [d.uom for d in self.get("uom_conversion_details")]
		if self.stock_uom not in uom_conv_list:
			ch = self.append('uom_conversion_details', {})
			ch.uom = self.stock_uom
			ch.conversion_factor = 1

		to_remove = []
		for d in self.get("uom_conversion_details"):
			if d.conversion_factor == 1 and d.uom != self.stock_uom:
				to_remove.append(d)

		[self.remove(d) for d in to_remove]


	def check_stock_uom_with_bin(self):
		if not self.get("__islocal"):
			matched=True
			ref_uom = frappe.db.get_value("Stock Ledger Entry",
				{"item_code": self.name}, "stock_uom")
			if ref_uom:
				if cstr(ref_uom) != cstr(self.stock_uom):
					matched = False
			else:
				bin_list = frappe.db.sql("select * from tabBin where item_code=%s",
					self.item_code, as_dict=1)
				for bin in bin_list:
					if (bin.reserved_qty > 0 or bin.ordered_qty > 0 or bin.indented_qty > 0 \
						or bin.planned_qty > 0) and cstr(bin.stock_uom) != cstr(self.stock_uom):
							matched = False
							break

				if matched and bin_list:
					frappe.db.sql("""update tabBin set stock_uom=%s where item_code=%s""",
						(self.stock_uom, self.name))

			if not matched:
				frappe.throw(_("Default Unit of Measure can not be changed directly because you have already made some transaction(s) with another UOM. To change default UOM, use 'UOM Replace Utility' tool under Stock module."))

	def validate_conversion_factor(self):
		check_list = []
		for d in self.get('uom_conversion_details'):
			if cstr(d.uom) in check_list:
				frappe.throw(_("Unit of Measure {0} has been entered more than once in Conversion Factor Table").format(d.uom))
			else:
				check_list.append(cstr(d.uom))

			if d.uom and cstr(d.uom) == cstr(self.stock_uom) and flt(d.conversion_factor) != 1:
				frappe.throw(_("Conversion factor for default Unit of Measure must be 1 in row {0}").format(d.idx))

	def validate_item_type(self):
		if cstr(self.is_manufactured_item) == "No":
			self.is_pro_applicable = "No"

		if self.is_pro_applicable == 'Yes' and self.is_stock_item == 'No':
			frappe.throw(_("As Production Order can be made for this item, it must be a stock item."))

		if self.has_serial_no == 'Yes' and self.is_stock_item == 'No':
			msgprint(_("'Has Serial No' can not be 'Yes' for non-stock item"), raise_exception=1)

		if self.has_serial_no == "No" and self.serial_no_series:
			self.serial_no_series = None


	def check_for_active_boms(self):
		if self.is_purchase_item != "Yes":
			bom_mat = frappe.db.sql("""select distinct t1.parent
				from `tabBOM Item` t1, `tabBOM` t2 where t2.name = t1.parent
				and t1.item_code =%s and ifnull(t1.bom_no, '') = '' and t2.is_active = 1
				and t2.docstatus = 1 and t1.docstatus =1 """, self.name)

			if bom_mat and bom_mat[0][0]:
				frappe.throw(_("Item must be a purchase item, as it is present in one or many Active BOMs"))

		if self.is_manufactured_item != "Yes":
			bom = frappe.db.sql("""select name from `tabBOM` where item = %s
				and is_active = 1""", (self.name,))
			if bom and bom[0][0]:
				print self.name
				frappe.throw(_("""Allow Bill of Materials should be 'Yes'. Because one or many active BOMs present for this item"""))

	def fill_customer_code(self):
		""" Append all the customer codes and insert into "customer_code" field of item table """
		cust_code=[]
		for d in self.get('item_customer_details'):
			cust_code.append(d.ref_code)
		self.customer_code=','.join(cust_code)

	def check_item_tax(self):
		"""Check whether Tax Rate is not entered twice for same Tax Type"""
		check_list=[]
		for d in self.get('item_tax'):
			if d.tax_type:
				account_type = frappe.db.get_value("Account", d.tax_type, "account_type")

				if account_type not in ['Tax', 'Chargeable', 'Income Account', 'Expense Account']:
					frappe.throw(_("Item Tax Row {0} must have account of type Tax or Income or Expense or Chargeable").format(d.idx))
				else:
					if d.tax_type in check_list:
						frappe.throw(_("{0} entered twice in Item Tax").format(d.tax_type))
					else:
						check_list.append(d.tax_type)

	def validate_barcode(self):
		if self.barcode:
			duplicate = frappe.db.sql("""select name from tabItem where barcode = %s
				and name != %s""", (self.barcode, self.name))
			if duplicate:
				frappe.throw(_("Barcode {0} already used in Item {1}").format(self.barcode, duplicate[0][0]))

	def cant_change(self):
		if not self.get("__islocal"):
			vals = frappe.db.get_value("Item", self.name,
				["has_serial_no", "is_stock_item", "valuation_method"], as_dict=True)

			if vals and ((self.is_stock_item == "No" and vals.is_stock_item == "Yes") or
				vals.has_serial_no != self.has_serial_no or
				cstr(vals.valuation_method) != cstr(self.valuation_method)):
					if self.check_if_sle_exists() == "exists":
						frappe.throw(_("As there are existing stock transactions for this item, you can not change the values of 'Has Serial No', 'Is Stock Item' and 'Valuation Method'"))

	def validate_item_type_for_reorder(self):
		if self.re_order_level or len(self.get("item_reorder", {"material_request_type": "Purchase"})):
			if not self.is_purchase_item:
				frappe.throw(_("""To set reorder level, item must be Purchase Item"""))

	def check_if_sle_exists(self):
		sle = frappe.db.sql("""select name from `tabStock Ledger Entry`
			where item_code = %s""", self.name)
		return sle and 'exists' or 'not exists'

	def validate_name_with_item_group(self):
		# causes problem with tree build
		if frappe.db.exists("Item Group", self.name):
			frappe.throw(_("An Item Group exists with same name, please change the item name or rename the item group"))

	def update_item_price(self):
		frappe.db.sql("""update `tabItem Price` set item_name=%s,
			item_description=%s, modified=NOW() where item_code=%s""",
			(self.item_name, self.description, self.name))

	def get_page_title(self):
		if self.name==self.item_name:
			page_name_from = self.name
		else:
			page_name_from = self.name + " " + self.item_name

		return page_name_from

	def get_tax_rate(self, tax_type):
		return { "tax_rate": frappe.db.get_value("Account", tax_type, "tax_rate") }

	def on_trash(self):
		super(Item, self).on_trash()
		frappe.db.sql("""delete from tabBin where item_code=%s""", self.item_code)

	def before_rename(self, olddn, newdn, merge=False):
		if merge:
			# Validate properties before merging
			if not frappe.db.exists("Item", newdn):
				frappe.throw(_("Item {0} does not exist").format(newdn))

			field_list = ["stock_uom", "is_stock_item", "has_serial_no", "has_batch_no"]
			new_properties = [cstr(d) for d in frappe.db.get_value("Item", newdn, field_list)]
			if new_properties != [cstr(self.get(fld)) for fld in field_list]:
				frappe.throw(_("To merge, following properties must be same for both items")
					+ ": \n" + ", ".join([self.meta.get_label(fld) for fld in field_list]))

			frappe.db.sql("delete from `tabBin` where item_code=%s", olddn)

	def after_rename(self, olddn, newdn, merge):
		super(Item, self).after_rename(olddn, newdn, merge)
		if self.page_name:
			invalidate_cache_for_item(self)
			clear_cache(self.page_name)

		frappe.db.set_value("Item", newdn, "item_code", newdn)
		if merge:
			self.set_last_purchase_rate(newdn)
			self.recalculate_bin_qty(newdn)

	def set_last_purchase_rate(self, newdn):
		last_purchase_rate = get_last_purchase_details(newdn).get("base_rate", 0)
		frappe.db.set_value("Item", newdn, "last_purchase_rate", last_purchase_rate)

	def recalculate_bin_qty(self, newdn):
		from erpnext.utilities.repost_stock import repost_stock
		frappe.db.auto_commit_on_many_writes = 1
		frappe.db.set_default("allow_negative_stock", 1)

		for warehouse in frappe.db.sql("select name from `tabWarehouse`"):
			repost_stock(newdn, warehouse[0])

		frappe.db.set_default("allow_negative_stock",
			frappe.db.get_value("Stock Settings", None, "allow_negative_stock"))
		frappe.db.auto_commit_on_many_writes = 0

def validate_end_of_life(item_code, end_of_life=None, verbose=1):
	if not end_of_life:
		end_of_life = frappe.db.get_value("Item", item_code, "end_of_life")

	if end_of_life and getdate(end_of_life) <= now_datetime().date():
		msg = _("Item {0} has reached its end of life on {1}").format(item_code, formatdate(end_of_life))
		_msgprint(msg, verbose)

def validate_is_stock_item(item_code, is_stock_item=None, verbose=1):
	if not is_stock_item:
		is_stock_item = frappe.db.get_value("Item", item_code, "is_stock_item")

	if is_stock_item != "Yes":
		msg = _("Item {0} is not a stock Item").format(item_code)

		_msgprint(msg, verbose)

def validate_cancelled_item(item_code, docstatus=None, verbose=1):
	if docstatus is None:
		docstatus = frappe.db.get_value("Item", item_code, "docstatus")

	if docstatus == 2:
		msg = _("Item {0} is cancelled").format(item_code)
		_msgprint(msg, verbose)

def _msgprint(msg, verbose):
	if verbose:
		msgprint(msg, raise_exception=True)
	else:
		raise frappe.ValidationError, msg


def get_last_purchase_details(item_code, doc_name=None, conversion_rate=1.0):
	"""returns last purchase details in stock uom"""
	# get last purchase order item details
	last_purchase_order = frappe.db.sql("""\
		select po.name, po.transaction_date, po.conversion_rate,
			po_item.conversion_factor, po_item.base_price_list_rate,
			po_item.discount_percentage, po_item.base_rate
		from `tabPurchase Order` po, `tabPurchase Order Item` po_item
		where po.docstatus = 1 and po_item.item_code = %s and po.name != %s and
			po.name = po_item.parent
		order by po.transaction_date desc, po.name desc
		limit 1""", (item_code, cstr(doc_name)), as_dict=1)

	# get last purchase receipt item details
	last_purchase_receipt = frappe.db.sql("""\
		select pr.name, pr.posting_date, pr.posting_time, pr.conversion_rate,
			pr_item.conversion_factor, pr_item.base_price_list_rate, pr_item.discount_percentage,
			pr_item.base_rate
		from `tabPurchase Receipt` pr, `tabPurchase Receipt Item` pr_item
		where pr.docstatus = 1 and pr_item.item_code = %s and pr.name != %s and
			pr.name = pr_item.parent
		order by pr.posting_date desc, pr.posting_time desc, pr.name desc
		limit 1""", (item_code, cstr(doc_name)), as_dict=1)

	purchase_order_date = getdate(last_purchase_order and last_purchase_order[0].transaction_date \
		or "1900-01-01")
	purchase_receipt_date = getdate(last_purchase_receipt and \
		last_purchase_receipt[0].posting_date or "1900-01-01")

	if (purchase_order_date > purchase_receipt_date) or \
			(last_purchase_order and not last_purchase_receipt):
		# use purchase order
		last_purchase = last_purchase_order[0]
		purchase_date = purchase_order_date

	elif (purchase_receipt_date > purchase_order_date) or \
			(last_purchase_receipt and not last_purchase_order):
		# use purchase receipt
		last_purchase = last_purchase_receipt[0]
		purchase_date = purchase_receipt_date

	else:
		return frappe._dict()

	conversion_factor = flt(last_purchase.conversion_factor)
	out = frappe._dict({
		"base_price_list_rate": flt(last_purchase.base_price_list_rate) / conversion_factor,
		"base_rate": flt(last_purchase.base_rate) / conversion_factor,
		"discount_percentage": flt(last_purchase.discount_percentage),
		"purchase_date": purchase_date
	})

	conversion_rate = flt(conversion_rate) or 1.0
	out.update({
		"price_list_rate": out.base_price_list_rate / conversion_rate,
		"rate": out.base_rate / conversion_rate,
		"base_rate": out.base_rate
	})

	return out

def invalidate_cache_for_item(doc):
	invalidate_cache_for(doc, doc.item_group)
	for d in doc.get({"doctype":"Website Item Group"}):
		if d.item_group:
			invalidate_cache_for(doc, d.item_group)

########NEW FILE########
__FILENAME__ = test_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import unittest
import frappe

from frappe.test_runner import make_test_records

test_ignore = ["BOM"]
test_dependencies = ["Warehouse"]

class TestItem(unittest.TestCase):
	def test_default_warehouse(self):
		from erpnext.stock.doctype.item.item import WarehouseNotSet
		item = frappe.copy_doc(test_records[0])
		item.is_stock_item = "Yes"
		item.default_warehouse = None
		self.assertRaises(WarehouseNotSet, item.insert)
		
	def test_get_item_details(self):
		from erpnext.stock.get_item_details import get_item_details
		to_check = {
			"item_code": "_Test Item",
			"item_name": "_Test Item",
			"description": "_Test Item",
			"warehouse": "_Test Warehouse - _TC",
			"income_account": "Sales - _TC",
			"expense_account": "_Test Account Cost for Goods Sold - _TC",
			"cost_center": "_Test Cost Center - _TC",
			"qty": 1.0,
			"price_list_rate": 100.0,
			"base_price_list_rate": 0.0,
			"discount_percentage": 0.0,
			"rate": 0.0,
			"base_rate": 0.0,
			"amount": 0.0,
			"base_amount": 0.0,
			"batch_no": None,
			"item_tax_rate": '{}',
			"uom": "_Test UOM",
			"conversion_factor": 1.0,
		}
		
		make_test_records("Item Price")
				
		details = get_item_details({
			"item_code": "_Test Item",
			"company": "_Test Company",
			"price_list": "_Test Price List",
			"currency": "_Test Currency",
			"doctype": "Sales Order",
			"conversion_rate": 1,
			"price_list_currency": "_Test Currency",
			"plc_conversion_rate": 1,
			"order_type": "Sales",
			"transaction_type": "selling"
		})
		
		for key, value in to_check.iteritems():
			self.assertEquals(value, details.get(key))

test_records = frappe.get_test_records('Item')
########NEW FILE########
__FILENAME__ = item_customer_detail
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ItemCustomerDetail(Document):
	pass
########NEW FILE########
__FILENAME__ = item_price
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import throw, _

class ItemPriceDuplicateItem(frappe.ValidationError): pass

from frappe.model.document import Document

class ItemPrice(Document):

	def validate(self):
		self.validate_item()
		self.validate_price_list()
		self.check_duplicate_item()
		self.update_price_list_details()
		self.update_item_details()

	def validate_item(self):
		if not frappe.db.exists("Item", self.item_code):
			throw(_("Item {0} not found").format(self.item_code))

	def validate_price_list(self):
		enabled = frappe.db.get_value("Price List", self.price_list, "enabled")
		if not enabled:
			throw(_("Price List {0} is disabled").format(self.price_list))

	def check_duplicate_item(self):
		if frappe.db.sql("""select name from `tabItem Price`
			where item_code=%s and price_list=%s and name!=%s""", (self.item_code, self.price_list, self.name)):

			frappe.throw(_("Item {0} appears multiple times in Price List {1}").format(self.item_code, self.price_list),
				ItemPriceDuplicateItem)

	def update_price_list_details(self):
		self.buying, self.selling, self.currency = \
			frappe.db.get_value("Price List", {"name": self.price_list, "enabled": 1},
				["buying", "selling", "currency"])

	def update_item_details(self):
		self.item_name, self.item_description = frappe.db.get_value("Item",
			self.item_code, ["item_name", "description"])

########NEW FILE########
__FILENAME__ = test_item_price
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import unittest
import frappe

class TestItem(unittest.TestCase):
	def test_duplicate_item(self):
		from erpnext.stock.doctype.item_price.item_price import ItemPriceDuplicateItem
		doc = frappe.copy_doc(test_records[0])
		self.assertRaises(ItemPriceDuplicateItem, doc.insert)

test_records = frappe.get_test_records('Item Price')
########NEW FILE########
__FILENAME__ = item_quality_inspection_parameter
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ItemQualityInspectionParameter(Document):
	pass
########NEW FILE########
__FILENAME__ = item_reorder
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ItemReorder(Document):
	pass
########NEW FILE########
__FILENAME__ = item_supplier
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ItemSupplier(Document):
	pass
########NEW FILE########
__FILENAME__ = item_tax
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ItemTax(Document):
	pass
########NEW FILE########
__FILENAME__ = item_website_specification
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class ItemWebsiteSpecification(Document):
	pass
########NEW FILE########
__FILENAME__ = landed_cost_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class LandedCostItem(Document):
	pass
########NEW FILE########
__FILENAME__ = landed_cost_purchase_receipt
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class LandedCostPurchaseReceipt(Document):
	pass
########NEW FILE########
__FILENAME__ = landed_cost_wizard
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt
from frappe import msgprint, _

from frappe.model.document import Document

class LandedCostWizard(Document):

	def update_landed_cost(self):
		"""
			Add extra cost and recalculate all values in pr,
			Recalculate valuation rate in all sle after pr posting date
		"""
		purchase_receipts = [row.purchase_receipt for row in
			self.get("lc_pr_details")]

		self.validate_purchase_receipts(purchase_receipts)
		self.cancel_pr(purchase_receipts)
		self.add_charges_in_pr(purchase_receipts)
		self.submit_pr(purchase_receipts)
		msgprint(_("Landed Cost updated successfully"))

	def validate_purchase_receipts(self, purchase_receipts):
		for pr in purchase_receipts:
			if frappe.db.get_value("Purchase Receipt", pr, "docstatus") != 1:
				frappe.throw(_("Purchase Receipt {0} is not submitted").format(pr))

	def add_charges_in_pr(self, purchase_receipts):
		""" Add additional charges in selected pr proportionately"""
		total_amt = self.get_total_pr_amt(purchase_receipts)

		for pr in purchase_receipts:
			pr_doc = frappe.get_doc('Purchase Receipt', pr)
			pr_items = pr_doc.get("purchase_tax_details")

			for lc in self.get("landed_cost_details"):
				amt = flt(lc.amount) * flt(pr_doc.net_total)/ flt(total_amt)

				matched_row = pr_doc.get("other_charges", {
					"category": "Valuation",
					"add_deduct_tax": "Add",
					"charge_type": "Actual",
					"account_head": lc.account_head
				})

				if not matched_row:	# add if not exists
					ch = pr_doc.append("other_charges")
					ch.category = 'Valuation'
					ch.add_deduct_tax = 'Add'
					ch.charge_type = 'Actual'
					ch.description = lc.description
					ch.account_head = lc.account_head
					ch.cost_center = lc.cost_center
					ch.rate = amt
					ch.tax_amount = amt
					ch.docstatus = 1
					ch.db_insert()
				else:	# overwrite if exists
					matched_row[0].rate = amt
					matched_row[0].tax_amount = amt
					matched_row[0].cost_center = lc.cost_center

			pr_doc.run_method("validate")
			pr_doc._validate_mandatory()
			for d in pr_doc.get_all_children():
				d.db_update()

	def get_total_pr_amt(self, purchase_receipts):
		return frappe.db.sql("""SELECT SUM(net_total) FROM `tabPurchase Receipt`
			WHERE name in (%s)""" % ', '.join(['%s']*len(purchase_receipts)),
			tuple(purchase_receipts))[0][0]

	def cancel_pr(self, purchase_receipts):
		for pr in purchase_receipts:
			pr_doc = frappe.get_doc("Purchase Receipt", pr)

			pr_doc.run_method("update_ordered_qty")

			frappe.db.sql("""delete from `tabStock Ledger Entry`
				where voucher_type='Purchase Receipt' and voucher_no=%s""", pr)
			frappe.db.sql("""delete from `tabGL Entry` where voucher_type='Purchase Receipt'
				and voucher_no=%s""", pr)

	def submit_pr(self, purchase_receipts):
		for pr in purchase_receipts:
			pr_doc = frappe.get_doc("Purchase Receipt", pr)
			pr_doc.run_method("update_ordered_qty")
			pr_doc.run_method("update_stock")
			pr_doc.run_method("make_gl_entries")

########NEW FILE########
__FILENAME__ = material_request
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# ERPNext - web based ERP (http://erpnext.com)
# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import cstr, flt
from frappe import _
from frappe.model.mapper import get_mapped_doc

from erpnext.controllers.buying_controller import BuyingController
class MaterialRequest(BuyingController):
	tname = 'Material Request Item'
	fname = 'indent_details'

	def check_if_already_pulled(self):
		pass#if self.[d.sales_order_no for d in self.get('indent_details')]

	def validate_qty_against_so(self):
		so_items = {} # Format --> {'SO/00001': {'Item/001': 120, 'Item/002': 24}}
		for d in self.get('indent_details'):
			if d.sales_order_no:
				if not so_items.has_key(d.sales_order_no):
					so_items[d.sales_order_no] = {d.item_code: flt(d.qty)}
				else:
					if not so_items[d.sales_order_no].has_key(d.item_code):
						so_items[d.sales_order_no][d.item_code] = flt(d.qty)
					else:
						so_items[d.sales_order_no][d.item_code] += flt(d.qty)

		for so_no in so_items.keys():
			for item in so_items[so_no].keys():
				already_indented = frappe.db.sql("""select sum(ifnull(qty, 0))
					from `tabMaterial Request Item`
					where item_code = %s and sales_order_no = %s and
					docstatus = 1 and parent != %s""", (item, so_no, self.name))
				already_indented = already_indented and flt(already_indented[0][0]) or 0

				actual_so_qty = frappe.db.sql("""select sum(ifnull(qty, 0)) from `tabSales Order Item`
					where parent = %s and item_code = %s and docstatus = 1""", (so_no, item))
				actual_so_qty = actual_so_qty and flt(actual_so_qty[0][0]) or 0

				if actual_so_qty and (flt(so_items[so_no][item]) + already_indented > actual_so_qty):
					frappe.throw(_("Material Request of maximum {0} can be made for Item {1} against Sales Order {2}").format(actual_so_qty - already_indented, item, so_no))

	def validate_schedule_date(self):
		for d in self.get('indent_details'):
			if d.schedule_date < self.transaction_date:
				frappe.throw(_("Expected Date cannot be before Material Request Date"))

	# Validate
	# ---------------------
	def validate(self):
		super(MaterialRequest, self).validate()

		self.validate_schedule_date()
		self.validate_uom_is_integer("uom", "qty")

		if not self.status:
			self.status = "Draft"

		from erpnext.utilities import validate_status
		validate_status(self.status, ["Draft", "Submitted", "Stopped", "Cancelled"])

		self.validate_value("material_request_type", "in", ["Purchase", "Transfer"])

		pc_obj = frappe.get_doc('Purchase Common')
		pc_obj.validate_for_items(self)

		# self.validate_qty_against_so()
		# NOTE: Since Item BOM and FG quantities are combined, using current data, it cannot be validated
		# Though the creation of Material Request from a Production Plan can be rethought to fix this

	def update_bin(self, is_submit, is_stopped):
		""" Update Quantity Requested for Purchase in Bin for Material Request of type 'Purchase'"""

		from erpnext.stock.utils import update_bin
		for d in self.get('indent_details'):
			if frappe.db.get_value("Item", d.item_code, "is_stock_item") == "Yes":
				if not d.warehouse:
					frappe.throw(_("Warehouse required for stock Item {0}").format(d.item_code))

				qty =flt(d.qty)
				if is_stopped:
					qty = (d.qty > d.ordered_qty) and flt(flt(d.qty) - flt(d.ordered_qty)) or 0

				args = {
					"item_code": d.item_code,
					"warehouse": d.warehouse,
					"indented_qty": (is_submit and 1 or -1) * flt(qty),
					"posting_date": self.transaction_date
				}
				update_bin(args)

	def on_submit(self):
		frappe.db.set(self, 'status', 'Submitted')
		self.update_bin(is_submit = 1, is_stopped = 0)

	def check_modified_date(self):
		mod_db = frappe.db.sql("""select modified from `tabMaterial Request` where name = %s""",
			self.name)
		date_diff = frappe.db.sql("""select TIMEDIFF('%s', '%s')"""
			% (mod_db[0][0], cstr(self.modified)))

		if date_diff and date_diff[0][0]:
			frappe.throw(_("{0} {1} has been modified. Please refresh.").format(_(self.doctype), self.name))

	def update_status(self, status):
		self.check_modified_date()
		self.update_bin(is_submit = (status == 'Submitted') and 1 or 0, is_stopped = 1)
		frappe.db.set(self, 'status', cstr(status))
		frappe.msgprint(_("Status updated to {0}").format(_(status)))

	def on_cancel(self):
		# Step 1:=> Get Purchase Common Obj
		pc_obj = frappe.get_doc('Purchase Common')

		# Step 2:=> Check for stopped status
		pc_obj.check_for_stopped_status(self.doctype, self.name)

		# Step 3:=> Check if Purchase Order has been submitted against current Material Request
		pc_obj.check_docstatus(check = 'Next', doctype = 'Purchase Order', docname = self.name, detail_doctype = 'Purchase Order Item')
		# Step 4:=> Update Bin
		self.update_bin(is_submit = 0, is_stopped = (cstr(self.status) == 'Stopped') and 1 or 0)

		# Step 5:=> Set Status
		frappe.db.set(self,'status','Cancelled')

	def update_completed_qty(self, mr_items=None):
		if self.material_request_type != "Transfer":
			return

		item_doclist = self.get("indent_details")

		if not mr_items:
			mr_items = [d.name for d in item_doclist]

		per_ordered = 0.0
		for d in item_doclist:
			if d.name in mr_items:
				d.ordered_qty =  flt(frappe.db.sql("""select sum(transfer_qty)
					from `tabStock Entry Detail` where material_request = %s
					and material_request_item = %s and docstatus = 1""",
					(self.name, d.name))[0][0])
				frappe.db.set_value(d.doctype, d.name, "ordered_qty", d.ordered_qty)

			# note: if qty is 0, its row is still counted in len(item_doclist)
			# hence adding 1 to per_ordered
			if (d.ordered_qty > d.qty) or not d.qty:
				per_ordered += 1.0
			elif d.qty > 0:
				per_ordered += flt(d.ordered_qty / flt(d.qty))

		self.per_ordered = flt((per_ordered / flt(len(item_doclist))) * 100.0, 2)
		frappe.db.set_value(self.doctype, self.name, "per_ordered", self.per_ordered)

def update_completed_qty(doc, method):
	if doc.doctype == "Stock Entry":
		material_request_map = {}

		for d in doc.get("mtn_details"):
			if d.material_request:
				material_request_map.setdefault(d.material_request, []).append(d.material_request_item)

		for mr_name, mr_items in material_request_map.items():
			mr_obj = frappe.get_doc("Material Request", mr_name)

			if mr_obj.status in ["Stopped", "Cancelled"]:
				frappe.throw(_("Material Request {0} is cancelled or stopped").format(mr_obj.name),
					frappe.InvalidStatusError)

			_update_requested_qty(doc, mr_obj, mr_items)

			# update ordered percentage and qty
			mr_obj.update_completed_qty(mr_items)

def _update_requested_qty(doc, mr_obj, mr_items):
	"""update requested qty (before ordered_qty is updated)"""
	from erpnext.stock.utils import update_bin
	for mr_item_name in mr_items:
		mr_item = mr_obj.get("indent_details", {"name": mr_item_name})
		se_detail = doc.get("mtn_details", {"material_request": mr_obj.name,
			"material_request_item": mr_item_name})

		if mr_item and se_detail:
			mr_item = mr_item[0]
			se_detail = se_detail[0]
			mr_item.ordered_qty = flt(mr_item.ordered_qty)
			mr_item.qty = flt(mr_item.qty)
			se_detail.transfer_qty = flt(se_detail.transfer_qty)

			if se_detail.docstatus == 2 and mr_item.ordered_qty > mr_item.qty \
					and se_detail.transfer_qty == mr_item.ordered_qty:
				add_indented_qty = mr_item.qty
			elif se_detail.docstatus == 1 and \
					mr_item.ordered_qty + se_detail.transfer_qty > mr_item.qty:
				add_indented_qty = mr_item.qty - mr_item.ordered_qty
			else:
				add_indented_qty = se_detail.transfer_qty

			update_bin({
				"item_code": se_detail.item_code,
				"warehouse": se_detail.t_warehouse,
				"indented_qty": (se_detail.docstatus==2 and 1 or -1) * add_indented_qty,
				"posting_date": doc.posting_date,
			})

def set_missing_values(source, target_doc):
	target_doc.run_method("set_missing_values")
	target_doc.run_method("calculate_taxes_and_totals")

def update_item(obj, target, source_parent):
	target.conversion_factor = 1
	target.qty = flt(obj.qty) - flt(obj.ordered_qty)

@frappe.whitelist()
def make_purchase_order(source_name, target_doc=None):
	doclist = get_mapped_doc("Material Request", source_name, 	{
		"Material Request": {
			"doctype": "Purchase Order",
			"validation": {
				"docstatus": ["=", 1],
				"material_request_type": ["=", "Purchase"]
			}
		},
		"Material Request Item": {
			"doctype": "Purchase Order Item",
			"field_map": [
				["name", "prevdoc_detail_docname"],
				["parent", "prevdoc_docname"],
				["parenttype", "prevdoc_doctype"],
				["uom", "stock_uom"],
				["uom", "uom"]
			],
			"postprocess": update_item
		}
	}, target_doc, set_missing_values)

	return doclist

@frappe.whitelist()
def make_purchase_order_based_on_supplier(source_name, target_doc=None):
	if target_doc:
		if isinstance(target_doc, basestring):
			import json
			target_doc = frappe.get_doc(json.loads(target_doc))
		target_doc.set("po_details", [])

	material_requests, supplier_items = get_material_requests_based_on_supplier(source_name)

	def postprocess(source, target_doc):
		target_doc.supplier = source_name
		set_missing_values(source, target_doc)
		target_doc.set("po_details", [d for d in target_doc.get("po_details")
			if d.get("item_code") in supplier_items and d.get("qty" > 0)])

		return target_doc

	for mr in material_requests:
		target_doc = get_mapped_doc("Material Request", mr, 	{
			"Material Request": {
				"doctype": "Purchase Order",
			},
			"Material Request Item": {
				"doctype": "Purchase Order Item",
				"field_map": [
					["name", "prevdoc_detail_docname"],
					["parent", "prevdoc_docname"],
					["parenttype", "prevdoc_doctype"],
					["uom", "stock_uom"],
					["uom", "uom"]
				],
				"postprocess": update_item
			}
		}, target_doc, postprocess)

	return target_doc

def get_material_requests_based_on_supplier(supplier):
	supplier_items = [d[0] for d in frappe.db.get_values("Item",
		{"default_supplier": supplier})]
	material_requests = frappe.db.sql_list("""select distinct mr.name
		from `tabMaterial Request` mr, `tabMaterial Request Item` mr_item
		where mr.name = mr_item.parent
		and mr_item.item_code in (%s)
		and mr.material_request_type = 'Purchase'
		and ifnull(mr.per_ordered, 0) < 99.99
		and mr.docstatus = 1
		and mr.status != 'Stopped'""" % ', '.join(['%s']*len(supplier_items)),
		tuple(supplier_items))
	return material_requests, supplier_items

@frappe.whitelist()
def make_supplier_quotation(source_name, target_doc=None):
	doclist = get_mapped_doc("Material Request", source_name, {
		"Material Request": {
			"doctype": "Supplier Quotation",
			"validation": {
				"docstatus": ["=", 1],
				"material_request_type": ["=", "Purchase"]
			}
		},
		"Material Request Item": {
			"doctype": "Supplier Quotation Item",
			"field_map": {
				"name": "prevdoc_detail_docname",
				"parent": "prevdoc_docname",
				"parenttype": "prevdoc_doctype"
			}
		}
	}, target_doc, set_missing_values)

	return doclist

@frappe.whitelist()
def make_stock_entry(source_name, target_doc=None):
	def update_item(obj, target, source_parent):
		target.conversion_factor = 1
		target.qty = flt(obj.qty) - flt(obj.ordered_qty)
		target.transfer_qty = flt(obj.qty) - flt(obj.ordered_qty)

	def set_missing_values(source, target):
		target.purpose = "Material Transfer"
		target.run_method("get_stock_and_rate")

	doclist = get_mapped_doc("Material Request", source_name, {
		"Material Request": {
			"doctype": "Stock Entry",
			"validation": {
				"docstatus": ["=", 1],
				"material_request_type": ["=", "Transfer"]
			}
		},
		"Material Request Item": {
			"doctype": "Stock Entry Detail",
			"field_map": {
				"name": "material_request_item",
				"parent": "material_request",
				"uom": "stock_uom",
				"warehouse": "t_warehouse"
			},
			"postprocess": update_item
		}
	}, target_doc, set_missing_values)

	return doclist

########NEW FILE########
__FILENAME__ = test_material_request
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# ERPNext - web based ERP (http://erpnext.com)
# For license information, please see license.txt

from __future__ import unicode_literals
import frappe, unittest
from frappe.utils import flt

class TestMaterialRequest(unittest.TestCase):
	def setUp(self):
		frappe.defaults.set_global_default("auto_accounting_for_stock", 0)

	def test_make_purchase_order(self):
		from erpnext.stock.doctype.material_request.material_request import make_purchase_order

		mr = frappe.copy_doc(test_records[0]).insert()

		self.assertRaises(frappe.ValidationError, make_purchase_order,
			mr.name)

		mr = frappe.get_doc("Material Request", mr.name)
		mr.submit()
		po = make_purchase_order(mr.name)

		self.assertEquals(po.doctype, "Purchase Order")
		self.assertEquals(len(po.get("po_details")), len(mr.get("indent_details")))

	def test_make_supplier_quotation(self):
		from erpnext.stock.doctype.material_request.material_request import make_supplier_quotation

		mr = frappe.copy_doc(test_records[0]).insert()

		self.assertRaises(frappe.ValidationError, make_supplier_quotation, mr.name)

		mr = frappe.get_doc("Material Request", mr.name)
		mr.submit()
		sq = make_supplier_quotation(mr.name)

		self.assertEquals(sq.doctype, "Supplier Quotation")
		self.assertEquals(len(sq.get("quotation_items")), len(mr.get("indent_details")))


	def test_make_stock_entry(self):
		from erpnext.stock.doctype.material_request.material_request import make_stock_entry

		mr = frappe.copy_doc(test_records[0]).insert()

		self.assertRaises(frappe.ValidationError, make_stock_entry,
			mr.name)

		mr = frappe.get_doc("Material Request", mr.name)
		mr.material_request_type = "Transfer"
		mr.submit()
		se = make_stock_entry(mr.name)

		self.assertEquals(se.doctype, "Stock Entry")
		self.assertEquals(len(se.get("mtn_details")), len(mr.get("indent_details")))

	def _test_requested_qty(self, qty1, qty2):
		self.assertEqual(flt(frappe.db.get_value("Bin", {"item_code": "_Test Item Home Desktop 100",
			"warehouse": "_Test Warehouse - _TC"}, "indented_qty")), qty1)
		self.assertEqual(flt(frappe.db.get_value("Bin", {"item_code": "_Test Item Home Desktop 200",
			"warehouse": "_Test Warehouse - _TC"}, "indented_qty")), qty2)

	def _insert_stock_entry(self, qty1, qty2):
		se = frappe.get_doc({
				"company": "_Test Company",
				"doctype": "Stock Entry",
				"posting_date": "2013-03-01",
				"posting_time": "00:00:00",
				"purpose": "Material Receipt",
				"fiscal_year": "_Test Fiscal Year 2013",
				"mtn_details": [
					{
						"conversion_factor": 1.0,
						"doctype": "Stock Entry Detail",
						"item_code": "_Test Item Home Desktop 100",
						"parentfield": "mtn_details",
						"incoming_rate": 100,
						"qty": qty1,
						"stock_uom": "_Test UOM 1",
						"transfer_qty": qty1,
						"uom": "_Test UOM 1",
						"t_warehouse": "_Test Warehouse 1 - _TC",
					},
					{
						"conversion_factor": 1.0,
						"doctype": "Stock Entry Detail",
						"item_code": "_Test Item Home Desktop 200",
						"parentfield": "mtn_details",
						"incoming_rate": 100,
						"qty": qty2,
						"stock_uom": "_Test UOM 1",
						"transfer_qty": qty2,
						"uom": "_Test UOM 1",
						"t_warehouse": "_Test Warehouse 1 - _TC",
					}
				]
			})
		se.insert()
		se.submit()

	def test_completed_qty_for_purchase(self):
		frappe.db.sql("""delete from `tabBin`""")

		# submit material request of type Purchase
		mr = frappe.copy_doc(test_records[0])
		mr.insert()
		mr.submit()

		# check if per complete is None
		self.assertEquals(mr.per_ordered, None)
		self.assertEquals(mr.get("indent_details")[0].ordered_qty, 0)
		self.assertEquals(mr.get("indent_details")[1].ordered_qty, 0)

		self._test_requested_qty(54.0, 3.0)

		# map a purchase order
		from erpnext.stock.doctype.material_request.material_request import make_purchase_order
		po_doc = make_purchase_order(mr.name)
		po_doc.supplier = "_Test Supplier"
		po_doc.transaction_date = "2013-07-07"
		po_doc.get("po_details")[0].qty = 27.0
		po_doc.get("po_details")[1].qty = 1.5
		po_doc.get("po_details")[0].schedule_date = "2013-07-09"
		po_doc.get("po_details")[1].schedule_date = "2013-07-09"


		# check for stopped status of Material Request
		po = frappe.copy_doc(po_doc)
		po.insert()
		po.load_from_db()
		mr.update_status('Stopped')
		self.assertRaises(frappe.InvalidStatusError, po.submit)
		frappe.db.set(po, "docstatus", 1)
		self.assertRaises(frappe.InvalidStatusError, po.cancel)

		# resubmit and check for per complete
		mr.load_from_db()
		mr.update_status('Submitted')
		po = frappe.copy_doc(po_doc)
		po.insert()
		po.submit()

		# check if per complete is as expected
		mr.load_from_db()
		self.assertEquals(mr.per_ordered, 50)
		self.assertEquals(mr.get("indent_details")[0].ordered_qty, 27.0)
		self.assertEquals(mr.get("indent_details")[1].ordered_qty, 1.5)
		self._test_requested_qty(27.0, 1.5)

		po.cancel()
		# check if per complete is as expected
		mr.load_from_db()
		self.assertEquals(mr.per_ordered, None)
		self.assertEquals(mr.get("indent_details")[0].ordered_qty, None)
		self.assertEquals(mr.get("indent_details")[1].ordered_qty, None)

		self._test_requested_qty(54.0, 3.0)

	def test_completed_qty_for_transfer(self):
		frappe.db.sql("""delete from `tabBin`""")
		frappe.db.sql("""delete from `tabStock Ledger Entry`""")

		# submit material request of type Purchase
		mr = frappe.copy_doc(test_records[0])
		mr.material_request_type = "Transfer"
		mr.insert()
		mr.submit()

		# check if per complete is None
		self.assertEquals(mr.per_ordered, None)
		self.assertEquals(mr.get("indent_details")[0].ordered_qty, 0)
		self.assertEquals(mr.get("indent_details")[1].ordered_qty, 0)

		self._test_requested_qty(54.0, 3.0)

		from erpnext.stock.doctype.material_request.material_request import make_stock_entry

		# map a stock entry
		se_doc = make_stock_entry(mr.name)
		se_doc.update({
			"posting_date": "2013-03-01",
			"posting_time": "01:00",
			"fiscal_year": "_Test Fiscal Year 2013",
		})
		se_doc.get("mtn_details")[0].update({
			"qty": 27.0,
			"transfer_qty": 27.0,
			"s_warehouse": "_Test Warehouse 1 - _TC",
			"incoming_rate": 1.0
		})
		se_doc.get("mtn_details")[1].update({
			"qty": 1.5,
			"transfer_qty": 1.5,
			"s_warehouse": "_Test Warehouse 1 - _TC",
			"incoming_rate": 1.0
		})

		# make available the qty in _Test Warehouse 1 before transfer
		self._insert_stock_entry(27.0, 1.5)

		# check for stopped status of Material Request
		se = frappe.copy_doc(se_doc)
		se.insert()
		mr.update_status('Stopped')
		self.assertRaises(frappe.InvalidStatusError, se.submit)

		mr.update_status('Submitted')

		se.ignore_validate_update_after_submit = True
		se.submit()
		mr.update_status('Stopped')
		self.assertRaises(frappe.InvalidStatusError, se.cancel)

		mr.update_status('Submitted')
		se = frappe.copy_doc(se_doc)
		se.insert()
		se.submit()

		# check if per complete is as expected
		mr.load_from_db()
		self.assertEquals(mr.per_ordered, 50)
		self.assertEquals(mr.get("indent_details")[0].ordered_qty, 27.0)
		self.assertEquals(mr.get("indent_details")[1].ordered_qty, 1.5)

		self._test_requested_qty(27.0, 1.5)

		# check if per complete is as expected for Stock Entry cancelled
		se.cancel()
		mr.load_from_db()
		self.assertEquals(mr.per_ordered, 0)
		self.assertEquals(mr.get("indent_details")[0].ordered_qty, 0)
		self.assertEquals(mr.get("indent_details")[1].ordered_qty, 0)

		self._test_requested_qty(54.0, 3.0)

	def test_completed_qty_for_over_transfer(self):
		frappe.db.sql("""delete from `tabBin`""")
		frappe.db.sql("""delete from `tabStock Ledger Entry`""")

		# submit material request of type Purchase
		mr = frappe.copy_doc(test_records[0])
		mr.material_request_type = "Transfer"
		mr.insert()
		mr.submit()

		# check if per complete is None
		self.assertEquals(mr.per_ordered, None)
		self.assertEquals(mr.get("indent_details")[0].ordered_qty, 0)
		self.assertEquals(mr.get("indent_details")[1].ordered_qty, 0)

		self._test_requested_qty(54.0, 3.0)

		# map a stock entry
		from erpnext.stock.doctype.material_request.material_request import make_stock_entry

		se_doc = make_stock_entry(mr.name)
		se_doc.update({
			"posting_date": "2013-03-01",
			"posting_time": "00:00",
			"fiscal_year": "_Test Fiscal Year 2013",
		})
		se_doc.get("mtn_details")[0].update({
			"qty": 60.0,
			"transfer_qty": 60.0,
			"s_warehouse": "_Test Warehouse 1 - _TC",
			"incoming_rate": 1.0
		})
		se_doc.get("mtn_details")[1].update({
			"qty": 3.0,
			"transfer_qty": 3.0,
			"s_warehouse": "_Test Warehouse 1 - _TC",
			"incoming_rate": 1.0
		})

		# make available the qty in _Test Warehouse 1 before transfer
		self._insert_stock_entry(60.0, 3.0)

		# check for stopped status of Material Request
		se = frappe.copy_doc(se_doc)
		se.insert()
		mr.update_status('Stopped')
		self.assertRaises(frappe.InvalidStatusError, se.submit)
		self.assertRaises(frappe.InvalidStatusError, se.cancel)

		mr.update_status('Submitted')
		se = frappe.copy_doc(se_doc)
		se.insert()
		se.submit()

		# check if per complete is as expected
		mr.load_from_db()

		self.assertEquals(mr.per_ordered, 100)
		self.assertEquals(mr.get("indent_details")[0].ordered_qty, 60.0)
		self.assertEquals(mr.get("indent_details")[1].ordered_qty, 3.0)
		self._test_requested_qty(0.0, 0.0)

		# check if per complete is as expected for Stock Entry cancelled
		se.cancel()
		mr.load_from_db()
		self.assertEquals(mr.per_ordered, 0)
		self.assertEquals(mr.get("indent_details")[0].ordered_qty, 0)
		self.assertEquals(mr.get("indent_details")[1].ordered_qty, 0)

		self._test_requested_qty(54.0, 3.0)

	def test_incorrect_mapping_of_stock_entry(self):
		# submit material request of type Purchase
		mr = frappe.copy_doc(test_records[0])
		mr.material_request_type = "Transfer"
		mr.insert()
		mr.submit()

		# map a stock entry
		from erpnext.stock.doctype.material_request.material_request import make_stock_entry

		se_doc = make_stock_entry(mr.name)
		se_doc.update({
			"posting_date": "2013-03-01",
			"posting_time": "00:00",
			"fiscal_year": "_Test Fiscal Year 2013",
		})
		se_doc.get("mtn_details")[0].update({
			"qty": 60.0,
			"transfer_qty": 60.0,
			"s_warehouse": "_Test Warehouse - _TC",
			"t_warehouse": "_Test Warehouse 1 - _TC",
			"incoming_rate": 1.0
		})
		se_doc.get("mtn_details")[1].update({
			"qty": 3.0,
			"transfer_qty": 3.0,
			"s_warehouse": "_Test Warehouse 1 - _TC",
			"incoming_rate": 1.0
		})

		# check for stopped status of Material Request
		se = frappe.copy_doc(se_doc)
		self.assertRaises(frappe.MappingMismatchError, se.insert)

	def test_warehouse_company_validation(self):
		from erpnext.stock.utils import InvalidWarehouseCompany
		mr = frappe.copy_doc(test_records[0])
		mr.company = "_Test Company 1"
		self.assertRaises(InvalidWarehouseCompany, mr.insert)

test_dependencies = ["Currency Exchange"]
test_records = frappe.get_test_records('Material Request')

########NEW FILE########
__FILENAME__ = material_request_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class MaterialRequestItem(Document):
	pass
########NEW FILE########
__FILENAME__ = packed_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# MIT License. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cstr, flt


from frappe.model.document import Document

class PackedItem(Document):
	pass
		
def get_sales_bom_items(item_code):
	return frappe.db.sql("""select t1.item_code, t1.qty, t1.uom 
		from `tabSales BOM Item` t1, `tabSales BOM` t2 
		where t2.new_item_code=%s and t1.parent = t2.name""", item_code, as_dict=1)

def get_packing_item_details(item):
	return frappe.db.sql("""select item_name, description, stock_uom from `tabItem` 
		where name = %s""", item, as_dict = 1)[0]

def get_bin_qty(item, warehouse):
	det = frappe.db.sql("""select actual_qty, projected_qty from `tabBin` 
		where item_code = %s and warehouse = %s""", (item, warehouse), as_dict = 1)
	return det and det[0] or ''

def update_packing_list_item(obj, packing_item_code, qty, warehouse, line, packing_list_idx):
	bin = get_bin_qty(packing_item_code, warehouse)
	item = get_packing_item_details(packing_item_code)

	# check if exists
	exists = 0
	for d in obj.get("packing_details"):
		if d.parent_item == line.item_code and d.item_code == packing_item_code and d.parent_detail_docname == line.name:
			pi, exists = d, 1
			break

	if not exists:
		pi = obj.append('packing_details', {})

	pi.parent_item = line.item_code
	pi.item_code = packing_item_code
	pi.item_name = item['item_name']
	pi.parent_detail_docname = line.name
	pi.description = item['description']
	pi.uom = item['stock_uom']
	pi.qty = flt(qty)
	pi.actual_qty = bin and flt(bin['actual_qty']) or 0
	pi.projected_qty = bin and flt(bin['projected_qty']) or 0
	if not pi.warehouse:
		pi.warehouse = warehouse
	if not pi.batch_no:
		pi.batch_no = cstr(line.get("batch_no"))
	pi.idx = packing_list_idx
	
	packing_list_idx += 1


def make_packing_list(obj, item_table_fieldname):
	"""make packing list for sales bom item"""
	packing_list_idx = 0
	parent_items = []
	for d in obj.get(item_table_fieldname):
		warehouse = (item_table_fieldname == "sales_order_details") \
			and d.warehouse or d.warehouse
		if frappe.db.get_value("Sales BOM", {"new_item_code": d.item_code}):
			for i in get_sales_bom_items(d.item_code):
				update_packing_list_item(obj, i['item_code'], flt(i['qty'])*flt(d.qty), 
					warehouse, d, packing_list_idx)

			if [d.item_code, d.name] not in parent_items:
				parent_items.append([d.item_code, d.name])
			
	cleanup_packing_list(obj, parent_items)
		
def cleanup_packing_list(obj, parent_items):
	"""Remove all those child items which are no longer present in main item table"""
	delete_list = []
	for d in obj.get("packing_details"):
		if [d.parent_item, d.parent_detail_docname] not in parent_items:
			# mark for deletion from doclist
			delete_list.append(d)

	if not delete_list:
		return obj
	
	packing_details = obj.get("packing_details")
	obj.set("packing_details", [])
	for d in packing_details:
		if d not in delete_list:
			obj.append("packing_details", d)
	
########NEW FILE########
__FILENAME__ = packing_slip
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt, cint
from frappe import _

from frappe.model.document import Document

class PackingSlip(Document):

	def validate(self):
		"""
			* Validate existence of submitted Delivery Note
			* Case nos do not overlap
			* Check if packed qty doesn't exceed actual qty of delivery note

			It is necessary to validate case nos before checking quantity
		"""
		self.validate_delivery_note()
		self.validate_items_mandatory()
		self.validate_case_nos()
		self.validate_qty()

		from erpnext.utilities.transaction_base import validate_uom_is_integer
		validate_uom_is_integer(self, "stock_uom", "qty")
		validate_uom_is_integer(self, "weight_uom", "net_weight")

	def validate_delivery_note(self):
		"""
			Validates if delivery note has status as draft
		"""
		if cint(frappe.db.get_value("Delivery Note", self.delivery_note, "docstatus")) != 0:
			frappe.throw(_("Delivery Note {0} must not be submitted").format(self.delivery_note))

	def validate_items_mandatory(self):
		rows = [d.item_code for d in self.get("item_details")]
		if not rows:
			frappe.msgprint(_("No Items to pack"), raise_exception=1)

	def validate_case_nos(self):
		"""
			Validate if case nos overlap. If they do, recommend next case no.
		"""
		if not cint(self.from_case_no):
			frappe.msgprint(_("Please specify a valid 'From Case No.'"), raise_exception=1)
		elif not self.to_case_no:
			self.to_case_no = self.from_case_no
		elif self.from_case_no > self.to_case_no:
			frappe.msgprint(_("'To Case No.' cannot be less than 'From Case No.'"),
				raise_exception=1)


		res = frappe.db.sql("""SELECT name FROM `tabPacking Slip`
			WHERE delivery_note = %(delivery_note)s AND docstatus = 1 AND
			((from_case_no BETWEEN %(from_case_no)s AND %(to_case_no)s)
			OR (to_case_no BETWEEN %(from_case_no)s AND %(to_case_no)s)
			OR (%(from_case_no)s BETWEEN from_case_no AND to_case_no))
			""", {"delivery_note":self.delivery_note,
				"from_case_no":self.from_case_no,
				"to_case_no":self.to_case_no})

		if res:
			frappe.throw(_("""Case No(s) already in use. Try from Case No {0}""").format(self.get_recommended_case_no()))

	def validate_qty(self):
		"""
			Check packed qty across packing slips and delivery note
		"""
		# Get Delivery Note Items, Item Quantity Dict and No. of Cases for this Packing slip
		dn_details, ps_item_qty, no_of_cases = self.get_details_for_packing()

		for item in dn_details:
			new_packed_qty = (flt(ps_item_qty[item['item_code']]) * no_of_cases) + \
			 	flt(item['packed_qty'])
			if new_packed_qty > flt(item['qty']) and no_of_cases:
				self.recommend_new_qty(item, ps_item_qty, no_of_cases)


	def get_details_for_packing(self):
		"""
			Returns
			* 'Delivery Note Items' query result as a list of dict
			* Item Quantity dict of current packing slip doc
			* No. of Cases of this packing slip
		"""

		rows = [d.item_code for d in self.get("item_details")]

		condition = ""
		if rows:
			condition = " and item_code in (%s)" % (", ".join(["%s"]*len(rows)))

		# gets item code, qty per item code, latest packed qty per item code and stock uom
		res = frappe.db.sql("""select item_code, ifnull(sum(qty), 0) as qty,
			(select sum(ifnull(psi.qty, 0) * (abs(ps.to_case_no - ps.from_case_no) + 1))
				from `tabPacking Slip` ps, `tabPacking Slip Item` psi
				where ps.name = psi.parent and ps.docstatus = 1
				and ps.delivery_note = dni.parent and psi.item_code=dni.item_code) as packed_qty,
			stock_uom, item_name
			from `tabDelivery Note Item` dni
			where parent=%s %s
			group by item_code""" % ("%s", condition),
			tuple([self.delivery_note] + rows), as_dict=1)

		ps_item_qty = dict([[d.item_code, d.qty] for d in self.get("item_details")])
		no_of_cases = cint(self.to_case_no) - cint(self.from_case_no) + 1

		return res, ps_item_qty, no_of_cases


	def recommend_new_qty(self, item, ps_item_qty, no_of_cases):
		"""
			Recommend a new quantity and raise a validation exception
		"""
		item['recommended_qty'] = (flt(item['qty']) - flt(item['packed_qty'])) / no_of_cases
		item['specified_qty'] = flt(ps_item_qty[item['item_code']])
		if not item['packed_qty']: item['packed_qty'] = 0

		frappe.throw(_("Quantity for Item {0} must be less than {1}").format(item.get("item_code"), item.get("recommended_qty")))

	def update_item_details(self):
		"""
			Fill empty columns in Packing Slip Item
		"""
		if not self.from_case_no:
			self.from_case_no = self.get_recommended_case_no()

		for d in self.get("item_details"):
			res = frappe.db.get_value("Item", d.item_code,
				["net_weight", "weight_uom"], as_dict=True)

			if res and len(res)>0:
				d.net_weight = res["net_weight"]
				d.weight_uom = res["weight_uom"]

	def get_recommended_case_no(self):
		"""
			Returns the next case no. for a new packing slip for a delivery
			note
		"""
		recommended_case_no = frappe.db.sql("""SELECT MAX(to_case_no) FROM `tabPacking Slip`
			WHERE delivery_note = %(delivery_note)s AND docstatus=1""", self.as_dict())

		return cint(recommended_case_no[0][0]) + 1

	def get_items(self):
		self.set("item_details", [])

		dn_details = self.get_details_for_packing()[0]
		for item in dn_details:
			if flt(item.qty) > flt(item.packed_qty):
				ch = self.append('item_details', {})
				ch.item_code = item.item_code
				ch.item_name = item.item_name
				ch.stock_uom = item.stock_uom
				ch.qty = flt(item.qty) - flt(item.packed_qty)
		self.update_item_details()

def item_details(doctype, txt, searchfield, start, page_len, filters):
	from erpnext.controllers.queries import get_match_cond
	return frappe.db.sql("""select name, item_name, description from `tabItem`
				where name in ( select item_code FROM `tabDelivery Note Item`
	 						where parent= %s
	 							and ifnull(qty, 0) > ifnull(packed_qty, 0))
	 			and %s like "%s" %s
	 			limit  %s, %s """ % ("%s", searchfield, "%s",
	 			get_match_cond(doctype), "%s", "%s"),
	 			(filters["delivery_note"], "%%%s%%" % txt, start, page_len))

########NEW FILE########
__FILENAME__ = packing_slip_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class PackingSlipItem(Document):
	pass
########NEW FILE########
__FILENAME__ = price_list
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _, throw
from frappe.utils import cint
from frappe.model.document import Document
import frappe.defaults

class PriceList(Document):
	def validate(self):
		if not cint(self.buying) and not cint(self.selling):
			throw(_("Price List must be applicable for Buying or Selling"))

		try:
			# at least one territory
			self.validate_table_has_rows("valid_for_territories")
		except frappe.EmptyTableError:
			# if no territory, set default territory
			if frappe.defaults.get_user_default("territory"):
				self.append("valid_for_territories", {
					"doctype": "Applicable Territory",
					"territory": frappe.defaults.get_user_default("territory")
				})
			else:
				raise

	def on_update(self):
		self.set_default_if_missing()
		self.update_item_price()

	def set_default_if_missing(self):
		if cint(self.selling):
			if not frappe.db.get_value("Selling Settings", None, "selling_price_list"):
				frappe.set_value("Selling Settings", "Selling Settings", "selling_price_list", self.name)

		elif cint(self.buying):
			if not frappe.db.get_value("Buying Settings", None, "buying_price_list"):
				frappe.set_value("Buying Settings", "Buying Settings", "buying_price_list", self.name)

	def update_item_price(self):
		frappe.db.sql("""update `tabItem Price` set currency=%s,
			buying=%s, selling=%s, modified=NOW() where price_list=%s""",
			(self.currency, cint(self.buying), cint(self.selling), self.name))

	def on_trash(self):
		def _update_default_price_list(module):
			b = frappe.get_doc(module + " Settings")
			price_list_fieldname = module.lower() + "_price_list"

			if self.name == b.get(price_list_fieldname):
				b.set(price_list_fieldname, None)
				b.save()

		for module in ["Selling", "Buying"]:
			_update_default_price_list(module)

########NEW FILE########
__FILENAME__ = test_price_list
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

# test_ignore = ["Item"]

test_records = frappe.get_test_records('Price List')
########NEW FILE########
__FILENAME__ = purchase_receipt
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import cstr, flt, cint

from frappe import _
import frappe.defaults
from erpnext.stock.utils import update_bin

from erpnext.controllers.buying_controller import BuyingController
class PurchaseReceipt(BuyingController):
	tname = 'Purchase Receipt Item'
	fname = 'purchase_receipt_details'

	def __init__(self, arg1, arg2=None):
		super(PurchaseReceipt, self).__init__(arg1, arg2)
		self.status_updater = [{
			'source_dt': 'Purchase Receipt Item',
			'target_dt': 'Purchase Order Item',
			'join_field': 'prevdoc_detail_docname',
			'target_field': 'received_qty',
			'target_parent_dt': 'Purchase Order',
			'target_parent_field': 'per_received',
			'target_ref_field': 'qty',
			'source_field': 'qty',
			'percent_join_field': 'prevdoc_docname',
		}]

	def onload(self):
		billed_qty = frappe.db.sql("""select sum(ifnull(qty, 0)) from `tabPurchase Invoice Item`
			where purchase_receipt=%s""", self.name)
		if billed_qty:
			total_qty = sum((item.qty for item in self.get("purchase_receipt_details")))
			self.get("__onload").billing_complete = (billed_qty[0][0] == total_qty)

	def validate(self):
		super(PurchaseReceipt, self).validate()

		self.po_required()

		if not self.status:
			self.status = "Draft"

		from erpnext.utilities import validate_status
		validate_status(self.status, ["Draft", "Submitted", "Cancelled"])

		self.validate_with_previous_doc()
		self.validate_rejected_warehouse()
		self.validate_accepted_rejected_qty()
		self.validate_inspection()
		self.validate_uom_is_integer("uom", ["qty", "received_qty"])
		self.validate_uom_is_integer("stock_uom", "stock_qty")

		pc_obj = frappe.get_doc('Purchase Common')
		pc_obj.validate_for_items(self)
		self.check_for_stopped_status(pc_obj)

		# sub-contracting
		self.validate_for_subcontracting()
		self.create_raw_materials_supplied("pr_raw_material_details")

		self.update_valuation_rate("purchase_receipt_details")

	def validate_rejected_warehouse(self):
		for d in self.get("purchase_receipt_details"):
			if flt(d.rejected_qty) and not d.rejected_warehouse:
				d.rejected_warehouse = self.rejected_warehouse
				if not d.rejected_warehouse:
					frappe.throw(_("Rejected Warehouse is mandatory against regected item"))

	# validate accepted and rejected qty
	def validate_accepted_rejected_qty(self):
		for d in self.get("purchase_receipt_details"):
			if not flt(d.received_qty) and flt(d.qty):
				d.received_qty = flt(d.qty) - flt(d.rejected_qty)

			elif not flt(d.qty) and flt(d.rejected_qty):
				d.qty = flt(d.received_qty) - flt(d.rejected_qty)

			elif not flt(d.rejected_qty):
				d.rejected_qty = flt(d.received_qty) -  flt(d.qty)

			# Check Received Qty = Accepted Qty + Rejected Qty
			if ((flt(d.qty) + flt(d.rejected_qty)) != flt(d.received_qty)):
				frappe.throw(_("Accepted + Rejected Qty must be equal to Received quantity for Item {0}").format(d.item_code))


	def validate_with_previous_doc(self):
		super(PurchaseReceipt, self).validate_with_previous_doc(self.tname, {
			"Purchase Order": {
				"ref_dn_field": "prevdoc_docname",
				"compare_fields": [["supplier", "="], ["company", "="],	["currency", "="]],
			},
			"Purchase Order Item": {
				"ref_dn_field": "prevdoc_detail_docname",
				"compare_fields": [["project_name", "="], ["uom", "="], ["item_code", "="]],
				"is_child_table": True
			}
		})

		if cint(frappe.defaults.get_global_default('maintain_same_rate')):
			super(PurchaseReceipt, self).validate_with_previous_doc(self.tname, {
				"Purchase Order Item": {
					"ref_dn_field": "prevdoc_detail_docname",
					"compare_fields": [["rate", "="]],
					"is_child_table": True
				}
			})


	def po_required(self):
		if frappe.db.get_value("Buying Settings", None, "po_required") == 'Yes':
			 for d in self.get('purchase_receipt_details'):
				 if not d.prevdoc_docname:
					 frappe.throw(_("Purchase Order number required for Item {0}").format(d.item_code))

	def update_stock(self):
		sl_entries = []
		stock_items = self.get_stock_items()

		for d in self.get('purchase_receipt_details'):
			if d.item_code in stock_items and d.warehouse:
				pr_qty = flt(d.qty) * flt(d.conversion_factor)

				if pr_qty:
					sl_entries.append(self.get_sl_entries(d, {
						"actual_qty": flt(pr_qty),
						"serial_no": cstr(d.serial_no).strip(),
						"incoming_rate": d.valuation_rate
					}))

				if flt(d.rejected_qty) > 0:
					sl_entries.append(self.get_sl_entries(d, {
						"warehouse": d.rejected_warehouse,
						"actual_qty": flt(d.rejected_qty) * flt(d.conversion_factor),
						"serial_no": cstr(d.rejected_serial_no).strip(),
						"incoming_rate": d.valuation_rate
					}))

		self.bk_flush_supp_wh(sl_entries)
		self.make_sl_entries(sl_entries)

	def update_ordered_qty(self):
		stock_items = self.get_stock_items()
		for d in self.get("purchase_receipt_details"):
			if d.item_code in stock_items and d.warehouse \
					and cstr(d.prevdoc_doctype) == 'Purchase Order':

				already_received_qty = self.get_already_received_qty(d.prevdoc_docname,
					d.prevdoc_detail_docname)
				po_qty, ordered_warehouse = self.get_po_qty_and_warehouse(d.prevdoc_detail_docname)

				if not ordered_warehouse:
					frappe.throw(_("Warehouse is missing in Purchase Order"))

				if already_received_qty + d.qty > po_qty:
					ordered_qty = - (po_qty - already_received_qty) * flt(d.conversion_factor)
				else:
					ordered_qty = - flt(d.qty) * flt(d.conversion_factor)

				update_bin({
					"item_code": d.item_code,
					"warehouse": ordered_warehouse,
					"posting_date": self.posting_date,
					"ordered_qty": flt(ordered_qty) if self.docstatus==1 else -flt(ordered_qty)
				})

	def get_already_received_qty(self, po, po_detail):
		qty = frappe.db.sql("""select sum(qty) from `tabPurchase Receipt Item`
			where prevdoc_detail_docname = %s and docstatus = 1
			and prevdoc_doctype='Purchase Order' and prevdoc_docname=%s
			and parent != %s""", (po_detail, po, self.name))
		return qty and flt(qty[0][0]) or 0.0

	def get_po_qty_and_warehouse(self, po_detail):
		po_qty, po_warehouse = frappe.db.get_value("Purchase Order Item", po_detail,
			["qty", "warehouse"])
		return po_qty, po_warehouse

	def bk_flush_supp_wh(self, sl_entries):
		for d in self.get('pr_raw_material_details'):
			# negative quantity is passed as raw material qty has to be decreased
			# when PR is submitted and it has to be increased when PR is cancelled
			sl_entries.append(self.get_sl_entries(d, {
				"item_code": d.rm_item_code,
				"warehouse": self.supplier_warehouse,
				"actual_qty": -1*flt(d.consumed_qty),
				"incoming_rate": 0
			}))

	def validate_inspection(self):
		for d in self.get('purchase_receipt_details'):		 #Enter inspection date for all items that require inspection
			ins_reqd = frappe.db.sql("select inspection_required from `tabItem` where name = %s",
				(d.item_code,), as_dict = 1)
			ins_reqd = ins_reqd and ins_reqd[0]['inspection_required'] or 'No'
			if ins_reqd == 'Yes' and not d.qa_no:
				frappe.msgprint(_("Quality Inspection required for Item {0}").format(d.item_code))

	# Check for Stopped status
	def check_for_stopped_status(self, pc_obj):
		check_list =[]
		for d in self.get('purchase_receipt_details'):
			if d.meta.get_field('prevdoc_docname') and d.prevdoc_docname and d.prevdoc_docname not in check_list:
				check_list.append(d.prevdoc_docname)
				pc_obj.check_for_stopped_status( d.prevdoc_doctype, d.prevdoc_docname)

	# on submit
	def on_submit(self):
		purchase_controller = frappe.get_doc("Purchase Common")

		# Check for Approving Authority
		frappe.get_doc('Authorization Control').validate_approving_authority(self.doctype, self.company, self.grand_total)

		# Set status as Submitted
		frappe.db.set(self, 'status', 'Submitted')

		self.update_prevdoc_status()

		self.update_ordered_qty()

		self.update_stock()

		from erpnext.stock.doctype.serial_no.serial_no import update_serial_nos_after_submit
		update_serial_nos_after_submit(self, "purchase_receipt_details")

		purchase_controller.update_last_purchase_rate(self, 1)

		self.make_gl_entries()

	def check_next_docstatus(self):
		submit_rv = frappe.db.sql("""select t1.name
			from `tabPurchase Invoice` t1,`tabPurchase Invoice Item` t2
			where t1.name = t2.parent and t2.purchase_receipt = %s and t1.docstatus = 1""",
			(self.name))
		if submit_rv:
			frappe.throw(_("Purchase Invoice {0} is already submitted").format(self.submit_rv[0][0]))

	def on_cancel(self):
		pc_obj = frappe.get_doc('Purchase Common')

		self.check_for_stopped_status(pc_obj)
		# Check if Purchase Invoice has been submitted against current Purchase Order
		submitted = frappe.db.sql("""select t1.name
			from `tabPurchase Invoice` t1,`tabPurchase Invoice Item` t2
			where t1.name = t2.parent and t2.purchase_receipt = %s and t1.docstatus = 1""",
			self.name)
		if submitted:
			frappe.throw(_("Purchase Invoice {0} is already submitted").format(submitted[0][0]))

		frappe.db.set(self,'status','Cancelled')

		self.update_ordered_qty()

		self.update_stock()

		self.update_prevdoc_status()
		pc_obj.update_last_purchase_rate(self, 0)

		self.make_cancel_gl_entries()

	def get_current_stock(self):
		for d in self.get('pr_raw_material_details'):
			if self.supplier_warehouse:
				bin = frappe.db.sql("select actual_qty from `tabBin` where item_code = %s and warehouse = %s", (d.rm_item_code, self.supplier_warehouse), as_dict = 1)
				d.current_stock = bin and flt(bin[0]['actual_qty']) or 0

	def get_rate(self,arg):
		return frappe.get_doc('Purchase Common').get_rate(arg,self)

	def get_gl_entries(self, warehouse_account=None):
		against_stock_account = self.get_company_default("stock_received_but_not_billed")

		gl_entries = super(PurchaseReceipt, self).get_gl_entries(warehouse_account, against_stock_account)
		return gl_entries


@frappe.whitelist()
def make_purchase_invoice(source_name, target_doc=None):
	from frappe.model.mapper import get_mapped_doc
	invoiced_qty_map = get_invoiced_qty_map(source_name)

	def set_missing_values(source, target):
		if len(target.get("entries")) == 0:
			frappe.throw(_("All items have already been invoiced"))

		doc = frappe.get_doc(target)
		doc.run_method("set_missing_values")
		doc.run_method("calculate_taxes_and_totals")

	def update_item(source_doc, target_doc, source_parent):
		target_doc.qty = source_doc.qty - invoiced_qty_map.get(source_doc.name, 0)

	doclist = get_mapped_doc("Purchase Receipt", source_name,	{
		"Purchase Receipt": {
			"doctype": "Purchase Invoice",
			"validation": {
				"docstatus": ["=", 1],
			}
		},
		"Purchase Receipt Item": {
			"doctype": "Purchase Invoice Item",
			"field_map": {
				"name": "pr_detail",
				"parent": "purchase_receipt",
				"prevdoc_detail_docname": "po_detail",
				"prevdoc_docname": "purchase_order",
			},
			"postprocess": update_item,
			"filter": lambda d: d.qty - invoiced_qty_map.get(d.name, 0)<=0
		},
		"Purchase Taxes and Charges": {
			"doctype": "Purchase Taxes and Charges",
			"add_if_empty": True
		}
	}, target_doc, set_missing_values)

	return doclist

def get_invoiced_qty_map(purchase_receipt):
	"""returns a map: {pr_detail: invoiced_qty}"""
	invoiced_qty_map = {}

	for pr_detail, qty in frappe.db.sql("""select pr_detail, qty from `tabPurchase Invoice Item`
		where purchase_receipt=%s and docstatus=1""", purchase_receipt):
			if not invoiced_qty_map.get(pr_detail):
				invoiced_qty_map[pr_detail] = 0
			invoiced_qty_map[pr_detail] += qty

	return invoiced_qty_map

########NEW FILE########
__FILENAME__ = test_purchase_receipt
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


from __future__ import unicode_literals
import unittest
import frappe
import frappe.defaults
from frappe.utils import cint

class TestPurchaseReceipt(unittest.TestCase):
	def test_make_purchase_invoice(self):
		self._clear_stock_account_balance()
		set_perpetual_inventory(0)
		from erpnext.stock.doctype.purchase_receipt.purchase_receipt import make_purchase_invoice

		pr = frappe.copy_doc(test_records[0]).insert()

		self.assertRaises(frappe.ValidationError, make_purchase_invoice,
			pr.name)

		pr = frappe.get_doc("Purchase Receipt", pr.name)
		pr.submit()
		pi = make_purchase_invoice(pr.name)

		self.assertEquals(pi.doctype, "Purchase Invoice")
		self.assertEquals(len(pi.get("entries")), len(pr.get("purchase_receipt_details")))

		# modify rate
		pi.get("entries")[0].rate = 200
		self.assertRaises(frappe.ValidationError, frappe.get_doc(pi).submit)

	def test_purchase_receipt_no_gl_entry(self):
		self._clear_stock_account_balance()
		set_perpetual_inventory(0)
		pr = frappe.copy_doc(test_records[0])
		pr.insert()
		pr.submit()

		stock_value, stock_value_difference = frappe.db.get_value("Stock Ledger Entry",
			{"voucher_type": "Purchase Receipt", "voucher_no": pr.name,
				"item_code": "_Test Item", "warehouse": "_Test Warehouse - _TC"},
			["stock_value", "stock_value_difference"])
		self.assertEqual(stock_value, 375)
		self.assertEqual(stock_value_difference, 375)

		bin_stock_value = frappe.db.get_value("Bin", {"item_code": "_Test Item",
			"warehouse": "_Test Warehouse - _TC"}, "stock_value")
		self.assertEqual(bin_stock_value, 375)

		self.assertFalse(get_gl_entries("Purchase Receipt", pr.name))

	def test_purchase_receipt_gl_entry(self):
		self._clear_stock_account_balance()

		set_perpetual_inventory()
		self.assertEqual(cint(frappe.defaults.get_global_default("auto_accounting_for_stock")), 1)

		pr = frappe.copy_doc(test_records[0])
		pr.insert()
		pr.submit()

		gl_entries = get_gl_entries("Purchase Receipt", pr.name)

		self.assertTrue(gl_entries)

		stock_in_hand_account = frappe.db.get_value("Account",
			{"master_name": pr.get("purchase_receipt_details")[0].warehouse})
		fixed_asset_account = frappe.db.get_value("Account",
			{"master_name": pr.get("purchase_receipt_details")[1].warehouse})

		expected_values = {
			stock_in_hand_account: [375.0, 0.0],
			fixed_asset_account: [375.0, 0.0],
			"Stock Received But Not Billed - _TC": [0.0, 750.0]
		}

		for gle in gl_entries:
			self.assertEquals(expected_values[gle.account][0], gle.debit)
			self.assertEquals(expected_values[gle.account][1], gle.credit)

		pr.cancel()
		self.assertFalse(get_gl_entries("Purchase Receipt", pr.name))

		set_perpetual_inventory(0)

	def _clear_stock_account_balance(self):
		frappe.db.sql("delete from `tabStock Ledger Entry`")
		frappe.db.sql("""delete from `tabBin`""")
		frappe.db.sql("""delete from `tabGL Entry`""")

	def test_subcontracting(self):
		pr = frappe.copy_doc(test_records[1])
		pr.run_method("calculate_taxes_and_totals")
		pr.insert()

		self.assertEquals(len(pr.get("pr_raw_material_details")), 2)
		self.assertEquals(pr.get("purchase_receipt_details")[0].rm_supp_cost, 70000.0)


	def test_serial_no_supplier(self):
		pr = frappe.copy_doc(test_records[0])
		pr.get("purchase_receipt_details")[0].item_code = "_Test Serialized Item With Series"
		pr.get("purchase_receipt_details")[0].qty = 1
		pr.get("purchase_receipt_details")[0].received_qty = 1
		pr.insert()
		pr.submit()

		self.assertEquals(frappe.db.get_value("Serial No", pr.get("purchase_receipt_details")[0].serial_no,
			"supplier"), pr.supplier)

		return pr

	def test_serial_no_cancel(self):
		pr = self.test_serial_no_supplier()
		pr.cancel()

		self.assertFalse(frappe.db.get_value("Serial No", pr.get("purchase_receipt_details")[0].serial_no,
			"warehouse"))

def get_gl_entries(voucher_type, voucher_no):
	return frappe.db.sql("""select account, debit, credit
		from `tabGL Entry` where voucher_type=%s and voucher_no=%s
		order by account desc""", (voucher_type, voucher_no), as_dict=1)

def set_perpetual_inventory(enable=1):
	accounts_settings = frappe.get_doc("Accounts Settings")
	accounts_settings.auto_accounting_for_stock = enable
	accounts_settings.save()


test_dependencies = ["BOM"]

test_records = frappe.get_test_records('Purchase Receipt')

########NEW FILE########
__FILENAME__ = purchase_receipt_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class PurchaseReceiptItem(Document):
	pass
########NEW FILE########
__FILENAME__ = serial_no
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import cint, cstr, flt, add_days, nowdate
from frappe import _, ValidationError

from erpnext.controllers.stock_controller import StockController

class SerialNoCannotCreateDirectError(ValidationError): pass
class SerialNoCannotCannotChangeError(ValidationError): pass
class SerialNoNotRequiredError(ValidationError): pass
class SerialNoRequiredError(ValidationError): pass
class SerialNoQtyError(ValidationError): pass
class SerialNoItemError(ValidationError): pass
class SerialNoWarehouseError(ValidationError): pass
class SerialNoStatusError(ValidationError): pass
class SerialNoNotExistsError(ValidationError): pass
class SerialNoDuplicateError(ValidationError): pass

class SerialNo(StockController):
	def __init__(self, arg1, arg2=None):
		super(SerialNo, self).__init__(arg1, arg2)
		self.via_stock_ledger = False

	def validate(self):
		if self.get("__islocal") and self.warehouse:
			frappe.throw(_("New Serial No cannot have Warehouse. Warehouse must be set by Stock Entry or Purchase Receipt"), SerialNoCannotCreateDirectError)

		self.set_maintenance_status()
		self.validate_warehouse()
		self.validate_item()
		self.on_stock_ledger_entry()

	def set_maintenance_status(self):
		if not self.warranty_expiry_date and not self.amc_expiry_date:
			self.maintenance_status = None

		if self.warranty_expiry_date and self.warranty_expiry_date < nowdate():
			self.maintenance_status = "Out of Warranty"

		if self.amc_expiry_date and self.amc_expiry_date < nowdate():
			self.maintenance_status = "Out of AMC"

		if self.amc_expiry_date and self.amc_expiry_date >= nowdate():
			self.maintenance_status = "Under AMC"

		if self.warranty_expiry_date and self.warranty_expiry_date >= nowdate():
			self.maintenance_status = "Under Warranty"

	def validate_warehouse(self):
		if not self.get("__islocal"):
			item_code, warehouse = frappe.db.get_value("Serial No",
				self.name, ["item_code", "warehouse"])
			if item_code != self.item_code:
				frappe.throw(_("Item Code cannot be changed for Serial No."),
					SerialNoCannotCannotChangeError)
			if not self.via_stock_ledger and warehouse != self.warehouse:
				frappe.throw(_("Warehouse cannot be changed for Serial No."),
					SerialNoCannotCannotChangeError)

	def validate_item(self):
		"""
			Validate whether serial no is required for this item
		"""
		item = frappe.get_doc("Item", self.item_code)
		if item.has_serial_no!="Yes":
			frappe.throw(_("Item {0} is not setup for Serial Nos. Check Item master").format(self.item_code))

		self.item_group = item.item_group
		self.description = item.description
		self.item_name = item.item_name
		self.brand = item.brand
		self.warranty_period = item.warranty_period

	def set_status(self, last_sle):
		if last_sle:
			if last_sle.voucher_type == "Stock Entry":
				document_type = frappe.db.get_value("Stock Entry", last_sle.voucher_no,
					"purpose")
			else:
				document_type = last_sle.voucher_type

			if last_sle.actual_qty > 0:
				if document_type == "Sales Return":
					self.status = "Sales Returned"
				else:
					self.status = "Available"
			else:
				if document_type == "Purchase Return":
					self.status = "Purchase Returned"
				elif last_sle.voucher_type in ("Delivery Note", "Sales Invoice"):
					self.status = "Delivered"
				else:
					self.status = "Not Available"
		else:
			self.status = "Not Available"

	def set_purchase_details(self, purchase_sle):
		if purchase_sle:
			self.purchase_document_type = purchase_sle.voucher_type
			self.purchase_document_no = purchase_sle.voucher_no
			self.purchase_date = purchase_sle.posting_date
			self.purchase_time = purchase_sle.posting_time
			self.purchase_rate = purchase_sle.incoming_rate
			if purchase_sle.voucher_type == "Purchase Receipt":
				self.supplier, self.supplier_name = \
					frappe.db.get_value("Purchase Receipt", purchase_sle.voucher_no,
						["supplier", "supplier_name"])
		else:
			for fieldname in ("purchase_document_type", "purchase_document_no",
				"purchase_date", "purchase_time", "purchase_rate", "supplier", "supplier_name"):
					self.set(fieldname, None)

	def set_sales_details(self, delivery_sle):
		if delivery_sle:
			self.delivery_document_type = delivery_sle.voucher_type
			self.delivery_document_no = delivery_sle.voucher_no
			self.delivery_date = delivery_sle.posting_date
			self.delivery_time = delivery_sle.posting_time
			self.customer, self.customer_name = \
				frappe.db.get_value(delivery_sle.voucher_type, delivery_sle.voucher_no,
					["customer", "customer_name"])
			if self.warranty_period:
				self.warranty_expiry_date	= add_days(cstr(delivery_sle.posting_date),
					cint(self.warranty_period))
		else:
			for fieldname in ("delivery_document_type", "delivery_document_no",
				"delivery_date", "delivery_time", "customer", "customer_name",
				"warranty_expiry_date"):
					self.set(fieldname, None)

	def get_last_sle(self):
		entries = {}
		sle_dict = self.get_stock_ledger_entries()
		if sle_dict:
			if sle_dict.get("incoming", []):
				entries["purchase_sle"] = sle_dict["incoming"][0]

			if len(sle_dict.get("incoming", [])) - len(sle_dict.get("outgoing", [])) > 0:
				entries["last_sle"] = sle_dict["incoming"][0]
			else:
				entries["last_sle"] = sle_dict["outgoing"][0]
				entries["delivery_sle"] = sle_dict["outgoing"][0]

		return entries

	def get_stock_ledger_entries(self):
		sle_dict = {}
		for sle in frappe.db.sql("""select * from `tabStock Ledger Entry`
			where serial_no like %s and item_code=%s and ifnull(is_cancelled, 'No')='No'
			order by posting_date desc, posting_time desc, name desc""",
			("%%%s%%" % self.name, self.item_code), as_dict=1):
				if self.name.upper() in get_serial_nos(sle.serial_no):
					if sle.actual_qty > 0:
						sle_dict.setdefault("incoming", []).append(sle)
					else:
						sle_dict.setdefault("outgoing", []).append(sle)

		return sle_dict

	def on_trash(self):
		if self.status == 'Delivered':
			frappe.throw(_("Delivered Serial No {0} cannot be deleted").format(self.name))
		if self.warehouse:
			frappe.throw(_("Cannot delete Serial No {0} in stock. First remove from stock, then delete.").format(self.name))

	def before_rename(self, old, new, merge=False):
		if merge:
			frappe.throw(_("Sorry, Serial Nos cannot be merged"))

	def after_rename(self, old, new, merge=False):
		"""rename serial_no text fields"""
		for dt in frappe.db.sql("""select parent from tabDocField
			where fieldname='serial_no' and fieldtype='Text'"""):

			for item in frappe.db.sql("""select name, serial_no from `tab%s`
				where serial_no like '%%%s%%'""" % (dt[0], old)):

				serial_nos = map(lambda i: i==old and new or i, item[1].split('\n'))
				frappe.db.sql("""update `tab%s` set serial_no = %s
					where name=%s""" % (dt[0], '%s', '%s'),
					('\n'.join(serial_nos), item[0]))

	def on_stock_ledger_entry(self):
		if self.via_stock_ledger and not self.get("__islocal"):
			last_sle = self.get_last_sle()
			self.set_status(last_sle.get("last_sle"))
			self.set_purchase_details(last_sle.get("purchase_sle"))
			self.set_sales_details(last_sle.get("delivery_sle"))
			self.set_maintenance_status()

	def on_communication(self):
		return

def process_serial_no(sle):
	item_det = get_item_details(sle.item_code)
	validate_serial_no(sle, item_det)
	update_serial_nos(sle, item_det)

def validate_serial_no(sle, item_det):
	if item_det.has_serial_no=="No":
		if sle.serial_no:
			frappe.throw(_("Item {0} is not setup for Serial Nos. Column must be blank").format(sle.item_code),
				SerialNoNotRequiredError)
	else:
		if sle.serial_no:
			serial_nos = get_serial_nos(sle.serial_no)
			if cint(sle.actual_qty) != flt(sle.actual_qty):
				frappe.throw(_("Serial No {0} quantity {1} cannot be a fraction").format(sle.item_code, sle.actual_qty))

			if len(serial_nos) and len(serial_nos) != abs(cint(sle.actual_qty)):
				frappe.throw(_("{0} Serial Numbers required for Item {0}. Only {0} provided.").format(sle.actual_qty, sle.item_code, len(serial_nos)),
					SerialNoQtyError)

			if len(serial_nos) != len(set(serial_nos)):
				frappe.throw(_("Duplicate Serial No entered for Item {0}").format(sle.item_code), SerialNoDuplicateError)

			for serial_no in serial_nos:
				if frappe.db.exists("Serial No", serial_no):
					sr = frappe.get_doc("Serial No", serial_no)

					if sr.item_code!=sle.item_code:
						frappe.throw(_("Serial No {0} does not belong to Item {1}").format(sle.item_code,
							serial_no), SerialNoItemError)

					if sr.warehouse and sle.actual_qty > 0:
						frappe.throw(_("Serial No {0} has already been received").format(sr.name),
							SerialNoDuplicateError)

					if sle.actual_qty < 0:
						if sr.warehouse!=sle.warehouse:
							frappe.throw(_("Serial No {0} does not belong to Warehouse {1}").format(serial_no,
								sle.warehouse), SerialNoWarehouseError)

						if sle.voucher_type in ("Delivery Note", "Sales Invoice") \
							and sr.status != "Available":
							frappe.throw(_("Serial No {0} status must be 'Available' to Deliver").format(serial_no),
								SerialNoStatusError)

				elif sle.actual_qty < 0:
					# transfer out
					frappe.throw(_("Serial No {0} not in stock").format(serial_no), SerialNoNotExistsError)
		elif sle.actual_qty < 0 or not item_det.serial_no_series:
			frappe.throw(_("Serial Nos Required for Serialized Item {0}").format(sle.item_code),
				SerialNoRequiredError)

def update_serial_nos(sle, item_det):
	if sle.is_cancelled == "No" and not sle.serial_no and sle.actual_qty > 0 \
			and item_det.has_serial_no == "Yes" and item_det.serial_no_series:
		from frappe.model.naming import make_autoname
		serial_nos = []
		for i in xrange(cint(sle.actual_qty)):
			serial_nos.append(make_autoname(item_det.serial_no_series))
		frappe.db.set(sle, "serial_no", "\n".join(serial_nos))

	if sle.serial_no:
		serial_nos = get_serial_nos(sle.serial_no)
		for serial_no in serial_nos:
			if frappe.db.exists("Serial No", serial_no):
				sr = frappe.get_doc("Serial No", serial_no)
				sr.via_stock_ledger = True
				sr.warehouse = sle.warehouse if sle.actual_qty > 0 else None
				sr.save(ignore_permissions=True)
			elif sle.actual_qty > 0:
				make_serial_no(serial_no, sle)

def get_item_details(item_code):
	return frappe.db.sql("""select name, has_batch_no, docstatus,
		is_stock_item, has_serial_no, serial_no_series
		from tabItem where name=%s""", item_code, as_dict=True)[0]

def get_serial_nos(serial_no):
	return [s.strip() for s in cstr(serial_no).strip().upper().replace(',', '\n').split('\n')
		if s.strip()]

def make_serial_no(serial_no, sle):
	sr = frappe.new_doc("Serial No")
	sr.ignore_permissions = True
	sr.serial_no = serial_no
	sr.item_code = sle.item_code
	sr.warehouse = None
	sr.company = sle.company
	sr.via_stock_ledger = True
	sr.insert()
	sr.warehouse = sle.warehouse
	sr.status = "Available"
	sr.save()
	frappe.msgprint(_("Serial No {0} created").format(sr.name))
	return sr.name

def update_serial_nos_after_submit(controller, parentfield):
	stock_ledger_entries = frappe.db.sql("""select voucher_detail_no, serial_no
		from `tabStock Ledger Entry` where voucher_type=%s and voucher_no=%s""",
		(controller.doctype, controller.name), as_dict=True)

	if not stock_ledger_entries: return

	for d in controller.get(parentfield):
		serial_no = None
		for sle in stock_ledger_entries:
			if sle.voucher_detail_no==d.name:
				serial_no = sle.serial_no
				break

		if d.serial_no != serial_no:
			d.serial_no = serial_no
			frappe.db.set_value(d.doctype, d.name, "serial_no", serial_no)

########NEW FILE########
__FILENAME__ = test_serial_no
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# ERPNext - web based ERP (http://erpnext.com)
# For license information, please see license.txt

from __future__ import unicode_literals
import frappe, unittest

test_dependencies = ["Item"]
test_records = frappe.get_test_records('Serial No')

from erpnext.stock.doctype.serial_no.serial_no import *

class TestSerialNo(unittest.TestCase):
	def test_cannot_create_direct(self):
		frappe.delete_doc_if_exists("Serial No", "_TCSER0001")

		sr = frappe.new_doc("Serial No")
		sr.item_code = "_Test Serialized Item"
		sr.warehouse = "_Test Warehouse - _TC"
		sr.serial_no = "_TCSER0001"
		sr.purchase_rate = 10
		self.assertRaises(SerialNoCannotCreateDirectError, sr.insert)

		sr.warehouse = None
		sr.insert()
		self.assertTrue(sr.name)

		sr.warehouse = "_Test Warehouse - _TC"
		self.assertTrue(SerialNoCannotCannotChangeError, sr.save)

########NEW FILE########
__FILENAME__ = stock_entry
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
import frappe.defaults

from frappe.utils import cstr, cint, flt, comma_or, nowdate

from frappe import _
from erpnext.stock.utils import get_incoming_rate
from erpnext.stock.stock_ledger import get_previous_sle
from erpnext.controllers.queries import get_match_cond

class NotUpdateStockError(frappe.ValidationError): pass
class StockOverReturnError(frappe.ValidationError): pass
class IncorrectValuationRateError(frappe.ValidationError): pass
class DuplicateEntryForProductionOrderError(frappe.ValidationError): pass

from erpnext.controllers.stock_controller import StockController

class StockEntry(StockController):
	fname = 'mtn_details'

	def validate(self):
		self.validate_posting_time()
		self.validate_purpose()
		pro_obj = self.production_order and \
			frappe.get_doc('Production Order', self.production_order) or None

		self.set_transfer_qty()
		self.validate_item()
		self.validate_uom_is_integer("uom", "qty")
		self.validate_uom_is_integer("stock_uom", "transfer_qty")
		self.validate_warehouse(pro_obj)
		self.validate_production_order(pro_obj)
		self.get_stock_and_rate()
		self.validate_incoming_rate()
		self.validate_bom()
		self.validate_finished_goods()
		self.validate_return_reference_doc()
		self.validate_with_material_request()
		self.validate_fiscal_year()
		self.set_total_amount()

	def on_submit(self):
		self.update_stock_ledger()

		from erpnext.stock.doctype.serial_no.serial_no import update_serial_nos_after_submit
		update_serial_nos_after_submit(self, "mtn_details")
		self.update_production_order()
		self.make_gl_entries()

	def on_cancel(self):
		self.update_stock_ledger()
		self.update_production_order()
		self.make_cancel_gl_entries()

	def validate_fiscal_year(self):
		from erpnext.accounts.utils import validate_fiscal_year
		validate_fiscal_year(self.posting_date, self.fiscal_year,
			self.meta.get_label("posting_date"))

	def validate_purpose(self):
		valid_purposes = ["Material Issue", "Material Receipt", "Material Transfer",
			"Manufacture/Repack", "Subcontract", "Sales Return", "Purchase Return"]
		if self.purpose not in valid_purposes:
			frappe.throw(_("Purpose must be one of {0}").format(comma_or(valid_purposes)))

	def set_transfer_qty(self):
		for item in self.get("mtn_details"):
			item.transfer_qty = flt(item.qty * item.conversion_factor, self.precision("transfer_qty", item))

	def validate_item(self):
		stock_items = self.get_stock_items()
		for item in self.get("mtn_details"):
			if item.item_code not in stock_items:
				frappe.throw(_("{0} is not a stock Item").format(item.item_code))
			if not item.stock_uom:
				item.stock_uom = frappe.db.get_value("Item", item.item_code, "stock_uom")
			if not item.uom:
				item.uom = item.stock_uom
			if not item.conversion_factor:
				item.conversion_factor = 1
			if not item.transfer_qty:
				item.transfer_qty = item.qty * item.conversion_factor

	def validate_warehouse(self, pro_obj):
		"""perform various (sometimes conditional) validations on warehouse"""

		source_mandatory = ["Material Issue", "Material Transfer", "Purchase Return"]
		target_mandatory = ["Material Receipt", "Material Transfer", "Sales Return"]

		validate_for_manufacture_repack = any([d.bom_no for d in self.get("mtn_details")])

		if self.purpose in source_mandatory and self.purpose not in target_mandatory:
			self.to_warehouse = None
			for d in self.get('mtn_details'):
				d.t_warehouse = None
		elif self.purpose in target_mandatory and self.purpose not in source_mandatory:
			self.from_warehouse = None
			for d in self.get('mtn_details'):
				d.s_warehouse = None

		for d in self.get('mtn_details'):
			if not d.s_warehouse and not d.t_warehouse:
				d.s_warehouse = self.from_warehouse
				d.t_warehouse = self.to_warehouse

			if not (d.s_warehouse or d.t_warehouse):
				frappe.throw(_("Atleast one warehouse is mandatory"))

			if self.purpose in source_mandatory and not d.s_warehouse:
				frappe.throw(_("Source warehouse is mandatory for row {0}").format(d.idx))

			if self.purpose in target_mandatory and not d.t_warehouse:
				frappe.throw(_("Target warehouse is mandatory for row {0}").format(d.idx))

			if self.purpose == "Manufacture/Repack":
				if validate_for_manufacture_repack:
					if d.bom_no:
						d.s_warehouse = None

						if not d.t_warehouse:
							frappe.throw(_("Target warehouse is mandatory for row {0}").format(d.idx))

						elif pro_obj and cstr(d.t_warehouse) != pro_obj.fg_warehouse:
							frappe.throw(_("Target warehouse in row {0} must be same as Production Order").format(d.idx))

					else:
						d.t_warehouse = None
						if not d.s_warehouse:
							frappe.throw(_("Source warehouse is mandatory for row {0}").format(d.idx))

			if cstr(d.s_warehouse) == cstr(d.t_warehouse):
				frappe.throw(_("Source and target warehouse cannot be same for row {0}").format(d.idx))

	def validate_production_order(self, pro_obj=None):
		if not pro_obj:
			if self.production_order:
				pro_obj = frappe.get_doc('Production Order', self.production_order)
			else:
				return

		if self.purpose == "Manufacture/Repack":
			# check for double entry
			self.check_duplicate_entry_for_production_order()
		elif self.purpose != "Material Transfer":
			self.production_order = None

	def check_duplicate_entry_for_production_order(self):
		other_ste = [t[0] for t in frappe.db.get_values("Stock Entry",  {
			"production_order": self.production_order,
			"purpose": self.purpose,
			"docstatus": ["!=", 2],
			"name": ["!=", self.name]
		}, "name")]

		if other_ste:
			production_item, qty = frappe.db.get_value("Production Order",
				self.production_order, ["production_item", "qty"])
			args = other_ste + [production_item]
			fg_qty_already_entered = frappe.db.sql("""select sum(transfer_qty)
				from `tabStock Entry Detail`
				where parent in (%s)
					and item_code = %s
					and ifnull(s_warehouse,'')='' """ % (", ".join(["%s" * len(other_ste)]), "%s"), args)[0][0]

			if fg_qty_already_entered >= qty:
				frappe.throw(_("Stock Entries already created for Production Order ")
					+ self.production_order + ":" + ", ".join(other_ste), DuplicateEntryForProductionOrderError)

	def set_total_amount(self):
		self.total_amount = sum([flt(item.amount) for item in self.get("mtn_details")])

	def get_stock_and_rate(self):
		"""get stock and incoming rate on posting date"""
		for d in self.get('mtn_details'):
			args = frappe._dict({
				"item_code": d.item_code,
				"warehouse": d.s_warehouse or d.t_warehouse,
				"posting_date": self.posting_date,
				"posting_time": self.posting_time,
				"qty": d.s_warehouse and -1*d.transfer_qty or d.transfer_qty,
				"serial_no": d.serial_no,
				"bom_no": d.bom_no,
			})
			# get actual stock at source warehouse
			d.actual_qty = get_previous_sle(args).get("qty_after_transaction") or 0

			# get incoming rate
			if not flt(d.incoming_rate):
				d.incoming_rate = self.get_incoming_rate(args)

			d.amount = flt(d.transfer_qty) * flt(d.incoming_rate)

	def get_incoming_rate(self, args):
		incoming_rate = 0
		if self.purpose == "Sales Return" and \
				(self.delivery_note_no or self.sales_invoice_no):
			sle = frappe.db.sql("""select name, posting_date, posting_time,
				actual_qty, stock_value, warehouse from `tabStock Ledger Entry`
				where voucher_type = %s and voucher_no = %s and
				item_code = %s limit 1""",
				((self.delivery_note_no and "Delivery Note" or "Sales Invoice"),
				self.delivery_note_no or self.sales_invoice_no, args.item_code), as_dict=1)
			if sle:
				args.update({
					"posting_date": sle[0].posting_date,
					"posting_time": sle[0].posting_time,
					"sle": sle[0].name,
					"warehouse": sle[0].warehouse,
				})
				previous_sle = get_previous_sle(args)
				incoming_rate = (flt(sle[0].stock_value) - flt(previous_sle.get("stock_value"))) / \
					flt(sle[0].actual_qty)
		else:
			incoming_rate = get_incoming_rate(args)

		return incoming_rate

	def validate_incoming_rate(self):
		for d in self.get('mtn_details'):
			if d.t_warehouse:
				self.validate_value("incoming_rate", ">", 0, d, raise_exception=IncorrectValuationRateError)

	def validate_bom(self):
		for d in self.get('mtn_details'):
			if d.bom_no and not frappe.db.sql("""select name from `tabBOM`
					where item = %s and name = %s and docstatus = 1 and is_active = 1""",
					(d.item_code, d.bom_no)):
				frappe.throw(_("BOM {0} is not submitted or inactive BOM for Item {1}").format(d.bom_no, d.item_code))

	def validate_finished_goods(self):
		"""validation: finished good quantity should be same as manufacturing quantity"""
		for d in self.get('mtn_details'):
			if d.bom_no and flt(d.transfer_qty) != flt(self.fg_completed_qty):
				frappe.throw(_("Quantity in row {0} ({1}) must be same as manufactured quantity {2}").format(d.idx, d.transfer_qty, self.fg_completed_qty))

	def validate_return_reference_doc(self):
		"""validate item with reference doc"""
		ref = get_return_doc_and_details(self)

		if ref.doc:
			# validate docstatus
			if ref.doc.docstatus != 1:
				frappe.throw(_("{0} {1} must be submitted").format(ref.doc.doctype, ref.doc.name),
					frappe.InvalidStatusError)

			# update stock check
			if ref.doc.doctype == "Sales Invoice" and cint(ref.doc.update_stock) != 1:
				frappe.throw(_("'Update Stock' for Sales Invoice {0} must be set").format(ref.doc.name), NotUpdateStockError)

			# posting date check
			ref_posting_datetime = "%s %s" % (cstr(ref.doc.posting_date),
				cstr(ref.doc.posting_time) or "00:00:00")
			this_posting_datetime = "%s %s" % (cstr(self.posting_date),
				cstr(self.posting_time))
			if this_posting_datetime < ref_posting_datetime:
				from frappe.utils.dateutils import datetime_in_user_format
				frappe.throw(_("Posting timestamp must be after {0}").format(datetime_in_user_format(ref_posting_datetime)))

			stock_items = get_stock_items_for_return(ref.doc, ref.parentfields)
			already_returned_item_qty = self.get_already_returned_item_qty(ref.fieldname)

			for item in self.get("mtn_details"):
				# validate if item exists in the ref doc and that it is a stock item
				if item.item_code not in stock_items:
					frappe.throw(_("Item {0} does not exist in {1} {2}").format(item.item_code, ref.doc.doctype, ref.doc.name),
						frappe.DoesNotExistError)

				# validate quantity <= ref item's qty - qty already returned
				ref_item = ref.doc.getone({"item_code": item.item_code})
				returnable_qty = ref_item.qty - flt(already_returned_item_qty.get(item.item_code))
				if not returnable_qty:
					frappe.throw(_("Item {0} has already been returned").format(item.item_code), StockOverReturnError)
				elif item.transfer_qty > returnable_qty:
					frappe.throw(_("Cannot return more than {0} for Item {1}").format(returnable_qty, item.item_code),
						StockOverReturnError)

	def get_already_returned_item_qty(self, ref_fieldname):
		return dict(frappe.db.sql("""select item_code, sum(transfer_qty) as qty
			from `tabStock Entry Detail` where parent in (
				select name from `tabStock Entry` where `%s`=%s and docstatus=1)
			group by item_code""" % (ref_fieldname, "%s"), (self.get(ref_fieldname),)))

	def update_stock_ledger(self):
		sl_entries = []
		for d in self.get('mtn_details'):
			if cstr(d.s_warehouse) and self.docstatus == 1:
				sl_entries.append(self.get_sl_entries(d, {
					"warehouse": cstr(d.s_warehouse),
					"actual_qty": -flt(d.transfer_qty),
					"incoming_rate": 0
				}))

			if cstr(d.t_warehouse):
				sl_entries.append(self.get_sl_entries(d, {
					"warehouse": cstr(d.t_warehouse),
					"actual_qty": flt(d.transfer_qty),
					"incoming_rate": flt(d.incoming_rate)
				}))

			# On cancellation, make stock ledger entry for
			# target warehouse first, to update serial no values properly

			if cstr(d.s_warehouse) and self.docstatus == 2:
				sl_entries.append(self.get_sl_entries(d, {
					"warehouse": cstr(d.s_warehouse),
					"actual_qty": -flt(d.transfer_qty),
					"incoming_rate": 0
				}))

		self.make_sl_entries(sl_entries, self.amended_from and 'Yes' or 'No')

	def update_production_order(self):
		def _validate_production_order(pro_doc):
			if flt(pro_doc.docstatus) != 1:
				frappe.throw(_("Production Order {0} must be submitted").format(self.production_order))

			if pro_doc.status == 'Stopped':
				frappe.throw(_("Transaction not allowed against stopped Production Order {0}").format(self.production_order))

		if self.production_order:
			pro_doc = frappe.get_doc("Production Order", self.production_order)
			_validate_production_order(pro_doc)
			pro_doc.run_method("update_status")
			if self.purpose == "Manufacture/Repack":
				pro_doc.run_method("update_produced_qty")
				self.update_planned_qty(pro_doc)

	def update_planned_qty(self, pro_doc):
		from erpnext.stock.utils import update_bin
		update_bin({
			"item_code": pro_doc.production_item,
			"warehouse": pro_doc.fg_warehouse,
			"posting_date": self.posting_date,
			"planned_qty": (self.docstatus==1 and -1 or 1 ) * flt(self.fg_completed_qty)
		})

	def get_item_details(self, args):
		item = frappe.db.sql("""select stock_uom, description, item_name,
			expense_account, buying_cost_center from `tabItem`
			where name = %s and (ifnull(end_of_life,'')='' or end_of_life > now())""",
			(args.get('item_code')), as_dict = 1)
		if not item:
			frappe.throw(_("Item {0} is not active or end of life has been reached").format(args.get("item_code")))

		ret = {
			'uom'			      	: item and item[0]['stock_uom'] or '',
			'stock_uom'			  	: item and item[0]['stock_uom'] or '',
			'description'		  	: item and item[0]['description'] or '',
			'item_name' 		  	: item and item[0]['item_name'] or '',
			'expense_account'		: args.get("expense_account") \
				or frappe.db.get_value("Company", args.get("company"), "stock_adjustment_account"),
			'cost_center'			: item and item[0]['buying_cost_center'] or args.get("cost_center"),
			'qty'					: 0,
			'transfer_qty'			: 0,
			'conversion_factor'		: 1,
     		'batch_no'          	: '',
			'actual_qty'			: 0,
			'incoming_rate'			: 0
		}
		stock_and_rate = args.get('warehouse') and self.get_warehouse_details(args) or {}
		ret.update(stock_and_rate)
		return ret

	def get_uom_details(self, arg = ''):
		arg, ret = eval(arg), {}
		uom = frappe.db.sql("""select conversion_factor from `tabUOM Conversion Detail`
			where parent = %s and uom = %s""", (arg['item_code'], arg['uom']), as_dict = 1)
		if not uom or not flt(uom[0].conversion_factor):
			frappe.msgprint(_("UOM coversion factor required for UOM {0} in Item {1}").format(arg["uom"], arg["item_code"]))
			ret = {'uom' : ''}
		else:
			ret = {
				'conversion_factor'		: flt(uom[0]['conversion_factor']),
				'transfer_qty'			: flt(arg['qty']) * flt(uom[0]['conversion_factor']),
			}
		return ret

	def get_warehouse_details(self, args):
		ret = {}
		if args.get('warehouse') and args.get('item_code'):
			args.update({
				"posting_date": self.posting_date,
				"posting_time": self.posting_time,
			})
			args = frappe._dict(args)

			ret = {
				"actual_qty" : get_previous_sle(args).get("qty_after_transaction") or 0,
				"incoming_rate" : self.get_incoming_rate(args)
			}
		return ret

	def get_items(self):
		self.set('mtn_details', [])

		pro_obj = None
		if self.production_order:
			# common validations
			pro_obj = frappe.get_doc('Production Order', self.production_order)
			if pro_obj:
				self.validate_production_order(pro_obj)
				self.bom_no = pro_obj.bom_no
			else:
				# invalid production order
				self.production_order = None

		if self.bom_no:
			if self.purpose in ["Material Issue", "Material Transfer", "Manufacture/Repack",
					"Subcontract"]:
				if self.production_order and self.purpose == "Material Transfer":
					item_dict = self.get_pending_raw_materials(pro_obj)
				else:
					if not self.fg_completed_qty:
						frappe.throw(_("Manufacturing Quantity is mandatory"))
					item_dict = self.get_bom_raw_materials(self.fg_completed_qty)
					for item in item_dict.values():
						if pro_obj:
							item["from_warehouse"] = pro_obj.wip_warehouse
						item["to_warehouse"] = ""

				# add raw materials to Stock Entry Detail table
				self.add_to_stock_entry_detail(item_dict)

			# add finished good item to Stock Entry Detail table -- along with bom_no
			if self.production_order and self.purpose == "Manufacture/Repack":
				item = frappe.db.get_value("Item", pro_obj.production_item, ["item_name",
					"description", "stock_uom", "expense_account", "buying_cost_center"], as_dict=1)
				self.add_to_stock_entry_detail({
					cstr(pro_obj.production_item): {
						"to_warehouse": pro_obj.fg_warehouse,
						"from_warehouse": "",
						"qty": self.fg_completed_qty,
						"item_name": item.item_name,
						"description": item.description,
						"stock_uom": item.stock_uom,
						"expense_account": item.expense_account,
						"cost_center": item.buying_cost_center,
					}
				}, bom_no=pro_obj.bom_no)

			elif self.purpose in ["Material Receipt", "Manufacture/Repack"]:
				if self.purpose=="Material Receipt":
					self.from_warehouse = ""

				item = frappe.db.sql("""select name, item_name, description,
					stock_uom, expense_account, buying_cost_center from `tabItem`
					where name=(select item from tabBOM where name=%s)""",
					self.bom_no, as_dict=1)
				self.add_to_stock_entry_detail({
					item[0]["name"] : {
						"qty": self.fg_completed_qty,
						"item_name": item[0].item_name,
						"description": item[0]["description"],
						"stock_uom": item[0]["stock_uom"],
						"from_warehouse": "",
						"expense_account": item[0].expense_account,
						"cost_center": item[0].buying_cost_center,
					}
				}, bom_no=self.bom_no)

		self.get_stock_and_rate()

	def get_bom_raw_materials(self, qty):
		from erpnext.manufacturing.doctype.bom.bom import get_bom_items_as_dict

		# item dict = { item_code: {qty, description, stock_uom} }
		item_dict = get_bom_items_as_dict(self.bom_no, qty=qty, fetch_exploded = self.use_multi_level_bom)

		for item in item_dict.values():
			item.from_warehouse = item.default_warehouse

		return item_dict

	def get_pending_raw_materials(self, pro_obj):
		"""
			issue (item quantity) that is pending to issue or desire to transfer,
			whichever is less
		"""
		item_dict = self.get_bom_raw_materials(1)
		issued_item_qty = self.get_issued_qty()

		max_qty = flt(pro_obj.qty)
		only_pending_fetched = []

		for item in item_dict:
			pending_to_issue = (max_qty * item_dict[item]["qty"]) - issued_item_qty.get(item, 0)
			desire_to_transfer = flt(self.fg_completed_qty) * item_dict[item]["qty"]
			if desire_to_transfer <= pending_to_issue:
				item_dict[item]["qty"] = desire_to_transfer
			else:
				item_dict[item]["qty"] = pending_to_issue
				if pending_to_issue:
					only_pending_fetched.append(item)

		# delete items with 0 qty
		for item in item_dict.keys():
			if not item_dict[item]["qty"]:
				del item_dict[item]

		# show some message
		if not len(item_dict):
			frappe.msgprint(_("""All items have already been transferred for this Production Order."""))

		elif only_pending_fetched:
			frappe.msgprint(_("Pending Items {0} updated").format(only_pending_fetched))

		return item_dict

	def get_issued_qty(self):
		issued_item_qty = {}
		result = frappe.db.sql("""select t1.item_code, sum(t1.qty)
			from `tabStock Entry Detail` t1, `tabStock Entry` t2
			where t1.parent = t2.name and t2.production_order = %s and t2.docstatus = 1
			and t2.purpose = 'Material Transfer'
			group by t1.item_code""", self.production_order)
		for t in result:
			issued_item_qty[t[0]] = flt(t[1])

		return issued_item_qty

	def add_to_stock_entry_detail(self, item_dict, bom_no=None):
		expense_account, cost_center = frappe.db.get_values("Company", self.company, \
			["default_expense_account", "cost_center"])[0]

		for d in item_dict:
			se_child = self.append('mtn_details')
			se_child.s_warehouse = item_dict[d].get("from_warehouse", self.from_warehouse)
			se_child.t_warehouse = item_dict[d].get("to_warehouse", self.to_warehouse)
			se_child.item_code = cstr(d)
			se_child.item_name = item_dict[d]["item_name"]
			se_child.description = item_dict[d]["description"]
			se_child.uom = item_dict[d]["stock_uom"]
			se_child.stock_uom = item_dict[d]["stock_uom"]
			se_child.qty = flt(item_dict[d]["qty"])
			se_child.expense_account = item_dict[d]["expense_account"] or expense_account
			se_child.cost_center = item_dict[d]["cost_center"] or cost_center

			# in stock uom
			se_child.transfer_qty = flt(item_dict[d]["qty"])
			se_child.conversion_factor = 1.00

			# to be assigned for finished item
			se_child.bom_no = bom_no

	def validate_with_material_request(self):
		for item in self.get("mtn_details"):
			if item.material_request:
				mreq_item = frappe.db.get_value("Material Request Item",
					{"name": item.material_request_item, "parent": item.material_request},
					["item_code", "warehouse", "idx"], as_dict=True)
				if mreq_item.item_code != item.item_code or mreq_item.warehouse != item.t_warehouse:
					frappe.throw(_("Item or Warehouse for row {0} does not match Material Request").format(item.idx),
						frappe.MappingMismatchError)

@frappe.whitelist()
def get_party_details(ref_dt, ref_dn):
	if ref_dt in ["Delivery Note", "Sales Invoice"]:
		res = frappe.db.get_value(ref_dt, ref_dn,
			["customer", "customer_name", "address_display as customer_address"], as_dict=1)
	else:
		res = frappe.db.get_value(ref_dt, ref_dn,
			["supplier", "supplier_name", "address_display as supplier_address"], as_dict=1)
	return res or {}

@frappe.whitelist()
def get_production_order_details(production_order):
	result = frappe.db.sql("""select bom_no,
		ifnull(qty, 0) - ifnull(produced_qty, 0) as fg_completed_qty, use_multi_level_bom,
		wip_warehouse from `tabProduction Order` where name = %s""", production_order, as_dict=1)
	return result and result[0] or {}

def query_sales_return_doc(doctype, txt, searchfield, start, page_len, filters):
	conditions = ""
	if doctype == "Sales Invoice":
		conditions = "and update_stock=1"

	return frappe.db.sql("""select name, customer, customer_name
		from `tab%s` where docstatus = 1
			and (`%s` like %%(txt)s
				or `customer` like %%(txt)s) %s %s
		order by name, customer, customer_name
		limit %s""" % (doctype, searchfield, conditions,
		get_match_cond(doctype), "%(start)s, %(page_len)s"),
		{"txt": "%%%s%%" % txt, "start": start, "page_len": page_len},
		as_list=True)

def query_purchase_return_doc(doctype, txt, searchfield, start, page_len, filters):
	return frappe.db.sql("""select name, supplier, supplier_name
		from `tab%s` where docstatus = 1
			and (`%s` like %%(txt)s
				or `supplier` like %%(txt)s) %s
		order by name, supplier, supplier_name
		limit %s""" % (doctype, searchfield, get_match_cond(doctype),
		"%(start)s, %(page_len)s"),	{"txt": "%%%s%%" % txt, "start":
		start, "page_len": page_len}, as_list=True)

def query_return_item(doctype, txt, searchfield, start, page_len, filters):
	txt = txt.replace("%", "")

	ref = get_return_doc_and_details(filters)

	stock_items = get_stock_items_for_return(ref.doc, ref.parentfields)

	result = []
	for item in ref.doc.get_all_children():
		if getattr(item, "item_code", None) in stock_items:
			item.item_name = cstr(item.item_name)
			item.description = cstr(item.description)
			if (txt in item.item_code) or (txt in item.item_name) or (txt in item.description):
				val = [
					item.item_code,
					(len(item.item_name) > 40) and (item.item_name[:40] + "...") or item.item_name,
					(len(item.description) > 40) and (item.description[:40] + "...") or \
						item.description
				]
				if val not in result:
					result.append(val)

	return result[start:start+page_len]

def get_batch_no(doctype, txt, searchfield, start, page_len, filters):
	if not filters.get("posting_date"):
		filters["posting_date"] = nowdate()

	batch_nos = None
	args = {
		'item_code': filters['item_code'],
		's_warehouse': filters['s_warehouse'],
		'posting_date': filters['posting_date'],
		'txt': "%%%s%%" % txt,
		'mcond':get_match_cond(doctype),
		"start": start,
		"page_len": page_len
	}

	if filters.get("s_warehouse"):
		batch_nos = frappe.db.sql("""select batch_no
			from `tabStock Ledger Entry` sle
			where item_code = '%(item_code)s'
				and warehouse = '%(s_warehouse)s'
				and batch_no like '%(txt)s'
				and exists(select * from `tabBatch`
					where name = sle.batch_no
					and (ifnull(expiry_date, '2099-12-31') >= %(posting_date)s
						or expiry_date = '')
					and docstatus != 2)
			%(mcond)s
			group by batch_no having sum(actual_qty) > 0
			order by batch_no desc
			limit %(start)s, %(page_len)s """
			% args)

	if batch_nos:
		return batch_nos
	else:
		return frappe.db.sql("""select name from `tabBatch`
			where item = '%(item_code)s'
			and docstatus < 2
			and (ifnull(expiry_date, '2099-12-31') >= %(posting_date)s
				or expiry_date = '' or expiry_date = "0000-00-00")
			%(mcond)s
			order by name desc
			limit %(start)s, %(page_len)s
		""" % args)

def get_stock_items_for_return(ref_doc, parentfields):
	"""return item codes filtered from doc, which are stock items"""
	if isinstance(parentfields, basestring):
		parentfields = [parentfields]

	all_items = list(set([d.item_code for d in
		ref_doc.get_all_children() if d.get("item_code")]))
	stock_items = frappe.db.sql_list("""select name from `tabItem`
		where is_stock_item='Yes' and name in (%s)""" % (", ".join(["%s"] * len(all_items))),
		tuple(all_items))

	return stock_items

def get_return_doc_and_details(args):
	ref = frappe._dict()

	# get ref_doc
	if args.get("purpose") in return_map:
		for fieldname, val in return_map[args.get("purpose")].items():
			if args.get(fieldname):
				ref.fieldname = fieldname
				ref.doc = frappe.get_doc(val[0], args.get(fieldname))
				ref.parentfields = val[1]
				break

	return ref

return_map = {
	"Sales Return": {
		# [Ref DocType, [Item tables' parentfields]]
		"delivery_note_no": ["Delivery Note", ["delivery_note_details", "packing_details"]],
		"sales_invoice_no": ["Sales Invoice", ["entries", "packing_details"]]
	},
	"Purchase Return": {
		"purchase_receipt_no": ["Purchase Receipt", ["purchase_receipt_details"]]
	}
}

@frappe.whitelist()
def make_return_jv(stock_entry):
	se = frappe.get_doc("Stock Entry", stock_entry)
	if not se.purpose in ["Sales Return", "Purchase Return"]:
		return

	ref = get_return_doc_and_details(se)

	if ref.doc.doctype == "Delivery Note":
		result = make_return_jv_from_delivery_note(se, ref)
	elif ref.doc.doctype == "Sales Invoice":
		result = make_return_jv_from_sales_invoice(se, ref)
	elif ref.doc.doctype == "Purchase Receipt":
		result = make_return_jv_from_purchase_receipt(se, ref)

	# create jv doc and fetch balance for each unique row item
	jv = frappe.new_doc("Journal Voucher")
	jv.update({
		"posting_date": se.posting_date,
		"voucher_type": se.purpose == "Sales Return" and "Credit Note" or "Debit Note",
		"fiscal_year": se.fiscal_year,
		"company": se.company
	})

	from erpnext.accounts.utils import get_balance_on
	for r in result:
		jv.append("entries", {
			"__islocal": 1,
			"doctype": "Journal Voucher Detail",
			"parentfield": "entries",
			"account": r.get("account"),
			"against_invoice": r.get("against_invoice"),
			"against_voucher": r.get("against_voucher"),
			"balance": get_balance_on(r.get("account"), se.posting_date) \
				if r.get("account") else 0
		})

	return jv

def make_return_jv_from_sales_invoice(se, ref):
	# customer account entry
	parent = {
		"account": ref.doc.debit_to,
		"against_invoice": ref.doc.name,
	}

	# income account entries
	children = []
	for se_item in se.get("mtn_details"):
		# find item in ref.doc
		ref_item = ref.doc.get({"item_code": se_item.item_code})[0]

		account = get_sales_account_from_item(ref.doc, ref_item)

		if account not in children:
			children.append(account)

	return [parent] + [{"account": account} for account in children]

def get_sales_account_from_item(doc, ref_item):
	account = None
	if not getattr(ref_item, "income_account", None):
		if ref_item.parent_item:
			parent_item = doc.get(doc.fname, {"item_code": ref_item.parent_item})[0]
			account = parent_item.income_account
	else:
		account = ref_item.income_account

	return account

def make_return_jv_from_delivery_note(se, ref):
	invoices_against_delivery = get_invoice_list("Sales Invoice Item", "delivery_note",
		ref.doc.name)

	if not invoices_against_delivery:
		sales_orders_against_delivery = [d.against_sales_order for d in ref.doc.get_all_children() if getattr(d, "against_sales_order", None)]

		if sales_orders_against_delivery:
			invoices_against_delivery = get_invoice_list("Sales Invoice Item", "sales_order",
				sales_orders_against_delivery)

	if not invoices_against_delivery:
		return []

	packing_item_parent_map = dict([[d.item_code, d.parent_item] for d in ref.doc.get(ref.parentfields[1])])

	parent = {}
	children = []

	for se_item in se.get("mtn_details"):
		for sales_invoice in invoices_against_delivery:
			si = frappe.get_doc("Sales Invoice", sales_invoice)

			if se_item.item_code in packing_item_parent_map:
				ref_item = si.get({"item_code": packing_item_parent_map[se_item.item_code]})
			else:
				ref_item = si.get({"item_code": se_item.item_code})

			if not ref_item:
				continue

			ref_item = ref_item[0]

			account = get_sales_account_from_item(si, ref_item)

			if account not in children:
				children.append(account)

			if not parent:
				parent = {"account": si.debit_to}

			break

	if len(invoices_against_delivery) == 1:
		parent["against_invoice"] = invoices_against_delivery[0]

	result = [parent] + [{"account": account} for account in children]

	return result

def get_invoice_list(doctype, link_field, value):
	if isinstance(value, basestring):
		value = [value]

	return frappe.db.sql_list("""select distinct parent from `tab%s`
		where docstatus = 1 and `%s` in (%s)""" % (doctype, link_field,
			", ".join(["%s"]*len(value))), tuple(value))

def make_return_jv_from_purchase_receipt(se, ref):
	invoice_against_receipt = get_invoice_list("Purchase Invoice Item", "purchase_receipt",
		ref.doc.name)

	if not invoice_against_receipt:
		purchase_orders_against_receipt = [d.prevdoc_docname for d in
			ref.doc.get(ref.doc.fname, {"prevdoc_doctype": "Purchase Order"})
			if getattr(d, "prevdoc_docname", None)]

		if purchase_orders_against_receipt:
			invoice_against_receipt = get_invoice_list("Purchase Invoice Item", "purchase_order",
				purchase_orders_against_receipt)

	if not invoice_against_receipt:
		return []

	parent = {}
	children = []

	for se_item in se.get("mtn_details"):
		for purchase_invoice in invoice_against_receipt:
			pi = frappe.get_doc("Purchase Invoice", purchase_invoice)
			ref_item = pi.get({"item_code": se_item.item_code})

			if not ref_item:
				continue

			ref_item = ref_item[0]

			account = ref_item.expense_account

			if account not in children:
				children.append(account)

			if not parent:
				parent = {"account": pi.credit_to}

			break

	if len(invoice_against_receipt) == 1:
		parent["against_voucher"] = invoice_against_receipt[0]

	result = [parent] + [{"account": account} for account in children]

	return result

########NEW FILE########
__FILENAME__ = test_stock_entry
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe, unittest
import frappe.defaults
from frappe.utils import flt, getdate
from erpnext.stock.doctype.serial_no.serial_no import *
from erpnext.stock.doctype.purchase_receipt.test_purchase_receipt import set_perpetual_inventory
from erpnext.stock.doctype.stock_ledger_entry.stock_ledger_entry import StockFreezeError

class TestStockEntry(unittest.TestCase):
	def tearDown(self):
		frappe.set_user("Administrator")
		set_perpetual_inventory(0)
		if hasattr(self, "old_default_company"):
			frappe.db.set_default("company", self.old_default_company)

	def test_auto_material_request(self):
		frappe.db.sql("""delete from `tabMaterial Request Item`""")
		frappe.db.sql("""delete from `tabMaterial Request`""")
		self._clear_stock_account_balance()

		frappe.db.set_value("Stock Settings", None, "auto_indent", True)

		st1 = frappe.copy_doc(test_records[0])
		st1.insert()
		st1.submit()

		st2 = frappe.copy_doc(test_records[1])
		st2.insert()
		st2.submit()

		from erpnext.stock.utils import reorder_item
		reorder_item()

		mr_name = frappe.db.sql("""select parent from `tabMaterial Request Item`
			where item_code='_Test Item'""")

		self.assertTrue(mr_name)

	def test_material_receipt_gl_entry(self):
		self._clear_stock_account_balance()
		set_perpetual_inventory()

		mr = frappe.copy_doc(test_records[0])
		mr.insert()
		mr.submit()

		stock_in_hand_account = frappe.db.get_value("Account", {"account_type": "Warehouse",
			"master_name": mr.get("mtn_details")[0].t_warehouse})

		self.check_stock_ledger_entries("Stock Entry", mr.name,
			[["_Test Item", "_Test Warehouse - _TC", 50.0]])

		self.check_gl_entries("Stock Entry", mr.name,
			sorted([
				[stock_in_hand_account, 5000.0, 0.0],
				["Stock Adjustment - _TC", 0.0, 5000.0]
			])
		)

		mr.cancel()

		self.assertFalse(frappe.db.sql("""select * from `tabStock Ledger Entry`
			where voucher_type='Stock Entry' and voucher_no=%s""", mr.name))

		self.assertFalse(frappe.db.sql("""select * from `tabGL Entry`
			where voucher_type='Stock Entry' and voucher_no=%s""", mr.name))


	def test_material_issue_gl_entry(self):
		self._clear_stock_account_balance()
		set_perpetual_inventory()

		self._insert_material_receipt()

		mi = frappe.copy_doc(test_records[1])
		mi.insert()
		mi.submit()

		self.check_stock_ledger_entries("Stock Entry", mi.name,
			[["_Test Item", "_Test Warehouse - _TC", -40.0]])

		stock_in_hand_account = frappe.db.get_value("Account", {"account_type": "Warehouse",
			"master_name": mi.get("mtn_details")[0].s_warehouse})

		self.check_gl_entries("Stock Entry", mi.name,
			sorted([
				[stock_in_hand_account, 0.0, 4000.0],
				["Stock Adjustment - _TC", 4000.0, 0.0]
			])
		)

		mi.cancel()
		self.assertFalse(frappe.db.sql("""select * from `tabStock Ledger Entry`
			where voucher_type='Stock Entry' and voucher_no=%s""", mi.name))

		self.assertFalse(frappe.db.sql("""select * from `tabGL Entry`
			where voucher_type='Stock Entry' and voucher_no=%s""", mi.name))

		self.assertEquals(frappe.db.get_value("Bin", {"warehouse": mi.get("mtn_details")[0].s_warehouse,
			"item_code": mi.get("mtn_details")[0].item_code}, "actual_qty"), 50)

		self.assertEquals(frappe.db.get_value("Bin", {"warehouse": mi.get("mtn_details")[0].s_warehouse,
			"item_code": mi.get("mtn_details")[0].item_code}, "stock_value"), 5000)

	def test_material_transfer_gl_entry(self):
		self._clear_stock_account_balance()
		set_perpetual_inventory()

		self._insert_material_receipt()

		mtn = frappe.copy_doc(test_records[2])
		mtn.insert()
		mtn.submit()

		self.check_stock_ledger_entries("Stock Entry", mtn.name,
			[["_Test Item", "_Test Warehouse - _TC", -45.0], ["_Test Item", "_Test Warehouse 1 - _TC", 45.0]])

		stock_in_hand_account = frappe.db.get_value("Account", {"account_type": "Warehouse",
			"master_name": mtn.get("mtn_details")[0].s_warehouse})

		fixed_asset_account = frappe.db.get_value("Account", {"account_type": "Warehouse",
			"master_name": mtn.get("mtn_details")[0].t_warehouse})


		self.check_gl_entries("Stock Entry", mtn.name,
			sorted([
				[stock_in_hand_account, 0.0, 4500.0],
				[fixed_asset_account, 4500.0, 0.0],
			])
		)


		mtn.cancel()
		self.assertFalse(frappe.db.sql("""select * from `tabStock Ledger Entry`
			where voucher_type='Stock Entry' and voucher_no=%s""", mtn.name))

		self.assertFalse(frappe.db.sql("""select * from `tabGL Entry`
			where voucher_type='Stock Entry' and voucher_no=%s""", mtn.name))


	def test_repack_no_change_in_valuation(self):
		self._clear_stock_account_balance()
		set_perpetual_inventory()

		self._insert_material_receipt()

		repack = frappe.copy_doc(test_records[3])
		repack.insert()
		repack.submit()

		self.check_stock_ledger_entries("Stock Entry", repack.name,
			[["_Test Item", "_Test Warehouse - _TC", -50.0],
				["_Test Item Home Desktop 100", "_Test Warehouse - _TC", 1]])

		gl_entries = frappe.db.sql("""select account, debit, credit
			from `tabGL Entry` where voucher_type='Stock Entry' and voucher_no=%s
			order by account desc""", repack.name, as_dict=1)
		self.assertFalse(gl_entries)

		set_perpetual_inventory(0)

	def test_repack_with_change_in_valuation(self):
		self._clear_stock_account_balance()
		set_perpetual_inventory()

		self._insert_material_receipt()

		repack = frappe.copy_doc(test_records[3])
		repack.get("mtn_details")[1].incoming_rate = 6000
		repack.insert()
		repack.submit()

		stock_in_hand_account = frappe.db.get_value("Account", {"account_type": "Warehouse",
			"master_name": repack.get("mtn_details")[1].t_warehouse})

		self.check_gl_entries("Stock Entry", repack.name,
			sorted([
				[stock_in_hand_account, 1000.0, 0.0],
				["Stock Adjustment - _TC", 0.0, 1000.0],
			])
		)
		set_perpetual_inventory(0)

	def check_stock_ledger_entries(self, voucher_type, voucher_no, expected_sle):
		expected_sle.sort(key=lambda x: x[0])

		# check stock ledger entries
		sle = frappe.db.sql("""select item_code, warehouse, actual_qty
			from `tabStock Ledger Entry` where voucher_type = %s
			and voucher_no = %s order by item_code, warehouse, actual_qty""",
			(voucher_type, voucher_no), as_list=1)
		self.assertTrue(sle)
		sle.sort(key=lambda x: x[0])

		for i, sle in enumerate(sle):
			self.assertEquals(expected_sle[i][0], sle[0])
			self.assertEquals(expected_sle[i][1], sle[1])
			self.assertEquals(expected_sle[i][2], sle[2])

	def check_gl_entries(self, voucher_type, voucher_no, expected_gl_entries):
		expected_gl_entries.sort(key=lambda x: x[0])

		gl_entries = frappe.db.sql("""select account, debit, credit
			from `tabGL Entry` where voucher_type=%s and voucher_no=%s
			order by account asc, debit asc""", (voucher_type, voucher_no), as_list=1)
		self.assertTrue(gl_entries)
		gl_entries.sort(key=lambda x: x[0])

		for i, gle in enumerate(gl_entries):
			self.assertEquals(expected_gl_entries[i][0], gle[0])
			self.assertEquals(expected_gl_entries[i][1], gle[1])
			self.assertEquals(expected_gl_entries[i][2], gle[2])

	def _insert_material_receipt(self):
		self._clear_stock_account_balance()
		se1 = frappe.copy_doc(test_records[0])
		se1.insert()
		se1.submit()

		se2 = frappe.copy_doc(test_records[0])
		se2.get("mtn_details")[0].item_code = "_Test Item Home Desktop 100"
		se2.insert()
		se2.submit()

		frappe.db.set_default("company", self.old_default_company)

	def _get_actual_qty(self):
		return flt(frappe.db.get_value("Bin", {"item_code": "_Test Item",
			"warehouse": "_Test Warehouse - _TC"}, "actual_qty"))

	def _test_sales_invoice_return(self, item_code, delivered_qty, returned_qty):
		from erpnext.stock.doctype.stock_entry.stock_entry import NotUpdateStockError

		from erpnext.accounts.doctype.sales_invoice.test_sales_invoice \
			import test_records as sales_invoice_test_records

		# invalid sales invoice as update stock not checked
		si = frappe.copy_doc(sales_invoice_test_records[1])
		si.insert()
		si.submit()

		se = frappe.copy_doc(test_records[0])
		se.purpose = "Sales Return"
		se.sales_invoice_no = si.name
		se.get("mtn_details")[0].qty = returned_qty
		se.get("mtn_details")[0].transfer_qty = returned_qty
		self.assertRaises(NotUpdateStockError, se.insert)

		self._insert_material_receipt()

		# check currency available qty in bin
		actual_qty_0 = self._get_actual_qty()

		# insert a pos invoice with update stock
		si = frappe.copy_doc(sales_invoice_test_records[1])
		si.update_stock = 1
		si.get("entries")[0].warehouse = "_Test Warehouse - _TC"
		si.get("entries")[0].item_code = item_code
		si.get("entries")[0].qty = 5.0
		si.insert()
		si.submit()

		# check available bin qty after invoice submission
		actual_qty_1 = self._get_actual_qty()

		self.assertEquals(actual_qty_0 - delivered_qty, actual_qty_1)

		# check if item is validated
		se = frappe.copy_doc(test_records[0])
		se.purpose = "Sales Return"
		se.sales_invoice_no = si.name
		se.posting_date = "2013-03-10"
		se.fiscal_year = "_Test Fiscal Year 2013"
		se.get("mtn_details")[0].item_code = "_Test Item Home Desktop 200"
		se.get("mtn_details")[0].qty = returned_qty
		se.get("mtn_details")[0].transfer_qty = returned_qty

		# check if stock entry gets submitted
		self.assertRaises(frappe.DoesNotExistError, se.insert)

		# try again
		se = frappe.copy_doc(test_records[0])
		se.purpose = "Sales Return"
		se.posting_date = "2013-03-10"
		se.fiscal_year = "_Test Fiscal Year 2013"
		se.sales_invoice_no = si.name
		se.get("mtn_details")[0].qty = returned_qty
		se.get("mtn_details")[0].transfer_qty = returned_qty
		# in both cases item code remains _Test Item when returning
		se.insert()

		se.submit()

		# check if available qty is increased
		actual_qty_2 = self._get_actual_qty()

		self.assertEquals(actual_qty_1 + returned_qty, actual_qty_2)

		return se

	def test_sales_invoice_return_of_non_packing_item(self):
		self._clear_stock_account_balance()
		self._test_sales_invoice_return("_Test Item", 5, 2)

	def test_sales_invoice_return_of_packing_item(self):
		self._clear_stock_account_balance()
		self._test_sales_invoice_return("_Test Sales BOM Item", 25, 20)

	def _test_delivery_note_return(self, item_code, delivered_qty, returned_qty):
		self._insert_material_receipt()

		from erpnext.stock.doctype.delivery_note.test_delivery_note \
			import test_records as delivery_note_test_records

		from erpnext.stock.doctype.delivery_note.delivery_note import make_sales_invoice

		actual_qty_0 = self._get_actual_qty()
		# make a delivery note based on this invoice
		dn = frappe.copy_doc(delivery_note_test_records[0])
		dn.get("delivery_note_details")[0].item_code = item_code
		dn.insert()
		dn.submit()

		actual_qty_1 = self._get_actual_qty()

		self.assertEquals(actual_qty_0 - delivered_qty, actual_qty_1)

		si_doc = make_sales_invoice(dn.name)

		si = frappe.get_doc(si_doc)
		si.posting_date = dn.posting_date
		si.debit_to = "_Test Customer - _TC"
		for d in si.get("entries"):
			d.income_account = "Sales - _TC"
			d.cost_center = "_Test Cost Center - _TC"
		si.insert()
		si.submit()

		# insert and submit stock entry for sales return
		se = frappe.copy_doc(test_records[0])
		se.purpose = "Sales Return"
		se.delivery_note_no = dn.name
		se.posting_date = "2013-03-10"
		se.fiscal_year = "_Test Fiscal Year 2013"
		se.get("mtn_details")[0].qty = se.get("mtn_details")[0].transfer_qty = returned_qty

		se.insert()
		se.submit()

		actual_qty_2 = self._get_actual_qty()
		self.assertEquals(actual_qty_1 + returned_qty, actual_qty_2)

		return se

	def test_delivery_note_return_of_non_packing_item(self):
		self._clear_stock_account_balance()
		self._test_delivery_note_return("_Test Item", 5, 2)

	def test_delivery_note_return_of_packing_item(self):
		self._clear_stock_account_balance()
		self._test_delivery_note_return("_Test Sales BOM Item", 25, 20)

	def _test_sales_return_jv(self, se):
		from erpnext.stock.doctype.stock_entry.stock_entry import make_return_jv
		jv = make_return_jv(se.name)

		self.assertEqual(len(jv.get("entries")), 2)
		self.assertEqual(jv.get("voucher_type"), "Credit Note")
		self.assertEqual(jv.get("posting_date"), se.posting_date)
		self.assertEqual(jv.get("entries")[0].get("account"), "_Test Customer - _TC")
		self.assertEqual(jv.get("entries")[1].get("account"), "Sales - _TC")
		self.assertTrue(jv.get("entries")[0].get("against_invoice"))

	def test_make_return_jv_for_sales_invoice_non_packing_item(self):
		self._clear_stock_account_balance()
		se = self._test_sales_invoice_return("_Test Item", 5, 2)
		self._test_sales_return_jv(se)

	def test_make_return_jv_for_sales_invoice_packing_item(self):
		self._clear_stock_account_balance()
		se = self._test_sales_invoice_return("_Test Sales BOM Item", 25, 20)
		self._test_sales_return_jv(se)

	def test_make_return_jv_for_delivery_note_non_packing_item(self):
		self._clear_stock_account_balance()
		se = self._test_delivery_note_return("_Test Item", 5, 2)
		self._test_sales_return_jv(se)

		se = self._test_delivery_note_return_against_sales_order("_Test Item", 5, 2)
		self._test_sales_return_jv(se)

	def test_make_return_jv_for_delivery_note_packing_item(self):
		self._clear_stock_account_balance()
		se = self._test_delivery_note_return("_Test Sales BOM Item", 25, 20)
		self._test_sales_return_jv(se)

		se = self._test_delivery_note_return_against_sales_order("_Test Sales BOM Item", 25, 20)
		self._test_sales_return_jv(se)

	def _test_delivery_note_return_against_sales_order(self, item_code, delivered_qty, returned_qty):
		self._insert_material_receipt()

		from erpnext.selling.doctype.sales_order.test_sales_order import test_records as sales_order_test_records
		from erpnext.selling.doctype.sales_order.sales_order import make_sales_invoice, make_delivery_note

		actual_qty_0 = self._get_actual_qty()

		so = frappe.copy_doc(sales_order_test_records[0])
		so.get("sales_order_details")[0].item_code = item_code
		so.get("sales_order_details")[0].qty = 5.0
		so.insert()
		so.submit()

		dn = make_delivery_note(so.name)
		dn.status = "Draft"
		dn.posting_date = so.delivery_date
		dn.insert()
		dn.submit()

		actual_qty_1 = self._get_actual_qty()
		self.assertEquals(actual_qty_0 - delivered_qty, actual_qty_1)

		si = make_sales_invoice(so.name)
		si.posting_date = dn.posting_date
		si.debit_to = "_Test Customer - _TC"
		for d in si.get("entries"):
			d.income_account = "Sales - _TC"
			d.cost_center = "_Test Cost Center - _TC"
		si.insert()
		si.submit()

		# insert and submit stock entry for sales return
		se = frappe.copy_doc(test_records[0])
		se.purpose = "Sales Return"
		se.delivery_note_no = dn.name
		se.posting_date = "2013-03-10"
		se.fiscal_year = "_Test Fiscal Year 2013"
		se.get("mtn_details")[0].qty = se.get("mtn_details")[0].transfer_qty = returned_qty

		se.insert()
		se.submit()

		actual_qty_2 = self._get_actual_qty()
		self.assertEquals(actual_qty_1 + returned_qty, actual_qty_2)

		return se

	def test_purchase_receipt_return(self):
		self._clear_stock_account_balance()

		actual_qty_0 = self._get_actual_qty()

		from erpnext.stock.doctype.purchase_receipt.test_purchase_receipt \
			import test_records as purchase_receipt_test_records

		from erpnext.stock.doctype.purchase_receipt.purchase_receipt import make_purchase_invoice

		# submit purchase receipt
		pr = frappe.copy_doc(purchase_receipt_test_records[0])
		pr.insert()
		pr.submit()

		actual_qty_1 = self._get_actual_qty()

		self.assertEquals(actual_qty_0 + 5, actual_qty_1)

		pi_doc = make_purchase_invoice(pr.name)

		pi = frappe.get_doc(pi_doc)
		pi.posting_date = pr.posting_date
		pi.credit_to = "_Test Supplier - _TC"
		for d in pi.get("entries"):
			d.expense_account = "_Test Account Cost for Goods Sold - _TC"
			d.cost_center = "_Test Cost Center - _TC"

		for d in pi.get("other_charges"):
			d.cost_center = "_Test Cost Center - _TC"

		pi.run_method("calculate_taxes_and_totals")
		pi.bill_no = "NA"
		pi.insert()
		pi.submit()

		# submit purchase return
		se = frappe.copy_doc(test_records[0])
		se.purpose = "Purchase Return"
		se.purchase_receipt_no = pr.name
		se.posting_date = "2013-03-01"
		se.fiscal_year = "_Test Fiscal Year 2013"
		se.get("mtn_details")[0].qty = se.get("mtn_details")[0].transfer_qty = 5
		se.get("mtn_details")[0].s_warehouse = "_Test Warehouse - _TC"
		se.insert()
		se.submit()

		actual_qty_2 = self._get_actual_qty()

		self.assertEquals(actual_qty_1 - 5, actual_qty_2)

		frappe.db.set_default("company", self.old_default_company)

		return se, pr.name

	def test_over_stock_return(self):
		from erpnext.stock.doctype.stock_entry.stock_entry import StockOverReturnError
		self._clear_stock_account_balance()

		# out of 10, 5 gets returned
		prev_se, pr_docname = self.test_purchase_receipt_return()

		# submit purchase return - return another 6 qtys so that exception is raised
		se = frappe.copy_doc(test_records[0])
		se.purpose = "Purchase Return"
		se.purchase_receipt_no = pr_docname
		se.posting_date = "2013-03-01"
		se.fiscal_year = "_Test Fiscal Year 2013"
		se.get("mtn_details")[0].qty = se.get("mtn_details")[0].transfer_qty = 6
		se.get("mtn_details")[0].s_warehouse = "_Test Warehouse - _TC"

		self.assertRaises(StockOverReturnError, se.insert)

	def _test_purchase_return_jv(self, se):
		from erpnext.stock.doctype.stock_entry.stock_entry import make_return_jv
		jv = make_return_jv(se.name)

		self.assertEqual(len(jv.get("entries")), 2)
		self.assertEqual(jv.get("voucher_type"), "Debit Note")
		self.assertEqual(jv.get("posting_date"), se.posting_date)
		self.assertEqual(jv.get("entries")[0].get("account"), "_Test Supplier - _TC")
		self.assertEqual(jv.get("entries")[1].get("account"), "_Test Account Cost for Goods Sold - _TC")
		self.assertTrue(jv.get("entries")[0].get("against_voucher"))

	def test_make_return_jv_for_purchase_receipt(self):
		self._clear_stock_account_balance()
		se, pr_name = self.test_purchase_receipt_return()
		self._test_purchase_return_jv(se)

		se, pr_name = self._test_purchase_return_return_against_purchase_order()
		self._test_purchase_return_jv(se)

	def _test_purchase_return_return_against_purchase_order(self):
		self._clear_stock_account_balance()

		actual_qty_0 = self._get_actual_qty()

		from erpnext.buying.doctype.purchase_order.test_purchase_order \
			import test_records as purchase_order_test_records

		from erpnext.buying.doctype.purchase_order.purchase_order import \
			make_purchase_receipt, make_purchase_invoice

		# submit purchase receipt
		po = frappe.copy_doc(purchase_order_test_records[0])
		po.is_subcontracted = None
		po.get("po_details")[0].item_code = "_Test Item"
		po.get("po_details")[0].rate = 50
		po.insert()
		po.submit()

		pr_doc = make_purchase_receipt(po.name)

		pr = frappe.get_doc(pr_doc)
		pr.posting_date = po.transaction_date
		pr.insert()
		pr.submit()

		actual_qty_1 = self._get_actual_qty()

		self.assertEquals(actual_qty_0 + 10, actual_qty_1)

		pi_doc = make_purchase_invoice(po.name)

		pi = frappe.get_doc(pi_doc)
		pi.posting_date = pr.posting_date
		pi.credit_to = "_Test Supplier - _TC"
		for d in pi.get("entries"):
			d.expense_account = "_Test Account Cost for Goods Sold - _TC"
			d.cost_center = "_Test Cost Center - _TC"
		for d in pi.get("other_charges"):
			d.cost_center = "_Test Cost Center - _TC"

		pi.run_method("calculate_taxes_and_totals")
		pi.bill_no = "NA"
		pi.insert()
		pi.submit()

		# submit purchase return
		se = frappe.copy_doc(test_records[0])
		se.purpose = "Purchase Return"
		se.purchase_receipt_no = pr.name
		se.posting_date = "2013-03-01"
		se.fiscal_year = "_Test Fiscal Year 2013"
		se.get("mtn_details")[0].qty = se.get("mtn_details")[0].transfer_qty = 5
		se.get("mtn_details")[0].s_warehouse = "_Test Warehouse - _TC"
		se.insert()
		se.submit()

		actual_qty_2 = self._get_actual_qty()

		self.assertEquals(actual_qty_1 - 5, actual_qty_2)

		frappe.db.set_default("company", self.old_default_company)

		return se, pr.name

	def _clear_stock_account_balance(self):
		frappe.db.sql("delete from `tabStock Ledger Entry`")
		frappe.db.sql("""delete from `tabBin`""")
		frappe.db.sql("""delete from `tabGL Entry`""")

		self.old_default_company = frappe.db.get_default("company")
		frappe.db.set_default("company", "_Test Company")

	def test_serial_no_not_reqd(self):
		se = frappe.copy_doc(test_records[0])
		se.get("mtn_details")[0].serial_no = "ABCD"
		se.insert()
		self.assertRaises(SerialNoNotRequiredError, se.submit)

	def test_serial_no_reqd(self):
		se = frappe.copy_doc(test_records[0])
		se.get("mtn_details")[0].item_code = "_Test Serialized Item"
		se.get("mtn_details")[0].qty = 2
		se.get("mtn_details")[0].transfer_qty = 2
		se.insert()
		self.assertRaises(SerialNoRequiredError, se.submit)

	def test_serial_no_qty_more(self):
		se = frappe.copy_doc(test_records[0])
		se.get("mtn_details")[0].item_code = "_Test Serialized Item"
		se.get("mtn_details")[0].qty = 2
		se.get("mtn_details")[0].serial_no = "ABCD\nEFGH\nXYZ"
		se.get("mtn_details")[0].transfer_qty = 2
		se.insert()
		self.assertRaises(SerialNoQtyError, se.submit)

	def test_serial_no_qty_less(self):
		se = frappe.copy_doc(test_records[0])
		se.get("mtn_details")[0].item_code = "_Test Serialized Item"
		se.get("mtn_details")[0].qty = 2
		se.get("mtn_details")[0].serial_no = "ABCD"
		se.get("mtn_details")[0].transfer_qty = 2
		se.insert()
		self.assertRaises(SerialNoQtyError, se.submit)

	def test_serial_no_transfer_in(self):
		self._clear_stock_account_balance()
		se = frappe.copy_doc(test_records[0])
		se.get("mtn_details")[0].item_code = "_Test Serialized Item"
		se.get("mtn_details")[0].qty = 2
		se.get("mtn_details")[0].serial_no = "ABCD\nEFGH"
		se.get("mtn_details")[0].transfer_qty = 2
		se.insert()
		se.submit()

		self.assertTrue(frappe.db.exists("Serial No", "ABCD"))
		self.assertTrue(frappe.db.exists("Serial No", "EFGH"))

		se.cancel()
		self.assertFalse(frappe.db.get_value("Serial No", "ABCD", "warehouse"))

	def test_serial_no_not_exists(self):
		self._clear_stock_account_balance()
		frappe.db.sql("delete from `tabSerial No` where name in ('ABCD', 'EFGH')")
		se = frappe.copy_doc(test_records[0])
		se.purpose = "Material Issue"
		se.get("mtn_details")[0].item_code = "_Test Serialized Item"
		se.get("mtn_details")[0].qty = 2
		se.get("mtn_details")[0].s_warehouse = "_Test Warehouse 1 - _TC"
		se.get("mtn_details")[0].t_warehouse = None
		se.get("mtn_details")[0].serial_no = "ABCD\nEFGH"
		se.get("mtn_details")[0].transfer_qty = 2
		se.insert()
		self.assertRaises(SerialNoNotExistsError, se.submit)

	def test_serial_duplicate(self):
		self._clear_stock_account_balance()
		se, serial_nos = self.test_serial_by_series()

		se = frappe.copy_doc(test_records[0])
		se.get("mtn_details")[0].item_code = "_Test Serialized Item With Series"
		se.get("mtn_details")[0].qty = 1
		se.get("mtn_details")[0].serial_no = serial_nos[0]
		se.get("mtn_details")[0].transfer_qty = 1
		se.insert()
		self.assertRaises(SerialNoDuplicateError, se.submit)

	def test_serial_by_series(self):
		self._clear_stock_account_balance()
		se = make_serialized_item()

		serial_nos = get_serial_nos(se.get("mtn_details")[0].serial_no)

		self.assertTrue(frappe.db.exists("Serial No", serial_nos[0]))
		self.assertTrue(frappe.db.exists("Serial No", serial_nos[1]))

		return se, serial_nos

	def test_serial_item_error(self):
		self._clear_stock_account_balance()
		se, serial_nos = self.test_serial_by_series()

		se = frappe.copy_doc(test_records[0])
		se.purpose = "Material Transfer"
		se.get("mtn_details")[0].item_code = "_Test Serialized Item"
		se.get("mtn_details")[0].qty = 1
		se.get("mtn_details")[0].transfer_qty = 1
		se.get("mtn_details")[0].serial_no = serial_nos[0]
		se.get("mtn_details")[0].s_warehouse = "_Test Warehouse - _TC"
		se.get("mtn_details")[0].t_warehouse = "_Test Warehouse 1 - _TC"
		se.insert()
		self.assertRaises(SerialNoItemError, se.submit)

	def test_serial_move(self):
		self._clear_stock_account_balance()
		se = make_serialized_item()
		serial_no = get_serial_nos(se.get("mtn_details")[0].serial_no)[0]

		se = frappe.copy_doc(test_records[0])
		se.purpose = "Material Transfer"
		se.get("mtn_details")[0].item_code = "_Test Serialized Item With Series"
		se.get("mtn_details")[0].qty = 1
		se.get("mtn_details")[0].transfer_qty = 1
		se.get("mtn_details")[0].serial_no = serial_no
		se.get("mtn_details")[0].s_warehouse = "_Test Warehouse - _TC"
		se.get("mtn_details")[0].t_warehouse = "_Test Warehouse 1 - _TC"
		se.insert()
		se.submit()
		self.assertTrue(frappe.db.get_value("Serial No", serial_no, "warehouse"), "_Test Warehouse 1 - _TC")

		se.cancel()
		self.assertTrue(frappe.db.get_value("Serial No", serial_no, "warehouse"), "_Test Warehouse - _TC")

	def test_serial_warehouse_error(self):
		self._clear_stock_account_balance()
		t = make_serialized_item()
		serial_nos = get_serial_nos(t.get("mtn_details")[0].serial_no)

		se = frappe.copy_doc(test_records[0])
		se.purpose = "Material Transfer"
		se.get("mtn_details")[0].item_code = "_Test Serialized Item With Series"
		se.get("mtn_details")[0].qty = 1
		se.get("mtn_details")[0].transfer_qty = 1
		se.get("mtn_details")[0].serial_no = serial_nos[0]
		se.get("mtn_details")[0].s_warehouse = "_Test Warehouse 1 - _TC"
		se.get("mtn_details")[0].t_warehouse = "_Test Warehouse - _TC"
		se.insert()
		self.assertRaises(SerialNoWarehouseError, se.submit)

	def test_serial_cancel(self):
		self._clear_stock_account_balance()
		se, serial_nos = self.test_serial_by_series()
		se.cancel()

		serial_no = get_serial_nos(se.get("mtn_details")[0].serial_no)[0]
		self.assertFalse(frappe.db.get_value("Serial No", serial_no, "warehouse"))

	def test_warehouse_company_validation(self):
		set_perpetual_inventory(0)
		self._clear_stock_account_balance()
		frappe.get_doc("User", "test2@example.com")\
			.add_roles("Sales User", "Sales Manager", "Material User", "Material Manager")
		frappe.set_user("test2@example.com")

		from erpnext.stock.utils import InvalidWarehouseCompany
		st1 = frappe.copy_doc(test_records[0])
		st1.get("mtn_details")[0].t_warehouse="_Test Warehouse 2 - _TC1"
		st1.insert()
		self.assertRaises(InvalidWarehouseCompany, st1.submit)

	# permission tests
	def test_warehouse_user(self):
		set_perpetual_inventory(0)

		frappe.defaults.add_default("Warehouse", "_Test Warehouse 1 - _TC", "test@example.com", "Restriction")
		frappe.defaults.add_default("Warehouse", "_Test Warehouse 2 - _TC1", "test2@example.com", "Restriction")
		frappe.get_doc("User", "test@example.com")\
			.add_roles("Sales User", "Sales Manager", "Material User", "Material Manager")
		frappe.get_doc("User", "test2@example.com")\
			.add_roles("Sales User", "Sales Manager", "Material User", "Material Manager")

		frappe.set_user("test@example.com")
		st1 = frappe.copy_doc(test_records[0])
		st1.company = "_Test Company 1"
		st1.get("mtn_details")[0].t_warehouse="_Test Warehouse 2 - _TC1"
		self.assertRaises(frappe.PermissionError, st1.insert)

		frappe.set_user("test2@example.com")
		st1 = frappe.copy_doc(test_records[0])
		st1.company = "_Test Company 1"
		st1.get("mtn_details")[0].t_warehouse="_Test Warehouse 2 - _TC1"
		st1.insert()
		st1.submit()

		frappe.defaults.clear_default("Warehouse", "_Test Warehouse 1 - _TC",
			"test@example.com", parenttype="Restriction")
		frappe.defaults.clear_default("Warehouse", "_Test Warehouse 2 - _TC1",
			"test2@example.com", parenttype="Restriction")

	def test_freeze_stocks (self):
		self._clear_stock_account_balance()
		frappe.db.set_value('Stock Settings', None,'stock_auth_role', '')

		# test freeze_stocks_upto
		date_newer_than_test_records = add_days(getdate(test_records[0]['posting_date']), 5)
		frappe.db.set_value("Stock Settings", None, "stock_frozen_upto", date_newer_than_test_records)
		se = frappe.copy_doc(test_records[0]).insert()
		self.assertRaises (StockFreezeError, se.submit)
		frappe.db.set_value("Stock Settings", None, "stock_frozen_upto", '')

		# test freeze_stocks_upto_days
		frappe.db.set_value("Stock Settings", None, "stock_frozen_upto_days", 7)
		se = frappe.copy_doc(test_records[0]).insert()
		self.assertRaises (StockFreezeError, se.submit)
		frappe.db.set_value("Stock Settings", None, "stock_frozen_upto_days", 0)

def make_serialized_item():
	se = frappe.copy_doc(test_records[0])
	se.get("mtn_details")[0].item_code = "_Test Serialized Item With Series"
	se.get("mtn_details")[0].qty = 2
	se.get("mtn_details")[0].transfer_qty = 2
	se.insert()
	se.submit()
	return se

def make_stock_entry(item, source, target, qty, incoming_rate=None):
	s = frappe.new_doc("Stock Entry")
	if source and target:
		s.purpose = "Material Transfer"
	elif source:
		s.purpose = "Material Issue"
	else:
		s.purpose = "Material Receipt"
	s.company = "_Test Company"
	s.append("mtn_details", {
		"item_code": item,
		"s_warehouse": source,
		"t_warehouse": target,
		"qty": qty,
		"incoming_rate": incoming_rate,
		"conversion_factor": 1.0
	})
	s.insert()
	s.submit()
	return s

test_records = frappe.get_test_records('Stock Entry')

########NEW FILE########
__FILENAME__ = stock_entry_detail
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class StockEntryDetail(Document):
	pass
########NEW FILE########
__FILENAME__ = stock_ledger_entry

# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.utils import flt, getdate, add_days, formatdate
from frappe.model.document import Document
from datetime import date

class StockFreezeError(frappe.ValidationError): pass

class StockLedgerEntry(Document):
	def validate(self):
		from erpnext.stock.utils import validate_warehouse_company
		self.validate_mandatory()
		self.validate_item()
		validate_warehouse_company(self.warehouse, self.company)
		self.scrub_posting_time()

		from erpnext.accounts.utils import validate_fiscal_year
		validate_fiscal_year(self.posting_date, self.fiscal_year,
			self.meta.get_label("posting_date"))

	def on_submit(self):
		self.check_stock_frozen_date()
		self.actual_amt_check()

		from erpnext.stock.doctype.serial_no.serial_no import process_serial_no
		process_serial_no(self)

	#check for item quantity available in stock
	def actual_amt_check(self):
		if self.batch_no:
			batch_bal_after_transaction = flt(frappe.db.sql("""select sum(actual_qty)
				from `tabStock Ledger Entry`
				where warehouse=%s and item_code=%s and batch_no=%s""",
				(self.warehouse, self.item_code, self.batch_no))[0][0])

			if batch_bal_after_transaction < 0:
				frappe.throw(_("Negative balance in Batch {0} for Item {1} at Warehouse {2} on {3} {4}").format(\
					batch_bal_after_transaction - self.actual_qty, self.item_code, self.warehouse,
						formatdate(self.posting_date), self.posting_time))

	def validate_mandatory(self):
		mandatory = ['warehouse','posting_date','voucher_type','voucher_no','actual_qty','company']
		for k in mandatory:
			if not self.get(k):
				frappe.throw(_("{0} is required").format(self.meta.get_label(k)))

	def validate_item(self):
		item_det = frappe.db.sql("""select name, has_batch_no, docstatus, is_stock_item
			from tabItem where name=%s""", self.item_code, as_dict=True)[0]

		if item_det.is_stock_item != 'Yes':
			frappe.throw(_("Item {0} must be a stock Item").format(self.item_code))

		# check if batch number is required
		if item_det.has_batch_no =='Yes' and self.voucher_type != 'Stock Reconciliation':
			if not self.batch_no:
				frappe.throw("Batch number is mandatory for Item {0}".format(self.item_code))

			# check if batch belongs to item
			if not frappe.db.get_value("Batch",
					{"item": self.item_code, "name": self.batch_no}):
				frappe.throw(_("{0} is not a valid Batch Number for Item {1}").format(self.batch_no, self.item_code))

		if not self.stock_uom:
			self.stock_uom = item_det.stock_uom

	def check_stock_frozen_date(self):
		stock_frozen_upto = frappe.db.get_value('Stock Settings', None, 'stock_frozen_upto') or ''
		if stock_frozen_upto:
			stock_auth_role = frappe.db.get_value('Stock Settings', None,'stock_auth_role')
			if getdate(self.posting_date) <= getdate(stock_frozen_upto) and not stock_auth_role in frappe.user.get_roles():
				frappe.throw(_("Entries before {0} are frozen").format(formatdate(stock_frozen_upto)), StockFreezeError)

		stock_frozen_upto_days = int(frappe.db.get_value('Stock Settings', None, 'stock_frozen_upto_days') or 0)
		if stock_frozen_upto_days:
			stock_auth_role = frappe.db.get_value('Stock Settings', None,'stock_auth_role')
			older_than_x_days_ago = (add_days(getdate(self.posting_date), stock_frozen_upto_days) <= date.today())
			if older_than_x_days_ago and not stock_auth_role in frappe.user.get_roles():
				frappe.throw(_("Not allowed to update entries older than {0}").format(stock_frozen_upto_days), StockFreezeError)

	def scrub_posting_time(self):
		if not self.posting_time or self.posting_time == '00:0':
			self.posting_time = '00:00'

def on_doctype_update():
	if not frappe.db.sql("""show index from `tabStock Ledger Entry`
		where Key_name="posting_sort_index" """):
		frappe.db.commit()
		frappe.db.sql("""alter table `tabStock Ledger Entry`
			add index posting_sort_index(posting_date, posting_time, name)""")

########NEW FILE########
__FILENAME__ = stock_reconciliation
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
import frappe.defaults
import json
from frappe import msgprint, _
from frappe.utils import cstr, flt, cint
from erpnext.stock.stock_ledger import update_entries_after
from erpnext.controllers.stock_controller import StockController

class StockReconciliation(StockController):
	def validate(self):
		self.head_row = ["Item Code", "Warehouse", "Quantity", "Valuation Rate"]
		self.entries = []

		self.validate_data()
		self.validate_expense_account()

	def on_submit(self):
		self.insert_stock_ledger_entries()
		self.make_gl_entries()

	def on_cancel(self):
		self.delete_and_repost_sle()
		self.make_cancel_gl_entries()

	def validate_data(self):
		if not self.reconciliation_json:
			return

		data = json.loads(self.reconciliation_json)

		# strip out extra columns (if any)
		data = [row[:4] for row in data]

		if self.head_row not in data:
			msgprint(_("""Wrong Template: Unable to find head row."""),
				raise_exception=1)

		# remove the help part and save the json
		head_row_no = 0
		if data.index(self.head_row) != 0:
			head_row_no = data.index(self.head_row)
			data = data[head_row_no:]
			self.reconciliation_json = json.dumps(data)

		def _get_msg(row_num, msg):
			return _("Row # {0}: ").format(row_num+head_row_no+2) + msg

		self.validation_messages = []
		item_warehouse_combinations = []

		# validate no of rows
		rows = data[1:]
		if len(rows) > 100:
			msgprint(_("""Sorry! We can only allow upto 100 rows for Stock Reconciliation."""),
				raise_exception=True)
		for row_num, row in enumerate(rows):
			# find duplicates
			if [row[0], row[1]] in item_warehouse_combinations:
				self.validation_messages.append(_get_msg(row_num, _("Duplicate entry")))
			else:
				item_warehouse_combinations.append([row[0], row[1]])

			self.validate_item(row[0], row_num+head_row_no+2)

			# validate warehouse
			if not frappe.db.get_value("Warehouse", row[1]):
				self.validation_messages.append(_get_msg(row_num, _("Warehouse not found in the system")))

			# if both not specified
			if row[2] == "" and row[3] == "":
				self.validation_messages.append(_get_msg(row_num,
					_("Please specify either Quantity or Valuation Rate or both")))

			# do not allow negative quantity
			if flt(row[2]) < 0:
				self.validation_messages.append(_get_msg(row_num,
					_("Negative Quantity is not allowed")))

			# do not allow negative valuation
			if flt(row[3]) < 0:
				self.validation_messages.append(_get_msg(row_num,
					_("Negative Valuation Rate is not allowed")))

		# throw all validation messages
		if self.validation_messages:
			for msg in self.validation_messages:
				msgprint(msg)

			raise frappe.ValidationError

	def validate_item(self, item_code, row_num):
		from erpnext.stock.doctype.item.item import validate_end_of_life, \
			validate_is_stock_item, validate_cancelled_item

		# using try except to catch all validation msgs and display together

		try:
			item = frappe.get_doc("Item", item_code)
			if not item:
				raise frappe.ValidationError, (_("Item: {0} not found in the system").format(item_code))

			# end of life and stock item
			validate_end_of_life(item_code, item.end_of_life, verbose=0)
			validate_is_stock_item(item_code, item.is_stock_item, verbose=0)

			# item should not be serialized
			if item.has_serial_no == "Yes":
				raise frappe.ValidationError, _("Serialized Item {0} cannot be updated \
					using Stock Reconciliation").format(item_code)

			# item managed batch-wise not allowed
			if item.has_batch_no == "Yes":
				raise frappe.ValidationError, _("Item: {0} managed batch-wise, can not be reconciled using \
					Stock Reconciliation, instead use Stock Entry").format(item_code)

			# docstatus should be < 2
			validate_cancelled_item(item_code, item.docstatus, verbose=0)

		except Exception, e:
			self.validation_messages.append(_("Row # ") + ("%d: " % (row_num)) + cstr(e))

	def insert_stock_ledger_entries(self):
		"""	find difference between current and expected entries
			and create stock ledger entries based on the difference"""
		from erpnext.stock.utils import get_valuation_method
		from erpnext.stock.stock_ledger import get_previous_sle

		row_template = ["item_code", "warehouse", "qty", "valuation_rate"]

		if not self.reconciliation_json:
			msgprint(_("""Stock Reconciliation file not uploaded"""), raise_exception=1)

		data = json.loads(self.reconciliation_json)
		for row_num, row in enumerate(data[data.index(self.head_row)+1:]):
			row = frappe._dict(zip(row_template, row))
			row["row_num"] = row_num
			previous_sle = get_previous_sle({
				"item_code": row.item_code,
				"warehouse": row.warehouse,
				"posting_date": self.posting_date,
				"posting_time": self.posting_time
			})

			# check valuation rate mandatory
			if row.qty != "" and not row.valuation_rate and \
					flt(previous_sle.get("qty_after_transaction")) <= 0:
				frappe.throw(_("Valuation Rate required for Item {0}").format(row.item_code))

			change_in_qty = row.qty != "" and \
				(flt(row.qty) - flt(previous_sle.get("qty_after_transaction")))

			change_in_rate = row.valuation_rate != "" and \
				(flt(row.valuation_rate) - flt(previous_sle.get("valuation_rate")))

			if get_valuation_method(row.item_code) == "Moving Average":
				self.sle_for_moving_avg(row, previous_sle, change_in_qty, change_in_rate)

			else:
				self.sle_for_fifo(row, previous_sle, change_in_qty, change_in_rate)

	def sle_for_moving_avg(self, row, previous_sle, change_in_qty, change_in_rate):
		"""Insert Stock Ledger Entries for Moving Average valuation"""
		def _get_incoming_rate(qty, valuation_rate, previous_qty, previous_valuation_rate):
			if previous_valuation_rate == 0:
				return flt(valuation_rate)
			else:
				if valuation_rate == "":
					valuation_rate = previous_valuation_rate
				return (qty * valuation_rate - previous_qty * previous_valuation_rate) \
					/ flt(qty - previous_qty)

		if change_in_qty:
			# if change in qty, irrespective of change in rate
			incoming_rate = _get_incoming_rate(flt(row.qty), flt(row.valuation_rate),
				flt(previous_sle.get("qty_after_transaction")),
				flt(previous_sle.get("valuation_rate")))

			row["voucher_detail_no"] = "Row: " + cstr(row.row_num) + "/Actual Entry"
			self.insert_entries({"actual_qty": change_in_qty, "incoming_rate": incoming_rate}, row)

		elif change_in_rate and flt(previous_sle.get("qty_after_transaction")) > 0:
			# if no change in qty, but change in rate
			# and positive actual stock before this reconciliation
			incoming_rate = _get_incoming_rate(
				flt(previous_sle.get("qty_after_transaction"))+1, flt(row.valuation_rate),
				flt(previous_sle.get("qty_after_transaction")),
				flt(previous_sle.get("valuation_rate")))

			# +1 entry
			row["voucher_detail_no"] = "Row: " + cstr(row.row_num) + "/Valuation Adjustment +1"
			self.insert_entries({"actual_qty": 1, "incoming_rate": incoming_rate}, row)

			# -1 entry
			row["voucher_detail_no"] = "Row: " + cstr(row.row_num) + "/Valuation Adjustment -1"
			self.insert_entries({"actual_qty": -1}, row)

	def sle_for_fifo(self, row, previous_sle, change_in_qty, change_in_rate):
		"""Insert Stock Ledger Entries for FIFO valuation"""
		previous_stock_queue = json.loads(previous_sle.get("stock_queue") or "[]")
		previous_stock_qty = sum((batch[0] for batch in previous_stock_queue))
		previous_stock_value = sum((batch[0] * batch[1] for batch in \
			previous_stock_queue))

		def _insert_entries():
			if previous_stock_queue != [[row.qty, row.valuation_rate]]:
				# make entry as per attachment
				if row.qty:
					row["voucher_detail_no"] = "Row: " + cstr(row.row_num) + "/Actual Entry"
					self.insert_entries({"actual_qty": row.qty,
						"incoming_rate": flt(row.valuation_rate)}, row)

				# Make reverse entry
				if previous_stock_qty:
					row["voucher_detail_no"] = "Row: " + cstr(row.row_num) + "/Reverse Entry"
					self.insert_entries({"actual_qty": -1 * previous_stock_qty,
						"incoming_rate": previous_stock_qty < 0 and
							flt(row.valuation_rate) or 0}, row)


		if change_in_qty:
			if row.valuation_rate == "":
				# dont want change in valuation
				if previous_stock_qty > 0:
					# set valuation_rate as previous valuation_rate
					row.valuation_rate = previous_stock_value / flt(previous_stock_qty)

			_insert_entries()

		elif change_in_rate and previous_stock_qty > 0:
			# if no change in qty, but change in rate
			# and positive actual stock before this reconciliation

			row.qty = previous_stock_qty
			_insert_entries()

	def insert_entries(self, opts, row):
		"""Insert Stock Ledger Entries"""
		args = frappe._dict({
			"doctype": "Stock Ledger Entry",
			"item_code": row.item_code,
			"warehouse": row.warehouse,
			"posting_date": self.posting_date,
			"posting_time": self.posting_time,
			"voucher_type": self.doctype,
			"voucher_no": self.name,
			"company": self.company,
			"stock_uom": frappe.db.get_value("Item", row.item_code, "stock_uom"),
			"voucher_detail_no": row.voucher_detail_no,
			"fiscal_year": self.fiscal_year,
			"is_cancelled": "No"
		})
		args.update(opts)
		self.make_sl_entries([args])

		# append to entries
		self.entries.append(args)

	def delete_and_repost_sle(self):
		"""	Delete Stock Ledger Entries related to this voucher
			and repost future Stock Ledger Entries"""

		existing_entries = frappe.db.sql("""select distinct item_code, warehouse
			from `tabStock Ledger Entry` where voucher_type=%s and voucher_no=%s""",
			(self.doctype, self.name), as_dict=1)

		# delete entries
		frappe.db.sql("""delete from `tabStock Ledger Entry`
			where voucher_type=%s and voucher_no=%s""", (self.doctype, self.name))

		# repost future entries for selected item_code, warehouse
		for entries in existing_entries:
			update_entries_after({
				"item_code": entries.item_code,
				"warehouse": entries.warehouse,
				"posting_date": self.posting_date,
				"posting_time": self.posting_time
			})

	def get_gl_entries(self, warehouse_account=None):
		if not self.cost_center:
			msgprint(_("Please enter Cost Center"), raise_exception=1)

		return super(StockReconciliation, self).get_gl_entries(warehouse_account,
			self.expense_account, self.cost_center)

	def validate_expense_account(self):
		if not cint(frappe.defaults.get_global_default("auto_accounting_for_stock")):
			return

		if not self.expense_account:
			msgprint(_("Please enter Expense Account"), raise_exception=1)
		elif not frappe.db.sql("""select * from `tabStock Ledger Entry`"""):
			if frappe.db.get_value("Account", self.expense_account, "report_type") == "Profit and Loss":
				frappe.throw(_("Difference Account must be a 'Liability' type account, since this Stock Reconciliation is an Opening Entry"))

@frappe.whitelist()
def upload():
	from frappe.utils.datautils import read_csv_content_from_uploaded_file
	return read_csv_content_from_uploaded_file()

########NEW FILE########
__FILENAME__ = test_stock_reconciliation
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# ERPNext - web based ERP (http://erpnext.com)
# For license information, please see license.txt

from __future__ import unicode_literals
import frappe, unittest
from frappe.utils import flt
import json
from erpnext.accounts.utils import get_fiscal_year, get_stock_and_account_difference


class TestStockReconciliation(unittest.TestCase):
	def test_reco_for_fifo(self):
		frappe.defaults.set_global_default("auto_accounting_for_stock", 0)
		# [[qty, valuation_rate, posting_date,
		#		posting_time, expected_stock_value, bin_qty, bin_valuation]]
		input_data = [
			[50, 1000, "2012-12-26", "12:00", 50000, 45, 48000],
			[5, 1000, "2012-12-26", "12:00", 5000, 0, 0],
			[15, 1000, "2012-12-26", "12:00", 15000, 10, 12000],
			[25, 900, "2012-12-26", "12:00", 22500, 20, 22500],
			[20, 500, "2012-12-26", "12:00", 10000, 15, 18000],
			[50, 1000, "2013-01-01", "12:00", 50000, 65, 68000],
			[5, 1000, "2013-01-01", "12:00", 5000, 20, 23000],
			["", 1000, "2012-12-26", "12:05", 15000, 10, 12000],
			[20, "", "2012-12-26", "12:05", 16000, 15, 18000],
			[10, 2000, "2012-12-26", "12:10", 20000, 5, 6000],
			[1, 1000, "2012-12-01", "00:00", 1000, 11, 13200],
			[0, "", "2012-12-26", "12:10", 0, -5, 0]
		]

		for d in input_data:
			self.cleanup_data()
			self.insert_existing_sle("FIFO")
			stock_reco = self.submit_stock_reconciliation(d[0], d[1], d[2], d[3])

			# check stock value
			res = frappe.db.sql("""select stock_value from `tabStock Ledger Entry`
				where item_code = '_Test Item' and warehouse = '_Test Warehouse - _TC'
				and posting_date = %s and posting_time = %s order by name desc limit 1""",
				(d[2], d[3]))
			self.assertEqual(res and flt(res[0][0]) or 0, d[4])

			# check bin qty and stock value
			bin = frappe.db.sql("""select actual_qty, stock_value from `tabBin`
				where item_code = '_Test Item' and warehouse = '_Test Warehouse - _TC'""")

			self.assertEqual(bin and [flt(bin[0][0]), flt(bin[0][1])] or [], [d[5], d[6]])

			# no gl entries
			gl_entries = frappe.db.sql("""select name from `tabGL Entry`
				where voucher_type = 'Stock Reconciliation' and voucher_no = %s""",
				 stock_reco.name)
			self.assertFalse(gl_entries)


	def test_reco_for_moving_average(self):
		frappe.defaults.set_global_default("auto_accounting_for_stock", 0)
		# [[qty, valuation_rate, posting_date,
		#		posting_time, expected_stock_value, bin_qty, bin_valuation]]
		input_data = [
			[50, 1000, "2012-12-26", "12:00", 50000, 45, 48000],
			[5, 1000, "2012-12-26", "12:00", 5000, 0, 0],
			[15, 1000, "2012-12-26", "12:00", 15000, 10, 12000],
			[25, 900, "2012-12-26", "12:00", 22500, 20, 22500],
			[20, 500, "2012-12-26", "12:00", 10000, 15, 18000],
			[50, 1000, "2013-01-01", "12:00", 50000, 65, 68000],
			[5, 1000, "2013-01-01", "12:00", 5000, 20, 23000],
			["", 1000, "2012-12-26", "12:05", 15000, 10, 12000],
			[20, "", "2012-12-26", "12:05", 18000, 15, 18000],
			[10, 2000, "2012-12-26", "12:10", 20000, 5, 6000],
			[1, 1000, "2012-12-01", "00:00", 1000, 11, 13200],
			[0, "", "2012-12-26", "12:10", 0, -5, 0]

		]

		for d in input_data:
			self.cleanup_data()
			self.insert_existing_sle("Moving Average")
			stock_reco = self.submit_stock_reconciliation(d[0], d[1], d[2], d[3])

			# check stock value in sle
			res = frappe.db.sql("""select stock_value from `tabStock Ledger Entry`
				where item_code = '_Test Item' and warehouse = '_Test Warehouse - _TC'
				and posting_date = %s and posting_time = %s order by name desc limit 1""",
				(d[2], d[3]))

			self.assertEqual(res and flt(res[0][0], 4) or 0, d[4])

			# bin qty and stock value
			bin = frappe.db.sql("""select actual_qty, stock_value from `tabBin`
				where item_code = '_Test Item' and warehouse = '_Test Warehouse - _TC'""")

			self.assertEqual(bin and [flt(bin[0][0]), flt(bin[0][1], 4)] or [],
				[flt(d[5]), flt(d[6])])

			# no gl entries
			gl_entries = frappe.db.sql("""select name from `tabGL Entry`
				where voucher_type = 'Stock Reconciliation' and voucher_no = %s""",
				stock_reco.name)
			self.assertFalse(gl_entries)

	def test_reco_fifo_gl_entries(self):
		frappe.defaults.set_global_default("auto_accounting_for_stock", 1)

		# [[qty, valuation_rate, posting_date, posting_time, stock_in_hand_debit]]
		input_data = [
			[50, 1000, "2012-12-26", "12:00"],
			[5, 1000, "2012-12-26", "12:00"],
			[15, 1000, "2012-12-26", "12:00"],
			[25, 900, "2012-12-26", "12:00"],
			[20, 500, "2012-12-26", "12:00"],
			["", 1000, "2012-12-26", "12:05"],
			[20, "", "2012-12-26", "12:05"],
			[10, 2000, "2012-12-26", "12:10"],
			[0, "", "2012-12-26", "12:10"],
			[50, 1000, "2013-01-01", "12:00"],
			[5, 1000, "2013-01-01", "12:00"],
			[1, 1000, "2012-12-01", "00:00"],
		]

		for d in input_data:
			self.cleanup_data()
			self.insert_existing_sle("FIFO")
			self.assertFalse(get_stock_and_account_difference(["_Test Account Stock In Hand - _TC"]))
			stock_reco = self.submit_stock_reconciliation(d[0], d[1], d[2], d[3])


			self.assertFalse(get_stock_and_account_difference(["_Test Account Stock In Hand - _TC"]))

			stock_reco.cancel()
			self.assertFalse(get_stock_and_account_difference(["_Test Account Stock In Hand - _TC"]))

		frappe.defaults.set_global_default("auto_accounting_for_stock", 0)

	def test_reco_moving_average_gl_entries(self):
		frappe.defaults.set_global_default("auto_accounting_for_stock", 1)

		# [[qty, valuation_rate, posting_date,
		#		posting_time, stock_in_hand_debit]]
		input_data = [
			[50, 1000, "2012-12-26", "12:00", 36500],
			[5, 1000, "2012-12-26", "12:00", -8500],
			[15, 1000, "2012-12-26", "12:00", 1500],
			[25, 900, "2012-12-26", "12:00", 9000],
			[20, 500, "2012-12-26", "12:00", -3500],
			["", 1000, "2012-12-26", "12:05", 1500],
			[20, "", "2012-12-26", "12:05", 4500],
			[10, 2000, "2012-12-26", "12:10", 6500],
			[0, "", "2012-12-26", "12:10", -13500],
			[50, 1000, "2013-01-01", "12:00", 50000],
			[5, 1000, "2013-01-01", "12:00", 5000],
			[1, 1000, "2012-12-01", "00:00", 1000],

		]

		for d in input_data:
			self.cleanup_data()
			self.insert_existing_sle("Moving Average")
			stock_reco = self.submit_stock_reconciliation(d[0], d[1], d[2], d[3])
			self.assertFalse(get_stock_and_account_difference(["_Test Warehouse - _TC"]))

			# cancel
			stock_reco.cancel()
			self.assertFalse(get_stock_and_account_difference(["_Test Warehouse - _TC"]))

		frappe.defaults.set_global_default("auto_accounting_for_stock", 0)


	def cleanup_data(self):
		frappe.db.sql("delete from `tabStock Ledger Entry`")
		frappe.db.sql("delete from tabBin")
		frappe.db.sql("delete from `tabGL Entry`")

	def submit_stock_reconciliation(self, qty, rate, posting_date, posting_time):
		stock_reco = frappe.get_doc({
			"doctype": "Stock Reconciliation",
			"posting_date": posting_date,
			"posting_time": posting_time,
			"fiscal_year": get_fiscal_year(posting_date)[0],
			"company": "_Test Company",
			"expense_account": "Stock Adjustment - _TC",
			"cost_center": "_Test Cost Center - _TC",
			"reconciliation_json": json.dumps([
				["Item Code", "Warehouse", "Quantity", "Valuation Rate"],
				["_Test Item", "_Test Warehouse - _TC", qty, rate]
			]),
		})
		stock_reco.insert()
		stock_reco.submit()
		frappe.db.commit()
		return stock_reco

	def insert_existing_sle(self, valuation_method):
		frappe.db.set_value("Item", "_Test Item", "valuation_method", valuation_method)
		frappe.db.set_default("allow_negative_stock", 1)

		stock_entry = {
			"company": "_Test Company",
			"doctype": "Stock Entry",
			"posting_date": "2012-12-12",
			"posting_time": "01:00",
			"purpose": "Material Receipt",
			"fiscal_year": "_Test Fiscal Year 2012",
			"mtn_details": [
				{
					"conversion_factor": 1.0,
					"doctype": "Stock Entry Detail",
					"item_code": "_Test Item",
					"parentfield": "mtn_details",
					"incoming_rate": 1000,
					"qty": 20.0,
					"stock_uom": "_Test UOM",
					"transfer_qty": 20.0,
					"uom": "_Test UOM",
					"t_warehouse": "_Test Warehouse - _TC",
					"expense_account": "Stock Adjustment - _TC",
					"cost_center": "_Test Cost Center - _TC"
				}
			]
		}

		pr = frappe.copy_doc(stock_entry)
		pr.insert()
		pr.submit()

		pr1 = frappe.copy_doc(stock_entry)
		pr1.posting_date = "2012-12-15"
		pr1.posting_time = "02:00"
		pr1.get("mtn_details")[0].qty = 10
		pr1.get("mtn_details")[0].transfer_qty = 10
		pr1.get("mtn_details")[0].incoming_rate = 700
		pr1.insert()
		pr1.submit()

		pr2 = frappe.copy_doc(stock_entry)
		pr2.posting_date = "2012-12-25"
		pr2.posting_time = "03:00"
		pr2.purpose = "Material Issue"
		pr2.get("mtn_details")[0].s_warehouse = "_Test Warehouse - _TC"
		pr2.get("mtn_details")[0].t_warehouse = None
		pr2.get("mtn_details")[0].qty = 15
		pr2.get("mtn_details")[0].transfer_qty = 15
		pr2.get("mtn_details")[0].incoming_rate = 0
		pr2.insert()
		pr2.submit()

		pr3 = frappe.copy_doc(stock_entry)
		pr3.posting_date = "2012-12-31"
		pr3.posting_time = "08:00"
		pr3.purpose = "Material Issue"
		pr3.get("mtn_details")[0].s_warehouse = "_Test Warehouse - _TC"
		pr3.get("mtn_details")[0].t_warehouse = None
		pr3.get("mtn_details")[0].qty = 20
		pr3.get("mtn_details")[0].transfer_qty = 20
		pr3.get("mtn_details")[0].incoming_rate = 0
		pr3.insert()
		pr3.submit()


		pr4 = frappe.copy_doc(stock_entry)
		pr4.posting_date = "2013-01-05"
		pr4.fiscal_year = "_Test Fiscal Year 2013"
		pr4.posting_time = "07:00"
		pr4.get("mtn_details")[0].qty = 15
		pr4.get("mtn_details")[0].transfer_qty = 15
		pr4.get("mtn_details")[0].incoming_rate = 1200
		pr4.insert()
		pr4.submit()


test_dependencies = ["Item", "Warehouse"]

########NEW FILE########
__FILENAME__ = stock_settings
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe import _

from frappe.model.document import Document

class StockSettings(Document):

	def validate(self):
		for key in ["item_naming_by", "item_group", "stock_uom",
			"allow_negative_stock"]:
			frappe.db.set_default(key, self.get(key, ""))
			
		from erpnext.setup.doctype.naming_series.naming_series import set_by_naming_series
		set_by_naming_series("Item", "item_code", 
			self.get("item_naming_by")=="Naming Series", hide_name_field=True)

		stock_frozen_limit = 356
		submitted_stock_frozen = self.stock_frozen_upto_days
		if submitted_stock_frozen > stock_frozen_limit:
			self.stock_frozen_upto_days = stock_frozen_limit
			frappe.msgprint (_("`Freeze Stocks Older Than` should be smaller than %d days.") %stock_frozen_limit)

########NEW FILE########
__FILENAME__ = stock_uom_replace_utility
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cstr, flt, cint
from frappe import _


from frappe.model.document import Document

class StockUOMReplaceUtility(Document):
	def validate_mandatory(self):
		if not cstr(self.item_code):
			frappe.throw(_("Item is required"))

		if not cstr(self.new_stock_uom):
			frappe.throw(_("New Stock UOM is required"))

		if cstr(self.current_stock_uom) == cstr(self.new_stock_uom):
			frappe.throw(_("New Stock UOM must be different from current stock UOM"))

		# check conversion factor
		if not flt(self.conversion_factor):
			frappe.throw(_("Conversion Factor is required"))

		stock_uom = frappe.db.get_value("Item", self.item_code, "stock_uom")
		if cstr(self.new_stock_uom) == cstr(stock_uom):
			frappe.throw(_("Item is updated"))

	def update_item_master(self):
		item_doc = frappe.get_doc("Item", self.item_code)
		item_doc.stock_uom = self.new_stock_uom
		item_doc.save()

		frappe.msgprint(_("Stock UOM updatd for Item {0}").format(self.item_code))

	def update_bin(self):
		# update bin
		if flt(self.conversion_factor) != flt(1):
			frappe.db.sql("""update `tabBin`
				set stock_uom = %s,
					indented_qty = ifnull(indented_qty,0) * %s,
					ordered_qty = ifnull(ordered_qty,0) * %s,
					reserved_qty = ifnull(reserved_qty,0) * %s,
					planned_qty = ifnull(planned_qty,0) * %s,
					projected_qty = actual_qty + ordered_qty + indented_qty +
						planned_qty - reserved_qty
				where item_code = %s""", (self.new_stock_uom, self.conversion_factor,
					self.conversion_factor, self.conversion_factor,
					self.conversion_factor, self.item_code))
		else:
			frappe.db.sql("update `tabBin` set stock_uom = %s where item_code = %s",
				 (self.new_stock_uom, self.item_code) )

		# acknowledge user
		frappe.msgprint(_("Stock balances updated"))

	def update_stock_ledger_entry(self):
		# update stock ledger entry
		from erpnext.stock.stock_ledger import update_entries_after

		if flt(self.conversion_factor) != flt(1):
			frappe.db.sql("""update `tabStock Ledger Entry`
				set stock_uom = %s, actual_qty = ifnull(actual_qty,0) * %s
				where item_code = %s""",
				(self.new_stock_uom, self.conversion_factor, self.item_code))
		else:
			frappe.db.sql("""update `tabStock Ledger Entry` set stock_uom=%s
				where item_code=%s""", (self.new_stock_uom, self.item_code))

		# acknowledge user
		frappe.msgprint(_("Stock Ledger entries balances updated"))

		# update item valuation
		if flt(self.conversion_factor) != flt(1):
			wh = frappe.db.sql("select name from `tabWarehouse`")
			for w in wh:
				update_entries_after({"item_code": self.item_code, "warehouse": w[0]})

		# acknowledge user
		frappe.msgprint(_("Item valuation updated"))

	# Update Stock UOM
	def update_stock_uom(self):
		self.validate_mandatory()
		self.validate_uom_integer_type()

		self.update_stock_ledger_entry()

		self.update_bin()

		self.update_item_master()


	def validate_uom_integer_type(self):
		current_is_integer = frappe.db.get_value("UOM", self.current_stock_uom, "must_be_whole_number")
		new_is_integer = frappe.db.get_value("UOM", self.new_stock_uom, "must_be_whole_number")

		if not current_is_integer and new_is_integer:
			frappe.throw(_("New UOM must NOT be of type Whole Number"))

		if current_is_integer and new_is_integer and cint(self.conversion_factor)!=self.conversion_factor:
			frappe.throw(_("Conversion factor cannot be in fractions"))

@frappe.whitelist()
def get_stock_uom(item_code):
	return { 'current_stock_uom': cstr(frappe.db.get_value('Item', item_code, 'stock_uom')) }


########NEW FILE########
__FILENAME__ = uom_conversion_detail
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class UOMConversionDetail(Document):
	pass
########NEW FILE########
__FILENAME__ = test_warehouse
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Warehouse')
########NEW FILE########
__FILENAME__ = warehouse
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cint, validate_email_add
from frappe import throw, msgprint, _

from frappe.model.document import Document

class Warehouse(Document):

	def autoname(self):
		suffix = " - " + frappe.db.get_value("Company", self.company, "abbr")
		if not self.warehouse_name.endswith(suffix):
			self.name = self.warehouse_name + suffix

	def validate(self):
		if self.email_id and not validate_email_add(self.email_id):
				throw(_("Please enter valid Email Id"))

		self.update_parent_account()

	def update_parent_account(self):
		if not getattr(self, "__islocal", None) and (self.create_account_under !=
			frappe.db.get_value("Warehouse", self.name, "create_account_under")):
				warehouse_account = frappe.db.get_value("Account",
					{"account_type": "Warehouse", "company": self.company,
					"master_name": self.name}, ["name", "parent_account"])
				if warehouse_account and warehouse_account[1] != self.create_account_under:
					acc_doc = frappe.get_doc("Account", warehouse_account[0])
					acc_doc.parent_account = self.create_account_under
					acc_doc.save()

	def on_update(self):
		self.create_account_head()

	def create_account_head(self):
		if cint(frappe.defaults.get_global_default("auto_accounting_for_stock")):
			if not frappe.db.get_value("Account", {"account_type": "Warehouse",
					"master_name": self.name}) and not frappe.db.get_value("Account",
					{"account_name": self.warehouse_name}):
				if self.get("__islocal") or not frappe.db.get_value(
						"Stock Ledger Entry", {"warehouse": self.name}):
					self.validate_parent_account()
					ac_doc = frappe.get_doc({
						"doctype": "Account",
						'account_name': self.warehouse_name,
						'parent_account': self.create_account_under,
						'group_or_ledger':'Ledger',
						'company':self.company,
						"account_type": "Warehouse",
						"master_name": self.name,
						"freeze_account": "No"
					})
					ac_doc.ignore_permissions = True
					ac_doc.insert()
					msgprint(_("Account head {0} created").format(ac_doc.name))

	def validate_parent_account(self):
		if not self.create_account_under:
			parent_account = frappe.db.get_value("Account",
				{"account_name": "Stock Assets", "company": self.company})
			if parent_account:
				self.create_account_under = parent_account
			else:
				frappe.throw(_("Please enter parent account group for warehouse account"))

	def on_trash(self):
		# delete bin
		bins = frappe.db.sql("select * from `tabBin` where warehouse = %s",
			self.name, as_dict=1)
		for d in bins:
			if d['actual_qty'] or d['reserved_qty'] or d['ordered_qty'] or \
					d['indented_qty'] or d['projected_qty'] or d['planned_qty']:
				throw(_("Warehouse {0} can not be deleted as quantity exists for Item {1}").format(self.name, d['item_code']))
			else:
				frappe.db.sql("delete from `tabBin` where name = %s", d['name'])

		warehouse_account = frappe.db.get_value("Account",
			{"account_type": "Warehouse", "master_name": self.name})
		if warehouse_account:
			frappe.delete_doc("Account", warehouse_account)

		if frappe.db.sql("""select name from `tabStock Ledger Entry`
				where warehouse = %s""", self.name):
			throw(_("Warehouse can not be deleted as stock ledger entry exists for this warehouse."))

	def before_rename(self, olddn, newdn, merge=False):
		# Add company abbr if not provided
		from erpnext.setup.doctype.company.company import get_name_with_abbr
		new_warehouse = get_name_with_abbr(newdn, self.company)

		if merge:
			if not frappe.db.exists("Warehouse", new_warehouse):
				frappe.throw(_("Warehouse {0} does not exist").format(new_warehouse))

			if self.company != frappe.db.get_value("Warehouse", new_warehouse, "company"):
				frappe.throw(_("Both Warehouse must belong to same Company"))

			frappe.db.sql("delete from `tabBin` where warehouse=%s", olddn)

		from erpnext.accounts.utils import rename_account_for
		rename_account_for("Warehouse", olddn, newdn, merge, self.company)

		return new_warehouse

	def after_rename(self, olddn, newdn, merge=False):
		if merge:
			self.recalculate_bin_qty(newdn)

	def recalculate_bin_qty(self, newdn):
		from erpnext.utilities.repost_stock import repost_stock
		frappe.db.auto_commit_on_many_writes = 1
		frappe.db.set_default("allow_negative_stock", 1)

		for item in frappe.db.sql("""select distinct item_code from (
			select name as item_code from `tabItem` where ifnull(is_stock_item, 'Yes')='Yes'
			union
			select distinct item_code from tabBin) a"""):
				repost_stock(item[0], newdn)

		frappe.db.set_default("allow_negative_stock",
			frappe.db.get_value("Stock Settings", None, "allow_negative_stock"))
		frappe.db.auto_commit_on_many_writes = 0

########NEW FILE########
__FILENAME__ = warehouse_user
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class WarehouseUser(Document):
	pass
########NEW FILE########
__FILENAME__ = get_item_details
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _, throw
from frappe.utils import flt, cint, add_days
import json

class MultiplePricingRuleConflict(frappe.ValidationError): pass

@frappe.whitelist()
def get_item_details(args):
	"""
		args = {
			"item_code": "",
			"warehouse": None,
			"customer": "",
			"conversion_rate": 1.0,
			"selling_price_list": None,
			"price_list_currency": None,
			"plc_conversion_rate": 1.0,
			"doctype": "",
			"docname": "",
			"supplier": None,
			"transaction_date": None,
			"conversion_rate": 1.0,
			"buying_price_list": None,
			"is_subcontracted": "Yes" / "No",
			"transaction_type": "selling"
		}
	"""

	if isinstance(args, basestring):
		args = json.loads(args)

	args = frappe._dict(args)

	if not args.get("transaction_type"):
		if args.get("doctype")=="Material Request" or frappe.get_meta(args.get("doctype")).get_field("supplier"):
			args.transaction_type = "buying"
		else:
			args.transaction_type = "selling"

	if not args.get("price_list"):
		args.price_list = args.get("selling_price_list") or args.get("buying_price_list")

	if args.barcode:
		args.item_code = get_item_code(barcode=args.barcode)
	elif not args.item_code and args.serial_no:
		args.item_code = get_item_code(serial_no=args.serial_no)

	item_doc = frappe.get_doc("Item", args.item_code)
	item = item_doc

	validate_item_details(args, item)

	out = get_basic_details(args, item_doc)

	get_party_item_code(args, item_doc, out)

	if out.get("warehouse"):
		out.update(get_available_qty(args.item_code, out.warehouse))
		out.update(get_projected_qty(item.name, out.warehouse))

	get_price_list_rate(args, item_doc, out)

	if args.transaction_type == "selling" and cint(args.is_pos):
		out.update(get_pos_settings_item_details(args.company, args))

	apply_pricing_rule(out, args)

	if args.get("doctype") in ("Sales Invoice", "Delivery Note"):
		if item_doc.has_serial_no == "Yes" and not args.serial_no:
			out.serial_no = get_serial_nos_by_fifo(args, item_doc)

	if args.transaction_date and item.lead_time_days:
		out.schedule_date = out.lead_time_date = add_days(args.transaction_date,
			item.lead_time_days)

	return out

def get_item_code(barcode=None, serial_no=None):
	if barcode:
		item_code = frappe.db.get_value("Item", {"barcode": barcode})
		if not item_code:
			frappe.throw(_("No Item with Barcode {0}").format(barcode))
	elif serial_no:
		item_code = frappe.db.get_value("Serial No", serial_no, "item_code")
		if not item_code:
			frappe.throw(_("No Item with Serial No {0}").format(serial_no))

	return item_code

def validate_item_details(args, item):
	if not args.company:
		throw(_("Please specify Company"))

	from erpnext.stock.doctype.item.item import validate_end_of_life
	validate_end_of_life(item.name, item.end_of_life)

	if args.transaction_type == "selling":
		# validate if sales item or service item
		if args.get("order_type") == "Maintenance":
			if item.is_service_item != "Yes":
				throw(_("Item {0} must be a Service Item.").format(item.name))

		elif item.is_sales_item != "Yes":
			throw(_("Item {0} must be a Sales Item").format(item.name))

	elif args.transaction_type == "buying" and args.doctype != "Material Request":
		# validate if purchase item or subcontracted item
		if item.is_purchase_item != "Yes":
			throw(_("Item {0} must be a Purchase Item").format(item.name))

		if args.get("is_subcontracted") == "Yes" and item.is_sub_contracted_item != "Yes":
			throw(_("Item {0} must be a Sub-contracted Item").format(item.name))

def get_basic_details(args, item_doc):
	item = item_doc

	from frappe.defaults import get_user_default_as_list
	user_default_warehouse_list = get_user_default_as_list('warehouse')
	user_default_warehouse = user_default_warehouse_list[0] \
		if len(user_default_warehouse_list)==1 else ""

	out = frappe._dict({
		"item_code": item.name,
		"item_name": item.item_name,
		"description": item.description_html or item.description,
		"warehouse": user_default_warehouse or args.warehouse or item.default_warehouse,
		"income_account": item.income_account or args.income_account \
			or frappe.db.get_value("Company", args.company, "default_income_account"),
		"expense_account": item.expense_account or args.expense_account \
			or frappe.db.get_value("Company", args.company, "default_expense_account"),
		"cost_center": item.selling_cost_center \
			if args.transaction_type == "selling" else item.buying_cost_center,
		"batch_no": None,
		"item_tax_rate": json.dumps(dict(([d.tax_type, d.tax_rate] for d in
			item_doc.get("item_tax")))),
		"uom": item.stock_uom,
		"min_order_qty": flt(item.min_order_qty) if args.doctype == "Material Request" else "",
		"conversion_factor": 1.0,
		"qty": 1.0,
		"price_list_rate": 0.0,
		"base_price_list_rate": 0.0,
		"rate": 0.0,
		"base_rate": 0.0,
		"amount": 0.0,
		"base_amount": 0.0,
		"discount_percentage": 0.0
	})

	for fieldname in ("item_name", "item_group", "barcode", "brand", "stock_uom"):
		out[fieldname] = item.get(fieldname)

	return out

def get_price_list_rate(args, item_doc, out):
	meta = frappe.get_meta(args.doctype)

	if meta.get_field("currency"):
		validate_price_list(args)
		validate_conversion_rate(args, meta)

		price_list_rate = frappe.db.get_value("Item Price",
			{"price_list": args.price_list, "item_code": args.item_code}, "price_list_rate")

		if not price_list_rate: return {}

		out.price_list_rate = flt(price_list_rate) * flt(args.plc_conversion_rate) \
			/ flt(args.conversion_rate)

		if not out.price_list_rate and args.transaction_type == "buying":
			from erpnext.stock.doctype.item.item import get_last_purchase_details
			out.update(get_last_purchase_details(item_doc.name,
				args.docname, args.conversion_rate))

def validate_price_list(args):
	if args.get("price_list"):
		if not frappe.db.get_value("Price List",
			{"name": args.price_list, args.transaction_type: 1, "enabled": 1}):
			throw(_("Price List {0} is disabled").format(args.price_list))
	else:
		throw(_("Price List not selected"))

def validate_conversion_rate(args, meta):
	from erpnext.setup.doctype.currency.currency import validate_conversion_rate
	from frappe.model.meta import get_field_precision

	# validate currency conversion rate
	validate_conversion_rate(args.currency, args.conversion_rate,
		meta.get_label("conversion_rate"), args.company)

	args.conversion_rate = flt(args.conversion_rate,
		get_field_precision(meta.get_field("conversion_rate"),
			frappe._dict({"fields": args})))

	# validate price list currency conversion rate
	if not args.get("price_list_currency"):
		throw(_("Price List Currency not selected"))
	else:
		validate_conversion_rate(args.price_list_currency, args.plc_conversion_rate,
			meta.get_label("plc_conversion_rate"), args.company)

		args.plc_conversion_rate = flt(args.plc_conversion_rate,
			get_field_precision(meta.get_field("plc_conversion_rate"),
			frappe._dict({"fields": args})))

def get_party_item_code(args, item_doc, out):
	if args.transaction_type == "selling":
		customer_item_code = item_doc.get("item_customer_details", {"customer_name": args.customer})
		out.customer_item_code = customer_item_code[0].ref_code if customer_item_code else None
	else:
		item_supplier = item_doc.get("item_supplier_details", {"supplier": args.supplier})
		out.supplier_part_no = item_supplier[0].supplier_part_no if item_supplier else None


def get_pos_settings_item_details(company, args, pos_settings=None):
	res = frappe._dict()

	if not pos_settings:
		pos_settings = get_pos_settings(company)

	if pos_settings:
		for fieldname in ("income_account", "cost_center", "warehouse", "expense_account"):
			if not args.get(fieldname):
				res[fieldname] = pos_settings.get(fieldname)

		if res.get("warehouse"):
			res.actual_qty = get_available_qty(args.item_code,
				res.warehouse).get("actual_qty")

	return res

def get_pos_settings(company):
	pos_settings = frappe.db.sql("""select * from `tabPOS Setting` where user = %s
		and company = %s""", (frappe.session['user'], company), as_dict=1)

	if not pos_settings:
		pos_settings = frappe.db.sql("""select * from `tabPOS Setting`
			where ifnull(user,'') = '' and company = %s""", company, as_dict=1)

	return pos_settings and pos_settings[0] or None

def apply_pricing_rule(out, args):
	args_dict = frappe._dict().update(args)
	args_dict.update(out)
	all_pricing_rules = get_pricing_rules(args_dict)

	rule_for_price = False
	for rule_for in ["price", "discount_percentage"]:
		pricing_rules = filter(lambda x: x[rule_for] > 0.0, all_pricing_rules)
		if rule_for_price:
			pricing_rules = filter(lambda x: not x["for_price_list"], pricing_rules)

		pricing_rule = filter_pricing_rules(args_dict, pricing_rules)

		if pricing_rule:
			if rule_for == "discount_percentage":
				out["discount_percentage"] = pricing_rule["discount_percentage"]
				out["pricing_rule_for_discount"] = pricing_rule["name"]
			else:
				out["base_price_list_rate"] = pricing_rule["price"]
				out["price_list_rate"] = pricing_rule["price"] * \
					flt(args_dict.plc_conversion_rate) / flt(args_dict.conversion_rate)
				out["pricing_rule_for_price"] = pricing_rule["name"]
				rule_for_price = True

def get_pricing_rules(args_dict):
	def _get_tree_conditions(doctype, allow_blank=True):
		field = frappe.scrub(doctype)
		condition = ""
		if args_dict.get(field):
			lft, rgt = frappe.db.get_value(doctype, args_dict[field], ["lft", "rgt"])
			parent_groups = frappe.db.sql_list("""select name from `tab%s`
				where lft<=%s and rgt>=%s""" % (doctype, '%s', '%s'), (lft, rgt))

			if parent_groups:
				if allow_blank: parent_groups.append('')
				condition = " ifnull("+field+", '') in ('" + "', '".join(parent_groups)+"')"

		return condition


	conditions = ""
	for field in ["customer", "supplier", "supplier_type", "campaign", "sales_partner"]:
			if args_dict.get(field):
				conditions += " and ifnull("+field+", '') in (%("+field+")s, '')"
			else:
				conditions += " and ifnull("+field+", '') = ''"

	for doctype in ["Customer Group", "Territory"]:
		group_condition = _get_tree_conditions(doctype)
		if group_condition:
			conditions += " and " + group_condition

	conditions += " and ifnull(for_price_list, '') in (%(price_list)s, '')"


	if args_dict.get("transaction_date"):
		conditions += """ and %(transaction_date)s between ifnull(valid_from, '2000-01-01')
			and ifnull(valid_upto, '2500-12-31')"""

	return frappe.db.sql("""select * from `tabPricing Rule`
		where (item_code=%(item_code)s or {item_group_condition} or brand=%(brand)s)
			and docstatus < 2 and ifnull(disable, 0) = 0 {conditions}
		order by priority desc, name desc""".format(
			item_group_condition=_get_tree_conditions("Item Group", False), conditions=conditions),
			args_dict, as_dict=1)

def filter_pricing_rules(args_dict, pricing_rules):
	# filter for qty
	if pricing_rules and args_dict.get("qty"):
		pricing_rules = filter(lambda x: (args_dict.qty>=flt(x.min_qty)
			and (args_dict.qty<=x.max_qty if x.max_qty else True)), pricing_rules)

	# find pricing rule with highest priority
	if pricing_rules:
		max_priority = max([cint(p.priority) for p in pricing_rules])
		if max_priority:
			pricing_rules = filter(lambda x: cint(x.priority)==max_priority, pricing_rules)

	# apply internal priority
	all_fields = ["item_code", "item_group", "brand", "customer", "customer_group", "territory",
		"supplier", "supplier_type", "campaign", "for_price_list", "sales_partner"]

	if len(pricing_rules) > 1:
		for field_set in [["item_code", "item_group", "brand"],
			["customer", "customer_group", "territory"], ["supplier", "supplier_type"]]:
				remaining_fields = list(set(all_fields) - set(field_set))
				if if_all_rules_same(pricing_rules, remaining_fields):
					pricing_rules = apply_internal_priority(pricing_rules, field_set, args_dict)
					break

	if len(pricing_rules) > 1:
		frappe.throw(_("Multiple Price Rule exists with same criteria, please resolve \
			conflict by assigning priority. Price Rules: {0}")
			.format("\n".join([d.name for d in pricing_rules])), MultiplePricingRuleConflict)
	elif pricing_rules:
		return pricing_rules[0]

def if_all_rules_same(pricing_rules, fields):
	all_rules_same = True
	val = [pricing_rules[0][k] for k in fields]
	for p in pricing_rules[1:]:
		if val != [p[k] for k in fields]:
			all_rules_same = False
			break

	return all_rules_same

def apply_internal_priority(pricing_rules, field_set, args_dict):
	filtered_rules = []
	for field in field_set:
		if args_dict.get(field):
			filtered_rules = filter(lambda x: x[field]==args_dict[field], pricing_rules)
			if filtered_rules: break

	return filtered_rules or pricing_rules

def get_serial_nos_by_fifo(args, item_doc):
	return "\n".join(frappe.db.sql_list("""select name from `tabSerial No`
		where item_code=%(item_code)s and warehouse=%(warehouse)s and status='Available'
		order by timestamp(purchase_date, purchase_time) asc limit %(qty)s""", {
			"item_code": args.item_code,
			"warehouse": args.warehouse,
			"qty": cint(args.qty)
		}))

@frappe.whitelist()
def get_conversion_factor(item_code, uom):
	return {"conversion_factor": frappe.db.get_value("UOM Conversion Detail",
		{"parent": item_code, "uom": uom}, "conversion_factor")}

@frappe.whitelist()
def get_projected_qty(item_code, warehouse):
	return {"projected_qty": frappe.db.get_value("Bin",
		{"item_code": item_code, "warehouse": warehouse}, "projected_qty")}

@frappe.whitelist()
def get_available_qty(item_code, warehouse):
	return frappe.db.get_value("Bin", {"item_code": item_code, "warehouse": warehouse},
		["projected_qty", "actual_qty"], as_dict=True) or {}

########NEW FILE########
__FILENAME__ = batch_wise_balance_history
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.utils import flt

def execute(filters=None):
	if not filters: filters = {}

	columns = get_columns(filters)
	item_map = get_item_details(filters)
	iwb_map = get_item_warehouse_batch_map(filters)

	data = []
	for item in sorted(iwb_map):
		for wh in sorted(iwb_map[item]):
			for batch in sorted(iwb_map[item][wh]):
				qty_dict = iwb_map[item][wh][batch]
				data.append([item, item_map[item]["item_name"],
					item_map[item]["description"], wh, batch,
					qty_dict.opening_qty, qty_dict.in_qty,
					qty_dict.out_qty, qty_dict.bal_qty
				])

	return columns, data

def get_columns(filters):
	"""return columns based on filters"""

	columns = ["Item:Link/Item:100"] + ["Item Name::150"] + ["Description::150"] + \
	["Warehouse:Link/Warehouse:100"] + ["Batch:Link/Batch:100"] + ["Opening Qty::90"] + \
	["In Qty::80"] + ["Out Qty::80"] + ["Balance Qty::90"]

	return columns

def get_conditions(filters):
	conditions = ""
	if not filters.get("from_date"):
		frappe.throw(_("'From Date' is required"))

	if filters.get("to_date"):
		conditions += " and posting_date <= '%s'" % filters["to_date"]
	else:
		frappe.throw(_("'To Date' is required"))

	return conditions

#get all details
def get_stock_ledger_entries(filters):
	conditions = get_conditions(filters)
	return frappe.db.sql("""select item_code, batch_no, warehouse,
		posting_date, actual_qty
		from `tabStock Ledger Entry`
		where docstatus < 2 %s order by item_code, warehouse""" %
		conditions, as_dict=1)

def get_item_warehouse_batch_map(filters):
	sle = get_stock_ledger_entries(filters)
	iwb_map = {}

	for d in sle:
		iwb_map.setdefault(d.item_code, {}).setdefault(d.warehouse, {})\
			.setdefault(d.batch_no, frappe._dict({
				"opening_qty": 0.0, "in_qty": 0.0, "out_qty": 0.0, "bal_qty": 0.0
			}))
		qty_dict = iwb_map[d.item_code][d.warehouse][d.batch_no]
		if d.posting_date < filters["from_date"]:
			qty_dict.opening_qty += flt(d.actual_qty)
		elif d.posting_date >= filters["from_date"] and d.posting_date <= filters["to_date"]:
			if flt(d.actual_qty) > 0:
				qty_dict.in_qty += flt(d.actual_qty)
			else:
				qty_dict.out_qty += abs(flt(d.actual_qty))

		qty_dict.bal_qty += flt(d.actual_qty)

	return iwb_map

def get_item_details(filters):
	item_map = {}
	for d in frappe.db.sql("select name, item_name, description from tabItem", as_dict=1):
		item_map.setdefault(d.name, d)

	return item_map

########NEW FILE########
__FILENAME__ = delivery_note_trends
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from erpnext.controllers.trends	import get_columns,get_data

def execute(filters=None):
	if not filters: filters ={}
	data = []
	conditions = get_columns(filters, "Delivery Note")
	data = get_data(filters, conditions)
	
	return conditions["columns"], data 
########NEW FILE########
__FILENAME__ = itemwise_recommended_reorder_level
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

import frappe
from frappe import _
from frappe.utils import getdate, flt

def execute(filters=None):
	if not filters: filters = {}
	float_preceision = frappe.db.get_default("float_preceision")

	condition =get_condition(filters)

	avg_daily_outgoing = 0
	diff = ((getdate(filters.get("to_date")) - getdate(filters.get("from_date"))).days)+1
	if diff <= 0:
		frappe.throw(_("'From Date' must be after 'To Date'"))

	columns = get_columns()
	items = get_item_info()
	consumed_item_map = get_consumed_items(condition)
	delivered_item_map = get_delivered_items(condition)

	data = []
	for item in items:

		total_outgoing = consumed_item_map.get(item.name, 0)+delivered_item_map.get(item.name,0)
		avg_daily_outgoing = flt(total_outgoing/diff, float_preceision)
		reorder_level = (avg_daily_outgoing * flt(item.lead_time_days)) + flt(item.min_order_qty)

		data.append([item.name, item.item_name, item.description, item.min_order_qty, item.lead_time_days,
			consumed_item_map.get(item.name, 0), delivered_item_map.get(item.name,0), total_outgoing,
			avg_daily_outgoing, reorder_level])

	return columns , data

def get_columns():
	return[
			"Item:Link/Item:120", "Item name:Data:120", "Description::160",
			"Minimum Inventory Level:Float:160", "Lead Time Days:Float:120", "Consumed:Float:120",
			"Delivered:Float:120", "Total Outgoing:Float:120", "Avg Daily Outgoing:Float:160",
			"Reorder Level:Float:120"
	]

def get_item_info():
	return frappe.db.sql("""select name, item_name, description, min_order_qty,
		lead_time_days	from tabItem""", as_dict=1)

def get_consumed_items(condition):

	cn_items = frappe.db.sql("""select se_item.item_code,
				sum(se_item.actual_qty) as 'consume_qty'
		from `tabStock Entry` se, `tabStock Entry Detail` se_item
		where se.name = se_item.parent and se.docstatus = 1
		and ifnull(se_item.t_warehouse, '') = '' %s
		group by se_item.item_code""" % (condition), as_dict=1)

	cn_items_map = {}
	for item in cn_items:
		cn_items_map.setdefault(item.item_code, item.consume_qty)

	return cn_items_map

def get_delivered_items(condition):

	dn_items = frappe.db.sql("""select dn_item.item_code, sum(dn_item.qty) as dn_qty
		from `tabDelivery Note` dn, `tabDelivery Note Item` dn_item
		where dn.name = dn_item.parent and dn.docstatus = 1 %s
		group by dn_item.item_code""" % (condition), as_dict=1)

	si_items = frappe.db.sql("""select si_item.item_name, sum(si_item.qty) as si_qty
		from `tabSales Invoice` si, `tabSales Invoice Item` si_item
		where si.name = si_item.parent and si.docstatus = 1 and
		ifnull(si.update_stock, 0) = 1 and ifnull(si.is_pos, 0) = 1 %s
		group by si_item.item_name""" % (condition), as_dict=1)

	dn_item_map = {}
	for item in dn_items:
		dn_item_map.setdefault(item.item_code, item.dn_qty)

	for item in si_items:
		dn_item_map.setdefault(item.item_code, item.si_qty)

	return dn_item_map

def get_condition(filters):
	conditions = ""
	if filters.get("from_date") and filters.get("to_date"):
		conditions += " and posting_date between '%s' and '%s'" % (filters["from_date"],filters["to_date"])
	else:
		frappe.throw(_("From and To dates required"))
	return conditions

########NEW FILE########
__FILENAME__ = item_prices
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt

def execute(filters=None):
	if not filters: filters = {}
	
	columns = get_columns(filters)
	item_map = get_item_details()
	pl = get_price_list()
	last_purchase_rate = get_last_purchase_rate()
	bom_rate = get_item_bom_rate()
	val_rate_map = get_valuation_rate()

	from erpnext.accounts.utils import get_currency_precision
	precision = get_currency_precision() or 2
	data = []
	for item in sorted(item_map):
		data.append([item, item_map[item]["item_name"], 
			item_map[item]["description"], item_map[item]["stock_uom"], 
			flt(last_purchase_rate.get(item, 0), precision), 
			flt(val_rate_map.get(item, 0), precision), 
			pl.get(item, {}).get("Selling"), 
			pl.get(item, {}).get("Buying"), 
			flt(bom_rate.get(item, 0), precision), 
			flt(item_map[item]["standard_rate"], precision)
		])
	
	return columns, data

def get_columns(filters):
	"""return columns based on filters"""
	
	columns = ["Item:Link/Item:100", "Item Name::150", "Description::150", "UOM:Link/UOM:80", 
		"Last Purchase Rate:Currency:90", "Valuation Rate:Currency:80",	"Sales Price List::80", 
		"Purchase Price List::80", "BOM Rate:Currency:90", "Standard Rate:Currency:100"]

	return columns

def get_item_details():
	"""returns all items details"""
	
	item_map = {}
	
	for i in frappe.db.sql("select name, item_name, description, \
		stock_uom, standard_rate from tabItem \
		order by item_code", as_dict=1):
			item_map.setdefault(i.name, i)

	return item_map

def get_price_list():
	"""Get selling & buying price list of every item"""

	rate = {}

	price_list = frappe.db.sql("""select ip.item_code, ip.buying, ip.selling, 
		concat(ip.price_list, " - ", ip.currency, " ", ip.price_list_rate) as price 
		from `tabItem Price` ip, `tabPrice List` pl 
		where ip.price_list=pl.name and pl.enabled=1""", as_dict=1)

	for j in price_list:
		if j.price:
			rate.setdefault(j.item_code, {}).setdefault("Buying" if j.buying else "Selling", []).append(j.price)
	item_rate_map = {}
	
	for item in rate:
		for buying_or_selling in rate[item]:
			item_rate_map.setdefault(item, {}).setdefault(buying_or_selling, 
				", ".join(rate[item].get(buying_or_selling, [])))
	
	return item_rate_map

def get_last_purchase_rate():

	item_last_purchase_rate_map = {}

	query = """select * from (select 
					result.item_code,
					result.base_rate
					from (
						(select 
							po_item.item_code,
							po_item.item_name,
							po.transaction_date as posting_date,
							po_item.base_price_list_rate, 
							po_item.discount_percentage, 
							po_item.base_rate
						from `tabPurchase Order` po, `tabPurchase Order Item` po_item
						where po.name = po_item.parent and po.docstatus = 1)
						union
						(select 
							pr_item.item_code,
							pr_item.item_name,
							pr.posting_date,
							pr_item.base_price_list_rate,
							pr_item.discount_percentage,
							pr_item.base_rate
						from `tabPurchase Receipt` pr, `tabPurchase Receipt Item` pr_item
						where pr.name = pr_item.parent and pr.docstatus = 1)
				) result
				order by result.item_code asc, result.posting_date desc) result_wrapper
				group by item_code"""

	for d in frappe.db.sql(query, as_dict=1):
		item_last_purchase_rate_map.setdefault(d.item_code, d.base_rate)

	return item_last_purchase_rate_map

def get_item_bom_rate():
	"""Get BOM rate of an item from BOM"""

	item_bom_map = {}
	
	for b in frappe.db.sql("""select item, (total_cost/quantity) as bom_rate 
		from `tabBOM` where is_active=1 and is_default=1""", as_dict=1):
			item_bom_map.setdefault(b.item, flt(b.bom_rate))

	return item_bom_map

def get_valuation_rate():
	"""Get an average valuation rate of an item from all warehouses"""

	item_val_rate_map = {}
	
	for d in frappe.db.sql("""select item_code, 
		sum(actual_qty*valuation_rate)/sum(actual_qty) as val_rate
		from tabBin where actual_qty > 0 group by item_code""", as_dict=1):
			item_val_rate_map.setdefault(d.item_code, d.val_rate)

	return item_val_rate_map

########NEW FILE########
__FILENAME__ = purchase_receipt_trends
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from erpnext.controllers.trends	import get_columns,get_data

def execute(filters=None):
	if not filters: filters ={}
	data = []
	conditions = get_columns(filters, "Purchase Receipt")
	data = get_data(filters, conditions)

	return conditions["columns"], data  
########NEW FILE########
__FILENAME__ = stock_ageing
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import date_diff

def execute(filters=None):
	
	columns = get_columns()
	item_details = get_fifo_queue(filters)
	to_date = filters["to_date"]
	data = []
	for item, item_dict in item_details.items():
		fifo_queue = item_dict["fifo_queue"]
		details = item_dict["details"]
		if not fifo_queue: continue
		
		average_age = get_average_age(fifo_queue, to_date)
		earliest_age = date_diff(to_date, fifo_queue[0][1])
		latest_age = date_diff(to_date, fifo_queue[-1][1])
		
		data.append([item, details.item_name, details.description, details.item_group, 
			details.brand, average_age, earliest_age, latest_age, details.stock_uom])
		
	return columns, data
	
def get_average_age(fifo_queue, to_date):
	batch_age = age_qty = total_qty = 0.0
	for batch in fifo_queue:
		batch_age = date_diff(to_date, batch[1])
		age_qty += batch_age * batch[0]
		total_qty += batch[0]
	
	return (age_qty / total_qty) if total_qty else 0.0
	
def get_columns():
	return ["Item Code:Link/Item:100", "Item Name::100", "Description::200", 
		"Item Group:Link/Item Group:100", "Brand:Link/Brand:100", "Average Age:Float:100", 
		"Earliest:Int:80", "Latest:Int:80", "UOM:Link/UOM:100"]
		
def get_fifo_queue(filters):
	item_details = {}
	for d in get_stock_ledger_entries(filters):
		item_details.setdefault(d.name, {"details": d, "fifo_queue": []})
		fifo_queue = item_details[d.name]["fifo_queue"]
		if d.actual_qty > 0:
			fifo_queue.append([d.actual_qty, d.posting_date])
		else:
			qty_to_pop = abs(d.actual_qty)
			while qty_to_pop:
				batch = fifo_queue[0] if fifo_queue else [0, None]
				if 0 < batch[0] <= qty_to_pop:
					# if batch qty > 0 
					# not enough or exactly same qty in current batch, clear batch
					qty_to_pop -= batch[0]
					fifo_queue.pop(0)
				else:
					# all from current batch
					batch[0] -= qty_to_pop
					qty_to_pop = 0

	return item_details
	
def get_stock_ledger_entries(filters):
	return frappe.db.sql("""select 
			item.name, item.item_name, item_group, brand, description, item.stock_uom, 
			actual_qty, posting_date
		from `tabStock Ledger Entry` sle,
			(select name, item_name, description, stock_uom, brand, item_group
				from `tabItem` {item_conditions}) item
		where item_code = item.name and
			company = %(company)s and
			posting_date <= %(to_date)s
			{sle_conditions}
			order by posting_date, posting_time, sle.name"""\
		.format(item_conditions=get_item_conditions(filters),
			sle_conditions=get_sle_conditions(filters)), filters, as_dict=True)
	
def get_item_conditions(filters):
	conditions = []
	if filters.get("item_code"):
		conditions.append("item_code=%(item_code)s")
	if filters.get("brand"):
		conditions.append("brand=%(brand)s")
	
	return "where {}".format(" and ".join(conditions)) if conditions else ""
	
def get_sle_conditions(filters):
	conditions = []
	if filters.get("warehouse"):
		conditions.append("warehouse=%(warehouse)s")
	
	return "and {}".format(" and ".join(conditions)) if conditions else ""
########NEW FILE########
__FILENAME__ = stock_ledger
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute(filters=None):
	columns = get_columns()
	sl_entries = get_stock_ledger_entries(filters)
	item_details = get_item_details(filters)

	data = []
	for sle in sl_entries:
		item_detail = item_details[sle.item_code]
		voucher_link_icon = """<a href="%s"><i class="icon icon-share"
			style="cursor: pointer;"></i></a>""" \
			% ("/".join(["#Form", sle.voucher_type, sle.voucher_no]),)

		data.append([sle.date, sle.item_code, item_detail.item_name, item_detail.item_group,
			item_detail.brand, item_detail.description, sle.warehouse, item_detail.stock_uom,
			sle.actual_qty, sle.qty_after_transaction, sle.valuation_rate, sle.stock_value,
			sle.voucher_type, sle.voucher_no, voucher_link_icon, sle.batch_no, sle.serial_no, sle.company])

	return columns, data

def get_columns():
	return ["Date:Datetime:95", "Item:Link/Item:130", "Item Name::100",
		"Item Group:Link/Item Group:100", "Brand:Link/Brand:100",
		"Description::200", "Warehouse:Link/Warehouse:100",
		"Stock UOM:Link/UOM:100", "Qty:Float:50", "Balance Qty:Float:100", "Valuation Rate:Currency:110",
		"Balance Value:Currency:110", "Voucher Type::110", "Voucher #::100", "Link::30",
		"Batch:Link/Batch:100", "Serial #:Link/Serial No:100", "Company:Link/Company:100"]

def get_stock_ledger_entries(filters):
	return frappe.db.sql("""select concat_ws(" ", posting_date, posting_time) as date,
			item_code, warehouse, actual_qty, qty_after_transaction, valuation_rate,
			stock_value, voucher_type, voucher_no, batch_no, serial_no, company
		from `tabStock Ledger Entry`
		where company = %(company)s and
			posting_date between %(from_date)s and %(to_date)s
			{sle_conditions}
			order by posting_date desc, posting_time desc, name desc"""\
		.format(sle_conditions=get_sle_conditions(filters)), filters, as_dict=1)

def get_item_details(filters):
	item_details = {}
	for item in frappe.db.sql("""select name, item_name, description, item_group,
			brand, stock_uom from `tabItem` {item_conditions}"""\
			.format(item_conditions=get_item_conditions(filters)), filters, as_dict=1):
		item_details.setdefault(item.name, item)

	return item_details

def get_item_conditions(filters):
	conditions = []
	if filters.get("item_code"):
		conditions.append("name=%(item_code)s")
	if filters.get("brand"):
		conditions.append("brand=%(brand)s")

	return "where {}".format(" and ".join(conditions)) if conditions else ""

def get_sle_conditions(filters):
	conditions = []
	item_conditions=get_item_conditions(filters)
	if item_conditions:
		conditions.append("""item_code in (select name from tabItem
			{item_conditions})""".format(item_conditions=item_conditions))
	if filters.get("warehouse"):
		conditions.append("warehouse=%(warehouse)s")
	if filters.get("voucher_no"):
		conditions.append("voucher_no=%(voucher_no)s")

	return "and {}".format(" and ".join(conditions)) if conditions else ""

########NEW FILE########
__FILENAME__ = stock_projected_qty
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

def execute(filters=None):
	columns = get_columns()
		
	data = frappe.db.sql("""select 
			item.name, item.item_name, description, item_group, brand, warehouse, item.stock_uom, 
			actual_qty, planned_qty, indented_qty, ordered_qty, reserved_qty, 
			projected_qty, item.re_order_level, item.re_order_qty, 
			(item.re_order_level - projected_qty) as shortage_qty
		from `tabBin` bin, 
			(select name, company from tabWarehouse 
				{warehouse_conditions}) wh,
			(select name, item_name, description, stock_uom, item_group, 
				brand, re_order_level, re_order_qty 
				from `tabItem` {item_conditions}) item
		where item_code = item.name and warehouse = wh.name
		order by item.name, wh.name"""\
		.format(item_conditions=get_item_conditions(filters),
			warehouse_conditions=get_warehouse_conditions(filters)), filters)
	
	return columns, data
	
def get_columns():
	return ["Item Code:Link/Item:140", "Item Name::100", "Description::200", 
		"Item Group:Link/Item Group:100", "Brand:Link/Brand:100", "Warehouse:Link/Warehouse:120", 
		"UOM:Link/UOM:100", "Actual Qty:Float:100", "Planned Qty:Float:100", 
		"Requested Qty:Float:110", "Ordered Qty:Float:100", "Reserved Qty:Float:100", 
		"Projected Qty:Float:100", "Reorder Level:Float:100", "Reorder Qty:Float:100", 
		"Shortage Qty:Float:100"]
	
def get_item_conditions(filters):
	conditions = []
	if filters.get("item_code"):
		conditions.append("name=%(item_code)s")
	if filters.get("brand"):
		conditions.append("brand=%(brand)s")
	
	return "where {}".format(" and ".join(conditions)) if conditions else ""
	
def get_warehouse_conditions(filters):
	conditions = []
	if filters.get("company"):
		conditions.append("company=%(company)s")
	if filters.get("warehouse"):
		conditions.append("name=%(warehouse)s")
		
	return "where {}".format(" and ".join(conditions)) if conditions else ""
########NEW FILE########
__FILENAME__ = supplier_wise_sales_analytics
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import flt

def execute(filters=None):
	columns = get_columns(filters)
	consumed_details = get_consumed_details(filters)
	supplier_details = get_suppliers_details(filters)
	material_transfer_vouchers = get_material_transfer_vouchers()
	data = []

	for item_code, suppliers in supplier_details.items():
		consumed_qty = consumed_amount = delivered_qty = delivered_amount = 0.0
		total_qty = total_amount = 0.0
		if consumed_details.get(item_code):
			for cd in consumed_details.get(item_code):
				
				if (cd.voucher_no not in material_transfer_vouchers):
					if cd.voucher_type=="Delivery Note":
						delivered_qty += abs(flt(cd.actual_qty))
						delivered_amount += abs(flt(cd.stock_value_difference))
					elif cd.voucher_type!="Delivery Note":
						consumed_qty += abs(flt(cd.actual_qty))
						consumed_amount += abs(flt(cd.stock_value_difference))

			if consumed_qty or consumed_amount or delivered_qty or delivered_amount:
				total_qty += delivered_qty + consumed_qty
				total_amount += delivered_amount + consumed_amount

				row = [cd.item_code, cd.item_name, cd.description, cd.stock_uom, \
					consumed_qty, consumed_amount, delivered_qty, delivered_amount, \
					total_qty, total_amount, list(set(suppliers))]
				data.append(row)

	return columns, data

def get_columns(filters):
	"""return columns based on filters"""
	
	columns = ["Item:Link/Item:100"] + ["Item Name::100"] + \
	["Description::150"] + ["UOM:Link/UOM:90"] + \
	["Consumed Qty:Float:110"] + ["Consumed Amount:Currency:130"] + \
	["Delivered Qty:Float:110"] + ["Delivered Amount:Currency:130"] + \
	["Total Qty:Float:110"] + ["Total Amount:Currency:130"] + \
	["Supplier(s)::250"]

	return columns

def get_conditions(filters):
	conditions = ""
	values = []

	if filters.get('from_date') and filters.get('to_date'):
		conditions = "and sle.posting_date>=%s and sle.posting_date<=%s"
		values = [filters.get('from_date'), filters.get('to_date')]

	return conditions, values

def get_consumed_details(filters):
	conditions, values = get_conditions(filters)
	consumed_details = {}

	for d in frappe.db.sql("""select sle.item_code, i.item_name, i.description, 
		i.stock_uom, sle.actual_qty, sle.stock_value_difference, 
		sle.voucher_no, sle.voucher_type
		from `tabStock Ledger Entry` sle, `tabItem` i 
		where sle.item_code=i.name and sle.actual_qty < 0 %s""" % conditions, values, as_dict=1):
			consumed_details.setdefault(d.item_code, []).append(d)

	return consumed_details

def get_suppliers_details(filters):
	item_supplier_map = {}
	supplier = filters.get('supplier')

	for d in frappe.db.sql("""select pr.supplier, pri.item_code from 
		`tabPurchase Receipt` pr, `tabPurchase Receipt Item` pri 
		where pr.name=pri.parent and pr.docstatus=1 and 
		pri.item_code=(select name from `tabItem` where 
			ifnull(is_stock_item, 'Yes')='Yes' and name=pri.item_code)""", as_dict=1):
			item_supplier_map.setdefault(d.item_code, []).append(d.supplier)
	
	if supplier:
		for item_code, suppliers in item_supplier_map.items():
			if supplier not in suppliers:
				del item_supplier_map[item_code]
	
	return item_supplier_map

def get_material_transfer_vouchers():
	return frappe.db.sql_list("""select name from `tabStock Entry` where 
		purpose='Material Transfer' and docstatus=1""")
########NEW FILE########
__FILENAME__ = warehouse_wise_stock_balance
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.utils import flt

def execute(filters=None):
	if not filters: filters = {}

	columns = get_columns(filters)
	item_map = get_item_details(filters)
	iwb_map = get_item_warehouse_map(filters)

	data = []
	for company in sorted(iwb_map):
		for item in sorted(iwb_map[company]):
			for wh in sorted(iwb_map[company][item]):
				qty_dict = iwb_map[company][item][wh]
				data.append([item, item_map[item]["item_name"],
					item_map[item]["description"], wh,
					qty_dict.opening_qty, qty_dict.in_qty,
					qty_dict.out_qty, qty_dict.bal_qty, company
				])

	return columns, data

def get_columns(filters):
	"""return columns based on filters"""

	columns = ["Item:Link/Item:100", "Item Name::150", "Description::150", \
	"Warehouse:Link/Warehouse:100", "Opening Qty:Float:90", \
	"In Qty:Float:80", "Out Qty:Float:80", "Balance Qty:Float:90", "Company:Link/Company:100"]

	return columns

def get_conditions(filters):
	conditions = ""
	if not filters.get("from_date"):
		frappe.throw(_("'From Date' is required"))

	if filters.get("to_date"):
		conditions += " and posting_date <= '%s'" % filters["to_date"]
	else:
		frappe.throw(_("'To Date' is required"))

	return conditions

#get all details
def get_stock_ledger_entries(filters):
	conditions = get_conditions(filters)
	return frappe.db.sql("""select item_code, warehouse,
		posting_date, actual_qty, company
		from `tabStock Ledger Entry`
		where docstatus < 2 %s order by item_code, warehouse""" %
		conditions, as_dict=1)

def get_item_warehouse_map(filters):
	sle = get_stock_ledger_entries(filters)
	iwb_map = {}

	for d in sle:
		iwb_map.setdefault(d.company, {}).setdefault(d.item_code, {}).\
		setdefault(d.warehouse, frappe._dict({\
				"opening_qty": 0.0, "in_qty": 0.0, "out_qty": 0.0, "bal_qty": 0.0
			}))
		qty_dict = iwb_map[d.company][d.item_code][d.warehouse]
		if d.posting_date < filters["from_date"]:
			qty_dict.opening_qty += flt(d.actual_qty)
		elif d.posting_date >= filters["from_date"] and d.posting_date <= filters["to_date"]:
			if flt(d.actual_qty) > 0:
				qty_dict.in_qty += flt(d.actual_qty)
			else:
				qty_dict.out_qty += abs(flt(d.actual_qty))

		qty_dict.bal_qty += flt(d.actual_qty)

	return iwb_map

def get_item_details(filters):
	item_map = {}
	for d in frappe.db.sql("select name, item_name, description from tabItem", as_dict=1):
		item_map.setdefault(d.name, d)

	return item_map

########NEW FILE########
__FILENAME__ = stock_ledger
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt
from __future__ import unicode_literals

import frappe
from frappe import _
from frappe.utils import cint, flt, cstr, now
from erpnext.stock.utils import get_valuation_method
import json

# future reposting
class NegativeStockError(frappe.ValidationError): pass

_exceptions = frappe.local('stockledger_exceptions')
# _exceptions = []

def make_sl_entries(sl_entries, is_amended=None):
	if sl_entries:
		from erpnext.stock.utils import update_bin

		cancel = True if sl_entries[0].get("is_cancelled") == "Yes" else False
		if cancel:
			set_as_cancel(sl_entries[0].get('voucher_no'), sl_entries[0].get('voucher_type'))

		for sle in sl_entries:
			sle_id = None
			if sle.get('is_cancelled') == 'Yes':
				sle['actual_qty'] = -flt(sle['actual_qty'])

			if sle.get("actual_qty"):
				sle_id = make_entry(sle)

			args = sle.copy()
			args.update({
				"sle_id": sle_id,
				"is_amended": is_amended
			})
			update_bin(args)
		if cancel:
			delete_cancelled_entry(sl_entries[0].get('voucher_type'),
				sl_entries[0].get('voucher_no'))

def set_as_cancel(voucher_type, voucher_no):
	frappe.db.sql("""update `tabStock Ledger Entry` set is_cancelled='Yes',
		modified=%s, modified_by=%s
		where voucher_no=%s and voucher_type=%s""",
		(now(), frappe.session.user, voucher_type, voucher_no))

def make_entry(args):
	args.update({"doctype": "Stock Ledger Entry"})
	sle = frappe.get_doc(args)
	sle.ignore_permissions = 1
	sle.insert()
	sle.submit()
	return sle.name

def delete_cancelled_entry(voucher_type, voucher_no):
	frappe.db.sql("""delete from `tabStock Ledger Entry`
		where voucher_type=%s and voucher_no=%s""", (voucher_type, voucher_no))

def update_entries_after(args, verbose=1):
	"""
		update valution rate and qty after transaction
		from the current time-bucket onwards

		args = {
			"item_code": "ABC",
			"warehouse": "XYZ",
			"posting_date": "2012-12-12",
			"posting_time": "12:00"
		}
	"""
	if not _exceptions:
		frappe.local.stockledger_exceptions = []

	previous_sle = get_sle_before_datetime(args)

	qty_after_transaction = flt(previous_sle.get("qty_after_transaction"))
	valuation_rate = flt(previous_sle.get("valuation_rate"))
	stock_queue = json.loads(previous_sle.get("stock_queue") or "[]")
	stock_value = flt(previous_sle.get("stock_value"))
	prev_stock_value = flt(previous_sle.get("stock_value"))

	entries_to_fix = get_sle_after_datetime(previous_sle or \
		{"item_code": args["item_code"], "warehouse": args["warehouse"]}, for_update=True)

	valuation_method = get_valuation_method(args["item_code"])
	stock_value_difference = 0.0

	for sle in entries_to_fix:
		if sle.serial_no or not cint(frappe.db.get_default("allow_negative_stock")):
			# validate negative stock for serialized items, fifo valuation
			# or when negative stock is not allowed for moving average
			if not validate_negative_stock(qty_after_transaction, sle):
				qty_after_transaction += flt(sle.actual_qty)
				continue

		if sle.serial_no:
			valuation_rate = get_serialized_values(qty_after_transaction, sle, valuation_rate)
		elif valuation_method == "Moving Average":
			valuation_rate = get_moving_average_values(qty_after_transaction, sle, valuation_rate)
		else:
			valuation_rate = get_fifo_values(qty_after_transaction, sle, stock_queue)

		qty_after_transaction += flt(sle.actual_qty)

		# get stock value
		if sle.serial_no:
			stock_value = qty_after_transaction * valuation_rate
		elif valuation_method == "Moving Average":
			stock_value = (qty_after_transaction > 0) and \
				(qty_after_transaction * valuation_rate) or 0
		else:
			stock_value = sum((flt(batch[0]) * flt(batch[1]) for batch in stock_queue))

		# rounding as per precision
		from frappe.model.meta import get_field_precision
		meta = frappe.get_meta("Stock Ledger Entry")

		stock_value = flt(stock_value, get_field_precision(meta.get_field("stock_value"),
			frappe._dict({"fields": sle})))

		stock_value_difference = stock_value - prev_stock_value
		prev_stock_value = stock_value

		# update current sle
		frappe.db.sql("""update `tabStock Ledger Entry`
			set qty_after_transaction=%s, valuation_rate=%s, stock_queue=%s,
			stock_value=%s, stock_value_difference=%s where name=%s""",
			(qty_after_transaction, valuation_rate,
			json.dumps(stock_queue), stock_value, stock_value_difference, sle.name))

	if _exceptions:
		_raise_exceptions(args, verbose)

	# update bin
	if not frappe.db.exists({"doctype": "Bin", "item_code": args["item_code"],
			"warehouse": args["warehouse"]}):
		bin_wrapper = frappe.get_doc({
			"doctype": "Bin",
			"item_code": args["item_code"],
			"warehouse": args["warehouse"],
		})
		bin_wrapper.ignore_permissions = 1
		bin_wrapper.insert()

	frappe.db.sql("""update `tabBin` set valuation_rate=%s, actual_qty=%s,
		stock_value=%s,
		projected_qty = (actual_qty + indented_qty + ordered_qty + planned_qty - reserved_qty)
		where item_code=%s and warehouse=%s""", (valuation_rate, qty_after_transaction,
		stock_value, args["item_code"], args["warehouse"]))

def get_sle_before_datetime(args, for_update=False):
	"""
		get previous stock ledger entry before current time-bucket

		Details:
		get the last sle before the current time-bucket, so that all values
		are reposted from the current time-bucket onwards.
		this is necessary because at the time of cancellation, there may be
		entries between the cancelled entries in the same time-bucket
	"""
	sle = get_stock_ledger_entries(args,
		["timestamp(posting_date, posting_time) < timestamp(%(posting_date)s, %(posting_time)s)"],
		"desc", "limit 1", for_update=for_update)

	return sle and sle[0] or frappe._dict()

def get_sle_after_datetime(args, for_update=False):
	"""get Stock Ledger Entries after a particular datetime, for reposting"""
	# NOTE: using for update of
	conditions = ["timestamp(posting_date, posting_time) > timestamp(%(posting_date)s, %(posting_time)s)"]

	# Excluding name: Workaround for MariaDB timestamp() floating microsecond issue
	if args.get("name"):
		conditions.append("name!=%(name)s")

	return get_stock_ledger_entries(args, conditions, "asc", for_update=for_update)

def get_stock_ledger_entries(args, conditions=None, order="desc", limit=None, for_update=False):
	"""get stock ledger entries filtered by specific posting datetime conditions"""
	if not args.get("posting_date"):
		args["posting_date"] = "1900-01-01"
	if not args.get("posting_time"):
		args["posting_time"] = "00:00"

	return frappe.db.sql("""select *, timestamp(posting_date, posting_time) as "timestamp" from `tabStock Ledger Entry`
		where item_code = %%(item_code)s
		and warehouse = %%(warehouse)s
		and ifnull(is_cancelled, 'No')='No'
		%(conditions)s
		order by timestamp(posting_date, posting_time) %(order)s, name %(order)s
		%(limit)s %(for_update)s""" % {
			"conditions": conditions and ("and " + " and ".join(conditions)) or "",
			"limit": limit or "",
			"for_update": for_update and "for update" or "",
			"order": order
		}, args, as_dict=1)

def validate_negative_stock(qty_after_transaction, sle):
	"""
		validate negative stock for entries current datetime onwards
		will not consider cancelled entries
	"""
	diff = qty_after_transaction + flt(sle.actual_qty)

	if not _exceptions:
		frappe.local.stockledger_exceptions = []

	if diff < 0 and abs(diff) > 0.0001:
		# negative stock!
		exc = sle.copy().update({"diff": diff})
		_exceptions.append(exc)
		return False
	else:
		return True

def get_serialized_values(qty_after_transaction, sle, valuation_rate):
	incoming_rate = flt(sle.incoming_rate)
	actual_qty = flt(sle.actual_qty)
	serial_no = cstr(sle.serial_no).split("\n")

	if incoming_rate < 0:
		# wrong incoming rate
		incoming_rate = valuation_rate
	elif incoming_rate == 0 or flt(sle.actual_qty) < 0:
		# In case of delivery/stock issue, get average purchase rate
		# of serial nos of current entry
		incoming_rate = flt(frappe.db.sql("""select avg(ifnull(purchase_rate, 0))
			from `tabSerial No` where name in (%s)""" % (", ".join(["%s"]*len(serial_no))),
			tuple(serial_no))[0][0])

	if incoming_rate and not valuation_rate:
		valuation_rate = incoming_rate
	else:
		new_stock_qty = qty_after_transaction + actual_qty
		if new_stock_qty > 0:
			new_stock_value = qty_after_transaction * valuation_rate + actual_qty * incoming_rate
			if new_stock_value > 0:
				# calculate new valuation rate only if stock value is positive
				# else it remains the same as that of previous entry
				valuation_rate = new_stock_value / new_stock_qty

	return valuation_rate

def get_moving_average_values(qty_after_transaction, sle, valuation_rate):
	incoming_rate = flt(sle.incoming_rate)
	actual_qty = flt(sle.actual_qty)

	if not incoming_rate:
		# In case of delivery/stock issue in_rate = 0 or wrong incoming rate
		incoming_rate = valuation_rate

	elif qty_after_transaction < 0:
		# if negative stock, take current valuation rate as incoming rate
		valuation_rate = incoming_rate

	new_stock_qty = qty_after_transaction + actual_qty
	new_stock_value = qty_after_transaction * valuation_rate + actual_qty * incoming_rate

	if new_stock_qty > 0 and new_stock_value > 0:
		valuation_rate = new_stock_value / flt(new_stock_qty)
	elif new_stock_qty <= 0:
		valuation_rate = 0.0

	# NOTE: val_rate is same as previous entry if new stock value is negative

	return valuation_rate

def get_fifo_values(qty_after_transaction, sle, stock_queue):
	incoming_rate = flt(sle.incoming_rate)
	actual_qty = flt(sle.actual_qty)
	if not stock_queue:
		stock_queue.append([0, 0])

	if actual_qty > 0:
		if stock_queue[-1][0] > 0:
			stock_queue.append([actual_qty, incoming_rate])
		else:
			qty = stock_queue[-1][0] + actual_qty
			stock_queue[-1] = [qty, qty > 0 and incoming_rate or 0]
	else:
		incoming_cost = 0
		qty_to_pop = abs(actual_qty)
		while qty_to_pop:
			if not stock_queue:
				stock_queue.append([0, 0])

			batch = stock_queue[0]

			if 0 < batch[0] <= qty_to_pop:
				# if batch qty > 0
				# not enough or exactly same qty in current batch, clear batch
				incoming_cost += flt(batch[0]) * flt(batch[1])
				qty_to_pop -= batch[0]
				stock_queue.pop(0)
			else:
				# all from current batch
				incoming_cost += flt(qty_to_pop) * flt(batch[1])
				batch[0] -= qty_to_pop
				qty_to_pop = 0

	stock_value = sum((flt(batch[0]) * flt(batch[1]) for batch in stock_queue))
	stock_qty = sum((flt(batch[0]) for batch in stock_queue))

	valuation_rate = stock_qty and (stock_value / flt(stock_qty)) or 0

	return valuation_rate

def _raise_exceptions(args, verbose=1):
	deficiency = min(e["diff"] for e in _exceptions)
	msg = _("Negative Stock Error ({6}) for Item {0} in Warehouse {1} on {2} {3} in {4} {5}").format(args["item_code"],
		args.get("warehouse"), _exceptions[0]["posting_date"], _exceptions[0]["posting_time"],
		_(_exceptions[0]["voucher_type"]), _exceptions[0]["voucher_no"], deficiency)
	if verbose:
		frappe.throw(msg, NegativeStockError)
	else:
		raise NegativeStockError, msg

def get_previous_sle(args, for_update=False):
	"""
		get the last sle on or before the current time-bucket,
		to get actual qty before transaction, this function
		is called from various transaction like stock entry, reco etc

		args = {
			"item_code": "ABC",
			"warehouse": "XYZ",
			"posting_date": "2012-12-12",
			"posting_time": "12:00",
			"sle": "name of reference Stock Ledger Entry"
		}
	"""
	if not args.get("sle"): args["sle"] = ""

	sle = get_stock_ledger_entries(args, ["name != %(sle)s",
		"timestamp(posting_date, posting_time) <= timestamp(%(posting_date)s, %(posting_time)s)"],
		"desc", "limit 1", for_update=for_update)
	return sle and sle[0] or {}

########NEW FILE########
__FILENAME__ = utils
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

import frappe
from frappe import _
import json
from frappe.utils import flt, cstr, nowdate, add_days, cint
from frappe.defaults import get_global_default
from frappe.utils.email_lib import sendmail

class InvalidWarehouseCompany(frappe.ValidationError): pass

def get_stock_balance_on(warehouse, posting_date=None):
	if not posting_date: posting_date = nowdate()

	stock_ledger_entries = frappe.db.sql("""
		SELECT
			item_code, stock_value
		FROM
			`tabStock Ledger Entry`
		WHERE
			warehouse=%s AND posting_date <= %s
		ORDER BY timestamp(posting_date, posting_time) DESC, name DESC
	""", (warehouse, posting_date), as_dict=1)

	sle_map = {}
	for sle in stock_ledger_entries:
		sle_map.setdefault(sle.item_code, flt(sle.stock_value))

	return sum(sle_map.values())

def get_latest_stock_balance():
	bin_map = {}
	for d in frappe.db.sql("""SELECT item_code, warehouse, stock_value as stock_value
		FROM tabBin""", as_dict=1):
			bin_map.setdefault(d.warehouse, {}).setdefault(d.item_code, flt(d.stock_value))

	return bin_map

def get_bin(item_code, warehouse):
	bin = frappe.db.get_value("Bin", {"item_code": item_code, "warehouse": warehouse})
	if not bin:
		bin_obj = frappe.get_doc({
			"doctype": "Bin",
			"item_code": item_code,
			"warehouse": warehouse,
		})
		bin_obj.ignore_permissions = 1
		bin_obj.insert()
	else:
		bin_obj = frappe.get_doc('Bin', bin)
	bin_obj.ignore_permissions = True
	return bin_obj

def update_bin(args):
	is_stock_item = frappe.db.get_value('Item', args.get("item_code"), 'is_stock_item')
	if is_stock_item == 'Yes':
		bin = get_bin(args.get("item_code"), args.get("warehouse"))
		bin.update_stock(args)
		return bin
	else:
		frappe.msgprint(_("Item {0} ignored since it is not a stock item").format(args.get("item_code")))

def get_incoming_rate(args):
	"""Get Incoming Rate based on valuation method"""
	from erpnext.stock.stock_ledger import get_previous_sle

	in_rate = 0
	if args.get("serial_no"):
		in_rate = get_avg_purchase_rate(args.get("serial_no"))
	elif args.get("bom_no"):
		result = frappe.db.sql("""select ifnull(total_cost, 0) / ifnull(quantity, 1)
			from `tabBOM` where name = %s and docstatus=1 and is_active=1""", args.get("bom_no"))
		in_rate = result and flt(result[0][0]) or 0
	else:
		valuation_method = get_valuation_method(args.get("item_code"))
		previous_sle = get_previous_sle(args)
		if valuation_method == 'FIFO':
			if not previous_sle:
				return 0.0
			previous_stock_queue = json.loads(previous_sle.get('stock_queue', '[]') or '[]')
			in_rate = get_fifo_rate(previous_stock_queue, args.get("qty") or 0) if previous_stock_queue else 0
		elif valuation_method == 'Moving Average':
			in_rate = previous_sle.get('valuation_rate') or 0

	return in_rate

def get_avg_purchase_rate(serial_nos):
	"""get average value of serial numbers"""

	serial_nos = get_valid_serial_nos(serial_nos)
	return flt(frappe.db.sql("""select avg(ifnull(purchase_rate, 0)) from `tabSerial No`
		where name in (%s)""" % ", ".join(["%s"] * len(serial_nos)),
		tuple(serial_nos))[0][0])

def get_valuation_method(item_code):
	"""get valuation method from item or default"""
	val_method = frappe.db.get_value('Item', item_code, 'valuation_method')
	if not val_method:
		val_method = get_global_default('valuation_method') or "FIFO"
	return val_method

def get_fifo_rate(previous_stock_queue, qty):
	"""get FIFO (average) Rate from Queue"""
	if qty >= 0:
		total = sum(f[0] for f in previous_stock_queue)
		return total and sum(f[0] * f[1] for f in previous_stock_queue) / flt(total) or 0.0
	else:
		available_qty_for_outgoing, outgoing_cost = 0, 0
		qty_to_pop = abs(qty)
		while qty_to_pop and previous_stock_queue:
			batch = previous_stock_queue[0]
			if 0 < batch[0] <= qty_to_pop:
				# if batch qty > 0
				# not enough or exactly same qty in current batch, clear batch
				available_qty_for_outgoing += flt(batch[0])
				outgoing_cost += flt(batch[0]) * flt(batch[1])
				qty_to_pop -= batch[0]
				previous_stock_queue.pop(0)
			else:
				# all from current batch
				available_qty_for_outgoing += flt(qty_to_pop)
				outgoing_cost += flt(qty_to_pop) * flt(batch[1])
				batch[0] -= qty_to_pop
				qty_to_pop = 0

		return outgoing_cost / available_qty_for_outgoing

def get_valid_serial_nos(sr_nos, qty=0, item_code=''):
	"""split serial nos, validate and return list of valid serial nos"""
	# TODO: remove duplicates in client side
	serial_nos = cstr(sr_nos).strip().replace(',', '\n').split('\n')

	valid_serial_nos = []
	for val in serial_nos:
		if val:
			val = val.strip()
			if val in valid_serial_nos:
				frappe.throw(_("Serial number {0} entered more than once").format(val))
			else:
				valid_serial_nos.append(val)

	if qty and len(valid_serial_nos) != abs(qty):
		frappe.throw(_("{0} valid serial nos for Item {1}").format(abs(qty), item_code))

	return valid_serial_nos

def validate_warehouse_company(warehouse, company):
	warehouse_company = frappe.db.get_value("Warehouse", warehouse, "company")
	if warehouse_company and warehouse_company != company:
		frappe.throw(_("Warehouse {0} does not belong to company {1}").format(warehouse, company),
			InvalidWarehouseCompany)

def get_sales_bom_buying_amount(item_code, warehouse, voucher_type, voucher_no, voucher_detail_no,
		stock_ledger_entries, item_sales_bom):
	# sales bom item
	buying_amount = 0.0
	for bom_item in item_sales_bom[item_code]:
		if bom_item.get("parent_detail_docname")==voucher_detail_no:
			buying_amount += get_buying_amount(voucher_type, voucher_no, voucher_detail_no,
				stock_ledger_entries.get((bom_item.item_code, warehouse), []))

	return buying_amount

def get_buying_amount(voucher_type, voucher_no, item_row, stock_ledger_entries):
	# IMP NOTE
	# stock_ledger_entries should already be filtered by item_code and warehouse and
	# sorted by posting_date desc, posting_time desc
	for i, sle in enumerate(stock_ledger_entries):
		if sle.voucher_type == voucher_type and sle.voucher_no == voucher_no and \
			sle.voucher_detail_no == item_row:
				previous_stock_value = len(stock_ledger_entries) > i+1 and \
					flt(stock_ledger_entries[i+1].stock_value) or 0.0
				buying_amount =  previous_stock_value - flt(sle.stock_value)

				return buying_amount
	return 0.0


def reorder_item():
	""" Reorder item if stock reaches reorder level"""
	if getattr(frappe.local, "auto_indent", None) is None:
		frappe.local.auto_indent = cint(frappe.db.get_value('Stock Settings', None, 'auto_indent'))

	if frappe.local.auto_indent:
		material_requests = {}
		bin_list = frappe.db.sql("""select item_code, warehouse, projected_qty
			from tabBin where ifnull(item_code, '') != '' and ifnull(warehouse, '') != ''
			and exists (select name from `tabItem`
				where `tabItem`.name = `tabBin`.item_code and
				is_stock_item='Yes' and (is_purchase_item='Yes' or is_sub_contracted_item='Yes') and
				(ifnull(end_of_life, '')='' or end_of_life > curdate()))""", as_dict=True)
		for bin in bin_list:
			#check if re-order is required
			item_reorder = frappe.db.get("Item Reorder",
				{"parent": bin.item_code, "warehouse": bin.warehouse})
			if item_reorder:
				reorder_level = item_reorder.warehouse_reorder_level
				reorder_qty = item_reorder.warehouse_reorder_qty
				material_request_type = item_reorder.material_request_type or "Purchase"
			else:
				reorder_level, reorder_qty = frappe.db.get_value("Item", bin.item_code,
					["re_order_level", "re_order_qty"])
				material_request_type = "Purchase"

			if flt(reorder_level) and flt(bin.projected_qty) < flt(reorder_level):
				if flt(reorder_level) - flt(bin.projected_qty) > flt(reorder_qty):
					reorder_qty = flt(reorder_level) - flt(bin.projected_qty)

				company = frappe.db.get_value("Warehouse", bin.warehouse, "company") or \
					frappe.defaults.get_defaults()["company"] or \
					frappe.db.sql("""select name from tabCompany limit 1""")[0][0]

				material_requests.setdefault(material_request_type, frappe._dict()).setdefault(
					company, []).append(frappe._dict({
						"item_code": bin.item_code,
						"warehouse": bin.warehouse,
						"reorder_qty": reorder_qty
					})
				)

		create_material_request(material_requests)

def create_material_request(material_requests):
	"""	Create indent on reaching reorder level	"""
	mr_list = []
	defaults = frappe.defaults.get_defaults()
	exceptions_list = []
	from erpnext.accounts.utils import get_fiscal_year
	current_fiscal_year = get_fiscal_year(nowdate())[0] or defaults.fiscal_year
	for request_type in material_requests:
		for company in material_requests[request_type]:
			try:
				items = material_requests[request_type][company]
				if not items:
					continue

				mr = frappe.new_doc("Material Request")
				mr.update({
					"company": company,
					"fiscal_year": current_fiscal_year,
					"transaction_date": nowdate(),
					"material_request_type": request_type
				})

				for d in items:
					item = frappe.get_doc("Item", d.item_code)
					mr.append("indent_details", {
						"doctype": "Material Request Item",
						"item_code": d.item_code,
						"schedule_date": add_days(nowdate(),cint(item.lead_time_days)),
						"uom":	item.stock_uom,
						"warehouse": d.warehouse,
						"item_name": item.item_name,
						"description": item.description,
						"item_group": item.item_group,
						"qty": d.reorder_qty,
						"brand": item.brand,
					})

				mr.insert()
				mr.submit()
				mr_list.append(mr)

			except:
				if frappe.local.message_log:
					exceptions_list.append([] + frappe.local.message_log)
					frappe.local.message_log = []
				else:
					exceptions_list.append(frappe.get_traceback())

	if mr_list:
		if getattr(frappe.local, "reorder_email_notify", None) is None:
			frappe.local.reorder_email_notify = cint(frappe.db.get_value('Stock Settings', None,
				'reorder_email_notify'))

		if(frappe.local.reorder_email_notify):
			send_email_notification(mr_list)

	if exceptions_list:
		notify_errors(exceptions_list)

def send_email_notification(mr_list):
	""" Notify user about auto creation of indent"""

	email_list = frappe.db.sql_list("""select distinct r.parent
		from tabUserRole r, tabUser p
		where p.name = r.parent and p.enabled = 1 and p.docstatus < 2
		and r.role in ('Purchase Manager','Material Manager')
		and p.name not in ('Administrator', 'All', 'Guest')""")

	msg="""<h3>Following Material Requests has been raised automatically \
		based on item reorder level:</h3>"""
	for mr in mr_list:
		msg += "<p><b><u>" + mr.name + """</u></b></p><table class='table table-bordered'><tr>
			<th>Item Code</th><th>Warehouse</th><th>Qty</th><th>UOM</th></tr>"""
		for item in mr.get("indent_details"):
			msg += "<tr><td>" + item.item_code + "</td><td>" + item.warehouse + "</td><td>" + \
				cstr(item.qty) + "</td><td>" + cstr(item.uom) + "</td></tr>"
		msg += "</table>"
	sendmail(email_list, subject='Auto Material Request Generation Notification', msg = msg)

def notify_errors(exceptions_list):
	subject = "[Important] [ERPNext] Error(s) while creating Material Requests based on Re-order Levels"
	msg = """Dear System Manager,

		An error occured for certain Items while creating Material Requests based on Re-order level.

		Please rectify these issues:
		---

		%s

		---
		Regards,
		Administrator""" % ("\n\n".join(["\n".join(msg) for msg in exceptions_list]),)

	from frappe.utils.user import get_system_managers
	sendmail(get_system_managers(), subject=subject, msg=msg)

########NEW FILE########
__FILENAME__ = customer_issue
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


from __future__ import unicode_literals
import frappe
from frappe import session, _
from frappe.utils import today



from erpnext.utilities.transaction_base import TransactionBase

class CustomerIssue(TransactionBase):

	def validate(self):
		if session['user'] != 'Guest' and not self.customer:
			frappe.throw(_("Customer is required"))

		if self.status=="Closed" and \
			frappe.db.get_value("Customer Issue", self.name, "status")!="Closed":
			self.resolution_date = today()
			self.resolved_by = frappe.session.user

	def on_cancel(self):
		lst = frappe.db.sql("""select t1.name
			from `tabMaintenance Visit` t1, `tabMaintenance Visit Purpose` t2
			where t2.parent = t1.name and t2.prevdoc_docname = %s and	t1.docstatus!=2""",
			(self.name))
		if lst:
			lst1 = ','.join([x[0] for x in lst])
			frappe.throw(_("Cancel Material Visit {0} before cancelling this Customer Issue").format(lst1))
		else:
			frappe.db.set(self, 'status', 'Cancelled')

	def on_update(self):
		pass

@frappe.whitelist()
def make_maintenance_visit(source_name, target_doc=None):
	from frappe.model.mapper import get_mapped_doc

	visit = frappe.db.sql("""select t1.name
		from `tabMaintenance Visit` t1, `tabMaintenance Visit Purpose` t2
		where t2.parent=t1.name and t2.prevdoc_docname=%s
		and t1.docstatus=1 and t1.completion_status='Fully Completed'""", source_name)

	if not visit:
		doclist = get_mapped_doc("Customer Issue", source_name, {
			"Customer Issue": {
				"doctype": "Maintenance Visit",
				"field_map": {
					"complaint": "description",
					"doctype": "prevdoc_doctype",
					"name": "prevdoc_docname"
				}
			}
		}, target_doc)

		return doclist

########NEW FILE########
__FILENAME__ = maintenance_schedule
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import add_days, getdate, cint

from frappe import throw, _
from erpnext.utilities.transaction_base import TransactionBase, delete_events
from erpnext.stock.utils import get_valid_serial_nos

class MaintenanceSchedule(TransactionBase):

	def get_item_details(self, item_code):
		item = frappe.db.sql("""select item_name, description from `tabItem`
			where name=%s""", (item_code), as_dict=1)
		ret = {
			'item_name': item and item[0]['item_name'] or '',
			'description' : item and item[0]['description'] or ''
		}
		return ret

	def generate_schedule(self):
		self.set('maintenance_schedule_detail', [])
		frappe.db.sql("""delete from `tabMaintenance Schedule Detail`
			where parent=%s""", (self.name))
		count = 1
		for d in self.get('item_maintenance_detail'):
			self.validate_maintenance_detail()
			s_list = []
			s_list = self.create_schedule_list(d.start_date, d.end_date, d.no_of_visits, d.sales_person)
			for i in range(d.no_of_visits):
				child = self.append('maintenance_schedule_detail')
				child.item_code = d.item_code
				child.item_name = d.item_name
				child.scheduled_date = s_list[i].strftime('%Y-%m-%d')
				if d.serial_no:
					child.serial_no = d.serial_no
				child.idx = count
				count = count + 1
				child.sales_person = d.sales_person
				child.save(1)

		self.on_update()

	def on_submit(self):
		if not self.get('maintenance_schedule_detail'):
			throw(_("Please click on 'Generate Schedule' to get schedule"))
		self.check_serial_no_added()
		self.validate_schedule()

		email_map = {}
		for d in self.get('item_maintenance_detail'):
			if d.serial_no:
				serial_nos = get_valid_serial_nos(d.serial_no)
				self.validate_serial_no(serial_nos, d.start_date)
				self.update_amc_date(serial_nos, d.end_date)

			if d.sales_person not in email_map:
				sp = frappe.get_doc("Sales Person", d.sales_person)
				email_map[d.sales_person] = sp.get_email_id()

			scheduled_date = frappe.db.sql("""select scheduled_date from
				`tabMaintenance Schedule Detail` where sales_person=%s and item_code=%s and
				parent=%s""", (d.sales_person, d.item_code, self.name), as_dict=1)

			for key in scheduled_date:
				if email_map[d.sales_person]:
					description = "Reference: %s, Item Code: %s and Customer: %s" % \
						(self.name, d.item_code, self.customer)
					frappe.get_doc({
						"doctype": "Event",
						"owner": email_map[d.sales_person] or self.owner,
						"subject": description,
						"description": description,
						"starts_on": key["scheduled_date"] + " 10:00:00",
						"event_type": "Private",
						"ref_type": self.doctype,
						"ref_name": self.name
					}).insert(ignore_permissions=1)

		frappe.db.set(self, 'status', 'Submitted')

	def create_schedule_list(self, start_date, end_date, no_of_visit, sales_person):
		schedule_list = []
		start_date_copy = start_date
		date_diff = (getdate(end_date) - getdate(start_date)).days
		add_by = date_diff / no_of_visit

		for visit in range(cint(no_of_visit)):
			if (getdate(start_date_copy) < getdate(end_date)):
				start_date_copy = add_days(start_date_copy, add_by)
				if len(schedule_list) < no_of_visit:
					schedule_date = self.validate_schedule_date_for_holiday_list(getdate(start_date_copy),
						sales_person)
					if schedule_date > getdate(end_date):
						schedule_date = getdate(end_date)
					schedule_list.append(schedule_date)

		return schedule_list

	def validate_schedule_date_for_holiday_list(self, schedule_date, sales_person):
		from erpnext.accounts.utils import get_fiscal_year
		validated = False
		fy_details = ""

		try:
			fy_details = get_fiscal_year(date=schedule_date, verbose=0)
		except Exception:
			pass

		if fy_details and fy_details[0]:
			# check holiday list in employee master
			holiday_list = frappe.db.sql_list("""select h.holiday_date from `tabEmployee` emp,
				`tabSales Person` sp, `tabHoliday` h, `tabHoliday List` hl
				where sp.name=%s and emp.name=sp.employee
				and hl.name=emp.holiday_list and
				h.parent=hl.name and
				hl.fiscal_year=%s""", (sales_person, fy_details[0]))
			if not holiday_list:
				# check global holiday list
				holiday_list = frappe.db.sql("""select h.holiday_date from
					`tabHoliday` h, `tabHoliday List` hl
					where h.parent=hl.name and ifnull(hl.is_default, 0) = 1
					and hl.fiscal_year=%s""", fy_details[0])

			if not validated and holiday_list:
				if schedule_date in holiday_list:
					schedule_date = add_days(schedule_date, -1)
				else:
					validated = True

		return schedule_date

	def validate_dates_with_periodicity(self):
		for d in self.get("item_maintenance_detail"):
			if d.start_date and d.end_date and d.periodicity:
				date_diff = (getdate(d.end_date) - getdate(d.start_date)).days + 1
				days_in_period = {
					"Weekly": 7,
					"Monthly": 30,
					"Quarterly": 90,
					"Half Yearly": 180,
					"Yearly": 365
				}

				if date_diff < days_in_period[d.periodicity]:
					throw(_("Row {0}: To set {1} periodicity, difference between from and to date \
						must be greater than or equal to {2}")
						.format(d.idx, d.periodicity, days_in_period[d.periodicity]))

	def validate_maintenance_detail(self):
		if not self.get('item_maintenance_detail'):
			throw(_("Please enter Maintaince Details first"))

		for d in self.get('item_maintenance_detail'):
			if not d.item_code:
				throw(_("Please select item code"))
			elif not d.start_date or not d.end_date:
				throw(_("Please select Start Date and End Date for Item {0}".format(d.item_code)))
			elif not d.no_of_visits:
				throw(_("Please mention no of visits required"))
			elif not d.sales_person:
				throw(_("Please select Incharge Person's name"))

			if getdate(d.start_date) >= getdate(d.end_date):
				throw(_("Start date should be less than end date for Item {0}").format(d.item_code))

	def validate_sales_order(self):
		for d in self.get('item_maintenance_detail'):
			if d.prevdoc_docname:
				chk = frappe.db.sql("""select ms.name from `tabMaintenance Schedule` ms,
					`tabMaintenance Schedule Item` msi where msi.parent=ms.name and
					msi.prevdoc_docname=%s and ms.docstatus=1""", d.prevdoc_docname)
				if chk:
					throw(_("Maintenance Schedule {0} exists against {0}").format(chk[0][0], d.prevdoc_docname))

	def validate(self):
		self.validate_maintenance_detail()
		self.validate_dates_with_periodicity()
		self.validate_sales_order()

	def on_update(self):
		frappe.db.set(self, 'status', 'Draft')

	def update_amc_date(self, serial_nos, amc_expiry_date=None):
		for serial_no in serial_nos:
			serial_no_doc = frappe.get_doc("Serial No", serial_no)
			serial_no_doc.amc_expiry_date = amc_expiry_date
			serial_no_doc.save()

	def validate_serial_no(self, serial_nos, amc_start_date):
		for serial_no in serial_nos:
			sr_details = frappe.db.get_value("Serial No", serial_no,
				["warranty_expiry_date", "amc_expiry_date", "status", "delivery_date"], as_dict=1)

			if sr_details.warranty_expiry_date and sr_details.warranty_expiry_date>=amc_start_date:
				throw(_("Serial No {0} is under warranty upto {1}").format(serial_no, sr_details.warranty_expiry_date))

			if sr_details.amc_expiry_date and sr_details.amc_expiry_date >= amc_start_date:
				throw(_("Serial No {0} is under maintenance contract upto {1}").format(serial_no, sr_details.amc_start_date))

			if sr_details.status=="Delivered" and sr_details.delivery_date and \
				sr_details.delivery_date >= amc_start_date:
					throw(_("Maintenance start date can not be before delivery date for Serial No {0}").format(serial_no))

	def validate_schedule(self):
		item_lst1 =[]
		item_lst2 =[]
		for d in self.get('item_maintenance_detail'):
			if d.item_code not in item_lst1:
				item_lst1.append(d.item_code)

		for m in self.get('maintenance_schedule_detail'):
			if m.item_code not in item_lst2:
				item_lst2.append(m.item_code)

		if len(item_lst1) != len(item_lst2):
			throw(_("Maintenance Schedule is not generated for all the items. Please click on 'Generate Schedule'"))
		else:
			for x in item_lst1:
				if x not in item_lst2:
					throw(_("Please click on 'Generate Schedule'"))

	def check_serial_no_added(self):
		serial_present =[]
		for d in self.get('item_maintenance_detail'):
			if d.serial_no:
				serial_present.append(d.item_code)

		for m in self.get('maintenance_schedule_detail'):
			if serial_present:
				if m.item_code in serial_present and not m.serial_no:
					throw(_("Please click on 'Generate Schedule' to fetch Serial No added for Item {0}").format(m.item_code))

	def on_cancel(self):
		for d in self.get('item_maintenance_detail'):
			if d.serial_no:
				serial_nos = get_valid_serial_nos(d.serial_no)
				self.update_amc_date(serial_nos)
		frappe.db.set(self, 'status', 'Cancelled')
		delete_events(self.doctype, self.name)

	def on_trash(self):
		delete_events(self.doctype, self.name)

@frappe.whitelist()
def make_maintenance_visit(source_name, target_doc=None):
	from frappe.model.mapper import get_mapped_doc

	def update_status(source, target, parent):
		target.maintenance_type = "Scheduled"

	doclist = get_mapped_doc("Maintenance Schedule", source_name, {
		"Maintenance Schedule": {
			"doctype": "Maintenance Visit",
			"field_map": {
				"name": "maintenance_schedule"
			},
			"validation": {
				"docstatus": ["=", 1]
			},
			"postprocess": update_status
		},
		"Maintenance Schedule Item": {
			"doctype": "Maintenance Visit Purpose",
			"field_map": {
				"parent": "prevdoc_docname",
				"parenttype": "prevdoc_doctype",
				"sales_person": "service_person"
			}
		}
	}, target_doc)

	return doclist

########NEW FILE########
__FILENAME__ = maintenance_schedule_detail
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class MaintenanceScheduleDetail(Document):
	pass
########NEW FILE########
__FILENAME__ = maintenance_schedule_item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class MaintenanceScheduleItem(Document):
	pass
########NEW FILE########
__FILENAME__ = maintenance_visit
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _

from erpnext.utilities.transaction_base import TransactionBase

class MaintenanceVisit(TransactionBase):

	def get_item_details(self, item_code):
		return frappe.db.get_value("Item", item_code, ["item_name", "description"], as_dict=1)

	def validate_serial_no(self):
		for d in self.get('maintenance_visit_details'):
			if d.serial_no and not frappe.db.exists("Serial No", d.serial_no):
				frappe.throw(_("Serial No {0} does not exist").format(d.serial_no))

	def validate(self):
		self.validate_serial_no()

	def update_customer_issue(self, flag):
		for d in self.get('maintenance_visit_details'):
			if d.prevdoc_docname and d.prevdoc_doctype == 'Customer Issue' :
				if flag==1:
					mntc_date = self.mntc_date
					service_person = d.service_person
					work_done = d.work_done
					if self.completion_status == 'Fully Completed':
						status = 'Closed'
					elif self.completion_status == 'Partially Completed':
						status = 'Work In Progress'
				else:
					nm = frappe.db.sql("select t1.name, t1.mntc_date, t2.service_person, t2.work_done from `tabMaintenance Visit` t1, `tabMaintenance Visit Purpose` t2 where t2.parent = t1.name and t1.completion_status = 'Partially Completed' and t2.prevdoc_docname = %s and t1.name!=%s and t1.docstatus = 1 order by t1.name desc limit 1", (d.prevdoc_docname, self.name))

					if nm:
						status = 'Work In Progress'
						mntc_date = nm and nm[0][1] or ''
						service_person = nm and nm[0][2] or ''
						work_done = nm and nm[0][3] or ''
					else:
						status = 'Open'
						mntc_date = ''
						service_person = ''
						work_done = ''

				frappe.db.sql("update `tabCustomer Issue` set resolution_date=%s, resolved_by=%s, resolution_details=%s, status=%s where name =%s",(mntc_date,service_person,work_done,status,d.prevdoc_docname))


	def check_if_last_visit(self):
		"""check if last maintenance visit against same sales order/ customer issue"""
		check_for_docname = None
		for d in self.get('maintenance_visit_details'):
			if d.prevdoc_docname:
				check_for_docname = d.prevdoc_docname
				#check_for_doctype = d.prevdoc_doctype

		if check_for_docname:
			check = frappe.db.sql("select t1.name from `tabMaintenance Visit` t1, `tabMaintenance Visit Purpose` t2 where t2.parent = t1.name and t1.name!=%s and t2.prevdoc_docname=%s and t1.docstatus = 1 and (t1.mntc_date > %s or (t1.mntc_date = %s and t1.mntc_time > %s))", (self.name, check_for_docname, self.mntc_date, self.mntc_date, self.mntc_time))

			if check:
				check_lst = [x[0] for x in check]
				check_lst =','.join(check_lst)
				frappe.throw(_("Cancel Material Visits {0} before cancelling this Maintenance Visit").format(check_lst))
				raise Exception
			else:
				self.update_customer_issue(0)

	def on_submit(self):
		self.update_customer_issue(1)
		frappe.db.set(self, 'status', 'Submitted')

	def on_cancel(self):
		self.check_if_last_visit()
		frappe.db.set(self, 'status', 'Cancelled')

	def on_update(self):
		pass

########NEW FILE########
__FILENAME__ = maintenance_visit_purpose
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class MaintenanceVisitPurpose(Document):
	pass
########NEW FILE########
__FILENAME__ = newsletter
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals

import frappe
import frappe.utils
from frappe.utils import cstr
from frappe import throw, _
from frappe.model.document import Document

class Newsletter(Document):
	def onload(self):
		if self.email_sent:
			self.get("__onload").status_count = dict(frappe.db.sql("""select status, count(*)
				from `tabBulk Email` where ref_doctype=%s and ref_docname=%s
				group by status""", (self.doctype, self.name))) or None

	def test_send(self, doctype="Lead"):
		self.recipients = self.test_email_id.split(",")
		self.send_to_doctype = "Lead"
		self.send_bulk()
		frappe.msgprint(_("Scheduled to send to {0}").format(self.test_email_id))

	def send_emails(self):
		"""send emails to leads and customers"""
		if self.email_sent:
			throw(_("Newsletter has already been sent"))

		self.recipients = self.get_recipients()
		self.send_bulk()

		frappe.msgprint(_("Scheduled to send to {0} recipients").format(len(self.recipients)))

		frappe.db.set(self, "email_sent", 1)

	def get_recipients(self):
		self.email_field = None
		if self.send_to_type=="Contact":
			self.send_to_doctype = "Contact"
			if self.contact_type == "Customer":
				return frappe.db.sql_list("""select email_id from tabContact
					where ifnull(email_id, '') != '' and ifnull(customer, '') != ''""")

			elif self.contact_type == "Supplier":
				return frappe.db.sql_list("""select email_id from tabContact
					where ifnull(email_id, '') != '' and ifnull(supplier, '') != ''""")

		elif self.send_to_type=="Lead":
			self.send_to_doctype = "Lead"
			conditions = []
			if self.lead_source and self.lead_source != "All":
				conditions.append(" and source='%s'" % self.lead_source.replace("'", "\'"))
			if self.lead_status and self.lead_status != "All":
				conditions.append(" and status='%s'" % self.lead_status.replace("'", "\'"))

			if conditions:
				conditions = "".join(conditions)

			return frappe.db.sql_list("""select email_id from tabLead
				where ifnull(email_id, '') != '' %s""" % (conditions or ""))

		elif self.send_to_type=="Employee":
			self.send_to_doctype = "Employee"
			self.email_field = "company_email"

			return frappe.db.sql_list("""select
				if(ifnull(company_email, '')!='', company_email, personal_email) as email_id
				from `tabEmployee` where status='Active'""")

		elif self.email_list:
			email_list = [cstr(email).strip() for email in self.email_list.split(",")]
			for email in email_list:
				create_lead(email)

			self.send_to_doctype = "Lead"
			return email_list

	def send_bulk(self):
		self.validate_send()

		sender = self.send_from or frappe.utils.get_formatted_email(self.owner)

		from frappe.utils.email_lib.bulk import send

		if not frappe.flags.in_test:
			frappe.db.auto_commit_on_many_writes = True

		send(recipients = self.recipients, sender = sender,
			subject = self.subject, message = self.message,
			doctype = self.send_to_doctype, email_field = self.email_field or "email_id",
			ref_doctype = self.doctype, ref_docname = self.name)

		if not frappe.flags.in_test:
			frappe.db.auto_commit_on_many_writes = False

	def validate_send(self):
		if self.get("__islocal"):
			throw(_("Please save the Newsletter before sending"))

		from frappe import conf
		if (conf.get("status") or None) == "Trial":
			throw(_("Newsletters is not allowed for Trial users"))

@frappe.whitelist()
def get_lead_options():
	return {
		"sources": ["All"] + filter(None,
			frappe.db.sql_list("""select distinct source from tabLead""")),
		"statuses": ["All"] + filter(None,
			frappe.db.sql_list("""select distinct status from tabLead"""))
	}


def create_lead(email_id):
	"""create a lead if it does not exist"""
	from email.utils import parseaddr
	from frappe.model.naming import get_default_naming_series
	real_name, email_id = parseaddr(email_id)

	if frappe.db.get_value("Lead", {"email_id": email_id}):
		return

	lead = frappe.get_doc({
		"doctype": "Lead",
		"email_id": email_id,
		"lead_name": real_name or email_id,
		"status": "Contacted",
		"naming_series": get_default_naming_series("Lead"),
		"company": frappe.db.get_default("company"),
		"source": "Email"
	})
	lead.insert()

########NEW FILE########
__FILENAME__ = test_newsletter
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

import frappe, unittest

class TestNewsletter(unittest.TestCase):
	def test_get_recipients_lead(self):
		w = frappe.get_doc(test_records[0])
		w.insert()
		self.assertTrue("test_lead@example.com" in w.get_recipients())
		frappe.db.sql("""delete from `tabBulk Email`""")
		w.send_emails()
		self.assertTrue(frappe.db.get_value("Bulk Email", {"recipient": "test_lead@example.com"}))

	def test_get_recipients_lead_by_status(self):
		w = frappe.get_doc(test_records[0])
		w.lead_status="Converted"
		w.insert()
		self.assertTrue("test_lead3@example.com" in w.get_recipients())

	def test_get_recipients_contact_customer(self):
		w = frappe.get_doc(test_records[1])
		w.insert()
		self.assertTrue("test_contact_customer@example.com" in w.get_recipients())

	def test_get_recipients_contact_supplier(self):
		w = frappe.get_doc(test_records[1])
		w.contact_type="Supplier"
		w.insert()
		self.assertTrue("test_contact_supplier@example.com" in w.get_recipients())

	def test_get_recipients_custom(self):
		w = frappe.get_doc(test_records[2])
		w.insert()
		self.assertTrue("test_custom2@example.com" in w.get_recipients())
		self.assertTrue(frappe.db.get("Lead",
			{"email_id": "test_custom2@example.com"}))


test_dependencies = ["Lead", "Contact"]

test_records = frappe.get_test_records('Newsletter')

########NEW FILE########
__FILENAME__ = support_email_settings
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# MIT License. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.model.document import Document
from frappe.utils.email_lib.receive import POP3Mailbox
import _socket, poplib

class SupportEmailSettings(Document):

	def validate(self):
		"""
			Checks support ticket email settings
		"""
		if self.sync_support_mails and self.mail_server:
			inc_email = frappe._dict(self.as_dict())
			# inc_email.encode()
			inc_email.host = self.mail_server
			inc_email.use_ssl = self.use_ssl
			try:
				err_msg = _('User Name or Support Password missing. Please enter and try again.')
				if not (self.mail_login and self.mail_password):
					raise AttributeError, err_msg
				inc_email.username = self.mail_login
				inc_email.password = self.mail_password
			except AttributeError, e:
				frappe.msgprint(err_msg)
				raise

			pop_mb = POP3Mailbox(inc_email)

			try:
				pop_mb.connect()
			except _socket.error, e:
				# Invalid mail server -- due to refusing connection
				frappe.msgprint(_('Invalid Mail Server. Please rectify and try again.'))
				raise
			except poplib.error_proto, e:
				frappe.msgprint(_('Invalid User Name or Support Password. Please rectify and try again.'))
				raise

########NEW FILE########
__FILENAME__ = get_support_mails
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cstr, cint, decode_dict, today
from frappe.utils.email_lib import sendmail		
from frappe.utils.email_lib.receive import POP3Mailbox
from frappe.core.doctype.communication.communication import _make

class SupportMailbox(POP3Mailbox):	
	def setup(self, args=None):
		self.email_settings = frappe.get_doc("Support Email Settings", "Support Email Settings")
		self.settings = args or frappe._dict({
			"use_ssl": self.email_settings.use_ssl,
			"host": self.email_settings.mail_server,
			"username": self.email_settings.mail_login,
			"password": self.email_settings.mail_password
		})
		
	def process_message(self, mail):
		if mail.from_email == self.email_settings.get('support_email'):
			return
		thread_id = mail.get_thread_id()
		new_ticket = False

		if not (thread_id and frappe.db.exists("Support Ticket", thread_id)):
			new_ticket = True
		
		ticket = add_support_communication(mail.subject, mail.content, mail.from_email,
			docname=None if new_ticket else thread_id, mail=mail)
			
		if new_ticket and cint(self.email_settings.send_autoreply) and \
			"mailer-daemon" not in mail.from_email.lower():
				self.send_auto_reply(ticket)

	def send_auto_reply(self, d):
		signature = self.email_settings.get('support_signature') or ''
		response = self.email_settings.get('support_autoreply') or ("""
A new Ticket has been raised for your query. If you have any additional information, please
reply back to this mail.
		
We will get back to you as soon as possible
----------------------
Original Query:

""" + d.description + "\n----------------------\n" + cstr(signature))

		sendmail(\
			recipients = [cstr(d.raised_by)], \
			sender = cstr(self.email_settings.get('support_email')), \
			subject = '['+cstr(d.name)+'] ' + cstr(d.subject), \
			msg = cstr(response))
		
def get_support_mails():
	if cint(frappe.db.get_value('Support Email Settings', None, 'sync_support_mails')):
		SupportMailbox()
		
def add_support_communication(subject, content, sender, docname=None, mail=None):
	if docname:
		ticket = frappe.get_doc("Support Ticket", docname)
		ticket.status = 'Open'
		ticket.ignore_permissions = True
		ticket.save()
	else:
		ticket = frappe.get_doc(decode_dict({
			"doctype":"Support Ticket",
			"description": content,
			"subject": subject,
			"raised_by": sender,
			"content_type": mail.content_type if mail else None,
			"status": "Open",
		}))
		ticket.ignore_permissions = True
		ticket.ignore_mandatory = True
		ticket.insert()
	
	_make(content=content, sender=sender, subject = subject,
		doctype="Support Ticket", name=ticket.name,
		date=mail.date if mail else today(), sent_or_received="Received")

	if mail:
		mail.save_attachments_in_doc(ticket)
		
	return ticket
########NEW FILE########
__FILENAME__ = support_ticket
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from erpnext.utilities.transaction_base import TransactionBase
from frappe.utils import now, extract_email_id

class SupportTicket(TransactionBase):
	
	def get_sender(self, comm):
		return frappe.db.get_value('Support Email Settings',None,'support_email')

	def get_subject(self, comm):
		return '[' + self.name + '] ' + (comm.subject or 'No Subject Specified')
	
	def get_content(self, comm):
		signature = frappe.db.get_value('Support Email Settings',None,'support_signature')
		content = comm.content
		if signature:
			content += '<p>' + signature + '</p>'
		return content
		
	def get_portal_page(self):
		return "ticket"
	
	def validate(self):
		self.update_status()
		self.set_lead_contact(self.raised_by)
		
		if self.status == "Closed":
			from frappe.widgets.form.assign_to import clear
			clear(self.doctype, self.name)
				
	def set_lead_contact(self, email_id):
		import email.utils
		email_id = email.utils.parseaddr(email_id)
		if email_id:
			if not self.lead:
				self.lead = frappe.db.get_value("Lead", {"email_id": email_id})
			if not self.contact:
				self.contact = frappe.db.get_value("Contact", {"email_id": email_id})
				
			if not self.company:		
				self.company = frappe.db.get_value("Lead", self.lead, "company") or \
					frappe.db.get_default("company")

	def update_status(self):
		status = frappe.db.get_value("Support Ticket", self.name, "status")
		if self.status!="Open" and status =="Open" and not self.first_responded_on:
			self.first_responded_on = now()
		if self.status=="Closed" and status !="Closed":
			self.resolution_date = now()
		if self.status=="Open" and status !="Open":
			self.resolution_date = ""

@frappe.whitelist()
def set_status(name, status):
	st = frappe.get_doc("Support Ticket", name)
	st.status = status
	st.save()
		
def auto_close_tickets():
	frappe.db.sql("""update `tabSupport Ticket` set status = 'Closed' 
		where status = 'Replied' 
		and date_sub(curdate(),interval 15 Day) > modified""")

########NEW FILE########
__FILENAME__ = item
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals

import frappe
from erpnext.setup.doctype.item_group.item_group import get_parent_item_groups
from frappe.website.doctype.website_slideshow.website_slideshow import get_slideshow

doctype = "Item"
condition_field = "show_in_website"

def get_context(context):
	item_context = context.doc.as_dict()
	item_context["parent_groups"] = get_parent_item_groups(context.doc.item_group) + \
		[{"name":context.doc.name}]
	if context.doc.slideshow:
		item_context.update(get_slideshow(context.doc))

	return item_context

########NEW FILE########
__FILENAME__ = item_group
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals

import frappe
from frappe.website.doctype.website_slideshow.website_slideshow import get_slideshow
from erpnext.setup.doctype.item_group.item_group import get_parent_item_groups

doctype = "Item Group"
condition_field = "show_in_website"

def get_context(context):
	item_group_context = context.doc.as_dict()
	item_group_context.update({
		"items": get_product_list_for_group(product_group = context.docname, limit=100),
		"parent_groups": get_parent_item_groups(context.docname),
		"title": context.docname
	})

	if context.doc.slideshow:
		item_group_context.update(get_slideshow(context.doc))

	return item_group_context

def get_product_list_for_group(product_group=None, start=0, limit=10):
	child_groups = ", ".join(['"' + i[0] + '"' for i in get_child_groups(product_group)])

	# base query
	query = """select t1.name, t1.item_name, t1.page_name, t1.website_image, t1.item_group,
			t1.web_long_description as website_description, t2.name as route
		from `tabItem` t1, `tabWebsite Route` t2
		where t1.show_in_website = 1 and (item_group in (%s)
			or t1.name in (select parent from `tabWebsite Item Group` where item_group in (%s)))
			and t1.name = t2.docname and t2.ref_doctype='Item' """ % (child_groups, child_groups)

	query += """order by t1.weightage desc, t1.modified desc limit %s, %s""" % (start, limit)

	data = frappe.db.sql(query, {"product_group": product_group}, as_dict=1)

	return [get_item_for_list_in_html(r) for r in data]

def get_child_groups(item_group_name):
	item_group = frappe.get_doc("Item Group", item_group_name)
	return frappe.db.sql("""select name
		from `tabItem Group` where lft>=%(lft)s and rgt<=%(rgt)s
			and show_in_website = 1""", item_group.as_dict())

def get_item_for_list_in_html(context):
	return frappe.get_template("templates/includes/product_in_grid.html").render(context)

def get_group_item_count(item_group):
	child_groups = ", ".join(['"' + i[0] + '"' for i in get_child_groups(item_group)])
	return frappe.db.sql("""select count(*) from `tabItem`
		where docstatus = 0 and show_in_website = 1
		and (item_group in (%s)
			or name in (select parent from `tabWebsite Item Group`
				where item_group in (%s))) """ % (child_groups, child_groups))[0][0]


########NEW FILE########
__FILENAME__ = partner
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import filter_strip_join

doctype = "Sales Partner"
condition_field = "show_in_website"

def get_context(context):
	partner_context = context.doc.as_dict()
	
	address = frappe.db.get_value("Address", 
		{"sales_partner": context.doc.name, "is_primary_address": 1}, 
		"*", as_dict=True)
	if address:
		city_state = ", ".join(filter(None, [address.city, address.state]))
		address_rows = [address.address_line1, address.address_line2,
			city_state, address.pincode, address.country]
			
		partner_context.update({
			"email": address.email_id,
			"partner_address": filter_strip_join(address_rows, "\n<br>"),
			"phone": filter_strip_join(cstr(address.phone).split(","), "\n<br>")
		})
	
	return partner_context

########NEW FILE########
__FILENAME__ = partners
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
import frappe.website.render

def get_context(context):
	return {
		"partners": frappe.db.sql("""select * from `tabSales Partner`
			where show_in_website=1 order by name asc""", as_dict=True),
		"title": "Partners"
	}

########NEW FILE########
__FILENAME__ = product_search
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cstr
from erpnext.templates.generators.item_group import get_item_for_list_in_html

no_cache = 1
no_sitemap = 1

@frappe.whitelist(allow_guest=True)
def get_product_list(search=None, start=0, limit=10):
	# base query
	query = """select t1.name, t1.item_name, t1.page_name, t1.website_image, t1.item_group,
			t1.web_long_description as website_description, t2.name as route
		from `tabItem` t1, `tabWebsite Route` t2 where t1.show_in_website = 1
			and t1.name = t2.docname and t2.ref_doctype = 'Item'"""

	# search term condition
	if search:
		query += """and (t1.web_long_description like %(search)s or t1.description like %(search)s or
				t1.item_name like %(search)s or t1.name like %(search)s)"""
		search = "%" + cstr(search) + "%"

	# order by
	query += """order by t1.weightage desc, t1.modified desc limit %s, %s""" % (start, limit)

	data = frappe.db.sql(query, {
		"search": search,
	}, as_dict=1)

	return [get_item_for_list_in_html(r) for r in data]


########NEW FILE########
__FILENAME__ = utils
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

@frappe.whitelist(allow_guest=True)
def send_message(subject="Website Query", message="", sender="", status="Open"):
	from frappe.templates.pages.contact import send_message as website_send_message
	res = website_send_message(subject, message, sender)

	if not res:
		return

	if subject=="Support":
		# create support ticket
		from erpnext.support.doctype.support_ticket.get_support_mails import add_support_communication
		add_support_communication(subject, message, sender, mail=None)
	else:
		# make lead / communication
		from erpnext.selling.doctype.lead.get_leads import add_sales_communication
		add_sales_communication(subject or "Website Query", message, sender, sender,
			mail=None, status=status)

	return res

########NEW FILE########
__FILENAME__ = sel_tests
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

"""
Run Selenium Tests

Requires a clean install. After reinstalling fresh db, call

	frappe --execute erpnext.tests.sel_tests.start

"""

from __future__ import unicode_literals
import frappe

from frappe.utils import sel
import time

def start():
	try:
		run()
	finally:
		sel.close()

def run():
	def next_slide(idx, selector="next-btn"):
		sel.find('[data-slide-id="{0}"] .{1}'.format(idx, selector))[0].click()
		sel.wait_for_ajax()


	sel.start(verbose=True, driver="Firefox")
	sel.input_wait = 0.2
	sel.login("#page-setup-wizard")

	# slide 1
	next_slide("0")

	sel.set_field("first_name", "Test")
	sel.set_field("last_name", "User")
	sel.set_field("email", "test@erpnext.com")
	sel.set_field("password", "test")

	next_slide("1")

	sel.set_select("country", "India")

	next_slide("2")

	sel.set_field("company_name", "Wind Power LLC")
	sel.set_field("fy_start_date", "01-04-2014")
	sel.set_field("company_tagline", "Wind Power For Everyone")

	next_slide("3")
	next_slide("4")

	sel.set_field("tax_1", "VAT")
	sel.set_field("tax_rate_1", "12.5")

	sel.set_field("tax_2", "Service Tax")
	sel.set_field("tax_rate_2", "10.36")

	next_slide("5")

	sel.set_field("customer_1", "Asian Junction")
	sel.set_field("customer_contact_1", "January Vaclavik")
	sel.set_field("customer_2", "Life Plan Counselling")
	sel.set_field("customer_contact_2", "Jana Tobeolisa")
	sel.set_field("customer_3", "Two Pesos")
	sel.set_field("customer_contact_3", "Satomi Shigeki")
	sel.set_field("customer_4", "Intelacard")
	sel.set_field("customer_contact_4", "Hans Rasmussen")

	next_slide("6")

	sel.set_field("item_1", "Wind Turbine A")
	sel.set_field("item_2", "Wind Turbine B")
	sel.set_field("item_3", "Wind Turbine C")

	next_slide("7")

	sel.set_field("supplier_1", "Helios Air")
	sel.set_field("supplier_contact_1", "Quimey Osorio")
	sel.set_field("supplier_2", "Ks Merchandise")
	sel.set_field("supplier_contact_2", "Edgarda Salcedo")
	sel.set_field("supplier_3", "Eagle Hardware")
	sel.set_field("supplier_contact_3", "Hafsteinn Bjarnarsonar")

	next_slide("8")

	sel.set_field("item_buy_1", "Bearing Pipe")
	sel.set_field("item_buy_2", "Bearing Assembly")
	sel.set_field("item_buy_3", "Base Plate")
	sel.set_field("item_buy_4", "Coil")

	next_slide("9", "complete-btn")

	sel.wait('[data-state="setup-complete"]')

	w = raw_input("quit?")

# complete setup
# new customer
# new supplier
# new item
# sales cycle
# purchase cycle

########NEW FILE########
__FILENAME__ = address
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe import throw, _
from frappe.utils import cstr

from frappe.model.document import Document

class Address(Document):

	def autoname(self):
		if not self.address_title:
			self.address_title = self.customer \
				or self.supplier or self.sales_partner or self.lead

		if self.address_title:
			self.name = cstr(self.address_title).strip() + "-" + cstr(self.address_type).strip()
		else:
			throw(_("Address Title is mandatory."))

	def validate(self):
		self.validate_primary_address()
		self.validate_shipping_address()

	def validate_primary_address(self):
		"""Validate that there can only be one primary address for particular customer, supplier"""
		if self.is_primary_address == 1:
			self._unset_other("is_primary_address")

		elif self.is_shipping_address != 1:
			for fieldname in ["customer", "supplier", "sales_partner", "lead"]:
				if self.get(fieldname):
					if not frappe.db.sql("""select name from `tabAddress` where is_primary_address=1
						and `%s`=%s and name!=%s""" % (fieldname, "%s", "%s"),
						(self.get(fieldname), self.name)):
							self.is_primary_address = 1
					break

	def validate_shipping_address(self):
		"""Validate that there can only be one shipping address for particular customer, supplier"""
		if self.is_shipping_address == 1:
			self._unset_other("is_shipping_address")

	def _unset_other(self, is_address_type):
		for fieldname in ["customer", "supplier", "sales_partner", "lead"]:
			if self.get(fieldname):
				frappe.db.sql("""update `tabAddress` set `%s`=0 where `%s`=%s and name!=%s""" %
					(is_address_type, fieldname, "%s", "%s"), (self.get(fieldname), self.name))
				break

@frappe.whitelist()
def get_address_display(address_dict):
	if not isinstance(address_dict, dict):
		address_dict = frappe.db.get_value("Address", address_dict, "*", as_dict=True) or {}

	meta = frappe.get_meta("Address")
	sequence = (("", "address_line1"),
		("\n", "address_line2"),
		("\n", "city"),
		("\n", "state"),
		("\n" + meta.get_label("pincode") + ": ", "pincode"),
		("\n", "country"),
		("\n" + meta.get_label("phone") + ": ", "phone"),
		("\n" + meta.get_label("fax") + ": ", "fax"))

	display = ""
	for separator, fieldname in sequence:
		if address_dict.get(fieldname):
			display += separator + address_dict.get(fieldname)

	return display.strip()

def get_territory_from_address(address):
	"""Tries to match city, state and country of address to existing territory"""
	if not address:
		return

	if isinstance(address, basestring):
		address = frappe.get_doc("Address", address)

	territory = None
	for fieldname in ("city", "state", "country"):
		territory = frappe.db.get_value("Territory", address.get(fieldname))
		if territory:
			break

	return territory

########NEW FILE########
__FILENAME__ = test_address
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Address')
########NEW FILE########
__FILENAME__ = contact
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe.utils import cstr, extract_email_id

from erpnext.controllers.status_updater import StatusUpdater

class Contact(StatusUpdater):

	def autoname(self):
		# concat first and last name
		self.name = " ".join(filter(None, 
			[cstr(self.get(f)).strip() for f in ["first_name", "last_name"]]))
		
		# concat party name if reqd
		for fieldname in ("customer", "supplier", "sales_partner"):
			if self.get(fieldname):
				self.name = self.name + "-" + cstr(self.get(fieldname)).strip()
				break
		
	def validate(self):
		self.set_status()
		self.validate_primary_contact()

	def validate_primary_contact(self):
		if self.is_primary_contact == 1:
			if self.customer:
				frappe.db.sql("update tabContact set is_primary_contact=0 where customer = %s", 
					(self.customer))
			elif self.supplier:
				frappe.db.sql("update tabContact set is_primary_contact=0 where supplier = %s", 
					 (self.supplier))	
			elif self.sales_partner:
				frappe.db.sql("""update tabContact set is_primary_contact=0 
					where sales_partner = %s""", (self.sales_partner))
		else:
			if self.customer:
				if not frappe.db.sql("select name from tabContact \
						where is_primary_contact=1 and customer = %s", (self.customer)):
					self.is_primary_contact = 1
			elif self.supplier:
				if not frappe.db.sql("select name from tabContact \
						where is_primary_contact=1 and supplier = %s", (self.supplier)):
					self.is_primary_contact = 1
			elif self.sales_partner:
				if not frappe.db.sql("select name from tabContact \
						where is_primary_contact=1 and sales_partner = %s", 
						self.sales_partner):
					self.is_primary_contact = 1

	def on_trash(self):
		frappe.db.sql("""update `tabSupport Ticket` set contact='' where contact=%s""",
			self.name)

@frappe.whitelist()
def get_contact_details(contact):
	contact = frappe.get_doc("Contact", contact)
	out = {
		"contact_person": contact.get("name"),
		"contact_display": " ".join(filter(None, 
			[contact.get("first_name"), contact.get("last_name")])),
		"contact_email": contact.get("email_id"),
		"contact_mobile": contact.get("mobile_no"),
		"contact_phone": contact.get("phone"),
		"contact_designation": contact.get("designation"),
		"contact_department": contact.get("department")
	}
	
	return out
########NEW FILE########
__FILENAME__ = test_contact
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt


import frappe
test_records = frappe.get_test_records('Contact')
########NEW FILE########
__FILENAME__ = note
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.model.document import Document

class Note(Document):

	def autoname(self):
		# replace forbidden characters
		import re
		self.name = re.sub("[%'\"#*?`]", "", self.title.strip())

	def onload(self):
		if not self.public and frappe.session.user != self.owner:
			if frappe.session.user not in [d.user for d in self.get("share_with")]:
				frappe.throw(_("Not permitted"), frappe.PermissionError)

	def validate(self):
		if not self.get("__islocal"):
			if frappe.session.user != self.owner:
				if frappe.session.user not in frappe.db.sql_list("""select user from `tabNote User`
					where parent=%s and permission='Edit'""", self.name):
					frappe.throw(_("Not permitted"), frappe.PermissionError)

########NEW FILE########
__FILENAME__ = note_user
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class NoteUser(Document):
	pass
########NEW FILE########
__FILENAME__ = rename_tool
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

# For license information, please see license.txt

from __future__ import unicode_literals
import frappe
from frappe import _

from frappe.model.document import Document

class RenameTool(Document):
	pass

@frappe.whitelist()
def get_doctypes():
	return frappe.db.sql_list("""select name from tabDocType
		where ifnull(allow_rename,0)=1 and module!='Core' order by name""")

@frappe.whitelist()
def upload(select_doctype=None, rows=None):
	from frappe.utils.datautils import read_csv_content_from_uploaded_file
	from frappe.model.rename_doc import rename_doc

	if not select_doctype:
		select_doctype = frappe.form_dict.select_doctype

	if not frappe.has_permission(select_doctype, "write"):
		raise frappe.PermissionError

	if not rows:
		rows = read_csv_content_from_uploaded_file()
	if not rows:
		frappe.throw(_("Please select a valid csv file with data"))

	max_rows = 500
	if len(rows) > max_rows:
		frappe.throw(_("Maximum {0} rows allowed").format(max_rows))

	rename_log = []
	for row in rows:
		# if row has some content
		if len(row) > 1 and row[0] and row[1]:
			try:
				if rename_doc(select_doctype, row[0], row[1]):
					rename_log.append(_("Successful: ") + row[0] + " -> " + row[1])
					frappe.db.commit()
				else:
					rename_log.append(_("Ignored: ") + row[0] + " -> " + row[1])
			except Exception, e:
				rename_log.append("<span style='color: RED'>" + \
					_("Failed: ") + row[0] + " -> " + row[1] + "</span>")
				rename_log.append("<span style='margin-left: 20px;'>" + repr(e) + "</span>")

	return rename_log

########NEW FILE########
__FILENAME__ = sms_control
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe, json

from frappe.utils import nowdate, cstr
from frappe import msgprint, throw, _


from frappe.model.document import Document

class SMSControl(Document):

	def validate_receiver_nos(self,receiver_list):
		validated_receiver_list = []
		for d in receiver_list:
			# remove invalid character
			invalid_char_list = [' ', '+', '-', '(', ')']
			for x in invalid_char_list:
				d = d.replace(x, '')

			validated_receiver_list.append(d)

		if not validated_receiver_list:
			throw(_("Please enter valid mobile nos"))

		return validated_receiver_list


	def get_sender_name(self):
		"returns name as SMS sender"
		sender_name = frappe.db.get_value('Global Defaults', None, 'sms_sender_name') or \
			'ERPNXT'
		if len(sender_name) > 6 and \
				frappe.db.get_default("country") == "India":
			throw("""As per TRAI rule, sender name must be exactly 6 characters.
				Kindly change sender name in Setup --> Global Defaults.
				Note: Hyphen, space, numeric digit, special characters are not allowed.""")
		return sender_name

	def get_contact_number(self, arg):
		"returns mobile number of the contact"
		args = json.loads(arg)
		number = frappe.db.sql("""select mobile_no, phone from tabContact where name=%s and %s=%s""" %
			('%s', args['key'], '%s'), (args['contact_name'], args['value']))
		return number and (number[0][0] or number[0][1]) or ''

	def send_form_sms(self, arg):
		"called from client side"
		args = json.loads(arg)
		self.send_sms([cstr(args['number'])], cstr(args['message']))

	def send_sms(self, receiver_list, msg, sender_name = ''):
		receiver_list = self.validate_receiver_nos(receiver_list)

		arg = {
			'receiver_list' : receiver_list,
			'message'		: msg,
			'sender_name'	: sender_name or self.get_sender_name()
		}

		if frappe.db.get_value('SMS Settings', None, 'sms_gateway_url'):
			ret = self.send_via_gateway(arg)
			msgprint(ret)

	def send_via_gateway(self, arg):
		ss = frappe.get_doc('SMS Settings', 'SMS Settings')
		args = {ss.message_parameter : arg.get('message')}
		for d in ss.get("static_parameter_details"):
			args[d.parameter] = d.value

		resp = []
		for d in arg.get('receiver_list'):
			args[ss.receiver_parameter] = d
			resp.append(self.send_request(ss.sms_gateway_url, args))

		return resp

	# Send Request
	# =========================================================
	def send_request(self, gateway_url, args):
		import httplib, urllib
		server, api_url = self.scrub_gateway_url(gateway_url)
		conn = httplib.HTTPConnection(server)  # open connection
		headers = {}
		headers['Accept'] = "text/plain, text/html, */*"
		conn.request('GET', api_url + urllib.urlencode(args), headers = headers)    # send request
		resp = conn.getresponse()     # get response
		resp = resp.read()
		return resp

	# Split gateway url to server and api url
	# =========================================================
	def scrub_gateway_url(self, url):
		url = url.replace('http://', '').strip().split('/')
		server = url.pop(0)
		api_url = '/' + '/'.join(url)
		if not api_url.endswith('?'):
			api_url += '?'
		return server, api_url


	# Create SMS Log
	# =========================================================
	def create_sms_log(self, arg, sent_sms):
		sl = frappe.get_doc('SMS Log')
		sl.sender_name = arg['sender_name']
		sl.sent_on = nowdate()
		sl.receiver_list = cstr(arg['receiver_list'])
		sl.message = arg['message']
		sl.no_of_requested_sms = len(arg['receiver_list'])
		sl.no_of_sent_sms = sent_sms
		sl.save()

########NEW FILE########
__FILENAME__ = sms_log
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.model.document import Document

class SMSLog(Document):
	pass

########NEW FILE########
__FILENAME__ = repost_stock
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe

from frappe.utils import flt, cstr, nowdate, nowtime
from erpnext.stock.utils import update_bin
from erpnext.stock.stock_ledger import update_entries_after
from erpnext.accounts.utils import get_fiscal_year

def repost(allow_negative_stock=False):
	"""
	Repost everything!
	"""
	frappe.db.auto_commit_on_many_writes = 1

	if allow_negative_stock:
		frappe.db.set_default("allow_negative_stock", 1)

	for d in frappe.db.sql("""select distinct item_code, warehouse from
		(select item_code, warehouse from tabBin
		union
		select item_code, warehouse from `tabStock Ledger Entry`) a"""):
			repost_stock(d[0], d[1], allow_negative_stock)

	if allow_negative_stock:
		frappe.db.set_default("allow_negative_stock",
			frappe.db.get_value("Stock Settings", None, "allow_negative_stock"))
	frappe.db.auto_commit_on_many_writes = 0

def repost_stock(item_code, warehouse):
	repost_actual_qty(item_code, warehouse)

	if item_code and warehouse:
		update_bin(item_code, warehouse, {
			"reserved_qty": get_reserved_qty(item_code, warehouse),
			"indented_qty": get_indented_qty(item_code, warehouse),
			"ordered_qty": get_ordered_qty(item_code, warehouse),
			"planned_qty": get_planned_qty(item_code, warehouse)
		})

def repost_actual_qty(item_code, warehouse):
	try:
		update_entries_after({ "item_code": item_code, "warehouse": warehouse })
	except:
		pass

def get_reserved_qty(item_code, warehouse):
	reserved_qty = frappe.db.sql("""
		select
			sum((dnpi_qty / so_item_qty) * (so_item_qty - so_item_delivered_qty))
		from
			(
				(select
					qty as dnpi_qty,
					(
						select qty from `tabSales Order Item`
						where name = dnpi.parent_detail_docname
					) as so_item_qty,
					(
						select ifnull(delivered_qty, 0) from `tabSales Order Item`
						where name = dnpi.parent_detail_docname
					) as so_item_delivered_qty,
					parent, name
				from
				(
					select qty, parent_detail_docname, parent, name
					from `tabPacked Item` dnpi_in
					where item_code = %s and warehouse = %s
					and parenttype="Sales Order"
				and item_code != parent_item
					and exists (select * from `tabSales Order` so
					where name = dnpi_in.parent and docstatus = 1 and status != 'Stopped')
				) dnpi)
			union
				(select qty as dnpi_qty, qty as so_item_qty,
					ifnull(delivered_qty, 0) as so_item_delivered_qty, parent, name
				from `tabSales Order Item` so_item
				where item_code = %s and reserved_warehouse = %s
				and exists(select * from `tabSales Order` so
					where so.name = so_item.parent and so.docstatus = 1
					and so.status != 'Stopped'))
			) tab
		where
			so_item_qty >= so_item_delivered_qty
	""", (item_code, warehouse, item_code, warehouse))

	return flt(reserved_qty[0][0]) if reserved_qty else 0

def get_indented_qty(item_code, warehouse):
	indented_qty = frappe.db.sql("""select sum(pr_item.qty - ifnull(pr_item.ordered_qty, 0))
		from `tabMaterial Request Item` pr_item, `tabMaterial Request` pr
		where pr_item.item_code=%s and pr_item.warehouse=%s
		and pr_item.qty > ifnull(pr_item.ordered_qty, 0) and pr_item.parent=pr.name
		and pr.status!='Stopped' and pr.docstatus=1""", (item_code, warehouse))

	return flt(indented_qty[0][0]) if indented_qty else 0

def get_ordered_qty(item_code, warehouse):
	ordered_qty = frappe.db.sql("""
		select sum((po_item.qty - ifnull(po_item.received_qty, 0))*po_item.conversion_factor)
		from `tabPurchase Order Item` po_item, `tabPurchase Order` po
		where po_item.item_code=%s and po_item.warehouse=%s
		and po_item.qty > ifnull(po_item.received_qty, 0) and po_item.parent=po.name
		and po.status!='Stopped' and po.docstatus=1""", (item_code, warehouse))

	return flt(ordered_qty[0][0]) if ordered_qty else 0

def get_planned_qty(item_code, warehouse):
	planned_qty = frappe.db.sql("""
		select sum(ifnull(qty, 0) - ifnull(produced_qty, 0)) from `tabProduction Order`
		where production_item = %s and fg_warehouse = %s and status != "Stopped"
		and docstatus=1 and ifnull(qty, 0) > ifnull(produced_qty, 0)""", (item_code, warehouse))

	return flt(planned_qty[0][0]) if planned_qty else 0


def update_bin(item_code, warehouse, qty_dict=None):
	from erpnext.stock.utils import get_bin
	bin = get_bin(item_code, warehouse)
	mismatch = False
	for fld, val in qty_dict.items():
		if flt(bin.get(fld)) != flt(val):
			bin.set(fld, flt(val))
			mismatch = True

	if mismatch:
		bin.projected_qty = flt(bin.actual_qty) + flt(bin.ordered_qty) + \
			flt(bin.indented_qty) + flt(bin.planned_qty) - flt(bin.reserved_qty)

		bin.save()

def set_stock_balance_as_per_serial_no(item_code=None, posting_date=None, posting_time=None,
	 	fiscal_year=None):
	if not posting_date: posting_date = nowdate()
	if not posting_time: posting_time = nowtime()
	if not fiscal_year: fiscal_year = get_fiscal_year(posting_date)[0]

	condition = " and item.name='%s'" % item_code.replace("'", "\'") if item_code else ""

	bin = frappe.db.sql("""select bin.item_code, bin.warehouse, bin.actual_qty, item.stock_uom
		from `tabBin` bin, tabItem item
		where bin.item_code = item.name and item.has_serial_no = 'Yes' %s""" % condition)

	for d in bin:
		serial_nos = frappe.db.sql("""select count(name) from `tabSerial No`
			where item_code=%s and warehouse=%s and status = 'Available' and docstatus < 2""", (d[0], d[1]))

		if serial_nos and flt(serial_nos[0][0]) != flt(d[2]):
			print d[0], d[1], d[2], serial_nos[0][0]

		sle = frappe.db.sql("""select valuation_rate, company from `tabStock Ledger Entry`
			where item_code = %s and warehouse = %s and ifnull(is_cancelled, 'No') = 'No'
			order by posting_date desc limit 1""", (d[0], d[1]))

		sle_dict = {
			'doctype'					: 'Stock Ledger Entry',
			'item_code'					: d[0],
			'warehouse'					: d[1],
			'transaction_date'	 		: nowdate(),
			'posting_date'				: posting_date,
			'posting_time'			 	: posting_time,
			'voucher_type'			 	: 'Stock Reconciliation (Manual)',
			'voucher_no'				: '',
			'voucher_detail_no'			: '',
			'actual_qty'				: flt(serial_nos[0][0]) - flt(d[2]),
			'stock_uom'					: d[3],
			'incoming_rate'				: sle and flt(serial_nos[0][0]) > flt(d[2]) and flt(sle[0][0]) or 0,
			'company'					: sle and cstr(sle[0][1]) or 0,
			'fiscal_year'				: fiscal_year,
			'is_cancelled'			 	: 'No',
			'batch_no'					: '',
			'serial_no'					: ''
		}

		sle_doc = frappe.get_doc(sle_dict)
		sle_doc.insert()

		args = sle_dict.copy()
		args.update({
			"sle_id": sle_doc.name,
			"is_amended": 'No'
		})

		update_bin(args)
		update_entries_after({
			"item_code": d[0],
			"warehouse": d[1],
			"posting_date": posting_date,
			"posting_time": posting_time
		})

########NEW FILE########
__FILENAME__ = transaction_base
# Copyright (c) 2013, Web Notes Technologies Pvt. Ltd. and Contributors
# License: GNU General Public License v3. See license.txt

from __future__ import unicode_literals
import frappe
from frappe import _
from frappe.utils import cstr, now_datetime, cint

from erpnext.controllers.status_updater import StatusUpdater


class TransactionBase(StatusUpdater):
	def load_notification_message(self):
		dt = self.doctype.lower().replace(" ", "_")
		if int(frappe.db.get_value("Notification Control", None, dt) or 0):
			self.set("__notification_message",
				frappe.db.get_value("Notification Control", None, dt + "_message"))

	def validate_posting_time(self):
		if not self.posting_time:
			self.posting_time = now_datetime().strftime('%H:%M:%S')

	def add_calendar_event(self, opts, force=False):
		if self.contact_by != cstr(self._prev.contact_by) or \
				self.contact_date != cstr(self._prev.contact_date) or force:

			self.delete_events()
			self._add_calendar_event(opts)

	def delete_events(self):
		frappe.delete_doc("Event", frappe.db.sql_list("""select name from `tabEvent`
			where ref_type=%s and ref_name=%s""", (self.doctype, self.name)),
			ignore_permissions=True)

	def _add_calendar_event(self, opts):
		opts = frappe._dict(opts)

		if self.contact_date:
			event_doclist = frappe.get_doc({
				"doctype": "Event",
				"owner": opts.owner or self.owner,
				"subject": opts.subject,
				"description": opts.description,
				"starts_on": self.contact_date + " 10:00:00",
				"event_type": "Private",
				"ref_type": self.doctype,
				"ref_name": self.name
			})

			if frappe.db.exists("User", self.contact_by):
				event_doclist.append("event_individuals", {
					"doctype": "Event User",
					"person": self.contact_by
				})

			event_doclist.insert(ignore_permissions=True)

	def validate_uom_is_integer(self, uom_field, qty_fields):
		validate_uom_is_integer(self, uom_field, qty_fields)

	def validate_with_previous_doc(self, source_dt, ref):
		for key, val in ref.items():
			is_child = val.get("is_child_table")
			ref_doc = {}
			item_ref_dn = []
			for d in self.get_all_children(source_dt):
				ref_dn = d.get(val["ref_dn_field"])
				if ref_dn:
					if is_child:
						self.compare_values({key: [ref_dn]}, val["compare_fields"], d)
						if ref_dn not in item_ref_dn:
							item_ref_dn.append(ref_dn)
						elif not val.get("allow_duplicate_prev_row_id"):
							frappe.throw(_("Duplicate row {0} with same {1}").format(d.idx, key))
					elif ref_dn:
						ref_doc.setdefault(key, [])
						if ref_dn not in ref_doc[key]:
							ref_doc[key].append(ref_dn)
			if ref_doc:
				self.compare_values(ref_doc, val["compare_fields"])

	def compare_values(self, ref_doc, fields, doc=None):
		for ref_doctype, ref_dn_list in ref_doc.items():
			for ref_docname in ref_dn_list:
				prevdoc_values = frappe.db.get_value(ref_doctype, ref_docname,
					[d[0] for d in fields], as_dict=1)

				for field, condition in fields:
					if prevdoc_values[field] is not None:
						self.validate_value(field, condition, prevdoc_values[field], doc)

def delete_events(ref_type, ref_name):
	frappe.delete_doc("Event", frappe.db.sql_list("""select name from `tabEvent`
		where ref_type=%s and ref_name=%s""", (ref_type, ref_name)), for_reload=True)

class UOMMustBeIntegerError(frappe.ValidationError): pass

def validate_uom_is_integer(doc, uom_field, qty_fields):
	if isinstance(qty_fields, basestring):
		qty_fields = [qty_fields]

	distinct_uoms = list(set([d.get(uom_field) for d in doc.get_all_children()]))
	integer_uoms = filter(lambda uom: frappe.db.get_value("UOM", uom,
		"must_be_whole_number") or None, distinct_uoms)

	if not integer_uoms:
		return

	for d in doc.get_all_children():
		if d.get(uom_field) in integer_uoms:
			for f in qty_fields:
				if d.get(f):
					if cint(d.get(f))!=d.get(f):
						frappe.throw(_("Quantity cannot be a fraction in row {0}").format(d.idx), UOMMustBeIntegerError)

########NEW FILE########
