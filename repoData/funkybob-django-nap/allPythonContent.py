__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-nap documentation build configuration file, created by
# sphinx-quickstart on Thu Nov 28 11:22:05 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-nap'
copyright = u'2013, Curtis Maloney'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.13'
# The full version, including alpha/beta/rc tags.
release = '0.13.6'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-napdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-nap.tex', u'django-nap Documentation',
   u'Curtis Maloney', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-nap', u'django-nap Documentation',
     [u'Curtis Maloney'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'django-nap', u'django-nap Documentation',
   u'Curtis Maloney', 'django-nap', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'django-nap'
epub_author = u'Curtis Maloney'
epub_publisher = u'Curtis Maloney'
epub_copyright = u'2013, Curtis Maloney'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

########NEW FILE########
__FILENAME__ = api
from __future__ import unicode_literals

from django.conf.urls import url, include
from django.core.urlresolvers import reverse

from . import http


class Api(object):
    '''Helper class for registering many Publishers in one URL namespace'''
    def __init__(self, name, show_index=True):
        self.name = name
        self.children = {}
        self.show_index = show_index

    def patterns(self, flat=False):
        urlpatterns = [
            url(r'^$', self.index),
        ] + [
            url(r'^%s/' % name, include(child.patterns(self.name)))
            for name, child in self.children.items()
        ]
        if flat:
            return urlpatterns
        return [
            url(r'^%s/' % self.name, include(urlpatterns)),
        ]

    def index(self, request, *args, **kwargs):
        '''Return a dict of publisher name: url'''
        if not self.show_index:
            return http.NotFound()
        return http.JsonResponse(dict(
            (name, {
                'path': reverse(
                    '%s_%s_list_default' % (self.name, name),
                    kwargs=kwargs
                ),
                'methods': child.index(),
            })
            for name, child in self.children.items()
        ))

    def register(self, child, name=None):
        if name is None:
            name = getattr(child, 'api_name', child.__name__.lower())
        if name in self.children:
            raise Warning(
                'Publisher with name "%s" already registered: %r -> %r' % (
                    name, self.children[name], child
                )
            )
        self.children[name] = child

APIS = {}


def register(name, *args):
    if not args:
        # We've been called as a decorator
        def wrapper(cls, name=name):
            register(name, cls)
            return cls
        return wrapper
    try:
        api = APIS[name]
    except KeyError:
        api = APIS[name] = Api(name=name)
    for resource in args:
        api.register(resource)
    return api


def autodiscover():
    from django.conf import settings
    from django.utils.importlib import import_module
    from django.utils.module_loading import module_has_submodule

    for app in settings.INSTALLED_APPS:
        mod = import_module(app)
        # Attempt to import the app's api module.
        try:
            import_module('%s.publishers' % app)
        except:

            # Decide whether to bubble up this error. If the app just
            # doesn't have an admin module, we can ignore the error
            # attempting to import it, otherwise we want it to bubble up.
            if module_has_submodule(mod, 'publishers'):
                raise


def patterns(flat=False):
    urlpatterns = []
    for api in APIS.values():
        urlpatterns.extend(api.patterns(flat=flat))
    return urlpatterns

########NEW FILE########
__FILENAME__ = apps

from django.apps import AppConfig

from django.utils.module_loading import autodiscover_modules


class NapConfig(AppConfig):
    '''App Config that performs auto-discover on ready.'''

    def ready(self):
        super(NapConfig, self).ready()
        autodiscover_modules('publishers')

########NEW FILE########
__FILENAME__ = auth
from __future__ import unicode_literals

# Authentication and Authorisation
from functools import wraps
from . import http


def permit(test_func):
    '''Decorate a handler to control access'''
    def decorator(view_func):
        @wraps(view_func)
        def _wrapped_view(self, *args, **kwargs):
            if test_func(self, *args, **kwargs):
                return view_func(self, *args, **kwargs)
            return http.Forbidden()
        return _wrapped_view
    return decorator

permit_logged_in = permit(
    lambda self, *args, **kwargs: self.request.user.is_authenticated()
)

permit_staff = permit(
    lambda self, *args, **kwargs: self.request.user.is_staff
)


def permit_groups(*groups):
    def in_groups(request, *args):
        return request.user.groups.filter(name__in=groups).exists()
    return permit(
        lambda self, *args, **kwargs: in_groups(self.request, *groups)
    )

########NEW FILE########
__FILENAME__ = cache
from __future__ import unicode_literals

from django.core.cache import get_cache, cache as default_cache
from six import string_types


class CachedSerialiser(object):
    '''Mixin to cache per-object serialised data'''
    def __init__(self, *args, **kwargs):
        cache = getattr(self._meta, 'cache', default_cache)
        if isinstance(cache, string_types):
            cache = get_cache(cache)
        self._meta.cache = cache

    def object_deflate(self, obj, **kwargs):
        '''Add object caching'''
        # This currently assumes obj is a Model instance
        cache_key = 'api_%s_%d' % (self.__class__.__name__, obj.pk)
        data = self._meta.cache.get(cache_key)
        if data is None:
            data = super(CachedSerialiser, self).object_deflate(obj, **kwargs)
            timeout = getattr(self._meta, 'timeout', None)
            self._meta.cache.set(data, timeout=timeout)
        return data

########NEW FILE########
__FILENAME__ = exceptions

class ValidationError(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):  # pragma: no cover
        return 'ValidationError: %s' % self.message


class ValidationErrors(Exception):
    '''A container for a dict of validation errors.'''
    def __init__(self, errors):
        self.errors = errors

    def __str__(self):
        return 'ValidationErrors: %s' % (
            '\n'.join('%s: %s' % (
                (key, map(str, value))
                for key, value in self.errors.items()
            )),
        )

########NEW FILE########
__FILENAME__ = actions

from django.http import StreamingHttpResponse
from django.utils.encoding import force_text

from nap.models import modelserialiser_factory
from .simplecsv import Writer


class ExportCsv(object):
    '''
    A factory class for Admin Actions to export a model as CSV.

    actions = [ ExportCsv(myserialiser, 'Export as CSV'), ]

    Optionally, you can pass kwargs to be passed to modelserialiser_factory to
    create a ModelSerialiser.
    '''
    def __init__(self, serialiser=None, label=None, **opts):
        self.serialiser = serialiser
        self.opts = opts
        if label:
            self.short_description = label
        self.__name__ = label or 'ExportCsv'

    def __call__(self, admin, request, queryset):
        if self.serialiser is None:
            ser_class = modelserialiser_factory(
                '%sSerialiser' % admin.__class__.__name__,
                admin.model,
                **self.opts
            )
        else:
            ser_class = self.serialiser

        select_related = self.opts.get('select_related', None)
        if select_related:
            queryset = queryset.select_related(*select_related)
        prefetch_related = self.opts.get('prefetch_related', None)
        if prefetch_related:
            queryset = queryset.prefetch_related(*prefetch_related)

        def inner(ser):
            csv = Writer(fields=self.opts.get('fields', ser._fields.keys()))
            yield csv.write_headers()
            for obj in queryset:
                data = { 
                    key: force_text(val)
                    for key, val in ser.object_deflate(obj).items()
                }
                yield csv.write_dict(data)

        response = StreamingHttpResponse(inner(ser_class()), content_type='text/csv')
        filename = self.opts.get('filename', 'export_{classname}.csv')
        if callable(filename):
            filename = filename(admin)
        else:
            filename = filename.format(
                classname=admin.__class__.__name__,
                model=admin.model._meta.module_name,
                app_label=admin.model._meta.app_label,
            )
        response['Content-Disposition'] = 'attachment; filename=%s' % filename

        return response

########NEW FILE########
__FILENAME__ = simplecsv

class Writer(object):
    '''
    A generator friendly, unicode aware CSV encoder class built for speed.
    '''

    # What to put between fields
    SEP = u','
    # What to wrap fields in, if they contain SEP
    QUOTE = u'"'
    # What to replace a QUOTE in a field with
    ESCQUOTE = QUOTE + QUOTE
    # What to put between records
    LINEBREAK = u'\n'
    ENCODING = 'utf-8'

    fields = []

    def __init__(self, **opts):
        '''
        opts MUST contain 'fields', a list of field names.
        opts may also include 'headers', a list of field headings.
        opts MAY override any of the above configurables.
        '''
        self.__dict__.update(opts)

    def write(self, values):
        '''Write a row of values'''
        def escape_field(val, SEP=self.SEP, QUOTE=self.QUOTE, ESCQ=self.ESCQUOTE):
            '''
            Escape separator and quote values, and wrap with quotes if needed

            Inlined for speed
            '''
            # escape quotes in the value
            val = val.replace(QUOTE, ESCQ)
            # if needed, wrap quotes around value
            if SEP in val or QUOTE in val:
                return QUOTE + val + QUOTE
            return val

        line = self.SEP.join(map(escape_field, values)) + self.LINEBREAK
        if self.ENCODING:
            line = line.encode(self.ENCODING)
        return line

    def write_dict(self, values):
        '''Write a row, getting values from a dict.'''
        return self.write(map(values.get, self.fields))

    def write_headers(self):
        '''Write a row of headers.'''
        return self.write(getattr(self, 'headers', self.fields))

########NEW FILE########
__FILENAME__ = fields
from __future__ import unicode_literals

from .exceptions import ValidationError
from .utils import digattr

from decimal import Decimal
from datetime import datetime

try:
    from django.utils.encoding import force_text
except ImportError:
    # For Django1.4
    from django.utils.encoding import force_unicode as force_text


class NoDefault(object):
    '''Indicates no default value was provided.'''


class Field(object):
    type_class = None

    def __init__(self, attribute=None, default=NoDefault, readonly=False,
                 null=True, virtual=False, **kwargs):
        self.attribute = attribute
        self.default = default
        self.readonly = readonly
        self.null = null
        self.virtual = virtual
        self.kwargs = kwargs

    def _get_attrname(self, name):
        return self.attribute if self.attribute else name

    def reduce(self, value, **kwargs):
        return value

    def restore(self, value, **kwargs):
        if self.type_class is not None:
            return self.type_class(value)
        return value

    def deflate(self, name, obj, data, **kwargs):
        src = self._get_attrname(name)
        value = digattr(obj, src, self.default)
        if value is NoDefault:
            if self.virtual:
                return
            raise AttributeError('No attribute "%s" found on %r' % (src, obj,))
        if value is not None:
            value = self.reduce(value, **kwargs)
        data[name] = value

    def inflate(self, name, data, obj, **kwargs):
        if self.readonly:
            return
        dest = self._get_attrname(name)
        try:
            value = data[name]
        except KeyError:
            if self.default is not NoDefault and 'instance' not in kwargs:
                obj[dest] = self.default
            return

        if value is not None:
            try:
                value = self.restore(value, **kwargs)
            except ValueError:
                raise ValidationError(
                    "Field '%s' (%r) received invalid value: %r" % (
                        name, self.__class__.__name__, value
                        )
                )
        elif not self.null:
            raise ValidationError("Field '%s' must not be None." % name)

        obj[dest] = value


class BooleanField(Field):
    type_class = bool


class IntegerField(Field):
    type_class = int


class DecimalField(Field):
    type_class = Decimal

    def reduce(self, value, **kwargs):
        return float(value)


class DateTimeField(Field):

    def reduce(self, value, **kwargs):
        return value.replace(microsecond=0).isoformat(str(' '))

    def restore(self, value, **kwargs):
        return datetime.strptime(value, '%Y-%m-%d %H:%M:%S')


class DateField(Field):

    def reduce(self, value, **kwargs):
        return value.isoformat()

    def restore(self, value, **kwargs):
        return datetime.strptime(value, '%Y-%m-%d').date()


class TimeField(Field):

    def reduce(self, value, **kwargs):
        return value.isoformat()

    def restore(self, value, **kwargs):
        return datetime.strptime(value, '%H:%M:%S').time()


class SerialiserField(Field):

    def __init__(self, *args, **kwargs):
        super(SerialiserField, self).__init__(*args, **kwargs)
        self.serialiser = kwargs['serialiser']

    def reduce(self, value, **kwargs):
        return self.serialiser.object_deflate(value, **kwargs)

    def restore(self, value, **kwargs):
        return self.serialiser.object_inflate(value, **kwargs)


class ManySerialiserField(Field):

    def __init__(self, *args, **kwargs):
        super(ManySerialiserField, self).__init__(*args, **kwargs)
        self.serialiser = kwargs['serialiser']

    def reduce(self, value, **kwargs):
        return self.serialiser.list_deflate(iter(value), **kwargs)

    def restore(self, value, **kwargs):
        return self.serialiser.list_inflate(value, **kwargs)


class FileField(Field):

    def reduce(self, value, **kwargs):
        return value.url

    def restore(self, value, **kwargs):
        pass


class StringField(Field):
    '''
    Like Field, but always casts value to a text type.

    Since it can't know what type to restore to, it is set readonly by
    default.  If you want it to be writable, you must clear this flag and
    provide a custom inflater.
    '''
    def __init__(self, *args, **kwargs):
        kwargs.setdefault('readonly', True)
        super(StringField, self).__init__(*args, **kwargs)

    def reduce(self, value, **kwargs):
        return force_text(value)

########NEW FILE########
__FILENAME__ = http
from __future__ import unicode_literals

'''Add some missing HttpResponse sub-classes'''
from django.core.exceptions import SuspiciousOperation
from django.http import HttpResponse, Http404
from django.utils.encoding import iri_to_uri

try:
    from urlparse import urlparse
except ImportError:
    from urllib.parse import urlparse
try:
    from collections import OrderedDict
except ImportError:
    from ordereddict import OrderedDict

import json
import re

STATUS_CODES = (
    (100, 'Continue'),
    (101, 'Switching Protocols'),

    (200, 'OK'),
    (201, 'Created'),
    (202, 'Accepted'),
    # (203, Non-Authoritative Information),
    (204, 'No Content'),
    (205, 'Reset Content'),
    (206, 'Partial Content'),

    (300, 'Multiple Choices'),
    (301, 'Moved Permanently'),
    (302, 'Found'),
    (303, 'See Other'),
    (304, 'Not Modified'),
    (305, 'Use Proxy'),
    # 306 Deprecated
    (307, 'Temporary Redirect'),
    (308, 'Permanent Redirect'),

    (400, 'Bad Request'),
    (401, 'Unauthorized'),
    (402, 'Payment Required'),
    (403, 'Forbidden'),
    (404, 'Not Found'),
    (405, 'Method Not Allowed'),
    (406, 'Not Acceptable'),
    (407, 'Proxy Authentication Required'),
    (408, 'Request Timeout'),
    (409, 'Conflict'),
    (410, 'Gone'),
    (411, 'Length Required'),
    (412, 'Precondition Failed'),
    (413, 'Request Entity Too Large'),
    (414, 'Request-URI Too Long'),
    (415, 'Unsupported Media Type'),
    (416, 'Requested Range Not Satisfiable'),
    (417, 'Expectation Failed'),

    (500, 'Internal Server Error'),
    (501, 'Not Implemented'),
    (502, 'Bad Gateway'),
    (503, 'Service Unavailable'),
    (504, 'Gateway Timeout'),
    (505, 'HTTP Version Not Supported'),
)

STATUS = OrderedDict(STATUS_CODES)
# Set constant-like properties for reverse lookup
for code, label in STATUS_CODES:
    setattr(STATUS, re.sub(r'\W', '_', label.upper()), code)


class BaseHttpResponse(HttpResponse, Exception):
    '''
    A sub-class of HttpResponse that is also an Exception, allowing us to
    raise/catch it.

    With thanks to schinkel's repose.
    '''

#
# Success Responses (2xx)
#


class HttpResponseSuccess(BaseHttpResponse):
    '''A base class for all 2xx responses, so we can issubclass test.'''


class OK(HttpResponseSuccess):
    status_code = STATUS.OK


class Created(HttpResponseSuccess):
    status_code = STATUS.CREATED


class Accepted(HttpResponseSuccess):
    status_code = STATUS.ACCEPTED


class NoContent(HttpResponseSuccess):
    status_code = STATUS.NO_CONTENT


class ResetContent(HttpResponseSuccess):
    status_code = STATUS.RESET_CONTENT


class PartialContent(HttpResponseSuccess):
    status_code = STATUS.PARTIAL_CONTENT

#
# Redirection Responses (3xx)
#


class HttpResponseRedirection(BaseHttpResponse):
    '''A base class for all 3xx responses.'''


class LocationHeaderMixin(object):
    '''Many 3xx responses require a Location header'''
    def __init__(self, location, *args, **kwargs):
        super(LocationHeaderMixin, self).__init__(*args, **kwargs)
        parsed = urlparse(location)
        if parsed.scheme and parsed.scheme not in self.allowed_schemes:
            raise SuspiciousOperation(
                "Unsafe redirect to URL with protocol '%s'" % parsed.scheme
            )
        self['Location'] = iri_to_uri(location)

    url = property(lambda self: self['Location'])


class MultipleChoices(HttpResponseRedirection):
    status_code = STATUS.MULTIPLE_CHOICES


class MovedPermanently(LocationHeaderMixin, HttpResponseRedirection):
    status_code = STATUS.MOVED_PERMANENTLY


class Found(LocationHeaderMixin, HttpResponseRedirection):
    status_code = STATUS.FOUND


class SeeOther(LocationHeaderMixin, HttpResponseRedirection):
    status_code = STATUS.SEE_OTHER


class NotModified(HttpResponseRedirection):
    status_code = STATUS.NOT_MODIFIED


class UseProxy(LocationHeaderMixin, HttpResponseRedirection):
    status_code = STATUS.USE_PROXY


class TemporaryRedirect(HttpResponseRedirection):
    status_code = STATUS.TEMPORARY_REDIRECT


class PermanentRedirect(HttpResponseRedirection):
    status_code = STATUS.PERMANENT_REDIRECT

#
# Client Error Responses (4xx)
#


class HttpResponseError(BaseHttpResponse):
    '''A base class for all 4xx responses.'''


class BadRequest(HttpResponseError):
    status_code = STATUS.BAD_REQUEST

# XXX Auth-Realm ?
class Unauthorized(HttpResponseError):
    status_code = STATUS.UNAUTHORIZED


class PaymentRequired(HttpResponseError):
    status_code = STATUS.PAYMENT_REQUIRED


class Forbidden(HttpResponseError):
    status_code = STATUS.FORBIDDEN


class NotFound(HttpResponseError):
    status_code = STATUS.NOT_FOUND


class MethodNotAllowed(HttpResponseError):
    def __init__(self, permitted_methods, *args, **kwargs):
        super(MethodNotAllowed, self).__init__(*args, **kwargs)
        self['Allow'] = ', '.join(permitted_methods)

    status_code = STATUS.METHOD_NOT_ALLOWED


class NotAcceptable(HttpResponseError):
    status_code = STATUS.NOT_ACCEPTABLE


class ProxyAuthenticationRequired(HttpResponseError):
    status_code = STATUS.PROXY_AUTHENTICATION_REQUIRED


class RequestTimeout(HttpResponseError):
    status_code = STATUS.REQUEST_TIMEOUT


class Conflict(HttpResponseError):
    status_code = STATUS.CONFLICT


class Gone(HttpResponseError):
    status_code = STATUS.GONE


class LengthRequired(HttpResponseError):
    status_code = STATUS.LENGTH_REQUIRED


class PreconditionFailed(HttpResponseError):
    status_code = STATUS.PRECONDITION_FAILED


class RequestEntityTooLarge(HttpResponseError):
    status_code = STATUS.REQUEST_ENTITY_TOO_LARGE


class RequestURITooLong(HttpResponseError):
    status_code = STATUS.REQUEST_URI_TOO_LONG


class UnsupportedMediaType(HttpResponseError):
    status_code = STATUS.UNSUPPORTED_MEDIA_TYPE


class RequestedRangeNotSatisfiable(HttpResponseError):
    status_code = STATUS.REQUESTED_RANGE_NOT_SATISFIABLE


class ExpectationFailed(HttpResponseError):
    status_code = STATUS.EXPECTATION_FAILED

#
# Server Error (5xx)
#


class HttpResponseServerError(BaseHttpResponse):
    '''A base class for 5xx responses.'''


class InternalServerError(HttpResponseServerError):
    status_code = STATUS.INTERNAL_SERVER_ERROR


class NotImplemented(HttpResponseServerError):
    status_code = STATUS.NOT_IMPLEMENTED


class BadGateway(HttpResponseServerError):
    status_code = STATUS.BAD_GATEWAY


class ServiceUnavailable(HttpResponseServerError):
    status_code = STATUS.SERVICE_UNAVAILABLE


class GatewayTimeout(HttpResponseServerError):
    status_code = STATUS.GATEWAY_TIMEOUT


class HttpVersiontNotSupported(HttpResponseServerError):
    status_code = STATUS.HTTP_VERSION_NOT_SUPPORTED

#
# General Helpers
#


class JsonResponse(HttpResponse):
    '''Handy shortcut for dumping JSON data'''
    def __init__(self, content, *args, **kwargs):
        kwargs.setdefault('content_type', 'application/json')
        super(JsonResponse, self).__init__(json.dumps(content), *args, **kwargs)

########NEW FILE########
__FILENAME__ = meta
from __future__ import unicode_literals

from six import with_metaclass


class DeclarativeMetaclass(type):
    '''
    Mangle a class so any properties defined on it are stashed in _defaults
    '''
    def __new__(mcs, name, bases, attrs):
        defaults = {
            key: attrs.pop(key)
            for key in list(attrs.keys())
            if not key.startswith('_')
        }
        new_class = super(DeclarativeMetaclass, mcs).__new__(mcs, name, bases,
            attrs)
        new_class._defaults = defaults
        return new_class


class Meta(with_metaclass(DeclarativeMetaclass, object)):
    '''Generic container for Meta classes'''

    def __init__(self, meta):
        ''' Copy value values onto ourself '''
        for key in dir(meta):
            if key.startswith('_'):
                continue
            if key not in self._defaults:
                raise ValueError('Property "%s" not supported by %s' % (key, self.__class__.__name__))
        for key, value in self._defaults.items():
            setattr(self, key, getattr(meta, key, value))

########NEW FILE########
__FILENAME__ = models
from __future__ import unicode_literals

from . import fields, http
from .meta import Meta
from .publisher import Publisher
from .serialiser import MetaSerialiser, Serialiser

from six import with_metaclass

from django.db.models import Manager
from django.db.models.fields import NOT_PROVIDED
from django.db import transaction
from django.shortcuts import get_object_or_404

FIELD_MAP = {}
# Auto-construct the field map
for f in dir(fields):
    cls = getattr(fields, f)
    try:
        if issubclass(cls, fields.Field):
            FIELD_MAP[f] = cls
    except TypeError:
        pass


class ModelMeta(Meta):
    model = None
    # Fields to include from the Model
    fields = []
    field_types = {}
    # Fields to exclude from the Model
    exclude = []
    # Fields from the model to flag as read-only
    read_only_fields = []

    # When restoring an object, which fields do we treat as m2m?
    related_fields = []
    # When we try to retrieve an instance, which fields do we use?
    key_fields = ('id',)
    # When restoring an object, which attrs do we not use
    ignored_fields = ()
    # When calling get_or_create, what do we pass as defaults?
    defaults = {}
    # Are there any deserialised fields we must pass to get_or_create defaults?
    core_fields = ()


class MetaModelSerialiser(MetaSerialiser):
    meta_class = ModelMeta

    def __new__(mcs, name, bases, attrs):

        new_class = super(MetaModelSerialiser, mcs).__new__(mcs, name, bases, attrs)

        include = getattr(new_class._meta, 'fields', [])
        exclude = getattr(new_class._meta, 'exclude', [])
        read_only = getattr(new_class._meta, 'read_only_fields', [])

        current_fields = new_class._fields.keys()

        model_fields = {}
        model = new_class._meta.model
        if model is not None:
            for field in model._meta.fields:
                # If we've got one, skip...
                if field.name in current_fields:
                    continue

                # If we have a whitelist, and it's not in it, skip
                if include and field.name not in include:
                    continue

                # If it's blacklisted, skip
                if field.name in exclude:
                    continue

                kwargs = {
                    'readonly': field.name in read_only,
                    'null': field.null,
                }
                if field.default is not NOT_PROVIDED:
                    kwargs['default'] = field.default

                try:
                    field_class = new_class._meta.field_types[field.name]
                except KeyError:
                    field_class = FIELD_MAP.get(field.__class__.__name__, fields.Field)
                model_fields[field.name] = field_class(**kwargs)

        new_class._fields.update(model_fields)

        return new_class


class ModelSerialiser(with_metaclass(MetaModelSerialiser, Serialiser)):

    def restore_object(self, obj, instance, **kwargs):
        if instance:
            for key, val in obj.items():
                setattr(instance, key, val)
        else:
            instance = self._meta.model(**obj)
        if kwargs.get('commit', True):
            instance.save()
        return instance


class ModelReadSerialiser(ModelSerialiser):
    '''
    A Serialiser that will only Read, not Create, an instance on inflate.

    Specify only the fields you intend to filter by.
    '''

    def restore_object(self, objdata, instance, **kwargs):
        try:
            return self._meta.model.objects.get(**objdata)
        except self._meta.model.DoesNotExist:
            raise fields.ValidationError('%s with values %r does not exist.' % (
                self._meta.model.__name__,
                objdata,
            ))


class ModelCreateUpdateSerialiser(ModelSerialiser):

    '''
    A ModelSerialiser with the ability to create/update instances from data.
    '''

    def restore_object(self, objdata, instance, **kwargs):
        related = {
            key: objdata.pop(key)
            for key in self._meta.related_fields
        }

        if instance is None:
            lookup = {
                field: objdata[field]
                for field in self._meta.key_fields
            }
            defaults = dict(self._meta.defaults)
            for key in self._meta.core_fields:
                defaults[key] = objdata[key]
            instance, _ = self._meta.model.objects.get_or_create(
                defaults=defaults,
                **lookup
            )

        for key, value in objdata.items():
            if key in self._meta.ignored_fields:
                continue
            setattr(instance, key, value)

        instance.save()

        for key, value in related.items():
            getattr(instance, key).add(*value)

        return instance


class ModelPublisher(Publisher):
    '''A Publisher with useful methods to publish Models'''

    @property
    def model(self):
        '''By default, we try to get the model from our serialiser'''
        # XXX Should this call get_serialiser?
        return self.serialiser._meta.model

    # Auto-build serialiser from model class?

    def get_object_list(self):
        return self.model.objects.all()

    def get_object(self, object_id):
        return get_object_or_404(self.get_object_list(), pk=object_id)

    def list_post_default(self, request, **kwargs):
        data = self.get_request_data()

        serialiser = self.get_serialiser()
        serialiser_kwargs = self.get_serialiser_kwargs()
        try:
            with transaction.atomic():
                obj = serialiser.object_inflate(data, **serialiser_kwargs)
        except ValueError as e:
            return http.BadRequest(str(e))
        return self.render_single_object(obj, serialiser)


def modelserialiser_factory(name, model, **kwargs):
    attrs = {
        'model': model,
    }
    for key in ['fields', 'exclude', 'read_only']:
        try:
            attrs[key] = kwargs[key]
        except KeyError:
            pass

    meta = type(str('Meta'), (object,), attrs)
    return type(ModelSerialiser)(str(name), (ModelSerialiser,), {'Meta': meta})


class ModelSerialiserField(fields.SerialiserField):
    def __init__(self, *args, **kwargs):
        if 'serialiser' not in kwargs:
            model = kwargs.pop('model')
            kwargs['serialiser'] = modelserialiser_factory(model.__name__ + 'Serialiser', model, **kwargs)()
        super(ModelSerialiserField, self).__init__(*args, **kwargs)


class ModelManySerialiserField(fields.ManySerialiserField):
    def __init__(self, *args, **kwargs):
        if 'serialiser' not in kwargs:
            model = kwargs.pop('model')
            kwargs['serialiser'] = modelserialiser_factory(model.__name__ + 'Serialiser', model, **kwargs)()
        super(ModelManySerialiserField, self).__init__(*args, **kwargs)

    def reduce(self, value, **kwargs):
        if isinstance(value, Manager):
            value = value.all()
        return super(ModelManySerialiserField, self).reduce(value, **kwargs)

########NEW FILE########
__FILENAME__ = newrelic
from __future__ import absolute_import

# In agent configuration file add:
#
# [import-hook:nap.publisher]
# enabled = true
# execute = nap.newrelic:instrument_django_nap_publisher

from newrelic.agent import (current_transaction, set_transaction_name,
    FunctionTrace, callable_name, ObjectWrapper)


def instrument_django_nap_publisher(module):

    def execute_wrapper(wrapped, instance, args, kwargs):

        transaction = current_transaction()

        if transaction is None:
            return wrapped(*args, **kwargs)

        def _handler(handler, *args, **kwargs):
            return handler

        handler = _handler(*args, **kwargs)

        name = callable_name(handler)

        set_transaction_name(name)

        with FunctionTrace(transaction, name):
            return wrapped(*args, **kwargs)

    module.BasePublisher.execute = ObjectWrapper(
        module.BasePublisher.execute, None, execute_wrapper)

########NEW FILE########
__FILENAME__ = publisher
from __future__ import unicode_literals

from django.conf.urls import url
from django.core.paginator import Paginator, EmptyPage
from django.utils.decorators import method_decorator
from django.views.decorators.http import require_http_methods
from django.views.decorators.csrf import ensure_csrf_cookie, csrf_exempt

from cgi import parse_header
from collections import defaultdict
try:
    import ujson as json
except ImportError:
    import json

from . import http


def accepts(*verbs):
    '''Annotate a method with the HTTP verbs it accepts, and enforce it.'''
    def _inner(method):
        setattr(method, '_accepts', verbs)
        return method_decorator(
            require_http_methods([x.upper() for x in verbs])
        )(method)
    return _inner


class BasePublisher(object):
    CSRF = True

    ACTION_PATTERN = r'\w+'
    OBJECT_PATTERN = r'[-\w]+'
    ARGUMENT_PATTERN = r'.+?'

    def __init__(self, request, *args, **kwargs):
        self.request = request
        self.args = args
        self.kwargs = kwargs

    @classmethod
    def build_view(cls):
        '''Builds the view function for this publisher.'''
        def view(request, *args, **kwargs):
            '''A wrapper view to instantiate and dispatch'''
            self = cls(request, *args, **kwargs)
            return self.dispatch(request, **kwargs)

        if cls.CSRF:
            view = ensure_csrf_cookie(view)
        else:
            view = csrf_exempt(view)
        return view

    @classmethod
    def patterns(cls, api_name=None):
        '''
        Add this to your url patterns like:
            ( '^foo/', include(mypublisher.patterns()), ),
        /                       default object list
        /(action)/              list operation
        /(action)/(option)/     list operation with extra argument
        /object/(id)/           instance view
        /object/(id)/(action)/  custom action on instance
        '''
        view = cls.build_view()

        name = getattr(cls, 'api_name', cls.__name__.lower())
        if api_name:
            name = '%s_%s' % (api_name, name)

        return [
            url(r'^object/(?P<object_id>%s)/(?P<action>%s)/(?P<argument>%s)/?$' % (cls.OBJECT_PATTERN, cls.ACTION_PATTERN, cls.ARGUMENT_PATTERN),
                view,
                name='%s_object_action_arg' % name
            ),
            url(r'^object/(?P<object_id>%s)/(?P<action>%s)/?$' % (cls.OBJECT_PATTERN, cls.ACTION_PATTERN),
                view,
                name='%s_object_action' % name
            ),
            url(r'^object/(?P<object_id>%s)/?$' % (cls.OBJECT_PATTERN,),
                view,
                name='%s_object_default' % name
            ),
            url(r'^(?P<action>%s)/(?P<argument>%s)/?$' % (cls.ACTION_PATTERN, cls.ARGUMENT_PATTERN),
                view,
                name='%s_list_action_arg' % name
            ),
            url(r'^(?P<action>%s)/?$' % (cls.ACTION_PATTERN,),
                view,
                name='%s_list_action' % name
            ),
            url(r'^$',
                view,
                name='%s_list_default' % name
            ),
        ]

    def dispatch(self, request, action='default', object_id=None, **kwargs):
        '''View dispatcher called by Django'''
        self.action = action
        self.object_id = object_id
        method = request.method.lower()
        self.mode = prefix = 'object' if object_id else 'list'
        handler = getattr(self, '%s_%s_%s' % (prefix, method, action), None)
        if handler is None:
            # See if there's a method agnostic handler
            handler = getattr(self, '%s_%s' % (prefix, action), None)
        if handler is None:
            return http.NotFound()
        # Do we need to pass any of this?
        return self.execute(handler)

    def execute(self, handler):
        '''This allows wrapping calls to handler functions'''
        try:
            return handler(self.request,
                action=self.action,
                object_id=self.object_id,
            )
        except http.BaseHttpResponse as response:
            return response

    @classmethod
    def index(cls):
        '''Return details about which handlers exist on this publisher.'''
        list_handlers = defaultdict(list)
        object_handlers = defaultdict(list)
        for name in dir(cls):
            fnc = getattr(cls, name)
            if not callable(fnc):
                continue
            parts = name.split('_')

            if parts[0] == 'list':
                if len(parts) == 2:
                    list_handlers[parts[1]].extend(getattr(fnc, '_accepts', ['ALL']))
                else:
                    list_handlers[parts[2]].append(parts[1])

            elif parts[0] == 'object':
                if len(parts) == 2:
                    object_handlers[parts[1]].extend(getattr(fnc, '_accepts', ['ALL']))
                else:
                    object_handlers[parts[2]].append(parts[1])

        return {
            'list': list_handlers,
            'object': object_handlers,
        }


class SimplePatternsMixin(object):
    '''
    A "flatter" set of url patterns for when your object IDs are numbers only.
    '''

    @classmethod
    def patterns(cls, api_name=None):
        view = cls.build_view()

        name = getattr(cls, 'api_name', cls.__name__.lower())
        if api_name:
            name = '%s_%s' % (api_name, name)

        return [
            url(r'^(?P<object_id>\d+)/(?P<action>\w+)/(?P<argument>.+?)/?$',
                view,
                name='%s_object_action_arg' % name
            ),
            url(r'^(?P<object_id>\d+)/(?P<action>\w+)/?$',
                view,
                name='%s_object_action' % name
            ),
            url(r'^(?P<object_id>\d+)/?$',
                view,
                name='%s_object_default' % name
            ),
            url(r'^(?P<action>\w+)/(?P<argument>.+?)/?$',
                view,
                name='%s_list_action_arg' % name
            ),
            url(r'^(?P<action>\w+)/?$',
                view,
                name='%s_list_action' % name
            ),
            url(r'^$',
                view,
                name='%s_list_default' % name
            ),
        ]


class Publisher(BasePublisher):
    '''Default API-style publisher'''
    LIMIT_PARAM = 'limit'
    OFFSET_PARAM = 'offset'
    PAGE_PARAM = 'page'

    response_class = http.HttpResponse

    # De/Serialising
    # Which content types will we attempt to parse?
    # The first in the list will be used for responses.
    CONTENT_TYPES = ['application/json', 'text/json']

    def dumps(self, data):
        '''How to parse content that matches our content types list.'''
        return json.dumps(data)

    def loads(self, data):
        '''Serialise data for responses.'''
        return json.loads(data)

    # Hooks for controlling which serialiser to use

    def get_serialiser(self):
        '''Return the serialiser instance to use for this request'''
        return self.serialiser

    def get_serialiser_kwargs(self):
        '''Allow passing of extra kwargs to serialiser calls'''
        return {
            'publisher': self,
        }

    # Object access

    def get_object_list(self):  # pragma: no cover
        '''Return the object list appropriate for this request'''
        raise NotImplementedError

    def get_object(self, object_id):  # pragma: no cover
        '''Return the object for the given id'''
        raise NotImplementedError

    # List filtering and sorting

    def filter_object_list(self, object_list):
        '''Hook to allow custom filtering of object lists'''
        return object_list

    def sort_object_list(self, object_list):
        '''Hook to allow custom sorting of object lists'''
        return object_list

    # Pagination
    def get_page(self, object_list):
        '''Return a paginated object list, along with some metadata'''
        page_size = getattr(self, 'page_size', None)
        if page_size is None:
            return {
                'meta': {},
                'objects': object_list,
            }
        max_page_size = getattr(self, 'max_page_size', page_size)
        page_size = int(self.request.GET.get(self.LIMIT_PARAM, page_size))
        page_size = max(0, min(page_size, max_page_size))
        page_num = 0
        try:
            page_num = int(self.request.GET[self.PAGE_PARAM])
        except ValueError:
            # Bad page - default to 0
            pass
        except KeyError:
            try:
                offset = int(self.request.GET[self.OFFSET_PARAM])
            except ValueError:
                # Bad page - default to 0
                pass
            except KeyError:
                # No value - default to 0
                pass
            else:
                page_num = offset // page_size

        paginator = Paginator(object_list, page_size, allow_empty_first_page=True)
        try:
            page = paginator.page(page_num + 1)
        except EmptyPage:
            raise http.NotFound()
        return {
            'meta': {
                'offset': page.start_index() - 1,
                'page': page_num,
                'total_pages': paginator.num_pages,
                'limit': page_size,
                'count': paginator.count,
                'has_next': page.has_next(),
                'has_prev': page.has_previous(),
            },
            'objects': page.object_list,
        }

    # Get the parsed request data

    def get_request_data(self, default=None):
        '''Retrieve data from request'''
        content_type, _ = parse_header(self.request.META.get('CONTENT_TYPE', ''))
        if content_type in self.CONTENT_TYPES:
            if not self.request.body:
                return default
            return self.loads(self.request.body)
        if self.request.method == 'GET':
            return self.request.GET
        return self.request.POST

    # Response helpers

    def create_response(self, content, **response_kwargs):
        '''Return a response, serialising the content'''
        response_class = response_kwargs.pop('response_class', self.response_class)
        response_kwargs.setdefault('content_type', self.CONTENT_TYPES[0])
        return response_class(self.dumps(content), **response_kwargs)

    def render_single_object(self, obj, serialiser=None, **response_kwargs):
        '''Helper to return a single object instance serialised.'''
        if serialiser is None:
            serialiser = self.get_serialiser()
        serialiser_kwargs = response_kwargs.pop('serialiser_kwargs', None)
        if serialiser_kwargs is None:
            serialiser_kwargs = self.get_serialiser_kwargs()
        data = serialiser.object_deflate(obj, **serialiser_kwargs)
        return self.create_response(data, **response_kwargs)

    # Default handlers

    def list_get_default(self, request, **kwargs):
        object_list = self.get_object_list()
        object_list = self.filter_object_list(object_list)
        object_list = self.sort_object_list(object_list)

        data = self.get_page(object_list)

        serialiser = self.get_serialiser()
        serialiser_kwargs = self.get_serialiser_kwargs()
        data['objects'] = serialiser.list_deflate(data['objects'], **serialiser_kwargs)
        return self.create_response(data)

    def object_get_default(self, request, object_id, **kwargs):
        '''Default object GET handler -- get object'''
        obj = self.get_object(object_id)
        return self.render_single_object(obj)

########NEW FILE########
__FILENAME__ = client

import requests



########NEW FILE########
__FILENAME__ = publisher

from django.conf.urls import url

from nap.publisher import Publisher
from nap import http

class RpcPublisher(Publisher):
    '''
    RPC Style Publisher.

    Single URL endpoint, determines handler based on X-RPC-Action header and
    HTTP method.
    '''

    @classmethod
    def patterns(cls, api_name=None):
        view = cls.build_view()

        if api_name:
            name = '%s_%s' % (api_name, cls.api_name)
        else:
            name = cls.api_name

        return [
            url(r'^$', view, name='%s_endpoint' % name),
        ]

    def dispatch(self, request):
        self.action = request.HTTP['X-RPC-ACTION']
        try:
            handler = getattr(self, 'do_%s' % self.action, None)
        except AttributeError:
            return http.NotFound()

        return self.execute(handler)

########NEW FILE########
__FILENAME__ = serialiser
from __future__ import unicode_literals

from . import fields
from .exceptions import ValidationError, ValidationErrors
from .meta import Meta

from collections import defaultdict
from six import with_metaclass

import inspect


class MetaSerialiser(type):
    meta_class = Meta

    def __new__(mcs, name, bases, attrs):
        attrs['_fields'] = {}

        # Remove from attrs
        meta = attrs.pop('Meta', None)

        # Field declared on this new class
        declared_fields = {}
        for field_name, field in list(attrs.items()):
            if isinstance(field, fields.Field):
                declared_fields[field_name] = attrs.pop(field_name)

        new_class = super(MetaSerialiser, mcs).__new__(mcs, name, bases, attrs)

        # Find fields declared on parents
        base_fields = {}
        for base in reversed(inspect.getmro(new_class)):
            base_fields.update(getattr(base, '_fields', {}))

        base_fields.update(declared_fields)
        new_class._fields = base_fields

        # Handle class Meta
        new_class._meta = mcs.meta_class(meta)

        return new_class


class Serialiser(with_metaclass(MetaSerialiser, object)):
    obj_class = None

    def __init__(self):
        '''
        Since the list of methods to call to deflate/inflate an object
        don't change, we might as well construct the lists once right here.
        '''
        # Build list of deflate and inflate methods
        self._field_deflaters = []
        self._custom_deflaters = []
        self._field_inflaters = []
        self._custom_inflaters = []

        for name, field in self._fields.items():
            self._field_deflaters.append((name, field.deflate))
            method = getattr(self, 'deflate_%s' % name, None)
            if method is not None:
                self._custom_deflaters.append((name, method))

            if field.readonly:
                continue
            method = getattr(self, 'inflate_%s' % name, None)
            if method:
                self._custom_inflaters.append((name, method))
            else:
                self._field_inflaters.append((name, field.inflate))

    def object_deflate(self, obj, **kwargs):
        data = {}
        for name, method in self._field_deflaters:
            method(name, obj=obj, data=data, **kwargs)
        for name, method in self._custom_deflaters:
            data[name] = method(obj=obj, data=data, **kwargs)
        return data

    def list_deflate(self, obj_list, **kwargs):
        return [
            self.object_deflate(obj, **kwargs)
            for obj in iter(obj_list)
        ]

    def object_inflate(self, data, instance=None, **kwargs):
        objdata = {}
        errors = defaultdict(list)
        for name, method in self._field_inflaters:
            try:
                method(name, data=data, obj=objdata, instance=instance, **kwargs)
            except ValidationError as exc:
                errors[name].append(exc)
        for name, method in self._custom_inflaters:
            try:
                objdata[name] = method(data=data, obj=objdata, instance=instance,
                    **kwargs
                )
            except ValidationError as exc:
                errors[name].append(exc)
        if errors:
            raise ValidationErrors(errors)
        return self.restore_object(objdata, instance=instance, **kwargs)

    def list_inflate(self, data_list, **kwargs):
        # XXX target object list?
        return [
            self.object_inflate(data, **kwargs)
            for data in data_list
        ]

    def restore_object(self, objdata, **kwargs):  # pragma: no cover
        if not self.obj_class:
            raise NotImplementedError
        return self.obj_class(objdata)

########NEW FILE########
__FILENAME__ = test_fields

from django.test import TestCase

from nap import fields
from nap.exceptions import ValidationError

class Mock(object):
    def __init__(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)

class FieldTestCase(TestCase):
    '''
    Field cycles:
    deflate: digattr -> reduce -> data[name]
    inflate: data[name] -> restore -> dest[name]
    '''

    def test_000_field(self):
        data = {}
        field = fields.Field()

        field.deflate('value', Mock(value='str'), data)
        self.assertEqual('str', data['value'])

        dest = {}

        field.inflate('value', data, dest)
        self.assertEqual(dest['value'], data['value'])

    def test_000_field_none(self):
        '''None is treated specially.'''
        data = {}
        field = fields.Field()

        field.deflate('value', Mock(value=None), data)
        self.assertTrue(data['value'] is None)

        dest = {}

        field.inflate('value', data, dest)
        self.assertEqual(data['value'], dest['value'])

    def test_000_field_default(self):
        '''
        With no default set, we can't deflate a field with no value.
        '''
        data = {}
        field = fields.Field()

        with self.assertRaises(AttributeError):
            field.deflate('value', Mock(), data)

    def test_000_readonly(self):
        data = {'value': 1}
        dest = {}
        field = fields.Field(readonly=True)
        field.inflate('value', data, dest)
        self.assertNotIn('value', dest)

    def test_000_nodefault(self):
        data = {}
        dest = {}
        field = fields.Field()
        field.inflate('value', data, dest)
        self.assertNotIn('value', dest)

    def test_000_default(self):
        data = {}
        dest = {}
        field = fields.Field(default=1)

        field.inflate('value', data, dest)
        self.assertEqual(dest['value'], 1)

    def test_000_notnull(self):
        data = {'value': None}
        dest = {}
        field = fields.Field(null=False)

        with self.assertRaises(ValidationError):
            field.inflate('value', data, dest)

    def test_001_boolean(self):
        data = {}
        field = fields.BooleanField()

        field.deflate('value', Mock(value=True), data)
        self.assertTrue(data['value'] is True)

        dest = {}

        field.inflate('value', data, dest)
        self.assertTrue(dest['value'] is True)

    def test_002_integer(self):
        data = {}
        field = fields.IntegerField()

        field.deflate('value', Mock(value=7), data)
        self.assertEqual(data['value'], 7)

        dest = {}

        field.inflate('value', data, dest)
        self.assertEqual(dest['value'], data['value'])

    def test_003_decimal(self):
        from decimal import Decimal
        data = {}
        field = fields.DecimalField()

        field.deflate('value', Mock(value=Decimal('1.05')), data)
        # JS has no Decimal type, only float
        self.assertEqual(data['value'], 1.05)

        dest = {}

        field.inflate('value', data, dest)
        self.assertEqual(dest['value'], data['value'])

    def test_004_datetime(self):
        from datetime import datetime
        data = {}
        field = fields.DateTimeField()

        when = datetime(2010, 11, 5, 12, 7, 19)
        field.deflate('value', Mock(value=when), data)
        self.assertEqual(data['value'], '2010-11-05 12:07:19')

        dest = {}

        field.inflate('value', data, dest)
        self.assertEqual(dest['value'], when)

    def test_005_date(self):
        from datetime import date
        data = {}
        field = fields.DateField()

        when = date(2010, 11, 5)
        field.deflate('value', Mock(value=when), data)
        self.assertEqual(data['value'], '2010-11-05')

        dest = {}

        field.inflate('value', data, dest)
        self.assertEqual(dest['value'], when)

    def test_006_time(self):
        from datetime import time
        data = {}
        field = fields.TimeField()

        when = time(12, 7, 19)
        field.deflate('value', Mock(value=when), data)
        self.assertEqual(data['value'], '12:07:19')

        dest = {}

        field.inflate('value', data, dest)
        self.assertEqual(dest['value'], when)

    def test_007_serialiser(self):
        from nap.serialiser import Serialiser
        class SimpleSerialiser(Serialiser):
            a = fields.Field()
            b = fields.Field()
            c = fields.Field()

        data = {}
        field = fields.SerialiserField(serialiser=SimpleSerialiser())

        value = Mock(value=Mock(a=1, b='two', c=3.0))
        field.deflate('value', value, data)
        self.assertEqual(data['value']['a'], 1)
        self.assertEqual(data['value']['b'], 'two')
        self.assertEqual(data['value']['c'], 3.0)


########NEW FILE########
__FILENAME__ = test_models

from django.test import TestCase



########NEW FILE########
__FILENAME__ = test_publisher

from django.test import TestCase
from django.test.client import RequestFactory

from nap import publisher

class TestPublisher(publisher.Publisher):
    pass


class PublisherTestCase(TestCase):

    def setUp(self):
        self.factory = RequestFactory()
        self.request = self.factory.get('/')
        self.pub = TestPublisher(self.request)

    def test_000_index(self):
        data = self.pub.index()

        self.assertTrue('list' in data)
        self.assertTrue('object' in data)

########NEW FILE########
__FILENAME__ = test_serialiser

from django.test import TestCase



########NEW FILE########
__FILENAME__ = test_utils

from django.test import TestCase

from nap.utils import digattr

class DigattrTestCase(TestCase):

    def test_001_simple(self):

        data = {
            'a': 1,
            'b': [1,2,3],
            'c': lambda: 4,
            'd': {
                'a': 'test',
            },
        }

        self.assertEqual(digattr(data, 'a'), 1)
        self.assertEqual(digattr(data, 'b.2'), 3)
        self.assertEqual(digattr(data, 'c'), 4)
        self.assertEqual(digattr(data, 'd.a'), 'test')
        self.assertEqual(digattr(data, 'd.a.1'), 'e')


########NEW FILE########
__FILENAME__ = utils
from __future__ import unicode_literals


def digattr(obj, attr, default=None):
    '''Perform template-style dotted lookup'''
    steps = attr.split('.')
    for step in steps:
        try:    # dict lookup
            obj = obj[step]
        except (TypeError, AttributeError, KeyError):
            try:    # attribute lookup
                obj = getattr(obj, step)
            except (TypeError, AttributeError):
                try:    # list index lookup
                    obj = obj[int(step)]
                except (IndexError, ValueError, KeyError, TypeError):
                    return default
        if callable(obj):
            obj = obj()
    return obj

########NEW FILE########
__FILENAME__ = views
from __future__ import unicode_literals

from .publisher import Publisher, SimplePatternsMixin
from .models import ModelPublisher

from django.template.response import TemplateResponse


class ViewPublisherMixin(object):
    '''
    A Publisher for non-API views.

    Replaces create_response with a wrapper around TemplateResponse.
    '''
    api_name = None

    def create_response(self, content, **response_kwargs):
        '''Return a response serialising the content'''
        template = response_kwargs.pop('template', None)
        if not template:
            template = self.get_template_names()
        return TemplateResponse(self.request, template, content,
            **response_kwargs
        )


class ViewPublisher(SimplePatternsMixin, Publisher):
    def get_template_name(self):
        return self.template_name % {
            'action': self.action,
            'method': self.method,
            'mode': self.mode,
        }


class ModelViewPublisher(SimplePatternsMixin, ModelPublisher):
    model = None

    def get_template_name(self):
        '''Return the template name to use for this view.'''
        return '%s/%s_%s.html' % (
            self.api_name or self.model._meta.app_label,
            self.model._meta.model_name,
            self.action,
        )

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

sys.path.insert(0, os.path.join(os.path.dirname(__file__), os.path.pardir))

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = models
from django.db import models


class Poll(models.Model):
    question = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')


class Choice(models.Model):
    poll = models.ForeignKey(Poll)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField()

########NEW FILE########
__FILENAME__ = publishers

from nap import fields, api
from nap.models import ModelPublisher

from .models import Choice
from .serialiser import PollSerialiser

class PollPublisher(models.ModelPublisher)
    api_name = 'poll'
    serialiser = PollSerialiser()

api.register('api', PollPublisher)

########NEW FILE########
__FILENAME__ = serialiser

from nap.models import ModelSerialiser
from nap.serialiser import Serialiser
from nap import fields

from .models import Choice

class ChoiceSerialiser(ModelSerialiser):
    class Meta:
        model = Choice
        exclude = ('poll,')

class PollSerialiser(Serialiser):
    question = fields.Field()
    published = fields.DateTimeField('pub_date')
    choices = fields.ManySerialiserField(serialiser=ChoiceSerialiser())


########NEW FILE########
__FILENAME__ = api
from django.test import TestCase
from polls import models
from nap.models import ModelSerialiser
from nap.publisher import Publisher
from nap import api


class PollSerialiser(ModelSerialiser):
    class Meta:
        model = models.Poll


class PollPublisher(Publisher):
    serialiser = PollSerialiser()
    api_name = 'polls'

    def get_object_list(self):
        return models.Poll.objects.all()


class ApiTest(TestCase):

    def tearDown(self):
        try:
            del api.APIS['v1']
        except KeyError:
            pass

    def test_patterns(self):
        self.assertTrue(api.patterns() == [])

    def test_register(self):
        self.assertTrue(len(api.APIS.keys()) == 0)
        api.register('v1', PollPublisher)
        self.assertTrue(len(api.APIS.keys()) == 1)
        self.assertTrue(len(api.patterns()) == 1)

########NEW FILE########
__FILENAME__ = serializer
from django.test import TestCase
from polls import models
from nap.serialiser import Serialiser
from nap.models import ModelSerialiser
from nap.fields import Field


class SerializerTest(TestCase):

    def test_declared_fields(self):
        class MySerialiser(Serialiser):
            test_field = Field()
            another_field = Field()

        serializer = MySerialiser()
        for f in ('test_field', 'another_field'):
            self.assertIn(f, serializer._fields.keys())


class ModelSerializerTest(TestCase):

    def test_model_fields(self):
        class PollSerialiser(ModelSerialiser):
            class Meta:
                model = models.Poll

        serializer = PollSerialiser()
        for f in ('id', 'question', 'pub_date'):
            self.assertIn(f, serializer._fields.keys())

    def test_model_fields_include(self):

        class PollSerialiser(ModelSerialiser):
            class Meta:
                model = models.Poll
                fields = ('question', 'pub_date')

        serializer = PollSerialiser()
        for f in ('question', 'pub_date'):
            self.assertIn(f, serializer._fields.keys())
        self.assertNotIn('id', serializer._fields.keys())

    def test_model_fields_exclude(self):

        class PollSerialiser(ModelSerialiser):
            class Meta:
                model = models.Poll
                exclude = ('id')

        serializer = PollSerialiser()
        for f in ('question', 'pub_date'):
            self.assertIn(f, serializer._fields.keys())
        self.assertNotIn('id', serializer._fields.keys())

########NEW FILE########
__FILENAME__ = settings
import os.path

INSTALLED_APPS = [
    'nap',
    'polls',
]

SITE_ID = 1
SECRET_KEY = '+zzix-&k$afk-k0d0s7v01w0&15z#ne$71qf28#e$$c*@g742z'
ROOT_URLCONF = "urls"

DEBUG = True

STATIC_URL = '/static/'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(os.path.dirname(__file__), 'database.db'),
    }
}

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include

from nap import api
api.autodiscover()

urlpatterns = patterns('',
    (r'^api/', include(api.patterns(True))),
)

########NEW FILE########
