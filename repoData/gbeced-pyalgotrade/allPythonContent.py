__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# PyAlgoTrade documentation build configuration file, created by
# sphinx-quickstart on Fri Nov  4 21:48:31 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))
sys.path.insert(0, os.path.abspath('..'))

autoclass_content="both"

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'PyAlgoTrade'
copyright = u'2011-2014, Gabriel Martín Becedillas Ruiz'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.15'
# The full version, including alpha/beta/rc tags.
release = '0.15'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'PyAlgoTradedoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'PyAlgoTrade.tex', u'PyAlgoTrade Documentation',
   u'Gabriel Martín Becedillas Ruiz', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pyalgotrade', u'PyAlgoTrade Documentation',
     [u'Gabriel Martín Becedillas Ruiz'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'PyAlgoTrade', u'PyAlgoTrade Documentation',
   u'Gabriel Martín Becedillas Ruiz', 'PyAlgoTrade', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = config
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

master_task_queue = "mastertask-queue"
master_task_url = "/chanchero/mastertask"
worker_task_queue = "workertask-queue"
worker_task_url = "/chanchero/workertask"
result_task_queue = "resulttask-queue"
result_task_url = "/chanchero/resulttask"

########NEW FILE########
__FILENAME__ = mastertaskhandler
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from google.appengine.ext.webapp.util import run_wsgi_app
from google.appengine.api import taskqueue
import webapp2

# The usertasks import is necesary for tasks.MasterTask.fromPickleString to work.
import usertasks
from chanchero import tasks
from chanchero import config


class MasterTaskHandler(webapp2.RequestHandler):
    def post(self):
        masterTask = tasks.MasterTask.fromPickleString(self.request.get("mastertask"))
        maxWorkerTasksQueued = 500

        # Get the number of tasks in the worker task queue.
        stats = taskqueue.Queue(config.worker_task_queue).fetch_statistics()
        maxWorkerTasksQueued -= stats.tasks

        # Build worker tasks from the master task.
        while not masterTask.isFinished() and maxWorkerTasksQueued > 0:
            nextWorkerTask = masterTask.getNextWorker()
            if nextWorkerTask is not None:
                maxWorkerTasksQueued -= 1
                nextWorkerTask.queue()

        # If the master task was not fully expanded, queue it again.
        if not masterTask.isFinished():
            masterTask.queue()


def main():
    app = webapp2.WSGIApplication([(config.master_task_url, MasterTaskHandler)], debug=True)
    run_wsgi_app(app)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = resulttaskhandler
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from google.appengine.ext.webapp.util import run_wsgi_app
import webapp2

# The usertasks import is necesary for tasks.ResultTask.fromPickleString to work.
import usertasks
from chanchero import tasks
from chanchero import config


class ResultTaskHandler(webapp2.RequestHandler):
    def post(self):
        resultTask = tasks.ResultTask.fromPickleString(self.request.get("resulttask"))
        resultTask.run()


def main():
    app = webapp2.WSGIApplication([(config.result_task_url, ResultTaskHandler)], debug=True)
    run_wsgi_app(app)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = tasks
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from google.appengine.api import taskqueue

from chanchero import config

import pickle


class Task:
    def __init__(self, taskId):
        self.__taskId = taskId

    def beforeToPickleString(self):
        pass

    def getTaskId(self):
        return self.__taskId

    def toPickleString(self):
        self.beforeToPickleString()
        return str(pickle.dumps(self))

    @staticmethod
    def fromPickleString(pickledTask):
        return pickle.loads(str(pickledTask))


# Master tasks are responsible for partitioning the problem into smaller pieces, called worker tasks.
class MasterTask(Task):
    def __init__(self, taskId):
        Task.__init__(self, taskId)

    def queue(self):
        params = {}
        params["mastertask"] = self.toPickleString()
        taskqueue.add(queue_name=config.master_task_queue, url=config.master_task_url, params=params)

    def isFinished(self):
        raise NotImplementedError()

    def getNextWorker(self):
        raise NotImplementedError()


class WorkerTask(Task):
    def __init__(self, taskId):
        Task.__init__(self, taskId)

    def queue(self):
        params = {}
        params["workertask"] = self.toPickleString()
        taskqueue.add(queue_name=config.worker_task_queue, url=config.worker_task_url, params=params)

    def run(self):
        raise NotImplementedError()


class ResultTask(Task):
    def __init__(self, taskId):
        Task.__init__(self, taskId)

    def queue(self):
        params = {}
        params["resulttask"] = self.toPickleString()
        taskqueue.add(queue_name=config.result_task_queue, url=config.result_task_url, params=params)

    def run(self):
        raise NotImplementedError()

########NEW FILE########
__FILENAME__ = workertaskhandler
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from google.appengine.ext.webapp.util import run_wsgi_app
import webapp2

# The usertasks import is necesary for tasks.WorkerTask.fromPickleString to work.
import usertasks
from chanchero import tasks
from chanchero import config


class WorkerTaskHandler(webapp2.RequestHandler):
    def post(self):
        workerTask = tasks.WorkerTask.fromPickleString(self.request.get("workertask"))
        workerTask.run()


def main():
    app = webapp2.WSGIApplication([(config.worker_task_url, WorkerTaskHandler)], debug=True)
    run_wsgi_app(app)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = cls
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import inspect


class Class:
    def __init__(self, fullClassName):
        parts = fullClassName.split(".")

        if len(parts) > 1:
            mod = __import__(".".join(parts[0:-1]))
            for item in parts[1:-1]:
                mod = getattr(mod, item)
            self.__cls = getattr(mod, parts[-1])
        else:
            self.__cls = locals()[fullClassName]

    def getMethodParams(self, methodName):
        # Return args
        return inspect.getargspec(getattr(self.__cls, methodName))[0]

    def getClass(self):
        return self.__cls

########NEW FILE########
__FILENAME__ = forms
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import cgi


class Form:
    def __init__(self, request, fieldNames):
        self.__values = {}
        for name in fieldNames:
            self.__values[name] = request.get(name)

    def setRawValue(self, name, value):
        self.__values[name] = value

    def getRawValue(self, name):
        return self.__values[name]

    def getSafeValue(self, name):
        ret = self.getRawValue(name)
        if ret is not None:
            ret = cgi.escape(ret)
        return ret

    def getValuesForTemplate(self):
        ret = {}
        for name in self.__values.keys():
            ret[name] = self.getSafeValue(name)
        return ret

########NEW FILE########
__FILENAME__ = logger
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging


class Logger:
    def __init__(self, maxErrors=None):
        self.__maxErrors = maxErrors

    def info(self, msg):
        logging.info(msg)

    def error(self, msg):
        if self.__maxErrors is not None and self.__maxErrors > 0:
            self.__maxErrors -= 1
            logging.error(msg)

# logging.getLogger().setLevel(logging.DEBUG)

########NEW FILE########
__FILENAME__ = parameters
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


class ParametersIterator:
    def __init__(self, paramCount):
        self.__paramRanges = [None for i in range(paramCount)]
        self.__currentValues = [None for i in range(paramCount)]

    def setRange(self, paramIndex, begin, end):
        self.__paramRanges[paramIndex] = (begin, end)
        if self.__currentValues[paramIndex] is None:
            self.__currentValues[paramIndex] = begin

    def setCurrentValue(self, paramIndex, value):
        self.__currentValues[paramIndex] = value

    def getCurrent(self):
        ret = None
        if self.__currentValues is not None:
            ret = tuple(self.__currentValues)
        return ret

    def __incrementCurrent(self, paramIndex):
        nextValue = self.__currentValues[paramIndex] + 1
        if nextValue >= self.__paramRanges[paramIndex][1]:
            self.__currentValues[paramIndex] = self.__paramRanges[paramIndex][0]
            if paramIndex != 0:
                self.__incrementCurrent(paramIndex - 1)
            else:
                self.__currentValues = None
        else:
            self.__currentValues[paramIndex] = nextValue

    def moveNext(self):
        if self.__currentValues is not None:
            self.__incrementCurrent(len(self.__paramRanges) - 1)

    def __iter__(self):
        return self

    def next(self):
        ret = self.getCurrent()
        if ret is not None:
            self.moveNext()
        else:
            raise StopIteration()
        return ret

########NEW FILE########
__FILENAME__ = timer
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time


class Timer:
    def __init__(self):
        self.__started = time.time()

    def secondsElapsed(self):
        """Returns an int with the number of seconds elapsed since the instance was created."""
        return int(time.time() - self.__started)

    def minutesElapsed(self):
        """Returns an float with the number of seconds elapsed since the instance was created."""
        return self.secondsElapsed() / float(60)

########NEW FILE########
__FILENAME__ = utils
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import urllib


def build_url(urlPath, paramsDict):
    ret = urlPath
    params = urllib.urlencode(paramsDict)
    if params:
        ret += "?" + params
    return ret

########NEW FILE########
__FILENAME__ = home
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os

from google.appengine.ext import webapp
from google.appengine.api import users
from google.appengine.ext.webapp.util import run_wsgi_app
from google.appengine.ext.webapp import template

import pages.strategy
import strategies
import persistence


class HomePage(webapp.RequestHandler):
    url = "/"

    def get(self):
        templateValues = {}
        templateValues["logout_url"] = users.create_logout_url("/")
        templateValues["user"] = users.get_current_user()
        templateValues["strategies"] = []

        for strategyClass in strategies.get_strategy_classes():
            strategyValues = {}
            strategyValues["class"] = strategyClass
            strategyValues["url"] = pages.strategy.StrategyPage.getUrl(strategyClass)
            templateValues["strategies"].append(strategyValues)

        templateValues["active_executions"] = pages.strategy.get_stratexecconfig_for_template(persistence.StratExecConfig.getByStatus([persistence.StratExecConfig.Status.ACTIVE]))

        path = os.path.join(os.path.dirname(__file__), "..", "templates", 'index.html')
        self.response.out.write(template.render(path, templateValues))


def main():
    application = webapp.WSGIApplication([(HomePage.url, HomePage)], debug=True)
    run_wsgi_app(application)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = strategy
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import datetime
import cgi

from google.appengine.ext import webapp
from google.appengine.api import users
from google.appengine.ext.webapp.util import run_wsgi_app
from google.appengine.ext.webapp import template

import persistence
import usertasks
from common import utils
from common import cls
from common import forms


def get_stratexecconfig_for_template(stratExecConfigs):
    ret = []
    for stratExecConfig in stratExecConfigs:
        props = {}
        props["class"] = stratExecConfig.className
        props["created"] = stratExecConfig.created.strftime("%d/%b/%Y %H:%M")
        props["executions_finished"] = stratExecConfig.executionsFinished
        props["total_executions"] = stratExecConfig.totalExecutions
        if stratExecConfig.bestResult:
            props["best_result"] = stratExecConfig.bestResult
            props["best_result_parameters"] = stratExecConfig.bestResultParameters

        if stratExecConfig.status in [persistence.StratExecConfig.Status.ACTIVE, persistence.StratExecConfig.Status.FINISHED]:
            if stratExecConfig.errors > 0:
                props["additional_info"] = "%d errors were found. Take a look at the application logs." % (stratExecConfig.errors)
            if stratExecConfig.status == persistence.StratExecConfig.Status.FINISHED:
                props["reexecute_url"] = StrategyExecutionPage.getReExecuteUrl(stratExecConfig.className, stratExecConfig.key())
        elif stratExecConfig.status == persistence.StratExecConfig.Status.CANCELED_TOO_MANY_ERRORS:
            props["additional_info"] = "The strategy execution was cancelled because it generated too many errors."
        else:
            assert(False)  # Invalid state

        ret.append(props)
    return ret


class QueueStrategyExecutionForm(forms.Form):
    beginDateParam = "dateBegin"
    endDateParam = "dateEnd"
    instrumentParam = "instrument"

    def __init__(self, request, strategyParams):
        self.__strategyParams = strategyParams
        fieldNames = []

        # Build field names based on __init__ parameters.
        for strategyParam in strategyParams:
            fieldNames.append(self.getBeginParamName(strategyParam))
            fieldNames.append(self.getEndParamName(strategyParam))

        fieldNames.append(QueueStrategyExecutionForm.beginDateParam)
        fieldNames.append(QueueStrategyExecutionForm.endDateParam)
        fieldNames.append(QueueStrategyExecutionForm.instrumentParam)
        forms.Form.__init__(self, request, fieldNames)

    def getBeginParamName(self, strategyParam):
        return strategyParam+"Begin"

    def getEndParamName(self, strategyParam):
        return strategyParam+"End"

    def getParamAsDateTime(self, paramName):
        return datetime.datetime.strptime(self.getRawValue(paramName).strip(), "%Y/%m/%d")

    def getInstrument(self):
        return self.getRawValue(QueueStrategyExecutionForm.instrumentParam).strip()

    def getParamRange(self, strategyParam):
        beginParamValue = self.getRawValue(self.getBeginParamName(strategyParam)).strip()
        endParamValue = self.getRawValue(self.getEndParamName(strategyParam)).strip()
        return (int(beginParamValue), int(endParamValue))

    def __paramValuesValid(self, strategyParam):
        ret = True
        try:
            beginParamValue, endParamValue = self.getParamRange(strategyParam)
            ret = beginParamValue <= endParamValue
        except Exception:
            ret = False
        return ret

    def validateAllParams(self):
        # Validate strategy params.
        for strategyParam in self.__strategyParams:
            if not self.__paramValuesValid(strategyParam):
                raise Exception("%s values are not valid" % strategyParam)

        # Validate date range params.
        try:
            if self.getParamAsDateTime(QueueStrategyExecutionForm.beginDateParam) >= self.getParamAsDateTime(QueueStrategyExecutionForm.endDateParam):
                raise Exception("Begin date should be before end date.")
        except ValueError:
            raise Exception("Date range values are not valid")

        if len(self.getInstrument()) == 0:
            raise Exception("Instrument is not set")

    def getTemplateValues(self):
        formValues = self.getValuesForTemplate()
        ret = {}

        # Strategy parameter values.
        ret["strategy"] = []
        for strategyParam in self.__strategyParams:
            beginParamName = self.getBeginParamName(strategyParam)
            endParamName = self.getEndParamName(strategyParam)

            paramInfo = {}
            paramInfo["name"] = strategyParam
            paramInfo["beginName"] = beginParamName
            paramInfo["endName"] = endParamName
            paramInfo["beginValue"] = formValues[beginParamName]
            paramInfo["endValue"] = formValues[endParamName]
            ret["strategy"].append(paramInfo)

        # Other values.
        ret[QueueStrategyExecutionForm.instrumentParam] = formValues[QueueStrategyExecutionForm.instrumentParam]

        defDateValue = "YYYY/MM/DD"
        # Begin date.
        if formValues[QueueStrategyExecutionForm.beginDateParam] != "":
            ret[QueueStrategyExecutionForm.beginDateParam] = formValues[QueueStrategyExecutionForm.beginDateParam]
        else:
            ret[QueueStrategyExecutionForm.beginDateParam] = defDateValue
        # End date.
        if formValues[QueueStrategyExecutionForm.endDateParam] != "":
            ret[QueueStrategyExecutionForm.endDateParam] = formValues[QueueStrategyExecutionForm.endDateParam]
        else:
            ret[QueueStrategyExecutionForm.endDateParam] = defDateValue

        return ret

    def loadFromStratExecConfig(self, stratExecConfig):
        # Strategy parameter values.
        for strategyParam in self.__strategyParams:
            try:
                pos = stratExecConfig.parameterNames.index(strategyParam)
                beginPos = pos * 2
                endPos = beginPos + 1
                self.setRawValue(self.getBeginParamName(strategyParam), str(stratExecConfig.parameterRanges[beginPos]))
                self.setRawValue(self.getEndParamName(strategyParam), str(stratExecConfig.parameterRanges[endPos]-1))
            except ValueError:
                pass
                # Parameter not found

        # Other values.
        dateFormat = "%Y/%m/%d"
        self.setRawValue(QueueStrategyExecutionForm.instrumentParam, str(stratExecConfig.instrument))
        self.setRawValue(QueueStrategyExecutionForm.beginDateParam, stratExecConfig.firstDate.strftime(dateFormat))
        self.setRawValue(QueueStrategyExecutionForm.endDateParam, stratExecConfig.lastDate.strftime(dateFormat))


class StrategyPage(webapp.RequestHandler):
    url = "/strategy/"

    @staticmethod
    def getUrl(strategyClassName):
        return utils.build_url(StrategyPage.url, {"class": strategyClassName})

    def get(self):
        templateValues = {}
        strategyClassName = cgi.escape(self.request.get("class")).strip()

        # Try to load the class.
        try:
            cls.Class(strategyClassName)
        except Exception, e:
            templateValues["error"] = "Failed to load strategy '%s': %s" % (strategyClassName, e)
            path = os.path.join(os.path.dirname(__file__), "..", "templates", 'error.html')
            self.response.out.write(template.render(path, templateValues))
            return

        # persistence.StratExecConfig.getByClass(strategyClassName)

        # Template values
        strategyValues = {}
        strategyValues["class"] = strategyClassName
        templateValues["logout_url"] = users.create_logout_url("/")
        templateValues["user"] = users.get_current_user()
        templateValues["strategy"] = strategyValues
        templateValues["queue_execution_url"] = StrategyExecutionPage.getUrl(strategyClassName)

        templateValues["active_executions"] = get_stratexecconfig_for_template(persistence.StratExecConfig.getByClass(strategyClassName, [persistence.StratExecConfig.Status.ACTIVE]))
        templateValues["finished_executions"] = get_stratexecconfig_for_template(persistence.StratExecConfig.getByClass(strategyClassName, [persistence.StratExecConfig.Status.FINISHED, persistence.StratExecConfig.Status.CANCELED_TOO_MANY_ERRORS]))

        # Build the response using the template.
        path = os.path.join(os.path.dirname(__file__), "..", "templates", 'strategy.html')
        self.response.out.write(template.render(path, templateValues))


class StrategyExecutionPage(webapp.RequestHandler):
    url = "/strategy/queue_execution/"

    @staticmethod
    def getUrl(strategyClassName):
        return utils.build_url(StrategyExecutionPage.url, {"class": strategyClassName})

    @staticmethod
    def getReExecuteUrl(strategyClassName, stratExecConfigKey):
        return utils.build_url(StrategyExecutionPage.url, {
            "class": strategyClassName,
            "key": stratExecConfigKey
            })

    def __buildStratExecConfig(self, className, strategyParams, form):
        totalExecutions = 1
        parameterRanges = []
        for strategyParam in strategyParams:
            beginParamValue, endParamValue = form.getParamRange(strategyParam)
            endParamValue += 1
            parameterRanges.append(beginParamValue)
            parameterRanges.append(endParamValue)
            totalExecutions *= (endParamValue - beginParamValue)

        ret = persistence.StratExecConfig(
            className=className,
            instrument=form.getInstrument(),
            barType=persistence.Bar.Type.DAILY,
            firstDate=form.getParamAsDateTime(QueueStrategyExecutionForm.beginDateParam),
            lastDate=form.getParamAsDateTime(QueueStrategyExecutionForm.endDateParam),
            parameterNames=strategyParams,
            parameterRanges=parameterRanges,
            created=datetime.datetime.now(),
            status=persistence.StratExecConfig.Status.ACTIVE,
            totalExecutions=totalExecutions
            )

        return ret

    def __handleRequest(self, isPost):
        templateValues = {}
        strategyClassName = cgi.escape(self.request.get("class"))
        stratExecConfigKey = cgi.escape(self.request.get("key"))

        # Try to load the class.
        try:
            strategyClass = cls.Class(strategyClassName)
        except Exception, e:
            templateValues["error"] = "Failed to load strategy '%s': %s" % (strategyClassName, e)
            path = os.path.join(os.path.dirname(__file__), "..", "templates", 'error.html')
            self.response.out.write(template.render(path, templateValues))
            return

        # Get __init__ parameters.
        try:
            strategyParams = strategyClass.getMethodParams("__init__")
            minParamCount = 3
            if len(strategyParams) < minParamCount:
                raise Exception("__init__ should receive at least %d parameters. For example: __init__(self, feed, ...)" % minParamCount)
            strategyParams = strategyParams[minParamCount-1:]
        except Exception, e:
            templateValues["error"] = "Failed to get __init__ parameters for '%s': %s" % (strategyClassName, e)
            path = os.path.join(os.path.dirname(__file__), "..", "templates", 'error.html')
            self.response.out.write(template.render(path, templateValues))
            return

        form = QueueStrategyExecutionForm(self.request, strategyParams)

        # If handling a POST request, try to queue the new strategy execution.
        if isPost:
            try:
                form.validateAllParams()
                # Check that we have bars loaded for the given instrument within the given dates.
                instrument = form.getInstrument()
                beginDate = form.getParamAsDateTime(QueueStrategyExecutionForm.beginDateParam)
                endDate = form.getParamAsDateTime(QueueStrategyExecutionForm.endDateParam)
                if not persistence.Bar.hasBars(instrument, persistence.Bar.Type.DAILY, beginDate, endDate):
                    raise Exception("There are no bars loaded for '%s' between '%s' and '%s'" % (instrument, beginDate, endDate))

                # Queue the strategy execution config and redirect.
                stratExecConfig = self.__buildStratExecConfig(strategyClassName, strategyParams, form)
                stratExecConfig.put()
                usertasks.MasterTask(1, stratExecConfig).queue()
                self.redirect(StrategyPage.getUrl(strategyClassName))
            except Exception, e:
                templateValues["submit_error"] = str(e)
        # If this is a re-execution request, load form values from strat exec config.
        elif stratExecConfigKey != "":
            try:
                stratExecConfig = persistence.StratExecConfig.getByKey(stratExecConfigKey)
                form.loadFromStratExecConfig(stratExecConfig)
            except Exception, e:
                templateValues["error"] = "Failed to load previous execution: %s" % (e)
                path = os.path.join(os.path.dirname(__file__), "..", "templates", 'error.html')
                self.response.out.write(template.render(path, templateValues))
                return

        # Template values
        strategyValues = {}
        strategyValues["class"] = strategyClassName

        templateValues["logout_url"] = users.create_logout_url("/")
        templateValues["user"] = users.get_current_user()
        templateValues["strategy"] = strategyValues
        templateValues["form"] = form.getTemplateValues()

        # Build the response using the template.
        path = os.path.join(os.path.dirname(__file__), "..", "templates", 'queue_execution.html')
        self.response.out.write(template.render(path, templateValues))

    def get(self):
        return self.__handleRequest(False)

    def post(self):
        return self.__handleRequest(True)


def main():
    application = webapp.WSGIApplication([
        (StrategyPage.url, StrategyPage),
        (StrategyExecutionPage.url, StrategyExecutionPage),
        ], debug=True)

    run_wsgi_app(application)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = rsi2
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from pyalgotrade import strategy
from pyalgotrade.technical import ma
from pyalgotrade.technical import rsi


class Strategy(strategy.BacktestingStrategy):
    def __init__(self, feed, entrySMA, exitSMA, rsiPeriod, overBoughtThreshold, overSoldThreshold):
        initialCash = 2000
        strategy.BacktestingStrategy.__init__(self, feed, initialCash)
        self.__instrument = feed.getDefaultInstrument()
        ds = feed.getDataSeries().getCloseDataSeries()
        self.__entrySMA = ma.SMA(ds, entrySMA)
        self.__exitSMA = ma.SMA(ds, exitSMA)
        self.__rsi = rsi.RSI(ds, rsiPeriod)
        self.__overBoughtThreshold = overBoughtThreshold
        self.__overSoldThreshold = overSoldThreshold
        self.__longPos = None
        self.__shortPos = None

    def onEnterCanceled(self, position):
        if self.__longPos == position:
            self.__longPos = None
        elif self.__shortPos == position:
            self.__shortPos = None
        else:
            assert(False)

    def onExitOk(self, position):
        if self.__longPos == position:
            self.__longPos = None
        elif self.__shortPos == position:
            self.__shortPos = None
        else:
            assert(False)

    def onExitCanceled(self, position):
        # If the exit was canceled, re-submit it.
        position.exitMarket()

    def onBars(self, bars):
        # Wait for enough bars to be available to calculate SMA and RSI.
        if self.__exitSMA[-1] is None or self.__entrySMA[-1] is None or self.__rsi[-1] is None:
            return

        bar = bars.getBar(self.__instrument)
        if self.__longPos is not None:
            if self.exitLongSignal(bar):
                self.__longPos.exitMarket()
        elif self.__shortPos is not None:
            if self.exitShortSignal(bar):
                self.__shortPos.exitMarket()
        else:
            if self.enterLongSignal(bar):
                self.__longPos = self.enterLong(self.__instrument, 10, True)
            elif self.enterShortSignal(bar):
                self.__shortPos = self.enterShort(self.__instrument, 10, True)

    def enterLongSignal(self, bar):
        return bar.getClose() > self.__entrySMA[-1] and self.__rsi[-1] <= self.__overSoldThreshold

    def exitLongSignal(self, bar):
        return bar.getClose() > self.__exitSMA[-1]

    def enterShortSignal(self, bar):
        return bar.getClose() < self.__entrySMA[-1] and self.__rsi[-1] >= self.__overBoughtThreshold

    def exitShortSignal(self, bar):
        return bar.getClose() < self.__exitSMA[-1]

########NEW FILE########
__FILENAME__ = triple_ma_crossover
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from pyalgotrade import strategy
from pyalgotrade.technical import ma


class Strategy(strategy.BacktestingStrategy):
    def __init__(self, feed, ema1, ema2, ema3, ema4, daysToHold):
        strategy.BacktestingStrategy.__init__(self, feed)
        self.__instrument = feed.getDefaultInstrument()
        self.__daysToHold = daysToHold
        ds = feed[self.__instrument].getCloseDataSeries()
        self.__ema1 = ma.EMA(ds, ema1)
        self.__ema2 = ma.EMA(ds, ema2)
        self.__ema3 = ma.EMA(ds, ema3)
        self.__ema4 = ma.EMA(ds, ema4)
        self.__daysLeft = 0
        self.__position = None

    def getEMA1(self):
        return self.__ema1

    def getEMA2(self):
        return self.__ema2

    def getEMA3(self):
        return self.__ema3

    def getEMA4(self):
        return self.__ema4

    def onEnterCanceled(self, position):
        self.__position = None

    def onExitOk(self, position):
        self.__position = None

    def __getOrderSize(self, price):
        cash = self.getBroker().getCash() * 0.9
        return int(cash / price)

    def __entrySignal(self, bars):
        ret = False

        try:
            ema1 = self.__ema1[-1]
            ema2 = self.__ema2[-1]
            ema3 = self.__ema3[-1]
            ema4 = self.__ema4[-1]
            close3DaysAgo = self.getFeed()[self.__instrument][-3].getClose()
            close5DaysAgo = self.getFeed()[self.__instrument][-5].getClose()

            # Check that we have all the EMAs available.
            if ema1 is None or ema2 is None or ema3 is None or ema4 is None:
                return False

            openPrice = bars[self.__instrument].getOpen()
            closePrice = bars[self.__instrument].getClose()

            # Opens below the moving averages:
            ret = openPrice < ema3
            ret = ret and openPrice < ema2
            ret = ret and openPrice < ema1
            # Closes above the moving averages
            ret = ret and closePrice > ema3
            ret = ret and closePrice > ema1
            ret = ret and closePrice > ema2
            ret = ret and closePrice > openPrice
            # Whipsaw protection, this part tries to ensure that the price is moving in the right direction.
            ret = ret and close3DaysAgo < ema3
            ret = ret and close5DaysAgo < close3DaysAgo
            ret = ret and close5DaysAgo < ema4
        except IndexError:
            pass

        return ret

    def onBars(self, bars):
        closePrice = bars[self.__instrument].getClose()
        if self.__position is not None:
            self.__daysLeft -= 1
            if self.__daysLeft <= 0:
                self.__position.exitMarket()
            elif self.__position.getUnrealizedReturn() < -0.03:
                self.__position.exitMarket()
        elif self.__entrySignal(bars):
            self.__position = self.enterLong(self.__instrument, self.__getOrderSize(closePrice))
            self.__daysLeft = self.__daysToHold

########NEW FILE########
__FILENAME__ = strategyexecutor
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from google.appengine.api import memcache

from common import logger
from common import cls
import persistence
from pyalgotrade import bar
from pyalgotrade import barfeed
from pyalgotrade.barfeed import membf

import pickle
import zlib


class MemBarFeed(membf.BarFeed):
    def barsHaveAdjClose(self):
        return True


# Converts a persistence.Bar to a pyalgotrade.bar.Bar.
def ds_bar_to_pyalgotrade_bar(dsBar):
    return bar.BasicBar(dsBar.dateTime, dsBar.open_, dsBar.high, dsBar.low, dsBar.close_, dsBar.volume, dsBar.adjClose, bar.Frequency.DAY)


# Loads pyalgotrade.bar.Bars objects from the db.
def load_pyalgotrade_daily_bars(instrument, barType, fromDateTime, toDateTime):
    assert(barType == persistence.Bar.Type.DAILY)
    # Load pyalgotrade.bar.Bar objects from the db.
    dbBars = persistence.Bar.getBars(instrument, barType, fromDateTime, toDateTime)
    bars = [ds_bar_to_pyalgotrade_bar(dbBar) for dbBar in dbBars]

    # Use a feed to build pyalgotrade.bar.Bars objects.
    feed = MemBarFeed(bar.Frequency.DAY)
    feed.addBarsFromSequence(instrument, bars)
    ret = []
    for dateTime, bars in feed:
        ret.append(bars)
    return ret


class BarsCache:
    def __init__(self, aLogger):
        self.__cache = {}
        self.__logger = aLogger

    def __addLocal(self, key, bars):
        self.__cache[key] = bars

    def __getLocal(self, key):
        return self.__cache.get(key, None)

    def __addToMemCache(self, key, bars):
        try:
            value = str(pickle.dumps(bars))
            value = zlib.compress(value, 9)
            memcache.add(key=key, value=value)
        except Exception, e:
            self.__logger.error("Failed to add bars to memcache: %s" % e)

    def __getFromMemCache(self, key):
        ret = None
        try:
            value = memcache.get(key)
            if value is not None:
                value = zlib.decompress(value)
                ret = pickle.loads(value)
        except Exception, e:
            self.__logger.error("Failed to load bars from memcache: %s" % e)
        return ret

    def add(self, key, bars):
        key = str(key)
        self.__addLocal(key, bars)
        self.__addToMemCache(key, bars)

    def get(self, key):
        key = str(key)
        ret = self.__getLocal(key)
        if ret is None:
            ret = self.__getFromMemCache(key)
            if ret is not None:
                # Store in local cache for later use.
                self.__addLocal(key, ret)
        return ret


class StrategyExecutor:
    def __init__(self):
        self.__logger = logger.Logger(20)
        self.__barCache = BarsCache(self.__logger)

    def __loadBars(self, stratExecConfig):
        ret = self.__barCache.get(stratExecConfig.key())
        if ret is None:
            self.__logger.info("Loading '%s' bars from %s to %s" % (stratExecConfig.instrument, stratExecConfig.firstDate, stratExecConfig.lastDate))
            ret = load_pyalgotrade_daily_bars(stratExecConfig.instrument, stratExecConfig.barType, stratExecConfig.firstDate, stratExecConfig.lastDate)
            self.__barCache.add(stratExecConfig.key(), ret)
            self.__logger.info("Finished loading '%s' bars from %s to %s" % (stratExecConfig.instrument, stratExecConfig.firstDate, stratExecConfig.lastDate))
        return ret

    def getLogger(self):
        return self.__logger

    def runStrategy(self, stratExecConfig, paramValues):
        bars = self.__loadBars(stratExecConfig)

        barFeed = barfeed.OptimizerBarFeed(bar.Frequency.DAY, [stratExecConfig.instrument], bars)

        # Evaluate the strategy with the feed bars.
        params = [barFeed]
        params.extend(paramValues)
        myStrategy = cls.Class(stratExecConfig.className).getClass()(*params)
        myStrategy.run()
        return myStrategy.getResult()

########NEW FILE########
__FILENAME__ = usertasks
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import persistence
import strategyexecutor
import chanchero.tasks
from common import logger
from common import timer
from common import parameters

import copy
import traceback

# This is global to reuse previously loaded bars.
strategyExecutor = strategyexecutor.StrategyExecutor()


# Build a parameters.ParametersIterator from a StratExecConfig.
def build_params_iterator(stratExecConfig):
    ret = parameters.ParametersIterator(len(stratExecConfig.parameterRanges) / 2)
    for i in range(0, len(stratExecConfig.parameterRanges), 2):
        paramPos = int(i/2)
        firstValue = stratExecConfig.parameterRanges[i]
        lastValue = stratExecConfig.parameterRanges[i+1]
        ret.setRange(paramPos, firstValue, lastValue)
    return ret


class MasterTask(chanchero.tasks.MasterTask):
    def __init__(self, taskId, stratExecConfig):
        chanchero.tasks.MasterTask.__init__(self, taskId)
        # Everything that is defined here should be pickleable or reset in beforeToPickleString.
        self.__stratExecConfigKey = stratExecConfig.key()
        self.__paramsIt = build_params_iterator(stratExecConfig)
        self.__tooManyErrosChecked = False
        self.__logger = logger.Logger()

    def beforeToPickleString(self):
        # Reset to avoid from getting pickled.
        self.__tooManyErrosChecked = False

    def isFinished(self):
        return self.__paramsIt.getCurrent() is None

    def getNextWorker(self):
        # Check if we need to abort executions.
        # We're doing this only once per MasterTask execution to avoid calling the db too much.
        if not self.__tooManyErrosChecked:
            self.__tooManyErrosChecked = True
            stratExecConfig = persistence.StratExecConfig.getByKey(self.__stratExecConfigKey)
            if stratExecConfig.status == persistence.StratExecConfig.Status.CANCELED_TOO_MANY_ERRORS:
                self.__logger.error("Dropping execution of '%s' due to too many errors" % (stratExecConfig.className))
                return None

        chunkSize = 1000  # Max executions per task.
        ret = None
        if not self.isFinished():
            # Clone self.__paramsIt before building WorkerTask because we'll modify it immediately.
            paramsIt = copy.deepcopy(self.__paramsIt)
            ret = WorkerTask(1, self.__stratExecConfigKey, paramsIt, chunkSize)

            # Advance parameters iterator for the next worker.
            for i in xrange(chunkSize):
                self.__paramsIt.moveNext()
        return ret


class WorkerTask(chanchero.tasks.WorkerTask):
    def __init__(self, taskId, stratExecConfigKey, paramsIt, chunkSize):
        chanchero.tasks.WorkerTask.__init__(self, taskId)
        # Everything that is defined here should be pickleable or reset in beforeToPickleString.
        self.__stratExecConfigKey = stratExecConfigKey
        self.__paramsIt = paramsIt
        self.__chunkSize = chunkSize
        self.__logger = logger.Logger()

    def run(self):
        global strategyExecutor

        taskTimer = timer.Timer()
        stratExecConfig = persistence.StratExecConfig.getByKey(self.__stratExecConfigKey)
        self.__logger.info("WorkerTask for '%s' starting from %s" % (stratExecConfig.className, str(self.__paramsIt.getCurrent())))

        maxTaskRunTime = 9 * 60  # Stop the task after 9 minutes to avoid getting interrupted after 10 minutes.
        bestResult = 0.0
        bestResultParams = []
        errors = 0
        executions = 0
        maxStratTime = 0

        while self.__chunkSize > 0:
            stratExecTimer = timer.Timer()
            try:
                paramValues = self.__paramsIt.getCurrent()
                # self.__logger.info("WorkerTask running '%s' with parameters: %s" % (stratExecConfig.className, paramValues))

                # If there are no more parameters, just stop.
                if paramValues is None:
                    break

                result = strategyExecutor.runStrategy(stratExecConfig, paramValues)
                if result > bestResult:
                    bestResult = result
                    bestResultParams = paramValues
            except Exception, e:
                errors += 1
                strategyExecutor.getLogger().error("Error executing strategy '%s' with parameters %s: %s" % (stratExecConfig.className, paramValues, e))
                strategyExecutor.getLogger().error(traceback.format_exc())

            maxStratTime = max(maxStratTime, stratExecTimer.secondsElapsed())
            executions += 1
            self.__chunkSize -= 1
            self.__paramsIt.moveNext()

            # Stop executing if we'll ran out of time with the next execution.
            if self.__chunkSize > 0 and taskTimer.secondsElapsed() + maxStratTime > maxTaskRunTime:
                break

        # Save the (potentially partial) results.
        ResultTask(1, self.__stratExecConfigKey, bestResult, bestResultParams, executions, errors).queue()

        # Reschedule ourselves if there is work left to do.
        if self.__chunkSize > 0 and self.__paramsIt.getCurrent() is not None:
            self.__logger.info("Rescheduling WorkerTask for '%s' after %d minutes. %d executions completed. Continuing from %s." % (stratExecConfig.className, taskTimer.minutesElapsed(), executions, self.__paramsIt.getCurrent()))
            self.queue()
        else:
            self.__logger.info("WorkerTask for '%s' finished after %d minutes. %d executions completed. Max strat runtime %d seconds." % (stratExecConfig.className, taskTimer.minutesElapsed(), executions, maxStratTime))


class ResultTask(chanchero.tasks.ResultTask):
    def __init__(self, taskId, stratExecConfigKey, result, paramValues, executions, errors):
        chanchero.tasks.ResultTask.__init__(self, taskId)
        # Everything that is defined here should be pickleable or reset in beforeToPickleString.
        self.__stratExecConfigKey = stratExecConfigKey
        self.__result = result
        self.__paramValues = paramValues
        self.__executions = executions
        self.__errors = errors

    def run(self):
        stratExecConfig = persistence.StratExecConfig.getByKey(self.__stratExecConfigKey)

        # Update best result.
        if stratExecConfig.bestResult is None or self.__result > stratExecConfig.bestResult:
            # Need to convert paramValues to a list before storing that.
            paramValues = [value for value in self.__paramValues]
            stratExecConfig.bestResult = self.__result
            stratExecConfig.bestResultParameters = paramValues

        stratExecConfig.executionsFinished += self.__executions
        stratExecConfig.errors += self.__errors
        if stratExecConfig.executionsFinished == stratExecConfig.totalExecutions:
            stratExecConfig.status = persistence.StratExecConfig.Status.FINISHED
        # If we got more that 1000 errors, cancel the strategy execution to avoid wasting resources.
        elif stratExecConfig.errors > 1000:
            stratExecConfig.status = persistence.StratExecConfig.Status.CANCELED_TOO_MANY_ERRORS

        stratExecConfig.put()

########NEW FILE########
__FILENAME__ = updateapp
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from optparse import OptionParser
import sys
import subprocess
import os
import shutil
import fileinput


def parse_cmdline():
    usage = "usage: %prog [options]"
    parser = OptionParser(usage=usage)
    parser.add_option("-i", "--app_id", dest="app_id", help="Google App Engine application identifier")
    parser.add_option("-a", "--app_path", dest="app_path", help="Directory where app.yaml resides")
    parser.add_option("-c", "--appcfg_path", dest="appcfg_path", help="Path where appcfg.py resides")
    mandatory_options = [
        "app_id",
        "app_path"
        ]

    (options, args) = parser.parse_args()

    # Check that all mandatory options are available.
    for opt in mandatory_options:
        if getattr(options, opt) is None:
            raise Exception("--%s option is missing" % opt)

    return (options, args)


class AppCfg:
    def __init__(self, appPath, appCfgPath):
        self.__appPath = appPath
        self.__appCfgPath = appCfgPath

    def updateApp(self):
        cmd = []
        if self.__appCfgPath:
            cmd.append(os.path.join(self.__appCfgPath, "appcfg.py"))
        else:
            cmd.append("appcfg.py")
        cmd.append("update")
        cmd.append(self.__appPath)

        popenObj = subprocess.Popen(args=cmd)
        popenObj.communicate()


def update_file(path, linePrefix, lineReplacement, expectedMatches):
    matches = 0
    print "Updating %s" % (path)
    for line in fileinput.input(path, inplace=1):
        line = line.strip("\r\n")
        if line.find(linePrefix) == 0:
            matches += 1
            print lineReplacement
        else:
            print line
    if matches != expectedMatches:
        raise Exception("Failed to update '%s' file. '%s' found %d times" % (path, linePrefix, matches))


def update_app_yaml(appPath, appId):
    appYamlPath = os.path.join(appPath, "app.yaml")
    linePrefix = "application:"
    update_file(appYamlPath, linePrefix, "application: %s" % appId, 1)


def update_pyalgotrade(appPath):
    srcPath = os.path.join(appPath, "..", "..", "pyalgotrade")
    dstPath = os.path.join(appPath, "pyalgotrade")

    if os.path.exists(dstPath):
        print "WARNING: %s already exists. Cleaning it up." % (dstPath)
        shutil.rmtree(dstPath)

    print "Preparing pyalgotrade package"
    shutil.copytree(srcPath, dstPath)

    update_file(os.path.join(dstPath, "execcontext.py"), "running_in_google_app_engine = ", "running_in_google_app_engine = True", 1)


def main():
    try:
        (options, args) = parse_cmdline()
        update_app_yaml(options.app_path, options.app_id)
        update_pyalgotrade(options.app_path)
        appCfg = AppCfg(options.app_path, options.appcfg_path)
        print "Updating application using appcfg.py"
        appCfg.updateApp()
    except Exception, e:
        sys.stdout.write("Error: %s\n" % e)
        sys.exit(1)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = uploadbars
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from optparse import OptionParser
import sys
import os
import tempfile
import hashlib
import subprocess

# Just in case pyalgotrade isn't installed.
uploadBarsPath = os.path.dirname(os.path.abspath(__file__))
sys.path.append(os.path.join(uploadBarsPath, "..", ".."))

from pyalgotrade.barfeed import yahoofeed


def get_md5(value):
    m = hashlib.md5()
    m.update(value)
    return m.hexdigest()


def datetimeToCSV(dateTime):
    return dateTime.strftime("%Y-%m-%dT%H:%M:%S")


def parse_cmdline():
    usage = "usage: %prog [options] csv1 csv2 ..."
    parser = OptionParser(usage=usage)
    parser.add_option("-i", "--instrument", dest="instrument", help="Mandatory. The instrument's symbol. Note that all csv files must belong to the same instrument.")
    parser.add_option("-u", "--url", dest="url", help="The location of the remote_api endpoint. Example: http://YOURAPPID.appspot.com/remote_api")
    parser.add_option("-c", "--appcfg_path", dest="appcfg_path", help="Path where appcfg.py resides")
    mandatory_options = [
        "instrument",
        "url",
        ]

    (options, args) = parser.parse_args()

    # Check that all mandatory options are available.
    for opt in mandatory_options:
        if getattr(options, opt) is None:
            raise Exception("--%s option is missing" % opt)

    if len(args) == 0:
        raise Exception("No csv files to upload")

    return (options, args)


def gen_bar_key(instrument, barType, bar):
    return get_md5("%s %d %s" % (instrument, barType, bar.getDateTime()))


def write_intermediate_csv(instrument, csvFiles, csvToUpload):
    csvToUpload.write("key,instrument,barType,dateTime,open_,close_,high,low,volume,adjClose\n")

    instrument = instrument.upper()
    barType = 1

    feed = yahoofeed.Feed()
    for csvFile in csvFiles:
        print "Loading bars from %s" % csvFile
        feed.addBarsFromCSV(instrument, csvFile)

    print "Writing intermediate csv into %s" % csvToUpload.name
    for dateTime, bars in feed:
        bar = bars[instrument]
        csvToUpload.write("%s,%s,%d,%s,%s,%s,%s,%s,%s,%s\n" % (
            gen_bar_key(instrument, barType, bar),
            instrument,
            barType,
            datetimeToCSV(bar.getDateTime()),
            bar.getOpen(),
            bar.getClose(),
            bar.getHigh(),
            bar.getLow(),
            bar.getVolume(),
            bar.getAdjClose()
            ))
    csvToUpload.flush()


def upload_intermediate_csv(options, csvPath):
    print "Uploading %s" % csvPath
    cmd = []
    if options.appcfg_path:
        cmd.append(os.path.join(options.appcfg_path, "appcfg.py"))
    else:
        cmd.append("appcfg.py")
    cmd.append("upload_data")
    cmd.append("--kind=Bar")
    cmd.append("--filename=%s" % csvPath)
    cmd.append("--config_file=%s" % os.path.join(uploadBarsPath, "bulkloader.yaml"))
    cmd.append("--url=%s" % options.url)
    cmd.append("--num_threads=1")

    popenObj = subprocess.Popen(args=cmd)
    popenObj.communicate()


def main():
    try:
        (options, args) = parse_cmdline()
        csvToUpload = tempfile.NamedTemporaryFile()
        write_intermediate_csv(options.instrument, args, csvToUpload)
        upload_intermediate_csv(options, csvToUpload.name)
    except Exception, e:
        sys.stdout.write("Error: %s\n" % e)
        sys.exit(1)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = bar
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import abc

from pyalgotrade import warninghelpers


class Frequency(object):
    """Enum like class for bar frequencies. Valid values are:

    * **Frequency.TRADE**: The bar represents a single trade.
    * **Frequency.SECOND**: The bar summarizes the trading activity during 1 second.
    * **Frequency.MINUTE**: The bar summarizes the trading activity during 1 minute.
    * **Frequency.HOUR**: The bar summarizes the trading activity during 1 hour.
    * **Frequency.DAY**: The bar summarizes the trading activity during 1 day.
    * **Frequency.WEEK**: The bar summarizes the trading activity during 1 week.
    """

    # It is important for frequency values to get bigger for bigger windows.
    TRADE = -1
    SECOND = 1
    MINUTE = 60
    HOUR = 60*60
    DAY = 24*60*60
    WEEK = 24*60*60*7


class Bar(object):
    """A Bar is a summary of the trading activity for a security in a given period.

    .. note::
        This is a base class and should not be used directly.
    """

    __metaclass__ = abc.ABCMeta

    @abc.abstractmethod
    def setUseAdjustedValue(self, useAdjusted):
        raise NotImplementedError()

    @abc.abstractmethod
    def getDateTime(self):
        """Returns the :class:`datetime.datetime`."""
        raise NotImplementedError()

    @abc.abstractmethod
    def getOpen(self, adjusted=False):
        """Returns the opening price."""
        raise NotImplementedError()

    @abc.abstractmethod
    def getHigh(self, adjusted=False):
        """Returns the highest price."""
        raise NotImplementedError()

    @abc.abstractmethod
    def getLow(self, adjusted=False):
        """Returns the lowest price."""
        raise NotImplementedError()

    @abc.abstractmethod
    def getClose(self, adjusted=False):
        """Returns the closing price."""
        raise NotImplementedError()

    @abc.abstractmethod
    def getVolume(self):
        """Returns the volume."""
        raise NotImplementedError()

    @abc.abstractmethod
    def getAdjClose(self):
        """Returns the adjusted closing price."""
        raise NotImplementedError()

    @abc.abstractmethod
    def getFrequency(self):
        """The bar's period."""
        raise NotImplementedError()

    def getTypicalPrice(self):
        """Returns the typical price."""
        return (self.getHigh() + self.getLow() + self.getClose()) / 3.0

    @abc.abstractmethod
    def getPrice(self):
        """Returns the closing or adjusted closing price."""
        raise NotImplementedError()


class BasicBar(Bar):
    # Optimization to reduce memory footprint.
    __slots__ = ('__dateTime', '__open', '__close', '__high', '__low', '__volume', '__adjClose', '__frequency', '__useAdjustedValue')

    def __init__(self, dateTime, open_, high, low, close, volume, adjClose, frequency):
        if high < low:
            raise Exception("high < low on %s" % (dateTime))
        elif high < open_:
            raise Exception("high < open on %s" % (dateTime))
        elif high < close:
            raise Exception("high < close on %s" % (dateTime))
        elif low > open_:
            raise Exception("low > open on %s" % (dateTime))
        elif low > close:
            raise Exception("low > close on %s" % (dateTime))

        self.__dateTime = dateTime
        self.__open = open_
        self.__close = close
        self.__high = high
        self.__low = low
        self.__volume = volume
        self.__adjClose = adjClose
        self.__frequency = frequency
        self.__useAdjustedValue = False

    def __setstate__(self, state):
        (self.__dateTime, self.__open, self.__close, self.__high, self.__low, self.__volume, self.__adjClose, self.__frequency, self.__useAdjustedValue) = state

    def __getstate__(self):
        return (self.__dateTime, self.__open, self.__close, self.__high, self.__low, self.__volume, self.__adjClose, self.__frequency, self.__useAdjustedValue)

    def setUseAdjustedValue(self, useAdjusted):
        if useAdjusted and self.__adjClose is None:
            raise Exception("Adjusted close is not available")
        self.__useAdjustedValue = useAdjusted

    def getDateTime(self):
        return self.__dateTime

    def getOpen(self, adjusted=False):
        if adjusted:
            if self.__adjClose is None:
                raise Exception("Adjusted close is missing")
            return self.__adjClose * self.__open / float(self.__close)
        else:
            return self.__open

    def getHigh(self, adjusted=False):
        if adjusted:
            if self.__adjClose is None:
                raise Exception("Adjusted close is missing")
            return self.__adjClose * self.__high / float(self.__close)
        else:
            return self.__high

    def getLow(self, adjusted=False):
        if adjusted:
            if self.__adjClose is None:
                raise Exception("Adjusted close is missing")
            return self.__adjClose * self.__low / float(self.__close)
        else:
            return self.__low

    def getClose(self, adjusted=False):
        if adjusted:
            if self.__adjClose is None:
                raise Exception("Adjusted close is missing")
            return self.__adjClose
        else:
            return self.__close

    def getVolume(self):
        return self.__volume

    def getAdjOpen(self):
        # Deprecated in 0.15
        warninghelpers.deprecation_warning("The getAdjOpen method will be deprecated in the next version. Please use the getOpen(True) instead.", stacklevel=2)
        return self.getOpen(True)

    def getAdjHigh(self):
        # Deprecated in 0.15
        warninghelpers.deprecation_warning("The getAdjHigh method will be deprecated in the next version. Please use the getHigh(True) instead.", stacklevel=2)
        return self.getHigh(True)

    def getAdjLow(self):
        # Deprecated in 0.15
        warninghelpers.deprecation_warning("The getAdjLow method will be deprecated in the next version. Please use the getLow(True) instead.", stacklevel=2)
        return self.getLow(True)

    def getAdjClose(self):
        return self.__adjClose

    def getFrequency(self):
        return self.__frequency

    def getPrice(self):
        if self.__useAdjustedValue:
            return self.__adjClose
        else:
            return self.__close


class Bars(object):
    """A group of :class:`Bar` objects.

    :param barDict: A map of instrument to :class:`Bar` objects.
    :type barDict: map.

    .. note::
        All bars must have the same datetime.
    """
    def __init__(self, barDict):
        if len(barDict) == 0:
            raise Exception("No bars supplied")

        # Check that bar datetimes are in sync
        firstDateTime = None
        firstInstrument = None
        for instrument, currentBar in barDict.iteritems():
            if firstDateTime is None:
                firstDateTime = currentBar.getDateTime()
                firstInstrument = instrument
            elif currentBar.getDateTime() != firstDateTime:
                raise Exception("Bar data times are not in sync. %s %s != %s %s" % (instrument, currentBar.getDateTime(), firstInstrument, firstDateTime))

        self.__barDict = barDict
        self.__dateTime = firstDateTime

    def __getitem__(self, instrument):
        """Returns the :class:`pyalgotrade.bar.Bar` for the given instrument. If the instrument is not found an exception is raised."""
        return self.__barDict[instrument]

    def __contains__(self, instrument):
        """Returns True if a :class:`pyalgotrade.bar.Bar` for the given instrument is available."""
        return instrument in self.__barDict

    def items(self):
        return self.__barDict.items()

    def keys(self):
        return self.__barDict.keys()

    def getInstruments(self):
        """Returns the instrument symbols."""
        return self.__barDict.keys()

    def getDateTime(self):
        """Returns the :class:`datetime.datetime` for this set of bars."""
        return self.__dateTime

    def getBar(self, instrument):
        """Returns the :class:`pyalgotrade.bar.Bar` for the given instrument or None if the instrument is not found."""
        return self.__barDict.get(instrument, None)

########NEW FILE########
__FILENAME__ = csvfeed
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade.utils import dt
from pyalgotrade.utils import csvutils
from pyalgotrade.barfeed import membf
from pyalgotrade import dataseries
from pyalgotrade import bar

import datetime
import pytz


# Interface for csv row parsers.
class RowParser(object):
    def parseBar(self, csvRowDict):
        raise NotImplementedError()

    def getFieldNames(self):
        raise NotImplementedError()

    def getDelimiter(self):
        raise NotImplementedError()


# Interface for bar filters.
class BarFilter(object):
    def includeBar(self, bar_):
        raise NotImplementedError()


class DateRangeFilter(BarFilter):
    def __init__(self, fromDate=None, toDate=None):
        self.__fromDate = fromDate
        self.__toDate = toDate

    def includeBar(self, bar_):
        if self.__toDate and bar_.getDateTime() > self.__toDate:
            return False
        if self.__fromDate and bar_.getDateTime() < self.__fromDate:
            return False
        return True


# US Equities Regular Trading Hours filter
# Monday ~ Friday
# 9:30 ~ 16 (GMT-5)
class USEquitiesRTH(DateRangeFilter):
    timezone = pytz.timezone("US/Eastern")

    def __init__(self, fromDate=None, toDate=None):
        DateRangeFilter.__init__(self, fromDate, toDate)

        self.__fromTime = datetime.time(9, 30, 0)
        self.__toTime = datetime.time(16, 0, 0)

    def includeBar(self, bar_):
        ret = DateRangeFilter.includeBar(self, bar_)
        if ret:
            # Check day of week
            barDay = bar_.getDateTime().weekday()
            if barDay > 4:
                return False

            # Check time
            barTime = dt.localize(bar_.getDateTime(), USEquitiesRTH.timezone).time()
            if barTime < self.__fromTime:
                return False
            if barTime > self.__toTime:
                return False
        return ret


class BarFeed(membf.BarFeed):
    """Base class for CSV file based :class:`pyalgotrade.barfeed.BarFeed`.

    .. note::
        This is a base class and should not be used directly.
    """

    def __init__(self, frequency, maxLen=dataseries.DEFAULT_MAX_LEN):
        membf.BarFeed.__init__(self, frequency, maxLen)
        self.__barFilter = None
        self.__dailyTime = datetime.time(0, 0, 0)

    def getDailyBarTime(self):
        return self.__dailyTime

    def setDailyBarTime(self, time):
        self.__dailyTime = time

    def getBarFilter(self):
        return self.__barFilter

    def setBarFilter(self, barFilter):
        self.__barFilter = barFilter

    def addBarsFromCSV(self, instrument, path, rowParser):
        # Load the csv file
        loadedBars = []
        reader = csvutils.FastDictReader(open(path, "r"), fieldnames=rowParser.getFieldNames(), delimiter=rowParser.getDelimiter())
        for row in reader:
            bar_ = rowParser.parseBar(row)
            if bar_ is not None and (self.__barFilter is None or self.__barFilter.includeBar(bar_)):
                loadedBars.append(bar_)

        self.addBarsFromSequence(instrument, loadedBars)


class GenericRowParser(RowParser):
    def __init__(self, columnNames, dateTimeFormat, dailyBarTime, frequency, timezone):
        self.__dateTimeFormat = dateTimeFormat
        self.__dailyBarTime = dailyBarTime
        self.__frequency = frequency
        self.__timezone = timezone
        self.__haveAdjClose = False
        # Column names.
        self.__dateTimeColName = columnNames["datetime"]
        self.__openColName = columnNames["open"]
        self.__highColName = columnNames["high"]
        self.__lowColName = columnNames["low"]
        self.__closeColName = columnNames["close"]
        self.__volumeColName = columnNames["volume"]
        self.__adjCloseColName = columnNames["adj_close"]

    def _parseDate(self, dateString):
        ret = datetime.datetime.strptime(dateString, self.__dateTimeFormat)

        if self.__dailyBarTime is not None:
            ret = datetime.datetime.combine(ret, self.__dailyBarTime)
        # Localize the datetime if a timezone was given.
        if self.__timezone:
            ret = dt.localize(ret, self.__timezone)
        return ret

    def barsHaveAdjClose(self):
        return self.__haveAdjClose

    def getFieldNames(self):
        # It is expected for the first row to have the field names.
        return None

    def getDelimiter(self):
        return ","

    def parseBar(self, csvRowDict):
        dateTime = self._parseDate(csvRowDict[self.__dateTimeColName])
        open_ = float(csvRowDict[self.__openColName])
        high = float(csvRowDict[self.__highColName])
        low = float(csvRowDict[self.__lowColName])
        close = float(csvRowDict[self.__closeColName])
        volume = float(csvRowDict[self.__volumeColName])
        adjClose = None
        if self.__adjCloseColName is not None:
            adjCloseValue = csvRowDict.get(self.__adjCloseColName, "")
            if len(adjCloseValue) > 0:
                adjClose = float(adjCloseValue)
                self.__haveAdjClose = True
        return bar.BasicBar(dateTime, open_, high, low, close, volume, adjClose, self.__frequency)


class GenericBarFeed(BarFeed):
    """A BarFeed that loads bars from CSV files that have the following format:
    ::

        Date Time,Open,High,Low,Close,Volume,Adj Close
        2013-01-01 13:59:00,13.51001,13.56,13.51,13.56,273.88014126,13.51001

    :param frequency: The frequency of the bars. Check :class:`pyalgotrade.bar.Frequency`.
    :param timezone: The default timezone to use to localize bars. Check :mod:`pyalgotrade.marketsession`.
    :type timezone: A pytz timezone.
    :param maxLen: The maximum number of values that the :class:`pyalgotrade.dataseries.bards.BarDataSeries` will hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.

    .. note::
        * The CSV file **must** have the column names in the first row.
        * It is ok if the **Adj Close** column is empty.
        * When working with multiple instruments:

         * If all the instruments loaded are in the same timezone, then the timezone parameter may not be specified.
         * If any of the instruments loaded are in different timezones, then the timezone parameter should be set.
    """

    def __init__(self, frequency, timezone=None, maxLen=dataseries.DEFAULT_MAX_LEN):
        BarFeed.__init__(self, frequency, maxLen)
        self.__timezone = timezone
        # Assume bars don't have adjusted close. This will be set to True after
        # loading the first file if the adj_close column is there.
        self.__haveAdjClose = False

        self.__dateTimeFormat = "%Y-%m-%d %H:%M:%S"
        self.__columnNames = {
            "datetime": "Date Time",
            "open": "Open",
            "high": "High",
            "low": "Low",
            "close": "Close",
            "volume": "Volume",
            "adj_close": "Adj Close",
        }
        # self.__dateTimeFormat expects time to be set so there is no need to
        # fix time.
        self.setDailyBarTime(None)

    def barsHaveAdjClose(self):
        return self.__haveAdjClose

    def setNoAdjClose(self):
        self.__columnNames["adj_close"] = None
        self.__haveAdjClose = False

    def setColumnName(self, col, name):
        self.__columnNames[col] = name

    def setDateTimeFormat(self, dateTimeFormat):
        self.__dateTimeFormat = dateTimeFormat

    def addBarsFromCSV(self, instrument, path, timezone=None):
        """Loads bars for a given instrument from a CSV formatted file.
        The instrument gets registered in the bar feed.

        :param instrument: Instrument identifier.
        :type instrument: string.
        :param path: The path to the CSV file.
        :type path: string.
        :param timezone: The timezone to use to localize bars. Check :mod:`pyalgotrade.marketsession`.
        :type timezone: A pytz timezone.
        """

        if timezone is None:
            timezone = self.__timezone

        rowParser = GenericRowParser(self.__columnNames, self.__dateTimeFormat, self.getDailyBarTime(), self.getFrequency(), timezone)
        BarFeed.addBarsFromCSV(self, instrument, path, rowParser)

        if rowParser.barsHaveAdjClose():
            self.__haveAdjClose = True
        elif self.__haveAdjClose:
            raise Exception("Previous bars had adjusted close and these ones don't have.")

########NEW FILE########
__FILENAME__ = dbfeed
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""


class Database(object):
    def addBars(self, bars, frequency):
        for instrument in bars.getInstruments():
            bar = bars.getBar(instrument)
            self.addBar(instrument, bar, frequency)

    def addBarsFromFeed(self, feed):
        for dateTime, bars in feed:
            if bars:
                self.addBars(bars, feed.getFrequency())

    def addBar(self, instrument, bar, frequency):
        raise NotImplementedError()

    def getBars(self, instrument, frequency, timezone=None, fromDateTime=None, toDateTime=None):
        raise NotImplementedError()

########NEW FILE########
__FILENAME__ = membf
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import barfeed
from pyalgotrade import dataseries
from pyalgotrade import bar
from pyalgotrade import utils


# A non real-time BarFeed responsible for:
# - Holding bars in memory.
# - Aligning them with respect to time.
#
# Subclasses should:
# - Forward the call to start() if they override it.

class BarFeed(barfeed.BaseBarFeed):
    def __init__(self, frequency, maxLen=dataseries.DEFAULT_MAX_LEN):
        barfeed.BaseBarFeed.__init__(self, frequency, maxLen)
        self.__bars = {}
        self.__nextPos = {}
        self.__started = False
        self.__currDateTime = None

    def getCurrentDateTime(self):
        return self.__currDateTime

    def isRealTime(self):
        return False

    def start(self):
        self.__started = True

    def stop(self):
        pass

    def join(self):
        pass

    def addBarsFromSequence(self, instrument, bars):
        if self.__started:
            raise Exception("Can't add more bars once you started consuming bars")

        self.__bars.setdefault(instrument, [])
        self.__nextPos.setdefault(instrument, 0)

        # Add and sort the bars
        self.__bars[instrument].extend(bars)
        barCmp = lambda x, y: cmp(x.getDateTime(), y.getDateTime())
        self.__bars[instrument].sort(barCmp)

        self.registerInstrument(instrument)

    def eof(self):
        ret = True
        # Check if there is at least one more bar to return.
        for instrument, bars in self.__bars.iteritems():
            nextPos = self.__nextPos[instrument]
            if nextPos < len(bars):
                ret = False
                break
        return ret

    def peekDateTime(self):
        ret = None

        for instrument, bars in self.__bars.iteritems():
            nextPos = self.__nextPos[instrument]
            if nextPos < len(bars):
                ret = utils.safe_min(ret, bars[nextPos].getDateTime())
        return ret

    def getNextBars(self):
        # All bars must have the same datetime. We will return all the ones with the smallest datetime.
        smallestDateTime = self.peekDateTime()

        if smallestDateTime is None:
            return None

        # Make a second pass to get all the bars that had the smallest datetime.
        ret = {}
        for instrument, bars in self.__bars.iteritems():
            nextPos = self.__nextPos[instrument]
            if nextPos < len(bars) and bars[nextPos].getDateTime() == smallestDateTime:
                ret[instrument] = bars[nextPos]
                self.__nextPos[instrument] += 1

        if self.__currDateTime == smallestDateTime:
            raise Exception("Duplicate bars found for %s on %s" % (ret.keys(), smallestDateTime))

        self.__currDateTime = smallestDateTime
        return bar.Bars(ret)

    def loadAll(self):
        for dateTime, bars in self:
            pass

########NEW FILE########
__FILENAME__ = ninjatraderfeed
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import pyalgotrade.barfeed
from pyalgotrade.barfeed import csvfeed
from pyalgotrade import bar
from pyalgotrade import dataseries
from pyalgotrade.utils import dt

import pytz

import datetime


######################################################################
## NinjaTrader CSV parser
# Each bar must be on its own line and fields must be separated by semicolon (;).
#
# Minute Bars Format:
# yyyyMMdd HHmmss;open price;high price;low price;close price;volume
#
# Daily Bars Format:
# yyyyMMdd;open price;high price;low price;close price;volume
#
# The exported data will be in the UTC time zone.

def parse_datetime(dateTime):
    # Sample: 20081231 230600
    # This custom parsing works faster than:
    # datetime.datetime.strptime(dateTime, "%Y%m%d %H%M%S")
    year = int(dateTime[0:4])
    month = int(dateTime[4:6])
    day = int(dateTime[6:8])
    hour = int(dateTime[9:11])
    minute = int(dateTime[11:13])
    sec = int(dateTime[13:15])
    return datetime.datetime(year, month, day, hour, minute, sec)


class Frequency(object):
    MINUTE = pyalgotrade.bar.Frequency.MINUTE
    DAILY = pyalgotrade.bar.Frequency.DAY


class RowParser(csvfeed.RowParser):
    def __init__(self, frequency, dailyBarTime, timezone=None):
        self.__frequency = frequency
        self.__dailyBarTime = dailyBarTime
        self.__timezone = timezone

    def __parseDateTime(self, dateTime):
        ret = None
        if self.__frequency == pyalgotrade.bar.Frequency.MINUTE:
            ret = parse_datetime(dateTime)
        elif self.__frequency == pyalgotrade.bar.Frequency.DAY:
            ret = datetime.datetime.strptime(dateTime, "%Y%m%d")
            # Time on CSV files is empty. If told to set one, do it.
            if self.__dailyBarTime is not None:
                ret = datetime.datetime.combine(ret, self.__dailyBarTime)
        else:
            assert(False)

        # According to NinjaTrader documentation the exported data will be in UTC.
        ret = pytz.utc.localize(ret)

        # Localize bars if a market session was set.
        if self.__timezone:
            ret = dt.localize(ret, self.__timezone)
        return ret

    def getFieldNames(self):
        return ["Date Time", "Open", "High", "Low", "Close", "Volume"]

    def getDelimiter(self):
        return ";"

    def parseBar(self, csvRowDict):
        dateTime = self.__parseDateTime(csvRowDict["Date Time"])
        close = float(csvRowDict["Close"])
        open_ = float(csvRowDict["Open"])
        high = float(csvRowDict["High"])
        low = float(csvRowDict["Low"])
        volume = float(csvRowDict["Volume"])
        return bar.BasicBar(dateTime, open_, high, low, close, volume, None, self.__frequency)


class Feed(csvfeed.BarFeed):
    """A :class:`pyalgotrade.barfeed.csvfeed.BarFeed` that loads bars from CSV files exported from NinjaTrader.

    :param frequency: The frequency of the bars. Only **pyalgotrade.bar.Frequency.MINUTE** or **pyalgotrade.bar.Frequency.DAY**
        are supported.
    :param timezone: The default timezone to use to localize bars. Check :mod:`pyalgotrade.marketsession`.
    :type timezone: A pytz timezone.
    :param maxLen: The maximum number of values that the :class:`pyalgotrade.dataseries.bards.BarDataSeries` will hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, frequency, timezone=None, maxLen=dataseries.DEFAULT_MAX_LEN):
        if isinstance(timezone, int):
            raise Exception("timezone as an int parameter is not supported anymore. Please use a pytz timezone instead.")

        if frequency not in [bar.Frequency.MINUTE, bar.Frequency.DAY]:
            raise Exception("Invalid frequency.")

        csvfeed.BarFeed.__init__(self, frequency, maxLen)
        self.__timezone = timezone

    def barsHaveAdjClose(self):
        return False

    def addBarsFromCSV(self, instrument, path, timezone=None):
        """Loads bars for a given instrument from a CSV formatted file.
        The instrument gets registered in the bar feed.

        :param instrument: Instrument identifier.
        :type instrument: string.
        :param path: The path to the file.
        :type path: string.
        :param timezone: The timezone to use to localize bars. Check :mod:`pyalgotrade.marketsession`.
        :type timezone: A pytz timezone.
        """

        if isinstance(timezone, int):
            raise Exception("timezone as an int parameter is not supported anymore. Please use a pytz timezone instead.")

        if timezone is None:
            timezone = self.__timezone

        rowParser = RowParser(self.getFrequency(), self.getDailyBarTime(), timezone)
        csvfeed.BarFeed.addBarsFromCSV(self, instrument, path, rowParser)

########NEW FILE########
__FILENAME__ = quandlfeed
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade.barfeed import csvfeed
from pyalgotrade import bar
from pyalgotrade import dataseries


class Feed(csvfeed.GenericBarFeed):
    """A :class:`pyalgotrade.barfeed.csvfeed.BarFeed` that loads bars from CSV files downloaded from Quandl.

    :param frequency: The frequency of the bars. Only **pyalgotrade.bar.Frequency.DAY** or **pyalgotrade.bar.Frequency.WEEK**
        are supported.
    :param timezone: The default timezone to use to localize bars. Check :mod:`pyalgotrade.marketsession`.
    :type timezone: A pytz timezone.
    :param maxLen: The maximum number of values that the :class:`pyalgotrade.dataseries.bards.BarDataSeries` will hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.

    .. note::
        When working with multiple instruments:

            * If all the instruments loaded are in the same timezone, then the timezone parameter may not be specified.
            * If any of the instruments loaded are in different timezones, then the timezone parameter must be set.
    """

    def __init__(self, frequency=bar.Frequency.DAY, timezone=None, maxLen=dataseries.DEFAULT_MAX_LEN):
        if frequency not in [bar.Frequency.DAY, bar.Frequency.WEEK]:
            raise Exception("Invalid frequency.")

        csvfeed.GenericBarFeed.__init__(self, frequency, timezone, maxLen)

        self.setDateTimeFormat("%Y-%m-%d")
        self.setColumnName("datetime", "Date")
        self.setColumnName("adj_close", "Adj. Close")

########NEW FILE########
__FILENAME__ = sqlitefeed
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade.barfeed import dbfeed
from pyalgotrade.barfeed import membf
from pyalgotrade import bar
from pyalgotrade import dataseries
from pyalgotrade.utils import dt

import sqlite3
import os


def normalize_instrument(instrument):
    return instrument.upper()


# SQLite DB.
# Timestamps are stored in UTC.
class Database(dbfeed.Database):
    def __init__(self, dbFilePath):
        self.__instrumentIds = {}

        # If the file doesn't exist, we'll create it and initialize it.
        initialize = False
        if not os.path.exists(dbFilePath):
            initialize = True
        self.__connection = sqlite3.connect(dbFilePath)
        self.__connection.isolation_level = None  # To do auto-commit
        if initialize:
            self.createSchema()

    def __findInstrumentId(self, instrument):
        cursor = self.__connection.cursor()
        sql = "select instrument_id from instrument where name = ?"
        cursor.execute(sql, [instrument])
        ret = cursor.fetchone()
        if ret is not None:
            ret = ret[0]
        cursor.close()
        return ret

    def __addInstrument(self, instrument):
        ret = self.__connection.execute("insert into instrument (name) values (?)", [instrument])
        return ret.lastrowid

    def __getOrCreateInstrument(self, instrument):
        # Try to get the instrument id from the cache.
        ret = self.__instrumentIds.get(instrument, None)
        if ret is not None:
            return ret
        # If its not cached, get it from the db.
        ret = self.__findInstrumentId(instrument)
        # If its not in the db, add it.
        if ret is None:
            ret = self.__addInstrument(instrument)
        # Cache the id.
        self.__instrumentIds[instrument] = ret
        return ret

    def createSchema(self):
        self.__connection.execute(
            "create table instrument ("
            "instrument_id integer primary key autoincrement"
            ", name text unique not null)")

        self.__connection.execute(
            "create table bar ("
            "instrument_id integer references instrument (instrument_id)"
            ", frequency integer not null"
            ", timestamp integer not null"
            ", open real not null"
            ", high real not null"
            ", low real not null"
            ", close real not null"
            ", volume real not null"
            ", adj_close real"
            ", primary key (instrument_id, frequency, timestamp))")

    def addBar(self, instrument, bar, frequency):
        instrument = normalize_instrument(instrument)
        instrumentId = self.__getOrCreateInstrument(instrument)
        timeStamp = dt.datetime_to_timestamp(bar.getDateTime())

        try:
            sql = "insert into bar (instrument_id, frequency, timestamp, open, high, low, close, volume, adj_close) values (?, ?, ?, ?, ?, ?, ?, ?, ?)"
            params = [instrumentId, frequency, timeStamp, bar.getOpen(), bar.getHigh(), bar.getLow(), bar.getClose(), bar.getVolume(), bar.getAdjClose()]
            self.__connection.execute(sql, params)
        except sqlite3.IntegrityError:
            sql = "update bar set open = ?, high = ?, low = ?, close = ?, volume = ?, adj_close = ?" \
                " where instrument_id = ? and frequency = ? and timestamp = ?"
            params = [bar.getOpen(), bar.getHigh(), bar.getLow(), bar.getClose(), bar.getVolume(), bar.getAdjClose(), instrumentId, frequency, timeStamp]
            self.__connection.execute(sql, params)

    def getBars(self, instrument, frequency, timezone=None, fromDateTime=None, toDateTime=None):
        instrument = normalize_instrument(instrument)
        sql = "select bar.timestamp, bar.open, bar.high, bar.low, bar.close, bar.volume, bar.adj_close, bar.frequency" \
            " from bar join instrument on (bar.instrument_id = instrument.instrument_id)" \
            " where instrument.name = ? and bar.frequency = ?"
        args = [instrument, frequency]

        if fromDateTime is not None:
            sql += " and bar.timestamp >= ?"
            args.append(dt.datetime_to_timestamp(fromDateTime))
        if toDateTime is not None:
            sql += " and bar.timestamp <= ?"
            args.append(dt.datetime_to_timestamp(toDateTime))

        sql += " order by bar.timestamp asc"
        cursor = self.__connection.cursor()
        cursor.execute(sql, args)
        ret = []
        for row in cursor:
            dateTime = dt.timestamp_to_datetime(row[0])
            if timezone:
                dateTime = dt.localize(dateTime, timezone)
            ret.append(bar.BasicBar(dateTime, row[1], row[2], row[3], row[4], row[5], row[6], row[7]))
        cursor.close()
        return ret

    def disconnect(self):
        self.__connection.close()
        self.__connection = None


class Feed(membf.BarFeed):
    def __init__(self, dbFilePath, frequency, maxLen=dataseries.DEFAULT_MAX_LEN):
        membf.BarFeed.__init__(self, frequency, maxLen)
        self.__db = Database(dbFilePath)

    def barsHaveAdjClose(self):
        return True

    def getDatabase(self):
        return self.__db

    def loadBars(self, instrument, timezone=None, fromDateTime=None, toDateTime=None):
        bars = self.__db.getBars(instrument, self.getFrequency(), timezone, fromDateTime, toDateTime)
        self.addBarsFromSequence(instrument, bars)

########NEW FILE########
__FILENAME__ = yahoofeed
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade.barfeed import csvfeed
from pyalgotrade.utils import dt
from pyalgotrade import bar
from pyalgotrade import dataseries

import datetime


######################################################################
## Yahoo Finance CSV parser
# Each bar must be on its own line and fields must be separated by comma (,).
#
# Bars Format:
# Date,Open,High,Low,Close,Volume,Adj Close
#
# The csv Date column must have the following format: YYYY-MM-DD

def parse_date(date):
    # Sample: 2005-12-30
    # This custom parsing works faster than:
    # datetime.datetime.strptime(date, "%Y-%m-%d")
    year = int(date[0:4])
    month = int(date[5:7])
    day = int(date[8:10])
    ret = datetime.datetime(year, month, day)
    return ret


class RowParser(csvfeed.RowParser):
    def __init__(self, dailyBarTime, frequency, timezone=None, sanitize=False):
        self.__dailyBarTime = dailyBarTime
        self.__frequency = frequency
        self.__timezone = timezone
        self.__sanitize = sanitize

    def __parseDate(self, dateString):
        ret = parse_date(dateString)
        # Time on Yahoo! Finance CSV files is empty. If told to set one, do it.
        if self.__dailyBarTime is not None:
            ret = datetime.datetime.combine(ret, self.__dailyBarTime)
        # Localize the datetime if a timezone was given.
        if self.__timezone:
            ret = dt.localize(ret, self.__timezone)
        return ret

    def getFieldNames(self):
        # It is expected for the first row to have the field names.
        return None

    def getDelimiter(self):
        return ","

    def parseBar(self, csvRowDict):
        dateTime = self.__parseDate(csvRowDict["Date"])
        close = float(csvRowDict["Close"])
        open_ = float(csvRowDict["Open"])
        high = float(csvRowDict["High"])
        low = float(csvRowDict["Low"])
        volume = float(csvRowDict["Volume"])
        adjClose = float(csvRowDict["Adj Close"])

        if self.__sanitize:
            if low > open_:
                low = open_
            if low > close:
                low = close
            if high < open_:
                high = open_
            if high < close:
                high = close

        return bar.BasicBar(dateTime, open_, high, low, close, volume, adjClose, self.__frequency)


class Feed(csvfeed.BarFeed):
    """A :class:`pyalgotrade.barfeed.csvfeed.BarFeed` that loads bars from CSV files downloaded from Yahoo! Finance.

    :param frequency: The frequency of the bars. Only **pyalgotrade.bar.Frequency.DAY** or **pyalgotrade.bar.Frequency.WEEK**
        are supported.
    :param timezone: The default timezone to use to localize bars. Check :mod:`pyalgotrade.marketsession`.
    :type timezone: A pytz timezone.
    :param maxLen: The maximum number of values that the :class:`pyalgotrade.dataseries.bards.BarDataSeries` will hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.

    .. note::
        Yahoo! Finance csv files lack timezone information.
        When working with multiple instruments:

            * If all the instruments loaded are in the same timezone, then the timezone parameter may not be specified.
            * If any of the instruments loaded are in different timezones, then the timezone parameter must be set.
    """

    def __init__(self, frequency=bar.Frequency.DAY, timezone=None, maxLen=dataseries.DEFAULT_MAX_LEN):
        if isinstance(timezone, int):
            raise Exception("timezone as an int parameter is not supported anymore. Please use a pytz timezone instead.")

        if frequency not in [bar.Frequency.DAY, bar.Frequency.WEEK]:
            raise Exception("Invalid frequency.")

        csvfeed.BarFeed.__init__(self, frequency, maxLen)
        self.__timezone = timezone
        self.__sanitizeBars = False

    def sanitizeBars(self, sanitize):
        self.__sanitizeBars = sanitize

    def barsHaveAdjClose(self):
        return True

    def addBarsFromCSV(self, instrument, path, timezone=None):
        """Loads bars for a given instrument from a CSV formatted file.
        The instrument gets registered in the bar feed.

        :param instrument: Instrument identifier.
        :type instrument: string.
        :param path: The path to the CSV file.
        :type path: string.
        :param timezone: The timezone to use to localize bars. Check :mod:`pyalgotrade.marketsession`.
        :type timezone: A pytz timezone.
        """

        if isinstance(timezone, int):
            raise Exception("timezone as an int parameter is not supported anymore. Please use a pytz timezone instead.")

        if timezone is None:
            timezone = self.__timezone

        rowParser = RowParser(self.getDailyBarTime(), self.getFrequency(), timezone, self.__sanitizeBars)
        csvfeed.BarFeed.addBarsFromCSV(self, instrument, path, rowParser)

########NEW FILE########
__FILENAME__ = barfeed
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import barfeed
from pyalgotrade import bar
from pyalgotrade.barfeed import csvfeed
from pyalgotrade import dataseries
from pyalgotrade.utils import dt

import datetime


def to_utc_if_naive(dateTime):
    if dateTime is not None and dt.datetime_is_naive(dateTime):
        dateTime = dt.as_utc(dateTime)
    return dateTime


class TradeBar(bar.Bar):
    # Optimization to reduce memory footprint.
    __slots__ = ('__dateTime', '__price', '__amount')

    def __init__(self, dateTime, price, amount):
        self.__dateTime = dateTime
        self.__price = price
        self.__amount = amount

    def __setstate__(self, state):
        (self.__dateTime, self.__price, self.__amount) = state

    def __getstate__(self):
        return (self.__dateTime, self.__price, self.__amount)

    def setUseAdjustedValue(self, useAdjusted):
        if useAdjusted:
            raise Exception("Adjusted close is not available")

    def getDateTime(self):
        return self.__dateTime

    def getOpen(self, adjusted=False):
        return self.__price

    def getHigh(self, adjusted=False):
        return self.__price

    def getLow(self, adjusted=False):
        return self.__price

    def getClose(self, adjusted=False):
        return self.__price

    def getVolume(self):
        return self.__amount

    def getAdjClose(self):
        return None

    def getFrequency(self):
        return bar.Frequency.TRADE

    def getPrice(self):
        return self.__price

# As described in http://www.bitcoincharts.com/about/markets-api/
# unixtime has second precision so more than 1 trade in a second will trigger
# duplicate bars checks.
class UnixTimeFix(object):
    def __init__(self):
        self.__lastDateTime = None
        self.__nextFix = 1

    def fixDateTime(self, dateTime):
        ret = dateTime
        if dateTime == self.__lastDateTime:
            ret = dateTime + datetime.timedelta(microseconds=self.__nextFix)
            self.__nextFix += 1
        else:
            # Reset self.__nextFix
            self.__nextFix = 1
        self.__lastDateTime = dateTime
        return ret


class RowParser(csvfeed.RowParser):
    def __init__(self, unixTimeFix, timezone=None):
        self.__unixTimeFix = unixTimeFix
        self.__timezone = timezone

    def parseBar(self, csvRowDict):
        unixTime = int(csvRowDict["unixtime"])
        price = float(csvRowDict["price"])
        amount = float(csvRowDict["amount"])

        dateTime = dt.timestamp_to_datetime(unixTime)
        dateTime = self.__unixTimeFix.fixDateTime(dateTime)

        # Localize the datetime if a timezone was given.
        if self.__timezone:
            dateTime = dt.localize(dateTime, self.__timezone)

        return TradeBar(dateTime, price, amount)

    def getFieldNames(self):
        return ["unixtime", "price", "amount"]

    def getDelimiter(self):
        return ","


class CSVTradeFeed(csvfeed.BarFeed):
    """A BarFeed that builds bars from a Historic Trade Data CSV file as described in http://www.bitcoincharts.com/about/markets-api/.
    Files can be downloaded from http://api.bitcoincharts.com/v1/csv/.

    :param timezone: An optional default timezone to use to localize bars. By default bars are loaded in UTC.
    :type timezone: A pytz timezone.
    :param maxLen: The maximum number of values that the :class:`pyalgotrade.dataseries.bards.BarDataSeries` will hold.
        If not None, it must be greater than 0.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.

    .. note::
        Note that a :class:`pyalgotrade.bar.Bar` instance will be created for every trade, so
        open, high, low and close values will all be the same.
    """

    def __init__(self, timezone=None, maxLen=dataseries.DEFAULT_MAX_LEN):
        csvfeed.BarFeed.__init__(self, barfeed.Frequency.TRADE, maxLen)
        self.__timezone = timezone
        self.__unixTimeFix = UnixTimeFix()

    def barsHaveAdjClose(self):
        return False

    def addBarsFromCSV(self, path, instrument="BTC", timezone=None, fromDateTime=None, toDateTime=None):
        """Loads bars from a trades CSV formatted file.

        :param path: The path to the file.
        :type path: string.
        :param instrument: The instrument identifier.
        :type instrument: string.
        :param timezone: An optional timezone to use to localize bars. By default bars are loaded in UTC.
        :type timezone: A pytz timezone.
        :param fromDateTime: An optional datetime to use to filter bars to load.
            If supplied only those bars whose datetime is greater than or equal to fromDateTime are loaded.
        :type fromDateTime: datetime.datetime.
        :param toDateTime: An optional datetime to use to filter bars to load.
            If supplied only those bars whose datetime is lower than or equal to toDateTime are loaded.
        :type toDateTime: datetime.datetime.

        .. note::
            * Every file that you load bars from must have trades in the same currency.
            * If fromDateTime or toDateTime are naive, they are treated as UTC.
        """

        if timezone is None:
            timezone = self.__timezone
        rowParser = RowParser(self.__unixTimeFix, timezone)

        # Save the barfilter to restore it later.
        prevBarFilter = self.getBarFilter()
        try:
            if fromDateTime or toDateTime:
                self.setBarFilter(csvfeed.DateRangeFilter(to_utc_if_naive(fromDateTime), to_utc_if_naive(toDateTime)))
            csvfeed.BarFeed.addBarsFromCSV(self, instrument, path, rowParser)
        finally:
            self.setBarFilter(prevBarFilter)

########NEW FILE########
__FILENAME__ = barfeed
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import datetime

from pyalgotrade import bar
from pyalgotrade import dataseries
from pyalgotrade import barfeed
from pyalgotrade.bitstamp import wsclient


class TradeBar(bar.Bar):
    # Optimization to reduce memory footprint.
    __slots__ = ('__dateTime', '__tradeId', '__price', '__amount')

    def __init__(self, dateTime, trade):
        self.__dateTime = dateTime
        self.__tradeId = trade.getId()
        self.__price = trade.getPrice()
        self.__amount = trade.getAmount()

    def __setstate__(self, state):
        (self.__dateTime, self.__tradeId, self.__price, self.__amount) = state

    def __getstate__(self):
        return (self.__dateTime, self.__tradeId, self.__price, self.__amount)

    def setUseAdjustedValue(self, useAdjusted):
        if useAdjusted:
            raise Exception("Adjusted close is not available")

    def getTradeId(self):
        return self.__tradeId

    def getFrequency(self):
        return bar.Frequency.TRADE

    def getDateTime(self):
        return self.__dateTime

    def getOpen(self, adjusted=False):
        return self.__price

    def getHigh(self, adjusted=False):
        return self.__price

    def getLow(self, adjusted=False):
        return self.__price

    def getClose(self, adjusted=False):
        return self.__price

    def getVolume(self):
        return self.__amount

    def getAdjClose(self):
        return None

    def getTypicalPrice(self):
        return self.__price

    def getPrice(self):
        return self.__price


class LiveTradeFeed(barfeed.BaseBarFeed):
    """A real-time BarFeed that builds bars from live trades.

    :param client: A Bitstamp client.
    :type client: :class:`pyalgotrade.bitstamp.client.Client`.
    :param maxLen: The maximum number of values that the :class:`pyalgotrade.dataseries.bards.BarDataSeries` will hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.

    .. note::
        Note that a Bar will be created for every trade, so open, high, low and close values will all be the same.
    """

    def __init__(self, client, maxLen=dataseries.DEFAULT_MAX_LEN):
        barfeed.BaseBarFeed.__init__(self, bar.Frequency.TRADE, maxLen)
        self.__barDicts = []
        self.registerInstrument("BTC")
        client.getTradeEvent().subscribe(self.__onTrade)
        self.__prevTradeDateTime = None

    def getCurrentDateTime(self):
        return wsclient.get_current_datetime()

    def isRealTime(self):
        return True

    # Bar datetimes should not duplicate. In case trade object datetimes conflict, we just move one slightly forward.
    def __getTradeDateTime(self, trade):
        ret = trade.getDateTime()
        if ret == self.__prevTradeDateTime:
            ret += datetime.timedelta(microseconds=1)
        self.__prevTradeDateTime = ret
        return ret

    def __onTrade(self, trade):
        # Build a bar for each trade.
        barDict = {
            "BTC": TradeBar(self.__getTradeDateTime(trade), trade)
            }
        self.__barDicts.append(barDict)

        # Dispatch immediately
        self.dispatch()

    def barsHaveAdjClose(self):
        return False

    def getNextBars(self):
        ret = None
        if len(self.__barDicts):
            ret = bar.Bars(self.__barDicts.pop(0))
        return ret

    def peekDateTime(self):
        # Return None since this is a realtime subject.
        return None

    def eof(self):
        return len(self.__barDicts) == 0

    def start(self):
        pass

    def stop(self):
        pass

    def join(self):
        pass

########NEW FILE########
__FILENAME__ = broker
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import broker
from pyalgotrade.broker import backtesting


class BTCTraits(broker.InstrumentTraits):
    def roundQuantity(self, quantity):
        return round(quantity, 8)


# In a backtesting or paper-trading scenario the BacktestingBroker dispatches events while processing events from the BarFeed.
# It is guaranteed to process BarFeed events before the strategy because it connects to BarFeed events before the strategy.

class PaperTradingBroker(backtesting.Broker):
    """A Bitstamp paper trading broker.

    :param cash: The initial amount of cash.
    :type cash: int/float.
    :param barFeed: The bar feed that will provide the bars.
    :type barFeed: :class:`pyalgotrade.barfeed.BarFeed`
    :param fee: The fee percentage for each order. Defaults to 0.5%.
    :type fee: float.

    .. note::
        Only limit orders are supported.
    """

    def __init__(self, cash, barFeed, fee=0.005):
        commission = backtesting.TradePercentage(fee)
        backtesting.Broker.__init__(self, cash, barFeed, commission)

    def getInstrumentTraits(self, instrument):
        return BTCTraits()

    def createMarketOrder(self, action, instrument, quantity, onClose=False):
        raise Exception("Market orders are not supported")

    def createLimitOrder(self, action, instrument, limitPrice, quantity):
        if action not in [broker.Order.Action.BUY, broker.Order.Action.SELL]:
            raise Exception("Only BUY/SELL orders are supported")
        if instrument != "BTC":
            raise Exception("Only BTC instrument is supported")
        return backtesting.Broker.createLimitOrder(self, action, instrument, limitPrice, quantity)

    def createStopOrder(self, action, instrument, stopPrice, quantity):
        raise Exception("Stop orders are not supported")

    def createStopLimitOrder(self, action, instrument, stopPrice, limitPrice, quantity):
        raise Exception("Stop limit orders are not supported")

########NEW FILE########
__FILENAME__ = client
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import time
import threading
import Queue

import wsclient
from pyalgotrade import observer
import pyalgotrade.logger


logger = pyalgotrade.logger.getLogger("bitstamp")


class WSClient(wsclient.WebSocketClient):

    # Events
    ON_TRADE = 1
    ON_ORDER_BOOK_UPDATE = 2
    ON_CONNECTED = 3
    ON_DISCONNECTED = 4

    def __init__(self):
        wsclient.WebSocketClient.__init__(self)
        self.__queue = Queue.Queue()

    def getQueue(self):
        return self.__queue

    # WebSocketClientBase events.
    def onOpened(self):
        pass

    def onClosed(self, code, reason):
        logger.info("Closed. Code: %s. Reason: %s." % (code, reason))

    def onDisconnectionDetected(self):
        logger.info("Disconnection detected.")
        try:
            self.stopClient()
        except Exception, e:
            logger.error("Error stopping client: %s" % str(e))
        self.__queue.put((WSClient.ON_DISCONNECTED, None))

    # Pusher specific events.
    def onConnectionEstablished(self, event):
        logger.info("Connection established.")
        self.subscribeChannel("live_trades")
        self.subscribeChannel("order_book")
        self.__queue.put((WSClient.ON_CONNECTED, None))

    def onSubscriptionError(self, event):
        logger.error("Channel subscription error: %s" % (event))

    def onError(self, event):
        logger.error("Error: %s" % (event))

    def onUnknownEvent(self, event):
        logger.warning("Unknown event: %s" % (event))

    # Bitstamp specific
    def onTrade(self, trade):
        self.__queue.put((WSClient.ON_TRADE, trade))

    def onOrderBookUpdate(self, orderBookUpdate):
        self.__queue.put((WSClient.ON_ORDER_BOOK_UPDATE, orderBookUpdate))


class Client(observer.Subject):
    """This class is responsible for the interaction with Bitstamp. In order to get the client running
    it has to be included in the dispatch loop. Check the example code to get this done."""

    QUEUE_TIMEOUT = 0.01

    def __init__(self):
        self.__thread = None
        self.__initializationOk = None
        self.__wsClient = None
        self.__enableReconnection = False
        self.__stopped = False
        self.__tradeEvent = observer.Event()
        self.__orderBookUpdateEvent = observer.Event()

    def __threadMain(self):
        logger.debug("Thread started.")
        self.__wsClient.startClient()
        logger.debug("Thread finished.")

    def __initializeClient(self):
        self.__initializationOk = None
        logger.info("Initializing client.")

        try:
            # Try to connect
            self.__thread = None
            self.__wsClient = WSClient()
            self.__wsClient.connect()

            # Start the thread that runs the client.
            self.__thread = threading.Thread(target=self.__threadMain)
            self.__thread.start()
        except Exception, e:
            self.__initializationOk = False
            logger.error("Error connecting : %s" % str(e))

        # Wait for initialization to complete.
        while self.__initializationOk is None and self.__thread.is_alive():
            self.__dispatchImpl([WSClient.ON_CONNECTED])

        if self.__initializationOk:
            logger.info("Initialization ok.")
        else:
            logger.error("Initialization failed.")
        return self.__initializationOk

    def __onConnected(self):
        self.__initializationOk = True

    def __onDisconnected(self):
        if self.__enableReconnection:
            initialized = False
            while not self.__stopped and not initialized:
                logger.info("Reconnecting")
                initialized = self.__initializeClient()
                if not initialized:
                    time.sleep(5)
        else:
            self.__stopped = True

    def __dispatchImpl(self, eventFilter):
        ret = False
        try:
            eventType, eventData = self.__wsClient.getQueue().get(True, Client.QUEUE_TIMEOUT)
            if eventFilter is not None and eventType not in eventFilter:
                return False

            ret = True
            if eventType == WSClient.ON_TRADE:
                self.__tradeEvent.emit(eventData)
            elif eventType == WSClient.ON_ORDER_BOOK_UPDATE:
                self.__orderBookUpdateEvent.emit(eventData)
            elif eventType == WSClient.ON_CONNECTED:
                self.__onConnected()
            elif eventType == WSClient.ON_DISCONNECTED:
                self.__onDisconnected()
            else:
                ret = False
                logger.error("Invalid event received to dispatch: %s - %s" % (eventType, eventData))
        except Queue.Empty:
            pass
        return ret

    # This may raise.
    def start(self):
        if self.__thread is not None:
            raise Exception("Already running")
        elif not self.__initializeClient():
            self.__stopped = True
            raise Exception("Initialization failed")

    # This should not raise.
    def stop(self):
        try:
            self.__stopped = True
            if self.__thread is not None and self.__thread.is_alive():
                logger.info("Shutting down client.")
                self.__wsClient.stopClient()
        except Exception, e:
            logger.error("Error shutting down client: %s" % (str(e)))

    # This should not raise.
    def join(self):
        if self.__thread is not None:
            self.__thread.join()

    # Return True if there are not more events to dispatch.
    def eof(self):
        return self.__stopped

    # Dispatch events. If True is returned, it means that at least one event was dispatched.
    def dispatch(self):
        return self.__dispatchImpl(None)

    def peekDateTime(self):
        # Return None since this is a realtime subject.
        return None

    def getTradeEvent(self):
        """Returns the event that will be emitted as new trades are received from Bitstamp.
        To subscribe to this event you need to pass in a callable object that receives one parameter:

        1. A :class:`pyalgotrade.bitstamp.wsclient.Trade` instance.

        .. note::
            It is not necessary to manually subscribe to this event since trades are notified
            by the BarFeed.
        """
        return self.__tradeEvent

    def getOrderBookUpdateEvent(self):
        """Returns the event that will be emitted as new trades are received from Bitstamp.
        To subscribe to this event you need to pass in a callable object that receives one parameter:

        1. A :class:`pyalgotrade.bitstamp.wsclient.OrderBookUpdate` instance.
        """
        return self.__orderBookUpdateEvent

########NEW FILE########
__FILENAME__ = wsclient
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import datetime

from pyalgotrade.websocket import pusher


def get_current_datetime():
    return datetime.datetime.now()

# Bitstamp protocol reference: https://www.bitstamp.net/websocket/

class Trade(pusher.Event):
    """A trade event."""

    def __init__(self, dateTime, eventDict):
        pusher.Event.__init__(self, eventDict, True)
        self.__dateTime = dateTime

    def getDateTime(self):
        """Returns the :class:`datetime.datetime` when this event was received."""
        return self.__dateTime

    def getId(self):
        """Returns the trade id."""
        return self.getData()["id"]

    def getPrice(self):
        """Returns the trade price."""
        return self.getData()["price"]

    def getAmount(self):
        """Returns the trade amount."""
        return self.getData()["amount"]


class OrderBookUpdate(pusher.Event):
    """An order book update event."""

    def __init__(self, dateTime, eventDict):
        pusher.Event.__init__(self, eventDict, True)
        self.__dateTime = dateTime

    def getDateTime(self):
        """Returns the :class:`datetime.datetime` when this event was received."""
        return self.__dateTime

    def getBidPrices(self):
        """Returns a list with the top 20 bid prices."""
        return [float(bid[0]) for bid in self.getData()["bids"]]

    def getBidVolumes(self):
        """Returns a list with the top 20 bid volumes."""
        return [float(bid[1]) for bid in self.getData()["bids"]]

    def getAskPrices(self):
        """Returns a list with the top 20 ask prices."""
        return [float(ask[0]) for ask in self.getData()["asks"]]

    def getAskVolumes(self):
        """Returns a list with the top 20 ask volumes."""
        return [float(ask[1]) for ask in self.getData()["asks"]]


class WebSocketClient(pusher.WebSocketClient):
    PUSHER_APP_KEY = "de504dc5763aeef9ff52"

    def __init__(self):
        pusher.WebSocketClient.__init__(self, WebSocketClient.PUSHER_APP_KEY, 5)

    def onMessage(self, msg):
        # If we can't handle the message, forward it to Pusher WebSocketClient.
        event = msg.get("event")
        if event == "trade":
            self.onTrade(Trade(get_current_datetime(), msg))
        elif event == "data" and msg.get("channel") == "order_book":
            self.onOrderBookUpdate(OrderBookUpdate(get_current_datetime(), msg))
        else:
            pusher.WebSocketClient.onMessage(self, msg)

    ######################################################################
    # Override for Bitstamp specific events.

    def onTrade(self, trade):
        pass

    def onOrderBookUpdate(self, orderBookUpdate):
        pass

########NEW FILE########
__FILENAME__ = backtesting
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import abc

from pyalgotrade import broker
from pyalgotrade import warninghelpers
from pyalgotrade import logger
import pyalgotrade.bar


class DefaultTraits(broker.InstrumentTraits):
    def roundQuantity(self, quantity):
        return int(quantity)


######################################################################
## Commission models

class Commission(object):
    """Base class for implementing different commission schemes.

    .. note::
        This is a base class and should not be used directly.
    """

    __metaclass__ = abc.ABCMeta

    @abc.abstractmethod
    def calculate(self, order, price, quantity):
        """Calculates the commission for an order execution.

        :param order: The order being executed.
        :type order: :class:`pyalgotrade.broker.Order`.
        :param price: The price for each share.
        :type price: float.
        :param quantity: The order size.
        :type quantity: float.
        :rtype: float.
        """
        raise NotImplementedError()


class NoCommission(Commission):
    """A :class:`Commission` class that always returns 0."""

    def calculate(self, order, price, quantity):
        return 0


class FixedPerTrade(Commission):
    """A :class:`Commission` class that charges a fixed amount for the whole trade.

    :param amount: The commission for an order.
    :type amount: float.
    """
    def __init__(self, amount):
        self.__amount = amount

    def calculate(self, order, price, quantity):
        ret = 0
        # Only charge the first fill.
        if order.getExecutionInfo() is None:
            ret = self.__amount
        return ret


class TradePercentage(Commission):
    """A :class:`Commission` class that charges a percentage of the whole trade.

    :param percentage: The percentage to charge. 0.01 means 1%, and so on. It must be smaller than 1.
    :type percentage: float.
    """
    def __init__(self, percentage):
        assert(percentage < 1)
        self.__percentage = percentage

    def calculate(self, order, price, quantity):
        return price * quantity * self.__percentage


######################################################################
## Order filling strategies

# Returns the trigger price for a Stop or StopLimit order, or None if the stop price was not yet penetrated.
def get_stop_price_trigger(action, stopPrice, useAdjustedValues, bar):
    ret = None
    open_ = bar.getOpen(useAdjustedValues)
    high = bar.getHigh(useAdjustedValues)
    low = bar.getLow(useAdjustedValues)

    # If the bar is above the stop price, use the open price.
    # If the bar includes the stop price, use the open price or the stop price. Whichever is better.
    if action in [broker.Order.Action.BUY, broker.Order.Action.BUY_TO_COVER]:
        if low > stopPrice:
            ret = open_
        elif stopPrice <= high:
            if open_ > stopPrice:  # The stop price was penetrated on open.
                ret = open_
            else:
                ret = stopPrice
    # If the bar is below the stop price, use the open price.
    # If the bar includes the stop price, use the open price or the stop price. Whichever is better.
    elif action in [broker.Order.Action.SELL, broker.Order.Action.SELL_SHORT]:
        if high < stopPrice:
            ret = open_
        elif stopPrice >= low:
            if open_ < stopPrice:  # The stop price was penetrated on open.
                ret = open_
            else:
                ret = stopPrice
    else:  # Unknown action
        assert(False)

    return ret


# Returns the trigger price for a Limit or StopLimit order, or None if the limit price was not yet penetrated.
def get_limit_price_trigger(action, limitPrice, useAdjustedValues, bar):
    ret = None
    open_ = bar.getOpen(useAdjustedValues)
    high = bar.getHigh(useAdjustedValues)
    low = bar.getLow(useAdjustedValues)

    # If the bar is below the limit price, use the open price.
    # If the bar includes the limit price, use the open price or the limit price.
    if action in [broker.Order.Action.BUY, broker.Order.Action.BUY_TO_COVER]:
        if high < limitPrice:
            ret = open_
        elif limitPrice >= low:
            if open_ < limitPrice:  # The limit price was penetrated on open.
                ret = open_
            else:
                ret = limitPrice
    # If the bar is above the limit price, use the open price.
    # If the bar includes the limit price, use the open price or the limit price.
    elif action in [broker.Order.Action.SELL, broker.Order.Action.SELL_SHORT]:
        if low > limitPrice:
            ret = open_
        elif limitPrice <= high:
            if open_ > limitPrice:  # The limit price was penetrated on open.
                ret = open_
            else:
                ret = limitPrice
    else:  # Unknown action
        assert(False)
    return ret


class FillInfo(object):
    def __init__(self, price, quantity):
        self.__price = price
        self.__quantity = quantity

    def getPrice(self):
        return self.__price

    def getQuantity(self):
        return self.__quantity


class FillStrategy(object):
    """Base class for order filling strategies."""

    __metaclass__ = abc.ABCMeta

    def onBars(self, dateTime, bars):
        """Override (optional) to get notified when the broker is about to process new bars."""
        pass

    def onOrderFilled(self, order):
        """Override (optional) to get notified when an order was filled, or partially filled."""
        pass

    @abc.abstractmethod
    def fillMarketOrder(self, order, broker_, bar):
        """Override to return the fill price and quantity for a market order or None if the order can't be filled at the given time.

        :param order: The order.
        :type order: :class:`pyalgotrade.broker.MarketOrder`.
        :param broker_: The broker.
        :type broker_: :class:`Broker`.
        :param bar: The current bar.
        :type bar: :class:`pyalgotrade.bar.Bar`.
        :rtype: A :class:`FillInfo` or None if the order should not be filled.
        """
        raise NotImplementedError()

    @abc.abstractmethod
    def fillLimitOrder(self, order, broker_, bar):
        """Override to return the fill price and quantity for a limit order or None if the order can't be filled at the given time.

        :param order: The order.
        :type order: :class:`pyalgotrade.broker.LimitOrder`.
        :param broker_: The broker.
        :type broker_: :class:`Broker`.
        :param bar: The current bar.
        :type bar: :class:`pyalgotrade.bar.Bar`.
        :rtype: A :class:`FillInfo` or None if the order should not be filled.
        """
        raise NotImplementedError()

    @abc.abstractmethod
    def fillStopOrder(self, order, broker_, bar):
        """Override to return the fill price and quantity for a stop order or None if the order can't be filled at the given time.

        :param order: The order.
        :type order: :class:`pyalgotrade.broker.StopOrder`.
        :param broker_: The broker.
        :type broker_: :class:`Broker`.
        :param bar: The current bar.
        :type bar: :class:`pyalgotrade.bar.Bar`.
        :rtype: A :class:`FillInfo` or None if the order should not be filled.
        """
        raise NotImplementedError()

    @abc.abstractmethod
    def fillStopLimitOrder(self, order, broker_, bar):
        """Override to return the fill price and quantity for a stop limit order or None if the order can't be filled at the given time.

        :param order: The order.
        :type order: :class:`pyalgotrade.broker.StopLimitOrder`.
        :param broker_: The broker.
        :type broker_: :class:`Broker`.
        :param bar: The current bar.
        :type bar: :class:`pyalgotrade.bar.Bar`.
        :rtype: A :class:`FillInfo` or None if the order should not be filled.
        """
        raise NotImplementedError()


class DefaultStrategy(FillStrategy):
    """
    Default fill strategy.

    :param volumeLimit: The proportion of the volume that orders can take up in a bar. Must be > 0 and <= 1.
    :type volumeLimit: float.

    This strategy works as follows:

    * A :class:`pyalgotrade.broker.MarketOrder` is always filled using the open/close price.
    * A :class:`pyalgotrade.broker.LimitOrder` will be filled like this:
        * If the limit price was penetrated with the open price, then the open price is used.
        * If the bar includes the limit price, then the limit price is used.
        * Note that when buying the price is penetrated if it gets <= the limit price, and when selling the price is penetrated
          if it gets >= the limit price
    * A :class:`pyalgotrade.broker.StopOrder` will be filled like this:
        * If the stop price was penetrated with the open price, then the open price is used.
        * If the bar includes the stop price, then the stop price is used.
        * Note that when buying the price is penetrated if it gets >= the stop price, and when selling the price is penetrated
          if it gets <= the stop price
    * A :class:`pyalgotrade.broker.StopLimitOrder` will be filled like this:
        * If the stop price was penetrated with the open price, or if the bar includes the stop price, then the limit order becomes active.
        * If the limit order is active:
            * If the limit order was activated in this same bar and the limit price is penetrated as well, then the best between
              the stop price and the limit fill price (as described earlier) is used.
            * If the limit order was activated at a previous bar then the limit fill price (as described earlier) is used.

    .. note::
        * This is the default strategy used by the Broker.
        * If volumeLimit is 0.25, and a certain bar's volume is 100, then no more than 25 shares can be used by all
          orders that get processed at that bar.
        * If using trade bars, then all the volume from that bar can be used.
    """

    def __init__(self, volumeLimit=0.25):
        assert(volumeLimit > 0 and volumeLimit <= 1)
        self.__volumeLimit = volumeLimit
        self.__volumeLeft = {}

    def onBars(self, dateTime, bars):
        # Update the volume available for each instrument.
        volumeLeft = {}
        for instrument in bars.getInstruments():
            bar = bars[instrument]
            if bar.getFrequency() == pyalgotrade.bar.Frequency.TRADE:
                volumeLeft[instrument] = bar.getVolume()
            elif self.__volumeLimit is not None:
                volumeLeft[instrument] = bar.getVolume() * self.__volumeLimit
        self.__volumeLeft = volumeLeft

    def getVolumeLeft(self):
        return self.__volumeLeft

    def onOrderFilled(self, order):
        # Update the volume left.
        if self.__volumeLimit is not None:
            self.__volumeLeft[order.getInstrument()] = order.getInstrumentTraits().roundQuantity(self.__volumeLeft[order.getInstrument()] - order.getExecutionInfo().getQuantity())

    def setVolumeLimit(self, volumeLimit):
        self.__volumeLimit = volumeLimit

    def __calculateFillSize(self, order, broker_, bar):
        ret = 0

        # If self.__volumeLimit is None then allow all the order to get filled.
        if self.__volumeLimit is not None:
            volumeLeft = self.__volumeLeft.get(order.getInstrument(), 0)
        else:
            volumeLeft = order.getRemaining()

        volumeLeft = order.getInstrumentTraits().roundQuantity(volumeLeft)

        if not order.getAllOrNone():
            ret = min(volumeLeft, order.getRemaining())
        elif order.getRemaining() <= volumeLeft:
            ret = order.getRemaining()

        return ret

    def fillMarketOrder(self, order, broker_, bar):
        fillSize = self.__calculateFillSize(order, broker_, bar)
        if fillSize == 0:
            broker_.getLogger().debug("Not enough volume to fill %s market order [%s] for %d share/s" % (order.getInstrument(), order.getId(), order.getRemaining()))
            return None

        ret = None
        if order.getFillOnClose():
            price = bar.getClose(broker_.getUseAdjustedValues())
        else:
            price = bar.getOpen(broker_.getUseAdjustedValues())
        if price is not None:
            ret = FillInfo(price, fillSize)
        return ret

    def fillLimitOrder(self, order, broker_, bar):
        fillSize = self.__calculateFillSize(order, broker_, bar)
        if fillSize == 0:
            broker_.getLogger().debug("Not enough volume to fill %s limit order [%s] for %d share/s" % (order.getInstrument(), order.getId(), order.getRemaining()))
            return None

        ret = None
        price = get_limit_price_trigger(order.getAction(), order.getLimitPrice(), broker_.getUseAdjustedValues(), bar)
        if price is not None:
            ret = FillInfo(price, fillSize)
        return ret

    def fillStopOrder(self, order, broker_, bar):
        ret = None

        # First check if the stop price was hit so the market order becomes active.
        stopPriceTrigger = None
        if not order.getStopHit():
            stopPriceTrigger = get_stop_price_trigger(order.getAction(), order.getStopPrice(), broker_.getUseAdjustedValues(), bar)
            order.setStopHit(stopPriceTrigger is not None)

        # If the stop price was hit, check if we can fill the market order.
        if order.getStopHit():
            fillSize = self.__calculateFillSize(order, broker_, bar)
            if fillSize == 0:
                broker_.getLogger().debug("Not enough volume to fill %s stop order [%s] for %d share/s" % (order.getInstrument(), order.getId(), order.getRemaining()))
                return None

            # If we just hit the stop price we'll use it as the fill price.
            # For the remaining bars we'll use the open price.
            if stopPriceTrigger is not None:
                price = stopPriceTrigger
            else:
                price = bar.getOpen(broker_.getUseAdjustedValues())

            ret = FillInfo(price, fillSize)
        return ret

    def fillStopLimitOrder(self, order, broker_, bar):
        ret = None

        # First check if the stop price was hit so the limit order becomes active.
        stopPriceTrigger = None
        if not order.getStopHit():
            stopPriceTrigger = get_stop_price_trigger(order.getAction(), order.getStopPrice(), broker_.getUseAdjustedValues(), bar)
            order.setStopHit(stopPriceTrigger is not None)

        # If the stop price was hit, check if we can fill the limit order.
        if order.getStopHit():
            fillSize = self.__calculateFillSize(order, broker_, bar)
            if fillSize == 0:
                broker_.getLogger().debug("Not enough volume to fill %s stop limit order [%s] for %d share/s" % (order.getInstrument(), order.getId(), order.getRemaining()))
                return None

            price = get_limit_price_trigger(order.getAction(), order.getLimitPrice(), broker_.getUseAdjustedValues(), bar)
            if price is not None:
                # If we just hit the stop price, we need to make additional checks.
                if stopPriceTrigger is not None:
                    if order.isBuy():
                        # If the stop price triggered is lower than the limit price, then use that one. Else use the limit price.
                        price = min(stopPriceTrigger, order.getLimitPrice())
                    else:
                        # If the stop price triggered is greater than the limit price, then use that one. Else use the limit price.
                        price = max(stopPriceTrigger, order.getLimitPrice())

                ret = FillInfo(price, fillSize)

        return ret


######################################################################
## Orders

class BacktestingOrder(object):
    def __init__(self):
        self.__accepted = None

    def setAcceptedDateTime(self, dateTime):
        self.__accepted = dateTime

    def getAcceptedDateTime(self):
        return self.__accepted

    # Override to call the fill strategy using the concrete order type.
    # return FillInfo or None if the order should not be filled.
    def process(self, broker_, bar_):
        raise NotImplementedError()


class MarketOrder(broker.MarketOrder, BacktestingOrder):
    def __init__(self, orderId, action, instrument, quantity, onClose, instrumentTraits):
        broker.MarketOrder.__init__(self, orderId, action, instrument, quantity, onClose, instrumentTraits)
        BacktestingOrder.__init__(self)

    def process(self, broker_, bar_):
        return broker_.getFillStrategy().fillMarketOrder(self, broker_, bar_)


class LimitOrder(broker.LimitOrder, BacktestingOrder):
    def __init__(self, orderId, action, instrument, limitPrice, quantity, instrumentTraits):
        broker.LimitOrder.__init__(self, orderId, action, instrument, limitPrice, quantity, instrumentTraits)
        BacktestingOrder.__init__(self)

    def process(self, broker_, bar_):
        return broker_.getFillStrategy().fillLimitOrder(self, broker_, bar_)


class StopOrder(broker.StopOrder, BacktestingOrder):
    def __init__(self, orderId, action, instrument, stopPrice, quantity, instrumentTraits):
        broker.StopOrder.__init__(self, orderId, action, instrument, stopPrice, quantity, instrumentTraits)
        BacktestingOrder.__init__(self)
        self.__stopHit = False

    def process(self, broker_, bar_):
        return broker_.getFillStrategy().fillStopOrder(self, broker_, bar_)

    def setStopHit(self, stopHit):
        self.__stopHit = stopHit

    def getStopHit(self):
        return self.__stopHit


# http://www.sec.gov/answers/stoplim.htm
# http://www.interactivebrokers.com/en/trading/orders/stopLimit.php
class StopLimitOrder(broker.StopLimitOrder, BacktestingOrder):
    def __init__(self, orderId, action, instrument, stopPrice, limitPrice, quantity, instrumentTraits):
        broker.StopLimitOrder.__init__(self, orderId, action, instrument, stopPrice, limitPrice, quantity, instrumentTraits)
        BacktestingOrder.__init__(self)
        self.__stopHit = False  # Set to true when the limit order is activated (stop price is hit)

    def setStopHit(self, stopHit):
        self.__stopHit = stopHit

    def getStopHit(self):
        return self.__stopHit

    def isLimitOrderActive(self):
        # TODO: Deprecated since v0.15. Use getStopHit instead.
        return self.__stopHit

    def process(self, broker_, bar_):
        return broker_.getFillStrategy().fillStopLimitOrder(self, broker_, bar_)


######################################################################
## Broker

class Broker(broker.Broker):
    """Backtesting broker.

    :param cash: The initial amount of cash.
    :type cash: int/float.
    :param barFeed: The bar feed that will provide the bars.
    :type barFeed: :class:`pyalgotrade.barfeed.BarFeed`
    :param commission: An object responsible for calculating order commissions.
    :type commission: :class:`Commission`
    """

    LOGGER_NAME = "broker.backtesting"

    def __init__(self, cash, barFeed, commission=None):
        broker.Broker.__init__(self)

        assert(cash >= 0)
        self.__cash = cash
        if commission is None:
            self.__commission = NoCommission()
        else:
            self.__commission = commission
        self.__shares = {}
        self.__activeOrders = {}
        self.__useAdjustedValues = False
        self.__fillStrategy = DefaultStrategy()
        self.__logger = logger.getLogger(Broker.LOGGER_NAME)

        # It is VERY important that the broker subscribes to barfeed events before the strategy.
        barFeed.getNewBarsEvent().subscribe(self.onBars)
        self.__barFeed = barFeed
        self.__allowNegativeCash = False
        self.__nextOrderId = 1

    def __getNextOrderId(self):
        ret = self.__nextOrderId
        self.__nextOrderId += 1
        return ret

    def __getBar(self, bars, instrument):
        ret = bars.getBar(instrument)
        if ret is None:
            ret = self.__barFeed.getLastBar(instrument)
        return ret

    def getLogger(self):
        return self.__logger

    def setAllowNegativeCash(self, allowNegativeCash):
        self.__allowNegativeCash = allowNegativeCash

    def getCash(self, includeShort=True):
        """
        Returns the available cash.

        :param includeShort: Include cash from short positions.
        :type includeShort: boolean.
        """
        ret = self.__cash
        if not includeShort and self.__barFeed.getCurrentBars() is not None:
            bars = self.__barFeed.getCurrentBars()
            for instrument, shares in self.__shares.iteritems():
                if shares < 0:
                    instrumentPrice = self.__getBar(bars, instrument).getClose(self.getUseAdjustedValues())
                    ret += instrumentPrice * shares
        return ret

    def setCash(self, cash):
        self.__cash = cash

    def getCommission(self):
        """Returns the strategy used to calculate order commissions.

        :rtype: :class:`Commission`.
        """
        return self.__commission

    def setCommission(self, commission):
        """Sets the strategy to use to calculate order commissions.

        :param commission: An object responsible for calculating order commissions.
        :type commission: :class:`Commission`.
        """

        self.__commission = commission

    def setFillStrategy(self, strategy):
        """Sets the :class:`FillStrategy` to use."""
        self.__fillStrategy = strategy

    def getFillStrategy(self):
        """Returns the :class:`FillStrategy` currently set."""
        return self.__fillStrategy

    def getUseAdjustedValues(self):
        return self.__useAdjustedValues

    def setUseAdjustedValues(self, useAdjusted, deprecationCheck=None):
        # Deprecated since v0.15
        if not self.__barFeed.barsHaveAdjClose():
            raise Exception("The barfeed doesn't support adjusted close values")
        if deprecationCheck is None:
            warninghelpers.deprecation_warning("setUseAdjustedValues will be deprecated in the next version. Please use setUseAdjustedValues on the strategy instead.", stacklevel=2)
        self.__useAdjustedValues = useAdjusted

    def getActiveOrders(self, instrument=None):
        if instrument is None:
            ret = self.__activeOrders.values()
        else:
            ret = [order for order in self.__activeOrders.values() if order.getInstrument() == instrument]
        return ret

    def getPendingOrders(self):
        warninghelpers.deprecation_warning("getPendingOrders will be deprecated in the next version. Please use getActiveOrders instead.", stacklevel=2)
        return self.getActiveOrders()

    def getCurrentDateTime(self):
        return self.__barFeed.getCurrentDateTime()

    def getInstrumentTraits(self, instrument):
        return DefaultTraits()

    def getShares(self, instrument):
        return self.__shares.get(instrument, 0)

    def getPositions(self):
        return self.__shares

    def getActiveInstruments(self):
        return [instrument for instrument, shares in self.__shares.iteritems() if shares != 0]

    def __getEquityWithBars(self, bars):
        ret = self.getCash()
        if bars is not None:
            for instrument, shares in self.__shares.iteritems():
                instrumentPrice = self.__getBar(bars, instrument).getClose(self.getUseAdjustedValues())
                ret += instrumentPrice * shares
        return ret

    def getValue(self, deprecated=None):
        if deprecated is not None:
            warninghelpers.deprecation_warning("The bars parameter is no longer used and will be removed in the next version.", stacklevel=2)

        return self.__getEquityWithBars(self.__barFeed.getCurrentBars())

    def getEquity(self):
        """Returns the portfolio value (cash + shares)."""
        return self.__getEquityWithBars(self.__barFeed.getCurrentBars())

    # Tries to commit an order execution. Returns True if the order was commited, or False is there is not enough cash.
    def commitOrderExecution(self, order, dateTime, fillInfo):
        price = fillInfo.getPrice()
        quantity = fillInfo.getQuantity()

        if order.isBuy():
            cost = price * quantity * -1
            assert(cost < 0)
            sharesDelta = quantity
        elif order.isSell():
            cost = price * quantity
            assert(cost > 0)
            sharesDelta = quantity * -1
        else:  # Unknown action
            assert(False)

        commission = self.getCommission().calculate(order, price, quantity)
        cost -= commission
        resultingCash = self.getCash() + cost

        # Check that we're ok on cash after the commission.
        if resultingCash >= 0 or self.__allowNegativeCash:

            # Update the order before updating internal state since addExecutionInfo may raise.
            # addExecutionInfo should switch the order state.
            orderExecutionInfo = broker.OrderExecutionInfo(price, quantity, commission, dateTime)
            order.addExecutionInfo(orderExecutionInfo)

            # Commit the order execution.
            self.__cash = resultingCash
            updatedShares = order.getInstrumentTraits().roundQuantity(self.getShares(order.getInstrument()) + sharesDelta)
            if updatedShares == 0:
                del self.__shares[order.getInstrument()]
            else:
                self.__shares[order.getInstrument()] = updatedShares

            # Let the strategy know that the order was filled.
            self.__fillStrategy.onOrderFilled(order)

            # Notify the order update
            if order.isFilled():
                del self.__activeOrders[order.getId()]
                self.notifyOrderEvent(broker.OrderEvent(order, broker.OrderEvent.Type.FILLED, orderExecutionInfo))
            elif order.isPartiallyFilled():
                self.notifyOrderEvent(broker.OrderEvent(order, broker.OrderEvent.Type.PARTIALLY_FILLED, orderExecutionInfo))
            else:
                assert(False)
        else:
            self.__logger.debug("Not enough cash to fill %s order [%s] for %d share/s" % (order.getInstrument(), order.getId(), order.getRemaining()))

    def submitOrder(self, order):
        if order.isInitial():
            # assert(order.getId() not in self.__activeOrders)
            self.__activeOrders[order.getId()] = order
            # Switch from INITIAL -> SUBMITTED
            # IMPORTANT: Do not emit an event for this switch because when using the position interface
            # the order is not yet mapped to the position and Position.onOrderUpdated will get called.
            order.switchState(broker.Order.State.SUBMITTED)
            order.setSubmitDateTime(self.getCurrentDateTime())
        else:
            raise Exception("The order was already processed")

    # Return True if further processing is needed.
    def __preProcessOrder(self, order, bar_):
        ret = True

        # For non-GTC orders we need to check if the order has expired.
        if not order.getGoodTillCanceled():
            expired = bar_.getDateTime().date() > order.getAcceptedDateTime().date()

            # Cancel the order if it is expired.
            if expired:
                ret = False
                del self.__activeOrders[order.getId()]
                order.switchState(broker.Order.State.CANCELED)
                self.notifyOrderEvent(broker.OrderEvent(order, broker.OrderEvent.Type.CANCELED, "Expired"))

        return ret

    def __postProcessOrder(self, order, bar_):
        # For non-GTC orders and daily (or greater) bars we need to check if orders should expire right now
        # before waiting for the next bar.
        if not order.getGoodTillCanceled():
            expired = False
            if self.__barFeed.getFrequency() >= pyalgotrade.bar.Frequency.DAY:
                expired = bar_.getDateTime().date() >= order.getAcceptedDateTime().date()

            # Cancel the order if it will expire in the next bar.
            if expired:
                del self.__activeOrders[order.getId()]
                order.switchState(broker.Order.State.CANCELED)
                self.notifyOrderEvent(broker.OrderEvent(order, broker.OrderEvent.Type.CANCELED, "Expired"))

    def __processOrder(self, order, bar_):
        if not self.__preProcessOrder(order, bar_):
            return

        # Double dispatch to the fill strategy using the concrete order type.
        fillInfo = order.process(self, bar_)
        if fillInfo is not None:
            self.commitOrderExecution(order, bar_.getDateTime(), fillInfo)

        if order.isActive():
            self.__postProcessOrder(order, bar_)

    def __onBarsImpl(self, order, bars):
        # IF WE'RE DEALING WITH MULTIPLE INSTRUMENTS WE SKIP ORDER PROCESSING IF THERE IS NO BAR FOR THE ORDER'S
        # INSTRUMENT TO GET THE SAME BEHAVIOUR AS IF WERE BE PROCESSING ONLY ONE INSTRUMENT.
        bar_ = bars.getBar(order.getInstrument())
        if bar_ is not None:
            # Switch from SUBMITTED -> ACCEPTED
            if order.isSubmitted():
                order.setAcceptedDateTime(bar_.getDateTime())
                order.switchState(broker.Order.State.ACCEPTED)
                self.notifyOrderEvent(broker.OrderEvent(order, broker.OrderEvent.Type.ACCEPTED, None))

            if order.isActive():
                # This may trigger orders to be added/removed from __activeOrders.
                self.__processOrder(order, bar_)
            else:
                # If an order is not active it should be because it was canceled in this same loop and it should have been removed.
                assert(order.isCanceled())
                assert(order not in self.__activeOrders)

    def onBars(self, dateTime, bars):
        # Let the strategy know that new bars are being processed.
        self.__fillStrategy.onBars(dateTime, bars)

        # This is to froze the orders that will be processed in this event, to avoid new getting orders introduced
        # and processed on this very same event.
        ordersToProcess = self.__activeOrders.values()

        for order in ordersToProcess:
            # This may trigger orders to be added/removed from __activeOrders.
            self.__onBarsImpl(order, bars)

    def start(self):
        pass

    def stop(self):
        pass

    def join(self):
        pass

    def eof(self):
        # If there are no more events in the barfeed, then there is nothing left for us to do since all processing took
        # place while processing barfeed events.
        return self.__barFeed.eof()

    def dispatch(self):
        # All events were already emitted while handling barfeed events.
        pass

    def peekDateTime(self):
        return None

    def createMarketOrder(self, action, instrument, quantity, onClose=False):
        return MarketOrder(self.__getNextOrderId(), action, instrument, quantity, onClose, self.getInstrumentTraits(instrument))

    def createLimitOrder(self, action, instrument, limitPrice, quantity):
        return LimitOrder(self.__getNextOrderId(), action, instrument, limitPrice, quantity, self.getInstrumentTraits(instrument))

    def createStopOrder(self, action, instrument, stopPrice, quantity):
        return StopOrder(self.__getNextOrderId(), action, instrument, stopPrice, quantity, self.getInstrumentTraits(instrument))

    def createStopLimitOrder(self, action, instrument, stopPrice, limitPrice, quantity):
        return StopLimitOrder(self.__getNextOrderId(), action, instrument, stopPrice, limitPrice, quantity, self.getInstrumentTraits(instrument))

    def cancelOrder(self, order):
        activeOrder = self.__activeOrders.get(order.getId())
        if activeOrder is None:
            raise Exception("The order is not active anymore")
        if activeOrder.isFilled():
            raise Exception("Can't cancel order that has already been filled")

        del self.__activeOrders[activeOrder.getId()]
        activeOrder.switchState(broker.Order.State.CANCELED)
        self.notifyOrderEvent(broker.OrderEvent(activeOrder, broker.OrderEvent.Type.CANCELED, "User requested cancellation"))

########NEW FILE########
__FILENAME__ = aligned
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import dataseries


def datetime_aligned(ds1, ds2, maxLen=dataseries.DEFAULT_MAX_LEN):
    """
    Returns two dataseries that exhibit only those values whose datetimes are in both dataseries.

    :param ds1: A DataSeries instance.
    :type ds1: :class:`DataSeries`.
    :param ds2: A DataSeries instance.
    :type ds2: :class:`DataSeries`.
    :param maxLen: The maximum number of values to hold for the returned :class:`DataSeries`.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """
    aligned1 = dataseries.SequenceDataSeries(maxLen)
    aligned2 = dataseries.SequenceDataSeries(maxLen)
    Syncer(ds1, ds2, aligned1, aligned2)
    return (aligned1, aligned2)


# This class is responsible for filling 2 dataseries when 2 other dataseries get new values.
class Syncer(object):
    def __init__(self, sourceDS1, sourceDS2, destDS1, destDS2):
        self.__values1 = []  # (datetime, value)
        self.__values2 = []  # (datetime, value)
        self.__destDS1 = destDS1
        self.__destDS2 = destDS2
        sourceDS1.getNewValueEvent().subscribe(self.__onNewValue1)
        sourceDS2.getNewValueEvent().subscribe(self.__onNewValue2)
        # Source dataseries will keep a reference to self and that will prevent from getting this destroyed.

    # Scan backwards for the position of dateTime in ds.
    def __findPosForDateTime(self, values, dateTime):
        ret = None
        i = len(values) - 1
        while i >= 0:
            if values[i][0] == dateTime:
                ret = i
                break
            elif values[i][0] < dateTime:
                break
            i -= 1
        return ret

    def __onNewValue1(self, dataSeries, dateTime, value):
        pos2 = self.__findPosForDateTime(self.__values2, dateTime)
        # If a value for dateTime was added to first dataseries, and a value for that same datetime is also in the second one
        # then append to both destination dataseries.
        if pos2 is not None:
            self.__append(dateTime, value, self.__values2[pos2][1])
            # Reset buffers.
            self.__values1 = []
            self.__values2 = self.__values2[pos2+1:]
        else:
            # Since source dataseries may not hold all the values we need, we need to buffer manually.
            self.__values1.append((dateTime, value))

    def __onNewValue2(self, dataSeries, dateTime, value):
        pos1 = self.__findPosForDateTime(self.__values1, dateTime)
        # If a value for dateTime was added to second dataseries, and a value for that same datetime is also in the first one
        # then append to both destination dataseries.
        if pos1 is not None:
            self.__append(dateTime, self.__values1[pos1][1], value)
            # Reset buffers.
            self.__values1 = self.__values1[pos1+1:]
            self.__values2 = []
        else:
            # Since source dataseries may not hold all the values we need, we need to buffer manually.
            self.__values2.append((dateTime, value))

    def __append(self, dateTime, value1, value2):
        self.__destDS1.appendWithDateTime(dateTime, value1)
        self.__destDS2.appendWithDateTime(dateTime, value2)

########NEW FILE########
__FILENAME__ = bards
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import dataseries


class BarDataSeries(dataseries.SequenceDataSeries):
    """A DataSeries of :class:`pyalgotrade.bar.Bar` instances.

    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, maxLen=dataseries.DEFAULT_MAX_LEN):
        dataseries.SequenceDataSeries.__init__(self, maxLen)
        self.__openDS = dataseries.SequenceDataSeries(maxLen)
        self.__closeDS = dataseries.SequenceDataSeries(maxLen)
        self.__highDS = dataseries.SequenceDataSeries(maxLen)
        self.__lowDS = dataseries.SequenceDataSeries(maxLen)
        self.__volumeDS = dataseries.SequenceDataSeries(maxLen)
        self.__adjCloseDS = dataseries.SequenceDataSeries(maxLen)
        self.__useAdjustedValues = False

    def setUseAdjustedValues(self, useAdjusted):
        self.__useAdjustedValues = useAdjusted

    def append(self, bar):
        self.appendWithDateTime(bar.getDateTime(), bar)

    def appendWithDateTime(self, dateTime, bar):
        assert(dateTime is not None)
        assert(bar is not None)
        bar.setUseAdjustedValue(self.__useAdjustedValues)
        dataseries.SequenceDataSeries.appendWithDateTime(self, dateTime, bar)
        self.__openDS.appendWithDateTime(dateTime, bar.getOpen())
        self.__closeDS.appendWithDateTime(dateTime, bar.getClose())
        self.__highDS.appendWithDateTime(dateTime, bar.getHigh())
        self.__lowDS.appendWithDateTime(dateTime, bar.getLow())
        self.__volumeDS.appendWithDateTime(dateTime, bar.getVolume())
        self.__adjCloseDS.appendWithDateTime(dateTime, bar.getAdjClose())

    def getOpenDataSeries(self):
        """Returns a :class:`pyalgotrade.dataseries.DataSeries` with the open prices."""
        return self.__openDS

    def getCloseDataSeries(self):
        """Returns a :class:`pyalgotrade.dataseries.DataSeries` with the close prices."""
        return self.__closeDS

    def getHighDataSeries(self):
        """Returns a :class:`pyalgotrade.dataseries.DataSeries` with the high prices."""
        return self.__highDS

    def getLowDataSeries(self):
        """Returns a :class:`pyalgotrade.dataseries.DataSeries` with the low prices."""
        return self.__lowDS

    def getVolumeDataSeries(self):
        """Returns a :class:`pyalgotrade.dataseries.DataSeries` with the volume."""
        return self.__volumeDS

    def getAdjCloseDataSeries(self):
        """Returns a :class:`pyalgotrade.dataseries.DataSeries` with the adjusted close prices."""
        return self.__adjCloseDS

    def getPriceDataSeries(self):
        """Returns a :class:`pyalgotrade.dataseries.DataSeries` with the close or adjusted close prices."""
        if self.__useAdjustedValues:
            return self.__adjCloseDS
        else:
            return self.__closeDS

########NEW FILE########
__FILENAME__ = resampled
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from pyalgotrade import dataseries
from pyalgotrade.dataseries import bards
from pyalgotrade import bar
from pyalgotrade.utils import dt


# Returns the slot's beginning datetime.
# frequency in seconds
def get_slot_datetime(dateTime, frequency):
    ts = int(dt.datetime_to_timestamp(dateTime))
    slot = ts / frequency
    slotTs = slot * frequency
    ret = dt.timestamp_to_datetime(slotTs, False)
    if not dt.datetime_is_naive(dateTime):
        ret = dt.localize(ret, dateTime.tzinfo)
    return ret


class Slot(object):
    def __init__(self, dateTime, bar_, frequency):
        self.__dateTime = dateTime
        self.__open = bar_.getOpen()
        self.__high = bar_.getHigh()
        self.__low = bar_.getLow()
        self.__close = bar_.getClose()
        self.__volume = bar_.getVolume()
        self.__adjClose = bar_.getAdjClose()
        self.__frequency = frequency

    def getDateTime(self):
        return self.__dateTime

    def getOpen(self):
        return self.__open

    def getHigh(self):
        return self.__high

    def getLow(self):
        return self.__low

    def getClose(self):
        return self.__close

    def getVolume(self):
        return self.__volume

    def getAdjClose(self):
        return self.__adjClose

    def addBar(self, bar_):
        self.__high = max(self.__high, bar_.getHigh())
        self.__low = min(self.__low, bar_.getLow())
        self.__close = bar_.getClose()
        self.__adjClose = bar_.getAdjClose()
        self.__volume += bar_.getVolume()

    def buildBasicBar(self):
        return bar.BasicBar(self.__dateTime, self.__open, self.__high, self.__low, self.__close, self.__volume, self.__adjClose, self.__frequency)


class ResampledBarDataSeries(bards.BarDataSeries):
    """A BarDataSeries that will build on top of another, higher frequency, BarDataSeries.

    :param dataSeries: The DataSeries instance being resampled.
    :type dataSeries: :class:`pyalgotrade.dataseries.bards.BarDataSeries`.
    :param frequency: The grouping frequency in seconds. Must be > 0.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, dataSeries, frequency, maxLen=dataseries.DEFAULT_MAX_LEN):
        bards.BarDataSeries.__init__(self, maxLen)

        if not isinstance(dataSeries, bards.BarDataSeries):
            raise Exception("dataSeries must be a dataseries.bards.BarDataSeries instance")

        if frequency > 0:
            self.__frequency = frequency
        else:
            raise Exception("Invalid frequency")

        self.__slot = None
        dataSeries.getNewValueEvent().subscribe(self.__onNewValue)

    def pushLast(self):
        if self.__slot is not None:
            self.appendWithDateTime(self.__slot.getDateTime(), self.__slot.buildBasicBar())
        self.__slot = None

    def __onNewValue(self, dataSeries, dateTime, value):
        dateTime = get_slot_datetime(value.getDateTime(), self.__frequency)

        if self.__slot is None:
            self.__slot = Slot(dateTime, value, self.__frequency)
        elif self.__slot.getDateTime() == dateTime:
            self.__slot.addBar(value)
        else:
            self.appendWithDateTime(self.__slot.getDateTime(), self.__slot.buildBasicBar())
            self.__slot = Slot(dateTime, value, self.__frequency)

########NEW FILE########
__FILENAME__ = dispatcher
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import utils
from pyalgotrade import observer


# This class is responsible for dispatching events from multiple subjects, synchronizing them if necessary.
class Dispatcher(object):
    def __init__(self):
        self.__subjects = []
        self.__stop = False
        self.__startEvent = observer.Event()
        self.__idleEvent = observer.Event()
        self.__currDateTime = None

    # Returns the current event datetime. It may be None for events from realtime subjects.
    def getCurrentDateTime(self):
        return self.__currDateTime

    def getStartEvent(self):
        return self.__startEvent

    def getIdleEvent(self):
        return self.__idleEvent

    def stop(self):
        self.__stop = True

    def getSubjects(self):
        return self.__subjects

    def addSubject(self, subject):
        assert(subject not in self.__subjects)
        if subject.getDispatchPriority() is None:
            self.__subjects.append(subject)
        else:
            # Find the position for the subject's priority.
            pos = 0
            for s in self.__subjects:
                if s.getDispatchPriority() is None or subject.getDispatchPriority() < s.getDispatchPriority():
                    break
                pos += 1
            self.__subjects.insert(pos, subject)

    # Return True if events were dispatched.
    def __dispatchSubject(self, subject, currEventDateTime):
        ret = False
        # Dispatch if the datetime is currEventDateTime of if its a realtime subject.
        if not subject.eof() and subject.peekDateTime() in (None, currEventDateTime):
            ret = subject.dispatch() is True
        return ret

    # Returns a tuple with booleans
    # 1: True if all subjects hit eof
    # 2: True if at least one subject dispatched events.
    def __dispatch(self):
        smallestDateTime = None
        eof = True
        eventsDispatched = False

        # Scan for the lowest datetime.
        for subject in self.__subjects:
            if not subject.eof():
                eof = False
                smallestDateTime = utils.safe_min(smallestDateTime, subject.peekDateTime())

        self.__currDateTime = smallestDateTime

        # Dispatch realtime subjects and those subjects with the lowest datetime.
        if not eof:
            for subject in self.__subjects:
                if self.__dispatchSubject(subject, smallestDateTime):
                    eventsDispatched = True
        return eof, eventsDispatched

    def run(self):
        try:
            for subject in self.__subjects:
                subject.start()

            self.__startEvent.emit()

            while not self.__stop:
                eof, eventsDispatched = self.__dispatch()
                if eof:
                    self.__stop = True
                elif not eventsDispatched:
                    self.__idleEvent.emit()
        finally:
            for subject in self.__subjects:
                subject.stop()
            for subject in self.__subjects:
                subject.join()

########NEW FILE########
__FILENAME__ = eventprofiler
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import numpy as np
import matplotlib.pyplot as plt

from pyalgotrade.technical import roc
from pyalgotrade import dispatcher


class Results(object):
    """Results from the profiler."""
    def __init__(self, eventsDict, lookBack, lookForward):
        assert(lookBack > 0)
        assert(lookForward > 0)
        self.__lookBack = lookBack
        self.__lookForward = lookForward
        self.__values = [[] for i in xrange(lookBack+lookForward+1)]
        self.__eventCount = 0

        # Process events.
        for instrument, events in eventsDict.items():
            for event in events:
                # Skip events which are on the boundary or for some reason are not complete.
                if event.isComplete():
                    self.__eventCount += 1
                    # Compute cumulative returns: (1 + R1)*(1 + R2)*...*(1 + Rn)
                    values = np.cumprod(event.getValues() + 1)
                    # Normalize everything to the time of the event
                    values = values / values[event.getLookBack()]
                    for t in range(event.getLookBack()*-1, event.getLookForward()+1):
                        self.setValue(t, values[t+event.getLookBack()])

    def __mapPos(self, t):
        assert(t >= -1*self.__lookBack and t <= self.__lookForward)
        return t + self.__lookBack

    def setValue(self, t, value):
        if value is None:
            raise Exception("Invalid value at time %d" % (t))
        pos = self.__mapPos(t)
        self.__values[pos].append(value)

    def getValues(self, t):
        pos = self.__mapPos(t)
        return self.__values[pos]

    def getLookBack(self):
        return self.__lookBack

    def getLookForward(self):
        return self.__lookForward

    def getEventCount(self):
        """Returns the number of events occurred. Events that are on the boundary are skipped."""
        return self.__eventCount


class Predicate(object):
    """Base class for event identification. You should subclass this to implement
    the event identification logic."""

    def eventOccurred(self, instrument, bards):
        """Override (**mandatory**) to determine if an event took place in the last bar (bards[-1]).

        :param instrument: Instrument identifier.
        :type instrument: string.
        :param bards: The BarDataSeries for the given instrument.
        :type bards: :class:`pyalgotrade.dataseries.bards.BarDataSeries`.
        :rtype: boolean.
        """
        raise NotImplementedError()


class Event(object):
    def __init__(self, lookBack, lookForward):
        assert(lookBack > 0)
        assert(lookForward > 0)
        self.__lookBack = lookBack
        self.__lookForward = lookForward
        self.__values = np.empty((lookBack + lookForward + 1))
        self.__values[:] = np.NAN

    def __mapPos(self, t):
        assert(t >= -1*self.__lookBack and t <= self.__lookForward)
        return t + self.__lookBack

    def isComplete(self):
        return not any(np.isnan(self.__values))

    def getLookBack(self):
        return self.__lookBack

    def getLookForward(self):
        return self.__lookForward

    def setValue(self, t, value):
        if value is not None:
            pos = self.__mapPos(t)
            self.__values[pos] = value

    def getValue(self, t):
        pos = self.__mapPos(t)
        return self.__values[pos]

    def getValues(self):
        return self.__values


class Profiler(object):
    """This class is responsible for scanning over historical data and analyzing returns before
    and after the events.

    :param predicate: A :class:`Predicate` subclass responsible for identifying events.
    :type predicate: :class:`Predicate`.
    :param lookBack: The number of bars before the event to analyze. Must be > 0.
    :type lookBack: int.
    :param lookForward: The number of bars after the event to analyze. Must be > 0.
    :type lookForward: int.
    """

    def __init__(self, predicate, lookBack, lookForward):
        assert(lookBack > 0)
        assert(lookForward > 0)
        self.__predicate = predicate
        self.__lookBack = lookBack
        self.__lookForward = lookForward
        self.__feed = None
        self.__rets = {}
        self.__futureRets = {}
        self.__events = {}

    def __addPastReturns(self, instrument, event):
        begin = (event.getLookBack() + 1) * -1
        for t in xrange(begin, 0):
            try:
                ret = self.__rets[instrument][t]
                if ret is not None:
                    event.setValue(t+1, ret)
            except IndexError:
                pass

    def __addCurrentReturns(self, instrument):
        nextTs = []
        for event, t in self.__futureRets[instrument]:
            event.setValue(t, self.__rets[instrument][-1])
            if t < event.getLookForward():
                t += 1
                nextTs.append((event, t))
        self.__futureRets[instrument] = nextTs

    def __onBars(self, dateTime, bars):
        for instrument in bars.getInstruments():
            self.__addCurrentReturns(instrument)
            eventOccurred = self.__predicate.eventOccurred(instrument, self.__feed[instrument])
            if eventOccurred:
                event = Event(self.__lookBack, self.__lookForward)
                self.__events[instrument].append(event)
                self.__addPastReturns(instrument, event)
                # Add next return for this instrument at t=1.
                self.__futureRets[instrument].append((event, 1))

    def getResults(self):
        """Returns the results of the analysis.

        :rtype: :class:`Results`.
        """
        return Results(self.__events, self.__lookBack, self.__lookForward)

    def run(self, feed, useAdjustedCloseForReturns=True):
        """Runs the analysis using the bars supplied by the feed.

        :param barFeed: The bar feed to use to run the analysis.
        :type barFeed: :class:`pyalgotrade.barfeed.BarFeed`.
        :param useAdjustedCloseForReturns: True if adjusted close values should be used to calculate returns.
        :type useAdjustedCloseForReturns: boolean.
        """

        try:
            self.__feed = feed
            self.__rets = {}
            self.__futureRets = {}
            for instrument in feed.getRegisteredInstruments():
                self.__events.setdefault(instrument, [])
                self.__futureRets[instrument] = []
                if useAdjustedCloseForReturns:
                    ds = feed[instrument].getAdjCloseDataSeries()
                else:
                    ds = feed[instrument].getCloseDataSeries()
                self.__rets[instrument] = roc.RateOfChange(ds, 1)

            feed.getNewBarsEvent().subscribe(self.__onBars)
            disp = dispatcher.Dispatcher()
            disp.addSubject(feed)
            disp.run()
        finally:
            feed.getNewBarsEvent().unsubscribe(self.__onBars)


def build_plot(profilerResults):
    # Calculate each value.
    x = []
    y = []
    std = []
    for t in xrange(profilerResults.getLookBack()*-1, profilerResults.getLookForward()+1):
        x.append(t)
        values = np.asarray(profilerResults.getValues(t))
        y.append(values.mean())
        std.append(values.std())

    # Plot
    plt.clf()
    plt.plot(x, y, color='#0000FF')
    eventT = profilerResults.getLookBack()
    # stdBegin = eventT + 1
    # plt.errorbar(x[stdBegin:], y[stdBegin:], std[stdBegin:], alpha=0, ecolor='#AAAAFF')
    plt.errorbar(x[eventT+1:], y[eventT+1:], std[eventT+1:], alpha=0, ecolor='#AAAAFF')
    # plt.errorbar(x, y, std, alpha=0, ecolor='#AAAAFF')
    plt.axhline(y=y[eventT], xmin=-1*profilerResults.getLookBack(), xmax=profilerResults.getLookForward(), color='#000000')
    plt.xlim(profilerResults.getLookBack()*-1-0.5, profilerResults.getLookForward()+0.5)
    plt.xlabel('Time')
    plt.ylabel('Cumulative returns')


def plot(profilerResults):
    """Plots the result of the analysis.

    :param profilerResults: The result of the analysis
    :type profilerResults: :class:`Results`.
    """

    build_plot(profilerResults)
    plt.show()

########NEW FILE########
__FILENAME__ = execcontext
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

running_in_google_app_engine = False

########NEW FILE########
__FILENAME__ = csvfeed
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import abc
import datetime

from pyalgotrade.utils import dt
from pyalgotrade.utils import csvutils
from pyalgotrade.feed import memfeed
from pyalgotrade import dataseries


# Interface for csv row parsers.
class RowParser(object):

    __metaclass__ = abc.ABCMeta

    # Parses a row and returns a tuple with with two elements:
    # 1: datetime.datetime.
    # 2: dictionary or dict-like object.
    @abc.abstractmethod
    def parseRow(self, csvRowDict):
        raise NotImplementedError()

    # Returns a list of field names. If None, then the first row in the CSV should have the field names.
    @abc.abstractmethod
    def getFieldNames(self):
        raise NotImplementedError()

    # Returns the delimiter.
    @abc.abstractmethod
    def getDelimiter(self):
        raise NotImplementedError()


# Interface for bar filters.
class RowFilter(object):

    __metaclass__ = abc.ABCMeta

    @abc.abstractmethod
    def includeRow(self, dateTime, values):
        raise NotImplementedError()


class DateRangeFilter(RowFilter):
    def __init__(self, fromDate=None, toDate=None):
        self.__fromDate = fromDate
        self.__toDate = toDate

    def includeRow(self, dateTime, values):
        if self.__toDate and dateTime > self.__toDate:
            return False
        if self.__fromDate and dateTime < self.__fromDate:
            return False
        return True


class BaseFeed(memfeed.MemFeed):
    def __init__(self, rowParser, maxLen=dataseries.DEFAULT_MAX_LEN):
        memfeed.MemFeed.__init__(self, maxLen)
        self.__rowParser = rowParser
        self.__rowFilter = None

    def setRowFilter(self, rowFilter):
        self.__rowFilter = rowFilter

    def addValuesFromCSV(self, path):
        # Load the values from the csv file
        values = []
        reader = csvutils.FastDictReader(open(path, "r"), fieldnames=self.__rowParser.getFieldNames(), delimiter=self.__rowParser.getDelimiter())
        for row in reader:
            dateTime, rowValues = self.__rowParser.parseRow(row)
            if dateTime is not None and (self.__rowFilter is None or self.__rowFilter.includeRow(dateTime, rowValues)):
                values.append((dateTime, rowValues))

        self.addValues(values)


# This row parser doesn't support CSV files that have date and time in different columns.
class BasicRowParser(RowParser):
    def __init__(self, dateTimeColumn, dateTimeFormat, converter, delimiter=",", timezone=None):
        self.__dateTimeColumn = dateTimeColumn
        self.__dateTimeFormat = dateTimeFormat
        self.__converter = converter
        self.__delimiter = delimiter
        self.__timezone = timezone
        self.__timeDelta = None

    def parseRow(self, csvRowDict):
        dateTime = datetime.datetime.strptime(csvRowDict[self.__dateTimeColumn], self.__dateTimeFormat)
        # Localize the datetime if a timezone was given.
        if self.__timezone is not None:
            if self.__timeDelta is not None:
                dateTime += self.__timeDelta
            dateTime = dt.localize(dateTime, self.__timezone)
        # Convert the values
        values = {}
        for key, value in csvRowDict.items():
            if key != self.__dateTimeColumn:
                values[key] = self.__converter(key, value)
        return (dateTime, values)

    def getFieldNames(self):
        return None

    def getDelimiter(self):
        return self.__delimiter

    def setTimeDelta(self, timeDelta):
        self.__timeDelta = timeDelta


def float_or_string(column, value):
    try:
        ret = float(value)
    except Exception:
        ret = value
    return ret


class Feed(BaseFeed):
    """A feed that loads values from CSV formatted files.

    :param dateTimeColumn: The name of the column that has the datetime information.
    :type dateTimeColumn: string.
    :param dateTimeFormat: The datetime format. datetime.datetime.strptime will be used to parse the column.
    :type dateTimeFormat: string.
    :param converter: A function with two parameters (column name and value) used to convert the string
        value to something else. The default coverter will try to convert the value to a float. If that fails
        the original string is returned.
    :type converter: function.
    :param delimiter: The string used to separate values.
    :type delimiter: string.
    :param timezone: The timezone to use to localize datetimes. Check :mod:`pyalgotrade.marketsession`.
    :type timezone: A pytz timezone.
    :param maxLen: The maximum number of values that each :class:`pyalgotrade.dataseries.DataSeries` will hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, dateTimeColumn, dateTimeFormat, converter=None, delimiter=",", timezone=None, maxLen=dataseries.DEFAULT_MAX_LEN):
        if converter is None:
            converter = float_or_string
        self.__rowParser = BasicRowParser(dateTimeColumn, dateTimeFormat, converter, delimiter, timezone)
        BaseFeed.__init__(self, self.__rowParser, maxLen)

    def addValuesFromCSV(self, path):
        """Loads values from a file.

        :param path: The path to the CSV file.
        :type path: string.
        """
        return BaseFeed.addValuesFromCSV(self, path)

    def setDateRange(self, fromDateTime, toDateTime):
        self.setRowFilter(DateRangeFilter(fromDateTime, toDateTime))

    def setTimeDelta(self, timeDelta):
        self.__rowParser.setTimeDelta(timeDelta)

########NEW FILE########
__FILENAME__ = memfeed
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import feed
from pyalgotrade import dataseries


class MemFeed(feed.BaseFeed):
    def __init__(self, maxLen=dataseries.DEFAULT_MAX_LEN):
        feed.BaseFeed.__init__(self, maxLen)
        self.__values = []
        self.__nextIdx = 0

    def start(self):
        pass

    def stop(self):
        pass

    def join(self):
        pass

    def eof(self):
        if self.__nextIdx < len(self.__values):
            return False
        else:
            return True

    def peekDateTime(self):
        ret = None
        if self.__nextIdx < len(self.__values):
            ret = self.__values[self.__nextIdx][0]
        return ret

    def isRealTime(self):
        return False

    def createDataSeries(self, key, maxLen):
        return dataseries.SequenceDataSeries(maxLen)

    def getNextValues(self):
        ret = (None, None)
        if self.__nextIdx < len(self.__values):
            ret = self.__values[self.__nextIdx]
            self.__nextIdx += 1
        return ret

    # Add values to the feed. values should be a sequence of tupes. The tupes should have two elements:
    # 1: datetime.datetime.
    # 2: dictionary or dict-like object.
    def addValues(self, values):
        if len(values):
            # Register a dataseries for each item.
            for key in values[0][1].keys():
                self.registerDataSeries(key)

            self.__values.extend(values)
            cmpFun = lambda x, y: cmp(x[0], y[0])
            self.__values.sort(cmpFun)

########NEW FILE########
__FILENAME__ = logger
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import logging
import threading

initLock = threading.Lock()
rootLoggerInitialized = False

log_format = "%(asctime)s %(name)s [%(levelname)s] %(message)s"
level = logging.INFO
file_log = None  # File name
console_log = True


def init_handler(handler):
    handler.setFormatter(Formatter(log_format))


def init_logger(logger):
    logger.setLevel(level)

    if file_log is not None:
        fileHandler = logging.FileHandler(file_log)
        init_handler(fileHandler)
        logger.addHandler(fileHandler)

    if console_log:
        consoleHandler = logging.StreamHandler()
        init_handler(consoleHandler)
        logger.addHandler(consoleHandler)


def initialize():
    global rootLoggerInitialized
    with initLock:
        if not rootLoggerInitialized:
            init_logger(logging.getLogger())
            rootLoggerInitialized = True


def getLogger(name=None):
    initialize()
    return logging.getLogger(name)


# This formatter provides a way to hook in formatTime.
class Formatter(logging.Formatter):
    DATETIME_HOOK = None

    def formatTime(self, record, datefmt=None):
        newDateTime = None

        if Formatter.DATETIME_HOOK is not None:
            newDateTime = Formatter.DATETIME_HOOK()

        if newDateTime is None:
            ret = logging.Formatter.formatTime(self, record, datefmt)
        else:
            ret = str(newDateTime)
        return ret

########NEW FILE########
__FILENAME__ = marketsession
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import pytz


# http://en.wikipedia.org/wiki/List_of_market_opening_times
class MarketSession(object):
    """Base class for market sessions.

    .. note::
        This is a base class and should not be used directly.
    """

    @classmethod
    def getTimezone(cls):
        """Returns the pytz timezone for the market session."""
        return cls.timezone


######################################################################
# US

class NASDAQ(MarketSession):
    """NASDAQ market session."""
    timezone = pytz.timezone("US/Eastern")


class NYSE(MarketSession):
    """New York Stock Exchange market session."""
    timezone = pytz.timezone("US/Eastern")


class USEquities(MarketSession):
    """US Equities market session."""
    timezone = pytz.timezone("US/Eastern")


######################################################################
# South America

class MERVAL(MarketSession):
    """Buenos Aires (Argentina) market session."""
    timezone = pytz.timezone("America/Argentina/Buenos_Aires")


class BOVESPA(MarketSession):
    """BOVESPA (Brazil) market session."""
    timezone = pytz.timezone("America/Sao_Paulo")


######################################################################
# Europe

class FTSE(MarketSession):
    """ London Stock Exchange market session."""
    timezone = pytz.timezone("Europe/London")


######################################################################
# Asia

class TSE(MarketSession):
    """Tokyo Stock Exchange market session."""
    timezone = pytz.timezone("Asia/Tokyo")

########NEW FILE########
__FILENAME__ = observer
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import abc


class Event(object):
    def __init__(self):
        self.__handlers = []
        self.__toSubscribe = []
        self.__toUnsubscribe = []
        self.__emitting = False

    def __applyChanges(self):
        if len(self.__toSubscribe):
            for handler in self.__toSubscribe:
                if handler not in self.__handlers:
                    self.__handlers.append(handler)
            self.__toSubscribe = []

        if len(self.__toUnsubscribe):
            for handler in self.__toUnsubscribe:
                self.__handlers.remove(handler)
            self.__toUnsubscribe = []

    def subscribe(self, handler):
        if self.__emitting:
            self.__toSubscribe.append(handler)
        elif handler not in self.__handlers:
            self.__handlers.append(handler)

    def unsubscribe(self, handler):
        if self.__emitting:
            self.__toUnsubscribe.append(handler)
        else:
            self.__handlers.remove(handler)

    def emit(self, *args, **kwargs):
        try:
            self.__emitting = True
            for handler in self.__handlers:
                handler(*args, **kwargs)
        finally:
            self.__emitting = False
            self.__applyChanges()


class Subject(object):
    __metaclass__ = abc.ABCMeta

    # This may raise.
    @abc.abstractmethod
    def start(self):
        raise NotImplementedError()

    # This should not raise.
    @abc.abstractmethod
    def stop(self):
        raise NotImplementedError()

    # This should not raise.
    @abc.abstractmethod
    def join(self):
        raise NotImplementedError()

    # Return True if there are not more events to dispatch.
    @abc.abstractmethod
    def eof(self):
        raise NotImplementedError()

    # Dispatch events. If True is returned, it means that at least one event was dispatched.
    @abc.abstractmethod
    def dispatch(self):
        raise NotImplementedError()

    @abc.abstractmethod
    def peekDateTime(self):
        # Return the datetime for the next event.
        # This is needed to properly synchronize non-realtime subjects.
        raise NotImplementedError()

    def getDispatchPriority(self):
        # Returns a number (or None) used to sort subjects within the dispatch queue.
        # The return value should never change.
        return None

########NEW FILE########
__FILENAME__ = local
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import multiprocessing
import threading
import logging
import socket
import random
import os

from pyalgotrade.optimizer import server
from pyalgotrade.optimizer import worker


class ServerThread(threading.Thread):
    def __init__(self, server, barFeed, strategyParameters):
        threading.Thread.__init__(self)
        self.__server = server
        self.__barFeed = barFeed
        self.__strategyParameters = strategyParameters
        self.__results = None

    def getResults(self):
        return self.__results

    def run(self):
        self.__results = self.__server.serve(self.__barFeed, self.__strategyParameters)


def worker_process(strategyClass, port):
    class Worker(worker.Worker):
        def runStrategy(self, barFeed, *args, **kwargs):
            strat = strategyClass(barFeed, *args, **kwargs)
            strat.run()
            return strat.getResult()

    # Create a worker and run it.
    name = "worker-%s" % (os.getpid())
    w = Worker("localhost", port, name)
    w.getLogger().setLevel(logging.ERROR)
    w.run()


def find_port():
    while True:
        ret = random.randint(1025, 65536)
        try:
            s = socket.socket()
            s.bind(("localhost", ret))
            s.close()
            return ret
        except socket.error:
            pass


def run(strategyClass, barFeed, strategyParameters, workerCount=None):
    """Executes many instances of a strategy in parallel and finds the parameters that yield the best results.

    :param strategyClass: The strategy class.
    :param barFeed: The bar feed to use to backtest the strategy.
    :type barFeed: :class:`pyalgotrade.barfeed.BarFeed`.
    :param strategyParameters: The set of parameters to use for backtesting. An iterable object where **each element is a tuple that holds parameter values**.
    :param workerCount: The number of strategies to run in parallel. If None then as many workers as CPUs are used.
    :type workerCount: int.
    :rtype: A :class:`Results` instance with the best results found.
    """

    assert(workerCount is None or workerCount > 0)
    if workerCount is None:
        workerCount = multiprocessing.cpu_count()

    ret = None
    workers = []
    port = find_port()
    if port is None:
        raise Exception("Failed to find a port to listen")

    # Build and start the server thread before the worker processes. We'll manually stop the server once workers have finished.
    srv = server.Server("localhost", port, False)
    serverThread = ServerThread(srv, barFeed, strategyParameters)
    serverThread.start()

    try:
        # Build the worker processes.
        for i in range(workerCount):
            workers.append(multiprocessing.Process(target=worker_process, args=(strategyClass, port)))

        # Start workers
        for process in workers:
            process.start()

        # Wait workers
        for process in workers:
            process.join()

    finally:
        # Stop and wait the server to finish.
        srv.stop()
        serverThread.join()
        ret = serverThread.getResults()
    return ret

########NEW FILE########
__FILENAME__ = server
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import SimpleXMLRPCServer
import threading
import time
import pickle
import pyalgotrade.logger


class AutoStopThread(threading.Thread):
    def __init__(self, server):
        threading.Thread.__init__(self)
        self.__server = server

    def run(self):
        while self.__server.jobsPending():
            time.sleep(1)
        self.__server.stop()


class Results(object):
    """The results of the strategy executions."""
    def __init__(self, parameters, result):
        self.__parameters = parameters
        self.__result = result

    def getParameters(self):
        """Returns a sequence of parameter values."""
        return self.__parameters

    def getResult(self):
        """Returns the result for a given set of parameters."""
        return self.__result


class Job(object):
    def __init__(self, strategyParameters):
        self.__strategyParameters = strategyParameters
        self.__bestResult = None
        self.__bestParameters = None
        self.__id = id(self)

    def getId(self):
        return self.__id

    def getNextParameters(self):
        ret = None
        if len(self.__strategyParameters):
            ret = self.__strategyParameters.pop()
        return ret

    def getBestParameters(self):
        return self.__bestParameters

    def getBestResult(self):
        return self.__bestResult

    def getBestWorkerName(self):
        return self.__bestWorkerName

    def setBestResult(self, result, parameters, workerName):
        self.__bestResult = result
        self.__bestParameters = parameters
        self.__bestWorkerName = workerName


# Restrict to a particular path.
class RequestHandler(SimpleXMLRPCServer.SimpleXMLRPCRequestHandler):
    rpc_paths = ('/PyAlgoTradeRPC',)


class Server(SimpleXMLRPCServer.SimpleXMLRPCServer):
    defaultBatchSize = 200

    def __init__(self, address, port, autoStop=True):
        SimpleXMLRPCServer.SimpleXMLRPCServer.__init__(self, (address, port), requestHandler=RequestHandler, logRequests=False, allow_none=True)

        self.__instrumentsAndBars = None  # Pickle'd instruments and bars for faster retrieval.
        self.__barsFreq = None
        self.__activeJobs = {}
        self.__activeJobsLock = threading.Lock()
        self.__parametersLock = threading.Lock()
        self.__bestJob = None
        self.__parametersIterator = None
        self.__logger = pyalgotrade.logger.getLogger("server")
        if autoStop:
            self.__autoStopThread = AutoStopThread(self)
        else:
            self.__autoStopThread = None

        self.register_introspection_functions()
        self.register_function(self.getInstrumentsAndBars, 'getInstrumentsAndBars')
        self.register_function(self.getBarsFrequency, 'getBarsFrequency')
        self.register_function(self.getNextJob, 'getNextJob')
        self.register_function(self.pushJobResults, 'pushJobResults')
        self.__forcedStop = False

    def __getNextParams(self):
        ret = []

        # Get the next set of parameters.
        with self.__parametersLock:
            if self.__parametersIterator is not None:
                try:
                    for i in xrange(Server.defaultBatchSize):
                        ret.append(self.__parametersIterator.next())
                except StopIteration:
                    self.__parametersIterator = None
        return ret

    def getLogger(self):
        return self.__logger

    def getInstrumentsAndBars(self):
        return self.__instrumentsAndBars

    def getBarsFrequency(self):
        return str(self.__barsFreq)

    def getBestJob(self):
        return self.__bestJob

    def getNextJob(self):
        ret = None
        params = []

        # Get the next set of parameters.
        params = self.__getNextParams()

        # Map the active job
        if len(params):
            ret = Job(params)
            with self.__activeJobsLock:
                self.__activeJobs[ret.getId()] = ret

        return pickle.dumps(ret)

    def jobsPending(self):
        if self.__forcedStop:
            return False

        with self.__parametersLock:
            jobsPending = self.__parametersIterator is not None
        with self.__activeJobsLock:
            activeJobs = len(self.__activeJobs) > 0
        return jobsPending or activeJobs

    def pushJobResults(self, jobId, result, parameters, workerName):
        jobId = pickle.loads(jobId)
        result = pickle.loads(result)
        parameters = pickle.loads(parameters)
        workerName = pickle.loads(workerName)

        job = None

        # Get the active job and remove the mapping.
        with self.__activeJobsLock:
            try:
                job = self.__activeJobs[jobId]
                del self.__activeJobs[jobId]
            except KeyError:
                # The job's results were already submitted.
                return

        # Save the job with the best result
        if self.__bestJob is None or result > self.__bestJob.getBestResult():
            job.setBestResult(result, parameters, workerName)
            self.__bestJob = job

        self.getLogger().info("Partial result %s with parameters: %s from %s" % (result, parameters, workerName))

    def stop(self):
        self.shutdown()

    def serve(self, barFeed, strategyParameters):
        ret = None
        try:
            # Initialize instruments, bars and parameters.
            self.getLogger().info("Loading bars")
            loadedBars = []
            for dateTime, bars in barFeed:
                loadedBars.append(bars)
            instruments = barFeed.getRegisteredInstruments()
            self.__instrumentsAndBars = pickle.dumps((instruments, loadedBars))
            self.__barsFreq = barFeed.getFrequency()

            self.__parametersIterator = iter(strategyParameters)

            if self.__autoStopThread:
                self.__autoStopThread.start()

            self.getLogger().info("Waiting for workers")
            self.serve_forever()

            if self.__autoStopThread:
                self.__autoStopThread.join()

            # Show the best result.
            bestJob = self.getBestJob()
            if bestJob:
                self.getLogger().info("Best final result %s with parameters: %s from client %s" % (bestJob.getBestResult(), bestJob.getBestParameters(), bestJob.getBestWorkerName()))
                ret = Results(bestJob.getBestParameters(), bestJob.getBestResult())
            else:
                self.getLogger().error("No jobs processed")
        finally:
            self.__forcedStop = True
        return ret


def serve(barFeed, strategyParameters, address, port):
    """Executes a server that will provide bars and strategy parameters for workers to use.

    :param barFeed: The bar feed that each worker will use to backtest the strategy.
    :type barFeed: :class:`pyalgotrade.barfeed.BarFeed`.
    :param strategyParameters: The set of parameters to use for backtesting. An iterable object where **each element is a tuple that holds parameter values**.
    :param address: The address to listen for incoming worker connections.
    :type address: string.
    :param port: The port to listen for incoming worker connections.
    :type port: int.
    :rtype: A :class:`Results` instance with the best results found.
    """
    s = Server(address, port)
    return s.serve(barFeed, strategyParameters)

########NEW FILE########
__FILENAME__ = worker
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import xmlrpclib
import pickle
import time
import socket
import random
import multiprocessing

import pyalgotrade.logger
from pyalgotrade import barfeed


def call_function(function, *args, **kwargs):
    return function(*args, **kwargs)


def call_and_retry_on_network_error(function, retryCount, *args, **kwargs):
    ret = None
    while retryCount > 0:
        retryCount -= 1
        try:
            ret = call_function(function, *args, **kwargs)
            return ret
        except socket.error:
            time.sleep(random.randint(1, 3))
    ret = call_function(function, *args, **kwargs)
    return ret


class Worker(object):
    def __init__(self, address, port, workerName=None):
        url = "http://%s:%s/PyAlgoTradeRPC" % (address, port)
        self.__server = xmlrpclib.ServerProxy(url, allow_none=True)
        self.__logger = pyalgotrade.logger.getLogger(workerName)
        if workerName is None:
            self.__workerName = socket.gethostname()
        else:
            self.__workerName = workerName

    def getLogger(self):
        return self.__logger

    def getInstrumentsAndBars(self):
        ret = call_and_retry_on_network_error(self.__server.getInstrumentsAndBars, 10)
        ret = pickle.loads(ret)
        return ret

    def getBarsFrequency(self):
        ret = call_and_retry_on_network_error(self.__server.getBarsFrequency, 10)
        ret = int(ret)
        return ret

    def getNextJob(self):
        ret = call_and_retry_on_network_error(self.__server.getNextJob, 10)
        ret = pickle.loads(ret)
        return ret

    def pushJobResults(self, jobId, result, parameters):
        jobId = pickle.dumps(jobId)
        result = pickle.dumps(result)
        parameters = pickle.dumps(parameters)
        workerName = pickle.dumps(self.__workerName)
        call_and_retry_on_network_error(self.__server.pushJobResults, 10, jobId, result, parameters, workerName)

    def __processJob(self, job, barsFreq, instruments, bars):
        bestResult = None
        parameters = job.getNextParameters()
        bestParams = parameters
        while parameters is not None:
            # Wrap the bars into a feed.
            feed = barfeed.OptimizerBarFeed(barsFreq, instruments, bars)
            # Run the strategy.
            self.getLogger().info("Running strategy with parameters %s" % (str(parameters)))
            result = self.runStrategy(feed, *parameters)
            self.getLogger().info("Result %s" % result)
            if bestResult is None or result > bestResult:
                bestResult = result
                bestParams = parameters
            # Run with the next set of parameters.
            parameters = job.getNextParameters()

        assert(bestParams is not None)
        self.pushJobResults(job.getId(), bestResult, bestParams)

    # Run the strategy and return the result.
    def runStrategy(self, feed, parameters):
        raise Exception("Not implemented")

    def run(self):
        # Get the instruments and bars.
        instruments, bars = self.getInstrumentsAndBars()
        barsFreq = self.getBarsFrequency()

        # Process jobs
        job = self.getNextJob()
        while job is not None:
            self.__processJob(job, barsFreq, instruments, bars)
            job = self.getNextJob()


def worker_process(strategyClass, address, port, workerName):
    class MyWorker(Worker):
        def runStrategy(self, barFeed, *args, **kwargs):
            strat = strategyClass(barFeed, *args, **kwargs)
            strat.run()
            return strat.getResult()

    # Create a worker and run it.
    w = MyWorker(address, port, workerName)
    w.run()


def run(strategyClass, address, port, workerCount=None, workerName=None):
    """Executes one or more worker processes that will run a strategy with the bars and parameters supplied by the server.

    :param strategyClass: The strategy class.
    :param address: The address of the server.
    :type address: string.
    :param port: The port where the server is listening for incoming connections.
    :type port: int.
    :param workerCount: The number of worker processes to run. If None then as many workers as CPUs are used.
    :type workerCount: int.
    :param workerName: A name for the worker. A name that identifies the worker. If None, the hostname is used.
    :type workerName: string.
    """

    assert(workerCount is None or workerCount > 0)
    if workerCount is None:
        workerCount = multiprocessing.cpu_count()

    workers = []
    # Build the worker processes.
    for i in range(workerCount):
        workers.append(multiprocessing.Process(target=worker_process, args=(strategyClass, address, port, workerName)))

    # Start workers
    for process in workers:
        process.start()

    # Wait workers
    for process in workers:
        process.join()

########NEW FILE########
__FILENAME__ = plotter
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import collections

import broker

import matplotlib.pyplot as plt
from matplotlib import ticker
from matplotlib import finance
from matplotlib import dates


def get_last_value(dataSeries):
    ret = None
    try:
        ret = dataSeries[-1]
    except IndexError:
        pass
    return ret


def _filter_datetimes(dateTimes, fromDate=None, toDate=None):
    class DateTimeFilter(object):
        def __init__(self, fromDate=None, toDate=None):
            self.__fromDate = fromDate
            self.__toDate = toDate

        def includeDateTime(self, dateTime):
            if self.__toDate and dateTime > self.__toDate:
                return False
            if self.__fromDate and dateTime < self.__fromDate:
                return False
            return True

    dateTimeFilter = DateTimeFilter(fromDate, toDate)
    return filter(lambda x: dateTimeFilter.includeDateTime(x), dateTimes)


class Series(object):
    def __init__(self):
        self.__values = {}

    def getColor(self):
        return None

    def addValue(self, dateTime, value):
        self.__values[dateTime] = value

    def getValue(self, dateTime):
        return self.__values.get(dateTime, None)

    def getValues(self):
        self.__values

    def getMarker(self):
        raise NotImplementedError()

    def needColor(self):
        raise NotImplementedError()

    def plot(self, mplSubplot, dateTimes, color):
        values = []
        for dateTime in dateTimes:
            values.append(self.getValue(dateTime))
        mplSubplot.plot(dateTimes, values, color=color, marker=self.getMarker())


class BuyMarker(Series):
    def getColor(self):
        return 'g'

    def getMarker(self):
        return "^"

    def needColor(self):
        return True


class SellMarker(Series):
    def getColor(self):
        return 'r'

    def getMarker(self):
        return "v"

    def needColor(self):
        return True


class CustomMarker(Series):
    def __init__(self):
        Series.__init__(self)
        self.__marker = "o"

    def needColor(self):
        return True

    def setMarker(self, marker):
        self.__marker = marker

    def getMarker(self):
        return self.__marker


class LineMarker(Series):
    def __init__(self):
        Series.__init__(self)
        self.__marker = " "

    def needColor(self):
        return True

    def setMarker(self, marker):
        self.__marker = marker

    def getMarker(self):
        return self.__marker


class InstrumentMarker(Series):
    def __init__(self):
        Series.__init__(self)
        self.__useCandleSticks = False
        self.__useAdjClose = None
        self.__marker = " "

    def needColor(self):
        return not self.__useCandleSticks

    def setMarker(self, marker):
        self.__marker = marker

    def getMarker(self):
        return self.__marker

    def setUseAdjClose(self, useAdjClose):
        # Force close/adj_close instead of price.
        self.__useAdjClose = useAdjClose

    def getValue(self, dateTime):
        # If not using candlesticks, the return the closing price.
        ret = Series.getValue(self, dateTime)
        if not self.__useCandleSticks and ret is not None:
            if self.__useAdjClose is None:
                ret = ret.getPrice()
            elif self.__useAdjClose == True:
                ret = ret.getAdjClose()
            else:
                ret = ret.getClose()
        return ret

    def plot(self, mplSubplot, dateTimes, color):
        if self.__useCandleSticks:
            values = []
            for dateTime in dateTimes:
                bar = self.getValue(dateTime)
                if bar:
                    values.append((dates.date2num(dateTime), bar.getOpen(), bar.getClose(), bar.getHigh(), bar.getLow()))
            finance.candlestick(mplSubplot, values, width=0.5, colorup='g', colordown='r',)
        else:
            Series.plot(self, mplSubplot, dateTimes, color)


class HistogramMarker(Series):
    def needColor(self):
        return True

    def getColorForValue(self, value, default):
        return default

    def plot(self, mplSubplot, dateTimes, color):
        validDateTimes = []
        values = []
        colors = []
        for dateTime in dateTimes:
            value = self.getValue(dateTime)
            if value is not None:
                validDateTimes.append(dateTime)
                values.append(value)
                colors.append(self.getColorForValue(value, color))
        mplSubplot.bar(validDateTimes, values, color=colors)


class MACDMarker(HistogramMarker):
    def getColorForValue(self, value, default):
        ret = default
        if value >= 0:
            ret = "g"
        else:
            ret = "r"
        return ret


class Subplot(object):
    """ """
    colors = ['b', 'c', 'm', 'y', 'k']

    def __init__(self):
        self.__series = {}  # Series by name.
        self.__callbacks = {}  # Maps a function to a Series.
        self.__nextColor = 0

    def __getColor(self, series):
        ret = series.getColor()
        if ret is None:
            ret = Subplot.colors[self.__nextColor % len(Subplot.colors)]
            self.__nextColor += 1
        return ret

    def isEmpty(self):
        return len(self.__series) == 0

    def addDataSeries(self, label, dataSeries, defaultClass=LineMarker):
        """Add a DataSeries to the subplot.

        :param label: A name for the DataSeries values.
        :type label: string.
        :param dataSeries: The DataSeries to add.
        :type dataSeries: :class:`pyalgotrade.dataseries.DataSeries`.
        """
        callback = lambda bars: get_last_value(dataSeries)
        self.__callbacks[callback] = self.getSeries(label, defaultClass)

    def addCallback(self, label, callback, defaultClass=LineMarker):
        """Add a callback that will be called on each bar.

        :param label: A name for the series values.
        :type label: string.
        :param callback: A function that receives a :class:`pyalgotrade.bar.Bars` instance as a parameter and returns a number or None.
        """
        self.__callbacks[callback] = self.getSeries(label, defaultClass)

    def addLine(self, label, level):
        """Add a horizontal line to the plot.

        :param label: A label.
        :type label: string.
        :param level: The position for the line.
        :type level: int/float.
        """
        self.addCallback(label, lambda x: level)

    def onBars(self, bars):
        dateTime = bars.getDateTime()
        for cb, series in self.__callbacks.iteritems():
            series.addValue(dateTime, cb(bars))

    def getSeries(self, name, defaultClass=LineMarker):
        try:
            ret = self.__series[name]
        except KeyError:
            ret = defaultClass()
            self.__series[name] = ret
        return ret

    def getCustomMarksSeries(self, name):
        return self.getSeries(name, CustomMarker)

    def customizeSubplot(self, mplSubplot):
        # Don't scale the Y axis
        mplSubplot.yaxis.set_major_formatter(ticker.ScalarFormatter(useOffset=False))

    def plot(self, mplSubplot, dateTimes):
        for series in self.__series.values():
            color = None
            if series.needColor():
                color = self.__getColor(series)
            series.plot(mplSubplot, dateTimes, color)

        # Legend
        mplSubplot.legend(self.__series.keys(), shadow=True, loc="best")
        self.customizeSubplot(mplSubplot)


class InstrumentSubplot(Subplot):
    """A Subplot responsible for plotting an instrument."""
    def __init__(self, instrument, plotBuySell):
        Subplot.__init__(self)
        self.__instrument = instrument
        self.__plotBuySell = plotBuySell
        self.__instrumentSeries = self.getSeries(instrument, InstrumentMarker)

    def setUseAdjClose(self, useAdjClose):
        self.__instrumentSeries.setUseAdjClose(useAdjClose)

    def onBars(self, bars):
        Subplot.onBars(self, bars)
        bar = bars.getBar(self.__instrument)
        if bar:
            dateTime = bars.getDateTime()
            self.__instrumentSeries.addValue(dateTime, bar)

    def onOrderEvent(self, broker_, orderEvent):
        order = orderEvent.getOrder()
        if self.__plotBuySell and orderEvent.getEventType() in (broker.OrderEvent.Type.PARTIALLY_FILLED, broker.OrderEvent.Type.FILLED) and order.getInstrument() == self.__instrument:
            action = order.getAction()
            execInfo = orderEvent.getEventInfo()
            if action in [broker.Order.Action.BUY, broker.Order.Action.BUY_TO_COVER]:
                self.getSeries("Buy", BuyMarker).addValue(execInfo.getDateTime(), execInfo.getPrice())
            elif action in [broker.Order.Action.SELL, broker.Order.Action.SELL_SHORT]:
                self.getSeries("Sell", SellMarker).addValue(execInfo.getDateTime(), execInfo.getPrice())


class StrategyPlotter(object):
    """Class responsible for plotting a strategy execution.

    :param strat: The strategy to plot.
    :type strat: :class:`pyalgotrade.strategy.BaseStrategy`.
    :param plotAllInstruments: Set to True to get a subplot for each instrument available.
    :type plotAllInstruments: boolean.
    :param plotBuySell: Set to True to get the buy/sell events plotted for each instrument available.
    :type plotBuySell: boolean.
    :param plotPortfolio: Set to True to get the portfolio value (shares + cash) plotted.
    :type plotPortfolio: boolean.
    """

    def __init__(self, strat, plotAllInstruments=True, plotBuySell=True, plotPortfolio=True):
        self.__dateTimes = set()

        self.__plotAllInstruments = plotAllInstruments
        self.__plotBuySell = plotBuySell
        self.__barSubplots = {}
        self.__namedSubplots = collections.OrderedDict()
        self.__portfolioSubplot = None
        if plotPortfolio:
            self.__portfolioSubplot = Subplot()

        strat.getBarsProcessedEvent().subscribe(self.__onBarsProcessed)
        strat.getBroker().getOrderUpdatedEvent().subscribe(self.__onOrderEvent)

    def __checkCreateInstrumentSubplot(self, instrument):
        if instrument not in self.__barSubplots:
            self.getInstrumentSubplot(instrument)

    def __onBarsProcessed(self, strat, bars):
        dateTime = bars.getDateTime()
        self.__dateTimes.add(dateTime)

        if self.__plotAllInstruments:
            for instrument in bars.getInstruments():
                self.__checkCreateInstrumentSubplot(instrument)

        # Notify named subplots.
        for subplot in self.__namedSubplots.values():
            subplot.onBars(bars)

        # Notify bar subplots.
        for subplot in self.__barSubplots.values():
            subplot.onBars(bars)

        # Feed the portfolio evolution subplot.
        if self.__portfolioSubplot:
            self.__portfolioSubplot.getSeries("Portfolio").addValue(dateTime, strat.getBroker().getEquity())
            # This is in case additional dataseries were added to the portfolio subplot.
            self.__portfolioSubplot.onBars(bars)

    def __onOrderEvent(self, broker_, orderEvent):
        # Notify BarSubplots
        for subplot in self.__barSubplots.values():
            subplot.onOrderEvent(broker_, orderEvent)

    def getInstrumentSubplot(self, instrument):
        """Returns the InstrumentSubplot for a given instrument

        :rtype: :class:`InstrumentSubplot`.
        """
        try:
            ret = self.__barSubplots[instrument]
        except KeyError:
            ret = InstrumentSubplot(instrument, self.__plotBuySell)
            self.__barSubplots[instrument] = ret
        return ret

    def getOrCreateSubplot(self, name):
        """Returns a Subplot by name. If the subplot doesn't exist, it gets created.

        :param name: The name of the Subplot to get or create.
        :type name: string.
        :rtype: :class:`Subplot`.
        """
        try:
            ret = self.__namedSubplots[name]
        except KeyError:
            ret = Subplot()
            self.__namedSubplots[name] = ret
        return ret

    def getPortfolioSubplot(self):
        """Returns the subplot where the portfolio values get plotted.

        :rtype: :class:`Subplot`.
        """
        return self.__portfolioSubplot

    def __buildFigureImpl(self, fromDateTime=None, toDateTime=None):
        dateTimes = _filter_datetimes(self.__dateTimes, fromDateTime, toDateTime)
        dateTimes.sort()

        subplots = []
        subplots.extend(self.__barSubplots.values())
        subplots.extend(self.__namedSubplots.values())
        if self.__portfolioSubplot is not None:
            subplots.append(self.__portfolioSubplot)

        # Build each subplot.
        fig, axes = plt.subplots(nrows=len(subplots), sharex=True, squeeze=False)
        mplSubplots = []
        for i, subplot in enumerate(subplots):
            axesSubplot = axes[i][0]
            if not subplot.isEmpty():
                mplSubplots.append(axesSubplot)
                subplot.plot(axesSubplot, dateTimes)
                axesSubplot.grid(True)

        return (fig, mplSubplots)

    def buildFigure(self, fromDateTime=None, toDateTime=None):
        """Builds a matplotlib.figure.Figure with the subplots. Must be called after running the strategy.

        :param fromDateTime: An optional starting datetime.datetime. Everything before it won't get plotted.
        :type fromDateTime: datetime.datetime
        :param toDateTime: An optional ending datetime.datetime. Everything after it won't get plotted.
        :type toDateTime: datetime.datetime
        :rtype: matplotlib.figure.Figure.
        """
        fig, mplSubplots = self.__buildFigureImpl(fromDateTime, toDateTime)
        fig.autofmt_xdate()
        return fig

    def plot(self, fromDateTime=None, toDateTime=None):
        """Plots the strategy execution. Must be called after running the strategy.

        :param fromDateTime: An optional starting datetime.datetime. Everything before it won't get plotted.
        :type fromDateTime: datetime.datetime
        :param toDateTime: An optional ending datetime.datetime. Everything after it won't get plotted.
        :type toDateTime: datetime.datetime
        """

        fig, mplSubplots = self.__buildFigureImpl(fromDateTime, toDateTime)
        fig.autofmt_xdate()
        plt.show()

########NEW FILE########
__FILENAME__ = drawdown
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import stratanalyzer

import datetime


class DrawDownHelper(object):
    def __init__(self):
        self.__highWatermark = None
        self.__lowWatermark = None
        self.__lastLow = None
        self.__highDateTime = None
        self.__lastDateTime = None

    # The drawdown duration, not necessarily the max drawdown duration.
    def getDuration(self):
        return self.__lastDateTime - self.__highDateTime

    def getMaxDrawDown(self):
        return (self.__lowWatermark - self.__highWatermark) / float(self.__highWatermark)

    def getCurrentDrawDown(self):
        return (self.__lastLow - self.__highWatermark) / float(self.__highWatermark)

    def update(self, dateTime, low, high):
        assert(low <= high)
        self.__lastLow = low
        self.__lastDateTime = dateTime

        if self.__highWatermark is None or high >= self.__highWatermark:
            self.__highWatermark = high
            self.__lowWatermark = low
            self.__highDateTime = dateTime
        else:
            self.__lowWatermark = min(self.__lowWatermark, low)


class DrawDown(stratanalyzer.StrategyAnalyzer):
    """A :class:`pyalgotrade.stratanalyzer.StrategyAnalyzer` that calculates
    max. drawdown and longest drawdown duration for the portfolio."""

    def __init__(self):
        self.__maxDD = 0
        self.__longestDDDuration = datetime.timedelta()
        self.__currDrawDown = DrawDownHelper()

    def calculateEquity(self, strat):
        return strat.getBroker().getEquity()
        # ret = strat.getBroker().getCash()
        # for instrument, shares in strat.getBroker().getPositions().iteritems():
        #     _bar = strat.getFeed().getLastBar(instrument)
        #     if shares > 0:
        #         ret += strat.getBroker().getBarLow(_bar) * shares
        #     elif shares < 0:
        #         ret += strat.getBroker().getBarHigh(_bar) * shares
        # return ret

    def beforeOnBars(self, strat, bars):
        equity = self.calculateEquity(strat)
        self.__currDrawDown.update(bars.getDateTime(), equity, equity)
        self.__longestDDDuration = max(self.__longestDDDuration, self.__currDrawDown.getDuration())
        self.__maxDD = min(self.__maxDD, self.__currDrawDown.getMaxDrawDown())

    def getMaxDrawDown(self):
        """Returns the max. (deepest) drawdown."""
        return abs(self.__maxDD)

    def getLongestDrawDownDuration(self):
        """Returns the duration of the longest drawdown.

        :rtype: :class:`datetime.timedelta`.

        .. note::
            Note that this is the duration of the longest drawdown, not necessarily the deepest one.
        """
        return self.__longestDDDuration

########NEW FILE########
__FILENAME__ = returns
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import stratanalyzer
from pyalgotrade import observer
from pyalgotrade import dataseries


# Helper class to calculate returns and net profit.
class PositionTracker(object):
    def __init__(self):
        self.__shares = 0
        self.__cash = 0
        self.__commissions = 0
        self.__cost = 0

    def __updateCost(self, quantity, price):
        cost = 0

        if self.__shares > 0:  # Current position is long
            if quantity > 0:  # Increase long position
                cost = quantity * price
            else:
                diff = self.__shares + quantity
                if diff < 0:  # Entering a short position
                    cost = abs(diff) * price
        elif self.__shares < 0:  # Current position is short
            if quantity < 0:  # Increase short position
                cost = abs(quantity) * price
            else:
                diff = self.__shares + quantity
                if diff > 0:  # Entering a long position
                    cost = diff * price
        else:
            cost = abs(quantity) * price
        self.__cost += cost

    def getShares(self):
        return self.__shares

    def getCost(self):
        return self.__cost

    def getCommissions(self):
        return self.__commissions

    def getNetProfit(self, price, includeCommissions=True):
        ret = self.__cash + self.__shares * price
        if includeCommissions:
            ret -= self.__commissions
        return ret

    def getReturn(self, price, includeCommissions=True):
        ret = 0
        netProfit = self.getNetProfit(price, includeCommissions)
        cost = self.getCost()
        if cost != 0:
            ret = netProfit / float(cost)
        return ret

    def buy(self, quantity, price, commission=0):
        assert(quantity > 0)
        self.__updateCost(quantity, price)
        self.__cash += quantity * -1 * price
        self.__shares += quantity
        self.__commissions += commission

    def sell(self, quantity, price, commission=0):
        assert(quantity > 0)
        self.__updateCost(quantity * -1, price)
        self.__cash += quantity * price
        self.__shares -= quantity
        self.__commissions += commission

    def update(self, price):
        self.__commissions = 0
        self.__cash = self.__shares * -1 * price
        self.__cost = abs(self.__shares) * price


class ReturnsAnalyzerBase(stratanalyzer.StrategyAnalyzer):
    def __init__(self):
        self.__netRet = 0
        self.__cumRet = 0
        self.__event = observer.Event()
        self.__lastPortfolioValue = None

    @classmethod
    def getOrCreateShared(cls, strat):
        name = cls.__name__
        # Get or create the shared ReturnsAnalyzerBase.
        ret = strat.getNamedAnalyzer(name)
        if ret is None:
            ret = ReturnsAnalyzerBase()
            strat.attachAnalyzerEx(ret, name)
        return ret

    def attached(self, strat):
        self.__lastPortfolioValue = strat.getBroker().getEquity()

    # An event will be notified when return are calculated at each bar. The hander should receive 1 parameter:
    # 1: The current datetime.
    # 2: This analyzer's instance
    def getEvent(self):
        return self.__event

    def getNetReturn(self):
        return self.__netRet

    def getCumulativeReturn(self):
        return self.__cumRet

    def beforeOnBars(self, strat, bars):
        currentPortfolioValue = strat.getBroker().getEquity()
        netReturn = (currentPortfolioValue - self.__lastPortfolioValue) / float(self.__lastPortfolioValue)
        self.__lastPortfolioValue = currentPortfolioValue

        self.__netRet = netReturn

        # Calculate cumulative return.
        self.__cumRet = (1 + self.__cumRet) * (1 + netReturn) - 1

        # Notify that new returns are available.
        self.__event.emit(bars.getDateTime(), self)


class Returns(stratanalyzer.StrategyAnalyzer):
    """A :class:`pyalgotrade.stratanalyzer.StrategyAnalyzer` that calculates
    returns and cumulative returns for the whole portfolio."""

    def __init__(self):
        self.__netReturns = dataseries.SequenceDataSeries()
        self.__cumReturns = dataseries.SequenceDataSeries()

    def beforeAttach(self, strat):
        # Get or create a shared ReturnsAnalyzerBase
        analyzer = ReturnsAnalyzerBase.getOrCreateShared(strat)
        analyzer.getEvent().subscribe(self.__onReturns)

    def __onReturns(self, dateTime, returnsAnalyzerBase):
        self.__netReturns.append(returnsAnalyzerBase.getNetReturn())
        self.__cumReturns.append(returnsAnalyzerBase.getCumulativeReturn())

    def getReturns(self):
        """Returns a :class:`pyalgotrade.dataseries.DataSeries` with the returns for each bar."""
        return self.__netReturns

    def getCumulativeReturns(self):
        """Returns a :class:`pyalgotrade.dataseries.DataSeries` with the cumulative returns for each bar."""
        return self.__cumReturns

########NEW FILE########
__FILENAME__ = sharpe
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import stratanalyzer
from pyalgotrade.stratanalyzer import returns
from pyalgotrade.utils import stats

import math


def days_traded(begin, end):
    delta = end - begin
    ret = delta.days + 1
    return ret


# :param returns: The returns.
# :param riskFreeRate: The risk free rate per annum.
# :param tradingPeriods: The number of trading periods per annum.
# :param annualized: True if the sharpe ratio should be annualized.
# * If using daily bars, tradingPeriods should be set to 252.
# * If using hourly bars (with 6.5 trading hours a day) then tradingPeriods should be set to 252 * 6.5 = 1638.
def sharpe_ratio(returns, riskFreeRate, tradingPeriods, annualized=True):
    ret = 0.0

    # From http://en.wikipedia.org/wiki/Sharpe_ratio: if Rf is a constant risk-free return throughout the period,
    # then stddev(R - Rf) = stddev(R).
    volatility = stats.stddev(returns, 1)

    if volatility != 0:
        rfPerReturn = riskFreeRate / float(tradingPeriods)
        avgExcessReturns = stats.mean(returns) - rfPerReturn
        ret = avgExcessReturns / volatility

        if annualized:
            ret = ret * math.sqrt(tradingPeriods)
    return ret


# :param returns: The returns.
# :param riskFreeRate: The risk free rate per annum.
# :param firstDateTime: The first datetime in the period.
# :param lastDateTime: The last datetime in the period.
# :param annualized: True if the sharpe ratio should be annualized.
def sharpe_ratio_2(returns, riskFreeRate, firstDateTime, lastDateTime, annualized=True):
    ret = 0.0

    # From http://en.wikipedia.org/wiki/Sharpe_ratio:
    # if Rf is a constant risk-free return throughout the period, then stddev(R - Rf) = stddev(R).
    volatility = stats.stddev(returns, 1)

    if volatility != 0:
        # We use 365 instead of 252 becuase we wan't the diff from 1/1/xxxx to 12/31/xxxx to be 1 year.
        yearsTraded = days_traded(firstDateTime, lastDateTime) / 365.0

        riskFreeRateForPeriod = riskFreeRate * yearsTraded
        rfPerReturn = riskFreeRateForPeriod / float(len(returns))

        avgExcessReturns = stats.mean(returns) - rfPerReturn
        ret = avgExcessReturns / volatility
        if annualized:
            ret = ret * math.sqrt(len(returns) / yearsTraded)
    return ret


class SharpeRatio(stratanalyzer.StrategyAnalyzer):
    """A :class:`pyalgotrade.stratanalyzer.StrategyAnalyzer` that calculates
    Sharpe ratio for the whole portfolio.

    :param useDailyReturns: True if daily returns should be used instead of the returns for each bar.
    :type useDailyReturns: boolean.
    """

    def __init__(self, useDailyReturns=True):
        self.__useDailyReturns = useDailyReturns
        self.__returns = []

        # Only use when self.__useDailyReturns == False
        self.__firstDateTime = None
        self.__lastDateTime = None
        # Only use when self.__useDailyReturns == True
        self.__currentDate = None

    def getReturns(self):
        return self.__returns

    def beforeAttach(self, strat):
        # Get or create a shared ReturnsAnalyzerBase
        analyzer = returns.ReturnsAnalyzerBase.getOrCreateShared(strat)
        analyzer.getEvent().subscribe(self.__onReturns)

    def __onReturns(self, dateTime, returnsAnalyzerBase):
        netReturn = returnsAnalyzerBase.getNetReturn()
        if self.__useDailyReturns:
            # Calculate daily returns.
            if dateTime.date() == self.__currentDate:
                self.__returns[-1] = (1 + self.__returns[-1]) * (1 + netReturn) - 1
            else:
                self.__currentDate = dateTime.date()
                self.__returns.append(netReturn)
        else:
            self.__returns.append(netReturn)
            if self.__firstDateTime is None:
                self.__firstDateTime = dateTime
            self.__lastDateTime = dateTime

    def getSharpeRatio(self, riskFreeRate, annualized=True):
        """
        Returns the Sharpe ratio for the strategy execution. If the volatility is 0, 0 is returned.

        :param riskFreeRate: The risk free rate per annum.
        :type riskFreeRate: int/float.
        :param annualized: True if the sharpe ratio should be annualized.
        :type annualized: boolean.
        """

        if not isinstance(annualized, bool):
            raise Exception("tradingPeriods parameter is not supported anymore.")

        if self.__useDailyReturns:
            ret = sharpe_ratio(self.__returns, riskFreeRate, 252, annualized)
        else:
            ret = sharpe_ratio_2(self.__returns, riskFreeRate, self.__firstDateTime, self.__lastDateTime, annualized)
        return ret

########NEW FILE########
__FILENAME__ = trades
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import stratanalyzer
from pyalgotrade import broker
from pyalgotrade.stratanalyzer import returns

import numpy as np


class Trades(stratanalyzer.StrategyAnalyzer):
    """A :class:`pyalgotrade.stratanalyzer.StrategyAnalyzer` that records the profit/loss
    and returns of every completed trade.

    .. note::
        This analyzer operates on individual completed trades.
        For example, lets say you start with a $1000 cash, and then you buy 1 share of XYZ
        for $10 and later sell it for $20:

            * The trade's profit was $10.
            * The trade's return is 100%, even though your whole portfolio went from $1000 to $1020, a 2% return.
    """

    def __init__(self):
        self.__all = []
        self.__profits = []
        self.__losses = []
        self.__allReturns = []
        self.__positiveReturns = []
        self.__negativeReturns = []
        self.__allCommissions = []
        self.__profitableCommissions = []
        self.__unprofitableCommissions = []
        self.__evenCommissions = []
        self.__evenTrades = 0
        self.__posTrackers = {}

    def __updateTrades(self, posTracker):
        price = 0  # The price doesn't matter since the position should be closed.
        assert(posTracker.getShares() == 0)
        netProfit = posTracker.getNetProfit(price)
        netReturn = posTracker.getReturn(price)

        if netProfit > 0:
            self.__profits.append(netProfit)
            self.__positiveReturns.append(netReturn)
            self.__profitableCommissions.append(posTracker.getCommissions())
        elif netProfit < 0:
            self.__losses.append(netProfit)
            self.__negativeReturns.append(netReturn)
            self.__unprofitableCommissions.append(posTracker.getCommissions())
        else:
            self.__evenTrades += 1
            self.__evenCommissions.append(posTracker.getCommissions())

        self.__all.append(netProfit)
        self.__allReturns.append(netReturn)
        self.__allCommissions.append(posTracker.getCommissions())

        posTracker.update(price)

    def __updatePosTracker(self, posTracker, price, commission, quantity):
        currentShares = posTracker.getShares()

        if currentShares > 0:  # Current position is long
            if quantity > 0:  # Increase long position
                posTracker.buy(quantity, price, commission)
            else:
                newShares = currentShares + quantity
                if newShares == 0:  # Exit long.
                    posTracker.sell(currentShares, price, commission)
                    self.__updateTrades(posTracker)
                elif newShares > 0:  # Sell some shares.
                    posTracker.sell(quantity*-1, price, commission)
                else:  # Exit long and enter short. Use proportional commissions.
                    proportionalCommission = commission * currentShares / float(quantity*-1)
                    posTracker.sell(currentShares, price, proportionalCommission)
                    self.__updateTrades(posTracker)
                    proportionalCommission = commission * newShares / float(quantity)
                    posTracker.sell(newShares*-1, price, proportionalCommission)
        elif currentShares < 0:  # Current position is short
            if quantity < 0:  # Increase short position
                posTracker.sell(quantity*-1, price, commission)
            else:
                newShares = currentShares + quantity
                if newShares == 0:  # Exit short.
                    posTracker.buy(currentShares*-1, price, commission)
                    self.__updateTrades(posTracker)
                elif newShares < 0:  # Re-buy some shares.
                    posTracker.buy(quantity, price, commission)
                else:  # Exit short and enter long. Use proportional commissions.
                    proportionalCommission = commission * currentShares * -1 / float(quantity)
                    posTracker.buy(currentShares*-1, price, proportionalCommission)
                    self.__updateTrades(posTracker)
                    proportionalCommission = commission * newShares / float(quantity)
                    posTracker.buy(newShares, price, proportionalCommission)
        elif quantity > 0:
            posTracker.buy(quantity, price, commission)
        else:
            posTracker.sell(quantity*-1, price, commission)

    def __onOrderEvent(self, broker_, orderEvent):
        # Only interested in filled or partially filled orders.
        if orderEvent.getEventType() not in (broker.OrderEvent.Type.PARTIALLY_FILLED, broker.OrderEvent.Type.FILLED):
            return

        order = orderEvent.getOrder()

        # Get or create the tracker for this instrument.
        try:
            posTracker = self.__posTrackers[order.getInstrument()]
        except KeyError:
            posTracker = returns.PositionTracker()
            self.__posTrackers[order.getInstrument()] = posTracker

        # Update the tracker for this order.
        execInfo = orderEvent.getEventInfo()
        price = execInfo.getPrice()
        commission = execInfo.getCommission()
        action = order.getAction()
        if action in [broker.Order.Action.BUY, broker.Order.Action.BUY_TO_COVER]:
            quantity = execInfo.getQuantity()
        elif action in [broker.Order.Action.SELL, broker.Order.Action.SELL_SHORT]:
            quantity = execInfo.getQuantity() * -1
        else:  # Unknown action
            assert(False)

        self.__updatePosTracker(posTracker, price, commission, quantity)

    def attached(self, strat):
        strat.getBroker().getOrderUpdatedEvent().subscribe(self.__onOrderEvent)

    def getCount(self):
        """Returns the total number of trades."""
        return len(self.__all)

    def getProfitableCount(self):
        """Returns the number of profitable trades."""
        return len(self.__profits)

    def getUnprofitableCount(self):
        """Returns the number of unprofitable trades."""
        return len(self.__losses)

    def getEvenCount(self):
        """Returns the number of trades whose net profit was 0."""
        return self.__evenTrades

    def getAll(self):
        """Returns a numpy.array with the profits/losses for each trade."""
        return np.asarray(self.__all)

    def getProfits(self):
        """Returns a numpy.array with the profits for each profitable trade."""
        return np.asarray(self.__profits)

    def getLosses(self):
        """Returns a numpy.array with the losses for each unprofitable trade."""
        return np.asarray(self.__losses)

    def getAllReturns(self):
        """Returns a numpy.array with the returns for each trade."""
        return np.asarray(self.__allReturns)

    def getPositiveReturns(self):
        """Returns a numpy.array with the positive returns for each trade."""
        return np.asarray(self.__positiveReturns)

    def getNegativeReturns(self):
        """Returns a numpy.array with the negative returns for each trade."""
        return np.asarray(self.__negativeReturns)

    def getCommissionsForAllTrades(self):
        """Returns a numpy.array with the commissions for each trade."""
        return np.asarray(self.__allCommissions)

    def getCommissionsForProfitableTrades(self):
        """Returns a numpy.array with the commissions for each profitable trade."""
        return np.asarray(self.__profitableCommissions)

    def getCommissionsForUnprofitableTrades(self):
        """Returns a numpy.array with the commissions for each unprofitable trade."""
        return np.asarray(self.__unprofitableCommissions)

    def getCommissionsForEvenTrades(self):
        """Returns a numpy.array with the commissions for each trade whose net profit was 0."""
        return np.asarray(self.__evenCommissions)

########NEW FILE########
__FILENAME__ = position
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade.stratanalyzer import returns
from pyalgotrade import warninghelpers
from pyalgotrade import broker

import datetime


class PositionState(object):
    def onEnter(self, position):
        pass

    # Raise an exception if an order can't be submitted in the current state.
    def canSubmitOrder(self, position, order):
        raise NotImplementedError()

    def onOrderEvent(self, position, orderEvent):
        raise NotImplementedError()

    def isOpen(self, position):
        raise NotImplementedError()

    def exit(self, position, stopPrice=None, limitPrice=None, goodTillCanceled=None):
        raise NotImplementedError()


class WaitingEntryState(PositionState):
    def canSubmitOrder(self, position, order):
        if position.entryActive():
            raise Exception("The entry order is still active")

    def onOrderEvent(self, position, orderEvent):
        # Only entry order events are valid in this state.
        assert(position.getEntryOrder().getId() == orderEvent.getOrder().getId())

        if orderEvent.getEventType() in (broker.OrderEvent.Type.FILLED, broker.OrderEvent.Type.PARTIALLY_FILLED):
            position.switchState(OpenState())
            position.getStrategy().onEnterOk(position)
        elif orderEvent.getEventType() == broker.OrderEvent.Type.CANCELED:
            assert(position.getEntryOrder().getFilled() == 0)
            position.switchState(ClosedState())
            position.getStrategy().onEnterCanceled(position)

    def isOpen(self, position):
        return True

    def exit(self, position, stopPrice=None, limitPrice=None, goodTillCanceled=None):
        assert(position.getShares() == 0)
        assert(position.getEntryOrder().isActive())
        position.getStrategy().getBroker().cancelOrder(position.getEntryOrder())


class OpenState(PositionState):
    def onEnter(self, position):
        entryDateTime = position.getEntryOrder().getExecutionInfo().getDateTime()
        position.setEntryDateTime(entryDateTime)

    def canSubmitOrder(self, position, order):
        # Only exit orders should be submitted in this state.
        pass

    def onOrderEvent(self, position, orderEvent):
        if position.getExitOrder() and position.getExitOrder().getId() == orderEvent.getOrder().getId():
            if orderEvent.getEventType() == broker.OrderEvent.Type.FILLED:
                if position.getShares() == 0:
                    position.switchState(ClosedState())
                    position.getStrategy().onExitOk(position)
            elif orderEvent.getEventType() == broker.OrderEvent.Type.CANCELED:
                assert(position.getShares() != 0)
                position.getStrategy().onExitCanceled(position)
        elif position.getEntryOrder().getId() == orderEvent.getOrder().getId():
            # Nothing to do since the entry order may be completely filled or canceled after a partial fill.
            assert(position.getShares() != 0)
        else:
            raise Exception("Invalid order event '%s' in OpenState" % (orderEvent.getEventType()))

    def isOpen(self, position):
        return True

    def exit(self, position, stopPrice=None, limitPrice=None, goodTillCanceled=None):
        assert(position.getShares() != 0)

        # Fail if a previous exit order is active.
        if position.exitActive():
            raise Exception("Exit order is active and it should be canceled first")

        # If the entry order is active, request cancellation.
        if position.entryActive():
            position.getStrategy().getBroker().cancelOrder(position.getEntryOrder())

        position._submitExitOrder(stopPrice, limitPrice, goodTillCanceled)


class ClosedState(PositionState):
    def onEnter(self, position):
        # Set the exit datetime if the exit order was filled.
        if position.exitFilled():
            exitDateTime = position.getExitOrder().getExecutionInfo().getDateTime()
            position.setExitDateTime(exitDateTime)

        assert(position.getShares() == 0)
        position.getStrategy().unregisterPosition(position)

    def canSubmitOrder(self, position, order):
        raise Exception("The position is closed")

    def onOrderEvent(self, position, orderEvent):
        raise Exception("Invalid order event '%s' in ClosedState" % (orderEvent.getEventType()))

    def isOpen(self, position):
        return False

    def exit(self, position, stopPrice=None, limitPrice=None, goodTillCanceled=None):
        pass


class Position(object):
    """Base class for positions.

    Positions are higher level abstractions for placing orders.
    They are escentially a pair of entry-exit orders and allow
    to track returns and PnL easier that placing orders manually.

    :param strategy: The strategy that this position belongs to.
    :type strategy: :class:`pyalgotrade.strategy.BaseStrategy`.
    :param entryOrder: The order used to enter the position.
    :type entryOrder: :class:`pyalgotrade.broker.Order`
    :param goodTillCanceled: True if the entry order should be set as good till canceled.
    :type goodTillCanceled: boolean.
    :param allOrNone: True if the orders should be completely filled or not at all.
    :type allOrNone: boolean.

    .. note::
        This is a base class and should not be used directly.
    """

    def __init__(self, strategy, entryOrder, goodTillCanceled, allOrNone):
        # The order must be created but not submitted.
        assert(entryOrder.isInitial())

        self.__state = None
        self.__activeOrders = {}
        self.__shares = 0
        self.__strategy = strategy
        self.__entryOrder = None
        self.__entryDateTime = None
        self.__exitOrder = None
        self.__exitDateTime = None
        self.__posTracker = returns.PositionTracker()
        self.__allOrNone = allOrNone

        self.switchState(WaitingEntryState())

        entryOrder.setGoodTillCanceled(goodTillCanceled)
        entryOrder.setAllOrNone(allOrNone)
        self.__submitAndRegisterOrder(entryOrder)
        self.__entryOrder = entryOrder

    def __submitAndRegisterOrder(self, order):
        assert(order.isInitial())

        # Check if an order can be submitted in the current state.
        self.__state.canSubmitOrder(self, order)

        # This may raise an exception, so we wan't to submit the order before moving forward and registering the order in the strategy.
        self.getStrategy().getBroker().submitOrder(order)

        self.__activeOrders[order.getId()] = order
        self.getStrategy().registerPositionOrder(self, order)

    def setEntryDateTime(self, dateTime):
        self.__entryDateTime = dateTime

    def setExitDateTime(self, dateTime):
        self.__exitDateTime = dateTime

    def switchState(self, newState):
        self.__state = newState
        self.__state.onEnter(self)

    def getStrategy(self):
        return self.__strategy

    def getLastPrice(self):
        return self.__strategy.getLastPrice(self.getInstrument())

    def getActiveOrders(self):
        return self.__activeOrders.values()

    def getShares(self):
        """Returns the number of shares.
        This will be a possitive number for a long position, and a negative number for a short position.

        .. note::
            If the entry order was not filled, or if the position is closed, then the number of shares will be 0.
        """
        return self.__shares

    def entryActive(self):
        """Returns True if the entry order is active."""
        return self.__entryOrder is not None and self.__entryOrder.isActive()

    def entryFilled(self):
        """Returns True if the entry order was filled."""
        return self.__entryOrder is not None and self.__entryOrder.isFilled()

    def exitActive(self):
        """Returns True if the exit order is active."""
        return self.__exitOrder is not None and self.__exitOrder.isActive()

    def exitFilled(self):
        """Returns True if the exit order was filled."""
        return self.__exitOrder is not None and self.__exitOrder.isFilled()

    def getEntryOrder(self):
        """Returns the :class:`pyalgotrade.broker.Order` used to enter the position."""
        return self.__entryOrder

    def getExitOrder(self):
        """Returns the :class:`pyalgotrade.broker.Order` used to exit the position. If this position hasn't been closed yet, None is returned."""
        return self.__exitOrder

    def getInstrument(self):
        """Returns the instrument used for this position."""
        return self.__entryOrder.getInstrument()

    def getReturn(self, includeCommissions=True):
        """Calculates cumulative percentage returns up to this point.
        If the position is not closed, these will be unrealized returns.

        :param includeCommissions: True to include commisions in the calculation.
        :type includeCommissions: boolean.
        """

        ret = 0
        price = self.getLastPrice()
        if price is not None:
            ret = self.__posTracker.getReturn(price, includeCommissions)
        return ret

    def getUnrealizedReturn(self, price=None):
        # Deprecated in v0.15.
        warninghelpers.deprecation_warning("getUnrealizedReturn will be deprecated in the next version. Please use getReturn instead.", stacklevel=2)
        if price is not None:
            raise Exception("Setting the price to getUnrealizedReturn is no longer supported")
        return self.getReturn(False)

    def getPnL(self, includeCommissions=True):
        """Calculates PnL up to this point.
        If the position is not closed, these will be unrealized PnL.

        :param includeCommissions: True to include commisions in the calculation.
        :type includeCommissions: boolean.
        """

        ret = 0
        price = self.getLastPrice()
        if price is not None:
            ret = self.__posTracker.getNetProfit(price, includeCommissions)
        return ret

    def getNetProfit(self, includeCommissions=True):
        # Deprecated in v0.15.
        warninghelpers.deprecation_warning("getNetProfit will be deprecated in the next version. Please use getPnL instead.", stacklevel=2)
        return self.getPnL(includeCommissions)

    def getUnrealizedNetProfit(self, price=None):
        # Deprecated in v0.15.
        warninghelpers.deprecation_warning("getUnrealizedNetProfit will be deprecated in the next version. Please use getPnL instead.", stacklevel=2)
        if price is not None:
            raise Exception("Setting the price to getUnrealizedNetProfit is no longer supported")
        return self.getPnL(False)

    def getQuantity(self):
        # Deprecated in v0.15.
        warninghelpers.deprecation_warning("getQuantity will be deprecated in the next version. Please use abs(self.getShares()) instead.", stacklevel=2)
        return abs(self.getShares())

    def cancelEntry(self):
        """Cancels the entry order if its active."""
        if self.entryActive():
            self.getStrategy().getBroker().cancelOrder(self.getEntryOrder())

    def cancelExit(self):
        """Cancels the exit order if its active."""
        if self.exitActive():
            self.getStrategy().getBroker().cancelOrder(self.getExitOrder())

    def exitMarket(self, goodTillCanceled=None):
        """Submits a market order to close this position.

        :param goodTillCanceled: True if the exit order is good till canceled. If False then the order gets automatically canceled when the session closes. If None, then it will match the entry order.
        :type goodTillCanceled: boolean.

        .. note::
            * If the position is closed (entry canceled or exit filled) this won't have any effect.
            * If the exit order for this position is pending, an exception will be raised. The exit order should be canceled first.
            * If the entry order is active, cancellation will be requested.
        """

        self.__state.exit(self, None, None, goodTillCanceled)

    def exitLimit(self, limitPrice, goodTillCanceled=None):
        """Submits a limit order to close this position.

        :param limitPrice: The limit price.
        :type limitPrice: float.
        :param goodTillCanceled: True if the exit order is good till canceled. If False then the order gets automatically canceled when the session closes. If None, then it will match the entry order.
        :type goodTillCanceled: boolean.

        .. note::
            * If the position is closed (entry canceled or exit filled) this won't have any effect.
            * If the exit order for this position is pending, an exception will be raised. The exit order should be canceled first.
            * If the entry order is active, cancellation will be requested.
        """

        self.__state.exit(self, None, limitPrice, goodTillCanceled)

    def exitStop(self, stopPrice, goodTillCanceled=None):
        """Submits a stop order to close this position.

        :param stopPrice: The stop price.
        :type stopPrice: float.
        :param goodTillCanceled: True if the exit order is good till canceled. If False then the order gets automatically canceled when the session closes. If None, then it will match the entry order.
        :type goodTillCanceled: boolean.

        .. note::
            * If the position is closed (entry canceled or exit filled) this won't have any effect.
            * If the exit order for this position is pending, an exception will be raised. The exit order should be canceled first.
            * If the entry order is active, cancellation will be requested.
        """

        self.__state.exit(self, stopPrice, None, goodTillCanceled)

    def exitStopLimit(self, stopPrice, limitPrice, goodTillCanceled=None):
        """Submits a stop limit order to close this position.

        :param stopPrice: The stop price.
        :type stopPrice: float.
        :param limitPrice: The limit price.
        :type limitPrice: float.
        :param goodTillCanceled: True if the exit order is good till canceled. If False then the order gets automatically canceled when the session closes. If None, then it will match the entry order.
        :type goodTillCanceled: boolean.

        .. note::
            * If the position is closed (entry canceled or exit filled) this won't have any effect.
            * If the exit order for this position is pending, an exception will be raised. The exit order should be canceled first.
            * If the entry order is active, cancellation will be requested.
        """

        self.__state.exit(self, stopPrice, limitPrice, goodTillCanceled)

    def exit(self, stopPrice=None, limitPrice=None, goodTillCanceled=None):
        # Deprecated in v0.15.
        if stopPrice is None and limitPrice is None:
            warninghelpers.deprecation_warning("exit will be deprecated in the next version. Please use exitMarket instead.", stacklevel=2)
        elif stopPrice is None and limitPrice is not None:
            warninghelpers.deprecation_warning("exit will be deprecated in the next version. Please use exitLimit instead.", stacklevel=2)
        elif stopPrice is not None and limitPrice is None:
            warninghelpers.deprecation_warning("exit will be deprecated in the next version. Please use exitStop instead.", stacklevel=2)
        elif stopPrice is not None and limitPrice is not None:
            warninghelpers.deprecation_warning("exit will be deprecated in the next version. Please use exitStopLimit instead.", stacklevel=2)

        self.__state.exit(self, stopPrice, limitPrice, goodTillCanceled)

    def _submitExitOrder(self, stopPrice, limitPrice, goodTillCanceled):
        assert(not self.exitActive())

        exitOrder = self.buildExitOrder(stopPrice, limitPrice)

        # If goodTillCanceled was not set, match the entry order.
        if goodTillCanceled is None:
            goodTillCanceled = self.__entryOrder.getGoodTillCanceled()
        exitOrder.setGoodTillCanceled(goodTillCanceled)

        exitOrder.setAllOrNone(self.__allOrNone)

        self.__submitAndRegisterOrder(exitOrder)
        self.__exitOrder = exitOrder

    def onOrderEvent(self, orderEvent):
        self.__updatePosTracker(orderEvent)

        order = orderEvent.getOrder()
        if not order.isActive():
            del self.__activeOrders[order.getId()]

        # Update the number of shares.
        if orderEvent.getEventType() in (broker.OrderEvent.Type.PARTIALLY_FILLED, broker.OrderEvent.Type.FILLED):
            execInfo = orderEvent.getEventInfo()
            # roundQuantity is used to prevent bugs like the one triggered in testcases.bitstamp_test:TestCase.testRoundingBug
            if order.isBuy():
                self.__shares = order.getInstrumentTraits().roundQuantity(self.__shares + execInfo.getQuantity())
            else:
                self.__shares = order.getInstrumentTraits().roundQuantity(self.__shares - execInfo.getQuantity())

        self.__state.onOrderEvent(self, orderEvent)

    def __updatePosTracker(self, orderEvent):
        if orderEvent.getEventType() in (broker.OrderEvent.Type.PARTIALLY_FILLED, broker.OrderEvent.Type.FILLED):
            order = orderEvent.getOrder()
            execInfo = orderEvent.getEventInfo()
            if order.isBuy():
                self.__posTracker.buy(execInfo.getQuantity(), execInfo.getPrice(), execInfo.getCommission())
            else:
                self.__posTracker.sell(execInfo.getQuantity(), execInfo.getPrice(), execInfo.getCommission())

    def buildExitOrder(self, stopPrice, limitPrice):
        raise NotImplementedError()

    def isOpen(self):
        """Returns True if the position is open."""
        return self.__state.isOpen(self)

    def getAge(self):
        """Returns the duration in open state.

        :rtype: datetime.timedelta.

        .. note::
            * If the position is open, then the difference between the entry datetime and the datetime of the last bar is returned.
            * If the position is closed, then the difference between the entry datetime and the exit datetime is returned.
        """
        ret = datetime.timedelta()
        if self.__entryDateTime is not None:
            if self.__exitDateTime is not None:
                last = self.__exitDateTime
            else:
                last = self.__strategy.getCurrentDateTime()
            ret = last - self.__entryDateTime
        return ret


# This class is reponsible for order management in long positions.
class LongPosition(Position):
    def __init__(self, strategy, instrument, stopPrice, limitPrice, quantity, goodTillCanceled, allOrNone):
        if limitPrice is None and stopPrice is None:
            entryOrder = strategy.getBroker().createMarketOrder(broker.Order.Action.BUY, instrument, quantity, False)
        elif limitPrice is not None and stopPrice is None:
            entryOrder = strategy.getBroker().createLimitOrder(broker.Order.Action.BUY, instrument, limitPrice, quantity)
        elif limitPrice is None and stopPrice is not None:
            entryOrder = strategy.getBroker().createStopOrder(broker.Order.Action.BUY, instrument, stopPrice, quantity)
        elif limitPrice is not None and stopPrice is not None:
            entryOrder = strategy.getBroker().createStopLimitOrder(broker.Order.Action.BUY, instrument, stopPrice, limitPrice, quantity)
        else:
            assert(False)

        Position.__init__(self, strategy, entryOrder, goodTillCanceled, allOrNone)

    def buildExitOrder(self, stopPrice, limitPrice):
        quantity = self.getShares()
        assert(quantity > 0)
        if limitPrice is None and stopPrice is None:
            ret = self.getStrategy().getBroker().createMarketOrder(broker.Order.Action.SELL, self.getInstrument(), quantity, False)
        elif limitPrice is not None and stopPrice is None:
            ret = self.getStrategy().getBroker().createLimitOrder(broker.Order.Action.SELL, self.getInstrument(), limitPrice, quantity)
        elif limitPrice is None and stopPrice is not None:
            ret = self.getStrategy().getBroker().createStopOrder(broker.Order.Action.SELL, self.getInstrument(), stopPrice, quantity)
        elif limitPrice is not None and stopPrice is not None:
            ret = self.getStrategy().getBroker().createStopLimitOrder(broker.Order.Action.SELL, self.getInstrument(), stopPrice, limitPrice, quantity)
        else:
            assert(False)

        return ret


# This class is reponsible for order management in short positions.
class ShortPosition(Position):
    def __init__(self, strategy, instrument, stopPrice, limitPrice, quantity, goodTillCanceled, allOrNone):
        if limitPrice is None and stopPrice is None:
            entryOrder = strategy.getBroker().createMarketOrder(broker.Order.Action.SELL_SHORT, instrument, quantity, False)
        elif limitPrice is not None and stopPrice is None:
            entryOrder = strategy.getBroker().createLimitOrder(broker.Order.Action.SELL_SHORT, instrument, limitPrice, quantity)
        elif limitPrice is None and stopPrice is not None:
            entryOrder = strategy.getBroker().createStopOrder(broker.Order.Action.SELL_SHORT, instrument, stopPrice, quantity)
        elif limitPrice is not None and stopPrice is not None:
            entryOrder = strategy.getBroker().createStopLimitOrder(broker.Order.Action.SELL_SHORT, instrument, stopPrice, limitPrice, quantity)
        else:
            assert(False)

        Position.__init__(self, strategy, entryOrder, goodTillCanceled, allOrNone)

    def buildExitOrder(self, stopPrice, limitPrice):
        quantity = self.getShares() * -1
        assert(quantity > 0)
        if limitPrice is None and stopPrice is None:
            ret = self.getStrategy().getBroker().createMarketOrder(broker.Order.Action.BUY_TO_COVER, self.getInstrument(), quantity, False)
        elif limitPrice is not None and stopPrice is None:
            ret = self.getStrategy().getBroker().createLimitOrder(broker.Order.Action.BUY_TO_COVER, self.getInstrument(), limitPrice, quantity)
        elif limitPrice is None and stopPrice is not None:
            ret = self.getStrategy().getBroker().createStopOrder(broker.Order.Action.BUY_TO_COVER, self.getInstrument(), stopPrice, quantity)
        elif limitPrice is not None and stopPrice is not None:
            ret = self.getStrategy().getBroker().createStopLimitOrder(broker.Order.Action.BUY_TO_COVER, self.getInstrument(), stopPrice, limitPrice, quantity)
        else:
            assert(False)

        return ret

########NEW FILE########
__FILENAME__ = indicator
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import talib
import numpy


# Returns the last values of a dataseries as a numpy.array, or None if not enough values could be retrieved from the dataseries.
def value_ds_to_numpy(ds, count):
    ret = None
    try:
        values = ds[count*-1:]
        ret = numpy.array([float(value) for value in values])
    except IndexError:
        pass
    except TypeError:  # In case we try to convert None to float.
        pass
    return ret


# Returns the last open values of a bar dataseries as a numpy.array, or None if not enough values could be retrieved from the dataseries.
def bar_ds_open_to_numpy(barDs, count):
    return value_ds_to_numpy(barDs.getOpenDataSeries(), count)


# Returns the last high values of a bar dataseries as a numpy.array, or None if not enough values could be retrieved from the dataseries.
def bar_ds_high_to_numpy(barDs, count):
    return value_ds_to_numpy(barDs.getHighDataSeries(), count)


# Returns the last low values of a bar dataseries as a numpy.array, or None if not enough values could be retrieved from the dataseries.
def bar_ds_low_to_numpy(barDs, count):
    return value_ds_to_numpy(barDs.getLowDataSeries(), count)


# Returns the last close values of a bar dataseries as a numpy.array, or None if not enough values could be retrieved from the dataseries.
def bar_ds_close_to_numpy(barDs, count):
    return value_ds_to_numpy(barDs.getCloseDataSeries(), count)


# Returns the last volume values of a bar dataseries as a numpy.array, or None if not enough values could be retrieved from the dataseries.
def bar_ds_volume_to_numpy(barDs, count):
    return value_ds_to_numpy(barDs.getVolumeDataSeries(), count)


# Calls a talib function with the last values of a dataseries.
def call_talib_with_ds(ds, count, talibFunc, *args, **kwargs):
    data = value_ds_to_numpy(ds, count)
    if data is None:
        return None
    return talibFunc(data, *args, **kwargs)


# hlcv: High, Low, Close and Volume.
def call_talib_with_hlcv(barDs, count, talibFunc, *args, **kwargs):
    high = bar_ds_high_to_numpy(barDs, count)
    if high is None:
        return None

    low = bar_ds_low_to_numpy(barDs, count)
    if low is None:
        return None

    close = bar_ds_close_to_numpy(barDs, count)
    if close is None:
        return None

    volume = bar_ds_volume_to_numpy(barDs, count)
    if volume is None:
        return None

    return talibFunc(high, low, close, volume, *args, **kwargs)


def call_talib_with_hlc(barDs, count, talibFunc, *args, **kwargs):
    high = bar_ds_high_to_numpy(barDs, count)
    if high is None:
        return None

    low = bar_ds_low_to_numpy(barDs, count)
    if low is None:
        return None

    close = bar_ds_close_to_numpy(barDs, count)
    if close is None:
        return None

    return talibFunc(high, low, close, *args, **kwargs)


def call_talib_with_ohlc(barDs, count, talibFunc, *args, **kwargs):
    open_ = bar_ds_open_to_numpy(barDs, count)
    if open_ is None:
        return None

    high = bar_ds_high_to_numpy(barDs, count)
    if high is None:
        return None

    low = bar_ds_low_to_numpy(barDs, count)
    if low is None:
        return None

    close = bar_ds_close_to_numpy(barDs, count)
    if close is None:
        return None

    return talibFunc(open_, high, low, close, *args, **kwargs)


def call_talib_with_hl(barDs, count, talibFunc, *args, **kwargs):
    high = bar_ds_high_to_numpy(barDs, count)
    if high is None:
        return None

    low = bar_ds_low_to_numpy(barDs, count)
    if low is None:
        return None

    return talibFunc(high, low, *args, **kwargs)


######################################################################
## talib wrappers

def AD(barDs, count):
    """Chaikin A/D Line"""
    return call_talib_with_hlcv(barDs, count, talib.AD)


def ADOSC(barDs, count, fastperiod=-2**31, slowperiod=-2**31):
    """Chaikin A/D Oscillator"""
    return call_talib_with_hlcv(barDs, count, talib.ADOSC, fastperiod, slowperiod)


def ADX(barDs, count, timeperiod=-2**31):
    """Average Directional Movement Index"""
    return call_talib_with_hlc(barDs, count, talib.ADX, timeperiod)


def ADXR(barDs, count, timeperiod=-2**31):
    """Average Directional Movement Index Rating"""
    return call_talib_with_hlc(barDs, count, talib.ADXR, timeperiod)


def APO(ds, count, fastperiod=-2**31, slowperiod=-2**31, matype=0):
    """Absolute Price Oscillator"""
    return call_talib_with_ds(ds, count, talib.APO, fastperiod, slowperiod, matype)


def AROON(barDs, count, timeperiod=-2**31):
    """Aroon"""
    ret = call_talib_with_hl(barDs, count, talib.AROON, timeperiod)
    if ret is None:
        ret = (None, None)
    return ret


def AROONOSC(barDs, count, timeperiod=-2**31):
    """Aroon Oscillator"""
    return call_talib_with_hl(barDs, count, talib.AROONOSC, timeperiod)


def ATR(barDs, count, timeperiod=-2**31):
    """Average True Range"""
    return call_talib_with_hlc(barDs, count, talib.ATR, timeperiod)


def AVGPRICE(barDs, count):
    """Average Price"""
    return call_talib_with_ohlc(barDs, count, talib.AVGPRICE)


def BBANDS(ds, count, timeperiod=-2**31, nbdevup=-4e37, nbdevdn=-4e37, matype=0):
    """Bollinger Bands"""
    ret = call_talib_with_ds(ds, count, talib.BBANDS, timeperiod, nbdevup, nbdevdn, matype)
    if ret is None:
        ret = (None, None, None)
    return ret


def BETA(ds1, ds2, count, timeperiod=-2**31):
    """Beta"""
    data1 = value_ds_to_numpy(ds1, count)
    if data1 is None:
        return None
    data2 = value_ds_to_numpy(ds2, count)
    if data2 is None:
        return None
    return talib.BETA(data1, data2, timeperiod)


def BOP(barDs, count):
    """Balance Of Power"""
    return call_talib_with_ohlc(barDs, count, talib.BOP)


def CCI(barDs, count, timeperiod=-2**31):
    """Commodity Channel Index"""
    return call_talib_with_hlc(barDs, count, talib.CCI, timeperiod)


def CDL2CROWS(barDs, count):
    """Two Crows"""
    return call_talib_with_ohlc(barDs, count, talib.CDL2CROWS)


def CDL3BLACKCROWS(barDs, count):
    """Three Black Crows"""
    return call_talib_with_ohlc(barDs, count, talib.CDL3BLACKCROWS)


def CDL3INSIDE(barDs, count):
    """Three Inside Up/Down"""
    return call_talib_with_ohlc(barDs, count, talib.CDL3INSIDE)


def CDL3LINESTRIKE(barDs, count):
    """Three-Line Strike"""
    return call_talib_with_ohlc(barDs, count, talib.CDL3LINESTRIKE)


def CDL3OUTSIDE(barDs, count):
    """Three Outside Up/Down"""
    return call_talib_with_ohlc(barDs, count, talib.CDL3OUTSIDE)


def CDL3STARSINSOUTH(barDs, count):
    """Three Stars In The South"""
    return call_talib_with_ohlc(barDs, count, talib.CDL3STARSINSOUTH)


def CDL3WHITESOLDIERS(barDs, count):
    """Three Advancing White Soldiers"""
    return call_talib_with_ohlc(barDs, count, talib.CDL3WHITESOLDIERS)


def CDLABANDONEDBABY(barDs, count, penetration=-4e37):
    """Abandoned Baby"""
    return call_talib_with_ohlc(barDs, count, talib.CDLABANDONEDBABY, penetration)


def CDLADVANCEBLOCK(barDs, count):
    """Advance Block"""
    return call_talib_with_ohlc(barDs, count, talib.CDLADVANCEBLOCK)


def CDLBELTHOLD(barDs, count):
    """Belt-hold"""
    return call_talib_with_ohlc(barDs, count, talib.CDLBELTHOLD)


def CDLBREAKAWAY(barDs, count):
    """Breakaway"""
    return call_talib_with_ohlc(barDs, count, talib.CDLBREAKAWAY)


def CDLCLOSINGMARUBOZU(barDs, count):
    """Closing Marubozu"""
    return call_talib_with_ohlc(barDs, count, talib.CDLCLOSINGMARUBOZU)


def CDLCONCEALBABYSWALL(barDs, count):
    """Concealing Baby Swallow"""
    return call_talib_with_ohlc(barDs, count, talib.CDLCONCEALBABYSWALL)


def CDLCOUNTERATTACK(barDs, count):
    """Counterattack"""
    return call_talib_with_ohlc(barDs, count, talib.CDLCOUNTERATTACK)


def CDLDARKCLOUDCOVER(barDs, count, penetration=-4e37):
    """Dark Cloud Cover"""
    return call_talib_with_ohlc(barDs, count, talib.CDLDARKCLOUDCOVER, penetration)


def CDLDOJI(barDs, count):
    """Doji"""
    return call_talib_with_ohlc(barDs, count, talib.CDLDOJI)


def CDLDOJISTAR(barDs, count):
    """Doji Star"""
    return call_talib_with_ohlc(barDs, count, talib.CDLDOJISTAR)


def CDLDRAGONFLYDOJI(barDs, count):
    """Dragonfly Doji"""
    return call_talib_with_ohlc(barDs, count, talib.CDLDRAGONFLYDOJI)


def CDLENGULFING(barDs, count):
    """Engulfing Pattern"""
    return call_talib_with_ohlc(barDs, count, talib.CDLENGULFING)


def CDLEVENINGDOJISTAR(barDs, count, penetration=-4e37):
    """Evening Doji Star"""
    return call_talib_with_ohlc(barDs, count, talib.CDLEVENINGDOJISTAR, penetration)


def CDLEVENINGSTAR(barDs, count, penetration=-4e37):
    """Evening Star"""
    return call_talib_with_ohlc(barDs, count, talib.CDLEVENINGSTAR, penetration)


def CDLGAPSIDESIDEWHITE(barDs, count):
    """Up/Down-gap side-by-side white lines"""
    return call_talib_with_ohlc(barDs, count, talib.CDLGAPSIDESIDEWHITE)


def CDLGRAVESTONEDOJI(barDs, count):
    """Gravestone Doji"""
    return call_talib_with_ohlc(barDs, count, talib.CDLGRAVESTONEDOJI)


def CDLHAMMER(barDs, count):
    """Hammer"""
    return call_talib_with_ohlc(barDs, count, talib.CDLHAMMER)


def CDLHANGINGMAN(barDs, count):
    """Hanging Man"""
    return call_talib_with_ohlc(barDs, count, talib.CDLHANGINGMAN)


def CDLHARAMI(barDs, count):
    """Harami Pattern"""
    return call_talib_with_ohlc(barDs, count, talib.CDLHARAMI)


def CDLHARAMICROSS(barDs, count):
    """Harami Cross Pattern"""
    return call_talib_with_ohlc(barDs, count, talib.CDLHARAMICROSS)


def CDLHIGHWAVE(barDs, count):
    """High-Wave Candle"""
    return call_talib_with_ohlc(barDs, count, talib.CDLHIGHWAVE)


def CDLHIKKAKE(barDs, count):
    """Hikkake Pattern"""
    return call_talib_with_ohlc(barDs, count, talib.CDLHIKKAKE)


def CDLHIKKAKEMOD(barDs, count):
    """Modified Hikkake Pattern"""
    return call_talib_with_ohlc(barDs, count, talib.CDLHIKKAKEMOD)


def CDLHOMINGPIGEON(barDs, count):
    """Homing Pigeon"""
    return call_talib_with_ohlc(barDs, count, talib.CDLHOMINGPIGEON)


def CDLIDENTICAL3CROWS(barDs, count):
    """Identical Three Crows"""
    return call_talib_with_ohlc(barDs, count, talib.CDLIDENTICAL3CROWS)


def CDLINNECK(barDs, count):
    """In-Neck Pattern"""
    return call_talib_with_ohlc(barDs, count, talib.CDLINNECK)


def CDLINVERTEDHAMMER(barDs, count):
    """Inverted Hammer"""
    return call_talib_with_ohlc(barDs, count, talib.CDLINVERTEDHAMMER)


def CDLKICKING(barDs, count):
    """Kicking"""
    return call_talib_with_ohlc(barDs, count, talib.CDLKICKING)


def CDLKICKINGBYLENGTH(barDs, count):
    """Kicking - bull/bear determined by the longer marubozu"""
    return call_talib_with_ohlc(barDs, count, talib.CDLKICKINGBYLENGTH)


def CDLLADDERBOTTOM(barDs, count):
    """Ladder Bottom"""
    return call_talib_with_ohlc(barDs, count, talib.CDLLADDERBOTTOM)


def CDLLONGLEGGEDDOJI(barDs, count):
    """Long Legged Doji"""
    return call_talib_with_ohlc(barDs, count, talib.CDLLONGLEGGEDDOJI)


def CDLLONGLINE(barDs, count):
    """Long Line Candle"""
    return call_talib_with_ohlc(barDs, count, talib.CDLLONGLINE)


def CDLMARUBOZU(barDs, count):
    """Marubozu"""
    return call_talib_with_ohlc(barDs, count, talib.CDLMARUBOZU)


def CDLMATCHINGLOW(barDs, count):
    """Matching Low"""
    return call_talib_with_ohlc(barDs, count, talib.CDLMATCHINGLOW)


def CDLMATHOLD(barDs, count, penetration=-4e37):
    """Mat Hold"""
    return call_talib_with_ohlc(barDs, count, talib.CDLMATHOLD, penetration)


def CDLMORNINGDOJISTAR(barDs, count, penetration=-4e37):
    """Morning Doji Star"""
    return call_talib_with_ohlc(barDs, count, talib.CDLMORNINGDOJISTAR, penetration)


def CDLMORNINGSTAR(barDs, count, penetration=-4e37):
    """Morning Star"""
    return call_talib_with_ohlc(barDs, count, talib.CDLMORNINGSTAR, penetration)


def CDLONNECK(barDs, count):
    """On-Neck Pattern"""
    return call_talib_with_ohlc(barDs, count, talib.CDLONNECK)


def CDLPIERCING(barDs, count):
    """Piercing Pattern"""
    return call_talib_with_ohlc(barDs, count, talib.CDLPIERCING)


def CDLRICKSHAWMAN(barDs, count):
    """Rickshaw Man"""
    return call_talib_with_ohlc(barDs, count, talib.CDLRICKSHAWMAN)


def CDLRISEFALL3METHODS(barDs, count):
    """Rising/Falling Three Methods"""
    return call_talib_with_ohlc(barDs, count, talib.CDLRISEFALL3METHODS)


def CDLSEPARATINGLINES(barDs, count):
    """Separating Lines"""
    return call_talib_with_ohlc(barDs, count, talib.CDLSEPARATINGLINES)


def CDLSHOOTINGSTAR(barDs, count):
    """Shooting Star"""
    return call_talib_with_ohlc(barDs, count, talib.CDLSHOOTINGSTAR)


def CDLSHORTLINE(barDs, count):
    """Short Line Candle"""
    return call_talib_with_ohlc(barDs, count, talib.CDLSHORTLINE)


def CDLSPINNINGTOP(barDs, count):
    """Spinning Top"""
    return call_talib_with_ohlc(barDs, count, talib.CDLSPINNINGTOP)


def CDLSTALLEDPATTERN(barDs, count):
    """Stalled Pattern"""
    return call_talib_with_ohlc(barDs, count, talib.CDLSTALLEDPATTERN)


def CDLSTICKSANDWICH(barDs, count):
    """Stick Sandwich"""
    return call_talib_with_ohlc(barDs, count, talib.CDLSTICKSANDWICH)


def CDLTAKURI(barDs, count):
    """Takuri (Dragonfly Doji with very long lower shadow)"""
    return call_talib_with_ohlc(barDs, count, talib.CDLTAKURI)


def CDLTASUKIGAP(barDs, count):
    """Tasuki Gap"""
    return call_talib_with_ohlc(barDs, count, talib.CDLTASUKIGAP)


def CDLTHRUSTING(barDs, count):
    """Thrusting Pattern"""
    return call_talib_with_ohlc(barDs, count, talib.CDLTHRUSTING)


def CDLTRISTAR(barDs, count):
    """Tristar Pattern"""
    return call_talib_with_ohlc(barDs, count, talib.CDLTRISTAR)


def CDLUNIQUE3RIVER(barDs, count):
    """Unique 3 River"""
    return call_talib_with_ohlc(barDs, count, talib.CDLUNIQUE3RIVER)


def CDLUPSIDEGAP2CROWS(barDs, count):
    """Upside Gap Two Crows"""
    return call_talib_with_ohlc(barDs, count, talib.CDLUPSIDEGAP2CROWS)


def CDLXSIDEGAP3METHODS(barDs, count):
    """Upside/Downside Gap Three Methods"""
    return call_talib_with_ohlc(barDs, count, talib.CDLXSIDEGAP3METHODS)


def CMO(ds, count, timeperiod=-2**31):
    """Chande Momentum Oscillator"""
    return call_talib_with_ds(ds, count, talib.CMO, timeperiod)


def CORREL(ds1, ds2, count, timeperiod=-2**31):
    """Pearson's Correlation Coefficient (r)"""
    data1 = value_ds_to_numpy(ds1, count)
    if data1 is None:
        return None
    data2 = value_ds_to_numpy(ds2, count)
    if data2 is None:
        return None
    return talib.CORREL(data1, data2, timeperiod)


def DEMA(ds, count, timeperiod=-2**31):
    """Double Exponential Moving Average"""
    return call_talib_with_ds(ds, count, talib.DEMA, timeperiod)


def DX(barDs, count, timeperiod=-2**31):
    """Directional Movement Index"""
    return call_talib_with_hlc(barDs, count, talib.DX, timeperiod)


def EMA(ds, count, timeperiod=-2**31):
    """Exponential Moving Average"""
    return call_talib_with_ds(ds, count, talib.EMA, timeperiod)


def HT_DCPERIOD(ds, count):
    """Hilbert Transform - Dominant Cycle Period"""
    return call_talib_with_ds(ds, count, talib.HT_DCPERIOD)


def HT_DCPHASE(ds, count):
    """Hilbert Transform - Dominant Cycle Phase"""
    return call_talib_with_ds(ds, count, talib.HT_DCPHASE)


def HT_PHASOR(ds, count):
    """Hilbert Transform - Phasor Components"""
    ret = call_talib_with_ds(ds, count, talib.HT_PHASOR)
    if ret is None:
        ret = (None, None)
    return ret


def HT_SINE(ds, count):
    """Hilbert Transform - SineWave"""
    ret = call_talib_with_ds(ds, count, talib.HT_SINE)
    if ret is None:
        ret = (None, None)
    return ret


def HT_TRENDLINE(ds, count):
    """Hilbert Transform - Instantaneous Trendline"""
    return call_talib_with_ds(ds, count, talib.HT_TRENDLINE)


def HT_TRENDMODE(ds, count):
    """Hilbert Transform - Trend vs Cycle Mode"""
    return call_talib_with_ds(ds, count, talib.HT_TRENDMODE)


def KAMA(ds, count, timeperiod=-2**31):
    """Kaufman Adaptive Moving Average"""
    return call_talib_with_ds(ds, count, talib.KAMA, timeperiod)


def LINEARREG(ds, count, timeperiod=-2**31):
    """Linear Regression"""
    return call_talib_with_ds(ds, count, talib.LINEARREG, timeperiod)


def LINEARREG_ANGLE(ds, count, timeperiod=-2**31):
    """Linear Regression Angle"""
    return call_talib_with_ds(ds, count, talib.LINEARREG_ANGLE, timeperiod)


def LINEARREG_INTERCEPT(ds, count, timeperiod=-2**31):
    """Linear Regression Intercept"""
    return call_talib_with_ds(ds, count, talib.LINEARREG_INTERCEPT, timeperiod)


def LINEARREG_SLOPE(ds, count, timeperiod=-2**31):
    """Linear Regression Slope"""
    return call_talib_with_ds(ds, count, talib.LINEARREG_SLOPE, timeperiod)


def MA(ds, count, timeperiod=-2**31, matype=0):
    """All Moving Average"""
    return call_talib_with_ds(ds, count, talib.MA, timeperiod, matype)


def MACD(ds, count, fastperiod=-2**31, slowperiod=-2**31, signalperiod=-2**31):
    """Moving Average Convergence/Divergence"""
    ret = call_talib_with_ds(ds, count, talib.MACD, fastperiod, slowperiod, signalperiod)
    if ret is None:
        ret = (None, None, None)
    return ret


def MACDEXT(ds, count, fastperiod=-2**31, fastmatype=0, slowperiod=-2**31, slowmatype=0, signalperiod=-2**31, signalmatype=0):
    """MACD with controllable MA type"""
    ret = call_talib_with_ds(ds, count, talib.MACDEXT, fastperiod, fastmatype, slowperiod, slowmatype, signalperiod, signalmatype)
    if ret is None:
        ret = (None, None, None)
    return ret


def MACDFIX(ds, count, signalperiod=-2**31):
    """Moving Average Convergence/Divergence Fix 12/26"""
    ret = call_talib_with_ds(ds, count, talib.MACDFIX, signalperiod)
    if ret is None:
        ret = (None, None, None)
    return ret


def MAMA(ds, count, fastlimit=-4e37, slowlimit=-4e37):
    """MESA Adaptive Moving Average"""
    ret = call_talib_with_ds(ds, count, talib.MAMA, fastlimit, slowlimit)
    if ret is None:
        ret = (None, None)
    return ret


def MAX(ds, count, timeperiod=-2**31):
    """Highest value over a specified period"""
    return call_talib_with_ds(ds, count, talib.MAX, timeperiod)


def MAXINDEX(ds, count, timeperiod=-2**31):
    """Index of highest value over a specified period"""
    return call_talib_with_ds(ds, count, talib.MAXINDEX, timeperiod)


def MEDPRICE(barDs, count):
    """Median Price"""
    return call_talib_with_hl(barDs, count, talib.MEDPRICE)


def MFI(barDs, count, timeperiod=-2**31):
    """Money Flow Index"""
    return call_talib_with_hlcv(barDs, count, talib.MFI, timeperiod)


def MIDPOINT(ds, count, timeperiod=-2**31):
    """MidPoint over period"""
    return call_talib_with_ds(ds, count, talib.MIDPOINT, timeperiod)


def MIDPRICE(barDs, count, timeperiod=-2**31):
    """Midpoint Price over period"""
    return call_talib_with_hl(barDs, count, talib.MIDPRICE, timeperiod)


def MIN(ds, count, timeperiod=-2**31):
    """Lowest value over a specified period"""
    return call_talib_with_ds(ds, count, talib.MIN, timeperiod)


def MININDEX(ds, count, timeperiod=-2**31):
    """Index of lowest value over a specified period"""
    return call_talib_with_ds(ds, count, talib.MININDEX, timeperiod)


def MINMAX(ds, count, timeperiod=-2**31):
    """Lowest and highest values over a specified period"""
    ret = call_talib_with_ds(ds, count, talib.MINMAX, timeperiod)
    if ret is None:
        ret = (None, None)
    return ret


def MINMAXINDEX(ds, count, timeperiod=-2**31):
    """Indexes of lowest and highest values over a specified period"""
    ret = call_talib_with_ds(ds, count, talib.MINMAXINDEX, timeperiod)
    if ret is None:
        ret = (None, None)
    return ret


def MINUS_DI(barDs, count, timeperiod=-2**31):
    """Minus Directional Indicator"""
    return call_talib_with_hlc(barDs, count, talib.MINUS_DI, timeperiod)


def MINUS_DM(barDs, count, timeperiod=-2**31):
    """Minus Directional Movement"""
    return call_talib_with_hl(barDs, count, talib.MINUS_DM, timeperiod)


def MOM(ds, count, timeperiod=-2**31):
    """Momentum"""
    return call_talib_with_ds(ds, count, talib.MOM, timeperiod)


def NATR(barDs, count, timeperiod=-2**31):
    """Normalized Average True Range"""
    return call_talib_with_hlc(barDs, count, talib.NATR, timeperiod)


def OBV(ds1, volumeDs, count):
    """On Balance Volume"""
    data1 = value_ds_to_numpy(ds1, count)
    if data1 is None:
        return None
    data2 = value_ds_to_numpy(volumeDs, count)
    if data2 is None:
        return None
    return talib.OBV(data1, data2)


def PLUS_DI(barDs, count, timeperiod=-2**31):
    """Plus Directional Indicator"""
    return call_talib_with_hlc(barDs, count, talib.PLUS_DI, timeperiod)


def PLUS_DM(barDs, count, timeperiod=-2**31):
    """Plus Directional Movement"""
    return call_talib_with_hl(barDs, count, talib.PLUS_DM, timeperiod)


def PPO(ds, count, fastperiod=-2**31, slowperiod=-2**31, matype=0):
    """Percentage Price Oscillator"""
    return call_talib_with_ds(ds, count, talib.PPO, fastperiod, slowperiod, matype)


def ROC(ds, count, timeperiod=-2**31):
    """Rate of change : ((price/prevPrice)-1)*100"""
    return call_talib_with_ds(ds, count, talib.ROC, timeperiod)


def ROCP(ds, count, timeperiod=-2**31):
    """Rate of change Percentage: (price-prevPrice)/prevPrice"""
    return call_talib_with_ds(ds, count, talib.ROCP, timeperiod)


def ROCR(ds, count, timeperiod=-2**31):
    """Rate of change ratio: (price/prevPrice)"""
    return call_talib_with_ds(ds, count, talib.ROCR, timeperiod)


def ROCR100(ds, count, timeperiod=-2**31):
    """Rate of change ratio 100 scale: (price/prevPrice)*100"""
    return call_talib_with_ds(ds, count, talib.ROCR100, timeperiod)


def RSI(ds, count, timeperiod=-2**31):
    """Relative Strength Index"""
    return call_talib_with_ds(ds, count, talib.RSI, timeperiod)


def SAR(barDs, count, acceleration=-4e37, maximum=-4e37):
    """Parabolic SAR"""
    return call_talib_with_hl(barDs, count, talib.SAR, acceleration, maximum)


def SAREXT(barDs, count, startvalue=-4e37, offsetonreverse=-4e37, accelerationinitlong=-4e37, accelerationlong=-4e37, accelerationmaxlong=-4e37, accelerationinitshort=-4e37, accelerationshort=-4e37, accelerationmaxshort=-4e37):
    """Parabolic SAR - Extended"""
    return call_talib_with_hl(barDs, count, talib.SAREXT, startvalue, offsetonreverse, accelerationinitlong, accelerationlong, accelerationmaxlong, accelerationinitshort, accelerationshort, accelerationmaxshort)


def SMA(ds, count, timeperiod=-2**31):
    """Simple Moving Average"""
    return call_talib_with_ds(ds, count, talib.SMA, timeperiod)


def STDDEV(ds, count, timeperiod=-2**31, nbdev=-4e37):
    """Standard Deviation"""
    return call_talib_with_ds(ds, count, talib.STDDEV, timeperiod, nbdev)


def STOCH(barDs, count, fastk_period=-2**31, slowk_period=-2**31, slowk_matype=0, slowd_period=-2**31, slowd_matype=0):
    """Stochastic"""
    ret = call_talib_with_hlc(barDs, count, talib.STOCH, fastk_period, slowk_period, slowk_matype, slowd_period, slowd_matype)
    if ret is None:
        ret = (None, None)
    return ret


def STOCHF(barDs, count, fastk_period=-2**31, fastd_period=-2**31, fastd_matype=0):
    """Stochastic Fast"""
    ret = call_talib_with_hlc(barDs, count, talib.STOCHF, fastk_period, fastd_period, fastd_matype)
    if ret is None:
        ret = (None, None)
    return ret


def STOCHRSI(ds, count, timeperiod=-2**31, fastk_period=-2**31, fastd_period=-2**31, fastd_matype=0):
    """Stochastic Relative Strength Index"""
    ret = call_talib_with_ds(ds, count, talib.STOCHRSI, timeperiod, fastk_period, fastd_period, fastd_matype)
    if ret is None:
        ret = (None, None)
    return ret


def SUM(ds, count, timeperiod=-2**31):
    """Summation"""
    return call_talib_with_ds(ds, count, talib.SUM, timeperiod)


def T3(ds, count, timeperiod=-2**31, vfactor=-4e37):
    """Triple Exponential Moving Average (T3)"""
    return call_talib_with_ds(ds, count, talib.T3, timeperiod, vfactor)


def TEMA(ds, count, timeperiod=-2**31):
    """Triple Exponential Moving Average"""
    return call_talib_with_ds(ds, count, talib.TEMA, timeperiod)


def TRANGE(barDs, count):
    """True Range"""
    return call_talib_with_hlc(barDs, count, talib.TRANGE)


def TRIMA(ds, count, timeperiod=-2**31):
    """Triangular Moving Average"""
    return call_talib_with_ds(ds, count, talib.TRIMA, timeperiod)


def TRIX(ds, count, timeperiod=-2**31):
    """1-day Rate-Of-Change (ROC) of a Triple Smooth EMA"""
    return call_talib_with_ds(ds, count, talib.TRIX, timeperiod)


def TSF(ds, count, timeperiod=-2**31):
    """Time Series Forecast"""
    return call_talib_with_ds(ds, count, talib.TSF, timeperiod)


def TYPPRICE(barDs, count):
    """Typical Price"""
    return call_talib_with_hlc(barDs, count, talib.TYPPRICE)


def ULTOSC(barDs, count, timeperiod1=-2**31, timeperiod2=-2**31, timeperiod3=-2**31):
    """Ultimate Oscillator"""
    return call_talib_with_hlc(barDs, count, talib.ULTOSC, timeperiod1, timeperiod2, timeperiod3)


def VAR(ds, count, timeperiod=-2**31, nbdev=-4e37):
    """Variance"""
    return call_talib_with_ds(ds, count, talib.VAR, timeperiod, nbdev)


def WCLPRICE(barDs, count):
    """Weighted Close Price"""
    return call_talib_with_hlc(barDs, count, talib.WCLPRICE)


def WILLR(barDs, count, timeperiod=-2**31):
    """Williams' %R"""
    return call_talib_with_hlc(barDs, count, talib.WILLR, timeperiod)


def WMA(ds, count, timeperiod=-2**31):
    """Weighted Moving Average"""
    return call_talib_with_ds(ds, count, talib.WMA, timeperiod)

########NEW FILE########
__FILENAME__ = atr
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import technical
from pyalgotrade import dataseries
from pyalgotrade.dataseries import bards


# This event window will calculate and hold true-range values.
# Formula from http://stockcharts.com/help/doku.php?id=chart_school:technical_indicators:average_true_range_a.
class ATREventWindow(technical.EventWindow):
    def __init__(self, period, useAdjustedValues):
        assert(period > 1)
        technical.EventWindow.__init__(self, period)
        self.__useAdjustedValues = useAdjustedValues
        self.__prevClose = None
        self.__value = None

    def _calculateTrueRange(self, value):
        ret = None
        if self.__prevClose is None:
            ret = value.getHigh(self.__useAdjustedValues) - value.getLow(self.__useAdjustedValues)
        else:
            tr1 = value.getHigh(self.__useAdjustedValues) - value.getLow(self.__useAdjustedValues)
            tr2 = abs(value.getHigh(self.__useAdjustedValues) - self.__prevClose)
            tr3 = abs(value.getLow(self.__useAdjustedValues) - self.__prevClose)
            ret = max(max(tr1, tr2), tr3)
        return ret

    def onNewValue(self, dateTime, value):
        tr = self._calculateTrueRange(value)
        technical.EventWindow.onNewValue(self, dateTime, tr)
        self.__prevClose = value.getClose(self.__useAdjustedValues)

        if value is not None and self.windowFull():
            if self.__value is None:
                self.__value = self.getValues().mean()
            else:
                self.__value = (self.__value * (self.getWindowSize() - 1) + tr) / float(self.getWindowSize())

    def getValue(self):
        return self.__value


class ATR(technical.EventBasedFilter):
    """Average True Range filter as described in http://stockcharts.com/help/doku.php?id=chart_school:technical_indicators:average_true_range_a.

    :param barDataSeries: The BarDataSeries instance being filtered.
    :type barDataSeries: :class:`pyalgotrade.dataseries.bards.BarDataSeries`.
    :param period: The average period. Must be > 1.
    :type period: int.
    :param useAdjustedValues: True to use adjusted Low/High/Close values.
    :type useAdjustedValues: boolean.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, barDataSeries, period, useAdjustedValues=False, maxLen=dataseries.DEFAULT_MAX_LEN):
        if not isinstance(barDataSeries, bards.BarDataSeries):
            raise Exception("barDataSeries must be a dataseries.bards.BarDataSeries instance")

        technical.EventBasedFilter.__init__(self, barDataSeries, ATREventWindow(period, useAdjustedValues), maxLen)

########NEW FILE########
__FILENAME__ = bollinger
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import dataseries
from pyalgotrade.technical import ma
from pyalgotrade.technical import stats


class BollingerBands(object):
    """Bollinger Bands filter as described in http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:bollinger_bands.

    :param dataSeries: The DataSeries instance being filtered.
    :type dataSeries: :class:`pyalgotrade.dataseries.DataSeries`.
    :param period: The number of values to use in the calculation. Must be > 1.
    :type period: int.
    :param numStdDev: The number of standard deviations to use for the upper and lower bands.
    :type numStdDev: int.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, dataSeries, period, numStdDev, maxLen=dataseries.DEFAULT_MAX_LEN):
        self.__sma = ma.SMA(dataSeries, period, maxLen=maxLen)
        self.__stdDev = stats.StdDev(dataSeries, period, maxLen=maxLen)
        self.__upperBand = dataseries.SequenceDataSeries(maxLen)
        self.__lowerBand = dataseries.SequenceDataSeries(maxLen)
        self.__numStdDev = numStdDev
        # It is important to subscribe after sma and stddev since we'll use those values.
        dataSeries.getNewValueEvent().subscribe(self.__onNewValue)

    def __onNewValue(self, dataSeries, dateTime, value):
        upperValue = None
        lowerValue = None

        if value is not None:
            sma = self.__sma[-1]
            if sma is not None:
                stdDev = self.__stdDev[-1]
                upperValue = sma + stdDev * self.__numStdDev
                lowerValue = sma + stdDev * self.__numStdDev * -1

        self.__upperBand.appendWithDateTime(dateTime, upperValue)
        self.__lowerBand.appendWithDateTime(dateTime, lowerValue)

    def getUpperBand(self):
        """
        Returns the upper band as a :class:`pyalgotrade.dataseries.DataSeries`.
        """
        return self.__upperBand

    def getMiddleBand(self):
        """
        Returns the middle band as a :class:`pyalgotrade.dataseries.DataSeries`.
        """
        return self.__sma

    def getLowerBand(self):
        """
        Returns the lower band as a :class:`pyalgotrade.dataseries.DataSeries`.
        """
        return self.__lowerBand

########NEW FILE########
__FILENAME__ = cross
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""


def compute_diff(values1, values2):
    assert(len(values1) == len(values2))
    ret = []
    for i in range(len(values1)):
        v1 = values1[i]
        v2 = values2[i]
        if v1 is not None and v2 is not None:
            diff = v1 - v2
        else:
            diff = None
        ret.append(diff)
    return ret


def _cross_impl(values1, values2, start, end, signCheck):
    # Get both set of values.
    values1 = values1[start:end]
    values2 = values2[start:end]

    # Compute differences and check sign changes.
    ret = 0
    diffs = compute_diff(values1, values2)
    prevDiff = None
    for diff in diffs:
        if prevDiff is not None and not signCheck(prevDiff) and signCheck(diff):
            ret += 1
        prevDiff = diff
    return ret


# Note:
# Up to version 0.12 CrossAbove and CrossBelow were DataSeries.
# In version 0.13 SequenceDataSeries was refactored to support specifying a limit to the amount
# of values to hold. This was introduced mainly to reduce memory footprint.
# This change had a huge impact on the way DataSeries filters were implemented since they were
# mosly views and didn't hold any actual values. For example, a SMA(200) didn't hold any values at all
# but rather calculate those on demand by requesting 200 values from the DataSeries being wrapped.
# Now that the DataSeries being wrapped may not hold so many values, DataSeries filters were refactored
# to an event based model and they will calculate and hold resulting values as new values get added to
# the underlying DataSeries (the one being wrapped).
# Since it was too complicated to make CrossAbove and CrossBelow filters work with this new model (
# mainly because the underlying DataSeries may not get new values added at the same time, or one after
# another) I decided to turn those into functions, cross_above and cross_below.

def cross_above(values1, values2, start=-2, end=None):
    """Checks for a cross above conditions over the specified period between two DataSeries objects.

    It returns the number of times values1 crossed above values2 during the given period.

    :param values1: The DataSeries that crosses.
    :type values1: :class:`pyalgotrade.dataseries.DataSeries`.
    :param values2: The DataSeries being crossed.
    :type values2: :class:`pyalgotrade.dataseries.DataSeries`.
    :param start: The start of the range.
    :type start: int.
    :param end: The end of the range.
    :type end: int.

    .. note::
        The default start and end values check for cross above conditions over the last 2 values.
    """
    return _cross_impl(values1, values2, start, end, lambda x: x > 0)


def cross_below(values1, values2, start=-2, end=None):
    """Checks for a cross below conditions over the specified period between two DataSeries objects.

    It returns the number of times values1 crossed below values2 during the given period.

    :param values1: The DataSeries that crosses.
    :type values1: :class:`pyalgotrade.dataseries.DataSeries`.
    :param values2: The DataSeries being crossed.
    :type values2: :class:`pyalgotrade.dataseries.DataSeries`.
    :param start: The start of the range.
    :type start: int.
    :param end: The end of the range.
    :type end: int.

    .. note::
        The default start and end values check for cross below conditions over the last 2 values.
    """
    return _cross_impl(values1, values2, start, end, lambda x: x < 0)

########NEW FILE########
__FILENAME__ = cumret
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import technical
from pyalgotrade import dataseries


class CumRetEventWindow(technical.EventWindow):
    def __init__(self):
        technical.EventWindow.__init__(self, 2)
        self.__prevCumRet = 0

    def getValue(self):
        ret = None
        if self.windowFull():
            values = self.getValues()
            prev = values[0]
            actual = values[1]
            netReturn = (actual - prev) / float(prev)
            ret = (1 + self.__prevCumRet) * (1 + netReturn) - 1
            self.__prevCumRet = ret
        return ret


class CumulativeReturn(technical.EventBasedFilter):
    """This filter calculates cumulative returns over another dataseries.

    :param dataSeries: The DataSeries instance being filtered.
    :type dataSeries: :class:`pyalgotrade.dataseries.DataSeries`.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, dataSeries, maxLen=dataseries.DEFAULT_MAX_LEN):
        technical.EventBasedFilter.__init__(self, dataSeries, CumRetEventWindow(), maxLen)

########NEW FILE########
__FILENAME__ = highlow
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import technical
from pyalgotrade import dataseries


class HighLowEventWindow(technical.EventWindow):
    def __init__(self, windowSize, useMin):
        technical.EventWindow.__init__(self, windowSize)
        self.__useMin = useMin

    def getValue(self):
        ret = None
        if self.windowFull():
            values = self.getValues()
            if self.__useMin:
                ret = values.min()
            else:
                ret = values.max()
        return ret


class High(technical.EventBasedFilter):
    """This filter calculates the highest value.

    :param dataSeries: The DataSeries instance being filtered.
    :type dataSeries: :class:`pyalgotrade.dataseries.DataSeries`.
    :param period: The number of values to use to calculate the highest value.
    :type period: int.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, dataSeries, period, maxLen=dataseries.DEFAULT_MAX_LEN):
        technical.EventBasedFilter.__init__(self, dataSeries, HighLowEventWindow(period, False), maxLen)


class Low(technical.EventBasedFilter):
    """This filter calculates the lowest value.

    :param dataSeries: The DataSeries instance being filtered.
    :type dataSeries: :class:`pyalgotrade.dataseries.DataSeries`.
    :param period: The number of values to use to calculate the lowest value.
    :type period: int.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, dataSeries, period, maxLen=dataseries.DEFAULT_MAX_LEN):
        technical.EventBasedFilter.__init__(self, dataSeries, HighLowEventWindow(period, True), maxLen)

########NEW FILE########
__FILENAME__ = linebreak
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import dataseries
from pyalgotrade.dataseries import bards


class Line(object):
    """A line in a line break chart."""

    def __init__(self, low, high, dateTime, white):
        self.__low = low
        self.__high = high
        self.__dateTime = dateTime
        self.__white = white

    def getDateTime(self):
        """The datetime."""
        return self.__dateTime

    def getLow(self):
        """The low value."""
        return self.__low

    def getHigh(self):
        """The high value."""
        return self.__high

    def isWhite(self):
        """True if the line is white (rising prices)."""
        return self.__white

    def isBlack(self):
        """True if the line is black (falling prices)."""
        return not self.__white


class LineBreak(dataseries.SequenceDataSeries):
    """Line Break filter as described in http://stockcharts.com/help/doku.php?id=chart_school:chart_analysis:three_line_break
    .
    This is a DataSeries of :class:`Line` instances.

    :param barDataSeries: The DataSeries instance being filtered.
    :type barDataSeries: :class:`pyalgotrade.dataseries.bards.BarDataSeries`.
    :param reversalLines: The number of lines back to check to calculate a reversal. Must be greater than 1.
    :type reversalLines: int.
    :param useAdjustedValues: True to use adjusted high/low/close values.
    :type useAdjustedValues: boolean.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
        This value can't be smaller than reversalLines.
    :type maxLen: int.
    """

    def __init__(self, barDataSeries, reversalLines, useAdjustedValues=False, maxLen=dataseries.DEFAULT_MAX_LEN):
        if not isinstance(barDataSeries, bards.BarDataSeries):
            raise Exception("barDataSeries must be a dataseries.bards.BarDataSeries instance")
        if reversalLines < 2:
            raise Exception("reversalLines must be greater than 1")
        if maxLen < reversalLines:
            raise Exception("maxLen can't be smaller than reversalLines")

        dataseries.SequenceDataSeries.__init__(self, maxLen)

        self.__reversalLines = reversalLines
        self.__useAdjustedValues = useAdjustedValues

        barDataSeries.getNewValueEvent().subscribe(self.__onNewBar)

    def __onNewBar(self, dataSeries, dateTime, value):
        line = self.__getNextLine(value)
        if line is not None:
            self.appendWithDateTime(dateTime, line)

    def __isReversal(self, value, breakUp):
        assert(len(self))
        lines = self[self.__reversalLines*-1:]
        if breakUp:
            breakPoint = max([line.getHigh() for line in lines])
            ret = value > breakPoint
        else:
            breakPoint = min([line.getLow() for line in lines])
            ret = value < breakPoint
        return ret

    def __getNextLine(self, bar):
        ret = None

        if len(self) > 0:
            lastLine = self[-1]
            close = bar.getClose(self.__useAdjustedValues)
            if lastLine.isWhite():
                if close > lastLine.getHigh():
                    # Price extends in the same direction
                    ret = Line(lastLine.getHigh(), close, bar.getDateTime(), True)
                elif self.__isReversal(close, False):
                    # Price change is enough to warrant a reversal.
                    ret = Line(close, lastLine.getLow(), bar.getDateTime(), False)
            else:
                if close < lastLine.getLow():
                    # Price extends in the same direction
                    ret = Line(close, lastLine.getLow(), bar.getDateTime(), False)
                elif self.__isReversal(close, True):
                    # Price change is enough to warrant a reversal.
                    ret = Line(lastLine.getHigh(), close, bar.getDateTime(), True)
        else:
            white = False
            if bar.getClose(self.__useAdjustedValues) >= bar.getOpen(self.__useAdjustedValues):
                white = True
            ret = Line(bar.getLow(self.__useAdjustedValues), bar.getHigh(self.__useAdjustedValues), bar.getDateTime(), white)
        return ret

    def setMaxLen(self, maxLen):
        if maxLen < self.__reversalLines:
            raise Exception("maxLen can't be smaller than reversalLines")
        dataseries.SequenceDataSeries.setMaxLen(self, maxLen)

########NEW FILE########
__FILENAME__ = linreg
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import technical
from pyalgotrade import dataseries
from pyalgotrade.utils import collections
from pyalgotrade.utils import dt

import numpy as np
from scipy import stats


# Using scipy.stats.linregress instead of numpy.linalg.lstsq because of this:
# http://stackoverflow.com/questions/20736255/numpy-linalg-lstsq-with-big-values
def lsreg(x, y):
    x = np.asarray(x)
    y = np.asarray(y)
    res = stats.linregress(x, y)
    return res[0], res[1]


class LeastSquaresRegressionWindow(technical.EventWindow):
    def __init__(self, windowSize):
        assert(windowSize > 1)
        technical.EventWindow.__init__(self, windowSize)
        self.__timestamps = collections.NumPyDeque(windowSize)

    def onNewValue(self, dateTime, value):
        technical.EventWindow.onNewValue(self, dateTime, value)
        if value is not None:
            timestamp = dt.datetime_to_timestamp(dateTime)
            if len(self.__timestamps):
                assert(timestamp > self.__timestamps[-1])
            self.__timestamps.append(timestamp)

    def __getValueAtImpl(self, timestamp):
        ret = None
        if self.windowFull():
            a, b = lsreg(self.__timestamps.data(), self.getValues())
            ret = a * timestamp + b
        return ret

    def getTimeStamps(self):
        return self.__timestamps

    def getValueAt(self, dateTime):
        return self.__getValueAtImpl(dt.datetime_to_timestamp(dateTime))

    def getValue(self):
        ret = None
        if self.windowFull():
            ret = self.__getValueAtImpl(self.__timestamps.data()[-1])
        return ret


class LeastSquaresRegression(technical.EventBasedFilter):
    """Calculates values based on a least-squares regression.

    :param dataSeries: The DataSeries instance being filtered.
    :type dataSeries: :class:`pyalgotrade.dataseries.DataSeries`.
    :param windowSize: The number of values to use to calculate the regression.
    :type windowSize: int.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """
    def __init__(self, dataSeries, windowSize, maxLen=dataseries.DEFAULT_MAX_LEN):
        technical.EventBasedFilter.__init__(self, dataSeries, LeastSquaresRegressionWindow(windowSize), maxLen)

    def getValueAt(self, dateTime):
        """Calculates the value at a given time based on the regression line.

        :param dateTime: The datetime to calculate the value at.
            Will return None if there are not enough values in the underlying DataSeries.
        :type dateTime: :class:`datetime.datetime`.
        """
        return self.getEventWindow().getValueAt(dateTime)


class SlopeEventWindow(technical.EventWindow):
    def __init__(self, windowSize):
        technical.EventWindow.__init__(self, windowSize)
        self.__x = np.asarray(range(windowSize))

    def getValue(self):
        ret = None
        if self.windowFull():
            y = self.getValues()
            ret = lsreg(self.__x, y)[0]
        return ret


class Slope(technical.EventBasedFilter):
    """The Slope filter calculates the slope of a least-squares regression line.

    :param dataSeries: The DataSeries instance being filtered.
    :type dataSeries: :class:`pyalgotrade.dataseries.DataSeries`.
    :param period: The number of values to use to calculate the slope.
    :type period: int.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.

    .. note::
        This filter ignores the time elapsed between the different values.
    """

    def __init__(self, dataSeries, period, maxLen=dataseries.DEFAULT_MAX_LEN):
        technical.EventBasedFilter.__init__(self, dataSeries, SlopeEventWindow(period), maxLen)

    def getTrendDays(self):
        return self.getWindowSize()


class TrendEventWindow(SlopeEventWindow):
    def __init__(self, windowSize, positiveThreshold, negativeThreshold):
        if negativeThreshold > positiveThreshold:
            raise Exception("Invalid thresholds")

        SlopeEventWindow.__init__(self, windowSize)
        self.__positiveThreshold = positiveThreshold
        self.__negativeThreshold = negativeThreshold

    def getValue(self):
        ret = SlopeEventWindow.getValue(self)
        if ret is not None:
            if ret > self.__positiveThreshold:
                ret = True
            elif ret < self.__negativeThreshold:
                ret = False
            else:  # Between negative and postive thresholds.
                ret = None
        return ret


class Trend(technical.EventBasedFilter):
    def __init__(self, dataSeries, trendDays, positiveThreshold=0, negativeThreshold=0, maxLen=dataseries.DEFAULT_MAX_LEN):
        technical.EventBasedFilter.__init__(self, dataSeries, TrendEventWindow(trendDays, positiveThreshold, negativeThreshold), maxLen)

########NEW FILE########
__FILENAME__ = ma
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import numpy as np
from pyalgotrade import technical
from pyalgotrade import dataseries


def calculate_sma(values, begin, end):
    accum = 0
    for i in xrange(begin, end):
        value = values[i]
        if value is None:
            return None
        accum += value

    ret = accum / float(end - begin)
    return ret


# This is the formula I'm using to calculate the averages based on previous ones.
# 1 2 3 4
# x x x
#   x x x
#
# avg0 = (a + b + c) / 3
# avg1 = (b + c + d) / 3
#
# avg0 = avg1 + x
# (a + b + c) / 3 = (b + c + d) / 3 + x
# a/3 + b/3 + c/3 = b/3 + c/3 + d/3 + x
# a/3 = d/3 + x
# x = a/3 - d/3

# avg1 = avg0 - x
# avg1 = avg0 + d/3 - a/3

class SMAEventWindow(technical.EventWindow):
    def __init__(self, period):
        assert(period > 0)
        technical.EventWindow.__init__(self, period)
        self.__value = None

    def onNewValue(self, dateTime, value):
        firstValue = None
        if len(self.getValues()) > 0:
            firstValue = self.getValues()[0]
            assert(firstValue is not None)

        technical.EventWindow.onNewValue(self, dateTime, value)

        if value is not None and self.windowFull():
            if self.__value is None:
                self.__value = self.getValues().mean()
            else:
                self.__value = self.__value + value / float(self.getWindowSize()) - firstValue / float(self.getWindowSize())

    def getValue(self):
        return self.__value


class SMA(technical.EventBasedFilter):
    """Simple Moving Average filter.

    :param dataSeries: The DataSeries instance being filtered.
    :type dataSeries: :class:`pyalgotrade.dataseries.DataSeries`.
    :param period: The number of values to use to calculate the SMA.
    :type period: int.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """
    def __init__(self, dataSeries, period, maxLen=dataseries.DEFAULT_MAX_LEN):
        technical.EventBasedFilter.__init__(self, dataSeries, SMAEventWindow(period), maxLen)


class EMAEventWindow(technical.EventWindow):
    def __init__(self, period):
        assert(period > 1)
        technical.EventWindow.__init__(self, period)
        self.__multiplier = (2.0 / (period + 1))
        self.__value = None

    def onNewValue(self, dateTime, value):
        technical.EventWindow.onNewValue(self, dateTime, value)

        # Formula from http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_averages
        if value is not None and self.windowFull():
            if self.__value is None:
                self.__value = self.getValues().mean()
            else:
                self.__value = (value - self.__value) * self.__multiplier + self.__value

    def getValue(self):
        return self.__value


class EMA(technical.EventBasedFilter):
    """Exponential Moving Average filter.

    :param dataSeries: The DataSeries instance being filtered.
    :type dataSeries: :class:`pyalgotrade.dataseries.DataSeries`.
    :param period: The number of values to use to calculate the EMA. Must be an integer greater than 1.
    :type period: int.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, dataSeries, period, maxLen=dataseries.DEFAULT_MAX_LEN):
        technical.EventBasedFilter.__init__(self, dataSeries, EMAEventWindow(period), maxLen)


class WMAEventWindow(technical.EventWindow):
    def __init__(self, weights):
        assert(len(weights) > 0)
        technical.EventWindow.__init__(self, len(weights))
        self.__weights = np.asarray(weights)

    def getValue(self):
        ret = None
        if self.windowFull():
            accum = (self.getValues() * self.__weights).sum()
            weightSum = self.__weights.sum()
            ret = accum / float(weightSum)
        return ret


class WMA(technical.EventBasedFilter):
    """Weighted Moving Average filter.

    :param dataSeries: The DataSeries instance being filtered.
    :type dataSeries: :class:`pyalgotrade.dataseries.DataSeries`.
    :param weights: A list of int/float with the weights.
    :type weights: list.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, dataSeries, weights, maxLen=dataseries.DEFAULT_MAX_LEN):
        technical.EventBasedFilter.__init__(self, dataSeries, WMAEventWindow(weights), maxLen)

########NEW FILE########
__FILENAME__ = macd
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade.technical import ma
from pyalgotrade import dataseries


class MACD(dataseries.SequenceDataSeries):
    """Moving Average Convergence-Divergence indicator as described in http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_average_conve.

    :param dataSeries: The DataSeries instance being filtered.
    :type dataSeries: :class:`pyalgotrade.dataseries.DataSeries`.
    :param fastEMA: The number of values to use to calculate the fast EMA.
    :type fastEMA: int.
    :param slowEMA: The number of values to use to calculate the slow EMA.
    :type slowEMA: int.
    :param signalEMA: The number of values to use to calculate the signal EMA.
    :type signalEMA: int.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """
    def __init__(self, dataSeries, fastEMA, slowEMA, signalEMA, maxLen=dataseries.DEFAULT_MAX_LEN):
        assert(fastEMA > 0)
        assert(slowEMA > 0)
        assert(fastEMA < slowEMA)
        assert(signalEMA > 0)

        dataseries.SequenceDataSeries.__init__(self, maxLen)

        # We need to skip some values when calculating the fast EMA in order for both EMA
        # to calculate their first values at the same time.
        # I'M FORCING THIS BEHAVIOUR ONLY TO MAKE THIS FITLER MATCH TA-Lib MACD VALUES.
        self.__fastEMASkip = slowEMA - fastEMA

        self.__fastEMAWindow = ma.EMAEventWindow(fastEMA)
        self.__slowEMAWindow = ma.EMAEventWindow(slowEMA)
        self.__signalEMAWindow = ma.EMAEventWindow(signalEMA)
        self.__signal = dataseries.SequenceDataSeries(maxLen)
        self.__histogram = dataseries.SequenceDataSeries(maxLen)
        dataSeries.getNewValueEvent().subscribe(self.__onNewValue)

    def getSignal(self):
        """Returns a :class:`pyalgotrade.dataseries.DataSeries` with the EMA over the MACD."""
        return self.__signal

    def getHistogram(self):
        """Returns a :class:`pyalgotrade.dataseries.DataSeries` with the histogram (the difference between the MACD and the Signal)."""
        return self.__histogram

    def __onNewValue(self, dataSeries, dateTime, value):
        diff = None
        macdValue = None
        signalValue = None
        histogramValue = None

        # We need to skip some values when calculating the fast EMA in order for both EMA
        # to calculate their first values at the same time.
        # I'M FORCING THIS BEHAVIOUR ONLY TO MAKE THIS FITLER MATCH TA-Lib MACD VALUES.
        self.__slowEMAWindow.onNewValue(dateTime, value)
        if self.__fastEMASkip > 0:
            self.__fastEMASkip -= 1
        else:
            self.__fastEMAWindow.onNewValue(dateTime, value)
            if self.__fastEMAWindow.windowFull():
                diff = self.__fastEMAWindow.getValue() - self.__slowEMAWindow.getValue()

        # Make the first MACD value available as soon as the first signal value is available.
        # I'M FORCING THIS BEHAVIOUR ONLY TO MAKE THIS FITLER MATCH TA-Lib MACD VALUES.
        self.__signalEMAWindow.onNewValue(dateTime, diff)
        if self.__signalEMAWindow.windowFull():
            macdValue = diff
            signalValue = self.__signalEMAWindow.getValue()
            histogramValue = macdValue - signalValue

        self.appendWithDateTime(dateTime, macdValue)
        self.__signal.appendWithDateTime(dateTime, signalValue)
        self.__histogram.appendWithDateTime(dateTime, histogramValue)

########NEW FILE########
__FILENAME__ = ratio
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import technical
from pyalgotrade import utils
from pyalgotrade import dataseries


class RatioEventWindow(technical.EventWindow):
    def __init__(self):
        technical.EventWindow.__init__(self, 2)

    def getValue(self):
        ret = None
        if self.windowFull():
            prev = self.getValues()[0]
            actual = self.getValues()[-1]
            ret = utils.get_change_percentage(actual, prev)
        return ret


# Calculates the ratio between a value and the previous one.
# The ratio can't be calculated if a previous value is 0.
class Ratio(technical.EventBasedFilter):
    def __init__(self, dataSeries, maxLen=dataseries.DEFAULT_MAX_LEN):
        technical.EventBasedFilter.__init__(self, dataSeries, RatioEventWindow(), maxLen)

########NEW FILE########
__FILENAME__ = roc
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import technical
from pyalgotrade import dataseries


class ROCEventWindow(technical.EventWindow):
    def __init__(self, windowSize):
        technical.EventWindow.__init__(self, windowSize)

    def getValue(self):
        ret = None
        if self.windowFull():
            prev = self.getValues()[0]
            actual = self.getValues()[-1]
            if actual is not None and prev is not None:
                diff = float(actual - prev)
                if diff == 0:
                    ret = float(0)
                elif prev != 0:
                    ret = diff / prev
        return ret


class RateOfChange(technical.EventBasedFilter):
    """Rate of change filter as described in http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:rate_of_change.

    :param dataSeries: The DataSeries instance being filtered.
    :type dataSeries: :class:`pyalgotrade.dataseries.DataSeries`.
    :param valuesAgo: The number of values back that a given value will compare to. Must be > 0.
    :type valuesAgo: int.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, dataSeries, valuesAgo, maxLen=dataseries.DEFAULT_MAX_LEN):
        assert(valuesAgo > 0)
        technical.EventBasedFilter.__init__(self, dataSeries, ROCEventWindow(valuesAgo + 1), maxLen)

########NEW FILE########
__FILENAME__ = rsi
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import technical
from pyalgotrade import dataseries


# RSI = 100 - 100 / (1 + RS)
# RS = Average gain / Average loss
# First Average Gain = Sum of Gains over the past 14 periods / 14
# First Average Loss = Sum of Losses over the past 14 periods / 14
# Average Gain = [(previous Average Gain) x 13 + current Gain] / 14
# Average Loss = [(previous Average Loss) x 13 + current Loss] / 14
#
# RSI is 0 when the Average Gain equals zero. Assuming a 14-period RSI, a zero RSI value means prices moved lower all
# 14 periods. There were no gains to measure.
# RSI is 100 when the Average Loss equals zero. This means prices moved higher all 14 periods.
# There were no losses to measure.
#
# If Average Loss equals zero, a "divide by zero" situation occurs for RS and RSI is set to 100 by definition.
# Similarly, RSI equals 0 when Average Gain equals zero.
#
# RSI is considered overbought when above 70 and oversold when below 30.
# These traditional levels can also be adjusted to better fit the security or analytical requirements.
# Raising overbought to 80 or lowering oversold to 20 will reduce the number of overbought/oversold readings.
# Short-term traders sometimes use 2-period RSI to look for overbought readings above 80 and oversold readings below 20.

def gain_loss_one(prevValue, nextValue):
    change = nextValue - prevValue
    if change < 0:
        gain = 0
        loss = abs(change)
    else:
        gain = change
        loss = 0
    return gain, loss


# [begin, end)
def avg_gain_loss(values, begin, end):
    rangeLen = end - begin
    if rangeLen < 2:
        return None

    gain = 0
    loss = 0
    for i in xrange(begin+1, end):
        currGain, currLoss = gain_loss_one(values[i-1], values[i])
        gain += currGain
        loss += currLoss
    return (gain/float(rangeLen-1), loss/float(rangeLen-1))


def rsi(values, period):
    assert(period > 1)
    if len(values) < period + 1:
        return None

    avgGain, avgLoss = avg_gain_loss(values, 0, period)
    for i in xrange(period, len(values)):
        gain, loss = gain_loss_one(values[i-1], values[i])
        avgGain = (avgGain * (period - 1) + gain) / float(period)
        avgLoss = (avgLoss * (period - 1) + loss) / float(period)

    if avgLoss == 0:
        return 100
    rs = avgGain / avgLoss
    return 100 - 100 / (1 + rs)


class RSIEventWindow(technical.EventWindow):
    def __init__(self, period):
        assert(period > 1)
        # We need N + 1 samples to calculate N averages because they are calculated based on the diff with previous values.
        technical.EventWindow.__init__(self, period + 1)
        self.__value = None
        self.__prevGain = None
        self.__prevLoss = None
        self.__period = period

    def onNewValue(self, dateTime, value):
        technical.EventWindow.onNewValue(self, dateTime, value)

        # Formula from http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:relative_strength_index_rsi
        if value is not None and self.windowFull():
            if self.__prevGain is None:
                assert(self.__prevLoss is None)
                avgGain, avgLoss = avg_gain_loss(self.getValues(), 0, len(self.getValues()))
            else:
                # Rest of averages are smoothed
                assert(self.__prevLoss is not None)
                prevValue = self.getValues()[-2]
                currValue = self.getValues()[-1]
                currGain, currLoss = gain_loss_one(prevValue, currValue)
                avgGain = (self.__prevGain * (self.__period-1) + currGain) / float(self.__period)
                avgLoss = (self.__prevLoss * (self.__period-1) + currLoss) / float(self.__period)

            if avgLoss == 0:
                self.__value = 100
            else:
                rs = avgGain / avgLoss
                self.__value = 100 - 100 / (1 + rs)

            self.__prevGain = avgGain
            self.__prevLoss = avgLoss

    def getValue(self):
        return self.__value


class RSI(technical.EventBasedFilter):
    """Relative Strength Index filter as described in http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:relative_strength_index_rsi.

    :param dataSeries: The DataSeries instance being filtered.
    :type dataSeries: :class:`pyalgotrade.dataseries.DataSeries`.
    :param period: The period. Note that if period is **n**, then **n+1** values are used. Must be > 1.
    :type period: int.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, dataSeries, period, maxLen=dataseries.DEFAULT_MAX_LEN):
        technical.EventBasedFilter.__init__(self, dataSeries, RSIEventWindow(period), maxLen)

########NEW FILE########
__FILENAME__ = stats
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import technical
from pyalgotrade import dataseries


class StdDevEventWindow(technical.EventWindow):
    def __init__(self, period, ddof):
        assert(period > 0)
        technical.EventWindow.__init__(self, period)
        self.__ddof = ddof

    def getValue(self):
        ret = None
        if self.windowFull():
            ret = self.getValues().std(ddof=self.__ddof)
        return ret


class StdDev(technical.EventBasedFilter):
    """Standard deviation filter.

    :param dataSeries: The DataSeries instance being filtered.
    :type dataSeries: :class:`pyalgotrade.dataseries.DataSeries`.
    :param period: The number of values to use to calculate the Standard deviation.
    :type period: int.
    :param ddof: Delta degrees of freedom.
    :type ddof: int.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, dataSeries, period, ddof=0, maxLen=dataseries.DEFAULT_MAX_LEN):
        technical.EventBasedFilter.__init__(self, dataSeries, StdDevEventWindow(period, ddof), maxLen)


class ZScoreEventWindow(technical.EventWindow):
    def __init__(self, period, ddof):
        assert(period > 1)
        technical.EventWindow.__init__(self, period)
        self.__ddof = ddof

    def getValue(self):
        ret = None
        if self.windowFull():
            values = self.getValues()
            lastValue = values[-1]
            mean = values.mean()
            std = values.std(ddof=self.__ddof)
            ret = (lastValue - mean) / float(std)
        return ret


class ZScore(technical.EventBasedFilter):
    """Z-Score filter.

    :param dataSeries: The DataSeries instance being filtered.
    :type dataSeries: :class:`pyalgotrade.dataseries.DataSeries`.
    :param period: The number of values to use to calculate the Z-Score.
    :type period: int.
    :param ddof: Delta degrees of freedom to use for the standard deviation.
    :type ddof: int.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, dataSeries, period, ddof=0, maxLen=dataseries.DEFAULT_MAX_LEN):
        technical.EventBasedFilter.__init__(self, dataSeries, ZScoreEventWindow(period, ddof), maxLen)

########NEW FILE########
__FILENAME__ = stoch
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import technical
from pyalgotrade import dataseries
from pyalgotrade.dataseries import bards
from pyalgotrade.technical import ma


class BarWrapper(object):
    def __init__(self, useAdjusted):
        self.__useAdjusted = useAdjusted

    def getLow(self, bar_):
        return bar_.getLow(self.__useAdjusted)

    def getHigh(self, bar_):
        return bar_.getHigh(self.__useAdjusted)

    def getClose(self, bar_):
        return bar_.getClose(self.__useAdjusted)


def get_low_high_values(barWrapper, bars):
    currBar = bars[0]
    lowestLow = barWrapper.getLow(currBar)
    highestHigh = barWrapper.getHigh(currBar)
    for i in range(len(bars)):
        currBar = bars[i]
        lowestLow = min(lowestLow, barWrapper.getLow(currBar))
        highestHigh = max(highestHigh, barWrapper.getHigh(currBar))
    return (lowestLow, highestHigh)


class SOEventWindow(technical.EventWindow):
    def __init__(self, period, useAdjustedValues):
        assert(period > 1)
        technical.EventWindow.__init__(self, period, dtype=object)
        self.__barWrapper = BarWrapper(useAdjustedValues)

    def getValue(self):
        ret = None
        if self.windowFull():
            lowestLow, highestHigh = get_low_high_values(self.__barWrapper, self.getValues())
            currentClose = self.__barWrapper.getClose(self.getValues()[-1])
            ret = (currentClose - lowestLow) / float(highestHigh - lowestLow) * 100
        return ret


class StochasticOscillator(technical.EventBasedFilter):
    """Stochastic Oscillator filter as described in http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:stochastic_oscillato.
    Note that the value returned by this filter is %K. To access %D use :meth:`getD`.

    :param barDataSeries: The BarDataSeries instance being filtered.
    :type barDataSeries: :class:`pyalgotrade.dataseries.bards.BarDataSeries`.
    :param period: The period. Must be > 1.
    :type period: int.
    :param dSMAPeriod: The %D SMA period. Must be > 1.
    :type dSMAPeriod: int.
    :param useAdjustedValues: True to use adjusted Low/High/Close values.
    :type useAdjustedValues: boolean.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, barDataSeries, period, dSMAPeriod=3, useAdjustedValues=False, maxLen=dataseries.DEFAULT_MAX_LEN):
        assert(dSMAPeriod > 1)
        if not isinstance(barDataSeries, bards.BarDataSeries):
            raise Exception("barDataSeries must be a dataseries.bards.BarDataSeries instance")

        technical.EventBasedFilter.__init__(self, barDataSeries, SOEventWindow(period, useAdjustedValues), maxLen)
        self.__d = ma.SMA(self, dSMAPeriod, maxLen)

    def getD(self):
        """Returns a :class:`pyalgotrade.dataseries.DataSeries` with the %D values."""
        return self.__d

########NEW FILE########
__FILENAME__ = trend
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade.technical import linreg
from pyalgotrade import warninghelpers


class Slope(linreg.Slope):
    def __init__(self, *args, **kwargs):
        # Deprecated since v0.15
        warninghelpers.deprecation_warning("Slope was moved in the pyalgotrade.technical.linreg package", stacklevel=2)
        linreg.Slope.__init__(self, *args, **kwargs)


class Trend(linreg.Trend):
    def __init__(self, *args, **kwargs):
        linreg.Trend.__init__(self, *args, **kwargs)

########NEW FILE########
__FILENAME__ = vwap
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import technical
from pyalgotrade import dataseries
from pyalgotrade.dataseries import bards


class VWAPEventWindow(technical.EventWindow):
    def __init__(self, windowSize, useTypicalPrice):
        technical.EventWindow.__init__(self, windowSize, dtype=object)
        self.__useTypicalPrice = useTypicalPrice

    def getValue(self):
        ret = None
        if self.windowFull():
            cumTotal = 0
            cumVolume = 0

            for bar in self.getValues():
                if self.__useTypicalPrice:
                    cumTotal += bar.getTypicalPrice() * bar.getVolume()
                else:
                    cumTotal += bar.getClose() * bar.getVolume()
                cumVolume += bar.getVolume()

            ret = cumTotal / float(cumVolume)
        return ret


class VWAP(technical.EventBasedFilter):
    """Volume Weighted Average Price filter.

    :param dataSeries: The DataSeries instance being filtered.
    :type dataSeries: :class:`pyalgotrade.dataseries.bards.BarDataSeries`.
    :param period: The number of values to use to calculate the VWAP.
    :type period: int.
    :param useTypicalPrice: True if the typical price should be used instead of the closing price.
    :type useTypicalPrice: boolean.
    :param maxLen: The maximum number of values to hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.
    """

    def __init__(self, dataSeries, period, useTypicalPrice=False, maxLen=dataseries.DEFAULT_MAX_LEN):
        if not isinstance(dataSeries, bards.BarDataSeries):
            raise Exception("dataSeries must be a dataseries.bards.BarDataSeries instance")
        technical.EventBasedFilter.__init__(self, dataSeries, VWAPEventWindow(period, useTypicalPrice), maxLen)

    def getPeriod(self):
        return self.getWindowSize()

########NEW FILE########
__FILENAME__ = quandl
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import urllib
import urllib2
import datetime
import os
from pyalgotrade import bar
from pyalgotrade.barfeed import quandlfeed

from pyalgotrade.utils import dt
import pyalgotrade.logger


# http://www.quandl.com/help/api

def download_csv(sourceCode, tableCode, begin, end, frequency, authToken):
    params = {
        "trim_start": begin.strftime("%Y-%m-%d"),
        "trim_end": end.strftime("%Y-%m-%d"),
        "collapse": frequency
    }
    if authToken is not None:
        params["auth_token"] = authToken

    url = "http://www.quandl.com/api/v1/datasets/%s/%s.csv" % (sourceCode, tableCode)
    url = "%s?%s" % (url, urllib.urlencode(params))

    f = urllib2.urlopen(url)
    if f.headers['Content-Type'] != 'text/csv':
        raise Exception("Failed to download data: %s" % f.getcode())
    buff = f.read()

    # Remove the BOM
    while not buff[0].isalnum():
        buff = buff[1:]

    return buff

def download_daily_bars(sourceCode, tableCode, year, csvFile, authToken=None):
    """Download daily bars from Quandl for a given year.

    :param sourceCode: The dataset's source code.
    :type sourceCode: string.
    :param tableCode: The dataset's table code.
    :type tableCode: string.
    :param year: The year.
    :type year: int.
    :param csvFile: The path to the CSV file to write.
    :type csvFile: string.
    :param authToken: Optional. An authentication token needed if you're doing more than 50 calls per day.
    :type authToken: string.
    """

    bars = download_csv(sourceCode, tableCode, datetime.date(year, 1, 1), datetime.date(year, 12, 31), "daily", authToken)
    f = open(csvFile, "w")
    f.write(bars)
    f.close()


def download_weekly_bars(sourceCode, tableCode, year, csvFile, authToken=None):
    """Download weekly bars from Quandl for a given year.

    :param sourceCode: The dataset's source code.
    :type sourceCode: string.
    :param tableCode: The dataset's table code.
    :type tableCode: string.
    :param year: The year.
    :type year: int.
    :param csvFile: The path to the CSV file to write.
    :type csvFile: string.
    :param authToken: Optional. An authentication token needed if you're doing more than 50 calls per day.
    :type authToken: string.
    """

    begin = dt.get_first_monday(year) - datetime.timedelta(days=1) # Start on a sunday
    end = dt.get_last_monday(year)  - datetime.timedelta(days=1) # Start on a sunday
    bars = download_csv(sourceCode, tableCode, begin, end, "weekly", authToken)
    f = open(csvFile, "w")
    f.write(bars)
    f.close()


def build_feed(sourceCode, tableCodes, fromYear, toYear, storage, frequency=bar.Frequency.DAY, timezone=None, skipErrors=False, noAdjClose=False, authToken=None):
    """Build and load a :class:`pyalgotrade.barfeed.quandlfeed.Feed` using CSV files downloaded from Quandl.
    CSV files are downloaded if they haven't been downloaded before.

    :param sourceCode: The dataset source code.
    :type sourceCode: string.
    :param tableCodes: The dataset table codes.
    :type tableCodes: list.
    :param fromYear: The first year.
    :type fromYear: int.
    :param toYear: The last year.
    :type toYear: int.
    :param storage: The path were the files will be loaded from, or downloaded to.
    :type storage: string.
    :param frequency: The frequency of the bars. Only **pyalgotrade.bar.Frequency.DAY** or **pyalgotrade.bar.Frequency.WEEK**
        are supported.
    :param timezone: The default timezone to use to localize bars. Check :mod:`pyalgotrade.marketsession`.
    :type timezone: A pytz timezone.
    :param skipErrors: True to keep on loading/downloading files in case of errors.
    :type skipErrors: boolean.
    :param noAdjClose: True if the instruments don't have adjusted close values.
    :type noAdjClose: boolean.
    :param authToken: Optional. An authentication token needed if you're doing more than 50 calls per day.
    :type authToken: string.
    :rtype: :class:`pyalgotrade.barfeed.quandlfeed.Feed`.
    """

    logger = pyalgotrade.logger.getLogger("quandl")
    ret = quandlfeed.Feed(frequency, timezone)
    if noAdjClose:
        ret.setNoAdjClose()

    if not os.path.exists(storage):
        logger.info("Creating %s directory" % (storage))
        os.mkdir(storage)

    for year in range(fromYear, toYear+1):
        for tableCode in tableCodes:
            fileName = os.path.join(storage, "%s-%s-%d-quandl.csv" % (sourceCode, tableCode, year))
            if not os.path.exists(fileName):
                logger.info("Downloading %s %d to %s" % (tableCode, year, fileName))
                try:
                    if frequency == bar.Frequency.DAY:
                        download_daily_bars(sourceCode, tableCode, year, fileName, authToken)
                    elif frequency == bar.Frequency.WEEK:
                        download_weekly_bars(sourceCode, tableCode, year, fileName, authToken)
                    else:
                        raise Exception("Invalid frequency")
                except Exception, e:
                    if skipErrors:
                        logger.error(str(e))
                        continue
                    else:
                        raise e
            ret.addBarsFromCSV(tableCode, fileName)
    return ret

########NEW FILE########
__FILENAME__ = resample
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import os

from pyalgotrade import dispatcher
from pyalgotrade.dataseries import resampled

datetime_format = "%Y-%m-%d %H:%M:%S"


class CSVFileWriter(object):
    def __init__(self, csvFile):
        self.__file = open(csvFile, "w")
        self.__writeLine("Date Time", "Open", "High", "Low", "Close", "Volume", "Adj Close")

    def __writeLine(self, *values):
        line = ",".join([str(value) for value in values])
        self.__file.write(line)
        self.__file.write(os.linesep)

    def writeSlot(self, slot):
        adjClose = slot.getAdjClose()
        if adjClose is None:
            adjClose = ""
        dateTime = slot.getDateTime().strftime(datetime_format)
        self.__writeLine(dateTime, slot.getOpen(), slot.getHigh(), slot.getLow(), slot.getClose(), slot.getVolume(), adjClose)

    def close(self):
        self.__file.close()


class Sampler(object):
    def __init__(self, barFeed, frequency, csvFile):
        instruments = barFeed.getRegisteredInstruments()
        if len(instruments) != 1:
            raise Exception("Only barfeeds with 1 instrument can be resampled")

        barFeed.getNewBarsEvent().subscribe(self.__onBars)
        self.__barFeed = barFeed
        self.__frequency = frequency
        self.__instrument = instruments[0]
        self.__slot = None
        self.__writer = CSVFileWriter(csvFile)

    def __onBars(self, dateTime, bars):
        slotDateTime = resampled.get_slot_datetime(dateTime, self.__frequency)
        bar = bars[self.__instrument]

        if self.__slot is None:
            self.__slot = resampled.Slot(slotDateTime, bar, self.__frequency)
        elif self.__slot.getDateTime() == slotDateTime:
            self.__slot.addBar(bar)
        else:
            self.__writer.writeSlot(self.__slot)
            self.__slot = resampled.Slot(slotDateTime, bar, self.__frequency)

    def finish(self):
        if self.__slot is not None:
            self.__writer.writeSlot(self.__slot)
        self.__writer.close()


def resample_impl(barFeed, frequency, csvFile):
    sampler = Sampler(barFeed, frequency, csvFile)

    # Process all bars.
    disp = dispatcher.Dispatcher()
    disp.addSubject(barFeed)
    disp.run()

    sampler.finish()


def resample_to_csv(barFeed, frequency, csvFile):
    """Resample a BarFeed into a CSV file grouping bars by a certain frequency.
    The resulting file can be loaded using :class:`pyalgotrade.barfeed.csvfeed.GenericBarFeed`.
    The CSV file will have the following format:
    ::

        Date Time,Open,High,Low,Close,Volume,Adj Close
        2013-01-01 00:00:00,13.51001,13.56,13.51,13.56,273.88014126,13.51001


    :param barFeed: The bar feed that will provide the bars. It should only hold bars from a single instrument.
    :type barFeed: :class:`pyalgotrade.barfeed.BarFeed`
    :param frequency: The grouping frequency in seconds. Must be > 0.
    :param csvFile: The path to the CSV file to write.
    :type csvFile: string.

    .. note::
        * Datetimes are stored without timezone information.
        * **Adj Close** column may be empty if the input bar feed doesn't have that info.
    """

    if frequency > 0:
        resample_impl(barFeed, frequency, csvFile)
    else:
        raise Exception("Invalid frequency")

########NEW FILE########
__FILENAME__ = yahoofinance
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import urllib2
import os
import datetime

import pyalgotrade.logger
from pyalgotrade import bar
from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.utils import dt


def __adjust_month(month):
    if month > 12 or month < 1:
        raise Exception("Invalid month")
    month -= 1  # Months for yahoo are 0 based
    return month


def download_csv(instrument, begin, end, frequency):
    url = "http://ichart.finance.yahoo.com/table.csv?s=%s&a=%d&b=%d&c=%d&d=%d&e=%d&f=%d&g=%s&ignore=.csv" % (instrument, __adjust_month(begin.month), begin.day, begin.year, __adjust_month(end.month), end.day, end.year, frequency)

    f = urllib2.urlopen(url)
    if f.headers['Content-Type'] != 'text/csv':
        raise Exception("Failed to download data: %s" % f.getcode())
    buff = f.read()

    # Remove the BOM
    while not buff[0].isalnum():
        buff = buff[1:]

    return buff


def download_daily_bars(instrument, year, csvFile):
    """Download daily bars from Yahoo! Finance for a given year.

    :param instrument: Instrument identifier.
    :type instrument: string.
    :param year: The year.
    :type year: int.
    :param csvFile: The path to the CSV file to write.
    :type csvFile: string.
    """

    bars = download_csv(instrument, datetime.date(year, 1, 1), datetime.date(year, 12, 31), "d")
    f = open(csvFile, "w")
    f.write(bars)
    f.close()


def download_weekly_bars(instrument, year, csvFile):
    """Download weekly bars from Yahoo! Finance for a given year.

    :param instrument: Instrument identifier.
    :type instrument: string.
    :param year: The year.
    :type year: int.
    :param csvFile: The path to the CSV file to write.
    :type csvFile: string.
    """

    begin = dt.get_first_monday(year)
    end = dt.get_last_monday(year) + datetime.timedelta(days=6)
    bars = download_csv(instrument, begin, end, "w")
    f = open(csvFile, "w")
    f.write(bars)
    f.close()


def build_feed(instruments, fromYear, toYear, storage, frequency=bar.Frequency.DAY, timezone=None, skipErrors=False):
    """Build and load a :class:`pyalgotrade.barfeed.yahoofeed.Feed` using CSV files downloaded from Yahoo! Finance.
    CSV files are downloaded if they haven't been downloaded before.

    :param instruments: Instrument identifiers.
    :type instruments: list.
    :param fromYear: The first year.
    :type fromYear: int.
    :param toYear: The last year.
    :type toYear: int.
    :param storage: The path were the files will be loaded from, or downloaded to.
    :type storage: string.
    :param frequency: The frequency of the bars. Only **pyalgotrade.bar.Frequency.DAY** or **pyalgotrade.bar.Frequency.WEEK**
        are supported.
    :param timezone: The default timezone to use to localize bars. Check :mod:`pyalgotrade.marketsession`.
    :type timezone: A pytz timezone.
    :param skipErrors: True to keep on loading/downloading files in case of errors.
    :type skipErrors: boolean.
    :rtype: :class:`pyalgotrade.barfeed.yahoofeed.Feed`.
    """

    logger = pyalgotrade.logger.getLogger("yahoofinance")
    ret = yahoofeed.Feed(frequency, timezone)

    if not os.path.exists(storage):
        logger.info("Creating %s directory" % (storage))
        os.mkdir(storage)

    for year in range(fromYear, toYear+1):
        for instrument in instruments:
            fileName = os.path.join(storage, "%s-%d-yahoofinance.csv" % (instrument, year))
            if not os.path.exists(fileName):
                logger.info("Downloading %s %d to %s" % (instrument, year, fileName))
                try:
                    if frequency == bar.Frequency.DAY:
                        download_daily_bars(instrument, year, fileName)
                    elif frequency == bar.Frequency.WEEK:
                        download_weekly_bars(instrument, year, fileName)
                    else:
                        raise Exception("Invalid frequency")
                except Exception, e:
                    if skipErrors:
                        logger.error(str(e))
                        continue
                    else:
                        raise e
            ret.addBarsFromCSV(instrument, fileName)
    return ret

########NEW FILE########
__FILENAME__ = feed
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import Queue
import threading
import json

from pyalgotrade import observer
import pyalgotrade.logger

import tweepy
from tweepy import streaming

logger = pyalgotrade.logger.getLogger("twitter")


# This listener just pushs data into a queue.
class Listener(streaming.StreamListener):
    def __init__(self, queue):
        streaming.StreamListener.__init__(self)
        self.__queue = queue

    def on_connect(self):
        logger.info("Connected.")

    def on_timeout(self):
        logger.error("Timeout.")

    def on_data(self, data):
        self.__queue.put(data)
        return True

    def on_error(self, status):
        logger.error(status)
        return False


# https://dev.twitter.com/docs/streaming-apis/parameters
class TwitterFeed(observer.Subject):
    """Class responsible for connecting to Twitter's public stream API and dispatching events.
    Check https://dev.twitter.com/docs/streaming-apis/streams/public for more information.

    :param consumerKey: Consumer key.
    :type consumerKey: string.
    :param consumerSecret: Consumer secret.
    :type consumerSecret: string.
    :param accessToken: Access token.
    :type accessToken: string.
    :param accessTokenSecret: Access token secret.
    :type accessTokenSecret: string.
    :param track: A list of phrases which will be used to determine what Tweets will be delivered
        on the stream. A phrase may be one or more terms separated by spaces, and a phrase will match
        if all of the terms in the phrase are present in the Tweet, regardless of order and ignoring case.
    :type track: list.
    :param follow: A list of user IDs, indicating the users whose Tweets should be delivered on the
        stream. Following protected users is not supported.
    :type follow: list.
    :param languages: A list of language IDs a defined in http://tools.ietf.org/html/bcp47.
    :type languages: list.

    .. note::
        * Go to http://dev.twitter.com and create an app. The consumer key and secret will be generated for you after that.
        * Create an access token under the "Your access token" section.
        * At least **track** or **follow** have to be set.
    """

    QUEUE_TIMEOUT = 0.01
    MAX_EVENTS_PER_DISPATCH = 50

    def __init__(self, consumerKey, consumerSecret, accessToken, accessTokenSecret, track=[], follow=[], languages=[]):
        if not isinstance(track, list):
            raise Exception("track must be a list")
        if not isinstance(follow, list):
            raise Exception("follow must be a list")
        if not isinstance(languages, list):
            raise Exception("languages must be a list")

        self.__event = observer.Event()
        self.__queue = Queue.Queue()
        self.__thread = None
        self.__running = False

        listener = Listener(self.__queue)
        auth = tweepy.OAuthHandler(consumerKey, consumerSecret)
        auth.set_access_token(accessToken, accessTokenSecret)
        self.__stream = tweepy.Stream(auth, listener)
        self.__track = track
        self.__follow = follow
        self.__languages = languages

    def __threadMain(self):
        try:
            logger.info("Initializing client.")
            self.__stream.filter(track=self.__track, follow=self.__follow, languages=self.__languages)
        finally:
            logger.info("Client finished.")
            self.__running = False

    def __dispatchImpl(self):
        ret = False
        try:
            nextTweet = json.loads(self.__queue.get(True, TwitterFeed.QUEUE_TIMEOUT))
            ret = True
            self.__event.emit(nextTweet)
        except Queue.Empty:
            pass
        return ret

    def subscribe(self, callback):
        """Subscribe to Twitter events. The event handler will receive a dictionary with the data as defined in:
        https://dev.twitter.com/docs/streaming-apis/messages#Public_stream_messages.
        """
        return self.__event.subscribe(callback)

    def start(self):
        if self.__thread is not None:
            raise Exception("Already running")

        # Start the thread that will run the client.
        self.__thread = threading.Thread(target=self.__threadMain)
        self.__thread.start()
        self.__running = True

    def stop(self):
        try:
            if self.__thread is not None and self.__thread.is_alive():
                logger.info("Shutting down client.")
                self.__stream.disconnect()
        except Exception, e:
            logger.error("Error disconnecting stream: %s." % (str(e)))

    def join(self):
        if self.__thread is not None:
            self.__thread.join()
        assert(not self.__running)

    def eof(self):
        return not self.__running

    def dispatch(self):
        ret = False
        dispatched = TwitterFeed.MAX_EVENTS_PER_DISPATCH
        while self.__dispatchImpl() and dispatched > 0:
            ret = True
            dispatched -= 1
        return ret

    def peekDateTime(self):
        return None

    def getDispatchPriority(self):
        return None

########NEW FILE########
__FILENAME__ = collections
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import numpy as np


def lt(v1, v2):
    if v1 is None:
        return True
    elif v2 is None:
        return False
    else:
        return v1 < v2


# Returns (values, ix1, ix2)
# values1 and values2 are assumed to be sorted
def intersect(values1, values2, skipNone=False):
    ix1 = []
    ix2 = []
    values = []

    i1 = 0
    i2 = 0
    while i1 < len(values1) and i2 < len(values2):
        v1 = values1[i1]
        v2 = values2[i2]
        if v1 == v2 and (v1 is not None or skipNone is False):
            ix1.append(i1)
            ix2.append(i2)
            values.append(v1)
            i1 += 1
            i2 += 1
        elif lt(v1, v2):
            i1 += 1
        else:
            i2 += 1

    return (values, ix1, ix2)


# Like a collections.deque but using a numpy.array.
class NumPyDeque(object):
    def __init__(self, maxLen, dtype=float):
        if not maxLen > 0:
            raise Exception("Invalid maximum length")

        self.__values = np.empty(maxLen, dtype=dtype)
        self.__maxLen = maxLen
        self.__nextPos = 0

    def getMaxLen(self):
        return self.__maxLen

    def append(self, value):
        if self.__nextPos < self.__maxLen:
            self.__values[self.__nextPos] = value
            self.__nextPos += 1
        else:
            # Shift items to the left and put the last value.
            # I'm not using np.roll to avoid creating a new array.
            self.__values[0:-1] = self.__values[1:]
            self.__values[self.__nextPos - 1] = value

    def data(self):
        # If all values are not initialized, return a portion of the array.
        if self.__nextPos < self.__maxLen:
            ret = self.__values[0:self.__nextPos]
        else:
            ret = self.__values
        return ret

    def resize(self, maxLen):
        if not maxLen > 0:
            raise Exception("Invalid maximum length")

        self.__values = np.resize(self.__values, maxLen)
        self.__maxLen = maxLen
        if self.__nextPos >= self.__maxLen:
            self.__nextPos = self.__maxLen

    def __len__(self):
        return self.__nextPos

    def __getitem__(self, key):
        return self.data()[key]


# I'm not using collections.deque because:
# 1: Random access is slower.
# 2: Slicing is not supported.
class ListDeque(object):
    def __init__(self, maxLen, dtype=float):
        if not maxLen > 0:
            raise Exception("Invalid maximum length")

        self.__values = []
        self.__maxLen = maxLen

    def getMaxLen(self):
        return self.__maxLen

    def append(self, value):
        self.__values.append(value)
        # Check bounds
        if len(self.__values) > self.__maxLen:
            self.__values.pop(0)

    def data(self):
        return self.__values

    def resize(self, maxLen):
        if not maxLen > 0:
            raise Exception("Invalid maximum length")

        self.__maxLen = maxLen
        if len(self.__values) > maxLen:
            self.__values = self.__values[-1*maxLen:]

    def __len__(self):
        return len(self.__values)

    def __getitem__(self, key):
        return self.__values[key]

########NEW FILE########
__FILENAME__ = csvutils
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import csv


# A faster (but limited) version of csv.DictReader
class FastDictReader(object):
    def __init__(self, f, fieldnames=None, dialect="excel", *args, **kwargs):
        self.__fieldNames = fieldnames
        self.reader = csv.reader(f, dialect, *args, **kwargs)
        if self.__fieldNames is None:
            self.__fieldNames = self.reader.next()
        self.__dict = {}

    def __iter__(self):
        return self

    def next(self):
        # Skip empty rows.
        row = self.reader.next()
        while row == []:
            row = self.reader.next()

        # Check that the row has the right number of columns.
        assert(len(self.__fieldNames) == len(row))

        # Copy the row values into the dict.
        for i in xrange(len(self.__fieldNames)):
            self.__dict[self.__fieldNames[i]] = row[i]

        return self.__dict

########NEW FILE########
__FILENAME__ = dt
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import datetime
import pytz


def datetime_is_naive(dateTime):
    """ Returns True if dateTime is naive."""
    return dateTime.tzinfo is None or dateTime.tzinfo.utcoffset(dateTime) is None


# Remove timezone information.
def unlocalize(dateTime):
    return dateTime.replace(tzinfo=None)


def localize(dateTime, timeZone):
    """Returns a datetime adjusted to a timezone:

     * If dateTime is a naive datetime (datetime with no timezone information), timezone information is added but date and time remains the same.
     * If dateTime is not a naive datetime, a datetime object with new tzinfo attribute is returned, adjusting the date and time data so the result is the same UTC time.
    """

    if datetime_is_naive(dateTime):
        ret = timeZone.localize(dateTime)
    else:
        ret = dateTime.astimezone(timeZone)
    return ret


def as_utc(dateTime):
    return localize(dateTime, pytz.utc)


def datetime_to_timestamp(dateTime):
    """ Converts a datetime.datetime to a UTC timestamp."""
    diff = as_utc(dateTime) - epoch_utc
    return diff.total_seconds()


def timestamp_to_datetime(timeStamp, localized=True):
    """ Converts a UTC timestamp to a datetime.datetime."""
    ret = datetime.datetime.utcfromtimestamp(timeStamp)
    if localized:
        ret = localize(ret, pytz.utc)
    return ret


def get_first_monday(year):
    ret = datetime.date(year, 1, 1)
    if ret.weekday() != 0:
        diff = 7 - ret.weekday()
        ret = ret + datetime.timedelta(days=diff)
    return ret


def get_last_monday(year):
    ret = datetime.date(year, 12, 31)
    if ret.weekday() != 0:
        diff = ret.weekday() * -1
        ret = ret + datetime.timedelta(days=diff)
    return ret


epoch_utc = as_utc(datetime.datetime(1970, 1, 1))

########NEW FILE########
__FILENAME__ = stats
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import numpy


def mean(values):
    ret = None
    if len(values):
        ret = numpy.array(values).mean()
    return ret


def stddev(values, ddof=1):
    ret = None
    if len(values):
        ret = numpy.array(values).std(ddof=ddof)
    return ret

########NEW FILE########
__FILENAME__ = warninghelpers
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import warnings


class PyAlgoTradeDeprecationWarning(DeprecationWarning):
    pass

warnings.simplefilter("default", PyAlgoTradeDeprecationWarning)


# Deprecation warnings are disabled by default in Python 2.7, so this helper function enables them back.
def deprecation_warning(msg, stacklevel=0):
    warnings.warn(msg, category=PyAlgoTradeDeprecationWarning, stacklevel=stacklevel+1)

########NEW FILE########
__FILENAME__ = client
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import json
import time

from ws4py.client import tornadoclient
import tornado
import pyalgotrade.logger


logger = pyalgotrade.logger.getLogger("websocket")


# This class is responsible for sending keep alive messages and detecting disconnections
# from the server.
class KeepAliveMgr(object):
    def __init__(self, wsClient, maxInactivity, responseTimeout):
        assert(maxInactivity > 0)
        assert(responseTimeout > 0)
        self.__callback = None
        self.__wsClient = wsClient
        self.__activityTimeout = maxInactivity
        self.__responseTimeout = responseTimeout
        self.__lastSeen = None
        self.__kaSent = None  # timestamp when the last keep alive was sent.

    def _keepAlive(self):
        if self.__lastSeen is None:
            return

        # Check if we're under the inactivity threshold.
        inactivity = (time.time() - self.__lastSeen)
        if inactivity <= self.__activityTimeout:
            return

        # Send keep alive if it was not sent,
        # or check if we have to timeout waiting for the keep alive response.
        try:
            if self.__kaSent is None:
                self.sendKeepAlive()
                self.__kaSent = time.time()
            elif (time.time() - self.__kaSent) > self.__responseTimeout:
                self.__wsClient.onDisconnectionDetected()
        except Exception:
            # Treat an error sending the keep-alive as a diconnection.
            # print "Error sending keep alive", e
            self.__wsClient.onDisconnectionDetected()

    def getWSClient(self):
        return self.__wsClient

    def setAlive(self):
        self.__lastSeen = time.time()
        self.__kaSent = None

    def start(self):
        # Check every second.
        self.__callback = tornado.ioloop.PeriodicCallback(self._keepAlive, 1000, self.__wsClient.getIOLoop())
        self.__callback.start()

    def stop(self):
        if self.__callback is not None:
            self.__callback.stop()

    # Override to send the keep alive msg.
    def sendKeepAlive(self):
        raise NotImplementedError()

    # Return True if the response belongs to a keep alive message, False otherwise.
    def handleResponse(self, msg):
        raise NotImplementedError()


# Base clase for websocket clients.
# To use it call connect and startClient, and stopClient.
class WebSocketClientBase(tornadoclient.TornadoWebSocketClient):
    def __init__(self, url):
        tornadoclient.TornadoWebSocketClient.__init__(self, url)
        self.__keepAliveMgr = None
        self.__connected = False

    # This is to avoid a stack trace because TornadoWebSocketClient is not implementing _cleanup.
    def _cleanup(self):
        ret = None
        try:
            ret = tornadoclient.TornadoWebSocketClient._cleanup(self)
        except Exception:
            pass
        return ret

    def getIOLoop(self):
        return tornado.ioloop.IOLoop.instance()

    # Must be set before calling startClient().
    def setKeepAliveMgr(self, keepAliveMgr):
        if self.__keepAliveMgr is not None:
            raise Exception("KeepAliveMgr already set")
        self.__keepAliveMgr = keepAliveMgr

    def received_message(self, message):
        try:
            msg = json.loads(message.data)

            if self.__keepAliveMgr is not None:
                self.__keepAliveMgr.setAlive()
                if self.__keepAliveMgr.handleResponse(msg):
                    return

            self.onMessage(msg)
        except Exception, e:
            self.onUnhandledException(e)

    def opened(self):
        self.__connected = True
        if self.__keepAliveMgr is not None:
            self.__keepAliveMgr.start()
            self.__keepAliveMgr.setAlive()
        self.onOpened()

    def closed(self, code, reason=None):
        self.__connected = False
        if self.__keepAliveMgr:
            self.__keepAliveMgr.stop()
            self.__keepAliveMgr = None
        tornado.ioloop.IOLoop.instance().stop()

        self.onClosed(code, reason)

    def isConnected(self):
        return self.__connected

    def startClient(self):
        tornado.ioloop.IOLoop.instance().start()

    def stopClient(self):
        self.close_connection()

    ######################################################################
    # Overrides

    def onUnhandledException(self, exception):
        logger.critical("Unhandled exception", exc_info=exception)
        raise

    def onOpened(self):
        pass

    def onMessage(self, msg):
        raise NotImplementedError()

    def onClosed(self, code, reason):
        pass

    def onDisconnectionDetected(self):
        pass

########NEW FILE########
__FILENAME__ = pusher
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import json
import urllib

import pyalgotrade
from pyalgotrade.websocket import client
import pyalgotrade.logger


logger = pyalgotrade.logger.getLogger("pusher")


# Pusher protocol reference: http://pusher.com/docs/pusher_protocol
# Every message on a Pusher WebSocket connection is packaged as an event.
# The data field is sent as a string (check 'Double encoding' in the protocol reference). If dataIsJSON is True, it is decoded.
class Event(object):
    def __init__(self, eventDict, dataIsJSON):
        self.__eventDict = eventDict
        self.__data = eventDict.get("data")
        if self.__data is not None and dataIsJSON:
            self.__data = json.loads(self.__data)

    def __str__(self):
        return str(self.__eventDict)

    def getDict(self):
        return self.__eventDict

    def getData(self):
        return self.__data

    def getType(self):
        return self.__eventDict.get("event")


class PingKeepAliveMgr(client.KeepAliveMgr):
    def __init__(self, wsClient, maxInactivity, responseTimeout):
        client.KeepAliveMgr.__init__(self, wsClient, maxInactivity, responseTimeout)

    # Override to send the keep alive msg.
    def sendKeepAlive(self):
        logger.debug("Sending pusher:ping.")
        self.getWSClient().sendPing()

    # Return True if the response belongs to a keep alive message, False otherwise.
    def handleResponse(self, msg):
        ret = msg.get("event") == "pusher:pong"
        if ret:
            logger.debug("Received pusher:pong.")
        return ret


class WebSocketClient(client.WebSocketClientBase):
    def __init__(self, appKey, protocol=5, maxInactivity=120, responseTimeout=30):
        params = {
            "protocol": protocol,
            "client": "Python-PyAlgoTrade",
            "version": pyalgotrade.__version__
            }
        url = "ws://ws.pusherapp.com/app/%s?%s" % (appKey, urllib.urlencode(params))
        client.WebSocketClientBase.__init__(self, url)
        self.setKeepAliveMgr(PingKeepAliveMgr(self, maxInactivity, responseTimeout))

    def sendEvent(self, eventType, eventData):
        msgDict = {"event": eventType}
        if eventData:
            msgDict["data"] = eventData
        msg = json.dumps(msgDict)
        self.send(msg, False)

    def subscribeChannel(self, channel):
        self.sendEvent("pusher:subscribe", {"channel": channel})

    def sendPing(self):
        self.sendEvent("pusher:ping", None)

    def sendPong(self):
        self.sendEvent("pusher:pong", None)

    def onMessage(self, msg):
        eventType = msg.get("event")

        if eventType == "pusher:error":
            self.onError(Event(msg, True))
        elif eventType == "pusher:ping":
            self.sendPong()
        elif eventType == "pusher:connection_established":
            self.onConnectionEstablished(Event(msg, True))
        elif eventType == "pusher_internal:subscription_succeeded":
            self.onSubscriptionSucceeded(Event(msg, True))
        elif eventType == "pusher_internal:subscription_error":
            self.onSubscriptionError(Event(msg, True))
        else:
            # If we can't handle the message, notify the most concrete class.
            self.onUnknownEvent(Event(msg, False))

    ######################################################################
    # Override for Pusher specific events.

    def onConnectionEstablished(self, event):
        pass

    def onSubscriptionSucceeded(self, event):
        pass

    def onSubscriptionError(self, event):
        raise NotImplementedError()

    def onError(self, event):
        raise NotImplementedError()

    def onUnknownEvent(self, event):
        raise NotImplementedError()

########NEW FILE########
__FILENAME__ = api
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import urlparse
import urllib
import urllib2
import json
import pytz

from pyalgotrade.utils import dt


USE_SECURE_REQUESTS = False

# The exchange list comes from:
#  https://www.xignite.com/product/global-real-time-stock-quote-data/api/ListExchanges/
#
# I couldn't deduce the timezones for OOTC, PINX and XOTC using:
#  https://www.xignite.com/product/XigniteGlobalExchanges/api/GetExchangeHoursUTC/
#  https://www.xignite.com/product/XigniteGlobalExchanges/api/GetExchangeHours/

MARKET_TIMEZONES = {
    "ARCX": pytz.timezone("US/Eastern"),     # NYSE ARCA
    "CHIX": pytz.timezone("Europe/London"),  # CHI-X EUROPE LIMITED
    "XASE": pytz.timezone("US/Eastern"),     # NYSE MKT EQUITIES
    "XNAS": pytz.timezone("US/Eastern"),     # NASDAQ
    "XNYS": pytz.timezone("US/Eastern"),     # NEW YORK STOCK EXCHANGE, INC
}


class XigniteError(Exception):
    def __init__(self, message, response):
        Exception.__init__(self, message)
        self.__response = response

    def getResponse(self):
        return self.__response


def to_market_datetime(dateTime, exchange):
    timezone = MARKET_TIMEZONES.get(exchange)
    if timezone is None:
        raise Exception("No timezone available to localize datetime for exchange %s" % (exchange))
    return dt.localize(dateTime, timezone)


def datetime_to_string(dateTime, exchange):
    # MM/DD/YYYY HH:MM
    return to_market_datetime(dateTime, exchange).strftime("%m/%d/%Y %H:%M")


def json_http_request(url):
    f = urllib2.urlopen(url)
    response = f.read()
    return json.loads(response)


def parse_instrument_exchange(identifier):
    ret = identifier.split(".")
    if len(ret) != 2:
        raise Exception("Invalid identifier. Exchange suffix is missing")
    return ret


# https://www.xignite.com/product/global-real-time-stock-quote-data/api/GetBar/
def XigniteGlobalRealTime_GetBar(token, identifier, identifierType, endDateTime, precision, period, secureRequest=None):
    if dt.datetime_is_naive(endDateTime):
        raise Exception("endDateTime must have a timezone")

    # Parse the exchange from the identifier.
    instrument, exchange = parse_instrument_exchange(identifier)

    if secureRequest is None:
        secureRequest = USE_SECURE_REQUESTS

    if secureRequest:
        scheme = "https"
    else:
        scheme = "http"

    # print datetime_to_string(endDateTime, exchange)
    params = {
        "_Token": token,
        "Identifier": identifier,
        "IdentifierType": identifierType,
        "EndTime": datetime_to_string(endDateTime, exchange),
        "Precision": precision,
        "Period": period,
    }
    parts = (scheme, "globalrealtime.xignite.com", "v3/xGlobalRealTime.json/GetBar", urllib.urlencode(params), "")
    url = urlparse.urlunsplit(parts)

    ret = json_http_request(url)
    if ret.get("Outcome") != "Success":
        msg = ret.get("Message")
        if msg is None:
            msg = "Error %s" % (ret.get("Outcome"))
        raise XigniteError(msg, ret)

    return ret

########NEW FILE########
__FILENAME__ = barfeed
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import time
import datetime
import threading
import Queue

from pyalgotrade import bar
from pyalgotrade import barfeed
from pyalgotrade import dataseries
from pyalgotrade.dataseries import resampled
import pyalgotrade.logger
from pyalgotrade.utils import dt
import api


logger = pyalgotrade.logger.getLogger("xignite")


def utcnow():
    return dt.as_utc(datetime.datetime.utcnow())


class PollingThread(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.__stopped = False

    def __wait(self):
        # Wait until getNextCallDateTime checking for cancelation every 0.5 second.
        nextCall = self.getNextCallDateTime()
        while not self.__stopped and utcnow() < nextCall:
            time.sleep(0.5)

    def stop(self):
        self.__stopped = True

    def stopped(self):
        return self.__stopped

    def run(self):
        logger.debug("Thread started.")
        while not self.__stopped:
            self.__wait()
            if not self.__stopped:
                try:
                    self.doCall()
                except Exception, e:
                    logger.critical("Unhandled exception", exc_info=e)
        logger.debug("Thread finished.")

    # Must return a non-naive datetime.
    def getNextCallDateTime(self):
        raise NotImplementedError()

    def doCall(self):
        raise NotImplementedError()


def build_bar(barDict, identifier, frequency):
    # "StartDate": "3/19/2014"
    # "StartTime": "9:55:00 AM"
    # "EndDate": "3/19/2014"
    # "EndTime": "10:00:00 AM"
    # "UTCOffset": 0
    # "Open": 31.71
    # "High": 31.71
    # "Low": 31.68
    # "Close": 31.69
    # "Volume": 2966
    # "Trades": 19
    # "TWAP": 31.6929
    # "VWAP": 31.693

    startDate = barDict["StartDate"]
    startTime = barDict["StartTime"]
    startDateTimeStr = startDate + " " + startTime
    startDateTime = datetime.datetime.strptime(startDateTimeStr, "%m/%d/%Y %I:%M:%S %p")

    instrument, exchange = api.parse_instrument_exchange(identifier)
    startDateTime = api.to_market_datetime(startDateTime, exchange)

    return bar.BasicBar(startDateTime, barDict["Open"], barDict["High"], barDict["Low"], barDict["Close"], barDict["Volume"], None, frequency)


class GetBarThread(PollingThread):

    # Events
    ON_BARS = 1

    def __init__(self, queue, apiToken, identifiers, frequency, apiCallDelay):
        PollingThread.__init__(self)

        # Map frequency to precision and period.
        if frequency < bar.Frequency.MINUTE:
            raise Exception("Frequency must be greater than or equal to bar.Frequency.MINUTE")
        elif frequency < bar.Frequency.HOUR:
            self.__precision = "Minutes"
            self.__period = frequency / bar.Frequency.MINUTE
            self.__timeDelta = datetime.timedelta(minutes=self.__period)
        elif frequency < bar.Frequency.DAY:
            self.__precision = "Hours"
            self.__period = frequency / bar.Frequency.HOUR
            self.__timeDelta = datetime.timedelta(hours=self.__period)
        else:
            raise Exception("Frequency must be less than bar.Frequency.DAY")

        self.__queue = queue
        self.__apiToken = apiToken
        self.__identifiers = identifiers
        self.__frequency = frequency
        self.__nextBarClose = None
        # The delay between the bar's close and the API call.
        self.__apiCallDelay = apiCallDelay

        self.__updateNextBarClose()

    def __updateNextBarClose(self):
        self.__nextBarClose = resampled.get_slot_datetime(utcnow(), self.__frequency) + self.__timeDelta

    def getNextCallDateTime(self):
        return self.__nextBarClose + self.__apiCallDelay

    def doCall(self):
        endDateTime = self.__nextBarClose
        self.__updateNextBarClose()
        barDict = {}

        for indentifier in self.__identifiers:
            try:
                logger.debug("Requesting bars with precision %s and period %s for %s" % (self.__precision, self.__period, indentifier))
                response = api.XigniteGlobalRealTime_GetBar(self.__apiToken, indentifier, "Symbol", endDateTime, self.__precision, self.__period)
                # logger.debug(response)
                barDict[indentifier] = build_bar(response["Bar"], indentifier, self.__frequency)
            except api.XigniteError, e:
                logger.error(e)

        if len(barDict):
            bars = bar.Bars(barDict)
            self.__queue.put((GetBarThread.ON_BARS, bars))


class LiveFeed(barfeed.BaseBarFeed):
    """A real-time BarFeed that builds bars using XigniteGlobalRealTime API
    (https://www.xignite.com/product/global-real-time-stock-quote-data/).

    :param apiToken: The API token to authenticate calls to Xignine APIs.
    :type apiToken: string.
    :param identifiers: A list with the fully qualified identifier for the securities including the exchange suffix.
    :type identifiers: list.
    :param frequency: The frequency of the bars.
        Must be greater than or equal to **bar.Frequency.MINUTE** and less than **bar.Frequency.DAY**.
    :param apiCallDelay: The delay in seconds between the bar's close and the API call.
        This is necessary because the bar may not be immediately available.
    :type apiCallDelay: int.
    :param maxLen: The maximum number of values that the :class:`pyalgotrade.dataseries.bards.BarDataSeries` will hold.
        Once a bounded length is full, when new items are added, a corresponding number of items are discarded from the opposite end.
    :type maxLen: int.

    .. note:: Valid exchange suffixes are:

         * **ARCX**: NYSE ARCA
         * **CHIX**: CHI-X EUROPE LIMITED
         * **XASE**: NYSE MKT EQUITIES
         * **XNAS**: NASDAQ
         * **XNYS**: NEW YORK STOCK EXCHANGE, INC
    """

    QUEUE_TIMEOUT = 0.01

    def __init__(self, apiToken, identifiers, frequency, apiCallDelay=30, maxLen=dataseries.DEFAULT_MAX_LEN):
        barfeed.BaseBarFeed.__init__(self, frequency, maxLen)
        if not isinstance(identifiers, list):
            raise Exception("identifiers must be a list")

        self.__queue = Queue.Queue()
        self.__thread = GetBarThread(self.__queue, apiToken, identifiers, frequency, datetime.timedelta(seconds=apiCallDelay))
        for instrument in identifiers:
            self.registerInstrument(instrument)

    ######################################################################
    # observer.Subject interface

    def start(self):
        if self.__thread.is_alive():
            raise Exception("Already strated")

        # Start the thread that runs the client.
        self.__thread.start()

    def stop(self):
        self.__thread.stop()

    def join(self):
        if self.__thread.is_alive():
            self.__thread.join()

    def eof(self):
        return self.__thread.stopped()

    def peekDateTime(self):
        return None

    def isRealTime(self):
        return True

    ######################################################################
    # barfeed.BaseBarFeed interface

    def barsHaveAdjClose(self):
        return False

    def getNextBars(self):
        ret = None
        try:
            eventType, eventData = self.__queue.get(True, LiveFeed.QUEUE_TIMEOUT)
            if eventType == GetBarThread.ON_BARS:
                ret = eventData
            else:
                logger.error("Invalid event received: %s - %s" % (eventType, eventData))
        except Queue.Empty:
            pass
        return ret

########NEW FILE########
__FILENAME__ = bbands
from pyalgotrade import strategy
from pyalgotrade import plotter
from pyalgotrade.tools import yahoofinance
from pyalgotrade.technical import bollinger
from pyalgotrade.stratanalyzer import sharpe


class BBands(strategy.BacktestingStrategy):
    def __init__(self, feed, instrument, bBandsPeriod):
        strategy.BacktestingStrategy.__init__(self, feed)
        self.__instrument = instrument
        self.__bbands = bollinger.BollingerBands(feed[instrument].getCloseDataSeries(), bBandsPeriod, 2)

    def getBollingerBands(self):
        return self.__bbands

    def onBars(self, bars):
        lower = self.__bbands.getLowerBand()[-1]
        upper = self.__bbands.getUpperBand()[-1]
        if lower is None:
            return

        shares = self.getBroker().getShares(self.__instrument)
        bar = bars[self.__instrument]
        if shares == 0 and bar.getClose() < lower:
            sharesToBuy = int(self.getBroker().getCash(False) / bar.getClose())
            self.marketOrder(self.__instrument, sharesToBuy)
        elif shares > 0 and bar.getClose() > upper:
            self.marketOrder(self.__instrument, -1*shares)


def main(plot):
    instrument = "yhoo"
    bBandsPeriod = 40

    # Download the bars.
    feed = yahoofinance.build_feed([instrument], 2011, 2012, ".")

    strat = BBands(feed, instrument, bBandsPeriod)
    sharpeRatioAnalyzer = sharpe.SharpeRatio()
    strat.attachAnalyzer(sharpeRatioAnalyzer)

    if plot:
        plt = plotter.StrategyPlotter(strat, True, True, True)
        plt.getInstrumentSubplot(instrument).addDataSeries("upper", strat.getBollingerBands().getUpperBand())
        plt.getInstrumentSubplot(instrument).addDataSeries("middle", strat.getBollingerBands().getMiddleBand())
        plt.getInstrumentSubplot(instrument).addDataSeries("lower", strat.getBollingerBands().getLowerBand())

    strat.run()
    print "Sharpe ratio: %.2f" % sharpeRatioAnalyzer.getSharpeRatio(0.05)

    if plot:
        plt.plot()


if __name__ == "__main__":
    main(True)

########NEW FILE########
__FILENAME__ = compinv-1
from pyalgotrade import strategy
from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.stratanalyzer import returns
from pyalgotrade.stratanalyzer import sharpe
from pyalgotrade.utils import stats


class MyStrategy(strategy.BacktestingStrategy):
    def __init__(self, feed):
        strategy.BacktestingStrategy.__init__(self, feed, 1000000)

        # We wan't to use adjusted close prices instead of close.
        self.setUseAdjustedValues(True)

        # Place the orders to get them processed on the first bar.
        orders = {
            "aeti": 297810,
            "egan": 81266,
            "glng": 11095,
            "simo": 17293,
        }
        for instrument, quantity in orders.items():
            self.marketOrder(instrument, quantity, onClose=True, allOrNone=True)

    def onBars(self, bars):
        pass

# Load the yahoo feed from CSV files.
feed = yahoofeed.Feed()
feed.addBarsFromCSV("aeti", "aeti-2011-yahoofinance.csv")
feed.addBarsFromCSV("egan", "egan-2011-yahoofinance.csv")
feed.addBarsFromCSV("glng", "glng-2011-yahoofinance.csv")
feed.addBarsFromCSV("simo", "simo-2011-yahoofinance.csv")

# Evaluate the strategy with the feed's bars.
myStrategy = MyStrategy(feed)

# Attach returns and sharpe ratio analyzers.
retAnalyzer = returns.Returns()
myStrategy.attachAnalyzer(retAnalyzer)
sharpeRatioAnalyzer = sharpe.SharpeRatio()
myStrategy.attachAnalyzer(sharpeRatioAnalyzer)

# Run the strategy
myStrategy.run()

# Print the results.
print "Final portfolio value: $%.2f" % myStrategy.getResult()
print "Anual return: %.2f %%" % (retAnalyzer.getCumulativeReturns()[-1] * 100)
print "Average daily return: %.2f %%" % (stats.mean(retAnalyzer.getReturns()) * 100)
print "Std. dev. daily return: %.4f" % (stats.stddev(retAnalyzer.getReturns()))
print "Sharpe ratio: %.2f" % (sharpeRatioAnalyzer.getSharpeRatio(0))

########NEW FILE########
__FILENAME__ = compinv-3
import csv
import datetime
import os

from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.barfeed import csvfeed
from pyalgotrade import strategy
from pyalgotrade.utils import stats
from pyalgotrade.stratanalyzer import returns
from pyalgotrade.stratanalyzer import sharpe


class OrdersFile:
    def __init__(self, ordersFile):
        self.__orders = {}
        self.__firstDate = None
        self.__lastDate = None
        self.__instruments = []

        # Load orders from the file.
        reader = csv.DictReader(open(ordersFile, "r"), fieldnames=["year", "month", "day", "symbol", "action", "qty"])
        for row in reader:
            dateTime = datetime.datetime(int(row["year"]), int(row["month"]), int(row["day"]))
            self.__orders.setdefault(dateTime, [])
            order = (row["symbol"], row["action"], int(row["qty"]))
            self.__orders[dateTime].append(order)

            # As we process the file, store instruments, first date, and last date.
            if row["symbol"] not in self.__instruments:
                self.__instruments.append(row["symbol"])

            if self.__firstDate is None:
                self.__firstDate = dateTime
            else:
                self.__firstDate = min(self.__firstDate, dateTime)

            if self.__lastDate is None:
                self.__lastDate = dateTime
            else:
                self.__lastDate = max(self.__lastDate, dateTime)

    def getFirstDate(self):
        return self.__firstDate

    def getLastDate(self):
        return self.__lastDate

    def getInstruments(self):
        return self.__instruments

    def getOrders(self, dateTime):
        return self.__orders.get(dateTime, [])


class MyStrategy(strategy.BacktestingStrategy):
    def __init__(self, feed, cash, ordersFile, useAdjustedClose):
        # Suscribe to the feed bars event before the broker just to place the orders properly.
        feed.getNewBarsEvent().subscribe(self.__onBarsBeforeBroker)
        strategy.BacktestingStrategy.__init__(self, feed, cash)
        self.__ordersFile = ordersFile
        self.setUseAdjustedValues(useAdjustedClose)
        # We will allow buying more shares than cash allows.
        self.getBroker().setAllowNegativeCash(True)

    def __onBarsBeforeBroker(self, dateTime, bars):
        for instrument, action, quantity in self.__ordersFile.getOrders(dateTime):
            if action.lower() == "buy":
                self.marketOrder(instrument, quantity, onClose=True)
            else:
                self.marketOrder(instrument, quantity*-1, onClose=True)

    def onOrderUpdated(self, order):
        if order.isCanceled():
            raise Exception("Order canceled. Ran out of cash ?")

    def onBars(self, bars):
        portfolioValue = self.getBroker().getEquity()
        self.info("Portfolio value: $%.2f" % (portfolioValue))


def main():
    # Load the orders file.
    ordersFile = OrdersFile("orders.csv")
    print "First date", ordersFile.getFirstDate()
    print "Last date", ordersFile.getLastDate()
    print "Symbols", ordersFile.getInstruments()

    # Load the data from QSTK storage. QS environment variable has to be defined.
    if os.getenv("QS") is None:
        raise Exception("QS environment variable not defined")
    feed = yahoofeed.Feed()
    feed.setBarFilter(csvfeed.DateRangeFilter(ordersFile.getFirstDate(), ordersFile.getLastDate()))
    feed.setDailyBarTime(datetime.time(0, 0, 0))  # This is to match the dates loaded with the ones in the orders file.
    for symbol in ordersFile.getInstruments():
        feed.addBarsFromCSV(symbol, os.path.join(os.getenv("QS"), "QSData", "Yahoo", symbol + ".csv"))

    # Run the strategy.
    cash = 1000000
    useAdjustedClose = True
    myStrategy = MyStrategy(feed, cash, ordersFile, useAdjustedClose)

    # Attach returns and sharpe ratio analyzers.
    retAnalyzer = returns.Returns()
    myStrategy.attachAnalyzer(retAnalyzer)
    sharpeRatioAnalyzer = sharpe.SharpeRatio()
    myStrategy.attachAnalyzer(sharpeRatioAnalyzer)

    myStrategy.run()

    # Print the results.
    print "Final portfolio value: $%.2f" % myStrategy.getResult()
    print "Anual return: %.2f %%" % (retAnalyzer.getCumulativeReturns()[-1] * 100)
    print "Average daily return: %.2f %%" % (stats.mean(retAnalyzer.getReturns()) * 100)
    print "Std. dev. daily return: %.4f" % (stats.stddev(retAnalyzer.getReturns()))
    print "Sharpe ratio: %.2f" % (sharpeRatioAnalyzer.getSharpeRatio(0))

main()

########NEW FILE########
__FILENAME__ = csvfeed_1
from pyalgotrade.feed import csvfeed

feed = csvfeed.Feed("Date", "%Y-%m-%d")
feed.addValuesFromCSV("quandl_gold_2.csv")
for dateTime, value in feed:
    print dateTime, value

########NEW FILE########
__FILENAME__ = eventstudy
from pyalgotrade import eventprofiler
from pyalgotrade.technical import stats
from pyalgotrade.technical import roc
from pyalgotrade.technical import ma
from pyalgotrade.tools import yahoofinance

# Event inspired on an example from Ernie Chan's book:
# 'Algorithmic Trading: Winning Strategies and Their Rationale'


class BuyOnGap(eventprofiler.Predicate):
    def __init__(self, feed):
        stdDevPeriod = 90
        smaPeriod = 20
        self.__returns = {}
        self.__stdDev = {}
        self.__ma = {}
        for instrument in feed.getRegisteredInstruments():
            priceDS = feed[instrument].getAdjCloseDataSeries()
            # Returns over the adjusted close values.
            self.__returns[instrument] = roc.RateOfChange(priceDS, 1)
            # StdDev over those returns.
            self.__stdDev[instrument] = stats.StdDev(self.__returns[instrument], stdDevPeriod)
            # MA over the adjusted close values.
            self.__ma[instrument] = ma.SMA(priceDS, smaPeriod)

    def __gappedDown(self, instrument, bards):
        ret = False
        if self.__stdDev[instrument][-1] is not None:
            prevBar = bards[-2]
            currBar = bards[-1]
            low2OpenRet = (currBar.getOpen(True) - prevBar.getLow(True)) / float(prevBar.getLow(True))
            if low2OpenRet < (self.__returns[instrument][-1] - self.__stdDev[instrument][-1]):
                ret = True
        return ret

    def __aboveSMA(self, instrument, bards):
        ret = False
        if self.__ma[instrument][-1] is not None and bards[-1].getOpen(True) > self.__ma[instrument][-1]:
            ret = True
        return ret

    def eventOccurred(self, instrument, bards):
        ret = False
        if self.__gappedDown(instrument, bards) and self.__aboveSMA(instrument, bards):
            ret = True
        return ret


def main(plot):
    instruments = ["AA", "AES", "AIG"]
    feed = yahoofinance.build_feed(instruments, 2008, 2009, ".")

    predicate = BuyOnGap(feed)
    eventProfiler = eventprofiler.Profiler(predicate, 5, 5)
    eventProfiler.run(feed, True)

    results = eventProfiler.getResults()
    print "%d events found" % (results.getEventCount())
    if plot:
        eventprofiler.plot(results)

if __name__ == "__main__":
    main(True)

########NEW FILE########
__FILENAME__ = market_timing
from pyalgotrade import strategy
from pyalgotrade import plotter
from pyalgotrade.tools import yahoofinance
from pyalgotrade.technical import ma
from pyalgotrade.technical import cumret
from pyalgotrade.stratanalyzer import sharpe
from pyalgotrade.stratanalyzer import returns


class MarketTiming(strategy.BacktestingStrategy):
    def __init__(self, feed, instrumentsByClass, initialCash):
        strategy.BacktestingStrategy.__init__(self, feed, initialCash)
        self.setUseAdjustedValues(True)
        self.__instrumentsByClass = instrumentsByClass
        self.__rebalanceMonth = None
        self.__sharesToBuy = {}
        # Initialize indicators for each instrument.
        self.__sma = {}
        for assetClass in instrumentsByClass:
            for instrument in instrumentsByClass[assetClass]:
                priceDS = feed[instrument].getPriceDataSeries()
                self.__sma[instrument] = ma.SMA(priceDS, 200)

    def _shouldRebalance(self, dateTime):
        return dateTime.month != self.__rebalanceMonth

    def _getRank(self, instrument):
        # If the price is below the SMA, then this instrument doesn't rank at
        # all.
        smas = self.__sma[instrument]
        price = self.getLastPrice(instrument)
        if len(smas) == 0 or smas[-1] is None or price < smas[-1]:
            return None

        # Rank based on 20 day returns.
        ret = None
        lookBack = 20
        priceDS = self.getFeed()[instrument].getPriceDataSeries()
        if len(priceDS) >= lookBack and smas[-1] is not None and smas[-1*lookBack] is not None:
            ret = (priceDS[-1] - priceDS[-1*lookBack]) / float(priceDS[-1*lookBack])
        return ret

    def _getTopByClass(self, assetClass):
        # Find the instrument with the highest rank.
        ret = None
        highestRank = None
        for instrument in self.__instrumentsByClass[assetClass]:
            rank = self._getRank(instrument)
            if rank is not None and (highestRank is None or rank > highestRank):
                highestRank = rank
                ret = instrument
        return ret

    def _getTop(self):
        ret = {}
        for assetClass in self.__instrumentsByClass:
            ret[assetClass] = self._getTopByClass(assetClass)
        return ret

    def _placePendingOrders(self):
        remainingCash = self.getBroker().getCash() * 0.9 # Use less chash just in case price changes too much.

        for instrument in self.__sharesToBuy:
            orderSize = self.__sharesToBuy[instrument]
            if orderSize > 0:
                # Adjust the order size based on available cash.
                lastPrice = self.getLastPrice(instrument)
                cost = orderSize * lastPrice
                while cost > remainingCash and orderSize > 0:
                    orderSize -= 1
                    cost = orderSize * lastPrice
                if orderSize > 0:
                    remainingCash -= cost
                    assert(remainingCash >= 0)

            if orderSize != 0:
                self.info("Placing market order for %d %s shares" % (orderSize, instrument))
                self.marketOrder(instrument, orderSize, goodTillCanceled=True)
                self.__sharesToBuy[instrument] -= orderSize

    def _logPosSize(self):
        totalEquity = self.getBroker().getEquity()
        positions = self.getBroker().getPositions()
        for instrument in self.getBroker().getPositions():
            posSize = positions[instrument] * self.getLastPrice(instrument) / totalEquity * 100
            self.info("%s - %0.2f %%" % (instrument, posSize))

    def _rebalance(self):
        self.info("Rebalancing")

        # Cancel all active/pending orders.
        for order in self.getBroker().getActiveOrders():
            self.getBroker().cancelOrder(order)

        cashPerAssetClass = self.getBroker().getEquity() / float(len(self.__instrumentsByClass))
        self.__sharesToBuy = {}

        # Calculate which positions should be open during the next period.
        topByClass = self._getTop()
        for assetClass in topByClass:
            instrument = topByClass[assetClass]
            self.info("Best for class %s: %s" % (assetClass, instrument))
            if instrument is not None:
                lastPrice = self.getLastPrice(instrument)
                cashForInstrument = cashPerAssetClass - self.getBroker().getShares(instrument) * lastPrice
                # This may yield a negative value and we have to reduce this
                # position.
                self.__sharesToBuy[instrument] = int(cashForInstrument / lastPrice)

        # Calculate which positions should be closed.
        for instrument in self.getBroker().getPositions():
            if instrument not in topByClass.values():
                currentShares = self.getBroker().getShares(instrument)
                assert(instrument not in self.__sharesToBuy)
                self.__sharesToBuy[instrument] = currentShares * -1

    def getSMA(self, instrument):
        return self.__sma[instrument]

    def onBars(self, bars):
        currentDateTime = bars.getDateTime()

        if self._shouldRebalance(currentDateTime):
            self.__rebalanceMonth = currentDateTime.month
            self._rebalance()

        self._placePendingOrders()

def main(plot):
    initialCash = 10000
    instrumentsByClass = {
        "US Stocks": ["VTI"],
        "Foreign Stocks": ["VEU"],
        "US 10 Year Government Bonds": ["IEF"],
        "Real Estate": ["VNQ"],
        "Commodities": ["DBC"],
    }

    # Download the bars.
    instruments = ["SPY"]
    for assetClass in instrumentsByClass:
        instruments.extend(instrumentsByClass[assetClass])
    feed = yahoofinance.build_feed(instruments, 2007, 2013, "data", skipErrors=True)

    strat = MarketTiming(feed, instrumentsByClass, initialCash)
    sharpeRatioAnalyzer = sharpe.SharpeRatio()
    strat.attachAnalyzer(sharpeRatioAnalyzer)
    returnsAnalyzer = returns.Returns()
    strat.attachAnalyzer(returnsAnalyzer)

    if plot:
        plt = plotter.StrategyPlotter(strat, False, False, True)
        plt.getOrCreateSubplot("cash").addCallback("Cash", lambda x: strat.getBroker().getCash())
        # Plot strategy vs. SPY cumulative returns.
        plt.getOrCreateSubplot("returns").addDataSeries("SPY", cumret.CumulativeReturn(feed["SPY"].getPriceDataSeries()))
        plt.getOrCreateSubplot("returns").addDataSeries("Strategy", returnsAnalyzer.getCumulativeReturns())

    strat.run()
    print "Sharpe ratio: %.2f" % sharpeRatioAnalyzer.getSharpeRatio(0.05)
    print "Returns: %.2f %%" % (returnsAnalyzer.getCumulativeReturns()[-1] * 100)

    if plot:
        plt.plot()


if __name__ == "__main__":
    main(True)

########NEW FILE########
__FILENAME__ = quandl_sample
from pyalgotrade import strategy
from pyalgotrade import plotter
from pyalgotrade.tools import quandl
from pyalgotrade.feed import csvfeed
import datetime


class MyStrategy(strategy.BacktestingStrategy):
    def __init__(self, feed, quandlFeed, instrument):
        strategy.BacktestingStrategy.__init__(self, feed)
        self.setUseAdjustedValues(True)
        self.__instrument = instrument

        # It is VERY important to add the the extra feed to the event dispatch loop before
        # running the strategy.
        self.getDispatcher().addSubject(quandlFeed)

        # Subscribe to events from the Quandl feed.
        quandlFeed.getNewValuesEvent().subscribe(self.onQuandlData)

    def onQuandlData(self, dateTime, values):
        self.info(values)

    def onBars(self, bars):
        self.info(bars[self.__instrument].getAdjClose())


def main(plot):
    instruments = ["GORO"]

    # Download GORO bars using WIKI source code.
    feed = quandl.build_feed("WIKI", instruments, 2006, 2012, ".")

    # Load Quandl CSV downloaded from http://www.quandl.com/OFDP-Open-Financial-Data-Project/GOLD_2-LBMA-Gold-Price-London-Fixings-P-M
    quandlFeed = csvfeed.Feed("Date", "%Y-%m-%d")
    quandlFeed.setDateRange(datetime.datetime(2006, 1, 1), datetime.datetime(2012, 12, 31))
    quandlFeed.addValuesFromCSV("quandl_gold_2.csv")

    myStrategy = MyStrategy(feed, quandlFeed, instruments[0])

    if plot:
        plt = plotter.StrategyPlotter(myStrategy, True, False, False)
        plt.getOrCreateSubplot("quandl").addDataSeries("USD", quandlFeed["USD"])
        plt.getOrCreateSubplot("quandl").addDataSeries("EUR", quandlFeed["EUR"])
        plt.getOrCreateSubplot("quandl").addDataSeries("GBP", quandlFeed["GBP"])

    myStrategy.run()

    if plot:
        plt.plot()


if __name__ == "__main__":
    main(True)

########NEW FILE########
__FILENAME__ = rsi2
from pyalgotrade import strategy
from pyalgotrade.technical import ma
from pyalgotrade.technical import rsi
from pyalgotrade.technical import cross


class RSI2(strategy.BacktestingStrategy):
    def __init__(self, feed, instrument, entrySMA, exitSMA, rsiPeriod, overBoughtThreshold, overSoldThreshold):
        strategy.BacktestingStrategy.__init__(self, feed)
        self.__instrument = instrument
        # We'll use adjusted close values instead of regular close values.
        self.setUseAdjustedValues(True)
        self.__priceDS = feed[instrument].getPriceDataSeries()
        self.__entrySMA = ma.SMA(self.__priceDS, entrySMA)
        self.__exitSMA = ma.SMA(self.__priceDS, exitSMA)
        self.__rsi = rsi.RSI(self.__priceDS, rsiPeriod)
        self.__overBoughtThreshold = overBoughtThreshold
        self.__overSoldThreshold = overSoldThreshold
        self.__longPos = None
        self.__shortPos = None

    def getEntrySMA(self):
        return self.__entrySMA

    def getExitSMA(self):
        return self.__exitSMA

    def getRSI(self):
        return self.__rsi

    def onEnterCanceled(self, position):
        if self.__longPos == position:
            self.__longPos = None
        elif self.__shortPos == position:
            self.__shortPos = None
        else:
            assert(False)

    def onExitOk(self, position):
        if self.__longPos == position:
            self.__longPos = None
        elif self.__shortPos == position:
            self.__shortPos = None
        else:
            assert(False)

    def onExitCanceled(self, position):
        # If the exit was canceled, re-submit it.
        position.exitMarket()

    def onBars(self, bars):
        # Wait for enough bars to be available to calculate SMA and RSI.
        if self.__exitSMA[-1] is None or self.__entrySMA[-1] is None or self.__rsi[-1] is None:
            return

        bar = bars[self.__instrument]
        if self.__longPos is not None:
            if self.exitLongSignal():
                self.__longPos.exitMarket()
        elif self.__shortPos is not None:
            if self.exitShortSignal():
                self.__shortPos.exitMarket()
        else:
            if self.enterLongSignal(bar):
                shares = int(self.getBroker().getCash() * 0.9 / bars[self.__instrument].getPrice())
                self.__longPos = self.enterLong(self.__instrument, shares, True)
            elif self.enterShortSignal(bar):
                shares = int(self.getBroker().getCash() * 0.9 / bars[self.__instrument].getPrice())
                self.__shortPos = self.enterShort(self.__instrument, shares, True)

    def enterLongSignal(self, bar):
        return bar.getPrice() > self.__entrySMA[-1] and self.__rsi[-1] <= self.__overSoldThreshold

    def exitLongSignal(self):
        return cross.cross_above(self.__priceDS, self.__exitSMA)

    def enterShortSignal(self, bar):
        return bar.getPrice() < self.__entrySMA[-1] and self.__rsi[-1] >= self.__overBoughtThreshold

    def exitShortSignal(self):
        return cross.cross_below(self.__priceDS, self.__exitSMA)

########NEW FILE########
__FILENAME__ = rsi2_sample
import rsi2
from pyalgotrade import plotter
from pyalgotrade.tools import yahoofinance
from pyalgotrade.stratanalyzer import sharpe


def main(plot):
    instrument = "DIA"
    entrySMA = 200
    exitSMA = 5
    rsiPeriod = 2
    overBoughtThreshold = 90
    overSoldThreshold = 10

    # Download the bars.
    feed = yahoofinance.build_feed([instrument], 2009, 2012, ".")

    strat = rsi2.RSI2(feed, instrument, entrySMA, exitSMA, rsiPeriod, overBoughtThreshold, overSoldThreshold)
    sharpeRatioAnalyzer = sharpe.SharpeRatio()
    strat.attachAnalyzer(sharpeRatioAnalyzer)

    if plot:
        plt = plotter.StrategyPlotter(strat, True, False, True)
        plt.getInstrumentSubplot(instrument).addDataSeries("Entry SMA", strat.getEntrySMA())
        plt.getInstrumentSubplot(instrument).addDataSeries("Exit SMA", strat.getExitSMA())
        plt.getOrCreateSubplot("rsi").addDataSeries("RSI", strat.getRSI())
        plt.getOrCreateSubplot("rsi").addLine("Overbought", overBoughtThreshold)
        plt.getOrCreateSubplot("rsi").addLine("Oversold", overSoldThreshold)

    strat.run()
    print "Sharpe ratio: %.2f" % sharpeRatioAnalyzer.getSharpeRatio(0.05)

    if plot:
        plt.plot()


if __name__ == "__main__":
    main(True)

########NEW FILE########
__FILENAME__ = sample-strategy-analyzer
from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.stratanalyzer import returns
from pyalgotrade.stratanalyzer import sharpe
from pyalgotrade.stratanalyzer import drawdown
from pyalgotrade.stratanalyzer import trades
import sma_crossover

# Load the yahoo feed from the CSV file
feed = yahoofeed.Feed()
feed.addBarsFromCSV("orcl", "orcl-2000.csv")

# Evaluate the strategy with the feed's bars.
myStrategy = sma_crossover.SMACrossOver(feed, "orcl", 20)

# Attach different analyzers to a strategy before executing it.
retAnalyzer = returns.Returns()
myStrategy.attachAnalyzer(retAnalyzer)
sharpeRatioAnalyzer = sharpe.SharpeRatio()
myStrategy.attachAnalyzer(sharpeRatioAnalyzer)
drawDownAnalyzer = drawdown.DrawDown()
myStrategy.attachAnalyzer(drawDownAnalyzer)
tradesAnalyzer = trades.Trades()
myStrategy.attachAnalyzer(tradesAnalyzer)

# Run the strategy.
myStrategy.run()

print "Final portfolio value: $%.2f" % myStrategy.getResult()
print "Cumulative returns: %.2f %%" % (retAnalyzer.getCumulativeReturns()[-1] * 100)
print "Sharpe ratio: %.2f" % (sharpeRatioAnalyzer.getSharpeRatio(0.05))
print "Max. drawdown: %.2f %%" % (drawDownAnalyzer.getMaxDrawDown() * 100)
print "Longest drawdown duration: %s" % (drawDownAnalyzer.getLongestDrawDownDuration())

print
print "Total trades: %d" % (tradesAnalyzer.getCount())
if tradesAnalyzer.getCount() > 0:
    profits = tradesAnalyzer.getAll()
    print "Avg. profit: $%2.f" % (profits.mean())
    print "Profits std. dev.: $%2.f" % (profits.std())
    print "Max. profit: $%2.f" % (profits.max())
    print "Min. profit: $%2.f" % (profits.min())
    returns = tradesAnalyzer.getAllReturns()
    print "Avg. return: %2.f %%" % (returns.mean() * 100)
    print "Returns std. dev.: %2.f %%" % (returns.std() * 100)
    print "Max. return: %2.f %%" % (returns.max() * 100)
    print "Min. return: %2.f %%" % (returns.min() * 100)

print
print "Profitable trades: %d" % (tradesAnalyzer.getProfitableCount())
if tradesAnalyzer.getProfitableCount() > 0:
    profits = tradesAnalyzer.getProfits()
    print "Avg. profit: $%2.f" % (profits.mean())
    print "Profits std. dev.: $%2.f" % (profits.std())
    print "Max. profit: $%2.f" % (profits.max())
    print "Min. profit: $%2.f" % (profits.min())
    returns = tradesAnalyzer.getPositiveReturns()
    print "Avg. return: %2.f %%" % (returns.mean() * 100)
    print "Returns std. dev.: %2.f %%" % (returns.std() * 100)
    print "Max. return: %2.f %%" % (returns.max() * 100)
    print "Min. return: %2.f %%" % (returns.min() * 100)

print
print "Unprofitable trades: %d" % (tradesAnalyzer.getUnprofitableCount())
if tradesAnalyzer.getUnprofitableCount() > 0:
    losses = tradesAnalyzer.getLosses()
    print "Avg. loss: $%2.f" % (losses.mean())
    print "Losses std. dev.: $%2.f" % (losses.std())
    print "Max. loss: $%2.f" % (losses.min())
    print "Min. loss: $%2.f" % (losses.max())
    returns = tradesAnalyzer.getNegativeReturns()
    print "Avg. return: %2.f %%" % (returns.mean() * 100)
    print "Returns std. dev.: %2.f %%" % (returns.std() * 100)
    print "Max. return: %2.f %%" % (returns.max() * 100)
    print "Min. return: %2.f %%" % (returns.min() * 100)

########NEW FILE########
__FILENAME__ = sma_crossover
from pyalgotrade import strategy
from pyalgotrade.technical import ma
from pyalgotrade.technical import cross


class SMACrossOver(strategy.BacktestingStrategy):
    def __init__(self, feed, instrument, smaPeriod):
        strategy.BacktestingStrategy.__init__(self, feed)
        self.__instrument = instrument
        self.__position = None
        # We'll use adjusted close values instead of regular close values.
        self.setUseAdjustedValues(True)
        self.__prices = feed[instrument].getPriceDataSeries()
        self.__sma = ma.SMA(self.__prices, smaPeriod)

    def getSMA(self):
        return self.__sma

    def onEnterCanceled(self, position):
        self.__position = None

    def onExitOk(self, position):
        self.__position = None

    def onExitCanceled(self, position):
        # If the exit was canceled, re-submit it.
        self.__position.exitMarket()

    def onBars(self, bars):
        # If a position was not opened, check if we should enter a long position.
        if self.__position is None:
            if cross.cross_above(self.__prices, self.__sma) > 0:
                shares = int(self.getBroker().getCash() * 0.9 / bars[self.__instrument].getPrice())
                # Enter a buy market order. The order is good till canceled.
                self.__position = self.enterLong(self.__instrument, shares, True)
        # Check if we have to exit the position.
        elif not self.__position.exitActive() and cross.cross_below(self.__prices, self.__sma) > 0:
            self.__position.exitMarket()

########NEW FILE########
__FILENAME__ = sma_crossover_sample
import sma_crossover
from pyalgotrade import plotter
from pyalgotrade.tools import yahoofinance
from pyalgotrade.stratanalyzer import sharpe


def main(plot):
    instrument = "aapl"
    smaPeriod = 163

    # Download the bars.
    feed = yahoofinance.build_feed([instrument], 2011, 2012, ".")

    strat = sma_crossover.SMACrossOver(feed, instrument, smaPeriod)
    sharpeRatioAnalyzer = sharpe.SharpeRatio()
    strat.attachAnalyzer(sharpeRatioAnalyzer)

    if plot:
        plt = plotter.StrategyPlotter(strat, True, False, True)
        plt.getInstrumentSubplot(instrument).addDataSeries("sma", strat.getSMA())

    strat.run()
    print "Sharpe ratio: %.2f" % sharpeRatioAnalyzer.getSharpeRatio(0.05)

    if plot:
        plt.plot()


if __name__ == "__main__":
    main(True)

########NEW FILE########
__FILENAME__ = statarb_erniechan
from pyalgotrade import strategy
from pyalgotrade import dataseries
from pyalgotrade.dataseries import aligned
from pyalgotrade import plotter
from pyalgotrade.tools import yahoofinance
from pyalgotrade.stratanalyzer import sharpe

import numpy as np
import statsmodels.api as sm


def get_beta(values1, values2):
    # http://statsmodels.sourceforge.net/stable/regression.html
    model = sm.OLS(values1, values2)
    results = model.fit()
    return results.params[0]


class StatArbHelper:
    def __init__(self, ds1, ds2, windowSize):
        # We're going to use datetime aligned versions of the dataseries.
        self.__ds1, self.__ds2 = aligned.datetime_aligned(ds1, ds2)
        self.__windowSize = windowSize
        self.__hedgeRatio = None
        self.__spread = None
        self.__spreadMean = None
        self.__spreadStd = None
        self.__zScore = None

    def getSpread(self):
        return self.__spread

    def getSpreadMean(self):
        return self.__spreadMean

    def getSpreadStd(self):
        return self.__spreadStd

    def getZScore(self):
        return self.__zScore

    def getHedgeRatio(self):
        return self.__hedgeRatio

    def __updateHedgeRatio(self, values1, values2):
        self.__hedgeRatio = get_beta(values1, values2)

    def __updateSpreadMeanAndStd(self, values1, values2):
        if self.__hedgeRatio is not None:
            spread = values1 - values2 * self.__hedgeRatio
            self.__spreadMean = spread.mean()
            self.__spreadStd = spread.std(ddof=1)

    def __updateSpread(self):
        if self.__hedgeRatio is not None:
            self.__spread = self.__ds1[-1] - self.__hedgeRatio * self.__ds2[-1]

    def __updateZScore(self):
        if self.__spread is not None and self.__spreadMean is not None and self.__spreadStd is not None:
            self.__zScore = (self.__spread - self.__spreadMean) / float(self.__spreadStd)

    def update(self):
        if len(self.__ds1) >= self.__windowSize:
            values1 = np.asarray(self.__ds1[-1*self.__windowSize:])
            values2 = np.asarray(self.__ds2[-1*self.__windowSize:])
            self.__updateHedgeRatio(values1, values2)
            self.__updateSpread()
            self.__updateSpreadMeanAndStd(values1, values2)
            self.__updateZScore()


class StatArb(strategy.BacktestingStrategy):
    def __init__(self, feed, instrument1, instrument2, windowSize):
        strategy.BacktestingStrategy.__init__(self, feed)
        self.setUseAdjustedValues(True)
        self.__statArbHelper = StatArbHelper(feed[instrument1].getAdjCloseDataSeries(), feed[instrument2].getAdjCloseDataSeries(), windowSize)
        self.__i1 = instrument1
        self.__i2 = instrument2

        # These are used only for plotting purposes.
        self.__spread = dataseries.SequenceDataSeries()
        self.__hedgeRatio = dataseries.SequenceDataSeries()

    def getSpreadDS(self):
        return self.__spread

    def getHedgeRatioDS(self):
        return self.__hedgeRatio

    def __getOrderSize(self, bars, hedgeRatio):
        cash = self.getBroker().getCash(False)
        price1 = bars[self.__i1].getAdjClose()
        price2 = bars[self.__i2].getAdjClose()
        size1 = int(cash / (price1 + hedgeRatio * price2))
        size2 = int(size1 * hedgeRatio)
        return (size1, size2)

    def buySpread(self, bars, hedgeRatio):
        amount1, amount2 = self.__getOrderSize(bars, hedgeRatio)
        self.marketOrder(self.__i1, amount1)
        self.marketOrder(self.__i2, amount2 * -1)

    def sellSpread(self, bars, hedgeRatio):
        amount1, amount2 = self.__getOrderSize(bars, hedgeRatio)
        self.marketOrder(self.__i1, amount1 * -1)
        self.marketOrder(self.__i2, amount2)

    def reducePosition(self, instrument):
        currentPos = self.getBroker().getShares(instrument)
        if currentPos > 0:
            self.marketOrder(instrument, currentPos * -1)
        elif currentPos < 0:
            self.marketOrder(instrument, currentPos * -1)

    def onBars(self, bars):
        self.__statArbHelper.update()

        # These is used only for plotting purposes.
        self.__spread.appendWithDateTime(bars.getDateTime(), self.__statArbHelper.getSpread())
        self.__hedgeRatio.appendWithDateTime(bars.getDateTime(), self.__statArbHelper.getHedgeRatio())

        if bars.getBar(self.__i1) and bars.getBar(self.__i2):
            hedgeRatio = self.__statArbHelper.getHedgeRatio()
            zScore = self.__statArbHelper.getZScore()
            if zScore is not None:
                currentPos = abs(self.getBroker().getShares(self.__i1)) + abs(self.getBroker().getShares(self.__i2))
                if abs(zScore) <= 1 and currentPos != 0:
                    self.reducePosition(self.__i1)
                    self.reducePosition(self.__i2)
                elif zScore <= -2 and currentPos == 0:  # Buy spread when its value drops below 2 standard deviations.
                    self.buySpread(bars, hedgeRatio)
                elif zScore >= 2 and currentPos == 0:  # Short spread when its value rises above 2 standard deviations.
                    self.sellSpread(bars, hedgeRatio)


def main(plot):
    instruments = ["gld", "gdx"]
    windowSize = 50

    # Download the bars.
    feed = yahoofinance.build_feed(instruments, 2006, 2012, ".")

    strat = StatArb(feed, instruments[0], instruments[1], windowSize)
    sharpeRatioAnalyzer = sharpe.SharpeRatio()
    strat.attachAnalyzer(sharpeRatioAnalyzer)

    if plot:
        plt = plotter.StrategyPlotter(strat, False, False, True)
        plt.getOrCreateSubplot("hedge").addDataSeries("Hedge Ratio", strat.getHedgeRatioDS())
        plt.getOrCreateSubplot("spread").addDataSeries("Spread", strat.getSpreadDS())

    strat.run()
    print "Sharpe ratio: %.2f" % sharpeRatioAnalyzer.getSharpeRatio(0.05)

    if plot:
        plt.plot()


if __name__ == "__main__":
    main(True)

########NEW FILE########
__FILENAME__ = technical-1
from pyalgotrade import dataseries
from pyalgotrade import technical


# An EventWindow is responsible for making calculations using a window of values.
class Accumulator(technical.EventWindow):
    def getValue(self):
        ret = None
        if self.windowFull():
            ret = self.getValues().sum()
        return ret

# Build a sequence based DataSeries.
seqDS = dataseries.SequenceDataSeries()
# Wrap it with a filter that will get fed as new values get added to the underlying DataSeries.
accum = technical.EventBasedFilter(seqDS, Accumulator(3))

# Put in some values.
for i in range(0, 50):
    seqDS.append(i)

# Get some values.
print accum[0]  # Not enough values yet.
print accum[1]  # Not enough values yet.
print accum[2]  # Ok, now we should have at least 3 values.
print accum[3]

# Get the last value, which should be equal to 49 + 48 + 47.
print accum[-1]

########NEW FILE########
__FILENAME__ = tutorial-1
from pyalgotrade import strategy
from pyalgotrade.barfeed import yahoofeed


class MyStrategy(strategy.BacktestingStrategy):
    def __init__(self, feed, instrument):
        strategy.BacktestingStrategy.__init__(self, feed)
        self.__instrument = instrument

    def onBars(self, bars):
        bar = bars[self.__instrument]
        self.info(bar.getClose())

# Load the yahoo feed from the CSV file
feed = yahoofeed.Feed()
feed.addBarsFromCSV("orcl", "orcl-2000.csv")

# Evaluate the strategy with the feed's bars.
myStrategy = MyStrategy(feed, "orcl")
myStrategy.run()

########NEW FILE########
__FILENAME__ = tutorial-2
from pyalgotrade import strategy
from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.technical import ma


class MyStrategy(strategy.BacktestingStrategy):
    def __init__(self, feed, instrument):
        strategy.BacktestingStrategy.__init__(self, feed)
        # We want a 15 period SMA over the closing prices.
        self.__sma = ma.SMA(feed[instrument].getCloseDataSeries(), 15)
        self.__instrument = instrument

    def onBars(self, bars):
        bar = bars[self.__instrument]
        self.info("%s %s" % (bar.getClose(), self.__sma[-1]))

# Load the yahoo feed from the CSV file
feed = yahoofeed.Feed()
feed.addBarsFromCSV("orcl", "orcl-2000.csv")

# Evaluate the strategy with the feed's bars.
myStrategy = MyStrategy(feed, "orcl")
myStrategy.run()

########NEW FILE########
__FILENAME__ = tutorial-3
from pyalgotrade import strategy
from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.technical import ma
from pyalgotrade.technical import rsi


class MyStrategy(strategy.BacktestingStrategy):
    def __init__(self, feed, instrument):
        strategy.BacktestingStrategy.__init__(self, feed)
        self.__rsi = rsi.RSI(feed[instrument].getCloseDataSeries(), 14)
        self.__sma = ma.SMA(self.__rsi, 15)
        self.__instrument = instrument

    def onBars(self, bars):
        bar = bars[self.__instrument]
        self.info("%s %s %s" % (bar.getClose(), self.__rsi[-1], self.__sma[-1]))

# Load the yahoo feed from the CSV file
feed = yahoofeed.Feed()
feed.addBarsFromCSV("orcl", "orcl-2000.csv")

# Evaluate the strategy with the feed's bars.
myStrategy = MyStrategy(feed, "orcl")
myStrategy.run()

########NEW FILE########
__FILENAME__ = tutorial-4
from pyalgotrade import strategy
from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.technical import ma


class MyStrategy(strategy.BacktestingStrategy):
    def __init__(self, feed, instrument, smaPeriod):
        strategy.BacktestingStrategy.__init__(self, feed, 1000)
        self.__position = None
        self.__instrument = instrument
        # We'll use adjusted close values instead of regular close values.
        self.setUseAdjustedValues(True)
        self.__sma = ma.SMA(feed[instrument].getPriceDataSeries(), smaPeriod)

    def onEnterOk(self, position):
        execInfo = position.getEntryOrder().getExecutionInfo()
        self.info("BUY at $%.2f" % (execInfo.getPrice()))

    def onEnterCanceled(self, position):
        self.__position = None

    def onExitOk(self, position):
        execInfo = position.getExitOrder().getExecutionInfo()
        self.info("SELL at $%.2f" % (execInfo.getPrice()))
        self.__position = None

    def onExitCanceled(self, position):
        # If the exit was canceled, re-submit it.
        self.__position.exitMarket()

    def onBars(self, bars):
        # Wait for enough bars to be available to calculate a SMA.
        if self.__sma[-1] is None:
            return

        bar = bars[self.__instrument]
        # If a position was not opened, check if we should enter a long position.
        if self.__position is None:
            if bar.getPrice() > self.__sma[-1]:
                # Enter a buy market order for 10 shares. The order is good till canceled.
                self.__position = self.enterLong(self.__instrument, 10, True)
        # Check if we have to exit the position.
        elif bar.getPrice() < self.__sma[-1]:
            self.__position.exitMarket()


def run_strategy(smaPeriod):
    # Load the yahoo feed from the CSV file
    feed = yahoofeed.Feed()
    feed.addBarsFromCSV("orcl", "orcl-2000.csv")

    # Evaluate the strategy with the feed.
    myStrategy = MyStrategy(feed, "orcl", smaPeriod)
    myStrategy.run()
    print "Final portfolio value: $%.2f" % myStrategy.getBroker().getEquity()

run_strategy(15)

########NEW FILE########
__FILENAME__ = tutorial-5
from pyalgotrade import plotter
from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.stratanalyzer import returns
import sma_crossover

# Load the yahoo feed from the CSV file
feed = yahoofeed.Feed()
feed.addBarsFromCSV("orcl", "orcl-2000.csv")

# Evaluate the strategy with the feed's bars.
myStrategy = sma_crossover.SMACrossOver(feed, "orcl", 20)

# Attach a returns analyzers to the strategy.
returnsAnalyzer = returns.Returns()
myStrategy.attachAnalyzer(returnsAnalyzer)

# Attach the plotter to the strategy.
plt = plotter.StrategyPlotter(myStrategy)
# Include the SMA in the instrument's subplot to get it displayed along with the closing prices.
plt.getInstrumentSubplot("orcl").addDataSeries("SMA", myStrategy.getSMA())
# Plot the simple returns on each bar.
plt.getOrCreateSubplot("returns").addDataSeries("Simple returns", returnsAnalyzer.getReturns())

# Run the strategy.
myStrategy.run()
myStrategy.info("Final portfolio value: $%.2f" % myStrategy.getResult())

# Plot the strategy.
plt.plot()

########NEW FILE########
__FILENAME__ = tutorial-optimizer-local
import itertools
from pyalgotrade.optimizer import local
from pyalgotrade.barfeed import yahoofeed
import rsi2


def parameters_generator():
    instrument = ["dia"]
    entrySMA = range(150, 251)
    exitSMA = range(5, 16)
    rsiPeriod = range(2, 11)
    overBoughtThreshold = range(75, 96)
    overSoldThreshold = range(5, 26)
    return itertools.product(instrument, entrySMA, exitSMA, rsiPeriod, overBoughtThreshold, overSoldThreshold)


# The if __name__ == '__main__' part is necessary if running on Windows.
if __name__ == '__main__':
    # Load the feed from the CSV files.
    feed = yahoofeed.Feed()
    feed.addBarsFromCSV("dia", "dia-2009.csv")
    feed.addBarsFromCSV("dia", "dia-2010.csv")
    feed.addBarsFromCSV("dia", "dia-2011.csv")

    local.run(rsi2.RSI2, feed, parameters_generator())

########NEW FILE########
__FILENAME__ = tutorial-optimizer-server
import itertools
from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.optimizer import server


def parameters_generator():
    instrument = ["dia"]
    entrySMA = range(150, 251)
    exitSMA = range(5, 16)
    rsiPeriod = range(2, 11)
    overBoughtThreshold = range(75, 96)
    overSoldThreshold = range(5, 26)
    return itertools.product(instrument, entrySMA, exitSMA, rsiPeriod, overBoughtThreshold, overSoldThreshold)

# The if __name__ == '__main__' part is necessary if running on Windows.
if __name__ == '__main__':
    # Load the feed from the CSV files.
    feed = yahoofeed.Feed()
    feed.addBarsFromCSV("dia", "dia-2009.csv")
    feed.addBarsFromCSV("dia", "dia-2010.csv")
    feed.addBarsFromCSV("dia", "dia-2011.csv")

    # Run the server.
    server.serve(feed, parameters_generator(), "localhost", 5000)

########NEW FILE########
__FILENAME__ = tutorial-optimizer-worker
from pyalgotrade.optimizer import worker
import rsi2

# The if __name__ == '__main__' part is necessary if running on Windows.
if __name__ == '__main__':
    worker.run(rsi2.RSI2, "localhost", 5000, workerName="localworker")

########NEW FILE########
__FILENAME__ = tutorial_bitstamp_1
from pyalgotrade.bitstamp import client
from pyalgotrade.bitstamp import barfeed
from pyalgotrade.bitstamp import broker
from pyalgotrade import strategy
from pyalgotrade.technical import ma
from pyalgotrade.technical import cross


class Strategy(strategy.BaseStrategy):
    def __init__(self, cli, feed, brk):
        strategy.BaseStrategy.__init__(self, feed, brk)
        smaPeriod = 20
        self.__instrument = "BTC"
        self.__prices = feed[self.__instrument].getCloseDataSeries()
        self.__sma = ma.SMA(self.__prices, smaPeriod)
        self.__bid = None
        self.__ask = None
        self.__position = None
        self.__posSize = 0.05

        # Subscribe to order book update events to get bid/ask prices to trade.
        cli.getOrderBookUpdateEvent().subscribe(self.__onOrderBookUpdate)

    def __onOrderBookUpdate(self, orderBookUpdate):
        bid = orderBookUpdate.getBidPrices()[0]
        ask = orderBookUpdate.getAskPrices()[0]

        if bid != self.__bid or ask != self.__ask:
            self.__bid = bid
            self.__ask = ask
            self.info("Order book updated. Best bid: %s. Best ask: %s" % (self.__bid, self.__ask))

    def onEnterOk(self, position):
        self.info("Position opened at %s" % (position.getEntryOrder().getExecutionInfo().getPrice()))

    def onEnterCanceled(self, position):
        self.info("Position entry canceled")
        self.__position = None

    def onExitOk(self, position):
        self.__position = None
        self.info("Position closed at %s" % (position.getExitOrder().getExecutionInfo().getPrice()))

    def onExitCanceled(self, position):
        # If the exit was canceled, re-submit it.
        self.__position.exitLimit(self.__bid)

    def onBars(self, bars):
        bar = bars[self.__instrument]
        self.info("Price: %s. Volume: %s." % (bar.getClose(), bar.getVolume()))

        # Wait until we get the current bid/ask prices.
        if self.__ask is None:
            return

        # If a position was not opened, check if we should enter a long position.
        if self.__position is None:
            if cross.cross_above(self.__prices, self.__sma) > 0:
                self.info("Entry signal. Buy at %s" % (self.__ask))
                self.__position = self.enterLongLimit(self.__instrument, self.__ask, self.__posSize, True)
        # Check if we have to close the position.
        elif not self.__position.exitActive() and cross.cross_below(self.__prices, self.__sma) > 0:
            self.info("Exit signal. Sell at %s" % (self.__bid))
            self.__position.exitLimit(self.__bid)


def main():
    cli = client.Client()
    barFeed = barfeed.LiveTradeFeed(cli)
    brk = broker.PaperTradingBroker(1000, barFeed)
    strat = Strategy(cli, barFeed, brk)

    # It is VERY important to add the client to the event dispatch loop before running the strategy.
    strat.getDispatcher().addSubject(cli)
    strat.run()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = tutorial_twitter_bitstamp
from pyalgotrade import strategy
from pyalgotrade.bitstamp import client
from pyalgotrade.bitstamp import barfeed
from pyalgotrade.bitstamp import broker
from pyalgotrade.twitter import feed as twitterfeed


class Strategy(strategy.BaseStrategy):
    def __init__(self, cli, feed, brk, twitterFeed):
        strategy.BaseStrategy.__init__(self, feed, brk)
        self.__instrument = "BTC"

        # Subscribe to Twitter events.
        twitterFeed.subscribe(self.__onTweet)

    def __onTweet(self, data):
        # Refer to https://dev.twitter.com/docs/streaming-apis/messages#Public_stream_messages for
        # the information available in data.
        try:
            self.info("Twitter: %s" % (data["text"]))
        except KeyError:
            pass

    def onBars(self, bars):
        bar = bars[self.__instrument]
        self.info("Price: %s. Volume: %s." % (bar.getClose(), bar.getVolume()))


def main():
    # Go to http://dev.twitter.com and create an app.
    # The consumer key and secret will be generated for you after that.
    consumer_key = "<YOUR-CONSUMER-KEY-HERE>"
    consumer_secret = "<YOUR-CONSUMER-SECRET-HERE>"

    # After the step above, you will be redirected to your app's page.
    # Create an access token under the the "Your access token" section
    access_token = "<YOUR-ACCESS-TOKEN-HERE>"
    access_token_secret = "<YOUR-ACCESS-TOKEN-SECRET-HERE>"

    # Create a twitter feed to track BitCoin related events.
    track = ["bitcoin", "btc", "mtgox", "bitstamp", "xapo"]
    follow = []
    languages = ["en"]
    twitterFeed = twitterfeed.TwitterFeed(consumer_key, consumer_secret, access_token, access_token_secret, track, follow, languages)

    cli = client.Client()
    barFeed = barfeed.LiveTradeFeed(cli)
    brk = broker.PaperTradingBroker(1000, barFeed)
    strat = Strategy(cli, barFeed, brk, twitterFeed)

    # It is VERY important to add these to the event dispatch loop before running the strategy.
    strat.getDispatcher().addSubject(cli)
    strat.getDispatcher().addSubject(twitterFeed)

    strat.run()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = tutorial_xignite_1
from pyalgotrade import strategy
from pyalgotrade.bar import Frequency
from pyalgotrade.xignite import barfeed
from pyalgotrade.broker import backtesting
from pyalgotrade.technical import ma


class Strategy(strategy.BaseStrategy):
    def __init__(self, feed, brk):
        strategy.BaseStrategy.__init__(self, feed, brk)
        self.__sma = {}
        for instrument in feed.getRegisteredInstruments():
            self.__sma[instrument] = ma.SMA(feed[instrument].getCloseDataSeries(), 5)

    def onBars(self, bars):
        for instrument in bars.getInstruments():
            bar = bars[instrument]
            self.info("%s: Open: %s High: %s Low: %s Close: %s Volume: %s SMA: %s" % (instrument, bar.getOpen(), bar.getHigh(), bar.getLow(), bar.getClose(), bar.getVolume(), self.__sma[instrument][-1]))


def main():
    # Replace apiToken with your own API token.
    apiToken = "<YOUR API TOKEN HERE>"
    # indentifiers are fully qualified identifiers for the security and must include the exchange suffix.
    indentifiers = ["RIOl.CHIX", "HSBAl.CHIX"]
    # apiCallDelay is necessary because the bar may not be immediately available.
    apiCallDelay = 60

    feed = barfeed.LiveFeed(apiToken, indentifiers, Frequency.MINUTE*5, apiCallDelay)
    brk = backtesting.Broker(1000, feed)
    myStrategy = Strategy(feed, brk)
    myStrategy.run()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = vwap_momentum
from pyalgotrade import strategy
from pyalgotrade import plotter
from pyalgotrade.tools import yahoofinance
from pyalgotrade.technical import vwap
from pyalgotrade.stratanalyzer import sharpe


class VWAPMomentum(strategy.BacktestingStrategy):
    def __init__(self, feed, instrument, vwapWindowSize, threshold):
        strategy.BacktestingStrategy.__init__(self, feed)
        self.__instrument = instrument
        self.__vwap = vwap.VWAP(feed[instrument], vwapWindowSize)
        self.__threshold = threshold

    def getVWAP(self):
        return self.__vwap

    def onBars(self, bars):
        vwap = self.__vwap[-1]
        if vwap is None:
            return

        shares = self.getBroker().getShares(self.__instrument)
        price = bars[self.__instrument].getClose()
        notional = shares * price

        if price > vwap * (1 + self.__threshold) and notional < 1000000:
            self.marketOrder(self.__instrument, 100)
        elif price < vwap * (1 - self.__threshold) and notional > 0:
            self.marketOrder(self.__instrument, -100)


def main(plot):
    instrument = "aapl"
    vwapWindowSize = 5
    threshold = 0.01

    # Download the bars.
    feed = yahoofinance.build_feed([instrument], 2011, 2012, ".")

    strat = VWAPMomentum(feed, instrument, vwapWindowSize, threshold)
    sharpeRatioAnalyzer = sharpe.SharpeRatio()
    strat.attachAnalyzer(sharpeRatioAnalyzer)

    if plot:
        plt = plotter.StrategyPlotter(strat, True, False, True)
        plt.getInstrumentSubplot(instrument).addDataSeries("vwap", strat.getVWAP())

    strat.run()
    print "Sharpe ratio: %.2f" % sharpeRatioAnalyzer.getSharpeRatio(0.05)

    if plot:
        plt.plot()

if __name__ == "__main__":
    main(True)

########NEW FILE########
__FILENAME__ = barfeed_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime

from pyalgotrade import barfeed
from pyalgotrade import bar
from pyalgotrade import dispatcher


def check_base_barfeed(testCase, barFeed, barsHaveAdjClose, isRealTime):
    called = {"called": True}

    def callback(dateTime, bars):
        called["called"] = True
        testCase.assertEquals(barFeed.getCurrentDateTime(), dateTime)

    testCase.assertEquals(barFeed.getCurrentDateTime(), None)
    testCase.assertEquals(barFeed.barsHaveAdjClose(), barsHaveAdjClose)
    if not barsHaveAdjClose:
        with testCase.assertRaisesRegexp(Exception, "The barfeed doesn't support adjusted close values.*"):
            barFeed.setUseAdjustedValues(True)
    testCase.assertEquals(barFeed.isRealTime(), isRealTime)

    d = dispatcher.Dispatcher()
    d.addSubject(barFeed)
    barFeed.getNewValuesEvent().subscribe(callback)
    d.run()

    testCase.assertEquals(called["called"], True)


class OptimizerBarFeedestCase(unittest.TestCase):
    def testDateTimesNotInOrder(self):
        bars = [
            bar.Bars({"orcl": bar.BasicBar(datetime.datetime(2001, 1, 2), 1, 1, 1, 1, 1, 1, bar.Frequency.DAY)}),
            bar.Bars({"orcl": bar.BasicBar(datetime.datetime(2001, 1, 1), 1, 1, 1, 1, 1, 1, bar.Frequency.DAY)}),
        ]
        f = barfeed.OptimizerBarFeed(bar.Frequency.DAY, ["orcl"], bars)
        with self.assertRaisesRegexp(Exception, "Bar date times are not in order.*"):
            for dt, b in f:
                pass

    def testBaseBarFeed(self):
        bars = [
            bar.Bars({"orcl": bar.BasicBar(datetime.datetime(2001, 1, 1), 1, 1, 1, 1, 1, 1, bar.Frequency.DAY)}),
            bar.Bars({"orcl": bar.BasicBar(datetime.datetime(2001, 1, 2), 1, 1, 1, 1, 1, 1, bar.Frequency.DAY)}),
        ]
        barFeed = barfeed.OptimizerBarFeed(bar.Frequency.DAY, ["orcl"], bars)
        check_base_barfeed(self, barFeed, True, False)

    def testBaseBarFeedNoAdjClose(self):
        bars = [
            bar.Bars({"orcl": bar.BasicBar(datetime.datetime(2001, 1, 1), 1, 1, 1, 1, 1, None, bar.Frequency.DAY)}),
            bar.Bars({"orcl": bar.BasicBar(datetime.datetime(2001, 1, 2), 1, 1, 1, 1, 1, None, bar.Frequency.DAY)}),
        ]
        barFeed = barfeed.OptimizerBarFeed(bar.Frequency.DAY, ["orcl"], bars)
        check_base_barfeed(self, barFeed, False, False)

    def testEmtpy(self):
        barFeed = barfeed.OptimizerBarFeed(bar.Frequency.DAY, ["orcl"], [])
        self.assertEquals(barFeed.barsHaveAdjClose(), False)


########NEW FILE########
__FILENAME__ = bar_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime
import cPickle

from pyalgotrade import bar

class BasicBarTestCase(unittest.TestCase):
    def testInvalidConstruction(self):
        with self.assertRaises(Exception):
            bar.BasicBar(datetime.datetime.now(), 2, 1, 1, 1, 1, 1, bar.Frequency.DAY)
        with self.assertRaises(Exception):
            bar.BasicBar(datetime.datetime.now(), 1, 1, 1, 2, 1, 1, bar.Frequency.DAY)
        with self.assertRaises(Exception):
            bar.BasicBar(datetime.datetime.now(), 1, 2, 1.5, 1, 1, 1, bar.Frequency.DAY)
        with self.assertRaises(Exception):
            bar.BasicBar(datetime.datetime.now(), 2, 2, 1.5, 1, 1, 1, bar.Frequency.DAY)
        with self.assertRaises(Exception):
            bar.BasicBar(datetime.datetime.now(), 1, 1, 1.5, 1, 1, 1, bar.Frequency.DAY)

    def testTypicalPrice(self):
        b = bar.BasicBar(datetime.datetime.now(), 2, 3, 1, 2.1, 10, 5, bar.Frequency.DAY)
        self.assertEquals(b.getTypicalPrice(), (3 + 1 + 2.1) / 3)

    def testGetPrice(self):
        b = bar.BasicBar(datetime.datetime.now(), 2, 3, 1, 2.1, 10, 5, bar.Frequency.DAY)
        self.assertEquals(b.getPrice(), b.getClose())
        b.setUseAdjustedValue(True)
        self.assertEquals(b.getPrice(), b.getAdjClose())
        self.assertEquals(b.getOpen(True), b.getAdjOpen())
        self.assertEquals(b.getHigh(True), b.getAdjHigh())
        self.assertEquals(b.getLow(True), b.getAdjLow())

    def testPickle(self):
        b1 = bar.BasicBar(datetime.datetime.now(), 2, 3, 1, 2.1, 10, 5, bar.Frequency.DAY)
        b2 = cPickle.loads(cPickle.dumps(b1))
        self.assertEquals(b1.getDateTime(), b2.getDateTime())
        self.assertEquals(b1.getOpen(), b2.getOpen())
        self.assertEquals(b1.getHigh(), b2.getHigh())
        self.assertEquals(b1.getLow(), b2.getLow())
        self.assertEquals(b1.getClose(), b2.getClose())
        self.assertEquals(b1.getVolume(), b2.getVolume())
        self.assertEquals(b1.getAdjClose(), b2.getAdjClose())
        self.assertEquals(b1.getFrequency(), b2.getFrequency())
        self.assertEquals(b1.getPrice(), b2.getPrice())
        self.assertEquals(b1.getOpen(True), b2.getOpen(True))
        self.assertEquals(b1.getHigh(True), b2.getHigh(True))
        self.assertEquals(b1.getLow(True), b2.getLow(True))
        self.assertEquals(b1.getClose(True), b2.getClose(True))

    def testNoAdjClose(self):
        b = bar.BasicBar(datetime.datetime.now(), 2, 3, 1, 2.1, 10, None, bar.Frequency.DAY)
        with self.assertRaises(Exception):
            b.setUseAdjustedValue(True)
        with self.assertRaises(Exception):
            b.getOpen(True)
        with self.assertRaises(Exception):
            b.getHigh(True)
        with self.assertRaises(Exception):
            b.getLow(True)
        with self.assertRaises(Exception):
            b.getClose(True)

class BarsTestCase(unittest.TestCase):
    def testEmptyDict(self):
        with self.assertRaises(Exception):
            bar.Bars({})

    def testInvalidDateTimes(self):
        b1 = bar.BasicBar(datetime.datetime.now(), 2, 3, 1, 2.1, 10, 5, bar.Frequency.DAY)
        b2 = bar.BasicBar(datetime.datetime.now() + datetime.timedelta(days=1), 2, 3, 1, 2.1, 10, 5, bar.Frequency.DAY)
        with self.assertRaises(Exception):
            bar.Bars({"a": b1, "b": b2})

    def testBasic(self):
        dt = datetime.datetime.now()
        b1 = bar.BasicBar(dt, 1, 1, 1, 1, 10, 1, bar.Frequency.DAY)
        b2 = bar.BasicBar(dt, 2, 2, 2, 2, 10, 2, bar.Frequency.DAY)
        bars = bar.Bars({"a": b1, "b": b2})
        self.assertEquals(bars["a"].getClose(), 1)
        self.assertEquals(bars["b"].getClose(), 2)
        self.assertTrue("a" in bars)
        self.assertEquals(bars.items(), [("a", b1), ("b", b2)])
        self.assertEquals(bars.keys(), ["a", "b"])
        self.assertEquals(bars.getInstruments(), ["a", "b"])
        self.assertEquals(bars.getDateTime(), dt)
        self.assertEquals(bars.getBar("a").getClose(), 1)

########NEW FILE########
__FILENAME__ = bitstamp_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime
import json

from pyalgotrade import broker as basebroker
from pyalgotrade.bitstamp import barfeed
from pyalgotrade.bitstamp import broker
from pyalgotrade.bitstamp import wsclient
from pyalgotrade import observer
from pyalgotrade import strategy


class MockClient(observer.Subject):
    def __init__(self):
        self.__tradeEvent = observer.Event()
        self.__orderBookUpdateEvent = observer.Event()
        self.__events = []

    # This may raise.
    def start(self):
        pass

    # This should not raise.
    def stop(self):
        pass

    # This should not raise.
    def join(self):
        pass

    # Return True if there are not more events to dispatch.
    def eof(self):
        return len(self.__events) == 0

    # Dispatch events. If True is returned, it means that at least one event was dispatched.
    def dispatch(self):
        if len(self.__events):
            event = self.__events.pop(0)
            if isinstance(event, wsclient.Trade):
                self.__tradeEvent.emit(event)
            elif isinstance(event, wsclient.OrderBookUpdate):
                self.__orderBookUpdateEvent.emit(event)
            else:
                assert(False)

    def peekDateTime(self):
        # Return None since this is a realtime subject.
        return None

    def getTradeEvent(self):
        return self.__tradeEvent

    def getOrderBookUpdateEvent(self):
        return self.__orderBookUpdateEvent

    def addTrade(self, dateTime, tid, price, amount):
        dataDict = {
            "id": tid,
            "price": price,
            "amount": amount
            }
        eventDict = {}
        eventDict["data"] = json.dumps(dataDict)
        self.__events.append(wsclient.Trade(dateTime, eventDict))


class TestStrategy(strategy.BaseStrategy):
    def __init__(self, cli, feed, brk):
        strategy.BaseStrategy.__init__(self, feed, brk)
        self.bid = None
        self.ask = None
        self.posExecutionInfo = []

        # Subscribe to order book update events to get bid/ask prices to trade.
        cli.getOrderBookUpdateEvent().subscribe(self.__onOrderBookUpdate)

    def __onOrderBookUpdate(self, orderBookUpdate):
        bid = orderBookUpdate.getBidPrices()[0]
        ask = orderBookUpdate.getAskPrices()[0]

        if bid != self.bid or ask != self.ask:
            self.bid = bid
            self.ask = ask

    def onEnterOk(self, position):
        self.posExecutionInfo.append(position.getEntryOrder().getExecutionInfo())

    def onEnterCanceled(self, position):
        self.posExecutionInfo.append(position.getEntryOrder().getExecutionInfo())

    def onExitOk(self, position):
        self.posExecutionInfo.append(position.getExitOrder().getExecutionInfo())

    def onExitCanceled(self, position):
        self.posExecutionInfo.append(position.getExitOrder().getExecutionInfo())


class TestCase(unittest.TestCase):
    def testInstrumentTraits(self):
        traits = broker.BTCTraits()
        self.assertEqual(traits.roundQuantity(0), 0)
        self.assertEqual(traits.roundQuantity(1), 1)
        self.assertEqual(traits.roundQuantity(1.1 + 1.1 + 1.1), 3.3)
        self.assertEqual(traits.roundQuantity(1.1 + 1.1 + 1.1 - 3.3), 0)
        self.assertEqual(traits.roundQuantity(0.00441376), 0.00441376)
        self.assertEqual(traits.roundQuantity(0.004413764), 0.00441376)

    def testBuyWithPartialFill(self):

        class Strategy(TestStrategy):
            def __init__(self, cli, feed, brk):
                TestStrategy.__init__(self, cli, feed, brk)
                self.pos = None

            def onBars(self, bars):
                if self.pos is None:
                    self.pos = self.enterLongLimit("BTC", 100, 1, True)

        cli = MockClient()
        cli.addTrade(datetime.datetime(2000, 1, 1), 1, 100, 0.1)
        cli.addTrade(datetime.datetime(2000, 1, 2), 1, 100, 0.1)
        cli.addTrade(datetime.datetime(2000, 1, 2), 1, 101, 10)
        cli.addTrade(datetime.datetime(2000, 1, 3), 1, 100, 0.2)

        barFeed = barfeed.LiveTradeFeed(cli)
        brk = broker.PaperTradingBroker(1000, barFeed)
        strat = Strategy(cli, barFeed, brk)

        strat.getDispatcher().addSubject(cli)
        strat.run()

        self.assertTrue(strat.pos.isOpen())
        self.assertEqual(round(strat.pos.getShares(), 3), 0.3)
        self.assertEqual(len(strat.posExecutionInfo), 1)
        self.assertEqual(strat.pos.getEntryOrder().getSubmitDateTime().date(), wsclient.get_current_datetime().date())

    def testBuyAndSellWithPartialFill1(self):

        class Strategy(TestStrategy):
            def __init__(self, cli, feed, brk):
                TestStrategy.__init__(self, cli, feed, brk)
                self.pos = None

            def onBars(self, bars):
                if self.pos is None:
                    self.pos = self.enterLongLimit("BTC", 100, 1, True)
                elif bars.getDateTime() == datetime.datetime(2000, 1, 3):
                    self.pos.exit(limitPrice=101)

        cli = MockClient()
        cli.addTrade(datetime.datetime(2000, 1, 1), 1, 100, 0.1)
        cli.addTrade(datetime.datetime(2000, 1, 2), 1, 100, 0.1)
        cli.addTrade(datetime.datetime(2000, 1, 2), 1, 101, 10)
        cli.addTrade(datetime.datetime(2000, 1, 3), 1, 100, 0.2)
        cli.addTrade(datetime.datetime(2000, 1, 4), 1, 100, 0.2)
        cli.addTrade(datetime.datetime(2000, 1, 5), 1, 101, 0.2)

        barFeed = barfeed.LiveTradeFeed(cli)
        brk = broker.PaperTradingBroker(1000, barFeed)
        strat = Strategy(cli, barFeed, brk)

        strat.getDispatcher().addSubject(cli)
        strat.run()

        self.assertTrue(strat.pos.isOpen())
        self.assertEqual(round(strat.pos.getShares(), 3), 0.1)
        self.assertEqual(len(strat.posExecutionInfo), 1)
        self.assertEqual(strat.pos.getEntryOrder().getSubmitDateTime().date(), wsclient.get_current_datetime().date())
        self.assertEqual(strat.pos.getExitOrder().getSubmitDateTime().date(), wsclient.get_current_datetime().date())

    def testBuyAndSellWithPartialFill2(self):

        class Strategy(TestStrategy):
            def __init__(self, cli, feed, brk):
                TestStrategy.__init__(self, cli, feed, brk)
                self.pos = None

            def onBars(self, bars):
                if self.pos is None:
                    self.pos = self.enterLongLimit("BTC", 100, 1, True)
                elif bars.getDateTime() == datetime.datetime(2000, 1, 3):
                    self.pos.exit(limitPrice=101)

        cli = MockClient()
        cli.addTrade(datetime.datetime(2000, 1, 1), 1, 100, 0.1)
        cli.addTrade(datetime.datetime(2000, 1, 2), 1, 100, 0.1)
        cli.addTrade(datetime.datetime(2000, 1, 2), 1, 101, 10)
        cli.addTrade(datetime.datetime(2000, 1, 3), 1, 100, 0.2)
        cli.addTrade(datetime.datetime(2000, 1, 4), 1, 100, 0.2)
        cli.addTrade(datetime.datetime(2000, 1, 5), 1, 101, 0.2)
        cli.addTrade(datetime.datetime(2000, 1, 6), 1, 102, 5)

        barFeed = barfeed.LiveTradeFeed(cli)
        brk = broker.PaperTradingBroker(1000, barFeed)
        strat = Strategy(cli, barFeed, brk)

        strat.getDispatcher().addSubject(cli)
        strat.run()

        self.assertFalse(strat.pos.isOpen())
        self.assertEqual(strat.pos.getShares(), 0)
        self.assertEqual(len(strat.posExecutionInfo), 2)
        self.assertEqual(strat.pos.getEntryOrder().getSubmitDateTime().date(), wsclient.get_current_datetime().date())
        self.assertEqual(strat.pos.getExitOrder().getSubmitDateTime().date(), wsclient.get_current_datetime().date())

    def testRoundingBugWithTrades(self):
        # Unless proper rounding is in place 0.01 - 0.00441376 - 0.00445547 - 0.00113077 == 6.50521303491e-19
        # instead of 0.

        class Strategy(TestStrategy):
            def __init__(self, cli, feed, brk):
                TestStrategy.__init__(self, cli, feed, brk)
                self.pos = None

            def onBars(self, bars):
                if self.pos is None:
                    self.pos = self.enterLongLimit("BTC", 100, 0.01, True)
                elif self.pos.entryFilled() and not self.pos.getExitOrder():
                    self.pos.exitLimit(100, True)

        cli = MockClient()
        cli.addTrade(datetime.datetime(2000, 1, 1), 1, 100, 1)
        cli.addTrade(datetime.datetime(2000, 1, 2), 1, 100, 0.01)
        cli.addTrade(datetime.datetime(2000, 1, 3), 1, 100, 0.00441376)
        cli.addTrade(datetime.datetime(2000, 1, 4), 1, 100, 0.00445547)
        cli.addTrade(datetime.datetime(2000, 1, 5), 1, 100, 0.00113077)

        barFeed = barfeed.LiveTradeFeed(cli)
        brk = broker.PaperTradingBroker(1000, barFeed)
        strat = Strategy(cli, barFeed, brk)

        strat.getDispatcher().addSubject(cli)
        strat.run()

        self.assertEqual(brk.getShares("BTC"), 0)
        self.assertEqual(strat.pos.getEntryOrder().getAvgFillPrice(), 100)
        self.assertEqual(strat.pos.getExitOrder().getAvgFillPrice(), 100)
        self.assertEqual(strat.pos.getEntryOrder().getFilled(), 0.01)
        self.assertEqual(strat.pos.getExitOrder().getFilled(), 0.01)
        self.assertEqual(strat.pos.getEntryOrder().getRemaining(), 0)
        self.assertEqual(strat.pos.getExitOrder().getRemaining(), 0)
        self.assertEqual(strat.pos.getEntryOrder().getSubmitDateTime().date(), wsclient.get_current_datetime().date())
        self.assertEqual(strat.pos.getExitOrder().getSubmitDateTime().date(), wsclient.get_current_datetime().date())

        self.assertFalse(strat.pos.isOpen())
        self.assertEqual(len(strat.posExecutionInfo), 2)
        self.assertEqual(strat.pos.getShares(), 0.0)

    def testInvalidOrders(self):
        cli = MockClient()
        barFeed = barfeed.LiveTradeFeed(cli)
        brk = broker.PaperTradingBroker(1000, barFeed)
        with self.assertRaises(Exception):
            brk.createLimitOrder(basebroker.Order.Action.BUY, "none", 1, 1)
        with self.assertRaises(Exception):
            brk.createLimitOrder(basebroker.Order.Action.SELL_SHORT, "none", 1, 1)
        with self.assertRaises(Exception):
            brk.createMarketOrder(basebroker.Order.Action.BUY, "none", 1)
        with self.assertRaises(Exception):
            brk.createStopOrder(basebroker.Order.Action.BUY, "none", 1, 1)
        with self.assertRaises(Exception):
            brk.createStopLimitOrder(basebroker.Order.Action.BUY, "none", 1, 1, 1)

########NEW FILE########
__FILENAME__ = broker_backtesting_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime

from pyalgotrade import broker
from pyalgotrade.broker import backtesting
from pyalgotrade import bar
from pyalgotrade import barfeed


class OrderUpdateCallback:
    def __init__(self, broker_):
        self.eventCount = 0
        self.events = []
        broker_.getOrderUpdatedEvent().subscribe(self.onOrderEvent)

    def onOrderEvent(self, broker_, orderEvent):
        self.eventCount += 1
        self.events.append(orderEvent)


class BarsBuilder(object):
    def __init__(self, instrument, frequency):
        self.__instrument = instrument
        self.__frequency = frequency
        self.__nextDateTime = datetime.datetime(2011, 1, 1)
        if frequency == bar.Frequency.TRADE:
            self.__delta = datetime.timedelta(milliseconds=1)
        elif frequency == bar.Frequency.SECOND:
            self.__delta = datetime.timedelta(seconds=1)
        elif frequency == bar.Frequency.MINUTE:
            self.__delta = datetime.timedelta(minutes=1)
        elif frequency == bar.Frequency.HOUR:
            self.__delta = datetime.timedelta(hours=1)
        elif frequency == bar.Frequency.DAY:
            self.__delta = datetime.timedelta(days=1)
        else:
            raise Exception("Invalid frequency")

    def getCurrentDateTime(self):
        return self.__nextDateTime

    def advance(self, sessionClose):
        if sessionClose:
            self.__nextDateTime = datetime.datetime(self.__nextDateTime.year, self.__nextDateTime.month, self.__nextDateTime.day)
            self.__nextDateTime += datetime.timedelta(days=1)
        else:
            self.__nextDateTime += self.__delta

    # sessionClose is True if the next bars should start at a different date.
    def nextBars(self, openPrice, highPrice, lowPrice, closePrice, volume=None, sessionClose=False):
        if volume is None:
            volume = closePrice*10
        bar_ = bar.BasicBar(self.__nextDateTime, openPrice, highPrice, lowPrice, closePrice, volume, closePrice, self.__frequency)
        ret = {self.__instrument: bar_}
        self.advance(sessionClose)
        return bar.Bars(ret)

    # sessionClose is True if the next bars should start at a different date.
    def nextTuple(self, openPrice, highPrice, lowPrice, closePrice, volume=None, sessionClose=False):
        ret = self.nextBars(openPrice, highPrice, lowPrice, closePrice, volume, sessionClose)
        return (ret.getDateTime(), ret)


class DecimalTraits(broker.InstrumentTraits):
    def __init__(self, decimals):
        self.__decimals = decimals

    def roundQuantity(self, quantity):
        return round(quantity, self.__decimals)


class BarFeed(barfeed.BaseBarFeed):
    def __init__(self, instrument, frequency):
        barfeed.BaseBarFeed.__init__(self, frequency)
        self.__builder = BarsBuilder(instrument, frequency)
        self.__nextBars = None

    def getCurrentDateTime(self):
        return self.__builder.getCurrentDateTime()

    def start(self):
        raise NotImplementedError()

    def stop(self):
        raise NotImplementedError()

    def join(self):
        raise NotImplementedError()

    def eof(self):
        raise NotImplementedError()

    def peekDateTime(self):
        raise NotImplementedError()

    def isRealTime(self):
        raise NotImplementedError()

    def dispatchBars(self, openPrice, highPrice, lowPrice, closePrice, volume=None, sessionClose=False):
        self.__nextBars = self.__builder.nextBars(openPrice, highPrice, lowPrice, closePrice, volume, sessionClose)
        self.dispatch()

    def barsHaveAdjClose(self):
        raise True

    def getNextBars(self):
        return self.__nextBars


class BaseTestCase(unittest.TestCase):
    TestInstrument = "orcl"

    def buildBroker(self, *args, **kwargs):
        return backtesting.Broker(*args, **kwargs)

    def buildBarFeed(self, *args, **kwargs):
        return BarFeed(*args, **kwargs)


class CommissionTestCase(unittest.TestCase):
    def testNoCommission(self):
        comm = backtesting.NoCommission()
        self.assertEqual(comm.calculate(None, 1, 1), 0)

    def testFixedPerTrade(self):
        comm = backtesting.FixedPerTrade(1.2)
        order = backtesting.MarketOrder(1, broker.Order.Action.BUY, "orcl", 1, False, backtesting.DefaultTraits())
        self.assertEqual(comm.calculate(order, 1, 1), 1.2)

    def testTradePercentage(self):
        comm = backtesting.TradePercentage(0.1)
        self.assertEqual(comm.calculate(None, 1, 1), 0.1)
        self.assertEqual(comm.calculate(None, 2, 2), 0.4)


class BrokerTestCase(BaseTestCase):
    def testStopOrderTriggerBuy(self):
        barsBuilder = BarsBuilder(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        # Bar is below
        self.assertEqual(backtesting.get_stop_price_trigger(broker.Order.Action.BUY, 10, False, barsBuilder.nextBars(5, 5, 5, 5)[BaseTestCase.TestInstrument]), None)
        self.assertEqual(backtesting.get_stop_price_trigger(broker.Order.Action.BUY, 10, False, barsBuilder.nextBars(5, 6, 4, 5)[BaseTestCase.TestInstrument]), None)
        # High touches
        self.assertEqual(backtesting.get_stop_price_trigger(broker.Order.Action.BUY, 10, False, barsBuilder.nextBars(5, 10, 4, 9)[BaseTestCase.TestInstrument]), 10)
        # High penetrates
        self.assertEqual(backtesting.get_stop_price_trigger(broker.Order.Action.BUY, 10, False, barsBuilder.nextBars(5, 11, 4, 9)[BaseTestCase.TestInstrument]), 10)
        # Open touches
        self.assertEqual(backtesting.get_stop_price_trigger(broker.Order.Action.BUY, 10, False, barsBuilder.nextBars(10, 10, 10, 10)[BaseTestCase.TestInstrument]), 10)
        # Open is above
        self.assertEqual(backtesting.get_stop_price_trigger(broker.Order.Action.BUY, 10, False, barsBuilder.nextBars(11, 12, 4, 9)[BaseTestCase.TestInstrument]), 11)
        # Bar gaps above
        self.assertEqual(backtesting.get_stop_price_trigger(broker.Order.Action.BUY, 10, False, barsBuilder.nextBars(12, 13, 11, 12)[BaseTestCase.TestInstrument]), 12)

    def testStopOrderTriggerSell(self):
        barsBuilder = BarsBuilder(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        # Bar is above
        self.assertEqual(backtesting.get_stop_price_trigger(broker.Order.Action.SELL, 10, False, barsBuilder.nextBars(15, 15, 15, 15)[BaseTestCase.TestInstrument]), None)
        self.assertEqual(backtesting.get_stop_price_trigger(broker.Order.Action.SELL, 10, False, barsBuilder.nextBars(15, 16, 11, 15)[BaseTestCase.TestInstrument]), None)
        # Low touches
        self.assertEqual(backtesting.get_stop_price_trigger(broker.Order.Action.SELL, 10, False, barsBuilder.nextBars(15, 16, 10, 11)[BaseTestCase.TestInstrument]), 10)
        # Low penetrates
        self.assertEqual(backtesting.get_stop_price_trigger(broker.Order.Action.SELL, 10, False, barsBuilder.nextBars(15, 16, 9, 11)[BaseTestCase.TestInstrument]), 10)
        # Open touches
        self.assertEqual(backtesting.get_stop_price_trigger(broker.Order.Action.SELL, 10, False, barsBuilder.nextBars(10, 10, 10, 10)[BaseTestCase.TestInstrument]), 10)
        # Open is below
        self.assertEqual(backtesting.get_stop_price_trigger(broker.Order.Action.SELL, 10, False, barsBuilder.nextBars(9, 12, 4, 9)[BaseTestCase.TestInstrument]), 9)
        # Bar gaps below
        self.assertEqual(backtesting.get_stop_price_trigger(broker.Order.Action.SELL, 10, False, barsBuilder.nextBars(8, 9, 6, 9)[BaseTestCase.TestInstrument]), 8)

    def testLimitOrderTriggerBuy(self):
        barsBuilder = BarsBuilder(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        # Bar is above
        self.assertEqual(backtesting.get_limit_price_trigger(broker.Order.Action.BUY, 10, False, barsBuilder.nextBars(15, 15, 15, 15)[BaseTestCase.TestInstrument]), None)
        self.assertEqual(backtesting.get_limit_price_trigger(broker.Order.Action.BUY, 10, False, barsBuilder.nextBars(15, 16, 11, 15)[BaseTestCase.TestInstrument]), None)
        # Low touches
        self.assertEqual(backtesting.get_limit_price_trigger(broker.Order.Action.BUY, 10, False, barsBuilder.nextBars(15, 16, 10, 11)[BaseTestCase.TestInstrument]), 10)
        # Low penetrates
        self.assertEqual(backtesting.get_limit_price_trigger(broker.Order.Action.BUY, 10, False, barsBuilder.nextBars(15, 16, 9, 11)[BaseTestCase.TestInstrument]), 10)
        # Open touches
        self.assertEqual(backtesting.get_limit_price_trigger(broker.Order.Action.BUY, 10, False, barsBuilder.nextBars(10, 10, 10, 10)[BaseTestCase.TestInstrument]), 10)
        # Open is below
        self.assertEqual(backtesting.get_limit_price_trigger(broker.Order.Action.BUY, 10, False, barsBuilder.nextBars(9, 12, 4, 9)[BaseTestCase.TestInstrument]), 9)
        # Bar gaps below
        self.assertEqual(backtesting.get_limit_price_trigger(broker.Order.Action.BUY, 10, False, barsBuilder.nextBars(8, 9, 6, 9)[BaseTestCase.TestInstrument]), 8)

    def testLimitOrderTriggerSell(self):
        barsBuilder = BarsBuilder(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        # Bar is below
        self.assertEqual(backtesting.get_limit_price_trigger(broker.Order.Action.SELL, 10, False, barsBuilder.nextBars(5, 5, 5, 5)[BaseTestCase.TestInstrument]), None)
        self.assertEqual(backtesting.get_limit_price_trigger(broker.Order.Action.SELL, 10, False, barsBuilder.nextBars(5, 6, 4, 5)[BaseTestCase.TestInstrument]), None)
        # High touches
        self.assertEqual(backtesting.get_limit_price_trigger(broker.Order.Action.SELL, 10, False, barsBuilder.nextBars(5, 10, 4, 9)[BaseTestCase.TestInstrument]), 10)
        # High penetrates
        self.assertEqual(backtesting.get_limit_price_trigger(broker.Order.Action.SELL, 10, False, barsBuilder.nextBars(5, 11, 4, 9)[BaseTestCase.TestInstrument]), 10)
        # Open touches
        self.assertEqual(backtesting.get_limit_price_trigger(broker.Order.Action.SELL, 10, False, barsBuilder.nextBars(10, 10, 10, 10)[BaseTestCase.TestInstrument]), 10)
        # Open is above
        self.assertEqual(backtesting.get_limit_price_trigger(broker.Order.Action.SELL, 10, False, barsBuilder.nextBars(11, 12, 4, 9)[BaseTestCase.TestInstrument]), 11)
        # Bar gaps above
        self.assertEqual(backtesting.get_limit_price_trigger(broker.Order.Action.SELL, 10, False, barsBuilder.nextBars(12, 13, 11, 12)[BaseTestCase.TestInstrument]), 12)

    def testOneCancelsAnother(self):
        orders = {}

        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        def onOrderEvent(broker_, orderEvent):
            if orderEvent.getEventType() == broker.OrderEvent.Type.FILLED and orderEvent.getOrder().getId() == orders["sell"].getId():
                brk.cancelOrder(orders["stoploss"])

        # Buy order.
        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())

        barFeed.dispatchBars(10, 15, 8, 12)
        self.assertTrue(order.isFilled())

        brk.getOrderUpdatedEvent().subscribe(onOrderEvent)

        # Create a sell limit and a stop loss order.
        order = brk.createLimitOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 11, 1)
        orders["sell"] = order
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        order = brk.createStopOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 8, 1)
        orders["stoploss"] = order
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(10, 15, 5, 12)

        # Only one order (the sell limit order) should have got filled. The other one should be canceled.
        self.assertEqual(brk.getShares(BaseTestCase.TestInstrument), 0)
        self.assertTrue(orders["sell"].isFilled())
        self.assertTrue(orders["stoploss"].isCanceled())

    def testRegressionGetActiveOrders(self):
        activeOrders = []

        def onOrderEvent(broker, orderEvent):
            activeOrders.append(len(broker.getActiveOrders()))

        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        brk.getOrderUpdatedEvent().subscribe(onOrderEvent)
        o1 = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)
        self.assertEquals(o1.getSubmitDateTime(), None)
        brk.placeOrder(o1)
        self.assertEquals(o1.getSubmitDateTime(), barFeed.getCurrentDateTime())
        o2 = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)
        self.assertEquals(o2.getSubmitDateTime(), None)
        brk.placeOrder(o2)
        self.assertEquals(o2.getSubmitDateTime(), barFeed.getCurrentDateTime())

        self.assertEqual(o1.getFilled(), 0)
        self.assertEqual(o2.getFilled(), 0)
        self.assertEqual(o1.getRemaining(), o1.getQuantity())
        self.assertEqual(o2.getRemaining(), o2.getQuantity())

        barFeed.dispatchBars(10, 15, 8, 12)

        self.assertNotEquals(o1.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertNotEquals(o2.getSubmitDateTime(), barFeed.getCurrentDateTime())

        self.assertEqual(o1.getFilled(), 1)
        self.assertEqual(o2.getFilled(), 1)
        self.assertEqual(o1.getRemaining(), 0)
        self.assertEqual(o2.getRemaining(), 0)
        self.assertEqual(brk.getCash(), 1000 - 10*2)
        self.assertEqual(len(activeOrders), 4)
        self.assertEqual(activeOrders[0], 2)  # First order gets accepted, both orders are active.
        self.assertEqual(activeOrders[1], 1)  # First order gets filled, one order is active.
        self.assertEqual(activeOrders[2], 1)  # Second order gets accepted, one order is active.
        self.assertEqual(activeOrders[3], 0)  # Second order gets filled, zero orders are active.

    def testVolumeLimitMinuteBars(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 3)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 3)

        # The order should not get filled if there is not enough volume.
        barFeed.dispatchBars(10, 15, 8, 12, volume=3)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 3)

        # The order should now get filled since there is enough volume.
        barFeed.dispatchBars(10, 15, 8, 12, volume=12)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 3)
        self.assertEqual(order.getRemaining(), 0)

    def testVolumeLimitTradeBars(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.TRADE)
        brk = self.buildBroker(1000, barFeed)

        # Try with different order types.
        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 3)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 3)

        # The order should get partially filled.
        barFeed.dispatchBars(10, 15, 8, 12, volume=1)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 2)

        # The order should now get completely filled.
        barFeed.dispatchBars(10, 15, 8, 12, volume=3)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 3)
        self.assertEqual(order.getRemaining(), 0)

    def testCancelationEvent(self):
        orderStates = []

        def onOrderEvent(broker, orderEvent):
            orderStates.append(order.getState())

        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)
        brk.getOrderUpdatedEvent().subscribe(onOrderEvent)

        order = brk.createLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 2, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())

        barFeed.dispatchBars(10, 15, 8, 12)
        # Check that cancelation event gets emited right away.
        brk.cancelOrder(order)
        self.assertTrue(broker.Order.State.CANCELED in orderStates)

    def testSkipOrderSubmittedDuringEvent(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)
        ordersUpdated = []

        def onOrderEvent(broker_, orderEvent):
            ordersUpdated.append(orderEvent.getOrder())
            newOrder = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)
            self.assertEquals(newOrder.getSubmitDateTime(), None)
            brk.placeOrder(newOrder)
            self.assertEquals(newOrder.getSubmitDateTime(), barFeed.getCurrentDateTime())

        brk.getOrderUpdatedEvent().subscribe(onOrderEvent)

        firstOrder = brk.createLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 2, 1)
        self.assertEquals(firstOrder.getSubmitDateTime(), None)
        brk.placeOrder(firstOrder)
        self.assertEquals(firstOrder.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEquals(len(ordersUpdated), 0)

        barFeed.dispatchBars(10, 15, 8, 12)
        self.assertEquals(len(ordersUpdated), 1)  # First order got accepted.
        self.assertTrue(firstOrder in ordersUpdated)
        self.assertEquals(len(brk.getActiveOrders()), 2)  # Both orders are active.
        # Check that the first one was accepted, and the second one submitted.
        for activeOrder in brk.getActiveOrders():
            if activeOrder.getId() == firstOrder.getId():
                self.assertTrue(activeOrder.isAccepted())
            else:
                self.assertTrue(activeOrder.isSubmitted())

        # Second order should get accepted and filled.
        barFeed.dispatchBars(10, 15, 8, 12)
        self.assertEquals(len(ordersUpdated), 3)
        self.assertTrue(firstOrder.isAccepted())

    def testPartialFillAndCancel(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.DAY)
        brk = self.buildBroker(1000, barFeed)
        cb = OrderUpdateCallback(brk)

        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())

        # 2 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 10)
        self.assertTrue(order.isCanceled())
        self.assertEqual(order.getFilled(), 2)
        self.assertEqual(order.getRemaining(), 8)
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        self.assertEqual(len(cb.events), 3)
        self.assertEqual(cb.events[0].getEventType(), broker.OrderEvent.Type.ACCEPTED)
        self.assertEqual(cb.events[1].getEventType(), broker.OrderEvent.Type.PARTIALLY_FILLED)
        self.assertEqual(cb.events[2].getEventType(), broker.OrderEvent.Type.CANCELED)

    def testVolumeLimitPerBar1(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        order1 = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 2)
        self.assertEquals(order1.getSubmitDateTime(), None)
        brk.placeOrder(order1)
        self.assertEquals(order1.getSubmitDateTime(), barFeed.getCurrentDateTime())
        order2 = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 2)
        self.assertEquals(order2.getSubmitDateTime(), None)
        brk.placeOrder(order2)
        self.assertEquals(order2.getSubmitDateTime(), barFeed.getCurrentDateTime())

        barFeed.dispatchBars(12, 15, 8, 12, 10)
        # 2 should get filled for the first order.
        self.assertTrue(order1.isFilled())
        self.assertEqual(order1.getFilled(), 2)
        self.assertEqual(order1.getRemaining(), 0)
        self.assertEqual(order1.getAvgFillPrice(), 12)
        self.assertEqual(order1.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order1.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order1.getExecutionInfo().getCommission(), 0)
        # 0 should get filled for the second order.
        self.assertTrue(order2.isAccepted())
        self.assertEqual(order2.getFilled(), 0)
        self.assertEqual(order2.getRemaining(), 2)
        self.assertEqual(order2.getAvgFillPrice(), None)
        self.assertEqual(order2.getExecutionInfo(), None)

        barFeed.dispatchBars(13, 15, 8, 12, 10)
        # 2 should get filled for the second order.
        self.assertTrue(order2.isFilled())
        self.assertEqual(order2.getFilled(), 2)
        self.assertEqual(order2.getRemaining(), 0)
        self.assertEqual(order2.getAvgFillPrice(), 13)
        self.assertEqual(order2.getExecutionInfo().getPrice(), 13)
        self.assertEqual(order2.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order2.getExecutionInfo().getCommission(), 0)

    def testVolumeLimitPerBar2(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        order1 = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)
        self.assertEquals(order1.getSubmitDateTime(), None)
        brk.placeOrder(order1)
        self.assertEquals(order1.getSubmitDateTime(), barFeed.getCurrentDateTime())
        order2 = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)
        self.assertEquals(order2.getSubmitDateTime(), None)
        brk.placeOrder(order2)
        self.assertEquals(order2.getSubmitDateTime(), barFeed.getCurrentDateTime())

        barFeed.dispatchBars(12, 15, 8, 12, 10)
        # 1 should get filled for the first order.
        self.assertTrue(order1.isFilled())
        self.assertEqual(order1.getFilled(), 1)
        self.assertEqual(order1.getRemaining(), 0)
        self.assertEqual(order1.getAvgFillPrice(), 12)
        self.assertEqual(order1.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order1.getExecutionInfo().getQuantity(), 1)
        self.assertEqual(order1.getExecutionInfo().getCommission(), 0)
        # 1 should get filled for the second order.
        self.assertTrue(order2.isFilled())
        self.assertEqual(order2.getFilled(), 1)
        self.assertEqual(order2.getRemaining(), 0)
        self.assertEqual(order2.getAvgFillPrice(), 12)
        self.assertEqual(order2.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order2.getExecutionInfo().getQuantity(), 1)
        self.assertEqual(order2.getExecutionInfo().getCommission(), 0)

    def testGetActiveOrders(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        order1 = brk.createMarketOrder(broker.Order.Action.BUY, "ins1", 1)
        self.assertEquals(order1.getSubmitDateTime(), None)
        brk.placeOrder(order1)
        self.assertEquals(order1.getSubmitDateTime(), barFeed.getCurrentDateTime())
        order2 = brk.createMarketOrder(broker.Order.Action.BUY, "ins2", 1)
        self.assertEquals(order2.getSubmitDateTime(), None)
        brk.placeOrder(order2)
        self.assertEquals(order2.getSubmitDateTime(), barFeed.getCurrentDateTime())

        self.assertEqual(len(brk.getActiveOrders()), 2)
        self.assertEqual(len(brk.getActiveOrders("ins1")), 1)
        self.assertEqual(len(brk.getActiveOrders("ins2")), 1)
        self.assertEqual(len(brk.getActiveOrders("ins3")), 0)


class MarketOrderTestCase(BaseTestCase):
    def testGetPositions(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        cash = 1000000
        brk = backtesting.Broker(cash, barFeed)

        # Buy
        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)
        brk.placeOrder(order)
        barFeed.dispatchBars(12.03, 12.03, 12.03, 12.03, 555.00)
        self.assertTrue(order.isFilled())
        self.assertEquals(brk.getPositions().get(BaseTestCase.TestInstrument), 1)

        # Sell
        order = brk.createMarketOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 1)
        brk.placeOrder(order)
        barFeed.dispatchBars(12.03, 12.03, 12.03, 12.03, 555.00)
        self.assertTrue(order.isFilled())
        self.assertEquals(brk.getPositions().get(BaseTestCase.TestInstrument), None)


    def testBuyPartialWithTwoDecimals(self):
        class Broker(backtesting.Broker):
            def getInstrumentTraits(self, instrument):
                return DecimalTraits(2)

        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        cash = 1000000
        brk = Broker(cash, barFeed)

        # Buy
        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 500)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())

        # 138.75 should get filled.
        barFeed.dispatchBars(12.03, 12.03, 12.03, 12.03, 555.00)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getExecutionInfo().getQuantity(), 138.75)
        self.assertEqual(order.getFilled(), 138.75)
        self.assertEqual(order.getRemaining(), 361.25)
        self.assertEqual(order.getAvgFillPrice(), 12.03)
        self.assertEqual(brk.getShares(BaseTestCase.TestInstrument), 138.75)
        self.assertEqual(brk.getEquity(), cash)
        self.assertEqual(brk.getFillStrategy().getVolumeLeft()[BaseTestCase.TestInstrument], 0)

        # 361.25 should get filled.
        barFeed.dispatchBars(12.03, 12.03, 12.03, 12.03, 2345.00)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getExecutionInfo().getQuantity(), 361.25)
        self.assertEqual(order.getFilled(), 500)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 12.03)
        self.assertEqual(brk.getShares(BaseTestCase.TestInstrument), 500)
        self.assertEqual(brk.getEquity(), cash)
        self.assertEqual(brk.getFillStrategy().getVolumeLeft()[BaseTestCase.TestInstrument], 586.25 - 361.25)

    def testBuyPartialWithEightDecimals(self):
        quantityPresicion = 8
        cashPresicion = 2
        maxFill = 0.25

        class Broker(backtesting.Broker):
            def getInstrumentTraits(self, instrument):
                return DecimalTraits(quantityPresicion)

        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        cash = 1000000
        brk = Broker(cash, barFeed)

        # Buy
        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())

        volumes = [0.0001, 0.1, 0.0000001, 0.00000001, 0.132401]
        volumeFill = [(volume, round(volume*maxFill, quantityPresicion)) for volume in volumes]
        cumFilled = 0
        for volume, expectedFill in volumeFill:
            cumFilled += expectedFill # I'm not rounding here so I can carry errors.
            barFeed.dispatchBars(12.03, 12.03, 12.03, 12.03, volume)
            # print expectedFill, cumFilled
            self.assertTrue(order.isPartiallyFilled())
            if expectedFill > 0:
                self.assertEqual(order.getExecutionInfo().getQuantity(), expectedFill)
            self.assertEqual(order.getFilled(), round(cumFilled, quantityPresicion))
            self.assertEqual(order.getRemaining(), 1 - cumFilled)
            self.assertEqual(round(order.getAvgFillPrice(), cashPresicion), 12.03)
            self.assertEqual(brk.getShares(BaseTestCase.TestInstrument), round(cumFilled, quantityPresicion))
            self.assertEqual(round(brk.getEquity(), cashPresicion), cash)
            self.assertEqual(round(brk.getFillStrategy().getVolumeLeft()[BaseTestCase.TestInstrument], quantityPresicion), 0)

        # Full fill
        filledSoFar = order.getFilled()
        volume = 10
        cumFilled += expectedFill # I'm not rounding here so I can carry errors.
        barFeed.dispatchBars(12.03, 12.03, 12.03, 12.03, volume)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getExecutionInfo().getQuantity(), 1 - filledSoFar)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 12.03)
        self.assertEqual(brk.getShares(BaseTestCase.TestInstrument), 1)
        self.assertEqual(brk.getEquity(), cash)
        self.assertEqual(round(brk.getFillStrategy().getVolumeLeft()[BaseTestCase.TestInstrument], quantityPresicion), round((volume*maxFill) - (1-filledSoFar), quantityPresicion))

    def testBuySellPartial(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        # Buy
        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        # 2 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 10)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 2)
        self.assertEqual(order.getRemaining(), 8)
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 5 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 20)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 7)
        self.assertEqual(order.getRemaining(), 3)
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 3 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 20)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 10)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 3)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)

        # Sell
        order = brk.createMarketOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        # 0 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 2)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 10)
        # 1 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 4)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 9)
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 1)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 9 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 100)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 10)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 9)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)

    def testBuyAndSell(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(11, barFeed)

        # Buy
        cb = OrderUpdateCallback(brk)
        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        barFeed.dispatchBars(10, 15, 8, 12)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getPrice() == 10)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 1)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 1)
        self.assertTrue(cb.eventCount == 2)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

        # Sell
        cb = OrderUpdateCallback(brk)
        order = brk.createMarketOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(10, 15, 8, 12)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getPrice() == 10)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 11)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertTrue(cb.eventCount == 2)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

    def testFailToBuy(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(5, barFeed)

        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)

        # Fail to buy. No money.
        cb = OrderUpdateCallback(brk)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        barFeed.dispatchBars(10, 15, 8, 12, sessionClose=True)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertTrue(order.getExecutionInfo() is None)
        self.assertTrue(len(brk.getActiveOrders()) == 1)
        self.assertTrue(brk.getCash() == 5)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertTrue(cb.eventCount == 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Fail to buy. No money. Canceled due to session close.
        cb = OrderUpdateCallback(brk)
        barFeed.dispatchBars(11, 15, 8, 12)
        self.assertTrue(order.isCanceled())
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertTrue(order.getExecutionInfo() is None)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 5)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertTrue(cb.eventCount == 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

    def testBuy_GTC(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(5, barFeed)

        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)
        order.setGoodTillCanceled(True)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Fail to buy. No money.
        cb = OrderUpdateCallback(brk)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        # Set sessionClose to true test that the order doesn't get canceled.
        barFeed.dispatchBars(10, 15, 8, 12, sessionClose=True)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertTrue(order.getExecutionInfo() is None)
        self.assertTrue(len(brk.getActiveOrders()) == 1)
        self.assertTrue(brk.getCash() == 5)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertTrue(cb.eventCount == 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Buy
        cb = OrderUpdateCallback(brk)
        barFeed.dispatchBars(2, 15, 1, 12)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 2)
        self.assertTrue(order.getExecutionInfo().getPrice() == 2)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 3)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 1)
        self.assertTrue(cb.eventCount == 1)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

    def testBuyAndSellInTwoSteps(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(20.4, barFeed)

        # Buy
        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 2)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 2)
        barFeed.dispatchBars(10, 15, 8, 12)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getPrice() == 10)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(round(brk.getCash(), 1) == 0.4)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 2)
        self.assertEqual(order.getFilled(), 2)
        self.assertEqual(order.getRemaining(), 0)

        # Sell
        order = brk.createMarketOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        barFeed.dispatchBars(10, 15, 8, 12)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getPrice() == 10)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(round(brk.getCash(), 1) == 10.4)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 1)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

        # Sell again
        order = brk.createMarketOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(11, 15, 8, 12)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 11)
        self.assertTrue(order.getExecutionInfo().getPrice() == 11)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(round(brk.getCash(), 1) == 21.4)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

    def testPortfolioValue(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(11, barFeed)

        # Buy
        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        barFeed.dispatchBars(10, 15, 8, 12)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 1)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 1)

        barFeed.dispatchBars(11, 11, 11, 11)
        self.assertEqual(brk.getEquity(), 11 + 1)
        barFeed.dispatchBars(1, 1, 1, 1)
        self.assertEqual(brk.getEquity(), 1 + 1)

    def testBuyWithCommission(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1020, barFeed, commission=backtesting.FixedPerTrade(10))

        # Buy
        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 100)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 100)
        barFeed.dispatchBars(10, 15, 8, 12, volume=500)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getCommission() == 10)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 10)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 100)
        self.assertEqual(order.getFilled(), 100)
        self.assertEqual(order.getRemaining(), 0)

    def testSellShort_1(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        # Short sell
        order = brk.createMarketOrder(broker.Order.Action.SELL_SHORT, BaseTestCase.TestInstrument, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        barFeed.dispatchBars(200, 200, 200, 200)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 200)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 1200)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == -1)
        barFeed.dispatchBars(100, 100, 100, 100)
        self.assertTrue(brk.getEquity() == 1000 + 100)
        barFeed.dispatchBars(0, 0, 0, 0)
        self.assertTrue(brk.getEquity() == 1000 + 200)
        barFeed.dispatchBars(30, 30, 30, 30)
        self.assertTrue(brk.getEquity() == 1000 + 170)

        # Buy at the same price.
        order = brk.createMarketOrder(broker.Order.Action.BUY_TO_COVER, BaseTestCase.TestInstrument, 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(200, 200, 200, 200)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 200)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 1000)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)

    def testSellShort_2(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        # Short sell 1
        order = brk.createMarketOrder(broker.Order.Action.SELL_SHORT, BaseTestCase.TestInstrument, 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(100, 100, 100, 100)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 100)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(brk.getCash() == 1100)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == -1)
        barFeed.dispatchBars(100, 100, 100, 100)
        self.assertTrue(brk.getEquity() == 1000)
        barFeed.dispatchBars(0, 0, 0, 0)
        self.assertTrue(brk.getEquity() == 1000 + 100)
        barFeed.dispatchBars(70, 70, 70, 70)
        self.assertTrue(brk.getEquity() == 1000 + 30)
        barFeed.dispatchBars(200, 200, 200, 200)
        self.assertTrue(brk.getEquity() == 1000 - 100)

        # Buy 2 and earn 50
        order = brk.createMarketOrder(broker.Order.Action.BUY_TO_COVER, BaseTestCase.TestInstrument, 2)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 2)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(50, 50, 50, 50)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 50)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertEqual(order.getFilled(), 2)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 1)
        self.assertTrue(brk.getCash() == 1000)  # +50 from short sell operation, -50 from buy operation.
        barFeed.dispatchBars(50, 50, 50, 50)
        self.assertTrue(brk.getEquity() == 1000 + 50)
        barFeed.dispatchBars(70, 70, 70, 70)
        self.assertTrue(brk.getEquity() == 1000 + 50 + 20)

        # Sell 1 and earn 50
        order = brk.createMarketOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(100, 100, 100, 100)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 100)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        barFeed.dispatchBars(70, 70, 70, 70)
        self.assertTrue(brk.getEquity() == 1000 + 50 + 50)

    def testSellShort_3(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(100, barFeed)

        # Buy 1
        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(100, 100, 100, 100)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 100)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 1)
        self.assertTrue(brk.getCash() == 0)

        # Sell 2
        order = brk.createMarketOrder(broker.Order.Action.SELL_SHORT, BaseTestCase.TestInstrument, 2)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 2)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(100, 100, 100, 100)
        self.assertEqual(order.getFilled(), 2)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 100)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == -1)
        self.assertTrue(brk.getCash() == 200)

        # Buy 1
        order = brk.createMarketOrder(broker.Order.Action.BUY_TO_COVER, BaseTestCase.TestInstrument, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        barFeed.dispatchBars(100, 100, 100, 100)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 100)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertTrue(brk.getCash() == 100)

    def testSellShortWithCommission(self):
        sharePrice = 100
        commission = 10
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1010, barFeed, commission=backtesting.FixedPerTrade(commission))

        # Sell 10 shares
        order = brk.createMarketOrder(broker.Order.Action.SELL_SHORT, BaseTestCase.TestInstrument, 10)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(sharePrice, sharePrice, sharePrice, sharePrice)
        self.assertEqual(order.getFilled(), 10)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), sharePrice)
        self.assertTrue(order.getExecutionInfo().getCommission() == 10)
        self.assertTrue(brk.getCash() == 2000)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == -10)

        # Buy the 10 shares sold short plus 9 extra
        order = brk.createMarketOrder(broker.Order.Action.BUY_TO_COVER, BaseTestCase.TestInstrument, 19)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 19)
        barFeed.dispatchBars(sharePrice, sharePrice, sharePrice, sharePrice)
        self.assertEqual(order.getFilled(), 19)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), sharePrice)
        self.assertTrue(order.getExecutionInfo().getCommission() == 10)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 9)
        self.assertTrue(brk.getCash() == sharePrice - commission)

    def testCancel(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(100, barFeed)

        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        brk.cancelOrder(order)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        barFeed.dispatchBars(10, 10, 10, 10)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertTrue(order.isCanceled())

    def testTradePercentageWithPartialFills(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)
        commPercentage = 0.1
        brk.setCommission(backtesting.TradePercentage(0.1))

        # Buy
        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getCommissions(), 0)
        # 2 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 10)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 2)
        self.assertEqual(order.getRemaining(), 8)
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertEqual(order.getCommissions(), 12*2*commPercentage)
        self.assertEqual(order.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order.getExecutionInfo().getCommission(), 12*2*commPercentage)
        # 5 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 20)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 7)
        self.assertEqual(order.getRemaining(), 3)
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertEqual(order.getCommissions(), 12*7*commPercentage)
        self.assertEqual(order.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 12*5*commPercentage)
        # 3 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 20)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 10)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertEqual(order.getCommissions(), 12*10*commPercentage)
        self.assertEqual(order.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 3)
        self.assertEqual(order.getExecutionInfo().getCommission(), 12*3*commPercentage)

    def testFixedPerTradeWithPartialFills(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)
        brk.setCommission(backtesting.FixedPerTrade(1.2))

        # Buy
        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getCommissions(), 0)
        # 2 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 10)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 2)
        self.assertEqual(order.getRemaining(), 8)
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertEqual(order.getCommissions(), 1.2)
        self.assertEqual(order.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order.getExecutionInfo().getCommission(), 1.2)  # Commision applied in the first fill.
        # 5 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 20)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 7)
        self.assertEqual(order.getRemaining(), 3)
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertEqual(order.getCommissions(), 1.2)
        self.assertEqual(order.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 3 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 20)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 10)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertEqual(order.getCommissions(), 1.2)
        self.assertEqual(order.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 3)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)


class LimitOrderTestCase(BaseTestCase):
    def testBuySellPartial(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        # Buy
        order = brk.createLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 10, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        # 2 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 10)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 2)
        self.assertEqual(order.getRemaining(), 8)
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertEqual(order.getExecutionInfo().getPrice(), 10)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 5 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 20)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 7)
        self.assertEqual(order.getRemaining(), 3)
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertEqual(order.getExecutionInfo().getPrice(), 10)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 3 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 20)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 10)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertEqual(order.getExecutionInfo().getPrice(), 10)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 3)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)

        # Sell
        order = brk.createLimitOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 10, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        # 0 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 2)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 10)
        # 1 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 4)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 9)
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 1)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 9 should get filled.
        barFeed.dispatchBars(12, 15, 8, 12, 100)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 10)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getPrice(), 12)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 9)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)

    def testBuyAndSell_HitTargetPrice(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(20, barFeed)

        # Buy
        cb = OrderUpdateCallback(brk)
        order = brk.createLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 10, 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(12, 15, 8, 12)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getPrice() == 10)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 10)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 1)
        self.assertTrue(cb.eventCount == 2)

        # Sell
        cb = OrderUpdateCallback(brk)
        order = brk.createLimitOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 15, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        barFeed.dispatchBars(10, 17, 8, 10)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 15)
        self.assertTrue(order.getExecutionInfo().getPrice() == 15)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 25)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertTrue(cb.eventCount == 2)

    def testBuyAndSell_GetBetterPrice(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(20, barFeed)

        # Buy
        cb = OrderUpdateCallback(brk)
        order = brk.createLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 14, 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(12, 15, 8, 12)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertTrue(order.getExecutionInfo().getPrice() == 12)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 8)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 1)
        self.assertTrue(cb.eventCount == 2)

        # Sell
        cb = OrderUpdateCallback(brk)
        order = brk.createLimitOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 15, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        barFeed.dispatchBars(16, 17, 8, 10)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 16)
        self.assertTrue(order.getExecutionInfo().getPrice() == 16)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 24)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertTrue(cb.eventCount == 2)

    def testBuyAndSell_GappingBars(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(20, barFeed)

        # Buy. Bar is below the target price.
        cb = OrderUpdateCallback(brk)
        order = brk.createLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 20, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        barFeed.dispatchBars(10, 15, 8, 10)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getPrice() == 10)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 10)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 1)
        self.assertTrue(cb.eventCount == 2)

        # Sell. Bar is above the target price.
        cb = OrderUpdateCallback(brk)
        order = brk.createLimitOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 30, 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(35, 40, 32, 35)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 35)
        self.assertTrue(order.getExecutionInfo().getPrice() == 35)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 45)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertTrue(cb.eventCount == 2)

    def testFailToBuy(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(5, barFeed)

        order = brk.createLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 5, 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Fail to buy (couldn't get specific price).
        cb = OrderUpdateCallback(brk)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(10, 15, 8, 12, sessionClose=True)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertTrue(order.getExecutionInfo() is None)
        self.assertTrue(len(brk.getActiveOrders()) == 1)
        self.assertTrue(brk.getCash() == 5)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertTrue(cb.eventCount == 1)

        # Fail to buy (couldn't get specific price). Canceled due to session close.
        cb = OrderUpdateCallback(brk)
        barFeed.dispatchBars(11, 15, 8, 12)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertTrue(order.isCanceled())
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertTrue(order.getExecutionInfo() is None)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 5)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertTrue(cb.eventCount == 1)

    def testBuy_GTC(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(10, barFeed)

        order = brk.createLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 4, 2)
        order.setGoodTillCanceled(True)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 2)

        # Fail to buy (couldn't get specific price).
        cb = OrderUpdateCallback(brk)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        # Set sessionClose to true test that the order doesn't get canceled.
        barFeed.dispatchBars(10, 15, 8, 12, sessionClose=True)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 2)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertTrue(order.getExecutionInfo() is None)
        self.assertTrue(len(brk.getActiveOrders()) == 1)
        self.assertTrue(brk.getCash() == 10)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertTrue(cb.eventCount == 1)

        # Buy
        cb = OrderUpdateCallback(brk)
        barFeed.dispatchBars(2, 15, 1, 12)
        self.assertEqual(order.getFilled(), 2)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 2)
        self.assertTrue(order.getExecutionInfo().getPrice() == 2)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 6)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 2)
        self.assertTrue(cb.eventCount == 1)


class StopOrderTestCase(BaseTestCase):
    def testStopHitWithoutVolume(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        # Buy. Stop >= 15.
        order = brk.createStopOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 15, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())

        # 0 should get filled. There is not enough volume.
        barFeed.dispatchBars(18, 19, 17.01, 18, 3)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 10)
        self.assertEqual(order.getStopHit(), True)
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertEqual(order.getExecutionInfo(), None)

    def testBuySellPartial_ActivateAndThenFill(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        # Buy. Stop >= 15.
        order = brk.createStopOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 15, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())

        # 0 should get filled. The stop price should have not been hit.
        barFeed.dispatchBars(12, 14, 8, 12, 10)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 10)
        self.assertEqual(order.getStopHit(), False)
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertEqual(order.getExecutionInfo(), None)
        # 0 should get filled. The stop price should have been hit but there is not enough volume.
        barFeed.dispatchBars(17.1, 18, 17.01, 18, 3)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 10)
        self.assertEqual(order.getStopHit(), True)
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertEqual(order.getExecutionInfo(), None)
        # 5 should get filled.
        barFeed.dispatchBars(18, 18, 16, 18, 20)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 5)
        self.assertEqual(order.getRemaining(), 5)
        self.assertEqual(order.getAvgFillPrice(), 18)
        self.assertEqual(order.getExecutionInfo().getPrice(), 18)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 5 should get filled.
        barFeed.dispatchBars(17.1, 18, 17.01, 18, 50)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 10)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), (18 + 17.1) / 2.0)
        self.assertEqual(order.getExecutionInfo().getPrice(), 17.1)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)

        # Sell. Stop <= 19.
        order = brk.createStopOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 19, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        # 0 should get filled. The stop price should have not been hit.
        barFeed.dispatchBars(19.1, 19.5, 19.1, 19.4, 10)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 10)
        self.assertEqual(order.getStopHit(), False)
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertEqual(order.getExecutionInfo(), None)
        # 0 should get filled. The stop price should have been hit but there is not enough volume.
        barFeed.dispatchBars(18, 18, 16, 18, 3)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 10)
        self.assertEqual(order.getStopHit(), True)
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertEqual(order.getExecutionInfo(), None)
        # 5 should get filled.
        barFeed.dispatchBars(20, 21, 17, 18, 20)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 5)
        self.assertEqual(order.getRemaining(), 5)
        self.assertEqual(order.getAvgFillPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 2 should get filled.
        barFeed.dispatchBars(16, 21, 15, 18, 10)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 7)
        self.assertEqual(order.getRemaining(), 3)
        self.assertEqual(order.getAvgFillPrice(), (20*5 + 16*2)/7.0)
        self.assertEqual(order.getExecutionInfo().getPrice(), 16)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 2 should get filled.
        barFeed.dispatchBars(21, 21, 17, 18, 10)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 9)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEqual(order.getAvgFillPrice(), (20*5 + 16*2 + 21*2)/9.0)
        self.assertEqual(order.getExecutionInfo().getPrice(), 21)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 1 should get filled.
        barFeed.dispatchBars(20, 21, 17, 18, 10)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 10)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), (20*5 + 16*2 + 21*2 + 20)/10.0)
        self.assertEqual(order.getExecutionInfo().getPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 1)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)

    def testBuySellPartial_ActivateAndFill(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        # Buy. Stop >= 15.
        order = brk.createStopOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 15, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())

        # 5 should get filled.
        barFeed.dispatchBars(18, 18, 16, 18, 20)
        self.assertEqual(order.getStopHit(), True)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 5)
        self.assertEqual(order.getRemaining(), 5)
        self.assertEqual(order.getAvgFillPrice(), 18)
        self.assertEqual(order.getExecutionInfo().getPrice(), 18)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 0 should get filled. There is not enough volume.
        barFeed.dispatchBars(17.1, 18, 17.01, 18, 3)
        self.assertEqual(order.getAvgFillPrice(), 18)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 5)
        self.assertEqual(order.getRemaining(), 5)
        # 5 should get filled.
        barFeed.dispatchBars(16, 18, 16, 18, 20)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 10)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), (18 + 16) / 2.0)
        self.assertEqual(order.getExecutionInfo().getPrice(), 16)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)

        # Sell. Stop <= 19.
        order = brk.createStopOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 19, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        # 5 should get filled.
        barFeed.dispatchBars(20, 21, 17, 18, 20)
        self.assertEqual(order.getStopHit(), True)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 5)
        self.assertEqual(order.getRemaining(), 5)
        self.assertEqual(order.getAvgFillPrice(), 19)
        self.assertEqual(order.getExecutionInfo().getPrice(), 19)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 0 should get filled. There is not enough volume.
        barFeed.dispatchBars(18, 18, 16, 18, 3)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getAvgFillPrice(), 19)
        self.assertEqual(order.getFilled(), 5)
        self.assertEqual(order.getRemaining(), 5)
        # 2 should get filled.
        barFeed.dispatchBars(20, 21, 17, 18, 10)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 7)
        self.assertEqual(order.getRemaining(), 3)
        self.assertEqual(order.getAvgFillPrice(), (19*5 + 20*2)/7.0)
        self.assertEqual(order.getExecutionInfo().getPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 2 should get filled.
        barFeed.dispatchBars(21, 21, 17, 18, 10)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 9)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEqual(order.getAvgFillPrice(), (19*5 + 20*2 + 21*2)/9.0)
        self.assertEqual(order.getExecutionInfo().getPrice(), 21)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 1 should get filled.
        barFeed.dispatchBars(21, 21, 17, 18, 10)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 10)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), (19*5 + 20*2 + 21*3)/10.0)
        self.assertEqual(order.getExecutionInfo().getPrice(), 21)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 1)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)

    def testLongPosStopLoss(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(15, barFeed)

        # Buy
        cb = OrderUpdateCallback(brk)
        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(10, 15, 8, 12)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getPrice() == 10)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 5)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 1)
        self.assertTrue(cb.eventCount == 2)

        # Create stop loss order.
        cb = OrderUpdateCallback(brk)
        order = brk.createStopOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 9, 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(10, 15, 10, 12)  # Stop loss not hit.
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertFalse(order.isFilled())
        self.assertTrue(len(brk.getActiveOrders()) == 1)
        self.assertTrue(brk.getCash() == 5)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 1)
        self.assertTrue(cb.eventCount == 1)
        barFeed.dispatchBars(10, 15, 8, 12)  # Stop loss hit.
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 9)
        self.assertTrue(order.getExecutionInfo().getPrice() == 9)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 5+9)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertTrue(cb.eventCount == 2)

    def testLongPosStopLoss_GappingBars(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(15, barFeed)

        # Buy
        cb = OrderUpdateCallback(brk)
        order = brk.createMarketOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(10, 15, 8, 12)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getPrice() == 10)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 5)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 1)
        self.assertTrue(cb.eventCount == 2)

        # Create stop loss order.
        cb = OrderUpdateCallback(brk)
        order = brk.createStopOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 9, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        barFeed.dispatchBars(10, 15, 10, 12)  # Stop loss not hit.
        self.assertFalse(order.isFilled())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertTrue(len(brk.getActiveOrders()) == 1)
        self.assertTrue(brk.getCash() == 5)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 1)
        self.assertTrue(cb.eventCount == 1)
        barFeed.dispatchBars(5, 8, 4, 7)  # Stop loss hit.
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 5)
        self.assertTrue(order.getExecutionInfo().getPrice() == 5)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 5+5)  # Fill the stop loss order at open price.
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertTrue(cb.eventCount == 2)

    def testShortPosStopLoss(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(15, barFeed)

        # Sell short
        cb = OrderUpdateCallback(brk)
        order = brk.createMarketOrder(broker.Order.Action.SELL_SHORT, BaseTestCase.TestInstrument, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        barFeed.dispatchBars(10, 15, 8, 12)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getPrice() == 10)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 15+10)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == -1)
        self.assertTrue(cb.eventCount == 2)

        # Create stop loss order.
        cb = OrderUpdateCallback(brk)
        order = brk.createStopOrder(broker.Order.Action.BUY_TO_COVER, BaseTestCase.TestInstrument, 11, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        barFeed.dispatchBars(8, 10, 7, 9)  # Stop loss not hit.
        self.assertFalse(order.isFilled())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertTrue(len(brk.getActiveOrders()) == 1)
        self.assertTrue(brk.getCash() == 15+10)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == -1)
        self.assertTrue(cb.eventCount == 1)
        barFeed.dispatchBars(10, 15, 8, 12)  # Stop loss hit.
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertTrue(order.getExecutionInfo().getPrice() == 11)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 15-1)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertTrue(cb.eventCount == 2)

    def testShortPosStopLoss_GappingBars(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(15, barFeed)

        # Sell short
        cb = OrderUpdateCallback(brk)
        order = brk.createMarketOrder(broker.Order.Action.SELL_SHORT, BaseTestCase.TestInstrument, 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        barFeed.dispatchBars(10, 15, 8, 12)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getPrice() == 10)
        self.assertTrue(order.getExecutionInfo().getCommission() == 0)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 15+10)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == -1)
        self.assertTrue(cb.eventCount == 2)

        # Create stop loss order.
        cb = OrderUpdateCallback(brk)
        order = brk.createStopOrder(broker.Order.Action.BUY_TO_COVER, BaseTestCase.TestInstrument, 11, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        barFeed.dispatchBars(8, 10, 7, 9)  # Stop loss not hit.
        self.assertFalse(order.isFilled())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertTrue(len(brk.getActiveOrders()) == 1)
        self.assertTrue(brk.getCash() == 15+10)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == -1)
        self.assertTrue(cb.eventCount == 1)
        barFeed.dispatchBars(15, 20, 13, 14)  # Stop loss hit.
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 15)
        self.assertTrue(order.getExecutionInfo().getPrice() == 15)
        self.assertTrue(len(brk.getActiveOrders()) == 0)
        self.assertTrue(brk.getCash() == 15-5)
        self.assertTrue(brk.getShares(BaseTestCase.TestInstrument) == 0)
        self.assertTrue(cb.eventCount == 2)


class StopLimitOrderTestCase(BaseTestCase):
    def testStopHitWithoutVolume(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        # Buy. Stop >= 15. Buy <= 17.
        order = brk.createStopLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 15, 17, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())

        # 0 should get filled. There is not enough volume.
        barFeed.dispatchBars(18, 19, 15, 18, 3)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 10)
        self.assertEqual(order.getStopHit(), True)
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertEqual(order.getExecutionInfo(), None)

    def testRegressionBarGapsAboveStop(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        # Buy. Stop >= 15. Buy <= 17.
        order = brk.createStopLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 15, 17, 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())

        # 1 should get filled at 17. Before the bug was fixed it was filled at 15.
        barFeed.dispatchBars(18, 18, 16, 18, 20)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 17)
        self.assertEqual(order.getExecutionInfo().getPrice(), 17)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 1)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)

    def testBuySellPartial_ActivateAndThenFill(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        # Buy. Stop >= 15. Buy <= 17.
        order = brk.createStopLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 15, 17, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())

        # 0 should get filled. The stop price should have not been hit.
        barFeed.dispatchBars(12, 14, 8, 12, 10)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 10)
        self.assertEqual(order.getStopHit(), False)
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertEqual(order.getExecutionInfo(), None)
        # 0 should get filled. The stop price should have been hit.
        barFeed.dispatchBars(17.1, 18, 17.01, 18, 10)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 10)
        self.assertEqual(order.getStopHit(), True)
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertEqual(order.getExecutionInfo(), None)
        # 5 should get filled.
        barFeed.dispatchBars(18, 18, 16, 18, 20)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 5)
        self.assertEqual(order.getRemaining(), 5)
        self.assertEqual(order.getAvgFillPrice(), 17)
        self.assertEqual(order.getExecutionInfo().getPrice(), 17)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 0 should get filled.
        barFeed.dispatchBars(17.1, 18, 17.01, 18, 10)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 5)
        self.assertEqual(order.getRemaining(), 5)
        self.assertEqual(order.getAvgFillPrice(), 17)
        self.assertEqual(order.getExecutionInfo().getPrice(), 17)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 5 should get filled.
        barFeed.dispatchBars(18, 18, 16, 18, 20)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 10)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), 17)
        self.assertEqual(order.getExecutionInfo().getPrice(), 17)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)

        # Sell. Stop <= 19. Sell >= 20.
        order = brk.createStopLimitOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 19, 20, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        # 0 should get filled. The stop price should have not been hit.
        barFeed.dispatchBars(19.1, 19.5, 19.1, 19.4, 10)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 10)
        self.assertEqual(order.getStopHit(), False)
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertEqual(order.getExecutionInfo(), None)
        # 0 should get filled. The stop price should have been hit.
        barFeed.dispatchBars(18, 18, 16, 18, 20)
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 10)
        self.assertEqual(order.getStopHit(), True)
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertEqual(order.getExecutionInfo(), None)
        # 5 should get filled.
        barFeed.dispatchBars(20, 21, 17, 18, 20)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 5)
        self.assertEqual(order.getRemaining(), 5)
        self.assertEqual(order.getAvgFillPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 0 should get filled.
        barFeed.dispatchBars(18, 18, 16, 18, 20)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 5)
        self.assertEqual(order.getRemaining(), 5)
        self.assertEqual(order.getAvgFillPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 2 should get filled.
        barFeed.dispatchBars(20, 21, 17, 18, 10)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 7)
        self.assertEqual(order.getRemaining(), 3)
        self.assertEqual(order.getAvgFillPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 2 should get filled.
        barFeed.dispatchBars(21, 21, 17, 18, 10)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 9)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEqual(order.getAvgFillPrice(), (20*7 + 21*2) / 9.0)
        self.assertEqual(order.getExecutionInfo().getPrice(), 21)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 1 should get filled.
        barFeed.dispatchBars(21, 21, 17, 18, 10)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 10)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), (20*7 + 21*3) / 10.0)
        self.assertEqual(order.getExecutionInfo().getPrice(), 21)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 1)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)

    def testBuySellPartial_ActivateAndFill(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(1000, barFeed)

        # Buy. Stop >= 15. Buy <= 17.
        order = brk.createStopLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, 15, 17, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())

        # 5 should get filled.
        barFeed.dispatchBars(18, 18, 16, 18, 20)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 5)
        self.assertEqual(order.getRemaining(), 5)
        self.assertEqual(order.getAvgFillPrice(), 17)
        self.assertEqual(order.getExecutionInfo().getPrice(), 17)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 0 should get filled.
        barFeed.dispatchBars(17.1, 18, 17.01, 18, 10)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 5)
        self.assertEqual(order.getRemaining(), 5)
        self.assertEqual(order.getAvgFillPrice(), 17)
        self.assertEqual(order.getExecutionInfo().getPrice(), 17)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 5 should get filled.
        barFeed.dispatchBars(16, 18, 16, 18, 20)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 10)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), (17+16)/2.0)
        self.assertEqual(order.getExecutionInfo().getPrice(), 16)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)

        # Sell. Stop <= 19. Sell >= 20.
        order = brk.createStopLimitOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, 19, 20, 10)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        # 5 should get filled.
        barFeed.dispatchBars(20, 21, 17, 18, 20)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 5)
        self.assertEqual(order.getRemaining(), 5)
        self.assertEqual(order.getAvgFillPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 0 should get filled.
        barFeed.dispatchBars(18, 18, 16, 18, 20)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 5)
        self.assertEqual(order.getRemaining(), 5)
        self.assertEqual(order.getAvgFillPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 5)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 2 should get filled.
        barFeed.dispatchBars(20, 21, 17, 18, 10)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 7)
        self.assertEqual(order.getRemaining(), 3)
        self.assertEqual(order.getAvgFillPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getPrice(), 20)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 2 should get filled.
        barFeed.dispatchBars(21, 21, 17, 18, 10)
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getFilled(), 9)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEqual(order.getAvgFillPrice(), (20*7 + 21*2) / 9.0)
        self.assertEqual(order.getExecutionInfo().getPrice(), 21)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)
        # 1 should get filled.
        barFeed.dispatchBars(21, 21, 17, 18, 10)
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getFilled(), 10)
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getAvgFillPrice(), (20*7 + 21*3) / 10.0)
        self.assertEqual(order.getExecutionInfo().getPrice(), 21)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 1)
        self.assertEqual(order.getExecutionInfo().getCommission(), 0)

    def testFillOpen(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(15, barFeed)

        # Buy. Stop >= 10. Buy <= 12.
        order = brk.createStopLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, stopPrice=10, limitPrice=12, quantity=1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price not hit. Limit price not hit.
        barFeed.dispatchBars(8, 9, 7, 8)
        self.assertFalse(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price not hit.
        barFeed.dispatchBars(13, 15, 13, 14)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Limit price hit (bars include the price). Fill at open price.
        barFeed.dispatchBars(11, 15, 10, 14)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 11)
        self.assertTrue(order.getExecutionInfo().getPrice() == 11)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

        # Sell. Stop <= 8. Sell >= 6.
        order = brk.createStopLimitOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, stopPrice=8, limitPrice=6, quantity=1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price not hit. Limit price not hit.
        barFeed.dispatchBars(9, 10, 9, 10)
        self.assertFalse(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price not hit.
        barFeed.dispatchBars(4, 5, 3, 4)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Limit price hit (bars include the price). Fill at open price.
        barFeed.dispatchBars(7, 8, 6, 7)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 7)
        self.assertTrue(order.getExecutionInfo().getPrice() == 7)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

    def testFillOpen_GappingBars(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(15, barFeed)

        # Buy. Stop >= 10. Buy <= 12.
        order = brk.createStopLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, stopPrice=10, limitPrice=12, quantity=1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price not hit. Limit price not hit.
        barFeed.dispatchBars(8, 9, 7, 8)
        self.assertFalse(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price not hit.
        barFeed.dispatchBars(13, 18, 13, 17)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Limit price hit (bars don't include the price). Fill at open price.
        barFeed.dispatchBars(7, 9, 6, 8)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 7)
        self.assertTrue(order.getExecutionInfo().getPrice() == 7)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

        # Sell. Stop <= 8. Sell >= 6.
        order = brk.createStopLimitOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, stopPrice=8, limitPrice=6, quantity=1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price not hit. Limit price not hit.
        barFeed.dispatchBars(9, 10, 9, 10)
        self.assertFalse(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price not hit.
        barFeed.dispatchBars(4, 5, 3, 4)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Limit price hit (bars don't include the price). Fill at open price.
        barFeed.dispatchBars(10, 12, 8, 10)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getPrice() == 10)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

    def testFillLimit(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(15, barFeed)

        # Buy. Stop >= 10. Buy <= 12.
        order = brk.createStopLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, stopPrice=10, limitPrice=12, quantity=1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price not hit. Limit price not hit.
        barFeed.dispatchBars(8, 9, 7, 8)
        self.assertFalse(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price not hit.
        barFeed.dispatchBars(13, 15, 13, 14)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Limit price hit. Fill at limit price.
        barFeed.dispatchBars(13, 15, 10, 14)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 12)
        self.assertTrue(order.getExecutionInfo().getPrice() == 12)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

        # Sell. Stop <= 8. Sell >= 6.
        order = brk.createStopLimitOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, stopPrice=8, limitPrice=6, quantity=1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price not hit. Limit price not hit.
        barFeed.dispatchBars(9, 10, 9, 10)
        self.assertFalse(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price not hit.
        barFeed.dispatchBars(4, 5, 3, 4)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Limit price hit. Fill at limit price.
        barFeed.dispatchBars(5, 7, 5, 6)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 6)
        self.assertTrue(order.getExecutionInfo().getPrice() == 6)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

    def testHitStopAndLimit(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(15, barFeed)

        # Buy. Stop >= 10. Buy <= 12.
        order = brk.createStopLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, stopPrice=10, limitPrice=12, quantity=1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price hit. Fill at stop price.
        barFeed.dispatchBars(9, 15, 8, 14)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getPrice() == 10)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

        # Sell. Stop <= 8. Sell >= 6.
        order = brk.createStopLimitOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, stopPrice=8, limitPrice=6, quantity=1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price hit. Fill at stop price.
        barFeed.dispatchBars(9, 10, 5, 8)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 8)
        self.assertTrue(order.getExecutionInfo().getPrice() == 8)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

    def testInvertedPrices_FillOpen(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(15, barFeed)

        # Buy. Stop >= 12. Buy <= 10.
        order = brk.createStopLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, stopPrice=12, limitPrice=10, quantity=1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price not hit. Limit price not hit.
        barFeed.dispatchBars(8, 9, 7, 8)
        self.assertFalse(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price not hit.
        barFeed.dispatchBars(11, 12, 10.5, 11)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Limit price hit. Fill at open price.
        barFeed.dispatchBars(9, 15, 8, 14)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 9)
        self.assertTrue(order.getExecutionInfo().getPrice() == 9)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

        # Sell. Stop <= 6. Sell >= 8.
        order = brk.createStopLimitOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, stopPrice=6, limitPrice=8, quantity=1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price not hit. Limit price not hit.
        barFeed.dispatchBars(9, 10, 9, 10)
        self.assertFalse(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price not hit.
        barFeed.dispatchBars(7, 7, 6, 7)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Limit price hit. Fill at open price.
        barFeed.dispatchBars(9, 10, 8, 9)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 9)
        self.assertTrue(order.getExecutionInfo().getPrice() == 9)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

    def testInvertedPrices_FillOpen_GappingBars(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(15, barFeed)

        # Buy. Stop >= 12. Buy <= 10.
        order = brk.createStopLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, stopPrice=12, limitPrice=10, quantity=1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price not hit. Limit price not hit.
        barFeed.dispatchBars(8, 9, 7, 8)
        self.assertFalse(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price not hit.
        barFeed.dispatchBars(11, 12, 10.5, 11)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Limit price hit. Fill at open price.
        barFeed.dispatchBars(7, 9, 6, 8)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 7)
        self.assertTrue(order.getExecutionInfo().getPrice() == 7)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

        # Sell. Stop <= 6. Sell >= 8.
        order = brk.createStopLimitOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, stopPrice=6, limitPrice=8, quantity=1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price not hit. Limit price not hit.
        barFeed.dispatchBars(9, 10, 9, 10)
        self.assertFalse(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price not hit.
        barFeed.dispatchBars(7, 7, 6, 7)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Limit price hit. Fill at open price.
        barFeed.dispatchBars(10, 10, 9, 9)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getPrice() == 10)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

    def testInvertedPrices_FillLimit(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(15, barFeed)

        # Buy. Stop >= 12. Buy <= 10.
        order = brk.createStopLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, stopPrice=12, limitPrice=10, quantity=1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price not hit. Limit price not hit.
        barFeed.dispatchBars(8, 9, 7, 8)
        self.assertFalse(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price not hit.
        barFeed.dispatchBars(11, 12, 10.5, 11)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Limit price hit. Fill at limit price.
        barFeed.dispatchBars(11, 13, 8, 9)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getPrice() == 10)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

        # Sell. Stop <= 6. Sell >= 8.
        order = brk.createStopLimitOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, stopPrice=6, limitPrice=8, quantity=1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price not hit. Limit price not hit.
        barFeed.dispatchBars(9, 10, 9, 10)
        self.assertFalse(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price not hit.
        barFeed.dispatchBars(7, 7, 6, 7)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Limit price hit. Fill at limit price.
        barFeed.dispatchBars(7, 10, 6, 9)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 8)
        self.assertTrue(order.getExecutionInfo().getPrice() == 8)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

    def testInvertedPrices_HitStopAndLimit(self):
        barFeed = self.buildBarFeed(BaseTestCase.TestInstrument, bar.Frequency.MINUTE)
        brk = self.buildBroker(15, barFeed)

        # Buy. Stop >= 12. Buy <= 10.
        order = brk.createStopLimitOrder(broker.Order.Action.BUY, BaseTestCase.TestInstrument, stopPrice=12, limitPrice=10, quantity=1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price hit. Fill at limit price.
        barFeed.dispatchBars(9, 15, 8, 14)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 10)
        self.assertTrue(order.getExecutionInfo().getPrice() == 10)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

        # Sell. Stop <= 6. Sell >= 8.
        order = brk.createStopLimitOrder(broker.Order.Action.SELL, BaseTestCase.TestInstrument, stopPrice=6, limitPrice=8, quantity=1)
        self.assertEquals(order.getSubmitDateTime(), None)
        brk.placeOrder(order)
        self.assertEquals(order.getSubmitDateTime(), barFeed.getCurrentDateTime())
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getRemaining(), 1)

        # Stop price hit. Limit price hit. Fill at limit price.
        barFeed.dispatchBars(6, 10, 5, 7)
        self.assertTrue(order.getStopHit())
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getAvgFillPrice(), 8)
        self.assertTrue(order.getExecutionInfo().getPrice() == 8)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getRemaining(), 0)

########NEW FILE########
__FILENAME__ = broker_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime

from pyalgotrade import broker


class DefaultTraits(broker.InstrumentTraits):
    def roundQuantity(self, quantity):
        return int(quantity)


class OrderTestCase(unittest.TestCase):
    def __buildAcceptedLimitOrder(self, action, limitPrice, quantity):
        ret = broker.LimitOrder(1, action, "orcl", limitPrice, quantity, DefaultTraits())
        self.assertEquals(ret.getSubmitDateTime(), None)
        ret.switchState(broker.Order.State.SUBMITTED)
        ret.setSubmitDateTime(datetime.datetime.now())
        self.assertNotEquals(ret.getSubmitDateTime(), None)
        ret.switchState(broker.Order.State.ACCEPTED)
        return ret

    def testCompleteFill(self):
        order = self.__buildAcceptedLimitOrder(broker.Order.Action.BUY, 1, 1)
        self.assertEqual(order.getRemaining(), 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertEqual(order.getExecutionInfo(), None)

        order.addExecutionInfo(broker.OrderExecutionInfo(0.9, 1, 0, datetime.datetime.now()))
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getFilled(), 1)
        self.assertEqual(order.getAvgFillPrice(), 0.9)

    def testCompleteFillInvalidSize(self):
        order = self.__buildAcceptedLimitOrder(broker.Order.Action.BUY, 1, 1)
        with self.assertRaises(Exception):
            order.addExecutionInfo(broker.OrderExecutionInfo(1, 1.001, 0, datetime.datetime.now()))
        self.assertTrue(order.isAccepted())
        self.assertEqual(order.getRemaining(), 1)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertEqual(order.getExecutionInfo(), None)

    def testPartialFill(self):
        order = self.__buildAcceptedLimitOrder(broker.Order.Action.BUY, 2, 11)
        self.assertEqual(order.getRemaining(), 11)
        self.assertEqual(order.getFilled(), 0)
        self.assertEqual(order.getAvgFillPrice(), None)
        self.assertEqual(order.getExecutionInfo(), None)

        order.addExecutionInfo(broker.OrderExecutionInfo(1, 8, 0, datetime.datetime.now()))
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getRemaining(), 3)
        self.assertEqual(order.getFilled(), 8)
        self.assertEqual(order.getAvgFillPrice(), 1)
        self.assertEqual(order.getExecutionInfo().getQuantity(), 8)
        self.assertEqual(order.getExecutionInfo().getPrice(), 1)

        order.addExecutionInfo(broker.OrderExecutionInfo(1.5, 1, 0, datetime.datetime.now()))
        self.assertTrue(order.isPartiallyFilled())
        self.assertEqual(order.getRemaining(), 2)
        self.assertEqual(order.getFilled(), 9)
        self.assertEqual(round(order.getAvgFillPrice(), 4), round(1.055555556, 4))
        self.assertEqual(order.getExecutionInfo().getQuantity(), 1)
        self.assertEqual(order.getExecutionInfo().getPrice(), 1.5)

        order.addExecutionInfo(broker.OrderExecutionInfo(1.123, 2, 0, datetime.datetime.now()))
        self.assertTrue(order.isFilled())
        self.assertEqual(order.getRemaining(), 0)
        self.assertEqual(order.getFilled(), 11)
        self.assertEqual(round(order.getAvgFillPrice(), 4), round(1.067818182, 4))
        self.assertEqual(order.getExecutionInfo().getQuantity(), 2)
        self.assertEqual(order.getExecutionInfo().getPrice(), 1.123)

########NEW FILE########
__FILENAME__ = btcharts_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade.bitcoincharts import barfeed
from pyalgotrade.utils import dt

import unittest
import common
import datetime


class TestCase(unittest.TestCase):
    def testLoadNoFilter(self):
        feed = barfeed.CSVTradeFeed()
        feed.addBarsFromCSV(common.get_data_file_path("bitstampUSD.csv"))
        loaded = [(dateTime, bars) for dateTime, bars in feed]

        self.assertEquals(len(loaded), 9999)

        self.assertEquals(loaded[0][0], dt.as_utc(datetime.datetime(2011, 9, 13, 13, 53, 36)))
        self.assertEquals(loaded[0][1]["BTC"].getDateTime(), dt.as_utc(datetime.datetime(2011, 9, 13, 13, 53, 36)))
        self.assertEquals(loaded[0][1]["BTC"].getClose(), 5.8)
        self.assertEquals(loaded[0][1]["BTC"].getPrice(), 5.8)
        self.assertEquals(loaded[0][1]["BTC"].getVolume(), 1.0)

        self.assertEquals(loaded[-1][0], dt.as_utc(datetime.datetime(2012, 5, 31, 8, 41, 18, 5)))
        self.assertEquals(loaded[-1][1]["BTC"].getDateTime(), dt.as_utc(datetime.datetime(2012, 5, 31, 8, 41, 18, 5)))
        self.assertEquals(loaded[-1][1]["BTC"].getClose(), 5.1)
        self.assertEquals(loaded[-1][1]["BTC"].getPrice(), 5.1)
        self.assertEquals(loaded[-1][1]["BTC"].getVolume(), 0.39215686)

    def testLoadFilterFrom(self):
        feed = barfeed.CSVTradeFeed()
        feed.addBarsFromCSV(common.get_data_file_path("bitstampUSD.csv"), "bitstampUSD", fromDateTime=dt.as_utc(datetime.datetime(2012, 5, 29)))
        loaded = [(dateTime, bars) for dateTime, bars in feed]

        self.assertEquals(len(loaded), 646)

        self.assertEquals(loaded[0][0], dt.as_utc(datetime.datetime(2012, 5, 29, 1, 47, 52)))
        self.assertEquals(loaded[0][1]["bitstampUSD"].getDateTime(), dt.as_utc(datetime.datetime(2012, 5, 29, 1, 47, 52)))
        self.assertEquals(loaded[0][1]["bitstampUSD"].getClose(), 5.07)
        self.assertEquals(loaded[0][1]["bitstampUSD"].getPrice(), 5.07)
        self.assertEquals(loaded[0][1]["bitstampUSD"].getVolume(), 1.39081288)

        self.assertEquals(loaded[-1][0], dt.as_utc(datetime.datetime(2012, 5, 31, 8, 41, 18, 5)))
        self.assertEquals(loaded[-1][1]["bitstampUSD"].getDateTime(), dt.as_utc(datetime.datetime(2012, 5, 31, 8, 41, 18, 5)))
        self.assertEquals(loaded[-1][1]["bitstampUSD"].getClose(), 5.1)
        self.assertEquals(loaded[-1][1]["bitstampUSD"].getPrice(), 5.1)
        self.assertEquals(loaded[-1][1]["bitstampUSD"].getVolume(), 0.39215686)

    def testLoadFilterFromAndTo(self):
        feed = barfeed.CSVTradeFeed()
        feed.addBarsFromCSV(common.get_data_file_path("bitstampUSD.csv"), "bitstampUSD", fromDateTime=dt.as_utc(datetime.datetime(2012, 5, 29)), toDateTime=datetime.datetime(2012, 5, 31))
        loaded = [(dateTime, bars) for dateTime, bars in feed]

        self.assertEquals(len(loaded), 579)

        self.assertEquals(loaded[0][0], dt.as_utc(datetime.datetime(2012, 5, 29, 1, 47, 52)))
        self.assertEquals(loaded[0][1]["bitstampUSD"].getDateTime(), dt.as_utc(datetime.datetime(2012, 5, 29, 1, 47, 52)))
        self.assertEquals(loaded[0][1]["bitstampUSD"].getClose(), 5.07)
        self.assertEquals(loaded[0][1]["bitstampUSD"].getVolume(), 1.39081288)

        self.assertEquals(loaded[-1][0], dt.as_utc(datetime.datetime(2012, 5, 30, 23, 49, 21)))
        self.assertEquals(loaded[-1][1]["bitstampUSD"].getDateTime(), dt.as_utc(datetime.datetime(2012, 5, 30, 23, 49, 21)))
        self.assertEquals(loaded[-1][1]["bitstampUSD"].getClose(), 5.14)
        self.assertEquals(loaded[-1][1]["bitstampUSD"].getVolume(), 20)

########NEW FILE########
__FILENAME__ = common
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import csv
import os
import shutil
import subprocess
import tempfile

from pyalgotrade import dataseries


def run_and_get_output(cmd):
    return subprocess.check_output(cmd, universal_newlines=True, stderr=subprocess.STDOUT)


def run_python_code(code, outputFileName=None):
    cmd = ["python"]
    cmd.append("-u")
    cmd.append("-c")
    cmd.append(code)
    ret = run_and_get_output(cmd)
    if outputFileName:
        outputFile = open(outputFileName, "w")
        outputFile.write(ret)
        outputFile.close()
    return ret


def run_python_script(script, params=[]):
    cmd = ["python"]
    cmd.append("-u")
    cmd.append(script)
    cmd.extend(params)
    return run_and_get_output(cmd)


def run_sample_script(script, params=[]):
    lines = run_python_script(os.path.join("samples", script), params).split("\n")
    # Skip the last, empty line.
    return lines[:-1]


def get_file_lines(fileName):
    rawLines = open(fileName, "r").readlines()
    return [rawLine.strip() for rawLine in rawLines]


def compare_head(fileName, lines):
    assert(len(lines) > 0)
    fileLines = get_file_lines(os.path.join("samples", fileName))
    return fileLines[0:len(lines)] == lines


def compare_tail(fileName, lines):
    assert(len(lines) > 0)
    fileLines = get_file_lines(os.path.join("samples", fileName))
    return fileLines[len(lines)*-1:] == lines


def load_test_csv(path):
    inputSeq = []
    expectedSeq = []
    csvFile = open(path, "r")
    reader = csv.DictReader(csvFile)
    for row in reader:
        inputSeq.append(float(row["Input"]))
        expected = row["Expected"]
        if not expected:
            expected = None
        else:
            expected = float(expected)
        expectedSeq.append(expected)

    return inputSeq, expectedSeq


def normalize_value(value, decimals):
    if value is not None:
        value = round(value, decimals)
    return value


def get_data_file_path(fileName):
    return os.path.join(os.path.split(__file__)[0], "data", fileName)


def test_from_csv(testcase, filename, filterClassBuilder, roundDecimals=2, maxLen=dataseries.DEFAULT_MAX_LEN):
    inputValues, expectedValues = load_test_csv(get_data_file_path(filename))
    inputDS = dataseries.SequenceDataSeries(maxLen=maxLen)
    filterDS = filterClassBuilder(inputDS)
    for i in xrange(len(inputValues)):
        inputDS.append(inputValues[i])
        value = normalize_value(filterDS[i], roundDecimals)
        expectedValue = normalize_value(expectedValues[i], roundDecimals)
        testcase.assertEqual(value, expectedValue)


def init_temp_path():
    storage = get_temp_path()
    if not os.path.exists(storage):
        os.mkdir(storage)


def get_temp_path():
    return "data"


def safe_round(number, ndigits):
    ret = None
    if number is not None:
        ret = round(number, ndigits)
    return ret


class CopyFiles:
    def __init__(self, files, dst):
        self.__files = files
        self.__dst = dst

    def __enter__(self):
        for src in self.__files:
            shutil.copy2(src, self.__dst)

    def __exit__(self, exc_type, exc_val, exc_tb):
        for src in self.__files:
            os.remove(os.path.join(self.__dst, os.path.basename(src)))

class TmpDir(object):
    def __init__(self):
        self.__tmpdir = None

    def __enter__(self):
        self.__tmpdir = tempfile.mkdtemp()
        return self.__tmpdir

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.__tmpdir is not None:
            shutil.rmtree(self.__tmpdir)

########NEW FILE########
__FILENAME__ = csvfeed_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime
import os

from pyalgotrade.feed import csvfeed
from pyalgotrade import dispatcher
from pyalgotrade import marketsession
from pyalgotrade.utils import dt
import common
import feed_test


class TestCase(unittest.TestCase):
    def testBaseFeedInterface(self):
        feed = csvfeed.Feed("Date", "%Y-%m-%d")
        feed.addValuesFromCSV(common.get_data_file_path("orcl-2000-yahoofinance.csv"))
        feed_test.tstBaseFeedInterface(self, feed)

    def testFeedWithBars(self):
        feed = csvfeed.Feed("Date", "%Y-%m-%d")
        feed.addValuesFromCSV(common.get_data_file_path("orcl-2000-yahoofinance.csv"))

        self.assertEqual(len(feed.getKeys()), 6)
        for col in ["Open", "High", "Low", "Close", "Volume", "Adj Close"]:
            self.assertEqual(len(feed[col]), 0)

        disp = dispatcher.Dispatcher()
        disp.addSubject(feed)
        disp.run()

        for col in ["Open", "High", "Low", "Close", "Volume", "Adj Close"]:
            self.assertEqual(len(feed[col]), 252)

        self.assertEqual(feed["Open"][-1], 30.87)
        self.assertEqual(feed["High"][-1], 31.31)
        self.assertEqual(feed["Low"][-1], 28.69)
        self.assertEqual(feed["Close"][-1], 29.06)
        self.assertEqual(feed["Volume"][-1], 31655500)
        self.assertEqual(feed["Adj Close"][-1], 28.41)

    def testFeedWithQuandl(self):
        class RowFilter(csvfeed.RowFilter):
            def includeRow(self, dateTime, values):
                return dateTime.year == 2013

        feed = csvfeed.Feed("Date", "%Y-%m-%d", maxLen=40, timezone=marketsession.USEquities.timezone)
        feed.setRowFilter(RowFilter())
        feed.setTimeDelta(datetime.timedelta(hours=23, minutes=59, seconds=59))
        feed.addValuesFromCSV(os.path.join("samples", "data", "quandl_gold_2.csv"))

        for col in ["USD", "GBP", "EUR"]:
            self.assertEqual(len(feed[col]), 0)

        disp = dispatcher.Dispatcher()
        disp.addSubject(feed)
        disp.run()

        for col in ["USD", "GBP", "EUR"]:
            self.assertEqual(len(feed[col]), 39)

        self.assertEqual(feed["USD"][-1], 1333.0)
        self.assertEqual(feed["GBP"][-1], 831.203)
        self.assertEqual(feed["EUR"][-1], 986.75)
        self.assertFalse(dt.datetime_is_naive(feed["USD"].getDateTimes()[-1]))
        self.assertEqual(feed["USD"].getDateTimes()[-1], dt.localize(datetime.datetime(2013, 9, 29, 23, 59, 59), marketsession.USEquities.timezone))

########NEW FILE########
__FILENAME__ = dataseries_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime

from pyalgotrade import dataseries
from pyalgotrade.dataseries import bards
from pyalgotrade.dataseries import aligned
from pyalgotrade import bar


class TestSequenceDataSeries(unittest.TestCase):
    def testEmpty(self):
        ds = dataseries.SequenceDataSeries()
        self.assertTrue(len(ds) == 0)
        with self.assertRaises(IndexError):
            ds[-1]
        with self.assertRaises(IndexError):
            ds[-2]
        with self.assertRaises(IndexError):
            ds[0]
        with self.assertRaises(IndexError):
            ds[1]

    def testNonEmpty(self):
        ds = dataseries.SequenceDataSeries()
        for value in range(10):
            ds.append(value)
        self.assertTrue(len(ds) == 10)
        self.assertTrue(ds[-1] == 9)
        self.assertTrue(ds[-2] == 8)
        self.assertTrue(ds[0] == 0)
        self.assertTrue(ds[1] == 1)

        self.assertTrue(ds[-1:] == [9])
        self.assertTrue(ds[-2:] == [8, 9])
        self.assertTrue(ds[-2:-1] == [8])
        self.assertTrue(ds[-3:-1] == [7, 8])

        self.assertTrue(ds[1:4] == [1, 2, 3])
        self.assertTrue(ds[9:10] == [9])
        self.assertTrue(ds[9:11] == [9])
        self.assertTrue(ds[9:] == [9])

    def testSeqLikeOps(self):
        seq = range(10)
        ds = dataseries.SequenceDataSeries()
        for value in seq:
            ds.append(value)

        # Test length and every item.
        self.assertEqual(len(ds), len(seq))
        for i in xrange(len(seq)):
            self.assertEqual(ds[i], seq[i])

        # Test negative indices
        self.assertEqual(ds[-1], seq[-1])
        self.assertEqual(ds[-2], seq[-2])
        self.assertEqual(ds[-9], seq[-9])

        # Test slices
        sl = slice(0, 1, 2)
        self.assertEqual(ds[sl], seq[sl])
        sl = slice(0, 9, 2)
        self.assertEqual(ds[sl], seq[sl])
        sl = slice(0, -1, 1)
        self.assertEqual(ds[sl], seq[sl])

        for i in xrange(-100, 100):
            self.assertEqual(ds[i:], seq[i:])

        for step in xrange(1, 10):
            for i in xrange(-100, 100):
                self.assertEqual(ds[i::step], seq[i::step])

    def testBounded(self):
        ds = dataseries.SequenceDataSeries(maxLen=2)
        for i in xrange(100):
            ds.append(i)
            if i > 0:
                self.assertEqual(ds[0], i - 1)
                self.assertEqual(ds[1], i)
        self.assertEqual(len(ds), 2)

    def testResize1(self):
        ds = dataseries.SequenceDataSeries(100)
        for i in xrange(100):
            ds.append(i)

        self.assertEqual(len(ds), 100)
        self.assertEqual(len(ds.getDateTimes()), 100)
        self.assertEqual(ds[0], 0)
        self.assertEqual(ds[-1], 99)

        ds.setMaxLen(2)
        self.assertEqual(len(ds), 2)
        self.assertEqual(len(ds.getDateTimes()), 2)
        self.assertEqual(ds[0], 98)
        self.assertEqual(ds[1], 99)

    def testResize2(self):
        ds = dataseries.SequenceDataSeries()
        for i in xrange(100):
            ds.append(i)

        ds.setMaxLen(1000)
        self.assertEqual(len(ds), 100)
        self.assertEqual(len(ds.getDateTimes()), 100)
        self.assertEqual(ds[0], 0)
        self.assertEqual(ds[-1], 99)

        ds.setMaxLen(10000)
        self.assertEqual(len(ds), 100)
        self.assertEqual(len(ds.getDateTimes()), 100)
        self.assertEqual(ds[0], 0)
        self.assertEqual(ds[-1], 99)

        ds.setMaxLen(10)
        self.assertEqual(len(ds), 10)
        self.assertEqual(len(ds.getDateTimes()), 10)
        self.assertEqual(ds[0], 90)
        self.assertEqual(ds[-1], 99)


class TestBarDataSeries(unittest.TestCase):
    def testEmpty(self):
        ds = bards.BarDataSeries()
        with self.assertRaises(IndexError):
            ds[-1]
        with self.assertRaises(IndexError):
            ds[0]
        with self.assertRaises(IndexError):
            ds[1000]

    def testAppendInvalidDatetime(self):
        ds = bards.BarDataSeries()
        for i in range(10):
            now = datetime.datetime.now() + datetime.timedelta(seconds=i)
            ds.append(bar.BasicBar(now, 0, 0, 0, 0, 0, 0, bar.Frequency.SECOND))
            # Adding the same datetime twice should fail
            self.assertRaises(Exception, ds.append, bar.BasicBar(now, 0, 0, 0, 0, 0, 0, bar.Frequency.SECOND))
            # Adding a previous datetime should fail
            self.assertRaises(Exception, ds.append, bar.BasicBar(now - datetime.timedelta(seconds=i), 0, 0, 0, 0, 0, 0, bar.Frequency.SECOND))

    def testNonEmpty(self):
        ds = bards.BarDataSeries()
        for i in range(10):
            ds.append(bar.BasicBar(datetime.datetime.now() + datetime.timedelta(seconds=i), 0, 0, 0, 0, 0, 0, bar.Frequency.SECOND))

        for i in range(0, 10):
            self.assertTrue(ds[i].getOpen() == 0)

    def __testGetValue(self, ds, itemCount, value):
        for i in range(0, itemCount):
            self.assertTrue(ds[i] == value)

    def testNestedDataSeries(self):
        ds = bards.BarDataSeries()
        for i in range(10):
            ds.append(bar.BasicBar(datetime.datetime.now() + datetime.timedelta(seconds=i), 2, 4, 1, 3, 10, 3, bar.Frequency.SECOND))

        self.__testGetValue(ds.getOpenDataSeries(), 10, 2)
        self.__testGetValue(ds.getCloseDataSeries(), 10, 3)
        self.__testGetValue(ds.getHighDataSeries(), 10, 4)
        self.__testGetValue(ds.getLowDataSeries(), 10, 1)
        self.__testGetValue(ds.getVolumeDataSeries(), 10, 10)
        self.__testGetValue(ds.getAdjCloseDataSeries(), 10, 3)
        self.__testGetValue(ds.getPriceDataSeries(), 10, 3)

    def testSeqLikeOps(self):
        seq = []
        ds = bards.BarDataSeries()
        for i in range(10):
            bar_ = bar.BasicBar(datetime.datetime.now() + datetime.timedelta(seconds=i), 2, 4, 1, 3, 10, 3, bar.Frequency.SECOND)
            ds.append(bar_)
            seq.append(bar_)

        self.assertEqual(ds[-1], seq[-1])
        self.assertEqual(ds[-2], seq[-2])
        self.assertEqual(ds[0], seq[0])
        self.assertEqual(ds[1], seq[1])
        self.assertEqual(ds[-2:][-1], seq[-2:][-1])

    def testDateTimes(self):
        ds = bards.BarDataSeries()
        firstDt = datetime.datetime.now()
        for i in range(10):
            ds.append(bar.BasicBar(firstDt + datetime.timedelta(seconds=i), 2, 4, 1, 3, 10, 3, bar.Frequency.SECOND))

        for i in range(10):
            self.assertEqual(ds[i].getDateTime(), ds.getDateTimes()[i])
            self.assertEqual(ds.getDateTimes()[i], firstDt + datetime.timedelta(seconds=i))


class TestDateAlignedDataSeries(unittest.TestCase):
    def testNotAligned(self):
        size = 20
        ds1 = dataseries.SequenceDataSeries()
        ds2 = dataseries.SequenceDataSeries()
        ads1, ads2 = aligned.datetime_aligned(ds1, ds2)

        now = datetime.datetime.now()
        for i in range(size):
            if i % 2 == 0:
                ds1.appendWithDateTime(now + datetime.timedelta(seconds=i), i)
            else:
                ds2.appendWithDateTime(now + datetime.timedelta(seconds=i), i)

        self.assertEqual(len(ds1), len(ds2))

        for ads in [ads1, ads2]:
            self.assertEqual(len(ads), 0)
            self.assertEqual(ads.getValueAbsolute(0), None)
            self.assertEqual(ads.getDateTimes(), [])

    def testFullyAligned(self):
        size = 20
        ds1 = dataseries.SequenceDataSeries()
        ds2 = dataseries.SequenceDataSeries()
        ads1, ads2 = aligned.datetime_aligned(ds1, ds2)

        now = datetime.datetime.now()
        for i in range(size):
            ds1.appendWithDateTime(now + datetime.timedelta(seconds=i), i)
            ds2.appendWithDateTime(now + datetime.timedelta(seconds=i), i)

        self.assertEqual(len(ds1), len(ds2))

        for ads in [ads1, ads2]:
            self.assertEqual(len(ads), size)
            for i in range(size):
                self.assertEqual(ads.getValueAbsolute(i), i)
                self.assertEqual(ads.getDateTimes()[i], now + datetime.timedelta(seconds=i))

    def testPartiallyAligned(self):
        size = 20
        commonDateTimes = []
        ds1 = dataseries.SequenceDataSeries()
        ds2 = dataseries.SequenceDataSeries()
        ads1, ads2 = aligned.datetime_aligned(ds1, ds2)

        now = datetime.datetime.now()
        for i in range(size):
            if i % 3 == 0:
                commonDateTimes.append(now + datetime.timedelta(seconds=i))
                ds1.appendWithDateTime(now + datetime.timedelta(seconds=i), i)
                ds2.appendWithDateTime(now + datetime.timedelta(seconds=i), i)
            elif i % 2 == 0:
                ds1.appendWithDateTime(now + datetime.timedelta(seconds=i), i)
            else:
                ds2.appendWithDateTime(now + datetime.timedelta(seconds=i), i)

        self.assertEqual(len(ads1), len(ads2))
        self.assertEqual(ads1[:], ads2[:])
        self.assertEqual(ads1.getDateTimes(), commonDateTimes)
        self.assertEqual(ads2.getDateTimes(), commonDateTimes)

    def testIncremental(self):
        size = 20
        ds1 = dataseries.SequenceDataSeries()
        ds2 = dataseries.SequenceDataSeries()
        ads1, ads2 = aligned.datetime_aligned(ds1, ds2)

        now = datetime.datetime.now()
        for i in range(size):
            ds1.appendWithDateTime(now + datetime.timedelta(seconds=i), i)
            ds2.appendWithDateTime(now + datetime.timedelta(seconds=i), i)
            self.assertEqual(len(ads1), len(ads2))
            self.assertEqual(ads1[:], ads2[:])
            self.assertEqual(ads1.getDateTimes()[:], ads2.getDateTimes()[:])

    def testNotAligned_Recursive(self):
        size = 20
        ds1 = dataseries.SequenceDataSeries()
        ds2 = dataseries.SequenceDataSeries()
        ads1, ads2 = aligned.datetime_aligned(ds1, ds2)
        # Align the aligned dataseries again with respect to each other.
        ads1, ads2 = aligned.datetime_aligned(ads1, ads2)

        now = datetime.datetime.now()
        for i in range(size):
            if i % 2 == 0:
                ds1.appendWithDateTime(now + datetime.timedelta(seconds=i), i)
            else:
                ds2.appendWithDateTime(now + datetime.timedelta(seconds=i), i)

        self.assertEqual(len(ds1), len(ds2))

        for ads in [ads1, ads2]:
            self.assertEqual(len(ads), 0)
            self.assertEqual(ads.getValueAbsolute(0), None)
            self.assertEqual(ads.getDateTimes(), [])

    def testFullyAligned_Recursive(self):
        size = 20
        ds1 = dataseries.SequenceDataSeries()
        ds2 = dataseries.SequenceDataSeries()
        ads1, ads2 = aligned.datetime_aligned(ds1, ds2)
        # Align the aligned dataseries again with respect to each other.
        ads1, ads2 = aligned.datetime_aligned(ads1, ads2)

        now = datetime.datetime.now()
        for i in range(size):
            ds1.appendWithDateTime(now + datetime.timedelta(seconds=i), i)
            ds2.appendWithDateTime(now + datetime.timedelta(seconds=i), i)

        self.assertEqual(len(ds1), len(ds2))

        for ads in [ads1, ads2]:
            self.assertEqual(len(ads), size)
            for i in range(size):
                self.assertEqual(ads.getValueAbsolute(i), i)
                self.assertEqual(ads.getDateTimes()[i], now + datetime.timedelta(seconds=i))

    def testPartiallyAligned_Recursive(self):
        size = 20
        commonDateTimes = []
        ds1 = dataseries.SequenceDataSeries()
        ds2 = dataseries.SequenceDataSeries()
        ads1, ads2 = aligned.datetime_aligned(ds1, ds2)
        # Align the aligned dataseries again with respect to each other.
        ads1, ads2 = aligned.datetime_aligned(ads1, ads2)

        now = datetime.datetime.now()
        for i in range(size):
            if i % 3 == 0:
                commonDateTimes.append(now + datetime.timedelta(seconds=i))
                ds1.appendWithDateTime(now + datetime.timedelta(seconds=i), i)
                ds2.appendWithDateTime(now + datetime.timedelta(seconds=i), i)
            elif i % 2 == 0:
                ds1.appendWithDateTime(now + datetime.timedelta(seconds=i), i)
            else:
                ds2.appendWithDateTime(now + datetime.timedelta(seconds=i), i)

        self.assertEqual(len(ads1), len(ads2))
        self.assertEqual(ads1[:], ads2[:])
        self.assertEqual(ads1.getDateTimes(), commonDateTimes)
        self.assertEqual(ads2.getDateTimes(), commonDateTimes)

    def testIncremental_Recursive(self):
        size = 20
        ds1 = dataseries.SequenceDataSeries()
        ds2 = dataseries.SequenceDataSeries()
        ads1, ads2 = aligned.datetime_aligned(ds1, ds2)
        # Align the aligned dataseries again with respect to each other.
        ads1, ads2 = aligned.datetime_aligned(ads1, ads2)

        now = datetime.datetime.now()
        for i in range(size):
            ds1.appendWithDateTime(now + datetime.timedelta(seconds=i), i)
            ds2.appendWithDateTime(now + datetime.timedelta(seconds=i), i)
            self.assertEqual(len(ads1), len(ads2))
            self.assertEqual(ads1[:], ads2[:])
            self.assertEqual(ads1.getDateTimes()[:], ads2.getDateTimes()[:])

    def testBounded(self):
        ds1 = dataseries.SequenceDataSeries()
        ds2 = dataseries.SequenceDataSeries()
        ads1, ads2 = aligned.datetime_aligned(ds1, ds2, 1)

        now = datetime.datetime.now()
        ds1.appendWithDateTime(now + datetime.timedelta(seconds=1), 1)
        ds1.appendWithDateTime(now + datetime.timedelta(seconds=2), 2)
        ds1.appendWithDateTime(now + datetime.timedelta(seconds=3), 3)
        ds2.appendWithDateTime(now + datetime.timedelta(seconds=2), 2)
        ds2.appendWithDateTime(now + datetime.timedelta(seconds=3), 3)
        ds2.appendWithDateTime(now + datetime.timedelta(seconds=4), 4)
        self.assertEqual(ads1[:], [3])
        self.assertEqual(ads2[:], [3])

    def testBoundedSources(self):
        ds1 = dataseries.SequenceDataSeries(1)
        ds2 = dataseries.SequenceDataSeries(1)
        ads1, ads2 = aligned.datetime_aligned(ds1, ds2)

        now = datetime.datetime.now()
        ds1.appendWithDateTime(now + datetime.timedelta(seconds=1), 1)
        ds1.appendWithDateTime(now + datetime.timedelta(seconds=2), 2)
        ds1.appendWithDateTime(now + datetime.timedelta(seconds=3), 3)
        ds2.appendWithDateTime(now + datetime.timedelta(seconds=2), 2)
        ds2.appendWithDateTime(now + datetime.timedelta(seconds=3), 3)
        ds2.appendWithDateTime(now + datetime.timedelta(seconds=4), 4)
        self.assertEqual(ads1[:], [2, 3])
        self.assertEqual(ads2[:], [2, 3])

########NEW FILE########
__FILENAME__ = dbfeed_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import os

from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.barfeed import sqlitefeed
from pyalgotrade import bar
from pyalgotrade import dataseries
from pyalgotrade import marketsession
import common
import feed_test


class TemporarySQLiteFeed:
    def __init__(self, dbFilePath, frequency, maxLen=dataseries.DEFAULT_MAX_LEN):
        if os.path.exists(dbFilePath):
            raise Exception("File exists")

        self.__dbFilePath = dbFilePath
        self.__frequency = frequency
        self.__feed = None
        self.__maxLen = maxLen

    def __enter__(self):
        self.__feed = sqlitefeed.Feed(self.__dbFilePath, self.__frequency, maxLen=self.__maxLen)

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.__feed.getDatabase().disconnect()  # This is for the feed to release the file and get it deleted.
        self.__feed = None
        os.remove(self.__dbFilePath)

    def getFeed(self):
        return self.__feed


class SQLiteFeedTestCase(unittest.TestCase):
    dbName = "SQLiteFeedTestCase.sqlite"

    def testBaseFeedInterface(self):
        tmpFeed = TemporarySQLiteFeed(SQLiteFeedTestCase.dbName, bar.Frequency.DAY)
        with tmpFeed:
            # Load bars using a Yahoo! feed.
            yahooFeed = yahoofeed.Feed()
            yahooFeed.addBarsFromCSV("orcl", common.get_data_file_path("orcl-2000-yahoofinance.csv"), marketsession.USEquities.timezone)
            yahooFeed.addBarsFromCSV("orcl", common.get_data_file_path("orcl-2001-yahoofinance.csv"), marketsession.USEquities.timezone)

            # Fill the database using the bars from the Yahoo! feed.
            sqliteFeed = tmpFeed.getFeed()
            sqliteFeed.getDatabase().addBarsFromFeed(yahooFeed)

            # Load the SQLite feed and process all bars.
            sqliteFeed.loadBars("orcl")
            feed_test.tstBaseFeedInterface(self, sqliteFeed)

    def testLoadDailyBars(self):
        tmpFeed = TemporarySQLiteFeed(SQLiteFeedTestCase.dbName, bar.Frequency.DAY)
        with tmpFeed:
            # Load bars using a Yahoo! feed.
            yahooFeed = yahoofeed.Feed()
            yahooFeed.addBarsFromCSV("orcl", common.get_data_file_path("orcl-2000-yahoofinance.csv"), marketsession.USEquities.timezone)
            yahooFeed.addBarsFromCSV("orcl", common.get_data_file_path("orcl-2001-yahoofinance.csv"), marketsession.USEquities.timezone)

            # Fill the database using the bars from the Yahoo! feed.
            sqliteFeed = tmpFeed.getFeed()
            sqliteFeed.getDatabase().addBarsFromFeed(yahooFeed)

            # Load the SQLite feed and process all bars.
            sqliteFeed.loadBars("orcl")
            for bars in sqliteFeed:
                pass

            # Check that both dataseries have the same bars.
            yahooDS = yahooFeed["orcl"]
            sqliteDS = sqliteFeed["orcl"]
            self.assertEqual(len(yahooDS), len(sqliteDS))
            for i in xrange(len(yahooDS)):
                self.assertEqual(yahooDS[i].getDateTime(), sqliteDS[i].getDateTime())
                self.assertEqual(yahooDS[i].getOpen(), sqliteDS[i].getOpen())
                self.assertEqual(yahooDS[i].getHigh(), sqliteDS[i].getHigh())
                self.assertEqual(yahooDS[i].getLow(), sqliteDS[i].getLow())
                self.assertEqual(yahooDS[i].getClose(), sqliteDS[i].getClose())
                self.assertEqual(yahooDS[i].getAdjClose(), sqliteDS[i].getAdjClose())

    def testBounded(self):
        tmpFeed = TemporarySQLiteFeed(SQLiteFeedTestCase.dbName, bar.Frequency.DAY, maxLen=2)
        with tmpFeed:
            # Load bars using a Yahoo! feed.
            yahooFeed = yahoofeed.Feed(maxLen=1)
            yahooFeed.addBarsFromCSV("orcl", common.get_data_file_path("orcl-2000-yahoofinance.csv"), marketsession.USEquities.timezone)
            yahooFeed.addBarsFromCSV("orcl", common.get_data_file_path("orcl-2001-yahoofinance.csv"), marketsession.USEquities.timezone)

            # Fill the database using the bars from the Yahoo! feed.
            sqliteFeed = tmpFeed.getFeed()
            sqliteFeed.getDatabase().addBarsFromFeed(yahooFeed)

            # Load the SQLite feed and process all bars.
            sqliteFeed.loadBars("orcl")
            for bars in sqliteFeed:
                pass

            barDS = sqliteFeed["orcl"]
            self.assertEqual(len(barDS), 2)
            self.assertEqual(len(barDS.getDateTimes()), 2)
            self.assertEqual(len(barDS.getCloseDataSeries()), 2)
            self.assertEqual(len(barDS.getCloseDataSeries().getDateTimes()), 2)
            self.assertEqual(len(barDS.getOpenDataSeries()), 2)
            self.assertEqual(len(barDS.getHighDataSeries()), 2)
            self.assertEqual(len(barDS.getLowDataSeries()), 2)
            self.assertEqual(len(barDS.getAdjCloseDataSeries()), 2)

########NEW FILE########
__FILENAME__ = doc_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import os

from testcases import common


class DocCodeTest(unittest.TestCase):
    def testTutorial1(self):
        with common.CopyFiles([os.path.join("testcases", "data", "orcl-2000.csv")], "."):
            lines = common.run_sample_script("tutorial-1.py")
            self.assertTrue(common.compare_head("tutorial-1.output", lines[:3]))
            self.assertTrue(common.compare_tail("tutorial-1.output", lines[-3:]))

    def testTutorial2(self):
        with common.CopyFiles([os.path.join("testcases", "data", "orcl-2000.csv")], "."):
            lines = common.run_sample_script("tutorial-2.py")
            self.assertTrue(common.compare_head("tutorial-2.output", lines[:15]))
            self.assertTrue(common.compare_tail("tutorial-2.output", lines[-3:]))

    def testTutorial3(self):
        with common.CopyFiles([os.path.join("testcases", "data", "orcl-2000.csv")], "."):
            lines = common.run_sample_script("tutorial-3.py")
            self.assertTrue(common.compare_head("tutorial-3.output", lines[:30]))
            self.assertTrue(common.compare_tail("tutorial-3.output", lines[-3:]))

    def testTutorial4(self):
        with common.CopyFiles([os.path.join("testcases", "data", "orcl-2000.csv")], "."):
            lines = common.run_sample_script("tutorial-4.py")
            self.assertTrue(common.compare_head("tutorial-4.output", lines))

    def testCSVFeed(self):
        with common.CopyFiles([os.path.join("samples", "data", "quandl_gold_2.csv")], "."):
            code = """import sys
sys.path.append('samples')
import csvfeed_1
"""
            lines = common.run_python_code(code).split("\n")
            self.assertTrue(common.compare_head("csvfeed_1.output", lines[0:10]))
            self.assertTrue(common.compare_tail("csvfeed_1.output", lines[-10:-1]))


class CompInvTestCase(unittest.TestCase):
    def testCompInv_1(self):
        files = [os.path.join("samples", "data", src) for src in ["aeti-2011-yahoofinance.csv", "egan-2011-yahoofinance.csv", "simo-2011-yahoofinance.csv", "glng-2011-yahoofinance.csv"]]
        with common.CopyFiles(files, "."):
            lines = common.run_sample_script("compinv-1.py")
            # Skip the first two lines that have debug messages from the
            # broker.
            self.assertTrue(common.compare_head("compinv-1.output", lines[2:]))


class StratAnalyzerTestCase(unittest.TestCase):
    def testSampleStrategyAnalyzer(self):
        with common.CopyFiles([os.path.join("testcases", "data", "orcl-2000.csv")], "."):
            lines = common.run_sample_script("sample-strategy-analyzer.py")
            self.assertTrue(common.compare_head("sample-strategy-analyzer.output", lines))


class TechnicalTestCase(unittest.TestCase):
    def testTechnical_1(self):
        lines = common.run_sample_script("technical-1.py")
        self.assertTrue(common.compare_head("technical-1.output", lines))


class SampleStratTestCase(unittest.TestCase):
    def testErnieChanGldVsGdx(self):
        files = []
        for year in range(2006, 2013):
            for symbol in ["gld", "gdx"]:
                fileName = "%s-%d-yahoofinance.csv" % (symbol, year)
                files.append(os.path.join("samples", "data", fileName))

        with common.CopyFiles(files, "."):
            code = """import sys
sys.path.append('samples')
import statarb_erniechan
statarb_erniechan.main(False)
"""
            lines = common.run_python_code(code).split("\n")
            self.assertTrue(common.compare_tail("statarb_erniechan.output", lines[-2:-1]))

    def testVWAPMomentum(self):
        files = []
        for year in range(2011, 2013):
            for symbol in ["aapl"]:
                fileName = "%s-%d-yahoofinance.csv" % (symbol, year)
                files.append(os.path.join("samples", "data", fileName))

        with common.CopyFiles(files, "."):
            code = """import sys
sys.path.append('samples')
import vwap_momentum
vwap_momentum.main(False)
"""
            lines = common.run_python_code(code).split("\n")
            self.assertTrue(common.compare_tail("vwap_momentum.output", lines[-2:-1]))

    def testSMACrossOver(self):
        files = []
        for year in range(2011, 2013):
            for symbol in ["aapl"]:
                fileName = "%s-%d-yahoofinance.csv" % (symbol, year)
                files.append(os.path.join("samples", "data", fileName))

        with common.CopyFiles(files, "."):
            code = """import sys
sys.path.append('samples')
import sma_crossover_sample
sma_crossover_sample.main(False)
"""
            lines = common.run_python_code(code).split("\n")
            self.assertTrue(common.compare_tail("sma_crossover.output", lines[-2:-1]))

    def testRSI2(self):
        files = []
        for year in range(2009, 2013):
            for symbol in ["DIA"]:
                fileName = "%s-%d-yahoofinance.csv" % (symbol, year)
                files.append(os.path.join("samples", "data", fileName))

        with common.CopyFiles(files, "."):
            code = """import sys
sys.path.append('samples')
import rsi2_sample
rsi2_sample.main(False)
"""
            lines = common.run_python_code(code).split("\n")
            self.assertTrue(common.compare_tail("rsi2_sample.output", lines[-2:-1]))

    def testBBands(self):
        files = []
        for year in range(2011, 2013):
            for symbol in ["yhoo"]:
                fileName = "%s-%d-yahoofinance.csv" % (symbol, year)
                files.append(os.path.join("samples", "data", fileName))

        with common.CopyFiles(files, "."):
            code = """import sys
sys.path.append('samples')
import bbands
bbands.main(False)
"""
            lines = common.run_python_code(code).split("\n")
            self.assertTrue(common.compare_tail("bbands.output", lines[-2:-1]))

    def testEventStudy(self):
        files = []
        for year in range(2008, 2010):
            for symbol in ["AA", "AES", "AIG"]:
                fileName = "%s-%d-yahoofinance.csv" % (symbol, year)
                files.append(os.path.join("samples", "data", fileName))

        with common.CopyFiles(files, "."):
            code = """import sys
sys.path.append('samples')
import eventstudy
eventstudy.main(False)
"""
            lines = common.run_python_code(code).split("\n")
            self.assertTrue(common.compare_tail("eventstudy.output", lines[-2:-1]))

    def testQuandl(self):
        files = []
        for year in range(2006, 2013):
            for symbol in ["GORO"]:
                fileName = "WIKI-%s-%d-quandl.csv" % (symbol, year)
                files.append(os.path.join("samples", "data", fileName))
        files.append(os.path.join("samples", "data", "quandl_gold_2.csv"))

        with common.CopyFiles(files, "."):
            code = """import sys
sys.path.append('samples')
import quandl_sample
quandl_sample.main(False)
"""
            lines = common.run_python_code(code).split("\n")
            self.assertTrue(common.compare_head("quandl_sample.output", lines[0:10]))
            self.assertTrue(common.compare_tail("quandl_sample.output", lines[-10:-1]))

    def testMarketTiming(self):
        common.init_temp_path()
        files = []
        instruments = ["MSFT", "ORCL", "IBM", "HPQ", "WMT", "UPS", "TGT", "CCL", "XOM", "CVX", "COP", "OXY", "BAC", "JPM", "WFC", "GS", "PG", "PEP", "CL", "KO"]
        for year in range(2005, 2013+1):
            for symbol in instruments:
                fileName = "%s-%d-yahoofinance.csv" % (symbol, year)
                files.append(os.path.join("samples", "data", fileName))

        with common.CopyFiles(files, "data"):
            code = """import sys
sys.path.append('samples')
import market_timing
market_timing.main(False)
"""
            lines = common.run_python_code(code).split("\n")
            self.assertTrue(common.compare_tail("market_timing.output", lines[-10:-1]))

########NEW FILE########
__FILENAME__ = drawdown_analyzer_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.barfeed import membf
from pyalgotrade.stratanalyzer import drawdown
from pyalgotrade import broker
from pyalgotrade import bar

import strategy_test
import common

import unittest
import datetime


def build_bars_from_closing_prices(closingPrices):
    ret = []

    nextDateTime = datetime.datetime.now()
    for closePrice in closingPrices:
        bar_ = bar.BasicBar(nextDateTime, closePrice, closePrice, closePrice, closePrice, closePrice, closePrice, bar.Frequency.DAY)
        ret.append(bar_)
        nextDateTime = nextDateTime + datetime.timedelta(days=1)
    return ret


class TestBarFeed(membf.BarFeed):
    def barsHaveAdjClose(self):
        raise NotImplementedError()


class DDHelperCase(unittest.TestCase):
    def testNoDrawDown1(self):
        helper = drawdown.DrawDownHelper()
        helper.update(datetime.datetime.now(), 10, 10)
        self.assertEqual(helper.getMaxDrawDown(), 0)
        self.assertEqual(helper.getCurrentDrawDown(), 0)
        self.assertEqual(helper.getDuration(), datetime.timedelta())

    def testNoDrawDown2(self):
        helper = drawdown.DrawDownHelper()

        dt = datetime.datetime.now()
        helper.update(dt, 10, 10)
        self.assertEqual(helper.getMaxDrawDown(), 0)
        self.assertEqual(helper.getCurrentDrawDown(), 0)
        self.assertEqual(helper.getDuration(), datetime.timedelta())

        dt += datetime.timedelta(days=1)
        helper.update(dt, 10.01, 10.01)
        self.assertEqual(helper.getMaxDrawDown(), 0)
        self.assertEqual(helper.getCurrentDrawDown(), 0)
        self.assertEqual(helper.getDuration(), datetime.timedelta())

        dt += datetime.timedelta(days=1)
        helper.update(dt, 11, 11)
        self.assertEqual(helper.getMaxDrawDown(), 0)
        self.assertEqual(helper.getCurrentDrawDown(), 0)
        self.assertEqual(helper.getDuration(), datetime.timedelta())

    def testDrawDown1(self):
        helper = drawdown.DrawDownHelper()

        dt = datetime.datetime.now()
        helper.update(dt, 10, 10)
        self.assertEqual(helper.getMaxDrawDown(), 0)
        self.assertEqual(helper.getCurrentDrawDown(), 0)
        self.assertEqual(helper.getDuration(), datetime.timedelta())

        dt += datetime.timedelta(days=1)
        helper.update(dt, 5, 5)
        self.assertEqual(helper.getMaxDrawDown(), -0.5)
        self.assertEqual(helper.getCurrentDrawDown(), -0.5)
        self.assertEqual(helper.getDuration(), datetime.timedelta(days=1))

        dt += datetime.timedelta(days=1)
        helper.update(dt, 4, 4)
        self.assertEqual(helper.getMaxDrawDown(), -0.6)
        self.assertEqual(helper.getCurrentDrawDown(), -0.6)
        self.assertEqual(helper.getDuration(), datetime.timedelta(days=2))

        dt += datetime.timedelta(days=1)
        helper.update(dt, 4, 4)
        self.assertEqual(helper.getMaxDrawDown(), -0.6)
        self.assertEqual(helper.getCurrentDrawDown(), -0.6)
        self.assertEqual(helper.getDuration(), datetime.timedelta(days=3))

        dt += datetime.timedelta(days=1)
        helper.update(dt, 5, 5)
        self.assertEqual(helper.getMaxDrawDown(), -0.6)
        self.assertEqual(helper.getCurrentDrawDown(), -0.5)
        self.assertEqual(helper.getDuration(), datetime.timedelta(days=4))

        dt += datetime.timedelta(days=1)
        helper.update(dt, 9, 9)
        self.assertEqual(helper.getMaxDrawDown(), -0.6)
        self.assertEqual(helper.getCurrentDrawDown(), -0.1)
        self.assertEqual(helper.getDuration(), datetime.timedelta(days=5))

        dt += datetime.timedelta(days=1)
        helper.update(dt, 9.9, 9.9)
        self.assertEqual(helper.getMaxDrawDown(), -0.6)
        self.assertEqual(round(helper.getCurrentDrawDown(), 2), -0.01)
        self.assertEqual(helper.getDuration(), datetime.timedelta(days=6))

    def testDrawDown2(self):
        helper = drawdown.DrawDownHelper()

        dt = datetime.datetime.now()
        helper.update(dt, 10, 10)
        self.assertEqual(helper.getMaxDrawDown(), 0)
        self.assertEqual(helper.getCurrentDrawDown(), 0)
        self.assertEqual(helper.getDuration(), datetime.timedelta())

        dt += datetime.timedelta(minutes=1)
        helper.update(dt, 5, 5)
        self.assertEqual(helper.getMaxDrawDown(), -0.5)
        self.assertEqual(helper.getCurrentDrawDown(), -0.5)
        self.assertEqual(helper.getDuration(), datetime.timedelta(minutes=1))

        dt += datetime.timedelta(minutes=1)
        helper.update(dt, 4, 4)
        self.assertEqual(helper.getMaxDrawDown(), -0.6)
        self.assertEqual(helper.getCurrentDrawDown(), -0.6)
        self.assertEqual(helper.getDuration(), datetime.timedelta(minutes=2))

        dt += datetime.timedelta(minutes=1)
        helper.update(dt, 4, 4)
        self.assertEqual(helper.getMaxDrawDown(), -0.6)
        self.assertEqual(helper.getCurrentDrawDown(), -0.6)
        self.assertEqual(helper.getDuration(), datetime.timedelta(minutes=3))

        dt += datetime.timedelta(minutes=1)
        helper.update(dt, 5, 5)
        self.assertEqual(helper.getMaxDrawDown(), -0.6)
        self.assertEqual(helper.getCurrentDrawDown(), -0.5)
        self.assertEqual(helper.getDuration(), datetime.timedelta(minutes=4))

        dt += datetime.timedelta(minutes=1)
        helper.update(dt, 9, 9)
        self.assertEqual(helper.getMaxDrawDown(), -0.6)
        self.assertEqual(helper.getCurrentDrawDown(), -0.1)
        self.assertEqual(helper.getDuration(), datetime.timedelta(minutes=5))

        dt += datetime.timedelta(minutes=1)
        helper.update(dt, 9.9, 9.9)
        self.assertEqual(helper.getMaxDrawDown(), -0.6)
        self.assertEqual(round(helper.getCurrentDrawDown(), 2), -0.01)
        self.assertEqual(helper.getDuration(), datetime.timedelta(minutes=6))

        dt += datetime.timedelta(minutes=1)
        helper.update(dt, 20, 20)
        self.assertEqual(helper.getMaxDrawDown(), 0)
        self.assertEqual(helper.getCurrentDrawDown(), 0)
        self.assertEqual(helper.getDuration(), datetime.timedelta())

        dt += datetime.timedelta(minutes=1)
        helper.update(dt, 10, 10)
        self.assertEqual(helper.getMaxDrawDown(), -0.5)
        self.assertEqual(helper.getCurrentDrawDown(), -0.5)
        self.assertEqual(helper.getDuration(), datetime.timedelta(minutes=1))


class AnalyzerTestCase(unittest.TestCase):
    def testNoTrades(self):
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV("ige", common.get_data_file_path("sharpe-ratio-test-ige.csv"))
        barFeed.addBarsFromCSV("spy", common.get_data_file_path("sharpe-ratio-test-spy.csv"))
        strat = strategy_test.TestStrategy(barFeed, 1000)
        strat.setBrokerOrdersGTC(True)
        strat.setUseAdjustedValues(True)
        stratAnalyzer = drawdown.DrawDown()
        strat.attachAnalyzer(stratAnalyzer)

        strat.run()
        self.assertTrue(strat.getBroker().getCash() == 1000)
        self.assertEqual(strat.orderUpdatedCalls, 0)
        self.assertTrue(stratAnalyzer.getMaxDrawDown() == 0)
        self.assertTrue(stratAnalyzer.getLongestDrawDownDuration() == datetime.timedelta())

    def __testIGE_BrokerImpl(self, quantity):
        initialCash = 42.09*quantity
        # This testcase is based on an example from Ernie Chan's book:
        # 'Quantitative Trading: How to Build Your Own Algorithmic Trading Business'
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV("ige", common.get_data_file_path("sharpe-ratio-test-ige.csv"))
        strat = strategy_test.TestStrategy(barFeed, initialCash)
        strat.setUseAdjustedValues(True)
        strat.setBrokerOrdersGTC(True)
        stratAnalyzer = drawdown.DrawDown()
        strat.attachAnalyzer(stratAnalyzer)

        # Disable volume checks to match book results.
        strat.getBroker().getFillStrategy().setVolumeLimit(None)

        # Manually place the order to get it filled on the first bar.
        order = strat.getBroker().createMarketOrder(broker.Order.Action.BUY, "ige", quantity, True)  # Adj. Close: 42.09
        order.setGoodTillCanceled(True)
        strat.getBroker().placeOrder(order)
        strat.addOrder(datetime.datetime(2007, 11, 13), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, "ige", quantity, True)  # Adj. Close: 127.64
        strat.run()

        self.assertTrue(round(strat.getBroker().getCash(), 2) == initialCash + (127.64 - 42.09) * quantity)
        self.assertEqual(strat.orderUpdatedCalls, 4)
        self.assertTrue(round(stratAnalyzer.getMaxDrawDown(), 5) == 0.31178)
        self.assertTrue(stratAnalyzer.getLongestDrawDownDuration() == datetime.timedelta(days=623))

    def testIGE_Broker(self):
        self.__testIGE_BrokerImpl(1)

    def testIGE_Broker2(self):
        self.__testIGE_BrokerImpl(2)

    def __testManualImpl(self, closingPrices, cash):
        barFeed = TestBarFeed(bar.Frequency.DAY)
        bars = build_bars_from_closing_prices(closingPrices)
        barFeed.addBarsFromSequence("orcl", bars)

        strat = strategy_test.TestStrategy(barFeed, cash)
        stratAnalyzer = drawdown.DrawDown()
        strat.attachAnalyzer(stratAnalyzer)

        # Manually place the order to get it filled on the first bar.
        order = strat.getBroker().createMarketOrder(broker.Order.Action.BUY, "orcl", 1, True)
        order.setGoodTillCanceled(True)
        strat.getBroker().placeOrder(order)

        strat.run()
        return stratAnalyzer

    def testManual_NoDD(self):
        # No drawdown
        stratAnalyzer = self.__testManualImpl([10, 10, 10], 10)
        self.assertEqual(round(stratAnalyzer.getMaxDrawDown(), 2), 0)
        self.assertEqual(stratAnalyzer.getLongestDrawDownDuration(), datetime.timedelta())

    def testManual_1DD(self):
        stratAnalyzer = self.__testManualImpl([10, 9, 8], 10)
        self.assertEqual(round(stratAnalyzer.getMaxDrawDown(), 2), 0.2)
        self.assertEqual(stratAnalyzer.getLongestDrawDownDuration(), datetime.timedelta(days=2))

    def testManual_2DD(self):
        stratAnalyzer = self.__testManualImpl([10, 9.5, 9, 8, 11, 8], 10)
        self.assertEqual(round(stratAnalyzer.getMaxDrawDown(), 2), 0.27)
        self.assertEqual(stratAnalyzer.getLongestDrawDownDuration(), datetime.timedelta(days=3))

########NEW FILE########
__FILENAME__ = eventprofiler_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime
from pyalgotrade import eventprofiler
from pyalgotrade.barfeed import yahoofeed
import common


class Predicate(eventprofiler.Predicate):
    def __init__(self, eventDates):
        self.__dates = eventDates

    def eventOccurred(self, instrument, bards):
        ret = False
        if bards[-1].getDateTime().date() in self.__dates:
            ret = True
        return ret


class EventProfilerTestCase(unittest.TestCase):
    def testNoEvents(self):
        feed = yahoofeed.Feed()
        feed.addBarsFromCSV("orcl", common.get_data_file_path("orcl-2000-yahoofinance.csv"))

        predicate = Predicate([])
        eventProfiler = eventprofiler.Profiler(predicate, 5, 5)
        eventProfiler.run(feed, True)
        self.assertEqual(eventProfiler.getResults().getEventCount(), 0)

    def testEventsOnBoundary(self):
        feed = yahoofeed.Feed()
        feed.addBarsFromCSV("orcl", common.get_data_file_path("orcl-2000-yahoofinance.csv"))

        dates = []
        dates.append(datetime.date(2000, 1, 3))
        dates.append(datetime.date(2000, 1, 4))
        dates.append(datetime.date(2000, 1, 5))
        dates.append(datetime.date(2000, 1, 6))
        dates.append(datetime.date(2000, 1, 7))
        dates.append(datetime.date(2000, 1, 10))
        dates.append(datetime.date(2000, 12, 22))
        dates.append(datetime.date(2000, 12, 26))
        dates.append(datetime.date(2000, 12, 27))
        dates.append(datetime.date(2000, 12, 28))
        dates.append(datetime.date(2000, 12, 29))
        predicate = Predicate(dates)
        eventProfiler = eventprofiler.Profiler(predicate, 5, 5)
        eventProfiler.run(feed, True)
        self.assertEqual(eventProfiler.getResults().getEventCount(), 0)

    def testOneEvent(self):
        feed = yahoofeed.Feed()
        feed.addBarsFromCSV("orcl", common.get_data_file_path("orcl-2000-yahoofinance.csv"))

        predicate = Predicate([datetime.date(2000, 1, 11)])
        eventProfiler = eventprofiler.Profiler(predicate, 5, 5)
        eventProfiler.run(feed, True)
        self.assertEqual(eventProfiler.getResults().getEventCount(), 1)
        self.assertEqual(eventProfiler.getResults().getValues(0)[0], 1.0)
        self.assertEqual(round(eventProfiler.getResults().getValues(5)[0], 5), round(1.016745541, 5))

########NEW FILE########
__FILENAME__ = feed_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import dispatcher


# This will test both the feed and subject interface.
def tstBaseFeedInterface(testCase, feed):
    # This tests the observer.Subject interface.
    disp = dispatcher.Dispatcher()
    disp.addSubject(feed)
    disp.run()

    # This tests the feed.BaseFeed interface.
    feed.isRealTime()
    feed.createDataSeries("any", 10)
    feed.getNextValues()

########NEW FILE########
__FILENAME__ = logger_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime
from testcases import common


class TestCase(unittest.TestCase):
    # Check that strategy and custom logs have the proper datetime, this is, the bars date time.
    def testBacktestingLog1(self):
            code = """from testcases import logger_test_1
logger_test_1.main()
"""
            lines = common.run_python_code(code).split("\n")
            expectedLines = [
                "2000-01-01 00:00:00 strategy [INFO] bla",
                "2000-01-01 00:00:00 custom [INFO] ble",
                "",
            ]
            self.assertEqual(lines, expectedLines)

    # Check that strategy and custom logs have the proper datetime, this is, the bars date time.
    def testBacktestingLog2(self):
            code = """from testcases import logger_test_2
logger_test_2.main()
"""
            lines = common.run_python_code(code).split("\n")
            self.assertEqual(len(lines), 4)
            self.assertEqual(lines[0], "2000-01-01 00:00:00 strategy [INFO] bla")
            self.assertEqual(lines[1], "2000-01-02 00:00:00 broker.backtesting [DEBUG] Not enough cash to fill orcl order [1] for 1 share/s")
            self.assertEqual(lines[2], "2000-01-02 00:00:00 strategy [INFO] bla")
            self.assertEqual(lines[3], "")

    # Check that strategy and custom logs have the proper datetime, this is, the current date.
    def testNonBacktestingLog3(self):
            code = """from testcases import logger_test_3
logger_test_3.main()
"""
            lines = common.run_python_code(code).split("\n")

            now = datetime.datetime.now()
            self.assertEqual(len(lines), 3)
            for line in lines[:-1]:
                self.assertEqual(line.find(str(now.date())), 0)
            self.assertNotEqual(lines[0].find("strategy [INFO] bla"), -1)
            self.assertNotEqual(lines[1].find("custom [INFO] ble"), -1)

########NEW FILE########
__FILENAME__ = logger_test_1
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import datetime
from pyalgotrade import strategy
from pyalgotrade import bar
from pyalgotrade import logger
from pyalgotrade.barfeed import membf


class TestBarFeed(membf.BarFeed):
    def barsHaveAdjClose(self):
        raise NotImplementedError()


class BacktestingStrategy(strategy.BacktestingStrategy):
    def __init__(self, barFeed, cash):
        strategy.BacktestingStrategy.__init__(self, barFeed, cash)

    def onBars(self, bars):
        self.info("bla")
        logger.getLogger("custom").info("ble")


def main():
    bf = TestBarFeed(bar.Frequency.DAY)
    bars = [
        bar.BasicBar(datetime.datetime(2000, 1, 1), 10, 10, 10, 10, 10, 10, bar.Frequency.DAY),
        ]
    bf.addBarsFromSequence("orcl", bars)

    strat = BacktestingStrategy(bf, 1000)
    strat.run()

########NEW FILE########
__FILENAME__ = logger_test_2
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import datetime
from pyalgotrade import strategy
from pyalgotrade import bar
from pyalgotrade import logger
from pyalgotrade.barfeed import membf
import logging


class TestBarFeed(membf.BarFeed):
    def barsHaveAdjClose(self):
        raise NotImplementedError()


class BacktestingStrategy(strategy.BacktestingStrategy):
    def __init__(self, barFeed, cash):
        strategy.BacktestingStrategy.__init__(self, barFeed, cash)

    def onBars(self, bars):
        self.info("bla")
        self.marketOrder("orcl", 1)


def main():
    bf = TestBarFeed(bar.Frequency.DAY)
    bars = [
        bar.BasicBar(datetime.datetime(2000, 1, 1), 10, 10, 10, 10, 10, 10, bar.Frequency.DAY),
        bar.BasicBar(datetime.datetime(2000, 1, 2), 10, 10, 10, 10, 10, 10, bar.Frequency.DAY),
        ]
    bf.addBarsFromSequence("orcl", bars)

    logger.getLogger().setLevel(logging.DEBUG)
    strat = BacktestingStrategy(bf, 1)
    strat.run()

########NEW FILE########
__FILENAME__ = logger_test_3
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import datetime
from pyalgotrade import strategy
from pyalgotrade.broker import backtesting
from pyalgotrade import bar
from pyalgotrade import logger
from pyalgotrade.barfeed import membf


class TestBarFeed(membf.BarFeed):
    def barsHaveAdjClose(self):
        raise NotImplementedError()


class Strategy(strategy.BaseStrategy):
    def __init__(self, barFeed, cash):
        strategy.BaseStrategy.__init__(self, barFeed, backtesting.Broker(cash, barFeed))

    def onBars(self, bars):
        self.info("bla")
        logger.getLogger("custom").info("ble")


def main():
    bf = TestBarFeed(bar.Frequency.DAY)
    bars = [
        bar.BasicBar(datetime.datetime(2000, 1, 1), 10, 10, 10, 10, 10, 10, bar.Frequency.DAY),
        ]
    bf.addBarsFromSequence("orcl", bars)

    strat = Strategy(bf, 1000)
    strat.run()

########NEW FILE########
__FILENAME__ = memfeed_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime

from pyalgotrade.feed import memfeed
from pyalgotrade import dispatcher
import feed_test


class MemFeedTestCase(unittest.TestCase):
    def testBaseFeedInterface(self):
        values = [(datetime.datetime.now() + datetime.timedelta(seconds=i), {"i": i}) for i in xrange(100)]
        feed = memfeed.MemFeed()
        feed.addValues(values)
        feed_test.tstBaseFeedInterface(self, feed)

    def testFeed(self):
        values = [(datetime.datetime.now() + datetime.timedelta(seconds=i), {"i": i}) for i in xrange(100)]

        feed = memfeed.MemFeed()
        feed.addValues(values)

        # Check that the dataseries are available after adding values.
        self.assertTrue("i" in feed)
        self.assertEqual(len(feed["i"]), 0)
        self.assertFalse("dt" in feed)

        disp = dispatcher.Dispatcher()
        disp.addSubject(feed)
        disp.run()

        self.assertTrue("i" in feed)
        self.assertFalse("dt" in feed)
        self.assertEqual(feed["i"][0], 0)
        self.assertEqual(feed["i"][-1], 99)

########NEW FILE########
__FILENAME__ = multi_instrument_strategy_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest

from pyalgotrade import bar
from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.barfeed import sqlitefeed
from pyalgotrade import marketsession
from pyalgotrade import strategy
from pyalgotrade.technical import ma
from pyalgotrade.technical import cross
import common


class NikkeiSpyStrategy(strategy.BacktestingStrategy):
    def __init__(self, feed, smaPeriod):
        strategy.BacktestingStrategy.__init__(self, feed)

        assert(smaPeriod > 3)
        self.__lead = "^n225"
        self.__lag = "spy"
        self.__adjClose = feed[self.__lead].getAdjCloseDataSeries()
        # Exit signal is more sensitive than entry.
        self.__fastSMA = ma.SMA(self.__adjClose, int(smaPeriod/2))
        self.__slowSMA = ma.SMA(self.__adjClose, smaPeriod)
        self.__pos = None

    def onEnterCanceled(self, position):
        assert(position == self.__pos)
        self.__pos = None

    def onExitOk(self, position):
        assert(position == self.__pos)
        self.__pos = None

    def __calculatePosSize(self):
        cash = self.getBroker().getCash()
        lastPrice = self.getFeed()[self.__lag][-1].getClose()
        ret = cash / lastPrice
        return int(ret)

    def onBars(self, bars):
        if bars.getBar(self.__lead):
            if cross.cross_above(self.__adjClose, self.__slowSMA) == 1 and self.__pos is None:
                shares = self.__calculatePosSize()
                if shares:
                    self.__pos = self.enterLong(self.__lag, shares)
            elif cross.cross_below(self.__adjClose, self.__fastSMA) == 1 and self.__pos is not None:
                self.__pos.exit()


class TestCase(unittest.TestCase):
    def __testDifferentTimezonesImpl(self, feed):
        self.assertTrue("^n225" in feed)
        self.assertTrue("spy" in feed)
        self.assertTrue("cacho" not in feed)
        strat = NikkeiSpyStrategy(feed, 34)
        strat.run()
        self.assertEqual(round(strat.getResult(), 2), 1033854.48)

    def testDifferentTimezones(self):
        # Market times in UTC:
        # - TSE: 0hs ~ 6hs
        # - US: 14:30hs ~ 21hs
        feed = yahoofeed.Feed()
        for year in [2010, 2011]:
            feed.addBarsFromCSV("^n225", common.get_data_file_path("nikkei-%d-yahoofinance.csv" % year), marketsession.TSE.getTimezone())
            feed.addBarsFromCSV("spy", common.get_data_file_path("spy-%d-yahoofinance.csv" % year), marketsession.USEquities.getTimezone())

        self.__testDifferentTimezonesImpl(feed)

    def testDifferentTimezones_DBFeed(self):
        feed = sqlitefeed.Feed(common.get_data_file_path("multiinstrument.sqlite"), bar.Frequency.DAY)
        feed.loadBars("^n225")
        feed.loadBars("spy")
        self.__testDifferentTimezonesImpl(feed)

    def testDifferentTimezones_DBFeed_LocalizedBars(self):
        feed = sqlitefeed.Feed(common.get_data_file_path("multiinstrument.sqlite"), bar.Frequency.DAY)
        feed.loadBars("^n225", marketsession.TSE.getTimezone())
        feed.loadBars("spy", marketsession.USEquities.getTimezone())
        self.__testDifferentTimezonesImpl(feed)

########NEW FILE########
__FILENAME__ = ninjatraderfeed_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime

import common
import barfeed_test
import feed_test

from pyalgotrade.barfeed import ninjatraderfeed
from pyalgotrade import marketsession
from pyalgotrade import bar
from pyalgotrade.utils import dt


class NinjaTraderTestCase(unittest.TestCase):
    def __loadIntradayBarFeed(self, timeZone=None):
        ret = ninjatraderfeed.Feed(ninjatraderfeed.Frequency.MINUTE, timeZone)
        ret.addBarsFromCSV("spy", common.get_data_file_path("nt-spy-minute-2011.csv"))
        ret.loadAll()
        return ret

    def testBaseFeedInterface(self):
        barFeed = ninjatraderfeed.Feed(ninjatraderfeed.Frequency.MINUTE)
        barFeed.addBarsFromCSV("spy", common.get_data_file_path("nt-spy-minute-2011.csv"))
        feed_test.tstBaseFeedInterface(self, barFeed)

    def testWithTimezone(self):
        timeZone = marketsession.USEquities.getTimezone()
        barFeed = self.__loadIntradayBarFeed(timeZone)
        ds = barFeed.getDataSeries()

        for i, currentBar in enumerate(ds):
            self.assertFalse(dt.datetime_is_naive(currentBar.getDateTime()))
            self.assertEqual(ds[i].getDateTime(), ds.getDateTimes()[i])

    def testWithoutTimezone(self):
        barFeed = self.__loadIntradayBarFeed(None)
        ds = barFeed.getDataSeries()

        for i, currentBar in enumerate(ds):
            # Datetime must be set to UTC.
            self.assertFalse(dt.datetime_is_naive(currentBar.getDateTime()))
            self.assertEqual(ds[i].getDateTime(), ds.getDateTimes()[i])

    def testWithIntegerTimezone(self):
        try:
            barFeed = ninjatraderfeed.Feed(ninjatraderfeed.Frequency.MINUTE, -3)
            self.assertTrue(False, "Exception expected")
        except Exception, e:
            self.assertTrue(str(e).find("timezone as an int parameter is not supported anymore") == 0)

        try:
            barFeed = ninjatraderfeed.Feed(ninjatraderfeed.Frequency.MINUTE)
            barFeed.addBarsFromCSV("spy", common.get_data_file_path("nt-spy-minute-2011.csv"), -5)
            self.assertTrue(False, "Exception expected")
        except Exception, e:
            self.assertTrue(str(e).find("timezone as an int parameter is not supported anymore") == 0)

    def testLocalizeAndFilter(self):
        timezone = marketsession.USEquities.getTimezone()
        # The prices come from NinjaTrader interface when set to use 'US Equities RTH' session template.
        prices = {
            dt.localize(datetime.datetime(2011, 3, 9, 9, 31), timezone): 132.35,
            dt.localize(datetime.datetime(2011, 3, 9, 16), timezone): 132.39,
            dt.localize(datetime.datetime(2011, 3, 10, 9, 31), timezone): 130.81,
            dt.localize(datetime.datetime(2011, 3, 10, 16), timezone): 129.92,
            dt.localize(datetime.datetime(2011, 3, 11, 9, 31), timezone): 129.72,
            dt.localize(datetime.datetime(2011, 3, 11, 16), timezone): 130.84,
        }
        barFeed = ninjatraderfeed.Feed(ninjatraderfeed.Frequency.MINUTE, timezone)
        barFeed.addBarsFromCSV("spy", common.get_data_file_path("nt-spy-minute-2011-03.csv"))
        for dateTime, bars in barFeed:
            price = prices.get(bars.getDateTime(), None)
            if price is not None:
                self.assertTrue(price == bars.getBar("spy").getClose())

    def testBounded(self):
        barFeed = ninjatraderfeed.Feed(ninjatraderfeed.Frequency.MINUTE, maxLen=2)
        barFeed.addBarsFromCSV("spy", common.get_data_file_path("nt-spy-minute-2011-03.csv"))
        barFeed.loadAll()

        barDS = barFeed["spy"]
        self.assertEqual(len(barDS), 2)
        self.assertEqual(len(barDS.getDateTimes()), 2)
        self.assertEqual(len(barDS.getCloseDataSeries()), 2)
        self.assertEqual(len(barDS.getCloseDataSeries().getDateTimes()), 2)
        self.assertEqual(len(barDS.getOpenDataSeries()), 2)
        self.assertEqual(len(barDS.getHighDataSeries()), 2)
        self.assertEqual(len(barDS.getLowDataSeries()), 2)
        self.assertEqual(len(barDS.getAdjCloseDataSeries()), 2)

    def testBaseBarFeed(self):
        barFeed = ninjatraderfeed.Feed(ninjatraderfeed.Frequency.MINUTE)
        barFeed.addBarsFromCSV("spy", common.get_data_file_path("nt-spy-minute-2011.csv"))
        barfeed_test.check_base_barfeed(self, barFeed, False, False)

    def testInvalidFrequency(self):
        with self.assertRaisesRegexp(Exception, "Invalid frequency.*"):
            ninjatraderfeed.Feed(bar.Frequency.WEEK)

########NEW FILE########
__FILENAME__ = observer_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime
import copy

from pyalgotrade import observer
from pyalgotrade import dispatcher


class NonRealtimeFeed(observer.Subject):
    def __init__(self, datetimes, priority=None):
        self.__datetimes = datetimes
        self.__event = observer.Event()
        self.__priority = priority

    def getEvent(self):
        return self.__event

    def start(self):
        pass

    def stop(self):
        pass

    def join(self):
        pass

    def eof(self):
        return len(self.__datetimes) == 0

    def dispatch(self):
        ret = True
        self.__event.emit(self.__datetimes.pop(0))
        return ret

    def peekDateTime(self):
        return self.__datetimes[0]

    def getDispatchPriority(self):
        return self.__priority


class RealtimeFeed(observer.Subject):
    def __init__(self, datetimes, priority=None):
        self.__datetimes = datetimes
        self.__event = observer.Event()
        self.__priority = priority

    def getEvent(self):
        return self.__event

    def start(self):
        pass

    def stop(self):
        pass

    def join(self):
        pass

    def eof(self):
        return len(self.__datetimes) == 0

    def dispatch(self):
        ret = True
        self.__event.emit(self.__datetimes.pop(0))
        return ret

    def peekDateTime(self):
        return None

    def getDispatchPriority(self):
        return self.__priority


class DispatcherTestCase(unittest.TestCase):
    def test1NrtFeed(self):
        values = []
        now = datetime.datetime.now()
        datetimes = [now + datetime.timedelta(seconds=i) for i in xrange(10)]
        nrtFeed = NonRealtimeFeed(copy.copy(datetimes))
        nrtFeed.getEvent().subscribe(lambda x: values.append(x))

        disp = dispatcher.Dispatcher()
        disp.addSubject(nrtFeed)
        disp.run()

        self.assertEqual(values, datetimes)

    def test2NrtFeeds(self):
        values = []
        now = datetime.datetime.now()
        datetimes1 = [now + datetime.timedelta(seconds=i) for i in xrange(10)]
        datetimes2 = [now + datetime.timedelta(seconds=i+len(datetimes1)) for i in xrange(10)]
        nrtFeed1 = NonRealtimeFeed(copy.copy(datetimes1))
        nrtFeed1.getEvent().subscribe(lambda x: values.append(x))
        nrtFeed2 = NonRealtimeFeed(copy.copy(datetimes2))
        nrtFeed2.getEvent().subscribe(lambda x: values.append(x))

        disp = dispatcher.Dispatcher()
        disp.addSubject(nrtFeed1)
        disp.addSubject(nrtFeed2)
        disp.run()

        self.assertEqual(len(values), len(datetimes1) + len(datetimes2))
        self.assertEqual(values[:len(datetimes1)], datetimes1)
        self.assertEqual(values[len(datetimes1):], datetimes2)

    def test1RtFeed(self):
        values = []
        now = datetime.datetime.now()
        datetimes = [now + datetime.timedelta(seconds=i) for i in xrange(10)]
        nrtFeed = RealtimeFeed(copy.copy(datetimes))
        nrtFeed.getEvent().subscribe(lambda x: values.append(x))

        disp = dispatcher.Dispatcher()
        disp.addSubject(nrtFeed)
        disp.run()

        self.assertEqual(values, datetimes)

    def test2RtFeeds(self):
        values = []
        now = datetime.datetime.now()
        datetimes1 = [now + datetime.timedelta(seconds=i) for i in xrange(10)]
        datetimes2 = [now + datetime.timedelta(seconds=i+len(datetimes1)) for i in xrange(10)]
        nrtFeed1 = RealtimeFeed(copy.copy(datetimes1))
        nrtFeed1.getEvent().subscribe(lambda x: values.append(x))
        nrtFeed2 = RealtimeFeed(copy.copy(datetimes2))
        nrtFeed2.getEvent().subscribe(lambda x: values.append(x))

        disp = dispatcher.Dispatcher()
        disp.addSubject(nrtFeed1)
        disp.addSubject(nrtFeed2)
        disp.run()

        self.assertEqual(len(values), len(datetimes1) + len(datetimes2))
        for i in xrange(len(datetimes1)):
            self.assertEqual(values[i*2], datetimes1[i])
            self.assertEqual(values[i*2+1], datetimes2[i])

    def test2Combined(self):
        values = []
        now = datetime.datetime.now()
        datetimes1 = [now + datetime.timedelta(seconds=i) for i in xrange(10)]
        datetimes2 = [now + datetime.timedelta(seconds=i+len(datetimes1)) for i in xrange(10)]
        nrtFeed1 = RealtimeFeed(copy.copy(datetimes1))
        nrtFeed1.getEvent().subscribe(lambda x: values.append(x))
        nrtFeed2 = NonRealtimeFeed(copy.copy(datetimes2))
        nrtFeed2.getEvent().subscribe(lambda x: values.append(x))

        disp = dispatcher.Dispatcher()
        disp.addSubject(nrtFeed1)
        disp.addSubject(nrtFeed2)
        disp.run()

        self.assertEqual(len(values), len(datetimes1) + len(datetimes2))
        for i in xrange(len(datetimes1)):
            self.assertEqual(values[i*2], datetimes1[i])
            self.assertEqual(values[i*2+1], datetimes2[i])

    def testPriority(self):
        feed4 = RealtimeFeed([], None)
        feed3 = RealtimeFeed([], None)
        feed2 = RealtimeFeed([], 3)
        feed1 = RealtimeFeed([], 0)

        disp = dispatcher.Dispatcher()
        disp.addSubject(feed3)
        disp.addSubject(feed2)
        disp.addSubject(feed1)
        self.assertEqual(disp.getSubjects(), [feed1, feed2, feed3])

        disp = dispatcher.Dispatcher()
        disp.addSubject(feed1)
        disp.addSubject(feed2)
        disp.addSubject(feed3)
        self.assertEqual(disp.getSubjects(), [feed1, feed2, feed3])

        disp = dispatcher.Dispatcher()
        disp.addSubject(feed3)
        disp.addSubject(feed4)
        disp.addSubject(feed2)
        disp.addSubject(feed1)
        self.assertEqual(disp.getSubjects(), [feed1, feed2, feed3, feed4])

    def testDispatchOrder(self):
        values = []
        now = datetime.datetime.now()
        feed1 = NonRealtimeFeed([now], 0)
        feed2 = RealtimeFeed([now + datetime.timedelta(seconds=1)], None)
        feed1.getEvent().subscribe(lambda x: values.append(x))
        feed2.getEvent().subscribe(lambda x: values.append(x))

        disp = dispatcher.Dispatcher()
        disp.addSubject(feed2)
        disp.addSubject(feed1)
        self.assertEqual(disp.getSubjects(), [feed1, feed2])
        disp.run()
        # Check that although feed2 is realtime, feed1 was dispatched before.
        self.assertTrue(values[0] < values[1])


class EventTestCase(unittest.TestCase):
    def testEmitOrder(self):
        handlersData = []

        def handler3():
            handlersData.append(3)

        def handler1():
            handlersData.append(1)

        def handler2():
            handlersData.append(2)

        event = observer.Event()
        event.subscribe(handler1)
        event.subscribe(handler2)
        event.subscribe(handler3)
        event.emit()
        self.assertTrue(handlersData == [1, 2, 3])

        handlersData = []
        event = observer.Event()
        event.subscribe(handler3)
        event.subscribe(handler2)
        event.subscribe(handler1)
        event.emit()
        self.assertTrue(handlersData == [3, 2, 1])

    def testDuplicateHandlers(self):
        def handler1():
            handlersData.append(1)

        handlersData = []
        event = observer.Event()
        event.subscribe(handler1)
        event.subscribe(handler1)
        event.emit()
        self.assertTrue(handlersData == [1])

    def testReentrancy(self):
        handlersData = []
        event = observer.Event()

        def handler2():
            handlersData.append(2)

        def handler1():
            handlersData.append(1)
            event.subscribe(handler2)
            event.subscribe(handler1)

        event.subscribe(handler1)
        event.emit()
        self.assertTrue(handlersData == [1])
        event.emit()
        self.assertTrue(handlersData == [1, 1, 2])
        event.unsubscribe(handler1)
        event.emit()
        self.assertTrue(handlersData == [1, 1, 2, 2])
        event.unsubscribe(handler2)
        event.emit()
        self.assertTrue(handlersData == [1, 1, 2, 2])

########NEW FILE########
__FILENAME__ = optimizer_testcase
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import sys

import common

from pyalgotrade.optimizer import local
from pyalgotrade.barfeed import yahoofeed

sys.path.append("samples")
import sma_crossover


def parameters_generator(instrument, smaFirst, smaLast):
    for sma in range(smaFirst, smaLast+1):
        yield(instrument, sma)


class OptimizerTestCase(unittest.TestCase):
    def testLocal(self):
        barFeed = yahoofeed.Feed()
        instrument = "orcl"
        barFeed.addBarsFromCSV(instrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"))
        res = local.run(sma_crossover.SMACrossOver, barFeed, parameters_generator(instrument, 5, 100))
        self.assertEquals(round(res.getResult(), 2), 1295462.6)
        self.assertEquals(res.getParameters()[1], 20)

########NEW FILE########
__FILENAME__ = plotter_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import sys
import os

from pyalgotrade.barfeed import yahoofeed
from pyalgotrade import plotter

import common

sys.path.append("samples")
import sma_crossover


class PlotterTestCase(unittest.TestCase):
    def testDownloadAndParseDaily(self):
        instrument = "orcl"
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV(instrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"))
        strat = sma_crossover.SMACrossOver(barFeed, instrument, 20)
        plt = plotter.StrategyPlotter(strat, True, True, True)
        plt.getInstrumentSubplot(instrument).addDataSeries("sma", strat.getSMA())
        strat.run()

        with common.TmpDir() as tmpPath:
            fig = plt.buildFigure()
            fig.set_size_inches(10, 8)
            png = os.path.join(tmpPath, "plotter_test.png")
            fig.savefig(png)
            self.assertEquals(open(common.get_data_file_path("plotter_test.png"), "r").read(), open(png, "r").read())

########NEW FILE########
__FILENAME__ = position_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime
import pytz

from pyalgotrade import bar
from pyalgotrade import strategy
from pyalgotrade.strategy import position
from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.barfeed import csvfeed
from pyalgotrade import barfeed
from pyalgotrade.barfeed import membf
from pyalgotrade.barfeed import ninjatraderfeed
from pyalgotrade.utils import dt
from pyalgotrade import marketsession
import common
import strategy_test


def load_daily_barfeed(instrument):
    barFeed = yahoofeed.Feed()
    barFeed.addBarsFromCSV(instrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"))
    return barFeed


def us_equities_datetime(*args, **kwargs):
    ret = datetime.datetime(*args, **kwargs)
    ret = dt.localize(ret, marketsession.USEquities.getTimezone())
    return ret


class TestBarFeed(membf.BarFeed):
    def barsHaveAdjClose(self):
        raise NotImplementedError()


class BaseTestStrategy(strategy.BacktestingStrategy):
    def __init__(self, barFeed, instrument, cash=1000000):
        strategy.BacktestingStrategy.__init__(self, barFeed, cash)
        self.instrument = instrument
        self.orderUpdatedCalls = 0
        self.enterOkCalls = 0
        self.enterCanceledCalls = 0
        self.exitOkCalls = 0
        self.exitCanceledCalls = 0
        self.posExecutionInfo = []

    def onOrderUpdated(self, order):
        self.orderUpdatedCalls += 1

    def onEnterOk(self, position):
        self.enterOkCalls += 1
        self.posExecutionInfo.append(position.getEntryOrder().getExecutionInfo())

    def onEnterCanceled(self, position):
        self.enterCanceledCalls += 1
        self.posExecutionInfo.append(position.getEntryOrder().getExecutionInfo())

    def onExitOk(self, position):
        self.exitOkCalls += 1
        self.posExecutionInfo.append(position.getExitOrder().getExecutionInfo())

    def onExitCanceled(self, position):
        self.exitCanceledCalls += 1
        self.posExecutionInfo.append(position.getExitOrder().getExecutionInfo())


class TestStrategy(BaseTestStrategy):
    def __init__(self, barFeed, instrument, cash):
        BaseTestStrategy.__init__(self, barFeed, instrument, cash)

        self.__activePosition = None
        # Maps dates to a tuple of (method, params)
        self.__posEntry = {}
        self.__posExit = {}

        self.__result = 0
        self.__netProfit = 0
        self.positions = []

    def addPosEntry(self, dateTime, enterMethod, *args, **kwargs):
        self.__posEntry.setdefault(dateTime, [])
        self.__posEntry[dateTime].append((enterMethod, args, kwargs))

    def addPosExit(self, dateTime, *args, **kwargs):
        self.__posExit.setdefault(dateTime, [])
        self.__posExit[dateTime].append((position.Position.exit, args, kwargs))

    def addPosExitMarket(self, dateTime, *args, **kwargs):
        self.__posExit.setdefault(dateTime, [])
        self.__posExit[dateTime].append((position.Position.exitMarket, args, kwargs))

    def addPosExitLimit(self, dateTime, *args, **kwargs):
        self.__posExit.setdefault(dateTime, [])
        self.__posExit[dateTime].append((position.Position.exitLimit, args, kwargs))

    def addPosExitStop(self, dateTime, *args, **kwargs):
        self.__posExit.setdefault(dateTime, [])
        self.__posExit[dateTime].append((position.Position.exitStop, args, kwargs))

    def addPosExitStopLimit(self, dateTime, *args, **kwargs):
        self.__posExit.setdefault(dateTime, [])
        self.__posExit[dateTime].append((position.Position.exitStopLimit, args, kwargs))

    def getResult(self):
        return self.__result

    def getNetProfit(self):
        return self.__netProfit

    def getActivePosition(self):
        return self.__activePosition

    def onEnterOk(self, position):
        # print "Enter ok", position.getEntryOrder().getExecutionInfo().getDateTime()
        BaseTestStrategy.onEnterOk(self, position)
        if self.__activePosition is None:
            self.__activePosition = position
            assert(position.isOpen())
            assert(len(position.getActiveOrders()) != 0)
            assert(position.getShares() != 0)

    def onEnterCanceled(self, position):
        # print "Enter canceled", position.getEntryOrder().getExecutionInfo().getDateTime()
        BaseTestStrategy.onEnterCanceled(self, position)
        self.__activePosition = None
        assert(not position.isOpen())
        assert(len(position.getActiveOrders()) == 0)
        assert(position.getShares() == 0)

    def onExitOk(self, position):
        # print "Exit ok", position.getExitOrder().getExecutionInfo().getDateTime()
        BaseTestStrategy.onExitOk(self, position)
        self.__result += position.getReturn()
        self.__netProfit += position.getNetProfit()
        self.__activePosition = None
        assert(not position.isOpen())
        assert(len(position.getActiveOrders()) == 0)
        assert(position.getShares() == 0)

    def onExitCanceled(self, position):
        # print "Exit canceled", position.getExitOrder().getExecutionInfo().getDateTime()
        BaseTestStrategy.onExitCanceled(self, position)
        assert(position.isOpen())
        assert(len(position.getActiveOrders()) == 0)
        assert(position.getShares() != 0)

    def onBars(self, bars):
        dateTime = bars.getDateTime()

        # Check position entry.
        for meth, args, kwargs in strategy_test.get_by_datetime_or_date(self.__posEntry, dateTime):
            if self.__activePosition is not None:
                raise Exception("Only one position allowed at a time")
            self.__activePosition = meth(*args, **kwargs)
            self.positions.append(self.__activePosition)

        # Check position exit.
        for meth, args, kwargs in strategy_test.get_by_datetime_or_date(self.__posExit, dateTime):
            if self.__activePosition is None:
                raise Exception("A position was not entered")
            meth(self.__activePosition, *args, **kwargs)
            # self.__activePosition.exit(*args, **kwargs)


class EnterAndExitStrategy(BaseTestStrategy):
    def onStart(self):
        self.position = None

    def onBars(self, bars):
        if self.position is None:
            self.position = self.enterLong(self.instrument, 1)
        elif self.position.entryFilled() and not self.position.exitFilled():
            self.position.exitMarket()


class DoubleExitStrategy(BaseTestStrategy):
    def onStart(self):
        self.position = None
        self.doubleExit = False
        self.doubleExitFailed = False

    def onBars(self, bars):
        if self.position is None:
            self.position = self.enterLong(self.instrument, 1)
        elif not self.doubleExit:
            self.doubleExit = True
            self.position.exitMarket()
            try:
                self.position.exit()
            except Exception:
                self.doubleExitFailed = True


class CancelEntryStrategy(BaseTestStrategy):
    def onStart(self):
        self.position = None

    def onBars(self, bars):
        if self.position is None:
            self.position = self.enterLong(self.instrument, 1)
            self.position.cancelEntry()


class ExitEntryNotFilledStrategy(BaseTestStrategy):
    def onStart(self):
        self.position = None

    def onBars(self, bars):
        if self.position is None:
            self.position = self.enterLong(self.instrument, 1)
            self.position.exit()


class ResubmitExitStrategy(BaseTestStrategy):
    def onStart(self):
        self.position = None
        self.exitRequestCanceled = False

    def onBars(self, bars):
        if self.position is None:
            self.position = self.enterLong(self.instrument, 1)
        elif self.position.entryFilled() and not self.position.exitFilled():
            self.position.exitMarket()
            if not self.exitRequestCanceled:
                self.position.cancelExit()
                self.exitRequestCanceled = True


class BaseTestCase(unittest.TestCase):
    TestInstrument = "doesntmatter"

    def loadIntradayBarFeed(self):
        fromMonth = 1
        toMonth = 1
        fromDay = 3
        toDay = 3
        barFilter = csvfeed.USEquitiesRTH(us_equities_datetime(2011, fromMonth, fromDay, 00, 00), us_equities_datetime(2011, toMonth, toDay, 23, 59))
        barFeed = ninjatraderfeed.Feed(barfeed.Frequency.MINUTE)
        barFeed.setBarFilter(barFilter)
        barFeed.addBarsFromCSV(BaseTestCase.TestInstrument, common.get_data_file_path("nt-spy-minute-2011.csv"))
        return barFeed

    def loadDailyBarFeed(self):
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV(BaseTestCase.TestInstrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"))
        return barFeed

    def createStrategy(self, useIntradayBarFeed=False):
        if useIntradayBarFeed:
            barFeed = self.loadIntradayBarFeed()
        else:
            barFeed = self.loadDailyBarFeed()

        strat = TestStrategy(barFeed, BaseTestCase.TestInstrument, 1000)
        return strat


class LongPosTestCase(BaseTestCase):
    def testEnterAndExit(self):
        instrument = "orcl"
        barFeed = load_daily_barfeed(instrument)
        strat = EnterAndExitStrategy(barFeed, instrument)
        strat.run()

        self.assertEqual(strat.position.isOpen(), False)
        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertEqual(strat.exitCanceledCalls, 0)
        self.assertEqual(strat.orderUpdatedCalls, 0)
        self.assertEqual(len(strat.getActivePositions()), 0)
        self.assertEqual(len(strat.getOrderToPosition()), 0)
        self.assertEqual(strat.position.getAge().days, 1)

    def testCancelEntry(self):
        instrument = "orcl"
        barFeed = load_daily_barfeed(instrument)
        strat = CancelEntryStrategy(barFeed, instrument)
        strat.run()

        self.assertEqual(strat.position.isOpen(), False)
        self.assertEqual(strat.enterOkCalls, 0)
        self.assertEqual(strat.enterCanceledCalls, 1)
        self.assertEqual(strat.exitOkCalls, 0)
        self.assertEqual(strat.exitCanceledCalls, 0)
        self.assertEqual(strat.orderUpdatedCalls, 0)
        self.assertEqual(len(strat.getActivePositions()), 0)
        self.assertEqual(len(strat.getOrderToPosition()), 0)
        self.assertEqual(strat.position.getAge().total_seconds(), 0)

    def testExitEntryNotFilled(self):
        instrument = "orcl"
        barFeed = load_daily_barfeed(instrument)
        strat = ExitEntryNotFilledStrategy(barFeed, instrument)
        strat.run()

        self.assertEqual(strat.position.isOpen(), False)
        self.assertEqual(strat.enterOkCalls, 0)
        self.assertEqual(strat.enterCanceledCalls, 1)
        self.assertEqual(strat.exitOkCalls, 0)
        self.assertEqual(strat.exitCanceledCalls, 0)
        self.assertEqual(strat.orderUpdatedCalls, 0)
        self.assertEqual(len(strat.getActivePositions()), 0)
        self.assertEqual(len(strat.getOrderToPosition()), 0)
        self.assertEqual(strat.position.getAge().total_seconds(), 0)

    def testDoubleExitFails(self):
        instrument = "orcl"
        barFeed = load_daily_barfeed(instrument)
        strat = DoubleExitStrategy(barFeed, instrument)
        strat.run()

        self.assertEqual(strat.position.isOpen(), False)
        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertEqual(strat.exitCanceledCalls, 0)
        self.assertEqual(strat.orderUpdatedCalls, 0)
        self.assertEqual(strat.doubleExit, True)
        self.assertEqual(strat.doubleExitFailed, True)
        self.assertEqual(len(strat.getActivePositions()), 0)
        self.assertEqual(len(strat.getOrderToPosition()), 0)
        self.assertEqual(strat.position.getAge().days, 1)

    def testResubmitExit(self):
        instrument = "orcl"
        barFeed = load_daily_barfeed(instrument)
        strat = ResubmitExitStrategy(barFeed, instrument)
        strat.run()

        self.assertEqual(strat.position.isOpen(), False)
        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertEqual(strat.exitCanceledCalls, 1)
        self.assertEqual(strat.orderUpdatedCalls, 0)
        self.assertEqual(len(strat.getActivePositions()), 0)
        self.assertEqual(len(strat.getOrderToPosition()), 0)
        self.assertEqual(strat.position.getAge().days, 2)

    def testLongPosition(self):
        strat = self.createStrategy()

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-11-08,27.37,27.50,24.50,24.81,63040000,24.26 - Sell
        # 2000-11-07,28.37,28.44,26.50,26.56,58950800,25.97 - Exit long
        # 2000-11-06,30.69,30.69,27.50,27.94,75552300,27.32 - Buy
        # 2000-11-03,31.50,31.75,29.50,30.31,65020900,29.64 - Enter long

        strat.addPosEntry(datetime.datetime(2000, 11, 3), strat.enterLong, BaseTestCase.TestInstrument, 1, False)
        strat.addPosExitMarket(datetime.datetime(2000, 11, 7))
        strat.run()

        self.assertEqual(strat.positions[0].isOpen(), False)
        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertEqual(strat.orderUpdatedCalls, 0)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + 27.37 - 30.69, 2))
        self.assertTrue(round(strat.getResult(), 3) == -0.108)
        self.assertTrue(round(strat.getNetProfit(), 2) == round(27.37 - 30.69, 2))
        self.assertEqual(strat.positions[0].getAge().days, 2)

    def testLongPositionAdjClose(self):
        strat = self.createStrategy()
        strat.setUseAdjustedValues(True)

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-10-13,31.00,35.75,31.00,35.63,38516200,34.84
        # 2000-10-12,63.81,64.87,61.75,63.00,50892400,30.80
        # 2000-01-19,56.13,58.25,54.00,57.13,49208800,27.93
        # 2000-01-18,107.87,114.50,105.62,111.25,66791200,27.19

        strat.addPosEntry(datetime.datetime(2000, 1, 18), strat.enterLong, BaseTestCase.TestInstrument, 1, False)
        strat.addPosExit(datetime.datetime(2000, 10, 12))
        strat.run()

        self.assertEqual(strat.positions[0].isOpen(), False)
        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + 30.31 - 27.44, 2))
        self.assertTrue(round(strat.getResult(), 3) == 0.105)
        self.assertTrue(round(strat.getNetProfit(), 2) == round(30.31 - 27.44, 2))
        self.assertEqual(strat.positions[0].getAge().days, 268)

    def testLongPositionGTC(self):
        strat = self.createStrategy()
        strat.getBroker().setCash(48)

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-02-07,59.31,60.00,58.42,59.94,44697200,29.30
        # 2000-02-04,57.63,58.25,56.81,57.81,40925000,28.26 - sell succeeds
        # 2000-02-03,55.38,57.00,54.25,56.69,55540600,27.71 - exit
        # 2000-02-02,54.94,56.00,54.00,54.31,63940400,26.55
        # 2000-02-01,51.25,54.31,50.00,54.00,57108800,26.40
        # 2000-01-31,47.94,50.13,47.06,49.95,68152400,24.42 - buy succeeds
        # 2000-01-28,51.50,51.94,46.63,47.38,86400600,23.16 - buy fails
        # 2000-01-27,55.81,56.69,50.00,51.81,61061800,25.33 - enterLong

        strat.addPosEntry(datetime.datetime(2000, 1, 27), strat.enterLong, BaseTestCase.TestInstrument, 1, True)
        strat.addPosExitMarket(datetime.datetime(2000, 2, 3))
        strat.run()

        self.assertEqual(strat.positions[0].isOpen(), False)
        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(48 + 57.63 - 47.94, 2))
        self.assertTrue(round(strat.getNetProfit(), 2) == round(57.63 - 47.94, 2))
        self.assertEqual(strat.positions[0].getAge().days, 4)

    def testEntryCanceled(self):
        strat = self.createStrategy()
        strat.getBroker().setCash(10)

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-01-28,51.50,51.94,46.63,47.38,86400600,23.16 - buy fails
        # 2000-01-27,55.81,56.69,50.00,51.81,61061800,25.33 - enterLong

        strat.addPosEntry(datetime.datetime(2000, 1, 27), strat.enterLong, BaseTestCase.TestInstrument, 1, False)
        strat.run()

        self.assertEqual(strat.positions[0].isOpen(), False)
        self.assertEqual(strat.enterOkCalls, 0)
        self.assertEqual(strat.enterCanceledCalls, 1)
        self.assertEqual(strat.exitOkCalls, 0)
        self.assertTrue(strat.exitCanceledCalls == 0)
        self.assertTrue(strat.getBroker().getCash() == 10)
        self.assertTrue(strat.getNetProfit() == 0)

    def testUnrealized1(self):
        strat = self.createStrategy(True)

        # 3/Jan/2011 205300 - Enter long
        # 3/Jan/2011 205400 - entry gets filled at 127.21
        # 3/Jan/2011 210000 - last bar

        strat.addPosEntry(dt.localize(datetime.datetime(2011, 1, 3, 20, 53), pytz.utc), strat.enterLong, BaseTestCase.TestInstrument, 1, True)
        strat.run()

        self.assertEqual(strat.positions[0].isOpen(), True)
        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.exitOkCalls, 0)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertTrue(strat.exitCanceledCalls == 0)

        entryPrice = 127.21
        lastPrice = strat.getFeed().getCurrentBars()[BaseTestCase.TestInstrument].getClose()

        self.assertEqual(strat.getActivePosition().getUnrealizedReturn(), (lastPrice - entryPrice) / entryPrice)
        self.assertEqual(strat.getActivePosition().getReturn(), (lastPrice - entryPrice) / entryPrice)
        self.assertEqual(strat.getActivePosition().getUnrealizedNetProfit(), lastPrice - entryPrice)
        self.assertEqual(strat.getActivePosition().getPnL(), lastPrice - entryPrice)

    def testUnrealized2(self):
        instrument = "orcl"
        barFeed = load_daily_barfeed(instrument)
        strat = TestStrategy(barFeed, instrument, 1000)
        strat.addPosEntry(datetime.date(2000, 12, 13), strat.enterLong, instrument, 1, False)  # Filled on 2000-12-14 at 29.25.
        strat.run()

        self.assertEqual(strat.positions[0].isOpen(), True)
        self.assertEqual(strat.getActivePosition().getUnrealizedNetProfit(), 29.06 - 29.25)
        self.assertEqual(strat.getActivePosition().getPnL(), 29.06 - 29.25)
        self.assertEqual(strat.getActivePosition().getUnrealizedReturn(), (29.06 - 29.25) / 29.25)
        self.assertEqual(strat.getActivePosition().getReturn(), (29.06 - 29.25) / 29.25)

    def testUnrealizedAdjusted(self):
        instrument = "orcl"
        barFeed = load_daily_barfeed(instrument)
        strat = TestStrategy(barFeed, instrument, 1000)
        strat.setUseAdjustedValues(True)
        strat.addPosEntry(datetime.date(2000, 12, 13), strat.enterLong, instrument, 1, False)  # Filled on 2000-12-14 at 28.60
        strat.run()

        self.assertEqual(strat.positions[0].isOpen(), True)
        self.assertEqual(round(strat.getActivePosition().getUnrealizedNetProfit(), 2), round(28.41 - 28.60, 2))
        self.assertEqual(round(strat.getActivePosition().getPnL(), 2), round(28.41 - 28.60, 2))
        self.assertEqual(round(strat.getActivePosition().getUnrealizedReturn(), 2), round((28.41 - 28.60) / 28.60, 2))
        self.assertEqual(round(strat.getActivePosition().getReturn(), 2), round((28.41 - 28.60) / 28.60, 2))

    def testInvalidUnrealized(self):
        instrument = "orcl"
        barFeed = load_daily_barfeed(instrument)
        strat = TestStrategy(barFeed, instrument, 1000)
        strat.addPosEntry(datetime.date(2000, 12, 13), strat.enterLong, instrument, 1, False)  # Filled on 2000-12-14 at 29.25.
        strat.addPosExit(datetime.date(2000, 12, 19))
        strat.run()

        self.assertEqual(strat.positions[0].isOpen(), False)
        with self.assertRaises(Exception):
            strat.getActivePosition().getUnrealizedNetProfit()

        with self.assertRaises(Exception):
            strat.getActivePosition().getUnrealizedReturn()

    def testActiveOrdersAndSharesLong(self):
        instrument = "orcl"
        testCase = self

        class Strategy(strategy.BacktestingStrategy):
            def __init__(self, barFeed, cash):
                strategy.BacktestingStrategy.__init__(self, barFeed, cash)
                self.pos = None

            def onBars(self, bars):
                if self.pos is None:
                    self.pos = self.enterLong(instrument, 1, True)
                    # The entry order should be active.
                    testCase.assertEqual(len(self.pos.getActiveOrders()), 1)
                    testCase.assertEqual(self.pos.getShares(), 0)
                elif self.pos.isOpen():
                    # At this point the entry order should have been filled.
                    testCase.assertEqual(len(self.pos.getActiveOrders()), 0)
                    testCase.assertEqual(self.pos.getShares(), 1)
                    self.pos.exit()
                    testCase.assertEqual(len(self.pos.getActiveOrders()), 1)
                    testCase.assertEqual(self.pos.getShares(), 1)
                else:
                    # The position was closed.
                    testCase.assertEqual(len(self.pos.getActiveOrders()), 0)
                    testCase.assertEqual(self.pos.getShares(), 0)

        barFeed = load_daily_barfeed(instrument)
        strat = Strategy(barFeed, 1000)
        strat.run()

        self.assertNotEqual(strat.pos, None)
        self.assertEqual(strat.pos.isOpen(), False)
        # Entered on 2000-01-04 at 115.50
        # Exit on 2000-01-05 at 101.62
        self.assertEqual(strat.pos.getNetProfit(),  101.62 - 115.50)
        self.assertEqual(strat.pos.getPnL(),  101.62 - 115.50)

    def testIsOpen_NotClosed(self):
        strat = self.createStrategy()
        strat.addPosEntry(datetime.datetime(2000, 11, 3), strat.enterLong, BaseTestCase.TestInstrument, 1, False)
        strat.run()
        self.assertTrue(strat.getActivePosition().isOpen())

    def testPartialFillGTC1(self):
        # Open and close after entry has been fully filled.
        instrument = "orcl"
        bf = TestBarFeed(bar.Frequency.DAY)
        bars = [
            bar.BasicBar(datetime.datetime(2000, 1, 1), 10, 10, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 2), 11, 11, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 3), 12, 12, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 4), 13, 13, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 5), 14, 14, 10, 10, 10, 10, bar.Frequency.DAY),
            ]
        bf.addBarsFromSequence(instrument, bars)
        strat = TestStrategy(bf, instrument, 1000)
        strat.addPosEntry(datetime.datetime(2000, 1, 1), strat.enterLong, instrument, 4, True)
        strat.addPosExitMarket(datetime.datetime(2000, 1, 3))
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertEqual(strat.exitCanceledCalls, 0)

        self.assertEqual(len(strat.posExecutionInfo), 2)
        self.assertEqual(strat.posExecutionInfo[0].getPrice(), 11)
        self.assertEqual(strat.posExecutionInfo[0].getQuantity(), 2)
        self.assertEqual(strat.posExecutionInfo[0].getCommission(), 0)
        self.assertEqual(strat.posExecutionInfo[0].getDateTime(), datetime.datetime(2000, 1, 2))
        self.assertEqual(strat.posExecutionInfo[1].getPrice(), 14)
        self.assertEqual(strat.posExecutionInfo[1].getQuantity(), 2)
        self.assertEqual(strat.posExecutionInfo[1].getCommission(), 0)
        self.assertEqual(strat.posExecutionInfo[1].getDateTime(), datetime.datetime(2000, 1, 5))

        self.assertEqual(strat.positions[0].isOpen(), False)
        self.assertEqual(strat.positions[0].getShares(), 0)
        self.assertTrue(strat.positions[0].getEntryOrder().isFilled())
        self.assertEqual(strat.positions[0].getEntryOrder().getFilled(), 4)
        self.assertEqual(strat.positions[0].getEntryOrder().getRemaining(), 0)
        self.assertTrue(strat.positions[0].getExitOrder().isFilled())
        self.assertEqual(strat.positions[0].getExitOrder().getFilled(), 4)
        self.assertEqual(strat.positions[0].getExitOrder().getRemaining(), 0)

    def testPartialFillGTC2(self):
        # Open and close after entry has been partially filled.
        instrument = "orcl"
        bf = TestBarFeed(bar.Frequency.DAY)
        bars = [
            bar.BasicBar(datetime.datetime(2000, 1, 1), 10, 10, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 2), 11, 11, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 3), 12, 12, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 4), 13, 13, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 5), 14, 14, 10, 10, 10, 10, bar.Frequency.DAY),
            ]
        bf.addBarsFromSequence(instrument, bars)
        strat = TestStrategy(bf, instrument, 1000)
        strat.addPosEntry(datetime.datetime(2000, 1, 1), strat.enterLong, instrument, 4, True)
        # Exit the position before the entry order gets completely filled.
        strat.addPosExit(datetime.datetime(2000, 1, 2))
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertEqual(strat.exitCanceledCalls, 0)

        self.assertEqual(len(strat.posExecutionInfo), 2)
        self.assertEqual(strat.posExecutionInfo[0].getPrice(), 11)
        self.assertEqual(strat.posExecutionInfo[0].getQuantity(), 2)
        self.assertEqual(strat.posExecutionInfo[0].getCommission(), 0)
        self.assertEqual(strat.posExecutionInfo[0].getDateTime(), datetime.datetime(2000, 1, 2))
        self.assertEqual(strat.posExecutionInfo[1].getPrice(), 12)
        self.assertEqual(strat.posExecutionInfo[1].getQuantity(), 2)
        self.assertEqual(strat.posExecutionInfo[1].getCommission(), 0)
        self.assertEqual(strat.posExecutionInfo[1].getDateTime(), datetime.datetime(2000, 1, 3))

        self.assertEqual(strat.positions[0].isOpen(), False)
        self.assertEqual(strat.positions[0].getShares(), 0)
        self.assertTrue(strat.positions[0].getEntryOrder().isCanceled())
        self.assertEqual(strat.positions[0].getEntryOrder().getFilled(), 2)
        self.assertEqual(strat.positions[0].getEntryOrder().getRemaining(), 2)
        self.assertTrue(strat.positions[0].getExitOrder().isFilled())
        self.assertEqual(strat.positions[0].getExitOrder().getFilled(), 2)
        self.assertEqual(strat.positions[0].getExitOrder().getRemaining(), 0)

    def testPartialFillGTC3(self):
        class SkipCancelBroker(object):
            def __init__(self, decorated):
                self.__decorated = decorated

            def __getattr__(self, name):
                return getattr(self.__decorated, name)

            def cancelOrder(self, order):
                return

        # Open and close after entry has been partially filled.
        # Cancelations get skipped and the position is left open.
        # The idea is to simulate a real scenario where cancelation gets submited but the order gets
        # filled before the cancelation gets processed.
        instrument = "orcl"
        bf = TestBarFeed(bar.Frequency.DAY)
        bars = [
            bar.BasicBar(datetime.datetime(2000, 1, 1), 10, 10, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 2), 11, 11, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 3), 12, 12, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 4), 13, 13, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 5), 14, 14, 10, 10, 10, 10, bar.Frequency.DAY),
            ]
        bf.addBarsFromSequence(instrument, bars)
        strat = TestStrategy(bf, instrument, 1000)
        strat._setBroker(SkipCancelBroker(strat.getBroker()))
        strat.addPosEntry(datetime.datetime(2000, 1, 1), strat.enterLong, instrument, 4, True)
        # Exit the position before the entry order gets completely filled.
        strat.addPosExitMarket(datetime.datetime(2000, 1, 2))
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 0)
        self.assertEqual(strat.exitCanceledCalls, 0)

        self.assertEqual(len(strat.posExecutionInfo), 1)
        self.assertEqual(strat.posExecutionInfo[0].getPrice(), 11)
        self.assertEqual(strat.posExecutionInfo[0].getQuantity(), 2)
        self.assertEqual(strat.posExecutionInfo[0].getCommission(), 0)
        self.assertEqual(strat.posExecutionInfo[0].getDateTime(), datetime.datetime(2000, 1, 2))

        self.assertEqual(strat.positions[0].isOpen(), True)
        self.assertEqual(strat.positions[0].getShares(), 2)
        self.assertTrue(strat.positions[0].getEntryOrder().isFilled())
        self.assertEqual(strat.positions[0].getEntryOrder().getFilled(), 4)
        self.assertEqual(strat.positions[0].getEntryOrder().getRemaining(), 0)
        self.assertTrue(strat.positions[0].getExitOrder().isFilled())
        self.assertEqual(strat.positions[0].getExitOrder().getFilled(), 2)
        self.assertEqual(strat.positions[0].getExitOrder().getRemaining(), 0)

    def testPartialFillGTC4(self):
        class SkipFirstCancelBroker(object):
            def __init__(self, decorated):
                self.__decorated = decorated
                self.__cancelSkipped = False

            def __getattr__(self, name):
                return getattr(self.__decorated, name)

            def cancelOrder(self, order):
                if not self.__cancelSkipped:
                    self.__cancelSkipped = True
                    return
                self.__decorated.cancelOrder(order)

        # Open and close after entry has been partially filled.
        # The first cancelation get skipped and a second exit has to be requested to close the position.
        # The idea is to simulate a real scenario where cancelation gets submited but the order gets
        # filled before the cancelation gets processed.
        instrument = "orcl"
        bf = TestBarFeed(bar.Frequency.DAY)
        bars = [
            bar.BasicBar(datetime.datetime(2000, 1, 1), 10, 10, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 2), 11, 11, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 3), 12, 12, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 4), 13, 13, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 5), 14, 14, 10, 10, 10, 10, bar.Frequency.DAY),
            ]
        bf.addBarsFromSequence(instrument, bars)
        strat = TestStrategy(bf, instrument, 1000)
        strat._setBroker(SkipFirstCancelBroker(strat.getBroker()))
        strat.addPosEntry(datetime.datetime(2000, 1, 1), strat.enterLong, instrument, 4, True)
        # Exit the position before the entry order gets completely filled.
        strat.addPosExit(datetime.datetime(2000, 1, 2))
        # Retry exit.
        strat.addPosExitMarket(datetime.datetime(2000, 1, 4))
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertEqual(strat.exitCanceledCalls, 0)

        self.assertEqual(len(strat.posExecutionInfo), 2)
        self.assertEqual(strat.posExecutionInfo[0].getPrice(), 11)
        self.assertEqual(strat.posExecutionInfo[0].getQuantity(), 2)
        self.assertEqual(strat.posExecutionInfo[0].getCommission(), 0)
        self.assertEqual(strat.posExecutionInfo[0].getDateTime(), datetime.datetime(2000, 1, 2))
        self.assertEqual(strat.posExecutionInfo[1].getPrice(), 14)
        self.assertEqual(strat.posExecutionInfo[1].getQuantity(), 2)
        self.assertEqual(strat.posExecutionInfo[1].getCommission(), 0)
        self.assertEqual(strat.posExecutionInfo[1].getDateTime(), datetime.datetime(2000, 1, 5))

        self.assertEqual(strat.positions[0].isOpen(), False)
        self.assertEqual(strat.positions[0].getShares(), 0)
        self.assertTrue(strat.positions[0].getEntryOrder().isFilled())
        self.assertEqual(strat.positions[0].getEntryOrder().getFilled(), 4)
        self.assertEqual(strat.positions[0].getEntryOrder().getRemaining(), 0)
        self.assertTrue(strat.positions[0].getExitOrder().isFilled())
        self.assertEqual(strat.positions[0].getExitOrder().getFilled(), 2)
        self.assertEqual(strat.positions[0].getExitOrder().getRemaining(), 0)


class ShortPosTestCase(BaseTestCase):
    def testActiveOrdersAndSharesShort(self):
        instrument = "orcl"
        testCase = self

        class Strategy(strategy.BacktestingStrategy):
            def __init__(self, barFeed, cash):
                strategy.BacktestingStrategy.__init__(self, barFeed, cash)
                self.pos = None

            def onBars(self, bars):
                if self.pos is None:
                    self.pos = self.enterShort(instrument, 1, True)
                    # The entry order should be active.
                    testCase.assertEqual(len(self.pos.getActiveOrders()), 1)
                    testCase.assertEqual(self.pos.getShares(), 0)
                elif self.pos.isOpen():
                    # At this point the entry order should have been filled.
                    testCase.assertEqual(len(self.pos.getActiveOrders()), 0)
                    testCase.assertEqual(self.pos.getShares(), -1)
                    self.pos.exitMarket()
                    testCase.assertEqual(len(self.pos.getActiveOrders()), 1)
                    testCase.assertEqual(self.pos.getShares(), -1)
                else:
                    # The position was closed.
                    testCase.assertEqual(len(self.pos.getActiveOrders()), 0)
                    testCase.assertEqual(self.pos.getShares(), 0)

        barFeed = load_daily_barfeed(instrument)
        strat = Strategy(barFeed, 1000)
        strat.run()

        self.assertNotEqual(strat.pos, None)
        self.assertEqual(strat.pos.isOpen(), False)
        # Entered on 2000-01-04 at 115.50
        # Exit on 2000-01-05 at 101.62
        self.assertEqual(strat.pos.getNetProfit(),  115.50 - 101.62)
        self.assertEqual(strat.pos.getPnL(),  115.50 - 101.62)

    def testShortPosition(self):
        strat = self.createStrategy()

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-11-08,27.37,27.50,24.50,24.81,63040000,24.26
        # 2000-11-07,28.37,28.44,26.50,26.56,58950800,25.97
        # 2000-11-06,30.69,30.69,27.50,27.94,75552300,27.32
        # 2000-11-03,31.50,31.75,29.50,30.31,65020900,29.64

        strat.addPosEntry(datetime.datetime(2000, 11, 3), strat.enterShort, BaseTestCase.TestInstrument, 1, False)
        strat.addPosExit(datetime.datetime(2000, 11, 7))
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + 30.69 - 27.37, 2))
        self.assertTrue(round(strat.getResult(), 3) == round(0.10817856, 3))
        self.assertTrue(round(strat.getNetProfit(), 2) == round(30.69 - 27.37, 2))

    def testShortPositionAdjClose(self):
        strat = self.createStrategy()
        strat.setUseAdjustedValues(True)

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-10-13,31.00,35.75,31.00,35.63,38516200,34.84
        # 2000-10-12,63.81,64.87,61.75,63.00,50892400,30.80
        # 2000-01-19,56.13,58.25,54.00,57.13,49208800,27.93
        # 2000-01-18,107.87,114.50,105.62,111.25,66791200,27.19

        strat.addPosEntry(datetime.datetime(2000, 1, 18), strat.enterShort, BaseTestCase.TestInstrument, 1, False)
        strat.addPosExitMarket(datetime.datetime(2000, 10, 12))
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + 27.44 - 30.31, 2))
        self.assertTrue(round(strat.getResult(), 3) == round(-0.104591837, 3))
        self.assertTrue(round(strat.getNetProfit(), 2) == round(27.44 - 30.31, 2))

    def testShortPositionExitCanceled(self):
        strat = self.createStrategy()
        strat.getBroker().setCash(0)

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-12-08,30.06,30.62,29.25,30.06,40054100,29.39
        # 2000-12-07,29.62,29.94,28.12,28.31,41093000,27.68
        # .
        # 2000-11-29,23.19,23.62,21.81,22.87,75408100,22.36
        # 2000-11-28,23.50,23.81,22.25,22.66,43078300,22.16

        strat.addPosEntry(datetime.datetime(2000, 11, 28), strat.enterShort, BaseTestCase.TestInstrument, 1, False)
        strat.addPosExit(datetime.datetime(2000, 12, 7))
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertTrue(strat.exitCanceledCalls == 1)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == 23.19)
        self.assertTrue(strat.getNetProfit() == 0)

    def testShortPositionExitCanceledAndReSubmitted(self):
        strat = self.createStrategy()
        strat.getBroker().setCash(0)

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-11-24,23.31,24.25,23.12,24.12,22446100,23.58
        # 2000-11-22,23.62,24.06,22.06,22.31,53317000,21.81 - exitShort that gets filled
        # 2000-11-21,24.81,25.62,23.50,23.87,58651900,23.34
        # 2000-11-20,24.31,25.87,24.00,24.75,89783100,24.20
        # 2000-11-17,26.94,29.25,25.25,28.81,59639400,28.17
        # 2000-11-16,28.75,29.81,27.25,27.37,37990000,26.76
        # 2000-11-15,28.81,29.44,27.70,28.87,50655200,28.23
        # 2000-11-14,27.37,28.50,26.50,28.37,77496700,27.74 - exitShort that gets canceled
        # 2000-11-13,25.12,25.87,23.50,24.75,61651900,24.20
        # 2000-11-10,26.44,26.94,24.87,25.44,54614100,24.87 - enterShort

        strat.addPosEntry(datetime.datetime(2000, 11, 10), strat.enterShort, BaseTestCase.TestInstrument, 1)
        strat.addPosExitMarket(datetime.datetime(2000, 11, 14))
        strat.addPosExit(datetime.datetime(2000, 11, 22))
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertTrue(strat.exitCanceledCalls == 1)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(25.12 - 23.31, 2))

    def testUnrealized(self):
        strat = self.createStrategy(True)

        # 3/Jan/2011 205300 - Enter long
        # 3/Jan/2011 205400 - entry gets filled at 127.21
        # 3/Jan/2011 210000 - last bar

        strat.addPosEntry(dt.localize(datetime.datetime(2011, 1, 3, 20, 53), pytz.utc), strat.enterShort, BaseTestCase.TestInstrument, 1, True)
        strat.run()
        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.exitOkCalls, 0)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertTrue(strat.exitCanceledCalls == 0)

        entryPrice = 127.21
        lastPrice = strat.getFeed().getCurrentBars()[BaseTestCase.TestInstrument].getClose()

        self.assertEqual(strat.getActivePosition().getUnrealizedReturn(), (entryPrice - lastPrice) / entryPrice)
        self.assertEqual(strat.getActivePosition().getReturn(), (entryPrice - lastPrice) / entryPrice)
        self.assertEqual(strat.getActivePosition().getUnrealizedNetProfit(), entryPrice - lastPrice)
        self.assertEqual(strat.getActivePosition().getPnL(), entryPrice - lastPrice)


class LimitPosTestCase(BaseTestCase):
    def testLong(self):
        strat = self.createStrategy()

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-11-17,26.94,29.25,25.25,28.81,59639400,28.17 - exit filled
        # 2000-11-16,28.75,29.81,27.25,27.37,37990000,26.76 - exitPosition
        # 2000-11-15,28.81,29.44,27.70,28.87,50655200,28.23
        # 2000-11-14,27.37,28.50,26.50,28.37,77496700,27.74
        # 2000-11-13,25.12,25.87,23.50,24.75,61651900,24.20 - entry filled
        # 2000-11-10,26.44,26.94,24.87,25.44,54614100,24.87 - enterLongLimit

        strat.addPosEntry(datetime.datetime(2000, 11, 10), strat.enterLongLimit, BaseTestCase.TestInstrument, 25, 1)
        strat.addPosExitLimit(datetime.datetime(2000, 11, 16), 29)
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertTrue(strat.exitCanceledCalls == 0)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == 1004)

    def testShort(self):
        strat = self.createStrategy()

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-11-24,23.31,24.25,23.12,24.12,22446100,23.58 - exit filled
        # 2000-11-22,23.62,24.06,22.06,22.31,53317000,21.81 - exitPosition
        # 2000-11-21,24.81,25.62,23.50,23.87,58651900,23.34
        # 2000-11-20,24.31,25.87,24.00,24.75,89783100,24.20
        # 2000-11-17,26.94,29.25,25.25,28.81,59639400,28.17 - entry filled
        # 2000-11-16,28.75,29.81,27.25,27.37,37990000,26.76 - enterShortLimit

        strat.addPosEntry(datetime.datetime(2000, 11, 16), strat.enterShortLimit, BaseTestCase.TestInstrument, 29, 1)
        strat.addPosExit(datetime.datetime(2000, 11, 22), None, 24)
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertTrue(strat.exitCanceledCalls == 0)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (29 - 23.31), 2))

    def testExitOnEntryNotFilled(self):
        strat = self.createStrategy()

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-11-17,26.94,29.25,25.25,28.81,59639400,28.17 - entry canceled
        # 2000-11-16,28.75,29.81,27.25,27.37,37990000,26.76 - exitPosition
        # 2000-11-15,28.81,29.44,27.70,28.87,50655200,28.23
        # 2000-11-14,27.37,28.50,26.50,28.37,77496700,27.74
        # 2000-11-13,25.12,25.87,23.50,24.75,61651900,24.20
        # 2000-11-10,26.44,26.94,24.87,25.44,54614100,24.87 - enterLongLimit

        strat.addPosEntry(datetime.datetime(2000, 11, 10), strat.enterLongLimit, BaseTestCase.TestInstrument, 5, 1, True)
        strat.addPosExitLimit(datetime.datetime(2000, 11, 16), 29)
        strat.run()

        self.assertEqual(strat.enterOkCalls, 0)
        self.assertEqual(strat.enterCanceledCalls, 1)
        self.assertEqual(strat.exitOkCalls, 0)
        self.assertTrue(strat.exitCanceledCalls == 0)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == 1000)

    def testExitTwice(self):
        strat = self.createStrategy()

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-11-17,26.94,29.25,25.25,28.81,59639400,28.17 - exit filled
        # 2000-11-16,28.75,29.81,27.25,27.37,37990000,26.76 - exitPosition using a market order (cancels the previous one).
        # 2000-11-15,28.81,29.44,27.70,28.87,50655200,28.23
        # 2000-11-14,27.37,28.50,26.50,28.37,77496700,27.74 - exitPosition
        # 2000-11-13,25.12,25.87,23.50,24.75,61651900,24.20 - entry filled
        # 2000-11-10,26.44,26.94,24.87,25.44,54614100,24.87 - enterLongLimit

        strat.addPosEntry(datetime.datetime(2000, 11, 10), strat.enterLongLimit, BaseTestCase.TestInstrument, 25, 1)
        strat.addPosExit(datetime.datetime(2000, 11, 14), None, 100)
        strat.addPosExit(datetime.datetime(2000, 11, 16))
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertTrue(strat.exitCanceledCalls == 1)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (26.94 - 25), 2))

    def testExitCancelsEntry(self):
        strat = self.createStrategy()

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-11-14,27.37,28.50,26.50,28.37,77496700,27.74 - exitPosition (cancels the entry).
        # 2000-11-13,25.12,25.87,23.50,24.75,61651900,24.20 -
        # 2000-11-10,26.44,26.94,24.87,25.44,54614100,24.87 - enterLongLimit

        strat.addPosEntry(datetime.datetime(2000, 11, 10), strat.enterLongLimit, BaseTestCase.TestInstrument, 5, 1, True)
        strat.addPosExitLimit(datetime.datetime(2000, 11, 14), 100)
        strat.run()

        self.assertEqual(strat.enterOkCalls, 0)
        self.assertEqual(strat.enterCanceledCalls, 1)
        self.assertEqual(strat.exitOkCalls, 0)
        self.assertTrue(strat.exitCanceledCalls == 0)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == 1000)

    def testEntryGTCExitNotGTC(self):
        strat = self.createStrategy()

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-11-15,28.81,29.44,27.70,28.87,50655200,28.23 - GTC exitPosition (never filled)
        # 2000-11-14,27.37,28.50,26.50,28.37,77496700,27.74 -
        # 2000-11-13,25.12,25.87,23.50,24.75,61651900,24.20 - entry filled
        # 2000-11-10,26.44,26.94,24.87,25.44,54614100,24.87 - enterLongLimit

        strat.addPosEntry(datetime.datetime(2000, 11, 10), strat.enterLongLimit, BaseTestCase.TestInstrument, 25, 1, True)
        strat.addPosExitLimit(datetime.datetime(2000, 11, 15), 100, False)
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 0)
        self.assertTrue(strat.exitCanceledCalls == 1)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 - 25, 2))


class StopPosTestCase(BaseTestCase):
    def testLong(self):
        strat = self.createStrategy()

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-11-17,26.94,29.25,25.25,28.81,59639400,28.17 - exit filled
        # 2000-11-16,28.75,29.81,27.25,27.37,37990000,26.76 - exitPosition
        # 2000-11-15,28.81,29.44,27.70,28.87,50655200,28.23
        # 2000-11-14,27.37,28.50,26.50,28.37,77496700,27.74
        # 2000-11-13,25.12,25.87,23.50,24.75,61651900,24.20 - entry filled
        # 2000-11-10,26.44,26.94,24.87,25.44,54614100,24.87 - enterLongStop

        strat.addPosEntry(datetime.datetime(2000, 11, 10), strat.enterLongStop, BaseTestCase.TestInstrument, 25, 1)
        strat.addPosExitStop(datetime.datetime(2000, 11, 16), 26)
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertTrue(strat.exitCanceledCalls == 0)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (26 - 25.12), 2))

    def testShort(self):
        strat = self.createStrategy()

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-11-24,23.31,24.25,23.12,24.12,22446100,23.58 - exit filled
        # 2000-11-22,23.62,24.06,22.06,22.31,53317000,21.81 - exitPosition
        # 2000-11-21,24.81,25.62,23.50,23.87,58651900,23.34
        # 2000-11-20,24.31,25.87,24.00,24.75,89783100,24.20
        # 2000-11-17,26.94,29.25,25.25,28.81,59639400,28.17 - entry filled
        # 2000-11-16,28.75,29.81,27.25,27.37,37990000,26.76 - enterShortStop

        strat.addPosEntry(datetime.datetime(2000, 11, 16), strat.enterShortStop, BaseTestCase.TestInstrument, 27, 1)
        strat.addPosExit(datetime.datetime(2000, 11, 22), 23, None)
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertTrue(strat.exitCanceledCalls == 0)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (26.94 - 23.31), 2))

    def testPartialFillGTC1(self):
        # Open and close after entry has been fully filled.
        instrument = "orcl"
        bf = TestBarFeed(bar.Frequency.DAY)
        bars = [
            bar.BasicBar(datetime.datetime(2000, 1, 1), 10, 10, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 2), 11, 11, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 3), 12, 12, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 4), 13, 13, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 5), 14, 14, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 6), 15, 15, 10, 10, 10, 10, bar.Frequency.DAY),
            ]
        bf.addBarsFromSequence(instrument, bars)
        strat = TestStrategy(bf, instrument, 1000)
        strat.addPosEntry(datetime.datetime(2000, 1, 1), strat.enterLongStop, instrument, 12, 4, True)
        strat.addPosExit(datetime.datetime(2000, 1, 4))
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertEqual(strat.exitCanceledCalls, 0)

        self.assertEqual(len(strat.posExecutionInfo), 2)
        self.assertEqual(strat.posExecutionInfo[0].getPrice(), 12)
        self.assertEqual(strat.posExecutionInfo[0].getQuantity(), 2)
        self.assertEqual(strat.posExecutionInfo[0].getCommission(), 0)
        self.assertEqual(strat.posExecutionInfo[0].getDateTime(), datetime.datetime(2000, 1, 3))
        self.assertEqual(strat.posExecutionInfo[1].getPrice(), 15)
        self.assertEqual(strat.posExecutionInfo[1].getQuantity(), 2)
        self.assertEqual(strat.posExecutionInfo[1].getCommission(), 0)
        self.assertEqual(strat.posExecutionInfo[1].getDateTime(), datetime.datetime(2000, 1, 6))

        self.assertEqual(strat.positions[0].isOpen(), False)
        self.assertEqual(strat.positions[0].getShares(), 0)
        self.assertTrue(strat.positions[0].getEntryOrder().isFilled())
        self.assertEqual(strat.positions[0].getEntryOrder().getFilled(), 4)
        self.assertEqual(strat.positions[0].getEntryOrder().getRemaining(), 0)
        self.assertTrue(strat.positions[0].getExitOrder().isFilled())
        self.assertEqual(strat.positions[0].getExitOrder().getFilled(), 4)
        self.assertEqual(strat.positions[0].getExitOrder().getRemaining(), 0)

    def testPartialFillGTC2(self):
        # Open and close after entry has been partially filled.
        instrument = "orcl"
        bf = TestBarFeed(bar.Frequency.DAY)
        bars = [
            bar.BasicBar(datetime.datetime(2000, 1, 1), 10, 10, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 2), 11, 11, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 3), 12, 12, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 4), 13, 13, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 5), 14, 14, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 6), 15, 15, 10, 10, 10, 10, bar.Frequency.DAY),
            ]
        bf.addBarsFromSequence(instrument, bars)
        strat = TestStrategy(bf, instrument, 1000)
        strat.addPosEntry(datetime.datetime(2000, 1, 1), strat.enterLongStop, instrument, 12, 4, True)
        # Exit the position before the entry order gets completely filled.
        strat.addPosExit(datetime.datetime(2000, 1, 3))
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertEqual(strat.exitCanceledCalls, 0)

        self.assertEqual(len(strat.posExecutionInfo), 2)
        self.assertEqual(strat.posExecutionInfo[0].getPrice(), 12)
        self.assertEqual(strat.posExecutionInfo[0].getQuantity(), 2)
        self.assertEqual(strat.posExecutionInfo[0].getCommission(), 0)
        self.assertEqual(strat.posExecutionInfo[0].getDateTime(), datetime.datetime(2000, 1, 3))
        self.assertEqual(strat.posExecutionInfo[1].getPrice(), 13)
        self.assertEqual(strat.posExecutionInfo[1].getQuantity(), 2)
        self.assertEqual(strat.posExecutionInfo[1].getCommission(), 0)
        self.assertEqual(strat.posExecutionInfo[1].getDateTime(), datetime.datetime(2000, 1, 4))

        self.assertEqual(strat.positions[0].isOpen(), False)
        self.assertEqual(strat.positions[0].getShares(), 0)
        self.assertTrue(strat.positions[0].getEntryOrder().isCanceled())
        self.assertEqual(strat.positions[0].getEntryOrder().getFilled(), 2)
        self.assertEqual(strat.positions[0].getEntryOrder().getRemaining(), 2)
        self.assertTrue(strat.positions[0].getExitOrder().isFilled())
        self.assertEqual(strat.positions[0].getExitOrder().getFilled(), 2)
        self.assertEqual(strat.positions[0].getExitOrder().getRemaining(), 0)

    def testPartialFillGTC3(self):
        class SkipCancelBroker(object):
            def __init__(self, decorated):
                self.__decorated = decorated

            def __getattr__(self, name):
                return getattr(self.__decorated, name)

            def cancelOrder(self, order):
                return

        # Open and close after entry has been partially filled.
        # Cancelations get skipped and the position is left open.
        # The idea is to simulate a real scenario where cancelation gets submited but the order gets
        # filled before the cancelation gets processed.
        instrument = "orcl"
        bf = TestBarFeed(bar.Frequency.DAY)
        bars = [
            bar.BasicBar(datetime.datetime(2000, 1, 1), 10, 10, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 2), 11, 11, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 3), 12, 12, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 4), 13, 13, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 5), 14, 14, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 6), 15, 15, 10, 10, 10, 10, bar.Frequency.DAY),
            ]
        bf.addBarsFromSequence(instrument, bars)
        strat = TestStrategy(bf, instrument, 1000)
        strat._setBroker(SkipCancelBroker(strat.getBroker()))
        strat.addPosEntry(datetime.datetime(2000, 1, 1), strat.enterLongStop, instrument, 12, 4, True)
        # Exit the position before the entry order gets completely filled.
        strat.addPosExit(datetime.datetime(2000, 1, 3))
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 0)
        self.assertEqual(strat.exitCanceledCalls, 0)

        self.assertEqual(len(strat.posExecutionInfo), 1)
        self.assertEqual(strat.posExecutionInfo[0].getPrice(), 12)
        self.assertEqual(strat.posExecutionInfo[0].getQuantity(), 2)
        self.assertEqual(strat.posExecutionInfo[0].getCommission(), 0)
        self.assertEqual(strat.posExecutionInfo[0].getDateTime(), datetime.datetime(2000, 1, 3))

        self.assertEqual(strat.positions[0].isOpen(), True)
        self.assertEqual(strat.positions[0].getShares(), 2)
        self.assertTrue(strat.positions[0].getEntryOrder().isFilled())
        self.assertEqual(strat.positions[0].getEntryOrder().getFilled(), 4)
        self.assertEqual(strat.positions[0].getEntryOrder().getRemaining(), 0)
        self.assertTrue(strat.positions[0].getExitOrder().isFilled())
        self.assertEqual(strat.positions[0].getExitOrder().getFilled(), 2)
        self.assertEqual(strat.positions[0].getExitOrder().getRemaining(), 0)

    def testPartialFillGTC4(self):
        class SkipFirstCancelBroker(object):
            def __init__(self, decorated):
                self.__decorated = decorated
                self.__cancelSkipped = False

            def __getattr__(self, name):
                return getattr(self.__decorated, name)

            def cancelOrder(self, order):
                if not self.__cancelSkipped:
                    self.__cancelSkipped = True
                    return
                self.__decorated.cancelOrder(order)

        # Open and close after entry has been partially filled.
        # The first cancelation get skipped and a second exit has to be requested to close the position.
        # The idea is to simulate a real scenario where cancelation gets submited but the order gets
        # filled before the cancelation gets processed.
        instrument = "orcl"
        bf = TestBarFeed(bar.Frequency.DAY)
        bars = [
            bar.BasicBar(datetime.datetime(2000, 1, 1), 10, 10, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 2), 11, 11, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 3), 12, 12, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 4), 13, 13, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 5), 14, 14, 10, 10, 10, 10, bar.Frequency.DAY),
            bar.BasicBar(datetime.datetime(2000, 1, 6), 15, 15, 10, 10, 10, 10, bar.Frequency.DAY),
            ]
        bf.addBarsFromSequence(instrument, bars)
        strat = TestStrategy(bf, instrument, 1000)
        strat._setBroker(SkipFirstCancelBroker(strat.getBroker()))
        strat.addPosEntry(datetime.datetime(2000, 1, 1), strat.enterLongStop, instrument, 12, 4, True)
        # Exit the position before the entry order gets completely filled.
        strat.addPosExit(datetime.datetime(2000, 1, 3))
        # Retry exit.
        strat.addPosExit(datetime.datetime(2000, 1, 5))
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertEqual(strat.exitCanceledCalls, 0)

        self.assertEqual(len(strat.posExecutionInfo), 2)
        self.assertEqual(strat.posExecutionInfo[0].getPrice(), 12)
        self.assertEqual(strat.posExecutionInfo[0].getQuantity(), 2)
        self.assertEqual(strat.posExecutionInfo[0].getCommission(), 0)
        self.assertEqual(strat.posExecutionInfo[0].getDateTime(), datetime.datetime(2000, 1, 3))
        self.assertEqual(strat.posExecutionInfo[1].getPrice(), 15)
        self.assertEqual(strat.posExecutionInfo[1].getQuantity(), 2)
        self.assertEqual(strat.posExecutionInfo[1].getCommission(), 0)
        self.assertEqual(strat.posExecutionInfo[1].getDateTime(), datetime.datetime(2000, 1, 6))

        self.assertEqual(strat.positions[0].isOpen(), False)
        self.assertEqual(strat.positions[0].getShares(), 0)
        self.assertTrue(strat.positions[0].getEntryOrder().isFilled())
        self.assertEqual(strat.positions[0].getEntryOrder().getFilled(), 4)
        self.assertEqual(strat.positions[0].getEntryOrder().getRemaining(), 0)
        self.assertTrue(strat.positions[0].getExitOrder().isFilled())
        self.assertEqual(strat.positions[0].getExitOrder().getFilled(), 2)
        self.assertEqual(strat.positions[0].getExitOrder().getRemaining(), 0)


class StopLimitPosTestCase(BaseTestCase):
    def testLong(self):
        strat = self.createStrategy()

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-11-17,26.94,29.25,25.25,28.81,59639400,28.17 - exit filled
        # 2000-11-16,28.75,29.81,27.25,27.37,37990000,26.76 - exitPosition
        # 2000-11-15,28.81,29.44,27.70,28.87,50655200,28.23
        # 2000-11-14,27.37,28.50,26.50,28.37,77496700,27.74
        # 2000-11-13,25.12,25.87,23.50,24.75,61651900,24.20 - entry filled
        # 2000-11-10,26.44,26.94,24.87,25.44,54614100,24.87 - enterLongStopLimit

        strat.addPosEntry(datetime.datetime(2000, 11, 10), strat.enterLongStopLimit, BaseTestCase.TestInstrument, 25.5, 24, 1)
        strat.addPosExitStopLimit(datetime.datetime(2000, 11, 16), 27, 28)
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertTrue(strat.exitCanceledCalls == 0)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (28 - 24), 2))

    def testShort(self):
        strat = self.createStrategy()

        # Date,Open,High,Low,Close,Volume,Adj Close
        # 2000-11-24,23.31,24.25,23.12,24.12,22446100,23.58 - exit filled
        # 2000-11-22,23.62,24.06,22.06,22.31,53317000,21.81 - exitPosition
        # 2000-11-21,24.81,25.62,23.50,23.87,58651900,23.34
        # 2000-11-20,24.31,25.87,24.00,24.75,89783100,24.20
        # 2000-11-17,26.94,29.25,25.25,28.81,59639400,28.17 - entry filled
        # 2000-11-16,28.75,29.81,27.25,27.37,37990000,26.76 - enterShortStopLimit
        # 2000-11-15,28.81,29.44,27.70,28.87,50655200,28.23
        # 2000-11-14,27.37,28.50,26.50,28.37,77496700,27.74
        # 2000-11-13,25.12,25.87,23.50,24.75,61651900,24.20
        # 2000-11-10,26.44,26.94,24.87,25.44,54614100,24.87

        strat.addPosEntry(datetime.datetime(2000, 11, 16), strat.enterShortStopLimit, BaseTestCase.TestInstrument, 27, 29, 1)
        strat.addPosExit(datetime.datetime(2000, 11, 22), 24, 25)
        strat.run()

        self.assertEqual(strat.enterOkCalls, 1)
        self.assertEqual(strat.enterCanceledCalls, 0)
        self.assertEqual(strat.exitOkCalls, 1)
        self.assertTrue(strat.exitCanceledCalls == 0)
        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (29 - 24), 2))

########NEW FILE########
__FILENAME__ = quandl_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import os
import unittest
import datetime

from pyalgotrade.tools import quandl
from pyalgotrade import bar
from pyalgotrade.barfeed import quandlfeed
import common


auth_token = None


class ToolsTestCase(unittest.TestCase):
    def testDownloadAndParseDaily(self):
        with common.TmpDir() as tmpPath:
            instrument = "ORCL"
            path = os.path.join(tmpPath, "quandl-daily-orcl-2010.csv")
            quandl.download_daily_bars("WIKI", instrument, 2010, path, auth_token)
            bf = quandlfeed.Feed()
            bf.addBarsFromCSV(instrument, path)
            bf.loadAll()
            self.assertEquals(bf[instrument][-1].getDateTime(), datetime.datetime(2010, 12, 31))
            self.assertEquals(bf[instrument][-1].getOpen(), 31.22)
            self.assertEquals(bf[instrument][-1].getHigh(), 31.33)
            self.assertEquals(bf[instrument][-1].getLow(), 30.93)
            self.assertEquals(bf[instrument][-1].getClose(), 31.3)
            self.assertEquals(bf[instrument][-1].getVolume(), 11716300)
            self.assertEquals(bf[instrument][-1].getAdjClose(), 30.23179912467581)
            self.assertEquals(bf[instrument][-1].getPrice(), 31.3)

    def testDownloadAndParseDaily_UseAdjClose(self):
        with common.TmpDir() as tmpPath:
            instrument = "ORCL"
            path = os.path.join(tmpPath, "quandl-daily-orcl-2010.csv")
            quandl.download_daily_bars("WIKI", instrument, 2010, path, auth_token)
            bf = quandlfeed.Feed()
            bf.addBarsFromCSV(instrument, path)
            # Need to setUseAdjustedValues(True) after loading the file because we
            # can't tell in advance if adjusted values are there or not.
            bf.setUseAdjustedValues(True)
            bf.loadAll()
            self.assertEquals(bf[instrument][-1].getDateTime(), datetime.datetime(2010, 12, 31))
            self.assertEquals(bf[instrument][-1].getOpen(), 31.22)
            self.assertEquals(bf[instrument][-1].getHigh(), 31.33)
            self.assertEquals(bf[instrument][-1].getLow(), 30.93)
            self.assertEquals(bf[instrument][-1].getClose(), 31.3)
            self.assertEquals(bf[instrument][-1].getVolume(), 11716300)
            self.assertEquals(bf[instrument][-1].getAdjClose(), 30.23179912467581)
            self.assertEquals(bf[instrument][-1].getPrice(), 30.23179912467581)

    def testDownloadAndParseDailyNoAdjClose(self):
        with common.TmpDir() as tmpPath:
            instrument = "ORCL"
            path = os.path.join(tmpPath, "quandl-daily-orcl-2013.csv")
            quandl.download_daily_bars("GOOG", "NASDAQ_ORCL", 2013, path, auth_token)
            bf = quandlfeed.Feed()
            bf.setNoAdjClose()
            bf.addBarsFromCSV(instrument, path)
            bf.loadAll()
            self.assertEquals(bf[instrument][-1].getDateTime(), datetime.datetime(2013, 12, 31))
            self.assertEquals(bf[instrument][-1].getOpen(), 37.94)
            self.assertEquals(bf[instrument][-1].getHigh(), 38.34)
            self.assertEquals(bf[instrument][-1].getLow(), 37.88)
            self.assertEquals(bf[instrument][-1].getClose(), 38.26)
            self.assertEquals(bf[instrument][-1].getVolume(), 11747517)
            self.assertEquals(bf[instrument][-1].getAdjClose(), None)
            self.assertEquals(bf[instrument][-1].getPrice(), 38.26)

    def testDownloadAndParseWeekly(self):
        with common.TmpDir() as tmpPath:
            instrument = "AAPL"
            path = os.path.join(tmpPath, "quandl-aapl-weekly-2010.csv")
            quandl.download_weekly_bars("WIKI", instrument, 2010, path, auth_token)
            bf = quandlfeed.Feed(frequency=bar.Frequency.WEEK)
            bf.addBarsFromCSV(instrument, path)
            bf.loadAll()
            self.assertEquals(bf[instrument][0].getDateTime(), datetime.datetime(2010, 1, 3))
            self.assertEquals(bf[instrument][-1].getDateTime(), datetime.datetime(2010, 12, 26))
            self.assertEquals(bf[instrument][-1].getOpen(), 325.0)
            self.assertEquals(bf[instrument][-1].getHigh(), 325.15)
            self.assertEquals(bf[instrument][-1].getLow(), 323.17)
            self.assertEquals(bf[instrument][-1].getClose(), 323.6)
            self.assertEquals(bf[instrument][-1].getVolume(), 7969900)
            self.assertEquals(bf[instrument][-1].getPrice(), 323.6)
            # Not checking against a specific value since this is going to change
            # as time passes by.
            self.assertNotEquals(bf[instrument][-1].getAdjClose(), None)

    def testInvalidFrequency(self):
        with self.assertRaisesRegexp(Exception, "Invalid frequency.*"):
            quandlfeed.Feed(frequency=bar.Frequency.MINUTE)

    def testBuildFeedDaily(self):
        with common.TmpDir() as tmpPath:
            instrument = "ORCL"
            bf = quandl.build_feed("WIKI", [instrument], 2010, 2010, tmpPath, authToken=auth_token)
            bf.loadAll()
            self.assertEquals(bf[instrument][-1].getDateTime(), datetime.datetime(2010, 12, 31))
            self.assertEquals(bf[instrument][-1].getOpen(), 31.22)
            self.assertEquals(bf[instrument][-1].getHigh(), 31.33)
            self.assertEquals(bf[instrument][-1].getLow(), 30.93)
            self.assertEquals(bf[instrument][-1].getClose(), 31.3)
            self.assertEquals(bf[instrument][-1].getVolume(), 11716300)
            self.assertEquals(bf[instrument][-1].getAdjClose(), 30.23179912467581)
            self.assertEquals(bf[instrument][-1].getPrice(), 31.3)

    def testBuildFeedWeekly(self):
        with common.TmpDir() as tmpPath:
            instrument = "AAPL"
            bf = quandl.build_feed("WIKI", [instrument], 2010, 2010, tmpPath, bar.Frequency.WEEK, authToken=auth_token)
            bf.loadAll()
            self.assertEquals(bf[instrument][0].getDateTime(), datetime.datetime(2010, 1, 3))
            self.assertEquals(bf[instrument][-1].getDateTime(), datetime.datetime(2010, 12, 26))
            self.assertEquals(bf[instrument][-1].getOpen(), 325.0)
            self.assertEquals(bf[instrument][-1].getHigh(), 325.15)
            self.assertEquals(bf[instrument][-1].getLow(), 323.17)
            self.assertEquals(bf[instrument][-1].getClose(), 323.6)
            self.assertEquals(bf[instrument][-1].getVolume(), 7969900)
            self.assertEquals(bf[instrument][-1].getPrice(), 323.6)
            # Not checking against a specific value since this is going to change
            # as time passes by.
            self.assertNotEquals(bf[instrument][-1].getAdjClose(), None)


########NEW FILE########
__FILENAME__ = resample_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime
import os

from pyalgotrade.barfeed import ninjatraderfeed
from pyalgotrade.barfeed import csvfeed
from pyalgotrade.tools import resample
from pyalgotrade import marketsession
from pyalgotrade.utils import dt
from pyalgotrade.dataseries import resampled
from pyalgotrade.dataseries import bards
from pyalgotrade import bar
import common


class ResampleTestCase(unittest.TestCase):
    def testSlotDateTime(self):
        # 1 minute
        self.assertEqual(resampled.get_slot_datetime(datetime.datetime(2011, 1, 1, 1, 1, 1), 60), datetime.datetime(2011, 1, 1, 1, 1))
        self.assertEqual(resampled.get_slot_datetime(datetime.datetime(2011, 1, 1, 1, 1, 1, microsecond=1), 60), datetime.datetime(2011, 1, 1, 1, 1))
        # 5 minute
        self.assertEqual(resampled.get_slot_datetime(datetime.datetime(2011, 1, 1, 1, 0), 60*5), datetime.datetime(2011, 1, 1, 1, 0))
        self.assertEqual(resampled.get_slot_datetime(datetime.datetime(2011, 1, 1, 1, 1), 60*5), datetime.datetime(2011, 1, 1, 1, 0))
        self.assertEqual(resampled.get_slot_datetime(datetime.datetime(2011, 1, 1, 1, 4), 60*5), datetime.datetime(2011, 1, 1, 1, 0))
        self.assertEqual(resampled.get_slot_datetime(datetime.datetime(2011, 1, 1, 1, 5), 60*5), datetime.datetime(2011, 1, 1, 1, 5))
        # 1 hour
        self.assertEqual(resampled.get_slot_datetime(datetime.datetime(2011, 1, 1, 1, 1, 1), 60*60), datetime.datetime(2011, 1, 1, 1))
        self.assertEqual(resampled.get_slot_datetime(datetime.datetime(2011, 1, 1, 1, 1, 1, microsecond=1), 60*60), datetime.datetime(2011, 1, 1, 1))
        # 1 day
        self.assertEqual(resampled.get_slot_datetime(datetime.datetime(2011, 1, 1, 1, 1, 1), 60*60*24), datetime.datetime(2011, 1, 1))
        self.assertEqual(resampled.get_slot_datetime(datetime.datetime(2011, 1, 1, 1, 1, 1, microsecond=1), 60*60*24), datetime.datetime(2011, 1, 1))

    def testResample(self):
        barDs = bards.BarDataSeries()
        resampledBarDS = resampled.ResampledBarDataSeries(barDs, bar.Frequency.MINUTE)

        barDs.append(bar.BasicBar(datetime.datetime(2011, 1, 1, 1, 1, 1), 2.1, 3, 1, 2, 10, 1, bar.Frequency.SECOND))
        barDs.append(bar.BasicBar(datetime.datetime(2011, 1, 1, 1, 1, 2), 2, 3, 1, 2.3, 10, 2, bar.Frequency.SECOND))
        barDs.append(bar.BasicBar(datetime.datetime(2011, 1, 1, 1, 2, 1), 2, 3, 1, 2, 10, 2, bar.Frequency.SECOND))

        self.assertEqual(len(resampledBarDS), 1)
        self.assertEqual(resampledBarDS[0].getDateTime(), datetime.datetime(2011, 1, 1, 1, 1))
        self.assertEqual(resampledBarDS[0].getOpen(), 2.1)
        self.assertEqual(resampledBarDS[0].getHigh(), 3)
        self.assertEqual(resampledBarDS[0].getLow(), 1)
        self.assertEqual(resampledBarDS[0].getClose(), 2.3)
        self.assertEqual(resampledBarDS[0].getVolume(), 20)
        self.assertEqual(resampledBarDS[0].getAdjClose(), 2)

        resampledBarDS.pushLast()
        self.assertEqual(len(resampledBarDS), 2)
        self.assertEqual(resampledBarDS[1].getDateTime(), datetime.datetime(2011, 1, 1, 1, 2))
        self.assertEqual(resampledBarDS[1].getOpen(), 2)
        self.assertEqual(resampledBarDS[1].getHigh(), 3)
        self.assertEqual(resampledBarDS[1].getLow(), 1)
        self.assertEqual(resampledBarDS[1].getClose(), 2)
        self.assertEqual(resampledBarDS[1].getVolume(), 10)
        self.assertEqual(resampledBarDS[1].getAdjClose(), 2)

    def testResampleNinjaTraderHour(self):
        common.init_temp_path()

        # Resample.
        feed = ninjatraderfeed.Feed(ninjatraderfeed.Frequency.MINUTE)
        feed.addBarsFromCSV("spy", common.get_data_file_path("nt-spy-minute-2011.csv"))
        resampledBarDS = resampled.ResampledBarDataSeries(feed["spy"], bar.Frequency.HOUR)
        resampledFile = os.path.join(common.get_temp_path(), "hour-nt-spy-minute-2011.csv")
        resample.resample_to_csv(feed, bar.Frequency.HOUR, resampledFile)
        resampledBarDS.pushLast()  # Need to manually push the last stot since time didn't change.

        # Load the resampled file.
        feed = csvfeed.GenericBarFeed(bar.Frequency.HOUR, marketsession.USEquities.getTimezone())
        feed.addBarsFromCSV("spy", resampledFile)
        feed.loadAll()

        self.assertEqual(len(feed["spy"]), 340)
        self.assertEqual(feed["spy"][0].getDateTime(), dt.localize(datetime.datetime(2011, 1, 3, 9), marketsession.USEquities.getTimezone()))
        self.assertEqual(feed["spy"][-1].getDateTime(), dt.localize(datetime.datetime(2011, 2, 1, 1), marketsession.USEquities.getTimezone()))
        self.assertEqual(feed["spy"][0].getOpen(), 126.35)
        self.assertEqual(feed["spy"][0].getHigh(), 126.45)
        self.assertEqual(feed["spy"][0].getLow(), 126.3)
        self.assertEqual(feed["spy"][0].getClose(), 126.4)
        self.assertEqual(feed["spy"][0].getVolume(), 3397.0)
        self.assertEqual(feed["spy"][0].getAdjClose(), None)

        self.assertEqual(len(resampledBarDS), len(feed["spy"]))
        self.assertEqual(resampledBarDS[0].getDateTime(), dt.as_utc(datetime.datetime(2011, 1, 3, 9)))
        self.assertEqual(resampledBarDS[-1].getDateTime(), dt.as_utc(datetime.datetime(2011, 2, 1, 1)))

    def testResampleNinjaTraderDay(self):
        common.init_temp_path()

        # Resample.
        feed = ninjatraderfeed.Feed(ninjatraderfeed.Frequency.MINUTE)
        feed.addBarsFromCSV("spy", common.get_data_file_path("nt-spy-minute-2011.csv"))
        resampledBarDS = resampled.ResampledBarDataSeries(feed["spy"], bar.Frequency.DAY)
        resampledFile = os.path.join(common.get_temp_path(), "day-nt-spy-minute-2011.csv")
        resample.resample_to_csv(feed, bar.Frequency.DAY, resampledFile)
        resampledBarDS.pushLast()  # Need to manually push the last stot since time didn't change.

        # Load the resampled file.
        feed = csvfeed.GenericBarFeed(bar.Frequency.DAY)
        feed.addBarsFromCSV("spy", resampledFile, marketsession.USEquities.getTimezone())
        feed.loadAll()

        self.assertEqual(len(feed["spy"]), 25)
        self.assertEqual(feed["spy"][0].getDateTime(), dt.localize(datetime.datetime(2011, 1, 3), marketsession.USEquities.getTimezone()))
        self.assertEqual(feed["spy"][-1].getDateTime(), dt.localize(datetime.datetime(2011, 2, 1), marketsession.USEquities.getTimezone()))

        self.assertEqual(len(resampledBarDS), len(feed["spy"]))
        self.assertEqual(resampledBarDS[0].getDateTime(), dt.as_utc(datetime.datetime(2011, 1, 3)))
        self.assertEqual(resampledBarDS[-1].getDateTime(), dt.as_utc(datetime.datetime(2011, 2, 1)))

########NEW FILE########
__FILENAME__ = returns_analyzer_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.barfeed import csvfeed
from pyalgotrade.stratanalyzer import returns
from pyalgotrade import broker
from pyalgotrade import marketsession

import strategy_test
import position_test
import common

import unittest
import datetime


class PosTrackerTestCase(unittest.TestCase):
    invalid_price = 5000

    def testBuyAndSellBreakEvenWithCommission(self):
        posTracker = returns.PositionTracker()
        posTracker.buy(1, 10, 0.01)
        posTracker.sell(1, 10.02, 0.01)
        self.assertTrue(posTracker.getCost() == 10)
        # We need to round here or else the testcase fails since the value returned is not exactly 0.<
        # The same issue can be reproduced with this piece of code:
        # a = 10.02 - 10
        # b = 0.02
        # print a - b
        # print a - b == 0
        self.assertTrue(round(posTracker.getNetProfit(PosTrackerTestCase.invalid_price), 2) == 0.0)
        self.assertTrue(round(posTracker.getReturn(PosTrackerTestCase.invalid_price), 2) == 0.0)

    def testBuyAndSellBreakEven(self):
        posTracker = returns.PositionTracker()
        posTracker.buy(1, 10)
        posTracker.sell(1, 10)
        self.assertTrue(posTracker.getCost() == 10)
        self.assertTrue(posTracker.getNetProfit(PosTrackerTestCase.invalid_price) == 0)
        self.assertTrue(posTracker.getReturn(PosTrackerTestCase.invalid_price) == 0)

    def testBuyAndSellWin(self):
        posTracker = returns.PositionTracker()
        posTracker.buy(1, 10)
        posTracker.sell(1, 11)
        self.assertTrue(posTracker.getCost() == 10)
        self.assertTrue(posTracker.getNetProfit(PosTrackerTestCase.invalid_price) == 1)
        self.assertTrue(posTracker.getReturn(PosTrackerTestCase.invalid_price) == 0.1)

    def testBuyAndSellMultipleEvals(self):
        posTracker = returns.PositionTracker()
        posTracker.buy(2, 10)
        self.assertTrue(posTracker.getCost() == 20)
        self.assertTrue(posTracker.getNetProfit(10) == 0)
        self.assertTrue(posTracker.getReturn(10) == 0)

        self.assertTrue(posTracker.getNetProfit(11) == 2)
        self.assertTrue(posTracker.getReturn(11) == 0.1)

        self.assertTrue(posTracker.getNetProfit(20) == 20)
        self.assertTrue(posTracker.getReturn(20) == 1)

        posTracker.sell(1, 11)
        self.assertTrue(posTracker.getCost() == 20)
        self.assertTrue(posTracker.getNetProfit(11) == 2)
        self.assertTrue(posTracker.getReturn(11) == 0.1)

        posTracker.sell(1, 10)
        self.assertTrue(posTracker.getCost() == 20)
        self.assertTrue(posTracker.getNetProfit(PosTrackerTestCase.invalid_price) == 1)
        self.assertTrue(posTracker.getReturn(11) == 0.05)

    def testSellAndBuyWin(self):
        posTracker = returns.PositionTracker()
        posTracker.sell(1, 11)
        posTracker.buy(1, 10)
        self.assertTrue(posTracker.getCost() == 11)
        self.assertTrue(posTracker.getNetProfit(PosTrackerTestCase.invalid_price) == 1)
        self.assertTrue(round(posTracker.getReturn(PosTrackerTestCase.invalid_price), 4) == round(0.090909091, 4))

    def testSellAndBuyMultipleEvals(self):
        posTracker = returns.PositionTracker()
        posTracker.sell(2, 11)
        self.assertTrue(posTracker.getCost() == 22)
        self.assertTrue(posTracker.getNetProfit(11) == 0)
        self.assertTrue(posTracker.getReturn(11) == 0)

        posTracker.buy(1, 10)
        self.assertTrue(posTracker.getCost() == 22)
        self.assertTrue(posTracker.getNetProfit(11) == 1)
        self.assertTrue(round(posTracker.getReturn(11), 4) == round(0.045454545, 4))

        posTracker.buy(1, 10)
        self.assertTrue(posTracker.getCost() == 22)
        self.assertTrue(posTracker.getNetProfit(PosTrackerTestCase.invalid_price) == 2)
        self.assertTrue(round(posTracker.getReturn(PosTrackerTestCase.invalid_price), 4) == round(0.090909091, 4))

    def testBuySellBuy(self):
        posTracker = returns.PositionTracker()
        posTracker.buy(1, 10)
        self.assertTrue(posTracker.getCost() == 10)

        posTracker.sell(2, 13)  # Short selling 1 @ $13
        self.assertTrue(posTracker.getCost() == 10 + 13)

        posTracker.buy(1, 10)
        self.assertTrue(posTracker.getCost() == 10 + 13)
        self.assertTrue(posTracker.getNetProfit(PosTrackerTestCase.invalid_price) == 6)
        self.assertTrue(round(posTracker.getReturn(PosTrackerTestCase.invalid_price), 4) == round(0.260869565, 4))

    def testBuyAndUpdate(self):
        posTracker = returns.PositionTracker()
        posTracker.buy(1, 10)
        self.assertTrue(posTracker.getCost() == 10)
        self.assertTrue(posTracker.getNetProfit(20) == 10)
        self.assertTrue(posTracker.getReturn(20) == 1)

        posTracker.update(15)
        self.assertTrue(posTracker.getCost() == 15)
        self.assertTrue(posTracker.getNetProfit(15) == 0)
        self.assertTrue(posTracker.getReturn(15) == 0)

        self.assertTrue(posTracker.getNetProfit(20) == 5)
        self.assertTrue(round(posTracker.getReturn(20), 2) == 0.33)

    def testBuyUpdateAndSell(self):
        posTracker = returns.PositionTracker()
        posTracker.buy(1, 10)
        self.assertTrue(posTracker.getCost() == 10)
        self.assertTrue(posTracker.getNetProfit(15) == 5)
        self.assertTrue(posTracker.getReturn(15) == 0.5)

        posTracker.update(15)
        self.assertTrue(posTracker.getCost() == 15)
        posTracker.sell(1, 20)
        self.assertTrue(posTracker.getCost() == 15)
        self.assertTrue(posTracker.getNetProfit(PosTrackerTestCase.invalid_price) == 5)
        self.assertTrue(round(posTracker.getReturn(PosTrackerTestCase.invalid_price), 2) == 0.33)

        posTracker.update(100)
        self.assertTrue(posTracker.getCost() == 0)
        self.assertTrue(posTracker.getNetProfit(PosTrackerTestCase.invalid_price) == 0)
        self.assertTrue(posTracker.getReturn(PosTrackerTestCase.invalid_price) == 0)

    def testBuyAndSellBreakEvenWithCommision(self):
        posTracker = returns.PositionTracker()
        posTracker.buy(1, 10, 0.5)
        posTracker.sell(1, 11, 0.5)
        self.assertTrue(posTracker.getCost() == 10)
        self.assertTrue(posTracker.getNetProfit(PosTrackerTestCase.invalid_price, False) == 1)
        self.assertTrue(posTracker.getReturn(PosTrackerTestCase.invalid_price, False) == 0.1)

        self.assertTrue(posTracker.getNetProfit(PosTrackerTestCase.invalid_price, True) == 0)
        self.assertTrue(posTracker.getReturn(PosTrackerTestCase.invalid_price, True) == 0)

    def testLongShortEqualAmount(self):
        posTrackerXYZ = returns.PositionTracker()
        posTrackerXYZ.buy(11, 10)
        posTrackerXYZ.sell(11, 30)
        self.assertTrue(posTrackerXYZ.getCost() == 11*10)
        self.assertTrue(posTrackerXYZ.getNetProfit(PosTrackerTestCase.invalid_price) == 20*11)
        self.assertTrue(posTrackerXYZ.getReturn(PosTrackerTestCase.invalid_price) == 2)

        posTrackerABC = returns.PositionTracker()
        posTrackerABC.sell(100, 1.1)
        posTrackerABC.buy(100, 1)
        self.assertTrue(posTrackerABC.getCost() == 100*1.1)
        self.assertTrue(round(posTrackerABC.getNetProfit(PosTrackerTestCase.invalid_price), 2) == 100*0.1)
        self.assertEqual(round(posTrackerABC.getReturn(PosTrackerTestCase.invalid_price), 2), 0.09)

        combinedCost = posTrackerXYZ.getCost() + posTrackerABC.getCost()
        combinedPL = posTrackerXYZ.getNetProfit(PosTrackerTestCase.invalid_price) + posTrackerABC.getNetProfit(PosTrackerTestCase.invalid_price)
        combinedReturn = combinedPL / float(combinedCost)
        self.assertTrue(round(combinedReturn, 9) == 1.045454545)


class ReturnsTestCase(unittest.TestCase):
    TestInstrument = "any"

    def testOneBarReturn(self):
        initialCash = 1000
        barFeed = yahoofeed.Feed()
        barFeed.setBarFilter(csvfeed.DateRangeFilter(datetime.datetime(2001, 12, 07), datetime.datetime(2001, 12, 07)))
        barFeed.addBarsFromCSV(ReturnsTestCase.TestInstrument, common.get_data_file_path("orcl-2001-yahoofinance.csv"))
        strat = strategy_test.TestStrategy(barFeed, initialCash)

        # 2001-12-07,15.74,15.95,15.55,15.91,42463200,15.56
        # Manually place the orders to get them filled on the first (and only) bar.
        order = strat.getBroker().createMarketOrder(broker.Order.Action.BUY, ReturnsTestCase.TestInstrument, 1, False)  # Open: 15.74
        strat.getBroker().placeOrder(order)
        order = strat.getBroker().createMarketOrder(broker.Order.Action.SELL, ReturnsTestCase.TestInstrument, 1, True)  # Close: 15.91
        strat.getBroker().placeOrder(order)

        stratAnalyzer = returns.Returns()
        strat.attachAnalyzer(stratAnalyzer)
        strat.run()
        self.assertTrue(strat.getBroker().getCash() == initialCash + (15.91 - 15.74))

        finalValue = 1000 - 15.74 + 15.91
        rets = (finalValue - initialCash) / float(initialCash)
        self.assertEqual(stratAnalyzer.getReturns()[-1], rets)

    def testTwoBarReturns_OpenOpen(self):
        initialCash = 15.61
        barFeed = yahoofeed.Feed()
        barFeed.setBarFilter(csvfeed.DateRangeFilter(datetime.datetime(2001, 12, 06), datetime.datetime(2001, 12, 07)))
        barFeed.addBarsFromCSV(ReturnsTestCase.TestInstrument, common.get_data_file_path("orcl-2001-yahoofinance.csv"))
        strat = strategy_test.TestStrategy(barFeed, initialCash)

        # 2001-12-06,15.61,16.03,15.50,15.90,66944900,15.55
        # 2001-12-07,15.74,15.95,15.55,15.91,42463200,15.56
        # Manually place the entry order, to get it filled on the first bar.
        order = strat.getBroker().createMarketOrder(broker.Order.Action.BUY, ReturnsTestCase.TestInstrument, 1, False)  # Open: 15.61
        strat.getBroker().placeOrder(order)
        strat.addOrder(datetime.datetime(2001, 12, 06), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, ReturnsTestCase.TestInstrument, 1, False)  # Open: 15.74

        stratAnalyzer = returns.Returns()
        strat.attachAnalyzer(stratAnalyzer)
        strat.run()
        self.assertTrue(strat.getBroker().getCash() == initialCash + (15.74 - 15.61))
        # First day returns: Open vs Close
        self.assertTrue(stratAnalyzer.getReturns()[0] == (15.90 - 15.61) / 15.61)
        # Second day returns: Open vs Prev. day's close
        self.assertTrue(stratAnalyzer.getReturns()[1] == (15.74 - 15.90) / 15.90)

    def testTwoBarReturns_OpenClose(self):
        initialCash = 15.61
        barFeed = yahoofeed.Feed()
        barFeed.setBarFilter(csvfeed.DateRangeFilter(datetime.datetime(2001, 12, 06), datetime.datetime(2001, 12, 07)))
        barFeed.addBarsFromCSV(ReturnsTestCase.TestInstrument, common.get_data_file_path("orcl-2001-yahoofinance.csv"))
        strat = strategy_test.TestStrategy(barFeed, initialCash)

        # 2001-12-06,15.61,16.03,15.50,15.90,66944900,15.55
        # 2001-12-07,15.74,15.95,15.55,15.91,42463200,15.56
        # Manually place the entry order, to get it filled on the first bar.
        order = strat.getBroker().createMarketOrder(broker.Order.Action.BUY, ReturnsTestCase.TestInstrument, 1, False)  # Open: 15.61
        strat.getBroker().placeOrder(order)
        strat.addOrder(datetime.datetime(2001, 12, 06), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, ReturnsTestCase.TestInstrument, 1, True)  # Close: 15.91

        stratAnalyzer = returns.Returns()
        strat.attachAnalyzer(stratAnalyzer)
        strat.run()
        self.assertTrue(strat.getBroker().getCash() == initialCash + (15.91 - 15.61))
        # First day returns: Open vs Close
        self.assertTrue(stratAnalyzer.getReturns()[0] == (15.90 - 15.61) / 15.61)
        # Second day returns: Close vs Prev. day's close
        self.assertTrue(stratAnalyzer.getReturns()[1] == (15.91 - 15.90) / 15.90)

    def testTwoBarReturns_CloseOpen(self):
        initialCash = 15.9
        barFeed = yahoofeed.Feed()
        barFeed.setBarFilter(csvfeed.DateRangeFilter(datetime.datetime(2001, 12, 06), datetime.datetime(2001, 12, 07)))
        barFeed.addBarsFromCSV(ReturnsTestCase.TestInstrument, common.get_data_file_path("orcl-2001-yahoofinance.csv"))
        strat = strategy_test.TestStrategy(barFeed, initialCash)

        # 2001-12-06,15.61,16.03,15.50,15.90,66944900,15.55
        # 2001-12-07,15.74,15.95,15.55,15.91,42463200,15.56
        # Manually place the entry order, to get it filled on the first bar.
        order = strat.getBroker().createMarketOrder(broker.Order.Action.BUY, ReturnsTestCase.TestInstrument, 1, True)  # Close: 15.90
        strat.getBroker().placeOrder(order)
        strat.addOrder(datetime.datetime(2001, 12, 06), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, ReturnsTestCase.TestInstrument, 1, False)  # Open: 15.74

        stratAnalyzer = returns.Returns()
        strat.attachAnalyzer(stratAnalyzer)
        strat.run()
        self.assertTrue(strat.getBroker().getCash() == initialCash + (15.74 - 15.90))
        # First day returns: 0
        self.assertTrue(stratAnalyzer.getReturns()[0] == 0)
        # Second day returns: Open vs Prev. day's close
        self.assertTrue(stratAnalyzer.getReturns()[1] == (15.74 - 15.90) / 15.90)

    def testTwoBarReturns_CloseClose(self):
        initialCash = 15.90
        barFeed = yahoofeed.Feed()
        barFeed.setBarFilter(csvfeed.DateRangeFilter(datetime.datetime(2001, 12, 06), datetime.datetime(2001, 12, 07)))
        barFeed.addBarsFromCSV(ReturnsTestCase.TestInstrument, common.get_data_file_path("orcl-2001-yahoofinance.csv"))
        strat = strategy_test.TestStrategy(barFeed, initialCash)

        # 2001-12-06,15.61,16.03,15.50,15.90,66944900,15.55
        # 2001-12-07,15.74,15.95,15.55,15.91,42463200,15.56
        # Manually place the entry order, to get it filled on the first bar.
        order = strat.getBroker().createMarketOrder(broker.Order.Action.BUY, ReturnsTestCase.TestInstrument, 1, True)  # Close: 15.90
        strat.getBroker().placeOrder(order)
        strat.addOrder(datetime.datetime(2001, 12, 06), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, ReturnsTestCase.TestInstrument, 1, True)  # Close: 15.91

        stratAnalyzer = returns.Returns()
        strat.attachAnalyzer(stratAnalyzer)
        strat.run()
        self.assertTrue(strat.getBroker().getCash() == initialCash + (15.91 - 15.90))
        # First day returns: 0
        self.assertTrue(stratAnalyzer.getReturns()[0] == 0)
        # Second day returns: Open vs Prev. day's close
        self.assertTrue(stratAnalyzer.getReturns()[1] == (15.91 - 15.90) / 15.90)

    def testCumulativeReturn(self):
        initialCash = 33.06
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV(ReturnsTestCase.TestInstrument, common.get_data_file_path("orcl-2001-yahoofinance.csv"))
        strat = position_test.TestStrategy(barFeed, ReturnsTestCase.TestInstrument, initialCash)

        strat.addPosEntry(datetime.datetime(2001, 1, 12), strat.enterLong, ReturnsTestCase.TestInstrument, 1)  # 33.06
        strat.addPosExit(datetime.datetime(2001, 11, 27))  # 14.32

        stratAnalyzer = returns.Returns()
        strat.attachAnalyzer(stratAnalyzer)
        strat.run()
        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(initialCash + (14.32 - 33.06), 2))
        self.assertTrue(round(33.06 * (1 + stratAnalyzer.getCumulativeReturns()[-1]), 2) == 14.32)

    def testGoogle2011(self):
        initialValue = 1000000
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV(ReturnsTestCase.TestInstrument, common.get_data_file_path("goog-2011-yahoofinance.csv"))

        strat = strategy_test.TestStrategy(barFeed, initialValue)
        order = strat.getBroker().createMarketOrder(broker.Order.Action.BUY, ReturnsTestCase.TestInstrument, 1654, True)  # 2011-01-03 close: 604.35
        strat.getBroker().placeOrder(order)

        stratAnalyzer = returns.Returns()
        strat.attachAnalyzer(stratAnalyzer)
        strat.run()
        finalValue = strat.getBroker().getValue()

        self.assertEqual(round(stratAnalyzer.getCumulativeReturns()[-1], 4), round((finalValue - initialValue) / float(initialValue), 4))

    def testMultipleInstrumentsInterleaved(self):
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV("spy", common.get_data_file_path("spy-2010-yahoofinance.csv"), marketsession.NYSE.getTimezone())
        barFeed.addBarsFromCSV("nikkei", common.get_data_file_path("nikkei-2010-yahoofinance.csv"), marketsession.TSE.getTimezone())

        strat = strategy_test.TestStrategy(barFeed, 1000)
        stratAnalyzer = returns.Returns()
        strat.attachAnalyzer(stratAnalyzer)

        strat.order("spy", 1)
        strat.run()
        # The cumulative return should be the same if we load nikkei or not.
        self.assertEqual(round(stratAnalyzer.getCumulativeReturns()[-1], 5), 0.01338)

    def testFirstBar(self):
        initialCash = 1000
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV(ReturnsTestCase.TestInstrument, common.get_data_file_path("orcl-2001-yahoofinance.csv"))
        strat = strategy_test.TestStrategy(barFeed, initialCash)

        strat.addOrder(datetime.datetime(2001, 01, 02), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, ReturnsTestCase.TestInstrument, 1, False)  # 2001-01-03 Open: 25.25 Close: 32.00

        stratAnalyzer = returns.Returns()
        strat.attachAnalyzer(stratAnalyzer)
        strat.run()
        self.assertEqual(stratAnalyzer.getReturns()[0], 0)
        self.assertEqual(stratAnalyzer.getReturns()[1], (32.00 - 25.25) / 1000)

########NEW FILE########
__FILENAME__ = sharpe_analyzer_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.barfeed import ninjatraderfeed
from pyalgotrade.barfeed import csvfeed
from pyalgotrade.stratanalyzer import sharpe
from pyalgotrade.broker import backtesting
from pyalgotrade import broker
from pyalgotrade import marketsession

import strategy_test
import common

import unittest
import datetime


class SharpeRatioTestCase(unittest.TestCase):
    def testDateTimeDiffs(self):
        # sharpe.days_traded
        self.assertEqual(sharpe.days_traded(datetime.datetime(2001, 1, 1), datetime.datetime(2001, 1, 2)), 2)
        self.assertEqual(sharpe.days_traded(datetime.datetime(2001, 1, 1), datetime.datetime(2001, 1, 2, 12)), 2)
        self.assertEqual(sharpe.days_traded(datetime.datetime(2001, 1, 1), datetime.datetime(2001, 1, 1, 12)), 1)
        self.assertEqual(sharpe.days_traded(datetime.datetime(2001, 1, 1), datetime.datetime(2001, 1, 1, 6)), 1)
        self.assertEqual(sharpe.days_traded(datetime.datetime(2001, 1, 1), datetime.datetime(2001, 1, 2, 6)), 2)

    def testNoTrades(self):
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV("ige", common.get_data_file_path("sharpe-ratio-test-ige.csv"))
        strat = strategy_test.TestStrategy(barFeed, 1000)
        stratAnalyzer = sharpe.SharpeRatio()
        strat.attachAnalyzer(stratAnalyzer)

        strat.run()
        self.assertTrue(strat.getBroker().getCash() == 1000)
        self.assertTrue(stratAnalyzer.getSharpeRatio(0.04, True) == 0)
        self.assertTrue(stratAnalyzer.getSharpeRatio(0) == 0)
        self.assertTrue(stratAnalyzer.getSharpeRatio(0, True) == 0)

    def __testIGE_BrokerImpl(self, quantity):
        initialCash = 42.09 * quantity
        # This testcase is based on an example from Ernie Chan's book:
        # 'Quantitative Trading: How to Build Your Own Algorithmic Trading Business'
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV("ige", common.get_data_file_path("sharpe-ratio-test-ige.csv"))
        strat = strategy_test.TestStrategy(barFeed, initialCash)
        strat.setUseAdjustedValues(True)
        strat.setBrokerOrdersGTC(True)
        stratAnalyzer = sharpe.SharpeRatio()
        strat.attachAnalyzer(stratAnalyzer)

        # Disable volume checks to match book results.
        strat.getBroker().getFillStrategy().setVolumeLimit(None)

        # Manually place the order to get it filled on the first bar.
        order = strat.getBroker().createMarketOrder(broker.Order.Action.BUY, "ige", quantity, True)  # Adj. Close: 42.09
        order.setGoodTillCanceled(True)
        strat.getBroker().placeOrder(order)
        strat.addOrder(datetime.datetime(2007, 11, 13), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, "ige", quantity, True)  # Adj. Close: 127.64
        strat.run()
        self.assertEqual(round(strat.getBroker().getCash(), 2), initialCash + (127.64 - 42.09) * quantity)
        self.assertEqual(strat.orderUpdatedCalls, 4)
        # The results are slightly different only because I'm taking into account the first bar as well.
        self.assertEqual(round(stratAnalyzer.getSharpeRatio(0.04, True), 4), 0.7889)
        self.assertEqual(round(stratAnalyzer.getSharpeRatio(0.04, False), 4), 0.0497)

    def testIGE_Broker(self):
        self.__testIGE_BrokerImpl(1)

    def testIGE_Broker2(self):
        self.__testIGE_BrokerImpl(2)

    def testIGE_BrokerWithCommission(self):
        commision = 0.5
        initialCash = 42.09 + commision
        # This testcase is based on an example from Ernie Chan's book:
        # 'Quantitative Trading: How to Build Your Own Algorithmic Trading Business'
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV("ige", common.get_data_file_path("sharpe-ratio-test-ige.csv"))
        strat = strategy_test.TestStrategy(barFeed, initialCash)
        strat.getBroker().setCommission(backtesting.FixedPerTrade(commision))
        strat.setUseAdjustedValues(True)
        strat.setBrokerOrdersGTC(True)
        stratAnalyzer = sharpe.SharpeRatio()
        strat.attachAnalyzer(stratAnalyzer)

        # Disable volume checks to match book results.
        strat.getBroker().getFillStrategy().setVolumeLimit(None)

        # Manually place the order to get it filled on the first bar.
        order = strat.getBroker().createMarketOrder(broker.Order.Action.BUY, "ige", 1, True)  # Adj. Close: 42.09
        order.setGoodTillCanceled(True)
        strat.getBroker().placeOrder(order)
        strat.addOrder(datetime.datetime(2007, 11, 13), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, "ige", 1, True)  # Adj. Close: 127.64

        strat.run()
        self.assertTrue(round(strat.getBroker().getCash(), 2) == initialCash + (127.64 - 42.09 - commision*2))
        self.assertEqual(strat.orderUpdatedCalls, 4)
        # The results are slightly different only because I'm taking into account the first bar as well,
        # and I'm also adding commissions.
        self.assertEqual(round(stratAnalyzer.getSharpeRatio(0.04, True), 6), 0.776443)

    def testIntraDay(self):
        barFeed = ninjatraderfeed.Feed(ninjatraderfeed.Frequency.MINUTE, marketsession.USEquities.getTimezone())
        barFeed.setBarFilter(csvfeed.USEquitiesRTH())
        barFeed.addBarsFromCSV("spy", common.get_data_file_path("nt-spy-minute-2011.csv"))
        strat = strategy_test.TestStrategy(barFeed, 1000)
        stratAnalyzer = sharpe.SharpeRatio(False)
        strat.attachAnalyzer(stratAnalyzer)
        strat.order("spy", 1)

        strat.run()

        tradingPeriods = 252*6.5*60
        manualAnnualized = sharpe.sharpe_ratio(stratAnalyzer.getReturns(), 0.04, tradingPeriods, True)
        manualNotAnnualized = sharpe.sharpe_ratio(stratAnalyzer.getReturns(), 0.04, tradingPeriods, False)
        analyzerAnnualized = stratAnalyzer.getSharpeRatio(0.04)
        analyzerNotAnnualized = stratAnalyzer.getSharpeRatio(0.04, False)

        self.assertEqual(round(analyzerAnnualized, 10), -1.1814830854)
        self.assertEqual(round(analyzerNotAnnualized, 10), -0.0037659686)
        # They should be similar, but not identical because the analyzer uses 365 days/year
        # when useDailyReturns is set to False.
        self.assertEqual(round(analyzerAnnualized, 1), round(manualAnnualized, 1))
        self.assertEqual(round(analyzerNotAnnualized, 3), round(manualNotAnnualized, 3))

########NEW FILE########
__FILENAME__ = smacrossover_strategy_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest

from pyalgotrade import strategy
from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.technical import ma
from pyalgotrade.technical import cross
import common


class SMACrossOverStrategy(strategy.BacktestingStrategy):
    def __init__(self, feed, fastSMA, slowSMA):
        strategy.BacktestingStrategy.__init__(self, feed, 1000)
        ds = feed["orcl"].getPriceDataSeries()
        self.__fastSMADS = ma.SMA(ds, fastSMA)
        self.__slowSMADS = ma.SMA(ds, slowSMA)
        self.__longPos = None
        self.__shortPos = None
        self.__finalValue = None

    def enterLongPosition(self, bars):
        raise Exception("Not implemented")

    def enterShortPosition(self, bars):
        raise Exception("Not implemented")

    def exitLongPosition(self, bars, position):
        raise Exception("Not implemented")

    def exitShortPosition(self, bars, position):
        raise Exception("Not implemented")

    def getFinalValue(self):
        return self.__finalValue

    def printDebug(self, *args):
        args = [str(arg) for arg in args]
        # print " ".join(args)

    def onEnterOk(self, position):
        self.printDebug("enterOk: ", self.getCurrentDateTime(), position.getEntryOrder().getExecutionInfo().getPrice(), position)

    def onEnterCanceled(self, position):
        self.printDebug("enterCanceled: ", self.getCurrentDateTime(), position)
        if position == self.__longPos:
            self.__longPos = None
        elif position == self.__shortPos:
            self.__shortPos = None
        else:
            assert(False)

    def onExitOk(self, position):
        self.printDebug("exitOk: ", self.getCurrentDateTime(), position.getExitOrder().getExecutionInfo().getPrice(), position)
        if position == self.__longPos:
            self.__longPos = None
        elif position == self.__shortPos:
            self.__shortPos = None
        else:
            assert(False)

    def onExitCanceled(self, position):
        self.printDebug("exitCanceled: ", self.getCurrentDateTime(), position, ". Resubmitting as a Market order.")
        # If the exit was canceled, re-submit it.
        position.exit()

    def onBars(self, bars):
        bar = bars.getBar("orcl")
        self.printDebug("%s: O=%s H=%s L=%s C=%s" % (bar.getDateTime(), bar.getOpen(), bar.getHigh(), bar.getLow(), bar.getClose()))

        if cross.cross_above(self.__fastSMADS, self.__slowSMADS) == 1:
            if self.__shortPos:
                self.exitShortPosition(bars, self.__shortPos)
            assert(self.__longPos is None)
            self.__longPos = self.enterLongPosition(bars)
        elif cross.cross_below(self.__fastSMADS, self.__slowSMADS) == 1:
            if self.__longPos:
                self.exitLongPosition(bars, self.__longPos)
            assert(self.__shortPos is None)
            self.__shortPos = self.enterShortPosition(bars)

    def onFinish(self, bars):
        self.__finalValue = self.getBroker().getValue()


class MarketOrderStrategy(SMACrossOverStrategy):
    def enterLongPosition(self, bars):
        return self.enterLong("orcl", 10)

    def enterShortPosition(self, bars):
        return self.enterShort("orcl", 10)

    def exitLongPosition(self, bars, position):
        position.exit()

    def exitShortPosition(self, bars, position):
        position.exit()


class LimitOrderStrategy(SMACrossOverStrategy):
    def __getMiddlePrice(self, bars):
        bar = bars.getBar("orcl")
        ret = bar.getLow() + (bar.getHigh() - bar.getLow()) / 2.0
        ret = round(ret, 2)
        return ret

    def enterLongPosition(self, bars):
        price = self.__getMiddlePrice(bars)
        ret = self.enterLongLimit("orcl", price, 10)
        self.printDebug("enterLong:", self.getCurrentDateTime(), price, ret)
        return ret

    def enterShortPosition(self, bars):
        price = self.__getMiddlePrice(bars)
        ret = self.enterShortLimit("orcl", price, 10)
        self.printDebug("enterShort:", self.getCurrentDateTime(), price, ret)
        return ret

    def exitLongPosition(self, bars, position):
        price = self.__getMiddlePrice(bars)
        self.printDebug("exitLong:", self.getCurrentDateTime(), price, position)
        position.exit(None, price)

    def exitShortPosition(self, bars, position):
        price = self.__getMiddlePrice(bars)
        self.printDebug("exitShort:", self.getCurrentDateTime(), price, position)
        position.exit(limitPrice=price)


class TestSMACrossOver(unittest.TestCase):
    def __test(self, strategyClass, finalValue):
        feed = yahoofeed.Feed()
        feed.addBarsFromCSV("orcl", common.get_data_file_path("orcl-2001-yahoofinance.csv"))
        myStrategy = strategyClass(feed, 10, 25)
        myStrategy.run()
        myStrategy.printDebug("Final result:", round(myStrategy.getFinalValue(), 2))
        self.assertTrue(round(myStrategy.getFinalValue(), 2) == finalValue)

    def testWithMarketOrder(self):
        # This is the exact same result that we get using NinjaTrader.
        self.__test(MarketOrderStrategy, 1000 - 22.7)

    def testWithLimitOrder(self):
        # The result is different than the one we get using NinjaTrader. NinjaTrader processes Limit orders in a different way.
        self.__test(LimitOrderStrategy, 1000 + 32.7)

########NEW FILE########
__FILENAME__ = strategy_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime

from pyalgotrade import strategy
from pyalgotrade import broker
from pyalgotrade.barfeed import yahoofeed
import common


def get_by_datetime_or_date(dict_, dateTimeOrDate):
    ret = dict_.get(dateTimeOrDate, [])
    if len(ret) == 0 and isinstance(dateTimeOrDate, datetime.datetime):
        ret = dict_.get(dateTimeOrDate.date(), [])
    return ret


class TestStrategy(strategy.BacktestingStrategy):
    def __init__(self, barFeed, cash):
        strategy.BacktestingStrategy.__init__(self, barFeed, cash)

        # Maps dates to a tuple of (method, params)
        self.__orderEntry = {}

        self.__brokerOrdersGTC = False
        self.orderUpdatedCalls = 0
        self.onStartCalled = False
        self.onIdleCalled = False
        self.onFinishCalled = False

    def addOrder(self, dateTime, method, *args, **kwargs):
        self.__orderEntry.setdefault(dateTime, [])
        self.__orderEntry[dateTime].append((method, args, kwargs))

    def setBrokerOrdersGTC(self, gtc):
        self.__brokerOrdersGTC = gtc

    def onStart(self):
        self.onStartCalled = True

    def onIdle(self):
        self.onIdleCalled = True

    def onFinish(self, bars):
        self.onFinishCalled = True

    def onOrderUpdated(self, order):
        self.orderUpdatedCalls += 1

    def onBars(self, bars):
        dateTime = bars.getDateTime()

        # Check order entry.
        for meth, args, kwargs in get_by_datetime_or_date(self.__orderEntry, dateTime):
            order = meth(*args, **kwargs)
            order.setGoodTillCanceled(self.__brokerOrdersGTC)
            self.getBroker().placeOrder(order)


class StrategyTestCase(unittest.TestCase):
    TestInstrument = "doesntmatter"

    def loadDailyBarFeed(self):
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV(StrategyTestCase.TestInstrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"))
        return barFeed

    def createStrategy(self):
        barFeed = self.loadDailyBarFeed()
        strat = TestStrategy(barFeed, 1000)
        return strat


class BrokerOrderTestCase(StrategyTestCase):
    def testMarketOrder(self):
        strat = self.createStrategy()

        o = strat.getBroker().createMarketOrder(broker.Order.Action.BUY, StrategyTestCase.TestInstrument, 1)
        strat.getBroker().placeOrder(o)
        strat.run()
        self.assertTrue(o.isFilled())
        self.assertEqual(strat.orderUpdatedCalls, 2)


class StrategyOrderTestCase(StrategyTestCase):
    def testOrder(self):
        strat = self.createStrategy()

        o = strat.order(StrategyTestCase.TestInstrument, 1)
        strat.run()
        self.assertTrue(o.isFilled())
        self.assertEqual(strat.orderUpdatedCalls, 2)

    def testMarketOrderBuy(self):
        strat = self.createStrategy()

        o = strat.marketOrder(StrategyTestCase.TestInstrument, 1)
        strat.run()
        self.assertTrue(o.isFilled())
        self.assertEquals(o.getAction(), broker.Order.Action.BUY)
        self.assertEquals(o.getQuantity(), 1)
        self.assertEquals(o.getFilled(), 1)
        self.assertEquals(o.getRemaining(), 0)
        self.assertEqual(strat.orderUpdatedCalls, 2)

    def testMarketOrderSell(self):
        strat = self.createStrategy()

        o = strat.marketOrder(StrategyTestCase.TestInstrument, -2)
        strat.run()
        self.assertTrue(o.isFilled())
        self.assertEquals(o.getAction(), broker.Order.Action.SELL)
        self.assertEquals(o.getQuantity(), 2)
        self.assertEquals(o.getFilled(), 2)
        self.assertEquals(o.getRemaining(), 0)
        self.assertEqual(strat.orderUpdatedCalls, 2)

    def testLimitOrderBuy(self):
        strat = self.createStrategy()

        o = strat.limitOrder(StrategyTestCase.TestInstrument, 60, 1, True)
        strat.run()
        self.assertTrue(o.isFilled())
        self.assertEquals(o.getAction(), broker.Order.Action.BUY)
        self.assertEquals(o.getAvgFillPrice(), 56.13)
        self.assertEquals(o.getQuantity(), 1)
        self.assertEquals(o.getFilled(), 1)
        self.assertEquals(o.getRemaining(), 0)
        self.assertEqual(strat.orderUpdatedCalls, 2)

    def testLimitOrderSell(self):
        strat = self.createStrategy()

        o = strat.limitOrder(StrategyTestCase.TestInstrument, 60, -3, False)
        strat.run()
        self.assertTrue(o.isFilled())
        self.assertEquals(o.getAction(), broker.Order.Action.SELL)
        self.assertEquals(o.getAvgFillPrice(), 124.62)
        self.assertEquals(o.getQuantity(), 3)
        self.assertEquals(o.getFilled(), 3)
        self.assertEquals(o.getRemaining(), 0)
        self.assertEqual(strat.orderUpdatedCalls, 2)

    def testStopOrderBuy(self):
        strat = self.createStrategy()

        o = strat.stopOrder(StrategyTestCase.TestInstrument, 100, 1, False)
        strat.run()
        self.assertTrue(o.isFilled())
        self.assertEquals(o.getAction(), broker.Order.Action.BUY)
        self.assertEquals(o.getAvgFillPrice(), 124.62)
        self.assertEquals(o.getQuantity(), 1)
        self.assertEquals(o.getFilled(), 1)
        self.assertEquals(o.getRemaining(), 0)
        self.assertEqual(strat.orderUpdatedCalls, 2)

    def testStopOrderSell(self):
        strat = self.createStrategy()

        o = strat.stopOrder(StrategyTestCase.TestInstrument, 55, -2, True)
        strat.run()
        self.assertTrue(o.isFilled())
        self.assertEquals(o.getAction(), broker.Order.Action.SELL)
        self.assertEquals(o.getAvgFillPrice(), 55)
        self.assertEquals(o.getQuantity(), 2)
        self.assertEquals(o.getFilled(), 2)
        self.assertEquals(o.getRemaining(), 0)
        self.assertEqual(strat.orderUpdatedCalls, 2)
        self.assertEqual(o.getExecutionInfo().getDateTime(), datetime.datetime(2000, 1, 19))

    def testStopLimitOrderBuy(self):
        strat = self.createStrategy()

        o = strat.stopLimitOrder(StrategyTestCase.TestInstrument, 110, 100, 1, True)
        strat.run()
        self.assertTrue(o.isFilled())
        self.assertEquals(o.getAction(), broker.Order.Action.BUY)
        self.assertEquals(o.getAvgFillPrice(), 100)
        self.assertEquals(o.getQuantity(), 1)
        self.assertEquals(o.getFilled(), 1)
        self.assertEquals(o.getRemaining(), 0)
        self.assertEqual(strat.orderUpdatedCalls, 2)
        self.assertEqual(o.getExecutionInfo().getDateTime(), datetime.datetime(2000, 1, 5))

    def testStopLimitOrderSell(self):
        strat = self.createStrategy()

        o = strat.stopLimitOrder(StrategyTestCase.TestInstrument, 100, 110, -2, True)
        strat.run()
        self.assertTrue(o.isFilled())
        self.assertEquals(o.getAction(), broker.Order.Action.SELL)
        self.assertEquals(o.getAvgFillPrice(), 110)
        self.assertEquals(o.getQuantity(), 2)
        self.assertEquals(o.getFilled(), 2)
        self.assertEquals(o.getRemaining(), 0)
        self.assertEqual(strat.orderUpdatedCalls, 2)
        self.assertEqual(o.getExecutionInfo().getDateTime(), datetime.datetime(2000, 1, 10))


class OptionalOverridesTestCase(StrategyTestCase):
    def testOnStartIdleFinish(self):
        strat = self.createStrategy()
        strat.run()
        self.assertTrue(strat.onStartCalled)
        self.assertTrue(strat.onFinishCalled)
        self.assertFalse(strat.onIdleCalled)

########NEW FILE########
__FILENAME__ = talib_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade.talibext import indicator
from pyalgotrade import bar
from pyalgotrade import dataseries
from pyalgotrade.dataseries import bards

import datetime
import unittest
import talib

# Market data used for regression tests (252 price bars) extracted from ta-lib/src/tools/ta_regtest/test_data.c
OPEN_VALUES = [
    92.500000, 91.500000, 95.155000, 93.970000, 95.500000, 94.500000, 95.000000, 91.500000, 91.815000, 91.125000, 93.875000,
    97.500000, 98.815000, 92.000000, 91.125000, 91.875000, 93.405000, 89.750000, 89.345000, 92.250000, 89.780000,
    87.940000, 87.595000, 85.220000, 83.500000, 83.500000, 81.250000, 85.125000, 88.125000, 87.500000, 85.250000,
    86.000000, 87.190000, 86.125000, 89.000000, 88.625000, 86.000000, 85.500000, 84.750000, 85.250000, 84.250000,
    86.750000, 86.940000, 89.315000, 89.940000, 90.815000, 91.190000, 91.345000, 89.595000, 91.000000, 89.750000,
    88.750000, 88.315000, 84.345000, 83.500000, 84.000000, 86.000000, 85.530000, 87.500000, 88.500000, 90.000000,
    88.655000, 89.500000, 91.565000, 92.000000, 93.000000, 92.815000, 91.750000, 92.000000, 91.375000, 89.750000,
    88.750000, 85.440000, 83.500000, 84.875000, 98.625000, 96.690000, 102.375000, 106.000000, 104.625000, 102.500000,
    104.250000, 104.000000, 106.125000, 106.065000, 105.940000, 105.625000, 108.625000, 110.250000, 110.565000, 117.000000,
    120.750000, 118.000000, 119.125000, 119.125000, 117.815000, 116.375000, 115.155000, 111.250000, 111.500000, 116.690000,
    116.000000, 113.620000, 111.750000, 114.560000, 113.620000, 118.120000, 119.870000, 116.620000, 115.870000, 115.060000,
    115.870000, 117.500000, 119.870000, 119.250000, 120.190000, 122.870000, 123.870000, 122.250000, 123.120000, 123.310000,
    124.000000, 123.000000, 124.810000, 130.000000, 130.880000, 132.500000, 131.000000, 132.500000, 134.000000, 137.440000,
    135.750000, 138.310000, 138.000000, 136.380000, 136.500000, 132.000000, 127.500000, 127.620000, 124.000000, 123.620000,
    125.000000, 126.370000, 126.250000, 125.940000, 124.000000, 122.750000, 120.000000, 120.000000, 122.000000, 123.620000,
    121.500000, 120.120000, 123.750000, 122.750000, 125.000000, 128.500000, 128.380000, 123.870000, 124.370000, 122.750000,
    123.370000, 122.000000, 122.620000, 125.000000, 124.250000, 124.370000, 125.620000, 126.500000, 128.380000, 128.880000,
    131.500000, 132.500000, 137.500000, 134.630000, 132.000000, 134.000000, 132.000000, 131.380000, 126.500000, 128.750000,
    127.190000, 127.500000, 120.500000, 126.620000, 123.000000, 122.060000, 121.000000, 121.000000, 118.000000, 122.000000,
    122.250000, 119.120000, 115.000000, 113.500000, 114.000000, 110.810000, 106.500000, 106.440000, 108.000000, 107.000000,
    108.620000, 93.000000, 93.750000, 94.250000, 94.870000, 95.500000, 94.500000, 97.000000, 98.500000, 96.750000,
    95.870000, 94.440000, 92.750000, 90.500000, 95.060000, 94.620000, 97.500000, 96.000000, 96.000000, 94.620000,
    94.870000, 94.000000, 99.000000, 105.500000, 108.810000, 105.000000, 105.940000, 104.940000, 103.690000, 102.560000,
    103.440000, 109.810000, 113.000000, 117.000000, 116.250000, 120.500000, 111.620000, 108.120000, 110.190000, 107.750000,
    108.000000, 110.690000, 109.060000, 108.500000, 109.870000, 109.120000, 109.690000, 109.560000, 110.440000, 109.690000,
    109.190000]

HIGH_VALUES = [
    93.250000, 94.940000, 96.375000, 96.190000, 96.000000, 94.720000, 95.000000, 93.720000, 92.470000, 92.750000, 96.250000,
    99.625000, 99.125000, 92.750000, 91.315000, 93.250000, 93.405000, 90.655000, 91.970000, 92.250000, 90.345000,
    88.500000, 88.250000, 85.500000, 84.440000, 84.750000, 84.440000, 89.405000, 88.125000, 89.125000, 87.155000,
    87.250000, 87.375000, 88.970000, 90.000000, 89.845000, 86.970000, 85.940000, 84.750000, 85.470000, 84.470000,
    88.500000, 89.470000, 90.000000, 92.440000, 91.440000, 92.970000, 91.720000, 91.155000, 91.750000, 90.000000,
    88.875000, 89.000000, 85.250000, 83.815000, 85.250000, 86.625000, 87.940000, 89.375000, 90.625000, 90.750000,
    88.845000, 91.970000, 93.375000, 93.815000, 94.030000, 94.030000, 91.815000, 92.000000, 91.940000, 89.750000,
    88.750000, 86.155000, 84.875000, 85.940000, 99.375000, 103.280000, 105.375000, 107.625000, 105.250000, 104.500000,
    105.500000, 106.125000, 107.940000, 106.250000, 107.000000, 108.750000, 110.940000, 110.940000, 114.220000, 123.000000,
    121.750000, 119.815000, 120.315000, 119.375000, 118.190000, 116.690000, 115.345000, 113.000000, 118.315000, 116.870000,
    116.750000, 113.870000, 114.620000, 115.310000, 116.000000, 121.690000, 119.870000, 120.870000, 116.750000, 116.500000,
    116.000000, 118.310000, 121.500000, 122.000000, 121.440000, 125.750000, 127.750000, 124.190000, 124.440000, 125.750000,
    124.690000, 125.310000, 132.000000, 131.310000, 132.250000, 133.880000, 133.500000, 135.500000, 137.440000, 138.690000,
    139.190000, 138.500000, 138.130000, 137.500000, 138.880000, 132.130000, 129.750000, 128.500000, 125.440000, 125.120000,
    126.500000, 128.690000, 126.620000, 126.690000, 126.000000, 123.120000, 121.870000, 124.000000, 127.000000, 124.440000,
    122.500000, 123.750000, 123.810000, 124.500000, 127.870000, 128.560000, 129.630000, 124.870000, 124.370000, 124.870000,
    123.620000, 124.060000, 125.870000, 125.190000, 125.620000, 126.000000, 128.500000, 126.750000, 129.750000, 132.690000,
    133.940000, 136.500000, 137.690000, 135.560000, 133.560000, 135.000000, 132.380000, 131.440000, 130.880000, 129.630000,
    127.250000, 127.810000, 125.000000, 126.810000, 124.750000, 122.810000, 122.250000, 121.060000, 120.000000, 123.250000,
    122.750000, 119.190000, 115.060000, 116.690000, 114.870000, 110.870000, 107.250000, 108.870000, 109.000000, 108.500000,
    113.060000, 93.000000, 94.620000, 95.120000, 96.000000, 95.560000, 95.310000, 99.000000, 98.810000, 96.810000,
    95.940000, 94.440000, 92.940000, 93.940000, 95.500000, 97.060000, 97.500000, 96.250000, 96.370000, 95.000000,
    94.870000, 98.250000, 105.120000, 108.440000, 109.870000, 105.000000, 106.000000, 104.940000, 104.500000, 104.440000,
    106.310000, 112.870000, 116.500000, 119.190000, 121.000000, 122.120000, 111.940000, 112.750000, 110.190000, 107.940000,
    109.690000, 111.060000, 110.440000, 110.120000, 110.310000, 110.440000, 110.000000, 110.750000, 110.500000, 110.500000,
    109.500000]

LOW_VALUES = [
    90.750000, 91.405000, 94.250000, 93.500000, 92.815000, 93.500000, 92.000000, 89.750000, 89.440000, 90.625000, 92.750000,
    96.315000, 96.030000, 88.815000, 86.750000, 90.940000, 88.905000, 88.780000, 89.250000, 89.750000, 87.500000,
    86.530000, 84.625000, 82.280000, 81.565000, 80.875000, 81.250000, 84.065000, 85.595000, 85.970000, 84.405000,
    85.095000, 85.500000, 85.530000, 87.875000, 86.565000, 84.655000, 83.250000, 82.565000, 83.440000, 82.530000,
    85.065000, 86.875000, 88.530000, 89.280000, 90.125000, 90.750000, 89.000000, 88.565000, 90.095000, 89.000000,
    86.470000, 84.000000, 83.315000, 82.000000, 83.250000, 84.750000, 85.280000, 87.190000, 88.440000, 88.250000,
    87.345000, 89.280000, 91.095000, 89.530000, 91.155000, 92.000000, 90.530000, 89.970000, 88.815000, 86.750000,
    85.065000, 82.030000, 81.500000, 82.565000, 96.345000, 96.470000, 101.155000, 104.250000, 101.750000, 101.720000,
    101.720000, 103.155000, 105.690000, 103.655000, 104.000000, 105.530000, 108.530000, 108.750000, 107.750000, 117.000000,
    118.000000, 116.000000, 118.500000, 116.530000, 116.250000, 114.595000, 110.875000, 110.500000, 110.720000, 112.620000,
    114.190000, 111.190000, 109.440000, 111.560000, 112.440000, 117.500000, 116.060000, 116.560000, 113.310000, 112.560000,
    114.000000, 114.750000, 118.870000, 119.000000, 119.750000, 122.620000, 123.000000, 121.750000, 121.560000, 123.120000,
    122.190000, 122.750000, 124.370000, 128.000000, 129.500000, 130.810000, 130.630000, 132.130000, 133.880000, 135.380000,
    135.750000, 136.190000, 134.500000, 135.380000, 133.690000, 126.060000, 126.870000, 123.500000, 122.620000, 122.750000,
    123.560000, 125.810000, 124.620000, 124.370000, 121.810000, 118.190000, 118.060000, 117.560000, 121.000000, 121.120000,
    118.940000, 119.810000, 121.000000, 122.000000, 124.500000, 126.560000, 123.500000, 121.250000, 121.060000, 122.310000,
    121.000000, 120.870000, 122.060000, 122.750000, 122.690000, 122.870000, 125.500000, 124.250000, 128.000000, 128.380000,
    130.690000, 131.630000, 134.380000, 132.000000, 131.940000, 131.940000, 129.560000, 123.750000, 126.000000, 126.250000,
    124.370000, 121.440000, 120.440000, 121.370000, 121.690000, 120.000000, 119.620000, 115.500000, 116.750000, 119.060000,
    119.060000, 115.060000, 111.060000, 113.120000, 110.000000, 105.000000, 104.690000, 103.870000, 104.690000, 105.440000,
    107.000000, 89.000000, 92.500000, 92.120000, 94.620000, 92.810000, 94.250000, 96.250000, 96.370000, 93.690000,
    93.500000, 90.000000, 90.190000, 90.500000, 92.120000, 94.120000, 94.870000, 93.000000, 93.870000, 93.000000,
    92.620000, 93.560000, 98.370000, 104.440000, 106.000000, 101.810000, 104.120000, 103.370000, 102.120000, 102.250000,
    103.370000, 107.940000, 112.500000, 115.440000, 115.500000, 112.250000, 107.560000, 106.560000, 106.870000, 104.500000,
    105.750000, 108.620000, 107.750000, 108.060000, 108.000000, 108.190000, 108.120000, 109.060000, 108.750000, 108.560000,
    106.620000]

CLOSE_VALUES = [
    91.500000, 94.815000, 94.375000, 95.095000, 93.780000, 94.625000, 92.530000, 92.750000, 90.315000, 92.470000, 96.125000,
    97.250000, 98.500000, 89.875000, 91.000000, 92.815000, 89.155000, 89.345000, 91.625000, 89.875000, 88.375000,
    87.625000, 84.780000, 83.000000, 83.500000, 81.375000, 84.440000, 89.250000, 86.375000, 86.250000, 85.250000,
    87.125000, 85.815000, 88.970000, 88.470000, 86.875000, 86.815000, 84.875000, 84.190000, 83.875000, 83.375000,
    85.500000, 89.190000, 89.440000, 91.095000, 90.750000, 91.440000, 89.000000, 91.000000, 90.500000, 89.030000,
    88.815000, 84.280000, 83.500000, 82.690000, 84.750000, 85.655000, 86.190000, 88.940000, 89.280000, 88.625000,
    88.500000, 91.970000, 91.500000, 93.250000, 93.500000, 93.155000, 91.720000, 90.000000, 89.690000, 88.875000,
    85.190000, 83.375000, 84.875000, 85.940000, 97.250000, 99.875000, 104.940000, 106.000000, 102.500000, 102.405000,
    104.595000, 106.125000, 106.000000, 106.065000, 104.625000, 108.625000, 109.315000, 110.500000, 112.750000, 123.000000,
    119.625000, 118.750000, 119.250000, 117.940000, 116.440000, 115.190000, 111.875000, 110.595000, 118.125000, 116.000000,
    116.000000, 112.000000, 113.750000, 112.940000, 116.000000, 120.500000, 116.620000, 117.000000, 115.250000, 114.310000,
    115.500000, 115.870000, 120.690000, 120.190000, 120.750000, 124.750000, 123.370000, 122.940000, 122.560000, 123.120000,
    122.560000, 124.620000, 129.250000, 131.000000, 132.250000, 131.000000, 132.810000, 134.000000, 137.380000, 137.810000,
    137.880000, 137.250000, 136.310000, 136.250000, 134.630000, 128.250000, 129.000000, 123.870000, 124.810000, 123.000000,
    126.250000, 128.380000, 125.370000, 125.690000, 122.250000, 119.370000, 118.500000, 123.190000, 123.500000, 122.190000,
    119.310000, 123.310000, 121.120000, 123.370000, 127.370000, 128.500000, 123.870000, 122.940000, 121.750000, 124.440000,
    122.000000, 122.370000, 122.940000, 124.000000, 123.190000, 124.560000, 127.250000, 125.870000, 128.860000, 132.000000,
    130.750000, 134.750000, 135.000000, 132.380000, 133.310000, 131.940000, 130.000000, 125.370000, 130.130000, 127.120000,
    125.190000, 122.000000, 125.000000, 123.000000, 123.500000, 120.060000, 121.000000, 117.750000, 119.870000, 122.000000,
    119.190000, 116.370000, 113.500000, 114.250000, 110.000000, 105.060000, 107.000000, 107.870000, 107.000000, 107.120000,
    107.000000, 91.000000, 93.940000, 93.870000, 95.500000, 93.000000, 94.940000, 98.250000, 96.750000, 94.810000,
    94.370000, 91.560000, 90.250000, 93.940000, 93.620000, 97.000000, 95.000000, 95.870000, 94.060000, 94.620000,
    93.750000, 98.000000, 103.940000, 107.870000, 106.060000, 104.500000, 105.000000, 104.190000, 103.060000, 103.420000,
    105.270000, 111.870000, 116.000000, 116.620000, 118.280000, 113.370000, 109.000000, 109.700000, 109.250000, 107.000000,
    109.190000, 110.000000, 109.200000, 110.120000, 108.000000, 108.620000, 109.750000, 109.810000, 109.000000, 108.750000,
    107.870000]

VOLUME_VALUES = [
    4077500, 4955900, 4775300, 4155300, 4593100, 3631300, 3382800, 4954200, 4500000, 3397500, 4204500,
    6321400, 10203600, 19043900, 11692000, 9553300, 8920300, 5970900, 5062300, 3705600, 5865600,
    5603000, 5811900, 8483800, 5995200, 5408800, 5430500, 6283800, 5834800, 4515500, 4493300,
    4346100, 3700300, 4600200, 4557200, 4323600, 5237500, 7404100, 4798400, 4372800, 3872300,
    10750800, 5804800, 3785500, 5014800, 3507700, 4298800, 4842500, 3952200, 3304700, 3462000,
    7253900, 9753100, 5953000, 5011700, 5910800, 4916900, 4135000, 4054200, 3735300, 2921900,
    2658400, 4624400, 4372200, 5831600, 4268600, 3059200, 4495500, 3425000, 3630800, 4168100,
    5966900, 7692800, 7362500, 6581300, 19587700, 10378600, 9334700, 10467200, 5671400, 5645000,
    4518600, 4519500, 5569700, 4239700, 4175300, 4995300, 4776600, 4190000, 6035300, 12168900,
    9040800, 5780300, 4320800, 3899100, 3221400, 3455500, 4304200, 4703900, 8316300, 10553900,
    6384800, 7163300, 7007800, 5114100, 5263800, 6666100, 7398400, 5575000, 4852300, 4298100,
    4900500, 4887700, 6964800, 4679200, 9165000, 6469800, 6792000, 4423800, 5231900, 4565600,
    6235200, 5225900, 8261400, 5912500, 3545600, 5714500, 6653900, 6094500, 4799200, 5050800,
    5648900, 4726300, 5585600, 5124800, 7630200, 14311600, 8793600, 8874200, 6966600, 5525500,
    6515500, 5291900, 5711700, 4327700, 4568000, 6859200, 5757500, 7367000, 6144100, 4052700,
    5849700, 5544700, 5032200, 4400600, 4894100, 5140000, 6610900, 7585200, 5963100, 6045500,
    8443300, 6464700, 6248300, 4357200, 4774700, 6216900, 6266900, 5584800, 5284500, 7554500,
    7209500, 8424800, 5094500, 4443600, 4591100, 5658400, 6094100, 14862200, 7544700, 6985600,
    8093000, 7590000, 7451300, 7078000, 7105300, 8778800, 6643900, 10563900, 7043100, 6438900,
    8057700, 14240000, 17872300, 7831100, 8277700, 15017800, 14183300, 13921100, 9683000, 9187300,
    11380500, 69447300, 26673600, 13768400, 11371600, 9872200, 9450500, 11083300, 9552800, 11108400,
    10374200, 16701900, 13741900, 8523600, 9551900, 8680500, 7151700, 9673100, 6264700, 8541600,
    8358000, 18720800, 19683100, 13682500, 10668100, 9710600, 3113100, 5682000, 5763600, 5340000,
    6220800, 14680500, 9933000, 11329500, 8145300, 16644700, 12593800, 7138100, 7442300, 9442300,
    7123600, 7680600, 4839800, 4775500, 4008800, 4533600, 3741100, 4084800, 2685200, 3438000,
    2870500]

SAR_HIGH = [51.12, 52.35, 52.1, 51.8, 52.1, 52.5, 52.8, 52.5, 53.5, 53.5, 53.8, 54.2, 53.4, 53.5, 54.4, 55.2, 55.7, 57, 57.5, 58, 57.7, 58, 57.5, 57, 56.7, 57.5, 56.70, 56.00, 56.20, 54.80, 55.50, 54.70, 54.00, 52.50, 51.00, 51.50, 51.70, 53.00]
SAR_LOW = [50.0, 51.5, 51, 50.5, 51.25, 51.7, 51.85, 51.5, 52.3, 52.5, 53, 53.5, 52.5, 52.1, 53, 54, 55, 56, 56.5, 57, 56.5, 57.3, 56.7, 56.3, 56.2, 56, 55.50, 55.00, 54.90, 54.00, 54.50, 53.80, 53.00, 51.50, 50.00, 50.50, 50.20, 51.50]


def compare(obtained, expected, decimals=2):
    obtained = round(obtained, decimals)
    expected = round(expected, decimals)
    return obtained == expected


class TestCase(unittest.TestCase):
    TestInstrument = "orcl"

    def __loadMedPriceDS(self):
        ret = dataseries.SequenceDataSeries()
        for i in xrange(len(OPEN_VALUES)):
            ret.append(LOW_VALUES[i] + (HIGH_VALUES[i] - LOW_VALUES[i]) / 2.0)
        return ret

    def __loadBarDS(self):
        seconds = 0

        ret = bards.BarDataSeries()
        for i in xrange(len(OPEN_VALUES)):
            dateTime = datetime.datetime.now() + datetime.timedelta(seconds=seconds)
            ret.append(bar.BasicBar(dateTime, OPEN_VALUES[i], HIGH_VALUES[i], LOW_VALUES[i], CLOSE_VALUES[i], VOLUME_VALUES[i], CLOSE_VALUES[i], bar.Frequency.DAY))
            seconds += 1
        return ret

    def __loadSarTestBarDs(self):
        seconds = 0

        ret = bards.BarDataSeries()
        for i in xrange(len(SAR_HIGH)):
            dateTime = datetime.datetime.now() + datetime.timedelta(seconds=seconds)
            ret.append(bar.BasicBar(dateTime, SAR_LOW[i], SAR_HIGH[i], SAR_LOW[i], SAR_HIGH[i], 0, SAR_LOW[i], bar.Frequency.DAY))
            seconds += 1
        return ret

    def testAD(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.AD(barDs, 252)[0], -1631000.00))
        self.assertTrue(compare(indicator.AD(barDs, 252)[1], 2974412.02))
        self.assertTrue(compare(indicator.AD(barDs, 252)[-2], 8707691.07))
        self.assertTrue(compare(indicator.AD(barDs, 252)[-1], 8328944.54))

    def testADOSC(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.ADOSC(barDs, 252, 3, 10)[9], 841238.33))  # Original value was 841238.32
        self.assertTrue(compare(indicator.ADOSC(barDs, 252, 3, 10)[9+1], 2255663.07))
        self.assertTrue(compare(indicator.ADOSC(barDs, 252, 3, 10)[-2], -526700.32))
        self.assertTrue(compare(indicator.ADOSC(barDs, 252, 3, 10)[-1], -1139932.729))

    def testADX(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.ADX(barDs, 252, 14)[27], 23.0000))
        self.assertTrue(compare(indicator.ADX(barDs, 252, 14)[28], 22.0802))
        self.assertTrue(compare(indicator.ADX(barDs, 252, 14)[-2], 16.6840))
        self.assertTrue(compare(indicator.ADX(barDs, 252, 14)[-1], 15.5260))

    def testADXR(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.ADXR(barDs, 252, 14)[40], 19.8666))
        self.assertTrue(compare(indicator.ADXR(barDs, 252, 14)[41], 18.9092))
        self.assertTrue(compare(indicator.ADXR(barDs, 252, 14)[-2], 21.5972))
        self.assertTrue(compare(indicator.ADXR(barDs, 252, 14)[-1], 20.4920))

    def testAPO(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.APO(barDs.getCloseDataSeries(), 252, 26, 12, talib.MA_SMA)[25], -3.3124))
        self.assertTrue(compare(indicator.APO(barDs.getCloseDataSeries(), 252, 12, 26, talib.MA_SMA)[25], -3.3124))
        self.assertTrue(compare(indicator.APO(barDs.getCloseDataSeries(), 252, 12, 26, talib.MA_SMA)[26], -3.5876))
        self.assertTrue(compare(indicator.APO(barDs.getCloseDataSeries(), 252, 12, 26, talib.MA_SMA)[-1], -0.1667))

    def testAROON(self):
        barDs = self.__loadBarDS()
        # AROON DOWN TEST
        self.assertTrue(compare(indicator.AROON(barDs, 252, 14)[0][14], 100))
        self.assertTrue(compare(indicator.AROON(barDs, 252, 14)[0][14+1], 92.857))
        self.assertTrue(compare(indicator.AROON(barDs, 252, 14)[0][-2], 28.571))
        self.assertTrue(compare(indicator.AROON(barDs, 252, 14)[0][-1], 21.429))
        # AROON UP TEST
        self.assertTrue(compare(indicator.AROON(barDs, 252, 14)[1][14], 78.571))
        self.assertTrue(compare(indicator.AROON(barDs, 252, 14)[1][14+1], 71.429))
        self.assertTrue(compare(indicator.AROON(barDs, 252, 14)[1][-2], 0))
        self.assertTrue(compare(indicator.AROON(barDs, 252, 14)[1][-1], 7.1429))

    def testAROONOSC(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.AROONOSC(barDs, 252, 14)[14], -21.4285))
        self.assertTrue(compare(indicator.AROONOSC(barDs, 252, 14)[14+6], -21.4285))
        self.assertTrue(compare(indicator.AROONOSC(barDs, 252, 14)[14+7], -71.4285))
        self.assertTrue(compare(indicator.AROONOSC(barDs, 252, 14)[-2], -28.5714))
        self.assertTrue(compare(indicator.AROONOSC(barDs, 252, 14)[-1], -14.28571))

    def testATR(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.ATR(barDs, 252, 1)[1], 3.535, 3))
        self.assertTrue(compare(indicator.ATR(barDs, 252, 1)[13], 9.685, 3))
        self.assertTrue(compare(indicator.ATR(barDs, 252, 1)[41], 5.125, 3))
        self.assertTrue(compare(indicator.ATR(barDs, 252, 1)[-1], 2.88, 3))

    def testAVGPRICE(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.AVGPRICE(barDs, 252)[0], 92.0))
        self.assertTrue(compare(indicator.AVGPRICE(barDs, 252)[1], 93.16))  # Original value was 93.17

    def testBBANDS(self):
        barDs = self.__loadBarDS()
        # EMA
        self.assertTrue(compare(indicator.BBANDS(barDs.getCloseDataSeries(), 252, 20, 2.0, 2.0, talib.MA_EMA)[0][19+13], 93.674))
        self.assertTrue(compare(indicator.BBANDS(barDs.getCloseDataSeries(), 252, 20, 2.0, 2.0, talib.MA_EMA)[1][19+13], 87.679))
        self.assertTrue(compare(indicator.BBANDS(barDs.getCloseDataSeries(), 252, 20, 2.0, 2.0, talib.MA_EMA)[2][19+13], 81.685))
        # SMA
        self.assertTrue(compare(indicator.BBANDS(barDs.getCloseDataSeries(), 252, 20, 2.0, 2.0, talib.MA_SMA)[0][19], 98.0734))
        self.assertTrue(compare(indicator.BBANDS(barDs.getCloseDataSeries(), 252, 20, 2.0, 2.0, talib.MA_SMA)[1][19], 92.8910))
        self.assertTrue(compare(indicator.BBANDS(barDs.getCloseDataSeries(), 252, 20, 2.0, 2.0, talib.MA_SMA)[2][19], 87.7086))

    def testBETA(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.BETA(barDs.getHighDataSeries(), barDs.getLowDataSeries(), 252, 5)[5], 0.62907))
        self.assertTrue(compare(indicator.BETA(barDs.getHighDataSeries(), barDs.getLowDataSeries(), 252, 5)[6], 0.83604))

    def testBOP(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.BOP(barDs, 252)[0], -0.40))
        self.assertTrue(compare(indicator.BOP(barDs, 252)[1], 0.94))

    def testCCI(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.CCI(barDs, 252, 2)[1], 66.666))
        self.assertTrue(compare(indicator.CCI(barDs, 252, 5)[4], 18.857))
        self.assertTrue(compare(indicator.CCI(barDs, 252, 11)[10], 87.927))
        self.assertTrue(compare(indicator.CCI(barDs, 252, 11)[11], 180.005, 3))

    def testCMO(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.CMO(barDs.getCloseDataSeries(), 252, 14)[14], -1.70, 1))

    def testCORREL(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.CORREL(barDs.getHighDataSeries(), barDs.getLowDataSeries(), 252, 20)[19], 0.9401569))
        self.assertTrue(compare(indicator.CORREL(barDs.getHighDataSeries(), barDs.getLowDataSeries(), 252, 20)[20], 0.9471812))
        self.assertTrue(compare(indicator.CORREL(barDs.getHighDataSeries(), barDs.getLowDataSeries(), 252, 20)[-1], 0.8866901))

    def testDX(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.DX(barDs, 252, 14)[14], 19.3689))
        self.assertTrue(compare(indicator.DX(barDs, 252, 14)[15], 9.7131))
        self.assertTrue(compare(indicator.DX(barDs, 252, 14)[16], 17.2905))
        self.assertTrue(compare(indicator.DX(barDs, 252, 14)[-2], 10.6731))
        self.assertTrue(compare(indicator.DX(barDs, 252, 14)[-1], 0.4722))

    def testEMA(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.EMA(barDs.getCloseDataSeries(), 252, 2)[1], 93.16))  # Original value 93.15
        self.assertTrue(compare(indicator.EMA(barDs.getCloseDataSeries(), 252, 2)[2], 93.97))  # Original value 93.96
        self.assertTrue(compare(indicator.EMA(barDs.getCloseDataSeries(), 252, 2)[-1], 108.22))  # Original value 108.21
        self.assertTrue(compare(indicator.EMA(barDs.getCloseDataSeries(), 252, 10)[9], 93.23))  # Original value 93.22

    def testHT_DCPERIOD(self):
        ds = self.__loadMedPriceDS()
        self.assertTrue(compare(indicator.HT_DCPERIOD(ds, 252)[32], 15.5527, 4))
        self.assertTrue(compare(indicator.HT_DCPERIOD(ds, 252)[-1], 18.6140, 4))

    def testHT_DCPHASE(self):
        ds = self.__loadMedPriceDS()
        self.assertTrue(compare(indicator.HT_DCPHASE(ds, 252)[63], 22.1496, 4))  # Original value 22.1495
        self.assertTrue(compare(indicator.HT_DCPHASE(ds, 252)[-3], -31.182, 3))
        self.assertTrue(compare(indicator.HT_DCPHASE(ds, 252)[-2], 23.2691, 4))
        self.assertTrue(compare(indicator.HT_DCPHASE(ds, 252)[-1], 47.2765, 4))

    def testHT_TRENDLINE(self):
        ds = self.__loadMedPriceDS()
        self.assertTrue(compare(indicator.HT_TRENDLINE(ds, 252)[63], 88.257))
        self.assertTrue(compare(indicator.HT_TRENDLINE(ds, 252)[-3], 109.69))
        self.assertTrue(compare(indicator.HT_TRENDLINE(ds, 252)[-2], 110.18))
        self.assertTrue(compare(indicator.HT_TRENDLINE(ds, 252)[-1], 110.46))

    def testHT_TRENDMODE(self):
        ds = self.__loadMedPriceDS()
        self.assertTrue(compare(indicator.HT_TRENDMODE(ds, 252)[63], 1.0))

    def testKAMA(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.KAMA(barDs.getCloseDataSeries(), 252, 10)[10], 92.6575))
        self.assertTrue(compare(indicator.KAMA(barDs.getCloseDataSeries(), 252, 10)[11], 92.7783))
        self.assertTrue(compare(indicator.KAMA(barDs.getCloseDataSeries(), 252, 10)[-1], 109.294))

    def testMA(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.MA(barDs.getCloseDataSeries(), 252, 2, talib.MA_SMA)[1], 93.16))  # Original value 93.15
        self.assertTrue(compare(indicator.MA(barDs.getCloseDataSeries(), 252, 2, talib.MA_SMA)[2], 94.59))
        self.assertTrue(compare(indicator.MA(barDs.getCloseDataSeries(), 252, 2, talib.MA_SMA)[3], 94.73))
        self.assertTrue(compare(indicator.MA(barDs.getCloseDataSeries(), 252, 2, talib.MA_SMA)[-1], 108.31))

    def testMACD(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.MACD(barDs.getCloseDataSeries(), 252, 12, 26, 9)[0][33], -1.9738))
        self.assertTrue(compare(indicator.MACD(barDs.getCloseDataSeries(), 252, 12, 26, 9)[1][33], -2.7071))
        self.assertTrue(compare(indicator.MACD(barDs.getCloseDataSeries(), 252, 12, 26, 9)[2][33], (-1.9738)-(-2.7071)))
        self.assertTrue(compare(indicator.MACD(barDs.getCloseDataSeries(), 252, 26, 12, 9)[0][33], -1.9738))
        self.assertTrue(compare(indicator.MACD(barDs.getCloseDataSeries(), 252, 26, 12, 9)[1][33], -2.7071))
        self.assertTrue(compare(indicator.MACD(barDs.getCloseDataSeries(), 252, 26, 12, 9)[2][33], (-1.9738)-(-2.7071)))

    def testMACDEXT(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.MACDEXT(barDs.getCloseDataSeries(), 252, 12, talib.MA_EMA, 26, talib.MA_EMA, 9, talib.MA_EMA)[0][33], -1.9738))
        self.assertTrue(compare(indicator.MACDEXT(barDs.getCloseDataSeries(), 252, 12, talib.MA_EMA, 26, talib.MA_EMA, 9, talib.MA_EMA)[1][33], -2.7071))
        self.assertTrue(compare(indicator.MACDEXT(barDs.getCloseDataSeries(), 252, 12, talib.MA_EMA, 26, talib.MA_EMA, 9, talib.MA_EMA)[2][33], (-1.9738)-(-2.7071)))

    def testMAMA(self):
        ds = self.__loadMedPriceDS()
        self.assertTrue(compare(indicator.MAMA(ds, 252, 0.5, 0.05)[0][32], 85.3643))
        self.assertTrue(compare(indicator.MAMA(ds, 252, 0.5, 0.05)[0][-1], 110.1116))

    def testMAX(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.MAX(barDs.getOpenDataSeries(), 252, 14)[13], 98.815))
        self.assertTrue(compare(indicator.MAX(barDs.getOpenDataSeries(), 252, 14)[14], 98.815))
        self.assertTrue(compare(indicator.MAX(barDs.getOpenDataSeries(), 252, 14)[-1], 110.69))

    def testMFI(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.MFI(barDs, 252, 14)[14], 42.8923))
        self.assertTrue(compare(indicator.MFI(barDs, 252, 14)[15], 45.6072))
        self.assertTrue(compare(indicator.MFI(barDs, 252, 14)[-1], 53.1997))

    def testMIN(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.MIN(barDs.getOpenDataSeries(), 252, 14)[13], 91.125))
        self.assertTrue(compare(indicator.MIN(barDs.getOpenDataSeries(), 252, 14)[14], 91.125))
        self.assertTrue(compare(indicator.MIN(barDs.getOpenDataSeries(), 252, 14)[-1], 107.75))

    def testMINUS_DI(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.MINUS_DI(barDs, 252, 14)[14], 30.1684))
        self.assertTrue(compare(indicator.MINUS_DI(barDs, 252, 14)[28], 24.969182))
        self.assertTrue(compare(indicator.MINUS_DI(barDs, 252, 14)[-1], 21.1988))

    def testMINUS_DM(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.MINUS_DM(barDs, 252, 14)[13], 12.995, 3))
        self.assertTrue(compare(indicator.MINUS_DM(barDs, 252, 14)[-2], 8.33))
        self.assertTrue(compare(indicator.MINUS_DM(barDs, 252, 14)[-1], 9.68))  # Original value 9.672

    def testMOM(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.MOM(barDs.getCloseDataSeries(), 252, 14)[14], -0.50))
        self.assertTrue(compare(indicator.MOM(barDs.getCloseDataSeries(), 252, 14)[15], -2.00))
        self.assertTrue(compare(indicator.MOM(barDs.getCloseDataSeries(), 252, 14)[16], -5.22))
        self.assertTrue(compare(indicator.MOM(barDs.getCloseDataSeries(), 252, 14)[-1], -1.13))

    def testNATR(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.NATR(barDs, 252, 14)[14], 3.9321))
        self.assertTrue(compare(indicator.NATR(barDs, 252, 14)[15], 3.7576))
        self.assertTrue(compare(indicator.NATR(barDs, 252, 14)[-1], 3.0229))

    def testPLUS_DI(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.PLUS_DI(barDs, 252, 14)[14], 20.3781))
        self.assertTrue(compare(indicator.PLUS_DI(barDs, 252, 14)[14+13], 22.1073))
        self.assertTrue(compare(indicator.PLUS_DI(barDs, 252, 14)[14+14], 20.3746))
        self.assertTrue(compare(indicator.PLUS_DI(barDs, 252, 14)[-1], 21.0000))

    def testPLUS_DM(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.PLUS_DM(barDs, 252, 14)[13], 10.28))
        self.assertTrue(compare(indicator.PLUS_DM(barDs, 252, 14)[-2], 10.317))
        self.assertTrue(compare(indicator.PLUS_DM(barDs, 252, 14)[-1], 9.59))  # Original value 9.58

    def testPPO(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.PPO(barDs.getCloseDataSeries(), 252, 2, 3, talib.MA_SMA)[2], 1.10264))
        self.assertTrue(compare(indicator.PPO(barDs.getCloseDataSeries(), 252, 2, 3, talib.MA_SMA)[3], -0.02813))
        self.assertTrue(compare(indicator.PPO(barDs.getCloseDataSeries(), 252, 2, 3, talib.MA_SMA)[-1], -0.21191))

    def testROC(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.ROC(barDs.getCloseDataSeries(), 252, 14)[14], -0.546))
        self.assertTrue(compare(indicator.ROC(barDs.getCloseDataSeries(), 252, 14)[15], -2.109))
        self.assertTrue(compare(indicator.ROC(barDs.getCloseDataSeries(), 252, 14)[16], -5.53))
        self.assertTrue(compare(indicator.ROC(barDs.getCloseDataSeries(), 252, 14)[-1], -1.0367))

    def testROCR(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.ROCR(barDs.getCloseDataSeries(), 252, 14)[14], 0.994536, 4))
        self.assertTrue(compare(indicator.ROCR(barDs.getCloseDataSeries(), 252, 14)[15], 0.978906, 4))
        self.assertTrue(compare(indicator.ROCR(barDs.getCloseDataSeries(), 252, 14)[16], 0.944689, 4))
        self.assertTrue(compare(indicator.ROCR(barDs.getCloseDataSeries(), 252, 14)[-1], 0.989633, 4))

    def testROCR100(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.ROCR100(barDs.getCloseDataSeries(), 252, 14)[14], 99.4536, 4))
        self.assertTrue(compare(indicator.ROCR100(barDs.getCloseDataSeries(), 252, 14)[15], 97.8906, 4))
        self.assertTrue(compare(indicator.ROCR100(barDs.getCloseDataSeries(), 252, 14)[16], 94.4689, 4))
        self.assertTrue(compare(indicator.ROCR100(barDs.getCloseDataSeries(), 252, 14)[-1], 98.9633, 4))

    def testRSI(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.RSI(barDs.getCloseDataSeries(), 252, 14)[14], 49.15))  # Original value 49.14
        self.assertTrue(compare(indicator.RSI(barDs.getCloseDataSeries(), 252, 14)[15], 52.33))  # Original value 52.32
        self.assertTrue(compare(indicator.RSI(barDs.getCloseDataSeries(), 252, 14)[16], 46.07))
        self.assertTrue(compare(indicator.RSI(barDs.getCloseDataSeries(), 252, 14)[-1], 49.63))

    def testSAR(self):
        barDs = self.__loadSarTestBarDs()
        self.assertTrue(compare(indicator.SAR(barDs, len(SAR_HIGH), 0.02, 0.20)[1], 50.00))
        self.assertTrue(compare(indicator.SAR(barDs, len(SAR_HIGH), 0.02, 0.20)[2], 50.047))
        self.assertTrue(compare(indicator.SAR(barDs, len(SAR_HIGH), 0.02, 0.20)[5], 50.182))
        self.assertTrue(compare(indicator.SAR(barDs, len(SAR_HIGH), 0.02, 0.20)[-2], 52.93))
        self.assertTrue(compare(indicator.SAR(barDs, len(SAR_HIGH), 0.02, 0.20)[-1], 50.00))

    def testSMA(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.SMA(barDs.getCloseDataSeries(), 252, 2)[1], 93.16))  # Original value 93.15
        self.assertTrue(compare(indicator.SMA(barDs.getCloseDataSeries(), 252, 2)[2], 94.59))
        self.assertTrue(compare(indicator.SMA(barDs.getCloseDataSeries(), 252, 2)[3], 94.73))
        self.assertTrue(compare(indicator.SMA(barDs.getCloseDataSeries(), 252, 2)[-1], 108.31))

    def testSTDDEV(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.STDDEV(barDs.getCloseDataSeries(), 252, 5.0, 1)[4], 1.2856))
        self.assertTrue(compare(indicator.STDDEV(barDs.getCloseDataSeries(), 252, 5.0, 1)[5], 0.4462))
        self.assertTrue(compare(indicator.STDDEV(barDs.getCloseDataSeries(), 252, 5.0, 1)[-1], 0.7144))
        self.assertTrue(compare(indicator.STDDEV(barDs.getCloseDataSeries(), 252, 5.0, 1.5)[4], 1.9285))
        self.assertTrue(compare(indicator.STDDEV(barDs.getCloseDataSeries(), 252, 5.0, 1.5)[5], 0.66937))
        self.assertTrue(compare(indicator.STDDEV(barDs.getCloseDataSeries(), 252, 5.0, 1.5)[-1], 1.075))

    def testSTOCH(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.STOCH(barDs, 252, 5, 3, talib.MA_SMA, 3, talib.MA_SMA)[0][8], 24.0128))
        self.assertTrue(compare(indicator.STOCH(barDs, 252, 5, 3, talib.MA_SMA, 3, talib.MA_SMA)[1][8], 36.254))
        self.assertTrue(compare(indicator.STOCH(barDs, 252, 5, 3, talib.MA_SMA, 4, talib.MA_SMA)[0][-1], 30.194))
        self.assertTrue(compare(indicator.STOCH(barDs, 252, 5, 3, talib.MA_SMA, 4, talib.MA_SMA)[1][-1], 46.641))

    def testSTOCHRSI(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.STOCHRSI(barDs.getCloseDataSeries(), 252, 14, 14, 1, talib.MA_SMA)[0][27], 94.156709))
        self.assertTrue(compare(indicator.STOCHRSI(barDs.getCloseDataSeries(), 252, 14, 14, 1, talib.MA_SMA)[1][27], 94.156709))
        self.assertTrue(compare(indicator.STOCHRSI(barDs.getCloseDataSeries(), 252, 14, 14, 1, talib.MA_SMA)[0][-1], 0))
        self.assertTrue(compare(indicator.STOCHRSI(barDs.getCloseDataSeries(), 252, 14, 14, 1, talib.MA_SMA)[1][-1], 0))

        self.assertTrue(compare(indicator.STOCHRSI(barDs.getCloseDataSeries(), 252, 14, 45, 1, talib.MA_SMA)[0][58], 79.729186))
        self.assertTrue(compare(indicator.STOCHRSI(barDs.getCloseDataSeries(), 252, 14, 45, 1, talib.MA_SMA)[1][58], 79.729186))
        self.assertTrue(compare(indicator.STOCHRSI(barDs.getCloseDataSeries(), 252, 14, 45, 1, talib.MA_SMA)[0][-1], 48.1550743))
        self.assertTrue(compare(indicator.STOCHRSI(barDs.getCloseDataSeries(), 252, 14, 45, 1, talib.MA_SMA)[1][-1], 48.1550743))

    def testT3(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.T3(barDs.getCloseDataSeries(), 252, 5, 0.7)[24],  85.73))
        self.assertTrue(compare(indicator.T3(barDs.getCloseDataSeries(), 252, 5, 0.7)[25],  84.37))
        self.assertTrue(compare(indicator.T3(barDs.getCloseDataSeries(), 252, 5, 0.7)[-2], 109.03))
        self.assertTrue(compare(indicator.T3(barDs.getCloseDataSeries(), 252, 5, 0.7)[-1], 108.88))

    def testTRANGE(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.TRANGE(barDs, 252)[1], 3.535, 3))
        self.assertTrue(compare(indicator.TRANGE(barDs, 252)[13], 9.685, 3))
        self.assertTrue(compare(indicator.TRANGE(barDs, 252)[41], 5.125, 3))
        self.assertTrue(compare(indicator.TRANGE(barDs, 252)[-1], 2.88))

    def testTRIMA(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.TRIMA(barDs.getCloseDataSeries(), 252, 10)[9], 93.6043))
        self.assertTrue(compare(indicator.TRIMA(barDs.getCloseDataSeries(), 252, 10)[10], 93.4252))
        self.assertTrue(compare(indicator.TRIMA(barDs.getCloseDataSeries(), 252, 10)[-2], 109.1850, 3))
        self.assertTrue(compare(indicator.TRIMA(barDs.getCloseDataSeries(), 252, 10)[-1], 109.1407))

    def testTRIX(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.TRIX(barDs.getCloseDataSeries(), 252, 5)[13], 0.2589))
        self.assertTrue(compare(indicator.TRIX(barDs.getCloseDataSeries(), 252, 5)[14], 0.010495))
        self.assertTrue(compare(indicator.TRIX(barDs.getCloseDataSeries(), 252, 5)[-2], -0.058))
        self.assertTrue(compare(indicator.TRIX(barDs.getCloseDataSeries(), 252, 5)[-1], -0.095))

    def testULTOSC(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.ULTOSC(barDs, 252, 7, 14, 28)[28], 47.1713))
        self.assertTrue(compare(indicator.ULTOSC(barDs, 252, 7, 14, 28)[29], 46.2802))
        self.assertTrue(compare(indicator.ULTOSC(barDs, 252, 7, 14, 28)[-1], 40.0854))

    def testVAR(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.VAR(barDs.getCloseDataSeries(), 252, 5.0, 1)[4], 1.2856**2))
        self.assertTrue(compare(indicator.VAR(barDs.getCloseDataSeries(), 252, 5.0, 1)[5], 0.4462**2))
        self.assertTrue(compare(indicator.VAR(barDs.getCloseDataSeries(), 252, 5.0, 1)[-1], 0.7144**2))

    def testWILLR(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.WILLR(barDs, 252, 14)[13], -90.1943))
        self.assertTrue(compare(indicator.WILLR(barDs, 252, 14)[13+112], 0))

    def testWMA(self):
        barDs = self.__loadBarDS()
        self.assertTrue(compare(indicator.WMA(barDs.getCloseDataSeries(), 252, 2)[1], 93.71))
        self.assertTrue(compare(indicator.WMA(barDs.getCloseDataSeries(), 252, 2)[2], 94.52))
        self.assertTrue(compare(indicator.WMA(barDs.getCloseDataSeries(), 252, 2)[3], 94.86))  # Original value 94.85
        self.assertTrue(compare(indicator.WMA(barDs.getCloseDataSeries(), 252, 2)[-1], 108.16))

########NEW FILE########
__FILENAME__ = technical_atr_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime
import common
from pyalgotrade.technical import atr
from pyalgotrade import bar
from pyalgotrade.dataseries import bards


class TestCase(unittest.TestCase):
    def testStockChartsATR(self):
        # Test data from http://stockcharts.com/help/doku.php?id=chart_school:technical_indicators:average_true_range_a
        high = [48.70, 48.72, 48.90, 48.87, 48.82, 49.05, 49.20, 49.35, 49.92, 50.19, 50.12, 49.66, 49.88, 50.19, 50.36, 50.57, 50.65, 50.43, 49.63, 50.33, 50.29, 50.17, 49.32, 48.50, 48.32, 46.80, 47.80, 48.39, 48.66, 48.79]
        low = [47.790, 48.140, 48.390, 48.370, 48.240, 48.635, 48.940, 48.860, 49.500, 49.870, 49.200, 48.900, 49.430, 49.725, 49.260, 50.090, 50.300, 49.210, 48.980, 49.610, 49.200, 49.430, 48.080, 47.640, 41.550, 44.283, 47.310, 47.200, 47.900, 47.730]
        close = [48.160, 48.610, 48.750, 48.630, 48.740, 49.030, 49.070, 49.320, 49.910, 50.130, 49.530, 49.500, 49.750, 50.030, 50.310, 50.520, 50.410, 49.340, 49.370, 50.230, 49.238, 49.930, 48.430, 48.180, 46.570, 45.410, 47.770, 47.720, 48.620, 47.850]
        expected = [None, None, None, None, None, None, None, None, None, None, None, None, None, 0.56, 0.59, 0.59, 0.57, 0.62, 0.62, 0.64, 0.67, 0.69, 0.78, 0.78, 1.21, 1.30, 1.38, 1.37, 1.34, 1.32]

        # Build a bar dataseries using the test data.
        barDataSeries = bards.BarDataSeries()
        atrDS = atr.ATR(barDataSeries, 14)
        now = datetime.datetime(2000, 1, 1)
        for i in xrange(len(high)):
            b = bar.BasicBar(now + datetime.timedelta(days=i), close[i], high[i], low[i], close[i], 100, close[i], bar.Frequency.DAY)
            barDataSeries.append(b)
            self.assertEqual(common.safe_round(atrDS[-1], 2), expected[i])

    def testStockChartsATRAdjusted(self):
        # Test data from http://stockcharts.com/help/doku.php?id=chart_school:technical_indicators:average_true_range_a
        high = [48.70, 48.72, 48.90, 48.87, 48.82, 49.05, 49.20, 49.35, 49.92, 50.19, 50.12, 49.66, 49.88, 50.19, 50.36, 50.57, 50.65, 50.43, 49.63, 50.33, 50.29, 50.17, 49.32, 48.50, 48.32, 46.80, 47.80, 48.39, 48.66, 48.79]
        low = [47.790, 48.140, 48.390, 48.370, 48.240, 48.635, 48.940, 48.860, 49.500, 49.870, 49.200, 48.900, 49.430, 49.725, 49.260, 50.090, 50.300, 49.210, 48.980, 49.610, 49.200, 49.430, 48.080, 47.640, 41.550, 44.283, 47.310, 47.200, 47.900, 47.730]
        close = [48.160, 48.610, 48.750, 48.630, 48.740, 49.030, 49.070, 49.320, 49.910, 50.130, 49.530, 49.500, 49.750, 50.030, 50.310, 50.520, 50.410, 49.340, 49.370, 50.230, 49.238, 49.930, 48.430, 48.180, 46.570, 45.410, 47.770, 47.720, 48.620, 47.850]
        expected = [None, None, None, None, None, None, None, None, None, None, None, None, None, 0.555000, 0.593929, 0.585791, 0.568949, 0.615452, 0.617920, 0.642354, 0.674329, 0.692770, 0.775429, 0.781470, 1.209229, 1.302620, 1.380290, 1.366698, 1.336219, 1.316482]

        # Build a bar dataseries using the test data.
        barDataSeries = bards.BarDataSeries()
        atrDS = atr.ATR(barDataSeries, 14, True)
        now = datetime.datetime(2000, 1, 1)
        for i in xrange(len(high)):
            b = bar.BasicBar(now + datetime.timedelta(days=i), close[i], high[i], low[i], close[i], 100, close[i]/2, bar.Frequency.DAY)
            barDataSeries.append(b)
            if expected[i] is None:
                self.assertEqual(atrDS[-1], None)
            else:
                self.assertEqual(common.safe_round(atrDS[-1], 2), round(expected[i]/2, 2))

########NEW FILE########
__FILENAME__ = technical_bollinger_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
from pyalgotrade.technical import bollinger
from pyalgotrade import dataseries


class TestCase(unittest.TestCase):
    def testStockChartsBollinger(self):
        # Test data from http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:bollinger_bands
        prices = [86.1557, 89.0867, 88.7829, 90.3228, 89.0671, 91.1453, 89.4397, 89.1750, 86.9302, 87.6752, 86.9596, 89.4299, 89.3221, 88.7241, 87.4497, 87.2634, 89.4985, 87.9006, 89.1260, 90.7043, 92.9001, 92.9784, 91.8021, 92.6647, 92.6843, 92.3021, 92.7725, 92.5373, 92.9490, 93.2039, 91.0669, 89.8318, 89.7435, 90.3994, 90.7387, 88.0177, 88.0867, 88.8439, 90.7781, 90.5416, 91.3894, 90.6500]
        expectedMiddle = [88.71, 89.05, 89.24, 89.39, 89.51, 89.69, 89.75, 89.91, 90.08, 90.38, 90.66, 90.86, 90.88, 90.91, 90.99, 91.15, 91.19, 91.12, 91.17, 91.25, 91.24, 91.17, 91.05]
        expectedUpper = [91.29, 91.95, 92.61, 92.93, 93.31, 93.73, 93.90, 94.27, 94.57, 94.79, 95.04, 94.91, 94.90, 94.90, 94.86, 94.67, 94.56, 94.68, 94.58, 94.53, 94.53, 94.37, 94.15]
        expectedLower = [86.12, 86.14, 85.87, 85.85, 85.70, 85.65, 85.59, 85.56, 85.60, 85.98, 86.27, 86.82, 86.87, 86.91, 87.12, 87.63, 87.83, 87.56, 87.76, 87.97, 87.95, 87.96, 87.95]

        seqDS = dataseries.SequenceDataSeries()
        bBands = bollinger.BollingerBands(seqDS, 20, 2)
        for value in prices:
            seqDS.append(value)

        for i in xrange(19):
            self.assertEqual(bBands.getMiddleBand()[i], None)
            self.assertEqual(bBands.getUpperBand()[i], None)
            self.assertEqual(bBands.getLowerBand()[i], None)

        for i in xrange(19, len(seqDS)):
            self.assertEqual(round(bBands.getMiddleBand()[i], 2), expectedMiddle[i-19])
            self.assertEqual(round(bBands.getUpperBand()[i], 2), expectedUpper[i-19])
            self.assertEqual(round(bBands.getLowerBand()[i], 2), expectedLower[i-19])

    def testStockChartsBollinger_Bounded(self):
        # Test data from http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:bollinger_bands
        prices = [86.1557, 89.0867, 88.7829, 90.3228, 89.0671, 91.1453, 89.4397, 89.1750, 86.9302, 87.6752, 86.9596, 89.4299, 89.3221, 88.7241, 87.4497, 87.2634, 89.4985, 87.9006, 89.1260, 90.7043, 92.9001, 92.9784, 91.8021, 92.6647, 92.6843, 92.3021, 92.7725, 92.5373, 92.9490, 93.2039, 91.0669, 89.8318, 89.7435, 90.3994, 90.7387, 88.0177, 88.0867, 88.8439, 90.7781, 90.5416, 91.3894, 90.6500]
        expectedMiddle = [91.24, 91.17, 91.05]
        expectedUpper = [94.53, 94.37, 94.15]
        expectedLower = [87.95, 87.96, 87.95]

        seqDS = dataseries.SequenceDataSeries()
        bBands = bollinger.BollingerBands(seqDS, 20, 2, 3)
        for value in prices:
            seqDS.append(value)

        for i in xrange(3):
            self.assertEqual(round(bBands.getMiddleBand()[i], 2), expectedMiddle[i])
            self.assertEqual(round(bBands.getUpperBand()[i], 2), expectedUpper[i])
            self.assertEqual(round(bBands.getLowerBand()[i], 2), expectedLower[i])

        self.assertEqual(len(bBands.getMiddleBand()), 3)
        self.assertEqual(len(bBands.getMiddleBand()[:]), 3)
        self.assertEqual(len(bBands.getMiddleBand().getDateTimes()), 3)
        self.assertEqual(len(bBands.getUpperBand()), 3)
        self.assertEqual(len(bBands.getUpperBand()[:]), 3)
        self.assertEqual(len(bBands.getUpperBand().getDateTimes()), 3)
        self.assertEqual(len(bBands.getLowerBand()), 3)
        self.assertEqual(len(bBands.getLowerBand()[:]), 3)
        self.assertEqual(len(bBands.getLowerBand().getDateTimes()), 3)

########NEW FILE########
__FILENAME__ = technical_cross_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest

from pyalgotrade.technical import cross
from pyalgotrade.technical import ma
from pyalgotrade import dataseries


class TestCase(unittest.TestCase):
    def __buildSeqDS(self, values):
        ret = dataseries.SequenceDataSeries()
        for value in values:
            ret.append(value)
        return ret

    def testCrossAboveOnce(self):
        values1 = self.__buildSeqDS([1, 1, 1, 10, 1, 1, 1])
        values2 = self.__buildSeqDS([2, 2, 2,  2, 2, 2, 2])

        # Check every 2 values.
        self.assertEqual(cross.cross_above(values1, values2, 0, 2), 0)
        self.assertEqual(cross.cross_above(values1, values2, 1, 3), 0)
        self.assertEqual(cross.cross_above(values1, values2, 2, 4), 1)
        self.assertEqual(cross.cross_above(values1, values2, 3, 5), 0)
        self.assertEqual(cross.cross_above(values1, values2, 4, 6), 0)
        self.assertEqual(cross.cross_above(values1, values2, 5, 7), 0)

        # Check every 3 values.
        self.assertEqual(cross.cross_above(values1, values2, 0, 3), 0)
        self.assertEqual(cross.cross_above(values1, values2, 1, 4), 1)
        self.assertEqual(cross.cross_above(values1, values2, 2, 5), 1)
        self.assertEqual(cross.cross_above(values1, values2, 3, 6), 0)
        self.assertEqual(cross.cross_above(values1, values2, 4, 7), 0)

        # Check for all values.
        self.assertEqual(cross.cross_above(values1, values2, 0, 7), 1)
        self.assertEqual(cross.cross_above(values1, values2, 0, -1), 1)

    def testCrossAboveMany(self):
        count = 100
        values1 = [-1 if i % 2 == 0 else 1 for i in range(count)]
        values2 = [0 for i in range(count)]

        # Check first value
        self.assertEqual(cross.cross_above(values1, values2, 0, 0), 0)

        # Check every 2 values.
        period = 2
        for i in range(1, count):
            if i % 2 == 0:
                self.assertEqual(cross.cross_above(values1, values2, i - period + 1, i + 1), 0)
            else:
                self.assertEqual(cross.cross_above(values1, values2, i - period + 1, i + 1), 1)

        # Check every 4 values.
        period = 4
        for i in range(3, count):
            if i % 2 == 0:
                self.assertEqual(cross.cross_above(values1, values2, i - period + 1, i + 1), 1)
            else:
                self.assertEqual(cross.cross_above(values1, values2, i - period + 1, i + 1), 2)

        # Check for all values.
        self.assertEqual(cross.cross_above(values1, values2, 0, count), count / 2)

    def testCrossBelowOnce(self):
        values1 = self.__buildSeqDS([2, 2, 2,  2, 2, 2, 2])
        values2 = self.__buildSeqDS([1, 1, 1, 10, 1, 1, 1])

        # Check every 2 values.
        self.assertEqual(cross.cross_below(values1, values2, 0, 2), 0)
        self.assertEqual(cross.cross_below(values1, values2, 1, 3), 0)
        self.assertEqual(cross.cross_below(values1, values2, 2, 4), 1)
        self.assertEqual(cross.cross_below(values1, values2, 3, 5), 0)
        self.assertEqual(cross.cross_below(values1, values2, 4, 6), 0)
        self.assertEqual(cross.cross_below(values1, values2, 5, 7), 0)

        # Check every 3 values.
        self.assertEqual(cross.cross_below(values1, values2, 0, 3), 0)
        self.assertEqual(cross.cross_below(values1, values2, 1, 4), 1)
        self.assertEqual(cross.cross_below(values1, values2, 2, 5), 1)
        self.assertEqual(cross.cross_below(values1, values2, 3, 6), 0)
        self.assertEqual(cross.cross_below(values1, values2, 4, 7), 0)

        # Check for all values.
        self.assertEqual(cross.cross_below(values1, values2, 0, 7), 1)
        self.assertEqual(cross.cross_below(values1, values2, 0, -1), 1)

    def testCrossBelowMany(self):
        count = 100
        values1 = [0 for i in range(count)]
        values2 = [-1 if i % 2 == 0 else 1 for i in range(count)]

        # Check first value
        self.assertEqual(cross.cross_below(values1, values2, 0, 0), 0)

        # Check every 2 values.
        period = 2
        for i in range(1, count):
            if i % 2 == 0:
                self.assertEqual(cross.cross_below(values1, values2, i - period + 1, i + 1), 0)
            else:
                self.assertEqual(cross.cross_below(values1, values2, i - period + 1, i + 1), 1)

        # Check every 4 values.
        period = 4
        for i in range(3, count):
            if i % 2 == 0:
                self.assertEqual(cross.cross_below(values1, values2, i - period + 1, i + 1), 1)
            else:
                self.assertEqual(cross.cross_below(values1, values2, i - period + 1, i + 1), 2)

        # Check for all values.
        self.assertEqual(cross.cross_below(values1, values2, 0, count), count / 2)

    def testCrossAboveWithSMA(self):
        ds1 = dataseries.SequenceDataSeries()
        ds2 = dataseries.SequenceDataSeries()
        sma1 = ma.SMA(ds1, 15)
        sma2 = ma.SMA(ds2, 25)
        for i in range(100):
            ds1.append(i)
            ds2.append(50)
            if i == 58:
                self.assertEqual(cross.cross_above(sma1[:], sma2[:], -2, None), 1)
            else:
                self.assertEqual(cross.cross_above(sma1[:], sma2[:], -2, None), 0)

########NEW FILE########
__FILENAME__ = technical_cumret_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
from pyalgotrade import dataseries
from pyalgotrade.technical import cumret


class CumRetTestCase(unittest.TestCase):
    def testCumRet(self):
        values = dataseries.SequenceDataSeries()
        rets = cumret.CumulativeReturn(values)
        for value in [1, 2, 3, 4, 4, 3, 1, 1.2]:
            values.append(value)
        self.assertEqual(rets[0], None)
        self.assertEqual(rets[1], 1)
        self.assertEqual(rets[2], 2)
        self.assertEqual(rets[3], 3)
        self.assertEqual(rets[4], 3)
        self.assertEqual(rets[5], 2)
        self.assertEqual(rets[6], 0)
        self.assertEqual(round(rets[7], 1), 0.2)

########NEW FILE########
__FILENAME__ = technical_highlow_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
from pyalgotrade import dataseries
from pyalgotrade.technical import highlow


class HighLowTestCase(unittest.TestCase):
    def testHighLow(self):
        values = dataseries.SequenceDataSeries()
        high = highlow.High(values, 5)
        low = highlow.Low(values, 3)
        for value in [1, 2, 3, 4, 5]:
            values.append(value)
        self.assertEqual(high[-1], 5)
        self.assertEqual(low[-1], 3)

########NEW FILE########
__FILENAME__ = technical_linebreak_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import common
from pyalgotrade.technical import linebreak
from pyalgotrade.barfeed import yahoofeed


class LineBreakTestCase(unittest.TestCase):
    Instrument = "orcl"

    def __getFeed(self):
        # Load the feed and process all bars.
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV(LineBreakTestCase.Instrument, common.get_data_file_path("orcl-2001-yahoofinance.csv"))
        return barFeed

    def test2LineBreak(self):
        barFeed = self.__getFeed()
        bars = barFeed[LineBreakTestCase.Instrument]
        lineBreak = linebreak.LineBreak(bars, 2)
        barFeed.loadAll()

        self.assertEqual(len(lineBreak), 77)
        self.assertEqual(bars[0].getLow(), lineBreak[0].getLow())
        self.assertEqual(bars[0].getHigh(), lineBreak[0].getHigh())
        self.assertEqual(bars[0].getClose() > bars[0].getOpen(), lineBreak[0].isWhite())
        self.assertEqual(lineBreak[76].getLow(), 13.81)
        self.assertEqual(lineBreak[76].getHigh(), 13.99)
        self.assertEqual(lineBreak[76].isWhite(), False)
        self.assertEqual(lineBreak[76].isBlack(), True)

    def test3LineBreak(self):
        barFeed = self.__getFeed()
        bars = barFeed[LineBreakTestCase.Instrument]
        lineBreak = linebreak.LineBreak(bars, 3)
        barFeed.loadAll()

        self.assertEqual(len(lineBreak), 33)
        self.assertEqual(bars[0].getLow(), lineBreak[0].getLow())
        self.assertEqual(bars[0].getHigh(), lineBreak[0].getHigh())
        self.assertEqual(bars[0].getClose() > bars[0].getOpen(), lineBreak[0].isWhite())
        self.assertEqual(lineBreak[32].getLow(), 10.76)
        self.assertEqual(lineBreak[32].getHigh(), 10.92)
        self.assertEqual(lineBreak[32].isWhite(), False)
        self.assertEqual(lineBreak[32].isBlack(), True)

    def testLineBreakBounded(self):
        barFeed = self.__getFeed()
        bars = barFeed[LineBreakTestCase.Instrument]

        # Invalid maxLen, smaller than reversalLines.
        with self.assertRaises(Exception):
            lineBreak = linebreak.LineBreak(bars, 3, maxLen=2)

        lineBreak = linebreak.LineBreak(bars, 3, maxLen=4)
        # Invalid maxLen, smaller than reversalLines.
        with self.assertRaises(Exception):
            lineBreak.setMaxLen(2)
        barFeed.loadAll()

        self.assertEqual(len(lineBreak), 4)
        self.assertEqual(len(lineBreak[:]), 4)
        self.assertEqual(len(lineBreak.getDateTimes()), 4)
        self.assertEqual(lineBreak[-1].getLow(), 10.76)
        self.assertEqual(lineBreak[-1].getHigh(), 10.92)
        self.assertEqual(lineBreak[-1].isWhite(), False)
        self.assertEqual(lineBreak[-1].isBlack(), True)

########NEW FILE########
__FILENAME__ = technical_linreg_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
from pyalgotrade.technical import linreg
from pyalgotrade import dataseries
import datetime


class LeastSquaresRegressionTestCase(unittest.TestCase):
    def testLsreg1(self):
        x = [0, 1, 2]
        y = [1, 2, 3]
        a, b = linreg.lsreg(x, y)
        self.assertEqual(round(a, 2), 1.0)
        self.assertEqual(round(b, 2), 1.0)

    def testLsreg2(self):
        x = [0, 1, 2]
        y = [4, 5, 6]
        a, b = linreg.lsreg(x, y)
        self.assertEqual(round(a, 2), 1.0)
        self.assertEqual(round(b, 2), 4.0)

    def testLsreg3(self):
        x = [1, 2, 3]
        y = [1, 2, 3]
        a, b = linreg.lsreg(x, y)
        self.assertEqual(round(a, 2), 1.0)
        self.assertEqual(round(b, 2), 0)

    def testStraightLine(self):
        seqDS = dataseries.SequenceDataSeries()
        lsReg = linreg.LeastSquaresRegression(seqDS, 3)

        nextDateTime = datetime.datetime(2012, 1, 1)
        seqDS.appendWithDateTime(nextDateTime, 1)
        self.assertEqual(lsReg[-1], None)

        nextDateTime = nextDateTime + datetime.timedelta(hours=1)
        seqDS.appendWithDateTime(nextDateTime, 2)
        self.assertEqual(lsReg[-1], None)

        # Check current value.
        nextDateTime = nextDateTime + datetime.timedelta(hours=1)
        seqDS.appendWithDateTime(nextDateTime, 3)
        self.assertEqual(round(lsReg[-1], 2), 3)

        # Check future values.
        futureDateTime = nextDateTime + datetime.timedelta(hours=1)
        self.assertEqual(round(lsReg.getValueAt(futureDateTime), 2), 4)
        futureDateTime = futureDateTime + datetime.timedelta(minutes=30)
        self.assertEqual(round(lsReg.getValueAt(futureDateTime), 2), 4.5)
        futureDateTime = futureDateTime + datetime.timedelta(minutes=30)
        self.assertEqual(round(lsReg.getValueAt(futureDateTime), 2), 5)

        # Move forward in sub-second increments.
        nextDateTime = nextDateTime + datetime.timedelta(milliseconds=50)
        seqDS.appendWithDateTime(nextDateTime, 4)
        nextDateTime = nextDateTime + datetime.timedelta(milliseconds=50)
        seqDS.appendWithDateTime(nextDateTime, 5)
        self.assertEqual(round(lsReg[-1], 2), 5)

########NEW FILE########
__FILENAME__ = technical_macd_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import common
from pyalgotrade.technical import macd
from pyalgotrade import dataseries


class MACDTestCase(unittest.TestCase):
    def testMACD(self):
        values = [16.39, 16.4999, 16.45, 16.43, 16.52, 16.51, 16.423, 16.41, 16.47, 16.45, 16.32, 16.36, 16.34, 16.59, 16.54, 16.52, 16.44, 16.47, 16.5, 16.45, 16.28, 16.07, 16.08, 16.1, 16.1, 16.09, 16.43, 16.4899, 16.59, 16.65, 16.78, 16.86, 16.86, 16.76]
        # These expected values were generated using TA-Lib
        macdValues = [None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 0.0067, 0.0106, 0.0028, -0.0342, -0.0937, -0.1214, -0.1276, -0.125, -0.1195, -0.0459, 0.0097, 0.0601, 0.0975, 0.139, 0.1713, 0.1816, 0.1598]
        signalValues = [None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 0.0036, 0.0056, 0.0048, -0.0064, -0.0313, -0.057, -0.0772, -0.0909, -0.0991, -0.0839, -0.0571, -0.0236, 0.011, 0.0475, 0.0829, 0.1111, 0.125]
        histogramValues = [None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 0.0031, 0.005, -0.002, -0.0279, -0.0624, -0.0643, -0.0504, -0.0342, -0.0205, 0.0379, 0.0668, 0.0838, 0.0865, 0.0914, 0.0884, 0.0705, 0.0348]
        ds = dataseries.SequenceDataSeries()

        macdDs = macd.MACD(ds, 5, 13, 6)
        for i, value in enumerate(values):
            ds.append(value)
            self.assertEqual(common.safe_round(macdDs[i], 4), macdValues[i])
            self.assertEqual(common.safe_round(macdDs.getSignal()[i], 4), signalValues[i])
            self.assertEqual(common.safe_round(macdDs.getHistogram()[i], 4), histogramValues[i])

########NEW FILE########
__FILENAME__ = technical_ma_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import common
from pyalgotrade.technical import ma
from pyalgotrade import dataseries
from pyalgotrade.barfeed import ninjatraderfeed
from pyalgotrade import bar


def safe_round(number, ndigits):
    ret = None
    if number is not None:
        ret = round(number, ndigits)
    return ret


class SMATestCase(unittest.TestCase):
    def __buildSMA(self, period, values, smaMaxLen=dataseries.DEFAULT_MAX_LEN):
        seqDs = dataseries.SequenceDataSeries()
        ret = ma.SMA(seqDs, period, smaMaxLen)
        for value in values:
            seqDs.append(value)
        return ret

    def testPeriod1(self):
        sma = self.__buildSMA(1, [10, 20])

        self.assertTrue(sma[0] == 10)
        self.assertTrue(sma[1] == 20)
        self.assertTrue(sma[-1] == 20)
        self.assertTrue(sma[-2] == 10)
        with self.assertRaises(IndexError):
            sma[2]

        with self.assertRaises(IndexError):
            sma[-3]

        self.assertEqual(len(sma.getDateTimes()), 2)
        for i in range(len(sma)):
            self.assertEqual(sma.getDateTimes()[i], None)

    def testPeriod2(self):
        sma = self.__buildSMA(2, [0, 1, 2])
        self.assertEqual(sma[0], None)
        self.assertEqual(sma[1], (0+1) / float(2))
        self.assertEqual(sma[2], (1+2) / float(2))
        with self.assertRaises(IndexError):
            sma[3]

        self.assertEqual(len(sma.getDateTimes()), 3)
        for i in range(len(sma)):
            self.assertEqual(sma.getDateTimes()[i], None)

    def testPeriod2_BoundedFilter(self):
        sma = self.__buildSMA(2, [0, 1, 2, 3, 4], 2)
        self.assertEqual(sma[0], (2+3) / float(2))
        self.assertEqual(sma[1], (3+4) / float(2))
        self.assertEqual(sma[1], sma[-1])
        self.assertEqual(len(sma.getDateTimes()), 2)

    def testMultipleValues(self):
        period = 5
        values = range(1, 10)
        sma = self.__buildSMA(period, values)
        for i in xrange(period-1, len(values)):
            expected = sum(values[i-(period-1):i+1]) / float(period)
            self.assertTrue(sma[i] == expected)

    def testMultipleValuesSkippingOne(self):
        # Test SMA invalidating fast sma calculation.
        period = 5
        values = range(1, 10)
        sma = self.__buildSMA(period, values)
        for i in xrange(period-1, len(values), 2):
            expected = sum(values[i-(period-1):i+1]) / float(period)
            self.assertTrue(sma[i] == expected)

    def testStockChartsSMA(self):
        # Test data from http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_averages
        common.test_from_csv(self, "sc-sma-10.csv", lambda inputDS: ma.SMA(inputDS, 10))

    def testNinjaTraderSMA(self):
        common.test_from_csv(self, "nt-sma-15.csv", lambda inputDS: ma.SMA(inputDS, 15), 3)

    def testSeqLikeOps(self):
        # ds and seq should be the same.
        seq = [1.0 for i in xrange(10)]
        ds = self.__buildSMA(1, seq)

        # Test length and every item.
        self.assertEqual(len(ds), len(seq))
        for i in xrange(len(seq)):
            self.assertEqual(ds[i], seq[i])

        # Test negative indices
        self.assertEqual(ds[-1], seq[-1])
        self.assertEqual(ds[-2], seq[-2])
        self.assertEqual(ds[-9], seq[-9])

        # Test slices
        sl = slice(0, 1, 2)
        self.assertEqual(ds[sl], seq[sl])
        sl = slice(0, 9, 2)
        self.assertEqual(ds[sl], seq[sl])
        sl = slice(0, -1, 1)
        self.assertEqual(ds[sl], seq[sl])

        for i in xrange(-100, 100):
            self.assertEqual(ds[i:], seq[i:])

        for step in xrange(1, 10):
            for i in xrange(-100, 100):
                self.assertEqual(ds[i::step], seq[i::step])

    def testEventWindow(self):
        ds = dataseries.SequenceDataSeries()
        smaEW = ma.SMAEventWindow(10)
        sma = ma.SMA(ds, 10)
        smaEW.onNewValue(None, None)  # This value should get skipped
        for i in xrange(100):
            ds.append(i)
            smaEW.onNewValue(None, i)
            self.assertEqual(sma[-1], smaEW.getValue())
            smaEW.onNewValue(None, None)  # This value should get skipped

    def testStockChartsSMA_BoundedSeq(self):
        # Test data from http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_averages
        common.test_from_csv(self, "sc-sma-10.csv", lambda inputDS: ma.SMA(inputDS, 10), maxLen=1)
        common.test_from_csv(self, "sc-sma-10.csv", lambda inputDS: ma.SMA(inputDS, 10), maxLen=2)
        common.test_from_csv(self, "sc-sma-10.csv", lambda inputDS: ma.SMA(inputDS, 10), maxLen=4)
        common.test_from_csv(self, "sc-sma-10.csv", lambda inputDS: ma.SMA(inputDS, 10), maxLen=1000)


class WMATestCase(unittest.TestCase):
    def __buildWMA(self, weights, values, seqMaxLen=dataseries.DEFAULT_MAX_LEN, wmaMaxLen=dataseries.DEFAULT_MAX_LEN):
        seqDS = dataseries.SequenceDataSeries(maxLen=seqMaxLen)
        ret = ma.WMA(seqDS, weights, wmaMaxLen)
        for value in values:
            seqDS.append(value)
        return ret

    def testPeriod1(self):
        wma = self.__buildWMA([2], [10, 20])
        self.assertTrue(wma[0] == 10)
        self.assertTrue(wma[1] == 20)

        self.assertEqual(len(wma.getDateTimes()), 2)
        for i in range(len(wma)):
            self.assertEqual(wma.getDateTimes()[i], None)

    def __testPeriod2Impl(self, maxLen):
        weights = [3, 2, 1]
        values = [1, 2, 3]

        wma = self.__buildWMA(weights, values, maxLen)
        self.assertEqual(wma[0], None)
        self.assertEqual(wma[1], None)
        self.assertEqual(wma[2], (1*3 + 2*2 + 3*1) / float(3+2+1))

        self.assertEqual(len(wma.getDateTimes()), 3)
        for i in range(len(wma)):
            self.assertEqual(wma.getDateTimes()[i], None)

    def testPeriod2_BoundedSeq(self):
        self.__testPeriod2Impl(1)
        self.__testPeriod2Impl(2)
        self.__testPeriod2Impl(100)

    def testPeriod2_BoundedFilter(self):
        weights = [3, 2, 1]
        values = [1, 2, 3]

        wma = self.__buildWMA(weights, values, wmaMaxLen=2)
        self.assertEqual(wma[0], None)
        self.assertEqual(wma[1], (1*3 + 2*2 + 3*1) / float(3+2+1))
        self.assertEqual(len(wma), 2)
        self.assertEqual(len(wma[:]), 2)
        self.assertEqual(len(wma.getDateTimes()), 2)


class EMATestCase(unittest.TestCase):
    def testStockChartsEMA(self):
        # Test data from http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_averages
        common.test_from_csv(self, "sc-ema-10.csv", lambda inputDS: ma.EMA(inputDS, 10), 3)

    def testMaxRecursion(self):
        barFeed = ninjatraderfeed.Feed(bar.Frequency.MINUTE)
        barFeed.addBarsFromCSV("any", common.get_data_file_path("nt-spy-minute-2011.csv"))
        ema = ma.EMA(barFeed["any"].getPriceDataSeries(), 10)
        # Load all the feed.
        barFeed.loadAll()

        # Check that the max recursion limit bug is not hit when generating the last value first.
        self.assertEqual(round(ema[-1], 2), 128.81)

    def testBoundedFilter(self):
        values = [22.2734, 22.1940, 22.0847, 22.1741, 22.1840, 22.1344, 22.2337, 22.4323, 22.2436, 22.2933, 22.1542, 22.3926, 22.3816, 22.6109, 23.3558, 24.0519, 23.7530, 23.8324, 23.9516, 23.6338, 23.8225, 23.8722, 23.6537, 23.1870, 23.0976, 23.3260, 22.6805, 23.0976, 22.4025, 22.1725]

        seqDS = dataseries.SequenceDataSeries()
        ema = ma.EMA(seqDS, 10, 2)
        for value in values:
            seqDS.append(value)

        self.assertEqual(round(ema[0], 5), 23.08068)
        self.assertEqual(round(ema[1], 5), 22.91556)
        self.assertEqual(len(ema), 2)
        self.assertEqual(len(ema[:]), 2)
        self.assertEqual(len(ema.getDateTimes()), 2)

########NEW FILE########
__FILENAME__ = technical_ratio_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
from pyalgotrade.technical import ratio
from pyalgotrade import dataseries


class TestCase(unittest.TestCase):
    def __buildRatio(self, values, ratioMaxLen=dataseries.DEFAULT_MAX_LEN):
        seqDS = dataseries.SequenceDataSeries()
        ret = ratio.Ratio(seqDS, ratioMaxLen)
        for value in values:
            seqDS.append(value)
        return ret

    def testSimple(self):
        ratio = self.__buildRatio([1, 2, 1])
        self.assertEqual(ratio[0], None)
        self.assertEqual(ratio[1], 1)
        self.assertEqual(ratio[2], -0.5)
        self.assertEqual(ratio[-1], -0.5)
        with self.assertRaises(IndexError):
            ratio[3]

        self.assertEqual(ratio[-2], ratio[1])
        self.assertEqual(ratio[-1], ratio[2])

        self.assertEqual(len(ratio.getDateTimes()), 3)
        for i in range(len(ratio)):
            self.assertEqual(ratio.getDateTimes()[i], None)

    def testNegativeValues(self):
        ratio = self.__buildRatio([-1, -2, -1])
        self.assertEqual(ratio[0], None)
        self.assertEqual(ratio[1], -1)
        self.assertEqual(ratio[2], 0.5)
        self.assertEqual(ratio[-1], 0.5)
        with self.assertRaises(IndexError):
            ratio[3]

        self.assertEqual(ratio[-2], ratio[1])
        self.assertEqual(ratio[-1], ratio[2])

        self.assertEqual(len(ratio.getDateTimes()), 3)
        for i in range(len(ratio)):
            self.assertEqual(ratio.getDateTimes()[i], None)

    def testBounded(self):
        ratio = self.__buildRatio([-1, -2, -1], 2)
        self.assertEqual(ratio[0], -1)
        self.assertEqual(ratio[1], 0.5)
        self.assertEqual(len(ratio), 2)

########NEW FILE########
__FILENAME__ = technical_roc_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
from pyalgotrade.technical import roc
from pyalgotrade import dataseries


class ROCTestCase(unittest.TestCase):
    def __buildROC(self, values, period, rocMaxLen=dataseries.DEFAULT_MAX_LEN):
        seqDS = dataseries.SequenceDataSeries()
        ret = roc.RateOfChange(seqDS, period, rocMaxLen)
        for value in values:
            seqDS.append(value)
        return ret

    def testPeriod12(self):
        # http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:rate_of_change
        inputValues = [11045.27, 11167.32, 11008.61, 11151.83, 10926.77, 10868.12, 10520.32, 10380.43, 10785.14, 10748.26, 10896.91, 10782.95, 10620.16, 10625.83, 10510.95, 10444.37, 10068.01, 10193.39, 10066.57, 10043.75]
        roc_ = self.__buildROC(inputValues, 12)
        outputValues = [-3.85, -4.85, -4.52, -6.34, -7.86, -6.21, -4.31, -3.24]
        for i in range(len(outputValues)):
            outputValue = roc_[12 + i] * 100
            self.assertTrue(round(outputValue, 2) == outputValues[i])

        self.assertEqual(len(roc_.getDateTimes()), len(inputValues))
        for i in range(len(roc_)):
            self.assertEqual(roc_.getDateTimes()[i], None)

    def testPeriod1(self):
        def simple_roc(value1, value2):
            return self.__buildROC([value1, value2], 1)[1]

        self.assertTrue(simple_roc(1, 2) == 1)
        self.assertTrue(simple_roc(1, 2) == simple_roc(50, 100))
        self.assertTrue(simple_roc(2, 1) == -0.5)
        self.assertTrue(simple_roc(2, 1) == simple_roc(100, 50))

    def testBounded(self):
        # http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:rate_of_change
        inputValues = [11045.27, 11167.32, 11008.61, 11151.83, 10926.77, 10868.12, 10520.32, 10380.43, 10785.14, 10748.26, 10896.91, 10782.95, 10620.16, 10625.83, 10510.95, 10444.37, 10068.01, 10193.39, 10066.57, 10043.75]
        outputValues = [-4.31, -3.24]
        roc_ = self.__buildROC(inputValues, 12, 2)
        for i in xrange(2):
            self.assertEqual(round(roc_[i], 4), round(outputValues[i] / 100, 4))

    def testZeroes(self):
        inputValues = [0, 0, 0]
        outputValues = [None, 0, 0]
        roc_ = self.__buildROC(inputValues, 1)
        for i in xrange(len(inputValues)):
            self.assertEqual(roc_[i], outputValues[i])

########NEW FILE########
__FILENAME__ = technical_rsi_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import common
from pyalgotrade.technical import rsi
from pyalgotrade import dataseries


class TestCase(unittest.TestCase):
    def testAvgGainLoss(self):
        # We divide by 2 because N samples yield N-1 averages.

        # Gain only
        avgGain, avgLoss = rsi.avg_gain_loss([1, 2, 3], 0, 3)
        self.assertTrue(avgGain == 2 / float(2))
        self.assertTrue(avgLoss == 0)

        # Loss only
        avgGain, avgLoss = rsi.avg_gain_loss([3, 2, 1], 0, 3)
        self.assertTrue(avgGain == 0)
        self.assertTrue(avgLoss == 2 / float(2))

        # Gain and Loss equal
        avgGain, avgLoss = rsi.avg_gain_loss([1, 0, 1], 0, 3)
        self.assertTrue(avgGain == 1 / float(2))
        self.assertTrue(avgLoss == 1 / float(2))

        # Gain and Loss different
        avgGain, avgLoss = rsi.avg_gain_loss([1, 3, 2], 0, 3)
        self.assertTrue(avgGain == 2 / float(2))
        self.assertTrue(avgLoss == 1 / float(2))

        # Error
        self.assertEqual(rsi.avg_gain_loss([1, 1.5, 2], 0, 1), None)
        self.assertEqual(rsi.avg_gain_loss([1, 1.5, 2], 1, 2), None)
        with self.assertRaises(IndexError):
            rsi.avg_gain_loss([1, 1.5, 2], 2, 4)

    def __buildRSI(self, values, period, rsiMaxLen=dataseries.DEFAULT_MAX_LEN):
        seqDS = dataseries.SequenceDataSeries()
        ret = rsi.RSI(seqDS, period, rsiMaxLen)
        for value in values:
            seqDS.append(value)
        return ret

    def testStockChartsRSI(self):
        # Test data from http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:relative_strength_in
        common.test_from_csv(self, "rsi-test.csv", lambda inputDS: rsi.RSI(inputDS, 14), 3)

    def testDateTimes(self):
        rsi = self.__buildRSI(range(10), 3)

        self.assertEqual(len(rsi.getDateTimes()), 10)
        for i in range(len(rsi)):
            self.assertEqual(rsi.getDateTimes()[i], None)

    def testRSIFunc(self):
        values = [44.3389, 44.0902, 44.1497, 43.6124, 44.3278, 44.8264, 45.0955, 45.4245, 45.8433, 46.0826, 45.8931, 46.0328, 45.6140, 46.2820, 46.2820]
        self.assertEqual(round(rsi.rsi(values, 14), 8), 70.53278948)
        values = [44.3389, 44.0902, 44.1497, 43.6124, 44.3278, 44.8264, 45.0955, 45.4245, 45.8433, 46.0826, 45.8931, 46.0328, 45.6140, 46.2820, 46.2820, 46.0028, 46.0328, 46.4116, 46.2222, 45.6439, 46.2122, 46.2521, 45.7137, 46.4515, 45.7835, 45.3548, 44.0288, 44.1783, 44.2181, 44.5672, 43.4205, 42.6628, 43.1314]
        self.assertEqual(round(rsi.rsi(values, 14), 8), 37.77295211)

    def testRSI_Bounded(self):
        values = [44.3389, 44.0902, 44.1497, 43.6124, 44.3278, 44.8264, 45.0955, 45.4245, 45.8433, 46.0826, 45.8931, 46.0328, 45.6140, 46.2820, 46.2820]
        rsi = self.__buildRSI(values, 14, 1)
        self.assertEqual(round(rsi[0], 8), 70.53278948)
        self.assertEqual(len(rsi), 1)
        self.assertEqual(len(rsi[:]), 1)
        self.assertEqual(len(rsi.getDateTimes()), 1)
        self.assertEqual(round(rsi[-1], 8), 70.53278948)

########NEW FILE########
__FILENAME__ = technical_stats_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
from pyalgotrade.technical import stats
from pyalgotrade import dataseries
import numpy


class TestCase(unittest.TestCase):
    def testStdDev_1(self):
        values = [1, 1, 2, 3, 5]
        seqDS = dataseries.SequenceDataSeries()
        stdDev = stats.StdDev(seqDS, 1)
        for value in values:
            seqDS.append(value)
        for i in stdDev:
            self.assertEqual(i, 0)

    def testStdDev(self):
        values = [1, 1, 2, 3, 5]
        seqDS = dataseries.SequenceDataSeries()
        stdDev = stats.StdDev(seqDS, 2)
        for value in values:
            seqDS.append(value)

        self.assertEqual(stdDev[0], None)
        self.assertEqual(stdDev[1], numpy.array([1, 1]).std())
        self.assertEqual(stdDev[2], numpy.array([1, 2]).std())
        self.assertEqual(stdDev[3], numpy.array([2, 3]).std())
        self.assertEqual(stdDev[4], numpy.array([3, 5]).std())

    def testStdDev_Bounded(self):
        values = [1, 1, 2, 3, 5]
        seqDS = dataseries.SequenceDataSeries()
        stdDev = stats.StdDev(seqDS, 2, maxLen=2)
        for value in values:
            seqDS.append(value)

        self.assertEqual(stdDev[0], numpy.array([2, 3]).std())
        self.assertEqual(stdDev[1], numpy.array([3, 5]).std())

    def testZScore(self):
        values = [1.10, 2.20, 4.00, 5.10, 6.00, 7.10, 8.20, 9.00, 10.10, 3.00, 4.10, 5.20, 7.00, 8.10, 9.20, 16.00, 17.10, 18.20, 19.30, 20.40]
        expected = [None, None, None, None, 1.283041407, 1.317884611, 1.440611043, 1.355748299, 1.4123457, -1.831763202, -0.990484842, -0.388358578, 0.449889908, 1.408195169, 1.332948099, 1.867732104, 1.334258333, 1.063608066, 0.939656572, 1.414213562]
        seqDS = dataseries.SequenceDataSeries()
        zscore = stats.ZScore(seqDS, 5)
        i = 0
        for value in values:
            seqDS.append(value)
            if i >= 4:
                self.assertEqual(round(zscore[-1], 4), round(expected[i], 4))
            i += 1

########NEW FILE########
__FILENAME__ = technical_stoch_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime
from pyalgotrade.technical import stoch
from pyalgotrade.dataseries import bards
from pyalgotrade import bar


def values_equal(v1, v2):
    if v1 is not None and v2 is not None:
        return round(v1, 3) == round(v2, 3)
    elif v1 is None and v2 is None:
        return True
    return False


class TestCase(unittest.TestCase):
    def setUp(self):
        self.__currSeconds = 0

    def __buildBar(self, openPrice, highPrice, lowPrice, closePrice):
        dateTime = datetime.datetime.now() + datetime.timedelta(seconds=self.__currSeconds)
        self.__currSeconds += 1
        return bar.BasicBar(dateTime, openPrice, highPrice, lowPrice, closePrice, closePrice*10, closePrice, bar.Frequency.DAY)

    def __fillBarDataSeries(self, barDS, closePrices, highPrices, lowPrices):
        assert(len(closePrices) == len(highPrices) == len(lowPrices))
        for i in range(len(highPrices)):
            barDS.append(self.__buildBar(closePrices[i], highPrices[i], lowPrices[i], closePrices[i]))

    def testShortPeriod(self):
        highPrices = [3, 3, 3]
        lowPrices = [1, 1, 1]
        closePrices = [2, 2, 3]

        barDS = bards.BarDataSeries()
        stochFilter = stoch.StochasticOscillator(barDS, 2, 2)
        self.__fillBarDataSeries(barDS, closePrices, highPrices, lowPrices)

        self.assertTrue(values_equal(stochFilter[0], None))
        self.assertTrue(values_equal(stochFilter[1], 50))
        self.assertTrue(values_equal(stochFilter[2], 100))

        self.assertTrue(values_equal(stochFilter.getD()[0], None))
        self.assertTrue(values_equal(stochFilter.getD()[1], None))
        self.assertTrue(values_equal(stochFilter.getD()[2], 75))

        self.assertEqual(len(stochFilter.getDateTimes()), len(closePrices))
        for i in range(len(stochFilter)):
            self.assertNotEqual(stochFilter.getDateTimes()[i], None)

    def testStockChartsStoch(self):
        # Test data from http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:stochastic_oscillato
        highPrices = [127.0090, 127.6159, 126.5911, 127.3472, 128.1730, 128.4317, 127.3671, 126.4220, 126.8995, 126.8498, 125.6460, 125.7156, 127.1582, 127.7154, 127.6855, 128.2228, 128.2725, 128.0934, 128.2725, 127.7353, 128.7700, 129.2873, 130.0633, 129.1182, 129.2873, 128.4715, 128.0934, 128.6506, 129.1381, 128.6406]
        lowPrices = [125.3574, 126.1633, 124.9296, 126.0937, 126.8199, 126.4817, 126.0340, 124.8301, 126.3921, 125.7156, 124.5615, 124.5715, 125.0689, 126.8597, 126.6309, 126.8001, 126.7105, 126.8001, 126.1335, 125.9245, 126.9891, 127.8148, 128.4715, 128.0641, 127.6059, 127.5960, 126.9990, 126.8995, 127.4865, 127.3970]
        closePrices = lowPrices[:13]  # To keep initial close prince between low/high
        closePrices.extend([127.2876, 127.1781, 128.0138, 127.1085, 127.7253, 127.0587, 127.3273, 128.7103, 127.8745, 128.5809, 128.6008, 127.9342, 128.1133, 127.5960, 127.5960, 128.6904, 128.2725])
        kValues = [None, None, None, None, None, None, None, None, None, None, None, None, None, 70.4382, 67.6089, 89.2021, 65.8106, 81.7477, 64.5238, 74.5298, 98.5814, 70.1045, 73.0561, 73.4178, 61.2313, 60.9563, 40.3861, 40.3861, 66.8285, 56.7314]
        dValues = [None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 75.7497, 74.2072, 78.9201, 70.6940, 73.6004, 79.2117, 81.0719, 80.5807, 72.1928, 69.2351, 65.2018, 54.1912, 47.2428, 49.2003, 54.6487]

        barDS = bards.BarDataSeries()
        stochFilter = stoch.StochasticOscillator(barDS, 14)
        self.__fillBarDataSeries(barDS, closePrices, highPrices, lowPrices)

        for i in range(len(kValues)):
            self.assertTrue(values_equal(stochFilter[i], kValues[i]))
            self.assertTrue(values_equal(stochFilter.getD()[i], dValues[i]))

        self.assertEqual(len(stochFilter.getDateTimes()), len(closePrices))
        for i in range(len(stochFilter)):
            self.assertNotEqual(stochFilter.getDateTimes()[i], None)

    def testStockChartsStoch_Bounded(self):
        # Test data from http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:stochastic_oscillato
        highPrices = [127.0090, 127.6159, 126.5911, 127.3472, 128.1730, 128.4317, 127.3671, 126.4220, 126.8995, 126.8498, 125.6460, 125.7156, 127.1582, 127.7154, 127.6855, 128.2228, 128.2725, 128.0934, 128.2725, 127.7353, 128.7700, 129.2873, 130.0633, 129.1182, 129.2873, 128.4715, 128.0934, 128.6506, 129.1381, 128.6406]
        lowPrices = [125.3574, 126.1633, 124.9296, 126.0937, 126.8199, 126.4817, 126.0340, 124.8301, 126.3921, 125.7156, 124.5615, 124.5715, 125.0689, 126.8597, 126.6309, 126.8001, 126.7105, 126.8001, 126.1335, 125.9245, 126.9891, 127.8148, 128.4715, 128.0641, 127.6059, 127.5960, 126.9990, 126.8995, 127.4865, 127.3970]
        closePrices = lowPrices[:13]  # To keep initial close prince between low/high
        closePrices.extend([127.2876, 127.1781, 128.0138, 127.1085, 127.7253, 127.0587, 127.3273, 128.7103, 127.8745, 128.5809, 128.6008, 127.9342, 128.1133, 127.5960, 127.5960, 128.6904, 128.2725])
        kValues = [40.3861, 66.8285, 56.7314]
        dValues = [47.2428, 49.2003, 54.6487]

        barDS = bards.BarDataSeries()
        stochFilter = stoch.StochasticOscillator(barDS, 14, maxLen=3)
        self.__fillBarDataSeries(barDS, closePrices, highPrices, lowPrices)

        self.assertEqual(len(stochFilter), 3)
        self.assertEqual(len(stochFilter[:]), 3)
        self.assertEqual(len(stochFilter.getDateTimes()), 3)
        self.assertEqual(len(stochFilter.getD()), 3)
        self.assertEqual(len(stochFilter.getD().getDateTimes()), 3)

        for i in xrange(3):
            self.assertEqual(round(stochFilter[i], 4), kValues[i])
            self.assertEqual(round(stochFilter.getD()[i], 4), dValues[i])

########NEW FILE########
__FILENAME__ = technical_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
from pyalgotrade import technical
from pyalgotrade import dataseries


class TestEventWindow(technical.EventWindow):
    def __init__(self):
        technical.EventWindow.__init__(self, 1, skipNone=False, dtype=object)

    def getValue(self):
        return self.getValues()[-1]


class TestFilter(technical.EventBasedFilter):
    def __init__(self, dataSeries):
        technical.EventBasedFilter.__init__(self, dataSeries, TestEventWindow())


class DataSeriesFilterTest(unittest.TestCase):
    def testInvalidPosNotCached(self):
        ds = dataseries.SequenceDataSeries()
        testFilter = TestFilter(ds)
        for i in range(10):
            ds.append(i)
            ds.append(None)  # Interleave Nones.

        self.assertEqual(testFilter[-1], None)
        self.assertEqual(testFilter[-2], 9)
        self.assertEqual(testFilter[-4], 8)  # We go 3 instead of 2 because we need to skip the interleaved None values.

        self.assertEqual(testFilter[18], 9)
        self.assertEqual(testFilter[19], None)
        # Absolut pos 20 should have the next value once we insert it, but right now it should be invalid.
        with self.assertRaises(IndexError):
            testFilter[20]
        ds.append(10)
        self.assertEqual(testFilter[20], 10)

########NEW FILE########
__FILENAME__ = technical_trend_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
from pyalgotrade.technical import linreg
from pyalgotrade import dataseries


class SlopeTest(unittest.TestCase):
    def __buildSlope(self, values, period, slopeMaxLen=dataseries.DEFAULT_MAX_LEN):
        seqDS = dataseries.SequenceDataSeries()
        ret = linreg.Slope(seqDS, period, slopeMaxLen)
        for value in values:
            seqDS.append(value)
        return ret

    def testSlope(self):
        slope = self.__buildSlope([1, 2, 3, 2, 1], 3)
        self.assertEqual(slope[0], None)
        self.assertEqual(slope[1], None)
        self.assertEqual(round(slope[2], 2), 1.0)
        self.assertEqual(slope[3], 0.0)
        self.assertEqual(slope[4], -1.0)

    def testSlopeBounded(self):
        slope = self.__buildSlope([1, 2, 3, 2, 1], 3, 2)
        self.assertEqual(slope[0], 0.0)
        self.assertEqual(slope[1], -1.0)


class TrendTest(unittest.TestCase):
    def __buildTrend(self, values, trendDays, positiveThreshold, negativeThreshold, trendMaxLen=dataseries.DEFAULT_MAX_LEN):
        seqDS = dataseries.SequenceDataSeries()
        ret = linreg.Trend(seqDS, trendDays, positiveThreshold, negativeThreshold, trendMaxLen)
        for value in values:
            seqDS.append(value)
        return ret

    def testTrend(self):
        trend = self.__buildTrend([1, 2, 3, 2, 1], 3, 0, 0)
        self.assertEqual(trend[0], None)
        self.assertEqual(trend[1], None)
        self.assertEqual(trend[2], True)
        self.assertEqual(trend[3], None)
        self.assertEqual(trend[4], False)

        self.assertEqual(len(trend.getDateTimes()), 5)
        for i in range(len(trend)):
            self.assertEqual(trend.getDateTimes()[i], None)

    def testTrendWithCustomThresholds(self):
        trend = self.__buildTrend([1, 2, 3, 5, -10], 3, 1, -1)
        self.assertEqual(trend[0], None)
        self.assertEqual(trend[1], None)
        self.assertEqual(trend[2], None)
        self.assertEqual(trend[3], True)
        self.assertEqual(trend[4], False)

        self.assertEqual(len(trend.getDateTimes()), 5)
        for i in range(len(trend)):
            self.assertEqual(trend.getDateTimes()[i], None)

    def testTrendWithCustomThresholds_Bounded(self):
        trend = self.__buildTrend([1, 2, 3, 5, -10], 3, 1, -1, 2)
        self.assertEqual(trend[0], True)
        self.assertEqual(trend[1], False)
        self.assertEqual(len(trend), 2)

########NEW FILE########
__FILENAME__ = technical_vwap_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import common
from pyalgotrade.technical import vwap
from pyalgotrade.barfeed import yahoofeed


class VWAPTestCase(unittest.TestCase):
    Instrument = "orcl"

    def __getFeed(self):
        # Load the feed and process all bars.
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV(VWAPTestCase.Instrument, common.get_data_file_path("orcl-2001-yahoofinance.csv"))
        return barFeed

    def testPeriod1_ClosingPrice(self):
        barFeed = self.__getFeed()
        bars = barFeed[VWAPTestCase.Instrument]
        vwap_ = vwap.VWAP(bars, 1)
        barFeed.loadAll()
        for i in xrange(len(bars)):
            self.assertEqual(round(bars[i].getClose(), 5), round(vwap_[i], 5))

    def testPeriod1_TypicalPrice(self):
        barFeed = self.__getFeed()
        bars = barFeed[VWAPTestCase.Instrument]
        vwap_ = vwap.VWAP(bars, 1, True)
        barFeed.loadAll()
        for i in xrange(len(bars)):
            self.assertEqual(round(bars[i].getTypicalPrice(), 5), round(vwap_[i], 5))

    def testPeriod2_ClosingPrice(self):
        barFeed = self.__getFeed()
        bars = barFeed[VWAPTestCase.Instrument]
        vwap_ = vwap.VWAP(bars, 2)
        barFeed.loadAll()
        self.assertEqual(vwap_[0], None)
        for i in xrange(1, len(vwap_)):
            self.assertNotEqual(vwap_[i], None)

    def testPeriod2_TypicalPrice(self):
        barFeed = self.__getFeed()
        bars = barFeed[VWAPTestCase.Instrument]
        vwap_ = vwap.VWAP(bars, 2, True)
        barFeed.loadAll()
        self.assertEqual(vwap_[0], None)
        for i in xrange(1, len(vwap_)):
            self.assertNotEqual(vwap_[i], None)

    def testPeriod50_ClosingPrice(self):
        barFeed = self.__getFeed()
        bars = barFeed[VWAPTestCase.Instrument]
        vwap_ = vwap.VWAP(bars, 50)
        barFeed.loadAll()
        for i in xrange(49):
            self.assertEqual(vwap_[i], None)
        for i in xrange(49, len(vwap_)):
            self.assertNotEqual(vwap_[i], None)

    def testPeriod50_TypicalPrice(self):
        barFeed = self.__getFeed()
        bars = barFeed[VWAPTestCase.Instrument]
        vwap_ = vwap.VWAP(bars, 50, True)
        barFeed.loadAll()
        for i in xrange(49):
            self.assertEqual(vwap_[i], None)
        for i in xrange(49, len(vwap_)):
            self.assertNotEqual(vwap_[i], None)

    def testBounded(self):
        barFeed = self.__getFeed()
        bars = barFeed[VWAPTestCase.Instrument]
        vwap_ = vwap.VWAP(bars, 50, True, 2)
        barFeed.loadAll()

        outputValues = [14.605005665747331, 14.605416923506045]
        for i in xrange(2):
            self.assertEqual(round(vwap_[i], 4), round(outputValues[i], 4))

########NEW FILE########
__FILENAME__ = trades_analyzer_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade.barfeed import ninjatraderfeed
from pyalgotrade.barfeed import csvfeed
from pyalgotrade.stratanalyzer import trades
from pyalgotrade import broker
from pyalgotrade.broker import backtesting

import strategy_test
import position_test
import common

import unittest
import datetime
import math
from distutils import version
import pytz
import numpy


def buildUTCDateTime(year, month, day, hour, minute):
    ret = datetime.datetime(year, month, day, hour, minute)
    ret = pytz.utc.localize(ret)
    return ret


class TradesAnalyzerTestCase(unittest.TestCase):
    TestInstrument = "spy"

    def __loadBarFeed(self):
        ret = ninjatraderfeed.Feed(ninjatraderfeed.Frequency.MINUTE)
        barFilter = csvfeed.USEquitiesRTH()
        ret.setBarFilter(barFilter)
        ret.addBarsFromCSV(TradesAnalyzerTestCase.TestInstrument, common.get_data_file_path("nt-spy-minute-2011.csv"))
        return ret

    def __createStrategy(self):
        barFeed = self.__loadBarFeed()
        return strategy_test.TestStrategy(barFeed, 1000)

    def __createPositionStrategy(self):
        barFeed = self.__loadBarFeed()
        return position_test.TestStrategy(barFeed, TradesAnalyzerTestCase.TestInstrument, 1000)

    def testNoTrades(self):
        strat = self.__createStrategy()
        stratAnalyzer = trades.Trades()
        strat.attachAnalyzer(stratAnalyzer)

        strat.run()

        self.assertTrue(strat.getBroker().getCash() == 1000)

        self.assertTrue(stratAnalyzer.getCount() == 0)
        self.assertTrue(stratAnalyzer.getEvenCount() == 0)
        self.assertTrue(stratAnalyzer.getProfitableCount() == 0)
        self.assertTrue(stratAnalyzer.getUnprofitableCount() == 0)

    def testSomeTrades_Position(self):
        strat = self.__createPositionStrategy()
        stratAnalyzer = trades.Trades()
        strat.attachAnalyzer(stratAnalyzer)

        # Winning trade
        strat.addPosEntry(buildUTCDateTime(2011, 1, 3, 15, 0), strat.enterLong, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.14
        strat.addPosExit(buildUTCDateTime(2011, 1, 3, 15, 16))  # 127.16
        # Losing trade
        strat.addPosEntry(buildUTCDateTime(2011, 1, 3, 15, 30), strat.enterLong, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.2
        strat.addPosExit(buildUTCDateTime(2011, 1, 3, 15, 31))  # 127.16
        # Winning trade
        strat.addPosEntry(buildUTCDateTime(2011, 1, 3, 15, 38), strat.enterLong, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.16
        strat.addPosExit(buildUTCDateTime(2011, 1, 3, 15, 42))  # 127.26
        # Unfinished trade not closed
        strat.addPosEntry(buildUTCDateTime(2011, 1, 3, 15, 47), strat.enterLong, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.34
        strat.run()

        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (127.16 - 127.14) + (127.16 - 127.2) + (127.26 - 127.16) - 127.34, 2))

        self.assertTrue(stratAnalyzer.getCount() == 3)
        self.assertTrue(stratAnalyzer.getEvenCount() == 0)
        self.assertTrue(round(stratAnalyzer.getAll().mean(), 2) == 0.03)
        self.assertTrue(round(stratAnalyzer.getAll().std(ddof=1), 2) == 0.07)
        self.assertTrue(round(stratAnalyzer.getAll().std(ddof=0), 2) == 0.06)

        self.assertTrue(stratAnalyzer.getProfitableCount() == 2)
        self.assertTrue(round(stratAnalyzer.getProfits().mean(), 2) == 0.06)
        self.assertTrue(round(stratAnalyzer.getProfits().std(ddof=1), 2) == 0.06)
        self.assertTrue(round(stratAnalyzer.getProfits().std(ddof=0), 2) == 0.04)
        self.assertEqual(stratAnalyzer.getPositiveReturns()[0], (127.16 - 127.14) / 127.14)
        self.assertEqual(stratAnalyzer.getPositiveReturns()[1], (127.26 - 127.16) / 127.16)

        self.assertTrue(stratAnalyzer.getUnprofitableCount() == 1)
        self.assertTrue(round(stratAnalyzer.getLosses().mean(), 2) == -0.04)
        if version.LooseVersion(numpy.__version__) >= version.LooseVersion("1.6.2"):
            self.assertTrue(math.isnan(stratAnalyzer.getLosses().std(ddof=1)))
        else:
            self.assertTrue(stratAnalyzer.getLosses().std(ddof=1) == 0)
        self.assertTrue(stratAnalyzer.getLosses().std(ddof=0) == 0)
        self.assertEqual(stratAnalyzer.getNegativeReturns()[0], (127.16 - 127.2) / 127.2)

    def testSomeTrades(self):
        strat = self.__createStrategy()
        stratAnalyzer = trades.Trades()
        strat.attachAnalyzer(stratAnalyzer)

        # Winning trade
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 0), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.14
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 16), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.16
        # Losing trade
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 30), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.2
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 31), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.16
        # Winning trade
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 38), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.16
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 42), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.26
        # Open trade.
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 47), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.34
        strat.run()

        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (127.16 - 127.14) + (127.16 - 127.2) + (127.26 - 127.16) - 127.34, 2))

        self.assertTrue(stratAnalyzer.getCount() == 3)
        self.assertTrue(stratAnalyzer.getEvenCount() == 0)
        self.assertTrue(round(stratAnalyzer.getAll().mean(), 2) == 0.03)
        self.assertTrue(round(stratAnalyzer.getAll().std(ddof=1), 2) == 0.07)
        self.assertTrue(round(stratAnalyzer.getAll().std(ddof=0), 2) == 0.06)

        self.assertTrue(stratAnalyzer.getProfitableCount() == 2)
        self.assertTrue(round(stratAnalyzer.getProfits().mean(), 2) == 0.06)
        self.assertTrue(round(stratAnalyzer.getProfits().std(ddof=1), 2) == 0.06)
        self.assertTrue(round(stratAnalyzer.getProfits().std(ddof=0), 2) == 0.04)

        self.assertTrue(stratAnalyzer.getUnprofitableCount() == 1)
        self.assertTrue(round(stratAnalyzer.getLosses().mean(), 2) == -0.04)
        if version.LooseVersion(numpy.__version__) >= version.LooseVersion("1.6.2"):
            self.assertTrue(math.isnan(stratAnalyzer.getLosses().std(ddof=1)))
        else:
            self.assertTrue(stratAnalyzer.getLosses().std(ddof=1) == 0)
        self.assertTrue(stratAnalyzer.getLosses().std(ddof=0) == 0)

    def testSomeTradesWithCommissions(self):
        strat = self.__createStrategy()
        strat.getBroker().setCommission(backtesting.FixedPerTrade(0.01))
        stratAnalyzer = trades.Trades()
        strat.attachAnalyzer(stratAnalyzer)

        # Losing trade
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 30), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.2
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 31), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.16
        # Winning trade
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 38), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.16
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 42), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.26
        # Open trade.
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 47), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.34
        strat.run()

        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (127.16 - 127.2) + (127.26 - 127.16) - 127.34 - 0.01*5, 2))
        self.assertTrue(numpy.array_equal(stratAnalyzer.getCommissionsForAllTrades(), numpy.array([0.02, 0.02])))
        self.assertTrue(numpy.array_equal(stratAnalyzer.getCommissionsForProfitableTrades(), numpy.array([0.02])))
        self.assertTrue(numpy.array_equal(stratAnalyzer.getCommissionsForUnprofitableTrades(), numpy.array([0.02])))
        self.assertTrue(numpy.array_equal(stratAnalyzer.getCommissionsForEvenTrades(), numpy.array([])))

    def testProportionalCommissionBug(self):
        # Regression test for a bug reported by 'Jackson Sam' on 30/Aug/2013.
        strat = self.__createStrategy()
        strat.getBroker().setCommission(backtesting.FixedPerTrade(0.01))
        stratAnalyzer = trades.Trades()
        strat.attachAnalyzer(stratAnalyzer)

        # There are 3 trades here:
        # Trade 1 (Long)
        #   Buy 1 @ 127.16 Commission: 0.01
        #   Sell 1 @ 127.26 Commission: 0.005
        # Trade 2 (Short)
        #   Sell 1 @ 127.26 Commission: 0.005
        #   Buy 1 @ 127.37 Commission: 0.005
        # Trade 3 (Long)
        #   Buy 1 @ 127.37 Commission: 0.005
        #   Sell 1 @ 127.4 Commission: 0.01

        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 38), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, TradesAnalyzerTestCase.TestInstrument, 1)  # Fill at 127.16
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 42), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, TradesAnalyzerTestCase.TestInstrument, 2)  # Fill at 127.26
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 53), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, TradesAnalyzerTestCase.TestInstrument, 2)  # Fill at 127.37
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 58), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, TradesAnalyzerTestCase.TestInstrument, 1)  # Fill at 127.4

        strat.run()
        allReturns = stratAnalyzer.getAllReturns()
        self.assertEqual(round(allReturns[0], 6), 0.000668)
        self.assertEqual(round(allReturns[1], 6), -0.000943)
        self.assertEqual(round(allReturns[2], 6), 0.000118)

    def testLongShort(self):
        strat = self.__createStrategy()
        stratAnalyzer = trades.Trades()
        strat.attachAnalyzer(stratAnalyzer)

        # Enter long
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 0), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.14
        # Exit long and enter short
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 16), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, TradesAnalyzerTestCase.TestInstrument, 2)  # 127.16
        # Exit short
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 30), strat.getBroker().createMarketOrder, broker.Order.Action.BUY_TO_COVER, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.2
        strat.run()

        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (127.16 - 127.14) + (127.16 - 127.2), 2))

        self.assertTrue(stratAnalyzer.getCount() == 2)
        self.assertTrue(stratAnalyzer.getEvenCount() == 0)

        self.assertTrue(round(stratAnalyzer.getAll().mean(), 2) == -0.01)
        self.assertTrue(round(stratAnalyzer.getAll().std(ddof=1), 4) == 0.0424)

        self.assertTrue(stratAnalyzer.getProfitableCount() == 1)
        self.assertTrue(round(stratAnalyzer.getProfits().mean(), 2) == 0.02)

        self.assertTrue(stratAnalyzer.getUnprofitableCount() == 1)
        self.assertTrue(round(stratAnalyzer.getLosses().mean(), 2) == -0.04)

    def testLongShort2(self):
        strat = self.__createStrategy()
        stratAnalyzer = trades.Trades()
        strat.attachAnalyzer(stratAnalyzer)

        # Enter long
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 0), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.14
        # Exit long
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 16), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.16
        # Enter short
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 16), strat.getBroker().createMarketOrder, broker.Order.Action.SELL_SHORT, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.16
        # Exit short
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 30), strat.getBroker().createMarketOrder, broker.Order.Action.BUY_TO_COVER, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.2
        strat.run()

        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (127.16 - 127.14) + (127.16 - 127.2), 2))

        self.assertTrue(stratAnalyzer.getCount() == 2)
        self.assertTrue(stratAnalyzer.getEvenCount() == 0)

        self.assertTrue(round(stratAnalyzer.getAll().mean(), 2) == -0.01)
        self.assertTrue(round(stratAnalyzer.getAll().std(ddof=1), 4) == 0.0424)

        self.assertTrue(stratAnalyzer.getProfitableCount() == 1)
        self.assertTrue(round(stratAnalyzer.getProfits().mean(), 2) == 0.02)

        self.assertTrue(stratAnalyzer.getUnprofitableCount() == 1)
        self.assertTrue(round(stratAnalyzer.getLosses().mean(), 2) == -0.04)

    def testShortLong(self):
        strat = self.__createStrategy()
        stratAnalyzer = trades.Trades()
        strat.attachAnalyzer(stratAnalyzer)

        # Enter short
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 0), strat.getBroker().createMarketOrder, broker.Order.Action.SELL_SHORT, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.14
        # Exit short and enter long
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 16), strat.getBroker().createMarketOrder, broker.Order.Action.BUY_TO_COVER, TradesAnalyzerTestCase.TestInstrument, 2)  # 127.16
        # Exit long
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 30), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.2
        strat.run()

        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (127.14 - 127.16) + (127.2 - 127.16), 2))

        self.assertTrue(stratAnalyzer.getCount() == 2)
        self.assertTrue(stratAnalyzer.getEvenCount() == 0)

        self.assertTrue(round(stratAnalyzer.getAll().mean(), 2) == 0.01)
        self.assertTrue(round(stratAnalyzer.getAll().std(ddof=1), 4) == 0.0424)

        self.assertTrue(stratAnalyzer.getProfitableCount() == 1)
        self.assertTrue(round(stratAnalyzer.getProfits().mean(), 2) == 0.04)

        self.assertTrue(stratAnalyzer.getUnprofitableCount() == 1)
        self.assertTrue(round(stratAnalyzer.getLosses().mean(), 2) == -0.02)

    def testShortLong2(self):
        strat = self.__createStrategy()
        stratAnalyzer = trades.Trades()
        strat.attachAnalyzer(stratAnalyzer)

        # Enter short
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 0), strat.getBroker().createMarketOrder, broker.Order.Action.SELL_SHORT, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.14
        # Exit short
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 16), strat.getBroker().createMarketOrder, broker.Order.Action.BUY_TO_COVER, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.16
        # Enter long
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 16), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.16
        # Exit long
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 30), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.2
        strat.run()

        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (127.14 - 127.16) + (127.2 - 127.16), 2))

        self.assertTrue(stratAnalyzer.getCount() == 2)
        self.assertTrue(stratAnalyzer.getEvenCount() == 0)

        self.assertTrue(round(stratAnalyzer.getAll().mean(), 2) == 0.01)
        self.assertTrue(round(stratAnalyzer.getAll().std(ddof=1), 4) == 0.0424)

        self.assertTrue(stratAnalyzer.getProfitableCount() == 1)
        self.assertTrue(round(stratAnalyzer.getProfits().mean(), 2) == 0.04)

        self.assertTrue(stratAnalyzer.getUnprofitableCount() == 1)
        self.assertTrue(round(stratAnalyzer.getLosses().mean(), 2) == -0.02)

    def testLong2(self):
        strat = self.__createStrategy()
        stratAnalyzer = trades.Trades()
        strat.attachAnalyzer(stratAnalyzer)

        # Enter long
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 0), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.14
        # Extend long position
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 16), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.16
        # Exit long
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 30), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, TradesAnalyzerTestCase.TestInstrument, 2)  # 127.2
        strat.run()

        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (127.2 - 127.14) + (127.2 - 127.16), 2))

        self.assertTrue(stratAnalyzer.getCount() == 1)
        self.assertTrue(stratAnalyzer.getEvenCount() == 0)

        self.assertTrue(round(stratAnalyzer.getAll().mean(), 2) == 0.1)

        self.assertTrue(stratAnalyzer.getProfitableCount() == 1)
        self.assertTrue(round(stratAnalyzer.getProfits().mean(), 2) == 0.1)

        self.assertTrue(stratAnalyzer.getUnprofitableCount() == 0)

    def testLong3(self):
        strat = self.__createStrategy()
        stratAnalyzer = trades.Trades()
        strat.attachAnalyzer(stratAnalyzer)

        # Enter long
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 0), strat.getBroker().createMarketOrder, broker.Order.Action.BUY, TradesAnalyzerTestCase.TestInstrument, 2)  # 127.14
        # Decrease long position
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 16), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.16
        # Exit long
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 30), strat.getBroker().createMarketOrder, broker.Order.Action.SELL, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.2
        strat.run()

        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (127.2 - 127.14) + (127.16 - 127.14), 2))

        self.assertTrue(stratAnalyzer.getCount() == 1)
        self.assertTrue(stratAnalyzer.getEvenCount() == 0)

        self.assertTrue(round(stratAnalyzer.getAll().mean(), 2) == 0.08)

        self.assertTrue(stratAnalyzer.getProfitableCount() == 1)
        self.assertTrue(round(stratAnalyzer.getProfits().mean(), 2) == 0.08)

        self.assertTrue(stratAnalyzer.getUnprofitableCount() == 0)

    def testShort2(self):
        strat = self.__createStrategy()
        stratAnalyzer = trades.Trades()
        strat.attachAnalyzer(stratAnalyzer)

        # Enter short
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 0), strat.getBroker().createMarketOrder, broker.Order.Action.SELL_SHORT, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.14
        # Extend short position
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 16), strat.getBroker().createMarketOrder, broker.Order.Action.SELL_SHORT, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.16
        # Exit short
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 30), strat.getBroker().createMarketOrder, broker.Order.Action.BUY_TO_COVER, TradesAnalyzerTestCase.TestInstrument, 2)  # 127.2
        strat.run()

        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (127.14 - 127.2) + (127.16 - 127.2), 2))

        self.assertTrue(stratAnalyzer.getCount() == 1)
        self.assertTrue(stratAnalyzer.getEvenCount() == 0)

        self.assertTrue(round(stratAnalyzer.getAll().mean(), 2) == -0.1)

        self.assertTrue(stratAnalyzer.getUnprofitableCount() == 1)
        self.assertTrue(round(stratAnalyzer.getLosses().mean(), 2) == -0.1)

        self.assertTrue(stratAnalyzer.getProfitableCount() == 0)

    def testShort3(self):
        strat = self.__createStrategy()
        stratAnalyzer = trades.Trades()
        strat.attachAnalyzer(stratAnalyzer)

        # Enter short
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 0), strat.getBroker().createMarketOrder, broker.Order.Action.SELL_SHORT, TradesAnalyzerTestCase.TestInstrument, 2)  # 127.14
        # Decrease short position
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 16), strat.getBroker().createMarketOrder, broker.Order.Action.BUY_TO_COVER, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.16
        # Exit short
        strat.addOrder(buildUTCDateTime(2011, 1, 3, 15, 30), strat.getBroker().createMarketOrder, broker.Order.Action.BUY_TO_COVER, TradesAnalyzerTestCase.TestInstrument, 1)  # 127.2
        strat.run()

        self.assertTrue(round(strat.getBroker().getCash(), 2) == round(1000 + (127.14 - 127.16) + (127.14 - 127.2), 2))

        self.assertTrue(stratAnalyzer.getCount() == 1)
        self.assertTrue(stratAnalyzer.getEvenCount() == 0)

        self.assertTrue(round(stratAnalyzer.getAll().mean(), 2) == -0.08)

        self.assertTrue(stratAnalyzer.getUnprofitableCount() == 1)
        self.assertTrue(round(stratAnalyzer.getLosses().mean(), 2) == -0.08)

        self.assertTrue(stratAnalyzer.getProfitableCount() == 0)

########NEW FILE########
__FILENAME__ = utils_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade import utils
from pyalgotrade.utils import collections
from pyalgotrade.utils import dt

import unittest
import datetime


class UtilsTestCase(unittest.TestCase):
    def testChangePercentage(self):
        self.assertEqual(utils.get_change_percentage(1, 1), 0)
        self.assertEqual(round(utils.get_change_percentage(1.1, 1), 2), 0.1)
        self.assertEqual(round(utils.get_change_percentage(2, 1), 2), 1)
        self.assertEqual(utils.get_change_percentage(1, 2), -0.5)
        self.assertEqual(utils.get_change_percentage(0, -1), 1)
        self.assertEqual(utils.get_change_percentage(1, -1), 2)
        self.assertEqual(utils.get_change_percentage(-2, -1), -1)
        self.assertEqual(utils.get_change_percentage(-1.5, -1), -0.5)

    def testSafeMin(self):
        self.assertEqual(utils.safe_min(None, 0), 0)
        self.assertEqual(utils.safe_min(0, None), 0)
        self.assertEqual(utils.safe_min(None, None), None)
        self.assertEqual(utils.safe_min(0, 0), 0)
        self.assertEqual(utils.safe_min(1, 0), 0)
        self.assertEqual(utils.safe_min(0, 1), 0)
        self.assertEqual(utils.safe_min(-1, 1), -1)
        self.assertEqual(utils.safe_min(1, -1), -1)
        self.assertEqual(utils.safe_min(-1, -2), -2)
        self.assertEqual(utils.safe_min(-2, -1), -2)


class CollectionsTestCase(unittest.TestCase):
    def testEmptyIntersection(self):
        values, ix1, ix2 = collections.intersect([1, 2, 3], [4, 5, 6])
        self.assertEqual(len(values), 0)
        self.assertEqual(len(ix1), 0)
        self.assertEqual(len(ix2), 0)

        values, ix1, ix2 = collections.intersect([], [])
        self.assertEqual(len(values), 0)
        self.assertEqual(len(ix1), 0)
        self.assertEqual(len(ix2), 0)

    def testFullIntersection(self):
        values, ix1, ix2 = collections.intersect([1, 2, 3], [1, 2, 3])
        self.assertEqual(len(values), 3)
        self.assertEqual(len(ix1), 3)
        self.assertEqual(len(ix2), 3)
        self.assertEqual(ix1, ix2)

    def testPartialIntersection1(self):
        values, ix1, ix2 = collections.intersect([0, 2, 4], [1, 2, 3])
        self.assertEqual(len(values), 1)
        self.assertEqual(values[0], 2)
        self.assertEqual(ix1[0], 1)
        self.assertEqual(ix2[0], 1)

    def testPartialIntersection2(self):
        values, ix1, ix2 = collections.intersect([1, 2, 4], [1, 2, 3])
        self.assertEqual(len(values), 2)
        self.assertEqual(values[0], 1)
        self.assertEqual(values[1], 2)
        self.assertEqual(ix1[0], 0)
        self.assertEqual(ix1[1], 1)
        self.assertEqual(ix2[0], 0)
        self.assertEqual(ix2[1], 1)

    def testPartialIntersection3(self):
        values, ix1, ix2 = collections.intersect([1, 2, 5], [1, 3, 5])
        self.assertEqual(len(values), 2)
        self.assertEqual(values[0], 1)
        self.assertEqual(values[1], 5)
        self.assertEqual(ix1[0], 0)
        self.assertEqual(ix1[1], 2)
        self.assertEqual(ix2[0], 0)
        self.assertEqual(ix2[1], 2)

    def testPartialIntersection4(self):
        values, ix1, ix2 = collections.intersect([1, 2, 3], [2, 4, 6])
        self.assertEqual(len(values), 1)
        self.assertEqual(values[0], 2)
        self.assertEqual(ix1[0], 1)
        self.assertEqual(ix2[0], 0)

    def testPartialIntersection5(self):
        values, ix1, ix2 = collections.intersect([1, 2, 3], [3, 6])
        self.assertEqual(len(values), 1)
        self.assertEqual(values[0], 3)
        self.assertEqual(ix1[0], 2)
        self.assertEqual(ix2[0], 0)

    def testPartialIntersection6(self):
        v1 = [1, 1, 2, 2, 3, 3]
        v2 = [1, 2, 3]

        values, ix1, ix2 = collections.intersect(v1, v2)
        self.assertEqual(values, [1, 2, 3])
        self.assertEqual(ix1, [0, 2, 4])
        self.assertEqual(ix2, [0, 1, 2])

        values, ix2, ix1 = collections.intersect(v2, v1)
        self.assertEqual(values, [1, 2, 3])
        self.assertEqual(ix1, [0, 2, 4])
        self.assertEqual(ix2, [0, 1, 2])

    def testPartialIntersectionIncludeNones(self):
        v1 = [None, 1, None, None, 2, None, 3, None, 4]
        v2 = [1, None, 2, None, 3, 4]

        values, ix1, ix2 = collections.intersect(v1, v2)
        self.assertEqual(values, [1, None, 2, None, 3, 4])
        self.assertEqual(ix1, [1, 2, 4, 5, 6, 8])
        self.assertEqual(ix2, [0, 1, 2, 3, 4, 5])

        values, ix2, ix1 = collections.intersect(v2, v1)
        self.assertEqual(values, [1, None, 2, None, 3, 4])
        self.assertEqual(ix1, [1, 2, 4, 5, 6, 8])
        self.assertEqual(ix2, [0, 1, 2, 3, 4, 5])

    def testPartialIntersectionSkipNones(self):
        v1 = [None, 1, None, None, 2, None, 3, None, 4]
        v2 = [1, None, 2, None, 3, 4]

        values, ix1, ix2 = collections.intersect(v1, v2, True)
        self.assertEqual(values, [1, 2, 3, 4])
        self.assertEqual(ix1, [1, 4, 6, 8])
        self.assertEqual(ix2, [0, 2, 4, 5])

        values, ix2, ix1 = collections.intersect(v2, v1, True)
        self.assertEqual(values, [1, 2, 3, 4])
        self.assertEqual(ix1, [1, 4, 6, 8])
        self.assertEqual(ix2, [0, 2, 4, 5])

    def testFullIntersectionWithDateTimes(self):
        size = 1000
        dateTimes1 = []
        dateTimes2 = []
        now = datetime.datetime.now()
        for i in xrange(size):
            dateTimes1.append(now + datetime.timedelta(seconds=i))
            dateTimes2.append(now + datetime.timedelta(seconds=i))

        self.assertEqual(dateTimes1, dateTimes2)

        values, ix1, ix2 = collections.intersect(dateTimes1, dateTimes2)
        self.assertEqual(values, dateTimes1)
        self.assertEqual(values, dateTimes2)
        self.assertEqual(ix1, range(size))
        self.assertEqual(ix1, ix2)

    def testNumPyDeque(self):
        d = collections.NumPyDeque(10)
        self.assertEqual(len(d), 0)

        for i in range(10):
            d.append(i)
        self.assertEqual(d[0], 0)
        self.assertEqual(d[9], 9)
        self.assertEqual(d[-1], 9)
        self.assertEqual(d[-2], 8)
        self.assertEqual(d[0:3].sum(), 3)

        for i in range(3):
            d.append(i)
        self.assertEqual(len(d), 10)
        self.assertEqual(d[0], 3)
        self.assertEqual(d[9], 2)
        self.assertEqual(d[-1], 2)
        self.assertEqual(d[-2], 1)

    def testNumPyDequeResize(self):
        d = collections.NumPyDeque(10)

        self.assertEqual(len(d), 0)
        for i in range(20):
            d.append(i)
        self.assertEqual(d[0], 10)
        self.assertEqual(d[9], 19)
        self.assertEqual(d[-1], 19)
        self.assertEqual(len(d), 10)

        d.resize(5)
        self.assertEqual(len(d), 5)
        self.assertEqual(d[-0], 10)
        self.assertEqual(d[4], 14)
        self.assertEqual(d[-1], 14)

        d.resize(10)
        self.assertEqual(len(d), 5)
        self.assertEqual(d[-0], 10)
        self.assertEqual(d[4], 14)
        self.assertEqual(d[-1], 14)

        d.append(15)
        self.assertEqual(len(d), 6)
        self.assertEqual(d[5], 15)
        self.assertEqual(d[-1], 15)


class DateTimeTestCase(unittest.TestCase):
    def testTimeStampConversions(self):
        dateTime = datetime.datetime(2000, 1, 1)
        self.assertEqual(dt.timestamp_to_datetime(dt.datetime_to_timestamp(dateTime), False), dateTime)

        dateTime = dt.as_utc(datetime.datetime(2000, 1, 1, 1, 1))
        self.assertEqual(dt.timestamp_to_datetime(dt.datetime_to_timestamp(dateTime), True), dateTime)

    def testTimeStampConversionsWithMicroseconds(self):
        dateTime = datetime.datetime(2000, 1, 1, 1, 1, 1, microsecond=10)
        self.assertEqual(dt.timestamp_to_datetime(dt.datetime_to_timestamp(dateTime), False), dateTime)

        dateTime = dt.as_utc(datetime.datetime(2000, 1, 1, 1, 1, 1, microsecond=10))
        self.assertEqual(dt.timestamp_to_datetime(dt.datetime_to_timestamp(dateTime), True), dateTime)

    def testGetFirstMonday(self):
        self.assertEquals(dt.get_first_monday(2010), datetime.date(2010, 1, 4))
        self.assertEquals(dt.get_first_monday(2011), datetime.date(2011, 1, 3))

    def testGetLastMonday(self):
        self.assertEquals(dt.get_last_monday(2010), datetime.date(2010, 12, 27))
        self.assertEquals(dt.get_last_monday(2011), datetime.date(2011, 12, 26))

########NEW FILE########
__FILENAME__ = xignite_tests
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from pyalgotrade.xignite import api
from pyalgotrade.xignite import barfeed
from pyalgotrade.utils import dt

import unittest
import datetime
import json


class DateTimeTestCase(unittest.TestCase):
    def testMarketTimes(self):
        # 9:30 in GMT-5
        dateTime = dt.as_utc(datetime.datetime(2013, 1, 1, 9+5, 30))
        self.assertEqual(dt.unlocalize(api.to_market_datetime(dateTime, "XNYS")), datetime.datetime(2013, 1, 1, 9, 30))
        self.assertEqual(dt.unlocalize(api.to_market_datetime(dateTime, "XASE")), datetime.datetime(2013, 1, 1, 9, 30))
        self.assertEqual(dt.unlocalize(api.to_market_datetime(dateTime, "XNAS")), datetime.datetime(2013, 1, 1, 9, 30))
        self.assertEqual(dt.unlocalize(api.to_market_datetime(dateTime, "XNYS")), datetime.datetime(2013, 1, 1, 9, 30))

        # 8:00 in GMT
        dateTime = dt.as_utc(datetime.datetime(2013, 1, 1, 8))
        self.assertEqual(dt.unlocalize(api.to_market_datetime(dateTime, "CHIX")), datetime.datetime(2013, 1, 1, 8))
        # From Apr~Oct CHIX is GMT+1
        dateTime = dt.as_utc(datetime.datetime(2013, 4, 1, 8))
        self.assertEqual(dt.unlocalize(api.to_market_datetime(dateTime, "CHIX")), datetime.datetime(2013, 4, 1, 9))

    def testBuildBar(self):
        # This is the response to http://globalrealtime.xignite.com/v3/xGlobalRealTime.json/GetBar?Identifier=RIOl.CHIX&IdentifierType=Symbol&EndTime=3/19/2014%2010:00:00&Precision=Minutes&Period=5
        response = """{
            "Outcome": "Success",
            "Message": null,
            "Identity": "Request",
            "Delay": 0.0330687,
            "Bar": {
                "StartDate": "3/19/2014",
                "StartTime": "9:55:00 AM",
                "EndDate": "3/19/2014",
                "EndTime": "10:00:00 AM",
                "UTCOffset": 0,
                "Open": 31.71,
                "High": 31.71,
                "Low": 31.68,
                "Close": 31.69,
                "Volume": 2966,
                "Trades": 19,
                "TWAP": 31.6929,
                "VWAP": 31.693
            },
            "Security": {
                "CIK": "0000863064",
                "CUSIP": null,
                "Symbol": "RIOl.CHIX",
                "ISIN": null,
                "Valoren": "402589",
                "Name": "Rio Tinto PLC",
                "Market": "CHI-X EUROPE LIMITED.",
                "MarketIdentificationCode": "CHIX",
                "MostLiquidExchange": false,
                "CategoryOrIndustry": "IndustrialMetalsAndMinerals"
            }
        }"""

        responseDict = json.loads(response)
        bar = barfeed.build_bar(responseDict["Bar"], "RIOl.CHIX", 60*5)

        self.assertEqual(bar.getOpen(), 31.71)
        self.assertEqual(bar.getHigh(), 31.71)
        self.assertEqual(bar.getLow(), 31.68)
        self.assertEqual(bar.getClose(), 31.69)
        self.assertEqual(bar.getVolume(), 2966)
        self.assertEqual(bar.getDateTime(), dt.as_utc(datetime.datetime(2014, 3, 19, 9, 55)))

########NEW FILE########
__FILENAME__ = yahoofeed_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import unittest
import datetime

import common
import barfeed_test
import feed_test

from pyalgotrade.utils import dt
from pyalgotrade.barfeed import yahoofeed
from pyalgotrade.barfeed import csvfeed
from pyalgotrade import bar
from pyalgotrade import marketsession


class BarFeedEventHandler_TestLoadOrder:
    def __init__(self, testcase, barFeed, instrument):
        self.__testcase = testcase
        self.__count = 0
        self.__prevDateTime = None
        self.__barFeed = barFeed
        self.__instrument = instrument

    def onBars(self, dateTime, bars):
        self.__count += 1
        dateTime = bars.getBar(self.__instrument).getDateTime()
        if self.__prevDateTime is not None:
            # Check that bars are loaded in order
            self.__testcase.assertTrue(self.__prevDateTime < dateTime)
            # Check that the last value in the dataseries match the current datetime.
            self.__testcase.assertTrue(self.__barFeed.getDataSeries()[-1].getDateTime() == dateTime)
            # Check that the datetime for the last value matches that last datetime in the dataseries.
            self.__testcase.assertEqual(self.__barFeed.getDataSeries()[-1].getDateTime(), self.__barFeed.getDataSeries().getDateTimes()[-1])
        self.__prevDateTime = dateTime

    def getEventCount(self):
            return self.__count


class BarFeedEventHandler_TestFilterRange:
    def __init__(self, testcase, instrument, fromDate, toDate):
        self.__testcase = testcase
        self.__count = 0
        self.__instrument = instrument
        self.__fromDate = fromDate
        self.__toDate = toDate

    def onBars(self, dateTime, bars):
        self.__count += 1

        if self.__fromDate is not None:
            self.__testcase.assertTrue(bars.getBar(self.__instrument).getDateTime() >= self.__fromDate)
        if self.__toDate is not None:
            self.__testcase.assertTrue(bars.getBar(self.__instrument).getDateTime() <= self.__toDate)

    def getEventCount(self):
            return self.__count


class FeedTestCase(unittest.TestCase):
    TestInstrument = "orcl"

    def __parseDate(self, date):
        parser = yahoofeed.RowParser(datetime.time(23, 59), bar.Frequency.DAY)
        row = {
            "Date": date,
            "Close": 0,
            "Open": 0,
            "High": 0,
            "Low": 0,
            "Volume": 0,
            "Adj Close": 0}
        return parser.parseBar(row).getDateTime()

    def testInvalidConstruction(self):
        with self.assertRaises(Exception):
            yahoofeed.Feed(maxLen=0)

    def testDefaultInstrument(self):
        barFeed = yahoofeed.Feed()
        self.assertEquals(barFeed.getDefaultInstrument(), None)
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"))
        self.assertEquals(barFeed.getDefaultInstrument(), FeedTestCase.TestInstrument)

    def testDuplicateBars(self):
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"))
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"))
        with self.assertRaisesRegexp(Exception, "Duplicate bars found for.*"):
            barFeed.loadAll()

    def testBaseBarFeed(self):
        barFeed = yahoofeed.Feed()
        barFeed.sanitizeBars(True)
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"))
        barfeed_test.check_base_barfeed(self, barFeed, True, False)

    def testInvalidFrequency(self):
        with self.assertRaisesRegexp(Exception, "Invalid frequency.*"):
            yahoofeed.Feed(frequency=bar.Frequency.MINUTE)

    def testBaseFeedInterface(self):
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"))
        feed_test.tstBaseFeedInterface(self, barFeed)

    def testParseDate_1(self):
        date = self.__parseDate("1950-01-01")
        self.assertTrue(date.day == 1)
        self.assertTrue(date.month == 1)
        self.assertTrue(date.year == 1950)

    def testParseDate_2(self):
        date = self.__parseDate("2000-01-01")
        self.assertTrue(date.day == 1)
        self.assertTrue(date.month == 1)
        self.assertTrue(date.year == 2000)

    def testDateCompare(self):
        self.assertTrue(self.__parseDate("2000-01-01") == self.__parseDate("2000-01-01"))
        self.assertTrue(self.__parseDate("2000-01-01") != self.__parseDate("2001-01-01"))
        self.assertTrue(self.__parseDate("1999-01-01") < self.__parseDate("2001-01-01"))
        self.assertTrue(self.__parseDate("2011-01-01") > self.__parseDate("2001-02-02"))

    def testCSVFeedLoadOrder(self):
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"))
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2001-yahoofinance.csv"))

        # Dispatch and handle events.
        handler = BarFeedEventHandler_TestLoadOrder(self, barFeed, FeedTestCase.TestInstrument)
        barFeed.getNewBarsEvent().subscribe(handler.onBars)
        while not barFeed.eof():
            barFeed.dispatch()
        self.assertTrue(handler.getEventCount() > 0)

    def __testFilteredRangeImpl(self, fromDate, toDate):
        barFeed = yahoofeed.Feed()
        barFeed.setBarFilter(csvfeed.DateRangeFilter(fromDate, toDate))
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"))
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2001-yahoofinance.csv"))

        # Dispatch and handle events.
        handler = BarFeedEventHandler_TestFilterRange(self, FeedTestCase.TestInstrument, fromDate, toDate)
        barFeed.getNewBarsEvent().subscribe(handler.onBars)
        while not barFeed.eof():
            barFeed.dispatch()
        self.assertTrue(handler.getEventCount() > 0)

    def testFilteredRangeFrom(self):
        # Only load bars from year 2001.
        self.__testFilteredRangeImpl(datetime.datetime(2001, 1, 1, 00, 00), None)

    def testFilteredRangeTo(self):
        # Only load bars up to year 2000.
        self.__testFilteredRangeImpl(None, datetime.datetime(2000, 12, 31, 23, 55))

    def testFilteredRangeFromTo(self):
        # Only load bars in year 2000.
        self.__testFilteredRangeImpl(datetime.datetime(2000, 1, 1, 00, 00), datetime.datetime(2000, 12, 31, 23, 55))

    def testWithoutTimezone(self):
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"))
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2001-yahoofinance.csv"))
        for dateTime, bars in barFeed:
            bar = bars.getBar(FeedTestCase.TestInstrument)
            self.assertTrue(dt.datetime_is_naive(bar.getDateTime()))

    def testWithDefaultTimezone(self):
        barFeed = yahoofeed.Feed(timezone=marketsession.USEquities.getTimezone())
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"))
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2001-yahoofinance.csv"))
        for dateTime, bars in barFeed:
            bar = bars.getBar(FeedTestCase.TestInstrument)
            self.assertFalse(dt.datetime_is_naive(bar.getDateTime()))

    def testWithPerFileTimezone(self):
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"), marketsession.USEquities.getTimezone())
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2001-yahoofinance.csv"), marketsession.USEquities.getTimezone())
        for dateTime, bars in barFeed:
            bar = bars.getBar(FeedTestCase.TestInstrument)
            self.assertFalse(dt.datetime_is_naive(bar.getDateTime()))

    def testWithIntegerTimezone(self):
        try:
            barFeed = yahoofeed.Feed(timezone=-5)
            self.assertTrue(False, "Exception expected")
        except Exception, e:
            self.assertTrue(str(e).find("timezone as an int parameter is not supported anymore") == 0)

        try:
            barFeed = yahoofeed.Feed()
            barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"), -3)
            self.assertTrue(False, "Exception expected")
        except Exception, e:
            self.assertTrue(str(e).find("timezone as an int parameter is not supported anymore") == 0)

    def testMapTypeOperations(self):
        barFeed = yahoofeed.Feed()
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"), marketsession.USEquities.getTimezone())
        for dateTime, bars in barFeed:
            self.assertTrue(FeedTestCase.TestInstrument in bars)
            self.assertFalse(FeedTestCase.TestInstrument not in bars)
            bars[FeedTestCase.TestInstrument]
            with self.assertRaises(KeyError):
                bars["pirulo"]

    def testBounded(self):
        barFeed = yahoofeed.Feed(maxLen=2)
        barFeed.addBarsFromCSV(FeedTestCase.TestInstrument, common.get_data_file_path("orcl-2000-yahoofinance.csv"), marketsession.USEquities.getTimezone())
        for dateTime, bars in barFeed:
            pass

        barDS = barFeed[FeedTestCase.TestInstrument]
        self.assertEqual(len(barDS), 2)
        self.assertEqual(len(barDS.getDateTimes()), 2)
        self.assertEqual(len(barDS.getCloseDataSeries()), 2)
        self.assertEqual(len(barDS.getCloseDataSeries().getDateTimes()), 2)
        self.assertEqual(len(barDS.getOpenDataSeries()), 2)
        self.assertEqual(len(barDS.getHighDataSeries()), 2)
        self.assertEqual(len(barDS.getLowDataSeries()), 2)
        self.assertEqual(len(barDS.getAdjCloseDataSeries()), 2)

########NEW FILE########
__FILENAME__ = yahoo_test
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import os
import unittest

from pyalgotrade.tools import yahoofinance
from pyalgotrade import bar
from pyalgotrade.barfeed import yahoofeed
import common


class ToolsTestCase(unittest.TestCase):
    def testDownloadAndParseDaily(self):
        instrument = "orcl"

        common.init_temp_path()
        path = os.path.join(common.get_temp_path(), "orcl-2010.csv")
        yahoofinance.download_daily_bars(instrument, 2010, path)
        bf = yahoofeed.Feed()
        bf.addBarsFromCSV(instrument, path)
        bf.loadAll()
        self.assertEqual(bf[instrument][-1].getOpen(), 31.22)
        self.assertEqual(bf[instrument][-1].getClose(), 31.30)

    def testDownloadAndParseWeekly(self):
        instrument = "aapl"

        common.init_temp_path()
        path = os.path.join(common.get_temp_path(), "aapl-weekly-2013.csv")
        yahoofinance.download_weekly_bars(instrument, 2013, path)
        bf = yahoofeed.Feed(frequency=bar.Frequency.WEEK)
        bf.addBarsFromCSV(instrument, path)
        bf.loadAll()
        self.assertEqual(bf[instrument][-1].getOpen(), 557.46)
        self.assertEqual(bf[instrument][-1].getHigh(), 561.28)
        self.assertEqual(bf[instrument][-1].getLow(), 540.43)
        self.assertEqual(bf[instrument][-1].getClose(), 540.98)
        self.assertTrue(bf[instrument][-1].getVolume() in (9852500, 9855900))

    def testBuildDailyFeed(self):
        with common.TmpDir() as tmpPath:
            instrument = "orcl"
            bf = yahoofinance.build_feed([instrument], 2010, 2010, storage=tmpPath)
            bf.loadAll()
            self.assertEqual(bf[instrument][-1].getOpen(), 31.22)
            self.assertEqual(bf[instrument][-1].getClose(), 31.30)

    def testBuildWeeklyFeed(self):
        with common.TmpDir() as tmpPath:
            instrument = "aapl"
            bf = yahoofinance.build_feed([instrument], 2013, 2013, storage=tmpPath, frequency=bar.Frequency.WEEK)
            bf.loadAll()
            self.assertEqual(bf[instrument][-1].getOpen(), 557.46)
            self.assertEqual(bf[instrument][-1].getHigh(), 561.28)
            self.assertEqual(bf[instrument][-1].getLow(), 540.43)
            self.assertEqual(bf[instrument][-1].getClose(), 540.98)
            self.assertTrue(bf[instrument][-1].getVolume() in (9852500, 9855900))

########NEW FILE########
__FILENAME__ = get_merval_symbols
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import sys
sys.path.append("../..")

import pyalgotrade.logger
import lxml.html
import symbolsxml

logger = pyalgotrade.logger.getLogger("get_merval_symbols")


def find_company(htmlTree, ticker):
    ret = None
    anchor = htmlTree.xpath("//td[1]/a[@href='/q/pr?s=%s']/text()" % (ticker))
    if anchor:
        ret = anchor[0]
    return ret


def find_sector(htmlTree):
    ret = None
    anchor = htmlTree.xpath("//th[1][text() = 'Sector:']/../td/a[1]/text()")
    if anchor:
        ret = anchor[0]
    return ret


def find_industry(htmlTree):
    ret = None
    anchor = htmlTree.xpath("//th[1][text() = 'Industry:']/../td/a[1]/text()")
    if anchor:
        ret = anchor[0]
    return ret


def process_symbol(writer, symbol):
    try:
        logger.info("Getting info for %s" % (symbol))
        url = "http://finance.yahoo.com/q/in?s=%s+Industry" % (symbol)
        htmlTree = lxml.html.parse(url)

        company = find_company(htmlTree, symbol)
        if not company:
            raise Exception("Company name not found")

        sector = find_sector(htmlTree)
        if not sector:
            sector = ""
            logger.warning("Sector not found")

        industry = find_industry(htmlTree)
        if not industry:
            industry = ""
            logger.warning("Industry not found")

        writer.addStock(symbol, company, sector, industry)
    except Exception, e:
        logger.error(str(e))


def main():
    try:
        writer = symbolsxml.Writer()
        for symbol in open("merval-symbols.txt", "r"):
            symbol = symbol.strip()
            process_symbol(writer, symbol)

        # Index
        writer.addIndex("^MERV", "Merval")

        logger.info("Writing merval.xml")
        writer.write("merval.xml")
    except Exception, e:
        logger.error(str(e))

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = get_nasdaq_symbols
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import sys
sys.path.append("../..")

import pyalgotrade.logger
import tempfile
import urllib2
import csv
import symbolsxml


logger = pyalgotrade.logger.getLogger("get_nasdaq_symbols")


def main():
    try:
        logger.info("Getting NASDAQ symbols from http://www.nasdaq.com/")
        url = "http://www.nasdaq.com/screening/companies-by-name.aspx?exchange=NASDAQ&render=download"
        buff = urllib2.urlopen(url).read()

        tmpFile = tempfile.NamedTemporaryFile()
        tmpFile.write(buff)
        tmpFile.flush()
        with open(tmpFile.name, 'rb') as csvfile:
            symbolsXML = symbolsxml.Writer()
            for row in csv.DictReader(csvfile):
                symbolsXML.addStock(row["Symbol"], row["Name"], row["Sector"], row["industry"])

        logger.info("Writing nasdaq.xml")
        symbolsXML.write("nasdaq.xml")
    except Exception, e:
        logger.error(str(e))

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = get_nyse_symbols
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import sys
sys.path.append("../..")

import pyalgotrade.logger
import tempfile
import urllib2
import csv
import symbolsxml


logger = pyalgotrade.logger.getLogger("get_nyse_symbols")


def main():
    try:
        logger.info("Getting NYSE symbols from http://www.nasdaq.com/")
        url = "http://www.nasdaq.com/screening/companies-by-name.aspx?exchange=NYSE&render=download"
        buff = urllib2.urlopen(url).read()

        tmpFile = tempfile.NamedTemporaryFile()
        tmpFile.write(buff)
        tmpFile.flush()
        with open(tmpFile.name, 'rb') as csvfile:
            symbolsXML = symbolsxml.Writer()
            for row in csv.DictReader(csvfile):
                symbolsXML.addStock(row["Symbol"], row["Name"], row["Sector"], row["industry"])

        logger.info("Writing nyse.xml")
        symbolsXML.write("nyse.xml")
    except Exception, e:
        logger.error(str(e))

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = get_sp500_symbols
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import sys
sys.path.append("../..")

import pyalgotrade.logger
import lxml.html
import symbolsxml

# pyalgotrade.logger.file_log = "get_sp500_symbols.log"
logger = pyalgotrade.logger.getLogger("get_sp500_symbols")

TICKER_SYMBOL_COL = 0
COMPANY_COL = 1
GICS_COL = 3
GICS_SUB_INDUSTRY_COL = 4


def get_html():
    logger.info("Getting S&P 500 Component Stocks from Wikipedia")
    ret = lxml.html.parse("http://en.wikipedia.org/wiki/List_of_S%26P_500_companies")
    return ret


def find_table(htmlTree):
    logger.info("Finding the right table")
    ret = None
    tables = htmlTree.xpath("//table[@class='wikitable sortable']")
    for table in tables:
        headers = table.xpath("tr[1]/th")
        if len(headers) > 5:
            if headers[TICKER_SYMBOL_COL].xpath("a[1]")[0].text != "Ticker symbol":
                continue
            if headers[COMPANY_COL].text != "Company":
                continue
            if headers[GICS_COL].xpath("a[1]")[0].text != "GICS":
                continue
            if headers[GICS_SUB_INDUSTRY_COL].text != "GICS Sub Industry":
                continue
            ret = table
            break
    return ret


def parse_results(table):
    ret = symbolsxml.Writer()
    logger.info("Parsing table")
    rows = table.xpath("tr")
    for row in rows[1:]:
        cols = row.xpath("td")
        tickerSymbol = cols[TICKER_SYMBOL_COL].xpath("a[1]")[0].text
        company = cols[COMPANY_COL].xpath("a[1]")[0].text
        gics = cols[GICS_COL].text
        gicsSubIndustry = cols[GICS_SUB_INDUSTRY_COL].text
        if gicsSubIndustry is None:
            gicsSubIndustry = ""

        ret.addStock(tickerSymbol, company, gics, gicsSubIndustry)
    return ret


def main():
    try:
        htmlTree = get_html()
        table = find_table(htmlTree)
        if table is None:
            raise Exception("S&P 500 Component Stocks table not found")
        symbolsXML = parse_results(table)

        logger.info("Writing sp500.xml")
        symbolsXML.write("sp500.xml")
    except Exception, e:
        logger.error(str(e))

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = symbolsxml
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

from lxml import etree


class Stock:
    def __init__(self, symbolElement):
        self.__symbolElement = symbolElement

    def getTicker(self):
        return self.__symbolElement.attrib["ticker"]

    def getCompany(self):
        return self.__symbolElement.attrib["name"]

    def getSector(self):
        return self.__symbolElement.attrib["sector"]

    def getIndustry(self):
        return self.__symbolElement.attrib["industry"]


class Index:
    def __init__(self, symbolElement):
        self.__symbolElement = symbolElement

    def getTicker(self):
        return self.__symbolElement.attrib["ticker"]

    def getName(self):
        return self.__symbolElement.attrib["name"]


class Writer:
    def __init__(self):
        self.__root = etree.Element('symbols')

    def addStock(self, ticker, company, sector, industry):
        symbolElement = etree.Element("symbol")
        symbolElement.set("ticker", ticker)
        symbolElement.set("name", company)
        symbolElement.set("type", "stock")
        if sector is None:
            sector = ""
        symbolElement.set("sector", sector)
        if industry is None:
            industry = ""
        symbolElement.set("industry", industry)
        self.__root.append(symbolElement)

    def addIndex(self, ticker, name):
        symbolElement = etree.Element("symbol")
        symbolElement.set("ticker", ticker)
        symbolElement.set("name", name)
        symbolElement.set("type", "index")
        self.__root.append(symbolElement)

    def write(self, fileName):
        etree.ElementTree(self.__root).write(fileName, xml_declaration=True, encoding="utf-8", pretty_print=True)


def parse(fileName, stockCallback, indexCallback):
    root = etree.parse(open(fileName, "r"))
    if stockCallback is not None:
        for symbol in root.xpath("//symbols/symbol[@type='stock']"):
            stockCallback(Stock(symbol))
    if indexCallback is not None:
        for symbol in root.xpath("//symbols/symbol[@type='index']"):
            indexCallback(Index(symbol))

########NEW FILE########
__FILENAME__ = analyze_gaps
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import sys
import os
import datetime

sys.path.append(os.path.join("..", "symbols"))
sys.path.append(os.path.join("..", ".."))  # For pyalgotrade

import symbolsxml
import merval_calendar
import pyalgotrade.logger

pyalgotrade.logger.file_log = "analyze_gaps.log"
logger = pyalgotrade.logger.getLogger("analyze_gaps")

from pyalgotrade.barfeed import yahoofeed


storage = "data"


class MissingDataVerifier:
    def __init__(self, barDataSeries, threshold):
        self.__barDataSeries = barDataSeries
        self.__threshold = threshold

    def isTradingDay(self, dateTime):
        raise NotImplementedError()

    def getDatesInBetween(self, prevDateTime, currentDateTime):
        assert((currentDateTime - prevDateTime).days > 1)
        ret = []
        dateTime = prevDateTime + datetime.timedelta(days=1)
        while dateTime < currentDateTime:
            # Skip weekends.
            if dateTime.weekday() not in [5, 6]:
                ret.append(dateTime.date())
            dateTime = dateTime + datetime.timedelta(days=1)
        return ret

    def __processGap(self, prevDateTime, currentDateTime):
        dates = self.getDatesInBetween(prevDateTime, currentDateTime)
        dates = filter(lambda x: not self.isTradingDay(x), dates)
        if len(dates) >= self.__threshold:
            logger.warning("%d day gap between %s and %s" % (len(dates), prevDateTime, currentDateTime))

    def run(self):
        prevDateTime = None
        for bar in self.__barDataSeries:
            currentDateTime = bar.getDateTime()
            if prevDateTime is not None:
                if (currentDateTime - prevDateTime).days > 1:
                    self.__processGap(prevDateTime, currentDateTime)
            prevDateTime = currentDateTime


def get_csv_filename(symbol, year):
    return os.path.join(storage, "%s-%d-yahoofinance.csv" % (symbol, year))


def process_symbol(symbol, fromYear, toYear, missingDataVerifierClass):
    logger.info("Processing %s from %d to %d" % (symbol, fromYear, toYear))

    filesFound = 0
    # Load the bars from the CSV files.
    feed = yahoofeed.Feed(maxLen=1000000)
    feed.sanitizeBars(True)
    for year in range(fromYear, toYear+1):
        fileName = get_csv_filename(symbol, year)
        if os.path.exists(fileName):
            filesFound += 1
            feed.addBarsFromCSV(symbol, fileName)

    if filesFound > 0:
        # Process all items.
        for dateTime, bars in feed:
            pass

        missingDataVerifier = missingDataVerifierClass(feed[symbol])
        missingDataVerifier.run()
    else:
        logger.error("No files found")


class MervalMissingDataVerifier(MissingDataVerifier):
    def __init__(self, barDataSeries):
        MissingDataVerifier.__init__(self, barDataSeries, 5)

    def isTradingDay(self, dateTime):
        return not merval_calendar.is_trading_day(dateTime)


def main():
    fromYear = 2000
    toYear = 2012

    try:
        # MERVAL config.
        symbolsFile = os.path.join("..", "symbols", "merval.xml")
        missingDataVerifierClass = MervalMissingDataVerifier

        stockCallback = lambda stock: process_symbol(stock.getTicker(), fromYear, toYear, missingDataVerifierClass)
        indexCallback = stockCallback
        symbolsxml.parse(symbolsFile, stockCallback, indexCallback)
    except Exception, e:
        logger.error(str(e))

main()

########NEW FILE########
__FILENAME__ = download_data
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

import os
import sys

sys.path.append(os.path.join("..", "symbols"))
sys.path.append(os.path.join("..", ".."))  # For pyalgotrade

import pyalgotrade.logger

pyalgotrade.logger.file_log = "download_data.log"
logger = pyalgotrade.logger.getLogger("download_data")

from pyalgotrade.tools import yahoofinance
import symbolsxml


storage = "data"


def get_csv_filename(symbol, year):
    return os.path.join(storage, "%s-%d-yahoofinance.csv" % (symbol, year))


def download_files_for_symbol(symbol, fromYear, toYear):
    if not os.path.exists(storage):
        logger.info("Creating %s directory" % (storage))
        os.mkdir(storage)

    status = ""
    for year in range(fromYear, toYear+1):
        fileName = get_csv_filename(symbol, year)
        if not os.path.exists(fileName):
            logger.info("Downloading %s %d to %s" % (symbol, year, fileName))
            try:
                yahoofinance.download_daily_bars(symbol, year, fileName)
                status += "1"
            except Exception, e:
                logger.error(str(e))
                status += "0"
        else:
            status += "1"

    if status.find("1") == -1:
        logger.fatal("No data found for %s" % (symbol))
    elif status.lstrip("0").find("0") != -1:
        logger.fatal("Some bars are missing for %s" % (symbol))


def main():
    fromYear = 2000
    toYear = 2013

    try:
        symbolsFile = os.path.join("..", "symbols", "merval.xml")
        callback = lambda stock: download_files_for_symbol(stock.getTicker(), fromYear, toYear)
        symbolsxml.parse(symbolsFile, callback, callback)
    except Exception, e:
        logger.error(str(e))

main()

########NEW FILE########
__FILENAME__ = merval_calendar
# PyAlgoTrade
#
# Copyright 2011-2014 Gabriel Martin Becedillas Ruiz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
"""

skip_dates = {}


def skip_date(year, month, day):
    skip_dates.setdefault(year, {})
    skip_dates[year].setdefault(month, [])
    skip_dates[year][month].append(day)

# Feriados inamovibles
for year in range(2000, 2014):
    skip_date(year, 1, 1)  # Anio nuevo
    skip_date(year, 5, 1)  # Dia del Trabajador
    skip_date(year, 5, 25)  # Revolucion de Mayo
    skip_date(year, 7, 9)  # Independencia
    skip_date(year, 12, 8)  # Inmaculada Concepcion de Maria
    skip_date(year, 12, 25)  # Navidad

    if year >= 2006:
        skip_date(year, 3, 24)  # Dia Nacional de la Memoria por la Verdad y la Justicia

    if year >= 2007:
        skip_date(year, 4, 2)  # Dia del Veterano y de los Caidos en la Guerra de Malvinas

# 2010
# Feriados inamovibles
skip_date(2010, 4, 2)  # Viernes Santo
skip_date(2010, 5, 24)  # Feriado nacional
skip_date(2010, 10, 27)  # Censo
# Feriados trasladables
skip_date(2010, 6, 21)  # Paso a la Inmortalidad del General Manuel Belgrano
skip_date(2010, 8, 16)  # Paso a la Inmortalidad del General Jose de San Martin
skip_date(2010, 10, 11)  # Dia del Respeto a la Diversidad Cultural
skip_date(2010, 11, 22)  # Dia de la Soberania Nacional
skip_date(2010, 4, 24)  # Dia de accion por la tolerancia y el respeto entre los pueblos

# 2011
# Feriados inamovibles
skip_date(2011, 3, 7)  # Carnaval
skip_date(2011, 3, 8)  # Carnaval
skip_date(2011, 3, 25)  # Feriado Puente Turistico
skip_date(2011, 4, 22)  # Viernes Santo
skip_date(2011, 6, 20)  # Paso a la Inmortalidad del General Manuel Belgrano
skip_date(2011, 12, 9)  # Feriado Puente Turistico
skip_date(2011, 12, 25)  # Navidad
# Feriados trasladables
skip_date(2011, 8, 22)  # Paso a la Inmortalidad del General Jose de San Martin
skip_date(2011, 10, 10)  # Dia del Respeto a la Diversidad Cultural
skip_date(2011, 11, 28)  # Dia de la Soberania Nacional
# Dias no laborables
skip_date(2011, 4, 21)  # Jueves Santo Festividad Cristiana
skip_date(2011, 4, 24)  # Dia de accion por la tolerancia y el respeto entre los pueblos

# 2012
# Feriados inamovibles
skip_date(2012, 2, 20)  # Carnaval
skip_date(2012, 2, 21)  # Carnaval
skip_date(2012, 2, 27)  # Dia del Bicentenario de la Creacion y Primera Jura de la Bandera Argentina
skip_date(2012, 4, 6)  # Viernes Santo
skip_date(2012, 4, 30)  # Feriado Puente Turistico
skip_date(2012, 6, 20)  # Paso a la Inmortalidad del General Manuel Belgrano
skip_date(2012, 9, 24)  # Bicentenario de la Batalla de Tucuman
skip_date(2012, 12, 24)  # Feriado Puente Turistico
skip_date(2012, 12, 25)  # Navidad
# Feriados trasladables
skip_date(2012, 8, 20)  # Paso a la Inmortalidad del General Jose de San Martin
skip_date(2012, 10, 8)  # Dia del Respeto a la Diversidad Cultural
skip_date(2012, 11, 26)  # Dia de la Soberania Nacional
# Dias no laborables
skip_date(2012, 4, 5)  # Jueves Santo Festividad Cristiana
skip_date(2012, 4, 24)  # Dia de accion por la tolerancia y el respeto entre los pueblos

# 2013
# Feriados inamovibles
skip_date(2013, 1, 31)  # Bicentenario de la Asamblea General Constituyente de 1813
skip_date(2013, 2, 11)  # Carnaval
skip_date(2013, 2, 12)  # Carnaval
skip_date(2013, 2, 20)  # Dia de la Batalla de Salta
skip_date(2013, 3, 29)  # Viernes Santo
skip_date(2013, 4, 1)  # Feriado Puente Turistico
skip_date(2010, 6, 20)  # Paso a la Inmortalidad del General Manuel Belgrano
skip_date(2013, 6, 21)  # Feriado Puente Turistico
# Feriados trasladables
skip_date(2013, 8, 19)  # Paso a la Inmortalidad del General Jose de San Martin
skip_date(2013, 10, 14)  # Dia del Respeto a la Diversidad Cultural
skip_date(2013, 11, 25)  # Dia de la Soberania Nacional
# Dias no laborables
skip_date(2013, 3, 28)  # Jueves Santo
skip_date(2013, 4, 24)  # Dia de accion por la tolerancia y el respeto entre los pueblos


def is_trading_day(dateTime):
    return dateTime.day not in skip_dates.get(dateTime.year, {}).get(dateTime.month, [])

########NEW FILE########
